diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/HeapHprofBinWriter.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/HeapHprofBinWriter.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/HeapHprofBinWriter.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/HeapHprofBinWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -635,25 +635,25 @@
             writeObjectID(null);  // ik.getJavaMirror().getSigners());
             writeObjectID(null);  // ik.getJavaMirror().getProtectionDomain());
             // two reserved id fields
             writeObjectID(null);
             writeObjectID(null);
-            List fields = getInstanceFields(ik);
+            List<Field> fields = getInstanceFields(ik);
             int instSize = getSizeForFields(fields);
             classDataCache.put(ik, new ClassData(instSize, fields));
             out.writeInt(instSize);
 
             // For now, ignore constant pool - HAT ignores too!
             // output number of cp entries as zero.
             out.writeShort((short) 0);
 
-            List declaredFields = ik.getImmediateFields();
-            List staticFields = new ArrayList();
-            List instanceFields = new ArrayList();
-            Iterator itr = null;
+            List<Field> declaredFields = ik.getImmediateFields();
+            List<Field> staticFields = new ArrayList<>();
+            List<Field> instanceFields = new ArrayList<>();
+            Iterator<Field> itr = null;
             for (itr = declaredFields.iterator(); itr.hasNext();) {
-                Field field = (Field) itr.next();
+                Field field = itr.next();
                 if (field.isStatic()) {
                     staticFields.add(field);
                 } else {
                     instanceFields.add(field);
                 }
@@ -953,26 +953,26 @@
         ClassData cd = (ClassData) classDataCache.get(klass);
 
         if (Assert.ASSERTS_ENABLED) {
             Assert.that(cd != null, "can not get class data for " + klass.getName().asString() + klass.getAddress());
         }
-        List fields = cd.fields;
+        List<Field> fields = cd.fields;
         int size = cd.instSize;
         out.writeInt(size);
-        for (Iterator itr = fields.iterator(); itr.hasNext();) {
-            writeField((Field) itr.next(), instance);
+        for (Iterator<Field> itr = fields.iterator(); itr.hasNext();) {
+            writeField(itr.next(), instance);
         }
     }
 
     //-- Internals only below this point
 
-    private void writeFieldDescriptors(List fields, InstanceKlass ik)
+    private void writeFieldDescriptors(List<Field> fields, InstanceKlass ik)
         throws IOException {
         // ik == null for instance fields.
         out.writeShort((short) fields.size());
-        for (Iterator itr = fields.iterator(); itr.hasNext();) {
-            Field field = (Field) itr.next();
+        for (Iterator<Field> itr = fields.iterator(); itr.hasNext();) {
+            Field field = itr.next();
             Symbol name = field.getName();
             writeSymbolID(name);
             char typeCode = (char) field.getSignature().getByteAt(0);
             int kind = signatureToHprofKind(typeCode);
             out.writeByte((byte)kind);
@@ -1067,13 +1067,13 @@
 
     private void writeClassSymbols(Klass k) throws IOException {
         writeSymbol(k.getName());
         if (k instanceof InstanceKlass) {
             InstanceKlass ik = (InstanceKlass) k;
-            List declaredFields = ik.getImmediateFields();
-            for (Iterator itr = declaredFields.iterator(); itr.hasNext();) {
-                Field field = (Field) itr.next();
+            List<Field> declaredFields = ik.getImmediateFields();
+            for (Iterator<Field> itr = declaredFields.iterator(); itr.hasNext();) {
+                Field field = itr.next();
                 writeSymbol(field.getName());
             }
         }
     }
 
@@ -1172,17 +1172,17 @@
     private long getAddressValue(Address addr) {
         return (addr == null)? 0L : dbg.getAddressValue(addr);
     }
 
     // get all declared as well as inherited (directly/indirectly) fields
-    private static List/*<Field>*/ getInstanceFields(InstanceKlass ik) {
+    private static List<Field> getInstanceFields(InstanceKlass ik) {
         InstanceKlass klass = ik;
-        List res = new ArrayList();
+        List<Field> res = new ArrayList<>();
         while (klass != null) {
-            List curFields = klass.getImmediateFields();
-            for (Iterator itr = curFields.iterator(); itr.hasNext();) {
-                Field f = (Field) itr.next();
+            List<Field> curFields = klass.getImmediateFields();
+            for (Iterator<Field> itr = curFields.iterator(); itr.hasNext();) {
+                Field f = itr.next();
                 if (! f.isStatic()) {
                     res.add(f);
                 }
             }
             klass = (InstanceKlass) klass.getSuper();
@@ -1191,14 +1191,14 @@
     }
 
     // get size in bytes (in stream) required for given fields.  Note
     // that this is not the same as object size in heap. The size in
     // heap will include size of padding/alignment bytes as well.
-    private int getSizeForFields(List fields) {
+    private int getSizeForFields(List<Field> fields) {
         int size = 0;
-        for (Iterator itr = fields.iterator(); itr.hasNext();) {
-            Field field = (Field) itr.next();
+        for (Iterator<Field> itr = fields.iterator(); itr.hasNext();) {
+            Field field = itr.next();
             char typeCode = (char) field.getSignature().getByteAt(0);
             switch (typeCode) {
             case JVM_SIGNATURE_BOOLEAN:
             case JVM_SIGNATURE_BYTE:
                 size++;
@@ -1263,15 +1263,15 @@
     private long FLOAT_SIZE;
     private long DOUBLE_SIZE;
 
     private static class ClassData {
         int instSize;
-        List fields;
+        List<Field> fields;
 
-        ClassData(int instSize, List fields) {
+        ClassData(int instSize, List<Field> fields) {
             this.instSize = instSize;
             this.fields = fields;
         }
     }
 
-    private Map classDataCache = new HashMap(); // <InstanceKlass, ClassData>
+    private Map<InstanceKlass, ClassData> classDataCache = new HashMap<>();
 }

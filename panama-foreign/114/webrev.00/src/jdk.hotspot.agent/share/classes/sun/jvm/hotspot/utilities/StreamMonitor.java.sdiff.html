<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/StreamMonitor.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RobustOopDeterminator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SystemDictionaryHelper.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/StreamMonitor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.utilities;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 
 30 /** Reads all of the data from the given InputStream, and allows the
 31     caller to wait for a given string to come in or watch for many
 32     possible strings. */
 33 
 34 public class StreamMonitor implements Runnable {
 35   private BufferedReader input;
 36   private boolean printStreamContents;
 37 
 38   private String  waitString;
 39   private boolean waitStringSeen;
<span class="line-modified"> 40   private List    triggers = new LinkedList();</span>
<span class="line-modified"> 41   private List    triggersSeen = new LinkedList();</span>
 42 
 43   private String  prefixString;
 44   private boolean printContents;
 45 
 46   private StringBuffer captureBuffer;
 47 
 48   class Trigger {
 49     private String[] triggerStrings;
 50     private int      triggerVal;
 51 
 52     Trigger(String str, int val) {
 53       triggerStrings = new String[] { str };
 54       triggerVal     = val;
 55     }
 56 
 57     // Hack because we don&#39;t have a regexp library yet.
 58     // This requires all strings to be matched.
 59     Trigger(String[] strs, int val) {
 60       triggerStrings = strs;
 61       triggerVal     = val;
</pre>
<hr />
<pre>
128     return removeTrigger(new String[] { str });
129   }
130 
131   /** Removes a previously added trigger. Returns true if it was
132       present, false if not. */
133   public boolean removeTrigger(String[] strs) {
134     for (ListIterator iter = triggers.listIterator(); iter.hasNext(); ) {
135       Trigger trigger = (Trigger) iter.next();
136       if (trigger.equals(strs)) {
137         iter.remove();
138         return true;
139       }
140     }
141     return false;
142   }
143 
144   /** Returns an List of java.lang.Integer objects indicating the
145       values of the triggers seen since the last call to
146       getTriggersSeen. If there were no triggers seen, returns an
147       empty list; does not return null. */
<span class="line-modified">148   public synchronized List getTriggersSeen() {</span>
<span class="line-modified">149     List tmpList = triggersSeen;</span>
<span class="line-modified">150     triggersSeen = new LinkedList();</span>
151     return tmpList;
152   }
153 
154   /** Waits for the specified string to come in for the given period
155       of time (measured in milliseconds). */
156   public synchronized boolean waitFor(String str, long millis) {
157     waitString = str;
158     waitStringSeen = false;
159     try {
160       wait(millis);
161     }
162     catch (InterruptedException e) {
163     }
164 
165     waitString = null;
166     return waitStringSeen;
167   }
168 
169   public synchronized void startCapture() {
170     captureBuffer = new StringBuffer();
</pre>
<hr />
<pre>
190             System.err.println(prefixString + &quot;: &quot; + str);
191           }
192           synchronized (this) {
193 
194             if (captureBuffer != null) {
195               captureBuffer.append(str);
196               captureBuffer.append(&quot;\n&quot;);
197             }
198 
199             // Check wait string
200             if ((waitString != null) &amp;&amp;
201                 (str.indexOf(waitString) != -1)) {
202               waitStringSeen = true;
203               notifyAll();
204             }
205 
206             // Check all triggers
207             for (Iterator iter = triggers.iterator(); iter.hasNext(); ) {
208               Trigger trigger = (Trigger) iter.next();
209               if (trigger.matches(str)) {
<span class="line-modified">210                 triggersSeen.add(new Integer(trigger.triggerVal));</span>
211               }
212             }
213           }
214         }
215       } while (shouldContinue);
216     }
217     catch (IOException e) {
218     }
219 
220     System.err.print(&quot;StreamMonitor &quot;);
221     if (prefixString != null) {
222       System.err.print(&quot;\&quot;&quot; + prefixString + &quot;\&quot; &quot;);
223     }
224     System.err.println(&quot;exiting&quot;);
225   }
226 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.utilities;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 
 30 /** Reads all of the data from the given InputStream, and allows the
 31     caller to wait for a given string to come in or watch for many
 32     possible strings. */
 33 
 34 public class StreamMonitor implements Runnable {
 35   private BufferedReader input;
 36   private boolean printStreamContents;
 37 
 38   private String  waitString;
 39   private boolean waitStringSeen;
<span class="line-modified"> 40   private List&lt;Trigger&gt; triggers = new LinkedList&lt;&gt;();</span>
<span class="line-modified"> 41   private List&lt;Integer&gt; triggersSeen = new LinkedList&lt;&gt;();</span>
 42 
 43   private String  prefixString;
 44   private boolean printContents;
 45 
 46   private StringBuffer captureBuffer;
 47 
 48   class Trigger {
 49     private String[] triggerStrings;
 50     private int      triggerVal;
 51 
 52     Trigger(String str, int val) {
 53       triggerStrings = new String[] { str };
 54       triggerVal     = val;
 55     }
 56 
 57     // Hack because we don&#39;t have a regexp library yet.
 58     // This requires all strings to be matched.
 59     Trigger(String[] strs, int val) {
 60       triggerStrings = strs;
 61       triggerVal     = val;
</pre>
<hr />
<pre>
128     return removeTrigger(new String[] { str });
129   }
130 
131   /** Removes a previously added trigger. Returns true if it was
132       present, false if not. */
133   public boolean removeTrigger(String[] strs) {
134     for (ListIterator iter = triggers.listIterator(); iter.hasNext(); ) {
135       Trigger trigger = (Trigger) iter.next();
136       if (trigger.equals(strs)) {
137         iter.remove();
138         return true;
139       }
140     }
141     return false;
142   }
143 
144   /** Returns an List of java.lang.Integer objects indicating the
145       values of the triggers seen since the last call to
146       getTriggersSeen. If there were no triggers seen, returns an
147       empty list; does not return null. */
<span class="line-modified">148   public synchronized List&lt;Integer&gt; getTriggersSeen() {</span>
<span class="line-modified">149     List&lt;Integer&gt; tmpList = triggersSeen;</span>
<span class="line-modified">150     triggersSeen = new LinkedList&lt;&gt;();</span>
151     return tmpList;
152   }
153 
154   /** Waits for the specified string to come in for the given period
155       of time (measured in milliseconds). */
156   public synchronized boolean waitFor(String str, long millis) {
157     waitString = str;
158     waitStringSeen = false;
159     try {
160       wait(millis);
161     }
162     catch (InterruptedException e) {
163     }
164 
165     waitString = null;
166     return waitStringSeen;
167   }
168 
169   public synchronized void startCapture() {
170     captureBuffer = new StringBuffer();
</pre>
<hr />
<pre>
190             System.err.println(prefixString + &quot;: &quot; + str);
191           }
192           synchronized (this) {
193 
194             if (captureBuffer != null) {
195               captureBuffer.append(str);
196               captureBuffer.append(&quot;\n&quot;);
197             }
198 
199             // Check wait string
200             if ((waitString != null) &amp;&amp;
201                 (str.indexOf(waitString) != -1)) {
202               waitStringSeen = true;
203               notifyAll();
204             }
205 
206             // Check all triggers
207             for (Iterator iter = triggers.iterator(); iter.hasNext(); ) {
208               Trigger trigger = (Trigger) iter.next();
209               if (trigger.matches(str)) {
<span class="line-modified">210                 triggersSeen.add(trigger.triggerVal);</span>
211               }
212             }
213           }
214         }
215       } while (shouldContinue);
216     }
217     catch (IOException e) {
218     }
219 
220     System.err.print(&quot;StreamMonitor &quot;);
221     if (prefixString != null) {
222       System.err.print(&quot;\&quot;&quot; + prefixString + &quot;\&quot; &quot;);
223     }
224     System.err.println(&quot;exiting&quot;);
225   }
226 }
</pre>
</td>
</tr>
</table>
<center><a href="RobustOopDeterminator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SystemDictionaryHelper.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/cdbg/basic/BasicCDebugInfoDataBase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BasicBlockSym.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BasicCompoundType.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/cdbg/basic/BasicCDebugInfoDataBase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 41,31 ***</span>
    ///////////
    // Types //
    ///////////
  
    // Used only during construction
<span class="line-modified">!   private Map lazyTypeMap;</span>
  
    // Used during construction and at run time for iteration
<span class="line-modified">!   private List types;</span>
  
    // Used only during runtime
<span class="line-modified">!   private Map nameToTypeMap;</span>
  
    /////////////
    // Symbols //
    /////////////
  
    // Used only during construction
<span class="line-modified">!   private Map lazySymMap;</span>
  
    // List of blocks in increasing order by starting address. These can
    // then be binary searched.
<span class="line-modified">!   private List blocks;</span>
  
    // Name-to-global symbol table
<span class="line-modified">!   private Map nameToSymMap;</span>
  
    //////////////////
    // Line numbers //
    //////////////////
  
<span class="line-new-header">--- 41,31 ---</span>
    ///////////
    // Types //
    ///////////
  
    // Used only during construction
<span class="line-modified">!   private Map&lt;Object, Type&gt; lazyTypeMap;</span>
  
    // Used during construction and at run time for iteration
<span class="line-modified">!   private List&lt;Type&gt; types;</span>
  
    // Used only during runtime
<span class="line-modified">!   private Map&lt;String, Type&gt; nameToTypeMap;</span>
  
    /////////////
    // Symbols //
    /////////////
  
    // Used only during construction
<span class="line-modified">!   private Map&lt;Object, BlockSym&gt; lazySymMap;</span>
  
    // List of blocks in increasing order by starting address. These can
    // then be binary searched.
<span class="line-modified">!   private List&lt;BlockSym&gt; blocks;</span>
  
    // Name-to-global symbol table
<span class="line-modified">!   private Map&lt;String, GlobalSym&gt; nameToSymMap;</span>
  
    //////////////////
    // Line numbers //
    //////////////////
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 83,17 ***</span>
        Assert.that(state == INITIALIZED_STATE, &quot;wrong state&quot;);
      }
      state   = CONSTRUCTION_STATE;
  
      // Types
<span class="line-modified">!     lazyTypeMap  = new HashMap();</span>
<span class="line-modified">!     types        = new ArrayList();</span>
  
      // Symbols
<span class="line-modified">!     lazySymMap   = new HashMap();</span>
<span class="line-modified">!     blocks       = new ArrayList();</span>
<span class="line-modified">!     nameToSymMap = new HashMap();</span>
  
      // Line numbers
      lineNumbers  = new BasicLineNumberMapping();
    }
  
<span class="line-new-header">--- 83,17 ---</span>
        Assert.that(state == INITIALIZED_STATE, &quot;wrong state&quot;);
      }
      state   = CONSTRUCTION_STATE;
  
      // Types
<span class="line-modified">!     lazyTypeMap  = new HashMap&lt;&gt;();</span>
<span class="line-modified">!     types        = new ArrayList&lt;&gt;();</span>
  
      // Symbols
<span class="line-modified">!     lazySymMap   = new HashMap&lt;&gt;();</span>
<span class="line-modified">!     blocks       = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!     nameToSymMap = new HashMap&lt;&gt;();</span>
  
      // Line numbers
      lineNumbers  = new BasicLineNumberMapping();
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,11 ***</span>
        Assert.that(state == CONSTRUCTION_STATE, &quot;wrong state&quot;);
      }
      // Go through all types in lazyTypeMap and types.
      // Resolve all LazyTypes.
      resolveLazyMap(listener);
<span class="line-modified">!     for (ListIterator iter = types.listIterator(); iter.hasNext(); ) {</span>
        BasicType t = (BasicType) iter.next();
        BasicType t2 = (BasicType) t.resolveTypes(this, listener);
        if (t != t2) {
          iter.set(t2);
        }
<span class="line-new-header">--- 117,11 ---</span>
        Assert.that(state == CONSTRUCTION_STATE, &quot;wrong state&quot;);
      }
      // Go through all types in lazyTypeMap and types.
      // Resolve all LazyTypes.
      resolveLazyMap(listener);
<span class="line-modified">!     for (ListIterator&lt;Type&gt; iter = types.listIterator(); iter.hasNext(); ) {</span>
        BasicType t = (BasicType) iter.next();
        BasicType t2 = (BasicType) t.resolveTypes(this, listener);
        if (t != t2) {
          iter.set(t2);
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,14 ***</span>
        ((BasicSym) iter.next()).resolve(this, listener);
      }
  
      // Sort blocks in ascending order of starting address (but do not
      // change ordering among blocks with the same starting address)
<span class="line-modified">!     Collections.sort(blocks, new Comparator() {</span>
<span class="line-modified">!         public int compare(Object o1, Object o2) {</span>
<span class="line-removed">-           BlockSym b1 = (BlockSym) o1;</span>
<span class="line-removed">-           BlockSym b2 = (BlockSym) o2;</span>
            Address a1 = b1.getAddress();
            Address a2 = b2.getAddress();
            if (AddressOps.lt(a1, a2)) { return -1; }
            if (AddressOps.gt(a1, a2)) { return 1; }
            return 0;
<span class="line-new-header">--- 135,12 ---</span>
        ((BasicSym) iter.next()).resolve(this, listener);
      }
  
      // Sort blocks in ascending order of starting address (but do not
      // change ordering among blocks with the same starting address)
<span class="line-modified">!     Collections.sort(blocks, new Comparator&lt;&gt;() {</span>
<span class="line-modified">!         public int compare(BlockSym b1, BlockSym b2) {</span>
            Address a1 = b1.getAddress();
            Address a2 = b2.getAddress();
            if (AddressOps.lt(a1, a2)) { return -1; }
            if (AddressOps.gt(a1, a2)) { return 1; }
            return 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,15 ***</span>
    public void endConstruction() {
      if (Assert.ASSERTS_ENABLED) {
        Assert.that(state == RESOLVED_STATE, &quot;wrong state&quot;);
      }
      // Move all types to type list
<span class="line-modified">!     for (Iterator iter = lazyTypeMap.values().iterator(); iter.hasNext(); ) {</span>
        types.add(iter.next());
      }
      // Build name-to-type map
<span class="line-modified">!     nameToTypeMap = new HashMap();</span>
      for (Iterator iter = types.iterator(); iter.hasNext(); ) {
        Type t = (Type) iter.next();
        if (!t.isConst() &amp;&amp; !t.isVolatile()) {
          nameToTypeMap.put(t.getName(), t);
        }
<span class="line-new-header">--- 153,15 ---</span>
    public void endConstruction() {
      if (Assert.ASSERTS_ENABLED) {
        Assert.that(state == RESOLVED_STATE, &quot;wrong state&quot;);
      }
      // Move all types to type list
<span class="line-modified">!     for (Iterator&lt;Type&gt; iter = lazyTypeMap.values().iterator(); iter.hasNext(); ) {</span>
        types.add(iter.next());
      }
      // Build name-to-type map
<span class="line-modified">!     nameToTypeMap = new HashMap&lt;&gt;();</span>
      for (Iterator iter = types.iterator(); iter.hasNext(); ) {
        Type t = (Type) iter.next();
        if (!t.isConst() &amp;&amp; !t.isVolatile()) {
          nameToTypeMap.put(t.getName(), t);
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 335,12 ***</span>
      }
      return targetSym;
    }
  
    private void resolveLazyMap(ResolveListener listener) {
<span class="line-modified">!     for (Iterator iter = lazyTypeMap.entrySet().iterator(); iter.hasNext(); ) {</span>
<span class="line-modified">!       Map.Entry entry = (Map.Entry) iter.next();</span>
        BasicType t = (BasicType) entry.getValue();
        BasicType t2 = (BasicType) t.resolveTypes(this, listener);
        if (t2 != t) {
          entry.setValue(t2);
        }
<span class="line-new-header">--- 333,12 ---</span>
      }
      return targetSym;
    }
  
    private void resolveLazyMap(ResolveListener listener) {
<span class="line-modified">!     for (Iterator&lt;Map.Entry&lt;Object, Type&gt;&gt; iter = lazyTypeMap.entrySet().iterator(); iter.hasNext(); ) {</span>
<span class="line-modified">!       Map.Entry&lt;Object, Type&gt; entry = iter.next();</span>
        BasicType t = (BasicType) entry.getValue();
        BasicType t2 = (BasicType) t.resolveTypes(this, listener);
        if (t2 != t) {
          entry.setValue(t2);
        }
</pre>
<center><a href="BasicBlockSym.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BasicCompoundType.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
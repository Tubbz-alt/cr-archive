<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HSDB.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CommandProcessor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HotSpotAgent.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HSDB.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  30 import javax.swing.*;
  31 import java.util.*;
  32 
  33 import sun.jvm.hotspot.code.*;
  34 import sun.jvm.hotspot.compiler.*;
  35 import sun.jvm.hotspot.debugger.*;
  36 import sun.jvm.hotspot.gc.epsilon.*;
  37 import sun.jvm.hotspot.gc.parallel.*;
  38 import sun.jvm.hotspot.gc.shared.*;
  39 import sun.jvm.hotspot.gc.shenandoah.*;
  40 import sun.jvm.hotspot.gc.g1.*;
  41 import sun.jvm.hotspot.gc.z.*;
  42 import sun.jvm.hotspot.interpreter.*;
  43 import sun.jvm.hotspot.memory.*;
  44 import sun.jvm.hotspot.oops.*;
  45 import sun.jvm.hotspot.runtime.*;
  46 import sun.jvm.hotspot.ui.*;
  47 import sun.jvm.hotspot.ui.tree.*;
  48 import sun.jvm.hotspot.ui.classbrowser.*;
  49 import sun.jvm.hotspot.utilities.*;


  50 
  51 /** The top-level HotSpot Debugger. FIXME: make this an embeddable
  52     component! (Among other things, figure out what to do with the
  53     menu bar...) */
  54 
  55 public class HSDB implements ObjectHistogramPanel.Listener, SAListener {
  56   public static void main(String[] args) {
  57     new HSDB(args).run();
  58   }
  59 
  60   //--------------------------------------------------------------------------------
  61   // Internals only below this point
  62   //
  63   private HotSpotAgent agent;
  64   private JVMDebugger jvmDebugger;
  65   private JDesktopPane desktop;
  66   private boolean      attached;
  67   private boolean      argError;
  68   private JFrame frame;
<span class="line-modified">  69   /** List &lt;JMenuItem&gt; */</span>
<span class="line-modified">  70   private java.util.List attachMenuItems;</span>
<span class="line-removed">  71   /** List &lt;JMenuItem&gt; */</span>
<span class="line-removed">  72   private java.util.List detachMenuItems;</span>
  73   private JMenu toolsMenu;
  74   private JMenuItem showDbgConsoleMenuItem;
  75   private JMenuItem computeRevPtrsMenuItem;
  76   private JInternalFrame attachWaitDialog;
  77   private JInternalFrame threadsFrame;
  78   private JInternalFrame consoleFrame;
  79   private WorkerThread workerThread;
  80   // These had to be made data members because they are referenced in inner classes.
  81   private String pidText;
  82   private int pid;
  83   private String execPath;
  84   private String coreFilename;
  85 
  86   private void doUsage() {
  87     System.out.println(&quot;Usage:  java HSDB [[pid] | [path-to-java-executable [path-to-corefile]] | help ]&quot;);
  88     System.out.println(&quot;           pid:                     attach to the process whose id is &#39;pid&#39;&quot;);
  89     System.out.println(&quot;           path-to-java-executable: Debug a core file produced by this program&quot;);
  90     System.out.println(&quot;           path-to-corefile:        Debug this corefile.  The default is &#39;core&#39;&quot;);
  91     System.out.println(&quot;        If no arguments are specified, you can select what to do from the GUI.\n&quot;);
  92     HotSpotAgent.showUsage();
</pre>
<hr />
<pre>
 138       }
 139 
 140   }
 141 
 142   public void run() {
 143     // Don&#39;t start the UI if there were bad arguments.
 144     if (argError) {
 145         return;
 146     }
 147 
 148     // Create frame first, to catch any GUI creation issues
 149     // before we initialize agent
 150 
 151     frame = new JFrame(&quot;HSDB - HotSpot Debugger&quot;);
 152     frame.setSize(800, 600);
 153     frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
 154     frame.addWindowListener(new CloseUI());
 155 
 156     agent = new HotSpotAgent();
 157     workerThread = new WorkerThread();
<span class="line-modified"> 158     attachMenuItems = new java.util.ArrayList();</span>
<span class="line-modified"> 159     detachMenuItems = new java.util.ArrayList();</span>
 160 
 161 
 162     JMenuBar menuBar = new JMenuBar();
 163 
 164     //
 165     // File menu
 166     //
 167 
 168     JMenu menu = new JMenu(&quot;File&quot;);
 169     menu.setMnemonic(KeyEvent.VK_F);
 170     JMenuItem item;
 171     item = createMenuItem(&quot;Attach to HotSpot process...&quot;,
 172                           new ActionListener() {
 173                               public void actionPerformed(ActionEvent e) {
 174                                 showAttachDialog();
 175                               }
 176                             });
 177     item.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A, ActionEvent.ALT_MASK));
 178     item.setMnemonic(KeyEvent.VK_A);
 179     menu.add(item);
</pre>
<hr />
<pre>
 858 
 859     // Stackmap computation for interpreted frames is expensive; do
 860     // all stackwalking work in another thread for better GUI
 861     // responsiveness
 862     workerThread.invokeLater(new StackWalker(vframe, annoMemPanel) {
 863         public void run() {
 864           Address startAddr = null;
 865 
 866           // As this is a debugger, we want to provide potential crash
 867           // information to the user, i.e., by marking signal handler frames
 868           // on the stack. Since this system is currently targeted at
 869           // annotating the Java frames (interpreted or compiled) on the
 870           // stack and not, for example, &quot;external&quot; frames (note the current
 871           // absence of a PC-to-symbol lookup mechanism at the Debugger
 872           // level), we want to mark any Java frames which were interrupted
 873           // by a signal. We do this by making two passes over the stack,
 874           // one which finds signal handler frames and puts the parent
 875           // frames in a table and one which finds Java frames and if they
 876           // are in the table indicates that they were interrupted by a signal.
 877 
<span class="line-modified"> 878           Map interruptedFrameMap = new HashMap();</span>
 879           {
 880             sun.jvm.hotspot.runtime.Frame tmpFrame = thread.getCurrentFrameGuess();
 881             RegisterMap tmpMap = thread.newRegisterMap(false);
 882             while ((tmpFrame != null) &amp;&amp; (!tmpFrame.isFirstFrame())) {
 883               if (tmpFrame.isSignalHandlerFrameDbg()) {
 884                 // Add some information to the map that we can extract later
 885                 sun.jvm.hotspot.runtime.Frame interruptedFrame = tmpFrame.sender(tmpMap);
 886                 SignalInfo info = new SignalInfo();
 887                 info.sigNum  = tmpFrame.getSignalNumberDbg();
 888                 info.sigName = tmpFrame.getSignalNameDbg();
 889                 interruptedFrameMap.put(interruptedFrame, info);
 890               }
 891               tmpFrame = tmpFrame.sender(tmpMap);
 892             }
 893           }
 894 
 895           while (vf != null) {
 896             String anno = null;
 897             JavaVFrame curVFrame = vf;
 898             sun.jvm.hotspot.runtime.Frame curFrame = curVFrame.getFrame();
</pre>
<hr />
<pre>
1828     StringBuffer buf = new StringBuffer(message.length());
1829     StringTokenizer tokenizer = new StringTokenizer(message);
1830     int curLineLength = 0;
1831     while (tokenizer.hasMoreTokens()) {
1832       String tok = tokenizer.nextToken();
1833       if (curLineLength + tok.length() &gt; charsPerLine) {
1834         buf.append(&#39;\n&#39;);
1835         curLineLength = 0;
1836       } else {
1837         if (curLineLength != 0) {
1838           buf.append(&#39; &#39;);
1839           ++curLineLength;
1840         }
1841       }
1842       buf.append(tok);
1843       curLineLength += tok.length();
1844     }
1845     return buf.toString();
1846   }
1847 
<span class="line-modified">1848   private void setMenuItemsEnabled(java.util.List items, boolean enabled) {</span>
<span class="line-modified">1849     for (Iterator iter = items.iterator(); iter.hasNext(); ) {</span>
<span class="line-modified">1850       ((JMenuItem) iter.next()).setEnabled(enabled);</span>
1851     }
1852   }
1853 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  30 import javax.swing.*;
  31 import java.util.*;
  32 
  33 import sun.jvm.hotspot.code.*;
  34 import sun.jvm.hotspot.compiler.*;
  35 import sun.jvm.hotspot.debugger.*;
  36 import sun.jvm.hotspot.gc.epsilon.*;
  37 import sun.jvm.hotspot.gc.parallel.*;
  38 import sun.jvm.hotspot.gc.shared.*;
  39 import sun.jvm.hotspot.gc.shenandoah.*;
  40 import sun.jvm.hotspot.gc.g1.*;
  41 import sun.jvm.hotspot.gc.z.*;
  42 import sun.jvm.hotspot.interpreter.*;
  43 import sun.jvm.hotspot.memory.*;
  44 import sun.jvm.hotspot.oops.*;
  45 import sun.jvm.hotspot.runtime.*;
  46 import sun.jvm.hotspot.ui.*;
  47 import sun.jvm.hotspot.ui.tree.*;
  48 import sun.jvm.hotspot.ui.classbrowser.*;
  49 import sun.jvm.hotspot.utilities.*;
<span class="line-added">  50 import sun.jvm.hotspot.utilities.Observable;</span>
<span class="line-added">  51 import sun.jvm.hotspot.utilities.Observer;</span>
  52 
  53 /** The top-level HotSpot Debugger. FIXME: make this an embeddable
  54     component! (Among other things, figure out what to do with the
  55     menu bar...) */
  56 
  57 public class HSDB implements ObjectHistogramPanel.Listener, SAListener {
  58   public static void main(String[] args) {
  59     new HSDB(args).run();
  60   }
  61 
  62   //--------------------------------------------------------------------------------
  63   // Internals only below this point
  64   //
  65   private HotSpotAgent agent;
  66   private JVMDebugger jvmDebugger;
  67   private JDesktopPane desktop;
  68   private boolean      attached;
  69   private boolean      argError;
  70   private JFrame frame;
<span class="line-modified">  71   private java.util.List&lt;JMenuItem&gt; attachMenuItems;</span>
<span class="line-modified">  72   private java.util.List&lt;JMenuItem&gt; detachMenuItems;</span>


  73   private JMenu toolsMenu;
  74   private JMenuItem showDbgConsoleMenuItem;
  75   private JMenuItem computeRevPtrsMenuItem;
  76   private JInternalFrame attachWaitDialog;
  77   private JInternalFrame threadsFrame;
  78   private JInternalFrame consoleFrame;
  79   private WorkerThread workerThread;
  80   // These had to be made data members because they are referenced in inner classes.
  81   private String pidText;
  82   private int pid;
  83   private String execPath;
  84   private String coreFilename;
  85 
  86   private void doUsage() {
  87     System.out.println(&quot;Usage:  java HSDB [[pid] | [path-to-java-executable [path-to-corefile]] | help ]&quot;);
  88     System.out.println(&quot;           pid:                     attach to the process whose id is &#39;pid&#39;&quot;);
  89     System.out.println(&quot;           path-to-java-executable: Debug a core file produced by this program&quot;);
  90     System.out.println(&quot;           path-to-corefile:        Debug this corefile.  The default is &#39;core&#39;&quot;);
  91     System.out.println(&quot;        If no arguments are specified, you can select what to do from the GUI.\n&quot;);
  92     HotSpotAgent.showUsage();
</pre>
<hr />
<pre>
 138       }
 139 
 140   }
 141 
 142   public void run() {
 143     // Don&#39;t start the UI if there were bad arguments.
 144     if (argError) {
 145         return;
 146     }
 147 
 148     // Create frame first, to catch any GUI creation issues
 149     // before we initialize agent
 150 
 151     frame = new JFrame(&quot;HSDB - HotSpot Debugger&quot;);
 152     frame.setSize(800, 600);
 153     frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
 154     frame.addWindowListener(new CloseUI());
 155 
 156     agent = new HotSpotAgent();
 157     workerThread = new WorkerThread();
<span class="line-modified"> 158     attachMenuItems = new java.util.ArrayList&lt;&gt;();</span>
<span class="line-modified"> 159     detachMenuItems = new java.util.ArrayList&lt;&gt;();</span>
 160 
 161 
 162     JMenuBar menuBar = new JMenuBar();
 163 
 164     //
 165     // File menu
 166     //
 167 
 168     JMenu menu = new JMenu(&quot;File&quot;);
 169     menu.setMnemonic(KeyEvent.VK_F);
 170     JMenuItem item;
 171     item = createMenuItem(&quot;Attach to HotSpot process...&quot;,
 172                           new ActionListener() {
 173                               public void actionPerformed(ActionEvent e) {
 174                                 showAttachDialog();
 175                               }
 176                             });
 177     item.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A, ActionEvent.ALT_MASK));
 178     item.setMnemonic(KeyEvent.VK_A);
 179     menu.add(item);
</pre>
<hr />
<pre>
 858 
 859     // Stackmap computation for interpreted frames is expensive; do
 860     // all stackwalking work in another thread for better GUI
 861     // responsiveness
 862     workerThread.invokeLater(new StackWalker(vframe, annoMemPanel) {
 863         public void run() {
 864           Address startAddr = null;
 865 
 866           // As this is a debugger, we want to provide potential crash
 867           // information to the user, i.e., by marking signal handler frames
 868           // on the stack. Since this system is currently targeted at
 869           // annotating the Java frames (interpreted or compiled) on the
 870           // stack and not, for example, &quot;external&quot; frames (note the current
 871           // absence of a PC-to-symbol lookup mechanism at the Debugger
 872           // level), we want to mark any Java frames which were interrupted
 873           // by a signal. We do this by making two passes over the stack,
 874           // one which finds signal handler frames and puts the parent
 875           // frames in a table and one which finds Java frames and if they
 876           // are in the table indicates that they were interrupted by a signal.
 877 
<span class="line-modified"> 878           Map&lt;sun.jvm.hotspot.runtime.Frame, SignalInfo&gt; interruptedFrameMap = new HashMap&lt;&gt;();</span>
 879           {
 880             sun.jvm.hotspot.runtime.Frame tmpFrame = thread.getCurrentFrameGuess();
 881             RegisterMap tmpMap = thread.newRegisterMap(false);
 882             while ((tmpFrame != null) &amp;&amp; (!tmpFrame.isFirstFrame())) {
 883               if (tmpFrame.isSignalHandlerFrameDbg()) {
 884                 // Add some information to the map that we can extract later
 885                 sun.jvm.hotspot.runtime.Frame interruptedFrame = tmpFrame.sender(tmpMap);
 886                 SignalInfo info = new SignalInfo();
 887                 info.sigNum  = tmpFrame.getSignalNumberDbg();
 888                 info.sigName = tmpFrame.getSignalNameDbg();
 889                 interruptedFrameMap.put(interruptedFrame, info);
 890               }
 891               tmpFrame = tmpFrame.sender(tmpMap);
 892             }
 893           }
 894 
 895           while (vf != null) {
 896             String anno = null;
 897             JavaVFrame curVFrame = vf;
 898             sun.jvm.hotspot.runtime.Frame curFrame = curVFrame.getFrame();
</pre>
<hr />
<pre>
1828     StringBuffer buf = new StringBuffer(message.length());
1829     StringTokenizer tokenizer = new StringTokenizer(message);
1830     int curLineLength = 0;
1831     while (tokenizer.hasMoreTokens()) {
1832       String tok = tokenizer.nextToken();
1833       if (curLineLength + tok.length() &gt; charsPerLine) {
1834         buf.append(&#39;\n&#39;);
1835         curLineLength = 0;
1836       } else {
1837         if (curLineLength != 0) {
1838           buf.append(&#39; &#39;);
1839           ++curLineLength;
1840         }
1841       }
1842       buf.append(tok);
1843       curLineLength += tok.length();
1844     }
1845     return buf.toString();
1846   }
1847 
<span class="line-modified">1848   private void setMenuItemsEnabled(java.util.List&lt;JMenuItem&gt; items, boolean enabled) {</span>
<span class="line-modified">1849     for (Iterator&lt;JMenuItem&gt; iter = items.iterator(); iter.hasNext(); ) {</span>
<span class="line-modified">1850       iter.next().setEnabled(enabled);</span>
1851     }
1852   }
1853 }
</pre>
</td>
</tr>
</table>
<center><a href="CommandProcessor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HotSpotAgent.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
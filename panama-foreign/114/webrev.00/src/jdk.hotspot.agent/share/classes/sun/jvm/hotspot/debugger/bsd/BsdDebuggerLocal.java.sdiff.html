<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdDebuggerLocal.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BsdDebugger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../cdbg/CDebugger.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdDebuggerLocal.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.debugger.bsd;
 26 
 27 import java.io.File;
 28 import java.util.ArrayList;
 29 import java.util.List;
 30 
 31 import sun.jvm.hotspot.debugger.Address;
 32 import sun.jvm.hotspot.debugger.DebuggerBase;
 33 import sun.jvm.hotspot.debugger.DebuggerException;
 34 import sun.jvm.hotspot.debugger.DebuggerUtilities;
 35 import sun.jvm.hotspot.debugger.MachineDescription;
 36 import sun.jvm.hotspot.debugger.NotInHeapException;
 37 import sun.jvm.hotspot.debugger.OopHandle;

 38 import sun.jvm.hotspot.debugger.ReadResult;
 39 import sun.jvm.hotspot.debugger.ThreadProxy;
 40 import sun.jvm.hotspot.debugger.UnalignedAddressException;
 41 import sun.jvm.hotspot.debugger.UnmappedAddressException;
 42 import sun.jvm.hotspot.debugger.cdbg.CDebugger;
 43 import sun.jvm.hotspot.debugger.cdbg.ClosestSymbol;
 44 import sun.jvm.hotspot.debugger.cdbg.LoadObject;
 45 import sun.jvm.hotspot.runtime.JavaThread;
 46 import sun.jvm.hotspot.runtime.Threads;
 47 import sun.jvm.hotspot.runtime.VM;
 48 import sun.jvm.hotspot.utilities.PlatformInfo;
 49 
 50 /** &lt;P&gt; An implementation of the JVMDebugger interface. The basic debug
 51     facilities are implemented through ptrace interface in the JNI code
 52     (libsaproc.so). Library maps and symbol table management are done in
 53     JNI. &lt;/P&gt;
 54 
 55     &lt;P&gt; &lt;B&gt;NOTE&lt;/B&gt; that since we have the notion of fetching &quot;Java
 56     primitive types&quot; from the remote process (which might have
 57     different sizes than we expect) we have a bootstrapping
 58     problem. We need to know the sizes of these types before we can
 59     fetch them. The current implementation solves this problem by
 60     requiring that it be configured with these type sizes before they
 61     can be fetched. The readJ(Type) routines here will throw a
 62     RuntimeException if they are called before the debugger is
 63     configured with the Java primitive type sizes. &lt;/P&gt; */
 64 
 65 public class BsdDebuggerLocal extends DebuggerBase implements BsdDebugger {
 66     private boolean useGCC32ABI;
 67     private boolean attached;
 68     private long    p_ps_prochandle;      // native debugger handle
 69     private long    symbolicator;         // macosx symbolicator handle
 70     private long    task;                 // macosx task handle
 71     private boolean isCore;
 72     private boolean isDarwin;             // variant for bsd
 73 
 74     // CDebugger support
 75     private BsdCDebugger cdbg;
 76 
 77     // threadList and loadObjectList are filled by attach0 method
<span class="line-modified"> 78     private List threadList;</span>
<span class="line-modified"> 79     private List loadObjectList;</span>
 80 
 81     // called by native method lookupByAddress0
 82     private ClosestSymbol createClosestSymbol(String name, long offset) {
 83        return new ClosestSymbol(name, offset);
 84     }
 85 
 86     // called by native method attach0
 87     private LoadObject createLoadObject(String fileName, long textsize,
 88                                         long base) {
 89        File f = new File(fileName);
 90        Address baseAddr = newAddress(base);
 91        return new SharedObject(this, fileName, f.length(), baseAddr);
 92     }
 93 
 94     // native methods
 95 
 96     private native static void init0()
 97                                 throws DebuggerException;
 98     private native void attach0(int pid)
 99                                 throws DebuggerException;
</pre>
<hr />
<pre>
213             // dbx, but would have to test. For now, this cache works best
214             // if it covers the entire heap of the remote process. FIXME: at
215             // least should make this tunable from the outside, i.e., via
216             // the UI. This is a cache of 4096 4K pages, or 16 MB. The page
217             // size must be adjusted to be the hardware&#39;s page size.
218             // (FIXME: should pick this up from the debugger.)
219             initCache(4096, parseCacheNumPagesProperty(4096));
220         }
221 
222         isDarwin = getOS().equals(&quot;darwin&quot;);
223         workerThread = new BsdDebuggerLocalWorkerThread(this);
224         workerThread.start();
225     }
226 
227     /** From the Debugger interface via JVMDebugger */
228     public boolean hasProcessList() throws DebuggerException {
229         return false;
230     }
231 
232     /** From the Debugger interface via JVMDebugger */
<span class="line-modified">233     public List getProcessList() throws DebuggerException {</span>
234         throw new DebuggerException(&quot;getProcessList not implemented yet&quot;);
235     }
236 
237     private void checkAttached() throws DebuggerException {
238         if (attached) {
239             if (isCore) {
240                 throw new DebuggerException(&quot;attached to a core dump already&quot;);
241             } else {
242                 throw new DebuggerException(&quot;attached to a process already&quot;);
243             }
244         }
245     }
246 
247     private void requireAttach() {
248         if (! attached) {
249             throw new RuntimeException(&quot;not attached to a process or a core!&quot;);
250         }
251     }
252 
253     /* called from attach methods */
254     private void findABIVersion() throws DebuggerException {
255         String libjvmName = isDarwin ? &quot;libjvm.dylib&quot; : &quot;libjvm.so&quot;;
256         String javaThreadVt = isDarwin ? &quot;_vt_10JavaThread&quot; : &quot;__vt_10JavaThread&quot;;
257         if (lookupByName0(libjvmName, javaThreadVt) != 0) {
258             // old C++ ABI
259             useGCC32ABI = false;
260         } else {
261             // new C++ ABI
262             useGCC32ABI = true;
263         }
264     }
265 
266     /** From the Debugger interface via JVMDebugger */
267     public synchronized void attach(int processID) throws DebuggerException {
268         checkAttached();
<span class="line-modified">269         threadList = new ArrayList();</span>
<span class="line-modified">270         loadObjectList = new ArrayList();</span>
271         class AttachTask implements WorkerThreadTask {
272            int pid;
273            public void doit(BsdDebuggerLocal debugger) {
274               debugger.attach0(pid);
275               debugger.attached = true;
276               debugger.isCore = false;
277               findABIVersion();
278            }
279         }
280 
281         AttachTask task = new AttachTask();
282         task.pid = processID;
283         workerThread.execute(task);
284     }
285 
286     /** From the Debugger interface via JVMDebugger */
287     public synchronized void attach(String execName, String coreName) {
288         checkAttached();
<span class="line-modified">289         threadList = new ArrayList();</span>
<span class="line-modified">290         loadObjectList = new ArrayList();</span>
291         attach0(execName, coreName);
292         attached = true;
293         isCore = true;
294         findABIVersion();
295     }
296 
297     /** From the Debugger interface via JVMDebugger */
298     public synchronized boolean detach() {
299         if (!attached) {
300             return false;
301         }
302 
303         threadList = null;
304         loadObjectList = null;
305 
306         if (isCore) {
307             detach0();
308             attached = false;
309             return true;
310         } else {
</pre>
<hr />
<pre>
519         return utils.dataToJLong(data, jlongSize);
520     }
521 
522     //----------------------------------------------------------------------
523     // Address access. Can not be package private, but should only be
524     // accessed by the architecture-specific subpackages.
525 
526     /** From the BsdDebugger interface */
527     public long getAddressValue(Address addr) {
528       if (addr == null) return 0;
529       return ((BsdAddress) addr).getValue();
530     }
531 
532     /** From the BsdDebugger interface */
533     public Address newAddress(long value) {
534       if (value == 0) return null;
535       return new BsdAddress(this, value);
536     }
537 
538     /** From the BsdCDebugger interface */
<span class="line-modified">539     public List/*&lt;ThreadProxy&gt;*/ getThreadList() {</span>
540       requireAttach();
541       return threadList;
542     }
543 
544     /** From the BsdCDebugger interface */
<span class="line-modified">545     public List/*&lt;LoadObject&gt;*/ getLoadObjectList() {</span>
546       requireAttach();
547       return loadObjectList;
548     }
549 
550     /** From the BsdCDebugger interface */
551     public synchronized ClosestSymbol lookup(long addr) {
552        requireAttach();
553        if (isCore) {
554           return lookupByAddress0(addr);
555        } else {
556           class LookupByAddressTask implements WorkerThreadTask {
557              long addr;
558              ClosestSymbol result;
559 
560              public void doit(BsdDebuggerLocal debugger) {
561                  result = debugger.lookupByAddress0(addr);
562              }
563           }
564 
565           LookupByAddressTask task = new LookupByAddressTask();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.debugger.bsd;
 26 
 27 import java.io.File;
 28 import java.util.ArrayList;
 29 import java.util.List;
 30 
 31 import sun.jvm.hotspot.debugger.Address;
 32 import sun.jvm.hotspot.debugger.DebuggerBase;
 33 import sun.jvm.hotspot.debugger.DebuggerException;
 34 import sun.jvm.hotspot.debugger.DebuggerUtilities;
 35 import sun.jvm.hotspot.debugger.MachineDescription;
 36 import sun.jvm.hotspot.debugger.NotInHeapException;
 37 import sun.jvm.hotspot.debugger.OopHandle;
<span class="line-added"> 38 import sun.jvm.hotspot.debugger.ProcessInfo;</span>
 39 import sun.jvm.hotspot.debugger.ReadResult;
 40 import sun.jvm.hotspot.debugger.ThreadProxy;
 41 import sun.jvm.hotspot.debugger.UnalignedAddressException;
 42 import sun.jvm.hotspot.debugger.UnmappedAddressException;
 43 import sun.jvm.hotspot.debugger.cdbg.CDebugger;
 44 import sun.jvm.hotspot.debugger.cdbg.ClosestSymbol;
 45 import sun.jvm.hotspot.debugger.cdbg.LoadObject;
 46 import sun.jvm.hotspot.runtime.JavaThread;
 47 import sun.jvm.hotspot.runtime.Threads;
 48 import sun.jvm.hotspot.runtime.VM;
 49 import sun.jvm.hotspot.utilities.PlatformInfo;
 50 
 51 /** &lt;P&gt; An implementation of the JVMDebugger interface. The basic debug
 52     facilities are implemented through ptrace interface in the JNI code
 53     (libsaproc.so). Library maps and symbol table management are done in
 54     JNI. &lt;/P&gt;
 55 
 56     &lt;P&gt; &lt;B&gt;NOTE&lt;/B&gt; that since we have the notion of fetching &quot;Java
 57     primitive types&quot; from the remote process (which might have
 58     different sizes than we expect) we have a bootstrapping
 59     problem. We need to know the sizes of these types before we can
 60     fetch them. The current implementation solves this problem by
 61     requiring that it be configured with these type sizes before they
 62     can be fetched. The readJ(Type) routines here will throw a
 63     RuntimeException if they are called before the debugger is
 64     configured with the Java primitive type sizes. &lt;/P&gt; */
 65 
 66 public class BsdDebuggerLocal extends DebuggerBase implements BsdDebugger {
 67     private boolean useGCC32ABI;
 68     private boolean attached;
 69     private long    p_ps_prochandle;      // native debugger handle
 70     private long    symbolicator;         // macosx symbolicator handle
 71     private long    task;                 // macosx task handle
 72     private boolean isCore;
 73     private boolean isDarwin;             // variant for bsd
 74 
 75     // CDebugger support
 76     private BsdCDebugger cdbg;
 77 
 78     // threadList and loadObjectList are filled by attach0 method
<span class="line-modified"> 79     private List&lt;ThreadProxy&gt; threadList;</span>
<span class="line-modified"> 80     private List&lt;LoadObject&gt; loadObjectList;</span>
 81 
 82     // called by native method lookupByAddress0
 83     private ClosestSymbol createClosestSymbol(String name, long offset) {
 84        return new ClosestSymbol(name, offset);
 85     }
 86 
 87     // called by native method attach0
 88     private LoadObject createLoadObject(String fileName, long textsize,
 89                                         long base) {
 90        File f = new File(fileName);
 91        Address baseAddr = newAddress(base);
 92        return new SharedObject(this, fileName, f.length(), baseAddr);
 93     }
 94 
 95     // native methods
 96 
 97     private native static void init0()
 98                                 throws DebuggerException;
 99     private native void attach0(int pid)
100                                 throws DebuggerException;
</pre>
<hr />
<pre>
214             // dbx, but would have to test. For now, this cache works best
215             // if it covers the entire heap of the remote process. FIXME: at
216             // least should make this tunable from the outside, i.e., via
217             // the UI. This is a cache of 4096 4K pages, or 16 MB. The page
218             // size must be adjusted to be the hardware&#39;s page size.
219             // (FIXME: should pick this up from the debugger.)
220             initCache(4096, parseCacheNumPagesProperty(4096));
221         }
222 
223         isDarwin = getOS().equals(&quot;darwin&quot;);
224         workerThread = new BsdDebuggerLocalWorkerThread(this);
225         workerThread.start();
226     }
227 
228     /** From the Debugger interface via JVMDebugger */
229     public boolean hasProcessList() throws DebuggerException {
230         return false;
231     }
232 
233     /** From the Debugger interface via JVMDebugger */
<span class="line-modified">234     public List&lt;ProcessInfo&gt; getProcessList() throws DebuggerException {</span>
235         throw new DebuggerException(&quot;getProcessList not implemented yet&quot;);
236     }
237 
238     private void checkAttached() throws DebuggerException {
239         if (attached) {
240             if (isCore) {
241                 throw new DebuggerException(&quot;attached to a core dump already&quot;);
242             } else {
243                 throw new DebuggerException(&quot;attached to a process already&quot;);
244             }
245         }
246     }
247 
248     private void requireAttach() {
249         if (! attached) {
250             throw new RuntimeException(&quot;not attached to a process or a core!&quot;);
251         }
252     }
253 
254     /* called from attach methods */
255     private void findABIVersion() throws DebuggerException {
256         String libjvmName = isDarwin ? &quot;libjvm.dylib&quot; : &quot;libjvm.so&quot;;
257         String javaThreadVt = isDarwin ? &quot;_vt_10JavaThread&quot; : &quot;__vt_10JavaThread&quot;;
258         if (lookupByName0(libjvmName, javaThreadVt) != 0) {
259             // old C++ ABI
260             useGCC32ABI = false;
261         } else {
262             // new C++ ABI
263             useGCC32ABI = true;
264         }
265     }
266 
267     /** From the Debugger interface via JVMDebugger */
268     public synchronized void attach(int processID) throws DebuggerException {
269         checkAttached();
<span class="line-modified">270         threadList = new ArrayList&lt;&gt;();</span>
<span class="line-modified">271         loadObjectList = new ArrayList&lt;&gt;();</span>
272         class AttachTask implements WorkerThreadTask {
273            int pid;
274            public void doit(BsdDebuggerLocal debugger) {
275               debugger.attach0(pid);
276               debugger.attached = true;
277               debugger.isCore = false;
278               findABIVersion();
279            }
280         }
281 
282         AttachTask task = new AttachTask();
283         task.pid = processID;
284         workerThread.execute(task);
285     }
286 
287     /** From the Debugger interface via JVMDebugger */
288     public synchronized void attach(String execName, String coreName) {
289         checkAttached();
<span class="line-modified">290         threadList = new ArrayList&lt;&gt;();</span>
<span class="line-modified">291         loadObjectList = new ArrayList&lt;&gt;();</span>
292         attach0(execName, coreName);
293         attached = true;
294         isCore = true;
295         findABIVersion();
296     }
297 
298     /** From the Debugger interface via JVMDebugger */
299     public synchronized boolean detach() {
300         if (!attached) {
301             return false;
302         }
303 
304         threadList = null;
305         loadObjectList = null;
306 
307         if (isCore) {
308             detach0();
309             attached = false;
310             return true;
311         } else {
</pre>
<hr />
<pre>
520         return utils.dataToJLong(data, jlongSize);
521     }
522 
523     //----------------------------------------------------------------------
524     // Address access. Can not be package private, but should only be
525     // accessed by the architecture-specific subpackages.
526 
527     /** From the BsdDebugger interface */
528     public long getAddressValue(Address addr) {
529       if (addr == null) return 0;
530       return ((BsdAddress) addr).getValue();
531     }
532 
533     /** From the BsdDebugger interface */
534     public Address newAddress(long value) {
535       if (value == 0) return null;
536       return new BsdAddress(this, value);
537     }
538 
539     /** From the BsdCDebugger interface */
<span class="line-modified">540     public List&lt;ThreadProxy&gt; getThreadList() {</span>
541       requireAttach();
542       return threadList;
543     }
544 
545     /** From the BsdCDebugger interface */
<span class="line-modified">546     public List&lt;LoadObject&gt; getLoadObjectList() {</span>
547       requireAttach();
548       return loadObjectList;
549     }
550 
551     /** From the BsdCDebugger interface */
552     public synchronized ClosestSymbol lookup(long addr) {
553        requireAttach();
554        if (isCore) {
555           return lookupByAddress0(addr);
556        } else {
557           class LookupByAddressTask implements WorkerThreadTask {
558              long addr;
559              ClosestSymbol result;
560 
561              public void doit(BsdDebuggerLocal debugger) {
562                  result = debugger.lookupByAddress0(addr);
563              }
564           }
565 
566           LookupByAddressTask task = new LookupByAddressTask();
</pre>
</td>
</tr>
</table>
<center><a href="BsdDebugger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../cdbg/CDebugger.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/CommandProcessor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 package sun.jvm.hotspot;
  26 
  27 import java.io.BufferedOutputStream;
  28 import java.io.BufferedReader;
  29 import java.io.ByteArrayOutputStream;
  30 import java.io.File;
  31 import java.io.FileInputStream;
  32 import java.io.FileOutputStream;
  33 import java.io.IOException;
  34 import java.io.InputStreamReader;
  35 import java.io.PrintStream;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Comparator;
  39 import java.util.HashMap;
  40 import java.util.HashSet;
  41 import java.util.Iterator;
  42 import java.util.Stack;
  43 import java.util.regex.Matcher;
  44 import java.util.regex.Pattern;
  45 
  46 import sun.jvm.hotspot.ci.ciEnv;
  47 import sun.jvm.hotspot.code.CodeBlob;
  48 import sun.jvm.hotspot.code.CodeCacheVisitor;
  49 import sun.jvm.hotspot.code.NMethod;
  50 import sun.jvm.hotspot.debugger.Address;
  51 import sun.jvm.hotspot.debugger.OopHandle;
  52 import sun.jvm.hotspot.classfile.ClassLoaderDataGraph;
  53 import sun.jvm.hotspot.memory.FileMapInfo;
  54 import sun.jvm.hotspot.memory.SystemDictionary;
  55 import sun.jvm.hotspot.memory.Universe;
  56 import sun.jvm.hotspot.gc.shared.CollectedHeap;
  57 import sun.jvm.hotspot.gc.g1.G1CollectedHeap;
  58 import sun.jvm.hotspot.oops.DefaultHeapVisitor;
  59 import sun.jvm.hotspot.oops.HeapVisitor;
  60 import sun.jvm.hotspot.oops.InstanceKlass;
  61 import sun.jvm.hotspot.oops.Klass;
  62 import sun.jvm.hotspot.oops.Metadata;
  63 import sun.jvm.hotspot.oops.Method;
  64 import sun.jvm.hotspot.oops.MethodData;
  65 import sun.jvm.hotspot.oops.Oop;
  66 import sun.jvm.hotspot.oops.RawHeapVisitor;
  67 import sun.jvm.hotspot.oops.Symbol;
  68 import sun.jvm.hotspot.oops.UnknownOopException;
  69 import sun.jvm.hotspot.opto.Compile;
  70 import sun.jvm.hotspot.opto.InlineTree;
  71 import sun.jvm.hotspot.runtime.CompiledVFrame;
  72 import sun.jvm.hotspot.runtime.CompilerThread;
  73 import sun.jvm.hotspot.runtime.JavaThread;
  74 import sun.jvm.hotspot.runtime.JavaVFrame;
  75 import sun.jvm.hotspot.runtime.Threads;
  76 import sun.jvm.hotspot.runtime.VM;
  77 import sun.jvm.hotspot.tools.ObjectHistogram;
  78 import sun.jvm.hotspot.tools.JMap;
  79 import sun.jvm.hotspot.tools.PMap;
  80 import sun.jvm.hotspot.tools.PStack;
  81 import sun.jvm.hotspot.tools.StackTrace;
  82 import sun.jvm.hotspot.tools.SysPropsDumper;
  83 import sun.jvm.hotspot.tools.jcore.ClassDump;
  84 import sun.jvm.hotspot.tools.jcore.ClassFilter;
  85 import sun.jvm.hotspot.tools.jcore.ClassWriter;
  86 import sun.jvm.hotspot.types.CIntegerType;
  87 import sun.jvm.hotspot.types.Field;
  88 import sun.jvm.hotspot.types.Type;
  89 import sun.jvm.hotspot.types.basic.BasicType;
  90 import sun.jvm.hotspot.ui.classbrowser.HTMLGenerator;
  91 import sun.jvm.hotspot.ui.tree.CTypeTreeNodeAdapter;
  92 import sun.jvm.hotspot.ui.tree.OopTreeNodeAdapter;
  93 import sun.jvm.hotspot.ui.tree.SimpleTreeNode;
  94 import sun.jvm.hotspot.utilities.AddressOps;
  95 import sun.jvm.hotspot.utilities.Assert;
  96 import sun.jvm.hotspot.utilities.CompactHashTable;
  97 import sun.jvm.hotspot.utilities.HeapProgressThunk;
  98 import sun.jvm.hotspot.utilities.LivenessPathElement;
  99 import sun.jvm.hotspot.utilities.MethodArray;
 100 import sun.jvm.hotspot.utilities.ObjectReader;
 101 import sun.jvm.hotspot.utilities.PointerFinder;
 102 import sun.jvm.hotspot.utilities.PointerLocation;
 103 import sun.jvm.hotspot.utilities.ReversePtrs;
 104 import sun.jvm.hotspot.utilities.ReversePtrsAnalysis;
 105 import sun.jvm.hotspot.utilities.RobustOopDeterminator;
 106 import sun.jvm.hotspot.utilities.SystemDictionaryHelper;
 107 import sun.jvm.hotspot.utilities.soql.JSJavaFactory;
 108 import sun.jvm.hotspot.utilities.soql.JSJavaFactoryImpl;
 109 import sun.jvm.hotspot.utilities.soql.JSJavaScriptEngine;
 110 
 111 public class CommandProcessor {
 112 
 113     volatile boolean quit;
 114 
 115     public abstract static class DebuggerInterface {
 116         public abstract HotSpotAgent getAgent();
 117         public abstract boolean isAttached();
 118         public abstract void attach(String pid);
 119         public abstract void attach(String java, String core);
 120         public abstract void detach();
 121         public abstract void reattach();
 122     }
 123 
 124     public static class BootFilter implements ClassFilter {
 125         public boolean canInclude(InstanceKlass kls) {
 126             return kls.getClassLoader() == null;
 127         }
 128     }
 129 
 130     public static class NonBootFilter implements ClassFilter {
 131         private HashMap&lt;Symbol, InstanceKlass&gt; emitted = new HashMap&lt;&gt;();
 132         public boolean canInclude(InstanceKlass kls) {
 133             if (kls.getClassLoader() == null) return false;
 134             if (emitted.get(kls.getName()) != null) {
 135                 // Since multiple class loaders are being shoved
 136                 // together duplicate classes are a possibilty.  For
 137                 // now just ignore them.
 138                 return false;
 139             }
 140             emitted.put(kls.getName(), kls);
 141             return true;
 142         }
 143     }
 144 
 145     static class Tokens {
 146         final String input;
 147         int i;
 148         String[] tokens;
 149         int length;
 150 
 151         String[] splitWhitespace(String cmd) {
 152             String[] t = cmd.split(&quot;\\s&quot;);
 153             if (t.length == 1 &amp;&amp; t[0].length() == 0) {
 154                 return new String[0];
 155             }
 156             return t;
 157         }
 158 
 159         void add(String s, ArrayList&lt;String&gt; t) {
 160             if (s.length() &gt; 0) {
 161                 t.add(s);
 162             }
 163         }
 164 
 165         Tokens(String cmd) {
 166             input = cmd;
 167 
 168             // check for quoting
 169             int quote = cmd.indexOf(&#39;&quot;&#39;);
 170             ArrayList&lt;String&gt; t = new ArrayList&lt;&gt;();
 171             if (quote != -1) {
 172                 while (cmd.length() &gt; 0) {
 173                     if (quote != -1) {
 174                         int endquote = cmd.indexOf(&#39;&quot;&#39;, quote + 1);
 175                         if (endquote == -1) {
 176                             throw new RuntimeException(&quot;mismatched quotes: &quot; + input);
 177                         }
 178 
 179                         String before = cmd.substring(0, quote).trim();
 180                         String quoted = cmd.substring(quote + 1, endquote);
 181                         cmd = cmd.substring(endquote + 1).trim();
 182                         if (before.length() &gt; 0) {
 183                             String[] w = splitWhitespace(before);
 184                             for (int i = 0; i &lt; w.length; i++) {
 185                                 add(w[i], t);
 186                             }
 187                         }
 188                         add(quoted, t);
 189                         quote = cmd.indexOf(&#39;&quot;&#39;);
 190                     } else {
 191                         String[] w = splitWhitespace(cmd);
 192                         for (int i = 0; i &lt; w.length; i++) {
 193                             add(w[i], t);
 194                         }
 195                         cmd = &quot;&quot;;
 196 
 197                     }
 198                 }
 199             } else {
 200                 String[] w = splitWhitespace(cmd);
 201                 for (int i = 0; i &lt; w.length; i++) {
 202                     add(w[i], t);
 203                 }
 204             }
 205             tokens = (String[])t.toArray(new String[0]);
 206             i = 0;
 207             length = tokens.length;
 208 
 209             //for (int i = 0; i &lt; tokens.length; i++) {
 210             //    System.out.println(&quot;\&quot;&quot; + tokens[i] + &quot;\&quot;&quot;);
 211             //}
 212         }
 213 
 214         String nextToken() {
 215             return tokens[i++];
 216         }
 217         boolean hasMoreTokens() {
 218             return i &lt; length;
 219         }
 220         int countTokens() {
 221             return length - i;
 222         }
 223         void trim(int n) {
 224             if (length &gt;= n) {
 225                 length -= n;
 226             } else {
 227                 throw new IndexOutOfBoundsException(String.valueOf(n));
 228             }
 229         }
 230         String join(String sep) {
 231             StringBuffer result = new StringBuffer();
 232             for (int w = i; w &lt; length; w++) {
 233                 result.append(tokens[w]);
 234                 if (w + 1 &lt; length) {
 235                     result.append(sep);
 236                 }
 237             }
 238             return result.toString();
 239         }
 240 
 241         String at(int i) {
 242             if (i &lt; 0 || i &gt;= length) {
 243                 throw new IndexOutOfBoundsException(String.valueOf(i));
 244             }
 245             return tokens[i];
 246         }
 247     }
 248 
 249 
 250     abstract class Command {
 251         Command(String n, String u, boolean ok) {
 252             name = n;
 253             usage = u;
 254             okIfDisconnected = ok;
 255         }
 256 
 257         Command(String n, boolean ok) {
 258             name = n;
 259             usage = n;
 260             okIfDisconnected = ok;
 261         }
 262 
 263         final String name;
 264         final String usage;
 265         final boolean okIfDisconnected;
 266         abstract void doit(Tokens t);
 267         void usage() {
 268             out.println(&quot;Usage: &quot; + usage);
 269         }
 270 
 271         void printOopValue(Oop oop) {
 272             if (oop != null) {
 273                 Klass k = oop.getKlass();
 274                 Symbol s = k.getName();
 275                 if (s != null) {
 276                     out.print(&quot;Oop for &quot; + s.asString() + &quot; @ &quot;);
 277                 } else {
 278                     out.print(&quot;Oop @ &quot;);
 279                 }
 280                 Oop.printOopAddressOn(oop, out);
 281             } else {
 282                 out.print(&quot;null&quot;);
 283             }
 284         }
 285 
 286         void printNode(SimpleTreeNode node) {
 287             int count = node.getChildCount();
 288             for (int i = 0; i &lt; count; i++) {
 289                 try {
 290                     SimpleTreeNode field = node.getChild(i);
 291                     if (field instanceof OopTreeNodeAdapter) {
 292                         out.print(field);
 293                         out.print(&quot; &quot;);
 294                         printOopValue(((OopTreeNodeAdapter)field).getOop());
 295                         out.println();
 296                     } else {
 297                         out.println(field);
 298                     }
 299                 } catch (Exception e) {
 300                     out.println();
 301                     out.println(&quot;Error: &quot; + e);
 302                     if (verboseExceptions) {
 303                         e.printStackTrace(out);
 304                     }
 305                 }
 306             }
 307         }
 308     }
 309 
 310     void quote(String s) {
 311         if (s.indexOf(&quot; &quot;) == -1) {
 312             out.print(s);
 313         } else {
 314             out.print(&quot;\&quot;&quot;);
 315             out.print(s);
 316             out.print(&quot;\&quot;&quot;);
 317         }
 318     }
 319 
 320     void dumpType(Type type) {
 321         out.print(&quot;type &quot;);
 322         quote(type.getName());
 323         out.print(&quot; &quot;);
 324         if (type.getSuperclass() != null) {
 325             quote(type.getSuperclass().getName());
 326             out.print(&quot; &quot;);
 327         } else {
 328             out.print(&quot;null &quot;);
 329         }
 330         out.print(type.isOopType());
 331         out.print(&quot; &quot;);
 332         if (type.isCIntegerType()) {
 333             out.print(&quot;true &quot;);
 334             out.print(((CIntegerType)type).isUnsigned());
 335             out.print(&quot; &quot;);
 336         } else {
 337             out.print(&quot;false false &quot;);
 338         }
 339         out.print(type.getSize());
 340         out.println();
 341     }
 342 
 343     void dumpFields(Type type) {
 344         dumpFields(type, true);
 345     }
 346 
 347     void dumpFields(Type type, boolean allowStatic) {
 348         Iterator i = type.getFields();
 349         while (i.hasNext()) {
 350             Field f = (Field) i.next();
 351             if (!allowStatic &amp;&amp; f.isStatic()) continue;
 352             out.print(&quot;field &quot;);
 353             quote(type.getName());
 354             out.print(&quot; &quot;);
 355             out.print(f.getName());
 356             out.print(&quot; &quot;);
 357             quote(f.getType().getName());
 358             out.print(&quot; &quot;);
 359             out.print(f.isStatic());
 360             out.print(&quot; &quot;);
 361             if (f.isStatic()) {
 362                 out.print(&quot;0 &quot;);
 363                 out.print(f.getStaticFieldAddress());
 364             } else {
 365                 out.print(f.getOffset());
 366                 out.print(&quot; 0x0&quot;);
 367             }
 368             out.println();
 369         }
 370     }
 371 
 372 
 373     Address lookup(String symbol) {
 374         if (symbol.indexOf(&quot;::&quot;) != -1) {
 375             String[] parts = symbol.split(&quot;::&quot;);
 376             StringBuffer mangled = new StringBuffer(&quot;__1c&quot;);
 377             for (int i = 0; i &lt; parts.length; i++) {
 378                 int len = parts[i].length();
 379                 if (len &gt;= 26) {
 380                     mangled.append((char)(&#39;a&#39; + (len / 26)));
 381                     len = len % 26;
 382                 }
 383                 mangled.append((char)(&#39;A&#39; + len));
 384                 mangled.append(parts[i]);
 385             }
 386             mangled.append(&quot;_&quot;);
 387             symbol = mangled.toString();
 388         }
 389         return VM.getVM().getDebugger().lookup(null, symbol);
 390     }
 391 
 392     Address parseAddress(String addr) {
 393         return VM.getVM().getDebugger().parseAddress(addr);
 394     }
 395 
 396     private final Command[] commandList = {
 397         new Command(&quot;reattach&quot;, true) {
 398             public void doit(Tokens t) {
 399                 int tokens = t.countTokens();
 400                 if (tokens != 0) {
 401                     usage();
 402                     return;
 403                 }
 404                 preAttach();
 405                 debugger.reattach();
 406                 postAttach();
 407             }
 408         },
 409         new Command(&quot;attach&quot;, &quot;attach pid | exec core&quot;, true) {
 410             public void doit(Tokens t) {
 411                 int tokens = t.countTokens();
 412                 if (tokens == 1) {
 413                     preAttach();
 414                     debugger.attach(t.nextToken());
 415                     postAttach();
 416                 } else if (tokens == 2) {
 417                     preAttach();
 418                     debugger.attach(t.nextToken(), t.nextToken());
 419                     postAttach();
 420                 } else {
 421                     usage();
 422                 }
 423             }
 424         },
 425         new Command(&quot;detach&quot;, false) {
 426             public void doit(Tokens t) {
 427                 if (t.countTokens() != 0) {
 428                     usage();
 429                 } else {
 430                     debugger.detach();
 431                 }
 432             }
 433         },
 434         new Command(&quot;examine&quot;, &quot;examine [ address/count ] | [ address,address]&quot;, false) {
 435             Pattern args1 = Pattern.compile(&quot;^(0x[0-9a-f]+)(/([0-9]*)([a-z]*))?$&quot;);
 436             Pattern args2 = Pattern.compile(&quot;^(0x[0-9a-f]+),(0x[0-9a-f]+)(/[a-z]*)?$&quot;);
 437 
 438             String fill(Address a, int width) {
 439                 String s = &quot;0x0&quot;;
 440                 if (a != null) {
 441                     s = a.toString();
 442                 }
 443                 if (s.length() != width) {
 444                     return s.substring(0, 2) + &quot;000000000000000000000&quot;.substring(0, width - s.length()) + s.substring(2);
 445                 }
 446                 return s;
 447             }
 448 
 449             public void doit(Tokens t) {
 450                 if (t.countTokens() != 1) {
 451                     usage();
 452                 } else {
 453                     String arg = t.nextToken();
 454                     Matcher m1 = args1.matcher(arg);
 455                     Matcher m2 = args2.matcher(arg);
 456                     Address start = null;
 457                     Address end   = null;
 458                     String format = &quot;&quot;;
 459                     int formatSize = (int)VM.getVM().getAddressSize();
 460 
 461                     if (m1.matches()) {
 462                         start = VM.getVM().getDebugger().parseAddress(m1.group(1));
 463                         int count = 1;
 464                         if (m1.group(2) != null) {
 465                             count = Integer.parseInt(m1.group(3));
 466                         }
 467                         end = start.addOffsetTo(count * formatSize);
 468                     } else if (m2.matches()) {
 469                         start = VM.getVM().getDebugger().parseAddress(m2.group(1));
 470                         end   = VM.getVM().getDebugger().parseAddress(m2.group(2));
 471                     } else {
 472                         usage();
 473                         return;
 474                     }
 475                     int line = 80;
 476                     int formatWidth = formatSize * 8 / 4 + 2;
 477 
 478                     out.print(fill(start, formatWidth));
 479                     out.print(&quot;: &quot;);
 480                     int width = line - formatWidth - 2;
 481 
 482                     boolean needsPrintln = true;
 483                     while (start != null &amp;&amp; start.lessThan(end)) {
 484                         Address val = start.getAddressAt(0);
 485                         out.print(fill(val, formatWidth));
 486                         needsPrintln = true;
 487                         width -= formatWidth;
 488                         start = start.addOffsetTo(formatSize);
 489                         if (width &lt;= formatWidth) {
 490                             out.println();
 491                             needsPrintln = false;
 492                             if (start.lessThan(end)) {
 493                                 out.print(fill(start, formatWidth));
 494                                 out.print(&quot;: &quot;);
 495                                 width = line - formatWidth - 2;
 496                             }
 497                         } else {
 498                             out.print(&quot; &quot;);
 499                             width -= 1;
 500                         }
 501                     }
 502                     if (needsPrintln) {
 503                         out.println();
 504                     }
 505                 }
 506             }
 507         },
 508         new Command(&quot;dumpreplaydata&quot;, &quot;dumpreplaydata { &lt;address &gt; | -a | &lt;thread_id&gt; }&quot;, false) {
 509             // This is used to dump replay data from ciInstanceKlass, ciMethodData etc
 510             // default file name is replay.txt, also if java crashes in compiler
 511             // thread, this file will be dumped in error processing.
 512             public void doit(Tokens t) {
 513                 if (t.countTokens() != 1) {
 514                     usage();
 515                     return;
 516                 }
 517                 String name = t.nextToken();
 518                 Address a = null;
 519                 try {
 520                     a = VM.getVM().getDebugger().parseAddress(name);
 521                 } catch (NumberFormatException e) { }
 522                 if (a != null) {
 523                     // only nmethod, Method, MethodData and InstanceKlass needed to
 524                     // dump replay data
 525 
 526                     CodeBlob cb = VM.getVM().getCodeCache().findBlob(a);
 527                     if (cb != null &amp;&amp; (cb instanceof NMethod)) {
 528                         ((NMethod)cb).dumpReplayData(out);
 529                         return;
 530                     }
 531                     // assume it is Metadata
 532                     Metadata meta = Metadata.instantiateWrapperFor(a);
 533                     if (meta != null) {
 534                         meta.dumpReplayData(out);
 535                     } else {
 536                         usage();
 537                         return;
 538                     }
 539                 }
 540                 // Not an address
 541                 boolean all = name.equals(&quot;-a&quot;);
 542                 Threads threads = VM.getVM().getThreads();
 543                 for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
 544                     JavaThread thread = threads.getJavaThreadAt(i);
 545                     ByteArrayOutputStream bos = new ByteArrayOutputStream();
 546                     thread.printThreadIDOn(new PrintStream(bos));
 547                     if (all || bos.toString().equals(name)) {
 548                         if (thread instanceof CompilerThread) {
 549                             CompilerThread ct = (CompilerThread)thread;
 550                             ciEnv env = ct.env();
 551                             if (env != null) {
 552                                env.dumpReplayData(out);
 553                             }
 554                         }
 555                     }
 556                 }
 557             }
 558         },
 559         new Command(&quot;buildreplayjars&quot;, &quot;buildreplayjars [ all | app | boot ]  | [ prefix ]&quot;, false) {
 560             // This is used to dump jar files of all the classes
 561             // loaded in the core.  Everything with null classloader
 562             // will go in boot.jar and everything else will go in
 563             // app.jar. boot.jar usually not needed, unless changed by jvmti.
 564             public void doit(Tokens t) {
 565                 int tcount = t.countTokens();
 566                 if (tcount &gt; 2) {
 567                     usage();
 568                     return;
 569                 }
 570                 try {
 571                    String prefix = &quot;&quot;;
 572                    String option = &quot;all&quot;; // default
 573                    switch(tcount) {
 574                        case 0:
 575                            break;
 576                        case 1:
 577                            option = t.nextToken();
 578                            if (!option.equalsIgnoreCase(&quot;all&quot;) &amp;&amp; !option.equalsIgnoreCase(&quot;app&quot;) &amp;&amp;
 579                                !option.equalsIgnoreCase(&quot;root&quot;)) {
 580                               prefix = option;
 581                               option = &quot;all&quot;;
 582                            }
 583                            break;
 584                        case 2:
 585                            option = t.nextToken();
 586                            prefix = t.nextToken();
 587                            break;
 588                        default:
 589                            usage();
 590                            return;
 591                    }
 592                    if (!option.equalsIgnoreCase(&quot;all&quot;) &amp;&amp; !option.equalsIgnoreCase(&quot;app&quot;) &amp;&amp;
 593                                !option.equalsIgnoreCase(&quot;boot&quot;)) {
 594                        usage();
 595                        return;
 596                    }
 597                    ClassDump cd = new ClassDump();
 598                    if (option.equalsIgnoreCase(&quot;all&quot;) || option.equalsIgnoreCase(&quot;boot&quot;)) {
 599                      cd.setClassFilter(new BootFilter());
 600                      cd.setJarOutput(prefix + &quot;boot.jar&quot;);
 601                      cd.run();
 602                    }
 603                    if (option.equalsIgnoreCase(&quot;all&quot;) || option.equalsIgnoreCase(&quot;app&quot;)) {
 604                      cd.setClassFilter(new NonBootFilter());
 605                      cd.setJarOutput(prefix + &quot;app.jar&quot;);
 606                      cd.run();
 607                    }
 608                 } catch (IOException ioe) {
 609                    ioe.printStackTrace();
 610                 }
 611             }
 612         },
 613         new Command(&quot;findpc&quot;, &quot;findpc address&quot;, false) {
 614             public void doit(Tokens t) {
 615                 if (t.countTokens() != 1) {
 616                     usage();
 617                 } else {
 618                     Address a = VM.getVM().getDebugger().parseAddress(t.nextToken());
 619                     PointerLocation loc = PointerFinder.find(a);
 620                     loc.printOn(out);
 621                 }
 622             }
 623         },
 624         new Command(&quot;symbol&quot;, &quot;symbol address&quot;, false) {
 625             public void doit(Tokens t) {
 626                 if (t.countTokens() != 1) {
 627                     usage();
 628                 } else {
 629                     Address a = VM.getVM().getDebugger().parseAddress(t.nextToken());
 630                     Symbol.create(a).printValueOn(out);
 631                     out.println();
 632                 }
 633             }
 634         },
 635         new Command(&quot;flags&quot;, &quot;flags [ flag | -nd ]&quot;, false) {
 636             public void doit(Tokens t) {
 637                 int tokens = t.countTokens();
 638                 if (tokens != 0 &amp;&amp; tokens != 1) {
 639                     usage();
 640                 } else {
 641                     String name = tokens &gt; 0 ? t.nextToken() : null;
 642                     boolean nonDefault = false;
 643                     if (name != null &amp;&amp; name.equals(&quot;-nd&quot;)) {
 644                         name = null;
 645                         nonDefault = true;
 646                     }
 647 
 648                     VM.Flag[] flags = VM.getVM().getCommandLineFlags();
 649                     if (flags == null) {
 650                         out.println(&quot;Command Flag info not available (use 1.4.1_03 or later)!&quot;);
 651                     } else {
 652                         boolean printed = false;
 653                         for (int f = 0; f &lt; flags.length; f++) {
 654                             VM.Flag flag = flags[f];
 655                             if (name == null || flag.getName().equals(name)) {
 656 
 657                                 if (nonDefault &amp;&amp; (flag.getOrigin() == VM.Flags_DEFAULT)) {
 658                                     // only print flags which aren&#39;t their defaults
 659                                     continue;
 660                                 }
 661                                 out.println(flag.getName() + &quot; = &quot; + flag.getValue() + &quot; &quot; + flag.getOriginString());
 662                                 printed = true;
 663                             }
 664                         }
 665                         if (name != null &amp;&amp; !printed) {
 666                             out.println(&quot;Couldn&#39;t find flag: &quot; + name);
 667                         }
 668                     }
 669                 }
 670             }
 671         },
 672         new Command(&quot;help&quot;, &quot;help [ command ]&quot;, true) {
 673             public void doit(Tokens t) {
 674                 int tokens = t.countTokens();
 675                 Command cmd = null;
 676                 if (tokens == 1) {
 677                     cmd = findCommand(t.nextToken());
 678                 }
 679 
 680                 if (cmd != null) {
 681                     cmd.usage();
 682                 } else if (tokens == 0) {
 683                     out.println(&quot;Available commands:&quot;);
 684                     Object[] keys = commands.keySet().toArray();
 685                     Arrays.sort(keys, new Comparator&lt;&gt;() {
 686                              public int compare(Object o1, Object o2) {
 687                                  return o1.toString().compareTo(o2.toString());
 688                              }
 689                           });
 690                     for (int i = 0; i &lt; keys.length; i++) {
 691                         out.print(&quot;  &quot;);
 692                         out.println(((Command)commands.get(keys[i])).usage);
 693                     }
 694                 }
 695             }
 696         },
 697         new Command(&quot;history&quot;, &quot;history&quot;, true) {
 698             public void doit(Tokens t) {
 699                 int tokens = t.countTokens();
 700                 if (tokens != 0 &amp;&amp; (tokens != 1 || !t.nextToken().equals(&quot;-h&quot;))) {
 701                     usage();
 702                     return;
 703                 }
 704                 boolean printIndex = tokens == 0;
 705                 for (int i = 0; i &lt; history.size(); i++) {
 706                     if (printIndex) out.print(i + &quot; &quot;);
 707                     out.println(history.get(i));
 708                 }
 709             }
 710         },
 711         // decode raw address
 712         new Command(&quot;dis&quot;, &quot;dis address [length]&quot;, false) {
 713             public void doit(Tokens t) {
 714                 int tokens = t.countTokens();
 715                 if (tokens != 1 &amp;&amp; tokens != 2) {
 716                     usage();
 717                     return;
 718                 }
 719                 String name = t.nextToken();
 720                 Address addr = null;
 721                 int len = 0x10; // default length
 722                 try {
 723                     addr = VM.getVM().getDebugger().parseAddress(name);
 724                 } catch (NumberFormatException e) {
 725                    out.println(e);
 726                    return;
 727                 }
 728                 if (tokens == 2) {
 729                     try {
 730                         len = Integer.parseInt(t.nextToken());
 731                     } catch (NumberFormatException e) {
 732                         out.println(e);
 733                         return;
 734                     }
 735                 }
 736                 HTMLGenerator generator = new HTMLGenerator(false);
 737                 out.println(generator.genHTMLForRawDisassembly(addr, len));
 738             }
 739 
 740         },
 741         // decode codeblob or nmethod
 742         new Command(&quot;disassemble&quot;, &quot;disassemble address&quot;, false) {
 743             public void doit(Tokens t) {
 744                 int tokens = t.countTokens();
 745                 if (tokens != 1) {
 746                     usage();
 747                     return;
 748                 }
 749                 String name = t.nextToken();
 750                 Address addr = null;
 751                 try {
 752                     addr = VM.getVM().getDebugger().parseAddress(name);
 753                 } catch (NumberFormatException e) {
 754                    out.println(e);
 755                    return;
 756                 }
 757 
 758                 HTMLGenerator generator = new HTMLGenerator(false);
 759                 out.println(generator.genHTML(addr));
 760             }
 761         },
 762         // print Java bytecode disassembly
 763         new Command(&quot;jdis&quot;, &quot;jdis address&quot;, false) {
 764             public void doit(Tokens t) {
 765                 int tokens = t.countTokens();
 766                 if (tokens != 1) {
 767                     usage();
 768                     return;
 769                 }
 770                 Address a = VM.getVM().getDebugger().parseAddress(t.nextToken());
 771                 Method m = (Method)Metadata.instantiateWrapperFor(a);
 772                 HTMLGenerator html = new HTMLGenerator(false);
 773                 out.println(html.genHTML(m));
 774             }
 775         },
 776         new Command(&quot;revptrs&quot;, &quot;revptrs address&quot;, false) {
 777             public void doit(Tokens t) {
 778                 int tokens = t.countTokens();
 779                 if (tokens != 1 &amp;&amp; (tokens != 2 || !t.nextToken().equals(&quot;-c&quot;))) {
 780                     usage();
 781                     return;
 782                 }
 783                 boolean chase = tokens == 2;
 784                 ReversePtrs revptrs = VM.getVM().getRevPtrs();
 785                 if (revptrs == null) {
 786                     out.println(&quot;Computing reverse pointers...&quot;);
 787                     ReversePtrsAnalysis analysis = new ReversePtrsAnalysis();
 788                     final boolean[] complete = new boolean[1];
 789                     HeapProgressThunk thunk = new HeapProgressThunk() {
 790                             public void heapIterationFractionUpdate(double d) {}
 791                             public synchronized void heapIterationComplete() {
 792                                 complete[0] = true;
 793                                 notify();
 794                             }
 795                         };
 796                     analysis.setHeapProgressThunk(thunk);
 797                     analysis.run();
 798                     while (!complete[0]) {
 799                         synchronized (thunk) {
 800                             try {
 801                                 thunk.wait();
 802                             } catch (Exception e) {
 803                             }
 804                         }
 805                     }
 806                     revptrs = VM.getVM().getRevPtrs();
 807                     out.println(&quot;Done.&quot;);
 808                 }
 809                 Address a = VM.getVM().getDebugger().parseAddress(t.nextToken());
 810                 if (VM.getVM().getUniverse().heap().isInReserved(a)) {
 811                     OopHandle handle = a.addOffsetToAsOopHandle(0);
 812                     Oop oop = VM.getVM().getObjectHeap().newOop(handle);
 813                     ArrayList ptrs = revptrs.get(oop);
 814                     if (ptrs == null) {
 815                         out.println(&quot;no live references to &quot; + a);
 816                     } else {
 817                         if (chase) {
 818                             while (ptrs.size() == 1) {
 819                                 LivenessPathElement e = (LivenessPathElement)ptrs.get(0);
 820                                 ByteArrayOutputStream bos = new ByteArrayOutputStream();
 821                                 Oop.printOopValueOn(e.getObj(), new PrintStream(bos));
 822                                 out.println(bos.toString());
 823                                 ptrs = revptrs.get(e.getObj());
 824                             }
 825                         } else {
 826                             for (int i = 0; i &lt; ptrs.size(); i++) {
 827                                 LivenessPathElement e = (LivenessPathElement)ptrs.get(i);
 828                                 ByteArrayOutputStream bos = new ByteArrayOutputStream();
 829                                 Oop.printOopValueOn(e.getObj(), new PrintStream(bos));
 830                                 out.println(bos.toString());
 831                                 oop = e.getObj();
 832                             }
 833                         }
 834                     }
 835                 }
 836             }
 837         },
 838         new Command(&quot;printmdo&quot;, &quot;printmdo [ -a | expression ]&quot;, false) {
 839             // Print every MDO in the heap or the one referenced by expression.
 840             public void doit(Tokens t) {
 841                 if (t.countTokens() != 1) {
 842                     usage();
 843                 } else {
 844                     String s = t.nextToken();
 845                     if (s.equals(&quot;-a&quot;)) {
 846                         ClassLoaderDataGraph cldg = VM.getVM().getClassLoaderDataGraph();
 847                         cldg.classesDo(new ClassLoaderDataGraph.ClassVisitor() {
 848                                 public void visit(Klass k) {
 849                                     if (k instanceof InstanceKlass) {
 850                                         MethodArray methods = ((InstanceKlass)k).getMethods();
 851                                         for (int i = 0; i &lt; methods.length(); i++) {
 852                                             Method m = methods.at(i);
 853                                             MethodData mdo = m.getMethodData();
 854                                             if (mdo != null) {
 855                                                 out.println(&quot;MethodData &quot; + mdo.getAddress() + &quot; for &quot; +
 856                                                     &quot;method &quot; + m.getMethodHolder().getName().asString() + &quot;.&quot; +
 857                                                     m.getName().asString() +
 858                                                             m.getSignature().asString() + &quot;@&quot; + m.getAddress());
 859                                                 mdo.printDataOn(out);
 860                                     }
 861                                 }
 862                                     }
 863                                 }
 864                             }
 865                             );
 866                     } else {
 867                         Address a = VM.getVM().getDebugger().parseAddress(s);
 868                         MethodData mdo = (MethodData) Metadata.instantiateWrapperFor(a);
 869                         mdo.printDataOn(out);
 870                     }
 871                 }
 872             }
 873         },
 874         new Command(&quot;printall&quot;, &quot;printall&quot;, false) {
 875             // Print every MDO in the heap or the one referenced by expression.
 876             public void doit(Tokens t) {
 877                 if (t.countTokens() != 0) {
 878                     usage();
 879                 } else {
 880                     ClassLoaderDataGraph cldg = VM.getVM().getClassLoaderDataGraph();
 881                     cldg.classesDo(new ClassLoaderDataGraph.ClassVisitor() {
 882                             public void visit(Klass k) {
 883                                 if (k instanceof InstanceKlass &amp;&amp; ((InstanceKlass)k).getConstants().getCache() != null) {
 884                                     MethodArray methods = ((InstanceKlass)k).getMethods();
 885                                     for (int i = 0; i &lt; methods.length(); i++) {
 886                                         Method m = methods.at(i);
 887                                         HTMLGenerator gen = new HTMLGenerator(false);
 888                                         out.println(gen.genHTML(m));
 889                                     }
 890                                 }
 891                             }
 892                         }
 893                         );
 894                 }
 895             }
 896         },
 897         new Command(&quot;dumpideal&quot;, &quot;dumpideal { -a | id }&quot;, false) {
 898             // Do a full dump of the nodes reachabile from root in each compiler thread.
 899             public void doit(Tokens t) {
 900                 if (t.countTokens() != 1) {
 901                     usage();
 902                 } else {
 903                     String name = t.nextToken();
 904                     boolean all = name.equals(&quot;-a&quot;);
 905                     Threads threads = VM.getVM().getThreads();
 906                     for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
 907                         JavaThread thread = threads.getJavaThreadAt(i);
 908                         ByteArrayOutputStream bos = new ByteArrayOutputStream();
 909                         thread.printThreadIDOn(new PrintStream(bos));
 910                         if (all || bos.toString().equals(name)) {
 911                           if (thread instanceof CompilerThread) {
 912                             CompilerThread ct = (CompilerThread)thread;
 913                             out.println(ct);
 914                             ciEnv env = ct.env();
 915                             if (env != null) {
 916                               Compile c = env.compilerData();
 917                               c.root().dump(9999, out);
 918                             } else {
 919                               out.println(&quot;  not compiling&quot;);
 920                             }
 921                           }
 922                         }
 923                     }
 924                 }
 925             }
 926         },
 927         new Command(&quot;dumpcfg&quot;, &quot;dumpcfg { -a | id }&quot;, false) {
 928             // Dump the PhaseCFG for every compiler thread that has one live.
 929             public void doit(Tokens t) {
 930                 if (t.countTokens() != 1) {
 931                     usage();
 932                 } else {
 933                     String name = t.nextToken();
 934                     boolean all = name.equals(&quot;-a&quot;);
 935                     Threads threads = VM.getVM().getThreads();
 936                     for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
 937                         JavaThread thread = threads.getJavaThreadAt(i);
 938                         ByteArrayOutputStream bos = new ByteArrayOutputStream();
 939                         thread.printThreadIDOn(new PrintStream(bos));
 940                         if (all || bos.toString().equals(name)) {
 941                           if (thread instanceof CompilerThread) {
 942                             CompilerThread ct = (CompilerThread)thread;
 943                             out.println(ct);
 944                             ciEnv env = ct.env();
 945                             if (env != null) {
 946                               Compile c = env.compilerData();
 947                               c.cfg().dump(out);
 948                             }
 949                           }
 950                         }
 951                     }
 952                 }
 953             }
 954         },
 955         new Command(&quot;dumpilt&quot;, &quot;dumpilt { -a | id }&quot;, false) {
 956             // dumps the InlineTree of a C2 compile
 957             public void doit(Tokens t) {
 958                 if (t.countTokens() != 1) {
 959                     usage();
 960                 } else {
 961                     String name = t.nextToken();
 962                     boolean all = name.equals(&quot;-a&quot;);
 963                     Threads threads = VM.getVM().getThreads();
 964                     for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
 965                         JavaThread thread = threads.getJavaThreadAt(i);
 966                         ByteArrayOutputStream bos = new ByteArrayOutputStream();
 967                         thread.printThreadIDOn(new PrintStream(bos));
 968                         if (all || bos.toString().equals(name)) {
 969                             if (thread instanceof CompilerThread) {
 970                                 CompilerThread ct = (CompilerThread)thread;
 971                                 ciEnv env = ct.env();
 972                                 if (env != null) {
 973                                     Compile c = env.compilerData();
 974                                     InlineTree ilt = c.ilt();
 975                                     if (ilt != null) {
 976                                         ilt.print(out);
 977                                     }
 978                                 }
 979                             }
 980                         }
 981                     }
 982                 }
 983             }
 984         },
 985         new Command(&quot;vmstructsdump&quot;, &quot;vmstructsdump&quot;, false) {
 986             public void doit(Tokens t) {
 987                 if (t.countTokens() != 0) {
 988                     usage();
 989                     return;
 990                 }
 991 
 992                 // Dump a copy of the type database in a form that can
 993                 // be read back.
 994                 Iterator i = agent.getTypeDataBase().getTypes();
 995                 // Make sure the types are emitted in an order than can be read back in
 996                 HashSet&lt;String&gt; emitted = new HashSet&lt;&gt;();
 997                 Stack&lt;Type&gt; pending = new Stack&lt;&gt;();
 998                 while (i.hasNext()) {
 999                     Type n = (Type)i.next();
1000                     if (emitted.contains(n.getName())) {
1001                         continue;
1002                     }
1003 
1004                     while (n != null &amp;&amp; !emitted.contains(n.getName())) {
1005                         pending.push(n);
1006                         n = n.getSuperclass();
1007                     }
1008                     while (!pending.empty()) {
1009                         n = (Type)pending.pop();
1010                         dumpType(n);
1011                         emitted.add(n.getName());
1012                     }
1013                 }
1014                 i = agent.getTypeDataBase().getTypes();
1015                 while (i.hasNext()) {
1016                     dumpFields((Type)i.next(), false);
1017                 }
1018             }
1019         },
1020 
1021         new Command(&quot;inspect&quot;, &quot;inspect expression&quot;, false) {
1022             public void doit(Tokens t) {
1023                 if (t.countTokens() != 1) {
1024                     usage();
1025                 } else {
1026                     Address a = VM.getVM().getDebugger().parseAddress(t.nextToken());
1027                     SimpleTreeNode node = null;
1028                     if (VM.getVM().getUniverse().heap().isInReserved(a)) {
1029                         OopHandle handle = a.addOffsetToAsOopHandle(0);
1030                         Oop oop = VM.getVM().getObjectHeap().newOop(handle);
1031                         node = new OopTreeNodeAdapter(oop, null);
1032 
1033                         out.println(&quot;instance of &quot; + node.getValue() + &quot; @ &quot; + a +
1034                                     &quot; (size = &quot; + oop.getObjectSize() + &quot;)&quot;);
1035                     } else if (VM.getVM().getCodeCache().contains(a)) {
1036                         CodeBlob blob = VM.getVM().getCodeCache().findBlobUnsafe(a);
1037                         a = blob.headerBegin();
1038                     }
1039                     if (node == null) {
1040                         Type type = VM.getVM().getTypeDataBase().guessTypeForAddress(a);
1041                         if (type == null &amp;&amp; VM.getVM().isSharingEnabled()) {
1042                             // Check if the value falls in the _md_region
1043                             Address loc1 = a.getAddressAt(0);
1044                             FileMapInfo cdsFileMapInfo = VM.getVM().getFileMapInfo();
1045                             if (cdsFileMapInfo.inCopiedVtableSpace(loc1)) {
1046                                type = cdsFileMapInfo.getTypeForVptrAddress(loc1);
1047                             }
1048 
1049                         }
1050                         if (type != null) {
1051                             out.println(&quot;Type is &quot; + type.getName() + &quot; (size of &quot; + type.getSize() + &quot;)&quot;);
1052                             node = new CTypeTreeNodeAdapter(a, type, null);
1053                         }
1054                     }
1055                     if (node != null) {
1056                         printNode(node);
1057                     }
1058                 }
1059             }
1060         },
1061         new Command(&quot;jhisto&quot;, &quot;jhisto&quot;, false) {
1062             public void doit(Tokens t) {
1063                  ObjectHistogram histo = new ObjectHistogram();
1064                  histo.run(out, err);
1065             }
1066         },
1067         new Command(&quot;jstack&quot;, &quot;jstack [-v]&quot;, false) {
1068             public void doit(Tokens t) {
1069                 boolean verbose = false;
1070                 if (t.countTokens() &gt; 0 &amp;&amp; t.nextToken().equals(&quot;-v&quot;)) {
1071                     verbose = true;
1072                 }
1073                 StackTrace jstack = new StackTrace(verbose, true);
1074                 jstack.run(out);
1075             }
1076         },
1077         new Command(&quot;print&quot;, &quot;print expression&quot;, false) {
1078             public void doit(Tokens t) {
1079                 if (t.countTokens() != 1) {
1080                     usage();
1081                 } else {
1082                     Address a = VM.getVM().getDebugger().parseAddress(t.nextToken());
1083                     HTMLGenerator gen = new HTMLGenerator(false);
1084                     out.println(gen.genHTML(a));
1085                 }
1086             }
1087         },
1088         new Command(&quot;printas&quot;, &quot;printas type expression&quot;, false) {
1089             public void doit(Tokens t) {
1090                 if (t.countTokens() != 2) {
1091                     usage();
1092                 } else {
1093                     Type type = agent.getTypeDataBase().lookupType(t.nextToken());
1094                     Address a = VM.getVM().getDebugger().parseAddress(t.nextToken());
1095                     CTypeTreeNodeAdapter node = new CTypeTreeNodeAdapter(a, type, null);
1096 
1097                     out.println(&quot;pointer to &quot; + type + &quot; @ &quot; + a +
1098                                 &quot; (size = &quot; + type.getSize() + &quot;)&quot;);
1099                     printNode(node);
1100                 }
1101             }
1102         },
1103         new Command(&quot;printstatics&quot;, &quot;printstatics [ type ]&quot;, false) {
1104             public void doit(Tokens t) {
1105                 if (t.countTokens() &gt; 1) {
1106                     usage();
1107                 } else {
1108                     if (t.countTokens() == 0) {
1109                         out.println(&quot;All known static fields&quot;);
1110                         printNode(new CTypeTreeNodeAdapter(agent.getTypeDataBase().getTypes()));
1111                     } else {
1112                         Type type = agent.getTypeDataBase().lookupType(t.nextToken());
1113                         out.println(&quot;Static fields of &quot; + type.getName());
1114                         printNode(new CTypeTreeNodeAdapter(type));
1115                     }
1116                 }
1117             }
1118         },
1119         new Command(&quot;pmap&quot;, &quot;pmap&quot;, false) {
1120             public void doit(Tokens t) {
1121                 PMap pmap = new PMap();
1122                 pmap.run(out, debugger.getAgent().getDebugger());
1123             }
1124         },
1125         new Command(&quot;pstack&quot;, &quot;pstack [-v]&quot;, false) {
1126             public void doit(Tokens t) {
1127                 boolean verbose = false;
1128                 if (t.countTokens() &gt; 0 &amp;&amp; t.nextToken().equals(&quot;-v&quot;)) {
1129                     verbose = true;
1130                 }
1131                 PStack pstack = new PStack(verbose, true);
1132                 pstack.run(out, debugger.getAgent().getDebugger());
1133             }
1134         },
1135         new Command(&quot;quit&quot;, true) {
1136             public void doit(Tokens t) {
1137                 if (t.countTokens() != 0) {
1138                     usage();
1139                 } else {
1140                     debugger.detach();
1141                     quit = true;
1142                 }
1143             }
1144         },
1145         new Command(&quot;echo&quot;, &quot;echo [ true | false ]&quot;, true) {
1146             public void doit(Tokens t) {
1147                 if (t.countTokens() == 0) {
1148                     out.println(&quot;echo is &quot; + doEcho);
1149                 } else if (t.countTokens() == 1) {
1150                     doEcho = Boolean.valueOf(t.nextToken()).booleanValue();
1151                 } else {
1152                     usage();
1153                 }
1154             }
1155         },
1156         new Command(&quot;versioncheck&quot;, &quot;versioncheck [ true | false ]&quot;, true) {
1157             public void doit(Tokens t) {
1158                 if (t.countTokens() == 0) {
1159                     out.println(&quot;versioncheck is &quot; +
1160                                 (System.getProperty(&quot;sun.jvm.hotspot.runtime.VM.disableVersionCheck&quot;) == null));
1161                 } else if (t.countTokens() == 1) {
1162                     if (Boolean.valueOf(t.nextToken()).booleanValue()) {
1163                         System.setProperty(&quot;sun.jvm.hotspot.runtime.VM.disableVersionCheck&quot;, null);
1164                     } else {
1165                         System.setProperty(&quot;sun.jvm.hotspot.runtime.VM.disableVersionCheck&quot;, &quot;true&quot;);
1166                     }
1167                 } else {
1168                     usage();
1169                 }
1170             }
1171         },
1172         new Command(&quot;scanoops&quot;, &quot;scanoops start end [ type ]&quot;, false) {
1173             public void doit(Tokens t) {
1174                 if (t.countTokens() != 2 &amp;&amp; t.countTokens() != 3) {
1175                     usage();
1176                 } else {
1177                     long stride = VM.getVM().getAddressSize();
1178                     Address base = VM.getVM().getDebugger().parseAddress(t.nextToken());
1179                     Address end  = VM.getVM().getDebugger().parseAddress(t.nextToken());
1180                     Klass klass = null;
1181                     if (t.countTokens() == 1) {
1182                         klass = SystemDictionaryHelper.findInstanceKlass(t.nextToken());
1183                         if (klass == null) {
1184                             out.println(&quot;No such type.&quot;);
1185                             return;
1186                         }
1187                     }
1188                     while (base != null &amp;&amp; base.lessThan(end)) {
1189                         long step = stride;
1190                         OopHandle handle = base.addOffsetToAsOopHandle(0);
1191                         if (RobustOopDeterminator.oopLooksValid(handle)) {
1192                             try {
1193                                 Oop oop = VM.getVM().getObjectHeap().newOop(handle);
1194                                 if (klass == null || oop.getKlass().isSubtypeOf(klass))
1195                                     out.println(handle.toString() + &quot; &quot; + oop.getKlass().getName().asString());
1196                                 step = oop.getObjectSize();
1197                             } catch (UnknownOopException ex) {
1198                                 // ok
1199                             } catch (RuntimeException ex) {
1200                                 ex.printStackTrace();
1201                             }
1202                         }
1203                         base = base.addOffsetTo(step);
1204                     }
1205                 }
1206             }
1207         },
1208         new Command(&quot;intConstant&quot;, &quot;intConstant [ name [ value ] ]&quot;, false) {
1209             public void doit(Tokens t) {
1210                 if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 2) {
1211                     usage();
1212                     return;
1213                 }
1214                 HotSpotTypeDataBase db = (HotSpotTypeDataBase)agent.getTypeDataBase();
1215                 if (t.countTokens() == 1) {
1216                     String name = t.nextToken();
1217                     out.println(&quot;intConstant &quot; + name + &quot; &quot; + db.lookupIntConstant(name));
1218                 } else if (t.countTokens() == 0) {
1219                     Iterator i = db.getIntConstants();
1220                     while (i.hasNext()) {
1221                         String name = (String)i.next();
1222                         out.println(&quot;intConstant &quot; + name + &quot; &quot; + db.lookupIntConstant(name));
1223                     }
1224                 } else if (t.countTokens() == 2) {
1225                     String name = t.nextToken();
1226                     Integer value = Integer.valueOf(t.nextToken());
1227                     db.addIntConstant(name, value);
1228                 }
1229             }
1230         },
1231         new Command(&quot;longConstant&quot;, &quot;longConstant [ name [ value ] ]&quot;, false) {
1232             public void doit(Tokens t) {
1233                 if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 2) {
1234                     usage();
1235                     return;
1236                 }
1237                 HotSpotTypeDataBase db = (HotSpotTypeDataBase)agent.getTypeDataBase();
1238                 if (t.countTokens() == 1) {
1239                     String name = t.nextToken();
1240                     out.println(&quot;longConstant &quot; + name + &quot; &quot; + db.lookupLongConstant(name));
1241                 } else if (t.countTokens() == 0) {
1242                     Iterator i = db.getLongConstants();
1243                     while (i.hasNext()) {
1244                         String name = (String)i.next();
1245                         out.println(&quot;longConstant &quot; + name + &quot; &quot; + db.lookupLongConstant(name));
1246                     }
1247                 } else if (t.countTokens() == 2) {
1248                     String name = t.nextToken();
1249                     Long value = Long.valueOf(t.nextToken());
1250                     db.addLongConstant(name, value);
1251                 }
1252             }
1253         },
1254         new Command(&quot;field&quot;, &quot;field [ type [ name fieldtype isStatic offset address ] ]&quot;, false) {
1255             public void doit(Tokens t) {
1256                 if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 6) {
1257                     usage();
1258                     return;
1259                 }
1260                 if (t.countTokens() == 1) {
1261                     Type type = agent.getTypeDataBase().lookupType(t.nextToken());
1262                     dumpFields(type);
1263                 } else if (t.countTokens() == 0) {
1264                     Iterator i = agent.getTypeDataBase().getTypes();
1265                     while (i.hasNext()) {
1266                         dumpFields((Type)i.next());
1267                     }
1268                 } else {
1269                     BasicType containingType = (BasicType)agent.getTypeDataBase().lookupType(t.nextToken());
1270 
1271                     String fieldName = t.nextToken();
1272 
1273                     // The field&#39;s Type must already be in the database -- no exceptions
1274                     Type fieldType = agent.getTypeDataBase().lookupType(t.nextToken());
1275 
1276                     boolean isStatic = Boolean.valueOf(t.nextToken()).booleanValue();
1277                     long offset = Long.parseLong(t.nextToken());
1278                     Address staticAddress = parseAddress(t.nextToken());
1279                     if (isStatic &amp;&amp; staticAddress == null) {
1280                         staticAddress = lookup(containingType.getName() + &quot;::&quot; + fieldName);
1281                     }
1282 
1283                     // check to see if the field already exists
1284                     Iterator i = containingType.getFields();
1285                     while (i.hasNext()) {
1286                         Field f = (Field) i.next();
1287                         if (f.getName().equals(fieldName)) {
1288                             if (f.isStatic() != isStatic) {
1289                                 throw new RuntimeException(&quot;static/nonstatic mismatch: &quot; + t.input);
1290                             }
1291                             if (!isStatic) {
1292                                 if (f.getOffset() != offset) {
1293                                     throw new RuntimeException(&quot;bad redefinition of field offset: &quot; + t.input);
1294                                 }
1295                             } else {
1296                                 if (!f.getStaticFieldAddress().equals(staticAddress)) {
1297                                     throw new RuntimeException(&quot;bad redefinition of field location: &quot; + t.input);
1298                                 }
1299                             }
1300                             if (f.getType() != fieldType) {
1301                                 throw new RuntimeException(&quot;bad redefinition of field type: &quot; + t.input);
1302                             }
1303                             return;
1304                         }
1305                     }
1306 
1307                     // Create field by type
1308                     HotSpotTypeDataBase db = (HotSpotTypeDataBase)agent.getTypeDataBase();
1309                     db.createField(containingType,
1310                                    fieldName, fieldType,
1311                                    isStatic,
1312                                    offset,
1313                                    staticAddress);
1314 
1315                 }
1316             }
1317 
1318         },
1319         new Command(&quot;tokenize&quot;, &quot;tokenize ...&quot;, true) {
1320             public void doit(Tokens t) {
1321                 while (t.hasMoreTokens()) {
1322                     out.println(&quot;\&quot;&quot; + t.nextToken() + &quot;\&quot;&quot;);
1323                 }
1324             }
1325         },
1326         new Command(&quot;type&quot;, &quot;type [ type [ name super isOop isInteger isUnsigned size ] ]&quot;, false) {
1327             public void doit(Tokens t) {
1328                 if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 6) {
1329                     usage();
1330                     return;
1331                 }
1332                 if (t.countTokens() == 6) {
1333                     String typeName = t.nextToken();
1334                     String superclassName = t.nextToken();
1335                     if (superclassName.equals(&quot;null&quot;)) {
1336                         superclassName = null;
1337                     }
1338                     boolean isOop = Boolean.valueOf(t.nextToken()).booleanValue();
1339                     boolean isInteger = Boolean.valueOf(t.nextToken()).booleanValue();
1340                     boolean isUnsigned = Boolean.valueOf(t.nextToken()).booleanValue();
1341                     long size = Long.parseLong(t.nextToken());
1342 
1343                     BasicType type = null;
1344                     try {
1345                         type = (BasicType)agent.getTypeDataBase().lookupType(typeName);
1346                     } catch (RuntimeException e) {
1347                     }
1348                     if (type != null) {
1349                         if (type.isOopType() != isOop) {
1350                             throw new RuntimeException(&quot;oop mismatch in type definition: &quot; + t.input);
1351                         }
1352                         if (type.isCIntegerType() != isInteger) {
1353                             throw new RuntimeException(&quot;integer type mismatch in type definition: &quot; + t.input);
1354                         }
1355                         if (type.isCIntegerType() &amp;&amp; (((CIntegerType)type).isUnsigned()) != isUnsigned) {
1356                             throw new RuntimeException(&quot;unsigned mismatch in type definition: &quot; + t.input);
1357                         }
1358                         if (type.getSuperclass() == null) {
1359                             if (superclassName != null) {
1360                                 if (type.getSize() == -1) {
1361                                     type.setSuperclass(agent.getTypeDataBase().lookupType(superclassName));
1362                                 } else {
1363                                     throw new RuntimeException(&quot;unexpected superclass in type definition: &quot; + t.input);
1364                                 }
1365                             }
1366                         } else {
1367                             if (superclassName == null) {
1368                                 throw new RuntimeException(&quot;missing superclass in type definition: &quot; + t.input);
1369                             }
1370                             if (!type.getSuperclass().getName().equals(superclassName)) {
1371                                 throw new RuntimeException(&quot;incorrect superclass in type definition: &quot; + t.input);
1372                             }
1373                         }
1374                         if (type.getSize() != size) {
1375                             if (type.getSize() == -1) {
1376                                 type.setSize(size);
1377                             }
1378                             throw new RuntimeException(&quot;size mismatch in type definition: &quot; + t.input);
1379                         }
1380                         return;
1381                     }
1382 
1383                     // Create type
1384                     HotSpotTypeDataBase db = (HotSpotTypeDataBase)agent.getTypeDataBase();
1385                     db.createType(typeName, superclassName, isOop, isInteger, isUnsigned, size);
1386                 } else if (t.countTokens() == 1) {
1387                     Type type = agent.getTypeDataBase().lookupType(t.nextToken());
1388                     dumpType(type);
1389                 } else {
1390                     Iterator i = agent.getTypeDataBase().getTypes();
1391                     // Make sure the types are emitted in an order than can be read back in
1392                     HashSet&lt;String&gt; emitted = new HashSet&lt;&gt;();
1393                     Stack&lt;Type&gt; pending = new Stack&lt;&gt;();
1394                     while (i.hasNext()) {
1395                         Type n = (Type)i.next();
1396                         if (emitted.contains(n.getName())) {
1397                             continue;
1398                         }
1399 
1400                         while (n != null &amp;&amp; !emitted.contains(n.getName())) {
1401                             pending.push(n);
1402                             n = n.getSuperclass();
1403                         }
1404                         while (!pending.empty()) {
1405                             n = (Type)pending.pop();
1406                             dumpType(n);
1407                             emitted.add(n.getName());
1408                         }
1409                     }
1410                 }
1411             }
1412 
1413         },
1414         new Command(&quot;source&quot;, &quot;source filename&quot;, true) {
1415             public void doit(Tokens t) {
1416                 if (t.countTokens() != 1) {
1417                     usage();
1418                     return;
1419                 }
1420                 String file = t.nextToken();
1421                 BufferedReader savedInput = in;
1422                 try {
1423                     BufferedReader input = new BufferedReader(new InputStreamReader(new FileInputStream(file)));
1424                     in = input;
1425                     run(false);
1426                 } catch (Exception e) {
1427                     out.println(&quot;Error: &quot; + e);
1428                     if (verboseExceptions) {
1429                         e.printStackTrace(out);
1430                     }
1431                 } finally {
1432                     in = savedInput;
1433                 }
1434 
1435             }
1436         },
1437         new Command(&quot;search&quot;, &quot;search [ heap | perm | rawheap | codecache | threads ] value&quot;, false) {
1438             public void doit(Tokens t) {
1439                 if (t.countTokens() != 2) {
1440                     usage();
1441                     return;
1442                 }
1443                 String type = t.nextToken();
1444                 final Address value = VM.getVM().getDebugger().parseAddress(t.nextToken());
1445                 final long stride = VM.getVM().getAddressSize();
1446                 if (type.equals(&quot;threads&quot;)) {
1447                     Threads threads = VM.getVM().getThreads();
1448                     for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
1449                         JavaThread thread = threads.getJavaThreadAt(i);
1450                         Address base = thread.getStackBase();
1451                         Address end = thread.getLastJavaSP();
1452                         if (end == null) continue;
1453                         if (end.lessThan(base)) {
1454                             Address tmp = base;
1455                             base = end;
1456                             end = tmp;
1457                         }
1458                         //out.println(&quot;Searching &quot; + base + &quot; &quot; + end);
1459                         while (base != null &amp;&amp; base.lessThan(end)) {
1460                             Address val = base.getAddressAt(0);
1461                             if (AddressOps.equal(val, value)) {
1462                                 ByteArrayOutputStream bos = new ByteArrayOutputStream();
1463                                 thread.printThreadIDOn(new PrintStream(bos));
1464                                 out.println(&quot;found on the stack of thread &quot; + bos.toString() + &quot; at &quot; + base);
1465                             }
1466                             base = base.addOffsetTo(stride);
1467                         }
1468                     }
1469                 } else if (type.equals(&quot;rawheap&quot;)) {
1470                     RawHeapVisitor iterator = new RawHeapVisitor() {
1471                             public void prologue(long used) {
1472                             }
1473 
1474                             public void visitAddress(Address addr) {
1475                                 Address val = addr.getAddressAt(0);
1476                                 if (AddressOps.equal(val, value)) {
1477                                         out.println(&quot;found at &quot; + addr);
1478                                 }
1479                             }
1480                             public void visitCompOopAddress(Address addr) {
1481                                 Address val = addr.getCompOopAddressAt(0);
1482                                 if (AddressOps.equal(val, value)) {
1483                                     out.println(&quot;found at &quot; + addr);
1484                                 }
1485                             }
1486                             public void epilogue() {
1487                             }
1488                         };
1489                     VM.getVM().getObjectHeap().iterateRaw(iterator);
1490                 } else if (type.equals(&quot;heap&quot;)) {
1491                     HeapVisitor iterator = new DefaultHeapVisitor() {
1492                             public boolean doObj(Oop obj) {
1493                                 int index = 0;
1494                                 Address start = obj.getHandle();
1495                                 long end = obj.getObjectSize();
1496                                 while (index &lt; end) {
1497                                     Address val = start.getAddressAt(index);
1498                                     if (AddressOps.equal(val, value)) {
1499                                         out.println(&quot;found in &quot; + obj.getHandle());
1500                                         break;
1501                                     }
1502                                     index += 4;
1503                                 }
1504                                 return false;
1505                             }
1506                         };
1507                         VM.getVM().getObjectHeap().iterate(iterator);
1508                 } else if (type.equals(&quot;codecache&quot;)) {
1509                     CodeCacheVisitor v = new CodeCacheVisitor() {
1510                             public void prologue(Address start, Address end) {
1511                             }
1512                             public void visit(CodeBlob blob) {
1513                                 boolean printed = false;
1514                                 Address base = blob.getAddress();
1515                                 Address end = base.addOffsetTo(blob.getSize());
1516                                 while (base != null &amp;&amp; base.lessThan(end)) {
1517                                     Address val = base.getAddressAt(0);
1518                                     if (AddressOps.equal(val, value)) {
1519                                         if (!printed) {
1520                                             printed = true;
1521                                             try {
1522                                                 blob.printOn(out);
1523                                             } catch (Exception e) {
1524                                                 out.println(&quot;Exception printing blob at &quot; + base);
1525                                                 e.printStackTrace();
1526                                             }
1527                                         }
1528                                         out.println(&quot;found at &quot; + base + &quot;\n&quot;);
1529                                     }
1530                                     base = base.addOffsetTo(stride);
1531                                 }
1532                             }
1533                             public void epilogue() {
1534                             }
1535 
1536 
1537                         };
1538                     VM.getVM().getCodeCache().iterate(v);
1539 
1540                 }
1541             }
1542         },
1543         new Command(&quot;dumpcodecache&quot;, &quot;dumpcodecache&quot;, false) {
1544             public void doit(Tokens t) {
1545                 if (t.countTokens() != 0) {
1546                     usage();
1547                 } else {
1548                     final PrintStream fout = out;
1549                     final HTMLGenerator gen = new HTMLGenerator(false);
1550                     CodeCacheVisitor v = new CodeCacheVisitor() {
1551                             public void prologue(Address start, Address end) {
1552                             }
1553                             public void visit(CodeBlob blob) {
1554                                 fout.println(gen.genHTML(blob.contentBegin()));
1555                             }
1556                             public void epilogue() {
1557                             }
1558 
1559 
1560                         };
1561                     VM.getVM().getCodeCache().iterate(v);
1562                 }
1563             }
1564         },
1565         new Command(&quot;where&quot;, &quot;where { -a | id }&quot;, false) {
1566             public void doit(Tokens t) {
1567                 if (t.countTokens() != 1) {
1568                     usage();
1569                 } else {
1570                     String name = t.nextToken();
1571                     Threads threads = VM.getVM().getThreads();
1572                     boolean all = name.equals(&quot;-a&quot;);
1573                     for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
1574                         JavaThread thread = threads.getJavaThreadAt(i);
1575                         ByteArrayOutputStream bos = new ByteArrayOutputStream();
1576                         thread.printThreadIDOn(new PrintStream(bos));
1577                         if (all || bos.toString().equals(name)) {
1578                             out.println(&quot;Thread &quot; + bos.toString() + &quot; Address: &quot; + thread.getAddress());
1579                             HTMLGenerator gen = new HTMLGenerator(false);
1580                             try {
1581                                 out.println(gen.genHTMLForJavaStackTrace(thread));
1582                             } catch (Exception e) {
1583                                 err.println(&quot;Error: &quot; + e);
1584                                 if (verboseExceptions) {
1585                                     e.printStackTrace(err);
1586                                 }
1587                             }
1588                             if (!all) return;
1589                         }
1590                     }
1591                     if (!all) out.println(&quot;Couldn&#39;t find thread &quot; + name);
1592                 }
1593             }
1594         },
1595         new Command(&quot;thread&quot;, &quot;thread { -a | id }&quot;, false) {
1596             public void doit(Tokens t) {
1597                 if (t.countTokens() != 1) {
1598                     usage();
1599                 } else {
1600                     String name = t.nextToken();
1601                     Threads threads = VM.getVM().getThreads();
1602                     boolean all = name.equals(&quot;-a&quot;);
1603                     for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
1604                         JavaThread thread = threads.getJavaThreadAt(i);
1605                         ByteArrayOutputStream bos = new ByteArrayOutputStream();
1606                         thread.printThreadIDOn(new PrintStream(bos));
1607                         if (all || bos.toString().equals(name)) {
1608                             out.println(&quot;Thread &quot; + bos.toString() + &quot; Address &quot; + thread.getAddress());
1609                             thread.printInfoOn(out);
1610                             out.println(&quot; &quot;);
1611                             if (!all) return;
1612                         }
1613                     }
1614                     if (!all) {
1615                         out.println(&quot;Couldn&#39;t find thread &quot; + name);
1616                     }
1617                 }
1618             }
1619         },
1620 
1621         new Command(&quot;threads&quot;, false) {
1622             public void doit(Tokens t) {
1623                 if (t.countTokens() != 0) {
1624                     usage();
1625                 } else {
1626                     Threads threads = VM.getVM().getThreads();
1627                     for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
1628                         JavaThread thread = threads.getJavaThreadAt(i);
1629                         thread.printThreadIDOn(out);
1630                         out.println(&quot; &quot; + thread.getThreadName());
1631                         thread.printInfoOn(out);
1632                         out.println(&quot;\n...&quot;);
1633                     }
1634                 }
1635             }
1636         },
1637 
1638         new Command(&quot;livenmethods&quot;, false) {
1639             public void doit(Tokens t) {
1640                 if (t.countTokens() != 0) {
1641                     usage();
1642                 } else {
1643                     ArrayList&lt;NMethod&gt; nmethods = new ArrayList&lt;&gt;();
1644                     Threads threads = VM.getVM().getThreads();
1645                     HTMLGenerator gen = new HTMLGenerator(false);
1646                     for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
1647                         JavaThread thread = threads.getJavaThreadAt(i);
1648                         try {
1649                             for (JavaVFrame vf = thread.getLastJavaVFrameDbg(); vf != null; vf = vf.javaSender()) {
1650                                 if (vf instanceof CompiledVFrame) {
1651                                     NMethod c = ((CompiledVFrame)vf).getCode();
1652                                     if (!nmethods.contains(c)) {
1653                                         nmethods.add(c);
1654                                         out.println(gen.genHTML(c));
1655                                     }
1656                                 }
1657                             }
1658                         } catch (Exception e) {
1659                             e.printStackTrace();
1660                         }
1661                     }
1662                 }
1663             }
1664         },
1665         new Command(&quot;g1regiondetails&quot;, false) {
1666             public void doit(Tokens t) {
1667                 if (t.countTokens() != 0) {
1668                     usage();
1669                 } else {
1670                     CollectedHeap heap = VM.getVM().getUniverse().heap();
1671                     if (!(heap instanceof G1CollectedHeap)) {
1672                         out.println(&quot;This command is valid only for G1GC.&quot;);
1673                         return;
1674                     }
1675                     out.println(&quot;Region Details:&quot;);
1676                     ((G1CollectedHeap)heap).printRegionDetails(out);
1677                 }
1678             }
1679         },
1680         new Command(&quot;universe&quot;, false) {
1681             public void doit(Tokens t) {
1682                 if (t.countTokens() != 0) {
1683                     usage();
1684                 } else {
1685                     Universe u = VM.getVM().getUniverse();
1686                     out.println(&quot;Heap Parameters:&quot;);
1687                     u.heap().printOn(out);
1688                 }
1689             }
1690         },
1691         new Command(&quot;verbose&quot;, &quot;verbose true | false&quot;, true) {
1692             public void doit(Tokens t) {
1693                 if (t.countTokens() != 1) {
1694                     usage();
1695                 } else {
1696                     verboseExceptions = Boolean.valueOf(t.nextToken()).booleanValue();
1697                 }
1698             }
1699         },
1700         new Command(&quot;assert&quot;, &quot;assert true | false&quot;, true) {
1701             public void doit(Tokens t) {
1702                 if (t.countTokens() != 1) {
1703                     usage();
1704                 } else {
1705                     Assert.ASSERTS_ENABLED = Boolean.valueOf(t.nextToken()).booleanValue();
1706                 }
1707             }
1708         },
1709         new Command(&quot;dumpclass&quot;, &quot;dumpclass {address | name} [directory]&quot;, false) {
1710             public void doit(Tokens t) {
1711                 int tokenCount = t.countTokens();
1712                 if (tokenCount != 1 &amp;&amp; tokenCount != 2) {
1713                     usage();
1714                     return;
1715                 }
1716 
1717                 /* Find the InstanceKlass for specified class name or class address. */
1718                 InstanceKlass ik = null;
1719                 String classname = t.nextToken();
1720                 if (classname.startsWith(&quot;0x&quot;)) {
1721                     // treat it as address
1722                     VM vm = VM.getVM();
1723                     Address addr = vm.getDebugger().parseAddress(classname);
1724                     Metadata metadata = Metadata.instantiateWrapperFor(addr.addOffsetTo(0));
1725                     if (metadata instanceof InstanceKlass) {
1726                         ik = (InstanceKlass) metadata;
1727                     } else {
1728                         System.out.println(&quot;Specified address is not an InstanceKlass&quot;);
1729                         return;
1730                     }
1731                 } else {
1732                     ik = SystemDictionaryHelper.findInstanceKlass(classname);
1733                     if (ik == null) {
1734                         System.out.println(&quot;class not found: &quot; + classname);
1735                         return;
1736                     }
1737                 }
1738 
1739                 /* Compute filename for class. */
1740                 StringBuffer buf = new StringBuffer();
1741                 if (tokenCount &gt; 1) {
1742                     buf.append(t.nextToken());
1743                 } else {
1744                     buf.append(&#39;.&#39;);
1745                 }
1746                 buf.append(File.separatorChar);
1747                 buf.append(ik.getName().asString().replace(&#39;/&#39;, File.separatorChar));
1748                 buf.append(&quot;.class&quot;);
1749                 String fileName = buf.toString();
1750                 File file = new File(fileName);
1751 
1752                 /* Dump the class file. */
1753                 try {
1754                     int index = fileName.lastIndexOf(File.separatorChar);
1755                     File dir = new File(fileName.substring(0, index));
1756                     dir.mkdirs();
1757                     try (FileOutputStream fos = new FileOutputStream(file)) {
1758                         ClassWriter cw = new ClassWriter(ik, fos);
1759                         cw.write();
1760                     }
1761                 } catch (Exception e) {
1762                     err.println(&quot;Error: &quot; + e);
1763                     if (verboseExceptions) {
1764                         e.printStackTrace(err);
1765                     }
1766                 }
1767             }
1768         },
1769         new Command(&quot;sysprops&quot;, &quot;sysprops&quot;, false) {
1770             public void doit(Tokens t) {
1771                 if (t.countTokens() != 0) {
1772                     usage();
1773                     return;
1774                 }
1775                 SysPropsDumper sysProps = new SysPropsDumper();
1776                 sysProps.run();
1777             }
1778         },
1779         new Command(&quot;dumpheap&quot;, &quot;dumpheap [filename]&quot;, false) {
1780             public void doit(Tokens t) {
1781                 if (t.countTokens() &gt; 1) {
1782                     usage();
1783                 } else {
1784                     JMap jmap = new JMap();
1785                     String filename;
1786                     if (t.countTokens() == 1) {
1787                         filename = t.nextToken();
1788                     } else {
1789                         filename = &quot;heap.bin&quot;;;
1790                     }
1791                     try {
1792                         jmap.writeHeapHprofBin(filename);
1793                     } catch (Exception e) {
1794                         err.println(&quot;Error: &quot; + e);
1795                         if (verboseExceptions) {
1796                             e.printStackTrace(err);
1797                         }
1798                     }
1799                 }
1800             }
1801         },
1802         new Command(&quot;class&quot;, &quot;class name&quot;, false) {
1803             public void doit(Tokens t) {
1804                 if (t.countTokens() != 1) {
1805                     usage();
1806                     return;
1807                 }
1808                 String classname = t.nextToken();
1809                 InstanceKlass ik = SystemDictionaryHelper.findInstanceKlass(classname);
1810                 if (ik == null) {
1811                     System.out.println(&quot;class not found: &quot; + classname);
1812                 } else {
1813                     System.out.println(ik.getName().asString() + &quot; @&quot; + ik.getAddress());
1814                 }
1815             }
1816         },
1817         new Command(&quot;classes&quot;, &quot;classes&quot;, false) {
1818             public void doit(Tokens t) {
1819                 if (t.countTokens() != 0) {
1820                     usage();
1821                     return;
1822                 }
1823                 ClassLoaderDataGraph cldg = VM.getVM().getClassLoaderDataGraph();
1824                 cldg.classesDo(new ClassLoaderDataGraph.ClassVisitor() {
1825                         public void visit(Klass k) {
1826                             System.out.println(k.getName().asString() + &quot; @&quot; + k.getAddress());
1827                         }
1828                     }
1829                 );
1830             }
1831         },
1832     };
1833 
1834     private boolean verboseExceptions = false;
1835     private ArrayList&lt;String&gt; history = new ArrayList&lt;&gt;();
1836     private HashMap&lt;String, Command&gt; commands = new HashMap&lt;&gt;();
1837     private boolean doEcho = false;
1838 
1839     private Command findCommand(String key) {
1840         return (Command)commands.get(key);
1841     }
1842 
1843     public void printPrompt() {
1844         out.print(&quot;hsdb&gt; &quot;);
1845     }
1846 
1847     private DebuggerInterface debugger;
1848     private HotSpotAgent agent;
1849     private JSJavaScriptEngine jsengine;
1850     private BufferedReader in;
1851     private PrintStream out;
1852     private PrintStream err;
1853 
1854     // called before debuggee attach
1855     private void preAttach() {
1856         // nothing for now..
1857     }
1858 
1859     // called after debuggee attach
1860     private void postAttach() {
1861         /*
1862          * JavaScript engine no longer works. For now disable it. Eventually we will remove it.
1863         // create JavaScript engine and start it
1864         try {
1865             jsengine = new JSJavaScriptEngine() {
1866                         private ObjectReader reader = new ObjectReader();
1867                         private JSJavaFactory factory = new JSJavaFactoryImpl();
1868                         public ObjectReader getObjectReader() {
1869                             return reader;
1870                         }
1871                         public JSJavaFactory getJSJavaFactory() {
1872                             return factory;
1873                         }
1874                         protected void quit() {
1875                             debugger.detach();
1876                             quit = true;
1877                         }
1878                         protected BufferedReader getInputReader() {
1879                             return in;
1880                         }
1881                         protected PrintStream getOutputStream() {
1882                             return out;
1883                         }
1884                         protected PrintStream getErrorStream() {
1885                             return err;
1886                         }
1887                    };
1888             try {
1889                 jsengine.defineFunction(this,
1890                      this.getClass().getMethod(&quot;registerCommand&quot;,
1891                                 new Class[] {
1892                                      String.class, String.class, String.class
1893                                 }));
1894             } catch (NoSuchMethodException exp) {
1895                   // should not happen, see below...!!
1896                   exp.printStackTrace();
1897             }
1898             jsengine.start();
1899         }
1900         catch (Exception ex) {
1901             System.out.println(&quot;Warning! JS Engine can&#39;t start, some commands will not be available.&quot;);
1902             if (verboseExceptions) {
1903                 ex.printStackTrace(out);
1904             }
1905         }
1906         */
1907     }
1908 
1909     public void registerCommand(String cmd, String usage, final String func) {
1910         commands.put(cmd, new Command(cmd, usage, false) {
1911                               public void doit(Tokens t) {
1912                                   final int len = t.countTokens();
1913                                   Object[] args = new Object[len];
1914                                   for (int i = 0; i &lt; len; i++) {
1915                                       args[i] = t.nextToken();
1916                                   }
1917                                   jsengine.call(func, args);
1918                               }
1919                           });
1920     }
1921 
1922     public void setOutput(PrintStream o) {
1923         out = o;
1924     }
1925 
1926     public void setErr(PrintStream e) {
1927         err = e;
1928     }
1929 
1930     public CommandProcessor(DebuggerInterface debugger, BufferedReader in, PrintStream out, PrintStream err) {
1931         this.debugger = debugger;
1932         this.agent = debugger.getAgent();
1933         this.in = in;
1934         this.out = out;
1935         this.err = err;
1936         for (int i = 0; i &lt; commandList.length; i++) {
1937             Command c = commandList[i];
1938             if (commands.get(c.name) != null) {
1939                 throw new InternalError(c.name + &quot; has multiple definitions&quot;);
1940             }
1941             commands.put(c.name, c);
1942         }
1943         if (debugger.isAttached()) {
1944             postAttach();
1945         }
1946     }
1947 
1948 
1949     public void run(boolean prompt) {
1950         // Process interactive commands.
1951         while (!quit) {
1952             if (prompt) printPrompt();
1953             String ln = null;
1954             try {
1955                 ln = in.readLine();
1956             } catch (IOException e) {
1957             }
1958             if (ln == null) {
1959                 if (prompt) err.println(&quot;Input stream closed.&quot;);
1960                 return;
1961             }
1962 
1963             executeCommand(ln, prompt);
1964         }
1965     }
1966 
1967     static Pattern historyPattern = Pattern.compile(&quot;((!\\*)|(!\\$)|(!!-?)|(!-?[0-9][0-9]*)|(![a-zA-Z][^ ]*))&quot;);
1968 
1969     public void executeCommand(String ln, boolean putInHistory) {
1970         if (ln.indexOf(&#39;!&#39;) != -1) {
1971             int size = history.size();
1972             if (size == 0) {
1973                 ln = &quot;&quot;;
1974                 err.println(&quot;History is empty&quot;);
1975             } else {
1976                 StringBuffer result = new StringBuffer();
1977                 Matcher m = historyPattern.matcher(ln);
1978                 int start = 0;
1979                 while (m.find()) {
1980                     if (m.start() &gt; start) {
1981                         result.append(ln.substring(start, m.start() - start));
1982                     }
1983                     start = m.end();
1984 
1985                     String cmd = m.group();
1986                     if (cmd.equals(&quot;!!&quot;)) {
1987                         result.append((String)history.get(history.size() - 1));
1988                     } else if (cmd.equals(&quot;!!-&quot;)) {
1989                         Tokens item = new Tokens((String)history.get(history.size() - 1));
1990                         item.trim(1);
1991                         result.append(item.join(&quot; &quot;));
1992                     } else if (cmd.equals(&quot;!*&quot;)) {
1993                         Tokens item = new Tokens((String)history.get(history.size() - 1));
1994                         item.nextToken();
1995                         result.append(item.join(&quot; &quot;));
1996                     } else if (cmd.equals(&quot;!$&quot;)) {
1997                         Tokens item = new Tokens((String)history.get(history.size() - 1));
1998                         result.append(item.at(item.countTokens() - 1));
1999                     } else {
2000                         String tail = cmd.substring(1);
2001                         switch (tail.charAt(0)) {
2002                         case &#39;0&#39;:
2003                         case &#39;1&#39;:
2004                         case &#39;2&#39;:
2005                         case &#39;3&#39;:
2006                         case &#39;4&#39;:
2007                         case &#39;5&#39;:
2008                         case &#39;6&#39;:
2009                         case &#39;7&#39;:
2010                         case &#39;8&#39;:
2011                         case &#39;9&#39;:
2012                         case &#39;-&#39;: {
2013                             int index = Integer.parseInt(tail);
2014                             if (index &lt; 0) {
2015                                 index = history.size() + index;
2016                             }
2017                             if (index &gt; size) {
2018                                 err.println(&quot;No such history item&quot;);
2019                             } else {
2020                                 result.append((String)history.get(index));
2021                             }
2022                             break;
2023                         }
2024                         default: {
2025                             for (int i = history.size() - 1; i &gt;= 0; i--) {
2026                                 String s = (String)history.get(i);
2027                                 if (s.startsWith(tail)) {
2028                                     result.append(s);
2029                                 }
2030                             }
2031                         }
2032                         }
2033                     }
2034                 }
2035                 if (result.length() == 0) {
2036                     err.println(&quot;malformed history reference&quot;);
2037                     ln = &quot;&quot;;
2038                 } else {
2039                     if (start &lt; ln.length()) {
2040                         result.append(ln.substring(start));
2041                     }
2042                     ln = result.toString();
2043                     if (!doEcho) {
2044                         out.println(ln);
2045                     }
2046                 }
2047             }
2048         }
2049 
2050         if (doEcho) {
2051             out.println(&quot;+ &quot; + ln);
2052         }
2053 
2054         PrintStream redirect = null;
2055         Tokens t = new Tokens(ln);
2056         if (t.hasMoreTokens()) {
2057             boolean error = false;
2058             if (putInHistory) history.add(ln);
2059             int len = t.countTokens();
2060             if (len &gt; 2) {
2061                 String r = t.at(len - 2);
2062                 if (r.equals(&quot;&gt;&quot;) || r.equals(&quot;&gt;&gt;&quot;)) {
2063                     boolean append = r.length() == 2;
2064                     String file = t.at(len - 1);
2065                     try {
2066                         redirect = new PrintStream(new BufferedOutputStream(new FileOutputStream(file, append)));
2067                         t.trim(2);
2068                     } catch (Exception e) {
2069                         out.println(&quot;Error: &quot; + e);
2070                         if (verboseExceptions) {
2071                             e.printStackTrace(out);
2072                         }
2073                         error = true;
2074                     }
2075                 }
2076             }
2077             if (!error) {
2078                 PrintStream savedout = out;
2079                 if (redirect != null) {
2080                     out = redirect;
2081                 }
2082                 try {
2083                     executeCommand(t);
2084                 } catch (Exception e) {
2085                     err.println(&quot;Error: &quot; + e);
2086                     if (verboseExceptions) {
2087                         e.printStackTrace(err);
2088                     }
2089                 } finally {
2090                     if (redirect != null) {
2091                         out = savedout;
2092                         redirect.close();
2093                     }
2094                 }
2095             }
2096         }
2097     }
2098 
2099     void executeCommand(Tokens args) {
2100         String cmd = args.nextToken();
2101 
2102         Command doit = findCommand(cmd);
2103 
2104         /*
2105          * Check for an unknown command
2106          */
2107         if (doit == null) {
2108             out.println(&quot;Unrecognized command.  Try help...&quot;);
2109         } else if (!debugger.isAttached() &amp;&amp; !doit.okIfDisconnected) {
2110             out.println(&quot;Command not valid until attached to a VM&quot;);
2111         } else {
2112             try {
2113                 doit.doit(args);
2114             } catch (Exception e) {
2115                 out.println(&quot;Error: &quot; + e);
2116                 if (verboseExceptions) {
2117                     e.printStackTrace(out);
2118                 }
2119             }
2120         }
2121     }
2122 }
    </pre>
  </body>
</html>
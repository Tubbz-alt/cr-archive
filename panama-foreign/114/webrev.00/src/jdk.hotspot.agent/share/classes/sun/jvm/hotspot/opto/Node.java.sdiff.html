<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/opto/Node.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MultiNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Node_Array.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/opto/Node.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.opto;
 26 
 27 import java.io.*;
 28 import java.lang.reflect.Constructor;
 29 import java.util.*;
 30 import sun.jvm.hotspot.debugger.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.oops.*;
 33 import sun.jvm.hotspot.types.*;


 34 
 35 public class Node extends VMObject {
 36   static {
 37     VM.registerVMInitializedObserver(new Observer() {
 38         public void update(Observable o, Object data) {
 39           initialize(VM.getVM().getTypeDataBase());
 40         }
 41       });
 42   }
 43 
 44   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
 45     Type type      = db.lookupType(&quot;Node&quot;);
 46     outmaxField = new CIntField(type.getCIntegerField(&quot;_outmax&quot;), 0);
 47     outcntField = new CIntField(type.getCIntegerField(&quot;_outcnt&quot;), 0);
 48     maxField = new CIntField(type.getCIntegerField(&quot;_max&quot;), 0);
 49     cntField = new CIntField(type.getCIntegerField(&quot;_cnt&quot;), 0);
 50     idxField = new CIntField(type.getCIntegerField(&quot;_idx&quot;), 0);
 51     outField = type.getAddressField(&quot;_out&quot;);
 52     inField = type.getAddressField(&quot;_in&quot;);
 53 
 54     nodeType = db.lookupType(&quot;Node&quot;);
 55 
<span class="line-modified"> 56     virtualConstructor = new VirtualBaseConstructor(db, nodeType, &quot;sun.jvm.hotspot.opto&quot;, Node.class);</span>
 57   }
 58 
 59   private static CIntField outmaxField;
 60   private static CIntField outcntField;
 61   private static CIntField maxField;
 62   private static CIntField cntField;
 63   private static CIntField idxField;
 64   private static AddressField outField;
 65   private static AddressField inField;
 66 
<span class="line-modified"> 67   private static VirtualBaseConstructor virtualConstructor;</span>
 68 
 69   private static Type nodeType;
 70 
<span class="line-modified"> 71   static HashMap nodes = new HashMap();</span>
 72 
 73   static HashMap constructors = new HashMap();
 74 
 75   static abstract class Instantiator {
 76     abstract Node create(Address addr);
 77   }
 78 
 79   static public Node create(Address addr) {
 80     if (addr == null) return null;
<span class="line-modified"> 81     Node result = (Node)nodes.get(addr);</span>
 82     if (result == null) {
 83       result = (Node)virtualConstructor.instantiateWrapperFor(addr);
 84       nodes.put(addr, result);
 85     }
 86     return result;
 87   }
 88 
 89   public Node(Address addr) {
 90     super(addr);
 91   }
 92 
 93   public int outcnt() {
 94     return (int)outcntField.getValue(this.getAddress());
 95   }
 96 
 97   public int req() {
 98     return (int)cntField.getValue(this.getAddress());
 99   }
100 
101   public int len() {
</pre>
<hr />
<pre>
116       Address ptr = outField.getValue(this.getAddress());
117       for (int j = 0; j &lt; outcnt(); j++) {
118         _out[j] = Node.create(ptr.getAddressAt(j * addressSize));
119       }
120     }
121     return _out[i];
122   }
123 
124   public Node in(int i) {
125     if (_in == null) {
126       int addressSize = (int)VM.getVM().getAddressSize();
127       _in = new Node[len()];
128       Address ptr = inField.getValue(this.getAddress());
129       for (int j = 0; j &lt; len(); j++) {
130         _in[j] = Node.create(ptr.getAddressAt(j * addressSize));
131       }
132     }
133     return _in[i];
134   }
135 
<span class="line-modified">136   public ArrayList collect(int d, boolean onlyCtrl) {</span>
137     int depth = Math.abs(d);
<span class="line-modified">138     ArrayList nstack = new ArrayList();</span>
139     BitSet set = new BitSet();
140 
141     nstack.add(this);
142     set.set(idx());
143     int begin = 0;
144     int end = 0;
145     for (int i = 0; i &lt; depth; i++) {
146       end = nstack.size();
147       for(int j = begin; j &lt; end; j++) {
148         Node tp  = (Node)nstack.get(j);
149         int limit = d &gt; 0 ? tp.len() : tp.outcnt();
150         for(int k = 0; k &lt; limit; k++) {
151           Node n = d &gt; 0 ? tp.in(k) : tp.rawOut(k);
152 
153           // if (NotANode(n))  continue;
154           if (n == null) continue;
155           // do not recurse through top or the root (would reach unrelated stuff)
156           // if (n.isRoot() || n.isTop())  continue;
157           // if (onlyCtrl &amp;&amp; !n.isCfg()) continue;
158 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.opto;
 26 
 27 import java.io.*;
 28 import java.lang.reflect.Constructor;
 29 import java.util.*;
 30 import sun.jvm.hotspot.debugger.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.oops.*;
 33 import sun.jvm.hotspot.types.*;
<span class="line-added"> 34 import sun.jvm.hotspot.utilities.Observable;</span>
<span class="line-added"> 35 import sun.jvm.hotspot.utilities.Observer;</span>
 36 
 37 public class Node extends VMObject {
 38   static {
 39     VM.registerVMInitializedObserver(new Observer() {
 40         public void update(Observable o, Object data) {
 41           initialize(VM.getVM().getTypeDataBase());
 42         }
 43       });
 44   }
 45 
 46   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
 47     Type type      = db.lookupType(&quot;Node&quot;);
 48     outmaxField = new CIntField(type.getCIntegerField(&quot;_outmax&quot;), 0);
 49     outcntField = new CIntField(type.getCIntegerField(&quot;_outcnt&quot;), 0);
 50     maxField = new CIntField(type.getCIntegerField(&quot;_max&quot;), 0);
 51     cntField = new CIntField(type.getCIntegerField(&quot;_cnt&quot;), 0);
 52     idxField = new CIntField(type.getCIntegerField(&quot;_idx&quot;), 0);
 53     outField = type.getAddressField(&quot;_out&quot;);
 54     inField = type.getAddressField(&quot;_in&quot;);
 55 
 56     nodeType = db.lookupType(&quot;Node&quot;);
 57 
<span class="line-modified"> 58     virtualConstructor = new VirtualBaseConstructor&lt;&gt;(db, nodeType, &quot;sun.jvm.hotspot.opto&quot;, Node.class);</span>
 59   }
 60 
 61   private static CIntField outmaxField;
 62   private static CIntField outcntField;
 63   private static CIntField maxField;
 64   private static CIntField cntField;
 65   private static CIntField idxField;
 66   private static AddressField outField;
 67   private static AddressField inField;
 68 
<span class="line-modified"> 69   private static VirtualBaseConstructor&lt;Node&gt; virtualConstructor;</span>
 70 
 71   private static Type nodeType;
 72 
<span class="line-modified"> 73   static HashMap&lt;Address, Node&gt; nodes = new HashMap&lt;&gt;();</span>
 74 
 75   static HashMap constructors = new HashMap();
 76 
 77   static abstract class Instantiator {
 78     abstract Node create(Address addr);
 79   }
 80 
 81   static public Node create(Address addr) {
 82     if (addr == null) return null;
<span class="line-modified"> 83     Node result = nodes.get(addr);</span>
 84     if (result == null) {
 85       result = (Node)virtualConstructor.instantiateWrapperFor(addr);
 86       nodes.put(addr, result);
 87     }
 88     return result;
 89   }
 90 
 91   public Node(Address addr) {
 92     super(addr);
 93   }
 94 
 95   public int outcnt() {
 96     return (int)outcntField.getValue(this.getAddress());
 97   }
 98 
 99   public int req() {
100     return (int)cntField.getValue(this.getAddress());
101   }
102 
103   public int len() {
</pre>
<hr />
<pre>
118       Address ptr = outField.getValue(this.getAddress());
119       for (int j = 0; j &lt; outcnt(); j++) {
120         _out[j] = Node.create(ptr.getAddressAt(j * addressSize));
121       }
122     }
123     return _out[i];
124   }
125 
126   public Node in(int i) {
127     if (_in == null) {
128       int addressSize = (int)VM.getVM().getAddressSize();
129       _in = new Node[len()];
130       Address ptr = inField.getValue(this.getAddress());
131       for (int j = 0; j &lt; len(); j++) {
132         _in[j] = Node.create(ptr.getAddressAt(j * addressSize));
133       }
134     }
135     return _in[i];
136   }
137 
<span class="line-modified">138   public ArrayList&lt;Node&gt; collect(int d, boolean onlyCtrl) {</span>
139     int depth = Math.abs(d);
<span class="line-modified">140     ArrayList&lt;Node&gt; nstack = new ArrayList&lt;&gt;();</span>
141     BitSet set = new BitSet();
142 
143     nstack.add(this);
144     set.set(idx());
145     int begin = 0;
146     int end = 0;
147     for (int i = 0; i &lt; depth; i++) {
148       end = nstack.size();
149       for(int j = begin; j &lt; end; j++) {
150         Node tp  = (Node)nstack.get(j);
151         int limit = d &gt; 0 ? tp.len() : tp.outcnt();
152         for(int k = 0; k &lt; limit; k++) {
153           Node n = d &gt; 0 ? tp.in(k) : tp.rawOut(k);
154 
155           // if (NotANode(n))  continue;
156           if (n == null) continue;
157           // do not recurse through top or the root (would reach unrelated stuff)
158           // if (n.isRoot() || n.isTop())  continue;
159           // if (onlyCtrl &amp;&amp; !n.isCfg()) continue;
160 
</pre>
</td>
</tr>
</table>
<center><a href="MultiNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Node_Array.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
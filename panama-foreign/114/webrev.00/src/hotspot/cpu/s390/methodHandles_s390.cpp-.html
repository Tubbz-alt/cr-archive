<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/s390/methodHandles_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2016, 2017, SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;jvm.h&quot;
 28 #include &quot;asm/macroAssembler.inline.hpp&quot;
 29 #include &quot;classfile/javaClasses.inline.hpp&quot;
 30 #include &quot;interpreter/interpreter.hpp&quot;
 31 #include &quot;memory/allocation.inline.hpp&quot;
 32 #include &quot;memory/resourceArea.hpp&quot;
 33 #include &quot;prims/methodHandles.hpp&quot;
 34 #include &quot;runtime/frame.inline.hpp&quot;
 35 #include &quot;utilities/preserveException.hpp&quot;
 36 
 37 #ifdef PRODUCT
 38 #define __ _masm-&gt;
 39 #define BLOCK_COMMENT(str) /* nothing */
 40 #else
 41 #define __ (Verbose ? (_masm-&gt;block_comment(FILE_AND_LINE),_masm):_masm)-&gt;
 42 #define BLOCK_COMMENT(str) __ block_comment(str)
 43 #endif
 44 
 45 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
 46 
 47 // Workaround for C++ overloading nastiness on &#39;0&#39; for RegisterOrConstant.
 48 static RegisterOrConstant constant(int value) {
 49   return RegisterOrConstant(value);
 50 }
 51 
 52 void MethodHandles::load_klass_from_Class(MacroAssembler* _masm, Register klass_reg,
 53                                           Register temp_reg, Register temp2_reg) {
 54   if (VerifyMethodHandles) {
 55     verify_klass(_masm, klass_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),
 56                  temp_reg, temp2_reg, &quot;MH argument is a Class&quot;);
 57   }
 58   __ z_lg(klass_reg, Address(klass_reg, java_lang_Class::klass_offset_in_bytes()));
 59 }
 60 
 61 
 62 #ifdef ASSERT
 63 static int check_nonzero(const char* xname, int x) {
 64   assert(x != 0, &quot;%s should be nonzero&quot;, xname);
 65   return x;
 66 }
 67 #define NONZERO(x) check_nonzero(#x, x)
 68 #else
 69 #define NONZERO(x) (x)
 70 #endif
 71 
 72 #ifdef ASSERT
 73 void MethodHandles::verify_klass(MacroAssembler* _masm,
 74                                  Register obj_reg, SystemDictionary::WKID klass_id,
 75                                  Register temp_reg, Register temp2_reg,
 76                                  const char* error_message) {
 77 
 78   InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);
 79   Klass* klass = SystemDictionary::well_known_klass(klass_id);
 80 
 81   assert(temp_reg != Z_R0 &amp;&amp; // Is used as base register!
 82          temp_reg != noreg &amp;&amp; temp2_reg != noreg, &quot;need valid registers!&quot;);
 83 
 84   NearLabel L_ok, L_bad;
 85 
 86   BLOCK_COMMENT(&quot;verify_klass {&quot;);
 87 
 88   __ verify_oop(obj_reg, FILE_AND_LINE);
 89   __ compareU64_and_branch(obj_reg, (intptr_t)0L, Assembler::bcondEqual, L_bad);
 90   __ load_klass(temp_reg, obj_reg);
 91   // klass_addr is a klass in allstatic SystemDictionaryHandles. Can&#39;t get GCed.
 92   __ load_const_optimized(temp2_reg, (address)klass_addr);
 93   __ z_lg(temp2_reg, Address(temp2_reg));
 94   __ compareU64_and_branch(temp_reg, temp2_reg, Assembler::bcondEqual, L_ok);
 95 
 96   intptr_t super_check_offset = klass-&gt;super_check_offset();
 97   __ z_lg(temp_reg, Address(temp_reg, super_check_offset));
 98   __ compareU64_and_branch(temp_reg, temp2_reg, Assembler::bcondEqual, L_ok);
 99   __ BIND(L_bad);
100   __ stop(error_message);
101   __ BIND(L_ok);
102 
103   BLOCK_COMMENT(&quot;} verify_klass&quot;);
104 }
105 
106 void MethodHandles::verify_ref_kind(MacroAssembler* _masm, int ref_kind,
107                                     Register member_reg, Register temp  ) {
108   NearLabel L;
109   BLOCK_COMMENT(&quot;verify_ref_kind {&quot;);
110 
111   __ z_llgf(temp,
112             Address(member_reg,
113                     NONZERO(java_lang_invoke_MemberName::flags_offset_in_bytes())));
114   __ z_srl(temp,  java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT);
115   __ z_nilf(temp, java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK);
116   __ compare32_and_branch(temp, constant(ref_kind), Assembler::bcondEqual, L);
117 
118   {
119     char *buf = NEW_C_HEAP_ARRAY(char, 100, mtInternal);
120 
121     jio_snprintf(buf, 100, &quot;verify_ref_kind expected %x&quot;, ref_kind);
122     if (ref_kind == JVM_REF_invokeVirtual || ref_kind == JVM_REF_invokeSpecial) {
123       // Could do this for all ref_kinds, but would explode assembly code size.
124       trace_method_handle(_masm, buf);
125     }
126     __ stop(buf);
127   }
128 
129   BLOCK_COMMENT(&quot;} verify_ref_kind&quot;);
130 
131   __ bind(L);
132 }
133 #endif // ASSERT
134 
135 void MethodHandles::jump_from_method_handle(MacroAssembler* _masm, Register method, Register target,
136                                             Register temp, bool for_compiler_entry) {
137   assert(method == Z_method, &quot;interpreter calling convention&quot;);
138   __ verify_method_ptr(method);
139 
140   assert(target != method, &quot;don &#39;t you kill the method reg!&quot;);
141 
142   Label L_no_such_method;
143 
144   if (!for_compiler_entry &amp;&amp; JvmtiExport::can_post_interpreter_events()) {
145     // JVMTI events, such as single-stepping, are implemented partly
146     // by avoiding running compiled code in threads for which the
147     // event is enabled. Check here for interp_only_mode if these
148     // events CAN be enabled.
149     __ verify_thread();
150 
151     Label run_compiled_code;
152 
153     __ load_and_test_int(temp, Address(Z_thread, JavaThread::interp_only_mode_offset()));
154     __ z_bre(run_compiled_code);
155 
156     // Null method test is replicated below in compiled case,
157     // it might be able to address across the verify_thread().
158     __ z_ltgr(temp, method);
159     __ z_bre(L_no_such_method);
160 
161     __ z_lg(target, Address(method, Method::interpreter_entry_offset()));
162     __ z_br(target);
163 
164     __ bind(run_compiled_code);
165   }
166 
167   // Compiled case, either static or fall-through from runtime conditional.
168   __ z_ltgr(temp, method);
169   __ z_bre(L_no_such_method);
170 
171   ByteSize offset = for_compiler_entry ?
172                        Method::from_compiled_offset() : Method::from_interpreted_offset();
173   Address method_from(method, offset);
174 
175   __ z_lg(target, method_from);
176   __ z_br(target);
177 
178   __ bind(L_no_such_method);
179   assert(StubRoutines::throw_AbstractMethodError_entry() != NULL, &quot;not yet generated!&quot;);
180   __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());
181   __ z_br(target);
182 }
183 
184 void MethodHandles::jump_to_lambda_form(MacroAssembler* _masm,
185                                         Register recv, Register method_temp,
186                                         Register temp2, Register temp3,
187                                         bool for_compiler_entry) {
188 
189   // This is the initial entry point of a lazy method handle.
190   // After type checking, it picks up the invoker from the LambdaForm.
191   assert_different_registers(recv, method_temp, temp2, temp3);
192   assert(method_temp == Z_method, &quot;required register for loading method&quot;);
193 
194   BLOCK_COMMENT(&quot;jump_to_lambda_form {&quot;);
195 
196   // Load the invoker, as MH -&gt; MH.form -&gt; LF.vmentry
197   __ verify_oop(recv, FILE_AND_LINE);
198   __ load_heap_oop(method_temp,
199                    Address(recv,
200                            NONZERO(java_lang_invoke_MethodHandle::form_offset_in_bytes())),
201                    noreg, noreg, IS_NOT_NULL);
202   __ verify_oop(method_temp, FILE_AND_LINE);
203   __ load_heap_oop(method_temp,
204                    Address(method_temp,
205                            NONZERO(java_lang_invoke_LambdaForm::vmentry_offset_in_bytes())),
206                    noreg, noreg, IS_NOT_NULL);
207   __ verify_oop(method_temp, FILE_AND_LINE);
208   __ load_heap_oop(method_temp,
209                    Address(method_temp,
210                            NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes())),
211                    noreg, noreg, IS_NOT_NULL);
212   __ verify_oop(method_temp, FILE_AND_LINE);
213   __ z_lg(method_temp,
214           Address(method_temp,
215                   NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes())));
216 
217   if (VerifyMethodHandles &amp;&amp; !for_compiler_entry) {
218     // Make sure recv is already on stack.
219     NearLabel L;
220     Address paramSize(temp2, ConstMethod::size_of_parameters_offset());
221 
222     __ z_lg(temp2, Address(method_temp, Method::const_offset()));
223     __ load_sized_value(temp2, paramSize, sizeof(u2), /*is_signed*/ false);
224     // if (temp2 != recv) stop
225     __ z_lg(temp2, __ argument_address(temp2, temp2, 0));
226     __ compare64_and_branch(temp2, recv, Assembler::bcondEqual, L);
227     __ stop(&quot;receiver not on stack&quot;);
228     __ BIND(L);
229   }
230 
231   jump_from_method_handle(_masm, method_temp, temp2, Z_R0, for_compiler_entry);
232 
233   BLOCK_COMMENT(&quot;} jump_to_lambda_form&quot;);
234 }
235 
236 // code generation
237 address MethodHandles::generate_method_handle_interpreter_entry(MacroAssembler* _masm,
238                                                                 vmIntrinsics::ID iid) {
239   const bool not_for_compiler_entry = false;  // This is the interpreter entry.
240   assert(is_signature_polymorphic(iid), &quot;expected invoke iid&quot;);
241 
242   if (iid == vmIntrinsics::_invokeGeneric || iid == vmIntrinsics::_compiledLambdaForm) {
243     // Perhaps surprisingly, the symbolic references visible to Java
244     // are not directly used. They are linked to Java-generated
245     // adapters via MethodHandleNatives.linkMethod. They all allow an
246     // appendix argument.
247     __ should_not_reach_here();           // Empty stubs make SG sick.
248     return NULL;
249   }
250 
251   // Z_R10: sender SP (must preserve; see prepare_to_jump_from_interprted)
252   // Z_method: method
253   // Z_ARG1 (Gargs): incoming argument list (must preserve)
254   Register Z_R4_param_size = Z_R4;   // size of parameters
255   address code_start = __ pc();
256 
257   // Here is where control starts out:
258   __ align(CodeEntryAlignment);
259 
260   address entry_point = __ pc();
261 
262   if (VerifyMethodHandles) {
263     Label L;
264     BLOCK_COMMENT(&quot;verify_intrinsic_id {&quot;);
265 
266     // Supplement to 8139891: _intrinsic_id exceeded 1-byte size limit.
267     if (Method::intrinsic_id_size_in_bytes() == 1) {
268       __ z_cli(Address(Z_method, Method::intrinsic_id_offset_in_bytes()), (int)iid);
269     } else {
270       assert(Method::intrinsic_id_size_in_bytes() == 2, &quot;size error: check Method::_intrinsic_id&quot;);
271       __ z_lh(Z_R0_scratch, Address(Z_method, Method::intrinsic_id_offset_in_bytes()));
272       __ z_chi(Z_R0_scratch, (int)iid);
273     }
274     __ z_bre(L);
275 
276     if (iid == vmIntrinsics::_linkToVirtual || iid == vmIntrinsics::_linkToSpecial) {
277       // Could do this for all kinds, but would explode assembly code size.
278       trace_method_handle(_masm, &quot;bad Method::intrinsic_id&quot;);
279     }
280 
281     __ stop(&quot;bad Method::intrinsic_id&quot;);
282     __ bind(L);
283 
284     BLOCK_COMMENT(&quot;} verify_intrinsic_id&quot;);
285   }
286 
287   // First task: Find out how big the argument list is.
288   Address Z_R4_first_arg_addr;
289   int ref_kind = signature_polymorphic_intrinsic_ref_kind(iid);
290 
291   assert(ref_kind != 0 || iid == vmIntrinsics::_invokeBasic,
292          &quot;must be _invokeBasic or a linkTo intrinsic&quot;);
293 
294   if (ref_kind == 0 || MethodHandles::ref_kind_has_receiver(ref_kind)) {
295      Address paramSize(Z_R1_scratch, ConstMethod::size_of_parameters_offset());
296 
297     __ z_lg(Z_R1_scratch, Address(Z_method, Method::const_offset()));
298     __ load_sized_value(Z_R4_param_size, paramSize, sizeof(u2), /*is_signed*/ false);
299     Z_R4_first_arg_addr = __ argument_address(Z_R4_param_size, Z_R4_param_size, 0);
300   } else {
301     DEBUG_ONLY(Z_R4_param_size = noreg);
302   }
303 
304   Register Z_mh = noreg;
305   if (!is_signature_polymorphic_static(iid)) {
306     Z_mh = Z_ARG4;
307     __ z_lg(Z_mh, Z_R4_first_arg_addr);
308     DEBUG_ONLY(Z_R4_param_size = noreg);
309   }
310 
311   // Z_R4_first_arg_addr is live!
312 
313   trace_method_handle_interpreter_entry(_masm, iid);
314 
315   if (iid == vmIntrinsics::_invokeBasic) {
316     __ pc(); // just for the block comment
317     generate_method_handle_dispatch(_masm, iid, Z_mh, noreg, not_for_compiler_entry);
318   } else {
319     // Adjust argument list by popping the trailing MemberName argument.
320     Register Z_recv = noreg;
321 
322     if (MethodHandles::ref_kind_has_receiver(ref_kind)) {
323       // Load the receiver (not the MH; the actual MemberName&#39;s receiver)
324       // up from the interpreter stack.
325       __ z_lg(Z_recv = Z_R5, Z_R4_first_arg_addr);
326       DEBUG_ONLY(Z_R4_param_size = noreg);
327     }
328 
329     Register Z_member = Z_method;  // MemberName ptr; incoming method ptr is dead now
330 
331     __ z_lg(Z_member, __ argument_address(constant(1)));
332     __ add2reg(Z_esp, Interpreter::stackElementSize);
333     generate_method_handle_dispatch(_masm, iid, Z_recv, Z_member, not_for_compiler_entry);
334   }
335 
336   return entry_point;
337 }
338 
339 void MethodHandles::generate_method_handle_dispatch(MacroAssembler* _masm,
340                                                     vmIntrinsics::ID iid,
341                                                     Register receiver_reg,
342                                                     Register member_reg,
343                                                     bool for_compiler_entry) {
344   assert(is_signature_polymorphic(iid), &quot;expected invoke iid&quot;);
345 
346   Register temp1 = for_compiler_entry ? Z_R10 : Z_R6;
347   Register temp2 = Z_R12;
348   Register temp3 = Z_R11;
349   Register temp4 = Z_R13;
350 
351   if (for_compiler_entry) {
352     assert(receiver_reg == (iid == vmIntrinsics::_linkToStatic ? noreg : Z_ARG1),
353            &quot;only valid assignment&quot;);
354   }
355   if (receiver_reg != noreg) {
356     assert_different_registers(temp1, temp2, temp3, temp4, receiver_reg);
357   }
358   if (member_reg != noreg) {
359     assert_different_registers(temp1, temp2, temp3, temp4, member_reg);
360   }
361   if (!for_compiler_entry) {  // Don&#39;t trash last SP.
362     assert_different_registers(temp1, temp2, temp3, temp4, Z_R10);
363   }
364 
365   if (iid == vmIntrinsics::_invokeBasic) {
366     __ pc(); // Just for the block comment.
367     // Indirect through MH.form.vmentry.vmtarget.
368     jump_to_lambda_form(_masm, receiver_reg, Z_method, Z_R1, temp3, for_compiler_entry);
369     return;
370   }
371 
372   // The method is a member invoker used by direct method handles.
373   if (VerifyMethodHandles) {
374     // Make sure the trailing argument really is a MemberName (caller responsibility).
375     verify_klass(_masm, member_reg,
376                  SystemDictionary::WK_KLASS_ENUM_NAME(MemberName_klass),
377                  temp1, temp2,
378                  &quot;MemberName required for invokeVirtual etc.&quot;);
379   }
380 
381   Address  member_clazz(   member_reg, NONZERO(java_lang_invoke_MemberName::clazz_offset_in_bytes()));
382   Address  member_vmindex( member_reg, NONZERO(java_lang_invoke_MemberName::vmindex_offset_in_bytes()));
383   Address  member_vmtarget(member_reg, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes()));
384   Address  vmtarget_method(Z_method, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes()));
385   Register temp1_recv_klass = temp1;
386 
387   if (iid != vmIntrinsics::_linkToStatic) {
388     __ verify_oop(receiver_reg, FILE_AND_LINE);
389     if (iid == vmIntrinsics::_linkToSpecial) {
390       // Don&#39;t actually load the klass; just null-check the receiver.
391       __ null_check(receiver_reg);
392     } else {
393       // Load receiver klass itself.
394       __ null_check(receiver_reg, Z_R0, oopDesc::klass_offset_in_bytes());
395       __ load_klass(temp1_recv_klass, receiver_reg);
396       __ verify_klass_ptr(temp1_recv_klass);
397     }
398     BLOCK_COMMENT(&quot;check_receiver {&quot;);
399     // The receiver for the MemberName must be in receiver_reg.
400     // Check the receiver against the MemberName.clazz.
401     if (VerifyMethodHandles &amp;&amp; iid == vmIntrinsics::_linkToSpecial) {
402       // Did not load it above...
403       __ load_klass(temp1_recv_klass, receiver_reg);
404       __ verify_klass_ptr(temp1_recv_klass);
405     }
406 
407     if (VerifyMethodHandles &amp;&amp; iid != vmIntrinsics::_linkToInterface) {
408       NearLabel L_ok;
409       Register temp2_defc = temp2;
410 
411       __ load_heap_oop(temp2_defc, member_clazz,
412                        noreg, noreg, IS_NOT_NULL);
413       load_klass_from_Class(_masm, temp2_defc, temp3, temp4);
414       __ verify_klass_ptr(temp2_defc);
415       __ check_klass_subtype(temp1_recv_klass, temp2_defc, temp3, temp4, L_ok);
416       // If we get here, the type check failed!
417       __ stop(&quot;receiver class disagrees with MemberName.clazz&quot;);
418       __ bind(L_ok);
419     }
420     BLOCK_COMMENT(&quot;} check_receiver&quot;);
421   }
422   if (iid == vmIntrinsics::_linkToSpecial || iid == vmIntrinsics::_linkToStatic) {
423     DEBUG_ONLY(temp1_recv_klass = noreg);  // These guys didn&#39;t load the recv_klass.
424   }
425 
426   // Live registers at this point:
427   //   member_reg       - MemberName that was the trailing argument.
428   //   temp1_recv_klass - Klass of stacked receiver, if needed.
429   //   Z_R10            - Interpreter linkage if interpreted.
430 
431   bool method_is_live = false;
432 
433   switch (iid) {
434     case vmIntrinsics::_linkToSpecial:
435       if (VerifyMethodHandles) {
436         verify_ref_kind(_masm, JVM_REF_invokeSpecial, member_reg, temp3);
437       }
438       __ load_heap_oop(Z_method, member_vmtarget,
439                        noreg, noreg, IS_NOT_NULL);
440       __ z_lg(Z_method, vmtarget_method);
441       method_is_live = true;
442       break;
443 
444     case vmIntrinsics::_linkToStatic:
445       if (VerifyMethodHandles) {
446         verify_ref_kind(_masm, JVM_REF_invokeStatic, member_reg, temp3);
447       }
448       __ load_heap_oop(Z_method, member_vmtarget,
449                        noreg, noreg, IS_NOT_NULL);
450       __ z_lg(Z_method, vmtarget_method);
451       method_is_live = true;
452       break;
453 
454     case vmIntrinsics::_linkToVirtual: {
455       // Same as TemplateTable::invokevirtual, minus the CP setup and profiling.
456       if (VerifyMethodHandles) {
457         verify_ref_kind(_masm, JVM_REF_invokeVirtual, member_reg, temp3);
458       }
459 
460       // Pick out the vtable index from the MemberName, and then we can discard it.
461       Register temp2_index = temp2;
462       __ z_lg(temp2_index, member_vmindex);
463 
464       if (VerifyMethodHandles) {
465         // if (member_vmindex &lt; 0) stop
466         NearLabel L_index_ok;
467         __ compare32_and_branch(temp2_index, constant(0), Assembler::bcondNotLow, L_index_ok);
468         __ stop(&quot;no virtual index&quot;);
469         __ BIND(L_index_ok);
470       }
471 
472       // Note: The verifier invariants allow us to ignore MemberName.clazz and vmtarget
473       // at this point. And VerifyMethodHandles has already checked clazz, if needed.
474 
475       // Get target method and entry point.
476       __ lookup_virtual_method(temp1_recv_klass, temp2_index, Z_method);
477       method_is_live = true;
478       break;
479     }
480 
481     case vmIntrinsics::_linkToInterface: {
482       // Same as TemplateTable::invokeinterface, minus the CP setup
483       // and profiling, with different argument motion.
484       if (VerifyMethodHandles) {
485         verify_ref_kind(_masm, JVM_REF_invokeInterface, member_reg, temp3);
486       }
487 
488       Register temp3_intf = temp3;
489 
490       __ load_heap_oop(temp3_intf, member_clazz,
491                        noreg, noreg, IS_NOT_NULL);
492       load_klass_from_Class(_masm, temp3_intf, temp2, temp4);
493 
494       Register Z_index = Z_method;
495 
496       __ z_lg(Z_index, member_vmindex);
497 
498       if (VerifyMethodHandles) {
499         NearLabel L;
500         // if (member_vmindex &lt; 0) stop
501         __ compare32_and_branch(Z_index, constant(0), Assembler::bcondNotLow, L);
502         __ stop(&quot;invalid vtable index for MH.invokeInterface&quot;);
503         __ bind(L);
504       }
505 
506       // Given interface, index, and recv klass, dispatch to the implementation method.
507       Label L_no_such_interface;
508       __ lookup_interface_method(temp1_recv_klass, temp3_intf,
509                                  // Note: next two args must be the same:
510                                  Z_index, Z_method, temp2,
511                                  L_no_such_interface);
512       jump_from_method_handle(_masm, Z_method, temp2, Z_R0, for_compiler_entry);
513 
514       __ bind(L_no_such_interface);
515 
516       // Throw exception.
517       __ load_const_optimized(Z_R1, StubRoutines::throw_IncompatibleClassChangeError_entry());
518       __ z_br(Z_R1);
519       break;
520     }
521 
522     default:
523       fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
524       break;
525   }
526 
527   if (method_is_live) {
528     // Live at this point: Z_method, O5_savedSP (if interpreted).
529 
530     // After figuring out which concrete method to call, jump into it.
531     // Note that this works in the interpreter with no data motion.
532     // But the compiled version will require that rcx_recv be shifted out.
533     jump_from_method_handle(_masm, Z_method, temp1, Z_R0, for_compiler_entry);
534   }
535 }
536 
537 #ifndef PRODUCT
538 void trace_method_handle_stub(const char* adaptername,
539                               oopDesc* mh,
540                               intptr_t* sender_sp,
541                               intptr_t* args,
542                               intptr_t* tracing_fp) {
543   bool has_mh = (strstr(adaptername, &quot;/static&quot;) == NULL &amp;&amp;
544                  strstr(adaptername, &quot;linkTo&quot;) == NULL);    // Static linkers don&#39;t have MH.
545   const char* mh_reg_name = has_mh ? &quot;Z_R4_mh&quot; : &quot;Z_R4&quot;;
546   tty-&gt;print_cr(&quot;MH %s %s=&quot; INTPTR_FORMAT &quot; sender_sp=&quot; INTPTR_FORMAT &quot; args=&quot; INTPTR_FORMAT,
547                 adaptername, mh_reg_name,
548                 p2i(mh), p2i(sender_sp), p2i(args));
549 
550   if (Verbose) {
551     // Dumping last frame with frame::describe.
552 
553     JavaThread* p = JavaThread::active();
554 
555     ResourceMark rm;
556     PRESERVE_EXCEPTION_MARK; // May not be needed by safer and unexpensive here.
557     FrameValues values;
558 
559     // Note: We want to allow trace_method_handle from any call site.
560     // While trace_method_handle creates a frame, it may be entered
561     // without a valid return PC in Z_R14 (e.g. not just after a call).
562     // Walking that frame could lead to failures due to that invalid PC.
563     // =&gt; carefully detect that frame when doing the stack walking.
564 
565     // Walk up to the right frame using the &quot;tracing_fp&quot; argument.
566     frame cur_frame = os::current_frame(); // Current C frame.
567 
568     while (cur_frame.fp() != tracing_fp) {
569       cur_frame = os::get_sender_for_C_frame(&amp;cur_frame);
570     }
571 
572     // Safely create a frame and call frame::describe.
573     intptr_t *dump_sp = cur_frame.sender_sp();
574     intptr_t *dump_fp = cur_frame.link();
575 
576     bool walkable = has_mh; // Whether the traced frame shoud be walkable.
577 
578     // The sender for cur_frame is the caller of trace_method_handle.
579     if (walkable) {
580       // The previous definition of walkable may have to be refined
581       // if new call sites cause the next frame constructor to start
582       // failing. Alternatively, frame constructors could be
583       // modified to support the current or future non walkable
584       // frames (but this is more intrusive and is not considered as
585       // part of this RFE, which will instead use a simpler output).
586       frame dump_frame = frame(dump_sp);
587       dump_frame.describe(values, 1);
588     } else {
589       // Robust dump for frames which cannot be constructed from sp/younger_sp
590       // Add descriptions without building a Java frame to avoid issues.
591       values.describe(-1, dump_fp, &quot;fp for #1 &lt;not parsed, cannot trust pc&gt;&quot;);
592       values.describe(-1, dump_sp, &quot;sp&quot;);
593     }
594 
595     bool has_args = has_mh; // Whether Z_esp is meaningful.
596 
597     // Mark args, if seems valid (may not be valid for some adapters).
598     if (has_args) {
599       if ((args &gt;= dump_sp) &amp;&amp; (args &lt; dump_fp)) {
600         values.describe(-1, args, &quot;*Z_esp&quot;);
601       }
602     }
603 
604     // Note: the unextended_sp may not be correct.
605     tty-&gt;print_cr(&quot;  stack layout:&quot;);
606     values.print(p);
607     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
608       mh-&gt;print();
609       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
610         if (java_lang_invoke_MethodHandle::form_offset_in_bytes() != 0) {
611           java_lang_invoke_MethodHandle::form(mh)-&gt;print();
612         }
613       }
614     }
615   }
616 }
617 
618 void MethodHandles::trace_method_handle(MacroAssembler* _masm, const char* adaptername) {
619   if (!TraceMethodHandles) { return; }
620 
621   // If arg registers are contiguous, we can use STMG/LMG.
622   assert((Z_ARG5-&gt;encoding() - Z_ARG1-&gt;encoding() + 1) == RegisterImpl::number_of_arg_registers, &quot;Oops&quot;);
623 
624   BLOCK_COMMENT(&quot;trace_method_handle {&quot;);
625 
626   // Save argument registers (they are used in raise exception stub).
627   // Argument registers have contiguous register numbers -&gt; we can use stmg/lmg.
628   __ z_stmg(Z_ARG1, Z_ARG5, 16, Z_SP);
629 
630   // Setup arguments.
631   __ z_lgr(Z_ARG2, Z_ARG4); // mh, see generate_method_handle_interpreter_entry()
632   __ z_lgr(Z_ARG3, Z_R10);  // sender_sp
633   __ z_lgr(Z_ARG4, Z_esp);
634   __ load_const_optimized(Z_ARG1, (void *)adaptername);
635   __ z_lgr(Z_ARG5, Z_SP);   // tracing_fp
636   __ save_return_pc();      // saves Z_R14
637   __ push_frame_abi160(0);
638   __ call_VM_leaf(CAST_FROM_FN_PTR(address, trace_method_handle_stub));
639   __ pop_frame();
640   __ restore_return_pc();   // restores to Z_R14
641 
642   // Restore argument registers
643   __ z_lmg(Z_ARG1, Z_ARG5, 16, Z_SP);
644   __ zap_from_to(Z_SP, Z_SP, Z_R0, Z_R1, 50, -1);
645   __ zap_from_to(Z_SP, Z_SP, Z_R0, Z_R1, -1, 5);
646 
647   BLOCK_COMMENT(&quot;} trace_method_handle&quot;);
648 }
649 #endif // !PRODUCT
    </pre>
  </body>
</html>
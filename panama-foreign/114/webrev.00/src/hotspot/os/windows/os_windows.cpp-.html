<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/os/windows/os_windows.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // Must be at least Windows Vista or Server 2008 to use InitOnceExecuteOnce
  26 #define _WIN32_WINNT 0x0600
  27 
  28 // no precompiled headers
  29 #include &quot;jvm.h&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;code/vtableStubs.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;compiler/disassembler.hpp&quot;
  37 #include &quot;interpreter/interpreter.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/allocation.inline.hpp&quot;
  41 #include &quot;memory/filemap.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;os_share_windows.hpp&quot;
  44 #include &quot;os_windows.inline.hpp&quot;
  45 #include &quot;prims/jniFastGetField.hpp&quot;
  46 #include &quot;prims/jvm_misc.hpp&quot;
  47 #include &quot;runtime/arguments.hpp&quot;
  48 #include &quot;runtime/atomic.hpp&quot;
  49 #include &quot;runtime/extendedPC.hpp&quot;
  50 #include &quot;runtime/globals.hpp&quot;
  51 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  52 #include &quot;runtime/java.hpp&quot;
  53 #include &quot;runtime/javaCalls.hpp&quot;
  54 #include &quot;runtime/mutexLocker.hpp&quot;
  55 #include &quot;runtime/objectMonitor.hpp&quot;
  56 #include &quot;runtime/orderAccess.hpp&quot;
  57 #include &quot;runtime/osThread.hpp&quot;
  58 #include &quot;runtime/perfMemory.hpp&quot;
  59 #include &quot;runtime/safepointMechanism.hpp&quot;
  60 #include &quot;runtime/sharedRuntime.hpp&quot;
  61 #include &quot;runtime/statSampler.hpp&quot;
  62 #include &quot;runtime/stubRoutines.hpp&quot;
  63 #include &quot;runtime/thread.inline.hpp&quot;
  64 #include &quot;runtime/threadCritical.hpp&quot;
  65 #include &quot;runtime/timer.hpp&quot;
  66 #include &quot;runtime/vm_version.hpp&quot;
  67 #include &quot;services/attachListener.hpp&quot;
  68 #include &quot;services/memTracker.hpp&quot;
  69 #include &quot;services/runtimeService.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/decoder.hpp&quot;
  72 #include &quot;utilities/defaultStream.hpp&quot;
  73 #include &quot;utilities/events.hpp&quot;
  74 #include &quot;utilities/growableArray.hpp&quot;
  75 #include &quot;utilities/macros.hpp&quot;
  76 #include &quot;utilities/vmError.hpp&quot;
  77 #include &quot;symbolengine.hpp&quot;
  78 #include &quot;windbghelp.hpp&quot;
  79 
  80 
  81 #ifdef _DEBUG
  82 #include &lt;crtdbg.h&gt;
  83 #endif
  84 
  85 
  86 #include &lt;windows.h&gt;
  87 #include &lt;sys/types.h&gt;
  88 #include &lt;sys/stat.h&gt;
  89 #include &lt;sys/timeb.h&gt;
  90 #include &lt;objidl.h&gt;
  91 #include &lt;shlobj.h&gt;
  92 
  93 #include &lt;malloc.h&gt;
  94 #include &lt;signal.h&gt;
  95 #include &lt;direct.h&gt;
  96 #include &lt;errno.h&gt;
  97 #include &lt;fcntl.h&gt;
  98 #include &lt;io.h&gt;
  99 #include &lt;process.h&gt;              // For _beginthreadex(), _endthreadex()
 100 #include &lt;imagehlp.h&gt;             // For os::dll_address_to_function_name
 101 // for enumerating dll libraries
 102 #include &lt;vdmdbg.h&gt;
 103 #include &lt;psapi.h&gt;
 104 #include &lt;mmsystem.h&gt;
 105 #include &lt;winsock2.h&gt;
 106 
 107 // for timer info max values which include all bits
 108 #define ALL_64_BITS CONST64(-1)
 109 
 110 // For DLL loading/load error detection
 111 // Values of PE COFF
 112 #define IMAGE_FILE_PTR_TO_SIGNATURE 0x3c
 113 #define IMAGE_FILE_SIGNATURE_LENGTH 4
 114 
 115 static HANDLE main_process;
 116 static HANDLE main_thread;
 117 static int    main_thread_id;
 118 
 119 static FILETIME process_creation_time;
 120 static FILETIME process_exit_time;
 121 static FILETIME process_user_time;
 122 static FILETIME process_kernel_time;
 123 
 124 #ifdef _M_AMD64
 125   #define __CPU__ amd64
 126 #else
 127   #define __CPU__ i486
 128 #endif
 129 
 130 #if INCLUDE_AOT
 131 PVOID  topLevelVectoredExceptionHandler = NULL;
 132 LONG WINAPI topLevelVectoredExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo);
 133 #endif
 134 
 135 // save DLL module handle, used by GetModuleFileName
 136 
 137 HINSTANCE vm_lib_handle;
 138 
 139 BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved) {
 140   switch (reason) {
 141   case DLL_PROCESS_ATTACH:
 142     vm_lib_handle = hinst;
 143     if (ForceTimeHighResolution) {
 144       timeBeginPeriod(1L);
 145     }
 146     WindowsDbgHelp::pre_initialize();
 147     SymbolEngine::pre_initialize();
 148     break;
 149   case DLL_PROCESS_DETACH:
 150     if (ForceTimeHighResolution) {
 151       timeEndPeriod(1L);
 152     }
 153 #if INCLUDE_AOT
 154     if (topLevelVectoredExceptionHandler != NULL) {
 155       RemoveVectoredExceptionHandler(topLevelVectoredExceptionHandler);
 156       topLevelVectoredExceptionHandler = NULL;
 157     }
 158 #endif
 159     break;
 160   default:
 161     break;
 162   }
 163   return true;
 164 }
 165 
 166 static inline double fileTimeAsDouble(FILETIME* time) {
 167   const double high  = (double) ((unsigned int) ~0);
 168   const double split = 10000000.0;
 169   double result = (time-&gt;dwLowDateTime / split) +
 170                    time-&gt;dwHighDateTime * (high/split);
 171   return result;
 172 }
 173 
 174 // Implementation of os
 175 
 176 bool os::unsetenv(const char* name) {
 177   assert(name != NULL, &quot;Null pointer&quot;);
 178   return (SetEnvironmentVariable(name, NULL) == TRUE);
 179 }
 180 
 181 // No setuid programs under Windows.
 182 bool os::have_special_privileges() {
 183   return false;
 184 }
 185 
 186 
 187 // This method is  a periodic task to check for misbehaving JNI applications
 188 // under CheckJNI, we can add any periodic checks here.
 189 // For Windows at the moment does nothing
 190 void os::run_periodic_checks() {
 191   return;
 192 }
 193 
 194 // previous UnhandledExceptionFilter, if there is one
 195 static LPTOP_LEVEL_EXCEPTION_FILTER prev_uef_handler = NULL;
 196 
 197 LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo);
 198 
 199 void os::init_system_properties_values() {
 200   // sysclasspath, java_home, dll_dir
 201   {
 202     char *home_path;
 203     char *dll_path;
 204     char *pslash;
 205     const char *bin = &quot;\\bin&quot;;
 206     char home_dir[MAX_PATH + 1];
 207     char *alt_home_dir = ::getenv(&quot;_ALT_JAVA_HOME_DIR&quot;);
 208 
 209     if (alt_home_dir != NULL)  {
 210       strncpy(home_dir, alt_home_dir, MAX_PATH + 1);
 211       home_dir[MAX_PATH] = &#39;\0&#39;;
 212     } else {
 213       os::jvm_path(home_dir, sizeof(home_dir));
 214       // Found the full path to jvm.dll.
 215       // Now cut the path to &lt;java_home&gt;/jre if we can.
 216       *(strrchr(home_dir, &#39;\\&#39;)) = &#39;\0&#39;;  // get rid of \jvm.dll
 217       pslash = strrchr(home_dir, &#39;\\&#39;);
 218       if (pslash != NULL) {
 219         *pslash = &#39;\0&#39;;                   // get rid of \{client|server}
 220         pslash = strrchr(home_dir, &#39;\\&#39;);
 221         if (pslash != NULL) {
 222           *pslash = &#39;\0&#39;;                 // get rid of \bin
 223         }
 224       }
 225     }
 226 
 227     home_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + 1, mtInternal);
 228     strcpy(home_path, home_dir);
 229     Arguments::set_java_home(home_path);
 230     FREE_C_HEAP_ARRAY(char, home_path);
 231 
 232     dll_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + strlen(bin) + 1,
 233                                 mtInternal);
 234     strcpy(dll_path, home_dir);
 235     strcat(dll_path, bin);
 236     Arguments::set_dll_dir(dll_path);
 237     FREE_C_HEAP_ARRAY(char, dll_path);
 238 
 239     if (!set_boot_path(&#39;\\&#39;, &#39;;&#39;)) {
 240       vm_exit_during_initialization(&quot;Failed setting boot class path.&quot;, NULL);
 241     }
 242   }
 243 
 244 // library_path
 245 #define EXT_DIR &quot;\\lib\\ext&quot;
 246 #define BIN_DIR &quot;\\bin&quot;
 247 #define PACKAGE_DIR &quot;\\Sun\\Java&quot;
 248   {
 249     // Win32 library search order (See the documentation for LoadLibrary):
 250     //
 251     // 1. The directory from which application is loaded.
 252     // 2. The system wide Java Extensions directory (Java only)
 253     // 3. System directory (GetSystemDirectory)
 254     // 4. Windows directory (GetWindowsDirectory)
 255     // 5. The PATH environment variable
 256     // 6. The current directory
 257 
 258     char *library_path;
 259     char tmp[MAX_PATH];
 260     char *path_str = ::getenv(&quot;PATH&quot;);
 261 
 262     library_path = NEW_C_HEAP_ARRAY(char, MAX_PATH * 5 + sizeof(PACKAGE_DIR) +
 263                                     sizeof(BIN_DIR) + (path_str ? strlen(path_str) : 0) + 10, mtInternal);
 264 
 265     library_path[0] = &#39;\0&#39;;
 266 
 267     GetModuleFileName(NULL, tmp, sizeof(tmp));
 268     *(strrchr(tmp, &#39;\\&#39;)) = &#39;\0&#39;;
 269     strcat(library_path, tmp);
 270 
 271     GetWindowsDirectory(tmp, sizeof(tmp));
 272     strcat(library_path, &quot;;&quot;);
 273     strcat(library_path, tmp);
 274     strcat(library_path, PACKAGE_DIR BIN_DIR);
 275 
 276     GetSystemDirectory(tmp, sizeof(tmp));
 277     strcat(library_path, &quot;;&quot;);
 278     strcat(library_path, tmp);
 279 
 280     GetWindowsDirectory(tmp, sizeof(tmp));
 281     strcat(library_path, &quot;;&quot;);
 282     strcat(library_path, tmp);
 283 
 284     if (path_str) {
 285       strcat(library_path, &quot;;&quot;);
 286       strcat(library_path, path_str);
 287     }
 288 
 289     strcat(library_path, &quot;;.&quot;);
 290 
 291     Arguments::set_library_path(library_path);
 292     FREE_C_HEAP_ARRAY(char, library_path);
 293   }
 294 
 295   // Default extensions directory
 296   {
 297     char path[MAX_PATH];
 298     char buf[2 * MAX_PATH + 2 * sizeof(EXT_DIR) + sizeof(PACKAGE_DIR) + 1];
 299     GetWindowsDirectory(path, MAX_PATH);
 300     sprintf(buf, &quot;%s%s;%s%s%s&quot;, Arguments::get_java_home(), EXT_DIR,
 301             path, PACKAGE_DIR, EXT_DIR);
 302     Arguments::set_ext_dirs(buf);
 303   }
 304   #undef EXT_DIR
 305   #undef BIN_DIR
 306   #undef PACKAGE_DIR
 307 
 308 #ifndef _WIN64
 309   // set our UnhandledExceptionFilter and save any previous one
 310   prev_uef_handler = SetUnhandledExceptionFilter(Handle_FLT_Exception);
 311 #endif
 312 
 313   // Done
 314   return;
 315 }
 316 
 317 void os::breakpoint() {
 318   DebugBreak();
 319 }
 320 
 321 // Invoked from the BREAKPOINT Macro
 322 extern &quot;C&quot; void breakpoint() {
 323   os::breakpoint();
 324 }
 325 
 326 // RtlCaptureStackBackTrace Windows API may not exist prior to Windows XP.
 327 // So far, this method is only used by Native Memory Tracking, which is
 328 // only supported on Windows XP or later.
 329 //
 330 int os::get_native_stack(address* stack, int frames, int toSkip) {
 331   int captured = RtlCaptureStackBackTrace(toSkip + 1, frames, (PVOID*)stack, NULL);
 332   for (int index = captured; index &lt; frames; index ++) {
 333     stack[index] = NULL;
 334   }
 335   return captured;
 336 }
 337 
 338 
 339 // os::current_stack_base()
 340 //
 341 //   Returns the base of the stack, which is the stack&#39;s
 342 //   starting address.  This function must be called
 343 //   while running on the stack of the thread being queried.
 344 
 345 address os::current_stack_base() {
 346   MEMORY_BASIC_INFORMATION minfo;
 347   address stack_bottom;
 348   size_t stack_size;
 349 
 350   VirtualQuery(&amp;minfo, &amp;minfo, sizeof(minfo));
 351   stack_bottom =  (address)minfo.AllocationBase;
 352   stack_size = minfo.RegionSize;
 353 
 354   // Add up the sizes of all the regions with the same
 355   // AllocationBase.
 356   while (1) {
 357     VirtualQuery(stack_bottom+stack_size, &amp;minfo, sizeof(minfo));
 358     if (stack_bottom == (address)minfo.AllocationBase) {
 359       stack_size += minfo.RegionSize;
 360     } else {
 361       break;
 362     }
 363   }
 364   return stack_bottom + stack_size;
 365 }
 366 
 367 size_t os::current_stack_size() {
 368   size_t sz;
 369   MEMORY_BASIC_INFORMATION minfo;
 370   VirtualQuery(&amp;minfo, &amp;minfo, sizeof(minfo));
 371   sz = (size_t)os::current_stack_base() - (size_t)minfo.AllocationBase;
 372   return sz;
 373 }
 374 
 375 bool os::committed_in_range(address start, size_t size, address&amp; committed_start, size_t&amp; committed_size) {
 376   MEMORY_BASIC_INFORMATION minfo;
 377   committed_start = NULL;
 378   committed_size = 0;
 379   address top = start + size;
 380   const address start_addr = start;
 381   while (start &lt; top) {
 382     VirtualQuery(start, &amp;minfo, sizeof(minfo));
 383     if ((minfo.State &amp; MEM_COMMIT) == 0) {  // not committed
 384       if (committed_start != NULL) {
 385         break;
 386       }
 387     } else {  // committed
 388       if (committed_start == NULL) {
 389         committed_start = start;
 390       }
 391       size_t offset = start - (address)minfo.BaseAddress;
 392       committed_size += minfo.RegionSize - offset;
 393     }
 394     start = (address)minfo.BaseAddress + minfo.RegionSize;
 395   }
 396 
 397   if (committed_start == NULL) {
 398     assert(committed_size == 0, &quot;Sanity&quot;);
 399     return false;
 400   } else {
 401     assert(committed_start &gt;= start_addr &amp;&amp; committed_start &lt; top, &quot;Out of range&quot;);
 402     // current region may go beyond the limit, trim to the limit
 403     committed_size = MIN2(committed_size, size_t(top - committed_start));
 404     return true;
 405   }
 406 }
 407 
 408 struct tm* os::localtime_pd(const time_t* clock, struct tm* res) {
 409   const struct tm* time_struct_ptr = localtime(clock);
 410   if (time_struct_ptr != NULL) {
 411     *res = *time_struct_ptr;
 412     return res;
 413   }
 414   return NULL;
 415 }
 416 
 417 struct tm* os::gmtime_pd(const time_t* clock, struct tm* res) {
 418   const struct tm* time_struct_ptr = gmtime(clock);
 419   if (time_struct_ptr != NULL) {
 420     *res = *time_struct_ptr;
 421     return res;
 422   }
 423   return NULL;
 424 }
 425 
 426 LONG WINAPI topLevelExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo);
 427 
 428 // Thread start routine for all newly created threads
 429 static unsigned __stdcall thread_native_entry(Thread* thread) {
 430 
 431   thread-&gt;record_stack_base_and_size();
 432 
 433   // Try to randomize the cache line index of hot stack frames.
 434   // This helps when threads of the same stack traces evict each other&#39;s
 435   // cache lines. The threads can be either from the same JVM instance, or
 436   // from different JVM instances. The benefit is especially true for
 437   // processors with hyperthreading technology.
 438   static int counter = 0;
 439   int pid = os::current_process_id();
 440   _alloca(((pid ^ counter++) &amp; 7) * 128);
 441 
 442   thread-&gt;initialize_thread_current();
 443 
 444   OSThread* osthr = thread-&gt;osthread();
 445   assert(osthr-&gt;get_state() == RUNNABLE, &quot;invalid os thread state&quot;);
 446 
 447   if (UseNUMA) {
 448     int lgrp_id = os::numa_get_group_id();
 449     if (lgrp_id != -1) {
 450       thread-&gt;set_lgrp_id(lgrp_id);
 451     }
 452   }
 453 
 454   // Diagnostic code to investigate JDK-6573254
 455   int res = 30115;  // non-java thread
 456   if (thread-&gt;is_Java_thread()) {
 457     res = 20115;    // java thread
 458   }
 459 
 460   log_info(os, thread)(&quot;Thread is alive (tid: &quot; UINTX_FORMAT &quot;).&quot;, os::current_thread_id());
 461 
 462   // Install a win32 structured exception handler around every thread created
 463   // by VM, so VM can generate error dump when an exception occurred in non-
 464   // Java thread (e.g. VM thread).
 465   __try {
 466     thread-&gt;call_run();
 467   } __except(topLevelExceptionFilter(
 468                                      (_EXCEPTION_POINTERS*)_exception_info())) {
 469     // Nothing to do.
 470   }
 471 
 472   // Note: at this point the thread object may already have deleted itself.
 473   // Do not dereference it from here on out.
 474 
 475   log_info(os, thread)(&quot;Thread finished (tid: &quot; UINTX_FORMAT &quot;).&quot;, os::current_thread_id());
 476 
 477   // One less thread is executing
 478   // When the VMThread gets here, the main thread may have already exited
 479   // which frees the CodeHeap containing the Atomic::add code
 480   if (thread != VMThread::vm_thread() &amp;&amp; VMThread::vm_thread() != NULL) {
 481     Atomic::dec(&amp;os::win32::_os_thread_count);
 482   }
 483 
 484   // Thread must not return from exit_process_or_thread(), but if it does,
 485   // let it proceed to exit normally
 486   return (unsigned)os::win32::exit_process_or_thread(os::win32::EPT_THREAD, res);
 487 }
 488 
 489 static OSThread* create_os_thread(Thread* thread, HANDLE thread_handle,
 490                                   int thread_id) {
 491   // Allocate the OSThread object
 492   OSThread* osthread = new OSThread(NULL, NULL);
 493   if (osthread == NULL) return NULL;
 494 
 495   // Initialize the JDK library&#39;s interrupt event.
 496   // This should really be done when OSThread is constructed,
 497   // but there is no way for a constructor to report failure to
 498   // allocate the event.
 499   HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
 500   if (interrupt_event == NULL) {
 501     delete osthread;
 502     return NULL;
 503   }
 504   osthread-&gt;set_interrupt_event(interrupt_event);
 505 
 506   // Store info on the Win32 thread into the OSThread
 507   osthread-&gt;set_thread_handle(thread_handle);
 508   osthread-&gt;set_thread_id(thread_id);
 509 
 510   if (UseNUMA) {
 511     int lgrp_id = os::numa_get_group_id();
 512     if (lgrp_id != -1) {
 513       thread-&gt;set_lgrp_id(lgrp_id);
 514     }
 515   }
 516 
 517   // Initial thread state is INITIALIZED, not SUSPENDED
 518   osthread-&gt;set_state(INITIALIZED);
 519 
 520   return osthread;
 521 }
 522 
 523 
 524 bool os::create_attached_thread(JavaThread* thread) {
 525 #ifdef ASSERT
 526   thread-&gt;verify_not_published();
 527 #endif
 528   HANDLE thread_h;
 529   if (!DuplicateHandle(main_process, GetCurrentThread(), GetCurrentProcess(),
 530                        &amp;thread_h, THREAD_ALL_ACCESS, false, 0)) {
 531     fatal(&quot;DuplicateHandle failed\n&quot;);
 532   }
 533   OSThread* osthread = create_os_thread(thread, thread_h,
 534                                         (int)current_thread_id());
 535   if (osthread == NULL) {
 536     return false;
 537   }
 538 
 539   // Initial thread state is RUNNABLE
 540   osthread-&gt;set_state(RUNNABLE);
 541 
 542   thread-&gt;set_osthread(osthread);
 543 
 544   log_info(os, thread)(&quot;Thread attached (tid: &quot; UINTX_FORMAT &quot;).&quot;,
 545     os::current_thread_id());
 546 
 547   return true;
 548 }
 549 
 550 bool os::create_main_thread(JavaThread* thread) {
 551 #ifdef ASSERT
 552   thread-&gt;verify_not_published();
 553 #endif
 554   if (_starting_thread == NULL) {
 555     _starting_thread = create_os_thread(thread, main_thread, main_thread_id);
 556     if (_starting_thread == NULL) {
 557       return false;
 558     }
 559   }
 560 
 561   // The primordial thread is runnable from the start)
 562   _starting_thread-&gt;set_state(RUNNABLE);
 563 
 564   thread-&gt;set_osthread(_starting_thread);
 565   return true;
 566 }
 567 
 568 // Helper function to trace _beginthreadex attributes,
 569 //  similar to os::Posix::describe_pthread_attr()
 570 static char* describe_beginthreadex_attributes(char* buf, size_t buflen,
 571                                                size_t stacksize, unsigned initflag) {
 572   stringStream ss(buf, buflen);
 573   if (stacksize == 0) {
 574     ss.print(&quot;stacksize: default, &quot;);
 575   } else {
 576     ss.print(&quot;stacksize: &quot; SIZE_FORMAT &quot;k, &quot;, stacksize / 1024);
 577   }
 578   ss.print(&quot;flags: &quot;);
 579   #define PRINT_FLAG(f) if (initflag &amp; f) ss.print( #f &quot; &quot;);
 580   #define ALL(X) \
 581     X(CREATE_SUSPENDED) \
 582     X(STACK_SIZE_PARAM_IS_A_RESERVATION)
 583   ALL(PRINT_FLAG)
 584   #undef ALL
 585   #undef PRINT_FLAG
 586   return buf;
 587 }
 588 
 589 // Allocate and initialize a new OSThread
 590 bool os::create_thread(Thread* thread, ThreadType thr_type,
 591                        size_t stack_size) {
 592   unsigned thread_id;
 593 
 594   // Allocate the OSThread object
 595   OSThread* osthread = new OSThread(NULL, NULL);
 596   if (osthread == NULL) {
 597     return false;
 598   }
 599 
 600   // Initialize the JDK library&#39;s interrupt event.
 601   // This should really be done when OSThread is constructed,
 602   // but there is no way for a constructor to report failure to
 603   // allocate the event.
 604   HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
 605   if (interrupt_event == NULL) {
 606     delete osthread;
 607     return false;
 608   }
 609   osthread-&gt;set_interrupt_event(interrupt_event);
 610   // We don&#39;t call set_interrupted(false) as it will trip the assert in there
 611   // as we are not operating on the current thread. We don&#39;t need to call it
 612   // because the initial state is already correct.
 613 
 614   thread-&gt;set_osthread(osthread);
 615 
 616   if (stack_size == 0) {
 617     switch (thr_type) {
 618     case os::java_thread:
 619       // Java threads use ThreadStackSize which default value can be changed with the flag -Xss
 620       if (JavaThread::stack_size_at_create() &gt; 0) {
 621         stack_size = JavaThread::stack_size_at_create();
 622       }
 623       break;
 624     case os::compiler_thread:
 625       if (CompilerThreadStackSize &gt; 0) {
 626         stack_size = (size_t)(CompilerThreadStackSize * K);
 627         break;
 628       } // else fall through:
 629         // use VMThreadStackSize if CompilerThreadStackSize is not defined
 630     case os::vm_thread:
 631     case os::pgc_thread:
 632     case os::cgc_thread:
 633     case os::watcher_thread:
 634       if (VMThreadStackSize &gt; 0) stack_size = (size_t)(VMThreadStackSize * K);
 635       break;
 636     }
 637   }
 638 
 639   // Create the Win32 thread
 640   //
 641   // Contrary to what MSDN document says, &quot;stack_size&quot; in _beginthreadex()
 642   // does not specify stack size. Instead, it specifies the size of
 643   // initially committed space. The stack size is determined by
 644   // PE header in the executable. If the committed &quot;stack_size&quot; is larger
 645   // than default value in the PE header, the stack is rounded up to the
 646   // nearest multiple of 1MB. For example if the launcher has default
 647   // stack size of 320k, specifying any size less than 320k does not
 648   // affect the actual stack size at all, it only affects the initial
 649   // commitment. On the other hand, specifying &#39;stack_size&#39; larger than
 650   // default value may cause significant increase in memory usage, because
 651   // not only the stack space will be rounded up to MB, but also the
 652   // entire space is committed upfront.
 653   //
 654   // Finally Windows XP added a new flag &#39;STACK_SIZE_PARAM_IS_A_RESERVATION&#39;
 655   // for CreateThread() that can treat &#39;stack_size&#39; as stack size. However we
 656   // are not supposed to call CreateThread() directly according to MSDN
 657   // document because JVM uses C runtime library. The good news is that the
 658   // flag appears to work with _beginthredex() as well.
 659 
 660   const unsigned initflag = CREATE_SUSPENDED | STACK_SIZE_PARAM_IS_A_RESERVATION;
 661   HANDLE thread_handle =
 662     (HANDLE)_beginthreadex(NULL,
 663                            (unsigned)stack_size,
 664                            (unsigned (__stdcall *)(void*)) thread_native_entry,
 665                            thread,
 666                            initflag,
 667                            &amp;thread_id);
 668 
 669   char buf[64];
 670   if (thread_handle != NULL) {
 671     log_info(os, thread)(&quot;Thread started (tid: %u, attributes: %s)&quot;,
 672       thread_id, describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
 673   } else {
 674     log_warning(os, thread)(&quot;Failed to start thread - _beginthreadex failed (%s) for attributes: %s.&quot;,
 675       os::errno_name(errno), describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
 676     // Log some OS information which might explain why creating the thread failed.
 677     log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());
 678     LogStream st(Log(os, thread)::info());
 679     os::print_memory_info(&amp;st);
 680   }
 681 
 682   if (thread_handle == NULL) {
 683     // Need to clean up stuff we&#39;ve allocated so far
 684     thread-&gt;set_osthread(NULL);
 685     delete osthread;
 686     return false;
 687   }
 688 
 689   Atomic::inc(&amp;os::win32::_os_thread_count);
 690 
 691   // Store info on the Win32 thread into the OSThread
 692   osthread-&gt;set_thread_handle(thread_handle);
 693   osthread-&gt;set_thread_id(thread_id);
 694 
 695   // Initial thread state is INITIALIZED, not SUSPENDED
 696   osthread-&gt;set_state(INITIALIZED);
 697 
 698   // The thread is returned suspended (in state INITIALIZED), and is started higher up in the call chain
 699   return true;
 700 }
 701 
 702 
 703 // Free Win32 resources related to the OSThread
 704 void os::free_thread(OSThread* osthread) {
 705   assert(osthread != NULL, &quot;osthread not set&quot;);
 706 
 707   // We are told to free resources of the argument thread,
 708   // but we can only really operate on the current thread.
 709   assert(Thread::current()-&gt;osthread() == osthread,
 710          &quot;os::free_thread but not current thread&quot;);
 711 
 712   CloseHandle(osthread-&gt;thread_handle());
 713   delete osthread;
 714 }
 715 
 716 static jlong first_filetime;
 717 static jlong initial_performance_count;
 718 static jlong performance_frequency;
 719 
 720 
 721 jlong as_long(LARGE_INTEGER x) {
 722   jlong result = 0; // initialization to avoid warning
 723   set_high(&amp;result, x.HighPart);
 724   set_low(&amp;result, x.LowPart);
 725   return result;
 726 }
 727 
 728 
 729 jlong os::elapsed_counter() {
 730   LARGE_INTEGER count;
 731   QueryPerformanceCounter(&amp;count);
 732   return as_long(count) - initial_performance_count;
 733 }
 734 
 735 
 736 jlong os::elapsed_frequency() {
 737   return performance_frequency;
 738 }
 739 
 740 
 741 julong os::available_memory() {
 742   return win32::available_memory();
 743 }
 744 
 745 julong os::win32::available_memory() {
 746   // Use GlobalMemoryStatusEx() because GlobalMemoryStatus() may return incorrect
 747   // value if total memory is larger than 4GB
 748   MEMORYSTATUSEX ms;
 749   ms.dwLength = sizeof(ms);
 750   GlobalMemoryStatusEx(&amp;ms);
 751 
 752   return (julong)ms.ullAvailPhys;
 753 }
 754 
 755 julong os::physical_memory() {
 756   return win32::physical_memory();
 757 }
 758 
 759 bool os::has_allocatable_memory_limit(julong* limit) {
 760   MEMORYSTATUSEX ms;
 761   ms.dwLength = sizeof(ms);
 762   GlobalMemoryStatusEx(&amp;ms);
 763 #ifdef _LP64
 764   *limit = (julong)ms.ullAvailVirtual;
 765   return true;
 766 #else
 767   // Limit to 1400m because of the 2gb address space wall
 768   *limit = MIN2((julong)1400*M, (julong)ms.ullAvailVirtual);
 769   return true;
 770 #endif
 771 }
 772 
 773 int os::active_processor_count() {
 774   // User has overridden the number of active processors
 775   if (ActiveProcessorCount &gt; 0) {
 776     log_trace(os)(&quot;active_processor_count: &quot;
 777                   &quot;active processor count set by user : %d&quot;,
 778                   ActiveProcessorCount);
 779     return ActiveProcessorCount;
 780   }
 781 
 782   DWORD_PTR lpProcessAffinityMask = 0;
 783   DWORD_PTR lpSystemAffinityMask = 0;
 784   int proc_count = processor_count();
 785   if (proc_count &lt;= sizeof(UINT_PTR) * BitsPerByte &amp;&amp;
 786       GetProcessAffinityMask(GetCurrentProcess(), &amp;lpProcessAffinityMask, &amp;lpSystemAffinityMask)) {
 787     // Nof active processors is number of bits in process affinity mask
 788     int bitcount = 0;
 789     while (lpProcessAffinityMask != 0) {
 790       lpProcessAffinityMask = lpProcessAffinityMask &amp; (lpProcessAffinityMask-1);
 791       bitcount++;
 792     }
 793     return bitcount;
 794   } else {
 795     return proc_count;
 796   }
 797 }
 798 
 799 uint os::processor_id() {
 800   return (uint)GetCurrentProcessorNumber();
 801 }
 802 
 803 void os::set_native_thread_name(const char *name) {
 804 
 805   // See: http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx
 806   //
 807   // Note that unfortunately this only works if the process
 808   // is already attached to a debugger; debugger must observe
 809   // the exception below to show the correct name.
 810 
 811   // If there is no debugger attached skip raising the exception
 812   if (!IsDebuggerPresent()) {
 813     return;
 814   }
 815 
 816   const DWORD MS_VC_EXCEPTION = 0x406D1388;
 817   struct {
 818     DWORD dwType;     // must be 0x1000
 819     LPCSTR szName;    // pointer to name (in user addr space)
 820     DWORD dwThreadID; // thread ID (-1=caller thread)
 821     DWORD dwFlags;    // reserved for future use, must be zero
 822   } info;
 823 
 824   info.dwType = 0x1000;
 825   info.szName = name;
 826   info.dwThreadID = -1;
 827   info.dwFlags = 0;
 828 
 829   __try {
 830     RaiseException (MS_VC_EXCEPTION, 0, sizeof(info)/sizeof(DWORD), (const ULONG_PTR*)&amp;info );
 831   } __except(EXCEPTION_EXECUTE_HANDLER) {}
 832 }
 833 
 834 bool os::bind_to_processor(uint processor_id) {
 835   // Not yet implemented.
 836   return false;
 837 }
 838 
 839 void os::win32::initialize_performance_counter() {
 840   LARGE_INTEGER count;
 841   QueryPerformanceFrequency(&amp;count);
 842   performance_frequency = as_long(count);
 843   QueryPerformanceCounter(&amp;count);
 844   initial_performance_count = as_long(count);
 845 }
 846 
 847 
 848 double os::elapsedTime() {
 849   return (double) elapsed_counter() / (double) elapsed_frequency();
 850 }
 851 
 852 
 853 // Windows format:
 854 //   The FILETIME structure is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.
 855 // Java format:
 856 //   Java standards require the number of milliseconds since 1/1/1970
 857 
 858 // Constant offset - calculated using offset()
 859 static jlong  _offset   = 116444736000000000;
 860 // Fake time counter for reproducible results when debugging
 861 static jlong  fake_time = 0;
 862 
 863 #ifdef ASSERT
 864 // Just to be safe, recalculate the offset in debug mode
 865 static jlong _calculated_offset = 0;
 866 static int   _has_calculated_offset = 0;
 867 
 868 jlong offset() {
 869   if (_has_calculated_offset) return _calculated_offset;
 870   SYSTEMTIME java_origin;
 871   java_origin.wYear          = 1970;
 872   java_origin.wMonth         = 1;
 873   java_origin.wDayOfWeek     = 0; // ignored
 874   java_origin.wDay           = 1;
 875   java_origin.wHour          = 0;
 876   java_origin.wMinute        = 0;
 877   java_origin.wSecond        = 0;
 878   java_origin.wMilliseconds  = 0;
 879   FILETIME jot;
 880   if (!SystemTimeToFileTime(&amp;java_origin, &amp;jot)) {
 881     fatal(&quot;Error = %d\nWindows error&quot;, GetLastError());
 882   }
 883   _calculated_offset = jlong_from(jot.dwHighDateTime, jot.dwLowDateTime);
 884   _has_calculated_offset = 1;
 885   assert(_calculated_offset == _offset, &quot;Calculated and constant time offsets must be equal&quot;);
 886   return _calculated_offset;
 887 }
 888 #else
 889 jlong offset() {
 890   return _offset;
 891 }
 892 #endif
 893 
 894 jlong windows_to_java_time(FILETIME wt) {
 895   jlong a = jlong_from(wt.dwHighDateTime, wt.dwLowDateTime);
 896   return (a - offset()) / 10000;
 897 }
 898 
 899 // Returns time ticks in (10th of micro seconds)
 900 jlong windows_to_time_ticks(FILETIME wt) {
 901   jlong a = jlong_from(wt.dwHighDateTime, wt.dwLowDateTime);
 902   return (a - offset());
 903 }
 904 
 905 FILETIME java_to_windows_time(jlong l) {
 906   jlong a = (l * 10000) + offset();
 907   FILETIME result;
 908   result.dwHighDateTime = high(a);
 909   result.dwLowDateTime  = low(a);
 910   return result;
 911 }
 912 
 913 bool os::supports_vtime() { return true; }
 914 
 915 double os::elapsedVTime() {
 916   FILETIME created;
 917   FILETIME exited;
 918   FILETIME kernel;
 919   FILETIME user;
 920   if (GetThreadTimes(GetCurrentThread(), &amp;created, &amp;exited, &amp;kernel, &amp;user) != 0) {
 921     // the resolution of windows_to_java_time() should be sufficient (ms)
 922     return (double) (windows_to_java_time(kernel) + windows_to_java_time(user)) / MILLIUNITS;
 923   } else {
 924     return elapsedTime();
 925   }
 926 }
 927 
 928 jlong os::javaTimeMillis() {
 929   FILETIME wt;
 930   GetSystemTimeAsFileTime(&amp;wt);
 931   return windows_to_java_time(wt);
 932 }
 933 
 934 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
 935   FILETIME wt;
 936   GetSystemTimeAsFileTime(&amp;wt);
 937   jlong ticks = windows_to_time_ticks(wt); // 10th of micros
 938   jlong secs = jlong(ticks / 10000000); // 10000 * 1000
 939   seconds = secs;
 940   nanos = jlong(ticks - (secs*10000000)) * 100;
 941 }
 942 
 943 jlong os::javaTimeNanos() {
 944     LARGE_INTEGER current_count;
 945     QueryPerformanceCounter(&amp;current_count);
 946     double current = as_long(current_count);
 947     double freq = performance_frequency;
 948     jlong time = (jlong)((current/freq) * NANOSECS_PER_SEC);
 949     return time;
 950 }
 951 
 952 void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {
 953   jlong freq = performance_frequency;
 954   if (freq &lt; NANOSECS_PER_SEC) {
 955     // the performance counter is 64 bits and we will
 956     // be multiplying it -- so no wrap in 64 bits
 957     info_ptr-&gt;max_value = ALL_64_BITS;
 958   } else if (freq &gt; NANOSECS_PER_SEC) {
 959     // use the max value the counter can reach to
 960     // determine the max value which could be returned
 961     julong max_counter = (julong)ALL_64_BITS;
 962     info_ptr-&gt;max_value = (jlong)(max_counter / (freq / NANOSECS_PER_SEC));
 963   } else {
 964     // the performance counter is 64 bits and we will
 965     // be using it directly -- so no wrap in 64 bits
 966     info_ptr-&gt;max_value = ALL_64_BITS;
 967   }
 968 
 969   // using a counter, so no skipping
 970   info_ptr-&gt;may_skip_backward = false;
 971   info_ptr-&gt;may_skip_forward = false;
 972 
 973   info_ptr-&gt;kind = JVMTI_TIMER_ELAPSED;                // elapsed not CPU time
 974 }
 975 
 976 char* os::local_time_string(char *buf, size_t buflen) {
 977   SYSTEMTIME st;
 978   GetLocalTime(&amp;st);
 979   jio_snprintf(buf, buflen, &quot;%d-%02d-%02d %02d:%02d:%02d&quot;,
 980                st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
 981   return buf;
 982 }
 983 
 984 bool os::getTimesSecs(double* process_real_time,
 985                       double* process_user_time,
 986                       double* process_system_time) {
 987   HANDLE h_process = GetCurrentProcess();
 988   FILETIME create_time, exit_time, kernel_time, user_time;
 989   BOOL result = GetProcessTimes(h_process,
 990                                 &amp;create_time,
 991                                 &amp;exit_time,
 992                                 &amp;kernel_time,
 993                                 &amp;user_time);
 994   if (result != 0) {
 995     FILETIME wt;
 996     GetSystemTimeAsFileTime(&amp;wt);
 997     jlong rtc_millis = windows_to_java_time(wt);
 998     *process_real_time = ((double) rtc_millis) / ((double) MILLIUNITS);
 999     *process_user_time =
1000       (double) jlong_from(user_time.dwHighDateTime, user_time.dwLowDateTime) / (10 * MICROUNITS);
1001     *process_system_time =
1002       (double) jlong_from(kernel_time.dwHighDateTime, kernel_time.dwLowDateTime) / (10 * MICROUNITS);
1003     return true;
1004   } else {
1005     return false;
1006   }
1007 }
1008 
1009 void os::shutdown() {
1010   // allow PerfMemory to attempt cleanup of any persistent resources
1011   perfMemory_exit();
1012 
1013   // flush buffered output, finish log files
1014   ostream_abort();
1015 
1016   // Check for abort hook
1017   abort_hook_t abort_hook = Arguments::abort_hook();
1018   if (abort_hook != NULL) {
1019     abort_hook();
1020   }
1021 }
1022 
1023 
1024 static HANDLE dumpFile = NULL;
1025 
1026 // Check if dump file can be created.
1027 void os::check_dump_limit(char* buffer, size_t buffsz) {
1028   bool status = true;
1029   if (!FLAG_IS_DEFAULT(CreateCoredumpOnCrash) &amp;&amp; !CreateCoredumpOnCrash) {
1030     jio_snprintf(buffer, buffsz, &quot;CreateCoredumpOnCrash is disabled from command line&quot;);
1031     status = false;
1032   }
1033 
1034 #ifndef ASSERT
1035   if (!os::win32::is_windows_server() &amp;&amp; FLAG_IS_DEFAULT(CreateCoredumpOnCrash)) {
1036     jio_snprintf(buffer, buffsz, &quot;Minidumps are not enabled by default on client versions of Windows&quot;);
1037     status = false;
1038   }
1039 #endif
1040 
1041   if (status) {
1042     const char* cwd = get_current_directory(NULL, 0);
1043     int pid = current_process_id();
1044     if (cwd != NULL) {
1045       jio_snprintf(buffer, buffsz, &quot;%s\\hs_err_pid%u.mdmp&quot;, cwd, pid);
1046     } else {
1047       jio_snprintf(buffer, buffsz, &quot;.\\hs_err_pid%u.mdmp&quot;, pid);
1048     }
1049 
1050     if (dumpFile == NULL &amp;&amp;
1051        (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL))
1052                  == INVALID_HANDLE_VALUE) {
1053       jio_snprintf(buffer, buffsz, &quot;Failed to create minidump file (0x%x).&quot;, GetLastError());
1054       status = false;
1055     }
1056   }
1057   VMError::record_coredump_status(buffer, status);
1058 }
1059 
1060 void os::abort(bool dump_core, void* siginfo, const void* context) {
1061   EXCEPTION_POINTERS ep;
1062   MINIDUMP_EXCEPTION_INFORMATION mei;
1063   MINIDUMP_EXCEPTION_INFORMATION* pmei;
1064 
1065   HANDLE hProcess = GetCurrentProcess();
1066   DWORD processId = GetCurrentProcessId();
1067   MINIDUMP_TYPE dumpType;
1068 
1069   shutdown();
1070   if (!dump_core || dumpFile == NULL) {
1071     if (dumpFile != NULL) {
1072       CloseHandle(dumpFile);
1073     }
1074     win32::exit_process_or_thread(win32::EPT_PROCESS, 1);
1075   }
1076 
1077   dumpType = (MINIDUMP_TYPE)(MiniDumpWithFullMemory | MiniDumpWithHandleData |
1078     MiniDumpWithFullMemoryInfo | MiniDumpWithThreadInfo | MiniDumpWithUnloadedModules);
1079 
1080   if (siginfo != NULL &amp;&amp; context != NULL) {
1081     ep.ContextRecord = (PCONTEXT) context;
1082     ep.ExceptionRecord = (PEXCEPTION_RECORD) siginfo;
1083 
1084     mei.ThreadId = GetCurrentThreadId();
1085     mei.ExceptionPointers = &amp;ep;
1086     pmei = &amp;mei;
1087   } else {
1088     pmei = NULL;
1089   }
1090 
1091   // Older versions of dbghelp.dll (the one shipped with Win2003 for example) may not support all
1092   // the dump types we really want. If first call fails, lets fall back to just use MiniDumpWithFullMemory then.
1093   if (!WindowsDbgHelp::miniDumpWriteDump(hProcess, processId, dumpFile, dumpType, pmei, NULL, NULL) &amp;&amp;
1094       !WindowsDbgHelp::miniDumpWriteDump(hProcess, processId, dumpFile, (MINIDUMP_TYPE)MiniDumpWithFullMemory, pmei, NULL, NULL)) {
1095     jio_fprintf(stderr, &quot;Call to MiniDumpWriteDump() failed (Error 0x%x)\n&quot;, GetLastError());
1096   }
1097   CloseHandle(dumpFile);
1098   win32::exit_process_or_thread(win32::EPT_PROCESS, 1);
1099 }
1100 
1101 // Die immediately, no exit hook, no abort hook, no cleanup.
1102 void os::die() {
1103   win32::exit_process_or_thread(win32::EPT_PROCESS_DIE, -1);
1104 }
1105 
1106 // Directory routines copied from src/win32/native/java/io/dirent_md.c
1107 //  * dirent_md.c       1.15 00/02/02
1108 //
1109 // The declarations for DIR and struct dirent are in jvm_win32.h.
1110 
1111 // Caller must have already run dirname through JVM_NativePath, which removes
1112 // duplicate slashes and converts all instances of &#39;/&#39; into &#39;\\&#39;.
1113 
1114 DIR * os::opendir(const char *dirname) {
1115   assert(dirname != NULL, &quot;just checking&quot;);   // hotspot change
1116   DIR *dirp = (DIR *)malloc(sizeof(DIR), mtInternal);
1117   DWORD fattr;                                // hotspot change
1118   char alt_dirname[4] = { 0, 0, 0, 0 };
1119 
1120   if (dirp == 0) {
1121     errno = ENOMEM;
1122     return 0;
1123   }
1124 
1125   // Win32 accepts &quot;\&quot; in its POSIX stat(), but refuses to treat it
1126   // as a directory in FindFirstFile().  We detect this case here and
1127   // prepend the current drive name.
1128   //
1129   if (dirname[1] == &#39;\0&#39; &amp;&amp; dirname[0] == &#39;\\&#39;) {
1130     alt_dirname[0] = _getdrive() + &#39;A&#39; - 1;
1131     alt_dirname[1] = &#39;:&#39;;
1132     alt_dirname[2] = &#39;\\&#39;;
1133     alt_dirname[3] = &#39;\0&#39;;
1134     dirname = alt_dirname;
1135   }
1136 
1137   dirp-&gt;path = (char *)malloc(strlen(dirname) + 5, mtInternal);
1138   if (dirp-&gt;path == 0) {
1139     free(dirp);
1140     errno = ENOMEM;
1141     return 0;
1142   }
1143   strcpy(dirp-&gt;path, dirname);
1144 
1145   fattr = GetFileAttributes(dirp-&gt;path);
1146   if (fattr == 0xffffffff) {
1147     free(dirp-&gt;path);
1148     free(dirp);
1149     errno = ENOENT;
1150     return 0;
1151   } else if ((fattr &amp; FILE_ATTRIBUTE_DIRECTORY) == 0) {
1152     free(dirp-&gt;path);
1153     free(dirp);
1154     errno = ENOTDIR;
1155     return 0;
1156   }
1157 
1158   // Append &quot;*.*&quot;, or possibly &quot;\\*.*&quot;, to path
1159   if (dirp-&gt;path[1] == &#39;:&#39; &amp;&amp;
1160       (dirp-&gt;path[2] == &#39;\0&#39; ||
1161       (dirp-&gt;path[2] == &#39;\\&#39; &amp;&amp; dirp-&gt;path[3] == &#39;\0&#39;))) {
1162     // No &#39;\\&#39; needed for cases like &quot;Z:&quot; or &quot;Z:\&quot;
1163     strcat(dirp-&gt;path, &quot;*.*&quot;);
1164   } else {
1165     strcat(dirp-&gt;path, &quot;\\*.*&quot;);
1166   }
1167 
1168   dirp-&gt;handle = FindFirstFile(dirp-&gt;path, &amp;dirp-&gt;find_data);
1169   if (dirp-&gt;handle == INVALID_HANDLE_VALUE) {
1170     if (GetLastError() != ERROR_FILE_NOT_FOUND) {
1171       free(dirp-&gt;path);
1172       free(dirp);
1173       errno = EACCES;
1174       return 0;
1175     }
1176   }
1177   return dirp;
1178 }
1179 
1180 struct dirent * os::readdir(DIR *dirp) {
1181   assert(dirp != NULL, &quot;just checking&quot;);      // hotspot change
1182   if (dirp-&gt;handle == INVALID_HANDLE_VALUE) {
1183     return NULL;
1184   }
1185 
1186   strcpy(dirp-&gt;dirent.d_name, dirp-&gt;find_data.cFileName);
1187 
1188   if (!FindNextFile(dirp-&gt;handle, &amp;dirp-&gt;find_data)) {
1189     if (GetLastError() == ERROR_INVALID_HANDLE) {
1190       errno = EBADF;
1191       return NULL;
1192     }
1193     FindClose(dirp-&gt;handle);
1194     dirp-&gt;handle = INVALID_HANDLE_VALUE;
1195   }
1196 
1197   return &amp;dirp-&gt;dirent;
1198 }
1199 
1200 int os::closedir(DIR *dirp) {
1201   assert(dirp != NULL, &quot;just checking&quot;);      // hotspot change
1202   if (dirp-&gt;handle != INVALID_HANDLE_VALUE) {
1203     if (!FindClose(dirp-&gt;handle)) {
1204       errno = EBADF;
1205       return -1;
1206     }
1207     dirp-&gt;handle = INVALID_HANDLE_VALUE;
1208   }
1209   free(dirp-&gt;path);
1210   free(dirp);
1211   return 0;
1212 }
1213 
1214 // This must be hard coded because it&#39;s the system&#39;s temporary
1215 // directory not the java application&#39;s temp directory, ala java.io.tmpdir.
1216 const char* os::get_temp_directory() {
1217   static char path_buf[MAX_PATH];
1218   if (GetTempPath(MAX_PATH, path_buf) &gt; 0) {
1219     return path_buf;
1220   } else {
1221     path_buf[0] = &#39;\0&#39;;
1222     return path_buf;
1223   }
1224 }
1225 
1226 // Needs to be in os specific directory because windows requires another
1227 // header file &lt;direct.h&gt;
1228 const char* os::get_current_directory(char *buf, size_t buflen) {
1229   int n = static_cast&lt;int&gt;(buflen);
1230   if (buflen &gt; INT_MAX)  n = INT_MAX;
1231   return _getcwd(buf, n);
1232 }
1233 
1234 //-----------------------------------------------------------
1235 // Helper functions for fatal error handler
1236 #ifdef _WIN64
1237 // Helper routine which returns true if address in
1238 // within the NTDLL address space.
1239 //
1240 static bool _addr_in_ntdll(address addr) {
1241   HMODULE hmod;
1242   MODULEINFO minfo;
1243 
1244   hmod = GetModuleHandle(&quot;NTDLL.DLL&quot;);
1245   if (hmod == NULL) return false;
1246   if (!GetModuleInformation(GetCurrentProcess(), hmod,
1247                                           &amp;minfo, sizeof(MODULEINFO))) {
1248     return false;
1249   }
1250 
1251   if ((addr &gt;= minfo.lpBaseOfDll) &amp;&amp;
1252       (addr &lt; (address)((uintptr_t)minfo.lpBaseOfDll + (uintptr_t)minfo.SizeOfImage))) {
1253     return true;
1254   } else {
1255     return false;
1256   }
1257 }
1258 #endif
1259 
1260 struct _modinfo {
1261   address addr;
1262   char*   full_path;   // point to a char buffer
1263   int     buflen;      // size of the buffer
1264   address base_addr;
1265 };
1266 
1267 static int _locate_module_by_addr(const char * mod_fname, address base_addr,
1268                                   address top_address, void * param) {
1269   struct _modinfo *pmod = (struct _modinfo *)param;
1270   if (!pmod) return -1;
1271 
1272   if (base_addr   &lt;= pmod-&gt;addr &amp;&amp;
1273       top_address &gt; pmod-&gt;addr) {
1274     // if a buffer is provided, copy path name to the buffer
1275     if (pmod-&gt;full_path) {
1276       jio_snprintf(pmod-&gt;full_path, pmod-&gt;buflen, &quot;%s&quot;, mod_fname);
1277     }
1278     pmod-&gt;base_addr = base_addr;
1279     return 1;
1280   }
1281   return 0;
1282 }
1283 
1284 bool os::dll_address_to_library_name(address addr, char* buf,
1285                                      int buflen, int* offset) {
1286   // buf is not optional, but offset is optional
1287   assert(buf != NULL, &quot;sanity check&quot;);
1288 
1289 // NOTE: the reason we don&#39;t use SymGetModuleInfo() is it doesn&#39;t always
1290 //       return the full path to the DLL file, sometimes it returns path
1291 //       to the corresponding PDB file (debug info); sometimes it only
1292 //       returns partial path, which makes life painful.
1293 
1294   struct _modinfo mi;
1295   mi.addr      = addr;
1296   mi.full_path = buf;
1297   mi.buflen    = buflen;
1298   if (get_loaded_modules_info(_locate_module_by_addr, (void *)&amp;mi)) {
1299     // buf already contains path name
1300     if (offset) *offset = addr - mi.base_addr;
1301     return true;
1302   }
1303 
1304   buf[0] = &#39;\0&#39;;
1305   if (offset) *offset = -1;
1306   return false;
1307 }
1308 
1309 bool os::dll_address_to_function_name(address addr, char *buf,
1310                                       int buflen, int *offset,
1311                                       bool demangle) {
1312   // buf is not optional, but offset is optional
1313   assert(buf != NULL, &quot;sanity check&quot;);
1314 
1315   if (Decoder::decode(addr, buf, buflen, offset, demangle)) {
1316     return true;
1317   }
1318   if (offset != NULL)  *offset  = -1;
1319   buf[0] = &#39;\0&#39;;
1320   return false;
1321 }
1322 
1323 // save the start and end address of jvm.dll into param[0] and param[1]
1324 static int _locate_jvm_dll(const char* mod_fname, address base_addr,
1325                            address top_address, void * param) {
1326   if (!param) return -1;
1327 
1328   if (base_addr   &lt;= (address)_locate_jvm_dll &amp;&amp;
1329       top_address &gt; (address)_locate_jvm_dll) {
1330     ((address*)param)[0] = base_addr;
1331     ((address*)param)[1] = top_address;
1332     return 1;
1333   }
1334   return 0;
1335 }
1336 
1337 address vm_lib_location[2];    // start and end address of jvm.dll
1338 
1339 // check if addr is inside jvm.dll
1340 bool os::address_is_in_vm(address addr) {
1341   if (!vm_lib_location[0] || !vm_lib_location[1]) {
1342     if (!get_loaded_modules_info(_locate_jvm_dll, (void *)vm_lib_location)) {
1343       assert(false, &quot;Can&#39;t find jvm module.&quot;);
1344       return false;
1345     }
1346   }
1347 
1348   return (vm_lib_location[0] &lt;= addr) &amp;&amp; (addr &lt; vm_lib_location[1]);
1349 }
1350 
1351 // print module info; param is outputStream*
1352 static int _print_module(const char* fname, address base_address,
1353                          address top_address, void* param) {
1354   if (!param) return -1;
1355 
1356   outputStream* st = (outputStream*)param;
1357 
1358   st-&gt;print(PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot; \t%s\n&quot;, base_address, top_address, fname);
1359   return 0;
1360 }
1361 
1362 // Loads .dll/.so and
1363 // in case of error it checks if .dll/.so was built for the
1364 // same architecture as Hotspot is running on
1365 void * os::dll_load(const char *name, char *ebuf, int ebuflen) {
1366   log_info(os)(&quot;attempting shared library load of %s&quot;, name);
1367 
1368   void * result = LoadLibrary(name);
1369   if (result != NULL) {
1370     Events::log(NULL, &quot;Loaded shared library %s&quot;, name);
1371     // Recalculate pdb search path if a DLL was loaded successfully.
1372     SymbolEngine::recalc_search_path();
1373     log_info(os)(&quot;shared library load of %s was successful&quot;, name);
1374     return result;
1375   }
1376   DWORD errcode = GetLastError();
1377   // Read system error message into ebuf
1378   // It may or may not be overwritten below (in the for loop and just above)
1379   lasterror(ebuf, (size_t) ebuflen);
1380   ebuf[ebuflen - 1] = &#39;\0&#39;;
1381   Events::log(NULL, &quot;Loading shared library %s failed, error code %lu&quot;, name, errcode);
1382   log_info(os)(&quot;shared library load of %s failed, error code %lu&quot;, name, errcode);
1383 
1384   if (errcode == ERROR_MOD_NOT_FOUND) {
1385     strncpy(ebuf, &quot;Can&#39;t find dependent libraries&quot;, ebuflen - 1);
1386     ebuf[ebuflen - 1] = &#39;\0&#39;;
1387     return NULL;
1388   }
1389 
1390   // Parsing dll below
1391   // If we can read dll-info and find that dll was built
1392   // for an architecture other than Hotspot is running in
1393   // - then print to buffer &quot;DLL was built for a different architecture&quot;
1394   // else call os::lasterror to obtain system error message
1395   int fd = ::open(name, O_RDONLY | O_BINARY, 0);
1396   if (fd &lt; 0) {
1397     return NULL;
1398   }
1399 
1400   uint32_t signature_offset;
1401   uint16_t lib_arch = 0;
1402   bool failed_to_get_lib_arch =
1403     ( // Go to position 3c in the dll
1404      (os::seek_to_file_offset(fd, IMAGE_FILE_PTR_TO_SIGNATURE) &lt; 0)
1405      ||
1406      // Read location of signature
1407      (sizeof(signature_offset) !=
1408      (os::read(fd, (void*)&amp;signature_offset, sizeof(signature_offset))))
1409      ||
1410      // Go to COFF File Header in dll
1411      // that is located after &quot;signature&quot; (4 bytes long)
1412      (os::seek_to_file_offset(fd,
1413      signature_offset + IMAGE_FILE_SIGNATURE_LENGTH) &lt; 0)
1414      ||
1415      // Read field that contains code of architecture
1416      // that dll was built for
1417      (sizeof(lib_arch) != (os::read(fd, (void*)&amp;lib_arch, sizeof(lib_arch))))
1418     );
1419 
1420   ::close(fd);
1421   if (failed_to_get_lib_arch) {
1422     // file i/o error - report os::lasterror(...) msg
1423     return NULL;
1424   }
1425 
1426   typedef struct {
1427     uint16_t arch_code;
1428     char* arch_name;
1429   } arch_t;
1430 
1431   static const arch_t arch_array[] = {
1432     {IMAGE_FILE_MACHINE_I386,      (char*)&quot;IA 32&quot;},
1433     {IMAGE_FILE_MACHINE_AMD64,     (char*)&quot;AMD 64&quot;}
1434   };
1435 #if (defined _M_AMD64)
1436   static const uint16_t running_arch = IMAGE_FILE_MACHINE_AMD64;
1437 #elif (defined _M_IX86)
1438   static const uint16_t running_arch = IMAGE_FILE_MACHINE_I386;
1439 #else
1440   #error Method os::dll_load requires that one of following \
1441          is defined :_M_AMD64 or _M_IX86
1442 #endif
1443 
1444 
1445   // Obtain a string for printf operation
1446   // lib_arch_str shall contain string what platform this .dll was built for
1447   // running_arch_str shall string contain what platform Hotspot was built for
1448   char *running_arch_str = NULL, *lib_arch_str = NULL;
1449   for (unsigned int i = 0; i &lt; ARRAY_SIZE(arch_array); i++) {
1450     if (lib_arch == arch_array[i].arch_code) {
1451       lib_arch_str = arch_array[i].arch_name;
1452     }
1453     if (running_arch == arch_array[i].arch_code) {
1454       running_arch_str = arch_array[i].arch_name;
1455     }
1456   }
1457 
1458   assert(running_arch_str,
1459          &quot;Didn&#39;t find running architecture code in arch_array&quot;);
1460 
1461   // If the architecture is right
1462   // but some other error took place - report os::lasterror(...) msg
1463   if (lib_arch == running_arch) {
1464     return NULL;
1465   }
1466 
1467   if (lib_arch_str != NULL) {
1468     ::_snprintf(ebuf, ebuflen - 1,
1469                 &quot;Can&#39;t load %s-bit .dll on a %s-bit platform&quot;,
1470                 lib_arch_str, running_arch_str);
1471   } else {
1472     // don&#39;t know what architecture this dll was build for
1473     ::_snprintf(ebuf, ebuflen - 1,
1474                 &quot;Can&#39;t load this .dll (machine code=0x%x) on a %s-bit platform&quot;,
1475                 lib_arch, running_arch_str);
1476   }
1477 
1478   return NULL;
1479 }
1480 
1481 void os::print_dll_info(outputStream *st) {
1482   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
1483   get_loaded_modules_info(_print_module, (void *)st);
1484 }
1485 
1486 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
1487   HANDLE   hProcess;
1488 
1489 # define MAX_NUM_MODULES 128
1490   HMODULE     modules[MAX_NUM_MODULES];
1491   static char filename[MAX_PATH];
1492   int         result = 0;
1493 
1494   int pid = os::current_process_id();
1495   hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
1496                          FALSE, pid);
1497   if (hProcess == NULL) return 0;
1498 
1499   DWORD size_needed;
1500   if (!EnumProcessModules(hProcess, modules, sizeof(modules), &amp;size_needed)) {
1501     CloseHandle(hProcess);
1502     return 0;
1503   }
1504 
1505   // number of modules that are currently loaded
1506   int num_modules = size_needed / sizeof(HMODULE);
1507 
1508   for (int i = 0; i &lt; MIN2(num_modules, MAX_NUM_MODULES); i++) {
1509     // Get Full pathname:
1510     if (!GetModuleFileNameEx(hProcess, modules[i], filename, sizeof(filename))) {
1511       filename[0] = &#39;\0&#39;;
1512     }
1513 
1514     MODULEINFO modinfo;
1515     if (!GetModuleInformation(hProcess, modules[i], &amp;modinfo, sizeof(modinfo))) {
1516       modinfo.lpBaseOfDll = NULL;
1517       modinfo.SizeOfImage = 0;
1518     }
1519 
1520     // Invoke callback function
1521     result = callback(filename, (address)modinfo.lpBaseOfDll,
1522                       (address)((u8)modinfo.lpBaseOfDll + (u8)modinfo.SizeOfImage), param);
1523     if (result) break;
1524   }
1525 
1526   CloseHandle(hProcess);
1527   return result;
1528 }
1529 
1530 bool os::get_host_name(char* buf, size_t buflen) {
1531   DWORD size = (DWORD)buflen;
1532   return (GetComputerNameEx(ComputerNameDnsHostname, buf, &amp;size) == TRUE);
1533 }
1534 
1535 void os::get_summary_os_info(char* buf, size_t buflen) {
1536   stringStream sst(buf, buflen);
1537   os::win32::print_windows_version(&amp;sst);
1538   // chop off newline character
1539   char* nl = strchr(buf, &#39;\n&#39;);
1540   if (nl != NULL) *nl = &#39;\0&#39;;
1541 }
1542 
1543 int os::vsnprintf(char* buf, size_t len, const char* fmt, va_list args) {
1544 #if _MSC_VER &gt;= 1900
1545   // Starting with Visual Studio 2015, vsnprint is C99 compliant.
1546   int result = ::vsnprintf(buf, len, fmt, args);
1547   // If an encoding error occurred (result &lt; 0) then it&#39;s not clear
1548   // whether the buffer is NUL terminated, so ensure it is.
1549   if ((result &lt; 0) &amp;&amp; (len &gt; 0)) {
1550     buf[len - 1] = &#39;\0&#39;;
1551   }
1552   return result;
1553 #else
1554   // Before Visual Studio 2015, vsnprintf is not C99 compliant, so use
1555   // _vsnprintf, whose behavior seems to be *mostly* consistent across
1556   // versions.  However, when len == 0, avoid _vsnprintf too, and just
1557   // go straight to _vscprintf.  The output is going to be truncated in
1558   // that case, except in the unusual case of empty output.  More
1559   // importantly, the documentation for various versions of Visual Studio
1560   // are inconsistent about the behavior of _vsnprintf when len == 0,
1561   // including it possibly being an error.
1562   int result = -1;
1563   if (len &gt; 0) {
1564     result = _vsnprintf(buf, len, fmt, args);
1565     // If output (including NUL terminator) is truncated, the buffer
1566     // won&#39;t be NUL terminated.  Add the trailing NUL specified by C99.
1567     if ((result &lt; 0) || ((size_t)result &gt;= len)) {
1568       buf[len - 1] = &#39;\0&#39;;
1569     }
1570   }
1571   if (result &lt; 0) {
1572     result = _vscprintf(fmt, args);
1573   }
1574   return result;
1575 #endif // _MSC_VER dispatch
1576 }
1577 
1578 static inline time_t get_mtime(const char* filename) {
1579   struct stat st;
1580   int ret = os::stat(filename, &amp;st);
1581   assert(ret == 0, &quot;failed to stat() file &#39;%s&#39;: %s&quot;, filename, os::strerror(errno));
1582   return st.st_mtime;
1583 }
1584 
1585 int os::compare_file_modified_times(const char* file1, const char* file2) {
1586   time_t t1 = get_mtime(file1);
1587   time_t t2 = get_mtime(file2);
1588   return t1 - t2;
1589 }
1590 
1591 void os::print_os_info_brief(outputStream* st) {
1592   os::print_os_info(st);
1593 }
1594 
1595 void os::win32::print_uptime_info(outputStream* st) {
1596   unsigned long long ticks = GetTickCount64();
1597   os::print_dhm(st, &quot;OS uptime:&quot;, ticks/1000);
1598 }
1599 
1600 void os::print_os_info(outputStream* st) {
1601 #ifdef ASSERT
1602   char buffer[1024];
1603   st-&gt;print(&quot;HostName: &quot;);
1604   if (get_host_name(buffer, sizeof(buffer))) {
1605     st-&gt;print(&quot;%s &quot;, buffer);
1606   } else {
1607     st-&gt;print(&quot;N/A &quot;);
1608   }
1609 #endif
1610   st-&gt;print(&quot;OS:&quot;);
1611   os::win32::print_windows_version(st);
1612 
1613   os::win32::print_uptime_info(st);
1614 
1615 #ifdef _LP64
1616   VM_Version::print_platform_virtualization_info(st);
1617 #endif
1618 }
1619 
1620 void os::win32::print_windows_version(outputStream* st) {
1621   OSVERSIONINFOEX osvi;
1622   VS_FIXEDFILEINFO *file_info;
1623   TCHAR kernel32_path[MAX_PATH];
1624   UINT len, ret;
1625 
1626   // Use the GetVersionEx information to see if we&#39;re on a server or
1627   // workstation edition of Windows. Starting with Windows 8.1 we can&#39;t
1628   // trust the OS version information returned by this API.
1629   ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFOEX));
1630   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
1631   if (!GetVersionEx((OSVERSIONINFO *)&amp;osvi)) {
1632     st-&gt;print_cr(&quot;Call to GetVersionEx failed&quot;);
1633     return;
1634   }
1635   bool is_workstation = (osvi.wProductType == VER_NT_WORKSTATION);
1636 
1637   // Get the full path to \Windows\System32\kernel32.dll and use that for
1638   // determining what version of Windows we&#39;re running on.
1639   len = MAX_PATH - (UINT)strlen(&quot;\\kernel32.dll&quot;) - 1;
1640   ret = GetSystemDirectory(kernel32_path, len);
1641   if (ret == 0 || ret &gt; len) {
1642     st-&gt;print_cr(&quot;Call to GetSystemDirectory failed&quot;);
1643     return;
1644   }
1645   strncat(kernel32_path, &quot;\\kernel32.dll&quot;, MAX_PATH - ret);
1646 
1647   DWORD version_size = GetFileVersionInfoSize(kernel32_path, NULL);
1648   if (version_size == 0) {
1649     st-&gt;print_cr(&quot;Call to GetFileVersionInfoSize failed&quot;);
1650     return;
1651   }
1652 
1653   LPTSTR version_info = (LPTSTR)os::malloc(version_size, mtInternal);
1654   if (version_info == NULL) {
1655     st-&gt;print_cr(&quot;Failed to allocate version_info&quot;);
1656     return;
1657   }
1658 
1659   if (!GetFileVersionInfo(kernel32_path, NULL, version_size, version_info)) {
1660     os::free(version_info);
1661     st-&gt;print_cr(&quot;Call to GetFileVersionInfo failed&quot;);
1662     return;
1663   }
1664 
1665   if (!VerQueryValue(version_info, TEXT(&quot;\\&quot;), (LPVOID*)&amp;file_info, &amp;len)) {
1666     os::free(version_info);
1667     st-&gt;print_cr(&quot;Call to VerQueryValue failed&quot;);
1668     return;
1669   }
1670 
1671   int major_version = HIWORD(file_info-&gt;dwProductVersionMS);
1672   int minor_version = LOWORD(file_info-&gt;dwProductVersionMS);
1673   int build_number = HIWORD(file_info-&gt;dwProductVersionLS);
1674   int build_minor = LOWORD(file_info-&gt;dwProductVersionLS);
1675   int os_vers = major_version * 1000 + minor_version;
1676   os::free(version_info);
1677 
1678   st-&gt;print(&quot; Windows &quot;);
1679   switch (os_vers) {
1680 
1681   case 6000:
1682     if (is_workstation) {
1683       st-&gt;print(&quot;Vista&quot;);
1684     } else {
1685       st-&gt;print(&quot;Server 2008&quot;);
1686     }
1687     break;
1688 
1689   case 6001:
1690     if (is_workstation) {
1691       st-&gt;print(&quot;7&quot;);
1692     } else {
1693       st-&gt;print(&quot;Server 2008 R2&quot;);
1694     }
1695     break;
1696 
1697   case 6002:
1698     if (is_workstation) {
1699       st-&gt;print(&quot;8&quot;);
1700     } else {
1701       st-&gt;print(&quot;Server 2012&quot;);
1702     }
1703     break;
1704 
1705   case 6003:
1706     if (is_workstation) {
1707       st-&gt;print(&quot;8.1&quot;);
1708     } else {
1709       st-&gt;print(&quot;Server 2012 R2&quot;);
1710     }
1711     break;
1712 
1713   case 10000:
1714     if (is_workstation) {
1715       st-&gt;print(&quot;10&quot;);
1716     } else {
1717       // distinguish Windows Server 2016 and 2019 by build number
1718       // Windows server 2019 GA 10/2018 build number is 17763
1719       if (build_number &gt; 17762) {
1720         st-&gt;print(&quot;Server 2019&quot;);
1721       } else {
1722         st-&gt;print(&quot;Server 2016&quot;);
1723       }
1724     }
1725     break;
1726 
1727   default:
1728     // Unrecognized windows, print out its major and minor versions
1729     st-&gt;print(&quot;%d.%d&quot;, major_version, minor_version);
1730     break;
1731   }
1732 
1733   // Retrieve SYSTEM_INFO from GetNativeSystemInfo call so that we could
1734   // find out whether we are running on 64 bit processor or not
1735   SYSTEM_INFO si;
1736   ZeroMemory(&amp;si, sizeof(SYSTEM_INFO));
1737   GetNativeSystemInfo(&amp;si);
1738   if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {
1739     st-&gt;print(&quot; , 64 bit&quot;);
1740   }
1741 
1742   st-&gt;print(&quot; Build %d&quot;, build_number);
1743   st-&gt;print(&quot; (%d.%d.%d.%d)&quot;, major_version, minor_version, build_number, build_minor);
1744   st-&gt;cr();
1745 }
1746 
1747 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
1748   // Nothing to do for now.
1749 }
1750 
1751 void os::get_summary_cpu_info(char* buf, size_t buflen) {
1752   HKEY key;
1753   DWORD status = RegOpenKey(HKEY_LOCAL_MACHINE,
1754                &quot;HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0&quot;, &amp;key);
1755   if (status == ERROR_SUCCESS) {
1756     DWORD size = (DWORD)buflen;
1757     status = RegQueryValueEx(key, &quot;ProcessorNameString&quot;, NULL, NULL, (byte*)buf, &amp;size);
1758     if (status != ERROR_SUCCESS) {
1759         strncpy(buf, &quot;## __CPU__&quot;, buflen);
1760     }
1761     RegCloseKey(key);
1762   } else {
1763     // Put generic cpu info to return
1764     strncpy(buf, &quot;## __CPU__&quot;, buflen);
1765   }
1766 }
1767 
1768 void os::print_memory_info(outputStream* st) {
1769   st-&gt;print(&quot;Memory:&quot;);
1770   st-&gt;print(&quot; %dk page&quot;, os::vm_page_size()&gt;&gt;10);
1771 
1772   // Use GlobalMemoryStatusEx() because GlobalMemoryStatus() may return incorrect
1773   // value if total memory is larger than 4GB
1774   MEMORYSTATUSEX ms;
1775   ms.dwLength = sizeof(ms);
1776   int r1 = GlobalMemoryStatusEx(&amp;ms);
1777 
1778   if (r1 != 0) {
1779     st-&gt;print(&quot;, system-wide physical &quot; INT64_FORMAT &quot;M &quot;,
1780              (int64_t) ms.ullTotalPhys &gt;&gt; 20);
1781     st-&gt;print(&quot;(&quot; INT64_FORMAT &quot;M free)\n&quot;, (int64_t) ms.ullAvailPhys &gt;&gt; 20);
1782 
1783     st-&gt;print(&quot;TotalPageFile size &quot; INT64_FORMAT &quot;M &quot;,
1784              (int64_t) ms.ullTotalPageFile &gt;&gt; 20);
1785     st-&gt;print(&quot;(AvailPageFile size &quot; INT64_FORMAT &quot;M)&quot;,
1786              (int64_t) ms.ullAvailPageFile &gt;&gt; 20);
1787 
1788     // on 32bit Total/AvailVirtual are interesting (show us how close we get to 2-4 GB per process borders)
1789 #if defined(_M_IX86)
1790     st-&gt;print(&quot;, user-mode portion of virtual address-space &quot; INT64_FORMAT &quot;M &quot;,
1791              (int64_t) ms.ullTotalVirtual &gt;&gt; 20);
1792     st-&gt;print(&quot;(&quot; INT64_FORMAT &quot;M free)&quot;, (int64_t) ms.ullAvailVirtual &gt;&gt; 20);
1793 #endif
1794   } else {
1795     st-&gt;print(&quot;, GlobalMemoryStatusEx did not succeed so we miss some memory values.&quot;);
1796   }
1797 
1798   // extended memory statistics for a process
1799   PROCESS_MEMORY_COUNTERS_EX pmex;
1800   ZeroMemory(&amp;pmex, sizeof(PROCESS_MEMORY_COUNTERS_EX));
1801   pmex.cb = sizeof(pmex);
1802   int r2 = GetProcessMemoryInfo(GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*) &amp;pmex, sizeof(pmex));
1803 
1804   if (r2 != 0) {
1805     st-&gt;print(&quot;\ncurrent process WorkingSet (physical memory assigned to process): &quot; INT64_FORMAT &quot;M, &quot;,
1806              (int64_t) pmex.WorkingSetSize &gt;&gt; 20);
1807     st-&gt;print(&quot;peak: &quot; INT64_FORMAT &quot;M\n&quot;, (int64_t) pmex.PeakWorkingSetSize &gt;&gt; 20);
1808 
1809     st-&gt;print(&quot;current process commit charge (\&quot;private bytes\&quot;): &quot; INT64_FORMAT &quot;M, &quot;,
1810              (int64_t) pmex.PrivateUsage &gt;&gt; 20);
1811     st-&gt;print(&quot;peak: &quot; INT64_FORMAT &quot;M&quot;, (int64_t) pmex.PeakPagefileUsage &gt;&gt; 20);
1812   } else {
1813     st-&gt;print(&quot;\nGetProcessMemoryInfo did not succeed so we miss some memory values.&quot;);
1814   }
1815 
1816   st-&gt;cr();
1817 }
1818 
1819 bool os::signal_sent_by_kill(const void* siginfo) {
1820   // TODO: Is this possible?
1821   return false;
1822 }
1823 
1824 void os::print_siginfo(outputStream *st, const void* siginfo) {
1825   const EXCEPTION_RECORD* const er = (EXCEPTION_RECORD*)siginfo;
1826   st-&gt;print(&quot;siginfo:&quot;);
1827 
1828   char tmp[64];
1829   if (os::exception_name(er-&gt;ExceptionCode, tmp, sizeof(tmp)) == NULL) {
1830     strcpy(tmp, &quot;EXCEPTION_??&quot;);
1831   }
1832   st-&gt;print(&quot; %s (0x%x)&quot;, tmp, er-&gt;ExceptionCode);
1833 
1834   if ((er-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION ||
1835        er-&gt;ExceptionCode == EXCEPTION_IN_PAGE_ERROR) &amp;&amp;
1836        er-&gt;NumberParameters &gt;= 2) {
1837     switch (er-&gt;ExceptionInformation[0]) {
1838     case 0: st-&gt;print(&quot;, reading address&quot;); break;
1839     case 1: st-&gt;print(&quot;, writing address&quot;); break;
1840     case 8: st-&gt;print(&quot;, data execution prevention violation at address&quot;); break;
1841     default: st-&gt;print(&quot;, ExceptionInformation=&quot; INTPTR_FORMAT,
1842                        er-&gt;ExceptionInformation[0]);
1843     }
1844     st-&gt;print(&quot; &quot; INTPTR_FORMAT, er-&gt;ExceptionInformation[1]);
1845   } else {
1846     int num = er-&gt;NumberParameters;
1847     if (num &gt; 0) {
1848       st-&gt;print(&quot;, ExceptionInformation=&quot;);
1849       for (int i = 0; i &lt; num; i++) {
1850         st-&gt;print(INTPTR_FORMAT &quot; &quot;, er-&gt;ExceptionInformation[i]);
1851       }
1852     }
1853   }
1854   st-&gt;cr();
1855 }
1856 
1857 bool os::signal_thread(Thread* thread, int sig, const char* reason) {
1858   // TODO: Can we kill thread?
1859   return false;
1860 }
1861 
1862 void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {
1863   // do nothing
1864 }
1865 
1866 static char saved_jvm_path[MAX_PATH] = {0};
1867 
1868 // Find the full path to the current module, jvm.dll
1869 void os::jvm_path(char *buf, jint buflen) {
1870   // Error checking.
1871   if (buflen &lt; MAX_PATH) {
1872     assert(false, &quot;must use a large-enough buffer&quot;);
1873     buf[0] = &#39;\0&#39;;
1874     return;
1875   }
1876   // Lazy resolve the path to current module.
1877   if (saved_jvm_path[0] != 0) {
1878     strcpy(buf, saved_jvm_path);
1879     return;
1880   }
1881 
1882   buf[0] = &#39;\0&#39;;
1883   if (Arguments::sun_java_launcher_is_altjvm()) {
1884     // Support for the java launcher&#39;s &#39;-XXaltjvm=&lt;path&gt;&#39; option. Check
1885     // for a JAVA_HOME environment variable and fix up the path so it
1886     // looks like jvm.dll is installed there (append a fake suffix
1887     // hotspot/jvm.dll).
1888     char* java_home_var = ::getenv(&quot;JAVA_HOME&quot;);
1889     if (java_home_var != NULL &amp;&amp; java_home_var[0] != 0 &amp;&amp;
1890         strlen(java_home_var) &lt; (size_t)buflen) {
1891       strncpy(buf, java_home_var, buflen);
1892 
1893       // determine if this is a legacy image or modules image
1894       // modules image doesn&#39;t have &quot;jre&quot; subdirectory
1895       size_t len = strlen(buf);
1896       char* jrebin_p = buf + len;
1897       jio_snprintf(jrebin_p, buflen-len, &quot;\\jre\\bin\\&quot;);
1898       if (0 != _access(buf, 0)) {
1899         jio_snprintf(jrebin_p, buflen-len, &quot;\\bin\\&quot;);
1900       }
1901       len = strlen(buf);
1902       jio_snprintf(buf + len, buflen-len, &quot;hotspot\\jvm.dll&quot;);
1903     }
1904   }
1905 
1906   if (buf[0] == &#39;\0&#39;) {
1907     GetModuleFileName(vm_lib_handle, buf, buflen);
1908   }
1909   strncpy(saved_jvm_path, buf, MAX_PATH);
1910   saved_jvm_path[MAX_PATH - 1] = &#39;\0&#39;;
1911 }
1912 
1913 
1914 void os::print_jni_name_prefix_on(outputStream* st, int args_size) {
1915 #ifndef _WIN64
1916   st-&gt;print(&quot;_&quot;);
1917 #endif
1918 }
1919 
1920 
1921 void os::print_jni_name_suffix_on(outputStream* st, int args_size) {
1922 #ifndef _WIN64
1923   st-&gt;print(&quot;@%d&quot;, args_size  * sizeof(int));
1924 #endif
1925 }
1926 
1927 // This method is a copy of JDK&#39;s sysGetLastErrorString
1928 // from src/windows/hpi/src/system_md.c
1929 
1930 size_t os::lasterror(char* buf, size_t len) {
1931   DWORD errval;
1932 
1933   if ((errval = GetLastError()) != 0) {
1934     // DOS error
1935     size_t n = (size_t)FormatMessage(
1936                                      FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
1937                                      NULL,
1938                                      errval,
1939                                      0,
1940                                      buf,
1941                                      (DWORD)len,
1942                                      NULL);
1943     if (n &gt; 3) {
1944       // Drop final &#39;.&#39;, CR, LF
1945       if (buf[n - 1] == &#39;\n&#39;) n--;
1946       if (buf[n - 1] == &#39;\r&#39;) n--;
1947       if (buf[n - 1] == &#39;.&#39;) n--;
1948       buf[n] = &#39;\0&#39;;
1949     }
1950     return n;
1951   }
1952 
1953   if (errno != 0) {
1954     // C runtime error that has no corresponding DOS error code
1955     const char* s = os::strerror(errno);
1956     size_t n = strlen(s);
1957     if (n &gt;= len) n = len - 1;
1958     strncpy(buf, s, n);
1959     buf[n] = &#39;\0&#39;;
1960     return n;
1961   }
1962 
1963   return 0;
1964 }
1965 
1966 int os::get_last_error() {
1967   DWORD error = GetLastError();
1968   if (error == 0) {
1969     error = errno;
1970   }
1971   return (int)error;
1972 }
1973 
1974 // sun.misc.Signal
1975 // NOTE that this is a workaround for an apparent kernel bug where if
1976 // a signal handler for SIGBREAK is installed then that signal handler
1977 // takes priority over the console control handler for CTRL_CLOSE_EVENT.
1978 // See bug 4416763.
1979 static void (*sigbreakHandler)(int) = NULL;
1980 
1981 static void UserHandler(int sig, void *siginfo, void *context) {
1982   os::signal_notify(sig);
1983   // We need to reinstate the signal handler each time...
1984   os::signal(sig, (void*)UserHandler);
1985 }
1986 
1987 void* os::user_handler() {
1988   return (void*) UserHandler;
1989 }
1990 
1991 void* os::signal(int signal_number, void* handler) {
1992   if ((signal_number == SIGBREAK) &amp;&amp; (!ReduceSignalUsage)) {
1993     void (*oldHandler)(int) = sigbreakHandler;
1994     sigbreakHandler = (void (*)(int)) handler;
1995     return (void*) oldHandler;
1996   } else {
1997     return (void*)::signal(signal_number, (void (*)(int))handler);
1998   }
1999 }
2000 
2001 void os::signal_raise(int signal_number) {
2002   raise(signal_number);
2003 }
2004 
2005 // The Win32 C runtime library maps all console control events other than ^C
2006 // into SIGBREAK, which makes it impossible to distinguish ^BREAK from close,
2007 // logoff, and shutdown events.  We therefore install our own console handler
2008 // that raises SIGTERM for the latter cases.
2009 //
2010 static BOOL WINAPI consoleHandler(DWORD event) {
2011   switch (event) {
2012   case CTRL_C_EVENT:
2013     if (VMError::is_error_reported()) {
2014       // Ctrl-C is pressed during error reporting, likely because the error
2015       // handler fails to abort. Let VM die immediately.
2016       os::die();
2017     }
2018 
2019     os::signal_raise(SIGINT);
2020     return TRUE;
2021     break;
2022   case CTRL_BREAK_EVENT:
2023     if (sigbreakHandler != NULL) {
2024       (*sigbreakHandler)(SIGBREAK);
2025     }
2026     return TRUE;
2027     break;
2028   case CTRL_LOGOFF_EVENT: {
2029     // Don&#39;t terminate JVM if it is running in a non-interactive session,
2030     // such as a service process.
2031     USEROBJECTFLAGS flags;
2032     HANDLE handle = GetProcessWindowStation();
2033     if (handle != NULL &amp;&amp;
2034         GetUserObjectInformation(handle, UOI_FLAGS, &amp;flags,
2035         sizeof(USEROBJECTFLAGS), NULL)) {
2036       // If it is a non-interactive session, let next handler to deal
2037       // with it.
2038       if ((flags.dwFlags &amp; WSF_VISIBLE) == 0) {
2039         return FALSE;
2040       }
2041     }
2042   }
2043   case CTRL_CLOSE_EVENT:
2044   case CTRL_SHUTDOWN_EVENT:
2045     os::signal_raise(SIGTERM);
2046     return TRUE;
2047     break;
2048   default:
2049     break;
2050   }
2051   return FALSE;
2052 }
2053 
2054 // The following code is moved from os.cpp for making this
2055 // code platform specific, which it is by its very nature.
2056 
2057 // Return maximum OS signal used + 1 for internal use only
2058 // Used as exit signal for signal_thread
2059 int os::sigexitnum_pd() {
2060   return NSIG;
2061 }
2062 
2063 // a counter for each possible signal value, including signal_thread exit signal
2064 static volatile jint pending_signals[NSIG+1] = { 0 };
2065 static Semaphore* sig_sem = NULL;
2066 
2067 static void jdk_misc_signal_init() {
2068   // Initialize signal structures
2069   memset((void*)pending_signals, 0, sizeof(pending_signals));
2070 
2071   // Initialize signal semaphore
2072   sig_sem = new Semaphore();
2073 
2074   // Programs embedding the VM do not want it to attempt to receive
2075   // events like CTRL_LOGOFF_EVENT, which are used to implement the
2076   // shutdown hooks mechanism introduced in 1.3.  For example, when
2077   // the VM is run as part of a Windows NT service (i.e., a servlet
2078   // engine in a web server), the correct behavior is for any console
2079   // control handler to return FALSE, not TRUE, because the OS&#39;s
2080   // &quot;final&quot; handler for such events allows the process to continue if
2081   // it is a service (while terminating it if it is not a service).
2082   // To make this behavior uniform and the mechanism simpler, we
2083   // completely disable the VM&#39;s usage of these console events if -Xrs
2084   // (=ReduceSignalUsage) is specified.  This means, for example, that
2085   // the CTRL-BREAK thread dump mechanism is also disabled in this
2086   // case.  See bugs 4323062, 4345157, and related bugs.
2087 
2088   // Add a CTRL-C handler
2089   SetConsoleCtrlHandler(consoleHandler, TRUE);
2090 }
2091 
2092 void os::signal_notify(int sig) {
2093   if (sig_sem != NULL) {
2094     Atomic::inc(&amp;pending_signals[sig]);
2095     sig_sem-&gt;signal();
2096   } else {
2097     // Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init
2098     // initialization isn&#39;t called.
2099     assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
2100   }
2101 }
2102 
2103 static int check_pending_signals() {
2104   while (true) {
2105     for (int i = 0; i &lt; NSIG + 1; i++) {
2106       jint n = pending_signals[i];
2107       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {
2108         return i;
2109       }
2110     }
2111     JavaThread *thread = JavaThread::current();
2112 
2113     ThreadBlockInVM tbivm(thread);
2114 
2115     bool threadIsSuspended;
2116     do {
2117       thread-&gt;set_suspend_equivalent();
2118       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
2119       sig_sem-&gt;wait();
2120 
2121       // were we externally suspended while we were waiting?
2122       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
2123       if (threadIsSuspended) {
2124         // The semaphore has been incremented, but while we were waiting
2125         // another thread suspended us. We don&#39;t want to continue running
2126         // while suspended because that would surprise the thread that
2127         // suspended us.
2128         sig_sem-&gt;signal();
2129 
2130         thread-&gt;java_suspend_self();
2131       }
2132     } while (threadIsSuspended);
2133   }
2134 }
2135 
2136 int os::signal_wait() {
2137   return check_pending_signals();
2138 }
2139 
2140 // Implicit OS exception handling
2141 
2142 LONG Handle_Exception(struct _EXCEPTION_POINTERS* exceptionInfo,
2143                       address handler) {
2144   JavaThread* thread = (JavaThread*) Thread::current_or_null();
2145   // Save pc in thread
2146 #ifdef _M_AMD64
2147   // Do not blow up if no thread info available.
2148   if (thread) {
2149     thread-&gt;set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo-&gt;ContextRecord-&gt;Rip);
2150   }
2151   // Set pc to handler
2152   exceptionInfo-&gt;ContextRecord-&gt;Rip = (DWORD64)handler;
2153 #else
2154   // Do not blow up if no thread info available.
2155   if (thread) {
2156     thread-&gt;set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo-&gt;ContextRecord-&gt;Eip);
2157   }
2158   // Set pc to handler
2159   exceptionInfo-&gt;ContextRecord-&gt;Eip = (DWORD)(DWORD_PTR)handler;
2160 #endif
2161 
2162   // Continue the execution
2163   return EXCEPTION_CONTINUE_EXECUTION;
2164 }
2165 
2166 
2167 // Used for PostMortemDump
2168 extern &quot;C&quot; void safepoints();
2169 extern &quot;C&quot; void find(int x);
2170 extern &quot;C&quot; void events();
2171 
2172 // According to Windows API documentation, an illegal instruction sequence should generate
2173 // the 0xC000001C exception code. However, real world experience shows that occasionnaly
2174 // the execution of an illegal instruction can generate the exception code 0xC000001E. This
2175 // seems to be an undocumented feature of Win NT 4.0 (and probably other Windows systems).
2176 
2177 #define EXCEPTION_ILLEGAL_INSTRUCTION_2 0xC000001E
2178 
2179 // From &quot;Execution Protection in the Windows Operating System&quot; draft 0.35
2180 // Once a system header becomes available, the &quot;real&quot; define should be
2181 // included or copied here.
2182 #define EXCEPTION_INFO_EXEC_VIOLATION 0x08
2183 
2184 // Windows Vista/2008 heap corruption check
2185 #define EXCEPTION_HEAP_CORRUPTION        0xC0000374
2186 
2187 // All Visual C++ exceptions thrown from code generated by the Microsoft Visual
2188 // C++ compiler contain this error code. Because this is a compiler-generated
2189 // error, the code is not listed in the Win32 API header files.
2190 // The code is actually a cryptic mnemonic device, with the initial &quot;E&quot;
2191 // standing for &quot;exception&quot; and the final 3 bytes (0x6D7363) representing the
2192 // ASCII values of &quot;msc&quot;.
2193 
2194 #define EXCEPTION_UNCAUGHT_CXX_EXCEPTION    0xE06D7363
2195 
2196 #define def_excpt(val) { #val, (val) }
2197 
2198 static const struct { const char* name; uint number; } exceptlabels[] = {
2199     def_excpt(EXCEPTION_ACCESS_VIOLATION),
2200     def_excpt(EXCEPTION_DATATYPE_MISALIGNMENT),
2201     def_excpt(EXCEPTION_BREAKPOINT),
2202     def_excpt(EXCEPTION_SINGLE_STEP),
2203     def_excpt(EXCEPTION_ARRAY_BOUNDS_EXCEEDED),
2204     def_excpt(EXCEPTION_FLT_DENORMAL_OPERAND),
2205     def_excpt(EXCEPTION_FLT_DIVIDE_BY_ZERO),
2206     def_excpt(EXCEPTION_FLT_INEXACT_RESULT),
2207     def_excpt(EXCEPTION_FLT_INVALID_OPERATION),
2208     def_excpt(EXCEPTION_FLT_OVERFLOW),
2209     def_excpt(EXCEPTION_FLT_STACK_CHECK),
2210     def_excpt(EXCEPTION_FLT_UNDERFLOW),
2211     def_excpt(EXCEPTION_INT_DIVIDE_BY_ZERO),
2212     def_excpt(EXCEPTION_INT_OVERFLOW),
2213     def_excpt(EXCEPTION_PRIV_INSTRUCTION),
2214     def_excpt(EXCEPTION_IN_PAGE_ERROR),
2215     def_excpt(EXCEPTION_ILLEGAL_INSTRUCTION),
2216     def_excpt(EXCEPTION_ILLEGAL_INSTRUCTION_2),
2217     def_excpt(EXCEPTION_NONCONTINUABLE_EXCEPTION),
2218     def_excpt(EXCEPTION_STACK_OVERFLOW),
2219     def_excpt(EXCEPTION_INVALID_DISPOSITION),
2220     def_excpt(EXCEPTION_GUARD_PAGE),
2221     def_excpt(EXCEPTION_INVALID_HANDLE),
2222     def_excpt(EXCEPTION_UNCAUGHT_CXX_EXCEPTION),
2223     def_excpt(EXCEPTION_HEAP_CORRUPTION)
2224 };
2225 
2226 #undef def_excpt
2227 
2228 const char* os::exception_name(int exception_code, char *buf, size_t size) {
2229   uint code = static_cast&lt;uint&gt;(exception_code);
2230   for (uint i = 0; i &lt; ARRAY_SIZE(exceptlabels); ++i) {
2231     if (exceptlabels[i].number == code) {
2232       jio_snprintf(buf, size, &quot;%s&quot;, exceptlabels[i].name);
2233       return buf;
2234     }
2235   }
2236 
2237   return NULL;
2238 }
2239 
2240 //-----------------------------------------------------------------------------
2241 LONG Handle_IDiv_Exception(struct _EXCEPTION_POINTERS* exceptionInfo) {
2242   // handle exception caused by idiv; should only happen for -MinInt/-1
2243   // (division by zero is handled explicitly)
2244 #ifdef  _M_AMD64
2245   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2246   address pc = (address)ctx-&gt;Rip;
2247   assert(pc[0] &gt;= Assembler::REX &amp;&amp; pc[0] &lt;= Assembler::REX_WRXB &amp;&amp; pc[1] == 0xF7 || pc[0] == 0xF7, &quot;not an idiv opcode&quot;);
2248   assert(pc[0] &gt;= Assembler::REX &amp;&amp; pc[0] &lt;= Assembler::REX_WRXB &amp;&amp; (pc[2] &amp; ~0x7) == 0xF8 || (pc[1] &amp; ~0x7) == 0xF8, &quot;cannot handle non-register operands&quot;);
2249   if (pc[0] == 0xF7) {
2250     // set correct result values and continue after idiv instruction
2251     ctx-&gt;Rip = (DWORD64)pc + 2;        // idiv reg, reg  is 2 bytes
2252   } else {
2253     ctx-&gt;Rip = (DWORD64)pc + 3;        // REX idiv reg, reg  is 3 bytes
2254   }
2255   // Do not set ctx-&gt;Rax as it already contains the correct value (either 32 or 64 bit, depending on the operation)
2256   // this is the case because the exception only happens for -MinValue/-1 and -MinValue is always in rax because of the
2257   // idiv opcode (0xF7).
2258   ctx-&gt;Rdx = (DWORD)0;             // remainder
2259   // Continue the execution
2260 #else
2261   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2262   address pc = (address)ctx-&gt;Eip;
2263   assert(pc[0] == 0xF7, &quot;not an idiv opcode&quot;);
2264   assert((pc[1] &amp; ~0x7) == 0xF8, &quot;cannot handle non-register operands&quot;);
2265   assert(ctx-&gt;Eax == min_jint, &quot;unexpected idiv exception&quot;);
2266   // set correct result values and continue after idiv instruction
2267   ctx-&gt;Eip = (DWORD)pc + 2;        // idiv reg, reg  is 2 bytes
2268   ctx-&gt;Eax = (DWORD)min_jint;      // result
2269   ctx-&gt;Edx = (DWORD)0;             // remainder
2270   // Continue the execution
2271 #endif
2272   return EXCEPTION_CONTINUE_EXECUTION;
2273 }
2274 
2275 //-----------------------------------------------------------------------------
2276 LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo) {
2277   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2278 #ifndef  _WIN64
2279   // handle exception caused by native method modifying control word
2280   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
2281 
2282   switch (exception_code) {
2283   case EXCEPTION_FLT_DENORMAL_OPERAND:
2284   case EXCEPTION_FLT_DIVIDE_BY_ZERO:
2285   case EXCEPTION_FLT_INEXACT_RESULT:
2286   case EXCEPTION_FLT_INVALID_OPERATION:
2287   case EXCEPTION_FLT_OVERFLOW:
2288   case EXCEPTION_FLT_STACK_CHECK:
2289   case EXCEPTION_FLT_UNDERFLOW:
2290     jint fp_control_word = (* (jint*) StubRoutines::addr_fpu_cntrl_wrd_std());
2291     if (fp_control_word != ctx-&gt;FloatSave.ControlWord) {
2292       // Restore FPCW and mask out FLT exceptions
2293       ctx-&gt;FloatSave.ControlWord = fp_control_word | 0xffffffc0;
2294       // Mask out pending FLT exceptions
2295       ctx-&gt;FloatSave.StatusWord &amp;=  0xffffff00;
2296       return EXCEPTION_CONTINUE_EXECUTION;
2297     }
2298   }
2299 
2300   if (prev_uef_handler != NULL) {
2301     // We didn&#39;t handle this exception so pass it to the previous
2302     // UnhandledExceptionFilter.
2303     return (prev_uef_handler)(exceptionInfo);
2304   }
2305 #else // !_WIN64
2306   // On Windows, the mxcsr control bits are non-volatile across calls
2307   // See also CR 6192333
2308   //
2309   jint MxCsr = INITIAL_MXCSR;
2310   // we can&#39;t use StubRoutines::addr_mxcsr_std()
2311   // because in Win64 mxcsr is not saved there
2312   if (MxCsr != ctx-&gt;MxCsr) {
2313     ctx-&gt;MxCsr = MxCsr;
2314     return EXCEPTION_CONTINUE_EXECUTION;
2315   }
2316 #endif // !_WIN64
2317 
2318   return EXCEPTION_CONTINUE_SEARCH;
2319 }
2320 
2321 static inline void report_error(Thread* t, DWORD exception_code,
2322                                 address addr, void* siginfo, void* context) {
2323   VMError::report_and_die(t, exception_code, addr, siginfo, context);
2324 
2325   // If UseOsErrorReporting, this will return here and save the error file
2326   // somewhere where we can find it in the minidump.
2327 }
2328 
2329 bool os::win32::get_frame_at_stack_banging_point(JavaThread* thread,
2330         struct _EXCEPTION_POINTERS* exceptionInfo, address pc, frame* fr) {
2331   PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2332   address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2333   if (Interpreter::contains(pc)) {
2334     *fr = os::fetch_frame_from_context((void*)exceptionInfo-&gt;ContextRecord);
2335     if (!fr-&gt;is_first_java_frame()) {
2336       // get_frame_at_stack_banging_point() is only called when we
2337       // have well defined stacks so java_sender() calls do not need
2338       // to assert safe_for_sender() first.
2339       *fr = fr-&gt;java_sender();
2340     }
2341   } else {
2342     // more complex code with compiled code
2343     assert(!Interpreter::contains(pc), &quot;Interpreted methods should have been handled above&quot;);
2344     CodeBlob* cb = CodeCache::find_blob(pc);
2345     if (cb == NULL || !cb-&gt;is_nmethod() || cb-&gt;is_frame_complete_at(pc)) {
2346       // Not sure where the pc points to, fallback to default
2347       // stack overflow handling
2348       return false;
2349     } else {
2350       *fr = os::fetch_frame_from_context((void*)exceptionInfo-&gt;ContextRecord);
2351       // in compiled code, the stack banging is performed just after the return pc
2352       // has been pushed on the stack
2353       *fr = frame(fr-&gt;sp() + 1, fr-&gt;fp(), (address)*(fr-&gt;sp()));
2354       if (!fr-&gt;is_java_frame()) {
2355         // See java_sender() comment above.
2356         *fr = fr-&gt;java_sender();
2357       }
2358     }
2359   }
2360   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);
2361   return true;
2362 }
2363 
2364 #if INCLUDE_AOT
2365 LONG WINAPI topLevelVectoredExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {
2366   PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2367   address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2368   address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Rip;
2369 
2370   // Handle the case where we get an implicit exception in AOT generated
2371   // code.  AOT DLL&#39;s loaded are not registered for structured exceptions.
2372   // If the exception occurred in the codeCache or AOT code, pass control
2373   // to our normal exception handler.
2374   CodeBlob* cb = CodeCache::find_blob(pc);
2375   if (cb != NULL) {
2376     return topLevelExceptionFilter(exceptionInfo);
2377   }
2378 
2379   return EXCEPTION_CONTINUE_SEARCH;
2380 }
2381 #endif
2382 
2383 //-----------------------------------------------------------------------------
2384 LONG WINAPI topLevelExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {
2385   if (InterceptOSException) return EXCEPTION_CONTINUE_SEARCH;
2386   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
2387 #ifdef _M_AMD64
2388   address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Rip;
2389 #else
2390   address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Eip;
2391 #endif
2392   Thread* t = Thread::current_or_null_safe();
2393 
2394   // Handle SafeFetch32 and SafeFetchN exceptions.
2395   if (StubRoutines::is_safefetch_fault(pc)) {
2396     return Handle_Exception(exceptionInfo, StubRoutines::continuation_for_safefetch_fault(pc));
2397   }
2398 
2399 #ifndef _WIN64
2400   // Execution protection violation - win32 running on AMD64 only
2401   // Handled first to avoid misdiagnosis as a &quot;normal&quot; access violation;
2402   // This is safe to do because we have a new/unique ExceptionInformation
2403   // code for this condition.
2404   if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2405     PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2406     int exception_subcode = (int) exceptionRecord-&gt;ExceptionInformation[0];
2407     address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2408 
2409     if (exception_subcode == EXCEPTION_INFO_EXEC_VIOLATION) {
2410       int page_size = os::vm_page_size();
2411 
2412       // Make sure the pc and the faulting address are sane.
2413       //
2414       // If an instruction spans a page boundary, and the page containing
2415       // the beginning of the instruction is executable but the following
2416       // page is not, the pc and the faulting address might be slightly
2417       // different - we still want to unguard the 2nd page in this case.
2418       //
2419       // 15 bytes seems to be a (very) safe value for max instruction size.
2420       bool pc_is_near_addr =
2421         (pointer_delta((void*) addr, (void*) pc, sizeof(char)) &lt; 15);
2422       bool instr_spans_page_boundary =
2423         (align_down((intptr_t) pc ^ (intptr_t) addr,
2424                          (intptr_t) page_size) &gt; 0);
2425 
2426       if (pc == addr || (pc_is_near_addr &amp;&amp; instr_spans_page_boundary)) {
2427         static volatile address last_addr =
2428           (address) os::non_memory_address_word();
2429 
2430         // In conservative mode, don&#39;t unguard unless the address is in the VM
2431         if (UnguardOnExecutionViolation &gt; 0 &amp;&amp; addr != last_addr &amp;&amp;
2432             (UnguardOnExecutionViolation &gt; 1 || os::address_is_in_vm(addr))) {
2433 
2434           // Set memory to RWX and retry
2435           address page_start = align_down(addr, page_size);
2436           bool res = os::protect_memory((char*) page_start, page_size,
2437                                         os::MEM_PROT_RWX);
2438 
2439           log_debug(os)(&quot;Execution protection violation &quot;
2440                         &quot;at &quot; INTPTR_FORMAT
2441                         &quot;, unguarding &quot; INTPTR_FORMAT &quot;: %s&quot;, p2i(addr),
2442                         p2i(page_start), (res ? &quot;success&quot; : os::strerror(errno)));
2443 
2444           // Set last_addr so if we fault again at the same address, we don&#39;t
2445           // end up in an endless loop.
2446           //
2447           // There are two potential complications here.  Two threads trapping
2448           // at the same address at the same time could cause one of the
2449           // threads to think it already unguarded, and abort the VM.  Likely
2450           // very rare.
2451           //
2452           // The other race involves two threads alternately trapping at
2453           // different addresses and failing to unguard the page, resulting in
2454           // an endless loop.  This condition is probably even more unlikely
2455           // than the first.
2456           //
2457           // Although both cases could be avoided by using locks or thread
2458           // local last_addr, these solutions are unnecessary complication:
2459           // this handler is a best-effort safety net, not a complete solution.
2460           // It is disabled by default and should only be used as a workaround
2461           // in case we missed any no-execute-unsafe VM code.
2462 
2463           last_addr = addr;
2464 
2465           return EXCEPTION_CONTINUE_EXECUTION;
2466         }
2467       }
2468 
2469       // Last unguard failed or not unguarding
2470       tty-&gt;print_raw_cr(&quot;Execution protection violation&quot;);
2471       report_error(t, exception_code, addr, exceptionInfo-&gt;ExceptionRecord,
2472                    exceptionInfo-&gt;ContextRecord);
2473       return EXCEPTION_CONTINUE_SEARCH;
2474     }
2475   }
2476 #endif // _WIN64
2477 
2478   if ((exception_code == EXCEPTION_ACCESS_VIOLATION) &amp;&amp;
2479       VM_Version::is_cpuinfo_segv_addr(pc)) {
2480     // Verify that OS save/restore AVX registers.
2481     return Handle_Exception(exceptionInfo, VM_Version::cpuinfo_cont_addr());
2482   }
2483 
2484   if (t != NULL &amp;&amp; t-&gt;is_Java_thread()) {
2485     JavaThread* thread = (JavaThread*) t;
2486     bool in_java = thread-&gt;thread_state() == _thread_in_Java;
2487 
2488     // Handle potential stack overflows up front.
2489     if (exception_code == EXCEPTION_STACK_OVERFLOW) {
2490       if (thread-&gt;stack_guards_enabled()) {
2491         if (in_java) {
2492           frame fr;
2493           PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2494           address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2495           if (os::win32::get_frame_at_stack_banging_point(thread, exceptionInfo, pc, &amp;fr)) {
2496             assert(fr.is_java_frame(), &quot;Must be a Java frame&quot;);
2497             SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
2498           }
2499         }
2500         // Yellow zone violation.  The o/s has unprotected the first yellow
2501         // zone page for us.  Note:  must call disable_stack_yellow_zone to
2502         // update the enabled status, even if the zone contains only one page.
2503         assert(thread-&gt;thread_state() != _thread_in_vm, &quot;Undersized StackShadowPages&quot;);
2504         thread-&gt;disable_stack_yellow_reserved_zone();
2505         // If not in java code, return and hope for the best.
2506         return in_java
2507             ? Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW))
2508             :  EXCEPTION_CONTINUE_EXECUTION;
2509       } else {
2510         // Fatal red zone violation.
2511         thread-&gt;disable_stack_red_zone();
2512         tty-&gt;print_raw_cr(&quot;An unrecoverable stack overflow has occurred.&quot;);
2513         report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2514                       exceptionInfo-&gt;ContextRecord);
2515         return EXCEPTION_CONTINUE_SEARCH;
2516       }
2517     } else if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2518       // Either stack overflow or null pointer exception.
2519       if (in_java) {
2520         PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2521         address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2522         address stack_end = thread-&gt;stack_end();
2523         if (addr &lt; stack_end &amp;&amp; addr &gt;= stack_end - os::vm_page_size()) {
2524           // Stack overflow.
2525           assert(!os::uses_stack_guard_pages(),
2526                  &quot;should be caught by red zone code above.&quot;);
2527           return Handle_Exception(exceptionInfo,
2528                                   SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW));
2529         }
2530         // Check for safepoint polling and implicit null
2531         // We only expect null pointers in the stubs (vtable)
2532         // the rest are checked explicitly now.
2533         CodeBlob* cb = CodeCache::find_blob(pc);
2534         if (cb != NULL) {
2535           if (SafepointMechanism::is_poll_address(addr)) {
2536             address stub = SharedRuntime::get_poll_stub(pc);
2537             return Handle_Exception(exceptionInfo, stub);
2538           }
2539         }
2540         {
2541 #ifdef _WIN64
2542           // If it&#39;s a legal stack address map the entire region in
2543           //
2544           PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2545           address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2546           if (thread-&gt;is_in_usable_stack(addr)) {
2547             addr = (address)((uintptr_t)addr &amp;
2548                              (~((uintptr_t)os::vm_page_size() - (uintptr_t)1)));
2549             os::commit_memory((char *)addr, thread-&gt;stack_base() - addr,
2550                               !ExecMem);
2551             return EXCEPTION_CONTINUE_EXECUTION;
2552           } else
2553 #endif
2554           {
2555             // Null pointer exception.
2556             if (MacroAssembler::uses_implicit_null_check((void*)addr)) {
2557               address stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
2558               if (stub != NULL) return Handle_Exception(exceptionInfo, stub);
2559             }
2560             report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2561                          exceptionInfo-&gt;ContextRecord);
2562             return EXCEPTION_CONTINUE_SEARCH;
2563           }
2564         }
2565       }
2566 
2567 #ifdef _WIN64
2568       // Special care for fast JNI field accessors.
2569       // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks
2570       // in and the heap gets shrunk before the field access.
2571       if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2572         address addr = JNI_FastGetField::find_slowcase_pc(pc);
2573         if (addr != (address)-1) {
2574           return Handle_Exception(exceptionInfo, addr);
2575         }
2576       }
2577 #endif
2578 
2579       // Stack overflow or null pointer exception in native code.
2580       report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2581                    exceptionInfo-&gt;ContextRecord);
2582       return EXCEPTION_CONTINUE_SEARCH;
2583     } // /EXCEPTION_ACCESS_VIOLATION
2584     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2585 
2586     if (exception_code == EXCEPTION_IN_PAGE_ERROR) {
2587       CompiledMethod* nm = NULL;
2588       JavaThread* thread = (JavaThread*)t;
2589       if (in_java) {
2590         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
2591         nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
2592       }
2593 
2594       bool is_unsafe_arraycopy = (thread-&gt;thread_state() == _thread_in_native || in_java) &amp;&amp; UnsafeCopyMemory::contains_pc(pc);
2595       if (((thread-&gt;thread_state() == _thread_in_vm ||
2596            thread-&gt;thread_state() == _thread_in_native ||
2597            is_unsafe_arraycopy) &amp;&amp;
2598           thread-&gt;doing_unsafe_access()) ||
2599           (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access())) {
2600         address next_pc =  Assembler::locate_next_instruction(pc);
2601         if (is_unsafe_arraycopy) {
2602           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
2603         }
2604         return Handle_Exception(exceptionInfo, SharedRuntime::handle_unsafe_access(thread, next_pc));
2605       }
2606     }
2607 
2608     if (in_java) {
2609       switch (exception_code) {
2610       case EXCEPTION_INT_DIVIDE_BY_ZERO:
2611         return Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO));
2612 
2613       case EXCEPTION_INT_OVERFLOW:
2614         return Handle_IDiv_Exception(exceptionInfo);
2615 
2616       } // switch
2617     }
2618     if (((thread-&gt;thread_state() == _thread_in_Java) ||
2619          (thread-&gt;thread_state() == _thread_in_native)) &amp;&amp;
2620          exception_code != EXCEPTION_UNCAUGHT_CXX_EXCEPTION) {
2621       LONG result=Handle_FLT_Exception(exceptionInfo);
2622       if (result==EXCEPTION_CONTINUE_EXECUTION) return result;
2623     }
2624   }
2625 
2626   if (exception_code != EXCEPTION_BREAKPOINT) {
2627     report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2628                  exceptionInfo-&gt;ContextRecord);
2629   }
2630   return EXCEPTION_CONTINUE_SEARCH;
2631 }
2632 
2633 #ifndef _WIN64
2634 // Special care for fast JNI accessors.
2635 // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in and
2636 // the heap gets shrunk before the field access.
2637 // Need to install our own structured exception handler since native code may
2638 // install its own.
2639 LONG WINAPI fastJNIAccessorExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {
2640   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
2641   if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2642     address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Eip;
2643     address addr = JNI_FastGetField::find_slowcase_pc(pc);
2644     if (addr != (address)-1) {
2645       return Handle_Exception(exceptionInfo, addr);
2646     }
2647   }
2648   return EXCEPTION_CONTINUE_SEARCH;
2649 }
2650 
2651 #define DEFINE_FAST_GETFIELD(Return, Fieldname, Result)                     \
2652   Return JNICALL jni_fast_Get##Result##Field_wrapper(JNIEnv *env,           \
2653                                                      jobject obj,           \
2654                                                      jfieldID fieldID) {    \
2655     __try {                                                                 \
2656       return (*JNI_FastGetField::jni_fast_Get##Result##Field_fp)(env,       \
2657                                                                  obj,       \
2658                                                                  fieldID);  \
2659     } __except(fastJNIAccessorExceptionFilter((_EXCEPTION_POINTERS*)        \
2660                                               _exception_info())) {         \
2661     }                                                                       \
2662     return 0;                                                               \
2663   }
2664 
2665 DEFINE_FAST_GETFIELD(jboolean, bool,   Boolean)
2666 DEFINE_FAST_GETFIELD(jbyte,    byte,   Byte)
2667 DEFINE_FAST_GETFIELD(jchar,    char,   Char)
2668 DEFINE_FAST_GETFIELD(jshort,   short,  Short)
2669 DEFINE_FAST_GETFIELD(jint,     int,    Int)
2670 DEFINE_FAST_GETFIELD(jlong,    long,   Long)
2671 DEFINE_FAST_GETFIELD(jfloat,   float,  Float)
2672 DEFINE_FAST_GETFIELD(jdouble,  double, Double)
2673 
2674 address os::win32::fast_jni_accessor_wrapper(BasicType type) {
2675   switch (type) {
2676   case T_BOOLEAN: return (address)jni_fast_GetBooleanField_wrapper;
2677   case T_BYTE:    return (address)jni_fast_GetByteField_wrapper;
2678   case T_CHAR:    return (address)jni_fast_GetCharField_wrapper;
2679   case T_SHORT:   return (address)jni_fast_GetShortField_wrapper;
2680   case T_INT:     return (address)jni_fast_GetIntField_wrapper;
2681   case T_LONG:    return (address)jni_fast_GetLongField_wrapper;
2682   case T_FLOAT:   return (address)jni_fast_GetFloatField_wrapper;
2683   case T_DOUBLE:  return (address)jni_fast_GetDoubleField_wrapper;
2684   default:        ShouldNotReachHere();
2685   }
2686   return (address)-1;
2687 }
2688 #endif
2689 
2690 // Virtual Memory
2691 
2692 int os::vm_page_size() { return os::win32::vm_page_size(); }
2693 int os::vm_allocation_granularity() {
2694   return os::win32::vm_allocation_granularity();
2695 }
2696 
2697 // Windows large page support is available on Windows 2003. In order to use
2698 // large page memory, the administrator must first assign additional privilege
2699 // to the user:
2700 //   + select Control Panel -&gt; Administrative Tools -&gt; Local Security Policy
2701 //   + select Local Policies -&gt; User Rights Assignment
2702 //   + double click &quot;Lock pages in memory&quot;, add users and/or groups
2703 //   + reboot
2704 // Note the above steps are needed for administrator as well, as administrators
2705 // by default do not have the privilege to lock pages in memory.
2706 //
2707 // Note about Windows 2003: although the API supports committing large page
2708 // memory on a page-by-page basis and VirtualAlloc() returns success under this
2709 // scenario, I found through experiment it only uses large page if the entire
2710 // memory region is reserved and committed in a single VirtualAlloc() call.
2711 // This makes Windows large page support more or less like Solaris ISM, in
2712 // that the entire heap must be committed upfront. This probably will change
2713 // in the future, if so the code below needs to be revisited.
2714 
2715 #ifndef MEM_LARGE_PAGES
2716   #define MEM_LARGE_PAGES 0x20000000
2717 #endif
2718 
2719 static HANDLE    _hProcess;
2720 static HANDLE    _hToken;
2721 
2722 // Container for NUMA node list info
2723 class NUMANodeListHolder {
2724  private:
2725   int *_numa_used_node_list;  // allocated below
2726   int _numa_used_node_count;
2727 
2728   void free_node_list() {
2729     FREE_C_HEAP_ARRAY(int, _numa_used_node_list);
2730   }
2731 
2732  public:
2733   NUMANodeListHolder() {
2734     _numa_used_node_count = 0;
2735     _numa_used_node_list = NULL;
2736     // do rest of initialization in build routine (after function pointers are set up)
2737   }
2738 
2739   ~NUMANodeListHolder() {
2740     free_node_list();
2741   }
2742 
2743   bool build() {
2744     DWORD_PTR proc_aff_mask;
2745     DWORD_PTR sys_aff_mask;
2746     if (!GetProcessAffinityMask(GetCurrentProcess(), &amp;proc_aff_mask, &amp;sys_aff_mask)) return false;
2747     ULONG highest_node_number;
2748     if (!GetNumaHighestNodeNumber(&amp;highest_node_number)) return false;
2749     free_node_list();
2750     _numa_used_node_list = NEW_C_HEAP_ARRAY(int, highest_node_number + 1, mtInternal);
2751     for (unsigned int i = 0; i &lt;= highest_node_number; i++) {
2752       ULONGLONG proc_mask_numa_node;
2753       if (!GetNumaNodeProcessorMask(i, &amp;proc_mask_numa_node)) return false;
2754       if ((proc_aff_mask &amp; proc_mask_numa_node)!=0) {
2755         _numa_used_node_list[_numa_used_node_count++] = i;
2756       }
2757     }
2758     return (_numa_used_node_count &gt; 1);
2759   }
2760 
2761   int get_count() { return _numa_used_node_count; }
2762   int get_node_list_entry(int n) {
2763     // for indexes out of range, returns -1
2764     return (n &lt; _numa_used_node_count ? _numa_used_node_list[n] : -1);
2765   }
2766 
2767 } numa_node_list_holder;
2768 
2769 
2770 
2771 static size_t _large_page_size = 0;
2772 
2773 static bool request_lock_memory_privilege() {
2774   _hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE,
2775                           os::current_process_id());
2776 
2777   LUID luid;
2778   if (_hProcess != NULL &amp;&amp;
2779       OpenProcessToken(_hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;_hToken) &amp;&amp;
2780       LookupPrivilegeValue(NULL, &quot;SeLockMemoryPrivilege&quot;, &amp;luid)) {
2781 
2782     TOKEN_PRIVILEGES tp;
2783     tp.PrivilegeCount = 1;
2784     tp.Privileges[0].Luid = luid;
2785     tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
2786 
2787     // AdjustTokenPrivileges() may return TRUE even when it couldn&#39;t change the
2788     // privilege. Check GetLastError() too. See MSDN document.
2789     if (AdjustTokenPrivileges(_hToken, false, &amp;tp, sizeof(tp), NULL, NULL) &amp;&amp;
2790         (GetLastError() == ERROR_SUCCESS)) {
2791       return true;
2792     }
2793   }
2794 
2795   return false;
2796 }
2797 
2798 static void cleanup_after_large_page_init() {
2799   if (_hProcess) CloseHandle(_hProcess);
2800   _hProcess = NULL;
2801   if (_hToken) CloseHandle(_hToken);
2802   _hToken = NULL;
2803 }
2804 
2805 static bool numa_interleaving_init() {
2806   bool success = false;
2807   bool use_numa_interleaving_specified = !FLAG_IS_DEFAULT(UseNUMAInterleaving);
2808 
2809   // print a warning if UseNUMAInterleaving flag is specified on command line
2810   bool warn_on_failure = use_numa_interleaving_specified;
2811 #define WARN(msg) if (warn_on_failure) { warning(msg); }
2812 
2813   // NUMAInterleaveGranularity cannot be less than vm_allocation_granularity (or _large_page_size if using large pages)
2814   size_t min_interleave_granularity = UseLargePages ? _large_page_size : os::vm_allocation_granularity();
2815   NUMAInterleaveGranularity = align_up(NUMAInterleaveGranularity, min_interleave_granularity);
2816 
2817   if (numa_node_list_holder.build()) {
2818     if (log_is_enabled(Debug, os, cpu)) {
2819       Log(os, cpu) log;
2820       log.debug(&quot;NUMA UsedNodeCount=%d, namely &quot;, numa_node_list_holder.get_count());
2821       for (int i = 0; i &lt; numa_node_list_holder.get_count(); i++) {
2822         log.debug(&quot;  %d &quot;, numa_node_list_holder.get_node_list_entry(i));
2823       }
2824     }
2825     success = true;
2826   } else {
2827     WARN(&quot;Process does not cover multiple NUMA nodes.&quot;);
2828   }
2829   if (!success) {
2830     if (use_numa_interleaving_specified) WARN(&quot;...Ignoring UseNUMAInterleaving flag.&quot;);
2831   }
2832   return success;
2833 #undef WARN
2834 }
2835 
2836 // this routine is used whenever we need to reserve a contiguous VA range
2837 // but we need to make separate VirtualAlloc calls for each piece of the range
2838 // Reasons for doing this:
2839 //  * UseLargePagesIndividualAllocation was set (normally only needed on WS2003 but possible to be set otherwise)
2840 //  * UseNUMAInterleaving requires a separate node for each piece
2841 static char* allocate_pages_individually(size_t bytes, char* addr, DWORD flags,
2842                                          DWORD prot,
2843                                          bool should_inject_error = false) {
2844   char * p_buf;
2845   // note: at setup time we guaranteed that NUMAInterleaveGranularity was aligned up to a page size
2846   size_t page_size = UseLargePages ? _large_page_size : os::vm_allocation_granularity();
2847   size_t chunk_size = UseNUMAInterleaving ? NUMAInterleaveGranularity : page_size;
2848 
2849   // first reserve enough address space in advance since we want to be
2850   // able to break a single contiguous virtual address range into multiple
2851   // large page commits but WS2003 does not allow reserving large page space
2852   // so we just use 4K pages for reserve, this gives us a legal contiguous
2853   // address space. then we will deallocate that reservation, and re alloc
2854   // using large pages
2855   const size_t size_of_reserve = bytes + chunk_size;
2856   if (bytes &gt; size_of_reserve) {
2857     // Overflowed.
2858     return NULL;
2859   }
2860   p_buf = (char *) VirtualAlloc(addr,
2861                                 size_of_reserve,  // size of Reserve
2862                                 MEM_RESERVE,
2863                                 PAGE_READWRITE);
2864   // If reservation failed, return NULL
2865   if (p_buf == NULL) return NULL;
2866   MemTracker::record_virtual_memory_reserve((address)p_buf, size_of_reserve, CALLER_PC);
2867   os::release_memory(p_buf, bytes + chunk_size);
2868 
2869   // we still need to round up to a page boundary (in case we are using large pages)
2870   // but not to a chunk boundary (in case InterleavingGranularity doesn&#39;t align with page size)
2871   // instead we handle this in the bytes_to_rq computation below
2872   p_buf = align_up(p_buf, page_size);
2873 
2874   // now go through and allocate one chunk at a time until all bytes are
2875   // allocated
2876   size_t  bytes_remaining = bytes;
2877   // An overflow of align_up() would have been caught above
2878   // in the calculation of size_of_reserve.
2879   char * next_alloc_addr = p_buf;
2880   HANDLE hProc = GetCurrentProcess();
2881 
2882 #ifdef ASSERT
2883   // Variable for the failure injection
2884   int ran_num = os::random();
2885   size_t fail_after = ran_num % bytes;
2886 #endif
2887 
2888   int count=0;
2889   while (bytes_remaining) {
2890     // select bytes_to_rq to get to the next chunk_size boundary
2891 
2892     size_t bytes_to_rq = MIN2(bytes_remaining, chunk_size - ((size_t)next_alloc_addr % chunk_size));
2893     // Note allocate and commit
2894     char * p_new;
2895 
2896 #ifdef ASSERT
2897     bool inject_error_now = should_inject_error &amp;&amp; (bytes_remaining &lt;= fail_after);
2898 #else
2899     const bool inject_error_now = false;
2900 #endif
2901 
2902     if (inject_error_now) {
2903       p_new = NULL;
2904     } else {
2905       if (!UseNUMAInterleaving) {
2906         p_new = (char *) VirtualAlloc(next_alloc_addr,
2907                                       bytes_to_rq,
2908                                       flags,
2909                                       prot);
2910       } else {
2911         // get the next node to use from the used_node_list
2912         assert(numa_node_list_holder.get_count() &gt; 0, &quot;Multiple NUMA nodes expected&quot;);
2913         DWORD node = numa_node_list_holder.get_node_list_entry(count % numa_node_list_holder.get_count());
2914         p_new = (char *)VirtualAllocExNuma(hProc, next_alloc_addr, bytes_to_rq, flags, prot, node);
2915       }
2916     }
2917 
2918     if (p_new == NULL) {
2919       // Free any allocated pages
2920       if (next_alloc_addr &gt; p_buf) {
2921         // Some memory was committed so release it.
2922         size_t bytes_to_release = bytes - bytes_remaining;
2923         // NMT has yet to record any individual blocks, so it
2924         // need to create a dummy &#39;reserve&#39; record to match
2925         // the release.
2926         MemTracker::record_virtual_memory_reserve((address)p_buf,
2927                                                   bytes_to_release, CALLER_PC);
2928         os::release_memory(p_buf, bytes_to_release);
2929       }
2930 #ifdef ASSERT
2931       if (should_inject_error) {
2932         log_develop_debug(pagesize)(&quot;Reserving pages individually failed.&quot;);
2933       }
2934 #endif
2935       return NULL;
2936     }
2937 
2938     bytes_remaining -= bytes_to_rq;
2939     next_alloc_addr += bytes_to_rq;
2940     count++;
2941   }
2942   // Although the memory is allocated individually, it is returned as one.
2943   // NMT records it as one block.
2944   if ((flags &amp; MEM_COMMIT) != 0) {
2945     MemTracker::record_virtual_memory_reserve_and_commit((address)p_buf, bytes, CALLER_PC);
2946   } else {
2947     MemTracker::record_virtual_memory_reserve((address)p_buf, bytes, CALLER_PC);
2948   }
2949 
2950   // made it this far, success
2951   return p_buf;
2952 }
2953 
2954 
2955 
2956 void os::large_page_init() {
2957   if (!UseLargePages) return;
2958 
2959   // print a warning if any large page related flag is specified on command line
2960   bool warn_on_failure = !FLAG_IS_DEFAULT(UseLargePages) ||
2961                          !FLAG_IS_DEFAULT(LargePageSizeInBytes);
2962   bool success = false;
2963 
2964 #define WARN(msg) if (warn_on_failure) { warning(msg); }
2965   if (request_lock_memory_privilege()) {
2966     size_t s = GetLargePageMinimum();
2967     if (s) {
2968 #if defined(IA32) || defined(AMD64)
2969       if (s &gt; 4*M || LargePageSizeInBytes &gt; 4*M) {
2970         WARN(&quot;JVM cannot use large pages bigger than 4mb.&quot;);
2971       } else {
2972 #endif
2973         if (LargePageSizeInBytes &amp;&amp; LargePageSizeInBytes % s == 0) {
2974           _large_page_size = LargePageSizeInBytes;
2975         } else {
2976           _large_page_size = s;
2977         }
2978         success = true;
2979 #if defined(IA32) || defined(AMD64)
2980       }
2981 #endif
2982     } else {
2983       WARN(&quot;Large page is not supported by the processor.&quot;);
2984     }
2985   } else {
2986     WARN(&quot;JVM cannot use large page memory because it does not have enough privilege to lock pages in memory.&quot;);
2987   }
2988 #undef WARN
2989 
2990   const size_t default_page_size = (size_t) vm_page_size();
2991   if (success &amp;&amp; _large_page_size &gt; default_page_size) {
2992     _page_sizes[0] = _large_page_size;
2993     _page_sizes[1] = default_page_size;
2994     _page_sizes[2] = 0;
2995   }
2996 
2997   cleanup_after_large_page_init();
2998   UseLargePages = success;
2999 }
3000 
3001 int os::create_file_for_heap(const char* dir) {
3002 
3003   const char name_template[] = &quot;/jvmheap.XXXXXX&quot;;
3004 
3005   size_t fullname_len = strlen(dir) + strlen(name_template);
3006   char *fullname = (char*)os::malloc(fullname_len + 1, mtInternal);
3007   if (fullname == NULL) {
3008     vm_exit_during_initialization(err_msg(&quot;Malloc failed during creation of backing file for heap (%s)&quot;, os::strerror(errno)));
3009     return -1;
3010   }
3011   int n = snprintf(fullname, fullname_len + 1, &quot;%s%s&quot;, dir, name_template);
3012   assert((size_t)n == fullname_len, &quot;Unexpected number of characters in string&quot;);
3013 
3014   os::native_path(fullname);
3015 
3016   char *path = _mktemp(fullname);
3017   if (path == NULL) {
3018     warning(&quot;_mktemp could not create file name from template %s (%s)&quot;, fullname, os::strerror(errno));
3019     os::free(fullname);
3020     return -1;
3021   }
3022 
3023   int fd = _open(path, O_RDWR | O_CREAT | O_TEMPORARY | O_EXCL, S_IWRITE | S_IREAD);
3024 
3025   os::free(fullname);
3026   if (fd &lt; 0) {
3027     warning(&quot;Problem opening file for heap (%s)&quot;, os::strerror(errno));
3028     return -1;
3029   }
3030   return fd;
3031 }
3032 
3033 // If &#39;base&#39; is not NULL, function will return NULL if it cannot get &#39;base&#39;
3034 char* os::map_memory_to_file(char* base, size_t size, int fd) {
3035   assert(fd != -1, &quot;File descriptor is not valid&quot;);
3036 
3037   HANDLE fh = (HANDLE)_get_osfhandle(fd);
3038 #ifdef _LP64
3039   HANDLE fileMapping = CreateFileMapping(fh, NULL, PAGE_READWRITE,
3040     (DWORD)(size &gt;&gt; 32), (DWORD)(size &amp; 0xFFFFFFFF), NULL);
3041 #else
3042   HANDLE fileMapping = CreateFileMapping(fh, NULL, PAGE_READWRITE,
3043     0, (DWORD)size, NULL);
3044 #endif
3045   if (fileMapping == NULL) {
3046     if (GetLastError() == ERROR_DISK_FULL) {
3047       vm_exit_during_initialization(err_msg(&quot;Could not allocate sufficient disk space for Java heap&quot;));
3048     }
3049     else {
3050       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
3051     }
3052 
3053     return NULL;
3054   }
3055 
3056   LPVOID addr = MapViewOfFileEx(fileMapping, FILE_MAP_WRITE, 0, 0, size, base);
3057 
3058   CloseHandle(fileMapping);
3059 
3060   return (char*)addr;
3061 }
3062 
3063 char* os::replace_existing_mapping_with_file_mapping(char* base, size_t size, int fd) {
3064   assert(fd != -1, &quot;File descriptor is not valid&quot;);
3065   assert(base != NULL, &quot;Base address cannot be NULL&quot;);
3066 
3067   release_memory(base, size);
3068   return map_memory_to_file(base, size, fd);
3069 }
3070 
3071 // On win32, one cannot release just a part of reserved memory, it&#39;s an
3072 // all or nothing deal.  When we split a reservation, we must break the
3073 // reservation into two reservations.
3074 void os::pd_split_reserved_memory(char *base, size_t size, size_t split,
3075                                   bool realloc) {
3076   if (size &gt; 0) {
3077     release_memory(base, size);
3078     if (realloc) {
3079       reserve_memory(split, base);
3080     }
3081     if (size != split) {
3082       reserve_memory(size - split, base + split);
3083     }
3084   }
3085 }
3086 
3087 // Multiple threads can race in this code but it&#39;s not possible to unmap small sections of
3088 // virtual space to get requested alignment, like posix-like os&#39;s.
3089 // Windows prevents multiple thread from remapping over each other so this loop is thread-safe.
3090 char* os::reserve_memory_aligned(size_t size, size_t alignment, int file_desc) {
3091   assert((alignment &amp; (os::vm_allocation_granularity() - 1)) == 0,
3092          &quot;Alignment must be a multiple of allocation granularity (page size)&quot;);
3093   assert((size &amp; (alignment -1)) == 0, &quot;size must be &#39;alignment&#39; aligned&quot;);
3094 
3095   size_t extra_size = size + alignment;
3096   assert(extra_size &gt;= size, &quot;overflow, size is too large to allow alignment&quot;);
3097 
3098   char* aligned_base = NULL;
3099 
3100   do {
3101     char* extra_base = os::reserve_memory(extra_size, NULL, alignment, file_desc);
3102     if (extra_base == NULL) {
3103       return NULL;
3104     }
3105     // Do manual alignment
3106     aligned_base = align_up(extra_base, alignment);
3107 
3108     if (file_desc != -1) {
3109       os::unmap_memory(extra_base, extra_size);
3110     } else {
3111       os::release_memory(extra_base, extra_size);
3112     }
3113 
3114     aligned_base = os::reserve_memory(size, aligned_base, 0, file_desc);
3115 
3116   } while (aligned_base == NULL);
3117 
3118   return aligned_base;
3119 }
3120 
3121 char* os::pd_reserve_memory(size_t bytes, char* addr, size_t alignment_hint) {
3122   assert((size_t)addr % os::vm_allocation_granularity() == 0,
3123          &quot;reserve alignment&quot;);
3124   assert(bytes % os::vm_page_size() == 0, &quot;reserve page size&quot;);
3125   char* res;
3126   // note that if UseLargePages is on, all the areas that require interleaving
3127   // will go thru reserve_memory_special rather than thru here.
3128   bool use_individual = (UseNUMAInterleaving &amp;&amp; !UseLargePages);
3129   if (!use_individual) {
3130     res = (char*)VirtualAlloc(addr, bytes, MEM_RESERVE, PAGE_READWRITE);
3131   } else {
3132     elapsedTimer reserveTimer;
3133     if (Verbose &amp;&amp; PrintMiscellaneous) reserveTimer.start();
3134     // in numa interleaving, we have to allocate pages individually
3135     // (well really chunks of NUMAInterleaveGranularity size)
3136     res = allocate_pages_individually(bytes, addr, MEM_RESERVE, PAGE_READWRITE);
3137     if (res == NULL) {
3138       warning(&quot;NUMA page allocation failed&quot;);
3139     }
3140     if (Verbose &amp;&amp; PrintMiscellaneous) {
3141       reserveTimer.stop();
3142       tty-&gt;print_cr(&quot;reserve_memory of %Ix bytes took &quot; JLONG_FORMAT &quot; ms (&quot; JLONG_FORMAT &quot; ticks)&quot;, bytes,
3143                     reserveTimer.milliseconds(), reserveTimer.ticks());
3144     }
3145   }
3146   assert(res == NULL || addr == NULL || addr == res,
3147          &quot;Unexpected address from reserve.&quot;);
3148 
3149   return res;
3150 }
3151 
3152 // Reserve memory at an arbitrary address, only if that area is
3153 // available (and not reserved for something else).
3154 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
3155   // Windows os::reserve_memory() fails of the requested address range is
3156   // not avilable.
3157   return reserve_memory(bytes, requested_addr);
3158 }
3159 
3160 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {
3161   assert(file_desc &gt;= 0, &quot;file_desc is not valid&quot;);
3162   return map_memory_to_file(requested_addr, bytes, file_desc);
3163 }
3164 
3165 size_t os::large_page_size() {
3166   return _large_page_size;
3167 }
3168 
3169 bool os::can_commit_large_page_memory() {
3170   // Windows only uses large page memory when the entire region is reserved
3171   // and committed in a single VirtualAlloc() call. This may change in the
3172   // future, but with Windows 2003 it&#39;s not possible to commit on demand.
3173   return false;
3174 }
3175 
3176 bool os::can_execute_large_page_memory() {
3177   return true;
3178 }
3179 
3180 char* os::pd_reserve_memory_special(size_t bytes, size_t alignment, char* addr,
3181                                     bool exec) {
3182   assert(UseLargePages, &quot;only for large pages&quot;);
3183 
3184   if (!is_aligned(bytes, os::large_page_size()) || alignment &gt; os::large_page_size()) {
3185     return NULL; // Fallback to small pages.
3186   }
3187 
3188   const DWORD prot = exec ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE;
3189   const DWORD flags = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
3190 
3191   // with large pages, there are two cases where we need to use Individual Allocation
3192   // 1) the UseLargePagesIndividualAllocation flag is set (set by default on WS2003)
3193   // 2) NUMA Interleaving is enabled, in which case we use a different node for each page
3194   if (UseLargePagesIndividualAllocation || UseNUMAInterleaving) {
3195     log_debug(pagesize)(&quot;Reserving large pages individually.&quot;);
3196 
3197     char * p_buf = allocate_pages_individually(bytes, addr, flags, prot, LargePagesIndividualAllocationInjectError);
3198     if (p_buf == NULL) {
3199       // give an appropriate warning message
3200       if (UseNUMAInterleaving) {
3201         warning(&quot;NUMA large page allocation failed, UseLargePages flag ignored&quot;);
3202       }
3203       if (UseLargePagesIndividualAllocation) {
3204         warning(&quot;Individually allocated large pages failed, &quot;
3205                 &quot;use -XX:-UseLargePagesIndividualAllocation to turn off&quot;);
3206       }
3207       return NULL;
3208     }
3209 
3210     return p_buf;
3211 
3212   } else {
3213     log_debug(pagesize)(&quot;Reserving large pages in a single large chunk.&quot;);
3214 
3215     // normal policy just allocate it all at once
3216     DWORD flag = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
3217     char * res = (char *)VirtualAlloc(addr, bytes, flag, prot);
3218 
3219     return res;
3220   }
3221 }
3222 
3223 bool os::pd_release_memory_special(char* base, size_t bytes) {
3224   assert(base != NULL, &quot;Sanity check&quot;);
3225   return pd_release_memory(base, bytes);
3226 }
3227 
3228 void os::print_statistics() {
3229 }
3230 
3231 static void warn_fail_commit_memory(char* addr, size_t bytes, bool exec) {
3232   int err = os::get_last_error();
3233   char buf[256];
3234   size_t buf_len = os::lasterror(buf, sizeof(buf));
3235   warning(&quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
3236           &quot;, %d) failed; error=&#39;%s&#39; (DOS error/errno=%d)&quot;, addr, bytes,
3237           exec, buf_len != 0 ? buf : &quot;&lt;no_error_string&gt;&quot;, err);
3238 }
3239 
3240 bool os::pd_commit_memory(char* addr, size_t bytes, bool exec) {
3241   if (bytes == 0) {
3242     // Don&#39;t bother the OS with noops.
3243     return true;
3244   }
3245   assert((size_t) addr % os::vm_page_size() == 0, &quot;commit on page boundaries&quot;);
3246   assert(bytes % os::vm_page_size() == 0, &quot;commit in page-sized chunks&quot;);
3247   // Don&#39;t attempt to print anything if the OS call fails. We&#39;re
3248   // probably low on resources, so the print itself may cause crashes.
3249 
3250   // unless we have NUMAInterleaving enabled, the range of a commit
3251   // is always within a reserve covered by a single VirtualAlloc
3252   // in that case we can just do a single commit for the requested size
3253   if (!UseNUMAInterleaving) {
3254     if (VirtualAlloc(addr, bytes, MEM_COMMIT, PAGE_READWRITE) == NULL) {
3255       NOT_PRODUCT(warn_fail_commit_memory(addr, bytes, exec);)
3256       return false;
3257     }
3258     if (exec) {
3259       DWORD oldprot;
3260       // Windows doc says to use VirtualProtect to get execute permissions
3261       if (!VirtualProtect(addr, bytes, PAGE_EXECUTE_READWRITE, &amp;oldprot)) {
3262         NOT_PRODUCT(warn_fail_commit_memory(addr, bytes, exec);)
3263         return false;
3264       }
3265     }
3266     return true;
3267   } else {
3268 
3269     // when NUMAInterleaving is enabled, the commit might cover a range that
3270     // came from multiple VirtualAlloc reserves (using allocate_pages_individually).
3271     // VirtualQuery can help us determine that.  The RegionSize that VirtualQuery
3272     // returns represents the number of bytes that can be committed in one step.
3273     size_t bytes_remaining = bytes;
3274     char * next_alloc_addr = addr;
3275     while (bytes_remaining &gt; 0) {
3276       MEMORY_BASIC_INFORMATION alloc_info;
3277       VirtualQuery(next_alloc_addr, &amp;alloc_info, sizeof(alloc_info));
3278       size_t bytes_to_rq = MIN2(bytes_remaining, (size_t)alloc_info.RegionSize);
3279       if (VirtualAlloc(next_alloc_addr, bytes_to_rq, MEM_COMMIT,
3280                        PAGE_READWRITE) == NULL) {
3281         NOT_PRODUCT(warn_fail_commit_memory(next_alloc_addr, bytes_to_rq,
3282                                             exec);)
3283         return false;
3284       }
3285       if (exec) {
3286         DWORD oldprot;
3287         if (!VirtualProtect(next_alloc_addr, bytes_to_rq,
3288                             PAGE_EXECUTE_READWRITE, &amp;oldprot)) {
3289           NOT_PRODUCT(warn_fail_commit_memory(next_alloc_addr, bytes_to_rq,
3290                                               exec);)
3291           return false;
3292         }
3293       }
3294       bytes_remaining -= bytes_to_rq;
3295       next_alloc_addr += bytes_to_rq;
3296     }
3297   }
3298   // if we made it this far, return true
3299   return true;
3300 }
3301 
3302 bool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,
3303                           bool exec) {
3304   // alignment_hint is ignored on this OS
3305   return pd_commit_memory(addr, size, exec);
3306 }
3307 
3308 void os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,
3309                                   const char* mesg) {
3310   assert(mesg != NULL, &quot;mesg must be specified&quot;);
3311   if (!pd_commit_memory(addr, size, exec)) {
3312     warn_fail_commit_memory(addr, size, exec);
3313     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;%s&quot;, mesg);
3314   }
3315 }
3316 
3317 void os::pd_commit_memory_or_exit(char* addr, size_t size,
3318                                   size_t alignment_hint, bool exec,
3319                                   const char* mesg) {
3320   // alignment_hint is ignored on this OS
3321   pd_commit_memory_or_exit(addr, size, exec, mesg);
3322 }
3323 
3324 bool os::pd_uncommit_memory(char* addr, size_t bytes) {
3325   if (bytes == 0) {
3326     // Don&#39;t bother the OS with noops.
3327     return true;
3328   }
3329   assert((size_t) addr % os::vm_page_size() == 0, &quot;uncommit on page boundaries&quot;);
3330   assert(bytes % os::vm_page_size() == 0, &quot;uncommit in page-sized chunks&quot;);
3331   return (VirtualFree(addr, bytes, MEM_DECOMMIT) != 0);
3332 }
3333 
3334 bool os::pd_release_memory(char* addr, size_t bytes) {
3335   return VirtualFree(addr, 0, MEM_RELEASE) != 0;
3336 }
3337 
3338 bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
3339   return os::commit_memory(addr, size, !ExecMem);
3340 }
3341 
3342 bool os::remove_stack_guard_pages(char* addr, size_t size) {
3343   return os::uncommit_memory(addr, size);
3344 }
3345 
3346 static bool protect_pages_individually(char* addr, size_t bytes, unsigned int p, DWORD *old_status) {
3347   uint count = 0;
3348   bool ret = false;
3349   size_t bytes_remaining = bytes;
3350   char * next_protect_addr = addr;
3351 
3352   // Use VirtualQuery() to get the chunk size.
3353   while (bytes_remaining) {
3354     MEMORY_BASIC_INFORMATION alloc_info;
3355     if (VirtualQuery(next_protect_addr, &amp;alloc_info, sizeof(alloc_info)) == 0) {
3356       return false;
3357     }
3358 
3359     size_t bytes_to_protect = MIN2(bytes_remaining, (size_t)alloc_info.RegionSize);
3360     // We used different API at allocate_pages_individually() based on UseNUMAInterleaving,
3361     // but we don&#39;t distinguish here as both cases are protected by same API.
3362     ret = VirtualProtect(next_protect_addr, bytes_to_protect, p, old_status) != 0;
3363     warning(&quot;Failed protecting pages individually for chunk #%u&quot;, count);
3364     if (!ret) {
3365       return false;
3366     }
3367 
3368     bytes_remaining -= bytes_to_protect;
3369     next_protect_addr += bytes_to_protect;
3370     count++;
3371   }
3372   return ret;
3373 }
3374 
3375 // Set protections specified
3376 bool os::protect_memory(char* addr, size_t bytes, ProtType prot,
3377                         bool is_committed) {
3378   unsigned int p = 0;
3379   switch (prot) {
3380   case MEM_PROT_NONE: p = PAGE_NOACCESS; break;
3381   case MEM_PROT_READ: p = PAGE_READONLY; break;
3382   case MEM_PROT_RW:   p = PAGE_READWRITE; break;
3383   case MEM_PROT_RWX:  p = PAGE_EXECUTE_READWRITE; break;
3384   default:
3385     ShouldNotReachHere();
3386   }
3387 
3388   DWORD old_status;
3389 
3390   // Strange enough, but on Win32 one can change protection only for committed
3391   // memory, not a big deal anyway, as bytes less or equal than 64K
3392   if (!is_committed) {
3393     commit_memory_or_exit(addr, bytes, prot == MEM_PROT_RWX,
3394                           &quot;cannot commit protection page&quot;);
3395   }
3396   // One cannot use os::guard_memory() here, as on Win32 guard page
3397   // have different (one-shot) semantics, from MSDN on PAGE_GUARD:
3398   //
3399   // Pages in the region become guard pages. Any attempt to access a guard page
3400   // causes the system to raise a STATUS_GUARD_PAGE exception and turn off
3401   // the guard page status. Guard pages thus act as a one-time access alarm.
3402   bool ret;
3403   if (UseNUMAInterleaving) {
3404     // If UseNUMAInterleaving is enabled, the pages may have been allocated a chunk at a time,
3405     // so we must protect the chunks individually.
3406     ret = protect_pages_individually(addr, bytes, p, &amp;old_status);
3407   } else {
3408     ret = VirtualProtect(addr, bytes, p, &amp;old_status) != 0;
3409   }
3410 #ifdef ASSERT
3411   if (!ret) {
3412     int err = os::get_last_error();
3413     char buf[256];
3414     size_t buf_len = os::lasterror(buf, sizeof(buf));
3415     warning(&quot;INFO: os::protect_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
3416           &quot;) failed; error=&#39;%s&#39; (DOS error/errno=%d)&quot;, addr, bytes,
3417           buf_len != 0 ? buf : &quot;&lt;no_error_string&gt;&quot;, err);
3418   }
3419 #endif
3420   return ret;
3421 }
3422 
3423 bool os::guard_memory(char* addr, size_t bytes) {
3424   DWORD old_status;
3425   return VirtualProtect(addr, bytes, PAGE_READWRITE | PAGE_GUARD, &amp;old_status) != 0;
3426 }
3427 
3428 bool os::unguard_memory(char* addr, size_t bytes) {
3429   DWORD old_status;
3430   return VirtualProtect(addr, bytes, PAGE_READWRITE, &amp;old_status) != 0;
3431 }
3432 
3433 void os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) { }
3434 void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) { }
3435 void os::numa_make_global(char *addr, size_t bytes)    { }
3436 void os::numa_make_local(char *addr, size_t bytes, int lgrp_hint)    { }
3437 bool os::numa_topology_changed()                       { return false; }
3438 size_t os::numa_get_groups_num()                       { return MAX2(numa_node_list_holder.get_count(), 1); }
3439 int os::numa_get_group_id()                            { return 0; }
3440 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
3441   if (numa_node_list_holder.get_count() == 0 &amp;&amp; size &gt; 0) {
3442     // Provide an answer for UMA systems
3443     ids[0] = 0;
3444     return 1;
3445   } else {
3446     // check for size bigger than actual groups_num
3447     size = MIN2(size, numa_get_groups_num());
3448     for (int i = 0; i &lt; (int)size; i++) {
3449       ids[i] = numa_node_list_holder.get_node_list_entry(i);
3450     }
3451     return size;
3452   }
3453 }
3454 
3455 int os::numa_get_group_id_for_address(const void* address) {
3456   return 0;
3457 }
3458 
3459 bool os::get_page_info(char *start, page_info* info) {
3460   return false;
3461 }
3462 
3463 char *os::scan_pages(char *start, char* end, page_info* page_expected,
3464                      page_info* page_found) {
3465   return end;
3466 }
3467 
3468 char* os::non_memory_address_word() {
3469   // Must never look like an address returned by reserve_memory,
3470   // even in its subfields (as defined by the CPU immediate fields,
3471   // if the CPU splits constants across multiple instructions).
3472   return (char*)-1;
3473 }
3474 
3475 #define MAX_ERROR_COUNT 100
3476 #define SYS_THREAD_ERROR 0xffffffffUL
3477 
3478 void os::pd_start_thread(Thread* thread) {
3479   DWORD ret = ResumeThread(thread-&gt;osthread()-&gt;thread_handle());
3480   // Returns previous suspend state:
3481   // 0:  Thread was not suspended
3482   // 1:  Thread is running now
3483   // &gt;1: Thread is still suspended.
3484   assert(ret != SYS_THREAD_ERROR, &quot;StartThread failed&quot;); // should propagate back
3485 }
3486 
3487 
3488 // Short sleep, direct OS call.
3489 //
3490 // ms = 0, means allow others (if any) to run.
3491 //
3492 void os::naked_short_sleep(jlong ms) {
3493   assert(ms &lt; 1000, &quot;Un-interruptable sleep, short time use only&quot;);
3494   Sleep(ms);
3495 }
3496 
3497 // Windows does not provide sleep functionality with nanosecond resolution, so we
3498 // try to approximate this with spinning combined with yielding if another thread
3499 // is ready to run on the current processor.
3500 void os::naked_short_nanosleep(jlong ns) {
3501   assert(ns &gt; -1 &amp;&amp; ns &lt; NANOUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
3502 
3503   int64_t start = os::javaTimeNanos();
3504   do {
3505     if (SwitchToThread() == 0) {
3506       // Nothing else is ready to run on this cpu, spin a little
3507       SpinPause();
3508     }
3509   } while (os::javaTimeNanos() - start &lt; ns);
3510 }
3511 
3512 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
3513 void os::infinite_sleep() {
3514   while (true) {    // sleep forever ...
3515     Sleep(100000);  // ... 100 seconds at a time
3516   }
3517 }
3518 
3519 typedef BOOL (WINAPI * STTSignature)(void);
3520 
3521 void os::naked_yield() {
3522   // Consider passing back the return value from SwitchToThread().
3523   SwitchToThread();
3524 }
3525 
3526 // Win32 only gives you access to seven real priorities at a time,
3527 // so we compress Java&#39;s ten down to seven.  It would be better
3528 // if we dynamically adjusted relative priorities.
3529 
3530 int os::java_to_os_priority[CriticalPriority + 1] = {
3531   THREAD_PRIORITY_IDLE,                         // 0  Entry should never be used
3532   THREAD_PRIORITY_LOWEST,                       // 1  MinPriority
3533   THREAD_PRIORITY_LOWEST,                       // 2
3534   THREAD_PRIORITY_BELOW_NORMAL,                 // 3
3535   THREAD_PRIORITY_BELOW_NORMAL,                 // 4
3536   THREAD_PRIORITY_NORMAL,                       // 5  NormPriority
3537   THREAD_PRIORITY_NORMAL,                       // 6
3538   THREAD_PRIORITY_ABOVE_NORMAL,                 // 7
3539   THREAD_PRIORITY_ABOVE_NORMAL,                 // 8
3540   THREAD_PRIORITY_HIGHEST,                      // 9  NearMaxPriority
3541   THREAD_PRIORITY_HIGHEST,                      // 10 MaxPriority
3542   THREAD_PRIORITY_HIGHEST                       // 11 CriticalPriority
3543 };
3544 
3545 int prio_policy1[CriticalPriority + 1] = {
3546   THREAD_PRIORITY_IDLE,                         // 0  Entry should never be used
3547   THREAD_PRIORITY_LOWEST,                       // 1  MinPriority
3548   THREAD_PRIORITY_LOWEST,                       // 2
3549   THREAD_PRIORITY_BELOW_NORMAL,                 // 3
3550   THREAD_PRIORITY_BELOW_NORMAL,                 // 4
3551   THREAD_PRIORITY_NORMAL,                       // 5  NormPriority
3552   THREAD_PRIORITY_ABOVE_NORMAL,                 // 6
3553   THREAD_PRIORITY_ABOVE_NORMAL,                 // 7
3554   THREAD_PRIORITY_HIGHEST,                      // 8
3555   THREAD_PRIORITY_HIGHEST,                      // 9  NearMaxPriority
3556   THREAD_PRIORITY_TIME_CRITICAL,                // 10 MaxPriority
3557   THREAD_PRIORITY_TIME_CRITICAL                 // 11 CriticalPriority
3558 };
3559 
3560 static int prio_init() {
3561   // If ThreadPriorityPolicy is 1, switch tables
3562   if (ThreadPriorityPolicy == 1) {
3563     int i;
3564     for (i = 0; i &lt; CriticalPriority + 1; i++) {
3565       os::java_to_os_priority[i] = prio_policy1[i];
3566     }
3567   }
3568   if (UseCriticalJavaThreadPriority) {
3569     os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];
3570   }
3571   return 0;
3572 }
3573 
3574 OSReturn os::set_native_priority(Thread* thread, int priority) {
3575   if (!UseThreadPriorities) return OS_OK;
3576   bool ret = SetThreadPriority(thread-&gt;osthread()-&gt;thread_handle(), priority) != 0;
3577   return ret ? OS_OK : OS_ERR;
3578 }
3579 
3580 OSReturn os::get_native_priority(const Thread* const thread,
3581                                  int* priority_ptr) {
3582   if (!UseThreadPriorities) {
3583     *priority_ptr = java_to_os_priority[NormPriority];
3584     return OS_OK;
3585   }
3586   int os_prio = GetThreadPriority(thread-&gt;osthread()-&gt;thread_handle());
3587   if (os_prio == THREAD_PRIORITY_ERROR_RETURN) {
3588     assert(false, &quot;GetThreadPriority failed&quot;);
3589     return OS_ERR;
3590   }
3591   *priority_ptr = os_prio;
3592   return OS_OK;
3593 }
3594 
3595 // GetCurrentThreadId() returns DWORD
3596 intx os::current_thread_id()  { return GetCurrentThreadId(); }
3597 
3598 static int _initial_pid = 0;
3599 
3600 int os::current_process_id() {
3601   return (_initial_pid ? _initial_pid : _getpid());
3602 }
3603 
3604 int    os::win32::_vm_page_size              = 0;
3605 int    os::win32::_vm_allocation_granularity = 0;
3606 int    os::win32::_processor_type            = 0;
3607 // Processor level is not available on non-NT systems, use vm_version instead
3608 int    os::win32::_processor_level           = 0;
3609 julong os::win32::_physical_memory           = 0;
3610 size_t os::win32::_default_stack_size        = 0;
3611 
3612 intx          os::win32::_os_thread_limit    = 0;
3613 volatile intx os::win32::_os_thread_count    = 0;
3614 
3615 bool   os::win32::_is_windows_server         = false;
3616 
3617 // 6573254
3618 // Currently, the bug is observed across all the supported Windows releases,
3619 // including the latest one (as of this writing - Windows Server 2012 R2)
3620 bool   os::win32::_has_exit_bug              = true;
3621 
3622 void os::win32::initialize_system_info() {
3623   SYSTEM_INFO si;
3624   GetSystemInfo(&amp;si);
3625   _vm_page_size    = si.dwPageSize;
3626   _vm_allocation_granularity = si.dwAllocationGranularity;
3627   _processor_type  = si.dwProcessorType;
3628   _processor_level = si.wProcessorLevel;
3629   set_processor_count(si.dwNumberOfProcessors);
3630 
3631   MEMORYSTATUSEX ms;
3632   ms.dwLength = sizeof(ms);
3633 
3634   // also returns dwAvailPhys (free physical memory bytes), dwTotalVirtual, dwAvailVirtual,
3635   // dwMemoryLoad (% of memory in use)
3636   GlobalMemoryStatusEx(&amp;ms);
3637   _physical_memory = ms.ullTotalPhys;
3638 
3639   if (FLAG_IS_DEFAULT(MaxRAM)) {
3640     // Adjust MaxRAM according to the maximum virtual address space available.
3641     FLAG_SET_DEFAULT(MaxRAM, MIN2(MaxRAM, (uint64_t) ms.ullTotalVirtual));
3642   }
3643 
3644   OSVERSIONINFOEX oi;
3645   oi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
3646   GetVersionEx((OSVERSIONINFO*)&amp;oi);
3647   switch (oi.dwPlatformId) {
3648   case VER_PLATFORM_WIN32_NT:
3649     {
3650       int os_vers = oi.dwMajorVersion * 1000 + oi.dwMinorVersion;
3651       if (oi.wProductType == VER_NT_DOMAIN_CONTROLLER ||
3652           oi.wProductType == VER_NT_SERVER) {
3653         _is_windows_server = true;
3654       }
3655     }
3656     break;
3657   default: fatal(&quot;Unknown platform&quot;);
3658   }
3659 
3660   _default_stack_size = os::current_stack_size();
3661   assert(_default_stack_size &gt; (size_t) _vm_page_size, &quot;invalid stack size&quot;);
3662   assert((_default_stack_size &amp; (_vm_page_size - 1)) == 0,
3663          &quot;stack size not a multiple of page size&quot;);
3664 
3665   initialize_performance_counter();
3666 }
3667 
3668 
3669 HINSTANCE os::win32::load_Windows_dll(const char* name, char *ebuf,
3670                                       int ebuflen) {
3671   char path[MAX_PATH];
3672   DWORD size;
3673   DWORD pathLen = (DWORD)sizeof(path);
3674   HINSTANCE result = NULL;
3675 
3676   // only allow library name without path component
3677   assert(strchr(name, &#39;\\&#39;) == NULL, &quot;path not allowed&quot;);
3678   assert(strchr(name, &#39;:&#39;) == NULL, &quot;path not allowed&quot;);
3679   if (strchr(name, &#39;\\&#39;) != NULL || strchr(name, &#39;:&#39;) != NULL) {
3680     jio_snprintf(ebuf, ebuflen,
3681                  &quot;Invalid parameter while calling os::win32::load_windows_dll(): cannot take path: %s&quot;, name);
3682     return NULL;
3683   }
3684 
3685   // search system directory
3686   if ((size = GetSystemDirectory(path, pathLen)) &gt; 0) {
3687     if (size &gt;= pathLen) {
3688       return NULL; // truncated
3689     }
3690     if (jio_snprintf(path + size, pathLen - size, &quot;\\%s&quot;, name) == -1) {
3691       return NULL; // truncated
3692     }
3693     if ((result = (HINSTANCE)os::dll_load(path, ebuf, ebuflen)) != NULL) {
3694       return result;
3695     }
3696   }
3697 
3698   // try Windows directory
3699   if ((size = GetWindowsDirectory(path, pathLen)) &gt; 0) {
3700     if (size &gt;= pathLen) {
3701       return NULL; // truncated
3702     }
3703     if (jio_snprintf(path + size, pathLen - size, &quot;\\%s&quot;, name) == -1) {
3704       return NULL; // truncated
3705     }
3706     if ((result = (HINSTANCE)os::dll_load(path, ebuf, ebuflen)) != NULL) {
3707       return result;
3708     }
3709   }
3710 
3711   jio_snprintf(ebuf, ebuflen,
3712                &quot;os::win32::load_windows_dll() cannot load %s from system directories.&quot;, name);
3713   return NULL;
3714 }
3715 
3716 #define MAXIMUM_THREADS_TO_KEEP (16 * MAXIMUM_WAIT_OBJECTS)
3717 #define EXIT_TIMEOUT 300000 /* 5 minutes */
3718 
3719 static BOOL CALLBACK init_crit_sect_call(PINIT_ONCE, PVOID pcrit_sect, PVOID*) {
3720   InitializeCriticalSection((CRITICAL_SECTION*)pcrit_sect);
3721   return TRUE;
3722 }
3723 
3724 int os::win32::exit_process_or_thread(Ept what, int exit_code) {
3725   // Basic approach:
3726   //  - Each exiting thread registers its intent to exit and then does so.
3727   //  - A thread trying to terminate the process must wait for all
3728   //    threads currently exiting to complete their exit.
3729 
3730   if (os::win32::has_exit_bug()) {
3731     // The array holds handles of the threads that have started exiting by calling
3732     // _endthreadex().
3733     // Should be large enough to avoid blocking the exiting thread due to lack of
3734     // a free slot.
3735     static HANDLE handles[MAXIMUM_THREADS_TO_KEEP];
3736     static int handle_count = 0;
3737 
3738     static INIT_ONCE init_once_crit_sect = INIT_ONCE_STATIC_INIT;
3739     static CRITICAL_SECTION crit_sect;
3740     static volatile DWORD process_exiting = 0;
3741     int i, j;
3742     DWORD res;
3743     HANDLE hproc, hthr;
3744 
3745     // We only attempt to register threads until a process exiting
3746     // thread manages to set the process_exiting flag. Any threads
3747     // that come through here after the process_exiting flag is set
3748     // are unregistered and will be caught in the SuspendThread()
3749     // infinite loop below.
3750     bool registered = false;
3751 
3752     // The first thread that reached this point, initializes the critical section.
3753     if (!InitOnceExecuteOnce(&amp;init_once_crit_sect, init_crit_sect_call, &amp;crit_sect, NULL)) {
3754       warning(&quot;crit_sect initialization failed in %s: %d\n&quot;, __FILE__, __LINE__);
3755     } else if (Atomic::load_acquire(&amp;process_exiting) == 0) {
3756       if (what != EPT_THREAD) {
3757         // Atomically set process_exiting before the critical section
3758         // to increase the visibility between racing threads.
3759         Atomic::cmpxchg(&amp;process_exiting, (DWORD)0, GetCurrentThreadId());
3760       }
3761       EnterCriticalSection(&amp;crit_sect);
3762 
3763       if (what == EPT_THREAD &amp;&amp; Atomic::load_acquire(&amp;process_exiting) == 0) {
3764         // Remove from the array those handles of the threads that have completed exiting.
3765         for (i = 0, j = 0; i &lt; handle_count; ++i) {
3766           res = WaitForSingleObject(handles[i], 0 /* don&#39;t wait */);
3767           if (res == WAIT_TIMEOUT) {
3768             handles[j++] = handles[i];
3769           } else {
3770             if (res == WAIT_FAILED) {
3771               warning(&quot;WaitForSingleObject failed (%u) in %s: %d\n&quot;,
3772                       GetLastError(), __FILE__, __LINE__);
3773             }
3774             // Don&#39;t keep the handle, if we failed waiting for it.
3775             CloseHandle(handles[i]);
3776           }
3777         }
3778 
3779         // If there&#39;s no free slot in the array of the kept handles, we&#39;ll have to
3780         // wait until at least one thread completes exiting.
3781         if ((handle_count = j) == MAXIMUM_THREADS_TO_KEEP) {
3782           // Raise the priority of the oldest exiting thread to increase its chances
3783           // to complete sooner.
3784           SetThreadPriority(handles[0], THREAD_PRIORITY_ABOVE_NORMAL);
3785           res = WaitForMultipleObjects(MAXIMUM_WAIT_OBJECTS, handles, FALSE, EXIT_TIMEOUT);
3786           if (res &gt;= WAIT_OBJECT_0 &amp;&amp; res &lt; (WAIT_OBJECT_0 + MAXIMUM_WAIT_OBJECTS)) {
3787             i = (res - WAIT_OBJECT_0);
3788             handle_count = MAXIMUM_THREADS_TO_KEEP - 1;
3789             for (; i &lt; handle_count; ++i) {
3790               handles[i] = handles[i + 1];
3791             }
3792           } else {
3793             warning(&quot;WaitForMultipleObjects %s (%u) in %s: %d\n&quot;,
3794                     (res == WAIT_FAILED ? &quot;failed&quot; : &quot;timed out&quot;),
3795                     GetLastError(), __FILE__, __LINE__);
3796             // Don&#39;t keep handles, if we failed waiting for them.
3797             for (i = 0; i &lt; MAXIMUM_THREADS_TO_KEEP; ++i) {
3798               CloseHandle(handles[i]);
3799             }
3800             handle_count = 0;
3801           }
3802         }
3803 
3804         // Store a duplicate of the current thread handle in the array of handles.
3805         hproc = GetCurrentProcess();
3806         hthr = GetCurrentThread();
3807         if (!DuplicateHandle(hproc, hthr, hproc, &amp;handles[handle_count],
3808                              0, FALSE, DUPLICATE_SAME_ACCESS)) {
3809           warning(&quot;DuplicateHandle failed (%u) in %s: %d\n&quot;,
3810                   GetLastError(), __FILE__, __LINE__);
3811 
3812           // We can&#39;t register this thread (no more handles) so this thread
3813           // may be racing with a thread that is calling exit(). If the thread
3814           // that is calling exit() has managed to set the process_exiting
3815           // flag, then this thread will be caught in the SuspendThread()
3816           // infinite loop below which closes that race. A small timing
3817           // window remains before the process_exiting flag is set, but it
3818           // is only exposed when we are out of handles.
3819         } else {
3820           ++handle_count;
3821           registered = true;
3822 
3823           // The current exiting thread has stored its handle in the array, and now
3824           // should leave the critical section before calling _endthreadex().
3825         }
3826 
3827       } else if (what != EPT_THREAD &amp;&amp; handle_count &gt; 0) {
3828         jlong start_time, finish_time, timeout_left;
3829         // Before ending the process, make sure all the threads that had called
3830         // _endthreadex() completed.
3831 
3832         // Set the priority level of the current thread to the same value as
3833         // the priority level of exiting threads.
3834         // This is to ensure it will be given a fair chance to execute if
3835         // the timeout expires.
3836         hthr = GetCurrentThread();
3837         SetThreadPriority(hthr, THREAD_PRIORITY_ABOVE_NORMAL);
3838         start_time = os::javaTimeNanos();
3839         finish_time = start_time + ((jlong)EXIT_TIMEOUT * 1000000L);
3840         for (i = 0; ; ) {
3841           int portion_count = handle_count - i;
3842           if (portion_count &gt; MAXIMUM_WAIT_OBJECTS) {
3843             portion_count = MAXIMUM_WAIT_OBJECTS;
3844           }
3845           for (j = 0; j &lt; portion_count; ++j) {
3846             SetThreadPriority(handles[i + j], THREAD_PRIORITY_ABOVE_NORMAL);
3847           }
3848           timeout_left = (finish_time - start_time) / 1000000L;
3849           if (timeout_left &lt; 0) {
3850             timeout_left = 0;
3851           }
3852           res = WaitForMultipleObjects(portion_count, handles + i, TRUE, timeout_left);
3853           if (res == WAIT_FAILED || res == WAIT_TIMEOUT) {
3854             warning(&quot;WaitForMultipleObjects %s (%u) in %s: %d\n&quot;,
3855                     (res == WAIT_FAILED ? &quot;failed&quot; : &quot;timed out&quot;),
3856                     GetLastError(), __FILE__, __LINE__);
3857             // Reset portion_count so we close the remaining
3858             // handles due to this error.
3859             portion_count = handle_count - i;
3860           }
3861           for (j = 0; j &lt; portion_count; ++j) {
3862             CloseHandle(handles[i + j]);
3863           }
3864           if ((i += portion_count) &gt;= handle_count) {
3865             break;
3866           }
3867           start_time = os::javaTimeNanos();
3868         }
3869         handle_count = 0;
3870       }
3871 
3872       LeaveCriticalSection(&amp;crit_sect);
3873     }
3874 
3875     if (!registered &amp;&amp;
3876         Atomic::load_acquire(&amp;process_exiting) != 0 &amp;&amp;
3877         process_exiting != GetCurrentThreadId()) {
3878       // Some other thread is about to call exit(), so we don&#39;t let
3879       // the current unregistered thread proceed to exit() or _endthreadex()
3880       while (true) {
3881         SuspendThread(GetCurrentThread());
3882         // Avoid busy-wait loop, if SuspendThread() failed.
3883         Sleep(EXIT_TIMEOUT);
3884       }
3885     }
3886   }
3887 
3888   // We are here if either
3889   // - there&#39;s no &#39;race at exit&#39; bug on this OS release;
3890   // - initialization of the critical section failed (unlikely);
3891   // - the current thread has registered itself and left the critical section;
3892   // - the process-exiting thread has raised the flag and left the critical section.
3893   if (what == EPT_THREAD) {
3894     _endthreadex((unsigned)exit_code);
3895   } else if (what == EPT_PROCESS) {
3896     ::exit(exit_code);
3897   } else {
3898     _exit(exit_code);
3899   }
3900 
3901   // Should not reach here
3902   return exit_code;
3903 }
3904 
3905 #undef EXIT_TIMEOUT
3906 
3907 void os::win32::setmode_streams() {
3908   _setmode(_fileno(stdin), _O_BINARY);
3909   _setmode(_fileno(stdout), _O_BINARY);
3910   _setmode(_fileno(stderr), _O_BINARY);
3911 }
3912 
3913 void os::wait_for_keypress_at_exit(void) {
3914   if (PauseAtExit) {
3915     fprintf(stderr, &quot;Press any key to continue...\n&quot;);
3916     fgetc(stdin);
3917   }
3918 }
3919 
3920 
3921 bool os::message_box(const char* title, const char* message) {
3922   int result = MessageBox(NULL, message, title,
3923                           MB_YESNO | MB_ICONERROR | MB_SYSTEMMODAL | MB_DEFAULT_DESKTOP_ONLY);
3924   return result == IDYES;
3925 }
3926 
3927 #ifndef PRODUCT
3928 #ifndef _WIN64
3929 // Helpers to check whether NX protection is enabled
3930 int nx_exception_filter(_EXCEPTION_POINTERS *pex) {
3931   if (pex-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION &amp;&amp;
3932       pex-&gt;ExceptionRecord-&gt;NumberParameters &gt; 0 &amp;&amp;
3933       pex-&gt;ExceptionRecord-&gt;ExceptionInformation[0] ==
3934       EXCEPTION_INFO_EXEC_VIOLATION) {
3935     return EXCEPTION_EXECUTE_HANDLER;
3936   }
3937   return EXCEPTION_CONTINUE_SEARCH;
3938 }
3939 
3940 void nx_check_protection() {
3941   // If NX is enabled we&#39;ll get an exception calling into code on the stack
3942   char code[] = { (char)0xC3 }; // ret
3943   void *code_ptr = (void *)code;
3944   __try {
3945     __asm call code_ptr
3946   } __except(nx_exception_filter((_EXCEPTION_POINTERS*)_exception_info())) {
3947     tty-&gt;print_raw_cr(&quot;NX protection detected.&quot;);
3948   }
3949 }
3950 #endif // _WIN64
3951 #endif // PRODUCT
3952 
3953 // This is called _before_ the global arguments have been parsed
3954 void os::init(void) {
3955   _initial_pid = _getpid();
3956 
3957   init_random(1234567);
3958 
3959   win32::initialize_system_info();
3960   win32::setmode_streams();
3961   init_page_sizes((size_t) win32::vm_page_size());
3962 
3963   // This may be overridden later when argument processing is done.
3964   FLAG_SET_ERGO(UseLargePagesIndividualAllocation, false);
3965 
3966   // Initialize main_process and main_thread
3967   main_process = GetCurrentProcess();  // Remember main_process is a pseudo handle
3968   if (!DuplicateHandle(main_process, GetCurrentThread(), main_process,
3969                        &amp;main_thread, THREAD_ALL_ACCESS, false, 0)) {
3970     fatal(&quot;DuplicateHandle failed\n&quot;);
3971   }
3972   main_thread_id = (int) GetCurrentThreadId();
3973 
3974   // initialize fast thread access - only used for 32-bit
3975   win32::initialize_thread_ptr_offset();
3976 }
3977 
3978 // To install functions for atexit processing
3979 extern &quot;C&quot; {
3980   static void perfMemory_exit_helper() {
3981     perfMemory_exit();
3982   }
3983 }
3984 
3985 static jint initSock();
3986 
3987 // this is called _after_ the global arguments have been parsed
3988 jint os::init_2(void) {
3989 
3990   // This could be set any time but all platforms
3991   // have to set it the same so we have to mirror Solaris.
3992   DEBUG_ONLY(os::set_mutex_init_done();)
3993 
3994   // Setup Windows Exceptions
3995 
3996 #if INCLUDE_AOT
3997   // If AOT is enabled we need to install a vectored exception handler
3998   // in order to forward implicit exceptions from code in AOT
3999   // generated DLLs.  This is necessary since these DLLs are not
4000   // registered for structured exceptions like codecache methods are.
4001   if (AOTLibrary != NULL &amp;&amp; (UseAOT || FLAG_IS_DEFAULT(UseAOT))) {
4002     topLevelVectoredExceptionHandler = AddVectoredExceptionHandler( 1, topLevelVectoredExceptionFilter);
4003   }
4004 #endif
4005 
4006   // for debugging float code generation bugs
4007   if (ForceFloatExceptions) {
4008 #ifndef  _WIN64
4009     static long fp_control_word = 0;
4010     __asm { fstcw fp_control_word }
4011     // see Intel PPro Manual, Vol. 2, p 7-16
4012     const long precision = 0x20;
4013     const long underflow = 0x10;
4014     const long overflow  = 0x08;
4015     const long zero_div  = 0x04;
4016     const long denorm    = 0x02;
4017     const long invalid   = 0x01;
4018     fp_control_word |= invalid;
4019     __asm { fldcw fp_control_word }
4020 #endif
4021   }
4022 
4023   // If stack_commit_size is 0, windows will reserve the default size,
4024   // but only commit a small portion of it.
4025   size_t stack_commit_size = align_up(ThreadStackSize*K, os::vm_page_size());
4026   size_t default_reserve_size = os::win32::default_stack_size();
4027   size_t actual_reserve_size = stack_commit_size;
4028   if (stack_commit_size &lt; default_reserve_size) {
4029     // If stack_commit_size == 0, we want this too
4030     actual_reserve_size = default_reserve_size;
4031   }
4032 
4033   // Check minimum allowable stack size for thread creation and to initialize
4034   // the java system classes, including StackOverflowError - depends on page
4035   // size.  Add two 4K pages for compiler2 recursion in main thread.
4036   // Add in 4*BytesPerWord 4K pages to account for VM stack during
4037   // class initialization depending on 32 or 64 bit VM.
4038   size_t min_stack_allowed =
4039             (size_t)(JavaThread::stack_guard_zone_size() +
4040                      JavaThread::stack_shadow_zone_size() +
4041                      (4*BytesPerWord COMPILER2_PRESENT(+2)) * 4 * K);
4042 
4043   min_stack_allowed = align_up(min_stack_allowed, os::vm_page_size());
4044 
4045   if (actual_reserve_size &lt; min_stack_allowed) {
4046     tty-&gt;print_cr(&quot;\nThe Java thread stack size specified is too small. &quot;
4047                   &quot;Specify at least %dk&quot;,
4048                   min_stack_allowed / K);
4049     return JNI_ERR;
4050   }
4051 
4052   JavaThread::set_stack_size_at_create(stack_commit_size);
4053 
4054   // Calculate theoretical max. size of Threads to guard gainst artifical
4055   // out-of-memory situations, where all available address-space has been
4056   // reserved by thread stacks.
4057   assert(actual_reserve_size != 0, &quot;Must have a stack&quot;);
4058 
4059   // Calculate the thread limit when we should start doing Virtual Memory
4060   // banging. Currently when the threads will have used all but 200Mb of space.
4061   //
4062   // TODO: consider performing a similar calculation for commit size instead
4063   // as reserve size, since on a 64-bit platform we&#39;ll run into that more
4064   // often than running out of virtual memory space.  We can use the
4065   // lower value of the two calculations as the os_thread_limit.
4066   size_t max_address_space = ((size_t)1 &lt;&lt; (BitsPerWord - 1)) - (200 * K * K);
4067   win32::_os_thread_limit = (intx)(max_address_space / actual_reserve_size);
4068 
4069   // at exit methods are called in the reverse order of their registration.
4070   // there is no limit to the number of functions registered. atexit does
4071   // not set errno.
4072 
4073   if (PerfAllowAtExitRegistration) {
4074     // only register atexit functions if PerfAllowAtExitRegistration is set.
4075     // atexit functions can be delayed until process exit time, which
4076     // can be problematic for embedded VM situations. Embedded VMs should
4077     // call DestroyJavaVM() to assure that VM resources are released.
4078 
4079     // note: perfMemory_exit_helper atexit function may be removed in
4080     // the future if the appropriate cleanup code can be added to the
4081     // VM_Exit VMOperation&#39;s doit method.
4082     if (atexit(perfMemory_exit_helper) != 0) {
4083       warning(&quot;os::init_2 atexit(perfMemory_exit_helper) failed&quot;);
4084     }
4085   }
4086 
4087 #ifndef _WIN64
4088   // Print something if NX is enabled (win32 on AMD64)
4089   NOT_PRODUCT(if (PrintMiscellaneous &amp;&amp; Verbose) nx_check_protection());
4090 #endif
4091 
4092   // initialize thread priority policy
4093   prio_init();
4094 
4095   if (UseNUMA &amp;&amp; !ForceNUMA) {
4096     UseNUMA = false; // We don&#39;t fully support this yet
4097   }
4098 
4099   if (UseNUMAInterleaving) {
4100     // first check whether this Windows OS supports VirtualAllocExNuma, if not ignore this flag
4101     bool success = numa_interleaving_init();
4102     if (!success) UseNUMAInterleaving = false;
4103   }
4104 
4105   if (initSock() != JNI_OK) {
4106     return JNI_ERR;
4107   }
4108 
4109   SymbolEngine::recalc_search_path();
4110 
4111   // Initialize data for jdk.internal.misc.Signal
4112   if (!ReduceSignalUsage) {
4113     jdk_misc_signal_init();
4114   }
4115 
4116   return JNI_OK;
4117 }
4118 
4119 // combine the high and low DWORD into a ULONGLONG
4120 static ULONGLONG make_double_word(DWORD high_word, DWORD low_word) {
4121   ULONGLONG value = high_word;
4122   value &lt;&lt;= sizeof(high_word) * 8;
4123   value |= low_word;
4124   return value;
4125 }
4126 
4127 // Transfers data from WIN32_FILE_ATTRIBUTE_DATA structure to struct stat
4128 static void file_attribute_data_to_stat(struct stat* sbuf, WIN32_FILE_ATTRIBUTE_DATA file_data) {
4129   ::memset((void*)sbuf, 0, sizeof(struct stat));
4130   sbuf-&gt;st_size = (_off_t)make_double_word(file_data.nFileSizeHigh, file_data.nFileSizeLow);
4131   sbuf-&gt;st_mtime = make_double_word(file_data.ftLastWriteTime.dwHighDateTime,
4132                                   file_data.ftLastWriteTime.dwLowDateTime);
4133   sbuf-&gt;st_ctime = make_double_word(file_data.ftCreationTime.dwHighDateTime,
4134                                   file_data.ftCreationTime.dwLowDateTime);
4135   sbuf-&gt;st_atime = make_double_word(file_data.ftLastAccessTime.dwHighDateTime,
4136                                   file_data.ftLastAccessTime.dwLowDateTime);
4137   if ((file_data.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0) {
4138     sbuf-&gt;st_mode |= S_IFDIR;
4139   } else {
4140     sbuf-&gt;st_mode |= S_IFREG;
4141   }
4142 }
4143 
4144 static errno_t convert_to_unicode(char const* char_path, LPWSTR* unicode_path) {
4145   // Get required buffer size to convert to Unicode
4146   int unicode_path_len = MultiByteToWideChar(CP_THREAD_ACP,
4147                                              MB_ERR_INVALID_CHARS,
4148                                              char_path, -1,
4149                                              NULL, 0);
4150   if (unicode_path_len == 0) {
4151     return EINVAL;
4152   }
4153 
4154   *unicode_path = NEW_C_HEAP_ARRAY(WCHAR, unicode_path_len, mtInternal);
4155 
4156   int result = MultiByteToWideChar(CP_THREAD_ACP,
4157                                    MB_ERR_INVALID_CHARS,
4158                                    char_path, -1,
4159                                    *unicode_path, unicode_path_len);
4160   assert(result == unicode_path_len, &quot;length already checked above&quot;);
4161 
4162   return ERROR_SUCCESS;
4163 }
4164 
4165 static errno_t get_full_path(LPCWSTR unicode_path, LPWSTR* full_path) {
4166   // Get required buffer size to convert to full path. The return
4167   // value INCLUDES the terminating null character.
4168   DWORD full_path_len = GetFullPathNameW(unicode_path, 0, NULL, NULL);
4169   if (full_path_len == 0) {
4170     return EINVAL;
4171   }
4172 
4173   *full_path = NEW_C_HEAP_ARRAY(WCHAR, full_path_len, mtInternal);
4174 
4175   // When the buffer has sufficient size, the return value EXCLUDES the
4176   // terminating null character
4177   DWORD result = GetFullPathNameW(unicode_path, full_path_len, *full_path, NULL);
4178   assert(result &lt;= full_path_len, &quot;length already checked above&quot;);
4179 
4180   return ERROR_SUCCESS;
4181 }
4182 
4183 static void set_path_prefix(char* buf, LPWSTR* prefix, int* prefix_off, bool* needs_fullpath) {
4184   *prefix_off = 0;
4185   *needs_fullpath = true;
4186 
4187   if (::isalpha(buf[0]) &amp;&amp; !::IsDBCSLeadByte(buf[0]) &amp;&amp; buf[1] == &#39;:&#39; &amp;&amp; buf[2] == &#39;\\&#39;) {
4188     *prefix = L&quot;\\\\?\\&quot;;
4189   } else if (buf[0] == &#39;\\&#39; &amp;&amp; buf[1] == &#39;\\&#39;) {
4190     if (buf[2] == &#39;?&#39; &amp;&amp; buf[3] == &#39;\\&#39;) {
4191       *prefix = L&quot;&quot;;
4192       *needs_fullpath = false;
4193     } else {
4194       *prefix = L&quot;\\\\?\\UNC&quot;;
4195       *prefix_off = 1; // Overwrite the first char with the prefix, so \\share\path becomes \\?\UNC\share\path
4196     }
4197   } else {
4198     *prefix = L&quot;\\\\?\\&quot;;
4199   }
4200 }
4201 
4202 // Returns the given path as an absolute wide path in unc format. The returned path is NULL
4203 // on error (with err being set accordingly) and should be freed via os::free() otherwise.
4204 // additional_space is the size of space, in wchar_t, the function will additionally add to
4205 // the allocation of return buffer (such that the size of the returned buffer is at least
4206 // wcslen(buf) + 1 + additional_space).
4207 static wchar_t* wide_abs_unc_path(char const* path, errno_t &amp; err, int additional_space = 0) {
4208   if ((path == NULL) || (path[0] == &#39;\0&#39;)) {
4209     err = ENOENT;
4210     return NULL;
4211   }
4212 
4213   // Need to allocate at least room for 3 characters, since os::native_path transforms C: to C:.
4214   size_t buf_len = 1 + MAX2((size_t)3, strlen(path));
4215   char* buf = NEW_C_HEAP_ARRAY(char, buf_len, mtInternal);
4216   strncpy(buf, path, buf_len);
4217   os::native_path(buf);
4218 
4219   LPWSTR prefix = NULL;
4220   int prefix_off = 0;
4221   bool needs_fullpath = true;
4222   set_path_prefix(buf, &amp;prefix, &amp;prefix_off, &amp;needs_fullpath);
4223 
4224   LPWSTR unicode_path = NULL;
4225   err = convert_to_unicode(buf, &amp;unicode_path);
4226   FREE_C_HEAP_ARRAY(char, buf);
4227   if (err != ERROR_SUCCESS) {
4228     return NULL;
4229   }
4230 
4231   LPWSTR converted_path = NULL;
4232   if (needs_fullpath) {
4233     err = get_full_path(unicode_path, &amp;converted_path);
4234   } else {
4235     converted_path = unicode_path;
4236   }
4237 
4238   LPWSTR result = NULL;
4239   if (converted_path != NULL) {
4240     size_t prefix_len = wcslen(prefix);
4241     size_t result_len = prefix_len - prefix_off + wcslen(converted_path) + additional_space + 1;
4242     result = NEW_C_HEAP_ARRAY(WCHAR, result_len, mtInternal);
4243     _snwprintf(result, result_len, L&quot;%s%s&quot;, prefix, &amp;converted_path[prefix_off]);
4244 
4245     // Remove trailing pathsep (not for \\?\&lt;DRIVE&gt;:\, since it would make it relative)
4246     result_len = wcslen(result);
4247     if ((result[result_len - 1] == L&#39;\\&#39;) &amp;&amp;
4248         !(::iswalpha(result[4]) &amp;&amp; result[5] == L&#39;:&#39; &amp;&amp; result_len == 7)) {
4249       result[result_len - 1] = L&#39;\0&#39;;
4250     }
4251   }
4252 
4253   if (converted_path != unicode_path) {
4254     FREE_C_HEAP_ARRAY(WCHAR, converted_path);
4255   }
4256   FREE_C_HEAP_ARRAY(WCHAR, unicode_path);
4257 
4258   return static_cast&lt;wchar_t*&gt;(result); // LPWSTR and wchat_t* are the same type on Windows.
4259 }
4260 
4261 int os::stat(const char *path, struct stat *sbuf) {
4262   errno_t err;
4263   wchar_t* wide_path = wide_abs_unc_path(path, err);
4264 
4265   if (wide_path == NULL) {
4266     errno = err;
4267     return -1;
4268   }
4269 
4270   WIN32_FILE_ATTRIBUTE_DATA file_data;;
4271   BOOL bret = ::GetFileAttributesExW(wide_path, GetFileExInfoStandard, &amp;file_data);
4272   os::free(wide_path);
4273 
4274   if (!bret) {
4275     errno = ::GetLastError();
4276     return -1;
4277   }
4278 
4279   file_attribute_data_to_stat(sbuf, file_data);
4280   return 0;
4281 }
4282 
4283 static HANDLE create_read_only_file_handle(const char* file) {
4284   errno_t err;
4285   wchar_t* wide_path = wide_abs_unc_path(file, err);
4286 
4287   if (wide_path == NULL) {
4288     errno = err;
4289     return INVALID_HANDLE_VALUE;
4290   }
4291 
4292   HANDLE handle = ::CreateFileW(wide_path, 0, FILE_SHARE_READ,
4293                                 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
4294   os::free(wide_path);
4295 
4296   return handle;
4297 }
4298 
4299 bool os::same_files(const char* file1, const char* file2) {
4300 
4301   if (file1 == NULL &amp;&amp; file2 == NULL) {
4302     return true;
4303   }
4304 
4305   if (file1 == NULL || file2 == NULL) {
4306     return false;
4307   }
4308 
4309   if (strcmp(file1, file2) == 0) {
4310     return true;
4311   }
4312 
4313   HANDLE handle1 = create_read_only_file_handle(file1);
4314   HANDLE handle2 = create_read_only_file_handle(file2);
4315   bool result = false;
4316 
4317   // if we could open both paths...
4318   if (handle1 != INVALID_HANDLE_VALUE &amp;&amp; handle2 != INVALID_HANDLE_VALUE) {
4319     BY_HANDLE_FILE_INFORMATION fileInfo1;
4320     BY_HANDLE_FILE_INFORMATION fileInfo2;
4321     if (::GetFileInformationByHandle(handle1, &amp;fileInfo1) &amp;&amp;
4322       ::GetFileInformationByHandle(handle2, &amp;fileInfo2)) {
4323       // the paths are the same if they refer to the same file (fileindex) on the same volume (volume serial number)
4324       if (fileInfo1.dwVolumeSerialNumber == fileInfo2.dwVolumeSerialNumber &amp;&amp;
4325         fileInfo1.nFileIndexHigh == fileInfo2.nFileIndexHigh &amp;&amp;
4326         fileInfo1.nFileIndexLow == fileInfo2.nFileIndexLow) {
4327         result = true;
4328       }
4329     }
4330   }
4331 
4332   //free the handles
4333   if (handle1 != INVALID_HANDLE_VALUE) {
4334     ::CloseHandle(handle1);
4335   }
4336 
4337   if (handle2 != INVALID_HANDLE_VALUE) {
4338     ::CloseHandle(handle2);
4339   }
4340 
4341   return result;
4342 }
4343 
4344 #define FT2INT64(ft) \
4345   ((jlong)((jlong)(ft).dwHighDateTime &lt;&lt; 32 | (julong)(ft).dwLowDateTime))
4346 
4347 
4348 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)
4349 // are used by JVM M&amp;M and JVMTI to get user+sys or user CPU time
4350 // of a thread.
4351 //
4352 // current_thread_cpu_time() and thread_cpu_time(Thread*) returns
4353 // the fast estimate available on the platform.
4354 
4355 // current_thread_cpu_time() is not optimized for Windows yet
4356 jlong os::current_thread_cpu_time() {
4357   // return user + sys since the cost is the same
4358   return os::thread_cpu_time(Thread::current(), true /* user+sys */);
4359 }
4360 
4361 jlong os::thread_cpu_time(Thread* thread) {
4362   // consistent with what current_thread_cpu_time() returns.
4363   return os::thread_cpu_time(thread, true /* user+sys */);
4364 }
4365 
4366 jlong os::current_thread_cpu_time(bool user_sys_cpu_time) {
4367   return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
4368 }
4369 
4370 jlong os::thread_cpu_time(Thread* thread, bool user_sys_cpu_time) {
4371   // This code is copy from clasic VM -&gt; hpi::sysThreadCPUTime
4372   // If this function changes, os::is_thread_cpu_time_supported() should too
4373   FILETIME CreationTime;
4374   FILETIME ExitTime;
4375   FILETIME KernelTime;
4376   FILETIME UserTime;
4377 
4378   if (GetThreadTimes(thread-&gt;osthread()-&gt;thread_handle(), &amp;CreationTime,
4379                       &amp;ExitTime, &amp;KernelTime, &amp;UserTime) == 0) {
4380     return -1;
4381   } else if (user_sys_cpu_time) {
4382     return (FT2INT64(UserTime) + FT2INT64(KernelTime)) * 100;
4383   } else {
4384     return FT2INT64(UserTime) * 100;
4385   }
4386 }
4387 
4388 void os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
4389   info_ptr-&gt;max_value = ALL_64_BITS;        // the max value -- all 64 bits
4390   info_ptr-&gt;may_skip_backward = false;      // GetThreadTimes returns absolute time
4391   info_ptr-&gt;may_skip_forward = false;       // GetThreadTimes returns absolute time
4392   info_ptr-&gt;kind = JVMTI_TIMER_TOTAL_CPU;   // user+system time is returned
4393 }
4394 
4395 void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
4396   info_ptr-&gt;max_value = ALL_64_BITS;        // the max value -- all 64 bits
4397   info_ptr-&gt;may_skip_backward = false;      // GetThreadTimes returns absolute time
4398   info_ptr-&gt;may_skip_forward = false;       // GetThreadTimes returns absolute time
4399   info_ptr-&gt;kind = JVMTI_TIMER_TOTAL_CPU;   // user+system time is returned
4400 }
4401 
4402 bool os::is_thread_cpu_time_supported() {
4403   // see os::thread_cpu_time
4404   FILETIME CreationTime;
4405   FILETIME ExitTime;
4406   FILETIME KernelTime;
4407   FILETIME UserTime;
4408 
4409   if (GetThreadTimes(GetCurrentThread(), &amp;CreationTime, &amp;ExitTime,
4410                       &amp;KernelTime, &amp;UserTime) == 0) {
4411     return false;
4412   } else {
4413     return true;
4414   }
4415 }
4416 
4417 // Windows does&#39;t provide a loadavg primitive so this is stubbed out for now.
4418 // It does have primitives (PDH API) to get CPU usage and run queue length.
4419 // &quot;\\Processor(_Total)\\% Processor Time&quot;, &quot;\\System\\Processor Queue Length&quot;
4420 // If we wanted to implement loadavg on Windows, we have a few options:
4421 //
4422 // a) Query CPU usage and run queue length and &quot;fake&quot; an answer by
4423 //    returning the CPU usage if it&#39;s under 100%, and the run queue
4424 //    length otherwise.  It turns out that querying is pretty slow
4425 //    on Windows, on the order of 200 microseconds on a fast machine.
4426 //    Note that on the Windows the CPU usage value is the % usage
4427 //    since the last time the API was called (and the first call
4428 //    returns 100%), so we&#39;d have to deal with that as well.
4429 //
4430 // b) Sample the &quot;fake&quot; answer using a sampling thread and store
4431 //    the answer in a global variable.  The call to loadavg would
4432 //    just return the value of the global, avoiding the slow query.
4433 //
4434 // c) Sample a better answer using exponential decay to smooth the
4435 //    value.  This is basically the algorithm used by UNIX kernels.
4436 //
4437 // Note that sampling thread starvation could affect both (b) and (c).
4438 int os::loadavg(double loadavg[], int nelem) {
4439   return -1;
4440 }
4441 
4442 
4443 // DontYieldALot=false by default: dutifully perform all yields as requested by JVM_Yield()
4444 bool os::dont_yield() {
4445   return DontYieldALot;
4446 }
4447 
4448 int os::open(const char *path, int oflag, int mode) {
4449   errno_t err;
4450   wchar_t* wide_path = wide_abs_unc_path(path, err);
4451 
4452   if (wide_path == NULL) {
4453     errno = err;
4454     return -1;
4455   }
4456   int fd = ::_wopen(wide_path, oflag | O_BINARY | O_NOINHERIT, mode);
4457   os::free(wide_path);
4458 
4459   if (fd == -1) {
4460     errno = ::GetLastError();
4461   }
4462 
4463   return fd;
4464 }
4465 
4466 FILE* os::open(int fd, const char* mode) {
4467   return ::_fdopen(fd, mode);
4468 }
4469 
4470 // Is a (classpath) directory empty?
4471 bool os::dir_is_empty(const char* path) {
4472   errno_t err;
4473   wchar_t* wide_path = wide_abs_unc_path(path, err, 2);
4474 
4475   if (wide_path == NULL) {
4476     errno = err;
4477     return false;
4478   }
4479 
4480   // Make sure we end with &quot;\\*&quot;
4481   if (wide_path[wcslen(wide_path) - 1] == L&#39;\\&#39;) {
4482     wcscat(wide_path, L&quot;*&quot;);
4483   } else {
4484     wcscat(wide_path, L&quot;\\*&quot;);
4485   }
4486 
4487   WIN32_FIND_DATAW fd;
4488   HANDLE f = ::FindFirstFileW(wide_path, &amp;fd);
4489   os::free(wide_path);
4490   bool is_empty = true;
4491 
4492   if (f != INVALID_HANDLE_VALUE) {
4493     while (is_empty &amp;&amp; ::FindNextFileW(f, &amp;fd)) {
4494       // An empty directory contains only the current directory file
4495       // and the previous directory file.
4496       if ((wcscmp(fd.cFileName, L&quot;.&quot;) != 0) &amp;&amp;
4497           (wcscmp(fd.cFileName, L&quot;..&quot;) != 0)) {
4498         is_empty = false;
4499       }
4500     }
4501     FindClose(f);
4502   } else {
4503     errno = ::GetLastError();
4504   }
4505 
4506   return is_empty;
4507 }
4508 
4509 // create binary file, rewriting existing file if required
4510 int os::create_binary_file(const char* path, bool rewrite_existing) {
4511   int oflags = _O_CREAT | _O_WRONLY | _O_BINARY;
4512   if (!rewrite_existing) {
4513     oflags |= _O_EXCL;
4514   }
4515   return ::open(path, oflags, _S_IREAD | _S_IWRITE);
4516 }
4517 
4518 // return current position of file pointer
4519 jlong os::current_file_offset(int fd) {
4520   return (jlong)::_lseeki64(fd, (__int64)0L, SEEK_CUR);
4521 }
4522 
4523 // move file pointer to the specified offset
4524 jlong os::seek_to_file_offset(int fd, jlong offset) {
4525   return (jlong)::_lseeki64(fd, (__int64)offset, SEEK_SET);
4526 }
4527 
4528 
4529 jlong os::lseek(int fd, jlong offset, int whence) {
4530   return (jlong) ::_lseeki64(fd, offset, whence);
4531 }
4532 
4533 ssize_t os::read_at(int fd, void *buf, unsigned int nBytes, jlong offset) {
4534   OVERLAPPED ov;
4535   DWORD nread;
4536   BOOL result;
4537 
4538   ZeroMemory(&amp;ov, sizeof(ov));
4539   ov.Offset = (DWORD)offset;
4540   ov.OffsetHigh = (DWORD)(offset &gt;&gt; 32);
4541 
4542   HANDLE h = (HANDLE)::_get_osfhandle(fd);
4543 
4544   result = ReadFile(h, (LPVOID)buf, nBytes, &amp;nread, &amp;ov);
4545 
4546   return result ? nread : 0;
4547 }
4548 
4549 
4550 // This method is a slightly reworked copy of JDK&#39;s sysNativePath
4551 // from src/windows/hpi/src/path_md.c
4552 
4553 // Convert a pathname to native format.  On win32, this involves forcing all
4554 // separators to be &#39;\\&#39; rather than &#39;/&#39; (both are legal inputs, but Win95
4555 // sometimes rejects &#39;/&#39;) and removing redundant separators.  The input path is
4556 // assumed to have been converted into the character encoding used by the local
4557 // system.  Because this might be a double-byte encoding, care is taken to
4558 // treat double-byte lead characters correctly.
4559 //
4560 // This procedure modifies the given path in place, as the result is never
4561 // longer than the original.  There is no error return; this operation always
4562 // succeeds.
4563 char * os::native_path(char *path) {
4564   char *src = path, *dst = path, *end = path;
4565   char *colon = NULL;  // If a drive specifier is found, this will
4566                        // point to the colon following the drive letter
4567 
4568   // Assumption: &#39;/&#39;, &#39;\\&#39;, &#39;:&#39;, and drive letters are never lead bytes
4569   assert(((!::IsDBCSLeadByte(&#39;/&#39;)) &amp;&amp; (!::IsDBCSLeadByte(&#39;\\&#39;))
4570           &amp;&amp; (!::IsDBCSLeadByte(&#39;:&#39;))), &quot;Illegal lead byte&quot;);
4571 
4572   // Check for leading separators
4573 #define isfilesep(c) ((c) == &#39;/&#39; || (c) == &#39;\\&#39;)
4574   while (isfilesep(*src)) {
4575     src++;
4576   }
4577 
4578   if (::isalpha(*src) &amp;&amp; !::IsDBCSLeadByte(*src) &amp;&amp; src[1] == &#39;:&#39;) {
4579     // Remove leading separators if followed by drive specifier.  This
4580     // hack is necessary to support file URLs containing drive
4581     // specifiers (e.g., &quot;file://c:/path&quot;).  As a side effect,
4582     // &quot;/c:/path&quot; can be used as an alternative to &quot;c:/path&quot;.
4583     *dst++ = *src++;
4584     colon = dst;
4585     *dst++ = &#39;:&#39;;
4586     src++;
4587   } else {
4588     src = path;
4589     if (isfilesep(src[0]) &amp;&amp; isfilesep(src[1])) {
4590       // UNC pathname: Retain first separator; leave src pointed at
4591       // second separator so that further separators will be collapsed
4592       // into the second separator.  The result will be a pathname
4593       // beginning with &quot;\\\\&quot; followed (most likely) by a host name.
4594       src = dst = path + 1;
4595       path[0] = &#39;\\&#39;;     // Force first separator to &#39;\\&#39;
4596     }
4597   }
4598 
4599   end = dst;
4600 
4601   // Remove redundant separators from remainder of path, forcing all
4602   // separators to be &#39;\\&#39; rather than &#39;/&#39;. Also, single byte space
4603   // characters are removed from the end of the path because those
4604   // are not legal ending characters on this operating system.
4605   //
4606   while (*src != &#39;\0&#39;) {
4607     if (isfilesep(*src)) {
4608       *dst++ = &#39;\\&#39;; src++;
4609       while (isfilesep(*src)) src++;
4610       if (*src == &#39;\0&#39;) {
4611         // Check for trailing separator
4612         end = dst;
4613         if (colon == dst - 2) break;  // &quot;z:\\&quot;
4614         if (dst == path + 1) break;   // &quot;\\&quot;
4615         if (dst == path + 2 &amp;&amp; isfilesep(path[0])) {
4616           // &quot;\\\\&quot; is not collapsed to &quot;\\&quot; because &quot;\\\\&quot; marks the
4617           // beginning of a UNC pathname.  Even though it is not, by
4618           // itself, a valid UNC pathname, we leave it as is in order
4619           // to be consistent with the path canonicalizer as well
4620           // as the win32 APIs, which treat this case as an invalid
4621           // UNC pathname rather than as an alias for the root
4622           // directory of the current drive.
4623           break;
4624         }
4625         end = --dst;  // Path does not denote a root directory, so
4626                       // remove trailing separator
4627         break;
4628       }
4629       end = dst;
4630     } else {
4631       if (::IsDBCSLeadByte(*src)) {  // Copy a double-byte character
4632         *dst++ = *src++;
4633         if (*src) *dst++ = *src++;
4634         end = dst;
4635       } else {  // Copy a single-byte character
4636         char c = *src++;
4637         *dst++ = c;
4638         // Space is not a legal ending character
4639         if (c != &#39; &#39;) end = dst;
4640       }
4641     }
4642   }
4643 
4644   *end = &#39;\0&#39;;
4645 
4646   // For &quot;z:&quot;, add &quot;.&quot; to work around a bug in the C runtime library
4647   if (colon == dst - 1) {
4648     path[2] = &#39;.&#39;;
4649     path[3] = &#39;\0&#39;;
4650   }
4651 
4652   return path;
4653 }
4654 
4655 // This code is a copy of JDK&#39;s sysSetLength
4656 // from src/windows/hpi/src/sys_api_md.c
4657 
4658 int os::ftruncate(int fd, jlong length) {
4659   HANDLE h = (HANDLE)::_get_osfhandle(fd);
4660   long high = (long)(length &gt;&gt; 32);
4661   DWORD ret;
4662 
4663   if (h == (HANDLE)(-1)) {
4664     return -1;
4665   }
4666 
4667   ret = ::SetFilePointer(h, (long)(length), &amp;high, FILE_BEGIN);
4668   if ((ret == 0xFFFFFFFF) &amp;&amp; (::GetLastError() != NO_ERROR)) {
4669     return -1;
4670   }
4671 
4672   if (::SetEndOfFile(h) == FALSE) {
4673     return -1;
4674   }
4675 
4676   return 0;
4677 }
4678 
4679 int os::get_fileno(FILE* fp) {
4680   return _fileno(fp);
4681 }
4682 
4683 // This code is a copy of JDK&#39;s sysSync
4684 // from src/windows/hpi/src/sys_api_md.c
4685 // except for the legacy workaround for a bug in Win 98
4686 
4687 int os::fsync(int fd) {
4688   HANDLE handle = (HANDLE)::_get_osfhandle(fd);
4689 
4690   if ((!::FlushFileBuffers(handle)) &amp;&amp;
4691       (GetLastError() != ERROR_ACCESS_DENIED)) {
4692     // from winerror.h
4693     return -1;
4694   }
4695   return 0;
4696 }
4697 
4698 static int nonSeekAvailable(int, long *);
4699 static int stdinAvailable(int, long *);
4700 
4701 // This code is a copy of JDK&#39;s sysAvailable
4702 // from src/windows/hpi/src/sys_api_md.c
4703 
4704 int os::available(int fd, jlong *bytes) {
4705   jlong cur, end;
4706   struct _stati64 stbuf64;
4707 
4708   if (::_fstati64(fd, &amp;stbuf64) &gt;= 0) {
4709     int mode = stbuf64.st_mode;
4710     if (S_ISCHR(mode) || S_ISFIFO(mode)) {
4711       int ret;
4712       long lpbytes;
4713       if (fd == 0) {
4714         ret = stdinAvailable(fd, &amp;lpbytes);
4715       } else {
4716         ret = nonSeekAvailable(fd, &amp;lpbytes);
4717       }
4718       (*bytes) = (jlong)(lpbytes);
4719       return ret;
4720     }
4721     if ((cur = ::_lseeki64(fd, 0L, SEEK_CUR)) == -1) {
4722       return FALSE;
4723     } else if ((end = ::_lseeki64(fd, 0L, SEEK_END)) == -1) {
4724       return FALSE;
4725     } else if (::_lseeki64(fd, cur, SEEK_SET) == -1) {
4726       return FALSE;
4727     }
4728     *bytes = end - cur;
4729     return TRUE;
4730   } else {
4731     return FALSE;
4732   }
4733 }
4734 
4735 void os::flockfile(FILE* fp) {
4736   _lock_file(fp);
4737 }
4738 
4739 void os::funlockfile(FILE* fp) {
4740   _unlock_file(fp);
4741 }
4742 
4743 // This code is a copy of JDK&#39;s nonSeekAvailable
4744 // from src/windows/hpi/src/sys_api_md.c
4745 
4746 static int nonSeekAvailable(int fd, long *pbytes) {
4747   // This is used for available on non-seekable devices
4748   // (like both named and anonymous pipes, such as pipes
4749   //  connected to an exec&#39;d process).
4750   // Standard Input is a special case.
4751   HANDLE han;
4752 
4753   if ((han = (HANDLE) ::_get_osfhandle(fd)) == (HANDLE)(-1)) {
4754     return FALSE;
4755   }
4756 
4757   if (! ::PeekNamedPipe(han, NULL, 0, NULL, (LPDWORD)pbytes, NULL)) {
4758     // PeekNamedPipe fails when at EOF.  In that case we
4759     // simply make *pbytes = 0 which is consistent with the
4760     // behavior we get on Solaris when an fd is at EOF.
4761     // The only alternative is to raise an Exception,
4762     // which isn&#39;t really warranted.
4763     //
4764     if (::GetLastError() != ERROR_BROKEN_PIPE) {
4765       return FALSE;
4766     }
4767     *pbytes = 0;
4768   }
4769   return TRUE;
4770 }
4771 
4772 #define MAX_INPUT_EVENTS 2000
4773 
4774 // This code is a copy of JDK&#39;s stdinAvailable
4775 // from src/windows/hpi/src/sys_api_md.c
4776 
4777 static int stdinAvailable(int fd, long *pbytes) {
4778   HANDLE han;
4779   DWORD numEventsRead = 0;  // Number of events read from buffer
4780   DWORD numEvents = 0;      // Number of events in buffer
4781   DWORD i = 0;              // Loop index
4782   DWORD curLength = 0;      // Position marker
4783   DWORD actualLength = 0;   // Number of bytes readable
4784   BOOL error = FALSE;       // Error holder
4785   INPUT_RECORD *lpBuffer;   // Pointer to records of input events
4786 
4787   if ((han = ::GetStdHandle(STD_INPUT_HANDLE)) == INVALID_HANDLE_VALUE) {
4788     return FALSE;
4789   }
4790 
4791   // Construct an array of input records in the console buffer
4792   error = ::GetNumberOfConsoleInputEvents(han, &amp;numEvents);
4793   if (error == 0) {
4794     return nonSeekAvailable(fd, pbytes);
4795   }
4796 
4797   // lpBuffer must fit into 64K or else PeekConsoleInput fails
4798   if (numEvents &gt; MAX_INPUT_EVENTS) {
4799     numEvents = MAX_INPUT_EVENTS;
4800   }
4801 
4802   lpBuffer = (INPUT_RECORD *)os::malloc(numEvents * sizeof(INPUT_RECORD), mtInternal);
4803   if (lpBuffer == NULL) {
4804     return FALSE;
4805   }
4806 
4807   error = ::PeekConsoleInput(han, lpBuffer, numEvents, &amp;numEventsRead);
4808   if (error == 0) {
4809     os::free(lpBuffer);
4810     return FALSE;
4811   }
4812 
4813   // Examine input records for the number of bytes available
4814   for (i=0; i&lt;numEvents; i++) {
4815     if (lpBuffer[i].EventType == KEY_EVENT) {
4816 
4817       KEY_EVENT_RECORD *keyRecord = (KEY_EVENT_RECORD *)
4818                                       &amp;(lpBuffer[i].Event);
4819       if (keyRecord-&gt;bKeyDown == TRUE) {
4820         CHAR *keyPressed = (CHAR *) &amp;(keyRecord-&gt;uChar);
4821         curLength++;
4822         if (*keyPressed == &#39;\r&#39;) {
4823           actualLength = curLength;
4824         }
4825       }
4826     }
4827   }
4828 
4829   if (lpBuffer != NULL) {
4830     os::free(lpBuffer);
4831   }
4832 
4833   *pbytes = (long) actualLength;
4834   return TRUE;
4835 }
4836 
4837 // Map a block of memory.
4838 char* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,
4839                         char *addr, size_t bytes, bool read_only,
4840                         bool allow_exec) {
4841   HANDLE hFile;
4842   char* base;
4843 
4844   hFile = CreateFile(file_name, GENERIC_READ, FILE_SHARE_READ, NULL,
4845                      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
4846   if (hFile == NULL) {
4847     log_info(os)(&quot;CreateFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4848     return NULL;
4849   }
4850 
4851   if (allow_exec) {
4852     // CreateFileMapping/MapViewOfFileEx can&#39;t map executable memory
4853     // unless it comes from a PE image (which the shared archive is not.)
4854     // Even VirtualProtect refuses to give execute access to mapped memory
4855     // that was not previously executable.
4856     //
4857     // Instead, stick the executable region in anonymous memory.  Yuck.
4858     // Penalty is that ~4 pages will not be shareable - in the future
4859     // we might consider DLLizing the shared archive with a proper PE
4860     // header so that mapping executable + sharing is possible.
4861 
4862     base = (char*) VirtualAlloc(addr, bytes, MEM_COMMIT | MEM_RESERVE,
4863                                 PAGE_READWRITE);
4864     if (base == NULL) {
4865       log_info(os)(&quot;VirtualAlloc() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4866       CloseHandle(hFile);
4867       return NULL;
4868     }
4869 
4870     // Record virtual memory allocation
4871     MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, CALLER_PC);
4872 
4873     DWORD bytes_read;
4874     OVERLAPPED overlapped;
4875     overlapped.Offset = (DWORD)file_offset;
4876     overlapped.OffsetHigh = 0;
4877     overlapped.hEvent = NULL;
4878     // ReadFile guarantees that if the return value is true, the requested
4879     // number of bytes were read before returning.
4880     bool res = ReadFile(hFile, base, (DWORD)bytes, &amp;bytes_read, &amp;overlapped) != 0;
4881     if (!res) {
4882       log_info(os)(&quot;ReadFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4883       release_memory(base, bytes);
4884       CloseHandle(hFile);
4885       return NULL;
4886     }
4887   } else {
4888     HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_WRITECOPY, 0, 0,
4889                                     NULL /* file_name */);
4890     if (hMap == NULL) {
4891       log_info(os)(&quot;CreateFileMapping() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4892       CloseHandle(hFile);
4893       return NULL;
4894     }
4895 
4896     DWORD access = read_only ? FILE_MAP_READ : FILE_MAP_COPY;
4897     base = (char*)MapViewOfFileEx(hMap, access, 0, (DWORD)file_offset,
4898                                   (DWORD)bytes, addr);
4899     if (base == NULL) {
4900       log_info(os)(&quot;MapViewOfFileEx() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4901       CloseHandle(hMap);
4902       CloseHandle(hFile);
4903       return NULL;
4904     }
4905 
4906     if (CloseHandle(hMap) == 0) {
4907       log_info(os)(&quot;CloseHandle(hMap) failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4908       CloseHandle(hFile);
4909       return base;
4910     }
4911   }
4912 
4913   if (allow_exec) {
4914     DWORD old_protect;
4915     DWORD exec_access = read_only ? PAGE_EXECUTE_READ : PAGE_EXECUTE_READWRITE;
4916     bool res = VirtualProtect(base, bytes, exec_access, &amp;old_protect) != 0;
4917 
4918     if (!res) {
4919       log_info(os)(&quot;VirtualProtect() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4920       // Don&#39;t consider this a hard error, on IA32 even if the
4921       // VirtualProtect fails, we should still be able to execute
4922       CloseHandle(hFile);
4923       return base;
4924     }
4925   }
4926 
4927   if (CloseHandle(hFile) == 0) {
4928     log_info(os)(&quot;CloseHandle(hFile) failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4929     return base;
4930   }
4931 
4932   return base;
4933 }
4934 
4935 
4936 // Remap a block of memory.
4937 char* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,
4938                           char *addr, size_t bytes, bool read_only,
4939                           bool allow_exec) {
4940   // This OS does not allow existing memory maps to be remapped so we
4941   // would have to unmap the memory before we remap it.
4942 
4943   // Because there is a small window between unmapping memory and mapping
4944   // it in again with different protections, CDS archives are mapped RW
4945   // on windows, so this function isn&#39;t called.
4946   ShouldNotReachHere();
4947   return NULL;
4948 }
4949 
4950 
4951 // Unmap a block of memory.
4952 // Returns true=success, otherwise false.
4953 
4954 bool os::pd_unmap_memory(char* addr, size_t bytes) {
4955   MEMORY_BASIC_INFORMATION mem_info;
4956   if (VirtualQuery(addr, &amp;mem_info, sizeof(mem_info)) == 0) {
4957     log_info(os)(&quot;VirtualQuery() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4958     return false;
4959   }
4960 
4961   // Executable memory was not mapped using CreateFileMapping/MapViewOfFileEx.
4962   // Instead, executable region was allocated using VirtualAlloc(). See
4963   // pd_map_memory() above.
4964   //
4965   // The following flags should match the &#39;exec_access&#39; flages used for
4966   // VirtualProtect() in pd_map_memory().
4967   if (mem_info.Protect == PAGE_EXECUTE_READ ||
4968       mem_info.Protect == PAGE_EXECUTE_READWRITE) {
4969     return pd_release_memory(addr, bytes);
4970   }
4971 
4972   BOOL result = UnmapViewOfFile(addr);
4973   if (result == 0) {
4974     log_info(os)(&quot;UnmapViewOfFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4975     return false;
4976   }
4977   return true;
4978 }
4979 
4980 void os::pause() {
4981   char filename[MAX_PATH];
4982   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
4983     jio_snprintf(filename, MAX_PATH, &quot;%s&quot;, PauseAtStartupFile);
4984   } else {
4985     jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
4986   }
4987 
4988   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
4989   if (fd != -1) {
4990     struct stat buf;
4991     ::close(fd);
4992     while (::stat(filename, &amp;buf) == 0) {
4993       Sleep(100);
4994     }
4995   } else {
4996     jio_fprintf(stderr,
4997                 &quot;Could not open pause file &#39;%s&#39;, continuing immediately.\n&quot;, filename);
4998   }
4999 }
5000 
5001 Thread* os::ThreadCrashProtection::_protected_thread = NULL;
5002 os::ThreadCrashProtection* os::ThreadCrashProtection::_crash_protection = NULL;
5003 volatile intptr_t os::ThreadCrashProtection::_crash_mux = 0;
5004 
5005 os::ThreadCrashProtection::ThreadCrashProtection() {
5006 }
5007 
5008 // See the caveats for this class in os_windows.hpp
5009 // Protects the callback call so that raised OS EXCEPTIONS causes a jump back
5010 // into this method and returns false. If no OS EXCEPTION was raised, returns
5011 // true.
5012 // The callback is supposed to provide the method that should be protected.
5013 //
5014 bool os::ThreadCrashProtection::call(os::CrashProtectionCallback&amp; cb) {
5015 
5016   Thread::muxAcquire(&amp;_crash_mux, &quot;CrashProtection&quot;);
5017 
5018   _protected_thread = Thread::current_or_null();
5019   assert(_protected_thread != NULL, &quot;Cannot crash protect a NULL thread&quot;);
5020 
5021   bool success = true;
5022   __try {
5023     _crash_protection = this;
5024     cb.call();
5025   } __except(EXCEPTION_EXECUTE_HANDLER) {
5026     // only for protection, nothing to do
5027     success = false;
5028   }
5029   _crash_protection = NULL;
5030   _protected_thread = NULL;
5031   Thread::muxRelease(&amp;_crash_mux);
5032   return success;
5033 }
5034 
5035 
5036 class HighResolutionInterval : public CHeapObj&lt;mtThread&gt; {
5037   // The default timer resolution seems to be 10 milliseconds.
5038   // (Where is this written down?)
5039   // If someone wants to sleep for only a fraction of the default,
5040   // then we set the timer resolution down to 1 millisecond for
5041   // the duration of their interval.
5042   // We carefully set the resolution back, since otherwise we
5043   // seem to incur an overhead (3%?) that we don&#39;t need.
5044   // CONSIDER: if ms is small, say 3, then we should run with a high resolution time.
5045   // Buf if ms is large, say 500, or 503, we should avoid the call to timeBeginPeriod().
5046   // Alternatively, we could compute the relative error (503/500 = .6%) and only use
5047   // timeBeginPeriod() if the relative error exceeded some threshold.
5048   // timeBeginPeriod() has been linked to problems with clock drift on win32 systems and
5049   // to decreased efficiency related to increased timer &quot;tick&quot; rates.  We want to minimize
5050   // (a) calls to timeBeginPeriod() and timeEndPeriod() and (b) time spent with high
5051   // resolution timers running.
5052  private:
5053   jlong resolution;
5054  public:
5055   HighResolutionInterval(jlong ms) {
5056     resolution = ms % 10L;
5057     if (resolution != 0) {
5058       MMRESULT result = timeBeginPeriod(1L);
5059     }
5060   }
5061   ~HighResolutionInterval() {
5062     if (resolution != 0) {
5063       MMRESULT result = timeEndPeriod(1L);
5064     }
5065     resolution = 0L;
5066   }
5067 };
5068 
5069 // An Event wraps a win32 &quot;CreateEvent&quot; kernel handle.
5070 //
5071 // We have a number of choices regarding &quot;CreateEvent&quot; win32 handle leakage:
5072 //
5073 // 1:  When a thread dies return the Event to the EventFreeList, clear the ParkHandle
5074 //     field, and call CloseHandle() on the win32 event handle.  Unpark() would
5075 //     need to be modified to tolerate finding a NULL (invalid) win32 event handle.
5076 //     In addition, an unpark() operation might fetch the handle field, but the
5077 //     event could recycle between the fetch and the SetEvent() operation.
5078 //     SetEvent() would either fail because the handle was invalid, or inadvertently work,
5079 //     as the win32 handle value had been recycled.  In an ideal world calling SetEvent()
5080 //     on an stale but recycled handle would be harmless, but in practice this might
5081 //     confuse other non-Sun code, so it&#39;s not a viable approach.
5082 //
5083 // 2:  Once a win32 event handle is associated with an Event, it remains associated
5084 //     with the Event.  The event handle is never closed.  This could be construed
5085 //     as handle leakage, but only up to the maximum # of threads that have been extant
5086 //     at any one time.  This shouldn&#39;t be an issue, as windows platforms typically
5087 //     permit a process to have hundreds of thousands of open handles.
5088 //
5089 // 3:  Same as (1), but periodically, at stop-the-world time, rundown the EventFreeList
5090 //     and release unused handles.
5091 //
5092 // 4:  Add a CRITICAL_SECTION to the Event to protect LD+SetEvent from LD;ST(null);CloseHandle.
5093 //     It&#39;s not clear, however, that we wouldn&#39;t be trading one type of leak for another.
5094 //
5095 // 5.  Use an RCU-like mechanism (Read-Copy Update).
5096 //     Or perhaps something similar to Maged Michael&#39;s &quot;Hazard pointers&quot;.
5097 //
5098 // We use (2).
5099 //
5100 // TODO-FIXME:
5101 // 1.  Reconcile Doug&#39;s JSR166 j.u.c park-unpark with the objectmonitor implementation.
5102 // 2.  Consider wrapping the WaitForSingleObject(Ex) calls in SEH try/finally blocks
5103 //     to recover from (or at least detect) the dreaded Windows 841176 bug.
5104 // 3.  Collapse the JSR166 parker event, and the objectmonitor ParkEvent
5105 //     into a single win32 CreateEvent() handle.
5106 //
5107 // Assumption:
5108 //    Only one parker can exist on an event, which is why we allocate
5109 //    them per-thread. Multiple unparkers can coexist.
5110 //
5111 // _Event transitions in park()
5112 //   -1 =&gt; -1 : illegal
5113 //    1 =&gt;  0 : pass - return immediately
5114 //    0 =&gt; -1 : block; then set _Event to 0 before returning
5115 //
5116 // _Event transitions in unpark()
5117 //    0 =&gt; 1 : just return
5118 //    1 =&gt; 1 : just return
5119 //   -1 =&gt; either 0 or 1; must signal target thread
5120 //         That is, we can safely transition _Event from -1 to either
5121 //         0 or 1.
5122 //
5123 // _Event serves as a restricted-range semaphore.
5124 //   -1 : thread is blocked, i.e. there is a waiter
5125 //    0 : neutral: thread is running or ready,
5126 //        could have been signaled after a wait started
5127 //    1 : signaled - thread is running or ready
5128 //
5129 // Another possible encoding of _Event would be with
5130 // explicit &quot;PARKED&quot; == 01b and &quot;SIGNALED&quot; == 10b bits.
5131 //
5132 
5133 int os::PlatformEvent::park(jlong Millis) {
5134   // Transitions for _Event:
5135   //   -1 =&gt; -1 : illegal
5136   //    1 =&gt;  0 : pass - return immediately
5137   //    0 =&gt; -1 : block; then set _Event to 0 before returning
5138 
5139   guarantee(_ParkHandle != NULL , &quot;Invariant&quot;);
5140   guarantee(Millis &gt; 0          , &quot;Invariant&quot;);
5141 
5142   // CONSIDER: defer assigning a CreateEvent() handle to the Event until
5143   // the initial park() operation.
5144   // Consider: use atomic decrement instead of CAS-loop
5145 
5146   int v;
5147   for (;;) {
5148     v = _Event;
5149     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;
5150   }
5151   guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
5152   if (v != 0) return OS_OK;
5153 
5154   // Do this the hard way by blocking ...
5155   // TODO: consider a brief spin here, gated on the success of recent
5156   // spin attempts by this thread.
5157   //
5158   // We decompose long timeouts into series of shorter timed waits.
5159   // Evidently large timo values passed in WaitForSingleObject() are problematic on some
5160   // versions of Windows.  See EventWait() for details.  This may be superstition.  Or not.
5161   // We trust the WAIT_TIMEOUT indication and don&#39;t track the elapsed wait time
5162   // with os::javaTimeNanos().  Furthermore, we assume that spurious returns from
5163   // ::WaitForSingleObject() caused by latent ::setEvent() operations will tend
5164   // to happen early in the wait interval.  Specifically, after a spurious wakeup (rv ==
5165   // WAIT_OBJECT_0 but _Event is still &lt; 0) we don&#39;t bother to recompute Millis to compensate
5166   // for the already waited time.  This policy does not admit any new outcomes.
5167   // In the future, however, we might want to track the accumulated wait time and
5168   // adjust Millis accordingly if we encounter a spurious wakeup.
5169 
5170   const int MAXTIMEOUT = 0x10000000;
5171   DWORD rv = WAIT_TIMEOUT;
5172   while (_Event &lt; 0 &amp;&amp; Millis &gt; 0) {
5173     DWORD prd = Millis;     // set prd = MAX (Millis, MAXTIMEOUT)
5174     if (Millis &gt; MAXTIMEOUT) {
5175       prd = MAXTIMEOUT;
5176     }
5177     HighResolutionInterval *phri = NULL;
5178     if (!ForceTimeHighResolution) {
5179       phri = new HighResolutionInterval(prd);
5180     }
5181     rv = ::WaitForSingleObject(_ParkHandle, prd);
5182     assert(rv == WAIT_OBJECT_0 || rv == WAIT_TIMEOUT, &quot;WaitForSingleObject failed&quot;);
5183     if (rv == WAIT_TIMEOUT) {
5184       Millis -= prd;
5185     }
5186     delete phri; // if it is NULL, harmless
5187   }
5188   v = _Event;
5189   _Event = 0;
5190   // see comment at end of os::PlatformEvent::park() below:
5191   OrderAccess::fence();
5192   // If we encounter a nearly simultanous timeout expiry and unpark()
5193   // we return OS_OK indicating we awoke via unpark().
5194   // Implementor&#39;s license -- returning OS_TIMEOUT would be equally valid, however.
5195   return (v &gt;= 0) ? OS_OK : OS_TIMEOUT;
5196 }
5197 
5198 void os::PlatformEvent::park() {
5199   // Transitions for _Event:
5200   //   -1 =&gt; -1 : illegal
5201   //    1 =&gt;  0 : pass - return immediately
5202   //    0 =&gt; -1 : block; then set _Event to 0 before returning
5203 
5204   guarantee(_ParkHandle != NULL, &quot;Invariant&quot;);
5205   // Invariant: Only the thread associated with the Event/PlatformEvent
5206   // may call park().
5207   // Consider: use atomic decrement instead of CAS-loop
5208   int v;
5209   for (;;) {
5210     v = _Event;
5211     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;
5212   }
5213   guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
5214   if (v != 0) return;
5215 
5216   // Do this the hard way by blocking ...
5217   // TODO: consider a brief spin here, gated on the success of recent
5218   // spin attempts by this thread.
5219   while (_Event &lt; 0) {
5220     DWORD rv = ::WaitForSingleObject(_ParkHandle, INFINITE);
5221     assert(rv == WAIT_OBJECT_0, &quot;WaitForSingleObject failed&quot;);
5222   }
5223 
5224   // Usually we&#39;ll find _Event == 0 at this point, but as
5225   // an optional optimization we clear it, just in case can
5226   // multiple unpark() operations drove _Event up to 1.
5227   _Event = 0;
5228   OrderAccess::fence();
5229   guarantee(_Event &gt;= 0, &quot;invariant&quot;);
5230 }
5231 
5232 void os::PlatformEvent::unpark() {
5233   guarantee(_ParkHandle != NULL, &quot;Invariant&quot;);
5234 
5235   // Transitions for _Event:
5236   //    0 =&gt; 1 : just return
5237   //    1 =&gt; 1 : just return
5238   //   -1 =&gt; either 0 or 1; must signal target thread
5239   //         That is, we can safely transition _Event from -1 to either
5240   //         0 or 1.
5241   // See also: &quot;Semaphores in Plan 9&quot; by Mullender &amp; Cox
5242   //
5243   // Note: Forcing a transition from &quot;-1&quot; to &quot;1&quot; on an unpark() means
5244   // that it will take two back-to-back park() calls for the owning
5245   // thread to block. This has the benefit of forcing a spurious return
5246   // from the first park() call after an unpark() call which will help
5247   // shake out uses of park() and unpark() without condition variables.
5248 
5249   if (Atomic::xchg(&amp;_Event, 1) &gt;= 0) return;
5250 
5251   ::SetEvent(_ParkHandle);
5252 }
5253 
5254 
5255 // JSR166
5256 // -------------------------------------------------------
5257 
5258 // The Windows implementation of Park is very straightforward: Basic
5259 // operations on Win32 Events turn out to have the right semantics to
5260 // use them directly. We opportunistically resuse the event inherited
5261 // from Monitor.
5262 
5263 void Parker::park(bool isAbsolute, jlong time) {
5264   guarantee(_ParkEvent != NULL, &quot;invariant&quot;);
5265   // First, demultiplex/decode time arguments
5266   if (time &lt; 0) { // don&#39;t wait
5267     return;
5268   } else if (time == 0 &amp;&amp; !isAbsolute) {
5269     time = INFINITE;
5270   } else if (isAbsolute) {
5271     time -= os::javaTimeMillis(); // convert to relative time
5272     if (time &lt;= 0) {  // already elapsed
5273       return;
5274     }
5275   } else { // relative
5276     time /= 1000000;  // Must coarsen from nanos to millis
5277     if (time == 0) {  // Wait for the minimal time unit if zero
5278       time = 1;
5279     }
5280   }
5281 
5282   JavaThread* thread = JavaThread::current();
5283 
5284   // Don&#39;t wait if interrupted or already triggered
5285   if (thread-&gt;is_interrupted(false) ||
5286       WaitForSingleObject(_ParkEvent, 0) == WAIT_OBJECT_0) {
5287     ResetEvent(_ParkEvent);
5288     return;
5289   } else {
5290     ThreadBlockInVM tbivm(thread);
5291     OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);
5292     thread-&gt;set_suspend_equivalent();
5293 
5294     WaitForSingleObject(_ParkEvent, time);
5295     ResetEvent(_ParkEvent);
5296 
5297     // If externally suspended while waiting, re-suspend
5298     if (thread-&gt;handle_special_suspend_equivalent_condition()) {
5299       thread-&gt;java_suspend_self();
5300     }
5301   }
5302 }
5303 
5304 void Parker::unpark() {
5305   guarantee(_ParkEvent != NULL, &quot;invariant&quot;);
5306   SetEvent(_ParkEvent);
5307 }
5308 
5309 // Platform Monitor implementation
5310 
5311 // Must already be locked
5312 int os::PlatformMonitor::wait(jlong millis) {
5313   assert(millis &gt;= 0, &quot;negative timeout&quot;);
5314   int ret = OS_TIMEOUT;
5315   int status = SleepConditionVariableCS(&amp;_cond, &amp;_mutex,
5316                                         millis == 0 ? INFINITE : millis);
5317   if (status != 0) {
5318     ret = OS_OK;
5319   }
5320   #ifndef PRODUCT
5321   else {
5322     DWORD err = GetLastError();
5323     assert(err == ERROR_TIMEOUT, &quot;SleepConditionVariableCS: %ld:&quot;, err);
5324   }
5325   #endif
5326   return ret;
5327 }
5328 
5329 // Run the specified command in a separate process. Return its exit value,
5330 // or -1 on failure (e.g. can&#39;t create a new process).
5331 int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {
5332   STARTUPINFO si;
5333   PROCESS_INFORMATION pi;
5334   DWORD exit_code;
5335 
5336   char * cmd_string;
5337   const char * cmd_prefix = &quot;cmd /C &quot;;
5338   size_t len = strlen(cmd) + strlen(cmd_prefix) + 1;
5339   cmd_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtInternal);
5340   if (cmd_string == NULL) {
5341     return -1;
5342   }
5343   cmd_string[0] = &#39;\0&#39;;
5344   strcat(cmd_string, cmd_prefix);
5345   strcat(cmd_string, cmd);
5346 
5347   // now replace all &#39;\n&#39; with &#39;&amp;&#39;
5348   char * substring = cmd_string;
5349   while ((substring = strchr(substring, &#39;\n&#39;)) != NULL) {
5350     substring[0] = &#39;&amp;&#39;;
5351     substring++;
5352   }
5353   memset(&amp;si, 0, sizeof(si));
5354   si.cb = sizeof(si);
5355   memset(&amp;pi, 0, sizeof(pi));
5356   BOOL rslt = CreateProcess(NULL,   // executable name - use command line
5357                             cmd_string,    // command line
5358                             NULL,   // process security attribute
5359                             NULL,   // thread security attribute
5360                             TRUE,   // inherits system handles
5361                             0,      // no creation flags
5362                             NULL,   // use parent&#39;s environment block
5363                             NULL,   // use parent&#39;s starting directory
5364                             &amp;si,    // (in) startup information
5365                             &amp;pi);   // (out) process information
5366 
5367   if (rslt) {
5368     // Wait until child process exits.
5369     WaitForSingleObject(pi.hProcess, INFINITE);
5370 
5371     GetExitCodeProcess(pi.hProcess, &amp;exit_code);
5372 
5373     // Close process and thread handles.
5374     CloseHandle(pi.hProcess);
5375     CloseHandle(pi.hThread);
5376   } else {
5377     exit_code = -1;
5378   }
5379 
5380   FREE_C_HEAP_ARRAY(char, cmd_string);
5381   return (int)exit_code;
5382 }
5383 
5384 bool os::find(address addr, outputStream* st) {
5385   int offset = -1;
5386   bool result = false;
5387   char buf[256];
5388   if (os::dll_address_to_library_name(addr, buf, sizeof(buf), &amp;offset)) {
5389     st-&gt;print(PTR_FORMAT &quot; &quot;, addr);
5390     if (strlen(buf) &lt; sizeof(buf) - 1) {
5391       char* p = strrchr(buf, &#39;\\&#39;);
5392       if (p) {
5393         st-&gt;print(&quot;%s&quot;, p + 1);
5394       } else {
5395         st-&gt;print(&quot;%s&quot;, buf);
5396       }
5397     } else {
5398         // The library name is probably truncated. Let&#39;s omit the library name.
5399         // See also JDK-8147512.
5400     }
5401     if (os::dll_address_to_function_name(addr, buf, sizeof(buf), &amp;offset)) {
5402       st-&gt;print(&quot;::%s + 0x%x&quot;, buf, offset);
5403     }
5404     st-&gt;cr();
5405     result = true;
5406   }
5407   return result;
5408 }
5409 
5410 static jint initSock() {
5411   WSADATA wsadata;
5412 
5413   if (WSAStartup(MAKEWORD(2,2), &amp;wsadata) != 0) {
5414     jio_fprintf(stderr, &quot;Could not initialize Winsock (error: %d)\n&quot;,
5415                 ::GetLastError());
5416     return JNI_ERR;
5417   }
5418   return JNI_OK;
5419 }
5420 
5421 struct hostent* os::get_host_by_name(char* name) {
5422   return (struct hostent*)gethostbyname(name);
5423 }
5424 
5425 int os::socket_close(int fd) {
5426   return ::closesocket(fd);
5427 }
5428 
5429 int os::socket(int domain, int type, int protocol) {
5430   return ::socket(domain, type, protocol);
5431 }
5432 
5433 int os::connect(int fd, struct sockaddr* him, socklen_t len) {
5434   return ::connect(fd, him, len);
5435 }
5436 
5437 int os::recv(int fd, char* buf, size_t nBytes, uint flags) {
5438   return ::recv(fd, buf, (int)nBytes, flags);
5439 }
5440 
5441 int os::send(int fd, char* buf, size_t nBytes, uint flags) {
5442   return ::send(fd, buf, (int)nBytes, flags);
5443 }
5444 
5445 int os::raw_send(int fd, char* buf, size_t nBytes, uint flags) {
5446   return ::send(fd, buf, (int)nBytes, flags);
5447 }
5448 
5449 // WINDOWS CONTEXT Flags for THREAD_SAMPLING
5450 #if defined(IA32)
5451   #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS)
5452 #elif defined (AMD64)
5453   #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
5454 #endif
5455 
5456 // returns true if thread could be suspended,
5457 // false otherwise
5458 static bool do_suspend(HANDLE* h) {
5459   if (h != NULL) {
5460     if (SuspendThread(*h) != ~0) {
5461       return true;
5462     }
5463   }
5464   return false;
5465 }
5466 
5467 // resume the thread
5468 // calling resume on an active thread is a no-op
5469 static void do_resume(HANDLE* h) {
5470   if (h != NULL) {
5471     ResumeThread(*h);
5472   }
5473 }
5474 
5475 // retrieve a suspend/resume context capable handle
5476 // from the tid. Caller validates handle return value.
5477 void get_thread_handle_for_extended_context(HANDLE* h,
5478                                             OSThread::thread_id_t tid) {
5479   if (h != NULL) {
5480     *h = OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, tid);
5481   }
5482 }
5483 
5484 // Thread sampling implementation
5485 //
5486 void os::SuspendedThreadTask::internal_do_task() {
5487   CONTEXT    ctxt;
5488   HANDLE     h = NULL;
5489 
5490   // get context capable handle for thread
5491   get_thread_handle_for_extended_context(&amp;h, _thread-&gt;osthread()-&gt;thread_id());
5492 
5493   // sanity
5494   if (h == NULL || h == INVALID_HANDLE_VALUE) {
5495     return;
5496   }
5497 
5498   // suspend the thread
5499   if (do_suspend(&amp;h)) {
5500     ctxt.ContextFlags = sampling_context_flags;
5501     // get thread context
5502     GetThreadContext(h, &amp;ctxt);
5503     SuspendedThreadTaskContext context(_thread, &amp;ctxt);
5504     // pass context to Thread Sampling impl
5505     do_task(context);
5506     // resume thread
5507     do_resume(&amp;h);
5508   }
5509 
5510   // close handle
5511   CloseHandle(h);
5512 }
5513 
5514 bool os::start_debugging(char *buf, int buflen) {
5515   int len = (int)strlen(buf);
5516   char *p = &amp;buf[len];
5517 
5518   jio_snprintf(p, buflen-len,
5519              &quot;\n\n&quot;
5520              &quot;Do you want to debug the problem?\n\n&quot;
5521              &quot;To debug, attach Visual Studio to process %d; then switch to thread 0x%x\n&quot;
5522              &quot;Select &#39;Yes&#39; to launch Visual Studio automatically (PATH must include msdev)\n&quot;
5523              &quot;Otherwise, select &#39;No&#39; to abort...&quot;,
5524              os::current_process_id(), os::current_thread_id());
5525 
5526   bool yes = os::message_box(&quot;Unexpected Error&quot;, buf);
5527 
5528   if (yes) {
5529     // os::breakpoint() calls DebugBreak(), which causes a breakpoint
5530     // exception. If VM is running inside a debugger, the debugger will
5531     // catch the exception. Otherwise, the breakpoint exception will reach
5532     // the default windows exception handler, which can spawn a debugger and
5533     // automatically attach to the dying VM.
5534     os::breakpoint();
5535     yes = false;
5536   }
5537   return yes;
5538 }
5539 
5540 void* os::get_default_process_handle() {
5541   return (void*)GetModuleHandle(NULL);
5542 }
5543 
5544 // Builds a platform dependent Agent_OnLoad_&lt;lib_name&gt; function name
5545 // which is used to find statically linked in agents.
5546 // Additionally for windows, takes into account __stdcall names.
5547 // Parameters:
5548 //            sym_name: Symbol in library we are looking for
5549 //            lib_name: Name of library to look in, NULL for shared libs.
5550 //            is_absolute_path == true if lib_name is absolute path to agent
5551 //                                     such as &quot;C:/a/b/L.dll&quot;
5552 //            == false if only the base name of the library is passed in
5553 //               such as &quot;L&quot;
5554 char* os::build_agent_function_name(const char *sym_name, const char *lib_name,
5555                                     bool is_absolute_path) {
5556   char *agent_entry_name;
5557   size_t len;
5558   size_t name_len;
5559   size_t prefix_len = strlen(JNI_LIB_PREFIX);
5560   size_t suffix_len = strlen(JNI_LIB_SUFFIX);
5561   const char *start;
5562 
5563   if (lib_name != NULL) {
5564     len = name_len = strlen(lib_name);
5565     if (is_absolute_path) {
5566       // Need to strip path, prefix and suffix
5567       if ((start = strrchr(lib_name, *os::file_separator())) != NULL) {
5568         lib_name = ++start;
5569       } else {
5570         // Need to check for drive prefix
5571         if ((start = strchr(lib_name, &#39;:&#39;)) != NULL) {
5572           lib_name = ++start;
5573         }
5574       }
5575       if (len &lt;= (prefix_len + suffix_len)) {
5576         return NULL;
5577       }
5578       lib_name += prefix_len;
5579       name_len = strlen(lib_name) - suffix_len;
5580     }
5581   }
5582   len = (lib_name != NULL ? name_len : 0) + strlen(sym_name) + 2;
5583   agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);
5584   if (agent_entry_name == NULL) {
5585     return NULL;
5586   }
5587   if (lib_name != NULL) {
5588     const char *p = strrchr(sym_name, &#39;@&#39;);
5589     if (p != NULL &amp;&amp; p != sym_name) {
5590       // sym_name == _Agent_OnLoad@XX
5591       strncpy(agent_entry_name, sym_name, (p - sym_name));
5592       agent_entry_name[(p-sym_name)] = &#39;\0&#39;;
5593       // agent_entry_name == _Agent_OnLoad
5594       strcat(agent_entry_name, &quot;_&quot;);
5595       strncat(agent_entry_name, lib_name, name_len);
5596       strcat(agent_entry_name, p);
5597       // agent_entry_name == _Agent_OnLoad_lib_name@XX
5598     } else {
5599       strcpy(agent_entry_name, sym_name);
5600       strcat(agent_entry_name, &quot;_&quot;);
5601       strncat(agent_entry_name, lib_name, name_len);
5602     }
5603   } else {
5604     strcpy(agent_entry_name, sym_name);
5605   }
5606   return agent_entry_name;
5607 }
5608 
5609 #ifndef PRODUCT
5610 
5611 // test the code path in reserve_memory_special() that tries to allocate memory in a single
5612 // contiguous memory block at a particular address.
5613 // The test first tries to find a good approximate address to allocate at by using the same
5614 // method to allocate some memory at any address. The test then tries to allocate memory in
5615 // the vicinity (not directly after it to avoid possible by-chance use of that location)
5616 // This is of course only some dodgy assumption, there is no guarantee that the vicinity of
5617 // the previously allocated memory is available for allocation. The only actual failure
5618 // that is reported is when the test tries to allocate at a particular location but gets a
5619 // different valid one. A NULL return value at this point is not considered an error but may
5620 // be legitimate.
5621 void TestReserveMemorySpecial_test() {
5622   if (!UseLargePages) {
5623     return;
5624   }
5625   // save current value of globals
5626   bool old_use_large_pages_individual_allocation = UseLargePagesIndividualAllocation;
5627   bool old_use_numa_interleaving = UseNUMAInterleaving;
5628 
5629   // set globals to make sure we hit the correct code path
5630   UseLargePagesIndividualAllocation = UseNUMAInterleaving = false;
5631 
5632   // do an allocation at an address selected by the OS to get a good one.
5633   const size_t large_allocation_size = os::large_page_size() * 4;
5634   char* result = os::reserve_memory_special(large_allocation_size, os::large_page_size(), NULL, false);
5635   if (result == NULL) {
5636   } else {
5637     os::release_memory_special(result, large_allocation_size);
5638 
5639     // allocate another page within the recently allocated memory area which seems to be a good location. At least
5640     // we managed to get it once.
5641     const size_t expected_allocation_size = os::large_page_size();
5642     char* expected_location = result + os::large_page_size();
5643     char* actual_location = os::reserve_memory_special(expected_allocation_size, os::large_page_size(), expected_location, false);
5644     if (actual_location == NULL) {
5645     } else {
5646       // release memory
5647       os::release_memory_special(actual_location, expected_allocation_size);
5648       // only now check, after releasing any memory to avoid any leaks.
5649       assert(actual_location == expected_location,
5650              &quot;Failed to allocate memory at requested location &quot; PTR_FORMAT &quot; of size &quot; SIZE_FORMAT &quot;, is &quot; PTR_FORMAT &quot; instead&quot;,
5651              expected_location, expected_allocation_size, actual_location);
5652     }
5653   }
5654 
5655   // restore globals
5656   UseLargePagesIndividualAllocation = old_use_large_pages_individual_allocation;
5657   UseNUMAInterleaving = old_use_numa_interleaving;
5658 }
5659 #endif // PRODUCT
5660 
5661 /*
5662   All the defined signal names for Windows.
5663 
5664   NOTE that not all of these names are accepted by FindSignal!
5665 
5666   For various reasons some of these may be rejected at runtime.
5667 
5668   Here are the names currently accepted by a user of sun.misc.Signal with
5669   1.4.1 (ignoring potential interaction with use of chaining, etc):
5670 
5671      (LIST TBD)
5672 
5673 */
5674 int os::get_signal_number(const char* name) {
5675   static const struct {
5676     const char* name;
5677     int         number;
5678   } siglabels [] =
5679     // derived from version 6.0 VC98/include/signal.h
5680   {&quot;ABRT&quot;,      SIGABRT,        // abnormal termination triggered by abort cl
5681   &quot;FPE&quot;,        SIGFPE,         // floating point exception
5682   &quot;SEGV&quot;,       SIGSEGV,        // segment violation
5683   &quot;INT&quot;,        SIGINT,         // interrupt
5684   &quot;TERM&quot;,       SIGTERM,        // software term signal from kill
5685   &quot;BREAK&quot;,      SIGBREAK,       // Ctrl-Break sequence
5686   &quot;ILL&quot;,        SIGILL};        // illegal instruction
5687   for (unsigned i = 0; i &lt; ARRAY_SIZE(siglabels); ++i) {
5688     if (strcmp(name, siglabels[i].name) == 0) {
5689       return siglabels[i].number;
5690     }
5691   }
5692   return -1;
5693 }
5694 
5695 // Fast current thread access
5696 
5697 int os::win32::_thread_ptr_offset = 0;
5698 
5699 static void call_wrapper_dummy() {}
5700 
5701 // We need to call the os_exception_wrapper once so that it sets
5702 // up the offset from FS of the thread pointer.
5703 void os::win32::initialize_thread_ptr_offset() {
5704   os::os_exception_wrapper((java_call_t)call_wrapper_dummy,
5705                            NULL, methodHandle(), NULL, NULL);
5706 }
5707 
5708 bool os::supports_map_sync() {
5709   return false;
5710 }
    </pre>
  </body>
</html>
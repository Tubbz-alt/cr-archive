<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../code/dependencies.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2439     }
2440   }
2441 
2442   assert(spe != NULL &amp;&amp; spe-&gt;method() != NULL, &quot;&quot;);
2443   assert(Arguments::is_interpreter_only() || (spe-&gt;method()-&gt;has_compiled_code() &amp;&amp;
2444          spe-&gt;method()-&gt;code()-&gt;entry_point() == spe-&gt;method()-&gt;from_compiled_entry()),
2445          &quot;MH intrinsic invariant&quot;);
2446   return spe-&gt;method();
2447 }
2448 
2449 // Helper for unpacking the return value from linkMethod and linkCallSite.
2450 static Method* unpack_method_and_appendix(Handle mname,
2451                                           Klass* accessing_klass,
2452                                           objArrayHandle appendix_box,
2453                                           Handle* appendix_result,
2454                                           TRAPS) {
2455   if (mname.not_null()) {
2456     Method* m = java_lang_invoke_MemberName::vmtarget(mname());
2457     if (m != NULL) {
2458       oop appendix = appendix_box-&gt;obj_at(0);
<span class="line-modified">2459       if (TraceMethodHandles) {</span>
<span class="line-modified">2460     #ifndef PRODUCT</span>
<span class="line-modified">2461         ttyLocker ttyl;</span>
<span class="line-modified">2462         tty-&gt;print(&quot;Linked method=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(m));</span>
<span class="line-modified">2463         m-&gt;print();</span>
<span class="line-modified">2464         if (appendix != NULL) { tty-&gt;print(&quot;appendix = &quot;); appendix-&gt;print(); }</span>
<span class="line-modified">2465         tty-&gt;cr();</span>
<span class="line-modified">2466     #endif //PRODUCT</span>
2467       }

2468       (*appendix_result) = Handle(THREAD, appendix);
2469       // the target is stored in the cpCache and if a reference to this
2470       // MemberName is dropped we need a way to make sure the
2471       // class_loader containing this method is kept alive.
2472       methodHandle mh(THREAD, m); // record_dependency can safepoint.
2473       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2474       this_key-&gt;record_dependency(m-&gt;method_holder());
2475       return mh();
2476     }
2477   }
2478   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);
2479 }
2480 
2481 Method* SystemDictionary::find_method_handle_invoker(Klass* klass,
2482                                                      Symbol* name,
2483                                                      Symbol* signature,
2484                                                           Klass* accessing_klass,
2485                                                           Handle *appendix_result,
2486                                                           TRAPS) {
2487   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
</pre>
</td>
<td>
<hr />
<pre>
2439     }
2440   }
2441 
2442   assert(spe != NULL &amp;&amp; spe-&gt;method() != NULL, &quot;&quot;);
2443   assert(Arguments::is_interpreter_only() || (spe-&gt;method()-&gt;has_compiled_code() &amp;&amp;
2444          spe-&gt;method()-&gt;code()-&gt;entry_point() == spe-&gt;method()-&gt;from_compiled_entry()),
2445          &quot;MH intrinsic invariant&quot;);
2446   return spe-&gt;method();
2447 }
2448 
2449 // Helper for unpacking the return value from linkMethod and linkCallSite.
2450 static Method* unpack_method_and_appendix(Handle mname,
2451                                           Klass* accessing_klass,
2452                                           objArrayHandle appendix_box,
2453                                           Handle* appendix_result,
2454                                           TRAPS) {
2455   if (mname.not_null()) {
2456     Method* m = java_lang_invoke_MemberName::vmtarget(mname());
2457     if (m != NULL) {
2458       oop appendix = appendix_box-&gt;obj_at(0);
<span class="line-modified">2459       LogTarget(Info, methodhandles) lt;</span>
<span class="line-modified">2460       if (lt.develop_is_enabled()) {</span>
<span class="line-modified">2461         ResourceMark rm(THREAD);</span>
<span class="line-modified">2462         LogStream ls(lt);</span>
<span class="line-modified">2463         ls.print(&quot;Linked method=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(m));</span>
<span class="line-modified">2464         m-&gt;print_on(&amp;ls);</span>
<span class="line-modified">2465         if (appendix != NULL) { ls.print(&quot;appendix = &quot;); appendix-&gt;print_on(&amp;ls); }</span>
<span class="line-modified">2466         ls.cr();</span>
2467       }
<span class="line-added">2468 </span>
2469       (*appendix_result) = Handle(THREAD, appendix);
2470       // the target is stored in the cpCache and if a reference to this
2471       // MemberName is dropped we need a way to make sure the
2472       // class_loader containing this method is kept alive.
2473       methodHandle mh(THREAD, m); // record_dependency can safepoint.
2474       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2475       this_key-&gt;record_dependency(m-&gt;method_holder());
2476       return mh();
2477     }
2478   }
2479   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);
2480 }
2481 
2482 Method* SystemDictionary::find_method_handle_invoker(Klass* klass,
2483                                                      Symbol* name,
2484                                                      Symbol* signature,
2485                                                           Klass* accessing_klass,
2486                                                           Handle *appendix_result,
2487                                                           TRAPS) {
2488   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../code/dependencies.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/cpCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constantPool.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/cpCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/resolutionErrors.hpp&quot;
 27 #include &quot;interpreter/bytecodeStream.hpp&quot;
 28 #include &quot;interpreter/bytecodes.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;interpreter/linkResolver.hpp&quot;
 31 #include &quot;interpreter/rewriter.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;

 33 #include &quot;memory/heapShared.hpp&quot;
 34 #include &quot;memory/metadataFactory.hpp&quot;
 35 #include &quot;memory/metaspaceClosure.hpp&quot;
 36 #include &quot;memory/metaspaceShared.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;
 38 #include &quot;oops/access.inline.hpp&quot;
 39 #include &quot;oops/compressedOops.hpp&quot;
 40 #include &quot;oops/constantPool.inline.hpp&quot;
 41 #include &quot;oops/cpCache.inline.hpp&quot;
 42 #include &quot;oops/objArrayOop.inline.hpp&quot;
 43 #include &quot;oops/oop.inline.hpp&quot;
 44 #include &quot;prims/methodHandles.hpp&quot;
 45 #include &quot;runtime/atomic.hpp&quot;
 46 #include &quot;runtime/handles.inline.hpp&quot;
 47 #include &quot;utilities/macros.hpp&quot;
 48 
 49 // Implementation of ConstantPoolCacheEntry
 50 
 51 void ConstantPoolCacheEntry::initialize_entry(int index) {
 52   assert(0 &lt; index &amp;&amp; index &lt; 0x10000, &quot;sanity check&quot;);
</pre>
<hr />
<pre>
395     guarantee(index &gt;= 0, &quot;Didn&#39;t find cpCache entry!&quot;);
396     int encoded_index = ResolutionErrorTable::encode_cpcache_index(
397                           ConstantPool::encode_invokedynamic_index(index));
398     Thread* THREAD = Thread::current();
399     ConstantPool::throw_resolution_error(cpool, encoded_index, THREAD);
400     return;
401   }
402 
403   Method* adapter            = call_info.resolved_method();
404   const Handle appendix      = call_info.resolved_appendix();
405   const bool has_appendix    = appendix.not_null();
406 
407   // Write the flags.
408   // MHs and indy are always sig-poly and have a local signature.
409   set_method_flags(as_TosState(adapter-&gt;result_type()),
410                    ((has_appendix    ? 1 : 0) &lt;&lt; has_appendix_shift        ) |
411                    (                   1      &lt;&lt; has_local_signature_shift ) |
412                    (                   1      &lt;&lt; is_final_shift            ),
413                    adapter-&gt;size_of_parameters());
414 
<span class="line-modified">415   if (TraceInvokeDynamic) {</span>
<span class="line-modified">416     ttyLocker ttyl;</span>
<span class="line-modified">417     tty-&gt;print_cr(&quot;set_method_handle bc=%d appendix=&quot; PTR_FORMAT &quot;%s method=&quot; PTR_FORMAT &quot; (local signature) &quot;,</span>
<span class="line-modified">418                   invoke_code,</span>
<span class="line-modified">419                   p2i(appendix()),</span>
<span class="line-modified">420                   (has_appendix ? &quot;&quot; : &quot; (unused)&quot;),</span>
<span class="line-modified">421                   p2i(adapter));</span>
<span class="line-modified">422     adapter-&gt;print();</span>
<span class="line-modified">423     if (has_appendix)  appendix()-&gt;print();</span>



424   }
425 
426   // Method handle invokes and invokedynamic sites use both cp cache words.
427   // refs[f2], if not null, contains a value passed as a trailing argument to the adapter.
428   // In the general case, this could be the call site&#39;s MethodType,
429   // for use with java.lang.Invokers.checkExactType, or else a CallSite object.
430   // f1 contains the adapter method which manages the actual call.
431   // In the general case, this is a compiled LambdaForm.
432   // (The Java code is free to optimize these calls by binding other
433   // sorts of methods and appendices to call sites.)
434   // JVM-level linking is via f1, as if for invokespecial, and signatures are erased.
435   // The appendix argument (if any) is added to the signature, and is counted in the parameter_size bits.
436   // Even with the appendix, the method will never take more than 255 parameter slots.
437   //
438   // This means that given a call site like (List)mh.invoke(&quot;foo&quot;),
439   // the f1 method has signature &#39;(Ljl/Object;Ljl/invoke/MethodType;)Ljl/Object;&#39;,
440   // not &#39;(Ljava/lang/String;)Ljava/util/List;&#39;.
441   // The fact that String and List are involved is encoded in the MethodType in refs[f2].
442   // This allows us to create fewer Methods, while keeping type safety.
443   //
444 
445   // Store appendix, if any.
446   if (has_appendix) {
447     const int appendix_index = f2_as_index();
448     assert(appendix_index &gt;= 0 &amp;&amp; appendix_index &lt; resolved_references-&gt;length(), &quot;oob&quot;);
449     assert(resolved_references-&gt;obj_at(appendix_index) == NULL, &quot;init just once&quot;);
450     resolved_references-&gt;obj_at_put(appendix_index, appendix());
451   }
452 
453   release_set_f1(adapter);  // This must be the last one to set (see NOTE above)!
454 
455   // The interpreter assembly code does not check byte_2,
456   // but it is used by is_resolved, method_if_resolved, etc.
457   set_bytecode_1(invoke_code);
458   NOT_PRODUCT(verify(tty));
<span class="line-modified">459   if (TraceInvokeDynamic) {</span>
<span class="line-modified">460     ttyLocker ttyl;</span>
<span class="line-modified">461     this-&gt;print(tty, 0);</span>
462   }
463 
464   assert(has_appendix == this-&gt;has_appendix(), &quot;proper storage of appendix flag&quot;);
465   assert(this-&gt;has_local_signature(), &quot;proper storage of signature flag&quot;);
466 }
467 
468 bool ConstantPoolCacheEntry::save_and_throw_indy_exc(
469   const constantPoolHandle&amp; cpool, int cpool_index, int index, constantTag tag, TRAPS) {
470 
471   assert(HAS_PENDING_EXCEPTION, &quot;No exception got thrown!&quot;);
472   assert(PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass()),
473          &quot;No LinkageError exception&quot;);
474 
475   // Use the resolved_references() lock for this cpCache entry.
476   // resolved_references are created for all classes with Invokedynamic, MethodHandle
477   // or MethodType constant pool cache entries.
478   objArrayHandle resolved_references(Thread::current(), cpool-&gt;resolved_references());
479   assert(resolved_references() != NULL,
480          &quot;a resolved_references array should have been created for this class&quot;);
481   ObjectLocker ol(resolved_references, THREAD);
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/resolutionErrors.hpp&quot;
 27 #include &quot;interpreter/bytecodeStream.hpp&quot;
 28 #include &quot;interpreter/bytecodes.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;interpreter/linkResolver.hpp&quot;
 31 #include &quot;interpreter/rewriter.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;
<span class="line-added"> 33 #include &quot;logging/logStream.hpp&quot;</span>
 34 #include &quot;memory/heapShared.hpp&quot;
 35 #include &quot;memory/metadataFactory.hpp&quot;
 36 #include &quot;memory/metaspaceClosure.hpp&quot;
 37 #include &quot;memory/metaspaceShared.hpp&quot;
 38 #include &quot;memory/resourceArea.hpp&quot;
 39 #include &quot;oops/access.inline.hpp&quot;
 40 #include &quot;oops/compressedOops.hpp&quot;
 41 #include &quot;oops/constantPool.inline.hpp&quot;
 42 #include &quot;oops/cpCache.inline.hpp&quot;
 43 #include &quot;oops/objArrayOop.inline.hpp&quot;
 44 #include &quot;oops/oop.inline.hpp&quot;
 45 #include &quot;prims/methodHandles.hpp&quot;
 46 #include &quot;runtime/atomic.hpp&quot;
 47 #include &quot;runtime/handles.inline.hpp&quot;
 48 #include &quot;utilities/macros.hpp&quot;
 49 
 50 // Implementation of ConstantPoolCacheEntry
 51 
 52 void ConstantPoolCacheEntry::initialize_entry(int index) {
 53   assert(0 &lt; index &amp;&amp; index &lt; 0x10000, &quot;sanity check&quot;);
</pre>
<hr />
<pre>
396     guarantee(index &gt;= 0, &quot;Didn&#39;t find cpCache entry!&quot;);
397     int encoded_index = ResolutionErrorTable::encode_cpcache_index(
398                           ConstantPool::encode_invokedynamic_index(index));
399     Thread* THREAD = Thread::current();
400     ConstantPool::throw_resolution_error(cpool, encoded_index, THREAD);
401     return;
402   }
403 
404   Method* adapter            = call_info.resolved_method();
405   const Handle appendix      = call_info.resolved_appendix();
406   const bool has_appendix    = appendix.not_null();
407 
408   // Write the flags.
409   // MHs and indy are always sig-poly and have a local signature.
410   set_method_flags(as_TosState(adapter-&gt;result_type()),
411                    ((has_appendix    ? 1 : 0) &lt;&lt; has_appendix_shift        ) |
412                    (                   1      &lt;&lt; has_local_signature_shift ) |
413                    (                   1      &lt;&lt; is_final_shift            ),
414                    adapter-&gt;size_of_parameters());
415 
<span class="line-modified">416   LogStream* log_stream = NULL;</span>
<span class="line-modified">417   LogStreamHandle(Debug, methodhandles, indy) lsh_indy;</span>
<span class="line-modified">418   if (lsh_indy.is_enabled()) {</span>
<span class="line-modified">419     ResourceMark rm;</span>
<span class="line-modified">420     log_stream = &amp;lsh_indy;</span>
<span class="line-modified">421     log_stream-&gt;print_cr(&quot;set_method_handle bc=%d appendix=&quot; PTR_FORMAT &quot;%s method=&quot; PTR_FORMAT &quot; (local signature) &quot;,</span>
<span class="line-modified">422                          invoke_code,</span>
<span class="line-modified">423                          p2i(appendix()),</span>
<span class="line-modified">424                          (has_appendix ? &quot;&quot; : &quot; (unused)&quot;),</span>
<span class="line-added">425                          p2i(adapter));</span>
<span class="line-added">426     adapter-&gt;print_on(log_stream);</span>
<span class="line-added">427     if (has_appendix)  appendix()-&gt;print_on(log_stream);</span>
428   }
429 
430   // Method handle invokes and invokedynamic sites use both cp cache words.
431   // refs[f2], if not null, contains a value passed as a trailing argument to the adapter.
432   // In the general case, this could be the call site&#39;s MethodType,
433   // for use with java.lang.Invokers.checkExactType, or else a CallSite object.
434   // f1 contains the adapter method which manages the actual call.
435   // In the general case, this is a compiled LambdaForm.
436   // (The Java code is free to optimize these calls by binding other
437   // sorts of methods and appendices to call sites.)
438   // JVM-level linking is via f1, as if for invokespecial, and signatures are erased.
439   // The appendix argument (if any) is added to the signature, and is counted in the parameter_size bits.
440   // Even with the appendix, the method will never take more than 255 parameter slots.
441   //
442   // This means that given a call site like (List)mh.invoke(&quot;foo&quot;),
443   // the f1 method has signature &#39;(Ljl/Object;Ljl/invoke/MethodType;)Ljl/Object;&#39;,
444   // not &#39;(Ljava/lang/String;)Ljava/util/List;&#39;.
445   // The fact that String and List are involved is encoded in the MethodType in refs[f2].
446   // This allows us to create fewer Methods, while keeping type safety.
447   //
448 
449   // Store appendix, if any.
450   if (has_appendix) {
451     const int appendix_index = f2_as_index();
452     assert(appendix_index &gt;= 0 &amp;&amp; appendix_index &lt; resolved_references-&gt;length(), &quot;oob&quot;);
453     assert(resolved_references-&gt;obj_at(appendix_index) == NULL, &quot;init just once&quot;);
454     resolved_references-&gt;obj_at_put(appendix_index, appendix());
455   }
456 
457   release_set_f1(adapter);  // This must be the last one to set (see NOTE above)!
458 
459   // The interpreter assembly code does not check byte_2,
460   // but it is used by is_resolved, method_if_resolved, etc.
461   set_bytecode_1(invoke_code);
462   NOT_PRODUCT(verify(tty));
<span class="line-modified">463 </span>
<span class="line-modified">464   if (log_stream != NULL) {</span>
<span class="line-modified">465     this-&gt;print(log_stream, 0);</span>
466   }
467 
468   assert(has_appendix == this-&gt;has_appendix(), &quot;proper storage of appendix flag&quot;);
469   assert(this-&gt;has_local_signature(), &quot;proper storage of signature flag&quot;);
470 }
471 
472 bool ConstantPoolCacheEntry::save_and_throw_indy_exc(
473   const constantPoolHandle&amp; cpool, int cpool_index, int index, constantTag tag, TRAPS) {
474 
475   assert(HAS_PENDING_EXCEPTION, &quot;No exception got thrown!&quot;);
476   assert(PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass()),
477          &quot;No LinkageError exception&quot;);
478 
479   // Use the resolved_references() lock for this cpCache entry.
480   // resolved_references are created for all classes with Invokedynamic, MethodHandle
481   // or MethodType constant pool cache entries.
482   objArrayHandle resolved_references(Thread::current(), cpool-&gt;resolved_references());
483   assert(resolved_references() != NULL,
484          &quot;a resolved_references array should have been created for this class&quot;);
485   ObjectLocker ol(resolved_references, THREAD);
</pre>
</td>
</tr>
</table>
<center><a href="constantPool.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
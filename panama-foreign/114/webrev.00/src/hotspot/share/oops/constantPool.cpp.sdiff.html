<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/constantPool.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../logging/logTag.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/constantPool.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;


  35 #include &quot;memory/allocation.inline.hpp&quot;
  36 #include &quot;memory/heapShared.hpp&quot;
  37 #include &quot;memory/metadataFactory.hpp&quot;
  38 #include &quot;memory/metaspaceClosure.hpp&quot;
  39 #include &quot;memory/metaspaceShared.hpp&quot;
  40 #include &quot;memory/oopFactory.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;memory/universe.hpp&quot;
  43 #include &quot;oops/array.hpp&quot;
  44 #include &quot;oops/constantPool.inline.hpp&quot;
  45 #include &quot;oops/cpCache.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
  47 #include &quot;oops/objArrayKlass.hpp&quot;
  48 #include &quot;oops/objArrayOop.inline.hpp&quot;
  49 #include &quot;oops/oop.inline.hpp&quot;
  50 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  51 #include &quot;runtime/atomic.hpp&quot;
  52 #include &quot;runtime/handles.inline.hpp&quot;
  53 #include &quot;runtime/init.hpp&quot;
  54 #include &quot;runtime/javaCalls.hpp&quot;
</pre>
<hr />
<pre>
 924       break;
 925     }
 926 
 927   case JVM_CONSTANT_Dynamic:
 928     {
 929       // Resolve the Dynamically-Computed constant to invoke the BSM in order to obtain the resulting oop.
 930       BootstrapInfo bootstrap_specifier(this_cp, index);
 931 
 932       // The initial step in resolving an unresolved symbolic reference to a
 933       // dynamically-computed constant is to resolve the symbolic reference to a
 934       // method handle which will be the bootstrap method for the dynamically-computed
 935       // constant. If resolution of the java.lang.invoke.MethodHandle for the bootstrap
 936       // method fails, then a MethodHandleInError is stored at the corresponding
 937       // bootstrap method&#39;s CP index for the CONSTANT_MethodHandle_info. No need to
 938       // set a DynamicConstantInError here since any subsequent use of this
 939       // bootstrap method will encounter the resolution of MethodHandleInError.
 940       // Both the first, (resolution of the BSM and its static arguments), and the second tasks,
 941       // (invocation of the BSM), of JVMS Section 5.4.3.6 occur within invoke_bootstrap_method()
 942       // for the bootstrap_specifier created above.
 943       SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
<span class="line-modified"> 944       Exceptions::wrap_dynamic_exception(THREAD);</span>
 945       if (HAS_PENDING_EXCEPTION) {
 946         // Resolution failure of the dynamically-computed constant, save_and_throw_exception
 947         // will check for a LinkageError and store a DynamicConstantInError.
 948         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
 949       }
 950       result_oop = bootstrap_specifier.resolved_value()();
 951       BasicType type = Signature::basic_type(bootstrap_specifier.signature());
 952       if (!is_reference_type(type)) {
 953         // Make sure the primitive value is properly boxed.
 954         // This is a JDK responsibility.
 955         const char* fail = NULL;
 956         if (result_oop == NULL) {
 957           fail = &quot;null result instead of box&quot;;
 958         } else if (!is_java_primitive(type)) {
 959           // FIXME: support value types via unboxing
 960           fail = &quot;can only handle references and primitives&quot;;
 961         } else if (!java_lang_boxing_object::is_instance(result_oop, type)) {
 962           fail = &quot;primitive is not properly boxed&quot;;
 963         }
 964         if (fail != NULL) {
 965           // Since this exception is not a LinkageError, throw exception
 966           // but do not save a DynamicInError resolution result.
 967           // See section 5.4.3 of the VM spec.
 968           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), fail);
 969         }
 970       }
 971 
<span class="line-modified"> 972       if (TraceMethodHandles) {</span>
<span class="line-modified"> 973         bootstrap_specifier.print_msg_on(tty, &quot;resolve_constant_at_impl&quot;);</span>


 974       }
 975       break;
 976     }
 977 
 978   case JVM_CONSTANT_String:
 979     assert(cache_index != _no_index_sentinel, &quot;should have been set&quot;);
 980     if (this_cp-&gt;is_pseudo_string_at(index)) {
 981       result_oop = this_cp-&gt;pseudo_string_at(index, cache_index);
 982       break;
 983     }
 984     result_oop = string_at_impl(this_cp, index, cache_index, CHECK_NULL);
 985     break;
 986 
 987   case JVM_CONSTANT_DynamicInError:
 988   case JVM_CONSTANT_MethodHandleInError:
 989   case JVM_CONSTANT_MethodTypeInError:
 990     {
 991       throw_resolution_error(this_cp, index, CHECK_NULL);
 992       break;
 993     }
</pre>
</td>
<td>
<hr />
<pre>
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
<span class="line-added">  35 #include &quot;logging/log.hpp&quot;</span>
<span class="line-added">  36 #include &quot;logging/logStream.hpp&quot;</span>
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/heapShared.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceClosure.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/array.hpp&quot;
  46 #include &quot;oops/constantPool.inline.hpp&quot;
  47 #include &quot;oops/cpCache.inline.hpp&quot;
  48 #include &quot;oops/instanceKlass.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  53 #include &quot;runtime/atomic.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/init.hpp&quot;
  56 #include &quot;runtime/javaCalls.hpp&quot;
</pre>
<hr />
<pre>
 926       break;
 927     }
 928 
 929   case JVM_CONSTANT_Dynamic:
 930     {
 931       // Resolve the Dynamically-Computed constant to invoke the BSM in order to obtain the resulting oop.
 932       BootstrapInfo bootstrap_specifier(this_cp, index);
 933 
 934       // The initial step in resolving an unresolved symbolic reference to a
 935       // dynamically-computed constant is to resolve the symbolic reference to a
 936       // method handle which will be the bootstrap method for the dynamically-computed
 937       // constant. If resolution of the java.lang.invoke.MethodHandle for the bootstrap
 938       // method fails, then a MethodHandleInError is stored at the corresponding
 939       // bootstrap method&#39;s CP index for the CONSTANT_MethodHandle_info. No need to
 940       // set a DynamicConstantInError here since any subsequent use of this
 941       // bootstrap method will encounter the resolution of MethodHandleInError.
 942       // Both the first, (resolution of the BSM and its static arguments), and the second tasks,
 943       // (invocation of the BSM), of JVMS Section 5.4.3.6 occur within invoke_bootstrap_method()
 944       // for the bootstrap_specifier created above.
 945       SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
<span class="line-modified"> 946       Exceptions::wrap_dynamic_exception(/* is_indy */ false, THREAD);</span>
 947       if (HAS_PENDING_EXCEPTION) {
 948         // Resolution failure of the dynamically-computed constant, save_and_throw_exception
 949         // will check for a LinkageError and store a DynamicConstantInError.
 950         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
 951       }
 952       result_oop = bootstrap_specifier.resolved_value()();
 953       BasicType type = Signature::basic_type(bootstrap_specifier.signature());
 954       if (!is_reference_type(type)) {
 955         // Make sure the primitive value is properly boxed.
 956         // This is a JDK responsibility.
 957         const char* fail = NULL;
 958         if (result_oop == NULL) {
 959           fail = &quot;null result instead of box&quot;;
 960         } else if (!is_java_primitive(type)) {
 961           // FIXME: support value types via unboxing
 962           fail = &quot;can only handle references and primitives&quot;;
 963         } else if (!java_lang_boxing_object::is_instance(result_oop, type)) {
 964           fail = &quot;primitive is not properly boxed&quot;;
 965         }
 966         if (fail != NULL) {
 967           // Since this exception is not a LinkageError, throw exception
 968           // but do not save a DynamicInError resolution result.
 969           // See section 5.4.3 of the VM spec.
 970           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), fail);
 971         }
 972       }
 973 
<span class="line-modified"> 974       LogTarget(Debug, methodhandles, condy) lt_condy;</span>
<span class="line-modified"> 975       if (lt_condy.is_enabled()) {</span>
<span class="line-added"> 976         LogStream ls(lt_condy);</span>
<span class="line-added"> 977         bootstrap_specifier.print_msg_on(&amp;ls, &quot;resolve_constant_at_impl&quot;);</span>
 978       }
 979       break;
 980     }
 981 
 982   case JVM_CONSTANT_String:
 983     assert(cache_index != _no_index_sentinel, &quot;should have been set&quot;);
 984     if (this_cp-&gt;is_pseudo_string_at(index)) {
 985       result_oop = this_cp-&gt;pseudo_string_at(index, cache_index);
 986       break;
 987     }
 988     result_oop = string_at_impl(this_cp, index, cache_index, CHECK_NULL);
 989     break;
 990 
 991   case JVM_CONSTANT_DynamicInError:
 992   case JVM_CONSTANT_MethodHandleInError:
 993   case JVM_CONSTANT_MethodTypeInError:
 994     {
 995       throw_resolution_error(this_cp, index, CHECK_NULL);
 996       break;
 997     }
</pre>
</td>
</tr>
</table>
<center><a href="../logging/logTag.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
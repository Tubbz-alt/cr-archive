<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/sharedRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="mutexLocker.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2055     // Shouldn&#39;t happen, but don&#39;t cause even more problems if it does
2056     message = const_cast&lt;char*&gt;(caster_klass-&gt;external_name());
2057   } else {
2058     jio_snprintf(message,
2059                  msglen,
2060                  &quot;class %s cannot be cast to class %s (%s%s%s)&quot;,
2061                  caster_name,
2062                  target_name,
2063                  caster_klass_description,
2064                  klass_separator,
2065                  target_klass_description
2066                  );
2067   }
2068   return message;
2069 }
2070 
2071 JRT_LEAF(void, SharedRuntime::reguard_yellow_pages())
2072   (void) JavaThread::current()-&gt;reguard_stack();
2073 JRT_END
2074 
<span class="line-modified">2075 </span>
<span class="line-removed">2076 // Handles the uncommon case in locking, i.e., contention or an inflated lock.</span>
<span class="line-removed">2077 JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C(oopDesc* _obj, BasicLock* lock, JavaThread* thread))</span>
2078   if (!SafepointSynchronize::is_synchronizing()) {
2079     // Only try quick_enter() if we&#39;re not trying to reach a safepoint
2080     // so that the calling thread reaches the safepoint more quickly.
<span class="line-modified">2081     if (ObjectSynchronizer::quick_enter(_obj, thread, lock)) return;</span>
2082   }
2083   // NO_ASYNC required because an async exception on the state transition destructor
2084   // would leave you with the lock held and it would never be released.
2085   // The normal monitorenter NullPointerException is thrown without acquiring a lock
2086   // and the model is that an exception implies the method failed.
2087   JRT_BLOCK_NO_ASYNC
<span class="line-removed">2088   oop obj(_obj);</span>
2089   if (PrintBiasedLockingStatistics) {
2090     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
2091   }
2092   Handle h_obj(THREAD, obj);
2093   ObjectSynchronizer::enter(h_obj, lock, CHECK);
2094   assert(!HAS_PENDING_EXCEPTION, &quot;Should have no exception here&quot;);
2095   JRT_BLOCK_END
<span class="line-modified">2096 JRT_END</span>
2097 
<span class="line-modified">2098 // Handles the uncommon cases of monitor unlocking in compiled code</span>
<span class="line-modified">2099 JRT_LEAF(void, SharedRuntime::complete_monitor_unlocking_C(oopDesc* _obj, BasicLock* lock, JavaThread * THREAD))</span>
<span class="line-modified">2100    oop obj(_obj);</span>
<span class="line-modified">2101   assert(JavaThread::current() == THREAD, &quot;invariant&quot;);</span>
<span class="line-removed">2102   // I&#39;m not convinced we need the code contained by MIGHT_HAVE_PENDING anymore</span>
<span class="line-removed">2103   // testing was unable to ever fire the assert that guarded it so I have removed it.</span>
<span class="line-removed">2104   assert(!HAS_PENDING_EXCEPTION, &quot;Do we need code below anymore?&quot;);</span>
<span class="line-removed">2105 #undef MIGHT_HAVE_PENDING</span>
<span class="line-removed">2106 #ifdef MIGHT_HAVE_PENDING</span>
<span class="line-removed">2107   // Save and restore any pending_exception around the exception mark.</span>
<span class="line-removed">2108   // While the slow_exit must not throw an exception, we could come into</span>
<span class="line-removed">2109   // this routine with one set.</span>
<span class="line-removed">2110   oop pending_excep = NULL;</span>
<span class="line-removed">2111   const char* pending_file;</span>
<span class="line-removed">2112   int pending_line;</span>
<span class="line-removed">2113   if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-removed">2114     pending_excep = PENDING_EXCEPTION;</span>
<span class="line-removed">2115     pending_file  = THREAD-&gt;exception_file();</span>
<span class="line-removed">2116     pending_line  = THREAD-&gt;exception_line();</span>
<span class="line-removed">2117     CLEAR_PENDING_EXCEPTION;</span>
<span class="line-removed">2118   }</span>
<span class="line-removed">2119 #endif /* MIGHT_HAVE_PENDING */</span>
2120 
<span class="line-modified">2121   {</span>
<span class="line-modified">2122     // Exit must be non-blocking, and therefore no exceptions can be thrown.</span>
<span class="line-modified">2123     EXCEPTION_MARK;</span>
<span class="line-modified">2124     ObjectSynchronizer::exit(obj, lock, THREAD);</span>
<span class="line-modified">2125   }</span>

2126 
<span class="line-modified">2127 #ifdef MIGHT_HAVE_PENDING</span>
<span class="line-modified">2128   if (pending_excep != NULL) {</span>
<span class="line-modified">2129     THREAD-&gt;set_pending_exception(pending_excep, pending_file, pending_line);</span>
<span class="line-removed">2130   }</span>
<span class="line-removed">2131 #endif /* MIGHT_HAVE_PENDING */</span>
2132 JRT_END
2133 
2134 #ifndef PRODUCT
2135 
2136 void SharedRuntime::print_statistics() {
2137   ttyLocker ttyl;
2138   if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;SharedRuntime&#39;&quot;);
2139 
2140   if (_throw_null_ctr) tty-&gt;print_cr(&quot;%5d implicit null throw&quot;, _throw_null_ctr);
2141 
2142   SharedRuntime::print_ic_miss_histogram();
2143 
2144   if (CountRemovableExceptions) {
2145     if (_nof_removable_exceptions &gt; 0) {
2146       Unimplemented(); // this counter is not yet incremented
2147       tty-&gt;print_cr(&quot;Removable exceptions: %d&quot;, _nof_removable_exceptions);
2148     }
2149   }
2150 
2151   // Dump the JRT_ENTRY counters
</pre>
</td>
<td>
<hr />
<pre>
2055     // Shouldn&#39;t happen, but don&#39;t cause even more problems if it does
2056     message = const_cast&lt;char*&gt;(caster_klass-&gt;external_name());
2057   } else {
2058     jio_snprintf(message,
2059                  msglen,
2060                  &quot;class %s cannot be cast to class %s (%s%s%s)&quot;,
2061                  caster_name,
2062                  target_name,
2063                  caster_klass_description,
2064                  klass_separator,
2065                  target_klass_description
2066                  );
2067   }
2068   return message;
2069 }
2070 
2071 JRT_LEAF(void, SharedRuntime::reguard_yellow_pages())
2072   (void) JavaThread::current()-&gt;reguard_stack();
2073 JRT_END
2074 
<span class="line-modified">2075 void SharedRuntime::monitor_enter_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread) {</span>


2076   if (!SafepointSynchronize::is_synchronizing()) {
2077     // Only try quick_enter() if we&#39;re not trying to reach a safepoint
2078     // so that the calling thread reaches the safepoint more quickly.
<span class="line-modified">2079     if (ObjectSynchronizer::quick_enter(obj, thread, lock)) return;</span>
2080   }
2081   // NO_ASYNC required because an async exception on the state transition destructor
2082   // would leave you with the lock held and it would never be released.
2083   // The normal monitorenter NullPointerException is thrown without acquiring a lock
2084   // and the model is that an exception implies the method failed.
2085   JRT_BLOCK_NO_ASYNC

2086   if (PrintBiasedLockingStatistics) {
2087     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
2088   }
2089   Handle h_obj(THREAD, obj);
2090   ObjectSynchronizer::enter(h_obj, lock, CHECK);
2091   assert(!HAS_PENDING_EXCEPTION, &quot;Should have no exception here&quot;);
2092   JRT_BLOCK_END
<span class="line-modified">2093 }</span>
2094 
<span class="line-modified">2095 // Handles the uncommon case in locking, i.e., contention or an inflated lock.</span>
<span class="line-modified">2096 JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread))</span>
<span class="line-modified">2097   SharedRuntime::monitor_enter_helper(obj, lock, thread);</span>
<span class="line-modified">2098 JRT_END</span>


















2099 
<span class="line-modified">2100 void SharedRuntime::monitor_exit_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread) {</span>
<span class="line-modified">2101   assert(JavaThread::current() == thread, &quot;invariant&quot;);</span>
<span class="line-modified">2102   // Exit must be non-blocking, and therefore no exceptions can be thrown.</span>
<span class="line-modified">2103   EXCEPTION_MARK;</span>
<span class="line-modified">2104   ObjectSynchronizer::exit(obj, lock, THREAD);</span>
<span class="line-added">2105 }</span>
2106 
<span class="line-modified">2107 // Handles the uncommon cases of monitor unlocking in compiled code</span>
<span class="line-modified">2108 JRT_LEAF(void, SharedRuntime::complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread))</span>
<span class="line-modified">2109   SharedRuntime::monitor_exit_helper(obj, lock, thread);</span>


2110 JRT_END
2111 
2112 #ifndef PRODUCT
2113 
2114 void SharedRuntime::print_statistics() {
2115   ttyLocker ttyl;
2116   if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;SharedRuntime&#39;&quot;);
2117 
2118   if (_throw_null_ctr) tty-&gt;print_cr(&quot;%5d implicit null throw&quot;, _throw_null_ctr);
2119 
2120   SharedRuntime::print_ic_miss_histogram();
2121 
2122   if (CountRemovableExceptions) {
2123     if (_nof_removable_exceptions &gt; 0) {
2124       Unimplemented(); // this counter is not yet incremented
2125       tty-&gt;print_cr(&quot;Removable exceptions: %d&quot;, _nof_removable_exceptions);
2126     }
2127   }
2128 
2129   // Dump the JRT_ENTRY counters
</pre>
</td>
</tr>
</table>
<center><a href="mutexLocker.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
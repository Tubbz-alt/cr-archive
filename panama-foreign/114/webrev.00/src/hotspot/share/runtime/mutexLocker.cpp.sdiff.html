<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/mutexLocker.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mutexLocker.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/mutexLocker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 57 Mutex*   AdapterHandlerLibrary_lock   = NULL;
 58 Mutex*   SignatureHandlerLibrary_lock = NULL;
 59 Mutex*   VtableStubs_lock             = NULL;
 60 Mutex*   SymbolArena_lock             = NULL;
 61 Monitor* StringDedupQueue_lock        = NULL;
 62 Mutex*   StringDedupTable_lock        = NULL;
 63 Monitor* CodeCache_lock               = NULL;
 64 Mutex*   MethodData_lock              = NULL;
 65 Mutex*   TouchedMethodLog_lock        = NULL;
 66 Mutex*   RetData_lock                 = NULL;
 67 Monitor* VMOperationQueue_lock        = NULL;
 68 Monitor* VMOperationRequest_lock      = NULL;
 69 Monitor* Threads_lock                 = NULL;
 70 Mutex*   NonJavaThreadsList_lock      = NULL;
 71 Mutex*   NonJavaThreadsListSync_lock  = NULL;
 72 Monitor* CGC_lock                     = NULL;
 73 Monitor* STS_lock                     = NULL;
 74 Monitor* FullGCCount_lock             = NULL;
 75 Monitor* G1OldGCCount_lock            = NULL;
 76 Mutex*   Shared_DirtyCardQ_lock       = NULL;

 77 Mutex*   MarkStackFreeList_lock       = NULL;
 78 Mutex*   MarkStackChunkList_lock      = NULL;
 79 Mutex*   MonitoringSupport_lock       = NULL;
 80 Mutex*   ParGCRareEvent_lock          = NULL;
 81 Monitor* ConcurrentGCBreakpoints_lock = NULL;
 82 Mutex*   Compile_lock                 = NULL;
 83 Monitor* MethodCompileQueue_lock      = NULL;
 84 Monitor* CompileThread_lock           = NULL;
 85 Monitor* Compilation_lock             = NULL;
 86 Mutex*   CompileTaskAlloc_lock        = NULL;
 87 Mutex*   CompileStatistics_lock       = NULL;
 88 Mutex*   DirectivesStack_lock         = NULL;
 89 Mutex*   MultiArray_lock              = NULL;
 90 Monitor* Terminator_lock              = NULL;
 91 Monitor* InitCompleted_lock           = NULL;
 92 Monitor* BeforeExit_lock              = NULL;
 93 Monitor* Notify_lock                  = NULL;
 94 Mutex*   ProfilePrint_lock            = NULL;
 95 Mutex*   ExceptionCache_lock          = NULL;
 96 Mutex*   NMethodSweeperStats_lock     = NULL;
</pre>
<hr />
<pre>
195 
196 #define def(var, type, pri, vm_block, safepoint_check_allowed ) {      \
197   var = new type(Mutex::pri, #var, vm_block, Mutex::safepoint_check_allowed); \
198   assert(_num_mutex &lt; MAX_NUM_MUTEX, &quot;increase MAX_NUM_MUTEX&quot;);        \
199   _mutex_array[_num_mutex++] = var;                                      \
200 }
201 
202 // Using Padded subclasses to prevent false sharing of these global monitors and mutexes.
203 void mutex_init() {
204   def(tty_lock                     , PaddedMutex  , tty,         true,  _safepoint_check_never);      // allow to lock in VM
205 
206   def(CGC_lock                     , PaddedMonitor, special,     true,  _safepoint_check_never);      // coordinate between fore- and background GC
207   def(STS_lock                     , PaddedMonitor, leaf,        true,  _safepoint_check_never);
208 
209   def(FullGCCount_lock             , PaddedMonitor, leaf,        true,  _safepoint_check_never);      // in support of ExplicitGCInvokesConcurrent
210   if (UseG1GC) {
211     def(G1OldGCCount_lock          , PaddedMonitor, leaf,        true,  _safepoint_check_always);
212 
213     def(Shared_DirtyCardQ_lock     , PaddedMutex  , access + 1,  true,  _safepoint_check_never);
214 


215     def(FreeList_lock              , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);
216     def(OldSets_lock               , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);
217     def(RootRegionScan_lock        , PaddedMonitor, leaf     ,   true,  _safepoint_check_never);
218 
219     def(StringDedupQueue_lock      , PaddedMonitor, leaf,        true,  _safepoint_check_never);
220     def(StringDedupTable_lock      , PaddedMutex  , leaf,        true,  _safepoint_check_never);
221 
222     def(MarkStackFreeList_lock     , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);
223     def(MarkStackChunkList_lock    , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);
224 
225     def(MonitoringSupport_lock     , PaddedMutex  , native   ,   true,  _safepoint_check_never);      // used for serviceability monitoring support
226   }
227   if (UseShenandoahGC) {
228     def(StringDedupQueue_lock      , PaddedMonitor, leaf,        true,  _safepoint_check_never);
229     def(StringDedupTable_lock      , PaddedMutex  , leaf + 1,    true,  _safepoint_check_never);
230   }
231   def(ParGCRareEvent_lock          , PaddedMutex  , leaf     ,   true,  _safepoint_check_always);
232   def(CodeCache_lock               , PaddedMonitor, special,     true,  _safepoint_check_never);
233   def(RawMonitor_lock              , PaddedMutex  , special,     true,  _safepoint_check_never);
234   def(OopMapCacheAlloc_lock        , PaddedMutex  , leaf,        true,  _safepoint_check_always); // used for oop_map_cache allocation.
</pre>
<hr />
<pre>
252   def(ProtectionDomainSet_lock     , PaddedMutex  , leaf-1,      true,  _safepoint_check_never);
253   def(SharedDictionary_lock        , PaddedMutex  , leaf,        true,  _safepoint_check_always);
254   def(Module_lock                  , PaddedMutex  , leaf+2,      false, _safepoint_check_always);
255   def(InlineCacheBuffer_lock       , PaddedMutex  , leaf,        true,  _safepoint_check_never);
256   def(VMStatistic_lock             , PaddedMutex  , leaf,        false, _safepoint_check_always);
257   def(ExpandHeap_lock              , PaddedMutex  , leaf,        true,  _safepoint_check_always); // Used during compilation by VM thread
258   def(JNIHandleBlockFreeList_lock  , PaddedMutex  , leaf-1,      true,  _safepoint_check_never);      // handles are used by VM thread
259   def(SignatureHandlerLibrary_lock , PaddedMutex  , leaf,        false, _safepoint_check_always);
260   def(SymbolArena_lock             , PaddedMutex  , leaf+2,      true,  _safepoint_check_never);
261   def(ProfilePrint_lock            , PaddedMutex  , leaf,        false, _safepoint_check_always); // serial profile printing
262   def(ExceptionCache_lock          , PaddedMutex  , leaf,        false, _safepoint_check_always); // serial profile printing
263   def(Debug1_lock                  , PaddedMutex  , leaf,        true,  _safepoint_check_never);
264 #ifndef PRODUCT
265   def(FullGCALot_lock              , PaddedMutex  , leaf,        false, _safepoint_check_always); // a lock to make FullGCALot MT safe
266 #endif
267   def(BeforeExit_lock              , PaddedMonitor, leaf,        true,  _safepoint_check_always);
268   def(PerfDataMemAlloc_lock        , PaddedMutex  , leaf,        true,  _safepoint_check_always); // used for allocating PerfData memory for performance data
269   def(PerfDataManager_lock         , PaddedMutex  , leaf,        true,  _safepoint_check_always); // used for synchronized access to PerfDataManager resources
270 
271   def(Threads_lock                 , PaddedMonitor, barrier,     true,  _safepoint_check_always);  // Used for safepoint protocol.
<span class="line-modified">272   def(NonJavaThreadsList_lock      , PaddedMutex,   leaf,        true,  _safepoint_check_never);</span>
273   def(NonJavaThreadsListSync_lock  , PaddedMutex,   leaf,        true,  _safepoint_check_never);
274 
275   def(VMOperationQueue_lock        , PaddedMonitor, nonleaf,     true,  _safepoint_check_never);  // VM_thread allowed to block on these
276   def(VMOperationRequest_lock      , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);
277   def(RetData_lock                 , PaddedMutex  , nonleaf,     false, _safepoint_check_always);
278   def(Terminator_lock              , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);
279   def(InitCompleted_lock           , PaddedMonitor, leaf,        true,  _safepoint_check_never);
280   def(VtableStubs_lock             , PaddedMutex  , nonleaf,     true,  _safepoint_check_never);
281   def(Notify_lock                  , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);
282   def(JNICritical_lock             , PaddedMonitor, nonleaf,     true,  _safepoint_check_always); // used for JNI critical regions
283   def(AdapterHandlerLibrary_lock   , PaddedMutex  , nonleaf,     true,  _safepoint_check_always);
284 
285   def(Heap_lock                    , PaddedMonitor, nonleaf+1,   false, _safepoint_check_sometimes);  // Doesn&#39;t safepoint check during termination.
286   def(JfieldIdCreation_lock        , PaddedMutex  , nonleaf+1,   true,  _safepoint_check_always); // jfieldID, Used in VM_Operation
287 
288   def(CompiledIC_lock              , PaddedMutex  , nonleaf+2,   false, _safepoint_check_never);      // locks VtableStubs_lock, InlineCacheBuffer_lock
289   def(CompileTaskAlloc_lock        , PaddedMutex  , nonleaf+2,   true,  _safepoint_check_always);
290   def(CompileStatistics_lock       , PaddedMutex  , nonleaf+2,   false, _safepoint_check_always);
291   def(DirectivesStack_lock         , PaddedMutex  , special,     true,  _safepoint_check_never);
292   def(MultiArray_lock              , PaddedMutex  , nonleaf+2,   false, _safepoint_check_always);
</pre>
</td>
<td>
<hr />
<pre>
 57 Mutex*   AdapterHandlerLibrary_lock   = NULL;
 58 Mutex*   SignatureHandlerLibrary_lock = NULL;
 59 Mutex*   VtableStubs_lock             = NULL;
 60 Mutex*   SymbolArena_lock             = NULL;
 61 Monitor* StringDedupQueue_lock        = NULL;
 62 Mutex*   StringDedupTable_lock        = NULL;
 63 Monitor* CodeCache_lock               = NULL;
 64 Mutex*   MethodData_lock              = NULL;
 65 Mutex*   TouchedMethodLog_lock        = NULL;
 66 Mutex*   RetData_lock                 = NULL;
 67 Monitor* VMOperationQueue_lock        = NULL;
 68 Monitor* VMOperationRequest_lock      = NULL;
 69 Monitor* Threads_lock                 = NULL;
 70 Mutex*   NonJavaThreadsList_lock      = NULL;
 71 Mutex*   NonJavaThreadsListSync_lock  = NULL;
 72 Monitor* CGC_lock                     = NULL;
 73 Monitor* STS_lock                     = NULL;
 74 Monitor* FullGCCount_lock             = NULL;
 75 Monitor* G1OldGCCount_lock            = NULL;
 76 Mutex*   Shared_DirtyCardQ_lock       = NULL;
<span class="line-added"> 77 Mutex*   G1DetachedRefinementStats_lock = NULL;</span>
 78 Mutex*   MarkStackFreeList_lock       = NULL;
 79 Mutex*   MarkStackChunkList_lock      = NULL;
 80 Mutex*   MonitoringSupport_lock       = NULL;
 81 Mutex*   ParGCRareEvent_lock          = NULL;
 82 Monitor* ConcurrentGCBreakpoints_lock = NULL;
 83 Mutex*   Compile_lock                 = NULL;
 84 Monitor* MethodCompileQueue_lock      = NULL;
 85 Monitor* CompileThread_lock           = NULL;
 86 Monitor* Compilation_lock             = NULL;
 87 Mutex*   CompileTaskAlloc_lock        = NULL;
 88 Mutex*   CompileStatistics_lock       = NULL;
 89 Mutex*   DirectivesStack_lock         = NULL;
 90 Mutex*   MultiArray_lock              = NULL;
 91 Monitor* Terminator_lock              = NULL;
 92 Monitor* InitCompleted_lock           = NULL;
 93 Monitor* BeforeExit_lock              = NULL;
 94 Monitor* Notify_lock                  = NULL;
 95 Mutex*   ProfilePrint_lock            = NULL;
 96 Mutex*   ExceptionCache_lock          = NULL;
 97 Mutex*   NMethodSweeperStats_lock     = NULL;
</pre>
<hr />
<pre>
196 
197 #define def(var, type, pri, vm_block, safepoint_check_allowed ) {      \
198   var = new type(Mutex::pri, #var, vm_block, Mutex::safepoint_check_allowed); \
199   assert(_num_mutex &lt; MAX_NUM_MUTEX, &quot;increase MAX_NUM_MUTEX&quot;);        \
200   _mutex_array[_num_mutex++] = var;                                      \
201 }
202 
203 // Using Padded subclasses to prevent false sharing of these global monitors and mutexes.
204 void mutex_init() {
205   def(tty_lock                     , PaddedMutex  , tty,         true,  _safepoint_check_never);      // allow to lock in VM
206 
207   def(CGC_lock                     , PaddedMonitor, special,     true,  _safepoint_check_never);      // coordinate between fore- and background GC
208   def(STS_lock                     , PaddedMonitor, leaf,        true,  _safepoint_check_never);
209 
210   def(FullGCCount_lock             , PaddedMonitor, leaf,        true,  _safepoint_check_never);      // in support of ExplicitGCInvokesConcurrent
211   if (UseG1GC) {
212     def(G1OldGCCount_lock          , PaddedMonitor, leaf,        true,  _safepoint_check_always);
213 
214     def(Shared_DirtyCardQ_lock     , PaddedMutex  , access + 1,  true,  _safepoint_check_never);
215 
<span class="line-added">216     def(G1DetachedRefinementStats_lock, PaddedMutex, leaf    ,   true, _safepoint_check_never);</span>
<span class="line-added">217 </span>
218     def(FreeList_lock              , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);
219     def(OldSets_lock               , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);
220     def(RootRegionScan_lock        , PaddedMonitor, leaf     ,   true,  _safepoint_check_never);
221 
222     def(StringDedupQueue_lock      , PaddedMonitor, leaf,        true,  _safepoint_check_never);
223     def(StringDedupTable_lock      , PaddedMutex  , leaf,        true,  _safepoint_check_never);
224 
225     def(MarkStackFreeList_lock     , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);
226     def(MarkStackChunkList_lock    , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);
227 
228     def(MonitoringSupport_lock     , PaddedMutex  , native   ,   true,  _safepoint_check_never);      // used for serviceability monitoring support
229   }
230   if (UseShenandoahGC) {
231     def(StringDedupQueue_lock      , PaddedMonitor, leaf,        true,  _safepoint_check_never);
232     def(StringDedupTable_lock      , PaddedMutex  , leaf + 1,    true,  _safepoint_check_never);
233   }
234   def(ParGCRareEvent_lock          , PaddedMutex  , leaf     ,   true,  _safepoint_check_always);
235   def(CodeCache_lock               , PaddedMonitor, special,     true,  _safepoint_check_never);
236   def(RawMonitor_lock              , PaddedMutex  , special,     true,  _safepoint_check_never);
237   def(OopMapCacheAlloc_lock        , PaddedMutex  , leaf,        true,  _safepoint_check_always); // used for oop_map_cache allocation.
</pre>
<hr />
<pre>
255   def(ProtectionDomainSet_lock     , PaddedMutex  , leaf-1,      true,  _safepoint_check_never);
256   def(SharedDictionary_lock        , PaddedMutex  , leaf,        true,  _safepoint_check_always);
257   def(Module_lock                  , PaddedMutex  , leaf+2,      false, _safepoint_check_always);
258   def(InlineCacheBuffer_lock       , PaddedMutex  , leaf,        true,  _safepoint_check_never);
259   def(VMStatistic_lock             , PaddedMutex  , leaf,        false, _safepoint_check_always);
260   def(ExpandHeap_lock              , PaddedMutex  , leaf,        true,  _safepoint_check_always); // Used during compilation by VM thread
261   def(JNIHandleBlockFreeList_lock  , PaddedMutex  , leaf-1,      true,  _safepoint_check_never);      // handles are used by VM thread
262   def(SignatureHandlerLibrary_lock , PaddedMutex  , leaf,        false, _safepoint_check_always);
263   def(SymbolArena_lock             , PaddedMutex  , leaf+2,      true,  _safepoint_check_never);
264   def(ProfilePrint_lock            , PaddedMutex  , leaf,        false, _safepoint_check_always); // serial profile printing
265   def(ExceptionCache_lock          , PaddedMutex  , leaf,        false, _safepoint_check_always); // serial profile printing
266   def(Debug1_lock                  , PaddedMutex  , leaf,        true,  _safepoint_check_never);
267 #ifndef PRODUCT
268   def(FullGCALot_lock              , PaddedMutex  , leaf,        false, _safepoint_check_always); // a lock to make FullGCALot MT safe
269 #endif
270   def(BeforeExit_lock              , PaddedMonitor, leaf,        true,  _safepoint_check_always);
271   def(PerfDataMemAlloc_lock        , PaddedMutex  , leaf,        true,  _safepoint_check_always); // used for allocating PerfData memory for performance data
272   def(PerfDataManager_lock         , PaddedMutex  , leaf,        true,  _safepoint_check_always); // used for synchronized access to PerfDataManager resources
273 
274   def(Threads_lock                 , PaddedMonitor, barrier,     true,  _safepoint_check_always);  // Used for safepoint protocol.
<span class="line-modified">275   def(NonJavaThreadsList_lock      , PaddedMutex,   barrier,     true,  _safepoint_check_never);</span>
276   def(NonJavaThreadsListSync_lock  , PaddedMutex,   leaf,        true,  _safepoint_check_never);
277 
278   def(VMOperationQueue_lock        , PaddedMonitor, nonleaf,     true,  _safepoint_check_never);  // VM_thread allowed to block on these
279   def(VMOperationRequest_lock      , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);
280   def(RetData_lock                 , PaddedMutex  , nonleaf,     false, _safepoint_check_always);
281   def(Terminator_lock              , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);
282   def(InitCompleted_lock           , PaddedMonitor, leaf,        true,  _safepoint_check_never);
283   def(VtableStubs_lock             , PaddedMutex  , nonleaf,     true,  _safepoint_check_never);
284   def(Notify_lock                  , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);
285   def(JNICritical_lock             , PaddedMonitor, nonleaf,     true,  _safepoint_check_always); // used for JNI critical regions
286   def(AdapterHandlerLibrary_lock   , PaddedMutex  , nonleaf,     true,  _safepoint_check_always);
287 
288   def(Heap_lock                    , PaddedMonitor, nonleaf+1,   false, _safepoint_check_sometimes);  // Doesn&#39;t safepoint check during termination.
289   def(JfieldIdCreation_lock        , PaddedMutex  , nonleaf+1,   true,  _safepoint_check_always); // jfieldID, Used in VM_Operation
290 
291   def(CompiledIC_lock              , PaddedMutex  , nonleaf+2,   false, _safepoint_check_never);      // locks VtableStubs_lock, InlineCacheBuffer_lock
292   def(CompileTaskAlloc_lock        , PaddedMutex  , nonleaf+2,   true,  _safepoint_check_always);
293   def(CompileStatistics_lock       , PaddedMutex  , nonleaf+2,   false, _safepoint_check_always);
294   def(DirectivesStack_lock         , PaddedMutex  , special,     true,  _safepoint_check_never);
295   def(MultiArray_lock              , PaddedMutex  , nonleaf+2,   false, _safepoint_check_always);
</pre>
</td>
</tr>
</table>
<center><a href="globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mutexLocker.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
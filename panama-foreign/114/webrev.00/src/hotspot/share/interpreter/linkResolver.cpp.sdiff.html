<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/linkResolver.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bootstrapInfo.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../jvmci/jvmciRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/linkResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 419   if (vtable_index == Method::invalid_vtable_index) {
 420     // get vtable_index for miranda methods
 421     klassVtable vt = ik-&gt;vtable();
 422     vtable_index = vt.index_of_miranda(name, signature);
 423   }
 424   return vtable_index;
 425 }
 426 
 427 Method* LinkResolver::lookup_method_in_interfaces(const LinkInfo&amp; cp_info) {
 428   InstanceKlass *ik = InstanceKlass::cast(cp_info.resolved_klass());
 429 
 430   // Specify &#39;true&#39; in order to skip default methods when searching the
 431   // interfaces.  Function lookup_method_in_klasses() already looked for
 432   // the method in the default methods table.
 433   return ik-&gt;lookup_method_in_all_interfaces(cp_info.name(), cp_info.signature(), Klass::skip_defaults);
 434 }
 435 
 436 Method* LinkResolver::lookup_polymorphic_method(const LinkInfo&amp; link_info,
 437                                                 Handle *appendix_result_or_null,
 438                                                 TRAPS) {

 439   Klass* klass = link_info.resolved_klass();
 440   Symbol* name = link_info.name();
 441   Symbol* full_signature = link_info.signature();

 442 
 443   vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);
<span class="line-modified"> 444   if (TraceMethodHandles) {</span>
<span class="line-modified"> 445     ResourceMark rm(THREAD);</span>
<span class="line-modified"> 446     tty-&gt;print_cr(&quot;lookup_polymorphic_method iid=%s %s.%s%s&quot;,</span>
<span class="line-removed"> 447                   vmIntrinsics::name_at(iid), klass-&gt;external_name(),</span>
<span class="line-removed"> 448                   name-&gt;as_C_string(), full_signature-&gt;as_C_string());</span>
<span class="line-removed"> 449   }</span>
 450   if ((klass == SystemDictionary::MethodHandle_klass() ||
 451        klass == SystemDictionary::VarHandle_klass()) &amp;&amp;
 452       iid != vmIntrinsics::_none) {
 453     if (MethodHandles::is_signature_polymorphic_intrinsic(iid)) {
 454       // Most of these do not need an up-call to Java to resolve, so can be done anywhere.
 455       // Do not erase last argument type (MemberName) if it is a static linkTo method.
 456       bool keep_last_arg = MethodHandles::is_signature_polymorphic_static(iid);
 457       TempNewSymbol basic_signature =
 458         MethodHandles::lookup_basic_type_signature(full_signature, keep_last_arg, CHECK_NULL);
<span class="line-modified"> 459       if (TraceMethodHandles) {</span>
<span class="line-modified"> 460         ResourceMark rm(THREAD);</span>
<span class="line-modified"> 461         tty-&gt;print_cr(&quot;lookup_polymorphic_method %s %s =&gt; basic %s&quot;,</span>
<span class="line-modified"> 462                       name-&gt;as_C_string(),</span>
<span class="line-removed"> 463                       full_signature-&gt;as_C_string(),</span>
<span class="line-removed"> 464                       basic_signature-&gt;as_C_string());</span>
<span class="line-removed"> 465       }</span>
 466       Method* result = SystemDictionary::find_method_handle_intrinsic(iid,
 467                                                               basic_signature,
 468                                                               CHECK_NULL);
 469       if (result != NULL) {
 470         assert(result-&gt;is_method_handle_intrinsic(), &quot;MH.invokeBasic or MH.linkTo* intrinsic&quot;);
 471         assert(result-&gt;intrinsic_id() != vmIntrinsics::_invokeGeneric, &quot;wrong place to find this&quot;);
 472         assert(basic_signature == result-&gt;signature(), &quot;predict the result signature&quot;);
<span class="line-modified"> 473         if (TraceMethodHandles) {</span>
<span class="line-modified"> 474           ttyLocker ttyl;</span>
<span class="line-modified"> 475           tty-&gt;print(&quot;lookup_polymorphic_method =&gt; intrinsic &quot;);</span>
<span class="line-modified"> 476           result-&gt;print_on(tty);</span>
 477         }
 478       }
 479       return result;
 480     } else if (iid == vmIntrinsics::_invokeGeneric
 481                &amp;&amp; THREAD-&gt;can_call_java()
 482                &amp;&amp; appendix_result_or_null != NULL) {
 483       // This is a method with type-checking semantics.
 484       // We will ask Java code to spin an adapter method for it.
 485       if (!MethodHandles::enabled()) {
 486         // Make sure the Java part of the runtime has been booted up.
 487         Klass* natives = SystemDictionary::MethodHandleNatives_klass();
 488         if (natives == NULL || InstanceKlass::cast(natives)-&gt;is_not_initialized()) {
 489           SystemDictionary::resolve_or_fail(vmSymbols::java_lang_invoke_MethodHandleNatives(),
 490                                             Handle(),
 491                                             Handle(),
 492                                             true,
 493                                             CHECK_NULL);
 494         }
 495       }
 496 
 497       Handle appendix;
 498       Handle method_type;
 499       Method* result = SystemDictionary::find_method_handle_invoker(
 500                                                             klass,
 501                                                             name,
 502                                                             full_signature,
 503                                                             link_info.current_klass(),
 504                                                             &amp;appendix,
 505                                                             CHECK_NULL);
<span class="line-modified"> 506       if (TraceMethodHandles) {</span>
<span class="line-modified"> 507         ttyLocker ttyl;</span>
<span class="line-modified"> 508         tty-&gt;print(&quot;lookup_polymorphic_method =&gt; (via Java) &quot;);</span>
<span class="line-modified"> 509         result-&gt;print_on(tty);</span>
<span class="line-modified"> 510         tty-&gt;print(&quot;  lookup_polymorphic_method =&gt; appendix = &quot;);</span>
<span class="line-modified"> 511         if (appendix.is_null())  tty-&gt;print_cr(&quot;(none)&quot;);</span>
<span class="line-removed"> 512         else                     appendix-&gt;print_on(tty);</span>
 513       }
 514       if (result != NULL) {
 515 #ifdef ASSERT
 516         ResourceMark rm(THREAD);
 517 
 518         TempNewSymbol basic_signature =
 519           MethodHandles::lookup_basic_type_signature(full_signature, CHECK_NULL);
 520         int actual_size_of_params = result-&gt;size_of_parameters();
 521         int expected_size_of_params = ArgumentSizeComputer(basic_signature).size();
 522         // +1 for MethodHandle.this, +1 for trailing MethodType
 523         if (!MethodHandles::is_signature_polymorphic_static(iid))  expected_size_of_params += 1;
 524         if (appendix.not_null())                                   expected_size_of_params += 1;
 525         if (actual_size_of_params != expected_size_of_params) {
 526           tty-&gt;print_cr(&quot;*** basic_signature=%s&quot;, basic_signature-&gt;as_C_string());
 527           tty-&gt;print_cr(&quot;*** result for %s: &quot;, vmIntrinsics::name_at(iid));
 528           result-&gt;print();
 529         }
 530         assert(actual_size_of_params == expected_size_of_params,
 531                &quot;%d != %d&quot;, actual_size_of_params, expected_size_of_params);
 532 #endif //ASSERT
</pre>
<hr />
<pre>
1652 void LinkResolver::resolve_invokevirtual(CallInfo&amp; result, Handle recv,
1653                                           const constantPoolHandle&amp; pool, int index,
1654                                           TRAPS) {
1655 
1656   LinkInfo link_info(pool, index, CHECK);
1657   Klass* recvrKlass = recv.is_null() ? (Klass*)NULL : recv-&gt;klass();
1658   resolve_virtual_call(result, recv, recvrKlass, link_info, /*check_null_or_abstract*/true, CHECK);
1659 }
1660 
1661 
1662 void LinkResolver::resolve_invokeinterface(CallInfo&amp; result, Handle recv, const constantPoolHandle&amp; pool, int index, TRAPS) {
1663   LinkInfo link_info(pool, index, CHECK);
1664   Klass* recvrKlass = recv.is_null() ? (Klass*)NULL : recv-&gt;klass();
1665   resolve_interface_call(result, recv, recvrKlass, link_info, true, CHECK);
1666 }
1667 
1668 
1669 void LinkResolver::resolve_invokehandle(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
1670   // This guy is reached from InterpreterRuntime::resolve_invokehandle.
1671   LinkInfo link_info(pool, index, CHECK);
<span class="line-modified">1672   if (TraceMethodHandles) {</span>
1673     ResourceMark rm(THREAD);
<span class="line-modified">1674     tty-&gt;print_cr(&quot;resolve_invokehandle %s %s&quot;, link_info.name()-&gt;as_C_string(),</span>
<span class="line-modified">1675                   link_info.signature()-&gt;as_C_string());</span>
1676   }
1677   resolve_handle_call(result, link_info, CHECK);
1678 }
1679 
1680 void LinkResolver::resolve_handle_call(CallInfo&amp; result,
1681                                        const LinkInfo&amp; link_info,
1682                                        TRAPS) {
1683   // JSR 292:  this must be an implicitly generated method MethodHandle.invokeExact(*...) or similar
1684   Klass* resolved_klass = link_info.resolved_klass();
1685   assert(resolved_klass == SystemDictionary::MethodHandle_klass() ||
1686          resolved_klass == SystemDictionary::VarHandle_klass(), &quot;&quot;);
1687   assert(MethodHandles::is_signature_polymorphic_name(link_info.name()), &quot;&quot;);
1688   Handle       resolved_appendix;
1689   Method* resolved_method = lookup_polymorphic_method(link_info, &amp;resolved_appendix, CHECK);
1690   result.set_handle(resolved_klass, methodHandle(THREAD, resolved_method), resolved_appendix, CHECK);
1691 }
1692 
1693 void LinkResolver::resolve_invokedynamic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int indy_index, TRAPS) {
1694   ConstantPoolCacheEntry* cpce = pool-&gt;invokedynamic_cp_cache_entry_at(indy_index);
1695   int pool_index = cpce-&gt;constant_pool_index();
1696 
1697   // Resolve the bootstrap specifier (BSM + optional arguments).
1698   BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);
1699 
1700   // Check if CallSite has been bound already or failed already, and short circuit:
1701   {
1702     bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);
1703     if (is_done) return;
1704   }
1705 
1706   // The initial step in Call Site Specifier Resolution is to resolve the symbolic
1707   // reference to a method handle which will be the bootstrap method for a dynamic
1708   // call site.  If resolution for the java.lang.invoke.MethodHandle for the bootstrap
1709   // method fails, then a MethodHandleInError is stored at the corresponding bootstrap
1710   // method&#39;s CP index for the CONSTANT_MethodHandle_info.  So, there is no need to
1711   // set the indy_rf flag since any subsequent invokedynamic instruction which shares
1712   // this bootstrap method will encounter the resolution of MethodHandleInError.
1713 
1714   resolve_dynamic_call(result, bootstrap_specifier, CHECK);
1715 
<span class="line-modified">1716   if (TraceMethodHandles) {</span>
<span class="line-modified">1717     bootstrap_specifier.print_msg_on(tty, &quot;resolve_invokedynamic&quot;);</span>


1718   }
1719 
1720   // The returned linkage result is provisional up to the moment
1721   // the interpreter or runtime performs a serialized check of
1722   // the relevant CPCE::f1 field.  This is done by the caller
1723   // of this method, via CPCE::set_dynamic_call, which uses
1724   // an ObjectLocker to do the final serialization of updates
1725   // to CPCE state, including f1.
1726 }
1727 
1728 void LinkResolver::resolve_dynamic_call(CallInfo&amp; result,
1729                                         BootstrapInfo&amp; bootstrap_specifier,
1730                                         TRAPS) {
1731   // JSR 292:  this must resolve to an implicitly generated method
1732   // such as MH.linkToCallSite(*...) or some other call-site shape.
1733   // The appendix argument is likely to be a freshly-created CallSite.
1734   // It may also be a MethodHandle from an unwrapped ConstantCallSite,
1735   // or any other reference.  The resolved_method as well as the appendix
1736   // are both recorded together via CallInfo::set_handle.
1737   SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
<span class="line-modified">1738   Exceptions::wrap_dynamic_exception(THREAD);</span>
1739 
1740   if (HAS_PENDING_EXCEPTION) {
1741     if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {
1742       // Let any random low-level IE or SOE or OOME just bleed through.
1743       // Basically we pretend that the bootstrap method was never called,
1744       // if it fails this way:  We neither record a successful linkage,
1745       // nor do we memorize a LE for posterity.
1746       return;
1747     }
1748     // JVMS 5.4.3 says: If an attempt by the Java Virtual Machine to resolve
1749     // a symbolic reference fails because an error is thrown that is an
1750     // instance of LinkageError (or a subclass), then subsequent attempts to
1751     // resolve the reference always fail with the same error that was thrown
1752     // as a result of the initial resolution attempt.
1753      bool recorded_res_status = bootstrap_specifier.save_and_throw_indy_exc(CHECK);
1754      if (!recorded_res_status) {
1755        // Another thread got here just before we did.  So, either use the method
1756        // that it resolved or throw the LinkageError exception that it threw.
1757        bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);
1758        if (is_done) return;
</pre>
</td>
<td>
<hr />
<pre>
 419   if (vtable_index == Method::invalid_vtable_index) {
 420     // get vtable_index for miranda methods
 421     klassVtable vt = ik-&gt;vtable();
 422     vtable_index = vt.index_of_miranda(name, signature);
 423   }
 424   return vtable_index;
 425 }
 426 
 427 Method* LinkResolver::lookup_method_in_interfaces(const LinkInfo&amp; cp_info) {
 428   InstanceKlass *ik = InstanceKlass::cast(cp_info.resolved_klass());
 429 
 430   // Specify &#39;true&#39; in order to skip default methods when searching the
 431   // interfaces.  Function lookup_method_in_klasses() already looked for
 432   // the method in the default methods table.
 433   return ik-&gt;lookup_method_in_all_interfaces(cp_info.name(), cp_info.signature(), Klass::skip_defaults);
 434 }
 435 
 436 Method* LinkResolver::lookup_polymorphic_method(const LinkInfo&amp; link_info,
 437                                                 Handle *appendix_result_or_null,
 438                                                 TRAPS) {
<span class="line-added"> 439   ResourceMark rm(THREAD);</span>
 440   Klass* klass = link_info.resolved_klass();
 441   Symbol* name = link_info.name();
 442   Symbol* full_signature = link_info.signature();
<span class="line-added"> 443   LogTarget(Info, methodhandles) lt_mh;</span>
 444 
 445   vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);
<span class="line-modified"> 446   log_info(methodhandles)(&quot;lookup_polymorphic_method iid=%s %s.%s%s&quot;,</span>
<span class="line-modified"> 447                           vmIntrinsics::name_at(iid), klass-&gt;external_name(),</span>
<span class="line-modified"> 448                           name-&gt;as_C_string(), full_signature-&gt;as_C_string());</span>



 449   if ((klass == SystemDictionary::MethodHandle_klass() ||
 450        klass == SystemDictionary::VarHandle_klass()) &amp;&amp;
 451       iid != vmIntrinsics::_none) {
 452     if (MethodHandles::is_signature_polymorphic_intrinsic(iid)) {
 453       // Most of these do not need an up-call to Java to resolve, so can be done anywhere.
 454       // Do not erase last argument type (MemberName) if it is a static linkTo method.
 455       bool keep_last_arg = MethodHandles::is_signature_polymorphic_static(iid);
 456       TempNewSymbol basic_signature =
 457         MethodHandles::lookup_basic_type_signature(full_signature, keep_last_arg, CHECK_NULL);
<span class="line-modified"> 458       log_info(methodhandles)(&quot;lookup_polymorphic_method %s %s =&gt; basic %s&quot;,</span>
<span class="line-modified"> 459                               name-&gt;as_C_string(),</span>
<span class="line-modified"> 460                               full_signature-&gt;as_C_string(),</span>
<span class="line-modified"> 461                               basic_signature-&gt;as_C_string());</span>



 462       Method* result = SystemDictionary::find_method_handle_intrinsic(iid,
 463                                                               basic_signature,
 464                                                               CHECK_NULL);
 465       if (result != NULL) {
 466         assert(result-&gt;is_method_handle_intrinsic(), &quot;MH.invokeBasic or MH.linkTo* intrinsic&quot;);
 467         assert(result-&gt;intrinsic_id() != vmIntrinsics::_invokeGeneric, &quot;wrong place to find this&quot;);
 468         assert(basic_signature == result-&gt;signature(), &quot;predict the result signature&quot;);
<span class="line-modified"> 469         if (lt_mh.is_enabled()) {</span>
<span class="line-modified"> 470           LogStream ls(lt_mh);</span>
<span class="line-modified"> 471           ls.print(&quot;lookup_polymorphic_method =&gt; intrinsic &quot;);</span>
<span class="line-modified"> 472           result-&gt;print_on(&amp;ls);</span>
 473         }
 474       }
 475       return result;
 476     } else if (iid == vmIntrinsics::_invokeGeneric
 477                &amp;&amp; THREAD-&gt;can_call_java()
 478                &amp;&amp; appendix_result_or_null != NULL) {
 479       // This is a method with type-checking semantics.
 480       // We will ask Java code to spin an adapter method for it.
 481       if (!MethodHandles::enabled()) {
 482         // Make sure the Java part of the runtime has been booted up.
 483         Klass* natives = SystemDictionary::MethodHandleNatives_klass();
 484         if (natives == NULL || InstanceKlass::cast(natives)-&gt;is_not_initialized()) {
 485           SystemDictionary::resolve_or_fail(vmSymbols::java_lang_invoke_MethodHandleNatives(),
 486                                             Handle(),
 487                                             Handle(),
 488                                             true,
 489                                             CHECK_NULL);
 490         }
 491       }
 492 
 493       Handle appendix;
 494       Handle method_type;
 495       Method* result = SystemDictionary::find_method_handle_invoker(
 496                                                             klass,
 497                                                             name,
 498                                                             full_signature,
 499                                                             link_info.current_klass(),
 500                                                             &amp;appendix,
 501                                                             CHECK_NULL);
<span class="line-modified"> 502       if (lt_mh.is_enabled()) {</span>
<span class="line-modified"> 503         LogStream ls(lt_mh);</span>
<span class="line-modified"> 504         ls.print(&quot;lookup_polymorphic_method =&gt; (via Java) &quot;);</span>
<span class="line-modified"> 505         result-&gt;print_on(&amp;ls);</span>
<span class="line-modified"> 506         ls.print(&quot;  lookup_polymorphic_method =&gt; appendix = &quot;);</span>
<span class="line-modified"> 507         appendix.is_null() ? ls.print_cr(&quot;(none)&quot;) : appendix-&gt;print_on(&amp;ls);</span>

 508       }
 509       if (result != NULL) {
 510 #ifdef ASSERT
 511         ResourceMark rm(THREAD);
 512 
 513         TempNewSymbol basic_signature =
 514           MethodHandles::lookup_basic_type_signature(full_signature, CHECK_NULL);
 515         int actual_size_of_params = result-&gt;size_of_parameters();
 516         int expected_size_of_params = ArgumentSizeComputer(basic_signature).size();
 517         // +1 for MethodHandle.this, +1 for trailing MethodType
 518         if (!MethodHandles::is_signature_polymorphic_static(iid))  expected_size_of_params += 1;
 519         if (appendix.not_null())                                   expected_size_of_params += 1;
 520         if (actual_size_of_params != expected_size_of_params) {
 521           tty-&gt;print_cr(&quot;*** basic_signature=%s&quot;, basic_signature-&gt;as_C_string());
 522           tty-&gt;print_cr(&quot;*** result for %s: &quot;, vmIntrinsics::name_at(iid));
 523           result-&gt;print();
 524         }
 525         assert(actual_size_of_params == expected_size_of_params,
 526                &quot;%d != %d&quot;, actual_size_of_params, expected_size_of_params);
 527 #endif //ASSERT
</pre>
<hr />
<pre>
1647 void LinkResolver::resolve_invokevirtual(CallInfo&amp; result, Handle recv,
1648                                           const constantPoolHandle&amp; pool, int index,
1649                                           TRAPS) {
1650 
1651   LinkInfo link_info(pool, index, CHECK);
1652   Klass* recvrKlass = recv.is_null() ? (Klass*)NULL : recv-&gt;klass();
1653   resolve_virtual_call(result, recv, recvrKlass, link_info, /*check_null_or_abstract*/true, CHECK);
1654 }
1655 
1656 
1657 void LinkResolver::resolve_invokeinterface(CallInfo&amp; result, Handle recv, const constantPoolHandle&amp; pool, int index, TRAPS) {
1658   LinkInfo link_info(pool, index, CHECK);
1659   Klass* recvrKlass = recv.is_null() ? (Klass*)NULL : recv-&gt;klass();
1660   resolve_interface_call(result, recv, recvrKlass, link_info, true, CHECK);
1661 }
1662 
1663 
1664 void LinkResolver::resolve_invokehandle(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
1665   // This guy is reached from InterpreterRuntime::resolve_invokehandle.
1666   LinkInfo link_info(pool, index, CHECK);
<span class="line-modified">1667   if (log_is_enabled(Info, methodhandles)) {</span>
1668     ResourceMark rm(THREAD);
<span class="line-modified">1669     log_info(methodhandles)(&quot;resolve_invokehandle %s %s&quot;, link_info.name()-&gt;as_C_string(),</span>
<span class="line-modified">1670                             link_info.signature()-&gt;as_C_string());</span>
1671   }
1672   resolve_handle_call(result, link_info, CHECK);
1673 }
1674 
1675 void LinkResolver::resolve_handle_call(CallInfo&amp; result,
1676                                        const LinkInfo&amp; link_info,
1677                                        TRAPS) {
1678   // JSR 292:  this must be an implicitly generated method MethodHandle.invokeExact(*...) or similar
1679   Klass* resolved_klass = link_info.resolved_klass();
1680   assert(resolved_klass == SystemDictionary::MethodHandle_klass() ||
1681          resolved_klass == SystemDictionary::VarHandle_klass(), &quot;&quot;);
1682   assert(MethodHandles::is_signature_polymorphic_name(link_info.name()), &quot;&quot;);
1683   Handle       resolved_appendix;
1684   Method* resolved_method = lookup_polymorphic_method(link_info, &amp;resolved_appendix, CHECK);
1685   result.set_handle(resolved_klass, methodHandle(THREAD, resolved_method), resolved_appendix, CHECK);
1686 }
1687 
1688 void LinkResolver::resolve_invokedynamic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int indy_index, TRAPS) {
1689   ConstantPoolCacheEntry* cpce = pool-&gt;invokedynamic_cp_cache_entry_at(indy_index);
1690   int pool_index = cpce-&gt;constant_pool_index();
1691 
1692   // Resolve the bootstrap specifier (BSM + optional arguments).
1693   BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);
1694 
1695   // Check if CallSite has been bound already or failed already, and short circuit:
1696   {
1697     bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);
1698     if (is_done) return;
1699   }
1700 
1701   // The initial step in Call Site Specifier Resolution is to resolve the symbolic
1702   // reference to a method handle which will be the bootstrap method for a dynamic
1703   // call site.  If resolution for the java.lang.invoke.MethodHandle for the bootstrap
1704   // method fails, then a MethodHandleInError is stored at the corresponding bootstrap
1705   // method&#39;s CP index for the CONSTANT_MethodHandle_info.  So, there is no need to
1706   // set the indy_rf flag since any subsequent invokedynamic instruction which shares
1707   // this bootstrap method will encounter the resolution of MethodHandleInError.
1708 
1709   resolve_dynamic_call(result, bootstrap_specifier, CHECK);
1710 
<span class="line-modified">1711   LogTarget(Debug, methodhandles, indy) lt_indy;</span>
<span class="line-modified">1712   if (lt_indy.is_enabled()) {</span>
<span class="line-added">1713     LogStream ls(lt_indy);</span>
<span class="line-added">1714     bootstrap_specifier.print_msg_on(&amp;ls, &quot;resolve_invokedynamic&quot;);</span>
1715   }
1716 
1717   // The returned linkage result is provisional up to the moment
1718   // the interpreter or runtime performs a serialized check of
1719   // the relevant CPCE::f1 field.  This is done by the caller
1720   // of this method, via CPCE::set_dynamic_call, which uses
1721   // an ObjectLocker to do the final serialization of updates
1722   // to CPCE state, including f1.
1723 }
1724 
1725 void LinkResolver::resolve_dynamic_call(CallInfo&amp; result,
1726                                         BootstrapInfo&amp; bootstrap_specifier,
1727                                         TRAPS) {
1728   // JSR 292:  this must resolve to an implicitly generated method
1729   // such as MH.linkToCallSite(*...) or some other call-site shape.
1730   // The appendix argument is likely to be a freshly-created CallSite.
1731   // It may also be a MethodHandle from an unwrapped ConstantCallSite,
1732   // or any other reference.  The resolved_method as well as the appendix
1733   // are both recorded together via CallInfo::set_handle.
1734   SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
<span class="line-modified">1735   Exceptions::wrap_dynamic_exception(/* is_indy */ true, THREAD);</span>
1736 
1737   if (HAS_PENDING_EXCEPTION) {
1738     if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {
1739       // Let any random low-level IE or SOE or OOME just bleed through.
1740       // Basically we pretend that the bootstrap method was never called,
1741       // if it fails this way:  We neither record a successful linkage,
1742       // nor do we memorize a LE for posterity.
1743       return;
1744     }
1745     // JVMS 5.4.3 says: If an attempt by the Java Virtual Machine to resolve
1746     // a symbolic reference fails because an error is thrown that is an
1747     // instance of LinkageError (or a subclass), then subsequent attempts to
1748     // resolve the reference always fail with the same error that was thrown
1749     // as a result of the initial resolution attempt.
1750      bool recorded_res_status = bootstrap_specifier.save_and_throw_indy_exc(CHECK);
1751      if (!recorded_res_status) {
1752        // Another thread got here just before we did.  So, either use the method
1753        // that it resolved or throw the LinkageError exception that it threw.
1754        bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);
1755        if (is_done) return;
</pre>
</td>
</tr>
</table>
<center><a href="bootstrapInfo.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../jvmci/jvmciRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
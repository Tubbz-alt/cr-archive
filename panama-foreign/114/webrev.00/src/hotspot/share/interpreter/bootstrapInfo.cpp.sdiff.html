<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/bootstrapInfo.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../gc/shenandoah/shenandoahUtils.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/bootstrapInfo.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 48     // derived and eagerly cached:
 49     _argc(      pool-&gt;bootstrap_argument_count_at(bss_index) ),
 50     _name(      pool-&gt;uncached_name_ref_at(bss_index) ),
 51     _signature( pool-&gt;uncached_signature_ref_at(bss_index) )
 52 {
 53   _is_resolved = false;
 54   assert(pool-&gt;tag_at(bss_index).has_bootstrap(), &quot;&quot;);
 55   assert(indy_index == -1 || pool-&gt;invokedynamic_bootstrap_ref_index_at(indy_index) == bss_index, &quot;invalid bootstrap specifier index&quot;);
 56 }
 57 
 58 // If there is evidence this call site was already linked, set the
 59 // existing linkage data into result, or throw previous exception.
 60 // Return true if either action is taken, else false.
 61 bool BootstrapInfo::resolve_previously_linked_invokedynamic(CallInfo&amp; result, TRAPS) {
 62   assert(_indy_index != -1, &quot;&quot;);
 63   ConstantPoolCacheEntry* cpce = invokedynamic_cp_cache_entry();
 64   if (!cpce-&gt;is_f1_null()) {
 65     methodHandle method(     THREAD, cpce-&gt;f1_as_method());
 66     Handle       appendix(   THREAD, cpce-&gt;appendix_if_resolved(_pool));
 67     result.set_handle(method, appendix, THREAD);
<span class="line-modified"> 68     Exceptions::wrap_dynamic_exception(CHECK_false);</span>
 69     return true;
 70   } else if (cpce-&gt;indy_resolution_failed()) {
 71     int encoded_index = ResolutionErrorTable::encode_cpcache_index(_indy_index);
 72     ConstantPool::throw_resolution_error(_pool, encoded_index, CHECK_false);
 73     return true;
 74   } else {
 75     return false;
 76   }
 77 }
 78 
 79 // Resolve the bootstrap specifier in 3 steps:
 80 // - unpack the BSM by resolving the MH constant
 81 // - obtain the NameAndType description for the condy/indy
 82 // - prepare the BSM&#39;s static arguments
 83 Handle BootstrapInfo::resolve_bsm(TRAPS) {
<span class="line-modified"> 84   if (_bsm.not_null())  return _bsm;</span>




 85   // The tag at the bootstrap method index must be a valid method handle or a method handle in error.
 86   // If it is a MethodHandleInError, a resolution error will be thrown which will be wrapped if necessary
 87   // with a BootstrapMethodError.
 88   assert(_pool-&gt;tag_at(bsm_index()).is_method_handle() ||
 89          _pool-&gt;tag_at(bsm_index()).is_method_handle_in_error(), &quot;MH not present, classfile structural constraint&quot;);
 90   oop bsm_oop = _pool-&gt;resolve_possibly_cached_constant_at(bsm_index(), THREAD);
<span class="line-modified"> 91   Exceptions::wrap_dynamic_exception(CHECK_NH);</span>
 92   guarantee(java_lang_invoke_MethodHandle::is_instance(bsm_oop), &quot;classfile must supply a valid BSM&quot;);
 93   _bsm = Handle(THREAD, bsm_oop);
 94 
 95   // Obtain NameAndType information
 96   resolve_bss_name_and_type(THREAD);
<span class="line-modified"> 97   Exceptions::wrap_dynamic_exception(CHECK_NH);</span>
 98 
 99   // Prepare static arguments
100   resolve_args(THREAD);
<span class="line-modified">101   Exceptions::wrap_dynamic_exception(CHECK_NH);</span>
102 
103   return _bsm;
104 }
105 
106 // Resolve metadata from the JVM_Dynamic_info or JVM_InvokeDynamic_info&#39;s name and type information.
107 void BootstrapInfo::resolve_bss_name_and_type(TRAPS) {
108   assert(_bsm.not_null(), &quot;resolve_bsm first&quot;);
109   Symbol* name = this-&gt;name();
110   Symbol* type = this-&gt;signature();
111   _name_arg = java_lang_String::create_from_symbol(name, CHECK);
112   if (type-&gt;char_at(0) == &#39;(&#39;) {
113     _type_arg = SystemDictionary::find_method_handle_type(type, caller(), CHECK);
114   } else {
115     _type_arg = SystemDictionary::find_java_mirror_for_type(type, caller(), SignatureStream::NCDFError, CHECK);
116   }
117 }
118 
119 // Resolve the bootstrap method&#39;s static arguments and store the result in _arg_values.
120 void BootstrapInfo::resolve_args(TRAPS) {
121   assert(_bsm.not_null(), &quot;resolve_bsm first&quot;);
</pre>
<hr />
<pre>
236                 _signature-&gt;as_C_string(),
237                 (_type_arg.is_null() ? &quot;&quot; : &quot;(resolved)&quot;),
238                 bsms_attr_index(),
239                 bsm_index(), (_bsm.is_null() ? &quot;&quot; : &quot;(resolved)&quot;),
240                 _argc, (_arg_values.is_null() ? &quot;&quot; : &quot;(resolved)&quot;));
241   if (_argc &gt; 0) {
242     char argbuf[80];
243     argbuf[0] = 0;
244     for (int i = 0; i &lt; _argc; i++) {
245       int pos = (int) strlen(argbuf);
246       if (pos + 20 &gt; (int)sizeof(argbuf)) {
247         sprintf(argbuf + pos, &quot;...&quot;);
248         break;
249       }
250       if (i &gt; 0)  argbuf[pos++] = &#39;,&#39;;
251       sprintf(argbuf+pos, &quot;%d&quot;, arg_index(i));
252     }
253     st-&gt;print_cr(&quot;  argument indexes: {%s}&quot;, argbuf);
254   }
255   if (_bsm.not_null()) {
<span class="line-modified">256     st-&gt;print(&quot;  resolved BSM: &quot;); _bsm-&gt;print();</span>
257   }
258 
259   // How the array of resolved arguments is printed depends highly
260   // on how BootstrapInfo::resolve_args structures the array based on
261   // the use_BSCI setting.
262   if (_arg_values.not_null()) {
263     // Find the static arguments within the first element of _arg_values.
264     objArrayOop static_args = (objArrayOop)_arg_values();
265     if (!static_args-&gt;is_array()) {
266       assert(_argc == 1, &quot;Invalid BSM _arg_values for non-array&quot;);
<span class="line-modified">267       st-&gt;print(&quot;  resolved arg[0]: &quot;); static_args-&gt;print();</span>
268     } else if (static_args-&gt;is_objArray()) {
269       int lines = 0;
270       for (int i = 0; i &lt; _argc; i++) {
271         oop x = static_args-&gt;obj_at(i);
272         if (x != NULL) {
273           if (++lines &gt; 6) {
274             st-&gt;print_cr(&quot;  resolved arg[%d]: ...&quot;, i);
275             break;
276           }
<span class="line-modified">277           st-&gt;print(&quot;  resolved arg[%d]: &quot;, i); x-&gt;print();</span>
278         }
279       }
280     } else if (static_args-&gt;is_typeArray()) {
281       typeArrayOop tmp_array = (typeArrayOop) static_args;
282       assert(tmp_array-&gt;length() == 2, &quot;Invalid BSM _arg_values type array&quot;);
283       st-&gt;print_cr(&quot;  resolved arg[0]: %d&quot;, tmp_array-&gt;int_at(0));
284       st-&gt;print_cr(&quot;  resolved arg[1]: %d&quot;, tmp_array-&gt;int_at(1));
285     }
286   }
287 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 48     // derived and eagerly cached:
 49     _argc(      pool-&gt;bootstrap_argument_count_at(bss_index) ),
 50     _name(      pool-&gt;uncached_name_ref_at(bss_index) ),
 51     _signature( pool-&gt;uncached_signature_ref_at(bss_index) )
 52 {
 53   _is_resolved = false;
 54   assert(pool-&gt;tag_at(bss_index).has_bootstrap(), &quot;&quot;);
 55   assert(indy_index == -1 || pool-&gt;invokedynamic_bootstrap_ref_index_at(indy_index) == bss_index, &quot;invalid bootstrap specifier index&quot;);
 56 }
 57 
 58 // If there is evidence this call site was already linked, set the
 59 // existing linkage data into result, or throw previous exception.
 60 // Return true if either action is taken, else false.
 61 bool BootstrapInfo::resolve_previously_linked_invokedynamic(CallInfo&amp; result, TRAPS) {
 62   assert(_indy_index != -1, &quot;&quot;);
 63   ConstantPoolCacheEntry* cpce = invokedynamic_cp_cache_entry();
 64   if (!cpce-&gt;is_f1_null()) {
 65     methodHandle method(     THREAD, cpce-&gt;f1_as_method());
 66     Handle       appendix(   THREAD, cpce-&gt;appendix_if_resolved(_pool));
 67     result.set_handle(method, appendix, THREAD);
<span class="line-modified"> 68     Exceptions::wrap_dynamic_exception(/* is_indy */ true, CHECK_false);</span>
 69     return true;
 70   } else if (cpce-&gt;indy_resolution_failed()) {
 71     int encoded_index = ResolutionErrorTable::encode_cpcache_index(_indy_index);
 72     ConstantPool::throw_resolution_error(_pool, encoded_index, CHECK_false);
 73     return true;
 74   } else {
 75     return false;
 76   }
 77 }
 78 
 79 // Resolve the bootstrap specifier in 3 steps:
 80 // - unpack the BSM by resolving the MH constant
 81 // - obtain the NameAndType description for the condy/indy
 82 // - prepare the BSM&#39;s static arguments
 83 Handle BootstrapInfo::resolve_bsm(TRAPS) {
<span class="line-modified"> 84   if (_bsm.not_null()) {</span>
<span class="line-added"> 85     return _bsm;</span>
<span class="line-added"> 86   }</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88   bool is_indy = is_method_call();</span>
 89   // The tag at the bootstrap method index must be a valid method handle or a method handle in error.
 90   // If it is a MethodHandleInError, a resolution error will be thrown which will be wrapped if necessary
 91   // with a BootstrapMethodError.
 92   assert(_pool-&gt;tag_at(bsm_index()).is_method_handle() ||
 93          _pool-&gt;tag_at(bsm_index()).is_method_handle_in_error(), &quot;MH not present, classfile structural constraint&quot;);
 94   oop bsm_oop = _pool-&gt;resolve_possibly_cached_constant_at(bsm_index(), THREAD);
<span class="line-modified"> 95   Exceptions::wrap_dynamic_exception(is_indy, CHECK_NH);</span>
 96   guarantee(java_lang_invoke_MethodHandle::is_instance(bsm_oop), &quot;classfile must supply a valid BSM&quot;);
 97   _bsm = Handle(THREAD, bsm_oop);
 98 
 99   // Obtain NameAndType information
100   resolve_bss_name_and_type(THREAD);
<span class="line-modified">101   Exceptions::wrap_dynamic_exception(is_indy, CHECK_NH);</span>
102 
103   // Prepare static arguments
104   resolve_args(THREAD);
<span class="line-modified">105   Exceptions::wrap_dynamic_exception(is_indy, CHECK_NH);</span>
106 
107   return _bsm;
108 }
109 
110 // Resolve metadata from the JVM_Dynamic_info or JVM_InvokeDynamic_info&#39;s name and type information.
111 void BootstrapInfo::resolve_bss_name_and_type(TRAPS) {
112   assert(_bsm.not_null(), &quot;resolve_bsm first&quot;);
113   Symbol* name = this-&gt;name();
114   Symbol* type = this-&gt;signature();
115   _name_arg = java_lang_String::create_from_symbol(name, CHECK);
116   if (type-&gt;char_at(0) == &#39;(&#39;) {
117     _type_arg = SystemDictionary::find_method_handle_type(type, caller(), CHECK);
118   } else {
119     _type_arg = SystemDictionary::find_java_mirror_for_type(type, caller(), SignatureStream::NCDFError, CHECK);
120   }
121 }
122 
123 // Resolve the bootstrap method&#39;s static arguments and store the result in _arg_values.
124 void BootstrapInfo::resolve_args(TRAPS) {
125   assert(_bsm.not_null(), &quot;resolve_bsm first&quot;);
</pre>
<hr />
<pre>
240                 _signature-&gt;as_C_string(),
241                 (_type_arg.is_null() ? &quot;&quot; : &quot;(resolved)&quot;),
242                 bsms_attr_index(),
243                 bsm_index(), (_bsm.is_null() ? &quot;&quot; : &quot;(resolved)&quot;),
244                 _argc, (_arg_values.is_null() ? &quot;&quot; : &quot;(resolved)&quot;));
245   if (_argc &gt; 0) {
246     char argbuf[80];
247     argbuf[0] = 0;
248     for (int i = 0; i &lt; _argc; i++) {
249       int pos = (int) strlen(argbuf);
250       if (pos + 20 &gt; (int)sizeof(argbuf)) {
251         sprintf(argbuf + pos, &quot;...&quot;);
252         break;
253       }
254       if (i &gt; 0)  argbuf[pos++] = &#39;,&#39;;
255       sprintf(argbuf+pos, &quot;%d&quot;, arg_index(i));
256     }
257     st-&gt;print_cr(&quot;  argument indexes: {%s}&quot;, argbuf);
258   }
259   if (_bsm.not_null()) {
<span class="line-modified">260     st-&gt;print(&quot;  resolved BSM: &quot;); _bsm-&gt;print_on(st);</span>
261   }
262 
263   // How the array of resolved arguments is printed depends highly
264   // on how BootstrapInfo::resolve_args structures the array based on
265   // the use_BSCI setting.
266   if (_arg_values.not_null()) {
267     // Find the static arguments within the first element of _arg_values.
268     objArrayOop static_args = (objArrayOop)_arg_values();
269     if (!static_args-&gt;is_array()) {
270       assert(_argc == 1, &quot;Invalid BSM _arg_values for non-array&quot;);
<span class="line-modified">271       st-&gt;print(&quot;  resolved arg[0]: &quot;); static_args-&gt;print_on(st);</span>
272     } else if (static_args-&gt;is_objArray()) {
273       int lines = 0;
274       for (int i = 0; i &lt; _argc; i++) {
275         oop x = static_args-&gt;obj_at(i);
276         if (x != NULL) {
277           if (++lines &gt; 6) {
278             st-&gt;print_cr(&quot;  resolved arg[%d]: ...&quot;, i);
279             break;
280           }
<span class="line-modified">281           st-&gt;print(&quot;  resolved arg[%d]: &quot;, i); x-&gt;print_on(st);</span>
282         }
283       }
284     } else if (static_args-&gt;is_typeArray()) {
285       typeArrayOop tmp_array = (typeArrayOop) static_args;
286       assert(tmp_array-&gt;length() == 2, &quot;Invalid BSM _arg_values type array&quot;);
287       st-&gt;print_cr(&quot;  resolved arg[0]: %d&quot;, tmp_array-&gt;int_at(0));
288       st-&gt;print_cr(&quot;  resolved arg[1]: %d&quot;, tmp_array-&gt;int_at(1));
289     }
290   }
291 }
</pre>
</td>
</tr>
</table>
<center><a href="../gc/shenandoah/shenandoahUtils.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
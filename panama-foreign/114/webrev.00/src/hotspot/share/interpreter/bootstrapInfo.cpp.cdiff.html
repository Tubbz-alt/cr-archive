<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/interpreter/bootstrapInfo.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../gc/shenandoah/shenandoahUtils.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/bootstrapInfo.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,11 ***</span>
    ConstantPoolCacheEntry* cpce = invokedynamic_cp_cache_entry();
    if (!cpce-&gt;is_f1_null()) {
      methodHandle method(     THREAD, cpce-&gt;f1_as_method());
      Handle       appendix(   THREAD, cpce-&gt;appendix_if_resolved(_pool));
      result.set_handle(method, appendix, THREAD);
<span class="line-modified">!     Exceptions::wrap_dynamic_exception(CHECK_false);</span>
      return true;
    } else if (cpce-&gt;indy_resolution_failed()) {
      int encoded_index = ResolutionErrorTable::encode_cpcache_index(_indy_index);
      ConstantPool::throw_resolution_error(_pool, encoded_index, CHECK_false);
      return true;
<span class="line-new-header">--- 63,11 ---</span>
    ConstantPoolCacheEntry* cpce = invokedynamic_cp_cache_entry();
    if (!cpce-&gt;is_f1_null()) {
      methodHandle method(     THREAD, cpce-&gt;f1_as_method());
      Handle       appendix(   THREAD, cpce-&gt;appendix_if_resolved(_pool));
      result.set_handle(method, appendix, THREAD);
<span class="line-modified">!     Exceptions::wrap_dynamic_exception(/* is_indy */ true, CHECK_false);</span>
      return true;
    } else if (cpce-&gt;indy_resolution_failed()) {
      int encoded_index = ResolutionErrorTable::encode_cpcache_index(_indy_index);
      ConstantPool::throw_resolution_error(_pool, encoded_index, CHECK_false);
      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 79,28 ***</span>
  // Resolve the bootstrap specifier in 3 steps:
  // - unpack the BSM by resolving the MH constant
  // - obtain the NameAndType description for the condy/indy
  // - prepare the BSM&#39;s static arguments
  Handle BootstrapInfo::resolve_bsm(TRAPS) {
<span class="line-modified">!   if (_bsm.not_null())  return _bsm;</span>
    // The tag at the bootstrap method index must be a valid method handle or a method handle in error.
    // If it is a MethodHandleInError, a resolution error will be thrown which will be wrapped if necessary
    // with a BootstrapMethodError.
    assert(_pool-&gt;tag_at(bsm_index()).is_method_handle() ||
           _pool-&gt;tag_at(bsm_index()).is_method_handle_in_error(), &quot;MH not present, classfile structural constraint&quot;);
    oop bsm_oop = _pool-&gt;resolve_possibly_cached_constant_at(bsm_index(), THREAD);
<span class="line-modified">!   Exceptions::wrap_dynamic_exception(CHECK_NH);</span>
    guarantee(java_lang_invoke_MethodHandle::is_instance(bsm_oop), &quot;classfile must supply a valid BSM&quot;);
    _bsm = Handle(THREAD, bsm_oop);
  
    // Obtain NameAndType information
    resolve_bss_name_and_type(THREAD);
<span class="line-modified">!   Exceptions::wrap_dynamic_exception(CHECK_NH);</span>
  
    // Prepare static arguments
    resolve_args(THREAD);
<span class="line-modified">!   Exceptions::wrap_dynamic_exception(CHECK_NH);</span>
  
    return _bsm;
  }
  
  // Resolve metadata from the JVM_Dynamic_info or JVM_InvokeDynamic_info&#39;s name and type information.
<span class="line-new-header">--- 79,32 ---</span>
  // Resolve the bootstrap specifier in 3 steps:
  // - unpack the BSM by resolving the MH constant
  // - obtain the NameAndType description for the condy/indy
  // - prepare the BSM&#39;s static arguments
  Handle BootstrapInfo::resolve_bsm(TRAPS) {
<span class="line-modified">!   if (_bsm.not_null()) {</span>
<span class="line-added">+     return _bsm;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool is_indy = is_method_call();</span>
    // The tag at the bootstrap method index must be a valid method handle or a method handle in error.
    // If it is a MethodHandleInError, a resolution error will be thrown which will be wrapped if necessary
    // with a BootstrapMethodError.
    assert(_pool-&gt;tag_at(bsm_index()).is_method_handle() ||
           _pool-&gt;tag_at(bsm_index()).is_method_handle_in_error(), &quot;MH not present, classfile structural constraint&quot;);
    oop bsm_oop = _pool-&gt;resolve_possibly_cached_constant_at(bsm_index(), THREAD);
<span class="line-modified">!   Exceptions::wrap_dynamic_exception(is_indy, CHECK_NH);</span>
    guarantee(java_lang_invoke_MethodHandle::is_instance(bsm_oop), &quot;classfile must supply a valid BSM&quot;);
    _bsm = Handle(THREAD, bsm_oop);
  
    // Obtain NameAndType information
    resolve_bss_name_and_type(THREAD);
<span class="line-modified">!   Exceptions::wrap_dynamic_exception(is_indy, CHECK_NH);</span>
  
    // Prepare static arguments
    resolve_args(THREAD);
<span class="line-modified">!   Exceptions::wrap_dynamic_exception(is_indy, CHECK_NH);</span>
  
    return _bsm;
  }
  
  // Resolve metadata from the JVM_Dynamic_info or JVM_InvokeDynamic_info&#39;s name and type information.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 251,32 ***</span>
        sprintf(argbuf+pos, &quot;%d&quot;, arg_index(i));
      }
      st-&gt;print_cr(&quot;  argument indexes: {%s}&quot;, argbuf);
    }
    if (_bsm.not_null()) {
<span class="line-modified">!     st-&gt;print(&quot;  resolved BSM: &quot;); _bsm-&gt;print();</span>
    }
  
    // How the array of resolved arguments is printed depends highly
    // on how BootstrapInfo::resolve_args structures the array based on
    // the use_BSCI setting.
    if (_arg_values.not_null()) {
      // Find the static arguments within the first element of _arg_values.
      objArrayOop static_args = (objArrayOop)_arg_values();
      if (!static_args-&gt;is_array()) {
        assert(_argc == 1, &quot;Invalid BSM _arg_values for non-array&quot;);
<span class="line-modified">!       st-&gt;print(&quot;  resolved arg[0]: &quot;); static_args-&gt;print();</span>
      } else if (static_args-&gt;is_objArray()) {
        int lines = 0;
        for (int i = 0; i &lt; _argc; i++) {
          oop x = static_args-&gt;obj_at(i);
          if (x != NULL) {
            if (++lines &gt; 6) {
              st-&gt;print_cr(&quot;  resolved arg[%d]: ...&quot;, i);
              break;
            }
<span class="line-modified">!           st-&gt;print(&quot;  resolved arg[%d]: &quot;, i); x-&gt;print();</span>
          }
        }
      } else if (static_args-&gt;is_typeArray()) {
        typeArrayOop tmp_array = (typeArrayOop) static_args;
        assert(tmp_array-&gt;length() == 2, &quot;Invalid BSM _arg_values type array&quot;);
<span class="line-new-header">--- 255,32 ---</span>
        sprintf(argbuf+pos, &quot;%d&quot;, arg_index(i));
      }
      st-&gt;print_cr(&quot;  argument indexes: {%s}&quot;, argbuf);
    }
    if (_bsm.not_null()) {
<span class="line-modified">!     st-&gt;print(&quot;  resolved BSM: &quot;); _bsm-&gt;print_on(st);</span>
    }
  
    // How the array of resolved arguments is printed depends highly
    // on how BootstrapInfo::resolve_args structures the array based on
    // the use_BSCI setting.
    if (_arg_values.not_null()) {
      // Find the static arguments within the first element of _arg_values.
      objArrayOop static_args = (objArrayOop)_arg_values();
      if (!static_args-&gt;is_array()) {
        assert(_argc == 1, &quot;Invalid BSM _arg_values for non-array&quot;);
<span class="line-modified">!       st-&gt;print(&quot;  resolved arg[0]: &quot;); static_args-&gt;print_on(st);</span>
      } else if (static_args-&gt;is_objArray()) {
        int lines = 0;
        for (int i = 0; i &lt; _argc; i++) {
          oop x = static_args-&gt;obj_at(i);
          if (x != NULL) {
            if (++lines &gt; 6) {
              st-&gt;print_cr(&quot;  resolved arg[%d]: ...&quot;, i);
              break;
            }
<span class="line-modified">!           st-&gt;print(&quot;  resolved arg[%d]: &quot;, i); x-&gt;print_on(st);</span>
          }
        }
      } else if (static_args-&gt;is_typeArray()) {
        typeArrayOop tmp_array = (typeArrayOop) static_args;
        assert(tmp_array-&gt;length() == 2, &quot;Invalid BSM _arg_values type array&quot;);
</pre>
<center><a href="../gc/shenandoah/shenandoahUtils.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
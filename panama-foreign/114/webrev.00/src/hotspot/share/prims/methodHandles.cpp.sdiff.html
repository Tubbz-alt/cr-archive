<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/methodHandles.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../oops/oopsHierarchy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/methodHandles.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;code/codeCache.hpp&quot;
  30 #include &quot;code/dependencyContext.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/oopMapCache.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;


  35 #include &quot;memory/allocation.inline.hpp&quot;
  36 #include &quot;memory/oopFactory.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;oops/objArrayOop.inline.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  43 #include &quot;prims/methodHandles.hpp&quot;
  44 #include &quot;runtime/deoptimization.hpp&quot;
  45 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  46 #include &quot;runtime/handles.inline.hpp&quot;
  47 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  48 #include &quot;runtime/javaCalls.hpp&quot;
  49 #include &quot;runtime/jniHandles.inline.hpp&quot;
  50 #include &quot;runtime/timerTrace.hpp&quot;
  51 #include &quot;runtime/reflection.hpp&quot;
  52 #include &quot;runtime/safepointVerifiers.hpp&quot;
  53 #include &quot;runtime/signature.hpp&quot;
  54 #include &quot;runtime/stubRoutines.hpp&quot;
</pre>
<hr />
<pre>
 211     int slot   = java_lang_reflect_Constructor::slot(target_oop);
 212     Klass* k = java_lang_Class::as_Klass(clazz);
 213     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
 214       Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
 215       if (m == NULL)  return NULL;
 216       CallInfo info(m, k, CHECK_NULL);
 217       return init_method_MemberName(mname, info);
 218     }
 219   }
 220   return NULL;
 221 }
 222 
 223 oop MethodHandles::init_method_MemberName(Handle mname, CallInfo&amp; info) {
 224   assert(info.resolved_appendix().is_null(), &quot;only normal methods here&quot;);
 225   methodHandle m(Thread::current(), info.resolved_method());
 226   assert(m.not_null(), &quot;null method handle&quot;);
 227   InstanceKlass* m_klass = m-&gt;method_holder();
 228   assert(m_klass != NULL, &quot;null holder for method handle&quot;);
 229   int flags = (jushort)( m-&gt;access_flags().as_short() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS );
 230   int vmindex = Method::invalid_vtable_index;

 231 
 232   switch (info.call_kind()) {
 233   case CallInfo::itable_call:
 234     vmindex = info.itable_index();
 235     // More importantly, the itable index only works with the method holder.
 236     assert(m_klass-&gt;verify_itable_index(vmindex), &quot;&quot;);
 237     flags |= IS_METHOD | (JVM_REF_invokeInterface &lt;&lt; REFERENCE_KIND_SHIFT);
<span class="line-modified"> 238     if (TraceInvokeDynamic) {</span>
<span class="line-removed"> 239       ttyLocker ttyl;</span>
 240       ResourceMark rm;
<span class="line-modified"> 241       tty-&gt;print_cr(&quot;memberName: invokeinterface method_holder::method: %s, itableindex: %d, access_flags:&quot;,</span>
<span class="line-modified"> 242             Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),</span>
<span class="line-modified"> 243             vmindex);</span>
<span class="line-modified"> 244        m-&gt;access_flags().print_on(tty);</span>

 245        if (!m-&gt;is_abstract()) {
 246          if (!m-&gt;is_private()) {
<span class="line-modified"> 247            tty-&gt;print(&quot;default&quot;);</span>
 248          }
 249          else {
<span class="line-modified"> 250            tty-&gt;print(&quot;private-intf&quot;);</span>
 251          }
 252        }
<span class="line-modified"> 253        tty-&gt;cr();</span>
 254     }
 255     break;
 256 
 257   case CallInfo::vtable_call:
 258     vmindex = info.vtable_index();
 259     flags |= IS_METHOD | (JVM_REF_invokeVirtual &lt;&lt; REFERENCE_KIND_SHIFT);
 260     assert(info.resolved_klass()-&gt;is_subtype_of(m_klass), &quot;virtual call must be type-safe&quot;);
 261     if (m_klass-&gt;is_interface()) {
 262       // This is a vtable call to an interface method (abstract &quot;miranda method&quot; or default method).
 263       // The vtable index is meaningless without a class (not interface) receiver type, so get one.
 264       // (LinkResolver should help us figure this out.)
 265       assert(info.resolved_klass()-&gt;is_instance_klass(), &quot;subtype of interface must be an instance klass&quot;);
 266       InstanceKlass* m_klass_non_interface = InstanceKlass::cast(info.resolved_klass());
 267       if (m_klass_non_interface-&gt;is_interface()) {
 268         m_klass_non_interface = SystemDictionary::Object_klass();
 269 #ifdef ASSERT
 270         { ResourceMark rm;
 271           Method* m2 = m_klass_non_interface-&gt;vtable().method_at(vmindex);
 272           assert(m-&gt;name() == m2-&gt;name() &amp;&amp; m-&gt;signature() == m2-&gt;signature(),
 273                  &quot;at %d, %s != %s&quot;, vmindex,
 274                  m-&gt;name_and_sig_as_C_string(), m2-&gt;name_and_sig_as_C_string());
 275         }
 276 #endif //ASSERT
 277       }
 278       if (!m-&gt;is_public()) {
 279         assert(m-&gt;is_public(), &quot;virtual call must be to public interface method&quot;);
 280         return NULL;  // elicit an error later in product build
 281       }
 282       assert(info.resolved_klass()-&gt;is_subtype_of(m_klass_non_interface), &quot;virtual call must be type-safe&quot;);
 283       m_klass = m_klass_non_interface;
 284     }
<span class="line-modified"> 285     if (TraceInvokeDynamic) {</span>
<span class="line-removed"> 286       ttyLocker ttyl;</span>
 287       ResourceMark rm;
<span class="line-modified"> 288       tty-&gt;print_cr(&quot;memberName: invokevirtual method_holder::method: %s, receiver: %s, vtableindex: %d, access_flags:&quot;,</span>
<span class="line-modified"> 289             Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),</span>
<span class="line-modified"> 290             m_klass-&gt;internal_name(), vmindex);</span>
<span class="line-modified"> 291        m-&gt;access_flags().print_on(tty);</span>

 292        if (m-&gt;is_default_method()) {
<span class="line-modified"> 293          tty-&gt;print(&quot;default&quot;);</span>
 294        }
<span class="line-modified"> 295        tty-&gt;cr();</span>
 296     }
 297     break;
 298 
 299   case CallInfo::direct_call:
 300     vmindex = Method::nonvirtual_vtable_index;
 301     if (m-&gt;is_static()) {
 302       flags |= IS_METHOD      | (JVM_REF_invokeStatic  &lt;&lt; REFERENCE_KIND_SHIFT);
 303     } else if (m-&gt;is_initializer()) {
 304       flags |= IS_CONSTRUCTOR | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 305     } else {
 306       // &quot;special&quot; reflects that this is a direct call, not that it
 307       // necessarily originates from an invokespecial. We can also do
 308       // direct calls for private and/or final non-static methods.
 309       flags |= IS_METHOD      | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 310     }
 311     break;
 312 
 313   default:  assert(false, &quot;bad CallInfo&quot;);  return NULL;
 314   }
 315 
</pre>
<hr />
<pre>
1052 void MethodHandles::flush_dependent_nmethods(Handle call_site, Handle target) {
1053   assert_lock_strong(Compile_lock);
1054 
1055   int marked = 0;
1056   CallSiteDepChange changes(call_site, target);
1057   {
1058     NoSafepointVerifier nsv;
1059     MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1060 
1061     oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site());
1062     DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1063     marked = deps.mark_dependent_nmethods(changes);
1064   }
1065   if (marked &gt; 0) {
1066     // At least one nmethod has been marked for deoptimization.
1067     Deoptimization::deoptimize_all_marked();
1068   }
1069 }
1070 
1071 void MethodHandles::trace_method_handle_interpreter_entry(MacroAssembler* _masm, vmIntrinsics::ID iid) {
<span class="line-modified">1072   if (TraceMethodHandles) {</span>
1073     const char* name = vmIntrinsics::name_at(iid);
1074     if (*name == &#39;_&#39;)  name += 1;
1075     const size_t len = strlen(name) + 50;
1076     char* qname = NEW_C_HEAP_ARRAY(char, len, mtInternal);
1077     const char* suffix = &quot;&quot;;
1078     if (is_signature_polymorphic(iid)) {
1079       if (is_signature_polymorphic_static(iid))
1080         suffix = &quot;/static&quot;;
1081       else
1082         suffix = &quot;/private&quot;;
1083     }
1084     jio_snprintf(qname, len, &quot;MethodHandle::interpreter_entry::%s%s&quot;, name, suffix);
1085     trace_method_handle(_masm, qname);
1086     // Note:  Don&#39;t free the allocated char array because it&#39;s used
1087     // during runtime.
1088   }
1089 }
1090 
1091 //
1092 // Here are the native methods in java.lang.invoke.MethodHandleNatives
</pre>
<hr />
<pre>
1538  */
1539 JVM_ENTRY(void, JVM_RegisterMethodHandleMethods(JNIEnv *env, jclass MHN_class)) {
1540   assert(!MethodHandles::enabled(), &quot;must not be enabled&quot;);
1541   assert(SystemDictionary::MethodHandle_klass() != NULL, &quot;should be present&quot;);
1542 
1543   oop mirror = SystemDictionary::MethodHandle_klass()-&gt;java_mirror();
1544   jclass MH_class = (jclass) JNIHandles::make_local(env, mirror);
1545 
1546   {
1547     ThreadToNativeFromVM ttnfv(thread);
1548 
1549     int status = env-&gt;RegisterNatives(MHN_class, MHN_methods, sizeof(MHN_methods)/sizeof(JNINativeMethod));
1550     guarantee(status == JNI_OK &amp;&amp; !env-&gt;ExceptionOccurred(),
1551               &quot;register java.lang.invoke.MethodHandleNative natives&quot;);
1552 
1553     status = env-&gt;RegisterNatives(MH_class, MH_methods, sizeof(MH_methods)/sizeof(JNINativeMethod));
1554     guarantee(status == JNI_OK &amp;&amp; !env-&gt;ExceptionOccurred(),
1555               &quot;register java.lang.invoke.MethodHandle natives&quot;);
1556   }
1557 
<span class="line-modified">1558   if (TraceInvokeDynamic) {</span>
<span class="line-removed">1559     tty-&gt;print_cr(&quot;MethodHandle support loaded (using LambdaForms)&quot;);</span>
<span class="line-removed">1560   }</span>
1561 
1562   MethodHandles::set_enabled(true);
1563 }
1564 JVM_END
</pre>
</td>
<td>
<hr />
<pre>
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;code/codeCache.hpp&quot;
  30 #include &quot;code/dependencyContext.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/oopMapCache.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
<span class="line-added">  35 #include &quot;logging/log.hpp&quot;</span>
<span class="line-added">  36 #include &quot;logging/logStream.hpp&quot;</span>
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/oopFactory.hpp&quot;
  39 #include &quot;memory/resourceArea.hpp&quot;
  40 #include &quot;memory/universe.hpp&quot;
  41 #include &quot;oops/objArrayKlass.hpp&quot;
  42 #include &quot;oops/objArrayOop.inline.hpp&quot;
  43 #include &quot;oops/oop.inline.hpp&quot;
  44 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  45 #include &quot;prims/methodHandles.hpp&quot;
  46 #include &quot;runtime/deoptimization.hpp&quot;
  47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;
  49 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  50 #include &quot;runtime/javaCalls.hpp&quot;
  51 #include &quot;runtime/jniHandles.inline.hpp&quot;
  52 #include &quot;runtime/timerTrace.hpp&quot;
  53 #include &quot;runtime/reflection.hpp&quot;
  54 #include &quot;runtime/safepointVerifiers.hpp&quot;
  55 #include &quot;runtime/signature.hpp&quot;
  56 #include &quot;runtime/stubRoutines.hpp&quot;
</pre>
<hr />
<pre>
 213     int slot   = java_lang_reflect_Constructor::slot(target_oop);
 214     Klass* k = java_lang_Class::as_Klass(clazz);
 215     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
 216       Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
 217       if (m == NULL)  return NULL;
 218       CallInfo info(m, k, CHECK_NULL);
 219       return init_method_MemberName(mname, info);
 220     }
 221   }
 222   return NULL;
 223 }
 224 
 225 oop MethodHandles::init_method_MemberName(Handle mname, CallInfo&amp; info) {
 226   assert(info.resolved_appendix().is_null(), &quot;only normal methods here&quot;);
 227   methodHandle m(Thread::current(), info.resolved_method());
 228   assert(m.not_null(), &quot;null method handle&quot;);
 229   InstanceKlass* m_klass = m-&gt;method_holder();
 230   assert(m_klass != NULL, &quot;null holder for method handle&quot;);
 231   int flags = (jushort)( m-&gt;access_flags().as_short() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS );
 232   int vmindex = Method::invalid_vtable_index;
<span class="line-added"> 233   LogTarget(Debug, methodhandles, indy) lt_indy;</span>
 234 
 235   switch (info.call_kind()) {
 236   case CallInfo::itable_call:
 237     vmindex = info.itable_index();
 238     // More importantly, the itable index only works with the method holder.
 239     assert(m_klass-&gt;verify_itable_index(vmindex), &quot;&quot;);
 240     flags |= IS_METHOD | (JVM_REF_invokeInterface &lt;&lt; REFERENCE_KIND_SHIFT);
<span class="line-modified"> 241     if (lt_indy.is_enabled()) {</span>

 242       ResourceMark rm;
<span class="line-modified"> 243       LogStream ls(lt_indy);</span>
<span class="line-modified"> 244       ls.print_cr(&quot;memberName: invokeinterface method_holder::method: %s, itableindex: %d, access_flags:&quot;,</span>
<span class="line-modified"> 245                   Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),</span>
<span class="line-modified"> 246                   vmindex);</span>
<span class="line-added"> 247        m-&gt;access_flags().print_on(&amp;ls);</span>
 248        if (!m-&gt;is_abstract()) {
 249          if (!m-&gt;is_private()) {
<span class="line-modified"> 250            ls.print(&quot;default&quot;);</span>
 251          }
 252          else {
<span class="line-modified"> 253            ls.print(&quot;private-intf&quot;);</span>
 254          }
 255        }
<span class="line-modified"> 256        ls.cr();</span>
 257     }
 258     break;
 259 
 260   case CallInfo::vtable_call:
 261     vmindex = info.vtable_index();
 262     flags |= IS_METHOD | (JVM_REF_invokeVirtual &lt;&lt; REFERENCE_KIND_SHIFT);
 263     assert(info.resolved_klass()-&gt;is_subtype_of(m_klass), &quot;virtual call must be type-safe&quot;);
 264     if (m_klass-&gt;is_interface()) {
 265       // This is a vtable call to an interface method (abstract &quot;miranda method&quot; or default method).
 266       // The vtable index is meaningless without a class (not interface) receiver type, so get one.
 267       // (LinkResolver should help us figure this out.)
 268       assert(info.resolved_klass()-&gt;is_instance_klass(), &quot;subtype of interface must be an instance klass&quot;);
 269       InstanceKlass* m_klass_non_interface = InstanceKlass::cast(info.resolved_klass());
 270       if (m_klass_non_interface-&gt;is_interface()) {
 271         m_klass_non_interface = SystemDictionary::Object_klass();
 272 #ifdef ASSERT
 273         { ResourceMark rm;
 274           Method* m2 = m_klass_non_interface-&gt;vtable().method_at(vmindex);
 275           assert(m-&gt;name() == m2-&gt;name() &amp;&amp; m-&gt;signature() == m2-&gt;signature(),
 276                  &quot;at %d, %s != %s&quot;, vmindex,
 277                  m-&gt;name_and_sig_as_C_string(), m2-&gt;name_and_sig_as_C_string());
 278         }
 279 #endif //ASSERT
 280       }
 281       if (!m-&gt;is_public()) {
 282         assert(m-&gt;is_public(), &quot;virtual call must be to public interface method&quot;);
 283         return NULL;  // elicit an error later in product build
 284       }
 285       assert(info.resolved_klass()-&gt;is_subtype_of(m_klass_non_interface), &quot;virtual call must be type-safe&quot;);
 286       m_klass = m_klass_non_interface;
 287     }
<span class="line-modified"> 288     if (lt_indy.is_enabled()) {</span>

 289       ResourceMark rm;
<span class="line-modified"> 290       LogStream ls(lt_indy);</span>
<span class="line-modified"> 291       ls.print_cr(&quot;memberName: invokevirtual method_holder::method: %s, receiver: %s, vtableindex: %d, access_flags:&quot;,</span>
<span class="line-modified"> 292                   Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),</span>
<span class="line-modified"> 293                   m_klass-&gt;internal_name(), vmindex);</span>
<span class="line-added"> 294        m-&gt;access_flags().print_on(&amp;ls);</span>
 295        if (m-&gt;is_default_method()) {
<span class="line-modified"> 296          ls.print(&quot;default&quot;);</span>
 297        }
<span class="line-modified"> 298        ls.cr();</span>
 299     }
 300     break;
 301 
 302   case CallInfo::direct_call:
 303     vmindex = Method::nonvirtual_vtable_index;
 304     if (m-&gt;is_static()) {
 305       flags |= IS_METHOD      | (JVM_REF_invokeStatic  &lt;&lt; REFERENCE_KIND_SHIFT);
 306     } else if (m-&gt;is_initializer()) {
 307       flags |= IS_CONSTRUCTOR | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 308     } else {
 309       // &quot;special&quot; reflects that this is a direct call, not that it
 310       // necessarily originates from an invokespecial. We can also do
 311       // direct calls for private and/or final non-static methods.
 312       flags |= IS_METHOD      | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 313     }
 314     break;
 315 
 316   default:  assert(false, &quot;bad CallInfo&quot;);  return NULL;
 317   }
 318 
</pre>
<hr />
<pre>
1055 void MethodHandles::flush_dependent_nmethods(Handle call_site, Handle target) {
1056   assert_lock_strong(Compile_lock);
1057 
1058   int marked = 0;
1059   CallSiteDepChange changes(call_site, target);
1060   {
1061     NoSafepointVerifier nsv;
1062     MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1063 
1064     oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site());
1065     DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1066     marked = deps.mark_dependent_nmethods(changes);
1067   }
1068   if (marked &gt; 0) {
1069     // At least one nmethod has been marked for deoptimization.
1070     Deoptimization::deoptimize_all_marked();
1071   }
1072 }
1073 
1074 void MethodHandles::trace_method_handle_interpreter_entry(MacroAssembler* _masm, vmIntrinsics::ID iid) {
<span class="line-modified">1075   if (log_is_enabled(Info, methodhandles)) {</span>
1076     const char* name = vmIntrinsics::name_at(iid);
1077     if (*name == &#39;_&#39;)  name += 1;
1078     const size_t len = strlen(name) + 50;
1079     char* qname = NEW_C_HEAP_ARRAY(char, len, mtInternal);
1080     const char* suffix = &quot;&quot;;
1081     if (is_signature_polymorphic(iid)) {
1082       if (is_signature_polymorphic_static(iid))
1083         suffix = &quot;/static&quot;;
1084       else
1085         suffix = &quot;/private&quot;;
1086     }
1087     jio_snprintf(qname, len, &quot;MethodHandle::interpreter_entry::%s%s&quot;, name, suffix);
1088     trace_method_handle(_masm, qname);
1089     // Note:  Don&#39;t free the allocated char array because it&#39;s used
1090     // during runtime.
1091   }
1092 }
1093 
1094 //
1095 // Here are the native methods in java.lang.invoke.MethodHandleNatives
</pre>
<hr />
<pre>
1541  */
1542 JVM_ENTRY(void, JVM_RegisterMethodHandleMethods(JNIEnv *env, jclass MHN_class)) {
1543   assert(!MethodHandles::enabled(), &quot;must not be enabled&quot;);
1544   assert(SystemDictionary::MethodHandle_klass() != NULL, &quot;should be present&quot;);
1545 
1546   oop mirror = SystemDictionary::MethodHandle_klass()-&gt;java_mirror();
1547   jclass MH_class = (jclass) JNIHandles::make_local(env, mirror);
1548 
1549   {
1550     ThreadToNativeFromVM ttnfv(thread);
1551 
1552     int status = env-&gt;RegisterNatives(MHN_class, MHN_methods, sizeof(MHN_methods)/sizeof(JNINativeMethod));
1553     guarantee(status == JNI_OK &amp;&amp; !env-&gt;ExceptionOccurred(),
1554               &quot;register java.lang.invoke.MethodHandleNative natives&quot;);
1555 
1556     status = env-&gt;RegisterNatives(MH_class, MH_methods, sizeof(MH_methods)/sizeof(JNINativeMethod));
1557     guarantee(status == JNI_OK &amp;&amp; !env-&gt;ExceptionOccurred(),
1558               &quot;register java.lang.invoke.MethodHandle natives&quot;);
1559   }
1560 
<span class="line-modified">1561   log_debug(methodhandles, indy)(&quot;MethodHandle support loaded (using LambdaForms)&quot;);</span>


1562 
1563   MethodHandles::set_enabled(true);
1564 }
1565 JVM_END
</pre>
</td>
</tr>
</table>
<center><a href="../oops/oopsHierarchy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/prims/methodHandles.cpp b/src/hotspot/share/prims/methodHandles.cpp
--- a/src/hotspot/share/prims/methodHandles.cpp
+++ b/src/hotspot/share/prims/methodHandles.cpp
@@ -30,10 +30,12 @@
 #include "code/dependencyContext.hpp"
 #include "compiler/compileBroker.hpp"
 #include "interpreter/interpreter.hpp"
 #include "interpreter/oopMapCache.hpp"
 #include "interpreter/linkResolver.hpp"
+#include "logging/log.hpp"
+#include "logging/logStream.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
 #include "oops/objArrayKlass.hpp"
@@ -226,33 +228,34 @@
   assert(m.not_null(), "null method handle");
   InstanceKlass* m_klass = m->method_holder();
   assert(m_klass != NULL, "null holder for method handle");
   int flags = (jushort)( m->access_flags().as_short() & JVM_RECOGNIZED_METHOD_MODIFIERS );
   int vmindex = Method::invalid_vtable_index;
+  LogTarget(Debug, methodhandles, indy) lt_indy;
 
   switch (info.call_kind()) {
   case CallInfo::itable_call:
     vmindex = info.itable_index();
     // More importantly, the itable index only works with the method holder.
     assert(m_klass->verify_itable_index(vmindex), "");
     flags |= IS_METHOD | (JVM_REF_invokeInterface << REFERENCE_KIND_SHIFT);
-    if (TraceInvokeDynamic) {
-      ttyLocker ttyl;
+    if (lt_indy.is_enabled()) {
       ResourceMark rm;
-      tty->print_cr("memberName: invokeinterface method_holder::method: %s, itableindex: %d, access_flags:",
-            Method::name_and_sig_as_C_string(m->method_holder(), m->name(), m->signature()),
-            vmindex);
-       m->access_flags().print_on(tty);
+      LogStream ls(lt_indy);
+      ls.print_cr("memberName: invokeinterface method_holder::method: %s, itableindex: %d, access_flags:",
+                  Method::name_and_sig_as_C_string(m->method_holder(), m->name(), m->signature()),
+                  vmindex);
+       m->access_flags().print_on(&ls);
        if (!m->is_abstract()) {
          if (!m->is_private()) {
-           tty->print("default");
+           ls.print("default");
          }
          else {
-           tty->print("private-intf");
+           ls.print("private-intf");
          }
        }
-       tty->cr();
+       ls.cr();
     }
     break;
 
   case CallInfo::vtable_call:
     vmindex = info.vtable_index();
@@ -280,21 +283,21 @@
         return NULL;  // elicit an error later in product build
       }
       assert(info.resolved_klass()->is_subtype_of(m_klass_non_interface), "virtual call must be type-safe");
       m_klass = m_klass_non_interface;
     }
-    if (TraceInvokeDynamic) {
-      ttyLocker ttyl;
+    if (lt_indy.is_enabled()) {
       ResourceMark rm;
-      tty->print_cr("memberName: invokevirtual method_holder::method: %s, receiver: %s, vtableindex: %d, access_flags:",
-            Method::name_and_sig_as_C_string(m->method_holder(), m->name(), m->signature()),
-            m_klass->internal_name(), vmindex);
-       m->access_flags().print_on(tty);
+      LogStream ls(lt_indy);
+      ls.print_cr("memberName: invokevirtual method_holder::method: %s, receiver: %s, vtableindex: %d, access_flags:",
+                  Method::name_and_sig_as_C_string(m->method_holder(), m->name(), m->signature()),
+                  m_klass->internal_name(), vmindex);
+       m->access_flags().print_on(&ls);
        if (m->is_default_method()) {
-         tty->print("default");
+         ls.print("default");
        }
-       tty->cr();
+       ls.cr();
     }
     break;
 
   case CallInfo::direct_call:
     vmindex = Method::nonvirtual_vtable_index;
@@ -1067,11 +1070,11 @@
     Deoptimization::deoptimize_all_marked();
   }
 }
 
 void MethodHandles::trace_method_handle_interpreter_entry(MacroAssembler* _masm, vmIntrinsics::ID iid) {
-  if (TraceMethodHandles) {
+  if (log_is_enabled(Info, methodhandles)) {
     const char* name = vmIntrinsics::name_at(iid);
     if (*name == '_')  name += 1;
     const size_t len = strlen(name) + 50;
     char* qname = NEW_C_HEAP_ARRAY(char, len, mtInternal);
     const char* suffix = "";
@@ -1553,12 +1556,10 @@
     status = env->RegisterNatives(MH_class, MH_methods, sizeof(MH_methods)/sizeof(JNINativeMethod));
     guarantee(status == JNI_OK && !env->ExceptionOccurred(),
               "register java.lang.invoke.MethodHandle natives");
   }
 
-  if (TraceInvokeDynamic) {
-    tty->print_cr("MethodHandle support loaded (using LambdaForms)");
-  }
+  log_debug(methodhandles, indy)("MethodHandle support loaded (using LambdaForms)");
 
   MethodHandles::set_enabled(true);
 }
 JVM_END

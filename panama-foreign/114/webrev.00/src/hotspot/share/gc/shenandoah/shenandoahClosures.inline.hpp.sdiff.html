<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahClosures.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahCodeRoots.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahClosures.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 71 template &lt;class T&gt;
 72 void ShenandoahUpdateRefsClosure::do_oop_work(T* p) {
 73   T o = RawAccess&lt;&gt;::oop_load(p);
 74   if (!CompressedOops::is_null(o)) {
 75     oop obj = CompressedOops::decode_not_null(o);
 76     _heap-&gt;update_with_forwarded_not_null(p, obj);
 77   }
 78 }
 79 
 80 void ShenandoahUpdateRefsClosure::do_oop(oop* p)       { do_oop_work(p); }
 81 void ShenandoahUpdateRefsClosure::do_oop(narrowOop* p) { do_oop_work(p); }
 82 
 83 template &lt;DecoratorSet MO&gt;
 84 ShenandoahEvacuateUpdateRootsClosure&lt;MO&gt;::ShenandoahEvacuateUpdateRootsClosure() :
 85   _heap(ShenandoahHeap::heap()), _thread(Thread::current()) {
 86 }
 87 
 88 template &lt;DecoratorSet MO&gt;
 89 template &lt;class T&gt;
 90 void ShenandoahEvacuateUpdateRootsClosure&lt;MO&gt;::do_oop_work(T* p) {
<span class="line-modified"> 91   assert(_heap-&gt;is_concurrent_root_in_progress(), &quot;Only do this when evacuation is in progress&quot;);</span>


 92 
 93   T o = RawAccess&lt;&gt;::oop_load(p);
 94   if (! CompressedOops::is_null(o)) {
 95     oop obj = CompressedOops::decode_not_null(o);
 96     if (_heap-&gt;in_collection_set(obj)) {
 97       assert(_heap-&gt;is_evacuation_in_progress(), &quot;Only do this when evacuation is in progress&quot;);
 98       shenandoah_assert_marked(p, obj);
 99       oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
100       if (resolved == obj) {
101         resolved = _heap-&gt;evacuate_object(obj, _thread);
102       }
103       RawAccess&lt;IS_NOT_NULL | MO&gt;::oop_store(p, resolved);
104     }
105   }
106 }
107 template &lt;DecoratorSet MO&gt;
108 void ShenandoahEvacuateUpdateRootsClosure&lt;MO&gt;::do_oop(oop* p) {
109   do_oop_work(p);
110 }
111 
112 template &lt;DecoratorSet MO&gt;
113 void ShenandoahEvacuateUpdateRootsClosure&lt;MO&gt;::do_oop(narrowOop* p) {
114   do_oop_work(p);
115 }
116 
117 ShenandoahEvacUpdateOopStorageRootsClosure::ShenandoahEvacUpdateOopStorageRootsClosure() :
118   _heap(ShenandoahHeap::heap()), _thread(Thread::current()) {
119 }
120 
121 void ShenandoahEvacUpdateOopStorageRootsClosure::do_oop(oop* p) {
<span class="line-modified">122   assert(_heap-&gt;is_concurrent_root_in_progress(), &quot;Only do this when evacuation is in progress&quot;);</span>


123 
124   oop obj = RawAccess&lt;&gt;::oop_load(p);
125   if (! CompressedOops::is_null(obj)) {
126     if (_heap-&gt;in_collection_set(obj)) {
127       assert(_heap-&gt;is_evacuation_in_progress(), &quot;Only do this when evacuation is in progress&quot;);
128       shenandoah_assert_marked(p, obj);
129       oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
130       if (resolved == obj) {
131         resolved = _heap-&gt;evacuate_object(obj, _thread);
132       }
133 
134       Atomic::cmpxchg(p, obj, resolved);
135     }
136   }
137 }
138 
139 void ShenandoahEvacUpdateOopStorageRootsClosure::do_oop(narrowOop* p) {
140   ShouldNotReachHere();
141 }
142 
</pre>
</td>
<td>
<hr />
<pre>
 71 template &lt;class T&gt;
 72 void ShenandoahUpdateRefsClosure::do_oop_work(T* p) {
 73   T o = RawAccess&lt;&gt;::oop_load(p);
 74   if (!CompressedOops::is_null(o)) {
 75     oop obj = CompressedOops::decode_not_null(o);
 76     _heap-&gt;update_with_forwarded_not_null(p, obj);
 77   }
 78 }
 79 
 80 void ShenandoahUpdateRefsClosure::do_oop(oop* p)       { do_oop_work(p); }
 81 void ShenandoahUpdateRefsClosure::do_oop(narrowOop* p) { do_oop_work(p); }
 82 
 83 template &lt;DecoratorSet MO&gt;
 84 ShenandoahEvacuateUpdateRootsClosure&lt;MO&gt;::ShenandoahEvacuateUpdateRootsClosure() :
 85   _heap(ShenandoahHeap::heap()), _thread(Thread::current()) {
 86 }
 87 
 88 template &lt;DecoratorSet MO&gt;
 89 template &lt;class T&gt;
 90 void ShenandoahEvacuateUpdateRootsClosure&lt;MO&gt;::do_oop_work(T* p) {
<span class="line-modified"> 91   assert(_heap-&gt;is_concurrent_weak_root_in_progress() ||</span>
<span class="line-added"> 92          _heap-&gt;is_concurrent_strong_root_in_progress(),</span>
<span class="line-added"> 93          &quot;Only do this in root processing phase&quot;);</span>
 94 
 95   T o = RawAccess&lt;&gt;::oop_load(p);
 96   if (! CompressedOops::is_null(o)) {
 97     oop obj = CompressedOops::decode_not_null(o);
 98     if (_heap-&gt;in_collection_set(obj)) {
 99       assert(_heap-&gt;is_evacuation_in_progress(), &quot;Only do this when evacuation is in progress&quot;);
100       shenandoah_assert_marked(p, obj);
101       oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
102       if (resolved == obj) {
103         resolved = _heap-&gt;evacuate_object(obj, _thread);
104       }
105       RawAccess&lt;IS_NOT_NULL | MO&gt;::oop_store(p, resolved);
106     }
107   }
108 }
109 template &lt;DecoratorSet MO&gt;
110 void ShenandoahEvacuateUpdateRootsClosure&lt;MO&gt;::do_oop(oop* p) {
111   do_oop_work(p);
112 }
113 
114 template &lt;DecoratorSet MO&gt;
115 void ShenandoahEvacuateUpdateRootsClosure&lt;MO&gt;::do_oop(narrowOop* p) {
116   do_oop_work(p);
117 }
118 
119 ShenandoahEvacUpdateOopStorageRootsClosure::ShenandoahEvacUpdateOopStorageRootsClosure() :
120   _heap(ShenandoahHeap::heap()), _thread(Thread::current()) {
121 }
122 
123 void ShenandoahEvacUpdateOopStorageRootsClosure::do_oop(oop* p) {
<span class="line-modified">124   assert(_heap-&gt;is_concurrent_weak_root_in_progress() ||</span>
<span class="line-added">125          _heap-&gt;is_concurrent_strong_root_in_progress(),</span>
<span class="line-added">126          &quot;Only do this in root processing phase&quot;);</span>
127 
128   oop obj = RawAccess&lt;&gt;::oop_load(p);
129   if (! CompressedOops::is_null(obj)) {
130     if (_heap-&gt;in_collection_set(obj)) {
131       assert(_heap-&gt;is_evacuation_in_progress(), &quot;Only do this when evacuation is in progress&quot;);
132       shenandoah_assert_marked(p, obj);
133       oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
134       if (resolved == obj) {
135         resolved = _heap-&gt;evacuate_object(obj, _thread);
136       }
137 
138       Atomic::cmpxchg(p, obj, resolved);
139     }
140   }
141 }
142 
143 void ShenandoahEvacUpdateOopStorageRootsClosure::do_oop(narrowOop* p) {
144   ShouldNotReachHere();
145 }
146 
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahBarrierSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahCodeRoots.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../shared/taskqueue.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahClosures.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
176       gclab-&gt;retire();
177     }
178   }
179 }
180 
181 oop ShenandoahBarrierSet::load_reference_barrier_native(oop obj, oop* load_addr) {
182   return load_reference_barrier_native_impl(obj, load_addr);
183 }
184 
185 oop ShenandoahBarrierSet::load_reference_barrier_native(oop obj, narrowOop* load_addr) {
186   return load_reference_barrier_native_impl(obj, load_addr);
187 }
188 
189 template &lt;class T&gt;
190 oop ShenandoahBarrierSet::load_reference_barrier_native_impl(oop obj, T* load_addr) {
191   if (CompressedOops::is_null(obj)) {
192     return NULL;
193   }
194 
195   ShenandoahMarkingContext* const marking_context = _heap-&gt;marking_context();
<span class="line-modified">196   if (_heap-&gt;is_concurrent_root_in_progress() &amp;&amp; !marking_context-&gt;is_marked(obj)) {</span>
197     Thread* thr = Thread::current();
198     if (thr-&gt;is_Java_thread()) {
199       return NULL;
200     } else {
201       return obj;
202     }
203   }
204 
205   oop fwd = load_reference_barrier_not_null(obj);
206   if (load_addr != NULL &amp;&amp; fwd != obj) {
207     // Since we are here and we know the load address, update the reference.
208     ShenandoahHeap::cas_oop(fwd, load_addr, obj);
209   }
210 
211   return fwd;
212 }
213 
214 void ShenandoahBarrierSet::clone_barrier_runtime(oop src) {
215   if (_heap-&gt;has_forwarded_objects() || (ShenandoahStoreValEnqueueBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress())) {
216     clone_barrier(src);
</pre>
</td>
<td>
<hr />
<pre>
176       gclab-&gt;retire();
177     }
178   }
179 }
180 
181 oop ShenandoahBarrierSet::load_reference_barrier_native(oop obj, oop* load_addr) {
182   return load_reference_barrier_native_impl(obj, load_addr);
183 }
184 
185 oop ShenandoahBarrierSet::load_reference_barrier_native(oop obj, narrowOop* load_addr) {
186   return load_reference_barrier_native_impl(obj, load_addr);
187 }
188 
189 template &lt;class T&gt;
190 oop ShenandoahBarrierSet::load_reference_barrier_native_impl(oop obj, T* load_addr) {
191   if (CompressedOops::is_null(obj)) {
192     return NULL;
193   }
194 
195   ShenandoahMarkingContext* const marking_context = _heap-&gt;marking_context();
<span class="line-modified">196   if (_heap-&gt;is_concurrent_weak_root_in_progress() &amp;&amp; !marking_context-&gt;is_marked(obj)) {</span>
197     Thread* thr = Thread::current();
198     if (thr-&gt;is_Java_thread()) {
199       return NULL;
200     } else {
201       return obj;
202     }
203   }
204 
205   oop fwd = load_reference_barrier_not_null(obj);
206   if (load_addr != NULL &amp;&amp; fwd != obj) {
207     // Since we are here and we know the load address, update the reference.
208     ShenandoahHeap::cas_oop(fwd, load_addr, obj);
209   }
210 
211   return fwd;
212 }
213 
214 void ShenandoahBarrierSet::clone_barrier_runtime(oop src) {
215   if (_heap-&gt;has_forwarded_objects() || (ShenandoahStoreValEnqueueBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress())) {
216     clone_barrier(src);
</pre>
</td>
</tr>
</table>
<center><a href="../shared/taskqueue.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahClosures.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
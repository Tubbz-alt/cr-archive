<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahFreeSet.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -485,11 +485,10 @@</span>
    _collection_set(NULL)
  {
    _heap = this;
  
    log_info(gc, init)(&quot;GC threads: &quot; UINT32_FORMAT &quot; parallel, &quot; UINT32_FORMAT &quot; concurrent&quot;, ParallelGCThreads, ConcGCThreads);
<span class="udiff-line-removed">-   log_info(gc, init)(&quot;Reference processing: %s&quot;, ParallelRefProcEnabled ? &quot;parallel&quot; : &quot;serial&quot;);</span>
  
    BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this));
  
    _max_workers = MAX2(_max_workers, 1U);
    _workers = new ShenandoahWorkGang(&quot;Shenandoah GC Threads&quot;, _max_workers,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -553,18 +552,20 @@</span>
                 num_regions(),
                 byte_size_in_proper_unit(ShenandoahHeapRegion::region_size_bytes()),
                 proper_unit_for_byte_size(ShenandoahHeapRegion::region_size_bytes()));
  
    st-&gt;print(&quot;Status: &quot;);
<span class="udiff-line-modified-removed">-   if (has_forwarded_objects())               st-&gt;print(&quot;has forwarded objects, &quot;);</span>
<span class="udiff-line-modified-removed">-   if (is_concurrent_mark_in_progress())      st-&gt;print(&quot;marking, &quot;);</span>
<span class="udiff-line-modified-removed">-   if (is_evacuation_in_progress())           st-&gt;print(&quot;evacuating, &quot;);</span>
<span class="udiff-line-modified-removed">-   if (is_update_refs_in_progress())          st-&gt;print(&quot;updating refs, &quot;);</span>
<span class="udiff-line-modified-removed">-   if (is_degenerated_gc_in_progress())       st-&gt;print(&quot;degenerated gc, &quot;);</span>
<span class="udiff-line-modified-removed">-   if (is_full_gc_in_progress())              st-&gt;print(&quot;full gc, &quot;);</span>
<span class="udiff-line-modified-removed">-   if (is_full_gc_move_in_progress())         st-&gt;print(&quot;full gc move, &quot;);</span>
<span class="udiff-line-modified-removed">-   if (is_concurrent_root_in_progress())      st-&gt;print(&quot;concurrent roots, &quot;);</span>
<span class="udiff-line-modified-added">+   if (has_forwarded_objects())                 st-&gt;print(&quot;has forwarded objects, &quot;);</span>
<span class="udiff-line-modified-added">+   if (is_concurrent_mark_in_progress())        st-&gt;print(&quot;marking, &quot;);</span>
<span class="udiff-line-modified-added">+   if (is_evacuation_in_progress())             st-&gt;print(&quot;evacuating, &quot;);</span>
<span class="udiff-line-modified-added">+   if (is_update_refs_in_progress())            st-&gt;print(&quot;updating refs, &quot;);</span>
<span class="udiff-line-modified-added">+   if (is_degenerated_gc_in_progress())         st-&gt;print(&quot;degenerated gc, &quot;);</span>
<span class="udiff-line-modified-added">+   if (is_full_gc_in_progress())                st-&gt;print(&quot;full gc, &quot;);</span>
<span class="udiff-line-modified-added">+   if (is_full_gc_move_in_progress())           st-&gt;print(&quot;full gc move, &quot;);</span>
<span class="udiff-line-modified-added">+   if (is_concurrent_weak_root_in_progress())   st-&gt;print(&quot;concurrent weak roots, &quot;);</span>
<span class="udiff-line-added">+   if (is_concurrent_strong_root_in_progress() &amp;&amp;</span>
<span class="udiff-line-added">+       !is_concurrent_weak_root_in_progress())  st-&gt;print(&quot;concurrent strong roots, &quot;);</span>
  
    if (cancelled_gc()) {
      st-&gt;print(&quot;cancelled&quot;);
    } else {
      st-&gt;print(&quot;not cancelled&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1232,11 +1233,11 @@</span>
    template &lt;class T&gt;
    void do_oop_work(T* p) {
      T o = RawAccess&lt;&gt;::oop_load(p);
      if (!CompressedOops::is_null(o)) {
        oop obj = CompressedOops::decode_not_null(o);
<span class="udiff-line-modified-removed">-       if (_heap-&gt;is_concurrent_root_in_progress() &amp;&amp; !_marking_context-&gt;is_marked(obj)) {</span>
<span class="udiff-line-modified-added">+       if (_heap-&gt;is_concurrent_weak_root_in_progress() &amp;&amp; !_marking_context-&gt;is_marked(obj)) {</span>
          // There may be dead oops in weak roots in concurrent root phase, do not touch them.
          return;
        }
        obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1374,15 +1375,18 @@</span>
    ShenandoahMarkingContext* const _ctx;
  public:
    ShenandoahInitMarkUpdateRegionStateClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}
  
    void heap_region_do(ShenandoahHeapRegion* r) {
<span class="udiff-line-added">+     assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;index());</span>
      if (r-&gt;is_active()) {
<span class="udiff-line-modified-removed">-       r-&gt;clear_live_data();</span>
<span class="udiff-line-modified-removed">-       _ctx-&gt;capture_top_at_mark_start(r);</span>
<span class="udiff-line-modified-added">+       // Check if region needs updating its TAMS. We have updated it already during concurrent</span>
<span class="udiff-line-modified-added">+       // reset, so it is very likely we don&#39;t need to do another write here.</span>
<span class="udiff-line-added">+       if (_ctx-&gt;top_at_mark_start(r) != r-&gt;top()) {</span>
<span class="udiff-line-added">+         _ctx-&gt;capture_top_at_mark_start(r);</span>
<span class="udiff-line-added">+       }</span>
      } else {
<span class="udiff-line-removed">-       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;index());</span>
        assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
               &quot;Region &quot; SIZE_FORMAT &quot; should already have correct TAMS&quot;, r-&gt;index());
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1627,32 +1631,25 @@</span>
  }
  
  class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {
  private:
    ShenandoahVMRoots&lt;true /*concurrent*/&gt;        _vm_roots;
<span class="udiff-line-removed">-   ShenandoahWeakRoots&lt;true /*concurrent*/&gt;      _weak_roots;</span>
    ShenandoahClassLoaderDataRoots&lt;true /*concurrent*/, false /*single threaded*/&gt; _cld_roots;
    ShenandoahConcurrentStringDedupRoots          _dedup_roots;
<span class="udiff-line-removed">-   bool                                          _include_weak_roots;</span>
  
  public:
<span class="udiff-line-modified-removed">-   ShenandoahConcurrentRootsEvacUpdateTask(bool include_weak_roots) :</span>
<span class="udiff-line-modified-removed">-     AbstractGangTask(&quot;Shenandoah Evacuate/Update Concurrent Roots Task&quot;),</span>
<span class="udiff-line-removed">-     _include_weak_roots(include_weak_roots) {</span>
<span class="udiff-line-modified-added">+   ShenandoahConcurrentRootsEvacUpdateTask() :</span>
<span class="udiff-line-modified-added">+     AbstractGangTask(&quot;Shenandoah Evacuate/Update Concurrent Strong Roots Task&quot;) {</span>
    }
  
    void work(uint worker_id) {
      ShenandoahEvacOOMScope oom;
      {
        // vm_roots and weak_roots are OopStorage backed roots, concurrent iteration
        // may race against OopStorage::release() calls.
        ShenandoahEvacUpdateOopStorageRootsClosure cl;
        _vm_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl);
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if (_include_weak_roots) {</span>
<span class="udiff-line-removed">-         _weak_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl);</span>
<span class="udiff-line-removed">-       }</span>
      }
  
      {
        ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
        CLDToOopClosure clds(&amp;cl, ClassLoaderData::_claim_strong);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1767,34 +1764,56 @@</span>
      _resolved_method_table_roots.oops_do(&amp;cl, worker_id);
      ResolvedMethodTable::inc_dead_counter(cl.dead_counter());
    }
  };
  
<span class="udiff-line-modified-removed">- void ShenandoahHeap::op_roots() {</span>
<span class="udiff-line-modified-removed">-   if (is_concurrent_root_in_progress()) {</span>
<span class="udiff-line-modified-removed">-     if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="udiff-line-modified-removed">-       // Concurrent weak root processing</span>
<span class="udiff-line-modified-removed">-       ShenandoahConcurrentWeakRootsEvacUpdateTask task;</span>
<span class="udiff-line-removed">-       workers()-&gt;run_task(&amp;task);</span>
<span class="udiff-line-modified-added">+ void ShenandoahHeap::op_weak_roots() {</span>
<span class="udiff-line-modified-added">+   if (is_concurrent_weak_root_in_progress()) {</span>
<span class="udiff-line-modified-added">+     // Concurrent weak root processing</span>
<span class="udiff-line-modified-added">+     ShenandoahConcurrentWeakRootsEvacUpdateTask task;</span>
<span class="udiff-line-modified-added">+     workers()-&gt;run_task(&amp;task);</span>
  
<span class="udiff-line-added">+     if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
        _unloader.unload();
      }
<span class="udiff-line-added">+     set_concurrent_weak_root_in_progress(false);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ShenandoahHeap::op_strong_roots() {</span>
<span class="udiff-line-added">+   assert(is_concurrent_strong_root_in_progress(), &quot;Checked by caller&quot;);</span>
<span class="udiff-line-added">+   ShenandoahConcurrentRootsEvacUpdateTask task;</span>
<span class="udiff-line-added">+   workers()-&gt;run_task(&amp;task);</span>
<span class="udiff-line-added">+   set_concurrent_strong_root_in_progress(false);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ class ShenandoahResetUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {</span>
<span class="udiff-line-added">+ private:</span>
<span class="udiff-line-added">+   ShenandoahMarkingContext* const _ctx;</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   ShenandoahResetUpdateRegionStateClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}</span>
  
<span class="udiff-line-modified-removed">-     if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {</span>
<span class="udiff-line-modified-removed">-       ShenandoahConcurrentRootsEvacUpdateTask task(!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="udiff-line-modified-removed">-       workers()-&gt;run_task(&amp;task);</span>
<span class="udiff-line-modified-added">+   void heap_region_do(ShenandoahHeapRegion* r) {</span>
<span class="udiff-line-modified-added">+     if (r-&gt;is_active()) {</span>
<span class="udiff-line-modified-added">+       // Reset live data and set TAMS optimistically. We would recheck these under the pause</span>
<span class="udiff-line-added">+       // anyway to capture any updates that happened since now.</span>
<span class="udiff-line-added">+       r-&gt;clear_live_data();</span>
<span class="udiff-line-added">+       _ctx-&gt;capture_top_at_mark_start(r);</span>
      }
    }
  
<span class="udiff-line-modified-removed">-   set_concurrent_root_in_progress(false);</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-added">+   bool is_thread_safe() { return true; }</span>
<span class="udiff-line-modified-added">+ };</span>
  
  void ShenandoahHeap::op_reset() {
    if (ShenandoahPacing) {
      pacer()-&gt;setup_for_reset();
    }
    reset_mark_bitmap();
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ShenandoahResetUpdateRegionStateClosure cl;</span>
<span class="udiff-line-added">+   parallel_heap_region_iterate(&amp;cl);</span>
  }
  
  void ShenandoahHeap::op_preclean() {
    if (ShenandoahPacing) {
      pacer()-&gt;setup_for_preclean();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2012,32 +2031,48 @@</span>
  void ShenandoahHeap::set_evacuation_in_progress(bool in_progress) {
    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only call this at safepoint&quot;);
    set_gc_state_mask(EVACUATION, in_progress);
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahHeap::set_concurrent_root_in_progress(bool in_progress) {</span>
<span class="udiff-line-modified-added">+ void ShenandoahHeap::set_concurrent_strong_root_in_progress(bool in_progress) {</span>
<span class="udiff-line-added">+   assert(ShenandoahConcurrentRoots::can_do_concurrent_roots(), &quot;Why set the flag?&quot;);</span>
<span class="udiff-line-added">+   if (in_progress) {</span>
<span class="udiff-line-added">+     _concurrent_strong_root_in_progress.set();</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     _concurrent_strong_root_in_progress.unset();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ShenandoahHeap::set_concurrent_weak_root_in_progress(bool in_progress) {</span>
    assert(ShenandoahConcurrentRoots::can_do_concurrent_roots(), &quot;Why set the flag?&quot;);
    if (in_progress) {
<span class="udiff-line-modified-removed">-     _concurrent_root_in_progress.set();</span>
<span class="udiff-line-modified-added">+     _concurrent_weak_root_in_progress.set();</span>
    } else {
<span class="udiff-line-modified-removed">-     _concurrent_root_in_progress.unset();</span>
<span class="udiff-line-modified-added">+     _concurrent_weak_root_in_progress.unset();</span>
    }
  }
  
  void ShenandoahHeap::ref_processing_init() {
    assert(_max_workers &gt; 0, &quot;Sanity&quot;);
  
<span class="udiff-line-added">+   bool mt_processing = ParallelRefProcEnabled &amp;&amp; (ParallelGCThreads &gt; 1);</span>
<span class="udiff-line-added">+   bool mt_discovery = _max_workers &gt; 1;</span>
<span class="udiff-line-added">+ </span>
    _ref_processor =
      new ReferenceProcessor(&amp;_subject_to_discovery,  // is_subject_to_discovery
<span class="udiff-line-modified-removed">-                            ParallelRefProcEnabled,  // MT processing</span>
<span class="udiff-line-modified-added">+                            mt_processing,           // MT processing</span>
                             _max_workers,            // Degree of MT processing
<span class="udiff-line-modified-removed">-                            true,                    // MT discovery</span>
<span class="udiff-line-modified-added">+                            mt_discovery,            // MT discovery</span>
                             _max_workers,            // Degree of MT discovery
                             false,                   // Reference discovery is not atomic
                             NULL,                    // No closure, should be installed before use
                             true);                   // Scale worker threads
  
<span class="udiff-line-added">+   log_info(gc, init)(&quot;Reference processing: %s discovery, %s processing&quot;,</span>
<span class="udiff-line-added">+           mt_discovery ? &quot;parallel&quot; : &quot;serial&quot;,</span>
<span class="udiff-line-added">+           mt_processing ? &quot;parallel&quot; : &quot;serial&quot;);</span>
<span class="udiff-line-added">+ </span>
    shenandoah_assert_rp_isalive_not_installed();
  }
  
  GCTracer* ShenandoahHeap::tracer() {
    return shenandoah_policy()-&gt;tracer();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2291,11 +2326,12 @@</span>
  }
  
  void ShenandoahHeap::prepare_concurrent_roots() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
    if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {
<span class="udiff-line-modified-removed">-     set_concurrent_root_in_progress(true);</span>
<span class="udiff-line-modified-added">+     set_concurrent_strong_root_in_progress(!collection_set()-&gt;is_empty());</span>
<span class="udiff-line-added">+     set_concurrent_weak_root_in_progress(true);</span>
    }
  }
  
  void ShenandoahHeap::prepare_concurrent_unloading() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2718,11 +2754,11 @@</span>
    op_final_updaterefs();
  }
  
  void ShenandoahHeap::entry_full(GCCause::Cause cause) {
    static const char* msg = &quot;Pause Full&quot;;
<span class="udiff-line-modified-removed">-   ShenandoahPausePhase gc_phase(msg);</span>
<span class="udiff-line-modified-added">+   ShenandoahPausePhase gc_phase(msg, true /* log_heap_usage */);</span>
    EventMark em(&quot;%s&quot;, msg);
  
    ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
    ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2734,11 +2770,11 @@</span>
  }
  
  void ShenandoahHeap::entry_degenerated(int point) {
    ShenandoahDegenPoint dpoint = (ShenandoahDegenPoint)point;
    const char* msg = degen_event_message(dpoint);
<span class="udiff-line-modified-removed">-   ShenandoahPausePhase gc_phase(msg);</span>
<span class="udiff-line-modified-added">+   ShenandoahPausePhase gc_phase(msg, true /* log_heap_usage */);</span>
    EventMark em(&quot;%s&quot;, msg);
  
    ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
    ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2798,23 +2834,38 @@</span>
  
    try_inject_alloc_failure();
    op_updaterefs();
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahHeap::entry_roots() {</span>
<span class="udiff-line-modified-removed">-   static const char* msg = &quot;Concurrent roots processing&quot;;</span>
<span class="udiff-line-modified-added">+ void ShenandoahHeap::entry_weak_roots() {</span>
<span class="udiff-line-modified-added">+   static const char* msg = &quot;Concurrent weak roots&quot;;</span>
    ShenandoahConcurrentPhase gc_phase(msg);
    EventMark em(&quot;%s&quot;, msg);
  
<span class="udiff-line-modified-removed">-   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_roots);</span>
<span class="udiff-line-modified-added">+   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_weak_roots);</span>
  
    ShenandoahWorkerScope scope(workers(),
                                ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
<span class="udiff-line-modified-removed">-                               &quot;concurrent root processing&quot;);</span>
<span class="udiff-line-modified-added">+                               &quot;concurrent weak root&quot;);</span>
  
    try_inject_alloc_failure();
<span class="udiff-line-modified-removed">-   op_roots();</span>
<span class="udiff-line-modified-added">+   op_weak_roots();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ShenandoahHeap::entry_strong_roots() {</span>
<span class="udiff-line-added">+   static const char* msg = &quot;Concurrent strong roots&quot;;</span>
<span class="udiff-line-added">+   ShenandoahConcurrentPhase gc_phase(msg);</span>
<span class="udiff-line-added">+   EventMark em(&quot;%s&quot;, msg);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_strong_roots);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ShenandoahWorkerScope scope(workers(),</span>
<span class="udiff-line-added">+                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),</span>
<span class="udiff-line-added">+                               &quot;concurrent strong root&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   try_inject_alloc_failure();</span>
<span class="udiff-line-added">+   op_strong_roots();</span>
  }
  
  void ShenandoahHeap::entry_cleanup() {
    static const char* msg = &quot;Concurrent cleanup&quot;;
    ShenandoahConcurrentPhase gc_phase(msg,  true /* log_heap_usage */);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2861,11 +2912,11 @@</span>
    }
  }
  
  void ShenandoahHeap::entry_uncommit(double shrink_before) {
    static const char *msg = &quot;Concurrent uncommit&quot;;
<span class="udiff-line-modified-removed">-   ShenandoahConcurrentPhase gc_phase(msg);</span>
<span class="udiff-line-modified-added">+   ShenandoahConcurrentPhase gc_phase(msg, true /* log_heap_usage */);</span>
    EventMark em(&quot;%s&quot;, msg);
  
    ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::conc_uncommit);
  
    op_uncommit(shrink_before);
</pre>
<center><a href="shenandoahFreeSet.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
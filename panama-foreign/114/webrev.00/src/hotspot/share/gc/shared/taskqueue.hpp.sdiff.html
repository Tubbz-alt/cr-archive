<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/taskqueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../g1/heapRegionManager.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="taskqueue.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/taskqueue.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
189   bool peek()     const { return _bottom != _age.top(); }
190   bool is_empty() const { return size() == 0; }
191 
192   // Return an estimate of the number of elements in the queue.
193   // The &quot;careful&quot; version admits the possibility of pop_local/pop_global
194   // races.
195   uint size() const {
196     return size(_bottom, _age.top());
197   }
198 
199   uint dirty_size() const {
200     return dirty_size(_bottom, _age.top());
201   }
202 
203   void set_empty() {
204     _bottom = 0;
205     _age.set(0);
206   }
207 
208   // Maximum number of elements allowed in the queue.  This is two less
<span class="line-modified">209   // than the actual queue size, for somewhat complicated reasons.</span>


210   uint max_elems() const { return N - 2; }
211 
212   // Total size of queue.
213   static const uint total_size() { return N; }
214 
215   TASKQUEUE_STATS_ONLY(TaskQueueStats stats;)
216 };
217 
218 //
219 // GenericTaskQueue implements an ABP, Aurora-Blumofe-Plaxton, double-
220 // ended-queue (deque), intended for use in work stealing. Queue operations
221 // are non-blocking.
222 //
223 // A queue owner thread performs push() and pop_local() operations on one end
224 // of the queue, while other threads may steal work using the pop_global()
225 // method.
226 //
227 // The main difference to the original algorithm is that this
228 // implementation allows wrap-around at the end of its allocated
229 // storage, which is an array.
</pre>
<hr />
<pre>
250 class GenericTaskQueue: public TaskQueueSuper&lt;N, F&gt; {
251 protected:
252   typedef typename TaskQueueSuper&lt;N, F&gt;::Age Age;
253   typedef typename TaskQueueSuper&lt;N, F&gt;::idx_t idx_t;
254 
255   using TaskQueueSuper&lt;N, F&gt;::_bottom;
256   using TaskQueueSuper&lt;N, F&gt;::_age;
257   using TaskQueueSuper&lt;N, F&gt;::increment_index;
258   using TaskQueueSuper&lt;N, F&gt;::decrement_index;
259   using TaskQueueSuper&lt;N, F&gt;::dirty_size;
260 
261 public:
262   using TaskQueueSuper&lt;N, F&gt;::max_elems;
263   using TaskQueueSuper&lt;N, F&gt;::size;
264 
265 #if  TASKQUEUE_STATS
266   using TaskQueueSuper&lt;N, F&gt;::stats;
267 #endif
268 
269 private:
<span class="line-modified">270   // Slow paths for push, pop_local.  (pop_global has no fast path.)</span>
<span class="line-removed">271   bool push_slow(E t, uint dirty_n_elems);</span>
272   bool pop_local_slow(uint localBot, Age oldAge);
273 
274 public:
275   typedef E element_type;
276 
277   // Initializes the queue to empty.
278   GenericTaskQueue();
279 
280   void initialize();
281 
282   // Push the task &quot;t&quot; on the queue.  Returns &quot;false&quot; iff the queue is full.
283   inline bool push(E t);
284 
285   // Attempts to claim a task from the &quot;local&quot; end of the queue (the most
286   // recently pushed) as long as the number of entries exceeds the threshold.
287   // If successful, returns true and sets t to the task; otherwise, returns false
288   // (the queue is empty or the number of elements below the threshold).
289   inline bool pop_local(volatile E&amp; t, uint threshold = 0);
290 
291   // Like pop_local(), but uses the &quot;global&quot; end of the queue (the least
</pre>
</td>
<td>
<hr />
<pre>
189   bool peek()     const { return _bottom != _age.top(); }
190   bool is_empty() const { return size() == 0; }
191 
192   // Return an estimate of the number of elements in the queue.
193   // The &quot;careful&quot; version admits the possibility of pop_local/pop_global
194   // races.
195   uint size() const {
196     return size(_bottom, _age.top());
197   }
198 
199   uint dirty_size() const {
200     return dirty_size(_bottom, _age.top());
201   }
202 
203   void set_empty() {
204     _bottom = 0;
205     _age.set(0);
206   }
207 
208   // Maximum number of elements allowed in the queue.  This is two less
<span class="line-modified">209   // than the actual queue size, so that a full queue can be distinguished</span>
<span class="line-added">210   // from underflow involving pop_local and concurrent pop_global operations</span>
<span class="line-added">211   // in GenericTaskQueue.</span>
212   uint max_elems() const { return N - 2; }
213 
214   // Total size of queue.
215   static const uint total_size() { return N; }
216 
217   TASKQUEUE_STATS_ONLY(TaskQueueStats stats;)
218 };
219 
220 //
221 // GenericTaskQueue implements an ABP, Aurora-Blumofe-Plaxton, double-
222 // ended-queue (deque), intended for use in work stealing. Queue operations
223 // are non-blocking.
224 //
225 // A queue owner thread performs push() and pop_local() operations on one end
226 // of the queue, while other threads may steal work using the pop_global()
227 // method.
228 //
229 // The main difference to the original algorithm is that this
230 // implementation allows wrap-around at the end of its allocated
231 // storage, which is an array.
</pre>
<hr />
<pre>
252 class GenericTaskQueue: public TaskQueueSuper&lt;N, F&gt; {
253 protected:
254   typedef typename TaskQueueSuper&lt;N, F&gt;::Age Age;
255   typedef typename TaskQueueSuper&lt;N, F&gt;::idx_t idx_t;
256 
257   using TaskQueueSuper&lt;N, F&gt;::_bottom;
258   using TaskQueueSuper&lt;N, F&gt;::_age;
259   using TaskQueueSuper&lt;N, F&gt;::increment_index;
260   using TaskQueueSuper&lt;N, F&gt;::decrement_index;
261   using TaskQueueSuper&lt;N, F&gt;::dirty_size;
262 
263 public:
264   using TaskQueueSuper&lt;N, F&gt;::max_elems;
265   using TaskQueueSuper&lt;N, F&gt;::size;
266 
267 #if  TASKQUEUE_STATS
268   using TaskQueueSuper&lt;N, F&gt;::stats;
269 #endif
270 
271 private:
<span class="line-modified">272   // Slow path for pop_local, dealing with possible conflict with pop_global.</span>

273   bool pop_local_slow(uint localBot, Age oldAge);
274 
275 public:
276   typedef E element_type;
277 
278   // Initializes the queue to empty.
279   GenericTaskQueue();
280 
281   void initialize();
282 
283   // Push the task &quot;t&quot; on the queue.  Returns &quot;false&quot; iff the queue is full.
284   inline bool push(E t);
285 
286   // Attempts to claim a task from the &quot;local&quot; end of the queue (the most
287   // recently pushed) as long as the number of entries exceeds the threshold.
288   // If successful, returns true and sets t to the task; otherwise, returns false
289   // (the queue is empty or the number of elements below the threshold).
290   inline bool pop_local(volatile E&amp; t, uint threshold = 0);
291 
292   // Like pop_local(), but uses the &quot;global&quot; end of the queue (the least
</pre>
</td>
</tr>
</table>
<center><a href="../g1/heapRegionManager.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="taskqueue.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
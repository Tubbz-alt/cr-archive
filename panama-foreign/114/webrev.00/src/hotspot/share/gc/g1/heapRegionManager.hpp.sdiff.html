<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/heapRegionManager.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegionManager.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../shared/taskqueue.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegionManager.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 88   HeapWord* heap_bottom() const { return _regions.bottom_address_mapped(); }
 89   HeapWord* heap_end() const {return _regions.end_address_mapped(); }
 90 
 91   // Pass down commit calls to the VirtualSpace.
 92   void commit_regions(uint index, size_t num_regions = 1, WorkGang* pretouch_gang = NULL);
 93 
 94   // Notify other data structures about change in the heap layout.
 95   void update_committed_space(HeapWord* old_end, HeapWord* new_end);
 96 
 97   // Find a contiguous set of empty or uncommitted regions of length num_regions and return
 98   // the index of the first region or G1_NO_HRM_INDEX if the search was unsuccessful.
 99   // Start and end defines the range to seek in, policy is first-fit.
100   uint find_contiguous_in_range(uint start, uint end, uint num_regions);
101   // Find a contiguous set of empty regions of length num_regions. Returns the start index
102   // of that set, or G1_NO_HRM_INDEX.
103   uint find_contiguous_in_free_list(uint num_regions);
104   // Find a contiguous set of empty or unavailable regions of length num_regions. Returns the
105   // start index of that set, or G1_NO_HRM_INDEX.
106   uint find_contiguous_allow_expand(uint num_regions);
107 
<span class="line-modified">108   void guarantee_contiguous_range(uint start, uint num_regions) ;</span>
109 
110   // Finds the next sequence of unavailable regions starting from start_idx. Returns the
111   // length of the sequence found. If this result is zero, no such sequence could be found,
112   // otherwise res_idx indicates the start index of these regions.
113   uint find_unavailable_from_idx(uint start_idx, uint* res_idx) const;
114   // Finds the next sequence of empty regions starting from start_idx, going backwards in
115   // the heap. Returns the length of the sequence found. If this value is zero, no
116   // sequence could be found, otherwise res_idx contains the start index of this range.
117   uint find_empty_from_idx_reverse(uint start_idx, uint* res_idx) const;
118 
119   // Checks the G1MemoryNodeManager to see if this region is on the preferred node.
120   bool is_on_preferred_index(uint region_index, uint preferred_node_index);
121 
122 protected:
123   G1HeapRegionTable _regions;
124   G1RegionToSpaceMapper* _heap_mapper;
125   G1RegionToSpaceMapper* _prev_bitmap_mapper;
126   G1RegionToSpaceMapper* _next_bitmap_mapper;
127   FreeRegionList _free_list;
128 
</pre>
</td>
<td>
<hr />
<pre>
 88   HeapWord* heap_bottom() const { return _regions.bottom_address_mapped(); }
 89   HeapWord* heap_end() const {return _regions.end_address_mapped(); }
 90 
 91   // Pass down commit calls to the VirtualSpace.
 92   void commit_regions(uint index, size_t num_regions = 1, WorkGang* pretouch_gang = NULL);
 93 
 94   // Notify other data structures about change in the heap layout.
 95   void update_committed_space(HeapWord* old_end, HeapWord* new_end);
 96 
 97   // Find a contiguous set of empty or uncommitted regions of length num_regions and return
 98   // the index of the first region or G1_NO_HRM_INDEX if the search was unsuccessful.
 99   // Start and end defines the range to seek in, policy is first-fit.
100   uint find_contiguous_in_range(uint start, uint end, uint num_regions);
101   // Find a contiguous set of empty regions of length num_regions. Returns the start index
102   // of that set, or G1_NO_HRM_INDEX.
103   uint find_contiguous_in_free_list(uint num_regions);
104   // Find a contiguous set of empty or unavailable regions of length num_regions. Returns the
105   // start index of that set, or G1_NO_HRM_INDEX.
106   uint find_contiguous_allow_expand(uint num_regions);
107 
<span class="line-modified">108   void assert_contiguous_range(uint start, uint num_regions) NOT_DEBUG_RETURN;</span>
109 
110   // Finds the next sequence of unavailable regions starting from start_idx. Returns the
111   // length of the sequence found. If this result is zero, no such sequence could be found,
112   // otherwise res_idx indicates the start index of these regions.
113   uint find_unavailable_from_idx(uint start_idx, uint* res_idx) const;
114   // Finds the next sequence of empty regions starting from start_idx, going backwards in
115   // the heap. Returns the length of the sequence found. If this value is zero, no
116   // sequence could be found, otherwise res_idx contains the start index of this range.
117   uint find_empty_from_idx_reverse(uint start_idx, uint* res_idx) const;
118 
119   // Checks the G1MemoryNodeManager to see if this region is on the preferred node.
120   bool is_on_preferred_index(uint region_index, uint preferred_node_index);
121 
122 protected:
123   G1HeapRegionTable _regions;
124   G1RegionToSpaceMapper* _heap_mapper;
125   G1RegionToSpaceMapper* _prev_bitmap_mapper;
126   G1RegionToSpaceMapper* _next_bitmap_mapper;
127   FreeRegionList _free_list;
128 
</pre>
</td>
</tr>
</table>
<center><a href="heapRegionManager.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../shared/taskqueue.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
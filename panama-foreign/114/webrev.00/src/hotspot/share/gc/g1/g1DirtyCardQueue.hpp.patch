diff a/src/hotspot/share/gc/g1/g1DirtyCardQueue.hpp b/src/hotspot/share/gc/g1/g1DirtyCardQueue.hpp
--- a/src/hotspot/share/gc/g1/g1DirtyCardQueue.hpp
+++ b/src/hotspot/share/gc/g1/g1DirtyCardQueue.hpp
@@ -25,10 +25,11 @@
 #ifndef SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
 #define SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
 
 #include "gc/g1/g1BufferNodeList.hpp"
 #include "gc/g1/g1FreeIdSet.hpp"
+#include "gc/g1/g1ConcurrentRefineStats.hpp"
 #include "gc/shared/ptrQueue.hpp"
 #include "memory/allocation.hpp"
 #include "memory/padded.hpp"
 
 class G1ConcurrentRefineThread;
@@ -36,10 +37,12 @@
 class G1RedirtyCardsQueueSet;
 class Thread;
 
 // A ptrQueue whose elements are "oops", pointers to object heads.
 class G1DirtyCardQueue: public PtrQueue {
+  G1ConcurrentRefineStats* _refinement_stats;
+
 protected:
   virtual void handle_completed_buffer();
 
 public:
   G1DirtyCardQueue(G1DirtyCardQueueSet* qset);
@@ -47,14 +50,22 @@
   // Flush before destroying; queue may be used to capture pending work while
   // doing something else, with auto-flush on completion.
   ~G1DirtyCardQueue();
 
   // Process queue entries and release resources.
-  void flush() { flush_impl(); }
+  void flush();
 
   inline G1DirtyCardQueueSet* dirty_card_qset() const;
 
+  G1ConcurrentRefineStats* refinement_stats() const {
+    return _refinement_stats;
+  }
+
+  // To be called by the barrier set's on_thread_detach, to notify this
+  // object of the corresponding state change of its owning thread.
+  void on_thread_detach();
+
   // Compiler support.
   static ByteSize byte_offset_of_index() {
     return PtrQueue::byte_offset_of_index<G1DirtyCardQueue>();
   }
   using PtrQueue::byte_width_of_index;
@@ -213,13 +224,11 @@
   // mutator must start doing some of the concurrent refinement work.
   size_t _max_cards;
   volatile size_t _padded_max_cards;
   static const size_t MaxCardsUnlimited = SIZE_MAX;
 
-  // Array of cumulative dirty cards refined by mutator threads.
-  // Array has an entry per id in _free_ids.
-  size_t* _mutator_refined_cards_counters;
+  G1ConcurrentRefineStats _detached_refinement_stats;
 
   // Verify _num_cards == sum of cards in the completed queue.
   void verify_num_cards() const NOT_DEBUG_RETURN;
 
   // Thread-safe add a buffer to paused list for next safepoint.
@@ -239,13 +248,14 @@
   // Stops processing if SuspendibleThreadSet::should_yield() is true.
   // Returns true if the entire buffer was processed, false if there
   // is a pending yield request.  The node's index is updated to exclude
   // the processed elements, e.g. up to the element before processing
   // stopped, or one past the last element if the entire buffer was
-  // processed. Increments *total_refined_cards by the number of cards
-  // processed and removed from the buffer.
-  bool refine_buffer(BufferNode* node, uint worker_id, size_t* total_refined_cards);
+  // processed. Updates stats.
+  bool refine_buffer(BufferNode* node,
+                     uint worker_id,
+                     G1ConcurrentRefineStats* stats);
 
   // Deal with buffer after a call to refine_buffer.  If fully processed,
   // deallocate the buffer.  Otherwise, record it as paused.
   void handle_refined_buffer(BufferNode* node, bool fully_processed);
 
@@ -294,38 +304,43 @@
 
   // Helper for G1DirtyCardQueue::handle_completed_buffer().
   // Enqueue the buffer, and optionally perform refinement by the mutator.
   // Mutator refinement is only done by Java threads, and only if there
   // are more than max_cards (possibly padded) cards in the completed
-  // buffers.
+  // buffers.  Updates stats.
   //
   // Mutator refinement, if performed, stops processing a buffer if
   // SuspendibleThreadSet::should_yield(), recording the incompletely
   // processed buffer for later processing of the remainder.
-  void handle_completed_buffer(BufferNode* node);
+  void handle_completed_buffer(BufferNode* node, G1ConcurrentRefineStats* stats);
 
   // If there are more than stop_at cards in the completed buffers, pop
   // a buffer, refine its contents, and return true.  Otherwise return
-  // false.
+  // false.  Updates stats.
   //
   // Stops processing a buffer if SuspendibleThreadSet::should_yield(),
   // recording the incompletely processed buffer for later processing of
   // the remainder.
-  //
-  // Increments *total_refined_cards by the number of cards processed and
-  // removed from the buffer.
   bool refine_completed_buffer_concurrently(uint worker_id,
                                             size_t stop_at,
-                                            size_t* total_refined_cards);
+                                            G1ConcurrentRefineStats* stats);
 
   // If a full collection is happening, reset partial logs, and release
   // completed ones: the full collection will make them all irrelevant.
   void abandon_logs();
 
   // If any threads have partial logs, add them to the global list of logs.
   void concatenate_logs();
 
+  // Return the total of mutator refinement stats for all threads.
+  // Also resets the stats for the threads.
+  // precondition: at safepoint.
+  G1ConcurrentRefineStats get_and_reset_refinement_stats();
+
+  // Accumulate refinement stats from threads that are detaching.
+  void record_detached_refinement_stats(G1ConcurrentRefineStats* stats);
+
   // Threshold for mutator threads to also do refinement when there
   // are concurrent refinement threads.
   size_t max_cards() const;
 
   // Set threshold for mutator threads to also do refinement.
@@ -334,13 +349,10 @@
   // Artificially increase mutator refinement threshold.
   void set_max_cards_padding(size_t padding);
 
   // Discard artificial increase of mutator refinement threshold.
   void discard_max_cards_padding();
-
-  // Total dirty cards refined by mutator threads.
-  size_t total_mutator_refined_cards() const;
 };
 
 inline G1DirtyCardQueueSet* G1DirtyCardQueue::dirty_card_qset() const {
   return static_cast<G1DirtyCardQueueSet*>(qset());
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/g1/g1DirtyCardQueue.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1BufferNodeList.hpp&quot;
 27 #include &quot;gc/g1/g1CardTableEntryClosure.hpp&quot;
 28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 29 #include &quot;gc/g1/g1ConcurrentRefineStats.hpp&quot;
 30 #include &quot;gc/g1/g1ConcurrentRefineThread.hpp&quot;
 31 #include &quot;gc/g1/g1DirtyCardQueue.hpp&quot;
 32 #include &quot;gc/g1/g1FreeIdSet.hpp&quot;
 33 #include &quot;gc/g1/g1RedirtyCardsQueue.hpp&quot;
 34 #include &quot;gc/g1/g1RemSet.hpp&quot;
 35 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
 36 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 37 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 38 #include &quot;memory/iterator.hpp&quot;
 39 #include &quot;runtime/atomic.hpp&quot;
 40 #include &quot;runtime/mutex.hpp&quot;
 41 #include &quot;runtime/mutexLocker.hpp&quot;
 42 #include &quot;runtime/os.hpp&quot;
 43 #include &quot;runtime/safepoint.hpp&quot;
 44 #include &quot;runtime/thread.inline.hpp&quot;
 45 #include &quot;runtime/threadSMR.hpp&quot;
 46 #include &quot;utilities/globalCounter.inline.hpp&quot;
 47 #include &quot;utilities/macros.hpp&quot;
 48 #include &quot;utilities/quickSort.hpp&quot;
 49 #include &quot;utilities/ticks.hpp&quot;
 50 
 51 G1DirtyCardQueue::G1DirtyCardQueue(G1DirtyCardQueueSet* qset) :
 52   // Dirty card queues are always active, so we create them with their
 53   // active field set to true.
 54   PtrQueue(qset, true /* active */),
 55   _refinement_stats(new G1ConcurrentRefineStats())
 56 { }
 57 
 58 G1DirtyCardQueue::~G1DirtyCardQueue() {
 59   flush();
 60   delete _refinement_stats;
 61 }
 62 
 63 void G1DirtyCardQueue::flush() {
 64   _refinement_stats-&gt;inc_dirtied_cards(size());
 65   flush_impl();
 66 }
 67 
 68 void G1DirtyCardQueue::on_thread_detach() {
 69   assert(this == &amp;G1ThreadLocalData::dirty_card_queue(Thread::current()), &quot;precondition&quot;);
 70   flush();
 71   dirty_card_qset()-&gt;record_detached_refinement_stats(_refinement_stats);
 72 }
 73 
 74 void G1DirtyCardQueue::handle_completed_buffer() {
 75   assert(!is_empty(), &quot;precondition&quot;);
 76   _refinement_stats-&gt;inc_dirtied_cards(size());
 77   BufferNode* node = BufferNode::make_node_from_buffer(_buf, index());
 78   allocate_buffer();
 79   dirty_card_qset()-&gt;handle_completed_buffer(node, _refinement_stats);
 80 }
 81 
 82 // Assumed to be zero by concurrent threads.
 83 static uint par_ids_start() { return 0; }
 84 
 85 G1DirtyCardQueueSet::G1DirtyCardQueueSet(BufferNode::Allocator* allocator) :
 86   PtrQueueSet(allocator),
 87   _primary_refinement_thread(NULL),
 88   _num_cards(0),
 89   _completed(),
 90   _paused(),
 91   _free_ids(par_ids_start(), num_par_ids()),
 92   _process_cards_threshold(ProcessCardsThresholdNever),
 93   _max_cards(MaxCardsUnlimited),
 94   _padded_max_cards(MaxCardsUnlimited),
 95   _detached_refinement_stats()
 96 {
 97   _all_active = true;
 98 }
 99 
100 G1DirtyCardQueueSet::~G1DirtyCardQueueSet() {
101   abandon_completed_buffers();
102 }
103 
104 // Determines how many mutator threads can process the buffers in parallel.
105 uint G1DirtyCardQueueSet::num_par_ids() {
106   return (uint)os::initial_active_processor_count();
107 }
108 
109 void G1DirtyCardQueueSet::handle_zero_index_for_thread(Thread* t) {
110   G1ThreadLocalData::dirty_card_queue(t).handle_zero_index();
111 }
112 
113 #ifdef ASSERT
114 G1DirtyCardQueueSet::Queue::~Queue() {
115   assert(_head == NULL, &quot;precondition&quot;);
116   assert(_tail == NULL, &quot;precondition&quot;);
117 }
118 #endif // ASSERT
119 
120 BufferNode* G1DirtyCardQueueSet::Queue::top() const {
121   return Atomic::load(&amp;_head);
122 }
123 
124 // An append operation atomically exchanges the new tail with the queue tail.
125 // It then sets the &quot;next&quot; value of the old tail to the head of the list being
126 // appended; it is an invariant that the old tail&#39;s &quot;next&quot; value is NULL.
127 // But if the old tail is NULL then the queue was empty.  In this case the
128 // head of the list being appended is instead stored in the queue head; it is
129 // an invariant that the queue head is NULL in this case.
130 //
131 // This means there is a period between the exchange and the old tail update
132 // where the queue sequence is split into two parts, the list from the queue
133 // head to the old tail, and the list being appended.  If there are concurrent
134 // push/append operations, each may introduce another such segment.  But they
135 // all eventually get resolved by their respective updates of their old tail&#39;s
136 // &quot;next&quot; value.  This also means that pop operations must handle a buffer
137 // with a NULL &quot;next&quot; value specially.
138 //
139 // A push operation is just a degenerate append, where the buffer being pushed
140 // is both the head and the tail of the list being appended.
141 void G1DirtyCardQueueSet::Queue::append(BufferNode&amp; first, BufferNode&amp; last) {
142   assert(last.next() == NULL, &quot;precondition&quot;);
143   BufferNode* old_tail = Atomic::xchg(&amp;_tail, &amp;last);
144   if (old_tail == NULL) {       // Was empty.
145     Atomic::store(&amp;_head, &amp;first);
146   } else {
147     assert(old_tail-&gt;next() == NULL, &quot;invariant&quot;);
148     old_tail-&gt;set_next(&amp;first);
149   }
150 }
151 
152 BufferNode* G1DirtyCardQueueSet::Queue::pop() {
153   Thread* current_thread = Thread::current();
154   while (true) {
155     // Use a critical section per iteration, rather than over the whole
156     // operation.  We&#39;re not guaranteed to make progress.  Lingering in one
157     // CS could lead to excessive allocation of buffers, because the CS
158     // blocks return of released buffers to the free list for reuse.
159     GlobalCounter::CriticalSection cs(current_thread);
160 
161     BufferNode* result = Atomic::load_acquire(&amp;_head);
162     if (result == NULL) return NULL; // Queue is empty.
163 
164     BufferNode* next = Atomic::load_acquire(BufferNode::next_ptr(*result));
165     if (next != NULL) {
166       // The &quot;usual&quot; lock-free pop from the head of a singly linked list.
167       if (result == Atomic::cmpxchg(&amp;_head, result, next)) {
168         // Former head successfully taken; it is not the last.
169         assert(Atomic::load(&amp;_tail) != result, &quot;invariant&quot;);
170         assert(result-&gt;next() != NULL, &quot;invariant&quot;);
171         result-&gt;set_next(NULL);
172         return result;
173       }
174       // Lost the race; try again.
175       continue;
176     }
177 
178     // next is NULL.  This case is handled differently from the &quot;usual&quot;
179     // lock-free pop from the head of a singly linked list.
180 
181     // If _tail == result then result is the only element in the list. We can
182     // remove it from the list by first setting _tail to NULL and then setting
183     // _head to NULL, the order being important.  We set _tail with cmpxchg in
184     // case of a concurrent push/append/pop also changing _tail.  If we win
185     // then we&#39;ve claimed result.
186     if (Atomic::cmpxchg(&amp;_tail, result, (BufferNode*)NULL) == result) {
187       assert(result-&gt;next() == NULL, &quot;invariant&quot;);
188       // Now that we&#39;ve claimed result, also set _head to NULL.  But we must
189       // be careful of a concurrent push/append after we NULLed _tail, since
190       // it may have already performed its list-was-empty update of _head,
191       // which we must not overwrite.
192       Atomic::cmpxchg(&amp;_head, result, (BufferNode*)NULL);
193       return result;
194     }
195 
196     // If _head != result then we lost the race to take result; try again.
197     if (result != Atomic::load_acquire(&amp;_head)) {
198       continue;
199     }
200 
201     // An in-progress concurrent operation interfered with taking the head
202     // element when it was the only element.  A concurrent pop may have won
203     // the race to clear the tail but not yet cleared the head. Alternatively,
204     // a concurrent push/append may have changed the tail but not yet linked
205     // result-&gt;next().  We cannot take result in either case.  We don&#39;t just
206     // try again, because we could spin for a long time waiting for that
207     // concurrent operation to finish.  In the first case, returning NULL is
208     // fine; we lost the race for the only element to another thread.  We
209     // also return NULL for the second case, and let the caller cope.
210     return NULL;
211   }
212 }
213 
214 G1DirtyCardQueueSet::HeadTail G1DirtyCardQueueSet::Queue::take_all() {
215   assert_at_safepoint();
216   HeadTail result(Atomic::load(&amp;_head), Atomic::load(&amp;_tail));
217   Atomic::store(&amp;_head, (BufferNode*)NULL);
218   Atomic::store(&amp;_tail, (BufferNode*)NULL);
219   return result;
220 }
221 
222 void G1DirtyCardQueueSet::enqueue_completed_buffer(BufferNode* cbn) {
223   assert(cbn != NULL, &quot;precondition&quot;);
224   // Increment _num_cards before adding to queue, so queue removal doesn&#39;t
225   // need to deal with _num_cards possibly going negative.
226   size_t new_num_cards = Atomic::add(&amp;_num_cards, buffer_size() - cbn-&gt;index());
227   _completed.push(*cbn);
228   if ((new_num_cards &gt; process_cards_threshold()) &amp;&amp;
229       (_primary_refinement_thread != NULL)) {
230     _primary_refinement_thread-&gt;activate();
231   }
232 }
233 
234 BufferNode* G1DirtyCardQueueSet::get_completed_buffer() {
235   BufferNode* result = _completed.pop();
236   if (result == NULL) {         // Unlikely if no paused buffers.
237     enqueue_previous_paused_buffers();
238     result = _completed.pop();
239     if (result == NULL) return NULL;
240   }
241   Atomic::sub(&amp;_num_cards, buffer_size() - result-&gt;index());
242   return result;
243 }
244 
245 #ifdef ASSERT
246 void G1DirtyCardQueueSet::verify_num_cards() const {
247   size_t actual = 0;
248   BufferNode* cur = _completed.top();
249   for ( ; cur != NULL; cur = cur-&gt;next()) {
250     actual += buffer_size() - cur-&gt;index();
251   }
252   assert(actual == Atomic::load(&amp;_num_cards),
253          &quot;Num entries in completed buffers should be &quot; SIZE_FORMAT &quot; but are &quot; SIZE_FORMAT,
254          Atomic::load(&amp;_num_cards), actual);
255 }
256 #endif // ASSERT
257 
258 G1DirtyCardQueueSet::PausedBuffers::PausedList::PausedList() :
259   _head(NULL), _tail(NULL),
260   _safepoint_id(SafepointSynchronize::safepoint_id())
261 {}
262 
263 #ifdef ASSERT
264 G1DirtyCardQueueSet::PausedBuffers::PausedList::~PausedList() {
265   assert(Atomic::load(&amp;_head) == NULL, &quot;precondition&quot;);
266   assert(_tail == NULL, &quot;precondition&quot;);
267 }
268 #endif // ASSERT
269 
270 bool G1DirtyCardQueueSet::PausedBuffers::PausedList::is_next() const {
271   assert_not_at_safepoint();
272   return _safepoint_id == SafepointSynchronize::safepoint_id();
273 }
274 
275 void G1DirtyCardQueueSet::PausedBuffers::PausedList::add(BufferNode* node) {
276   assert_not_at_safepoint();
277   assert(is_next(), &quot;precondition&quot;);
278   BufferNode* old_head = Atomic::xchg(&amp;_head, node);
279   if (old_head == NULL) {
280     assert(_tail == NULL, &quot;invariant&quot;);
281     _tail = node;
282   } else {
283     node-&gt;set_next(old_head);
284   }
285 }
286 
287 G1DirtyCardQueueSet::HeadTail G1DirtyCardQueueSet::PausedBuffers::PausedList::take() {
288   BufferNode* head = Atomic::load(&amp;_head);
289   BufferNode* tail = _tail;
290   Atomic::store(&amp;_head, (BufferNode*)NULL);
291   _tail = NULL;
292   return HeadTail(head, tail);
293 }
294 
295 G1DirtyCardQueueSet::PausedBuffers::PausedBuffers() : _plist(NULL) {}
296 
297 #ifdef ASSERT
298 G1DirtyCardQueueSet::PausedBuffers::~PausedBuffers() {
299   assert(Atomic::load(&amp;_plist) == NULL, &quot;invariant&quot;);
300 }
301 #endif // ASSERT
302 
303 void G1DirtyCardQueueSet::PausedBuffers::add(BufferNode* node) {
304   assert_not_at_safepoint();
305   PausedList* plist = Atomic::load_acquire(&amp;_plist);
306   if (plist == NULL) {
307     // Try to install a new next list.
308     plist = new PausedList();
309     PausedList* old_plist = Atomic::cmpxchg(&amp;_plist, (PausedList*)NULL, plist);
310     if (old_plist != NULL) {
311       // Some other thread installed a new next list.  Use it instead.
312       delete plist;
313       plist = old_plist;
314     }
315   }
316   assert(plist-&gt;is_next(), &quot;invariant&quot;);
317   plist-&gt;add(node);
318 }
319 
320 G1DirtyCardQueueSet::HeadTail G1DirtyCardQueueSet::PausedBuffers::take_previous() {
321   assert_not_at_safepoint();
322   PausedList* previous;
323   {
324     // Deal with plist in a critical section, to prevent it from being
325     // deleted out from under us by a concurrent take_previous().
326     GlobalCounter::CriticalSection cs(Thread::current());
327     previous = Atomic::load_acquire(&amp;_plist);
328     if ((previous == NULL) ||   // Nothing to take.
329         previous-&gt;is_next() ||  // Not from a previous safepoint.
330         // Some other thread stole it.
331         (Atomic::cmpxchg(&amp;_plist, previous, (PausedList*)NULL) != previous)) {
332       return HeadTail();
333     }
334   }
335   // We now own previous.
336   HeadTail result = previous-&gt;take();
337   // There might be other threads examining previous (in concurrent
338   // take_previous()).  Synchronize to wait until any such threads are
339   // done with such examination before deleting.
340   GlobalCounter::write_synchronize();
341   delete previous;
342   return result;
343 }
344 
345 G1DirtyCardQueueSet::HeadTail G1DirtyCardQueueSet::PausedBuffers::take_all() {
346   assert_at_safepoint();
347   HeadTail result;
348   PausedList* plist = Atomic::load(&amp;_plist);
349   if (plist != NULL) {
350     Atomic::store(&amp;_plist, (PausedList*)NULL);
351     result = plist-&gt;take();
352     delete plist;
353   }
354   return result;
355 }
356 
357 void G1DirtyCardQueueSet::record_paused_buffer(BufferNode* node) {
358   assert_not_at_safepoint();
359   assert(node-&gt;next() == NULL, &quot;precondition&quot;);
360   // Ensure there aren&#39;t any paused buffers from a previous safepoint.
361   enqueue_previous_paused_buffers();
362   // Cards for paused buffers are included in count, to contribute to
363   // notification checking after the coming safepoint if it doesn&#39;t GC.
364   // Note that this means the queue&#39;s _num_cards differs from the number
365   // of cards in the queued buffers when there are paused buffers.
366   Atomic::add(&amp;_num_cards, buffer_size() - node-&gt;index());
367   _paused.add(node);
368 }
369 
370 void G1DirtyCardQueueSet::enqueue_paused_buffers_aux(const HeadTail&amp; paused) {
371   if (paused._head != NULL) {
372     assert(paused._tail != NULL, &quot;invariant&quot;);
373     // Cards from paused buffers are already recorded in the queue count.
374     _completed.append(*paused._head, *paused._tail);
375   }
376 }
377 
378 void G1DirtyCardQueueSet::enqueue_previous_paused_buffers() {
379   assert_not_at_safepoint();
380   enqueue_paused_buffers_aux(_paused.take_previous());
381 }
382 
383 void G1DirtyCardQueueSet::enqueue_all_paused_buffers() {
384   assert_at_safepoint();
385   enqueue_paused_buffers_aux(_paused.take_all());
386 }
387 
388 void G1DirtyCardQueueSet::abandon_completed_buffers() {
389   enqueue_all_paused_buffers();
390   verify_num_cards();
391   G1BufferNodeList list = take_all_completed_buffers();
392   BufferNode* buffers_to_delete = list._head;
393   while (buffers_to_delete != NULL) {
394     BufferNode* bn = buffers_to_delete;
395     buffers_to_delete = bn-&gt;next();
396     bn-&gt;set_next(NULL);
397     deallocate_buffer(bn);
398   }
399 }
400 
401 void G1DirtyCardQueueSet::notify_if_necessary() {
402   if ((_primary_refinement_thread != NULL) &amp;&amp;
403       (num_cards() &gt; process_cards_threshold())) {
404     _primary_refinement_thread-&gt;activate();
405   }
406 }
407 
408 // Merge lists of buffers. The source queue set is emptied as a
409 // result. The queue sets must share the same allocator.
410 void G1DirtyCardQueueSet::merge_bufferlists(G1RedirtyCardsQueueSet* src) {
411   assert(allocator() == src-&gt;allocator(), &quot;precondition&quot;);
412   const G1BufferNodeList from = src-&gt;take_all_completed_buffers();
413   if (from._head != NULL) {
414     Atomic::add(&amp;_num_cards, from._entry_count);
415     _completed.append(*from._head, *from._tail);
416   }
417 }
418 
419 G1BufferNodeList G1DirtyCardQueueSet::take_all_completed_buffers() {
420   enqueue_all_paused_buffers();
421   verify_num_cards();
422   HeadTail buffers = _completed.take_all();
423   size_t num_cards = Atomic::load(&amp;_num_cards);
424   Atomic::store(&amp;_num_cards, size_t(0));
425   return G1BufferNodeList(buffers._head, buffers._tail, num_cards);
426 }
427 
428 class G1RefineBufferedCards : public StackObj {
429   BufferNode* const _node;
430   CardTable::CardValue** const _node_buffer;
431   const size_t _node_buffer_size;
432   const uint _worker_id;
433   G1ConcurrentRefineStats* _stats;
434   G1RemSet* const _g1rs;
435 
436   static inline int compare_card(const CardTable::CardValue* p1,
437                                  const CardTable::CardValue* p2) {
438     return p2 - p1;
439   }
440 
441   // Sorts the cards from start_index to _node_buffer_size in *decreasing*
442   // address order. Tests showed that this order is preferable to not sorting
443   // or increasing address order.
444   void sort_cards(size_t start_index) {
445     QuickSort::sort(&amp;_node_buffer[start_index],
446                     _node_buffer_size - start_index,
447                     compare_card,
448                     false);
449   }
450 
451   // Returns the index to the first clean card in the buffer.
452   size_t clean_cards() {
453     const size_t start = _node-&gt;index();
454     assert(start &lt;= _node_buffer_size, &quot;invariant&quot;);
455 
456     // Two-fingered compaction algorithm similar to the filtering mechanism in
457     // SATBMarkQueue. The main difference is that clean_card_before_refine()
458     // could change the buffer element in-place.
459     // We don&#39;t check for SuspendibleThreadSet::should_yield(), because
460     // cleaning and redirtying the cards is fast.
461     CardTable::CardValue** src = &amp;_node_buffer[start];
462     CardTable::CardValue** dst = &amp;_node_buffer[_node_buffer_size];
463     assert(src &lt;= dst, &quot;invariant&quot;);
464     for ( ; src &lt; dst; ++src) {
465       // Search low to high for a card to keep.
466       if (_g1rs-&gt;clean_card_before_refine(src)) {
467         // Found keeper.  Search high to low for a card to discard.
468         while (src &lt; --dst) {
469           if (!_g1rs-&gt;clean_card_before_refine(dst)) {
470             *dst = *src;         // Replace discard with keeper.
471             break;
472           }
473         }
474         // If discard search failed (src == dst), the outer loop will also end.
475       }
476     }
477 
478     // dst points to the first retained clean card, or the end of the buffer
479     // if all the cards were discarded.
480     const size_t first_clean = dst - _node_buffer;
481     assert(first_clean &gt;= start &amp;&amp; first_clean &lt;= _node_buffer_size, &quot;invariant&quot;);
482     // Discarded cards are considered as refined.
483     _stats-&gt;inc_refined_cards(first_clean - start);
484     _stats-&gt;inc_precleaned_cards(first_clean - start);
485     return first_clean;
486   }
487 
488   bool refine_cleaned_cards(size_t start_index) {
489     bool result = true;
490     size_t i = start_index;
491     for ( ; i &lt; _node_buffer_size; ++i) {
492       if (SuspendibleThreadSet::should_yield()) {
493         redirty_unrefined_cards(i);
494         result = false;
495         break;
496       }
497       _g1rs-&gt;refine_card_concurrently(_node_buffer[i], _worker_id);
498     }
499     _node-&gt;set_index(i);
500     _stats-&gt;inc_refined_cards(i - start_index);
501     return result;
502   }
503 
504   void redirty_unrefined_cards(size_t start) {
505     for ( ; start &lt; _node_buffer_size; ++start) {
506       *_node_buffer[start] = G1CardTable::dirty_card_val();
507     }
508   }
509 
510 public:
511   G1RefineBufferedCards(BufferNode* node,
512                         size_t node_buffer_size,
513                         uint worker_id,
514                         G1ConcurrentRefineStats* stats) :
515     _node(node),
516     _node_buffer(reinterpret_cast&lt;CardTable::CardValue**&gt;(BufferNode::make_buffer_from_node(node))),
517     _node_buffer_size(node_buffer_size),
518     _worker_id(worker_id),
519     _stats(stats),
520     _g1rs(G1CollectedHeap::heap()-&gt;rem_set()) {}
521 
522   bool refine() {
523     size_t first_clean_index = clean_cards();
524     if (first_clean_index == _node_buffer_size) {
525       _node-&gt;set_index(first_clean_index);
526       return true;
527     }
528     // This fence serves two purposes. First, the cards must be cleaned
529     // before processing the contents. Second, we can&#39;t proceed with
530     // processing a region until after the read of the region&#39;s top in
531     // collect_and_clean_cards(), for synchronization with possibly concurrent
532     // humongous object allocation (see comment at the StoreStore fence before
533     // setting the regions&#39; tops in humongous allocation path).
534     // It&#39;s okay that reading region&#39;s top and reading region&#39;s type were racy
535     // wrto each other. We need both set, in any order, to proceed.
536     OrderAccess::fence();
537     sort_cards(first_clean_index);
538     return refine_cleaned_cards(first_clean_index);
539   }
540 };
541 
542 bool G1DirtyCardQueueSet::refine_buffer(BufferNode* node,
543                                         uint worker_id,
544                                         G1ConcurrentRefineStats* stats) {
545   Ticks start_time = Ticks::now();
546   G1RefineBufferedCards buffered_cards(node,
547                                        buffer_size(),
548                                        worker_id,
549                                        stats);
550   bool result = buffered_cards.refine();
551   stats-&gt;inc_refinement_time(Ticks::now() - start_time);
552   return result;
553 }
554 
555 void G1DirtyCardQueueSet::handle_refined_buffer(BufferNode* node,
556                                                 bool fully_processed) {
557   if (fully_processed) {
558     assert(node-&gt;index() == buffer_size(),
559            &quot;Buffer not fully consumed: index: &quot; SIZE_FORMAT &quot;, size: &quot; SIZE_FORMAT,
560            node-&gt;index(), buffer_size());
561     deallocate_buffer(node);
562   } else {
563     assert(node-&gt;index() &lt; buffer_size(), &quot;Buffer fully consumed.&quot;);
564     // Buffer incompletely processed because there is a pending safepoint.
565     // Record partially processed buffer, to be finished later.
566     record_paused_buffer(node);
567   }
568 }
569 
570 void G1DirtyCardQueueSet::handle_completed_buffer(BufferNode* new_node,
571                                                   G1ConcurrentRefineStats* stats) {
572   enqueue_completed_buffer(new_node);
573 
574   // No need for mutator refinement if number of cards is below limit.
575   if (Atomic::load(&amp;_num_cards) &lt;= Atomic::load(&amp;_padded_max_cards)) {
576     return;
577   }
578 
579   // Only Java threads perform mutator refinement.
580   if (!Thread::current()-&gt;is_Java_thread()) {
581     return;
582   }
583 
584   BufferNode* node = get_completed_buffer();
585   if (node == NULL) return;     // Didn&#39;t get a buffer to process.
586 
587   // Refine cards in buffer.
588 
589   uint worker_id = _free_ids.claim_par_id(); // temporarily claim an id
590   bool fully_processed = refine_buffer(node, worker_id, stats);
591   _free_ids.release_par_id(worker_id); // release the id
592 
593   // Deal with buffer after releasing id, to let another thread use id.
594   handle_refined_buffer(node, fully_processed);
595 }
596 
597 bool G1DirtyCardQueueSet::refine_completed_buffer_concurrently(uint worker_id,
598                                                                size_t stop_at,
599                                                                G1ConcurrentRefineStats* stats) {
600   // Not enough cards to trigger processing.
601   if (Atomic::load(&amp;_num_cards) &lt;= stop_at) return false;
602 
603   BufferNode* node = get_completed_buffer();
604   if (node == NULL) return false; // Didn&#39;t get a buffer to process.
605 
606   bool fully_processed = refine_buffer(node, worker_id, stats);
607   handle_refined_buffer(node, fully_processed);
608   return true;
609 }
610 
611 void G1DirtyCardQueueSet::abandon_logs() {
612   assert_at_safepoint();
613   abandon_completed_buffers();
614   _detached_refinement_stats.reset();
615 
616   // Since abandon is done only at safepoints, we can safely manipulate
617   // these queues.
618   struct AbandonThreadLogClosure : public ThreadClosure {
619     virtual void do_thread(Thread* t) {
620       G1DirtyCardQueue&amp; dcq = G1ThreadLocalData::dirty_card_queue(t);
621       dcq.reset();
622       dcq.refinement_stats()-&gt;reset();
623     }
624   } closure;
625   Threads::threads_do(&amp;closure);
626 
627   G1BarrierSet::shared_dirty_card_queue().reset();
628 }
629 
630 void G1DirtyCardQueueSet::concatenate_logs() {
631   // Iterate over all the threads, if we find a partial log add it to
632   // the global list of logs.  Temporarily turn off the limit on the number
633   // of outstanding buffers.
634   assert_at_safepoint();
635   size_t old_limit = max_cards();
636   set_max_cards(MaxCardsUnlimited);
637 
638   struct ConcatenateThreadLogClosure : public ThreadClosure {
639     virtual void do_thread(Thread* t) {
640       G1DirtyCardQueue&amp; dcq = G1ThreadLocalData::dirty_card_queue(t);
641       if (!dcq.is_empty()) {
642         dcq.flush();
643       }
644     }
645   } closure;
646   Threads::threads_do(&amp;closure);
647 
648   G1BarrierSet::shared_dirty_card_queue().flush();
649   enqueue_all_paused_buffers();
650   verify_num_cards();
651   set_max_cards(old_limit);
652 }
653 
654 G1ConcurrentRefineStats G1DirtyCardQueueSet::get_and_reset_refinement_stats() {
655   assert_at_safepoint();
656 
657   // Since we&#39;re at a safepoint, there aren&#39;t any races with recording of
658   // detached refinement stats.  In particular, there&#39;s no risk of double
659   // counting a thread that detaches after we&#39;ve examined it but before
660   // we&#39;ve processed the detached stats.
661 
662   // Collect and reset stats for attached threads.
663   struct CollectStats : public ThreadClosure {
664     G1ConcurrentRefineStats _total_stats;
665     virtual void do_thread(Thread* t) {
666       G1DirtyCardQueue&amp; dcq = G1ThreadLocalData::dirty_card_queue(t);
667       G1ConcurrentRefineStats&amp; stats = *dcq.refinement_stats();
668       _total_stats += stats;
669       stats.reset();
670     }
671   } closure;
672   Threads::threads_do(&amp;closure);
673 
674   // Collect and reset stats from detached threads.
675   MutexLocker ml(G1DetachedRefinementStats_lock, Mutex::_no_safepoint_check_flag);
676   closure._total_stats += _detached_refinement_stats;
677   _detached_refinement_stats.reset();
678 
679   return closure._total_stats;
680 }
681 
682 void G1DirtyCardQueueSet::record_detached_refinement_stats(G1ConcurrentRefineStats* stats) {
683   MutexLocker ml(G1DetachedRefinementStats_lock, Mutex::_no_safepoint_check_flag);
684   _detached_refinement_stats += *stats;
685   stats-&gt;reset();
686 }
687 
688 size_t G1DirtyCardQueueSet::max_cards() const {
689   return _max_cards;
690 }
691 
692 void G1DirtyCardQueueSet::set_max_cards(size_t value) {
693   _max_cards = value;
694   Atomic::store(&amp;_padded_max_cards, value);
695 }
696 
697 void G1DirtyCardQueueSet::set_max_cards_padding(size_t padding) {
698   // Compute sum, clipping to max.
699   size_t limit = _max_cards + padding;
700   if (limit &lt; padding) {        // Check for overflow.
701     limit = MaxCardsUnlimited;
702   }
703   Atomic::store(&amp;_padded_max_cards, limit);
704 }
705 
706 void G1DirtyCardQueueSet::discard_max_cards_padding() {
707   // Being racy here is okay, since all threads store the same value.
708   if (_max_cards != Atomic::load(&amp;_padded_max_cards)) {
709     Atomic::store(&amp;_padded_max_cards, _max_cards);
710   }
711 }
    </pre>
  </body>
</html>
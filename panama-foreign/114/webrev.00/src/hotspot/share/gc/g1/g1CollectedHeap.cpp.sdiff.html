<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1CollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1BarrierSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectedHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CollectedHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1037   // Rebuild the strong code root lists for each region
1038   rebuild_strong_code_roots();
1039 
1040   // Purge code root memory
1041   purge_code_root_memory();
1042 
1043   // Start a new incremental collection set for the next pause
1044   start_new_collection_set();
1045 
1046   _allocator-&gt;init_mutator_alloc_regions();
1047 
1048   // Post collection state updates.
1049   MetaspaceGC::compute_new_size();
1050 }
1051 
1052 void G1CollectedHeap::abort_refinement() {
1053   if (_hot_card_cache-&gt;use_cache()) {
1054     _hot_card_cache-&gt;reset_hot_cache();
1055   }
1056 
<span class="line-modified">1057   // Discard all remembered set updates.</span>
1058   G1BarrierSet::dirty_card_queue_set().abandon_logs();
1059   assert(G1BarrierSet::dirty_card_queue_set().num_cards() == 0,
1060          &quot;DCQS should be empty&quot;);

1061 }
1062 
1063 void G1CollectedHeap::verify_after_full_collection() {
1064   _hrm-&gt;verify_optional();
1065   _verifier-&gt;verify_region_sets_optional();
1066   _verifier-&gt;verify_after_gc(G1HeapVerifier::G1VerifyFull);
1067   // Clear the previous marking bitmap, if needed for bitmap verification.
1068   // Note we cannot do this when we clear the next marking bitmap in
1069   // G1ConcurrentMark::abort() above since VerifyDuringGC verifies the
1070   // objects marked during a full GC against the previous bitmap.
1071   // But we need to clear it before calling check_bitmaps below since
1072   // the full GC has compacted objects and updated TAMS but not updated
1073   // the prev bitmap.
1074   if (G1VerifyBitmaps) {
1075     GCTraceTime(Debug, gc) tm(&quot;Clear Prev Bitmap for Verification&quot;);
1076     _cm-&gt;clear_prev_bitmap(workers());
1077   }
1078   // This call implicitly verifies that the next bitmap is clear after Full GC.
1079   _verifier-&gt;check_bitmaps(&quot;Full GC End&quot;);
1080 
</pre>
<hr />
<pre>
2667 G1CollectedHeap* G1CollectedHeap::heap() {
2668   CollectedHeap* heap = Universe::heap();
2669   assert(heap != NULL, &quot;Uninitialized access to G1CollectedHeap::heap()&quot;);
2670   assert(heap-&gt;kind() == CollectedHeap::G1, &quot;Invalid name&quot;);
2671   return (G1CollectedHeap*)heap;
2672 }
2673 
2674 void G1CollectedHeap::gc_prologue(bool full) {
2675   assert(InlineCacheBuffer::is_empty(), &quot;should have cleaned up ICBuffer&quot;);
2676 
2677   // This summary needs to be printed before incrementing total collections.
2678   rem_set()-&gt;print_periodic_summary_info(&quot;Before GC RS summary&quot;, total_collections());
2679 
2680   // Update common counters.
2681   increment_total_collections(full /* full gc */);
2682   if (full || collector_state()-&gt;in_initial_mark_gc()) {
2683     increment_old_marking_cycles_started();
2684   }
2685 
2686   // Fill TLAB&#39;s and such
<span class="line-modified">2687   double start = os::elapsedTime();</span>
<span class="line-modified">2688   ensure_parsability(true);</span>
<span class="line-modified">2689   phase_times()-&gt;record_prepare_tlab_time_ms((os::elapsedTime() - start) * 1000.0);</span>













2690 }
2691 
2692 void G1CollectedHeap::gc_epilogue(bool full) {
2693   // Update common counters.
2694   if (full) {
2695     // Update the number of full collections that have been completed.
2696     increment_old_marking_cycles_completed(false /* concurrent */);
2697   }
2698 
2699   // We are at the end of the GC. Total collections has already been increased.
2700   rem_set()-&gt;print_periodic_summary_info(&quot;After GC RS summary&quot;, total_collections() - 1);
2701 
2702   // FIXME: what is this about?
2703   // I&#39;m ignoring the &quot;fill_newgen()&quot; call if &quot;alloc_event_enabled&quot;
2704   // is set.
2705 #if COMPILER2_OR_JVMCI
2706   assert(DerivedPointerTable::is_empty(), &quot;derived pointer present&quot;);
2707 #endif
2708 
2709   double start = os::elapsedTime();
</pre>
<hr />
<pre>
2742   VMThread::execute(&amp;op);
2743 
2744   HeapWord* result = op.result();
2745   bool ret_succeeded = op.prologue_succeeded() &amp;&amp; op.gc_succeeded();
2746   assert(result == NULL || ret_succeeded,
2747          &quot;the result should be NULL if the VM did not succeed&quot;);
2748   *succeeded = ret_succeeded;
2749 
2750   assert_heap_not_locked();
2751   return result;
2752 }
2753 
2754 void G1CollectedHeap::do_concurrent_mark() {
2755   MutexLocker x(CGC_lock, Mutex::_no_safepoint_check_flag);
2756   if (!_cm_thread-&gt;in_progress()) {
2757     _cm_thread-&gt;set_started();
2758     CGC_lock-&gt;notify();
2759   }
2760 }
2761 
<span class="line-removed">2762 size_t G1CollectedHeap::pending_card_num() {</span>
<span class="line-removed">2763   struct CountCardsClosure : public ThreadClosure {</span>
<span class="line-removed">2764     size_t _cards;</span>
<span class="line-removed">2765     CountCardsClosure() : _cards(0) {}</span>
<span class="line-removed">2766     virtual void do_thread(Thread* t) {</span>
<span class="line-removed">2767       _cards += G1ThreadLocalData::dirty_card_queue(t).size();</span>
<span class="line-removed">2768     }</span>
<span class="line-removed">2769   } count_from_threads;</span>
<span class="line-removed">2770   Threads::threads_do(&amp;count_from_threads);</span>
<span class="line-removed">2771 </span>
<span class="line-removed">2772   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="line-removed">2773   return dcqs.num_cards() + count_from_threads._cards;</span>
<span class="line-removed">2774 }</span>
<span class="line-removed">2775 </span>
2776 bool G1CollectedHeap::is_potential_eager_reclaim_candidate(HeapRegion* r) const {
2777   // We don&#39;t nominate objects with many remembered set entries, on
2778   // the assumption that such objects are likely still live.
2779   HeapRegionRemSet* rem_set = r-&gt;rem_set();
2780 
2781   return G1EagerReclaimHumongousObjectsWithStaleRefs ?
2782          rem_set-&gt;occupancy_less_or_equal_than(G1RSetSparseRegionEntries) :
2783          G1EagerReclaimHumongousObjects &amp;&amp; rem_set-&gt;is_empty();
2784 }
2785 
2786 #ifndef PRODUCT
2787 void G1CollectedHeap::verify_region_attr_remset_update() {
2788   class VerifyRegionAttrRemSet : public HeapRegionClosure {
2789   public:
2790     virtual bool do_heap_region(HeapRegion* r) {
2791       G1CollectedHeap* g1h = G1CollectedHeap::heap();
2792       bool const needs_remset_update = g1h-&gt;region_attr(r-&gt;bottom()).needs_remset_update();
2793       assert(r-&gt;rem_set()-&gt;is_tracked() == needs_remset_update,
2794              &quot;Region %u remset tracking status (%s) different to region attribute (%s)&quot;,
2795              r-&gt;hrm_index(), BOOL_TO_STR(r-&gt;rem_set()-&gt;is_tracked()), BOOL_TO_STR(needs_remset_update));
</pre>
</td>
<td>
<hr />
<pre>
1037   // Rebuild the strong code root lists for each region
1038   rebuild_strong_code_roots();
1039 
1040   // Purge code root memory
1041   purge_code_root_memory();
1042 
1043   // Start a new incremental collection set for the next pause
1044   start_new_collection_set();
1045 
1046   _allocator-&gt;init_mutator_alloc_regions();
1047 
1048   // Post collection state updates.
1049   MetaspaceGC::compute_new_size();
1050 }
1051 
1052 void G1CollectedHeap::abort_refinement() {
1053   if (_hot_card_cache-&gt;use_cache()) {
1054     _hot_card_cache-&gt;reset_hot_cache();
1055   }
1056 
<span class="line-modified">1057   // Discard all remembered set updates and reset refinement statistics.</span>
1058   G1BarrierSet::dirty_card_queue_set().abandon_logs();
1059   assert(G1BarrierSet::dirty_card_queue_set().num_cards() == 0,
1060          &quot;DCQS should be empty&quot;);
<span class="line-added">1061   concurrent_refine()-&gt;get_and_reset_refinement_stats();</span>
1062 }
1063 
1064 void G1CollectedHeap::verify_after_full_collection() {
1065   _hrm-&gt;verify_optional();
1066   _verifier-&gt;verify_region_sets_optional();
1067   _verifier-&gt;verify_after_gc(G1HeapVerifier::G1VerifyFull);
1068   // Clear the previous marking bitmap, if needed for bitmap verification.
1069   // Note we cannot do this when we clear the next marking bitmap in
1070   // G1ConcurrentMark::abort() above since VerifyDuringGC verifies the
1071   // objects marked during a full GC against the previous bitmap.
1072   // But we need to clear it before calling check_bitmaps below since
1073   // the full GC has compacted objects and updated TAMS but not updated
1074   // the prev bitmap.
1075   if (G1VerifyBitmaps) {
1076     GCTraceTime(Debug, gc) tm(&quot;Clear Prev Bitmap for Verification&quot;);
1077     _cm-&gt;clear_prev_bitmap(workers());
1078   }
1079   // This call implicitly verifies that the next bitmap is clear after Full GC.
1080   _verifier-&gt;check_bitmaps(&quot;Full GC End&quot;);
1081 
</pre>
<hr />
<pre>
2668 G1CollectedHeap* G1CollectedHeap::heap() {
2669   CollectedHeap* heap = Universe::heap();
2670   assert(heap != NULL, &quot;Uninitialized access to G1CollectedHeap::heap()&quot;);
2671   assert(heap-&gt;kind() == CollectedHeap::G1, &quot;Invalid name&quot;);
2672   return (G1CollectedHeap*)heap;
2673 }
2674 
2675 void G1CollectedHeap::gc_prologue(bool full) {
2676   assert(InlineCacheBuffer::is_empty(), &quot;should have cleaned up ICBuffer&quot;);
2677 
2678   // This summary needs to be printed before incrementing total collections.
2679   rem_set()-&gt;print_periodic_summary_info(&quot;Before GC RS summary&quot;, total_collections());
2680 
2681   // Update common counters.
2682   increment_total_collections(full /* full gc */);
2683   if (full || collector_state()-&gt;in_initial_mark_gc()) {
2684     increment_old_marking_cycles_started();
2685   }
2686 
2687   // Fill TLAB&#39;s and such
<span class="line-modified">2688   {</span>
<span class="line-modified">2689     Ticks start = Ticks::now();</span>
<span class="line-modified">2690     ensure_parsability(true);</span>
<span class="line-added">2691     Tickspan dt = Ticks::now() - start;</span>
<span class="line-added">2692     phase_times()-&gt;record_prepare_tlab_time_ms(dt.seconds() * MILLIUNITS);</span>
<span class="line-added">2693   }</span>
<span class="line-added">2694 </span>
<span class="line-added">2695   if (!full) {</span>
<span class="line-added">2696     // Flush dirty card queues to qset, so later phases don&#39;t need to account</span>
<span class="line-added">2697     // for partially filled per-thread queues and such.  Not needed for full</span>
<span class="line-added">2698     // collections, which ignore those logs.</span>
<span class="line-added">2699     Ticks start = Ticks::now();</span>
<span class="line-added">2700     G1BarrierSet::dirty_card_queue_set().concatenate_logs();</span>
<span class="line-added">2701     Tickspan dt = Ticks::now() - start;</span>
<span class="line-added">2702     phase_times()-&gt;record_concatenate_dirty_card_logs_time_ms(dt.seconds() * MILLIUNITS);</span>
<span class="line-added">2703   }</span>
2704 }
2705 
2706 void G1CollectedHeap::gc_epilogue(bool full) {
2707   // Update common counters.
2708   if (full) {
2709     // Update the number of full collections that have been completed.
2710     increment_old_marking_cycles_completed(false /* concurrent */);
2711   }
2712 
2713   // We are at the end of the GC. Total collections has already been increased.
2714   rem_set()-&gt;print_periodic_summary_info(&quot;After GC RS summary&quot;, total_collections() - 1);
2715 
2716   // FIXME: what is this about?
2717   // I&#39;m ignoring the &quot;fill_newgen()&quot; call if &quot;alloc_event_enabled&quot;
2718   // is set.
2719 #if COMPILER2_OR_JVMCI
2720   assert(DerivedPointerTable::is_empty(), &quot;derived pointer present&quot;);
2721 #endif
2722 
2723   double start = os::elapsedTime();
</pre>
<hr />
<pre>
2756   VMThread::execute(&amp;op);
2757 
2758   HeapWord* result = op.result();
2759   bool ret_succeeded = op.prologue_succeeded() &amp;&amp; op.gc_succeeded();
2760   assert(result == NULL || ret_succeeded,
2761          &quot;the result should be NULL if the VM did not succeed&quot;);
2762   *succeeded = ret_succeeded;
2763 
2764   assert_heap_not_locked();
2765   return result;
2766 }
2767 
2768 void G1CollectedHeap::do_concurrent_mark() {
2769   MutexLocker x(CGC_lock, Mutex::_no_safepoint_check_flag);
2770   if (!_cm_thread-&gt;in_progress()) {
2771     _cm_thread-&gt;set_started();
2772     CGC_lock-&gt;notify();
2773   }
2774 }
2775 














2776 bool G1CollectedHeap::is_potential_eager_reclaim_candidate(HeapRegion* r) const {
2777   // We don&#39;t nominate objects with many remembered set entries, on
2778   // the assumption that such objects are likely still live.
2779   HeapRegionRemSet* rem_set = r-&gt;rem_set();
2780 
2781   return G1EagerReclaimHumongousObjectsWithStaleRefs ?
2782          rem_set-&gt;occupancy_less_or_equal_than(G1RSetSparseRegionEntries) :
2783          G1EagerReclaimHumongousObjects &amp;&amp; rem_set-&gt;is_empty();
2784 }
2785 
2786 #ifndef PRODUCT
2787 void G1CollectedHeap::verify_region_attr_remset_update() {
2788   class VerifyRegionAttrRemSet : public HeapRegionClosure {
2789   public:
2790     virtual bool do_heap_region(HeapRegion* r) {
2791       G1CollectedHeap* g1h = G1CollectedHeap::heap();
2792       bool const needs_remset_update = g1h-&gt;region_attr(r-&gt;bottom()).needs_remset_update();
2793       assert(r-&gt;rem_set()-&gt;is_tracked() == needs_remset_update,
2794              &quot;Region %u remset tracking status (%s) different to region attribute (%s)&quot;,
2795              r-&gt;hrm_index(), BOOL_TO_STR(r-&gt;rem_set()-&gt;is_tracked()), BOOL_TO_STR(needs_remset_update));
</pre>
</td>
</tr>
</table>
<center><a href="g1BarrierSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectedHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentRefine.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefineThread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 26 #define SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 27 

 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 #include &quot;utilities/ticks.hpp&quot;
 31 
 32 // Forward decl
 33 class G1ConcurrentRefine;
 34 class G1ConcurrentRefineThread;
 35 class outputStream;
 36 class ThreadClosure;
 37 
 38 // Helper class for refinement thread management. Used to start, stop and
 39 // iterate over them.
 40 class G1ConcurrentRefineThreadControl {
 41   G1ConcurrentRefine* _cr;
 42 
 43   G1ConcurrentRefineThread** _threads;
 44   uint _num_max_threads;
 45 
 46   // Create the refinement thread for the given worker id.
 47   // If initializing is true, ignore InjectGCWorkerCreationFailure.
</pre>
<hr />
<pre>
102   void update_zones(double logged_cards_scan_time,
103                     size_t processed_logged_cards,
104                     double goal_ms);
105 
106   static uint worker_id_offset();
107   void maybe_activate_more_threads(uint worker_id, size_t num_cur_cards);
108 
109   jint initialize();
110 public:
111   ~G1ConcurrentRefine();
112 
113   // Returns a G1ConcurrentRefine instance if succeeded to create/initialize the
114   // G1ConcurrentRefine instance. Otherwise, returns NULL with error code.
115   static G1ConcurrentRefine* create(jint* ecode);
116 
117   void stop();
118 
119   // Adjust refinement thresholds based on work done during the pause and the goal time.
120   void adjust(double logged_cards_scan_time, size_t processed_logged_cards, double goal_ms);
121 
<span class="line-modified">122   struct RefinementStats {</span>
<span class="line-modified">123     Tickspan _time;</span>
<span class="line-modified">124     size_t _cards;</span>
<span class="line-removed">125     RefinementStats(Tickspan time, size_t cards) : _time(time), _cards(cards) {}</span>
<span class="line-removed">126   };</span>
<span class="line-removed">127 </span>
<span class="line-removed">128   RefinementStats total_refinement_stats() const;</span>
129 
130   // Cards in the dirty card queue set.
131   size_t activation_threshold(uint worker_id) const;
132   size_t deactivation_threshold(uint worker_id) const;
133 
134   // Perform a single refinement step; called by the refinement
135   // threads.  Returns true if there was refinement work available.
<span class="line-modified">136   // Increments *total_refined_cards.</span>
<span class="line-modified">137   bool do_refinement_step(uint worker_id, size_t* total_refined_cards);</span>
138 
139   // Iterate over all concurrent refinement threads applying the given closure.
140   void threads_do(ThreadClosure *tc);
141 
142   // Maximum number of refinement threads.
143   static uint max_num_threads();
144 
145   void print_threads_on(outputStream* st) const;
146 
147   // Cards in the dirty card queue set.
148   size_t green_zone() const      { return _green_zone;  }
149   size_t yellow_zone() const     { return _yellow_zone; }
150   size_t red_zone() const        { return _red_zone;    }
151 };
152 
153 #endif // SHARE_GC_G1_G1CONCURRENTREFINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 26 #define SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 27 
<span class="line-added"> 28 #include &quot;gc/g1/g1ConcurrentRefineStats.hpp&quot;</span>
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 #include &quot;utilities/ticks.hpp&quot;
 32 
 33 // Forward decl
 34 class G1ConcurrentRefine;
 35 class G1ConcurrentRefineThread;
 36 class outputStream;
 37 class ThreadClosure;
 38 
 39 // Helper class for refinement thread management. Used to start, stop and
 40 // iterate over them.
 41 class G1ConcurrentRefineThreadControl {
 42   G1ConcurrentRefine* _cr;
 43 
 44   G1ConcurrentRefineThread** _threads;
 45   uint _num_max_threads;
 46 
 47   // Create the refinement thread for the given worker id.
 48   // If initializing is true, ignore InjectGCWorkerCreationFailure.
</pre>
<hr />
<pre>
103   void update_zones(double logged_cards_scan_time,
104                     size_t processed_logged_cards,
105                     double goal_ms);
106 
107   static uint worker_id_offset();
108   void maybe_activate_more_threads(uint worker_id, size_t num_cur_cards);
109 
110   jint initialize();
111 public:
112   ~G1ConcurrentRefine();
113 
114   // Returns a G1ConcurrentRefine instance if succeeded to create/initialize the
115   // G1ConcurrentRefine instance. Otherwise, returns NULL with error code.
116   static G1ConcurrentRefine* create(jint* ecode);
117 
118   void stop();
119 
120   // Adjust refinement thresholds based on work done during the pause and the goal time.
121   void adjust(double logged_cards_scan_time, size_t processed_logged_cards, double goal_ms);
122 
<span class="line-modified">123   // Return total of concurrent refinement stats for the</span>
<span class="line-modified">124   // ConcurrentRefineThreads.  Also reset the stats for the threads.</span>
<span class="line-modified">125   G1ConcurrentRefineStats get_and_reset_refinement_stats();</span>




126 
127   // Cards in the dirty card queue set.
128   size_t activation_threshold(uint worker_id) const;
129   size_t deactivation_threshold(uint worker_id) const;
130 
131   // Perform a single refinement step; called by the refinement
132   // threads.  Returns true if there was refinement work available.
<span class="line-modified">133   // Updates stats.</span>
<span class="line-modified">134   bool do_refinement_step(uint worker_id, G1ConcurrentRefineStats* stats);</span>
135 
136   // Iterate over all concurrent refinement threads applying the given closure.
137   void threads_do(ThreadClosure *tc);
138 
139   // Maximum number of refinement threads.
140   static uint max_num_threads();
141 
142   void print_threads_on(outputStream* st) const;
143 
144   // Cards in the dirty card queue set.
145   size_t green_zone() const      { return _green_zone;  }
146   size_t yellow_zone() const     { return _yellow_zone; }
147   size_t red_zone() const        { return _red_zone;    }
148 };
149 
150 #endif // SHARE_GC_G1_G1CONCURRENTREFINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="g1ConcurrentRefine.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefineThread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
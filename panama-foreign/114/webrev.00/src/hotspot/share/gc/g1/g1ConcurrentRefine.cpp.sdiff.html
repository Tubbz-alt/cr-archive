<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1ConcurrentRefine.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1CollectedHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefine.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentRefine.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
391       dcqs.set_process_cards_threshold(G1DirtyCardQueueSet::ProcessCardsThresholdNever);
392     } else {
393       // Worker 0 is the primary; wakeup is via dcqs notification.
394       STATIC_ASSERT(max_yellow_zone &lt;= INT_MAX);
395       size_t activate = activation_threshold(0);
396       dcqs.set_process_cards_threshold(activate);
397     }
398     dcqs.set_max_cards(red_zone());
399   }
400 
401   size_t curr_queue_size = dcqs.num_cards();
402   if ((dcqs.max_cards() &gt; 0) &amp;&amp;
403       (curr_queue_size &gt;= yellow_zone())) {
404     dcqs.set_max_cards_padding(curr_queue_size);
405   } else {
406     dcqs.set_max_cards_padding(0);
407   }
408   dcqs.notify_if_necessary();
409 }
410 
<span class="line-modified">411 G1ConcurrentRefine::RefinementStats G1ConcurrentRefine::total_refinement_stats() const {</span>
<span class="line-modified">412   struct CollectData : public ThreadClosure {</span>
<span class="line-modified">413     Tickspan _total_time;</span>
<span class="line-removed">414     size_t _total_cards;</span>
<span class="line-removed">415     CollectData() : _total_time(), _total_cards(0) {}</span>
416     virtual void do_thread(Thread* t) {
417       G1ConcurrentRefineThread* crt = static_cast&lt;G1ConcurrentRefineThread*&gt;(t);
<span class="line-modified">418       _total_time += crt-&gt;total_refinement_time();</span>
<span class="line-modified">419       _total_cards += crt-&gt;total_refined_cards();</span>

420     }
421   } collector;
<span class="line-modified">422   // Cast away const so we can call non-modifying closure on threads.</span>
<span class="line-modified">423   const_cast&lt;G1ConcurrentRefine*&gt;(this)-&gt;threads_do(&amp;collector);</span>
<span class="line-removed">424   return RefinementStats(collector._total_time, collector._total_cards);</span>
425 }
426 
427 size_t G1ConcurrentRefine::activation_threshold(uint worker_id) const {
428   Thresholds thresholds = calc_thresholds(_green_zone, _yellow_zone, worker_id);
429   return activation_level(thresholds);
430 }
431 
432 size_t G1ConcurrentRefine::deactivation_threshold(uint worker_id) const {
433   Thresholds thresholds = calc_thresholds(_green_zone, _yellow_zone, worker_id);
434   return deactivation_level(thresholds);
435 }
436 
437 uint G1ConcurrentRefine::worker_id_offset() {
438   return G1DirtyCardQueueSet::num_par_ids();
439 }
440 
441 void G1ConcurrentRefine::maybe_activate_more_threads(uint worker_id, size_t num_cur_cards) {
442   if (num_cur_cards &gt; activation_threshold(worker_id + 1)) {
443     _thread_control.maybe_activate_next(worker_id);
444   }
445 }
446 
447 bool G1ConcurrentRefine::do_refinement_step(uint worker_id,
<span class="line-modified">448                                             size_t* total_refined_cards) {</span>
449   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();
450 
451   size_t curr_cards = dcqs.num_cards();
452   // If the number of the cards falls down into the yellow zone,
453   // that means that the transition period after the evacuation pause has ended.
454   if (curr_cards &lt;= yellow_zone()) {
455     dcqs.discard_max_cards_padding();
456   }
457 
458   maybe_activate_more_threads(worker_id, curr_cards);
459 
460   // Process the next buffer, if there are enough left.
461   return dcqs.refine_completed_buffer_concurrently(worker_id + worker_id_offset(),
462                                                    deactivation_threshold(worker_id),
<span class="line-modified">463                                                    total_refined_cards);</span>
464 }
</pre>
</td>
<td>
<hr />
<pre>
391       dcqs.set_process_cards_threshold(G1DirtyCardQueueSet::ProcessCardsThresholdNever);
392     } else {
393       // Worker 0 is the primary; wakeup is via dcqs notification.
394       STATIC_ASSERT(max_yellow_zone &lt;= INT_MAX);
395       size_t activate = activation_threshold(0);
396       dcqs.set_process_cards_threshold(activate);
397     }
398     dcqs.set_max_cards(red_zone());
399   }
400 
401   size_t curr_queue_size = dcqs.num_cards();
402   if ((dcqs.max_cards() &gt; 0) &amp;&amp;
403       (curr_queue_size &gt;= yellow_zone())) {
404     dcqs.set_max_cards_padding(curr_queue_size);
405   } else {
406     dcqs.set_max_cards_padding(0);
407   }
408   dcqs.notify_if_necessary();
409 }
410 
<span class="line-modified">411 G1ConcurrentRefineStats G1ConcurrentRefine::get_and_reset_refinement_stats() {</span>
<span class="line-modified">412   struct CollectStats : public ThreadClosure {</span>
<span class="line-modified">413     G1ConcurrentRefineStats _total_stats;</span>


414     virtual void do_thread(Thread* t) {
415       G1ConcurrentRefineThread* crt = static_cast&lt;G1ConcurrentRefineThread*&gt;(t);
<span class="line-modified">416       G1ConcurrentRefineStats&amp; stats = *crt-&gt;refinement_stats();</span>
<span class="line-modified">417       _total_stats += stats;</span>
<span class="line-added">418       stats.reset();</span>
419     }
420   } collector;
<span class="line-modified">421   threads_do(&amp;collector);</span>
<span class="line-modified">422   return collector._total_stats;</span>

423 }
424 
425 size_t G1ConcurrentRefine::activation_threshold(uint worker_id) const {
426   Thresholds thresholds = calc_thresholds(_green_zone, _yellow_zone, worker_id);
427   return activation_level(thresholds);
428 }
429 
430 size_t G1ConcurrentRefine::deactivation_threshold(uint worker_id) const {
431   Thresholds thresholds = calc_thresholds(_green_zone, _yellow_zone, worker_id);
432   return deactivation_level(thresholds);
433 }
434 
435 uint G1ConcurrentRefine::worker_id_offset() {
436   return G1DirtyCardQueueSet::num_par_ids();
437 }
438 
439 void G1ConcurrentRefine::maybe_activate_more_threads(uint worker_id, size_t num_cur_cards) {
440   if (num_cur_cards &gt; activation_threshold(worker_id + 1)) {
441     _thread_control.maybe_activate_next(worker_id);
442   }
443 }
444 
445 bool G1ConcurrentRefine::do_refinement_step(uint worker_id,
<span class="line-modified">446                                             G1ConcurrentRefineStats* stats) {</span>
447   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();
448 
449   size_t curr_cards = dcqs.num_cards();
450   // If the number of the cards falls down into the yellow zone,
451   // that means that the transition period after the evacuation pause has ended.
452   if (curr_cards &lt;= yellow_zone()) {
453     dcqs.discard_max_cards_padding();
454   }
455 
456   maybe_activate_more_threads(worker_id, curr_cards);
457 
458   // Process the next buffer, if there are enough left.
459   return dcqs.refine_completed_buffer_concurrently(worker_id + worker_id_offset(),
460                                                    deactivation_threshold(worker_id),
<span class="line-modified">461                                                    stats);</span>
462 }
</pre>
</td>
</tr>
</table>
<center><a href="g1CollectedHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefine.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
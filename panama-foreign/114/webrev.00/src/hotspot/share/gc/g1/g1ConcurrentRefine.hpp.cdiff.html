<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentRefine.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefineThread.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,10 ***</span>
<span class="line-new-header">--- 23,11 ---</span>
   */
  
  #ifndef SHARE_GC_G1_G1CONCURRENTREFINE_HPP
  #define SHARE_GC_G1_G1CONCURRENTREFINE_HPP
  
<span class="line-added">+ #include &quot;gc/g1/g1ConcurrentRefineStats.hpp&quot;</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;utilities/ticks.hpp&quot;
  
  // Forward decl
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,26 ***</span>
    void stop();
  
    // Adjust refinement thresholds based on work done during the pause and the goal time.
    void adjust(double logged_cards_scan_time, size_t processed_logged_cards, double goal_ms);
  
<span class="line-modified">!   struct RefinementStats {</span>
<span class="line-modified">!     Tickspan _time;</span>
<span class="line-modified">!     size_t _cards;</span>
<span class="line-removed">-     RefinementStats(Tickspan time, size_t cards) : _time(time), _cards(cards) {}</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- </span>
<span class="line-removed">-   RefinementStats total_refinement_stats() const;</span>
  
    // Cards in the dirty card queue set.
    size_t activation_threshold(uint worker_id) const;
    size_t deactivation_threshold(uint worker_id) const;
  
    // Perform a single refinement step; called by the refinement
    // threads.  Returns true if there was refinement work available.
<span class="line-modified">!   // Increments *total_refined_cards.</span>
<span class="line-modified">!   bool do_refinement_step(uint worker_id, size_t* total_refined_cards);</span>
  
    // Iterate over all concurrent refinement threads applying the given closure.
    void threads_do(ThreadClosure *tc);
  
    // Maximum number of refinement threads.
<span class="line-new-header">--- 118,22 ---</span>
    void stop();
  
    // Adjust refinement thresholds based on work done during the pause and the goal time.
    void adjust(double logged_cards_scan_time, size_t processed_logged_cards, double goal_ms);
  
<span class="line-modified">!   // Return total of concurrent refinement stats for the</span>
<span class="line-modified">!   // ConcurrentRefineThreads.  Also reset the stats for the threads.</span>
<span class="line-modified">!   G1ConcurrentRefineStats get_and_reset_refinement_stats();</span>
  
    // Cards in the dirty card queue set.
    size_t activation_threshold(uint worker_id) const;
    size_t deactivation_threshold(uint worker_id) const;
  
    // Perform a single refinement step; called by the refinement
    // threads.  Returns true if there was refinement work available.
<span class="line-modified">!   // Updates stats.</span>
<span class="line-modified">!   bool do_refinement_step(uint worker_id, G1ConcurrentRefineStats* stats);</span>
  
    // Iterate over all concurrent refinement threads applying the given closure.
    void threads_do(ThreadClosure *tc);
  
    // Maximum number of refinement threads.
</pre>
<center><a href="g1ConcurrentRefine.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefineThread.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
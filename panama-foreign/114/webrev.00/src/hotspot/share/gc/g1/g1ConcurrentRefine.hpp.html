<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 26 #define SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 27 
 28 #include &quot;gc/g1/g1ConcurrentRefineStats.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 #include &quot;utilities/ticks.hpp&quot;
 32 
 33 // Forward decl
 34 class G1ConcurrentRefine;
 35 class G1ConcurrentRefineThread;
 36 class outputStream;
 37 class ThreadClosure;
 38 
 39 // Helper class for refinement thread management. Used to start, stop and
 40 // iterate over them.
 41 class G1ConcurrentRefineThreadControl {
 42   G1ConcurrentRefine* _cr;
 43 
 44   G1ConcurrentRefineThread** _threads;
 45   uint _num_max_threads;
 46 
 47   // Create the refinement thread for the given worker id.
 48   // If initializing is true, ignore InjectGCWorkerCreationFailure.
 49   G1ConcurrentRefineThread* create_refinement_thread(uint worker_id, bool initializing);
 50 public:
 51   G1ConcurrentRefineThreadControl();
 52   ~G1ConcurrentRefineThreadControl();
 53 
 54   jint initialize(G1ConcurrentRefine* cr, uint num_max_threads);
 55 
 56   // If there is a &quot;successor&quot; thread that can be activated given the current id,
 57   // activate it.
 58   void maybe_activate_next(uint cur_worker_id);
 59 
 60   void print_on(outputStream* st) const;
 61   void worker_threads_do(ThreadClosure* tc);
 62   void stop();
 63 };
 64 
 65 // Controls refinement threads and their activation based on the number of
 66 // cards currently available in the global dirty card queue.
 67 // Refinement threads obtain work from the queue (a buffer at a time) based
 68 // on these thresholds. They are activated gradually based on the amount of
 69 // work to do.
 70 // Refinement thread n activates thread n+1 if the instance of this class determines there
 71 // is enough work available. Threads deactivate themselves if the current amount of
 72 // available cards falls below their individual threshold.
 73 class G1ConcurrentRefine : public CHeapObj&lt;mtGC&gt; {
 74   G1ConcurrentRefineThreadControl _thread_control;
 75   /*
 76    * The value of the completed dirty card queue length falls into one of 3 zones:
 77    * green, yellow, red. If the value is in [0, green) nothing is
 78    * done, the buffered cards are left unprocessed to enable the caching effect of the
 79    * dirtied cards. In the yellow zone [green, yellow) the concurrent refinement
 80    * threads are gradually activated. In [yellow, red) all threads are
 81    * running. If the length becomes red (max queue length) the mutators start
 82    * processing cards too.
 83    *
 84    * There are some interesting cases (when G1UseAdaptiveConcRefinement
 85    * is turned off):
 86    * 1) green = yellow = red = 0. In this case the mutator will process all
 87    *    cards. Except for those that are created by the deferred updates
 88    *    machinery during a collection.
 89    * 2) green = 0. Means no caching. Can be a good way to minimize the
 90    *    amount of time spent updating remembered sets during a collection.
 91    */
 92   size_t _green_zone;
 93   size_t _yellow_zone;
 94   size_t _red_zone;
 95   size_t _min_yellow_zone_size;
 96 
 97   G1ConcurrentRefine(size_t green_zone,
 98                      size_t yellow_zone,
 99                      size_t red_zone,
100                      size_t min_yellow_zone_size);
101 
102   // Update green/yellow/red zone values based on how well goals are being met.
103   void update_zones(double logged_cards_scan_time,
104                     size_t processed_logged_cards,
105                     double goal_ms);
106 
107   static uint worker_id_offset();
108   void maybe_activate_more_threads(uint worker_id, size_t num_cur_cards);
109 
110   jint initialize();
111 public:
112   ~G1ConcurrentRefine();
113 
114   // Returns a G1ConcurrentRefine instance if succeeded to create/initialize the
115   // G1ConcurrentRefine instance. Otherwise, returns NULL with error code.
116   static G1ConcurrentRefine* create(jint* ecode);
117 
118   void stop();
119 
120   // Adjust refinement thresholds based on work done during the pause and the goal time.
121   void adjust(double logged_cards_scan_time, size_t processed_logged_cards, double goal_ms);
122 
123   // Return total of concurrent refinement stats for the
124   // ConcurrentRefineThreads.  Also reset the stats for the threads.
125   G1ConcurrentRefineStats get_and_reset_refinement_stats();
126 
127   // Cards in the dirty card queue set.
128   size_t activation_threshold(uint worker_id) const;
129   size_t deactivation_threshold(uint worker_id) const;
130 
131   // Perform a single refinement step; called by the refinement
132   // threads.  Returns true if there was refinement work available.
133   // Updates stats.
134   bool do_refinement_step(uint worker_id, G1ConcurrentRefineStats* stats);
135 
136   // Iterate over all concurrent refinement threads applying the given closure.
137   void threads_do(ThreadClosure *tc);
138 
139   // Maximum number of refinement threads.
140   static uint max_num_threads();
141 
142   void print_threads_on(outputStream* st) const;
143 
144   // Cards in the dirty card queue set.
145   size_t green_zone() const      { return _green_zone;  }
146   size_t yellow_zone() const     { return _yellow_zone; }
147   size_t red_zone() const        { return _red_zone;    }
148 };
149 
150 #endif // SHARE_GC_G1_G1CONCURRENTREFINE_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1Policy.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1Policy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1RemSet.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Policy.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 84 
 85   // The survivor rate groups below must be initialized after the predictor because they
 86   // indirectly use it through the &quot;this&quot; object passed to their constructor.
 87   G1SurvRateGroup* _eden_surv_rate_group;
 88   G1SurvRateGroup* _survivor_surv_rate_group;
 89 
 90   double _reserve_factor;
 91   // This will be set when the heap is expanded
 92   // for the first time during initialization.
 93   uint   _reserve_regions;
 94 
 95   G1YoungGenSizer* _young_gen_sizer;
 96 
 97   uint _free_regions_at_end_of_collection;
 98 
 99   size_t _rs_length;
100 
101   size_t _rs_length_prediction;
102 
103   size_t _pending_cards_at_gc_start;
<span class="line-removed">104   size_t _pending_cards_at_prev_gc_end;</span>
<span class="line-removed">105   size_t _total_mutator_refined_cards;</span>
<span class="line-removed">106   size_t _total_concurrent_refined_cards;</span>
<span class="line-removed">107   Tickspan _total_concurrent_refinement_time;</span>
108 
109   // The amount of allocated bytes in old gen during the last mutator and the following
110   // young GC phase.
111   size_t _bytes_allocated_in_old_since_last_gc;
112 
113   G1InitialMarkToMixedTimeTracker _initial_mark_to_mixed;
114 
115   bool should_update_surv_rate_group_predictors() {
116     return collector_state()-&gt;in_young_only_phase() &amp;&amp; !collector_state()-&gt;mark_or_rebuild_in_progress();
117   }
118 
119   double logged_cards_processing_time() const;
120 public:
121   const G1Predictions&amp; predictor() const { return _predictor; }
122   const G1Analytics* analytics()   const { return const_cast&lt;const G1Analytics*&gt;(_analytics); }
123 
124   G1RemSetTrackingPolicy* remset_tracker() { return &amp;_remset_tracker; }
125 
126   // Add the given number of bytes to the total number of allocated bytes in the old gen.
127   void add_bytes_allocated_in_old_since_last_gc(size_t bytes) { _bytes_allocated_in_old_since_last_gc += bytes; }
</pre>
<hr />
<pre>
270   void maybe_start_marking();
271 
272   // The kind of STW pause.
273   enum PauseKind {
274     FullGC,
275     YoungOnlyGC,
276     MixedGC,
277     LastYoungGC,
278     InitialMarkGC,
279     Cleanup,
280     Remark
281   };
282 
283   // Calculate PauseKind from internal state.
284   PauseKind young_gc_pause_kind() const;
285   // Record the given STW pause with the given start and end times (in s).
286   void record_pause(PauseKind kind, double start, double end);
287   // Indicate that we aborted marking before doing any mixed GCs.
288   void abort_time_to_mixed_tracking();
289 
<span class="line-modified">290   void record_concurrent_refinement_data(bool is_full_collection);</span>

291 
292 public:
293 
294   G1Policy(STWGCTimer* gc_timer);
295 
296   virtual ~G1Policy();
297 
298   static G1Policy* create_policy(STWGCTimer* gc_timer_stw);
299 
300   G1CollectorState* collector_state() const;
301 
302   G1GCPhaseTimes* phase_times() const { return _phase_times; }
303 
304   // Check the current value of the young list RSet length and
305   // compare it against the last prediction. If the current value is
306   // higher, recalculate the young list target length prediction.
307   void revise_young_list_target_length_if_necessary(size_t rs_length);
308 
309   // This should be called after the heap is resized.
310   void record_new_heap_size(uint new_number_of_regions);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 84 
 85   // The survivor rate groups below must be initialized after the predictor because they
 86   // indirectly use it through the &quot;this&quot; object passed to their constructor.
 87   G1SurvRateGroup* _eden_surv_rate_group;
 88   G1SurvRateGroup* _survivor_surv_rate_group;
 89 
 90   double _reserve_factor;
 91   // This will be set when the heap is expanded
 92   // for the first time during initialization.
 93   uint   _reserve_regions;
 94 
 95   G1YoungGenSizer* _young_gen_sizer;
 96 
 97   uint _free_regions_at_end_of_collection;
 98 
 99   size_t _rs_length;
100 
101   size_t _rs_length_prediction;
102 
103   size_t _pending_cards_at_gc_start;




104 
105   // The amount of allocated bytes in old gen during the last mutator and the following
106   // young GC phase.
107   size_t _bytes_allocated_in_old_since_last_gc;
108 
109   G1InitialMarkToMixedTimeTracker _initial_mark_to_mixed;
110 
111   bool should_update_surv_rate_group_predictors() {
112     return collector_state()-&gt;in_young_only_phase() &amp;&amp; !collector_state()-&gt;mark_or_rebuild_in_progress();
113   }
114 
115   double logged_cards_processing_time() const;
116 public:
117   const G1Predictions&amp; predictor() const { return _predictor; }
118   const G1Analytics* analytics()   const { return const_cast&lt;const G1Analytics*&gt;(_analytics); }
119 
120   G1RemSetTrackingPolicy* remset_tracker() { return &amp;_remset_tracker; }
121 
122   // Add the given number of bytes to the total number of allocated bytes in the old gen.
123   void add_bytes_allocated_in_old_since_last_gc(size_t bytes) { _bytes_allocated_in_old_since_last_gc += bytes; }
</pre>
<hr />
<pre>
266   void maybe_start_marking();
267 
268   // The kind of STW pause.
269   enum PauseKind {
270     FullGC,
271     YoungOnlyGC,
272     MixedGC,
273     LastYoungGC,
274     InitialMarkGC,
275     Cleanup,
276     Remark
277   };
278 
279   // Calculate PauseKind from internal state.
280   PauseKind young_gc_pause_kind() const;
281   // Record the given STW pause with the given start and end times (in s).
282   void record_pause(PauseKind kind, double start, double end);
283   // Indicate that we aborted marking before doing any mixed GCs.
284   void abort_time_to_mixed_tracking();
285 
<span class="line-modified">286   // Record and log stats before not-full collection.</span>
<span class="line-added">287   void record_concurrent_refinement_stats();</span>
288 
289 public:
290 
291   G1Policy(STWGCTimer* gc_timer);
292 
293   virtual ~G1Policy();
294 
295   static G1Policy* create_policy(STWGCTimer* gc_timer_stw);
296 
297   G1CollectorState* collector_state() const;
298 
299   G1GCPhaseTimes* phase_times() const { return _phase_times; }
300 
301   // Check the current value of the young list RSet length and
302   // compare it against the last prediction. If the current value is
303   // higher, recalculate the young list target length prediction.
304   void revise_young_list_target_length_if_necessary(size_t rs_length);
305 
306   // This should be called after the heap is resized.
307   void record_new_heap_size(uint new_number_of_regions);
</pre>
</td>
</tr>
</table>
<center><a href="g1Policy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1RemSet.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
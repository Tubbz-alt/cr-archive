<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/heapRegionManager.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1RemSetSummary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionManager.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegionManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
325     if (is_on_preferred_index(expand_candidate, preferred_index)) {
326       // We have found a candidate on the preffered node, break.
327       break;
328     }
329   }
330 
331   if (expand_candidate == UINT_MAX) {
332      // No regions left, expand failed.
333     return 0;
334   }
335 
336   expand_exact(expand_candidate, 1, NULL);
337   return 1;
338 }
339 
340 bool HeapRegionManager::is_on_preferred_index(uint region_index, uint preferred_node_index) {
341   uint region_node_index = G1NUMA::numa()-&gt;preferred_node_index_for_index(region_index);
342   return region_node_index == preferred_node_index;
343 }
344 
<span class="line-modified">345 void HeapRegionManager::guarantee_contiguous_range(uint start, uint num_regions) {</span>

346   // General sanity check, regions found should either be available and empty
347   // or not available so that we can make them available and use them.
348   for (uint i = start; i &lt; (start + num_regions); i++) {
349     HeapRegion* hr = _regions.get_by_index(i);
<span class="line-modified">350     guarantee(!is_available(i) || hr-&gt;is_free(),</span>
<span class="line-modified">351               &quot;Found region sequence starting at &quot; UINT32_FORMAT &quot;, length &quot; UINT32_FORMAT</span>
<span class="line-modified">352               &quot; that is not free at &quot; UINT32_FORMAT &quot;. Hr is &quot; PTR_FORMAT &quot;, type is %s&quot;,</span>
<span class="line-modified">353               start, num_regions, i, p2i(hr), hr-&gt;get_type_str());</span>
354   }
355 }

356 
357 uint HeapRegionManager::find_contiguous_in_range(uint start, uint end, uint num_regions) {
358   assert(start &lt;= end, &quot;precondition&quot;);
359   assert(num_regions &gt;= 1, &quot;precondition&quot;);
360   uint candidate = start;       // First region in candidate sequence.
361   uint unchecked = candidate;   // First unchecked region in candidate.
362   // While the candidate sequence fits in the range...
363   while (num_regions &lt;= (end - candidate)) {
364     // Walk backward over the regions for the current candidate.
365     for (uint i = candidate + num_regions - 1; true; --i) {
366       if (is_available(i) &amp;&amp; !at(i)-&gt;is_free()) {
367         // Region i can&#39;t be used, so restart with i+1 as the start
368         // of a new candidate sequence, and with the region after the
369         // old candidate sequence being the first unchecked region.
370         unchecked = candidate + num_regions;
371         candidate = i + 1;
372         break;
373       } else if (i == unchecked) {
374         // All regions of candidate sequence have passed check.
<span class="line-modified">375         guarantee_contiguous_range(candidate, num_regions);</span>
376         return candidate;
377       }
378     }
379   }
380   return G1_NO_HRM_INDEX;
381 }
382 
383 uint HeapRegionManager::find_contiguous_in_free_list(uint num_regions) {
384   BitMap::idx_t range_start = 0;
385   BitMap::idx_t range_end = range_start;
386   uint candidate = G1_NO_HRM_INDEX;
387 
388   do {
389     range_start = _available_map.get_next_one_offset(range_end);
390     range_end = _available_map.get_next_zero_offset(range_start);
391     candidate = find_contiguous_in_range((uint) range_start, (uint) range_end, num_regions);
392   } while (candidate == G1_NO_HRM_INDEX &amp;&amp; range_end &lt; max_length());
393 
394   return candidate;
395 }
</pre>
</td>
<td>
<hr />
<pre>
325     if (is_on_preferred_index(expand_candidate, preferred_index)) {
326       // We have found a candidate on the preffered node, break.
327       break;
328     }
329   }
330 
331   if (expand_candidate == UINT_MAX) {
332      // No regions left, expand failed.
333     return 0;
334   }
335 
336   expand_exact(expand_candidate, 1, NULL);
337   return 1;
338 }
339 
340 bool HeapRegionManager::is_on_preferred_index(uint region_index, uint preferred_node_index) {
341   uint region_node_index = G1NUMA::numa()-&gt;preferred_node_index_for_index(region_index);
342   return region_node_index == preferred_node_index;
343 }
344 
<span class="line-modified">345 #ifdef ASSERT</span>
<span class="line-added">346 void HeapRegionManager::assert_contiguous_range(uint start, uint num_regions) {</span>
347   // General sanity check, regions found should either be available and empty
348   // or not available so that we can make them available and use them.
349   for (uint i = start; i &lt; (start + num_regions); i++) {
350     HeapRegion* hr = _regions.get_by_index(i);
<span class="line-modified">351     assert(!is_available(i) || hr-&gt;is_free(),</span>
<span class="line-modified">352            &quot;Found region sequence starting at &quot; UINT32_FORMAT &quot;, length &quot; UINT32_FORMAT</span>
<span class="line-modified">353            &quot; that is not free at &quot; UINT32_FORMAT &quot;. Hr is &quot; PTR_FORMAT &quot;, type is %s&quot;,</span>
<span class="line-modified">354            start, num_regions, i, p2i(hr), hr-&gt;get_type_str());</span>
355   }
356 }
<span class="line-added">357 #endif</span>
358 
359 uint HeapRegionManager::find_contiguous_in_range(uint start, uint end, uint num_regions) {
360   assert(start &lt;= end, &quot;precondition&quot;);
361   assert(num_regions &gt;= 1, &quot;precondition&quot;);
362   uint candidate = start;       // First region in candidate sequence.
363   uint unchecked = candidate;   // First unchecked region in candidate.
364   // While the candidate sequence fits in the range...
365   while (num_regions &lt;= (end - candidate)) {
366     // Walk backward over the regions for the current candidate.
367     for (uint i = candidate + num_regions - 1; true; --i) {
368       if (is_available(i) &amp;&amp; !at(i)-&gt;is_free()) {
369         // Region i can&#39;t be used, so restart with i+1 as the start
370         // of a new candidate sequence, and with the region after the
371         // old candidate sequence being the first unchecked region.
372         unchecked = candidate + num_regions;
373         candidate = i + 1;
374         break;
375       } else if (i == unchecked) {
376         // All regions of candidate sequence have passed check.
<span class="line-modified">377         assert_contiguous_range(candidate, num_regions);</span>
378         return candidate;
379       }
380     }
381   }
382   return G1_NO_HRM_INDEX;
383 }
384 
385 uint HeapRegionManager::find_contiguous_in_free_list(uint num_regions) {
386   BitMap::idx_t range_start = 0;
387   BitMap::idx_t range_end = range_start;
388   uint candidate = G1_NO_HRM_INDEX;
389 
390   do {
391     range_start = _available_map.get_next_one_offset(range_end);
392     range_end = _available_map.get_next_zero_offset(range_start);
393     candidate = find_contiguous_in_range((uint) range_start, (uint) range_end, num_regions);
394   } while (candidate == G1_NO_HRM_INDEX &amp;&amp; range_end &lt; max_length());
395 
396   return candidate;
397 }
</pre>
</td>
</tr>
</table>
<center><a href="g1RemSetSummary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionManager.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
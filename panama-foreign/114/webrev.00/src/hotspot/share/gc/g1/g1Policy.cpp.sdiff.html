<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1Policy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1GCPhaseTimes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Policy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/g1/g1Analytics.hpp&quot;
  27 #include &quot;gc/g1/g1Arguments.hpp&quot;
  28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  29 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
  30 #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
  31 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  32 #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
  33 #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;

  34 #include &quot;gc/g1/g1CollectionSetChooser.hpp&quot;
  35 #include &quot;gc/g1/g1HeterogeneousHeapPolicy.hpp&quot;
  36 #include &quot;gc/g1/g1HotCardCache.hpp&quot;
  37 #include &quot;gc/g1/g1IHOPControl.hpp&quot;
  38 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
  39 #include &quot;gc/g1/g1Policy.hpp&quot;
  40 #include &quot;gc/g1/g1SurvivorRegions.hpp&quot;
  41 #include &quot;gc/g1/g1YoungGenSizer.hpp&quot;
  42 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  43 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  44 #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;
  45 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
<span class="line-modified">  46 #include &quot;logging/logStream.hpp&quot;</span>
  47 #include &quot;runtime/arguments.hpp&quot;
  48 #include &quot;runtime/java.hpp&quot;
  49 #include &quot;runtime/mutexLocker.hpp&quot;
  50 #include &quot;utilities/debug.hpp&quot;
  51 #include &quot;utilities/growableArray.hpp&quot;
  52 #include &quot;utilities/pair.hpp&quot;
  53 
  54 G1Policy::G1Policy(STWGCTimer* gc_timer) :
  55   _predictor(G1ConfidencePercent / 100.0),
  56   _analytics(new G1Analytics(&amp;_predictor)),
  57   _remset_tracker(),
  58   _mmu_tracker(new G1MMUTrackerQueue(GCPauseIntervalMillis / 1000.0, MaxGCPauseMillis / 1000.0)),
  59   _ihop_control(create_ihop_control(&amp;_predictor)),
  60   _policy_counters(new GCPolicyCounters(&quot;GarbageFirst&quot;, 1, 2)),
  61   _full_collection_start_sec(0.0),
  62   _collection_pause_end_millis(os::javaTimeNanos() / NANOSECS_PER_MILLISEC),
  63   _young_list_target_length(0),
  64   _young_list_fixed_length(0),
  65   _young_list_max_length(0),
  66   _eden_surv_rate_group(new G1SurvRateGroup()),
  67   _survivor_surv_rate_group(new G1SurvRateGroup()),
  68   _reserve_factor((double) G1ReservePercent / 100.0),
  69   _reserve_regions(0),
  70   _young_gen_sizer(G1YoungGenSizer::create_gen_sizer()),
  71   _free_regions_at_end_of_collection(0),
  72   _rs_length(0),
  73   _rs_length_prediction(0),
  74   _pending_cards_at_gc_start(0),
<span class="line-removed">  75   _pending_cards_at_prev_gc_end(0),</span>
<span class="line-removed">  76   _total_mutator_refined_cards(0),</span>
<span class="line-removed">  77   _total_concurrent_refined_cards(0),</span>
<span class="line-removed">  78   _total_concurrent_refinement_time(),</span>
  79   _bytes_allocated_in_old_since_last_gc(0),
  80   _initial_mark_to_mixed(),
  81   _collection_set(NULL),
  82   _g1h(NULL),
  83   _phase_times(new G1GCPhaseTimes(gc_timer, ParallelGCThreads)),
  84   _mark_remark_start_sec(0),
  85   _mark_cleanup_start_sec(0),
  86   _tenuring_threshold(MaxTenuringThreshold),
  87   _max_survivor_regions(0),
  88   _survivors_age_table(true)
  89 {
  90 }
  91 
  92 G1Policy::~G1Policy() {
  93   delete _ihop_control;
  94   delete _young_gen_sizer;
  95 }
  96 
  97 G1Policy* G1Policy::create_policy(STWGCTimer* gc_timer_stw) {
  98   if (G1Arguments::is_heterogeneous_heap()) {
</pre>
<hr />
<pre>
 415     update_young_list_max_and_target_length(rs_length_prediction);
 416   }
 417 }
 418 
 419 void G1Policy::update_rs_length_prediction() {
 420   update_rs_length_prediction(_analytics-&gt;predict_rs_length());
 421 }
 422 
 423 void G1Policy::update_rs_length_prediction(size_t prediction) {
 424   if (collector_state()-&gt;in_young_only_phase() &amp;&amp; use_adaptive_young_list_length()) {
 425     _rs_length_prediction = prediction;
 426   }
 427 }
 428 
 429 void G1Policy::record_full_collection_start() {
 430   _full_collection_start_sec = os::elapsedTime();
 431   // Release the future to-space so that it is available for compaction into.
 432   collector_state()-&gt;set_in_young_only_phase(false);
 433   collector_state()-&gt;set_in_full_gc(true);
 434   _collection_set-&gt;clear_candidates();
<span class="line-modified"> 435   record_concurrent_refinement_data(true /* is_full_collection */);</span>
 436 }
 437 
 438 void G1Policy::record_full_collection_end() {
 439   // Consider this like a collection pause for the purposes of allocation
 440   // since last pause.
 441   double end_sec = os::elapsedTime();
 442   double full_gc_time_sec = end_sec - _full_collection_start_sec;
 443   double full_gc_time_ms = full_gc_time_sec * 1000.0;
 444 
 445   _analytics-&gt;update_recent_gc_times(end_sec, full_gc_time_ms);
 446 
 447   collector_state()-&gt;set_in_full_gc(false);
 448 
 449   // &quot;Nuke&quot; the heuristics that control the young/mixed GC
 450   // transitions and make sure we start with young GCs after the Full GC.
 451   collector_state()-&gt;set_in_young_only_phase(true);
 452   collector_state()-&gt;set_in_young_gc_before_mixed(false);
 453   collector_state()-&gt;set_initiate_conc_mark_if_possible(need_to_start_conc_mark(&quot;end of Full GC&quot;, 0));
 454   collector_state()-&gt;set_in_initial_mark_gc(false);
 455   collector_state()-&gt;set_mark_or_rebuild_in_progress(false);
 456   collector_state()-&gt;set_clearing_next_bitmap(false);
 457 
 458   _eden_surv_rate_group-&gt;start_adding_regions();
 459   // also call this on any additional surv rate groups
 460 
 461   _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
 462   _survivor_surv_rate_group-&gt;reset();
 463   update_young_list_max_and_target_length();
 464   update_rs_length_prediction();
<span class="line-removed"> 465   _pending_cards_at_prev_gc_end = _g1h-&gt;pending_card_num();</span>
 466 
 467   _bytes_allocated_in_old_since_last_gc = 0;
 468 
 469   record_pause(FullGC, _full_collection_start_sec, end_sec);
 470 }
 471 
<span class="line-modified"> 472 void G1Policy::record_concurrent_refinement_data(bool is_full_collection) {</span>
<span class="line-modified"> 473   _pending_cards_at_gc_start = _g1h-&gt;pending_card_num();</span>












 474 
<span class="line-modified"> 475   // Record info about concurrent refinement thread processing.</span>



 476   G1ConcurrentRefine* cr = _g1h-&gt;concurrent_refine();
<span class="line-modified"> 477   G1ConcurrentRefine::RefinementStats cr_stats = cr-&gt;total_refinement_stats();</span>
<span class="line-modified"> 478 </span>
<span class="line-modified"> 479   Tickspan cr_time = cr_stats._time - _total_concurrent_refinement_time;</span>
<span class="line-modified"> 480   _total_concurrent_refinement_time = cr_stats._time;</span>
<span class="line-modified"> 481 </span>
<span class="line-modified"> 482   size_t cr_cards = cr_stats._cards - _total_concurrent_refined_cards;</span>
<span class="line-modified"> 483   _total_concurrent_refined_cards = cr_stats._cards;</span>
<span class="line-modified"> 484 </span>
<span class="line-modified"> 485   // Don&#39;t update rate if full collection.  We could be in an implicit full</span>
<span class="line-modified"> 486   // collection after a non-full collection failure, in which case there</span>
<span class="line-modified"> 487   // wasn&#39;t any mutator/cr-thread activity since last recording.  And if</span>
<span class="line-modified"> 488   // we&#39;re in an explicit full collection, the time since the last GC can</span>
<span class="line-modified"> 489   // be arbitrarily short, so not a very good sample.  Similarly, don&#39;t</span>
<span class="line-modified"> 490   // update the rate if the current sample is empty or time is zero.</span>
<span class="line-removed"> 491   if (!is_full_collection &amp;&amp; (cr_cards &gt; 0) &amp;&amp; (cr_time &gt; Tickspan())) {</span>
<span class="line-removed"> 492     double rate = cr_cards / (cr_time.seconds() * MILLIUNITS);</span>
 493     _analytics-&gt;report_concurrent_refine_rate_ms(rate);

 494   }
 495 
<span class="line-removed"> 496   // Record info about mutator thread processing.</span>
<span class="line-removed"> 497   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="line-removed"> 498   size_t mut_total_cards = dcqs.total_mutator_refined_cards();</span>
<span class="line-removed"> 499   size_t mut_cards = mut_total_cards - _total_mutator_refined_cards;</span>
<span class="line-removed"> 500   _total_mutator_refined_cards = mut_total_cards;</span>
<span class="line-removed"> 501 </span>
 502   // Record mutator&#39;s card logging rate.
<span class="line-modified"> 503   // Don&#39;t update if full collection; see above.</span>
<span class="line-modified"> 504   if (!is_full_collection) {</span>
<span class="line-modified"> 505     size_t total_cards = _pending_cards_at_gc_start + cr_cards + mut_cards;</span>
<span class="line-modified"> 506     assert(_pending_cards_at_prev_gc_end &lt;= total_cards,</span>
<span class="line-modified"> 507            &quot;untracked cards: last pending: &quot; SIZE_FORMAT</span>
<span class="line-modified"> 508            &quot;, pending: &quot; SIZE_FORMAT &quot;, conc refine: &quot; SIZE_FORMAT</span>
<span class="line-modified"> 509            &quot;, mut refine:&quot; SIZE_FORMAT,</span>
<span class="line-modified"> 510            _pending_cards_at_prev_gc_end, _pending_cards_at_gc_start,</span>
<span class="line-modified"> 511            cr_cards, mut_cards);</span>
<span class="line-modified"> 512     size_t logged_cards = total_cards - _pending_cards_at_prev_gc_end;</span>
<span class="line-modified"> 513     double logging_start_time = _analytics-&gt;prev_collection_pause_end_ms();</span>
<span class="line-removed"> 514     double logging_end_time = Ticks::now().seconds() * MILLIUNITS;</span>
<span class="line-removed"> 515     double logging_time = logging_end_time - logging_start_time;</span>
<span class="line-removed"> 516     // Unlike above for conc-refine rate, here we should not require a</span>
<span class="line-removed"> 517     // non-empty sample, since an application could go some time with only</span>
<span class="line-removed"> 518     // young-gen or filtered out writes.  But we&#39;ll ignore unusually short</span>
<span class="line-removed"> 519     // sample periods, as they may just pollute the predictions.</span>
<span class="line-removed"> 520     if (logging_time &gt; 1.0) {   // Require &gt; 1ms sample time.</span>
<span class="line-removed"> 521       _analytics-&gt;report_logged_cards_rate_ms(logged_cards / logging_time);</span>
<span class="line-removed"> 522     }</span>
 523   }
 524 }
 525 
 526 void G1Policy::record_collection_pause_start(double start_time_sec) {
 527   // We only need to do this here as the policy will only be applied
 528   // to the GC we&#39;re about to start. so, no point is calculating this
 529   // every time we calculate / recalculate the target young length.
 530   update_survivors_policy();
 531 
 532   assert(max_survivor_regions() + _g1h-&gt;num_used_regions() &lt;= _g1h-&gt;max_regions(),
 533          &quot;Maximum survivor regions %u plus used regions %u exceeds max regions %u&quot;,
 534          max_survivor_regions(), _g1h-&gt;num_used_regions(), _g1h-&gt;max_regions());
 535   assert_used_and_recalculate_used_equal(_g1h);
 536 
 537   phase_times()-&gt;record_cur_collection_start_sec(start_time_sec);
 538 
<span class="line-modified"> 539   record_concurrent_refinement_data(false /* is_full_collection */);</span>
 540 
 541   _collection_set-&gt;reset_bytes_used_before();
 542 
 543   // do that for any other surv rate groups
 544   _eden_surv_rate_group-&gt;stop_adding_regions();
 545   _survivors_age_table.clear();
 546 
 547   assert(_g1h-&gt;collection_set()-&gt;verify_young_ages(), &quot;region age verification failed&quot;);
 548 }
 549 
 550 void G1Policy::record_concurrent_mark_init_end(double mark_init_elapsed_time_ms) {
 551   assert(!collector_state()-&gt;initiate_conc_mark_if_possible(), &quot;we should have cleared it by now&quot;);
 552   collector_state()-&gt;set_in_initial_mark_gc(false);
 553 }
 554 
 555 void G1Policy::record_concurrent_mark_remark_start() {
 556   _mark_remark_start_sec = os::elapsedTime();
 557 }
 558 
 559 void G1Policy::record_concurrent_mark_remark_end() {
</pre>
<hr />
<pre>
 813     // the marking threads may have received an uncharacterisic amount of cpu time
 814     // for completing the marking, i.e. are faster than expected.
 815     // This skews the predicted marking length towards smaller values which might cause
 816     // the mark start being too late.
 817     _initial_mark_to_mixed.reset();
 818   }
 819 
 820   // Note that _mmu_tracker-&gt;max_gc_time() returns the time in seconds.
 821   double scan_logged_cards_time_goal_ms = _mmu_tracker-&gt;max_gc_time() * MILLIUNITS * G1RSetUpdatingPauseTimePercent / 100.0;
 822 
 823   if (scan_logged_cards_time_goal_ms &lt; merge_hcc_time_ms) {
 824     log_debug(gc, ergo, refine)(&quot;Adjust concurrent refinement thresholds (scanning the HCC expected to take longer than Update RS time goal).&quot;
 825                                 &quot;Logged Cards Scan time goal: %1.2fms Scan HCC time: %1.2fms&quot;,
 826                                 scan_logged_cards_time_goal_ms, merge_hcc_time_ms);
 827 
 828     scan_logged_cards_time_goal_ms = 0;
 829   } else {
 830     scan_logged_cards_time_goal_ms -= merge_hcc_time_ms;
 831   }
 832 
<span class="line-removed"> 833   _pending_cards_at_prev_gc_end = _g1h-&gt;pending_card_num();</span>
 834   double const logged_cards_time = logged_cards_processing_time();
 835 
 836   log_debug(gc, ergo, refine)(&quot;Concurrent refinement times: Logged Cards Scan time goal: %1.2fms Logged Cards Scan time: %1.2fms HCC time: %1.2fms&quot;,
 837                               scan_logged_cards_time_goal_ms, logged_cards_time, merge_hcc_time_ms);
 838 
 839   _g1h-&gt;concurrent_refine()-&gt;adjust(logged_cards_time,
 840                                     phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards),
 841                                     scan_logged_cards_time_goal_ms);
 842 }
 843 
 844 G1IHOPControl* G1Policy::create_ihop_control(const G1Predictions* predictor){
 845   if (G1UseAdaptiveIHOP) {
 846     return new G1AdaptiveIHOPControl(InitiatingHeapOccupancyPercent,
 847                                      predictor,
 848                                      G1ReservePercent,
 849                                      G1HeapWastePercent);
 850   } else {
 851     return new G1StaticIHOPControl(InitiatingHeapOccupancyPercent);
 852   }
 853 }
</pre>
</td>
<td>
<hr />
<pre>
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/g1/g1Analytics.hpp&quot;
  27 #include &quot;gc/g1/g1Arguments.hpp&quot;
  28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  29 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
  30 #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
  31 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  32 #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
  33 #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
<span class="line-added">  34 #include &quot;gc/g1/g1ConcurrentRefineStats.hpp&quot;</span>
  35 #include &quot;gc/g1/g1CollectionSetChooser.hpp&quot;
  36 #include &quot;gc/g1/g1HeterogeneousHeapPolicy.hpp&quot;
  37 #include &quot;gc/g1/g1HotCardCache.hpp&quot;
  38 #include &quot;gc/g1/g1IHOPControl.hpp&quot;
  39 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
  40 #include &quot;gc/g1/g1Policy.hpp&quot;
  41 #include &quot;gc/g1/g1SurvivorRegions.hpp&quot;
  42 #include &quot;gc/g1/g1YoungGenSizer.hpp&quot;
  43 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  44 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  45 #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;
  46 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
<span class="line-modified">  47 #include &quot;logging/log.hpp&quot;</span>
  48 #include &quot;runtime/arguments.hpp&quot;
  49 #include &quot;runtime/java.hpp&quot;
  50 #include &quot;runtime/mutexLocker.hpp&quot;
  51 #include &quot;utilities/debug.hpp&quot;
  52 #include &quot;utilities/growableArray.hpp&quot;
  53 #include &quot;utilities/pair.hpp&quot;
  54 
  55 G1Policy::G1Policy(STWGCTimer* gc_timer) :
  56   _predictor(G1ConfidencePercent / 100.0),
  57   _analytics(new G1Analytics(&amp;_predictor)),
  58   _remset_tracker(),
  59   _mmu_tracker(new G1MMUTrackerQueue(GCPauseIntervalMillis / 1000.0, MaxGCPauseMillis / 1000.0)),
  60   _ihop_control(create_ihop_control(&amp;_predictor)),
  61   _policy_counters(new GCPolicyCounters(&quot;GarbageFirst&quot;, 1, 2)),
  62   _full_collection_start_sec(0.0),
  63   _collection_pause_end_millis(os::javaTimeNanos() / NANOSECS_PER_MILLISEC),
  64   _young_list_target_length(0),
  65   _young_list_fixed_length(0),
  66   _young_list_max_length(0),
  67   _eden_surv_rate_group(new G1SurvRateGroup()),
  68   _survivor_surv_rate_group(new G1SurvRateGroup()),
  69   _reserve_factor((double) G1ReservePercent / 100.0),
  70   _reserve_regions(0),
  71   _young_gen_sizer(G1YoungGenSizer::create_gen_sizer()),
  72   _free_regions_at_end_of_collection(0),
  73   _rs_length(0),
  74   _rs_length_prediction(0),
  75   _pending_cards_at_gc_start(0),




  76   _bytes_allocated_in_old_since_last_gc(0),
  77   _initial_mark_to_mixed(),
  78   _collection_set(NULL),
  79   _g1h(NULL),
  80   _phase_times(new G1GCPhaseTimes(gc_timer, ParallelGCThreads)),
  81   _mark_remark_start_sec(0),
  82   _mark_cleanup_start_sec(0),
  83   _tenuring_threshold(MaxTenuringThreshold),
  84   _max_survivor_regions(0),
  85   _survivors_age_table(true)
  86 {
  87 }
  88 
  89 G1Policy::~G1Policy() {
  90   delete _ihop_control;
  91   delete _young_gen_sizer;
  92 }
  93 
  94 G1Policy* G1Policy::create_policy(STWGCTimer* gc_timer_stw) {
  95   if (G1Arguments::is_heterogeneous_heap()) {
</pre>
<hr />
<pre>
 412     update_young_list_max_and_target_length(rs_length_prediction);
 413   }
 414 }
 415 
 416 void G1Policy::update_rs_length_prediction() {
 417   update_rs_length_prediction(_analytics-&gt;predict_rs_length());
 418 }
 419 
 420 void G1Policy::update_rs_length_prediction(size_t prediction) {
 421   if (collector_state()-&gt;in_young_only_phase() &amp;&amp; use_adaptive_young_list_length()) {
 422     _rs_length_prediction = prediction;
 423   }
 424 }
 425 
 426 void G1Policy::record_full_collection_start() {
 427   _full_collection_start_sec = os::elapsedTime();
 428   // Release the future to-space so that it is available for compaction into.
 429   collector_state()-&gt;set_in_young_only_phase(false);
 430   collector_state()-&gt;set_in_full_gc(true);
 431   _collection_set-&gt;clear_candidates();
<span class="line-modified"> 432   _pending_cards_at_gc_start = 0;</span>
 433 }
 434 
 435 void G1Policy::record_full_collection_end() {
 436   // Consider this like a collection pause for the purposes of allocation
 437   // since last pause.
 438   double end_sec = os::elapsedTime();
 439   double full_gc_time_sec = end_sec - _full_collection_start_sec;
 440   double full_gc_time_ms = full_gc_time_sec * 1000.0;
 441 
 442   _analytics-&gt;update_recent_gc_times(end_sec, full_gc_time_ms);
 443 
 444   collector_state()-&gt;set_in_full_gc(false);
 445 
 446   // &quot;Nuke&quot; the heuristics that control the young/mixed GC
 447   // transitions and make sure we start with young GCs after the Full GC.
 448   collector_state()-&gt;set_in_young_only_phase(true);
 449   collector_state()-&gt;set_in_young_gc_before_mixed(false);
 450   collector_state()-&gt;set_initiate_conc_mark_if_possible(need_to_start_conc_mark(&quot;end of Full GC&quot;, 0));
 451   collector_state()-&gt;set_in_initial_mark_gc(false);
 452   collector_state()-&gt;set_mark_or_rebuild_in_progress(false);
 453   collector_state()-&gt;set_clearing_next_bitmap(false);
 454 
 455   _eden_surv_rate_group-&gt;start_adding_regions();
 456   // also call this on any additional surv rate groups
 457 
 458   _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
 459   _survivor_surv_rate_group-&gt;reset();
 460   update_young_list_max_and_target_length();
 461   update_rs_length_prediction();

 462 
 463   _bytes_allocated_in_old_since_last_gc = 0;
 464 
 465   record_pause(FullGC, _full_collection_start_sec, end_sec);
 466 }
 467 
<span class="line-modified"> 468 static void log_refinement_stats(const char* kind, const G1ConcurrentRefineStats&amp; stats) {</span>
<span class="line-modified"> 469   log_debug(gc, refine, stats)</span>
<span class="line-added"> 470            (&quot;%s refinement: %.2fms, refined: &quot; SIZE_FORMAT</span>
<span class="line-added"> 471             &quot;, precleaned: &quot; SIZE_FORMAT &quot;, dirtied: &quot; SIZE_FORMAT,</span>
<span class="line-added"> 472             kind,</span>
<span class="line-added"> 473             stats.refinement_time().seconds() * MILLIUNITS,</span>
<span class="line-added"> 474             stats.refined_cards(),</span>
<span class="line-added"> 475             stats.precleaned_cards(),</span>
<span class="line-added"> 476             stats.dirtied_cards());</span>
<span class="line-added"> 477 }</span>
<span class="line-added"> 478 </span>
<span class="line-added"> 479 void G1Policy::record_concurrent_refinement_stats() {</span>
<span class="line-added"> 480   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="line-added"> 481   _pending_cards_at_gc_start = dcqs.num_cards();</span>
 482 
<span class="line-modified"> 483   // Collect per-thread stats, mostly from mutator activity.</span>
<span class="line-added"> 484   G1ConcurrentRefineStats mut_stats = dcqs.get_and_reset_refinement_stats();</span>
<span class="line-added"> 485 </span>
<span class="line-added"> 486   // Collect specialized concurrent refinement thread stats.</span>
 487   G1ConcurrentRefine* cr = _g1h-&gt;concurrent_refine();
<span class="line-modified"> 488   G1ConcurrentRefineStats cr_stats = cr-&gt;get_and_reset_refinement_stats();</span>
<span class="line-modified"> 489 </span>
<span class="line-modified"> 490   G1ConcurrentRefineStats total_stats = mut_stats + cr_stats;</span>
<span class="line-modified"> 491 </span>
<span class="line-modified"> 492   log_refinement_stats(&quot;Mutator&quot;, mut_stats);</span>
<span class="line-modified"> 493   log_refinement_stats(&quot;Concurrent&quot;, cr_stats);</span>
<span class="line-modified"> 494   log_refinement_stats(&quot;Total&quot;, total_stats);</span>
<span class="line-modified"> 495 </span>
<span class="line-modified"> 496   // Record the rate at which cards were refined.</span>
<span class="line-modified"> 497   // Don&#39;t update the rate if the current sample is empty or time is zero.</span>
<span class="line-modified"> 498   Tickspan refinement_time = total_stats.refinement_time();</span>
<span class="line-modified"> 499   size_t refined_cards = total_stats.refined_cards();</span>
<span class="line-modified"> 500   if ((refined_cards &gt; 0) &amp;&amp; (refinement_time &gt; Tickspan())) {</span>
<span class="line-modified"> 501     double rate = refined_cards / (refinement_time.seconds() * MILLIUNITS);</span>


 502     _analytics-&gt;report_concurrent_refine_rate_ms(rate);
<span class="line-added"> 503     log_debug(gc, refine, stats)(&quot;Concurrent refinement rate: %.2f cards/ms&quot;, rate);</span>
 504   }
 505 






 506   // Record mutator&#39;s card logging rate.
<span class="line-modified"> 507   double mut_start_time = _analytics-&gt;prev_collection_pause_end_ms();</span>
<span class="line-modified"> 508   double mut_end_time = phase_times()-&gt;cur_collection_start_sec() * MILLIUNITS;</span>
<span class="line-modified"> 509   double mut_time = mut_end_time - mut_start_time;</span>
<span class="line-modified"> 510   // Unlike above for conc-refine rate, here we should not require a</span>
<span class="line-modified"> 511   // non-empty sample, since an application could go some time with only</span>
<span class="line-modified"> 512   // young-gen or filtered out writes.  But we&#39;ll ignore unusually short</span>
<span class="line-modified"> 513   // sample periods, as they may just pollute the predictions.</span>
<span class="line-modified"> 514   if (mut_time &gt; 1.0) {   // Require &gt; 1ms sample time.</span>
<span class="line-modified"> 515     double dirtied_rate = total_stats.dirtied_cards() / mut_time;</span>
<span class="line-modified"> 516     _analytics-&gt;report_dirtied_cards_rate_ms(dirtied_rate);</span>
<span class="line-modified"> 517     log_debug(gc, refine, stats)(&quot;Generate dirty cards rate: %.2f cards/ms&quot;, dirtied_rate);</span>









 518   }
 519 }
 520 
 521 void G1Policy::record_collection_pause_start(double start_time_sec) {
 522   // We only need to do this here as the policy will only be applied
 523   // to the GC we&#39;re about to start. so, no point is calculating this
 524   // every time we calculate / recalculate the target young length.
 525   update_survivors_policy();
 526 
 527   assert(max_survivor_regions() + _g1h-&gt;num_used_regions() &lt;= _g1h-&gt;max_regions(),
 528          &quot;Maximum survivor regions %u plus used regions %u exceeds max regions %u&quot;,
 529          max_survivor_regions(), _g1h-&gt;num_used_regions(), _g1h-&gt;max_regions());
 530   assert_used_and_recalculate_used_equal(_g1h);
 531 
 532   phase_times()-&gt;record_cur_collection_start_sec(start_time_sec);
 533 
<span class="line-modified"> 534   record_concurrent_refinement_stats();</span>
 535 
 536   _collection_set-&gt;reset_bytes_used_before();
 537 
 538   // do that for any other surv rate groups
 539   _eden_surv_rate_group-&gt;stop_adding_regions();
 540   _survivors_age_table.clear();
 541 
 542   assert(_g1h-&gt;collection_set()-&gt;verify_young_ages(), &quot;region age verification failed&quot;);
 543 }
 544 
 545 void G1Policy::record_concurrent_mark_init_end(double mark_init_elapsed_time_ms) {
 546   assert(!collector_state()-&gt;initiate_conc_mark_if_possible(), &quot;we should have cleared it by now&quot;);
 547   collector_state()-&gt;set_in_initial_mark_gc(false);
 548 }
 549 
 550 void G1Policy::record_concurrent_mark_remark_start() {
 551   _mark_remark_start_sec = os::elapsedTime();
 552 }
 553 
 554 void G1Policy::record_concurrent_mark_remark_end() {
</pre>
<hr />
<pre>
 808     // the marking threads may have received an uncharacterisic amount of cpu time
 809     // for completing the marking, i.e. are faster than expected.
 810     // This skews the predicted marking length towards smaller values which might cause
 811     // the mark start being too late.
 812     _initial_mark_to_mixed.reset();
 813   }
 814 
 815   // Note that _mmu_tracker-&gt;max_gc_time() returns the time in seconds.
 816   double scan_logged_cards_time_goal_ms = _mmu_tracker-&gt;max_gc_time() * MILLIUNITS * G1RSetUpdatingPauseTimePercent / 100.0;
 817 
 818   if (scan_logged_cards_time_goal_ms &lt; merge_hcc_time_ms) {
 819     log_debug(gc, ergo, refine)(&quot;Adjust concurrent refinement thresholds (scanning the HCC expected to take longer than Update RS time goal).&quot;
 820                                 &quot;Logged Cards Scan time goal: %1.2fms Scan HCC time: %1.2fms&quot;,
 821                                 scan_logged_cards_time_goal_ms, merge_hcc_time_ms);
 822 
 823     scan_logged_cards_time_goal_ms = 0;
 824   } else {
 825     scan_logged_cards_time_goal_ms -= merge_hcc_time_ms;
 826   }
 827 

 828   double const logged_cards_time = logged_cards_processing_time();
 829 
 830   log_debug(gc, ergo, refine)(&quot;Concurrent refinement times: Logged Cards Scan time goal: %1.2fms Logged Cards Scan time: %1.2fms HCC time: %1.2fms&quot;,
 831                               scan_logged_cards_time_goal_ms, logged_cards_time, merge_hcc_time_ms);
 832 
 833   _g1h-&gt;concurrent_refine()-&gt;adjust(logged_cards_time,
 834                                     phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards),
 835                                     scan_logged_cards_time_goal_ms);
 836 }
 837 
 838 G1IHOPControl* G1Policy::create_ihop_control(const G1Predictions* predictor){
 839   if (G1UseAdaptiveIHOP) {
 840     return new G1AdaptiveIHOPControl(InitiatingHeapOccupancyPercent,
 841                                      predictor,
 842                                      G1ReservePercent,
 843                                      G1HeapWastePercent);
 844   } else {
 845     return new G1StaticIHOPControl(InitiatingHeapOccupancyPercent);
 846   }
 847 }
</pre>
</td>
</tr>
</table>
<center><a href="g1GCPhaseTimes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
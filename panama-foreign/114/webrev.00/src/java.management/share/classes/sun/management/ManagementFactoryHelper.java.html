<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.management/share/classes/sun/management/ManagementFactoryHelper.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.management;
 27 
 28 import java.lang.management.*;
 29 import java.lang.reflect.InvocationTargetException;
 30 import java.lang.reflect.Method;
 31 import javax.management.InstanceAlreadyExistsException;
 32 import javax.management.InstanceNotFoundException;
 33 import javax.management.MBeanServer;
 34 import javax.management.MBeanRegistrationException;
 35 import javax.management.NotCompliantMBeanException;
 36 import javax.management.ObjectName;
 37 import javax.management.RuntimeOperationsException;
 38 import java.security.AccessController;
 39 import java.security.PrivilegedActionException;
 40 import java.security.PrivilegedExceptionAction;
 41 
 42 import jdk.internal.access.SharedSecrets;
 43 import jdk.internal.misc.VM;
 44 import jdk.internal.misc.VM.BufferPool;
 45 
 46 import java.util.ArrayList;
 47 import java.util.List;
 48 
 49 import java.lang.reflect.UndeclaredThrowableException;
 50 import java.security.PrivilegedAction;
 51 import java.util.Arrays;
 52 import java.util.Collections;
 53 import java.util.HashMap;
 54 import java.util.Map;
 55 import java.util.Optional;
 56 import java.util.stream.Collectors;
 57 
 58 /**
 59  * ManagementFactoryHelper provides static factory methods to create
 60  * instances of the management interface.
 61  */
 62 public class ManagementFactoryHelper {
 63     static {
 64         // make sure that the management lib is loaded within
 65         // java.lang.management.ManagementFactory
 66         jdk.internal.misc.Unsafe.getUnsafe().ensureClassInitialized(ManagementFactory.class);
 67     }
 68 
 69     private static final VMManagement jvm = new VMManagementImpl();
 70 
 71     private ManagementFactoryHelper() {};
 72 
 73     public static VMManagement getVMManagement() {
 74         return jvm;
 75     }
 76 
 77     static final String LOGGING_MXBEAN_NAME = &quot;java.util.logging:type=Logging&quot;;
 78     private static ClassLoadingImpl    classMBean = null;
 79     private static MemoryImpl          memoryMBean = null;
 80     private static ThreadImpl          threadMBean = null;
 81     private static RuntimeImpl         runtimeMBean = null;
 82     private static CompilationImpl     compileMBean = null;
 83     private static BaseOperatingSystemImpl osMBean = null;
 84 
 85     public static synchronized ClassLoadingMXBean getClassLoadingMXBean() {
 86         if (classMBean == null) {
 87             classMBean = new ClassLoadingImpl(jvm);
 88         }
 89         return classMBean;
 90     }
 91 
 92     public static synchronized MemoryMXBean getMemoryMXBean() {
 93         if (memoryMBean == null) {
 94             memoryMBean = new MemoryImpl(jvm);
 95         }
 96         return memoryMBean;
 97     }
 98 
 99     public static synchronized ThreadMXBean getThreadMXBean() {
100         if (threadMBean == null) {
101             threadMBean = new ThreadImpl(jvm);
102         }
103         return threadMBean;
104     }
105 
106     public static synchronized RuntimeMXBean getRuntimeMXBean() {
107         if (runtimeMBean == null) {
108             runtimeMBean = new RuntimeImpl(jvm);
109         }
110         return runtimeMBean;
111     }
112 
113     public static synchronized CompilationMXBean getCompilationMXBean() {
114         if (compileMBean == null &amp;&amp; jvm.getCompilerName() != null) {
115             compileMBean = new CompilationImpl(jvm);
116         }
117         return compileMBean;
118     }
119 
120     public static synchronized OperatingSystemMXBean getOperatingSystemMXBean() {
121         if (osMBean == null) {
122             osMBean = new BaseOperatingSystemImpl(jvm);
123         }
124         return osMBean;
125     }
126 
127     public static List&lt;MemoryPoolMXBean&gt; getMemoryPoolMXBeans() {
128         MemoryPoolMXBean[] pools = MemoryImpl.getMemoryPools();
129         List&lt;MemoryPoolMXBean&gt; list = new ArrayList&lt;&gt;(pools.length);
130         for (MemoryPoolMXBean p : pools) {
131             list.add(p);
132         }
133         return list;
134     }
135 
136     public static List&lt;MemoryManagerMXBean&gt; getMemoryManagerMXBeans() {
137         MemoryManagerMXBean[]  mgrs = MemoryImpl.getMemoryManagers();
138         List&lt;MemoryManagerMXBean&gt; result = new ArrayList&lt;&gt;(mgrs.length);
139         for (MemoryManagerMXBean m : mgrs) {
140             result.add(m);
141         }
142         return result;
143     }
144 
145      public static List&lt;GarbageCollectorMXBean&gt; getGarbageCollectorMXBeans() {
146         MemoryManagerMXBean[]  mgrs = MemoryImpl.getMemoryManagers();
147         List&lt;GarbageCollectorMXBean&gt; result = new ArrayList&lt;&gt;(mgrs.length);
148         for (MemoryManagerMXBean m : mgrs) {
149             if (GarbageCollectorMXBean.class.isInstance(m)) {
150                  result.add(GarbageCollectorMXBean.class.cast(m));
151             }
152         }
153         return result;
154     }
155 
156     public static PlatformLoggingMXBean getPlatformLoggingMXBean() {
157         if (LoggingMXBeanAccess.isAvailable()) {
158             return PlatformLoggingImpl.MBEAN;
159         } else {
160             return null;
161         }
162     }
163 
164     public static boolean isPlatformLoggingMXBeanAvailable() {
165         return LoggingMXBeanAccess.isAvailable();
166     }
167 
168     /**
169      * Returns an array of the name of all memory pools.  The order of the memory pools is
170      * significant and maintained in the VM.
171      */
172     public static String[] getAllMemoryPoolNames() {
173         return Arrays.stream(MemoryImpl.getMemoryPools())
174                 .map(MemoryPoolMXBean::getName)
175                 .toArray(String[]::new);
176     }
177 
178     // The LoggingMXBeanAccess class uses reflection to determine
179     // whether java.util.logging is present, and load the actual LoggingMXBean
180     // implementation.
181     //
182     static final class LoggingMXBeanAccess {
183 
184         final static String LOG_MANAGER_CLASS_NAME = &quot;java.util.logging.LogManager&quot;;
185         final static String LOGGING_MXBEAN_CLASS_NAME = &quot;java.util.logging.LoggingMXBean&quot;;
186         final static Class&lt;?&gt; LOG_MANAGER_CLASS = loadLoggingClass(LOG_MANAGER_CLASS_NAME);
187 
188         static boolean isAvailable() {
189             return LOG_MANAGER_CLASS != null;
190         }
191 
192         private static Class&lt;?&gt; loadLoggingClass(String className) {
193             return AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
194                 @Override
195                 public Class&lt;?&gt; run() {
196                     Optional&lt;Module&gt; logging = ModuleLayer.boot().findModule(&quot;java.logging&quot;);
197                     if (logging.isPresent()) {
198                         return Class.forName(logging.get(), className);
199                     }
200                     return null;
201                 }
202             });
203         }
204 
205         private Map&lt;String, Method&gt; initMethodMap(Object impl) {
206             if (impl == null) {
207                 return Collections.emptyMap();
208             }
209             Class&lt;?&gt; intfClass = loadLoggingClass(LOGGING_MXBEAN_CLASS_NAME);
210             final Map&lt;String, Method&gt; methodsMap = new HashMap&lt;&gt;();
211             for (Method m : intfClass.getMethods()) {
212                 try {
213                     // Sanity checking: all public methods present in
214                     // java.util.logging.LoggingMXBean should
215                     // also be in PlatformLoggingMXBean
216                     Method specMethod = PlatformLoggingMXBean.class
217                              .getMethod(m.getName(), m.getParameterTypes());
218                     if (specMethod.getReturnType().isAssignableFrom(m.getReturnType())) {
219                         if (methodsMap.putIfAbsent(m.getName(), m) != null) {
220                             throw new RuntimeException(&quot;unexpected polymorphic method: &quot;
221                                      + m.getName());
222                         }
223                     }
224                 } catch (NoSuchMethodException x) {
225                     // All methods in java.util.logging.LoggingMXBean should
226                     // also be in PlatformLoggingMXBean
227                     throw new InternalError(x);
228                 }
229             }
230             return Collections.unmodifiableMap(methodsMap);
231         }
232 
233         private static Object getMXBeanImplementation() {
234             if (!isAvailable()) {
235                 // should not happen
236                 throw new NoClassDefFoundError(LOG_MANAGER_CLASS_NAME);
237             }
238             try {
239                 final Method m = LOG_MANAGER_CLASS.getMethod(&quot;getLoggingMXBean&quot;);
240                 return m.invoke(null);
241             } catch (NoSuchMethodException
242                     | IllegalAccessException
243                     | InvocationTargetException x) {
244                 throw new ExceptionInInitializerError(x);
245             }
246          }
247 
248         // The implementation object, which will be invoked through
249         // reflection. The implementation does not need to implement
250         // PlatformLoggingMXBean, but must declare the same methods
251         // with same signatures, and they must be public, with one
252         // exception:
253         // getObjectName will not be called on the implementation object,
254         // so the implementation object does not need to declare such
255         // a method.
256         final Object impl = getMXBeanImplementation();
257         final Map&lt;String, Method&gt; methods = initMethodMap(impl);
258 
259         LoggingMXBeanAccess() {
260         }
261 
262         &lt;T&gt; T invoke(String methodName, Object... args) {
263             Method m = methods.get(methodName);
264             if (m == null) {
265                 throw new UnsupportedOperationException(methodName);
266             }
267             try {
268                 @SuppressWarnings(&quot;unchecked&quot;)
269                 T result = (T) m.invoke(impl, args);
270                 return result;
271             } catch (IllegalAccessException ex) {
272                 throw new UnsupportedOperationException(ex);
273             } catch (InvocationTargetException ex) {
274                 throw unwrap(ex);
275             }
276         }
277 
278         private static RuntimeException unwrap(InvocationTargetException x) {
279             Throwable t = x.getCause();
280             if (t instanceof RuntimeException) {
281                 return (RuntimeException)t;
282             }
283             if (t instanceof Error) {
284                 throw (Error)t;
285             }
286             return new UndeclaredThrowableException(t == null ? x : t);
287         }
288 
289 
290     }
291 
292     static final class PlatformLoggingImpl implements PlatformLoggingMXBean {
293 
294         private final LoggingMXBeanAccess loggingAccess;
295         private PlatformLoggingImpl(LoggingMXBeanAccess loggingAccess) {
296             this.loggingAccess = loggingAccess;
297         }
298 
299         private volatile ObjectName objname;  // created lazily
300         @Override
301         public ObjectName getObjectName() {
302             ObjectName result = objname;
303             if (result == null) {
304                 synchronized (this) {
305                     result = objname;
306                     if (result == null) {
307                         result = Util.newObjectName(LOGGING_MXBEAN_NAME);
308                         objname = result;
309                     }
310                 }
311             }
312             return result;
313         }
314 
315         @Override
316         public java.util.List&lt;String&gt; getLoggerNames() {
317             return loggingAccess.invoke(&quot;getLoggerNames&quot;);
318         }
319 
320         @Override
321         public String getLoggerLevel(String loggerName) {
322             return loggingAccess.invoke(&quot;getLoggerLevel&quot;, loggerName);
323         }
324 
325         @Override
326         public void setLoggerLevel(String loggerName, String levelName) {
327             loggingAccess.invoke(&quot;setLoggerLevel&quot;, loggerName, levelName);
328         }
329 
330         @Override
331         public String getParentLoggerName(String loggerName) {
332             return loggingAccess.invoke(&quot;getParentLoggerName&quot;, loggerName);
333         }
334 
335         private static PlatformLoggingImpl getInstance() {
336             return new PlatformLoggingImpl(new LoggingMXBeanAccess());
337          }
338 
339         static final PlatformLoggingMXBean MBEAN = getInstance();
340     }
341 
342     private static volatile List&lt;BufferPoolMXBean&gt; bufferPools;
343     public static List&lt;BufferPoolMXBean&gt; getBufferPoolMXBeans() {
344         if (bufferPools == null) {
345             synchronized (ManagementFactoryHelper.class) {
346                 if (bufferPools == null) {
347                     bufferPools = VM.getBufferPools().stream()
348                                     .map(ManagementFactoryHelper::createBufferPoolMXBean)
349                                     .collect(Collectors.toList());
350                 }
351             }
352         }
353         return bufferPools;
354     }
355 
356     private final static String BUFFER_POOL_MXBEAN_NAME = &quot;java.nio:type=BufferPool&quot;;
357 
358     /**
359      * Creates management interface for the given buffer pool.
360      */
361     private static BufferPoolMXBean
362         createBufferPoolMXBean(final BufferPool pool)
363     {
364         return new BufferPoolMXBean() {
365             private volatile ObjectName objname;  // created lazily
366             @Override
367             public ObjectName getObjectName() {
368                 ObjectName result = objname;
369                 if (result == null) {
370                     synchronized (this) {
371                         result = objname;
372                         if (result == null) {
373                             result = Util.newObjectName(BUFFER_POOL_MXBEAN_NAME +
374                                 &quot;,name=&quot; + pool.getName());
375                             objname = result;
376                         }
377                     }
378                 }
379                 return result;
380             }
381             @Override
382             public String getName() {
383                 return pool.getName();
384             }
385             @Override
386             public long getCount() {
387                 return pool.getCount();
388             }
389             @Override
390             public long getTotalCapacity() {
391                 return pool.getTotalCapacity();
392             }
393             @Override
394             public long getMemoryUsed() {
395                 return pool.getMemoryUsed();
396             }
397         };
398     }
399 
400     private static HotspotRuntime hsRuntimeMBean = null;
401     private static HotspotClassLoading hsClassMBean = null;
402     private static HotspotThread hsThreadMBean = null;
403     private static HotspotCompilation hsCompileMBean = null;
404     private static HotspotMemory hsMemoryMBean = null;
405 
406     /**
407      * This method is for testing only.
408      */
409     public static synchronized HotspotRuntimeMBean getHotspotRuntimeMBean() {
410         if (hsRuntimeMBean == null) {
411             hsRuntimeMBean = new HotspotRuntime(jvm);
412         }
413         return hsRuntimeMBean;
414     }
415 
416     /**
417      * This method is for testing only.
418      */
419     public static synchronized HotspotClassLoadingMBean getHotspotClassLoadingMBean() {
420         if (hsClassMBean == null) {
421             hsClassMBean = new HotspotClassLoading(jvm);
422         }
423         return hsClassMBean;
424     }
425 
426     /**
427      * This method is for testing only.
428      */
429     public static synchronized HotspotThreadMBean getHotspotThreadMBean() {
430         if (hsThreadMBean == null) {
431             hsThreadMBean = new HotspotThread(jvm);
432         }
433         return hsThreadMBean;
434     }
435 
436     /**
437      * This method is for testing only.
438      */
439     public static synchronized HotspotMemoryMBean getHotspotMemoryMBean() {
440         if (hsMemoryMBean == null) {
441             hsMemoryMBean = new HotspotMemory(jvm);
442         }
443         return hsMemoryMBean;
444     }
445 
446     /**
447      * This method is for testing only.
448      */
449     public static synchronized HotspotCompilationMBean getHotspotCompilationMBean() {
450         if (hsCompileMBean == null) {
451             hsCompileMBean = new HotspotCompilation(jvm);
452         }
453         return hsCompileMBean;
454     }
455 
456     /**
457      * Registers a given MBean if not registered in the MBeanServer;
458      * otherwise, just return.
459      */
460     private static void addMBean(MBeanServer mbs, Object mbean, String mbeanName) {
461         try {
462             final ObjectName objName = Util.newObjectName(mbeanName);
463 
464             // inner class requires these fields to be final
465             final MBeanServer mbs0 = mbs;
466             final Object mbean0 = mbean;
467             AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Void&gt;() {
468                 public Void run() throws MBeanRegistrationException,
469                                          NotCompliantMBeanException {
470                     try {
471                         mbs0.registerMBean(mbean0, objName);
472                         return null;
473                     } catch (InstanceAlreadyExistsException e) {
474                         // if an instance with the object name exists in
475                         // the MBeanServer ignore the exception
476                     }
477                     return null;
478                 }
479             });
480         } catch (PrivilegedActionException e) {
481             throw Util.newException(e.getException());
482         }
483     }
484 
485     private final static String HOTSPOT_CLASS_LOADING_MBEAN_NAME =
486         &quot;sun.management:type=HotspotClassLoading&quot;;
487 
488     private final static String HOTSPOT_COMPILATION_MBEAN_NAME =
489         &quot;sun.management:type=HotspotCompilation&quot;;
490 
491     private final static String HOTSPOT_MEMORY_MBEAN_NAME =
492         &quot;sun.management:type=HotspotMemory&quot;;
493 
494     private static final String HOTSPOT_RUNTIME_MBEAN_NAME =
495         &quot;sun.management:type=HotspotRuntime&quot;;
496 
497     private final static String HOTSPOT_THREAD_MBEAN_NAME =
498         &quot;sun.management:type=HotspotThreading&quot;;
499 
500     static void registerInternalMBeans(MBeanServer mbs) {
501         // register all internal MBeans if not registered
502         // No exception is thrown if a MBean with that object name
503         // already registered
504         addMBean(mbs, getHotspotClassLoadingMBean(),
505             HOTSPOT_CLASS_LOADING_MBEAN_NAME);
506         addMBean(mbs, getHotspotMemoryMBean(),
507             HOTSPOT_MEMORY_MBEAN_NAME);
508         addMBean(mbs, getHotspotRuntimeMBean(),
509             HOTSPOT_RUNTIME_MBEAN_NAME);
510         addMBean(mbs, getHotspotThreadMBean(),
511             HOTSPOT_THREAD_MBEAN_NAME);
512 
513         // CompilationMBean may not exist
514         if (getCompilationMXBean() != null) {
515             addMBean(mbs, getHotspotCompilationMBean(),
516                 HOTSPOT_COMPILATION_MBEAN_NAME);
517         }
518     }
519 
520     private static void unregisterMBean(MBeanServer mbs, String mbeanName) {
521         try {
522             final ObjectName objName = Util.newObjectName(mbeanName);
523 
524             // inner class requires these fields to be final
525             final MBeanServer mbs0 = mbs;
526             AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Void&gt;() {
527                 public Void run() throws MBeanRegistrationException,
528                                            RuntimeOperationsException  {
529                     try {
530                         mbs0.unregisterMBean(objName);
531                     } catch (InstanceNotFoundException e) {
532                         // ignore exception if not found
533                     }
534                     return null;
535                 }
536             });
537         } catch (PrivilegedActionException e) {
538             throw Util.newException(e.getException());
539         }
540     }
541 
542     static void unregisterInternalMBeans(MBeanServer mbs) {
543         // unregister all internal MBeans
544         unregisterMBean(mbs, HOTSPOT_CLASS_LOADING_MBEAN_NAME);
545         unregisterMBean(mbs, HOTSPOT_MEMORY_MBEAN_NAME);
546         unregisterMBean(mbs, HOTSPOT_RUNTIME_MBEAN_NAME);
547         unregisterMBean(mbs, HOTSPOT_THREAD_MBEAN_NAME);
548 
549         // CompilationMBean may not exist
550         if (getCompilationMXBean() != null) {
551             unregisterMBean(mbs, HOTSPOT_COMPILATION_MBEAN_NAME);
552         }
553     }
554 
555     public static boolean isThreadSuspended(int state) {
556         return ((state &amp; JMM_THREAD_STATE_FLAG_SUSPENDED) != 0);
557     }
558 
559     public static boolean isThreadRunningNative(int state) {
560         return ((state &amp; JMM_THREAD_STATE_FLAG_NATIVE) != 0);
561     }
562 
563     public static Thread.State toThreadState(int state) {
564         // suspended and native bits may be set in state
565         int threadStatus = state &amp; ~JMM_THREAD_STATE_FLAG_MASK;
566         return jdk.internal.misc.VM.toThreadState(threadStatus);
567     }
568 
569     // These values are defined in jmm.h
570     private static final int JMM_THREAD_STATE_FLAG_MASK = 0xFFF00000;
571     private static final int JMM_THREAD_STATE_FLAG_SUSPENDED = 0x00100000;
572     private static final int JMM_THREAD_STATE_FLAG_NATIVE = 0x00400000;
573 
574     // Invoked by the VM
575     private static MemoryPoolMXBean createMemoryPool
576         (String name, boolean isHeap, long uThreshold, long gcThreshold) {
577         return new MemoryPoolImpl(name, isHeap, uThreshold, gcThreshold);
578     }
579 
580     private static MemoryManagerMXBean createMemoryManager(String name) {
581         return new MemoryManagerImpl(name);
582     }
583 
584     private static GarbageCollectorMXBean
585         createGarbageCollector(String name, String type) {
586 
587         // ignore type parameter which is for future extension
588         return new GarbageCollectorImpl(name);
589     }
590 }
    </pre>
  </body>
</html>
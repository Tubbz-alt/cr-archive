<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/linker/NashornLinker.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.runtime.linker;
 27 
 28 import static jdk.nashorn.internal.lookup.Lookup.MH;
 29 
 30 import java.lang.invoke.MethodHandle;
 31 import java.lang.invoke.MethodHandles;
 32 import java.lang.invoke.MethodType;
 33 import java.lang.reflect.Modifier;
 34 import java.security.AccessControlContext;
 35 import java.security.AccessController;
 36 import java.security.PrivilegedAction;
 37 import java.util.Collection;
 38 import java.util.Deque;
 39 import java.util.List;
 40 import java.util.Map;
 41 import java.util.Queue;
 42 import java.util.function.Supplier;
 43 import javax.script.Bindings;
 44 import jdk.dynalink.CallSiteDescriptor;
 45 import jdk.dynalink.SecureLookupSupplier;
 46 import jdk.dynalink.linker.ConversionComparator;
 47 import jdk.dynalink.linker.GuardedInvocation;
 48 import jdk.dynalink.linker.GuardingTypeConverterFactory;
 49 import jdk.dynalink.linker.LinkRequest;
 50 import jdk.dynalink.linker.LinkerServices;
 51 import jdk.dynalink.linker.TypeBasedGuardingDynamicLinker;
 52 import jdk.dynalink.linker.support.Guards;
 53 import jdk.dynalink.linker.support.Lookup;
 54 import jdk.nashorn.api.scripting.JSObject;
 55 import jdk.nashorn.api.scripting.ScriptObjectMirror;
 56 import jdk.nashorn.api.scripting.ScriptUtils;
 57 import jdk.nashorn.internal.codegen.CompilerConstants.Call;
 58 import jdk.nashorn.internal.objects.NativeArray;
 59 import jdk.nashorn.internal.runtime.AccessControlContextFactory;
 60 import jdk.nashorn.internal.runtime.JSType;
 61 import jdk.nashorn.internal.runtime.ListAdapter;
 62 import jdk.nashorn.internal.runtime.ScriptFunction;
 63 import jdk.nashorn.internal.runtime.ScriptObject;
 64 import jdk.nashorn.internal.runtime.Undefined;
 65 
 66 /**
 67  * This is the main dynamic linker for Nashorn. It is used for linking all {@link ScriptObject} and its subclasses (this
 68  * includes {@link ScriptFunction} and its subclasses) as well as {@link Undefined}.
 69  */
 70 final class NashornLinker implements TypeBasedGuardingDynamicLinker, GuardingTypeConverterFactory, ConversionComparator {
 71     private static final AccessControlContext GET_LOOKUP_PERMISSION_CONTEXT =
 72             AccessControlContextFactory.createAccessControlContext(SecureLookupSupplier.GET_LOOKUP_PERMISSION_NAME);
 73 
 74     private static final ClassValue&lt;MethodHandle&gt; ARRAY_CONVERTERS = new ClassValue&lt;MethodHandle&gt;() {
 75         @Override
 76         protected MethodHandle computeValue(final Class&lt;?&gt; type) {
 77             return createArrayConverter(type);
 78         }
 79     };
 80 
 81     /**
 82      * Returns true if {@code ScriptObject} is assignable from {@code type}, or it is {@code Undefined}.
 83      */
 84     @Override
 85     public boolean canLinkType(final Class&lt;?&gt; type) {
 86         return canLinkTypeStatic(type);
 87     }
 88 
 89     static boolean canLinkTypeStatic(final Class&lt;?&gt; type) {
 90         return ScriptObject.class.isAssignableFrom(type) || Undefined.class == type;
 91     }
 92 
 93     @Override
 94     public GuardedInvocation getGuardedInvocation(final LinkRequest request, final LinkerServices linkerServices) throws Exception {
 95         final CallSiteDescriptor desc = request.getCallSiteDescriptor();
 96         return Bootstrap.asTypeSafeReturn(getGuardedInvocation(request, desc), linkerServices, desc);
 97     }
 98 
 99     private static GuardedInvocation getGuardedInvocation(final LinkRequest request, final CallSiteDescriptor desc) {
100         final Object self = request.getReceiver();
101 
102         final GuardedInvocation inv;
103         if (self instanceof ScriptObject) {
104             inv = ((ScriptObject)self).lookup(desc, request);
105         } else if (self instanceof Undefined) {
106             inv = Undefined.lookup(desc);
107         } else {
108             throw new AssertionError(self.getClass().getName()); // Should never reach here.
109         }
110 
111         return inv;
112     }
113 
114     @Override
115     public GuardedInvocation convertToType(final Class&lt;?&gt; sourceType, final Class&lt;?&gt; targetType, final Supplier&lt;MethodHandles.Lookup&gt; lookupSupplier) throws Exception {
116         GuardedInvocation gi = convertToTypeNoCast(sourceType, targetType, lookupSupplier);
117         if(gi == null) {
118             gi = getSamTypeConverter(sourceType, targetType, lookupSupplier);
119         }
120         return gi == null ? null : gi.asType(MH.type(targetType, sourceType));
121     }
122 
123     /**
124      * Main part of the implementation of {@link GuardingTypeConverterFactory#convertToType(Class, Class)} that doesn&#39;t
125      * care about adapting the method signature; that&#39;s done by the invoking method. Returns either a built-in
126      * conversion to primitive (or primitive wrapper) Java types or to String, or a just-in-time generated converter to
127      * a SAM type (if the target type is a SAM type).
128      * @param sourceType the source type
129      * @param targetType the target type
130      * @return a guarded invocation that converts from the source type to the target type.
131      * @throws Exception if something goes wrong
132      */
133     private static GuardedInvocation convertToTypeNoCast(final Class&lt;?&gt; sourceType, final Class&lt;?&gt; targetType, final Supplier&lt;MethodHandles.Lookup&gt; lookupSupplier) throws Exception {
134         final MethodHandle mh = JavaArgumentConverters.getConverter(targetType);
135         if (mh != null) {
136             return new GuardedInvocation(mh, canLinkTypeStatic(sourceType) ? null : IS_NASHORN_OR_UNDEFINED_TYPE);
137         }
138 
139         final GuardedInvocation arrayConverter = getArrayConverter(sourceType, targetType, lookupSupplier);
140         if(arrayConverter != null) {
141             return arrayConverter;
142         }
143 
144         return getMirrorConverter(sourceType, targetType);
145     }
146 
147     /**
148      * Returns a guarded invocation that converts from a source type that is ScriptFunction, or a subclass or a
149      * superclass of it) to a SAM type.
150      * @param sourceType the source type (presumably ScriptFunction or a subclass or a superclass of it)
151      * @param targetType the target type (presumably a SAM type)
152      * @return a guarded invocation that converts from the source type to the target SAM type. null is returned if
153      * either the source type is neither ScriptFunction, nor a subclass, nor a superclass of it, or if the target type
154      * is not a SAM type.
155      * @throws Exception if something goes wrong; generally, if there&#39;s an issue with creation of the SAM proxy type
156      * constructor.
157      */
158     private static GuardedInvocation getSamTypeConverter(final Class&lt;?&gt; sourceType, final Class&lt;?&gt; targetType, final Supplier&lt;MethodHandles.Lookup&gt; lookupSupplier) throws Exception {
159         // If source type is more generic than ScriptFunction class, we&#39;ll need to use a guard
160         final boolean isSourceTypeGeneric = sourceType.isAssignableFrom(ScriptObject.class);
161 
162         if ((isSourceTypeGeneric || ScriptFunction.class.isAssignableFrom(sourceType)) &amp;&amp; isAutoConvertibleFromFunction(targetType)) {
163             final Class&lt;?&gt; paramType = isSourceTypeGeneric ? Object.class : ScriptFunction.class;
164             // Using Object.class as constructor source type means we&#39;re getting an overloaded constructor handle,
165             // which is safe but slower than a single constructor handle. If the actual argument is a ScriptFunction it
166             // would be nice if we could change the formal parameter to ScriptFunction.class and add a guard for it
167             // in the main invocation.
168             final MethodHandle ctor = JavaAdapterFactory.getConstructor(paramType, targetType, getCurrentLookup(lookupSupplier));
169             assert ctor != null; // if isAutoConvertibleFromFunction() returned true, then ctor must exist.
170             return new GuardedInvocation(ctor, isSourceTypeGeneric ? IS_FUNCTION : null);
171         }
172         return null;
173     }
174 
175     private static MethodHandles.Lookup getCurrentLookup(final Supplier&lt;MethodHandles.Lookup&gt; lookupSupplier) {
176         return AccessController.doPrivileged(new PrivilegedAction&lt;MethodHandles.Lookup&gt;() {
177             @Override
178             public MethodHandles.Lookup run() {
179                 return lookupSupplier.get();
180             }
181         }, GET_LOOKUP_PERMISSION_CONTEXT);
182     }
183 
184     /**
185      * Returns a guarded invocation that converts from a source type that is NativeArray to a Java array or List or
186      * Queue or Deque or Collection type.
187      * @param sourceType the source type (presumably NativeArray a superclass of it)
188      * @param targetType the target type (presumably an array type, or List or Queue, or Deque, or Collection)
189      * @return a guarded invocation that converts from the source type to the target type. null is returned if
190      * either the source type is neither NativeArray, nor a superclass of it, or if the target type is not an array
191      * type, List, Queue, Deque, or Collection.
192      */
193     private static GuardedInvocation getArrayConverter(final Class&lt;?&gt; sourceType, final Class&lt;?&gt; targetType, final Supplier&lt;MethodHandles.Lookup&gt; lookupSupplier) {
194         final boolean isSourceTypeNativeArray = sourceType == NativeArray.class;
195         // If source type is more generic than NativeArray class, we&#39;ll need to use a guard
196         final boolean isSourceTypeGeneric = !isSourceTypeNativeArray &amp;&amp; sourceType.isAssignableFrom(NativeArray.class);
197 
198         if (isSourceTypeNativeArray || isSourceTypeGeneric) {
199             final MethodHandle guard = isSourceTypeGeneric ? IS_NATIVE_ARRAY : null;
200             if(targetType.isArray()) {
201                 final MethodHandle mh = ARRAY_CONVERTERS.get(targetType);
202                 final MethodHandle mhWithLookup;
203                 if (mh.type().parameterCount() == 2) {
204                     assert mh.type().parameterType(1) == SecureLookupSupplier.class;
205                     // We enter this branch when the array&#39;s ultimate component
206                     // type is a SAM type; we use a handle to JSType.toJavaArrayWithLookup
207                     // for these in the converter MH and must bind it here with
208                     // a secure supplier for the current lookup. By retrieving
209                     // the lookup, we&#39;ll also (correctly) inform the type
210                     // converter that this array converter is lookup specific.
211                     // We then need to wrap the returned lookup into a
212                     // new SecureLookupSupplier in order to bind it to the
213                     // JSType.toJavaArrayWithLookup() parameter.
214                     mhWithLookup = MH.insertArguments(mh, 1,
215                             new SecureLookupSupplier(getCurrentLookup(lookupSupplier)));
216                 } else {
217                     mhWithLookup = mh;
218                 }
219                 return new GuardedInvocation(mhWithLookup, guard);
220             } else if(targetType == List.class) {
221                 return new GuardedInvocation(TO_LIST, guard);
222             } else if(targetType == Deque.class) {
223                 return new GuardedInvocation(TO_DEQUE, guard);
224             } else if(targetType == Queue.class) {
225                 return new GuardedInvocation(TO_QUEUE, guard);
226             } else if(targetType == Collection.class) {
227                 return new GuardedInvocation(TO_COLLECTION, guard);
228             }
229         }
230         return null;
231     }
232 
233     private static MethodHandle createArrayConverter(final Class&lt;?&gt; type) {
234         assert type.isArray();
235 
236         final Class&lt;?&gt; componentType = type.getComponentType();
237         final Call converterCall;
238         // Is the ultimate component type of this array a SAM type?
239         if (isComponentTypeAutoConvertibleFromFunction(componentType)) {
240             converterCall = JSType.TO_JAVA_ARRAY_WITH_LOOKUP;
241         } else {
242             converterCall = JSType.TO_JAVA_ARRAY;
243         }
244         final MethodHandle typeBoundConverter = MH.insertArguments(converterCall.methodHandle(), 1, componentType);
245         return MH.asType(typeBoundConverter, typeBoundConverter.type().changeReturnType(type));
246     }
247 
248     private static boolean isComponentTypeAutoConvertibleFromFunction(final Class&lt;?&gt; targetType) {
249         if (targetType.isArray()) {
250             return isComponentTypeAutoConvertibleFromFunction(targetType.getComponentType());
251         }
252         return isAutoConvertibleFromFunction(targetType);
253     }
254 
255     private static GuardedInvocation getMirrorConverter(final Class&lt;?&gt; sourceType, final Class&lt;?&gt; targetType) {
256         // Could&#39;ve also used (targetType.isAssignableFrom(ScriptObjectMirror.class) &amp;&amp; targetType != Object.class) but
257         // it&#39;s probably better to explicitly spell out the supported target types
258         if (targetType == Map.class || targetType == Bindings.class || targetType == JSObject.class || targetType == ScriptObjectMirror.class) {
259             if (ScriptObject.class.isAssignableFrom(sourceType)) {
260                 return new GuardedInvocation(CREATE_MIRROR);
261             } else if (sourceType.isAssignableFrom(ScriptObject.class) || sourceType.isInterface()) {
262                 return new GuardedInvocation(CREATE_MIRROR, IS_SCRIPT_OBJECT);
263             }
264         }
265         return null;
266     }
267 
268     private static boolean isAutoConvertibleFromFunction(final Class&lt;?&gt; clazz) {
269         return isAbstractClass(clazz) &amp;&amp; !ScriptObject.class.isAssignableFrom(clazz) &amp;&amp;
270                 JavaAdapterFactory.isAutoConvertibleFromFunction(clazz);
271     }
272 
273     /**
274      * Utility method used by few other places in the code. Tests if the class has the abstract modifier and is not an
275      * array class. For some reason, array classes have the abstract modifier set in HotSpot JVM, and we don&#39;t want to
276      * treat array classes as abstract.
277      * @param clazz the inspected class
278      * @return true if the class is abstract and is not an array type.
279      */
280     static boolean isAbstractClass(final Class&lt;?&gt; clazz) {
281         return Modifier.isAbstract(clazz.getModifiers()) &amp;&amp; !clazz.isArray();
282     }
283 
284 
285     @Override
286     public Comparison compareConversion(final Class&lt;?&gt; sourceType, final Class&lt;?&gt; targetType1, final Class&lt;?&gt; targetType2) {
287         if(sourceType == NativeArray.class) {
288             // Prefer those types we can convert to with just a wrapper (cheaper than Java array creation).
289             if(isArrayPreferredTarget(targetType1)) {
290                 if(!isArrayPreferredTarget(targetType2)) {
291                     return Comparison.TYPE_1_BETTER;
292                 }
293             } else if(isArrayPreferredTarget(targetType2)) {
294                 return Comparison.TYPE_2_BETTER;
295             }
296             // Then prefer Java arrays
297             if(targetType1.isArray()) {
298                 if(!targetType2.isArray()) {
299                     return Comparison.TYPE_1_BETTER;
300                 }
301             } else if(targetType2.isArray()) {
302                 return Comparison.TYPE_2_BETTER;
303             }
304         }
305         if(ScriptObject.class.isAssignableFrom(sourceType)) {
306             // Prefer interfaces
307             if(targetType1.isInterface()) {
308                 if(!targetType2.isInterface()) {
309                     return Comparison.TYPE_1_BETTER;
310                 }
311             } else if(targetType2.isInterface()) {
312                 return Comparison.TYPE_2_BETTER;
313             }
314         }
315         return Comparison.INDETERMINATE;
316     }
317 
318     private static boolean isArrayPreferredTarget(final Class&lt;?&gt; clazz) {
319         return clazz == List.class || clazz == Collection.class || clazz == Queue.class || clazz == Deque.class;
320     }
321 
322     private static final MethodHandle IS_SCRIPT_OBJECT = Guards.isInstance(ScriptObject.class, MH.type(Boolean.TYPE, Object.class));
323     private static final MethodHandle IS_FUNCTION = findOwnMH(&quot;isFunction&quot;, boolean.class, Object.class);
324     private static final MethodHandle IS_NATIVE_ARRAY = Guards.isOfClass(NativeArray.class, MH.type(Boolean.TYPE, Object.class));
325 
326     private static final MethodHandle IS_NASHORN_OR_UNDEFINED_TYPE = findOwnMH(&quot;isNashornTypeOrUndefined&quot;, Boolean.TYPE, Object.class);
327     private static final MethodHandle CREATE_MIRROR = findOwnMH(&quot;createMirror&quot;, Object.class, Object.class);
328 
329     private static final MethodHandle TO_COLLECTION;
330     private static final MethodHandle TO_DEQUE;
331     private static final MethodHandle TO_LIST;
332     private static final MethodHandle TO_QUEUE;
333     static {
334         final MethodHandle listAdapterCreate = new Lookup(MethodHandles.lookup()).findStatic(
335                 ListAdapter.class, &quot;create&quot;, MethodType.methodType(ListAdapter.class, Object.class));
336         TO_COLLECTION = asReturning(listAdapterCreate, Collection.class);
337         TO_DEQUE = asReturning(listAdapterCreate, Deque.class);
338         TO_LIST = asReturning(listAdapterCreate, List.class);
339         TO_QUEUE = asReturning(listAdapterCreate, Queue.class);
340     }
341 
342     private static MethodHandle asReturning(final MethodHandle mh, final Class&lt;?&gt; nrtype) {
343         return mh.asType(mh.type().changeReturnType(nrtype));
344     }
345 
346     @SuppressWarnings(&quot;unused&quot;)
347     private static boolean isNashornTypeOrUndefined(final Object obj) {
348         return obj instanceof ScriptObject || obj instanceof Undefined;
349     }
350 
351     @SuppressWarnings(&quot;unused&quot;)
352     private static Object createMirror(final Object obj) {
353         return obj instanceof ScriptObject? ScriptUtils.wrap((ScriptObject)obj) : obj;
354     }
355 
356     @SuppressWarnings(&quot;unused&quot;)
357     private static boolean isFunction(final Object obj) {
358         return obj instanceof ScriptFunction || obj instanceof ScriptObjectMirror &amp;&amp; ((ScriptObjectMirror) obj).isFunction();
359     }
360 
361     private static MethodHandle findOwnMH(final String name, final Class&lt;?&gt; rtype, final Class&lt;?&gt;... types) {
362         return MH.findStatic(MethodHandles.lookup(), NashornLinker.class, name, MH.type(rtype, types));
363     }
364 }
365 
    </pre>
  </body>
</html>
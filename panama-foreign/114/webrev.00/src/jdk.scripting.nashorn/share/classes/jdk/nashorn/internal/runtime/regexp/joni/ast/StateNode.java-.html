<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/regexp/joni/ast/StateNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Permission is hereby granted, free of charge, to any person obtaining a copy of
  3  * this software and associated documentation files (the &quot;Software&quot;), to deal in
  4  * the Software without restriction, including without limitation the rights to
  5  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
  6  * of the Software, and to permit persons to whom the Software is furnished to do
  7  * so, subject to the following conditions:
  8  *
  9  * The above copyright notice and this permission notice shall be included in all
 10  * copies or substantial portions of the Software.
 11  *
 12  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 13  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 14  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 15  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 16  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 17  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 18  * SOFTWARE.
 19  */
 20 package jdk.nashorn.internal.runtime.regexp.joni.ast;
 21 
 22 import jdk.nashorn.internal.runtime.regexp.joni.constants.NodeStatus;
 23 
 24 @SuppressWarnings(&quot;javadoc&quot;)
 25 public abstract class StateNode extends Node implements NodeStatus {
 26     protected int state;
 27 
 28     @Override
 29     public String toString(final int level) {
 30         return &quot;\n  state: &quot; + stateToString();
 31     }
 32 
 33     public String stateToString() {
 34         final StringBuilder states = new StringBuilder();
 35         if (isMinFixed()) states.append(&quot;MIN_FIXED &quot;);
 36         if (isMaxFixed()) states.append(&quot;MAX_FIXED &quot;);
 37         if (isMark1()) states.append(&quot;MARK1 &quot;);
 38         if (isMark2()) states.append(&quot;MARK2 &quot;);
 39         if (isMemBackrefed()) states.append(&quot;MEM_BACKREFED &quot;);
 40         if (isStopBtSimpleRepeat()) states.append(&quot;STOP_BT_SIMPLE_REPEAT &quot;);
 41         if (isRecursion()) states.append(&quot;RECURSION &quot;);
 42         if (isCalled()) states.append(&quot;CALLED &quot;);
 43         if (isAddrFixed()) states.append(&quot;ADDR_FIXED &quot;);
 44         if (isInRepeat()) states.append(&quot;IN_REPEAT &quot;);
 45         if (isNestLevel()) states.append(&quot;NEST_LEVEL &quot;);
 46         if (isByNumber()) states.append(&quot;BY_NUMBER &quot;);
 47 
 48         return states.toString();
 49     }
 50 
 51     public boolean isMinFixed() {
 52         return (state &amp; NST_MIN_FIXED) != 0;
 53     }
 54 
 55     public void setMinFixed() {
 56         state |= NST_MIN_FIXED;
 57     }
 58 
 59     public boolean isMaxFixed() {
 60         return (state &amp; NST_MAX_FIXED) != 0;
 61     }
 62 
 63     public void setMaxFixed() {
 64         state |= NST_MAX_FIXED;
 65     }
 66 
 67     public boolean isCLenFixed() {
 68         return (state &amp; NST_CLEN_FIXED) != 0;
 69     }
 70 
 71     public void setCLenFixed() {
 72         state |= NST_CLEN_FIXED;
 73     }
 74 
 75     public boolean isMark1() {
 76         return (state &amp; NST_MARK1) != 0;
 77     }
 78 
 79     public void setMark1() {
 80         state |= NST_MARK1;
 81     }
 82 
 83     public boolean isMark2() {
 84         return (state &amp; NST_MARK2) != 0;
 85     }
 86 
 87     public void setMark2() {
 88         state |= NST_MARK2;
 89     }
 90 
 91     public void clearMark2() {
 92         state &amp;= ~NST_MARK2;
 93     }
 94 
 95     public boolean isMemBackrefed() {
 96         return (state &amp; NST_MEM_BACKREFED) != 0;
 97     }
 98 
 99     public void setMemBackrefed() {
100         state |= NST_MEM_BACKREFED;
101     }
102 
103     public boolean isStopBtSimpleRepeat() {
104         return (state &amp; NST_STOP_BT_SIMPLE_REPEAT) != 0;
105     }
106 
107     public void setStopBtSimpleRepeat() {
108         state |= NST_STOP_BT_SIMPLE_REPEAT;
109     }
110 
111     public boolean isRecursion() {
112         return (state &amp; NST_RECURSION) != 0;
113     }
114 
115     public void setRecursion() {
116         state |= NST_RECURSION;
117     }
118 
119     public boolean isCalled() {
120         return (state &amp; NST_CALLED) != 0;
121     }
122 
123     public void setCalled() {
124         state |= NST_CALLED;
125     }
126 
127     public boolean isAddrFixed() {
128         return (state &amp; NST_ADDR_FIXED) != 0;
129     }
130 
131     public void setAddrFixed() {
132         state |= NST_ADDR_FIXED;
133     }
134 
135     public boolean isInRepeat() {
136         return (state &amp; NST_IN_REPEAT) != 0;
137     }
138 
139     public void setInRepeat() {
140         state |= NST_IN_REPEAT;
141     }
142 
143     public boolean isNestLevel() {
144         return (state &amp; NST_NEST_LEVEL) != 0;
145     }
146 
147     public void setNestLevel() {
148         state |= NST_NEST_LEVEL;
149     }
150 
151     public boolean isByNumber() {
152         return (state &amp; NST_BY_NUMBER) != 0;
153     }
154 
155     public void setByNumber() {
156         state |= NST_BY_NUMBER;
157     }
158 
159 }
    </pre>
  </body>
</html>
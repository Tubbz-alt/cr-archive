<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/ir/visitor/NodeVisitor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.ir.visitor;
 27 
 28 import jdk.nashorn.internal.ir.AccessNode;
 29 import jdk.nashorn.internal.ir.BinaryNode;
 30 import jdk.nashorn.internal.ir.Block;
 31 import jdk.nashorn.internal.ir.BlockStatement;
 32 import jdk.nashorn.internal.ir.BreakNode;
 33 import jdk.nashorn.internal.ir.CallNode;
 34 import jdk.nashorn.internal.ir.CaseNode;
 35 import jdk.nashorn.internal.ir.CatchNode;
 36 import jdk.nashorn.internal.ir.ClassNode;
 37 import jdk.nashorn.internal.ir.ContinueNode;
 38 import jdk.nashorn.internal.ir.DebuggerNode;
 39 import jdk.nashorn.internal.ir.EmptyNode;
 40 import jdk.nashorn.internal.ir.ErrorNode;
 41 import jdk.nashorn.internal.ir.ExpressionStatement;
 42 import jdk.nashorn.internal.ir.ForNode;
 43 import jdk.nashorn.internal.ir.FunctionNode;
 44 import jdk.nashorn.internal.ir.GetSplitState;
 45 import jdk.nashorn.internal.ir.IdentNode;
 46 import jdk.nashorn.internal.ir.IfNode;
 47 import jdk.nashorn.internal.ir.IndexNode;
 48 import jdk.nashorn.internal.ir.JoinPredecessorExpression;
 49 import jdk.nashorn.internal.ir.JumpToInlinedFinally;
 50 import jdk.nashorn.internal.ir.LabelNode;
 51 import jdk.nashorn.internal.ir.LexicalContext;
 52 import jdk.nashorn.internal.ir.LiteralNode;
 53 import jdk.nashorn.internal.ir.Node;
 54 import jdk.nashorn.internal.ir.ObjectNode;
 55 import jdk.nashorn.internal.ir.PropertyNode;
 56 import jdk.nashorn.internal.ir.ReturnNode;
 57 import jdk.nashorn.internal.ir.RuntimeNode;
 58 import jdk.nashorn.internal.ir.SetSplitState;
 59 import jdk.nashorn.internal.ir.SplitNode;
 60 import jdk.nashorn.internal.ir.SplitReturn;
 61 import jdk.nashorn.internal.ir.SwitchNode;
 62 import jdk.nashorn.internal.ir.TemplateLiteral;
 63 import jdk.nashorn.internal.ir.TernaryNode;
 64 import jdk.nashorn.internal.ir.ThrowNode;
 65 import jdk.nashorn.internal.ir.TryNode;
 66 import jdk.nashorn.internal.ir.UnaryNode;
 67 import jdk.nashorn.internal.ir.VarNode;
 68 import jdk.nashorn.internal.ir.WhileNode;
 69 import jdk.nashorn.internal.ir.WithNode;
 70 
 71 /**
 72  * Visitor used to navigate the IR.
 73  * @param &lt;T&gt; lexical context class used by this visitor
 74  */
 75 public abstract class NodeVisitor&lt;T extends LexicalContext&gt; {
 76     /** lexical context in use */
 77     protected final T lc;
 78 
 79     /**
 80      * Constructor
 81      *
 82      * @param lc a custom lexical context
 83      */
 84     public NodeVisitor(final T lc) {
 85         this.lc = lc;
 86     }
 87 
 88     /**
 89      * Get the lexical context of this node visitor
 90      * @return lexical context
 91      */
 92     public T getLexicalContext() {
 93         return lc;
 94     }
 95 
 96     /**
 97      * Override this method to do a double inheritance pattern, e.g. avoid
 98      * using
 99      * &lt;p&gt;
100      * if (x instanceof NodeTypeA) {
101      *    ...
102      * } else if (x instanceof NodeTypeB) {
103      *    ...
104      * } else {
105      *    ...
106      * }
107      * &lt;p&gt;
108      * Use a NodeVisitor instead, and this method contents forms the else case.
109      *
110      * @see NodeVisitor#leaveDefault(Node)
111      * @param node the node to visit
112      * @return true if traversal should continue and node children be traversed, false otherwise
113      */
114     protected boolean enterDefault(final Node node) {
115         return true;
116     }
117 
118     /**
119      * Override this method to do a double inheritance pattern, e.g. avoid
120      * using
121      * &lt;p&gt;
122      * if (x instanceof NodeTypeA) {
123      *    ...
124      * } else if (x instanceof NodeTypeB) {
125      *    ...
126      * } else {
127      *    ...
128      * }
129      * &lt;p&gt;
130      * Use a NodeVisitor instead, and this method contents forms the else case.
131      *
132      * @see NodeVisitor#enterDefault(Node)
133      * @param node the node to visit
134      * @return the node
135      */
136     protected Node leaveDefault(final Node node) {
137         return node;
138     }
139 
140     /**
141      * Callback for entering an AccessNode
142      *
143      * @param  accessNode the node
144      * @return true if traversal should continue and node children be traversed, false otherwise
145      */
146     public boolean enterAccessNode(final AccessNode accessNode) {
147         return enterDefault(accessNode);
148     }
149 
150     /**
151      * Callback for entering an AccessNode
152      *
153      * @param  accessNode the node
154      * @return processed node, null if traversal should end
155      */
156     public Node leaveAccessNode(final AccessNode accessNode) {
157         return leaveDefault(accessNode);
158     }
159 
160     /**
161      * Callback for entering a Block
162      *
163      * @param  block     the node
164      * @return true if traversal should continue and node children be traversed, false otherwise
165      */
166     public boolean enterBlock(final Block block) {
167         return enterDefault(block);
168     }
169 
170     /**
171      * Callback for leaving a Block
172      *
173      * @param  block the node
174      * @return processed node, which will replace the original one, or the original node
175      */
176     public Node leaveBlock(final Block block) {
177         return leaveDefault(block);
178     }
179 
180     /**
181      * Callback for entering a BinaryNode
182      *
183      * @param  binaryNode  the node
184      * @return processed   node
185      */
186     public boolean enterBinaryNode(final BinaryNode binaryNode) {
187         return enterDefault(binaryNode);
188     }
189 
190     /**
191      * Callback for leaving a BinaryNode
192      *
193      * @param  binaryNode the node
194      * @return processed node, which will replace the original one, or the original node
195      */
196     public Node leaveBinaryNode(final BinaryNode binaryNode) {
197         return leaveDefault(binaryNode);
198     }
199 
200     /**
201      * Callback for entering a BreakNode
202      *
203      * @param  breakNode the node
204      * @return true if traversal should continue and node children be traversed, false otherwise
205      */
206     public boolean enterBreakNode(final BreakNode breakNode) {
207         return enterDefault(breakNode);
208     }
209 
210     /**
211      * Callback for leaving a BreakNode
212      *
213      * @param  breakNode the node
214      * @return processed node, which will replace the original one, or the original node
215      */
216     public Node leaveBreakNode(final BreakNode breakNode) {
217         return leaveDefault(breakNode);
218     }
219 
220     /**
221      * Callback for entering a CallNode
222      *
223      * @param  callNode  the node
224      * @return true if traversal should continue and node children be traversed, false otherwise
225      */
226     public boolean enterCallNode(final CallNode callNode) {
227         return enterDefault(callNode);
228     }
229 
230     /**
231      * Callback for leaving a CallNode
232      *
233      * @param  callNode the node
234      * @return processed node, which will replace the original one, or the original node
235      */
236     public Node leaveCallNode(final CallNode callNode) {
237         return leaveDefault(callNode);
238     }
239 
240     /**
241      * Callback for entering a CaseNode
242      *
243      * @param  caseNode  the node
244      * @return true if traversal should continue and node children be traversed, false otherwise
245      */
246     public boolean enterCaseNode(final CaseNode caseNode) {
247         return enterDefault(caseNode);
248     }
249 
250     /**
251      * Callback for leaving a CaseNode
252      *
253      * @param  caseNode the node
254      * @return processed node, which will replace the original one, or the original node
255      */
256     public Node leaveCaseNode(final CaseNode caseNode) {
257         return leaveDefault(caseNode);
258     }
259 
260     /**
261      * Callback for entering a CatchNode
262      *
263      * @param  catchNode the node
264      * @return true if traversal should continue and node children be traversed, false otherwise
265      */
266     public boolean enterCatchNode(final CatchNode catchNode) {
267         return enterDefault(catchNode);
268     }
269 
270     /**
271      * Callback for leaving a CatchNode
272      *
273      * @param  catchNode the node
274      * @return processed node, which will replace the original one, or the original node
275      */
276     public Node leaveCatchNode(final CatchNode catchNode) {
277         return leaveDefault(catchNode);
278     }
279 
280     /**
281      * Callback for entering a ContinueNode
282      *
283      * @param  continueNode the node
284      * @return true if traversal should continue and node children be traversed, false otherwise
285      */
286     public boolean enterContinueNode(final ContinueNode continueNode) {
287         return enterDefault(continueNode);
288     }
289 
290     /**
291      * Callback for leaving a ContinueNode
292      *
293      * @param  continueNode the node
294      * @return processed node, which will replace the original one, or the original node
295      */
296     public Node leaveContinueNode(final ContinueNode continueNode) {
297         return leaveDefault(continueNode);
298     }
299 
300 
301     /**
302      * Callback for entering a DebuggerNode
303      *
304      * @param  debuggerNode the node
305      * @return true if traversal should continue and node children be traversed, false otherwise
306      */
307     public boolean enterDebuggerNode(final DebuggerNode debuggerNode) {
308         return enterDefault(debuggerNode);
309     }
310 
311     /**
312      * Callback for leaving a DebuggerNode
313      *
314      * @param  debuggerNode the node
315      * @return processed node, which will replace the original one, or the original node
316      */
317     public Node leaveDebuggerNode(final DebuggerNode debuggerNode) {
318         return leaveDefault(debuggerNode);
319     }
320 
321     /**
322      * Callback for entering an EmptyNode
323      *
324      * @param  emptyNode   the node
325      * @return true if traversal should continue and node children be traversed, false otherwise
326      */
327     public boolean enterEmptyNode(final EmptyNode emptyNode) {
328         return enterDefault(emptyNode);
329     }
330 
331     /**
332      * Callback for leaving an EmptyNode
333      *
334      * @param  emptyNode the node
335      * @return processed node, which will replace the original one, or the original node
336      */
337     public Node leaveEmptyNode(final EmptyNode emptyNode) {
338         return leaveDefault(emptyNode);
339     }
340 
341     /**
342      * Callback for entering an ErrorNode
343      *
344      * @param  errorNode   the node
345      * @return true if traversal should continue and node children be traversed, false otherwise
346      */
347     public boolean enterErrorNode(final ErrorNode errorNode) {
348         return enterDefault(errorNode);
349     }
350 
351     /**
352      * Callback for leaving an ErrorNode
353      *
354      * @param  errorNode the node
355      * @return processed node, which will replace the original one, or the original node
356      */
357     public Node leaveErrorNode(final ErrorNode errorNode) {
358         return leaveDefault(errorNode);
359     }
360 
361     /**
362      * Callback for entering an ExpressionStatement
363      *
364      * @param  expressionStatement the node
365      * @return true if traversal should continue and node children be traversed, false otherwise
366      */
367     public boolean enterExpressionStatement(final ExpressionStatement expressionStatement) {
368         return enterDefault(expressionStatement);
369     }
370 
371     /**
372      * Callback for leaving an ExpressionStatement
373      *
374      * @param  expressionStatement the node
375      * @return processed node, which will replace the original one, or the original node
376      */
377     public Node leaveExpressionStatement(final ExpressionStatement expressionStatement) {
378         return leaveDefault(expressionStatement);
379     }
380 
381     /**
382      * Callback for entering a BlockStatement
383      *
384      * @param  blockStatement the node
385      * @return true if traversal should continue and node children be traversed, false otherwise
386      */
387     public boolean enterBlockStatement(final BlockStatement blockStatement) {
388         return enterDefault(blockStatement);
389     }
390 
391     /**
392      * Callback for leaving a BlockStatement
393      *
394      * @param  blockStatement the node
395      * @return processed node, which will replace the original one, or the original node
396      */
397     public Node leaveBlockStatement(final BlockStatement blockStatement) {
398         return leaveDefault(blockStatement);
399     }
400 
401     /**
402      * Callback for entering a ForNode
403      *
404      * @param  forNode   the node
405      * @return true if traversal should continue and node children be traversed, false otherwise
406      */
407     public boolean enterForNode(final ForNode forNode) {
408         return enterDefault(forNode);
409     }
410 
411     /**
412      * Callback for leaving a ForNode
413      *
414      * @param  forNode the node
415      * @return processed node, which will replace the original one, or the original node
416      */
417     public Node leaveForNode(final ForNode forNode) {
418         return leaveDefault(forNode);
419     }
420 
421     /**
422      * Callback for entering a FunctionNode
423      *
424      * @param  functionNode the node
425      * @return true if traversal should continue and node children be traversed, false otherwise
426      */
427     public boolean enterFunctionNode(final FunctionNode functionNode) {
428         return enterDefault(functionNode);
429     }
430 
431     /**
432      * Callback for leaving a FunctionNode
433      *
434      * @param  functionNode the node
435      * @return processed node, which will replace the original one, or the original node
436      */
437     public Node leaveFunctionNode(final FunctionNode functionNode) {
438         return leaveDefault(functionNode);
439     }
440 
441     /**
442      * Callback for entering a {@link GetSplitState}.
443      *
444      * @param  getSplitState the get split state expression
445      * @return true if traversal should continue and node children be traversed, false otherwise
446      */
447     public boolean enterGetSplitState(final GetSplitState getSplitState) {
448         return enterDefault(getSplitState);
449     }
450 
451     /**
452      * Callback for leaving a {@link GetSplitState}.
453      *
454      * @param  getSplitState the get split state expression
455      * @return processed node, which will replace the original one, or the original node
456      */
457     public Node leaveGetSplitState(final GetSplitState getSplitState) {
458         return leaveDefault(getSplitState);
459     }
460 
461     /**
462      * Callback for entering an IdentNode
463      *
464      * @param  identNode the node
465      * @return true if traversal should continue and node children be traversed, false otherwise
466      */
467     public boolean enterIdentNode(final IdentNode identNode) {
468         return enterDefault(identNode);
469     }
470 
471     /**
472      * Callback for leaving an IdentNode
473      *
474      * @param  identNode the node
475      * @return processed node, which will replace the original one, or the original node
476      */
477     public Node leaveIdentNode(final IdentNode identNode) {
478         return leaveDefault(identNode);
479     }
480 
481     /**
482      * Callback for entering an IfNode
483      *
484      * @param  ifNode the node
485      * @return true if traversal should continue and node children be traversed, false otherwise
486      */
487     public boolean enterIfNode(final IfNode ifNode) {
488         return enterDefault(ifNode);
489     }
490 
491     /**
492      * Callback for leaving an IfNode
493      *
494      * @param  ifNode the node
495      * @return processed node, which will replace the original one, or the original node
496      */
497     public Node leaveIfNode(final IfNode ifNode) {
498         return leaveDefault(ifNode);
499     }
500 
501     /**
502      * Callback for entering an IndexNode
503      *
504      * @param  indexNode  the node
505      * @return true if traversal should continue and node children be traversed, false otherwise
506      */
507     public boolean enterIndexNode(final IndexNode indexNode) {
508         return enterDefault(indexNode);
509     }
510 
511     /**
512      * Callback for leaving an IndexNode
513      *
514      * @param  indexNode the node
515      * @return processed node, which will replace the original one, or the original node
516      */
517     public Node leaveIndexNode(final IndexNode indexNode) {
518         return leaveDefault(indexNode);
519     }
520 
521     /**
522      * Callback for entering a JumpToInlinedFinally
523      *
524      * @param  jumpToInlinedFinally the node
525      * @return true if traversal should continue and node children be traversed, false otherwise
526      */
527     public boolean enterJumpToInlinedFinally(final JumpToInlinedFinally jumpToInlinedFinally) {
528         return enterDefault(jumpToInlinedFinally);
529     }
530 
531     /**
532      * Callback for leaving a JumpToInlinedFinally
533      *
534      * @param  jumpToInlinedFinally the node
535      * @return processed node, which will replace the original one, or the original node
536      */
537     public Node leaveJumpToInlinedFinally(final JumpToInlinedFinally jumpToInlinedFinally) {
538         return leaveDefault(jumpToInlinedFinally);
539     }
540 
541     /**
542      * Callback for entering a LabelNode
543      *
544      * @param  labelNode the node
545      * @return true if traversal should continue and node children be traversed, false otherwise
546      */
547     public boolean enterLabelNode(final LabelNode labelNode) {
548         return enterDefault(labelNode);
549     }
550 
551     /**
552      * Callback for leaving a LabelNode
553      *
554      * @param  labelNode the node
555      * @return processed node, which will replace the original one, or the original node
556      */
557     public Node leaveLabelNode(final LabelNode labelNode) {
558         return leaveDefault(labelNode);
559     }
560 
561     /**
562      * Callback for entering a LiteralNode
563      *
564      * @param  literalNode the node
565      * @return true if traversal should continue and node children be traversed, false otherwise
566      */
567     public boolean enterLiteralNode(final LiteralNode&lt;?&gt; literalNode) {
568         return enterDefault(literalNode);
569     }
570 
571     /**
572      * Callback for leaving a LiteralNode
573      *
574      * @param  literalNode the node
575      * @return processed node, which will replace the original one, or the original node
576      */
577     public Node leaveLiteralNode(final LiteralNode&lt;?&gt; literalNode) {
578         return leaveDefault(literalNode);
579     }
580 
581     /**
582      * Callback for entering an ObjectNode
583      *
584      * @param  objectNode the node
585      * @return true if traversal should continue and node children be traversed, false otherwise
586      */
587     public boolean enterObjectNode(final ObjectNode objectNode) {
588         return enterDefault(objectNode);
589     }
590 
591     /**
592      * Callback for leaving an ObjectNode
593      *
594      * @param  objectNode the node
595      * @return processed node, which will replace the original one, or the original node
596      */
597     public Node leaveObjectNode(final ObjectNode objectNode) {
598         return leaveDefault(objectNode);
599     }
600 
601     /**
602      * Callback for entering a PropertyNode
603      *
604      * @param  propertyNode the node
605      * @return true if traversal should continue and node children be traversed, false otherwise
606      */
607     public boolean enterPropertyNode(final PropertyNode propertyNode) {
608         return enterDefault(propertyNode);
609     }
610 
611     /**
612      * Callback for leaving a PropertyNode
613      *
614      * @param  propertyNode the node
615      * @return processed node, which will replace the original one, or the original node
616      */
617     public Node leavePropertyNode(final PropertyNode propertyNode) {
618         return leaveDefault(propertyNode);
619     }
620 
621     /**
622      * Callback for entering a ReturnNode
623      *
624      * @param  returnNode the node
625      * @return true if traversal should continue and node children be traversed, false otherwise
626      */
627     public boolean enterReturnNode(final ReturnNode returnNode) {
628         return enterDefault(returnNode);
629     }
630 
631     /**
632      * Callback for leaving a ReturnNode
633      *
634      * @param  returnNode the node
635      * @return processed node, which will replace the original one, or the original node
636      */
637     public Node leaveReturnNode(final ReturnNode returnNode) {
638         return leaveDefault(returnNode);
639     }
640 
641     /**
642      * Callback for entering a RuntimeNode
643      *
644      * @param  runtimeNode the node
645      * @return true if traversal should continue and node children be traversed, false otherwise
646      */
647     public boolean enterRuntimeNode(final RuntimeNode runtimeNode) {
648         return enterDefault(runtimeNode);
649     }
650 
651     /**
652      * Callback for leaving a RuntimeNode
653      *
654      * @param  runtimeNode the node
655      * @return processed node, which will replace the original one, or the original node
656      */
657     public Node leaveRuntimeNode(final RuntimeNode runtimeNode) {
658         return leaveDefault(runtimeNode);
659     }
660 
661     /**
662      * Callback for entering a {@link SetSplitState}.
663      *
664      * @param  setSplitState the set split state statement
665      * @return true if traversal should continue and node children be traversed, false otherwise
666      */
667     public boolean enterSetSplitState(final SetSplitState setSplitState) {
668         return enterDefault(setSplitState);
669     }
670 
671     /**
672      * Callback for leaving a {@link SetSplitState}.
673      *
674      * @param  setSplitState the set split state expression
675      * @return processed node, which will replace the original one, or the original node
676      */
677     public Node leaveSetSplitState(final SetSplitState setSplitState) {
678         return leaveDefault(setSplitState);
679     }
680 
681     /**
682      * Callback for entering a SplitNode
683      *
684      * @param  splitNode the node
685      * @return true if traversal should continue and node children be traversed, false otherwise
686      */
687     public boolean enterSplitNode(final SplitNode splitNode) {
688         return enterDefault(splitNode);
689     }
690 
691     /**
692      * Callback for leaving a SplitNode
693      *
694      * @param  splitNode the node
695      * @return processed node, which will replace the original one, or the original node
696      */
697     public Node leaveSplitNode(final SplitNode splitNode) {
698         return leaveDefault(splitNode);
699     }
700 
701     /**
702      * Callback for entering a SplitReturn
703      *
704      * @param  splitReturn the node
705      * @return true if traversal should continue and node children be traversed, false otherwise
706      */
707     public boolean enterSplitReturn(final SplitReturn splitReturn) {
708         return enterDefault(splitReturn);
709     }
710 
711     /**
712      * Callback for leaving a SplitReturn
713      *
714      * @param  splitReturn the node
715      * @return processed node, which will replace the original one, or the original node
716      */
717     public Node leaveSplitReturn(final SplitReturn splitReturn) {
718         return leaveDefault(splitReturn);
719     }
720 
721     /**
722      * Callback for entering a SwitchNode
723      *
724      * @param  switchNode the node
725      * @return true if traversal should continue and node children be traversed, false otherwise
726      */
727     public boolean enterSwitchNode(final SwitchNode switchNode) {
728         return enterDefault(switchNode);
729     }
730 
731     /**
732      * Callback for leaving a SwitchNode
733      *
734      * @param  switchNode the node
735      * @return processed node, which will replace the original one, or the original node
736      */
737     public Node leaveSwitchNode(final SwitchNode switchNode) {
738         return leaveDefault(switchNode);
739     }
740 
741     /**
742      * Callback for entering a TemplateLiteral (used only in --parse-only mode)
743      *
744      * @param  templateLiteral the node
745      * @return true if traversal should continue and node children be traversed, false otherwise
746      */
747     public boolean enterTemplateLiteral(final TemplateLiteral templateLiteral) {
748         return enterDefault(templateLiteral);
749     }
750 
751     /**
752      * Callback for leaving a TemplateLiteral (used only in --parse-only mode)
753      *
754      * @param  templateLiteral the node
755      * @return processed node, which will replace the original one, or the original node
756      */
757     public Node leaveTemplateLiteral(final TemplateLiteral templateLiteral) {
758         return leaveDefault(templateLiteral);
759     }
760 
761     /**
762      * Callback for entering a TernaryNode
763      *
764      * @param  ternaryNode the node
765      * @return true if traversal should continue and node children be traversed, false otherwise
766      */
767     public boolean enterTernaryNode(final TernaryNode ternaryNode) {
768         return enterDefault(ternaryNode);
769     }
770 
771     /**
772      * Callback for leaving a TernaryNode
773      *
774      * @param  ternaryNode the node
775      * @return processed node, which will replace the original one, or the original node
776      */
777     public Node leaveTernaryNode(final TernaryNode ternaryNode) {
778         return leaveDefault(ternaryNode);
779     }
780 
781     /**
782      * Callback for entering a ThrowNode
783      *
784      * @param  throwNode the node
785      * @return true if traversal should continue and node children be traversed, false otherwise
786      */
787     public boolean enterThrowNode(final ThrowNode throwNode) {
788         return enterDefault(throwNode);
789     }
790 
791     /**
792      * Callback for leaving a ThrowNode
793      *
794      * @param  throwNode the node
795      * @return processed node, which will replace the original one, or the original node
796      */
797     public Node leaveThrowNode(final ThrowNode throwNode) {
798         return leaveDefault(throwNode);
799     }
800 
801     /**
802      * Callback for entering a TryNode
803      *
804      * @param  tryNode the node
805      * @return true if traversal should continue and node children be traversed, false otherwise
806      */
807     public boolean enterTryNode(final TryNode tryNode) {
808         return enterDefault(tryNode);
809     }
810 
811     /**
812      * Callback for leaving a TryNode
813      *
814      * @param  tryNode the node
815      * @return processed node, which will replace the original one, or the original node
816      */
817     public Node leaveTryNode(final TryNode tryNode) {
818         return leaveDefault(tryNode);
819     }
820 
821     /**
822      * Callback for entering a UnaryNode
823      *
824      * @param  unaryNode the node
825      * @return true if traversal should continue and node children be traversed, false otherwise
826      */
827     public boolean enterUnaryNode(final UnaryNode unaryNode) {
828         return enterDefault(unaryNode);
829     }
830 
831     /**
832      * Callback for leaving a UnaryNode
833      *
834      * @param  unaryNode the node
835      * @return processed node, which will replace the original one, or the original node
836      */
837     public Node leaveUnaryNode(final UnaryNode unaryNode) {
838         return leaveDefault(unaryNode);
839     }
840 
841     /**
842      * Callback for entering a {@link JoinPredecessorExpression}.
843      *
844      * @param  expr the join predecessor expression
845      * @return true if traversal should continue and node children be traversed, false otherwise
846      */
847     public boolean enterJoinPredecessorExpression(final JoinPredecessorExpression expr) {
848         return enterDefault(expr);
849     }
850 
851     /**
852      * Callback for leaving a {@link JoinPredecessorExpression}.
853      *
854      * @param  expr the join predecessor expression
855      * @return processed node, which will replace the original one, or the original node
856      */
857     public Node leaveJoinPredecessorExpression(final JoinPredecessorExpression expr) {
858         return leaveDefault(expr);
859     }
860 
861 
862     /**
863      * Callback for entering a VarNode
864      *
865      * @param  varNode   the node
866      * @return true if traversal should continue and node children be traversed, false otherwise
867      */
868     public boolean enterVarNode(final VarNode varNode) {
869         return enterDefault(varNode);
870     }
871 
872     /**
873      * Callback for leaving a VarNode
874      *
875      * @param  varNode the node
876      * @return processed node, which will replace the original one, or the original node
877      */
878     public Node leaveVarNode(final VarNode varNode) {
879         return leaveDefault(varNode);
880     }
881 
882     /**
883      * Callback for entering a WhileNode
884      *
885      * @param  whileNode the node
886      * @return true if traversal should continue and node children be traversed, false otherwise
887      */
888     public boolean enterWhileNode(final WhileNode whileNode) {
889         return enterDefault(whileNode);
890     }
891 
892     /**
893      * Callback for leaving a WhileNode
894      *
895      * @param  whileNode the node
896      * @return processed node, which will replace the original one, or the original node
897      */
898     public Node leaveWhileNode(final WhileNode whileNode) {
899         return leaveDefault(whileNode);
900     }
901 
902     /**
903      * Callback for entering a WithNode
904      *
905      * @param  withNode  the node
906      * @return true if traversal should continue and node children be traversed, false otherwise
907      */
908     public boolean enterWithNode(final WithNode withNode) {
909         return enterDefault(withNode);
910     }
911 
912     /**
913      * Callback for leaving a WithNode
914      *
915      * @param  withNode  the node
916      * @return processed node, which will replace the original one, or the original node
917      */
918     public Node leaveWithNode(final WithNode withNode) {
919         return leaveDefault(withNode);
920     }
921 
922     /**
923      * Callback for entering a ClassNode
924      *
925      * @param  classNode  the node
926      * @return true if traversal should continue and node children be traversed, false otherwise
927      */
928     public boolean enterClassNode(final ClassNode classNode) {
929         return enterDefault(classNode);
930     }
931 
932     /**
933      * Callback for leaving a ClassNode
934      *
935      * @param  classNode  the node
936      * @return processed node, which will replace the original one, or the original node
937      */
938     public Node leaveClassNode(final ClassNode classNode) {
939         return leaveDefault(classNode);
940     }
941 }
    </pre>
  </body>
</html>
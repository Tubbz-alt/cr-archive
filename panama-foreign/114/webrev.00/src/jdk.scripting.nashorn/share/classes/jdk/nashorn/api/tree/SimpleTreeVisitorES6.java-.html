<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/api/tree/SimpleTreeVisitorES6.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.api.tree;
 27 
 28 import java.util.List;
 29 
 30 /**
 31  * A simple implementation of the TreeVisitor for ECMAScript edition 6.
 32  *
 33  * &lt;p&gt;The visit methods corresponding to ES 6 language constructs walk the
 34  * &quot;components&quot; of the given tree by calling accept method passing the
 35  * current visitor and the additional parameter.
 36  *
 37  * &lt;p&gt;For constructs introduced in later versions, {@code visitUnknown}
 38  * is called instead which throws {@link UnknownTreeException}.
 39  *
 40  * &lt;p&gt; Methods in this class may be overridden subject to their
 41  * general contract.  Note that annotating methods in concrete
 42  * subclasses with {@link java.lang.Override @Override} will help
 43  * ensure that methods are overridden as intended.
 44  *
 45  * @deprecated Nashorn JavaScript script engine and APIs, and the jjs tool
 46  * are deprecated with the intent to remove them in a future release.
 47  *
 48  * @param &lt;R&gt; the return type of this visitor&#39;s methods.  Use {@link
 49  *            Void} for visitors that do not need to return results.
 50  * @param &lt;P&gt; the type of the additional parameter to this visitor&#39;s
 51  *            methods.  Use {@code Void} for visitors that do not need an
 52  *            additional parameter.
 53  */
 54 @Deprecated(since=&quot;11&quot;, forRemoval=true)
 55 public class SimpleTreeVisitorES6&lt;R, P&gt; extends SimpleTreeVisitorES5_1&lt;R, P&gt; {
 56     @Override
 57     public R visitCompilationUnit(final CompilationUnitTree node, final P r) {
 58         final ModuleTree mod = node.getModule();
 59         if (mod != null) {
 60             mod.accept(this, r);
 61         }
 62         return super.visitCompilationUnit(node, r);
 63     }
 64 
 65     /**
 66      * Visit Module tree.
 67      *
 68      * @param node node being visited
 69      * @param p extra parameter passed to the visitor
 70      * @return value from the visitor
 71      */
 72     @Override
 73     public R visitModule(final ModuleTree node, final P p) {
 74         node.getImportEntries().forEach(e -&gt; visitImportEntry(e, p));
 75         node.getLocalExportEntries().forEach(e -&gt; visitExportEntry(e, p));
 76         node.getIndirectExportEntries().forEach(e -&gt; visitExportEntry(e, p));
 77         node.getStarExportEntries().forEach(e -&gt; visitExportEntry(e, p));
 78         return null;
 79     }
 80 
 81     /**
 82      * Visit Module ExportEntry tree.
 83      *
 84      * @param node node being visited
 85      * @param p extra parameter passed to the visitor
 86      * @return value from the visitor
 87      */
 88     @Override
 89     public R visitExportEntry(final ExportEntryTree node, final P p) {
 90         return null;
 91     }
 92 
 93     /**
 94      * Visit Module ImportEntry tree.
 95      *
 96      * @param node node being visited
 97      * @param p extra parameter passed to the visitor
 98      * @return value from the visitor
 99      */
100     @Override
101     public R visitImportEntry(final ImportEntryTree node, final P p) {
102         return null;
103     }
104 
105    /**
106     * Visit class statement tree.
107     *
108     * @param node node being visited
109     * @param p extra parameter passed to the visitor
110     * @return value from the visitor
111     */
112     @Override
113     public R visitClassDeclaration(final ClassDeclarationTree node, final P p) {
114         node.getName().accept(this, p);
115         final ExpressionTree heritage = node.getClassHeritage();
116         if (heritage != null) {
117             heritage.accept(this, p);
118         }
119         final PropertyTree constructor = node.getConstructor();
120         if (constructor != null) {
121             constructor.accept(this, p);
122         }
123         final List&lt;? extends PropertyTree&gt; elements = node.getClassElements();
124         if (elements != null) {
125             for (final PropertyTree prop : elements) {
126                 prop.accept(this, p);
127             }
128         }
129 
130         return null;
131     }
132 
133     /**
134      * Visit class expression tree.
135      *
136      * @param node node being visited
137      * @param p extra parameter passed to the visitor
138      * @return value from the visitor
139      */
140     @Override
141     public R visitClassExpression(final ClassExpressionTree node, final P p) {
142         node.getName().accept(this, p);
143         final ExpressionTree heritage = node.getClassHeritage();
144         if (heritage != null) {
145             heritage.accept(this, p);
146         }
147         final PropertyTree constructor = node.getConstructor();
148         if (constructor != null) {
149             constructor.accept(this, p);
150         }
151         final List&lt;? extends PropertyTree&gt; elements = node.getClassElements();
152         if (elements != null) {
153             for (final PropertyTree prop : elements) {
154                 prop.accept(this, p);
155             }
156         }
157 
158         return null;
159     }
160 
161     /**
162      * Visit for..of statement tree.
163      *
164      * @param node node being visited
165      * @param p extra parameter passed to the visitor
166      * @return value from the visitor
167      */
168     @Override
169     public R visitForOfLoop(final ForOfLoopTree node, final P p) {
170         node.getVariable().accept(this, p);
171         node.getExpression().accept(this, p);
172         final StatementTree stat = node.getStatement();
173         if (stat != null) {
174             stat.accept(this, p);
175         }
176         return null;
177     }
178 
179     /**
180      * Visit &#39;yield&#39; expression tree.
181      *
182      * @param node node being visited
183      * @param p extra parameter passed to the visitor
184      * @return value from the visitor
185      */
186     @Override
187     public R visitYield(final YieldTree node, final P p) {
188         node.getExpression().accept(this, p);
189         return null;
190     }
191 
192     /**
193      * Visit &#39;spread&#39; expression tree.
194      *
195      * @param node node being visited
196      * @param p extra parameter passed to the visitor
197      * @return value from the visitor
198      */
199     @Override
200     public R visitSpread(final SpreadTree node, final P p) {
201         node.getExpression().accept(this, p);
202         return null;
203     }
204 
205    /**
206     * Visit template literal tree.
207     *
208     * @param node node being visited
209     * @param p extra parameter passed to the visitor
210     * @return value from the visitor
211     */
212     @Override
213     public R visitTemplateLiteral(final TemplateLiteralTree node, final P p) {
214         final List&lt;? extends ExpressionTree&gt; expressions = node.getExpressions();
215         for (final ExpressionTree expr : expressions) {
216             expr.accept(this, p);
217         }
218         return null;
219     }
220 
221     @Override
222     public R visitVariable(final VariableTree node, final P r) {
223         final ExpressionTree expr = node.getBinding();
224         if (expr != null) {
225             expr.accept(this, r);
226         }
227         super.visitVariable(node, r);
228         return null;
229     }
230 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/regexp/RegExpFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.runtime.regexp;
 27 
 28 import java.util.Collections;
 29 import java.util.Map;
 30 import java.util.WeakHashMap;
 31 import jdk.nashorn.internal.runtime.ParserException;
 32 import jdk.nashorn.internal.runtime.options.Options;
 33 
 34 /**
 35  * Factory class for regular expressions. This class creates instances of {@link JdkRegExp}.
 36  * An alternative factory can be installed using the {@code nashorn.regexp.impl} system property.
 37  */
 38 public class RegExpFactory {
 39 
 40     private final static RegExpFactory instance;
 41 
 42     private final static String JDK  = &quot;jdk&quot;;
 43     private final static String JONI = &quot;joni&quot;;
 44 
 45     /** Weak cache of already validated regexps - when reparsing, we don&#39;t, for example
 46      *  need to recompile (reverify) all regexps that have previously been parsed by this
 47      *  RegExpFactory in a previous compilation. This saves significant time in e.g. avatar
 48      *  startup
 49      */
 50     private static final Map&lt;String, RegExp&gt; REGEXP_CACHE =
 51             Collections.synchronizedMap(new WeakHashMap&lt;String, RegExp&gt;());
 52 
 53     static {
 54         final String impl = Options.getStringProperty(&quot;nashorn.regexp.impl&quot;, JONI);
 55         switch (impl) {
 56             case JONI:
 57                 instance = new JoniRegExp.Factory();
 58                 break;
 59             case JDK:
 60                 instance = new RegExpFactory();
 61                 break;
 62             default:
 63                 instance = null;
 64                 throw new InternalError(&quot;Unsupported RegExp factory: &quot; + impl);
 65         }
 66     }
 67 
 68     /**
 69      * Creates a Regular expression from the given {@code pattern} and {@code flags} strings.
 70      *
 71      * @param pattern RegExp pattern string
 72      * @param flags   RegExp flags string
 73      * @return new RegExp
 74      * @throws ParserException if flags is invalid or pattern string has syntax error.
 75      */
 76     public RegExp compile(final String pattern, final String flags) throws ParserException {
 77         return new JdkRegExp(pattern, flags);
 78     }
 79 
 80     /**
 81      * Compile a regexp with the given {@code source} and {@code flags}.
 82      *
 83      * @param pattern RegExp pattern string
 84      * @param flags   flag string
 85      * @return new RegExp
 86      * @throws ParserException if invalid source or flags
 87      */
 88     public static RegExp create(final String pattern, final String flags) {
 89         final String key = pattern + &quot;/&quot; + flags;
 90         RegExp regexp = REGEXP_CACHE.get(key);
 91         if (regexp == null) {
 92             regexp = instance.compile(pattern,  flags);
 93             REGEXP_CACHE.put(key, regexp);
 94         }
 95         return regexp;
 96     }
 97 
 98     /**
 99      * Validate a regexp with the given {@code source} and {@code flags}.
100      *
101      * @param pattern RegExp pattern string
102      * @param flags  flag string
103      *
104      * @throws ParserException if invalid source or flags
105      */
106     public static void validate(final String pattern, final String flags) throws ParserException {
107         create(pattern, flags);
108     }
109 
110     /**
111      * Returns true if the instance uses the JDK&#39;s {@code java.util.regex} package.
112      *
113      * @return true if instance uses JDK regex package
114      */
115     public static boolean usesJavaUtilRegex() {
116         return instance != null &amp;&amp; instance.getClass() == RegExpFactory.class;
117     }
118 }
    </pre>
  </body>
</html>
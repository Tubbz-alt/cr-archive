<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/codegen/TypeEvaluator.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.codegen;
 27 
 28 import static jdk.nashorn.internal.runtime.Property.NOT_CONFIGURABLE;
 29 import static jdk.nashorn.internal.runtime.Property.NOT_ENUMERABLE;
 30 import static jdk.nashorn.internal.runtime.Property.NOT_WRITABLE;
 31 
 32 import java.lang.invoke.MethodType;
 33 import jdk.nashorn.internal.codegen.types.Type;
 34 import jdk.nashorn.internal.ir.AccessNode;
 35 import jdk.nashorn.internal.ir.CallNode;
 36 import jdk.nashorn.internal.ir.Expression;
 37 import jdk.nashorn.internal.ir.FunctionNode;
 38 import jdk.nashorn.internal.ir.IdentNode;
 39 import jdk.nashorn.internal.ir.IndexNode;
 40 import jdk.nashorn.internal.ir.Optimistic;
 41 import jdk.nashorn.internal.objects.ArrayBufferView;
 42 import jdk.nashorn.internal.objects.NativeArray;
 43 import jdk.nashorn.internal.runtime.FindProperty;
 44 import jdk.nashorn.internal.runtime.JSType;
 45 import jdk.nashorn.internal.runtime.Property;
 46 import jdk.nashorn.internal.runtime.RecompilableScriptFunctionData;
 47 import jdk.nashorn.internal.runtime.ScriptFunction;
 48 import jdk.nashorn.internal.runtime.ScriptObject;
 49 import jdk.nashorn.internal.runtime.ScriptRuntime;
 50 
 51 /**
 52  * Functionality for using a runtime scope to look up value types.
 53  * Used during recompilation.
 54  */
 55 final class TypeEvaluator {
 56     /**
 57      * Type signature for invocation of functions without parameters: we must pass (callee, this) of type
 58      * (ScriptFunction, Object) respectively. We also use Object as the return type (we must pass something,
 59      * but it&#39;ll be ignored; it can&#39;t be void, though).
 60      */
 61     private static final MethodType EMPTY_INVOCATION_TYPE = MethodType.methodType(Object.class, ScriptFunction.class, Object.class);
 62 
 63     private final Compiler compiler;
 64     private final ScriptObject runtimeScope;
 65 
 66     TypeEvaluator(final Compiler compiler, final ScriptObject runtimeScope) {
 67         this.compiler = compiler;
 68         this.runtimeScope = runtimeScope;
 69     }
 70 
 71     /**
 72      * Returns true if the expression can be safely evaluated, and its value is an object known to always use
 73      * String as the type of its property names retrieved through
 74      * {@link ScriptRuntime#toPropertyIterator(Object)}. It is used to avoid optimistic assumptions about its
 75      * property name types.
 76      * @param expr the expression to test
 77      * @return true if the expression can be safely evaluated, and its value is an object known to always use
 78      * String as the type of its property iterators.
 79      */
 80     boolean hasStringPropertyIterator(final Expression expr) {
 81         return evaluateSafely(expr) instanceof ScriptObject;
 82     }
 83 
 84     Type getOptimisticType(final Optimistic node) {
 85         assert compiler.useOptimisticTypes();
 86 
 87         final int  programPoint = node.getProgramPoint();
 88         final Type validType    = compiler.getInvalidatedProgramPointType(programPoint);
 89 
 90         if (validType != null) {
 91             return validType;
 92         }
 93 
 94         final Type mostOptimisticType = node.getMostOptimisticType();
 95         final Type evaluatedType      = getEvaluatedType(node);
 96 
 97         if (evaluatedType != null) {
 98             if (evaluatedType.widerThan(mostOptimisticType)) {
 99                 final Type newValidType = evaluatedType.isObject() || evaluatedType.isBoolean() ? Type.OBJECT : evaluatedType;
100                 // Update invalidatedProgramPoints so we don&#39;t re-evaluate the expression next time. This is a heuristic
101                 // as we&#39;re doing a tradeoff. Re-evaluating expressions on each recompile takes time, but it might
102                 // notice a widening in the type of the expression and thus prevent an unnecessary deoptimization later.
103                 // We&#39;ll presume though that the types of expressions are mostly stable, so if we evaluated it in one
104                 // compilation, we&#39;ll keep to that and risk a low-probability deoptimization if its type gets widened
105                 // in the future.
106                 compiler.addInvalidatedProgramPoint(node.getProgramPoint(), newValidType);
107             }
108             return evaluatedType;
109         }
110         return mostOptimisticType;
111     }
112 
113     private static Type getPropertyType(final ScriptObject sobj, final String name) {
114         final FindProperty find = sobj.findProperty(name, true);
115         if (find == null) {
116             return null;
117         }
118 
119         final Property property      = find.getProperty();
120         final Class&lt;?&gt; propertyClass = property.getType();
121         if (propertyClass == null) {
122             // propertyClass == null means its value is Undefined. It is probably not initialized yet, so we won&#39;t make
123             // a type assumption yet.
124             return null;
125         } else if (propertyClass.isPrimitive()) {
126             return Type.typeFor(propertyClass);
127         }
128 
129         final ScriptObject owner = find.getOwner();
130         if (property.hasGetterFunction(owner)) {
131             // Can have side effects, so we can&#39;t safely evaluate it; since !propertyClass.isPrimitive(), it&#39;s Object.
132             return Type.OBJECT;
133         }
134 
135         // Safely evaluate the property, and return the narrowest type for the actual value (e.g. Type.INT for a boxed
136         // integer).
137         final Object value = property.needsDeclaration() ? ScriptRuntime.UNDEFINED : property.getObjectValue(owner, owner);
138         if (value == ScriptRuntime.UNDEFINED) {
139             return null;
140         }
141         return Type.typeFor(JSType.unboxedFieldType(value));
142     }
143 
144     /**
145      * Declares a symbol name as belonging to a non-scoped local variable during an on-demand compilation of a single
146      * function. This method will add an explicit Undefined binding for the local into the runtime scope if it&#39;s
147      * otherwise implicitly undefined so that when an expression is evaluated for the name, it won&#39;t accidentally find
148      * an unrelated value higher up the scope chain. It is only required to call this method when doing an optimistic
149      * on-demand compilation.
150      * @param symbolName the name of the symbol that is to be declared as being a non-scoped local variable.
151      */
152     void declareLocalSymbol(final String symbolName) {
153         assert
154             compiler.useOptimisticTypes() &amp;&amp;
155             compiler.isOnDemandCompilation() &amp;&amp;
156             runtimeScope != null :
157                 &quot;useOptimistic=&quot; +
158                     compiler.useOptimisticTypes() +
159                     &quot; isOnDemand=&quot; +
160                     compiler.isOnDemandCompilation() +
161                     &quot; scope=&quot;+runtimeScope;
162 
163         if (runtimeScope.findProperty(symbolName, false) == null) {
164             runtimeScope.addOwnProperty(symbolName, NOT_WRITABLE | NOT_ENUMERABLE | NOT_CONFIGURABLE, ScriptRuntime.UNDEFINED);
165         }
166     }
167 
168     private Object evaluateSafely(final Expression expr) {
169         if (expr instanceof IdentNode) {
170             return runtimeScope == null ? null : evaluatePropertySafely(runtimeScope, ((IdentNode)expr).getName());
171         }
172 
173         if (expr instanceof AccessNode) {
174             final AccessNode accessNode = (AccessNode)expr;
175             final Object     base       = evaluateSafely(accessNode.getBase());
176             if (!(base instanceof ScriptObject)) {
177                 return null;
178             }
179             return evaluatePropertySafely((ScriptObject)base, accessNode.getProperty());
180         }
181 
182         return null;
183     }
184 
185     private static Object evaluatePropertySafely(final ScriptObject sobj, final String name) {
186         final FindProperty find = sobj.findProperty(name, true);
187         if (find == null) {
188             return null;
189         }
190         final Property     property = find.getProperty();
191         final ScriptObject owner    = find.getOwner();
192         if (property.hasGetterFunction(owner)) {
193             // Possible side effects; can&#39;t evaluate safely
194             return null;
195         }
196         return property.getObjectValue(owner, owner);
197     }
198 
199 
200     private Type getEvaluatedType(final Optimistic expr) {
201         if (expr instanceof IdentNode) {
202             if (runtimeScope == null) {
203                 return null;
204             }
205             return getPropertyType(runtimeScope, ((IdentNode)expr).getName());
206         } else if (expr instanceof AccessNode) {
207             final AccessNode accessNode = (AccessNode)expr;
208             final Object base = evaluateSafely(accessNode.getBase());
209             if (!(base instanceof ScriptObject)) {
210                 return null;
211             }
212             return getPropertyType((ScriptObject)base, accessNode.getProperty());
213         } else if (expr instanceof IndexNode) {
214             final IndexNode indexNode = (IndexNode)expr;
215             final Object    base = evaluateSafely(indexNode.getBase());
216             if(base instanceof NativeArray || base instanceof ArrayBufferView) {
217                 // NOTE: optimistic array getters throw UnwarrantedOptimismException based on the type of their
218                 // underlying array storage, not based on values of individual elements. Thus, a LongArrayData will
219                 // throw UOE for every optimistic int linkage attempt, even if the long value being returned in the
220                 // first invocation would be representable as int. That way, we can presume that the array&#39;s optimistic
221                 // type is the most optimistic type for which an element getter has a chance of executing successfully.
222                 return ((ScriptObject)base).getArray().getOptimisticType();
223             }
224         } else if (expr instanceof CallNode) {
225             // Currently, we&#39;ll only try to guess the return type of immediately invoked function expressions with no
226             // parameters, that is (function() { ... })(). We could do better, but these are all heuristics and we can
227             // gradually introduce them as needed. An easy one would be to do the same for .call(this) idiom.
228             final CallNode callExpr = (CallNode)expr;
229             final Expression fnExpr = callExpr.getFunction();
230             // Skip evaluation if running with eager compilation as we may violate constraints in RecompilableScriptFunctionData
231             if (fnExpr instanceof FunctionNode &amp;&amp; compiler.getContext().getEnv()._lazy_compilation) {
232                 final FunctionNode fn = (FunctionNode)fnExpr;
233                 if (callExpr.getArgs().isEmpty()) {
234                     final RecompilableScriptFunctionData data = compiler.getScriptFunctionData(fn.getId());
235                     if (data != null) {
236                         final Type returnType = Type.typeFor(data.getReturnType(EMPTY_INVOCATION_TYPE, runtimeScope));
237                         if (returnType == Type.BOOLEAN) {
238                             // We don&#39;t have optimistic booleans. In fact, optimistic call sites getting back boolean
239                             // currently deoptimize all the way to Object.
240                             return Type.OBJECT;
241                         }
242                         assert returnType == Type.INT || returnType == Type.NUMBER || returnType == Type.OBJECT;
243                         return returnType;
244                     }
245                 }
246             }
247         }
248 
249         return null;
250     }
251 }
    </pre>
  </body>
</html>
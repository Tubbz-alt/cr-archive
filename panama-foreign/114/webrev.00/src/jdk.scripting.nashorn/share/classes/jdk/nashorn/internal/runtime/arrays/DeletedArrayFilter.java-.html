<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/arrays/DeletedArrayFilter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.runtime.arrays;
 27 
 28 import static jdk.nashorn.internal.runtime.ScriptRuntime.UNDEFINED;
 29 import java.lang.reflect.Array;
 30 import jdk.nashorn.internal.runtime.BitVector;
 31 
 32 /**
 33  * This filter handles the deletion of array elements.
 34  */
 35 final class DeletedArrayFilter extends ArrayFilter {
 36     /** Bit vector tracking deletions. */
 37     private final BitVector deleted;
 38 
 39     DeletedArrayFilter(final ArrayData underlying) {
 40         super(underlying);
 41         this.deleted = new BitVector(underlying.length());
 42     }
 43 
 44     @Override
 45     public ArrayData copy() {
 46         final DeletedArrayFilter copy = new DeletedArrayFilter(underlying.copy());
 47         copy.getDeleted().copy(deleted);
 48         return copy;
 49     }
 50 
 51     @Override
 52     public Object[] asObjectArray() {
 53         final Object[] value = super.asObjectArray();
 54 
 55         for (int i = 0; i &lt; value.length; i++) {
 56             if (deleted.isSet(i)) {
 57                 value[i] = UNDEFINED;
 58             }
 59         }
 60 
 61         return value;
 62     }
 63 
 64     @Override
 65     public Object asArrayOfType(final Class&lt;?&gt; componentType) {
 66         final Object value = super.asArrayOfType(componentType);
 67         final Object undefValue = convertUndefinedValue(componentType);
 68         final int l = Array.getLength(value);
 69         for (int i = 0; i &lt; l; i++) {
 70             if (deleted.isSet(i)) {
 71                 Array.set(value, i, undefValue);
 72             }
 73         }
 74 
 75         return value;
 76     }
 77 
 78     @Override
 79     public ArrayData shiftLeft(final int by) {
 80         super.shiftLeft(by);
 81         deleted.shiftLeft(by, length());
 82         return this;
 83     }
 84 
 85     @Override
 86     public ArrayData shiftRight(final int by) {
 87         super.shiftRight(by);
 88         deleted.shiftRight(by, length());
 89         return this;
 90     }
 91 
 92     @Override
 93     public ArrayData ensure(final long safeIndex) {
 94         if (safeIndex &gt;= SparseArrayData.MAX_DENSE_LENGTH &amp;&amp; safeIndex &gt;= length()) {
 95             return new SparseArrayData(this, safeIndex + 1);
 96         }
 97 
 98         super.ensure(safeIndex);
 99         deleted.resize(length());
100 
101         return this;
102     }
103 
104     @Override
105     public ArrayData shrink(final long newLength) {
106         super.shrink(newLength);
107         deleted.resize(length());
108         return this;
109     }
110 
111     @Override
112     public ArrayData set(final int index, final Object value, final boolean strict) {
113         deleted.clear(ArrayIndex.toLongIndex(index));
114         return super.set(index, value, strict);
115     }
116 
117     @Override
118     public ArrayData set(final int index, final int value, final boolean strict) {
119         deleted.clear(ArrayIndex.toLongIndex(index));
120         return super.set(index, value, strict);
121     }
122 
123     @Override
124     public ArrayData set(final int index, final double value, final boolean strict) {
125         deleted.clear(ArrayIndex.toLongIndex(index));
126         return super.set(index, value, strict);
127     }
128 
129     @Override
130     public boolean has(final int index) {
131         return super.has(index) &amp;&amp; deleted.isClear(ArrayIndex.toLongIndex(index));
132     }
133 
134     @Override
135     public ArrayData delete(final int index) {
136         final long longIndex = ArrayIndex.toLongIndex(index);
137         assert longIndex &gt;= 0 &amp;&amp; longIndex &lt; length();
138         deleted.set(longIndex);
139         underlying.setEmpty(index);
140         return this;
141     }
142 
143     @Override
144     public ArrayData delete(final long fromIndex, final long toIndex) {
145         assert fromIndex &gt;= 0 &amp;&amp; fromIndex &lt;= toIndex &amp;&amp; toIndex &lt; length();
146         deleted.setRange(fromIndex, toIndex + 1);
147         underlying.setEmpty(fromIndex, toIndex);
148         return this;
149     }
150 
151     @Override
152     public Object pop() {
153         final long index = length() - 1;
154 
155         if (super.has((int)index)) {
156             final boolean isDeleted = deleted.isSet(index);
157             final Object value = super.pop();
158 
159             return isDeleted ? UNDEFINED : value;
160         }
161 
162         return super.pop();
163     }
164 
165     @Override
166     public ArrayData slice(final long from, final long to) {
167         final ArrayData newArray = underlying.slice(from, to);
168         final DeletedArrayFilter newFilter = new DeletedArrayFilter(newArray);
169         newFilter.getDeleted().copy(deleted);
170         newFilter.getDeleted().shiftLeft(from, newFilter.length());
171 
172         return newFilter;
173     }
174 
175     private BitVector getDeleted() {
176         return deleted;
177     }
178 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/ir/LabelNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.ir;
 27 
 28 import jdk.nashorn.internal.ir.annotations.Immutable;
 29 import jdk.nashorn.internal.ir.visitor.NodeVisitor;
 30 
 31 /**
 32  * IR representation for a labeled statement. It implements JoinPredecessor to hold conversions that need to be effected
 33  * when the block exits normally, but is also targeted by a break statement that might bring different local variable
 34  * types to the join at the break point.
 35  */
 36 @Immutable
 37 public final class LabelNode extends LexicalContextStatement implements JoinPredecessor {
 38     private static final long serialVersionUID = 1L;
 39 
 40     /** Label ident. */
 41     private final String labelName;
 42 
 43     /** Statements. */
 44     private final Block body;
 45 
 46     private final LocalVariableConversion localVariableConversion;
 47 
 48     /**
 49      * Constructor
 50      *
 51      * @param lineNumber line number
 52      * @param token      token
 53      * @param finish     finish
 54      * @param labelName  label name
 55      * @param body       body of label node
 56      */
 57     public LabelNode(final int lineNumber, final long token, final int finish, final String labelName, final Block body) {
 58         super(lineNumber, token, finish);
 59 
 60         this.labelName = labelName;
 61         this.body  = body;
 62         this.localVariableConversion = null;
 63     }
 64 
 65     private LabelNode(final LabelNode labelNode, final String labelName, final Block body, final LocalVariableConversion localVariableConversion) {
 66         super(labelNode);
 67         this.labelName = labelName;
 68         this.body = body;
 69         this.localVariableConversion = localVariableConversion;
 70     }
 71 
 72     @Override
 73     public boolean isTerminal() {
 74         return body.isTerminal();
 75     }
 76 
 77     @Override
 78     public Node accept(final LexicalContext lc, final NodeVisitor&lt;? extends LexicalContext&gt; visitor) {
 79         if (visitor.enterLabelNode(this)) {
 80             return visitor.leaveLabelNode(setBody(lc, (Block)body.accept(visitor)));
 81         }
 82 
 83         return this;
 84     }
 85 
 86     @Override
 87     public void toString(final StringBuilder sb, final boolean printType) {
 88         sb.append(labelName).append(&#39;:&#39;);
 89     }
 90 
 91     /**
 92      * Get the body of the node
 93      * @return the body
 94      */
 95     public Block getBody() {
 96         return body;
 97     }
 98 
 99     /**
100      * Reset the body of the node
101      * @param lc lexical context
102      * @param body new body
103      * @return new for node if changed or existing if not
104      */
105     public LabelNode setBody(final LexicalContext lc, final Block body) {
106         if (this.body == body) {
107             return this;
108         }
109         return Node.replaceInLexicalContext(lc, this, new LabelNode(this, labelName, body, localVariableConversion));
110     }
111 
112     /**
113      * Get the label name
114      * @return the label
115      */
116     public String getLabelName() {
117         return labelName;
118     }
119 
120     @Override
121     public LocalVariableConversion getLocalVariableConversion() {
122         return localVariableConversion;
123     }
124 
125     @Override
126     public LabelNode setLocalVariableConversion(final LexicalContext lc, final LocalVariableConversion localVariableConversion) {
127         if(this.localVariableConversion == localVariableConversion) {
128             return this;
129         }
130         return Node.replaceInLexicalContext(lc, this, new LabelNode(this, labelName, body, localVariableConversion));
131     }
132 }
    </pre>
  </body>
</html>
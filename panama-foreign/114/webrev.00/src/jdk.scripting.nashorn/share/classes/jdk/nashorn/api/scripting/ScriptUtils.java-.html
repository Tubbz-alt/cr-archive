<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/api/scripting/ScriptUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.api.scripting;
 27 
 28 import java.lang.invoke.MethodHandle;
 29 import jdk.dynalink.beans.StaticClass;
 30 import jdk.dynalink.linker.LinkerServices;
 31 import jdk.nashorn.internal.runtime.Context;
 32 import jdk.nashorn.internal.runtime.ScriptFunction;
 33 import jdk.nashorn.internal.runtime.ScriptObject;
 34 import jdk.nashorn.internal.runtime.ScriptRuntime;
 35 import jdk.nashorn.internal.runtime.linker.Bootstrap;
 36 
 37 /**
 38  * Utilities that are to be called from script code.
 39  *
 40  * @deprecated Nashorn JavaScript script engine and APIs, and the jjs tool
 41  * are deprecated with the intent to remove them in a future release.
 42  *
 43  * @since 1.8u40
 44  */
 45 @Deprecated(since=&quot;11&quot;, forRemoval=true)
 46 public final class ScriptUtils {
 47     private ScriptUtils() {}
 48 
 49     /**
 50      * Returns AST as JSON compatible string. This is used to
 51      * implement &quot;parse&quot; function in resources/parse.js script.
 52      *
 53      * @param code code to be parsed
 54      * @param name name of the code source (used for location)
 55      * @param includeLoc tells whether to include location information for nodes or not
 56      * @return JSON string representation of AST of the supplied code
 57      */
 58     public static String parse(final String code, final String name, final boolean includeLoc) {
 59         return ScriptRuntime.parse(code, name, includeLoc);
 60     }
 61 
 62     /**
 63      * Method which converts javascript types to java types for the
 64      * String.format method (jrunscript function sprintf).
 65      *
 66      * @param format a format string
 67      * @param args arguments referenced by the format specifiers in format
 68      * @return a formatted string
 69      */
 70     public static String format(final String format, final Object[] args) {
 71         return Formatter.format(format, args);
 72     }
 73 
 74     /**
 75      * Create a wrapper function that calls {@code func} synchronized on {@code sync} or, if that is undefined,
 76      * {@code self}. Used to implement &quot;sync&quot; function in resources/mozilla_compat.js.
 77      *
 78      * @param func the function to wrap
 79      * @param sync the object to synchronize on
 80      * @return a synchronizing wrapper function
 81      * @throws IllegalArgumentException if func does not represent a script function
 82      */
 83     public static Object makeSynchronizedFunction(final Object func, final Object sync) {
 84         final Object unwrapped = unwrap(func);
 85         if (unwrapped instanceof ScriptFunction) {
 86             return ((ScriptFunction)unwrapped).createSynchronized(unwrap(sync));
 87         }
 88 
 89         throw new IllegalArgumentException();
 90     }
 91 
 92     /**
 93      * Make a script object mirror on given object if needed.
 94      *
 95      * @param obj object to be wrapped
 96      * @return wrapped object
 97      * @throws IllegalArgumentException if obj cannot be wrapped
 98      */
 99     public static ScriptObjectMirror wrap(final Object obj) {
100         if (obj instanceof ScriptObjectMirror) {
101             return (ScriptObjectMirror)obj;
102         }
103 
104         if (obj instanceof ScriptObject) {
105             final ScriptObject sobj = (ScriptObject)obj;
106             return (ScriptObjectMirror) ScriptObjectMirror.wrap(sobj, Context.getGlobal());
107         }
108 
109         throw new IllegalArgumentException();
110     }
111 
112     /**
113      * Unwrap a script object mirror if needed.
114      *
115      * @param obj object to be unwrapped
116      * @return unwrapped object
117      */
118     public static Object unwrap(final Object obj) {
119         if (obj instanceof ScriptObjectMirror) {
120             return ScriptObjectMirror.unwrap(obj, Context.getGlobal());
121         }
122 
123         return obj;
124     }
125 
126     /**
127      * Wrap an array of object to script object mirrors if needed.
128      *
129      * @param args array to be unwrapped
130      * @return wrapped array
131      */
132     public static Object[] wrapArray(final Object[] args) {
133         if (args == null || args.length == 0) {
134             return args;
135         }
136 
137         return ScriptObjectMirror.wrapArray(args, Context.getGlobal());
138     }
139 
140     /**
141      * Unwrap an array of script object mirrors if needed.
142      *
143      * @param args array to be unwrapped
144      * @return unwrapped array
145      */
146     public static Object[] unwrapArray(final Object[] args) {
147         if (args == null || args.length == 0) {
148             return args;
149         }
150 
151         return ScriptObjectMirror.unwrapArray(args, Context.getGlobal());
152     }
153 
154     /**
155      * Convert the given object to the given type.
156      *
157      * @param obj object to be converted
158      * @param type destination type to convert to. type is either a Class
159      * or nashorn representation of a Java type returned by Java.type() call in script.
160      * @return converted object
161      */
162     public static Object convert(final Object obj, final Object type) {
163         if (obj == null) {
164             return null;
165         }
166 
167         final Class&lt;?&gt; clazz;
168         if (type instanceof Class) {
169             clazz = (Class&lt;?&gt;)type;
170         } else if (type instanceof StaticClass) {
171             clazz = ((StaticClass)type).getRepresentedClass();
172         } else {
173             throw new IllegalArgumentException(&quot;type expected&quot;);
174         }
175 
176         final LinkerServices linker = Bootstrap.getLinkerServices();
177         final Object objToConvert = unwrap(obj);
178         final MethodHandle converter = linker.getTypeConverter(objToConvert.getClass(), clazz);
179         if (converter == null) {
180             // no supported conversion!
181             throw new UnsupportedOperationException(&quot;conversion not supported&quot;);
182         }
183 
184         try {
185             return converter.invoke(objToConvert);
186         } catch (final RuntimeException | Error e) {
187             throw e;
188         } catch (final Throwable t) {
189             throw new RuntimeException(t);
190         }
191     }
192 }
    </pre>
  </body>
</html>
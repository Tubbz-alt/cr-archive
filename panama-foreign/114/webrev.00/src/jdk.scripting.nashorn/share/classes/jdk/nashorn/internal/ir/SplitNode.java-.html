<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/ir/SplitNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.ir;
 27 
 28 import java.io.IOException;
 29 import java.io.NotSerializableException;
 30 import java.io.ObjectOutputStream;
 31 import jdk.nashorn.internal.codegen.CompileUnit;
 32 import jdk.nashorn.internal.ir.annotations.Immutable;
 33 import jdk.nashorn.internal.ir.visitor.NodeVisitor;
 34 
 35 /**
 36  * Node indicating code is split across classes.
 37  */
 38 @Immutable
 39 public class SplitNode extends LexicalContextStatement implements CompileUnitHolder {
 40     private static final long serialVersionUID = 1L;
 41 
 42     /** Split node method name. */
 43     private final String name;
 44 
 45     /** Compilation unit. */
 46     private final CompileUnit compileUnit;
 47 
 48     /** Body of split code. */
 49     private final Block body;
 50 
 51     /**
 52      * Constructor
 53      *
 54      * @param name        name of split node
 55      * @param body        body of split code
 56      * @param compileUnit compile unit to use for the body
 57      */
 58     public SplitNode(final String name, final Block body, final CompileUnit compileUnit) {
 59         super(body.getFirstStatementLineNumber(), body.getToken(), body.getFinish());
 60         this.name        = name;
 61         this.body        = body;
 62         this.compileUnit = compileUnit;
 63     }
 64 
 65     private SplitNode(final SplitNode splitNode, final Block body, final CompileUnit compileUnit) {
 66         super(splitNode);
 67         this.name        = splitNode.name;
 68         this.body        = body;
 69         this.compileUnit = compileUnit;
 70     }
 71 
 72     /**
 73      * Get the body for this split node - i.e. the actual code it encloses
 74      * @return body for split node
 75      */
 76     public Block getBody() {
 77         return body;
 78     }
 79 
 80     private SplitNode setBody(final LexicalContext lc, final Block body) {
 81         if (this.body == body) {
 82             return this;
 83         }
 84         return Node.replaceInLexicalContext(lc, this, new SplitNode(this, body, compileUnit));
 85     }
 86 
 87     @Override
 88     public Node accept(final LexicalContext lc, final NodeVisitor&lt;? extends LexicalContext&gt; visitor) {
 89         if (visitor.enterSplitNode(this)) {
 90             return visitor.leaveSplitNode(setBody(lc, (Block)body.accept(visitor)));
 91         }
 92         return this;
 93     }
 94 
 95     @Override
 96     public void toString(final StringBuilder sb, final boolean printType) {
 97         sb.append(&quot;&lt;split&gt;(&quot;);
 98         sb.append(compileUnit.getClass().getSimpleName());
 99         sb.append(&quot;) &quot;);
100         body.toString(sb, printType);
101     }
102 
103     /**
104      * Get the name for this split node
105      * @return name
106      */
107     public String getName() {
108         return name;
109     }
110 
111     /**
112      * Get the compile unit for this split node
113      * @return compile unit
114      */
115     @Override
116     public CompileUnit getCompileUnit() {
117         return compileUnit;
118     }
119 
120     /**
121      * Set the compile unit for this split node
122      * @param lc lexical context
123      * @param compileUnit compile unit
124      * @return new node if changed, otherwise same node
125      */
126     public SplitNode setCompileUnit(final LexicalContext lc, final CompileUnit compileUnit) {
127         if (this.compileUnit == compileUnit) {
128             return this;
129         }
130         return Node.replaceInLexicalContext(lc, this, new SplitNode(this, body, compileUnit));
131     }
132 
133     private void writeObject(final ObjectOutputStream out) throws IOException {
134         // We are only serializing the AST after we run SplitIntoFunctions; no SplitNodes can remain for the
135         // serialization.
136         throw new NotSerializableException(getClass().getName());
137     }
138 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/codegen/MapCreator.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.codegen;
 27 
 28 import static jdk.nashorn.internal.runtime.arrays.ArrayIndex.getArrayIndex;
 29 import static jdk.nashorn.internal.runtime.arrays.ArrayIndex.isValidArrayIndex;
 30 
 31 import java.util.ArrayList;
 32 import java.util.List;
 33 import jdk.nashorn.internal.ir.Symbol;
 34 import jdk.nashorn.internal.runtime.AccessorProperty;
 35 import jdk.nashorn.internal.runtime.Property;
 36 import jdk.nashorn.internal.runtime.PropertyMap;
 37 import jdk.nashorn.internal.runtime.ScriptObject;
 38 import jdk.nashorn.internal.runtime.SpillProperty;
 39 
 40 /**
 41  * Class that creates PropertyMap sent to script object constructors.
 42  * @param &lt;T&gt; value type for tuples, e.g. Symbol
 43  */
 44 public class MapCreator&lt;T&gt; {
 45     /** Object structure for objects associated with this map */
 46     private final Class&lt;?&gt; structure;
 47 
 48     /** key set for object map */
 49     private final List&lt;MapTuple&lt;T&gt;&gt; tuples;
 50 
 51     /**
 52      * Constructor
 53      *
 54      * @param structure structure to generate map for (a JO subclass)
 55      * @param tuples    list of tuples for map
 56      */
 57     MapCreator(final Class&lt;? extends ScriptObject&gt; structure, final List&lt;MapTuple&lt;T&gt;&gt; tuples) {
 58         this.structure = structure;
 59         this.tuples    = tuples;
 60     }
 61 
 62     /**
 63      * Constructs a property map based on a set of fields.
 64      *
 65      * @param hasArguments  does the created object have an &quot;arguments&quot; property
 66      * @param fieldCount    Number of fields in use.
 67      * @param fieldMaximum  Number of fields available.
 68      * @param evalCode      is this property map created for &#39;eval&#39; code?
 69      * @return New map populated with accessor properties.
 70      */
 71     PropertyMap makeFieldMap(final boolean hasArguments, final boolean dualFields, final int fieldCount, final int fieldMaximum, final boolean evalCode) {
 72         final List&lt;Property&gt; properties = new ArrayList&lt;&gt;();
 73         assert tuples != null;
 74 
 75         for (final MapTuple&lt;T&gt; tuple : tuples) {
 76             final String   key         = tuple.key;
 77             final Symbol   symbol      = tuple.symbol;
 78             final Class&lt;?&gt; initialType = dualFields ? tuple.getValueType() : Object.class;
 79 
 80             if (symbol != null &amp;&amp; !isValidArrayIndex(getArrayIndex(key))) {
 81                 final int      flags    = getPropertyFlags(symbol, hasArguments, evalCode, dualFields);
 82                 final Property property = new AccessorProperty(
 83                         key,
 84                         flags,
 85                         structure,
 86                         symbol.getFieldIndex(),
 87                         initialType);
 88                 properties.add(property);
 89             }
 90         }
 91 
 92         return PropertyMap.newMap(properties, structure.getName(), fieldCount, fieldMaximum, 0);
 93     }
 94 
 95     PropertyMap makeSpillMap(final boolean hasArguments, final boolean dualFields) {
 96         final List&lt;Property&gt; properties = new ArrayList&lt;&gt;();
 97         int spillIndex = 0;
 98         assert tuples != null;
 99 
100         for (final MapTuple&lt;T&gt; tuple : tuples) {
101             final String key    = tuple.key;
102             final Symbol symbol = tuple.symbol;
103             final Class&lt;?&gt; initialType = dualFields ? tuple.getValueType() : Object.class;
104 
105             if (symbol != null &amp;&amp; !isValidArrayIndex(getArrayIndex(key))) {
106                 final int flags = getPropertyFlags(symbol, hasArguments, false, dualFields);
107                 properties.add(
108                         new SpillProperty(
109                                 key,
110                                 flags,
111                                 spillIndex++,
112                                 initialType));
113             }
114         }
115 
116         return PropertyMap.newMap(properties, structure.getName(), 0, 0, spillIndex);
117     }
118 
119     /**
120      * Compute property flags given local state of a field. May be overridden and extended,
121      *
122      * @param symbol       symbol to check
123      * @param hasArguments does the created object have an &quot;arguments&quot; property
124      *
125      * @return flags to use for fields
126      */
127     static int getPropertyFlags(final Symbol symbol, final boolean hasArguments, final boolean evalCode, final boolean dualFields) {
128         int flags = 0;
129 
130         if (symbol.isParam()) {
131             flags |= Property.IS_PARAMETER;
132         }
133 
134         if (hasArguments) {
135             flags |= Property.HAS_ARGUMENTS;
136         }
137 
138         // See ECMA 5.1 10.5 Declaration Binding Instantiation.
139         // Step 2  If code is eval code, then let configurableBindings
140         // be true else let configurableBindings be false.
141         // We have to make vars, functions declared in &#39;eval&#39; code
142         // configurable. But vars, functions from any other code is
143         // not configurable.
144         if (symbol.isScope() &amp;&amp; !evalCode) {
145             flags |= Property.NOT_CONFIGURABLE;
146         }
147 
148         if (symbol.isFunctionDeclaration()) {
149             flags |= Property.IS_FUNCTION_DECLARATION;
150         }
151 
152         if (symbol.isConst()) {
153             flags |= Property.NOT_WRITABLE;
154         }
155 
156         if (symbol.isBlockScoped()) {
157             flags |= Property.IS_LEXICAL_BINDING;
158         }
159 
160         // Mark symbol as needing declaration. Access before declaration will throw a ReferenceError.
161         if (symbol.isBlockScoped() &amp;&amp; symbol.isScope()) {
162             flags |= Property.NEEDS_DECLARATION;
163         }
164 
165         if (dualFields) {
166             flags |= Property.DUAL_FIELDS;
167         }
168 
169         return flags;
170     }
171 }
    </pre>
  </body>
</html>
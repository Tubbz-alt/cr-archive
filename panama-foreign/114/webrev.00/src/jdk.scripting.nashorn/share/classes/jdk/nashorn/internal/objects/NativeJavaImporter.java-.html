<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/objects/NativeJavaImporter.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.objects;
 27 
 28 import jdk.dynalink.beans.StaticClass;
 29 import jdk.nashorn.internal.objects.annotations.Constructor;
 30 import jdk.nashorn.internal.objects.annotations.ScriptClass;
 31 import jdk.nashorn.internal.runtime.Context;
 32 import jdk.nashorn.internal.runtime.FindProperty;
 33 import jdk.nashorn.internal.runtime.NativeJavaPackage;
 34 import jdk.nashorn.internal.runtime.PropertyMap;
 35 import jdk.nashorn.internal.runtime.ScriptObject;
 36 
 37 /**
 38  * This is &quot;JavaImporter&quot; constructor. This constructor allows you to use Java types omitting explicit package names.
 39  * Objects of this constructor are used along with {@code &quot;with&quot;} statements and as such are not usable in ECMAScript
 40  * strict mode. Example:
 41  * &lt;pre&gt;
 42  *     var imports = new JavaImporter(java.util, java.io);
 43  *     with (imports) {
 44  *         var m = new HashMap(); // java.util.HashMap
 45  *         var f = new File(&quot;.&quot;); // java.io.File
 46  *         ...
 47  *     }
 48  * &lt;/pre&gt;
 49  * Note however that the preferred way for accessing Java types in Nashorn is through the use of
 50  * {@link NativeJava#type(Object, Object) Java.type()} method.
 51  */
 52 @ScriptClass(&quot;JavaImporter&quot;)
 53 public final class NativeJavaImporter extends ScriptObject {
 54     private final Object[] args;
 55 
 56     // initialized by nasgen
 57     private static PropertyMap $nasgenmap$;
 58 
 59     private NativeJavaImporter(final Object[] args, final ScriptObject proto, final PropertyMap map) {
 60         super(proto, map);
 61         this.args = args;
 62     }
 63 
 64     private NativeJavaImporter(final Object[] args, final Global global) {
 65         this(args, global.getJavaImporterPrototype(), $nasgenmap$);
 66     }
 67 
 68     private NativeJavaImporter(final Object[] args) {
 69         this(args, Global.instance());
 70     }
 71 
 72     @Override
 73     public String getClassName() {
 74         return &quot;JavaImporter&quot;;
 75     }
 76 
 77     /**
 78      * Constructor
 79      * @param isNew is the new operator used for instantiating this NativeJavaImporter
 80      * @param self self reference
 81      * @param args arguments
 82      * @return NativeJavaImporter instance
 83      */
 84     @Constructor(arity = 1)
 85     public static NativeJavaImporter constructor(final boolean isNew, final Object self, final Object... args) {
 86         return new NativeJavaImporter(args);
 87     }
 88 
 89     @Override
 90     protected FindProperty findProperty(final Object key, final boolean deep, final boolean isScope, final ScriptObject start) {
 91         final FindProperty find = super.findProperty(key, deep, isScope, start);
 92         if (find == null &amp;&amp; key instanceof String) {
 93             final String name = (String) key;
 94             final Object value = createProperty(name);
 95             if(value != null) {
 96                 // We must avoid calling findProperty recursively, so we pass null as first argument
 97                 setObject(null, 0, key, value);
 98                 return super.findProperty(key, deep, isScope, start);
 99             }
100         }
101         return find;
102     }
103 
104     private Object createProperty(final String name) {
105         final int len = args.length;
106 
107         for (int i = len - 1; i &gt; -1; i--) {
108             final Object obj = args[i];
109 
110             if (obj instanceof StaticClass) {
111                 if (((StaticClass)obj).getRepresentedClass().getSimpleName().equals(name)) {
112                     return obj;
113                 }
114             } else if (obj instanceof NativeJavaPackage) {
115                 final String pkgName  = ((NativeJavaPackage)obj).getName();
116                 final String fullName = pkgName.isEmpty() ? name : (pkgName + &quot;.&quot; + name);
117                 final Context context = Global.instance().getContext();
118                 try {
119                     return StaticClass.forClass(context.findClass(fullName));
120                 } catch (final ClassNotFoundException e) {
121                     // IGNORE
122                 }
123             }
124         }
125         return null;
126     }
127 }
    </pre>
  </body>
</html>
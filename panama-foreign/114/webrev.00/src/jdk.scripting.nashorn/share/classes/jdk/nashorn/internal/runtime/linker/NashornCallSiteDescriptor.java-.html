<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/linker/NashornCallSiteDescriptor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.runtime.linker;
 27 
 28 import static jdk.dynalink.StandardNamespace.ELEMENT;
 29 import static jdk.dynalink.StandardNamespace.METHOD;
 30 import static jdk.dynalink.StandardNamespace.PROPERTY;
 31 import static jdk.dynalink.StandardOperation.GET;
 32 import static jdk.dynalink.StandardOperation.REMOVE;
 33 import static jdk.dynalink.StandardOperation.SET;
 34 
 35 import java.lang.invoke.MethodHandles;
 36 import java.lang.invoke.MethodHandles.Lookup;
 37 import java.lang.invoke.MethodType;
 38 import java.lang.ref.Reference;
 39 import java.lang.ref.WeakReference;
 40 import java.security.AccessControlContext;
 41 import java.security.AccessController;
 42 import java.security.PrivilegedAction;
 43 import java.util.Collections;
 44 import java.util.Map;
 45 import java.util.WeakHashMap;
 46 import java.util.concurrent.ConcurrentHashMap;
 47 import java.util.concurrent.ConcurrentMap;
 48 import java.util.stream.Stream;
 49 import jdk.dynalink.CallSiteDescriptor;
 50 import jdk.dynalink.NamedOperation;
 51 import jdk.dynalink.NamespaceOperation;
 52 import jdk.dynalink.Operation;
 53 import jdk.dynalink.SecureLookupSupplier;
 54 import jdk.dynalink.StandardNamespace;
 55 import jdk.dynalink.StandardOperation;
 56 import jdk.nashorn.internal.ir.debug.NashornTextifier;
 57 import jdk.nashorn.internal.runtime.AccessControlContextFactory;
 58 import jdk.nashorn.internal.runtime.ScriptRuntime;
 59 
 60 /**
 61  * Nashorn-specific implementation of Dynalink&#39;s {@link CallSiteDescriptor}.
 62  * The reason we have our own subclass is that we&#39;re storing flags in an
 63  * additional primitive field. The class also exposes some useful utilities in
 64  * form of static methods.
 65  */
 66 public final class NashornCallSiteDescriptor extends CallSiteDescriptor {
 67     // Lowest four bits describe the operation
 68     /** Property getter operation {@code obj.prop} */
 69     public static final int GET_PROPERTY        = 0;
 70     /** Element getter operation {@code obj[index]} */
 71     public static final int GET_ELEMENT         = 1;
 72     /** Property getter operation, subsequently invoked {@code obj.prop()} */
 73     public static final int GET_METHOD_PROPERTY = 2;
 74     /** Element getter operation, subsequently invoked {@code obj[index]()} */
 75     public static final int GET_METHOD_ELEMENT  = 3;
 76     /** Property setter operation {@code obj.prop = value} */
 77     public static final int SET_PROPERTY        = 4;
 78     /** Element setter operation {@code obj[index] = value} */
 79     public static final int SET_ELEMENT         = 5;
 80     /** Property remove operation {@code delete obj.prop} */
 81     public static final int REMOVE_PROPERTY     = 6;
 82     /** Element remove operation {@code delete obj[index]} */
 83     public static final int REMOVE_ELEMENT      = 7;
 84     /** Call operation {@code fn(args...)} */
 85     public static final int CALL                = 8;
 86     /** New operation {@code new Constructor(args...)} */
 87     public static final int NEW                 = 9;
 88 
 89     private static final int OPERATION_MASK = 15;
 90 
 91     // Correspond to the operation indices above.
 92     private static final Operation[] OPERATIONS = new Operation[] {
 93         GET.withNamespaces(PROPERTY, ELEMENT, METHOD),
 94         GET.withNamespaces(ELEMENT, PROPERTY, METHOD),
 95         GET.withNamespaces(METHOD, PROPERTY, ELEMENT),
 96         GET.withNamespaces(METHOD, ELEMENT, PROPERTY),
 97         SET.withNamespaces(PROPERTY, ELEMENT),
 98         SET.withNamespaces(ELEMENT, PROPERTY),
 99         REMOVE.withNamespaces(PROPERTY, ELEMENT),
100         REMOVE.withNamespaces(ELEMENT, PROPERTY),
101         StandardOperation.CALL,
102         StandardOperation.NEW
103     };
104 
105     /** Flags that the call site references a scope variable (it&#39;s an identifier reference or a var declaration, not a
106      * property access expression. */
107     public static final int CALLSITE_SCOPE         = 1 &lt;&lt; 4;
108     /** Flags that the call site is in code that uses ECMAScript strict mode. */
109     public static final int CALLSITE_STRICT        = 1 &lt;&lt; 5;
110     /** Flags that a property getter or setter call site references a scope variable that is located at a known distance
111      * in the scope chain. Such getters and setters can often be linked more optimally using these assumptions. */
112     public static final int CALLSITE_FAST_SCOPE    = 1 &lt;&lt; 6;
113     /** Flags that a callsite type is optimistic, i.e. we might get back a wider return value than encoded in the
114      * descriptor, and in that case we have to throw an UnwarrantedOptimismException */
115     public static final int CALLSITE_OPTIMISTIC    = 1 &lt;&lt; 7;
116     /** Is this really an apply that we try to call as a call? */
117     public static final int CALLSITE_APPLY_TO_CALL = 1 &lt;&lt; 8;
118     /** Does this a callsite for a variable declaration? */
119     public static final int CALLSITE_DECLARE       = 1 &lt;&lt; 9;
120 
121     /** Flags that the call site is profiled; Contexts that have {@code &quot;profile.callsites&quot;} boolean property set emit
122      * code where call sites have this flag set. */
123     public static final int CALLSITE_PROFILE         = 1 &lt;&lt; 10;
124     /** Flags that the call site is traced; Contexts that have {@code &quot;trace.callsites&quot;} property set emit code where
125      * call sites have this flag set. */
126     public static final int CALLSITE_TRACE           = 1 &lt;&lt; 11;
127     /** Flags that the call site linkage miss (and thus, relinking) is traced; Contexts that have the keyword
128      * {@code &quot;miss&quot;} in their {@code &quot;trace.callsites&quot;} property emit code where call sites have this flag set. */
129     public static final int CALLSITE_TRACE_MISSES    = 1 &lt;&lt; 12;
130     /** Flags that entry/exit to/from the method linked at call site are traced; Contexts that have the keyword
131      * {@code &quot;enterexit&quot;} in their {@code &quot;trace.callsites&quot;} property emit code where call sites have this flag set. */
132     public static final int CALLSITE_TRACE_ENTEREXIT = 1 &lt;&lt; 13;
133     /** Flags that values passed as arguments to and returned from the method linked at call site are traced; Contexts
134      * that have the keyword {@code &quot;values&quot;} in their {@code &quot;trace.callsites&quot;} property emit code where call sites
135      * have this flag set. */
136     public static final int CALLSITE_TRACE_VALUES    = 1 &lt;&lt; 14;
137 
138     //we could have more tracing flags here, for example CALLSITE_TRACE_SCOPE, but bits are a bit precious
139     //right now given the program points
140 
141     /**
142      * Number of bits the program point is shifted to the left in the flags (lowest bit containing a program point).
143      * Always one larger than the largest flag shift. Note that introducing a new flag halves the number of program
144      * points we can have.
145      * TODO: rethink if we need the various profile/trace flags or the linker can use the Context instead to query its
146      * trace/profile settings.
147      */
148     public static final int CALLSITE_PROGRAM_POINT_SHIFT = 15;
149 
150     /**
151      * Maximum program point value. We have 17 bits left over after flags, and
152      * it should be plenty. Program points are local to a single function. Every
153      * function maps to a single JVM bytecode method that can have at most 65535
154      * bytes. (Large functions are synthetically split into smaller functions.)
155      * A single invokedynamic is 5 bytes; even if a method consists of only
156      * invokedynamic instructions that leaves us with at most 65535/5 = 13107
157      * program points for the largest single method; those can be expressed on
158      * 14 bits. It is true that numbering of program points is independent of
159      * bytecode representation, but if a function would need more than ~14 bits
160      * for the program points, then it is reasonable to presume splitter
161      * would&#39;ve split it into several smaller functions already.
162      */
163     public static final int MAX_PROGRAM_POINT_VALUE = (1 &lt;&lt; 32 - CALLSITE_PROGRAM_POINT_SHIFT) - 1;
164 
165     /**
166      * Flag mask to get the program point flags
167      */
168     public static final int FLAGS_MASK = (1 &lt;&lt; CALLSITE_PROGRAM_POINT_SHIFT) - 1;
169 
170     private static final ClassValue&lt;ConcurrentMap&lt;NashornCallSiteDescriptor, NashornCallSiteDescriptor&gt;&gt; canonicals =
171             new ClassValue&lt;ConcurrentMap&lt;NashornCallSiteDescriptor,NashornCallSiteDescriptor&gt;&gt;() {
172         @Override
173         protected ConcurrentMap&lt;NashornCallSiteDescriptor, NashornCallSiteDescriptor&gt; computeValue(final Class&lt;?&gt; type) {
174             return new ConcurrentHashMap&lt;&gt;();
175         }
176     };
177 
178     private static final AccessControlContext GET_LOOKUP_PERMISSION_CONTEXT =
179             AccessControlContextFactory.createAccessControlContext(SecureLookupSupplier.GET_LOOKUP_PERMISSION_NAME);
180 
181     @SuppressWarnings(&quot;unchecked&quot;)
182     private static final Map&lt;String, Reference&lt;NamedOperation&gt;&gt;[] NAMED_OPERATIONS =
183             Stream.generate(() -&gt; Collections.synchronizedMap(new WeakHashMap&lt;&gt;()))
184             .limit(OPERATIONS.length).toArray(Map[]::new);
185 
186     private final int flags;
187 
188     /**
189      * Function used by {@link NashornTextifier} to represent call site flags in
190      * human readable form
191      * @param flags call site flags
192      * @param sb the string builder
193      */
194     public static void appendFlags(final int flags, final StringBuilder sb) {
195         final int pp = flags &gt;&gt; CALLSITE_PROGRAM_POINT_SHIFT;
196         if (pp != 0) {
197             sb.append(&quot; pp=&quot;).append(pp);
198         }
199         if ((flags &amp; CALLSITE_SCOPE) != 0) {
200             if ((flags &amp; CALLSITE_FAST_SCOPE) != 0) {
201                 sb.append(&quot; fastscope&quot;);
202             } else {
203                 sb.append(&quot; scope&quot;);
204             }
205             if ((flags &amp; CALLSITE_DECLARE) != 0) {
206                 sb.append(&quot; declare&quot;);
207             }
208         } else {
209             assert (flags &amp; CALLSITE_FAST_SCOPE) == 0 : &quot;can&#39;t be fastscope without scope&quot;;
210         }
211         if ((flags &amp; CALLSITE_APPLY_TO_CALL) != 0) {
212             sb.append(&quot; apply2call&quot;);
213         }
214         if ((flags &amp; CALLSITE_STRICT) != 0) {
215             sb.append(&quot; strict&quot;);
216         }
217     }
218 
219     /**
220      * Given call site flags, returns the operation name encoded in them.
221      * @param flags flags
222      * @return the operation name
223      */
224     public static String getOperationName(final int flags) {
225         switch(flags &amp; OPERATION_MASK) {
226         case 0: return &quot;GET_PROPERTY&quot;;
227         case 1: return &quot;GET_ELEMENT&quot;;
228         case 2: return &quot;GET_METHOD_PROPERTY&quot;;
229         case 3: return &quot;GET_METHOD_ELEMENT&quot;;
230         case 4: return &quot;SET_PROPERTY&quot;;
231         case 5: return &quot;SET_ELEMENT&quot;;
232         case 6: return &quot;REMOVE_PROPERTY&quot;;
233         case 7: return &quot;REMOVE_ELEMENT&quot;;
234         case 8: return &quot;CALL&quot;;
235         case 9: return &quot;NEW&quot;;
236         default: throw new AssertionError();
237         }
238     }
239 
240     /**
241      * Retrieves a Nashorn call site descriptor with the specified values. Since call site descriptors are immutable
242      * this method is at liberty to retrieve canonicalized instances (although it is not guaranteed it will do so).
243      * @param lookup the lookup describing the script
244      * @param name the name at the call site. Can not be null, but it can be empty.
245      * @param methodType the method type at the call site
246      * @param flags Nashorn-specific call site flags
247      * @return a call site descriptor with the specified values.
248      */
249     public static NashornCallSiteDescriptor get(final MethodHandles.Lookup lookup, final String name,
250             final MethodType methodType, final int flags) {
251         final int opIndex = flags &amp; OPERATION_MASK;
252         final Operation baseOp = OPERATIONS[opIndex];
253         final String decodedName = NameCodec.decode(name);
254         final Operation op = decodedName.isEmpty() ? baseOp : getNamedOperation(decodedName, opIndex, baseOp);
255         return get(lookup, op, methodType, flags);
256     }
257 
258     private static NamedOperation getNamedOperation(final String name, final int opIndex, final Operation baseOp) {
259         final Map&lt;String, Reference&lt;NamedOperation&gt;&gt; namedOps = NAMED_OPERATIONS[opIndex];
260         final Reference&lt;NamedOperation&gt; ref = namedOps.get(name);
261         if (ref != null) {
262             final NamedOperation existing = ref.get();
263             if (existing != null) {
264                 return existing;
265             }
266         }
267         final NamedOperation newOp = baseOp.named(name);
268         namedOps.put(name, new WeakReference&lt;&gt;(newOp));
269         return newOp;
270     }
271 
272     private static NashornCallSiteDescriptor get(final MethodHandles.Lookup lookup, final Operation operation, final MethodType methodType, final int flags) {
273         final NashornCallSiteDescriptor csd = new NashornCallSiteDescriptor(lookup, operation, methodType, flags);
274         // Many of these call site descriptors are identical (e.g. every getter for a property color will be
275         // &quot;GET_PROPERTY:color(Object)Object&quot;, so it makes sense canonicalizing them. Make an exception for
276         // optimistic call site descriptors, as they also carry a program point making them unique.
277         if (csd.isOptimistic()) {
278             return csd;
279         }
280         final NashornCallSiteDescriptor canonical = canonicals.get(lookup.lookupClass()).putIfAbsent(csd, csd);
281         return canonical != null ? canonical : csd;
282     }
283 
284     private NashornCallSiteDescriptor(final MethodHandles.Lookup lookup, final Operation operation, final MethodType methodType, final int flags) {
285         super(lookup, operation, methodType);
286         this.flags = flags;
287     }
288 
289     static Lookup getLookupInternal(final CallSiteDescriptor csd) {
290         if (csd instanceof NashornCallSiteDescriptor) {
291             return ((NashornCallSiteDescriptor)csd).getLookupPrivileged();
292         }
293         return AccessController.doPrivileged((PrivilegedAction&lt;Lookup&gt;)()-&gt;csd.getLookup(), GET_LOOKUP_PERMISSION_CONTEXT);
294     }
295 
296     @Override
297     public boolean equals(final Object obj) {
298         return super.equals(obj) &amp;&amp; flags == ((NashornCallSiteDescriptor)obj).flags;
299     }
300 
301     @Override
302     public int hashCode() {
303         return super.hashCode() ^ flags;
304     }
305 
306     /**
307      * Returns the named operand in the passed descriptor&#39;s operation.
308      * Equivalent to
309      * {@code ((NamedOperation)desc.getOperation()).getName().toString()} for
310      * descriptors with a named operand. For descriptors without named operands
311      * returns null.
312      * @param desc the call site descriptors
313      * @return the named operand in this descriptor&#39;s operation.
314      */
315     public static String getOperand(final CallSiteDescriptor desc) {
316         final Operation operation = desc.getOperation();
317         return operation instanceof NamedOperation ? ((NamedOperation)operation).getName().toString() : null;
318     }
319 
320     private static StandardNamespace findFirstStandardNamespace(final CallSiteDescriptor desc) {
321         return StandardNamespace.findFirst(desc.getOperation());
322     }
323 
324     /**
325      * Returns true if the operation of the call descriptor is operating on the method namespace first.
326      * @param desc the call descriptor in question.
327      * @return true if the operation of the call descriptor is operating on the method namespace first.
328      */
329     public static boolean isMethodFirstOperation(final CallSiteDescriptor desc) {
330         return findFirstStandardNamespace(desc) == StandardNamespace.METHOD;
331     }
332 
333     /**
334      * Returns true if there&#39;s a namespace operation in the call descriptor and it is operating on at least
335      * one {@link StandardNamespace}. This method is only needed for exported linkers, since internal linkers
336      * always operate on Nashorn-generated call sites, and they always operate on standard namespaces only.
337      * @param desc the call descriptor in question.
338      * @return true if the operation of the call descriptor is operating on at least one standard namespace.
339      */
340     public static boolean hasStandardNamespace(final CallSiteDescriptor desc) {
341         return findFirstStandardNamespace(desc) != null;
342     }
343 
344     /**
345      * Returns the base operation in this call site descriptor after unwrapping it from both a named operation
346      * and a namespace operation.
347      * @param desc the call site descriptor.
348      * @return the base operation in this call site descriptor.
349      */
350     public static Operation getBaseOperation(final CallSiteDescriptor desc) {
351         return NamespaceOperation.getBaseOperation(NamedOperation.getBaseOperation(desc.getOperation()));
352     }
353 
354     /**
355      * Returns the standard operation that is the base operation in this call site descriptor.
356      * @param desc the call site descriptor.
357      * @return the standard operation that is the base operation in this call site descriptor.
358      * @throws ClassCastException if the base operation is not a standard operation. This method is only
359      * safe to use when the base operation is known to be a standard operation (e.g. all Nashorn call sites
360      * are such, so it&#39;s safe to use from internal linkers).
361      */
362     public static StandardOperation getStandardOperation(final CallSiteDescriptor desc) {
363         return (StandardOperation)getBaseOperation(desc);
364     }
365 
366     /**
367      * Returns true if the passed call site descriptor contains the specified standard operation on the
368      * specified standard namespace.
369      * @param desc the call site descriptor.
370      * @param operation the operation whose presence is tested.
371      * @param namespace the namespace on which the operation operates.
372      * @return Returns true if the call site descriptor contains the specified standard operation on the
373      * specified standard namespace.
374      */
375     public static boolean contains(final CallSiteDescriptor desc, final StandardOperation operation, final StandardNamespace namespace) {
376         return NamespaceOperation.contains(NamedOperation.getBaseOperation(desc.getOperation()), operation, namespace);
377     }
378 
379     /**
380      * Returns the error message to be used when CALL or NEW is used on a non-function.
381      *
382      * @param obj object on which CALL or NEW is used
383      * @return error message
384      */
385     private String getFunctionErrorMessage(final Object obj) {
386         final String funcDesc = getOperand(this);
387         return funcDesc != null? funcDesc : ScriptRuntime.safeToString(obj);
388     }
389 
390     /**
391      * Returns the error message to be used when CALL or NEW is used on a non-function.
392      *
393      * @param desc call site descriptor
394      * @param obj object on which CALL or NEW is used
395      * @return error message
396      */
397     public static String getFunctionErrorMessage(final CallSiteDescriptor desc, final Object obj) {
398         return desc instanceof NashornCallSiteDescriptor ?
399                 ((NashornCallSiteDescriptor)desc).getFunctionErrorMessage(obj) :
400                 ScriptRuntime.safeToString(obj);
401     }
402 
403     /**
404      * Returns the Nashorn-specific flags for this call site descriptor.
405      * @param desc the descriptor. It can be any kind of a call site descriptor, not necessarily a
406      * {@code NashornCallSiteDescriptor}. This allows for graceful interoperability when linking Nashorn with code
407      * generated outside of Nashorn.
408      * @return the Nashorn-specific flags for the call site, or 0 if the passed descriptor is not a Nashorn call site
409      * descriptor.
410      */
411     public static int getFlags(final CallSiteDescriptor desc) {
412         return desc instanceof NashornCallSiteDescriptor ? ((NashornCallSiteDescriptor)desc).flags : 0;
413     }
414 
415     /**
416      * Returns true if this descriptor has the specified flag set, see {@code CALLSITE_*} constants in this class.
417      * @param flag the tested flag
418      * @return true if the flag is set, false otherwise
419      */
420     private boolean isFlag(final int flag) {
421         return (flags &amp; flag) != 0;
422     }
423 
424     /**
425      * Returns true if this descriptor has the specified flag set, see {@code CALLSITE_*} constants in this class.
426      * @param desc the descriptor. It can be any kind of a call site descriptor, not necessarily a
427      * {@code NashornCallSiteDescriptor}. This allows for graceful interoperability when linking Nashorn with code
428      * generated outside of Nashorn.
429      * @param flag the tested flag
430      * @return true if the flag is set, false otherwise (it will be false if the descriptor is not a Nashorn call site
431      * descriptor).
432      */
433     private static boolean isFlag(final CallSiteDescriptor desc, final int flag) {
434         return (getFlags(desc) &amp; flag) != 0;
435     }
436 
437     /**
438      * Returns true if this descriptor is a Nashorn call site descriptor and has the {@link  #CALLSITE_SCOPE} flag set.
439      * @param desc the descriptor. It can be any kind of a call site descriptor, not necessarily a
440      * {@code NashornCallSiteDescriptor}. This allows for graceful interoperability when linking Nashorn with code
441      * generated outside of Nashorn.
442      * @return true if the descriptor is a Nashorn call site descriptor, and the flag is set, false otherwise.
443      */
444     public static boolean isScope(final CallSiteDescriptor desc) {
445         return isFlag(desc, CALLSITE_SCOPE);
446     }
447 
448     /**
449      * Returns true if this descriptor is a Nashorn call site descriptor and has the {@link  #CALLSITE_FAST_SCOPE} flag set.
450      * @param desc the descriptor. It can be any kind of a call site descriptor, not necessarily a
451      * {@code NashornCallSiteDescriptor}. This allows for graceful interoperability when linking Nashorn with code
452      * generated outside of Nashorn.
453      * @return true if the descriptor is a Nashorn call site descriptor, and the flag is set, false otherwise.
454      */
455     public static boolean isFastScope(final CallSiteDescriptor desc) {
456         return isFlag(desc, CALLSITE_FAST_SCOPE);
457     }
458 
459     /**
460      * Returns true if this descriptor is a Nashorn call site descriptor and has the {@link  #CALLSITE_STRICT} flag set.
461      * @param desc the descriptor. It can be any kind of a call site descriptor, not necessarily a
462      * {@code NashornCallSiteDescriptor}. This allows for graceful interoperability when linking Nashorn with code
463      * generated outside of Nashorn.
464      * @return true if the descriptor is a Nashorn call site descriptor, and the flag is set, false otherwise.
465      */
466     public static boolean isStrict(final CallSiteDescriptor desc) {
467         return isFlag(desc, CALLSITE_STRICT);
468     }
469 
470     /**
471      * Returns true if this is an apply call that we try to call as
472      * a &quot;call&quot;
473      * @param desc descriptor
474      * @return true if apply to call
475      */
476     public static boolean isApplyToCall(final CallSiteDescriptor desc) {
477         return isFlag(desc, CALLSITE_APPLY_TO_CALL);
478     }
479 
480     /**
481      * Is this an optimistic call site
482      * @param desc descriptor
483      * @return true if optimistic
484      */
485     public static boolean isOptimistic(final CallSiteDescriptor desc) {
486         return isFlag(desc, CALLSITE_OPTIMISTIC);
487     }
488 
489     /**
490      * Does this callsite contain a declaration for its target?
491      * @param desc descriptor
492      * @return true if contains declaration
493      */
494     public static boolean isDeclaration(final CallSiteDescriptor desc) {
495         return isFlag(desc, CALLSITE_DECLARE);
496     }
497 
498     /**
499      * Returns true if {@code flags} has the {@link  #CALLSITE_STRICT} bit set.
500      * @param flags the flags
501      * @return true if the flag is set, false otherwise.
502      */
503     public static boolean isStrictFlag(final int flags) {
504         return (flags &amp; CALLSITE_STRICT) != 0;
505     }
506 
507     /**
508      * Returns true if {@code flags} has the {@link  #CALLSITE_SCOPE} bit set.
509      * @param flags the flags
510      * @return true if the flag is set, false otherwise.
511      */
512     public static boolean isScopeFlag(final int flags) {
513         return (flags &amp; CALLSITE_SCOPE) != 0;
514     }
515 
516     /**
517      * Returns true if {@code flags} has the {@link  #CALLSITE_DECLARE} bit set.
518      * @param flags the flags
519      * @return true if the flag is set, false otherwise.
520      */
521     public static boolean isDeclaration(final int flags) {
522         return (flags &amp; CALLSITE_DECLARE) != 0;
523     }
524 
525     /**
526      * Get a program point from a descriptor (must be optimistic)
527      * @param desc descriptor
528      * @return program point
529      */
530     public static int getProgramPoint(final CallSiteDescriptor desc) {
531         assert isOptimistic(desc) : &quot;program point requested from non-optimistic descriptor &quot; + desc;
532         return getFlags(desc) &gt;&gt; CALLSITE_PROGRAM_POINT_SHIFT;
533     }
534 
535     boolean isProfile() {
536         return isFlag(CALLSITE_PROFILE);
537     }
538 
539     boolean isTrace() {
540         return isFlag(CALLSITE_TRACE);
541     }
542 
543     boolean isTraceMisses() {
544         return isFlag(CALLSITE_TRACE_MISSES);
545     }
546 
547     boolean isTraceEnterExit() {
548         return isFlag(CALLSITE_TRACE_ENTEREXIT);
549     }
550 
551     boolean isTraceObjects() {
552         return isFlag(CALLSITE_TRACE_VALUES);
553     }
554 
555     boolean isOptimistic() {
556         return isFlag(CALLSITE_OPTIMISTIC);
557     }
558 
559     @Override
560     public CallSiteDescriptor changeMethodTypeInternal(final MethodType newMethodType) {
561         return get(getLookupPrivileged(), getOperation(), newMethodType, flags);
562     }
563 
564     @Override
565     protected CallSiteDescriptor changeOperationInternal(final Operation newOperation) {
566         return get(getLookupPrivileged(), newOperation, getMethodType(), flags);
567     }
568 }
    </pre>
  </body>
</html>
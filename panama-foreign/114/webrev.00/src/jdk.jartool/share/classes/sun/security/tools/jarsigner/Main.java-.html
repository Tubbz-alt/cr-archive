<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.tools.jarsigner;
  27 
  28 import java.io.*;
  29 import java.net.UnknownHostException;
  30 import java.security.cert.CertPathValidatorException;
  31 import java.security.cert.PKIXBuilderParameters;
  32 import java.util.*;
  33 import java.util.stream.Collectors;
  34 import java.util.zip.*;
  35 import java.util.jar.*;
  36 import java.net.URI;
  37 import java.text.Collator;
  38 import java.text.MessageFormat;
  39 import java.security.cert.Certificate;
  40 import java.security.cert.X509Certificate;
  41 import java.security.cert.CertificateException;
  42 import java.security.*;
  43 
  44 import java.net.SocketTimeoutException;
  45 import java.net.URL;
  46 import java.security.cert.CertPath;
  47 import java.security.cert.CertificateExpiredException;
  48 import java.security.cert.CertificateFactory;
  49 import java.security.cert.CertificateNotYetValidException;
  50 import java.security.cert.TrustAnchor;
  51 import java.util.Map.Entry;
  52 
  53 import jdk.security.jarsigner.JarSigner;
  54 import jdk.security.jarsigner.JarSignerException;
  55 import sun.security.pkcs.PKCS7;
  56 import sun.security.pkcs.SignerInfo;
  57 import sun.security.timestamp.TimestampToken;
  58 import sun.security.tools.KeyStoreUtil;
  59 import sun.security.validator.Validator;
  60 import sun.security.validator.ValidatorException;
  61 import sun.security.x509.*;
  62 import sun.security.util.*;
  63 
  64 
  65 /**
  66  * &lt;p&gt;The jarsigner utility.
  67  *
  68  * The exit codes for the main method are:
  69  *
  70  * 0: success
  71  * 1: any error that the jar cannot be signed or verified, including:
  72  *      keystore loading error
  73  *      TSP communication error
  74  *      jarsigner command line error...
  75  * otherwise: error codes from -strict
  76  *
  77  * @author Roland Schemers
  78  * @author Jan Luehe
  79  */
  80 public class Main {
  81 
  82     // for i18n
  83     private static final java.util.ResourceBundle rb =
  84         java.util.ResourceBundle.getBundle
  85         (&quot;sun.security.tools.jarsigner.Resources&quot;);
  86     private static final Collator collator = Collator.getInstance();
  87     static {
  88         // this is for case insensitive string comparisions
  89         collator.setStrength(Collator.PRIMARY);
  90     }
  91 
  92     private static final String NONE = &quot;NONE&quot;;
  93     private static final String P11KEYSTORE = &quot;PKCS11&quot;;
  94 
  95     private static final long SIX_MONTHS = 180*24*60*60*1000L; //milliseconds
  96     private static final long ONE_YEAR = 366*24*60*60*1000L;
  97 
  98     private static final DisabledAlgorithmConstraints DISABLED_CHECK =
  99             new DisabledAlgorithmConstraints(
 100                     DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS);
 101 
 102     private static final Set&lt;CryptoPrimitive&gt; DIGEST_PRIMITIVE_SET = Collections
 103             .unmodifiableSet(EnumSet.of(CryptoPrimitive.MESSAGE_DIGEST));
 104     private static final Set&lt;CryptoPrimitive&gt; SIG_PRIMITIVE_SET = Collections
 105             .unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 106 
 107     static final String VERSION = &quot;1.0&quot;;
 108 
 109     static final int IN_KEYSTORE = 0x01;        // signer is in keystore
 110     static final int NOT_ALIAS = 0x04;          // alias list is NOT empty and
 111     // signer is not in alias list
 112     static final int SIGNED_BY_ALIAS = 0x08;    // signer is in alias list
 113 
 114     // Attention:
 115     // This is the entry that get launched by the security tool jarsigner.
 116     public static void main(String args[]) throws Exception {
 117         Main js = new Main();
 118         js.run(args);
 119     }
 120 
 121     X509Certificate[] certChain;    // signer&#39;s cert chain (when composing)
 122     PrivateKey privateKey;          // private key
 123     KeyStore store;                 // the keystore specified by -keystore
 124                                     // or the default keystore, never null
 125 
 126     String keystore; // key store file
 127     boolean nullStream = false; // null keystore input stream (NONE)
 128     boolean token = false; // token-based keystore
 129     String jarfile;  // jar files to sign or verify
 130     String alias;    // alias to sign jar with
 131     List&lt;String&gt; ckaliases = new ArrayList&lt;&gt;(); // aliases in -verify
 132     char[] storepass; // keystore password
 133     boolean protectedPath; // protected authentication path
 134     String storetype; // keystore type
 135     String providerName; // provider name
 136     List&lt;String&gt; providers = null; // list of provider names
 137     List&lt;String&gt; providerClasses = null; // list of provider classes
 138     // arguments for provider constructors
 139     HashMap&lt;String,String&gt; providerArgs = new HashMap&lt;&gt;();
 140     char[] keypass; // private key password
 141     String sigfile; // name of .SF file
 142     String sigalg; // name of signature algorithm
 143     String digestalg; // name of digest algorithm
 144     String signedjar; // output filename
 145     String tsaUrl; // location of the Timestamping Authority
 146     String tsaAlias; // alias for the Timestamping Authority&#39;s certificate
 147     String altCertChain; // file to read alternative cert chain from
 148     String tSAPolicyID;
 149     String tSADigestAlg;
 150     boolean verify = false; // verify the jar
 151     String verbose = null; // verbose output when signing/verifying
 152     boolean showcerts = false; // show certs when verifying
 153     boolean debug = false; // debug
 154     boolean signManifest = true; // &quot;sign&quot; the whole manifest
 155     boolean externalSF = true; // leave the .SF out of the PKCS7 block
 156     boolean strict = false;  // treat warnings as error
 157 
 158     // read zip entry raw bytes
 159     private String altSignerClass = null;
 160     private String altSignerClasspath = null;
 161     private ZipFile zipFile = null;
 162 
 163     // Informational warnings
 164     private boolean hasExpiringCert = false;
 165     private boolean hasExpiringTsaCert = false;
 166     private boolean noTimestamp = true;
 167 
 168     // Expiration date. The value could be null if signed by a trusted cert.
 169     private Date expireDate = null;
 170     private Date tsaExpireDate = null;
 171 
 172     // If there is a time stamp block inside the PKCS7 block file
 173     boolean hasTimestampBlock = false;
 174 
 175 
 176     // Severe warnings.
 177 
 178     // jarsigner used to check signer cert chain validity and key usages
 179     // itself and set various warnings. Later CertPath validation is
 180     // added but chainNotValidated is only flagged when no other existing
 181     // warnings are set. TSA cert chain check is added separately and
 182     // only tsaChainNotValidated is set, i.e. has no affect on hasExpiredCert,
 183     // notYetValidCert, or any badXyzUsage.
 184 
 185     private int weakAlg = 0; // 1. digestalg, 2. sigalg, 4. tsadigestalg
 186     private boolean hasExpiredCert = false;
 187     private boolean hasExpiredTsaCert = false;
 188     private boolean notYetValidCert = false;
 189     private boolean chainNotValidated = false;
 190     private boolean tsaChainNotValidated = false;
 191     private boolean notSignedByAlias = false;
 192     private boolean aliasNotInStore = false;
 193     private boolean hasUnsignedEntry = false;
 194     private boolean badKeyUsage = false;
 195     private boolean badExtendedKeyUsage = false;
 196     private boolean badNetscapeCertType = false;
 197     private boolean signerSelfSigned = false;
 198 
 199     private Throwable chainNotValidatedReason = null;
 200     private Throwable tsaChainNotValidatedReason = null;
 201 
 202     private boolean seeWeak = false;
 203 
 204     PKIXBuilderParameters pkixParameters;
 205     Set&lt;X509Certificate&gt; trustedCerts = new HashSet&lt;&gt;();
 206 
 207     public void run(String args[]) {
 208         try {
 209             args = parseArgs(args);
 210 
 211             // Try to load and install the specified providers
 212             if (providers != null) {
 213                 for (String provName: providers) {
 214                     try {
 215                         KeyStoreUtil.loadProviderByName(provName,
 216                                 providerArgs.get(provName));
 217                         if (debug) {
 218                             System.out.println(&quot;loadProviderByName: &quot; + provName);
 219                         }
 220                     } catch (IllegalArgumentException e) {
 221                         throw new Exception(String.format(rb.getString(
 222                                 &quot;provider.name.not.found&quot;), provName));
 223                     }
 224                 }
 225             }
 226 
 227             if (providerClasses != null) {
 228                 ClassLoader cl = ClassLoader.getSystemClassLoader();
 229                 for (String provClass: providerClasses) {
 230                     try {
 231                         KeyStoreUtil.loadProviderByClass(provClass,
 232                                 providerArgs.get(provClass), cl);
 233                         if (debug) {
 234                             System.out.println(&quot;loadProviderByClass: &quot; + provClass);
 235                         }
 236                     } catch (ClassCastException cce) {
 237                         throw new Exception(String.format(rb.getString(
 238                                 &quot;provclass.not.a.provider&quot;), provClass));
 239                     } catch (IllegalArgumentException e) {
 240                         throw new Exception(String.format(rb.getString(
 241                                 &quot;provider.class.not.found&quot;), provClass), e.getCause());
 242                     }
 243                 }
 244             }
 245 
 246             if (verify) {
 247                 try {
 248                     loadKeyStore(keystore, false);
 249                 } catch (Exception e) {
 250                     if ((keystore != null) || (storepass != null)) {
 251                         System.out.println(rb.getString(&quot;jarsigner.error.&quot;) +
 252                                         e.getMessage());
 253                         if (debug) {
 254                             e.printStackTrace();
 255                         }
 256                         System.exit(1);
 257                     }
 258                 }
 259                 /*              if (debug) {
 260                     SignatureFileVerifier.setDebug(true);
 261                     ManifestEntryVerifier.setDebug(true);
 262                 }
 263                 */
 264                 verifyJar(jarfile);
 265             } else {
 266                 loadKeyStore(keystore, true);
 267                 getAliasInfo(alias);
 268 
 269                 signJar(jarfile, alias);
 270             }
 271         } catch (Exception e) {
 272             System.out.println(rb.getString(&quot;jarsigner.error.&quot;) + e);
 273             if (debug) {
 274                 e.printStackTrace();
 275             }
 276             System.exit(1);
 277         } finally {
 278             // zero-out private key password
 279             if (keypass != null) {
 280                 Arrays.fill(keypass, &#39; &#39;);
 281                 keypass = null;
 282             }
 283             // zero-out keystore password
 284             if (storepass != null) {
 285                 Arrays.fill(storepass, &#39; &#39;);
 286                 storepass = null;
 287             }
 288         }
 289 
 290         if (strict) {
 291             int exitCode = 0;
 292             if (weakAlg != 0 || chainNotValidated || hasExpiredCert
 293                     || hasExpiredTsaCert || notYetValidCert || signerSelfSigned) {
 294                 exitCode |= 4;
 295             }
 296             if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType) {
 297                 exitCode |= 8;
 298             }
 299             if (hasUnsignedEntry) {
 300                 exitCode |= 16;
 301             }
 302             if (notSignedByAlias || aliasNotInStore) {
 303                 exitCode |= 32;
 304             }
 305             if (tsaChainNotValidated) {
 306                 exitCode |= 64;
 307             }
 308             if (exitCode != 0) {
 309                 System.exit(exitCode);
 310             }
 311         }
 312     }
 313 
 314     /*
 315      * Parse command line arguments.
 316      */
 317     String[] parseArgs(String args[]) throws Exception {
 318         /* parse flags */
 319         int n = 0;
 320 
 321         if (args.length == 0) fullusage();
 322 
 323         String confFile = null;
 324         String command = &quot;-sign&quot;;
 325         for (n=0; n &lt; args.length; n++) {
 326             if (collator.compare(args[n], &quot;-verify&quot;) == 0) {
 327                 command = &quot;-verify&quot;;
 328             } else if (collator.compare(args[n], &quot;-conf&quot;) == 0) {
 329                 if (n == args.length - 1) {
 330                     usageNoArg();
 331                 }
 332                 confFile = args[++n];
 333             }
 334         }
 335 
 336         if (confFile != null) {
 337             args = KeyStoreUtil.expandArgs(
 338                     &quot;jarsigner&quot;, confFile, command, null, args);
 339         }
 340 
 341         debug = Arrays.stream(args).anyMatch(
 342                 x -&gt; collator.compare(x, &quot;-debug&quot;) == 0);
 343 
 344         if (debug) {
 345             // No need to localize debug output
 346             System.out.println(&quot;Command line args: &quot; +
 347                     Arrays.toString(args));
 348         }
 349 
 350         for (n=0; n &lt; args.length; n++) {
 351 
 352             String flags = args[n];
 353             String modifier = null;
 354 
 355             if (flags.startsWith(&quot;-&quot;)) {
 356                 int pos = flags.indexOf(&#39;:&#39;);
 357                 if (pos &gt; 0) {
 358                     modifier = flags.substring(pos+1);
 359                     flags = flags.substring(0, pos);
 360                 }
 361             }
 362 
 363             if (!flags.startsWith(&quot;-&quot;)) {
 364                 if (jarfile == null) {
 365                     jarfile = flags;
 366                 } else {
 367                     alias = flags;
 368                     ckaliases.add(alias);
 369                 }
 370             } else if (collator.compare(flags, &quot;-conf&quot;) == 0) {
 371                 if (++n == args.length) usageNoArg();
 372             } else if (collator.compare(flags, &quot;-keystore&quot;) == 0) {
 373                 if (++n == args.length) usageNoArg();
 374                 keystore = args[n];
 375             } else if (collator.compare(flags, &quot;-storepass&quot;) ==0) {
 376                 if (++n == args.length) usageNoArg();
 377                 storepass = getPass(modifier, args[n]);
 378             } else if (collator.compare(flags, &quot;-storetype&quot;) ==0) {
 379                 if (++n == args.length) usageNoArg();
 380                 storetype = args[n];
 381             } else if (collator.compare(flags, &quot;-providerName&quot;) ==0) {
 382                 if (++n == args.length) usageNoArg();
 383                 providerName = args[n];
 384             } else if (collator.compare(flags, &quot;-provider&quot;) == 0 ||
 385                         collator.compare(flags, &quot;-providerClass&quot;) == 0) {
 386                 if (++n == args.length) usageNoArg();
 387                 if (providerClasses == null) {
 388                     providerClasses = new ArrayList&lt;&gt;(3);
 389                 }
 390                 providerClasses.add(args[n]);
 391 
 392                 if (args.length &gt; (n+1)) {
 393                     flags = args[n+1];
 394                     if (collator.compare(flags, &quot;-providerArg&quot;) == 0) {
 395                         if (args.length == (n+2)) usageNoArg();
 396                         providerArgs.put(args[n], args[n+2]);
 397                         n += 2;
 398                     }
 399                 }
 400             } else if (collator.compare(flags, &quot;-addprovider&quot;) == 0) {
 401                 if (++n == args.length) usageNoArg();
 402                 if (providers == null) {
 403                     providers = new ArrayList&lt;&gt;(3);
 404                 }
 405                 providers.add(args[n]);
 406 
 407                 if (args.length &gt; (n+1)) {
 408                     flags = args[n+1];
 409                     if (collator.compare(flags, &quot;-providerArg&quot;) == 0) {
 410                         if (args.length == (n+2)) usageNoArg();
 411                         providerArgs.put(args[n], args[n+2]);
 412                         n += 2;
 413                     }
 414                 }
 415             } else if (collator.compare(flags, &quot;-protected&quot;) ==0) {
 416                 protectedPath = true;
 417             } else if (collator.compare(flags, &quot;-certchain&quot;) ==0) {
 418                 if (++n == args.length) usageNoArg();
 419                 altCertChain = args[n];
 420             } else if (collator.compare(flags, &quot;-tsapolicyid&quot;) ==0) {
 421                 if (++n == args.length) usageNoArg();
 422                 tSAPolicyID = args[n];
 423             } else if (collator.compare(flags, &quot;-tsadigestalg&quot;) ==0) {
 424                 if (++n == args.length) usageNoArg();
 425                 tSADigestAlg = args[n];
 426             } else if (collator.compare(flags, &quot;-debug&quot;) ==0) {
 427                 // Already processed
 428             } else if (collator.compare(flags, &quot;-keypass&quot;) ==0) {
 429                 if (++n == args.length) usageNoArg();
 430                 keypass = getPass(modifier, args[n]);
 431             } else if (collator.compare(flags, &quot;-sigfile&quot;) ==0) {
 432                 if (++n == args.length) usageNoArg();
 433                 sigfile = args[n];
 434             } else if (collator.compare(flags, &quot;-signedjar&quot;) ==0) {
 435                 if (++n == args.length) usageNoArg();
 436                 signedjar = args[n];
 437             } else if (collator.compare(flags, &quot;-tsa&quot;) ==0) {
 438                 if (++n == args.length) usageNoArg();
 439                 tsaUrl = args[n];
 440             } else if (collator.compare(flags, &quot;-tsacert&quot;) ==0) {
 441                 if (++n == args.length) usageNoArg();
 442                 tsaAlias = args[n];
 443             } else if (collator.compare(flags, &quot;-altsigner&quot;) ==0) {
 444                 if (++n == args.length) usageNoArg();
 445                 altSignerClass = args[n];
 446                 System.err.println(
 447                         rb.getString(&quot;This.option.is.deprecated&quot;) +
 448                                 &quot;-altsigner&quot;);
 449             } else if (collator.compare(flags, &quot;-altsignerpath&quot;) ==0) {
 450                 if (++n == args.length) usageNoArg();
 451                 altSignerClasspath = args[n];
 452                 System.err.println(
 453                         rb.getString(&quot;This.option.is.deprecated&quot;) +
 454                                 &quot;-altsignerpath&quot;);
 455             } else if (collator.compare(flags, &quot;-sectionsonly&quot;) ==0) {
 456                 signManifest = false;
 457             } else if (collator.compare(flags, &quot;-internalsf&quot;) ==0) {
 458                 externalSF = false;
 459             } else if (collator.compare(flags, &quot;-verify&quot;) ==0) {
 460                 verify = true;
 461             } else if (collator.compare(flags, &quot;-verbose&quot;) ==0) {
 462                 verbose = (modifier != null) ? modifier : &quot;all&quot;;
 463             } else if (collator.compare(flags, &quot;-sigalg&quot;) ==0) {
 464                 if (++n == args.length) usageNoArg();
 465                 sigalg = args[n];
 466             } else if (collator.compare(flags, &quot;-digestalg&quot;) ==0) {
 467                 if (++n == args.length) usageNoArg();
 468                 digestalg = args[n];
 469             } else if (collator.compare(flags, &quot;-certs&quot;) ==0) {
 470                 showcerts = true;
 471             } else if (collator.compare(flags, &quot;-strict&quot;) ==0) {
 472                 strict = true;
 473             } else if (collator.compare(flags, &quot;-?&quot;) == 0 ||
 474                        collator.compare(flags, &quot;-h&quot;) == 0 ||
 475                        collator.compare(flags, &quot;--help&quot;) == 0 ||
 476                        // -help: legacy.
 477                        collator.compare(flags, &quot;-help&quot;) == 0) {
 478                 fullusage();
 479             } else {
 480                 System.err.println(
 481                         rb.getString(&quot;Illegal.option.&quot;) + flags);
 482                 usage();
 483             }
 484         }
 485 
 486         // -certs must always be specified with -verbose
 487         if (verbose == null) showcerts = false;
 488 
 489         if (jarfile == null) {
 490             System.err.println(rb.getString(&quot;Please.specify.jarfile.name&quot;));
 491             usage();
 492         }
 493         if (!verify &amp;&amp; alias == null) {
 494             System.err.println(rb.getString(&quot;Please.specify.alias.name&quot;));
 495             usage();
 496         }
 497         if (!verify &amp;&amp; ckaliases.size() &gt; 1) {
 498             System.err.println(rb.getString(&quot;Only.one.alias.can.be.specified&quot;));
 499             usage();
 500         }
 501 
 502         if (storetype == null) {
 503             storetype = KeyStore.getDefaultType();
 504         }
 505         storetype = KeyStoreUtil.niceStoreTypeName(storetype);
 506 
 507         try {
 508             if (signedjar != null &amp;&amp; new File(signedjar).getCanonicalPath().equals(
 509                     new File(jarfile).getCanonicalPath())) {
 510                 signedjar = null;
 511             }
 512         } catch (IOException ioe) {
 513             // File system error?
 514             // Just ignore it.
 515         }
 516 
 517         if (P11KEYSTORE.equalsIgnoreCase(storetype) ||
 518                 KeyStoreUtil.isWindowsKeyStore(storetype)) {
 519             token = true;
 520             if (keystore == null) {
 521                 keystore = NONE;
 522             }
 523         }
 524 
 525         if (NONE.equals(keystore)) {
 526             nullStream = true;
 527         }
 528 
 529         if (token &amp;&amp; !nullStream) {
 530             System.err.println(MessageFormat.format(rb.getString
 531                 (&quot;.keystore.must.be.NONE.if.storetype.is.{0}&quot;), storetype));
 532             usage();
 533         }
 534 
 535         if (token &amp;&amp; keypass != null) {
 536             System.err.println(MessageFormat.format(rb.getString
 537                 (&quot;.keypass.can.not.be.specified.if.storetype.is.{0}&quot;), storetype));
 538             usage();
 539         }
 540 
 541         if (protectedPath) {
 542             if (storepass != null || keypass != null) {
 543                 System.err.println(rb.getString
 544                         (&quot;If.protected.is.specified.then.storepass.and.keypass.must.not.be.specified&quot;));
 545                 usage();
 546             }
 547         }
 548         if (KeyStoreUtil.isWindowsKeyStore(storetype)) {
 549             if (storepass != null || keypass != null) {
 550                 System.err.println(rb.getString
 551                         (&quot;If.keystore.is.not.password.protected.then.storepass.and.keypass.must.not.be.specified&quot;));
 552                 usage();
 553             }
 554         }
 555         return args;
 556     }
 557 
 558     static char[] getPass(String modifier, String arg) {
 559         char[] output = KeyStoreUtil.getPassWithModifier(modifier, arg, rb);
 560         if (output != null) return output;
 561         usage();
 562         return null;    // Useless, usage() already exit
 563     }
 564 
 565     static void usageNoArg() {
 566         System.out.println(rb.getString(&quot;Option.lacks.argument&quot;));
 567         usage();
 568     }
 569 
 570     static void usage() {
 571         System.out.println();
 572         System.out.println(rb.getString(&quot;Please.type.jarsigner.help.for.usage&quot;));
 573         System.exit(1);
 574     }
 575 
 576     static void fullusage() {
 577         System.out.println(rb.getString
 578                 (&quot;Usage.jarsigner.options.jar.file.alias&quot;));
 579         System.out.println(rb.getString
 580                 (&quot;.jarsigner.verify.options.jar.file.alias.&quot;));
 581         System.out.println();
 582         System.out.println(rb.getString
 583                 (&quot;.keystore.url.keystore.location&quot;));
 584         System.out.println();
 585         System.out.println(rb.getString
 586                 (&quot;.storepass.password.password.for.keystore.integrity&quot;));
 587         System.out.println();
 588         System.out.println(rb.getString
 589                 (&quot;.storetype.type.keystore.type&quot;));
 590         System.out.println();
 591         System.out.println(rb.getString
 592                 (&quot;.keypass.password.password.for.private.key.if.different.&quot;));
 593         System.out.println();
 594         System.out.println(rb.getString
 595                 (&quot;.certchain.file.name.of.alternative.certchain.file&quot;));
 596         System.out.println();
 597         System.out.println(rb.getString
 598                 (&quot;.sigfile.file.name.of.SF.DSA.file&quot;));
 599         System.out.println();
 600         System.out.println(rb.getString
 601                 (&quot;.signedjar.file.name.of.signed.JAR.file&quot;));
 602         System.out.println();
 603         System.out.println(rb.getString
 604                 (&quot;.digestalg.algorithm.name.of.digest.algorithm&quot;));
 605         System.out.println();
 606         System.out.println(rb.getString
 607                 (&quot;.sigalg.algorithm.name.of.signature.algorithm&quot;));
 608         System.out.println();
 609         System.out.println(rb.getString
 610                 (&quot;.verify.verify.a.signed.JAR.file&quot;));
 611         System.out.println();
 612         System.out.println(rb.getString
 613                 (&quot;.verbose.suboptions.verbose.output.when.signing.verifying.&quot;));
 614         System.out.println(rb.getString
 615                 (&quot;.suboptions.can.be.all.grouped.or.summary&quot;));
 616         System.out.println();
 617         System.out.println(rb.getString
 618                 (&quot;.certs.display.certificates.when.verbose.and.verifying&quot;));
 619         System.out.println();
 620         System.out.println(rb.getString
 621                 (&quot;.tsa.url.location.of.the.Timestamping.Authority&quot;));
 622         System.out.println();
 623         System.out.println(rb.getString
 624                 (&quot;.tsacert.alias.public.key.certificate.for.Timestamping.Authority&quot;));
 625         System.out.println();
 626         System.out.println(rb.getString
 627                 (&quot;.tsapolicyid.tsapolicyid.for.Timestamping.Authority&quot;));
 628         System.out.println();
 629         System.out.println(rb.getString
 630                 (&quot;.tsadigestalg.algorithm.of.digest.data.in.timestamping.request&quot;));
 631         System.out.println();
 632         System.out.println(rb.getString
 633                 (&quot;.altsigner.class.class.name.of.an.alternative.signing.mechanism&quot;));
 634         System.out.println();
 635         System.out.println(rb.getString
 636                 (&quot;.altsignerpath.pathlist.location.of.an.alternative.signing.mechanism&quot;));
 637         System.out.println();
 638         System.out.println(rb.getString
 639                 (&quot;.internalsf.include.the.SF.file.inside.the.signature.block&quot;));
 640         System.out.println();
 641         System.out.println(rb.getString
 642                 (&quot;.sectionsonly.don.t.compute.hash.of.entire.manifest&quot;));
 643         System.out.println();
 644         System.out.println(rb.getString
 645                 (&quot;.protected.keystore.has.protected.authentication.path&quot;));
 646         System.out.println();
 647         System.out.println(rb.getString
 648                 (&quot;.providerName.name.provider.name&quot;));
 649         System.out.println();
 650         System.out.println(rb.getString
 651                 (&quot;.add.provider.option&quot;));
 652         System.out.println(rb.getString
 653                 (&quot;.providerArg.option.1&quot;));
 654         System.out.println();
 655         System.out.println(rb.getString
 656                 (&quot;.providerClass.option&quot;));
 657         System.out.println(rb.getString
 658                 (&quot;.providerArg.option.2&quot;));
 659         System.out.println();
 660         System.out.println(rb.getString
 661                 (&quot;.strict.treat.warnings.as.errors&quot;));
 662         System.out.println();
 663         System.out.println(rb.getString
 664                 (&quot;.conf.url.specify.a.pre.configured.options.file&quot;));
 665         System.out.println();
 666         System.out.println(rb.getString
 667                 (&quot;.print.this.help.message&quot;));
 668         System.out.println();
 669 
 670         System.exit(0);
 671     }
 672 
 673     void verifyJar(String jarName)
 674         throws Exception
 675     {
 676         boolean anySigned = false;  // if there exists entry inside jar signed
 677         JarFile jf = null;
 678         Map&lt;String,String&gt; digestMap = new HashMap&lt;&gt;();
 679         Map&lt;String,PKCS7&gt; sigMap = new HashMap&lt;&gt;();
 680         Map&lt;String,String&gt; sigNameMap = new HashMap&lt;&gt;();
 681         Map&lt;String,String&gt; unparsableSignatures = new HashMap&lt;&gt;();
 682 
 683         try {
 684             jf = new JarFile(jarName, true);
 685             Vector&lt;JarEntry&gt; entriesVec = new Vector&lt;&gt;();
 686             byte[] buffer = new byte[8192];
 687 
 688             String suffix1 = &quot;-Digest-Manifest&quot;;
 689             String suffix2 = &quot;-Digest-&quot; + ManifestDigester.MF_MAIN_ATTRS;
 690 
 691             int suffixLength1 = suffix1.length();
 692             int suffixLength2 = suffix2.length();
 693 
 694             Enumeration&lt;JarEntry&gt; entries = jf.entries();
 695             while (entries.hasMoreElements()) {
 696                 JarEntry je = entries.nextElement();
 697                 entriesVec.addElement(je);
 698                 try (InputStream is = jf.getInputStream(je)) {
 699                     String name = je.getName();
 700                     if (signatureRelated(name)
 701                             &amp;&amp; SignatureFileVerifier.isBlockOrSF(name)) {
 702                         String alias = name.substring(name.lastIndexOf(&#39;/&#39;) + 1,
 703                                 name.lastIndexOf(&#39;.&#39;));
 704                         try {
 705                             if (name.endsWith(&quot;.SF&quot;)) {
 706                                 Manifest sf = new Manifest(is);
 707                                 boolean found = false;
 708                                 for (Object obj : sf.getMainAttributes().keySet()) {
 709                                     String key = obj.toString();
 710                                     if (key.endsWith(suffix1)) {
 711                                         digestMap.put(alias, key.substring(
 712                                                 0, key.length() - suffixLength1));
 713                                         found = true;
 714                                         break;
 715                                     } else if (key.endsWith(suffix2)) {
 716                                         digestMap.put(alias, key.substring(
 717                                                 0, key.length() - suffixLength2));
 718                                         found = true;
 719                                         break;
 720                                     }
 721                                 }
 722                                 if (!found) {
 723                                     unparsableSignatures.putIfAbsent(alias,
 724                                         String.format(
 725                                             rb.getString(&quot;history.unparsable&quot;),
 726                                             name));
 727                                 }
 728                             } else {
 729                                 sigNameMap.put(alias, name);
 730                                 sigMap.put(alias, new PKCS7(is));
 731                             }
 732                         } catch (IOException ioe) {
 733                             unparsableSignatures.putIfAbsent(alias, String.format(
 734                                     rb.getString(&quot;history.unparsable&quot;), name));
 735                         }
 736                     } else {
 737                         while (is.read(buffer, 0, buffer.length) != -1) {
 738                             // we just read. this will throw a SecurityException
 739                             // if  a signature/digest check fails.
 740                         }
 741                     }
 742                 }
 743             }
 744 
 745             Manifest man = jf.getManifest();
 746             boolean hasSignature = false;
 747 
 748             // The map to record display info, only used when -verbose provided
 749             //      key: signer info string
 750             //      value: the list of files with common key
 751             Map&lt;String,List&lt;String&gt;&gt; output = new LinkedHashMap&lt;&gt;();
 752 
 753             if (man != null) {
 754                 if (verbose != null) System.out.println();
 755                 Enumeration&lt;JarEntry&gt; e = entriesVec.elements();
 756 
 757                 String tab = rb.getString(&quot;6SPACE&quot;);
 758 
 759                 while (e.hasMoreElements()) {
 760                     JarEntry je = e.nextElement();
 761                     String name = je.getName();
 762 
 763                     hasSignature = hasSignature
 764                             || SignatureFileVerifier.isBlockOrSF(name);
 765 
 766                     CodeSigner[] signers = je.getCodeSigners();
 767                     boolean isSigned = (signers != null);
 768                     anySigned |= isSigned;
 769                     hasUnsignedEntry |= !je.isDirectory() &amp;&amp; !isSigned
 770                                         &amp;&amp; !signatureRelated(name);
 771 
 772                     int inStoreWithAlias = inKeyStore(signers);
 773 
 774                     boolean inStore = (inStoreWithAlias &amp; IN_KEYSTORE) != 0;
 775 
 776                     notSignedByAlias |= (inStoreWithAlias &amp; NOT_ALIAS) != 0;
 777                     if (keystore != null) {
 778                         aliasNotInStore |= isSigned &amp;&amp; !inStore;
 779                     }
 780 
 781                     // Only used when -verbose provided
 782                     StringBuffer sb = null;
 783                     if (verbose != null) {
 784                         sb = new StringBuffer();
 785                         boolean inManifest =
 786                             ((man.getAttributes(name) != null) ||
 787                              (man.getAttributes(&quot;./&quot;+name) != null) ||
 788                              (man.getAttributes(&quot;/&quot;+name) != null));
 789                         sb.append(isSigned ? rb.getString(&quot;s&quot;) : rb.getString(&quot;SPACE&quot;))
 790                                 .append(inManifest ? rb.getString(&quot;m&quot;) : rb.getString(&quot;SPACE&quot;))
 791                                 .append(inStore ? rb.getString(&quot;k&quot;) : rb.getString(&quot;SPACE&quot;))
 792                                 .append((inStoreWithAlias &amp; NOT_ALIAS) != 0 ? &#39;X&#39; : &#39; &#39;)
 793                                 .append(rb.getString(&quot;SPACE&quot;));
 794                         sb.append(&#39;|&#39;);
 795                     }
 796 
 797                     // When -certs provided, display info has extra empty
 798                     // lines at the beginning and end.
 799                     if (isSigned) {
 800                         if (showcerts) sb.append(&#39;\n&#39;);
 801                         for (CodeSigner signer: signers) {
 802                             // signerInfo() must be called even if -verbose
 803                             // not provided. The method updates various
 804                             // warning flags.
 805                             String si = signerInfo(signer, tab);
 806                             if (showcerts) {
 807                                 sb.append(si);
 808                                 sb.append(&#39;\n&#39;);
 809                             }
 810                         }
 811                     } else if (showcerts &amp;&amp; !verbose.equals(&quot;all&quot;)) {
 812                         // Print no info for unsigned entries when -verbose:all,
 813                         // to be consistent with old behavior.
 814                         if (signatureRelated(name)) {
 815                             sb.append(&#39;\n&#39;)
 816                                     .append(tab)
 817                                     .append(rb
 818                                             .getString(&quot;.Signature.related.entries.&quot;))
 819                                     .append(&quot;\n\n&quot;);
 820                         } else {
 821                             sb.append(&#39;\n&#39;).append(tab)
 822                                     .append(rb.getString(&quot;.Unsigned.entries.&quot;))
 823                                     .append(&quot;\n\n&quot;);
 824                         }
 825                     }
 826 
 827                     if (verbose != null) {
 828                         String label = sb.toString();
 829                         if (signatureRelated(name)) {
 830                             // Entries inside META-INF and other unsigned
 831                             // entries are grouped separately.
 832                             label = &quot;-&quot; + label;
 833                         }
 834 
 835                         // The label finally contains 2 parts separated by &#39;|&#39;:
 836                         // The legend displayed before the entry names, and
 837                         // the cert info (if -certs specified).
 838 
 839                         if (!output.containsKey(label)) {
 840                             output.put(label, new ArrayList&lt;String&gt;());
 841                         }
 842 
 843                         StringBuilder fb = new StringBuilder();
 844                         String s = Long.toString(je.getSize());
 845                         for (int i = 6 - s.length(); i &gt; 0; --i) {
 846                             fb.append(&#39; &#39;);
 847                         }
 848                         fb.append(s).append(&#39; &#39;).
 849                                 append(new Date(je.getTime()).toString());
 850                         fb.append(&#39; &#39;).append(name);
 851 
 852                         output.get(label).add(fb.toString());
 853                     }
 854                 }
 855             }
 856             if (verbose != null) {
 857                 for (Entry&lt;String,List&lt;String&gt;&gt; s: output.entrySet()) {
 858                     List&lt;String&gt; files = s.getValue();
 859                     String key = s.getKey();
 860                     if (key.charAt(0) == &#39;-&#39;) { // the signature-related group
 861                         key = key.substring(1);
 862                     }
 863                     int pipe = key.indexOf(&#39;|&#39;);
 864                     if (verbose.equals(&quot;all&quot;)) {
 865                         for (String f: files) {
 866                             System.out.println(key.substring(0, pipe) + f);
 867                             System.out.printf(key.substring(pipe+1));
 868                         }
 869                     } else {
 870                         if (verbose.equals(&quot;grouped&quot;)) {
 871                             for (String f: files) {
 872                                 System.out.println(key.substring(0, pipe) + f);
 873                             }
 874                         } else if (verbose.equals(&quot;summary&quot;)) {
 875                             System.out.print(key.substring(0, pipe));
 876                             if (files.size() &gt; 1) {
 877                                 System.out.println(files.get(0) + &quot; &quot; +
 878                                         String.format(rb.getString(
 879                                         &quot;.and.d.more.&quot;), files.size()-1));
 880                             } else {
 881                                 System.out.println(files.get(0));
 882                             }
 883                         }
 884                         System.out.printf(key.substring(pipe+1));
 885                     }
 886                 }
 887                 System.out.println();
 888                 System.out.println(rb.getString(
 889                     &quot;.s.signature.was.verified.&quot;));
 890                 System.out.println(rb.getString(
 891                     &quot;.m.entry.is.listed.in.manifest&quot;));
 892                 System.out.println(rb.getString(
 893                     &quot;.k.at.least.one.certificate.was.found.in.keystore&quot;));
 894                 if (ckaliases.size() &gt; 0) {
 895                     System.out.println(rb.getString(
 896                         &quot;.X.not.signed.by.specified.alias.es.&quot;));
 897                 }
 898             }
 899             if (man == null) {
 900                 System.out.println();
 901                 System.out.println(rb.getString(&quot;no.manifest.&quot;));
 902             }
 903 
 904             // If signer is a trusted cert or private entry in user&#39;s own
 905             // keystore, it can be self-signed. Please note aliasNotInStore
 906             // is always false when ~/.keystore is used.
 907             if (!aliasNotInStore &amp;&amp; keystore != null) {
 908                 signerSelfSigned = false;
 909             }
 910 
 911             // Even if the verbose option is not specified, all out strings
 912             // must be generated so seeWeak can be updated.
 913             if (!digestMap.isEmpty()
 914                     || !sigMap.isEmpty()
 915                     || !unparsableSignatures.isEmpty()) {
 916                 if (verbose != null) {
 917                     System.out.println();
 918                 }
 919                 for (String s : sigMap.keySet()) {
 920                     if (!digestMap.containsKey(s)) {
 921                         unparsableSignatures.putIfAbsent(s, String.format(
 922                                 rb.getString(&quot;history.nosf&quot;), s));
 923                     }
 924                 }
 925                 for (String s : digestMap.keySet()) {
 926                     PKCS7 p7 = sigMap.get(s);
 927                     if (p7 != null) {
 928                         String history;
 929                         try {
 930                             SignerInfo si = p7.getSignerInfos()[0];
 931                             X509Certificate signer = si.getCertificate(p7);
 932                             String digestAlg = digestMap.get(s);
 933                             String sigAlg = AlgorithmId.makeSigAlg(
 934                                     si.getDigestAlgorithmId().getName(),
 935                                     si.getDigestEncryptionAlgorithmId().getName());
 936                             PublicKey key = signer.getPublicKey();
 937                             PKCS7 tsToken = si.getTsToken();
 938                             if (tsToken != null) {
 939                                 hasTimestampBlock = true;
 940                                 SignerInfo tsSi = tsToken.getSignerInfos()[0];
 941                                 X509Certificate tsSigner = tsSi.getCertificate(tsToken);
 942                                 byte[] encTsTokenInfo = tsToken.getContentInfo().getData();
 943                                 TimestampToken tsTokenInfo = new TimestampToken(encTsTokenInfo);
 944                                 PublicKey tsKey = tsSigner.getPublicKey();
 945                                 String tsDigestAlg = tsTokenInfo.getHashAlgorithm().getName();
 946                                 String tsSigAlg = AlgorithmId.makeSigAlg(
 947                                         tsSi.getDigestAlgorithmId().getName(),
 948                                         tsSi.getDigestEncryptionAlgorithmId().getName());
 949                                 Calendar c = Calendar.getInstance(
 950                                         TimeZone.getTimeZone(&quot;UTC&quot;),
 951                                         Locale.getDefault(Locale.Category.FORMAT));
 952                                 c.setTime(tsTokenInfo.getDate());
 953                                 history = String.format(
 954                                         rb.getString(&quot;history.with.ts&quot;),
 955                                         signer.getSubjectX500Principal(),
 956                                         withWeak(digestAlg, DIGEST_PRIMITIVE_SET),
 957                                         withWeak(sigAlg, SIG_PRIMITIVE_SET),
 958                                         withWeak(key),
 959                                         c,
 960                                         tsSigner.getSubjectX500Principal(),
 961                                         withWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET),
 962                                         withWeak(tsSigAlg, SIG_PRIMITIVE_SET),
 963                                         withWeak(tsKey));
 964                             } else {
 965                                 history = String.format(
 966                                         rb.getString(&quot;history.without.ts&quot;),
 967                                         signer.getSubjectX500Principal(),
 968                                         withWeak(digestAlg, DIGEST_PRIMITIVE_SET),
 969                                         withWeak(sigAlg, SIG_PRIMITIVE_SET),
 970                                         withWeak(key));
 971                             }
 972                         } catch (Exception e) {
 973                             // The only usage of sigNameMap, remember the name
 974                             // of the block file if it&#39;s invalid.
 975                             history = String.format(
 976                                     rb.getString(&quot;history.unparsable&quot;),
 977                                     sigNameMap.get(s));
 978                         }
 979                         if (verbose != null) {
 980                             System.out.println(history);
 981                         }
 982                     } else {
 983                         unparsableSignatures.putIfAbsent(s, String.format(
 984                                 rb.getString(&quot;history.nobk&quot;), s));
 985                     }
 986                 }
 987                 if (verbose != null) {
 988                     for (String s : unparsableSignatures.keySet()) {
 989                         System.out.println(unparsableSignatures.get(s));
 990                     }
 991                 }
 992             }
 993             System.out.println();
 994             if (!anySigned) {
 995                 if (seeWeak) {
 996                     if (verbose != null) {
 997                         System.out.println(rb.getString(&quot;jar.treated.unsigned.see.weak.verbose&quot;));
 998                         System.out.println(&quot;\n  &quot; +
 999                                 DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS +
1000                                 &quot;=&quot; + Security.getProperty(DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS));
1001                     } else {
1002                         System.out.println(rb.getString(&quot;jar.treated.unsigned.see.weak&quot;));
1003                     }
1004                 } else if (hasSignature) {
1005                     System.out.println(rb.getString(&quot;jar.treated.unsigned&quot;));
1006                 } else {
1007                     System.out.println(rb.getString(&quot;jar.is.unsigned&quot;));
1008                 }
1009             } else {
1010                 displayMessagesAndResult(false);
1011             }
1012             return;
1013         } catch (Exception e) {
1014             System.out.println(rb.getString(&quot;jarsigner.&quot;) + e);
1015             if (debug) {
1016                 e.printStackTrace();
1017             }
1018         } finally { // close the resource
1019             if (jf != null) {
1020                 jf.close();
1021             }
1022         }
1023 
1024         System.exit(1);
1025     }
1026 
1027     private void displayMessagesAndResult(boolean isSigning) {
1028         String result;
1029         List&lt;String&gt; errors = new ArrayList&lt;&gt;();
1030         List&lt;String&gt; warnings = new ArrayList&lt;&gt;();
1031         List&lt;String&gt; info = new ArrayList&lt;&gt;();
1032 
1033         boolean signerNotExpired = expireDate == null
1034                 || expireDate.after(new Date());
1035 
1036         if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType ||
1037                 notYetValidCert || chainNotValidated || hasExpiredCert ||
1038                 hasUnsignedEntry || signerSelfSigned || (weakAlg != 0) ||
1039                 aliasNotInStore || notSignedByAlias ||
1040                 tsaChainNotValidated ||
1041                 (hasExpiredTsaCert &amp;&amp; !signerNotExpired)) {
1042 
1043             if (strict) {
1044                 result = isSigning
1045                         ? rb.getString(&quot;jar.signed.with.signer.errors.&quot;)
1046                         : rb.getString(&quot;jar.verified.with.signer.errors.&quot;);
1047             } else {
1048                 result = isSigning
1049                         ? rb.getString(&quot;jar.signed.&quot;)
1050                         : rb.getString(&quot;jar.verified.&quot;);
1051             }
1052 
1053             if (badKeyUsage) {
1054                 errors.add(isSigning
1055                         ? rb.getString(&quot;The.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.&quot;)
1056                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.&quot;));
1057             }
1058 
1059             if (badExtendedKeyUsage) {
1060                 errors.add(isSigning
1061                         ? rb.getString(&quot;The.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.&quot;)
1062                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.&quot;));
1063             }
1064 
1065             if (badNetscapeCertType) {
1066                 errors.add(isSigning
1067                         ? rb.getString(&quot;The.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.&quot;)
1068                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.&quot;));
1069             }
1070 
1071             // only in verifying
1072             if (hasUnsignedEntry) {
1073                 errors.add(rb.getString(
1074                         &quot;This.jar.contains.unsigned.entries.which.have.not.been.integrity.checked.&quot;));
1075             }
1076             if (hasExpiredCert) {
1077                 errors.add(isSigning
1078                         ? rb.getString(&quot;The.signer.certificate.has.expired.&quot;)
1079                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.has.expired.&quot;));
1080             }
1081             if (notYetValidCert) {
1082                 errors.add(isSigning
1083                         ? rb.getString(&quot;The.signer.certificate.is.not.yet.valid.&quot;)
1084                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.is.not.yet.valid.&quot;));
1085             }
1086 
1087             if (chainNotValidated) {
1088                 errors.add(String.format(isSigning
1089                                 ? rb.getString(&quot;The.signer.s.certificate.chain.is.invalid.reason.1&quot;)
1090                                 : rb.getString(&quot;This.jar.contains.entries.whose.certificate.chain.is.invalid.reason.1&quot;),
1091                         chainNotValidatedReason.getLocalizedMessage()));
1092             }
1093 
1094             if (hasExpiredTsaCert) {
1095                 errors.add(rb.getString(&quot;The.timestamp.has.expired.&quot;));
1096             }
1097             if (tsaChainNotValidated) {
1098                 errors.add(String.format(isSigning
1099                                 ? rb.getString(&quot;The.tsa.certificate.chain.is.invalid.reason.1&quot;)
1100                                 : rb.getString(&quot;This.jar.contains.entries.whose.tsa.certificate.chain.is.invalid.reason.1&quot;),
1101                         tsaChainNotValidatedReason.getLocalizedMessage()));
1102             }
1103 
1104             // only in verifying
1105             if (notSignedByAlias) {
1106                 errors.add(
1107                         rb.getString(&quot;This.jar.contains.signed.entries.which.is.not.signed.by.the.specified.alias.es.&quot;));
1108             }
1109 
1110             // only in verifying
1111             if (aliasNotInStore) {
1112                 errors.add(rb.getString(&quot;This.jar.contains.signed.entries.that.s.not.signed.by.alias.in.this.keystore.&quot;));
1113             }
1114 
1115             if (signerSelfSigned) {
1116                 errors.add(isSigning
1117                         ? rb.getString(&quot;The.signer.s.certificate.is.self.signed.&quot;)
1118                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.is.self.signed.&quot;));
1119             }
1120 
1121             // weakAlg only detected in signing. The jar file is
1122             // now simply treated unsigned in verifying.
1123             if ((weakAlg &amp; 1) == 1) {
1124                 errors.add(String.format(
1125                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.&quot;),
1126                         digestalg, &quot;-digestalg&quot;));
1127             }
1128 
1129             if ((weakAlg &amp; 2) == 2) {
1130                 errors.add(String.format(
1131                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.&quot;),
1132                         sigalg, &quot;-sigalg&quot;));
1133             }
1134             if ((weakAlg &amp; 4) == 4) {
1135                 errors.add(String.format(
1136                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.&quot;),
1137                         tSADigestAlg, &quot;-tsadigestalg&quot;));
1138             }
1139             if ((weakAlg &amp; 8) == 8) {
1140                 errors.add(String.format(
1141                         rb.getString(&quot;The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk.&quot;),
1142                         privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));
1143             }
1144         } else {
1145             result = isSigning ? rb.getString(&quot;jar.signed.&quot;) : rb.getString(&quot;jar.verified.&quot;);
1146         }
1147 
1148         if (hasExpiredTsaCert) {
1149             // No need to warn about expiring if already expired
1150             hasExpiringTsaCert = false;
1151         }
1152 
1153         if (hasExpiringCert ||
1154                 (hasExpiringTsaCert  &amp;&amp; expireDate != null) ||
1155                 (noTimestamp &amp;&amp; expireDate != null) ||
1156                 (hasExpiredTsaCert &amp;&amp; signerNotExpired)) {
1157 
1158             if (hasExpiredTsaCert &amp;&amp; signerNotExpired) {
1159                 if (expireDate != null) {
1160                     warnings.add(String.format(
1161                             rb.getString(&quot;The.timestamp.expired.1.but.usable.2&quot;),
1162                             tsaExpireDate,
1163                             expireDate));
1164                 }
1165                 // Reset the flag so exit code is 0
1166                 hasExpiredTsaCert = false;
1167             }
1168             if (hasExpiringCert) {
1169                 warnings.add(isSigning
1170                         ? rb.getString(&quot;The.signer.certificate.will.expire.within.six.months.&quot;)
1171                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.will.expire.within.six.months.&quot;));
1172             }
1173             if (hasExpiringTsaCert &amp;&amp; expireDate != null) {
1174                 if (expireDate.after(tsaExpireDate)) {
1175                     warnings.add(String.format(rb.getString(
1176                             &quot;The.timestamp.will.expire.within.one.year.on.1.but.2&quot;), tsaExpireDate, expireDate));
1177                 } else {
1178                     warnings.add(String.format(rb.getString(
1179                             &quot;The.timestamp.will.expire.within.one.year.on.1&quot;), tsaExpireDate));
1180                 }
1181             }
1182             if (noTimestamp &amp;&amp; expireDate != null) {
1183                 if (hasTimestampBlock) {
1184                     warnings.add(String.format(isSigning
1185                             ? rb.getString(&quot;invalid.timestamp.signing&quot;)
1186                             : rb.getString(&quot;bad.timestamp.verifying&quot;), expireDate));
1187                 } else {
1188                     warnings.add(String.format(isSigning
1189                             ? rb.getString(&quot;no.timestamp.signing&quot;)
1190                             : rb.getString(&quot;no.timestamp.verifying&quot;), expireDate));
1191                 }
1192             }
1193         }
1194 
1195         System.out.println(result);
1196         if (strict) {
1197             if (!errors.isEmpty()) {
1198                 System.out.println();
1199                 System.out.println(rb.getString(&quot;Error.&quot;));
1200                 errors.forEach(System.out::println);
1201             }
1202             if (!warnings.isEmpty()) {
1203                 System.out.println();
1204                 System.out.println(rb.getString(&quot;Warning.&quot;));
1205                 warnings.forEach(System.out::println);
1206             }
1207         } else {
1208             if (!errors.isEmpty() || !warnings.isEmpty()) {
1209                 System.out.println();
1210                 System.out.println(rb.getString(&quot;Warning.&quot;));
1211                 errors.forEach(System.out::println);
1212                 warnings.forEach(System.out::println);
1213             }
1214         }
1215         if (!isSigning &amp;&amp; (!errors.isEmpty() || !warnings.isEmpty())) {
1216             if (! (verbose != null &amp;&amp; showcerts)) {
1217                 System.out.println();
1218                 System.out.println(rb.getString(
1219                         &quot;Re.run.with.the.verbose.and.certs.options.for.more.details.&quot;));
1220             }
1221         }
1222 
1223         if (isSigning || verbose != null) {
1224             // Always print out expireDate, unless expired or expiring.
1225             if (!hasExpiringCert &amp;&amp; !hasExpiredCert
1226                     &amp;&amp; expireDate != null &amp;&amp; signerNotExpired) {
1227                 info.add(String.format(rb.getString(
1228                         &quot;The.signer.certificate.will.expire.on.1.&quot;), expireDate));
1229             }
1230             if (!noTimestamp) {
1231                 if (!hasExpiringTsaCert &amp;&amp; !hasExpiredTsaCert &amp;&amp; tsaExpireDate != null) {
1232                     if (signerNotExpired) {
1233                         info.add(String.format(rb.getString(
1234                                 &quot;The.timestamp.will.expire.on.1.&quot;), tsaExpireDate));
1235                     } else {
1236                         info.add(String.format(rb.getString(
1237                                 &quot;signer.cert.expired.1.but.timestamp.good.2.&quot;),
1238                                 expireDate,
1239                                 tsaExpireDate));
1240                     }
1241                 }
1242             }
1243         }
1244 
1245         if (!info.isEmpty()) {
1246             System.out.println();
1247             info.forEach(System.out::println);
1248         }
1249     }
1250 
1251     private String withWeak(String alg, Set&lt;CryptoPrimitive&gt; primitiveSet) {
1252         if (DISABLED_CHECK.permits(primitiveSet, alg, null)) {
1253             return alg;
1254         } else {
1255             seeWeak = true;
1256             return String.format(rb.getString(&quot;with.weak&quot;), alg);
1257         }
1258     }
1259 
1260     private String withWeak(PublicKey key) {
1261         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1262             int kLen = KeyUtil.getKeySize(key);
1263             if (kLen &gt;= 0) {
1264                 return String.format(rb.getString(&quot;key.bit&quot;), kLen);
1265             } else {
1266                 return rb.getString(&quot;unknown.size&quot;);
1267             }
1268         } else {
1269             seeWeak = true;
1270             return String.format(
1271                     rb.getString(&quot;key.bit.weak&quot;), KeyUtil.getKeySize(key));
1272         }
1273     }
1274 
1275     private static MessageFormat validityTimeForm = null;
1276     private static MessageFormat notYetTimeForm = null;
1277     private static MessageFormat expiredTimeForm = null;
1278     private static MessageFormat expiringTimeForm = null;
1279 
1280     /**
1281      * Returns a string about a certificate:
1282      *
1283      * [&lt;tab&gt;] &lt;cert-type&gt; [&quot;, &quot; &lt;subject-DN&gt;] [&quot; (&quot; &lt;keystore-entry-alias&gt; &quot;)&quot;]
1284      * [&lt;validity-period&gt; | &lt;expiry-warning&gt;]
1285      * [&lt;key-usage-warning&gt;]
1286      *
1287      * Note: no newline character at the end.
1288      *
1289      * This method sets global flags like hasExpiringCert, hasExpiredCert,
1290      * notYetValidCert, badKeyUsage, badExtendedKeyUsage, badNetscapeCertType,
1291      * hasExpiringTsaCert, hasExpiredTsaCert.
1292      *
1293      * @param isTsCert true if c is in the TSA cert chain, false otherwise.
1294      * @param checkUsage true to check code signer keyUsage
1295      */
1296     String printCert(boolean isTsCert, String tab, Certificate c,
1297         Date timestamp, boolean checkUsage) throws Exception {
1298 
1299         StringBuilder certStr = new StringBuilder();
1300         String space = rb.getString(&quot;SPACE&quot;);
1301         X509Certificate x509Cert = null;
1302 
1303         if (c instanceof X509Certificate) {
1304             x509Cert = (X509Certificate) c;
1305             certStr.append(tab).append(x509Cert.getType())
1306                 .append(rb.getString(&quot;COMMA&quot;))
1307                 .append(x509Cert.getSubjectDN().getName());
1308         } else {
1309             certStr.append(tab).append(c.getType());
1310         }
1311 
1312         String alias = storeHash.get(c);
1313         if (alias != null) {
1314             certStr.append(space).append(&quot;(&quot;).append(alias).append(&quot;)&quot;);
1315         }
1316 
1317         if (x509Cert != null) {
1318 
1319             certStr.append(&quot;\n&quot;).append(tab).append(&quot;[&quot;);
1320 
1321             if (trustedCerts.contains(x509Cert)) {
1322                 certStr.append(rb.getString(&quot;trusted.certificate&quot;));
1323             } else {
1324                 Date notAfter = x509Cert.getNotAfter();
1325                 try {
1326                     boolean printValidity = true;
1327                     if (isTsCert) {
1328                         if (tsaExpireDate == null || tsaExpireDate.after(notAfter)) {
1329                             tsaExpireDate = notAfter;
1330                         }
1331                     } else {
1332                         if (expireDate == null || expireDate.after(notAfter)) {
1333                             expireDate = notAfter;
1334                         }
1335                     }
1336                     if (timestamp == null) {
1337                         x509Cert.checkValidity();
1338                         // test if cert will expire within six months (or one year for tsa)
1339                         long age = isTsCert ? ONE_YEAR : SIX_MONTHS;
1340                         if (notAfter.getTime() &lt; System.currentTimeMillis() + age) {
1341                             if (isTsCert) {
1342                                 hasExpiringTsaCert = true;
1343                             } else {
1344                                 hasExpiringCert = true;
1345                             }
1346                             if (expiringTimeForm == null) {
1347                                 expiringTimeForm = new MessageFormat(
1348                                         rb.getString(&quot;certificate.will.expire.on&quot;));
1349                             }
1350                             Object[] source = {notAfter};
1351                             certStr.append(expiringTimeForm.format(source));
1352                             printValidity = false;
1353                         }
1354                     } else {
1355                         x509Cert.checkValidity(timestamp);
1356                     }
1357                     if (printValidity) {
1358                         if (validityTimeForm == null) {
1359                             validityTimeForm = new MessageFormat(
1360                                     rb.getString(&quot;certificate.is.valid.from&quot;));
1361                         }
1362                         Object[] source = {x509Cert.getNotBefore(), notAfter};
1363                         certStr.append(validityTimeForm.format(source));
1364                     }
1365                 } catch (CertificateExpiredException cee) {
1366                     if (isTsCert) {
1367                         hasExpiredTsaCert = true;
1368                     } else {
1369                         hasExpiredCert = true;
1370                     }
1371 
1372                     if (expiredTimeForm == null) {
1373                         expiredTimeForm = new MessageFormat(
1374                                 rb.getString(&quot;certificate.expired.on&quot;));
1375                     }
1376                     Object[] source = {notAfter};
1377                     certStr.append(expiredTimeForm.format(source));
1378 
1379                 } catch (CertificateNotYetValidException cnyve) {
1380                     if (!isTsCert) notYetValidCert = true;
1381 
1382                     if (notYetTimeForm == null) {
1383                         notYetTimeForm = new MessageFormat(
1384                                 rb.getString(&quot;certificate.is.not.valid.until&quot;));
1385                     }
1386                     Object[] source = {x509Cert.getNotBefore()};
1387                     certStr.append(notYetTimeForm.format(source));
1388                 }
1389             }
1390             certStr.append(&quot;]&quot;);
1391 
1392             if (checkUsage) {
1393                 boolean[] bad = new boolean[3];
1394                 checkCertUsage(x509Cert, bad);
1395                 if (bad[0] || bad[1] || bad[2]) {
1396                     String x = &quot;&quot;;
1397                     if (bad[0]) {
1398                         x =&quot;KeyUsage&quot;;
1399                     }
1400                     if (bad[1]) {
1401                         if (x.length() &gt; 0) x = x + &quot;, &quot;;
1402                         x = x + &quot;ExtendedKeyUsage&quot;;
1403                     }
1404                     if (bad[2]) {
1405                         if (x.length() &gt; 0) x = x + &quot;, &quot;;
1406                         x = x + &quot;NetscapeCertType&quot;;
1407                     }
1408                     certStr.append(&quot;\n&quot;).append(tab)
1409                         .append(MessageFormat.format(rb.getString(
1410                         &quot;.{0}.extension.does.not.support.code.signing.&quot;), x));
1411                 }
1412             }
1413         }
1414         return certStr.toString();
1415     }
1416 
1417     private static MessageFormat signTimeForm = null;
1418 
1419     private String printTimestamp(String tab, Timestamp timestamp) {
1420 
1421         if (signTimeForm == null) {
1422             signTimeForm =
1423                 new MessageFormat(rb.getString(&quot;entry.was.signed.on&quot;));
1424         }
1425         Object[] source = { timestamp.getTimestamp() };
1426 
1427         return new StringBuilder().append(tab).append(&quot;[&quot;)
1428             .append(signTimeForm.format(source)).append(&quot;]&quot;).toString();
1429     }
1430 
1431     private Map&lt;CodeSigner,Integer&gt; cacheForInKS = new IdentityHashMap&lt;&gt;();
1432 
1433     private int inKeyStoreForOneSigner(CodeSigner signer) {
1434         if (cacheForInKS.containsKey(signer)) {
1435             return cacheForInKS.get(signer);
1436         }
1437 
1438         int result = 0;
1439         if (store != null) {
1440             try {
1441                 List&lt;? extends Certificate&gt; certs =
1442                         signer.getSignerCertPath().getCertificates();
1443                 for (Certificate c : certs) {
1444                     String alias = storeHash.get(c);
1445                     if (alias == null) {
1446                         alias = store.getCertificateAlias(c);
1447                         if (alias != null) {
1448                             storeHash.put(c, alias);
1449                         }
1450                     }
1451                     if (alias != null) {
1452                         result |= IN_KEYSTORE;
1453                     }
1454                     for (String ckalias : ckaliases) {
1455                         if (c.equals(store.getCertificate(ckalias))) {
1456                             result |= SIGNED_BY_ALIAS;
1457                             // must continue with next certificate c and cannot
1458                             // return or break outer loop because has to fill
1459                             // storeHash for printCert
1460                             break;
1461                         }
1462                     }
1463                 }
1464             } catch (KeyStoreException kse) {
1465                 // never happens, because keystore has been loaded
1466             }
1467         }
1468         cacheForInKS.put(signer, result);
1469         return result;
1470     }
1471 
1472     /**
1473      * Maps certificates (as keys) to alias names associated in the keystore
1474      * {@link #store} (as values).
1475      */
1476     Hashtable&lt;Certificate, String&gt; storeHash = new Hashtable&lt;&gt;();
1477 
1478     int inKeyStore(CodeSigner[] signers) {
1479 
1480         if (signers == null)
1481             return 0;
1482 
1483         int output = 0;
1484 
1485         for (CodeSigner signer: signers) {
1486             int result = inKeyStoreForOneSigner(signer);
1487             output |= result;
1488         }
1489         if (ckaliases.size() &gt; 0 &amp;&amp; (output &amp; SIGNED_BY_ALIAS) == 0) {
1490             output |= NOT_ALIAS;
1491         }
1492         return output;
1493     }
1494 
1495     void signJar(String jarName, String alias)
1496             throws Exception {
1497 
1498         if (digestalg != null &amp;&amp; !DISABLED_CHECK.permits(
1499                 DIGEST_PRIMITIVE_SET, digestalg, null)) {
1500             weakAlg |= 1;
1501         }
1502         if (tSADigestAlg != null &amp;&amp; !DISABLED_CHECK.permits(
1503                 DIGEST_PRIMITIVE_SET, tSADigestAlg, null)) {
1504             weakAlg |= 4;
1505         }
1506         if (sigalg != null &amp;&amp; !DISABLED_CHECK.permits(
1507                 SIG_PRIMITIVE_SET , sigalg, null)) {
1508             weakAlg |= 2;
1509         }
1510         if (!DISABLED_CHECK.permits(
1511                 SIG_PRIMITIVE_SET, privateKey)) {
1512             weakAlg |= 8;
1513         }
1514 
1515         boolean aliasUsed = false;
1516         X509Certificate tsaCert = null;
1517 
1518         if (sigfile == null) {
1519             sigfile = alias;
1520             aliasUsed = true;
1521         }
1522 
1523         if (sigfile.length() &gt; 8) {
1524             sigfile = sigfile.substring(0, 8).toUpperCase(Locale.ENGLISH);
1525         } else {
1526             sigfile = sigfile.toUpperCase(Locale.ENGLISH);
1527         }
1528 
1529         StringBuilder tmpSigFile = new StringBuilder(sigfile.length());
1530         for (int j = 0; j &lt; sigfile.length(); j++) {
1531             char c = sigfile.charAt(j);
1532             if (!
1533                     ((c&gt;= &#39;A&#39; &amp;&amp; c&lt;= &#39;Z&#39;) ||
1534                             (c&gt;= &#39;0&#39; &amp;&amp; c&lt;= &#39;9&#39;) ||
1535                             (c == &#39;-&#39;) ||
1536                             (c == &#39;_&#39;))) {
1537                 if (aliasUsed) {
1538                     // convert illegal characters from the alias to be _&#39;s
1539                     c = &#39;_&#39;;
1540                 } else {
1541                     throw new
1542                             RuntimeException(rb.getString
1543                             (&quot;signature.filename.must.consist.of.the.following.characters.A.Z.0.9.or.&quot;));
1544                 }
1545             }
1546             tmpSigFile.append(c);
1547         }
1548 
1549         sigfile = tmpSigFile.toString();
1550 
1551         String tmpJarName;
1552         if (signedjar == null) tmpJarName = jarName+&quot;.sig&quot;;
1553         else tmpJarName = signedjar;
1554 
1555         File jarFile = new File(jarName);
1556         File signedJarFile = new File(tmpJarName);
1557 
1558         // Open the jar (zip) file
1559         try {
1560             zipFile = new ZipFile(jarName);
1561         } catch (IOException ioe) {
1562             error(rb.getString(&quot;unable.to.open.jar.file.&quot;)+jarName, ioe);
1563         }
1564 
1565         CertPath cp = CertificateFactory.getInstance(&quot;X.509&quot;)
1566                 .generateCertPath(Arrays.asList(certChain));
1567         JarSigner.Builder builder = new JarSigner.Builder(privateKey, cp);
1568 
1569         if (verbose != null) {
1570             builder.eventHandler((action, file) -&gt; {
1571                 switch (action) {
1572                     case &quot;signing&quot;:
1573                         System.out.println(rb.getString(&quot;.signing.&quot;) + file);
1574                         break;
1575                     case &quot;adding&quot;:
1576                         System.out.println(rb.getString(&quot;.adding.&quot;) + file);
1577                         break;
1578                     case &quot;updating&quot;:
1579                         System.out.println(rb.getString(&quot;.updating.&quot;) + file);
1580                         break;
1581                     default:
1582                         throw new IllegalArgumentException(&quot;unknown action: &quot;
1583                                 + action);
1584                 }
1585             });
1586         }
1587 
1588         if (digestalg != null) {
1589             builder.digestAlgorithm(digestalg);
1590         }
1591         if (sigalg != null) {
1592             builder.signatureAlgorithm(sigalg);
1593         }
1594 
1595         URI tsaURI = null;
1596 
1597         if (tsaUrl != null) {
1598             tsaURI = new URI(tsaUrl);
1599         } else if (tsaAlias != null) {
1600             tsaCert = getTsaCert(tsaAlias);
1601             tsaURI = TimestampedSigner.getTimestampingURI(tsaCert);
1602         }
1603 
1604         if (tsaURI != null) {
1605             if (verbose != null) {
1606                 System.out.println(
1607                         rb.getString(&quot;requesting.a.signature.timestamp&quot;));
1608                 if (tsaUrl != null) {
1609                     System.out.println(rb.getString(&quot;TSA.location.&quot;) + tsaUrl);
1610                 } else if (tsaCert != null) {
1611                     System.out.println(rb.getString(&quot;TSA.certificate.&quot;) +
1612                             printCert(true, &quot;&quot;, tsaCert, null, false));
1613                 }
1614             }
1615             builder.tsa(tsaURI);
1616             if (tSADigestAlg != null) {
1617                 builder.setProperty(&quot;tsaDigestAlg&quot;, tSADigestAlg);
1618             }
1619 
1620             if (tSAPolicyID != null) {
1621                 builder.setProperty(&quot;tsaPolicyId&quot;, tSAPolicyID);
1622             }
1623         }
1624 
1625         if (altSignerClass != null) {
1626             builder.setProperty(&quot;altSigner&quot;, altSignerClass);
1627             if (verbose != null) {
1628                 System.out.println(
1629                         rb.getString(&quot;using.an.alternative.signing.mechanism&quot;));
1630             }
1631         }
1632 
1633         if (altSignerClasspath != null) {
1634             builder.setProperty(&quot;altSignerPath&quot;, altSignerClasspath);
1635         }
1636 
1637         builder.signerName(sigfile);
1638 
1639         builder.setProperty(&quot;sectionsOnly&quot;, Boolean.toString(!signManifest));
1640         builder.setProperty(&quot;internalSF&quot;, Boolean.toString(!externalSF));
1641 
1642         FileOutputStream fos = null;
1643         try {
1644             fos = new FileOutputStream(signedJarFile);
1645         } catch (IOException ioe) {
1646             error(rb.getString(&quot;unable.to.create.&quot;)+tmpJarName, ioe);
1647         }
1648 
1649         Throwable failedCause = null;
1650         String failedMessage = null;
1651 
1652         try {
1653             builder.build().sign(zipFile, fos);
1654         } catch (JarSignerException e) {
1655             failedCause = e.getCause();
1656             if (failedCause instanceof SocketTimeoutException
1657                     || failedCause instanceof UnknownHostException) {
1658                 // Provide a helpful message when TSA is beyond a firewall
1659                 failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) +
1660                         rb.getString(&quot;no.response.from.the.Timestamping.Authority.&quot;) +
1661                         &quot;\n  -J-Dhttp.proxyHost=&lt;hostname&gt;&quot; +
1662                         &quot;\n  -J-Dhttp.proxyPort=&lt;portnumber&gt;\n&quot; +
1663                         rb.getString(&quot;or&quot;) +
1664                         &quot;\n  -J-Dhttps.proxyHost=&lt;hostname&gt; &quot; +
1665                         &quot;\n  -J-Dhttps.proxyPort=&lt;portnumber&gt; &quot;;
1666             } else {
1667                 // JarSignerException might have a null cause
1668                 if (failedCause == null) {
1669                     failedCause = e;
1670                 }
1671                 failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) + failedCause;
1672             }
1673         } catch (Exception e) {
1674             failedCause = e;
1675             failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) + failedCause;
1676         } finally {
1677             // close the resources
1678             if (zipFile != null) {
1679                 zipFile.close();
1680                 zipFile = null;
1681             }
1682 
1683             if (fos != null) {
1684                 fos.close();
1685             }
1686 
1687         }
1688 
1689         if (failedCause != null) {
1690             signedJarFile.delete();
1691             error(failedMessage, failedCause);
1692         }
1693 
1694         if (verbose != null) {
1695             System.out.println();
1696         }
1697 
1698         // The JarSigner API always accepts the timestamp received.
1699         // We need to extract the certs from the signed jar to
1700         // validate it.
1701         try (JarFile check = new JarFile(signedJarFile)) {
1702             PKCS7 p7 = new PKCS7(check.getInputStream(check.getEntry(
1703                     &quot;META-INF/&quot; + sigfile + &quot;.&quot; + privateKey.getAlgorithm())));
1704             Timestamp ts = null;
1705             try {
1706                 SignerInfo si = p7.getSignerInfos()[0];
1707                 if (si.getTsToken() != null) {
1708                     hasTimestampBlock = true;
1709                 }
1710                 ts = si.getTimestamp();
1711             } catch (Exception e) {
1712                 tsaChainNotValidated = true;
1713                 tsaChainNotValidatedReason = e;
1714             }
1715             // Spaces before the &quot;&gt;&gt;&gt; Signer&quot; and other lines are different
1716             String result = certsAndTSInfo(&quot;&quot;, &quot;    &quot;, Arrays.asList(certChain), ts);
1717             if (verbose != null) {
1718                 System.out.println(result);
1719             }
1720         } catch (Exception e) {
1721             if (debug) {
1722                 e.printStackTrace();
1723             }
1724         }
1725 
1726         if (signedjar == null) {
1727             // attempt an atomic rename. If that fails,
1728             // rename the original jar file, then the signed
1729             // one, then delete the original.
1730             if (!signedJarFile.renameTo(jarFile)) {
1731                 File origJar = new File(jarName+&quot;.orig&quot;);
1732 
1733                 if (jarFile.renameTo(origJar)) {
1734                     if (signedJarFile.renameTo(jarFile)) {
1735                         origJar.delete();
1736                     } else {
1737                         MessageFormat form = new MessageFormat(rb.getString
1738                     (&quot;attempt.to.rename.signedJarFile.to.jarFile.failed&quot;));
1739                         Object[] source = {signedJarFile, jarFile};
1740                         error(form.format(source));
1741                     }
1742                 } else {
1743                     MessageFormat form = new MessageFormat(rb.getString
1744                         (&quot;attempt.to.rename.jarFile.to.origJar.failed&quot;));
1745                     Object[] source = {jarFile, origJar};
1746                     error(form.format(source));
1747                 }
1748             }
1749         }
1750 
1751         displayMessagesAndResult(true);
1752     }
1753 
1754     /**
1755      * signature-related files include:
1756      * . META-INF/MANIFEST.MF
1757      * . META-INF/SIG-*
1758      * . META-INF/*.SF
1759      * . META-INF/*.DSA
1760      * . META-INF/*.RSA
1761      * . META-INF/*.EC
1762      */
1763     private boolean signatureRelated(String name) {
1764         return SignatureFileVerifier.isSigningRelated(name);
1765     }
1766 
1767     Map&lt;CodeSigner,String&gt; cacheForSignerInfo = new IdentityHashMap&lt;&gt;();
1768 
1769     /**
1770      * Returns a string of signer info, with a newline at the end.
1771      * Called by verifyJar().
1772      */
1773     private String signerInfo(CodeSigner signer, String tab) throws Exception {
1774         if (cacheForSignerInfo.containsKey(signer)) {
1775             return cacheForSignerInfo.get(signer);
1776         }
1777         List&lt;? extends Certificate&gt; certs = signer.getSignerCertPath().getCertificates();
1778         // signing time is only displayed on verification
1779         Timestamp ts = signer.getTimestamp();
1780         String tsLine = &quot;&quot;;
1781         if (ts != null) {
1782             tsLine = printTimestamp(tab, ts) + &quot;\n&quot;;
1783         }
1784         // Spaces before the &quot;&gt;&gt;&gt; Signer&quot; and other lines are the same.
1785 
1786         String result = certsAndTSInfo(tab, tab, certs, ts);
1787         cacheForSignerInfo.put(signer, tsLine + result);
1788         return result;
1789     }
1790 
1791     /**
1792      * Fills info on certs and timestamp into a StringBuilder, sets
1793      * warning flags (through printCert) and validates cert chains.
1794      *
1795      * @param tab1 spaces before the &quot;&gt;&gt;&gt; Signer&quot; line
1796      * @param tab2 spaces before the other lines
1797      * @param certs the signer cert
1798      * @param ts the timestamp, can be null
1799      * @return the info as a string
1800      */
1801     private String certsAndTSInfo(
1802             String tab1,
1803             String tab2,
1804             List&lt;? extends Certificate&gt; certs, Timestamp ts)
1805             throws Exception {
1806 
1807         Date timestamp;
1808         if (ts != null) {
1809             timestamp = ts.getTimestamp();
1810             noTimestamp = false;
1811         } else {
1812             timestamp = null;
1813         }
1814         // display the certificate(sb). The first one is end-entity cert and
1815         // its KeyUsage should be checked.
1816         boolean first = true;
1817         StringBuilder sb = new StringBuilder();
1818         sb.append(tab1).append(rb.getString(&quot;...Signer&quot;)).append(&#39;\n&#39;);
1819         for (Certificate c : certs) {
1820             sb.append(printCert(false, tab2, c, timestamp, first));
1821             sb.append(&#39;\n&#39;);
1822             first = false;
1823         }
1824         try {
1825             validateCertChain(Validator.VAR_CODE_SIGNING, certs, ts);
1826         } catch (Exception e) {
1827             chainNotValidated = true;
1828             chainNotValidatedReason = e;
1829             sb.append(tab2).append(rb.getString(&quot;.Invalid.certificate.chain.&quot;))
1830                     .append(e.getLocalizedMessage()).append(&quot;]\n&quot;);
1831         }
1832         if (ts != null) {
1833             sb.append(tab1).append(rb.getString(&quot;...TSA&quot;)).append(&#39;\n&#39;);
1834             for (Certificate c : ts.getSignerCertPath().getCertificates()) {
1835                 sb.append(printCert(true, tab2, c, null, false));
1836                 sb.append(&#39;\n&#39;);
1837             }
1838             try {
1839                 validateCertChain(Validator.VAR_TSA_SERVER,
1840                         ts.getSignerCertPath().getCertificates(), null);
1841             } catch (Exception e) {
1842                 tsaChainNotValidated = true;
1843                 tsaChainNotValidatedReason = e;
1844                 sb.append(tab2).append(rb.getString(&quot;.Invalid.TSA.certificate.chain.&quot;))
1845                         .append(e.getLocalizedMessage()).append(&quot;]\n&quot;);
1846             }
1847         }
1848         if (certs.size() == 1
1849                 &amp;&amp; KeyStoreUtil.isSelfSigned((X509Certificate)certs.get(0))) {
1850             signerSelfSigned = true;
1851         }
1852 
1853         return sb.toString();
1854     }
1855 
1856     void loadKeyStore(String keyStoreName, boolean prompt) {
1857 
1858         if (!nullStream &amp;&amp; keyStoreName == null) {
1859             keyStoreName = System.getProperty(&quot;user.home&quot;) + File.separator
1860                 + &quot;.keystore&quot;;
1861         }
1862 
1863         try {
1864             try {
1865                 KeyStore caks = KeyStoreUtil.getCacertsKeyStore();
1866                 if (caks != null) {
1867                     Enumeration&lt;String&gt; aliases = caks.aliases();
1868                     while (aliases.hasMoreElements()) {
1869                         String a = aliases.nextElement();
1870                         try {
1871                             trustedCerts.add((X509Certificate)caks.getCertificate(a));
1872                         } catch (Exception e2) {
1873                             // ignore, when a SecretkeyEntry does not include a cert
1874                         }
1875                     }
1876                 }
1877             } catch (Exception e) {
1878                 // Ignore, if cacerts cannot be loaded
1879             }
1880 
1881             if (providerName == null) {
1882                 store = KeyStore.getInstance(storetype);
1883             } else {
1884                 store = KeyStore.getInstance(storetype, providerName);
1885             }
1886 
1887             // Get pass phrase
1888             // XXX need to disable echo; on UNIX, call getpass(char *prompt)Z
1889             // and on NT call ??
1890             if (token &amp;&amp; storepass == null &amp;&amp; !protectedPath
1891                     &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)) {
1892                 storepass = getPass
1893                         (rb.getString(&quot;Enter.Passphrase.for.keystore.&quot;));
1894             } else if (!token &amp;&amp; storepass == null &amp;&amp; prompt) {
1895                 storepass = getPass
1896                         (rb.getString(&quot;Enter.Passphrase.for.keystore.&quot;));
1897             }
1898 
1899             try {
1900                 if (nullStream) {
1901                     store.load(null, storepass);
1902                 } else {
1903                     keyStoreName = keyStoreName.replace(File.separatorChar, &#39;/&#39;);
1904                     URL url = null;
1905                     try {
1906                         url = new URL(keyStoreName);
1907                     } catch (java.net.MalformedURLException e) {
1908                         // try as file
1909                         url = new File(keyStoreName).toURI().toURL();
1910                     }
1911                     InputStream is = null;
1912                     try {
1913                         is = url.openStream();
1914                         store.load(is, storepass);
1915                     } finally {
1916                         if (is != null) {
1917                             is.close();
1918                         }
1919                     }
1920                 }
1921                 Enumeration&lt;String&gt; aliases = store.aliases();
1922                 while (aliases.hasMoreElements()) {
1923                     String a = aliases.nextElement();
1924                     try {
1925                         X509Certificate c = (X509Certificate)store.getCertificate(a);
1926                         // Only add TrustedCertificateEntry and self-signed
1927                         // PrivateKeyEntry
1928                         if (store.isCertificateEntry(a) ||
1929                                 c.getSubjectDN().equals(c.getIssuerDN())) {
1930                             trustedCerts.add(c);
1931                         }
1932                     } catch (Exception e2) {
1933                         // ignore, when a SecretkeyEntry does not include a cert
1934                     }
1935                 }
1936             } finally {
1937                 try {
1938                     pkixParameters = new PKIXBuilderParameters(
1939                             trustedCerts.stream()
1940                                     .map(c -&gt; new TrustAnchor(c, null))
1941                                     .collect(Collectors.toSet()),
1942                             null);
1943                     pkixParameters.setRevocationEnabled(false);
1944                 } catch (InvalidAlgorithmParameterException ex) {
1945                     // Only if tas is empty
1946                 }
1947             }
1948         } catch (IOException ioe) {
1949             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
1950                                         ioe.getMessage());
1951         } catch (java.security.cert.CertificateException ce) {
1952             throw new RuntimeException(rb.getString(&quot;certificate.exception.&quot;) +
1953                                         ce.getMessage());
1954         } catch (NoSuchProviderException pe) {
1955             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
1956                                         pe.getMessage());
1957         } catch (NoSuchAlgorithmException nsae) {
1958             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
1959                                         nsae.getMessage());
1960         } catch (KeyStoreException kse) {
1961             throw new RuntimeException
1962                 (rb.getString(&quot;unable.to.instantiate.keystore.class.&quot;) +
1963                 kse.getMessage());
1964         }
1965     }
1966 
1967     X509Certificate getTsaCert(String alias) {
1968 
1969         java.security.cert.Certificate cs = null;
1970 
1971         try {
1972             cs = store.getCertificate(alias);
1973         } catch (KeyStoreException kse) {
1974             // this never happens, because keystore has been loaded
1975         }
1976         if (cs == null || (!(cs instanceof X509Certificate))) {
1977             MessageFormat form = new MessageFormat(rb.getString
1978                 (&quot;Certificate.not.found.for.alias.alias.must.reference.a.valid.KeyStore.entry.containing.an.X.509.public.key.certificate.for.the&quot;));
1979             Object[] source = {alias, alias};
1980             error(form.format(source));
1981         }
1982         return (X509Certificate) cs;
1983     }
1984 
1985     /**
1986      * Check if userCert is designed to be a code signer
1987      * @param userCert the certificate to be examined
1988      * @param bad 3 booleans to show if the KeyUsage, ExtendedKeyUsage,
1989      *            NetscapeCertType has codeSigning flag turned on.
1990      *            If null, the class field badKeyUsage, badExtendedKeyUsage,
1991      *            badNetscapeCertType will be set.
1992      */
1993     void checkCertUsage(X509Certificate userCert, boolean[] bad) {
1994 
1995         // Can act as a signer?
1996         // 1. if KeyUsage, then [0:digitalSignature] or
1997         //    [1:nonRepudiation] should be true
1998         // 2. if ExtendedKeyUsage, then should contains ANY or CODE_SIGNING
1999         // 3. if NetscapeCertType, then should contains OBJECT_SIGNING
2000         // 1,2,3 must be true
2001 
2002         if (bad != null) {
2003             bad[0] = bad[1] = bad[2] = false;
2004         }
2005 
2006         boolean[] keyUsage = userCert.getKeyUsage();
2007         if (keyUsage != null) {
2008             keyUsage = Arrays.copyOf(keyUsage, 9);
2009             if (!keyUsage[0] &amp;&amp; !keyUsage[1]) {
2010                 if (bad != null) {
2011                     bad[0] = true;
2012                     badKeyUsage = true;
2013                 }
2014             }
2015         }
2016 
2017         try {
2018             List&lt;String&gt; xKeyUsage = userCert.getExtendedKeyUsage();
2019             if (xKeyUsage != null) {
2020                 if (!xKeyUsage.contains(&quot;2.5.29.37.0&quot;) // anyExtendedKeyUsage
2021                         &amp;&amp; !xKeyUsage.contains(&quot;1.3.6.1.5.5.7.3.3&quot;)) {  // codeSigning
2022                     if (bad != null) {
2023                         bad[1] = true;
2024                         badExtendedKeyUsage = true;
2025                     }
2026                 }
2027             }
2028         } catch (java.security.cert.CertificateParsingException e) {
2029             // shouldn&#39;t happen
2030         }
2031 
2032         try {
2033             // OID_NETSCAPE_CERT_TYPE
2034             byte[] netscapeEx = userCert.getExtensionValue
2035                     (&quot;2.16.840.1.113730.1.1&quot;);
2036             if (netscapeEx != null) {
2037                 DerInputStream in = new DerInputStream(netscapeEx);
2038                 byte[] encoded = in.getOctetString();
2039                 encoded = new DerValue(encoded).getUnalignedBitString()
2040                         .toByteArray();
2041 
2042                 NetscapeCertTypeExtension extn =
2043                         new NetscapeCertTypeExtension(encoded);
2044 
2045                 Boolean val = extn.get(NetscapeCertTypeExtension.OBJECT_SIGNING);
2046                 if (!val) {
2047                     if (bad != null) {
2048                         bad[2] = true;
2049                         badNetscapeCertType = true;
2050                     }
2051                 }
2052             }
2053         } catch (IOException e) {
2054             //
2055         }
2056     }
2057 
2058     // Called by signJar().
2059     void getAliasInfo(String alias) throws Exception {
2060 
2061         Key key = null;
2062 
2063         try {
2064             java.security.cert.Certificate[] cs = null;
2065             if (altCertChain != null) {
2066                 try (FileInputStream fis = new FileInputStream(altCertChain)) {
2067                     cs = CertificateFactory.getInstance(&quot;X.509&quot;).
2068                             generateCertificates(fis).
2069                             toArray(new Certificate[0]);
2070                 } catch (FileNotFoundException ex) {
2071                     error(rb.getString(&quot;File.specified.by.certchain.does.not.exist&quot;));
2072                 } catch (CertificateException | IOException ex) {
2073                     error(rb.getString(&quot;Cannot.restore.certchain.from.file.specified&quot;));
2074                 }
2075             } else {
2076                 try {
2077                     cs = store.getCertificateChain(alias);
2078                 } catch (KeyStoreException kse) {
2079                     // this never happens, because keystore has been loaded
2080                 }
2081             }
2082             if (cs == null || cs.length == 0) {
2083                 if (altCertChain != null) {
2084                     error(rb.getString
2085                             (&quot;Certificate.chain.not.found.in.the.file.specified.&quot;));
2086                 } else {
2087                     MessageFormat form = new MessageFormat(rb.getString
2088                         (&quot;Certificate.chain.not.found.for.alias.alias.must.reference.a.valid.KeyStore.key.entry.containing.a.private.key.and&quot;));
2089                     Object[] source = {alias, alias};
2090                     error(form.format(source));
2091                 }
2092             }
2093 
2094             certChain = new X509Certificate[cs.length];
2095             for (int i=0; i&lt;cs.length; i++) {
2096                 if (!(cs[i] instanceof X509Certificate)) {
2097                     error(rb.getString
2098                         (&quot;found.non.X.509.certificate.in.signer.s.chain&quot;));
2099                 }
2100                 certChain[i] = (X509Certificate)cs[i];
2101             }
2102 
2103             try {
2104                 if (!token &amp;&amp; keypass == null)
2105                     key = store.getKey(alias, storepass);
2106                 else
2107                     key = store.getKey(alias, keypass);
2108             } catch (UnrecoverableKeyException e) {
2109                 if (token) {
2110                     throw e;
2111                 } else if (keypass == null) {
2112                     // Did not work out, so prompt user for key password
2113                     MessageFormat form = new MessageFormat(rb.getString
2114                         (&quot;Enter.key.password.for.alias.&quot;));
2115                     Object[] source = {alias};
2116                     keypass = getPass(form.format(source));
2117                     key = store.getKey(alias, keypass);
2118                 }
2119             }
2120         } catch (NoSuchAlgorithmException e) {
2121             error(e.getMessage());
2122         } catch (UnrecoverableKeyException e) {
2123             error(rb.getString(&quot;unable.to.recover.key.from.keystore&quot;));
2124         } catch (KeyStoreException kse) {
2125             // this never happens, because keystore has been loaded
2126         }
2127 
2128         if (!(key instanceof PrivateKey)) {
2129             MessageFormat form = new MessageFormat(rb.getString
2130                 (&quot;key.associated.with.alias.not.a.private.key&quot;));
2131             Object[] source = {alias};
2132             error(form.format(source));
2133         } else {
2134             privateKey = (PrivateKey)key;
2135         }
2136     }
2137 
2138     void error(String message) {
2139         System.out.println(rb.getString(&quot;jarsigner.&quot;)+message);
2140         System.exit(1);
2141     }
2142 
2143 
2144     void error(String message, Throwable e) {
2145         System.out.println(rb.getString(&quot;jarsigner.&quot;)+message);
2146         if (debug) {
2147             e.printStackTrace();
2148         }
2149         System.exit(1);
2150     }
2151 
2152     /**
2153      * Validates a cert chain.
2154      *
2155      * @param parameter this might be a timestamp
2156      */
2157     void validateCertChain(String variant, List&lt;? extends Certificate&gt; certs,
2158                            Timestamp parameter)
2159             throws Exception {
2160         try {
2161             Validator.getInstance(Validator.TYPE_PKIX,
2162                     variant,
2163                     pkixParameters)
2164                     .validate(certs.toArray(new X509Certificate[certs.size()]),
2165                             null, parameter);
2166         } catch (Exception e) {
2167             if (debug) {
2168                 e.printStackTrace();
2169             }
2170 
2171             // Exception might be dismissed if another warning flag
2172             // is already set by printCert.
2173 
2174             if (variant.equals(Validator.VAR_TSA_SERVER) &amp;&amp;
2175                     e instanceof ValidatorException) {
2176                 // Throw cause if it&#39;s CertPathValidatorException,
2177                 if (e.getCause() != null &amp;&amp;
2178                         e.getCause() instanceof CertPathValidatorException) {
2179                     e = (Exception) e.getCause();
2180                     Throwable t = e.getCause();
2181                     if ((t instanceof CertificateExpiredException &amp;&amp;
2182                             hasExpiredTsaCert)) {
2183                         // we already have hasExpiredTsaCert
2184                         return;
2185                     }
2186                 }
2187             }
2188 
2189             if (variant.equals(Validator.VAR_CODE_SIGNING) &amp;&amp;
2190                     e instanceof ValidatorException) {
2191                 // Throw cause if it&#39;s CertPathValidatorException,
2192                 if (e.getCause() != null &amp;&amp;
2193                         e.getCause() instanceof CertPathValidatorException) {
2194                     e = (Exception) e.getCause();
2195                     Throwable t = e.getCause();
2196                     if ((t instanceof CertificateExpiredException &amp;&amp;
2197                                 hasExpiredCert) ||
2198                             (t instanceof CertificateNotYetValidException &amp;&amp;
2199                                     notYetValidCert)) {
2200                         // we already have hasExpiredCert and notYetValidCert
2201                         return;
2202                     }
2203                 }
2204                 if (e instanceof ValidatorException) {
2205                     ValidatorException ve = (ValidatorException)e;
2206                     if (ve.getErrorType() == ValidatorException.T_EE_EXTENSIONS &amp;&amp;
2207                             (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType)) {
2208                         // We already have badKeyUsage, badExtendedKeyUsage
2209                         // and badNetscapeCertType
2210                         return;
2211                     }
2212                 }
2213             }
2214             throw e;
2215         }
2216     }
2217 
2218     char[] getPass(String prompt) {
2219         System.err.print(prompt);
2220         System.err.flush();
2221         try {
2222             char[] pass = Password.readPassword(System.in);
2223 
2224             if (pass == null) {
2225                 error(rb.getString(&quot;you.must.enter.key.password&quot;));
2226             } else {
2227                 return pass;
2228             }
2229         } catch (IOException ioe) {
2230             error(rb.getString(&quot;unable.to.read.password.&quot;)+ioe.getMessage());
2231         }
2232         // this shouldn&#39;t happen
2233         return null;
2234     }
2235 }
    </pre>
  </body>
</html>
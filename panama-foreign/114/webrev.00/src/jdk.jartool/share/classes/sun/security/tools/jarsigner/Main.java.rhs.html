<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.tools.jarsigner;
  27 
  28 import java.io.*;
  29 import java.net.UnknownHostException;
  30 import java.security.cert.CertPathValidatorException;
  31 import java.security.cert.PKIXBuilderParameters;
  32 import java.util.*;
  33 import java.util.stream.Collectors;
  34 import java.util.zip.*;
  35 import java.util.jar.*;
  36 import java.net.URI;
  37 import java.text.Collator;
  38 import java.text.MessageFormat;
  39 import java.security.cert.Certificate;
  40 import java.security.cert.X509Certificate;
  41 import java.security.cert.CertificateException;
  42 import java.security.*;
  43 
  44 import java.net.SocketTimeoutException;
  45 import java.net.URL;
  46 import java.security.cert.CertPath;
  47 import java.security.cert.CertificateExpiredException;
  48 import java.security.cert.CertificateFactory;
  49 import java.security.cert.CertificateNotYetValidException;
  50 import java.security.cert.TrustAnchor;
  51 import java.util.Map.Entry;
  52 
  53 import jdk.security.jarsigner.JarSigner;
  54 import jdk.security.jarsigner.JarSignerException;
  55 import sun.security.pkcs.PKCS7;
  56 import sun.security.pkcs.SignerInfo;
  57 import sun.security.timestamp.TimestampToken;
  58 import sun.security.tools.KeyStoreUtil;
  59 import sun.security.validator.Validator;
  60 import sun.security.validator.ValidatorException;
  61 import sun.security.x509.*;
  62 import sun.security.util.*;
  63 
  64 
  65 /**
  66  * &lt;p&gt;The jarsigner utility.
  67  *
  68  * The exit codes for the main method are:
  69  *
  70  * 0: success
  71  * 1: any error that the jar cannot be signed or verified, including:
  72  *      keystore loading error
  73  *      TSP communication error
  74  *      jarsigner command line error...
  75  * otherwise: error codes from -strict
  76  *
  77  * @author Roland Schemers
  78  * @author Jan Luehe
  79  */
  80 public class Main {
  81 
  82     // for i18n
  83     private static final java.util.ResourceBundle rb =
  84         java.util.ResourceBundle.getBundle
  85         (&quot;sun.security.tools.jarsigner.Resources&quot;);
  86     private static final Collator collator = Collator.getInstance();
  87     static {
  88         // this is for case insensitive string comparisions
  89         collator.setStrength(Collator.PRIMARY);
  90     }
  91 
  92     private static final String NONE = &quot;NONE&quot;;
  93     private static final String P11KEYSTORE = &quot;PKCS11&quot;;
  94 
  95     private static final long SIX_MONTHS = 180*24*60*60*1000L; //milliseconds
  96     private static final long ONE_YEAR = 366*24*60*60*1000L;
  97 
  98     private static final DisabledAlgorithmConstraints DISABLED_CHECK =
  99             new DisabledAlgorithmConstraints(
 100                     DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS);
 101 
 102     private static final Set&lt;CryptoPrimitive&gt; DIGEST_PRIMITIVE_SET = Collections
 103             .unmodifiableSet(EnumSet.of(CryptoPrimitive.MESSAGE_DIGEST));
 104     private static final Set&lt;CryptoPrimitive&gt; SIG_PRIMITIVE_SET = Collections
 105             .unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 106 
 107     static final String VERSION = &quot;1.0&quot;;
 108 
 109     static final int IN_KEYSTORE = 0x01;        // signer is in keystore
 110     static final int NOT_ALIAS = 0x04;          // alias list is NOT empty and
 111     // signer is not in alias list
 112     static final int SIGNED_BY_ALIAS = 0x08;    // signer is in alias list
 113 
 114     // Attention:
 115     // This is the entry that get launched by the security tool jarsigner.
 116     public static void main(String args[]) throws Exception {
 117         Main js = new Main();
 118         js.run(args);
 119     }
 120 
 121     X509Certificate[] certChain;    // signer&#39;s cert chain (when composing)
 122     PrivateKey privateKey;          // private key
 123     KeyStore store;                 // the keystore specified by -keystore
 124                                     // or the default keystore, never null
 125 
 126     String keystore; // key store file
 127     boolean nullStream = false; // null keystore input stream (NONE)
 128     boolean token = false; // token-based keystore
 129     String jarfile;  // jar files to sign or verify
 130     String alias;    // alias to sign jar with
 131     List&lt;String&gt; ckaliases = new ArrayList&lt;&gt;(); // aliases in -verify
 132     char[] storepass; // keystore password
 133     boolean protectedPath; // protected authentication path
 134     String storetype; // keystore type
 135     String providerName; // provider name
 136     List&lt;String&gt; providers = null; // list of provider names
 137     List&lt;String&gt; providerClasses = null; // list of provider classes
 138     // arguments for provider constructors
 139     HashMap&lt;String,String&gt; providerArgs = new HashMap&lt;&gt;();
 140     char[] keypass; // private key password
 141     String sigfile; // name of .SF file
 142     String sigalg; // name of signature algorithm
 143     String digestalg; // name of digest algorithm
 144     String signedjar; // output filename
 145     String tsaUrl; // location of the Timestamping Authority
 146     String tsaAlias; // alias for the Timestamping Authority&#39;s certificate
 147     String altCertChain; // file to read alternative cert chain from
 148     String tSAPolicyID;
 149     String tSADigestAlg;
 150     boolean verify = false; // verify the jar
 151     String verbose = null; // verbose output when signing/verifying
 152     boolean showcerts = false; // show certs when verifying
 153     boolean debug = false; // debug
 154     boolean signManifest = true; // &quot;sign&quot; the whole manifest
 155     boolean externalSF = true; // leave the .SF out of the PKCS7 block
 156     boolean strict = false;  // treat warnings as error
 157 
 158     // read zip entry raw bytes
 159     private String altSignerClass = null;
 160     private String altSignerClasspath = null;
 161     private ZipFile zipFile = null;
 162 
 163     // Informational warnings
 164     private boolean hasExpiringCert = false;
 165     private boolean hasExpiringTsaCert = false;
 166     private boolean noTimestamp = true;
 167 
 168     // Expiration date. The value could be null if signed by a trusted cert.
 169     private Date expireDate = null;
 170     private Date tsaExpireDate = null;
 171 
 172     // If there is a time stamp block inside the PKCS7 block file
 173     boolean hasTimestampBlock = false;
 174 
 175 
 176     // Severe warnings.
 177 
 178     // jarsigner used to check signer cert chain validity and key usages
 179     // itself and set various warnings. Later CertPath validation is
 180     // added but chainNotValidated is only flagged when no other existing
 181     // warnings are set. TSA cert chain check is added separately and
 182     // only tsaChainNotValidated is set, i.e. has no affect on hasExpiredCert,
 183     // notYetValidCert, or any badXyzUsage.
 184 
 185     private int weakAlg = 0; // 1. digestalg, 2. sigalg, 4. tsadigestalg
 186     private boolean hasExpiredCert = false;
 187     private boolean hasExpiredTsaCert = false;
 188     private boolean notYetValidCert = false;
 189     private boolean chainNotValidated = false;
 190     private boolean tsaChainNotValidated = false;
 191     private boolean notSignedByAlias = false;
 192     private boolean aliasNotInStore = false;
 193     private boolean hasUnsignedEntry = false;
 194     private boolean badKeyUsage = false;
 195     private boolean badExtendedKeyUsage = false;
 196     private boolean badNetscapeCertType = false;
 197     private boolean signerSelfSigned = false;
 198 
 199     private Throwable chainNotValidatedReason = null;
 200     private Throwable tsaChainNotValidatedReason = null;
 201 
 202     private boolean seeWeak = false;
 203 
 204     PKIXBuilderParameters pkixParameters;
 205     Set&lt;X509Certificate&gt; trustedCerts = new HashSet&lt;&gt;();
 206 
 207     public void run(String args[]) {
 208         try {
 209             args = parseArgs(args);
 210 
 211             // Try to load and install the specified providers
 212             if (providers != null) {
 213                 for (String provName: providers) {
 214                     try {
 215                         KeyStoreUtil.loadProviderByName(provName,
 216                                 providerArgs.get(provName));
 217                         if (debug) {
 218                             System.out.println(&quot;loadProviderByName: &quot; + provName);
 219                         }
 220                     } catch (IllegalArgumentException e) {
 221                         throw new Exception(String.format(rb.getString(
 222                                 &quot;provider.name.not.found&quot;), provName));
 223                     }
 224                 }
 225             }
 226 
 227             if (providerClasses != null) {
 228                 ClassLoader cl = ClassLoader.getSystemClassLoader();
 229                 for (String provClass: providerClasses) {
 230                     try {
 231                         KeyStoreUtil.loadProviderByClass(provClass,
 232                                 providerArgs.get(provClass), cl);
 233                         if (debug) {
 234                             System.out.println(&quot;loadProviderByClass: &quot; + provClass);
 235                         }
 236                     } catch (ClassCastException cce) {
 237                         throw new Exception(String.format(rb.getString(
 238                                 &quot;provclass.not.a.provider&quot;), provClass));
 239                     } catch (IllegalArgumentException e) {
 240                         throw new Exception(String.format(rb.getString(
 241                                 &quot;provider.class.not.found&quot;), provClass), e.getCause());
 242                     }
 243                 }
 244             }
 245 
 246             if (verify) {
 247                 try {
 248                     loadKeyStore(keystore, false);
 249                 } catch (Exception e) {
 250                     if ((keystore != null) || (storepass != null)) {
 251                         System.out.println(rb.getString(&quot;jarsigner.error.&quot;) +
 252                                         e.getMessage());
 253                         if (debug) {
 254                             e.printStackTrace();
 255                         }
 256                         System.exit(1);
 257                     }
 258                 }
 259                 /*              if (debug) {
 260                     SignatureFileVerifier.setDebug(true);
 261                     ManifestEntryVerifier.setDebug(true);
 262                 }
 263                 */
 264                 verifyJar(jarfile);
 265             } else {
 266                 loadKeyStore(keystore, true);
 267                 getAliasInfo(alias);
 268 
 269                 signJar(jarfile, alias);
 270             }
 271         } catch (Exception e) {
 272             System.out.println(rb.getString(&quot;jarsigner.error.&quot;) + e);
 273             if (debug) {
 274                 e.printStackTrace();
 275             }
 276             System.exit(1);
 277         } finally {
 278             // zero-out private key password
 279             if (keypass != null) {
 280                 Arrays.fill(keypass, &#39; &#39;);
 281                 keypass = null;
 282             }
 283             // zero-out keystore password
 284             if (storepass != null) {
 285                 Arrays.fill(storepass, &#39; &#39;);
 286                 storepass = null;
 287             }
 288         }
 289 
 290         if (strict) {
 291             int exitCode = 0;
 292             if (weakAlg != 0 || chainNotValidated || hasExpiredCert
 293                     || hasExpiredTsaCert || notYetValidCert || signerSelfSigned) {
 294                 exitCode |= 4;
 295             }
 296             if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType) {
 297                 exitCode |= 8;
 298             }
 299             if (hasUnsignedEntry) {
 300                 exitCode |= 16;
 301             }
 302             if (notSignedByAlias || aliasNotInStore) {
 303                 exitCode |= 32;
 304             }
 305             if (tsaChainNotValidated) {
 306                 exitCode |= 64;
 307             }
 308             if (exitCode != 0) {
 309                 System.exit(exitCode);
 310             }
 311         }
 312     }
 313 
 314     /*
 315      * Parse command line arguments.
 316      */
 317     String[] parseArgs(String args[]) throws Exception {
 318         /* parse flags */
 319         int n = 0;
 320 
 321         if (args.length == 0) fullusage();
 322 
 323         String confFile = null;
 324         String command = &quot;-sign&quot;;
 325         for (n=0; n &lt; args.length; n++) {
 326             if (collator.compare(args[n], &quot;-verify&quot;) == 0) {
 327                 command = &quot;-verify&quot;;
 328             } else if (collator.compare(args[n], &quot;-conf&quot;) == 0) {
 329                 if (n == args.length - 1) {
 330                     usageNoArg();
 331                 }
 332                 confFile = args[++n];
 333             }
 334         }
 335 
 336         if (confFile != null) {
 337             args = KeyStoreUtil.expandArgs(
 338                     &quot;jarsigner&quot;, confFile, command, null, args);
 339         }
 340 
 341         debug = Arrays.stream(args).anyMatch(
 342                 x -&gt; collator.compare(x, &quot;-debug&quot;) == 0);
 343 
 344         if (debug) {
 345             // No need to localize debug output
 346             System.out.println(&quot;Command line args: &quot; +
 347                     Arrays.toString(args));
 348         }
 349 
 350         for (n=0; n &lt; args.length; n++) {
 351 
 352             String flags = args[n];
 353             String modifier = null;
 354 
 355             if (flags.startsWith(&quot;-&quot;)) {
 356                 int pos = flags.indexOf(&#39;:&#39;);
 357                 if (pos &gt; 0) {
 358                     modifier = flags.substring(pos+1);
 359                     flags = flags.substring(0, pos);
 360                 }
 361             }
 362 
 363             if (!flags.startsWith(&quot;-&quot;)) {
 364                 if (jarfile == null) {
 365                     jarfile = flags;
 366                 } else {
 367                     alias = flags;
 368                     ckaliases.add(alias);
 369                 }
 370             } else if (collator.compare(flags, &quot;-conf&quot;) == 0) {
 371                 if (++n == args.length) usageNoArg();
 372             } else if (collator.compare(flags, &quot;-keystore&quot;) == 0) {
 373                 if (++n == args.length) usageNoArg();
 374                 keystore = args[n];
 375             } else if (collator.compare(flags, &quot;-storepass&quot;) ==0) {
 376                 if (++n == args.length) usageNoArg();
 377                 storepass = getPass(modifier, args[n]);
 378             } else if (collator.compare(flags, &quot;-storetype&quot;) ==0) {
 379                 if (++n == args.length) usageNoArg();
 380                 storetype = args[n];
 381             } else if (collator.compare(flags, &quot;-providerName&quot;) ==0) {
 382                 if (++n == args.length) usageNoArg();
 383                 providerName = args[n];
 384             } else if (collator.compare(flags, &quot;-provider&quot;) == 0 ||
 385                         collator.compare(flags, &quot;-providerClass&quot;) == 0) {
 386                 if (++n == args.length) usageNoArg();
 387                 if (providerClasses == null) {
 388                     providerClasses = new ArrayList&lt;&gt;(3);
 389                 }
 390                 providerClasses.add(args[n]);
 391 
 392                 if (args.length &gt; (n+1)) {
 393                     flags = args[n+1];
 394                     if (collator.compare(flags, &quot;-providerArg&quot;) == 0) {
 395                         if (args.length == (n+2)) usageNoArg();
 396                         providerArgs.put(args[n], args[n+2]);
 397                         n += 2;
 398                     }
 399                 }
 400             } else if (collator.compare(flags, &quot;-addprovider&quot;) == 0) {
 401                 if (++n == args.length) usageNoArg();
 402                 if (providers == null) {
 403                     providers = new ArrayList&lt;&gt;(3);
 404                 }
 405                 providers.add(args[n]);
 406 
 407                 if (args.length &gt; (n+1)) {
 408                     flags = args[n+1];
 409                     if (collator.compare(flags, &quot;-providerArg&quot;) == 0) {
 410                         if (args.length == (n+2)) usageNoArg();
 411                         providerArgs.put(args[n], args[n+2]);
 412                         n += 2;
 413                     }
 414                 }
 415             } else if (collator.compare(flags, &quot;-protected&quot;) ==0) {
 416                 protectedPath = true;
 417             } else if (collator.compare(flags, &quot;-certchain&quot;) ==0) {
 418                 if (++n == args.length) usageNoArg();
 419                 altCertChain = args[n];
 420             } else if (collator.compare(flags, &quot;-tsapolicyid&quot;) ==0) {
 421                 if (++n == args.length) usageNoArg();
 422                 tSAPolicyID = args[n];
 423             } else if (collator.compare(flags, &quot;-tsadigestalg&quot;) ==0) {
 424                 if (++n == args.length) usageNoArg();
 425                 tSADigestAlg = args[n];
 426             } else if (collator.compare(flags, &quot;-debug&quot;) ==0) {
 427                 // Already processed
 428             } else if (collator.compare(flags, &quot;-keypass&quot;) ==0) {
 429                 if (++n == args.length) usageNoArg();
 430                 keypass = getPass(modifier, args[n]);
 431             } else if (collator.compare(flags, &quot;-sigfile&quot;) ==0) {
 432                 if (++n == args.length) usageNoArg();
 433                 sigfile = args[n];
 434             } else if (collator.compare(flags, &quot;-signedjar&quot;) ==0) {
 435                 if (++n == args.length) usageNoArg();
 436                 signedjar = args[n];
 437             } else if (collator.compare(flags, &quot;-tsa&quot;) ==0) {
 438                 if (++n == args.length) usageNoArg();
 439                 tsaUrl = args[n];
 440             } else if (collator.compare(flags, &quot;-tsacert&quot;) ==0) {
 441                 if (++n == args.length) usageNoArg();
 442                 tsaAlias = args[n];
 443             } else if (collator.compare(flags, &quot;-altsigner&quot;) ==0) {
 444                 if (++n == args.length) usageNoArg();
 445                 altSignerClass = args[n];
 446                 System.err.println(
<a name="2" id="anc2"></a><span class="line-modified"> 447                         rb.getString(&quot;This.option.is.forremoval&quot;) +</span>
 448                                 &quot;-altsigner&quot;);
 449             } else if (collator.compare(flags, &quot;-altsignerpath&quot;) ==0) {
 450                 if (++n == args.length) usageNoArg();
 451                 altSignerClasspath = args[n];
 452                 System.err.println(
<a name="3" id="anc3"></a><span class="line-modified"> 453                         rb.getString(&quot;This.option.is.forremoval&quot;) +</span>
 454                                 &quot;-altsignerpath&quot;);
 455             } else if (collator.compare(flags, &quot;-sectionsonly&quot;) ==0) {
 456                 signManifest = false;
 457             } else if (collator.compare(flags, &quot;-internalsf&quot;) ==0) {
 458                 externalSF = false;
 459             } else if (collator.compare(flags, &quot;-verify&quot;) ==0) {
 460                 verify = true;
 461             } else if (collator.compare(flags, &quot;-verbose&quot;) ==0) {
 462                 verbose = (modifier != null) ? modifier : &quot;all&quot;;
 463             } else if (collator.compare(flags, &quot;-sigalg&quot;) ==0) {
 464                 if (++n == args.length) usageNoArg();
 465                 sigalg = args[n];
 466             } else if (collator.compare(flags, &quot;-digestalg&quot;) ==0) {
 467                 if (++n == args.length) usageNoArg();
 468                 digestalg = args[n];
 469             } else if (collator.compare(flags, &quot;-certs&quot;) ==0) {
 470                 showcerts = true;
 471             } else if (collator.compare(flags, &quot;-strict&quot;) ==0) {
 472                 strict = true;
 473             } else if (collator.compare(flags, &quot;-?&quot;) == 0 ||
 474                        collator.compare(flags, &quot;-h&quot;) == 0 ||
 475                        collator.compare(flags, &quot;--help&quot;) == 0 ||
 476                        // -help: legacy.
 477                        collator.compare(flags, &quot;-help&quot;) == 0) {
 478                 fullusage();
 479             } else {
 480                 System.err.println(
 481                         rb.getString(&quot;Illegal.option.&quot;) + flags);
 482                 usage();
 483             }
 484         }
 485 
 486         // -certs must always be specified with -verbose
 487         if (verbose == null) showcerts = false;
 488 
 489         if (jarfile == null) {
 490             System.err.println(rb.getString(&quot;Please.specify.jarfile.name&quot;));
 491             usage();
 492         }
 493         if (!verify &amp;&amp; alias == null) {
 494             System.err.println(rb.getString(&quot;Please.specify.alias.name&quot;));
 495             usage();
 496         }
 497         if (!verify &amp;&amp; ckaliases.size() &gt; 1) {
 498             System.err.println(rb.getString(&quot;Only.one.alias.can.be.specified&quot;));
 499             usage();
 500         }
 501 
 502         if (storetype == null) {
 503             storetype = KeyStore.getDefaultType();
 504         }
 505         storetype = KeyStoreUtil.niceStoreTypeName(storetype);
 506 
 507         try {
 508             if (signedjar != null &amp;&amp; new File(signedjar).getCanonicalPath().equals(
 509                     new File(jarfile).getCanonicalPath())) {
 510                 signedjar = null;
 511             }
 512         } catch (IOException ioe) {
 513             // File system error?
 514             // Just ignore it.
 515         }
 516 
 517         if (P11KEYSTORE.equalsIgnoreCase(storetype) ||
 518                 KeyStoreUtil.isWindowsKeyStore(storetype)) {
 519             token = true;
 520             if (keystore == null) {
 521                 keystore = NONE;
 522             }
 523         }
 524 
 525         if (NONE.equals(keystore)) {
 526             nullStream = true;
 527         }
 528 
 529         if (token &amp;&amp; !nullStream) {
 530             System.err.println(MessageFormat.format(rb.getString
 531                 (&quot;.keystore.must.be.NONE.if.storetype.is.{0}&quot;), storetype));
 532             usage();
 533         }
 534 
 535         if (token &amp;&amp; keypass != null) {
 536             System.err.println(MessageFormat.format(rb.getString
 537                 (&quot;.keypass.can.not.be.specified.if.storetype.is.{0}&quot;), storetype));
 538             usage();
 539         }
 540 
 541         if (protectedPath) {
 542             if (storepass != null || keypass != null) {
 543                 System.err.println(rb.getString
 544                         (&quot;If.protected.is.specified.then.storepass.and.keypass.must.not.be.specified&quot;));
 545                 usage();
 546             }
 547         }
 548         if (KeyStoreUtil.isWindowsKeyStore(storetype)) {
 549             if (storepass != null || keypass != null) {
 550                 System.err.println(rb.getString
 551                         (&quot;If.keystore.is.not.password.protected.then.storepass.and.keypass.must.not.be.specified&quot;));
 552                 usage();
 553             }
 554         }
 555         return args;
 556     }
 557 
 558     static char[] getPass(String modifier, String arg) {
<a name="4" id="anc4"></a><span class="line-modified"> 559         char[] output =</span>
<span class="line-added"> 560             KeyStoreUtil.getPassWithModifier(modifier, arg, rb, collator);</span>
 561         if (output != null) return output;
 562         usage();
 563         return null;    // Useless, usage() already exit
 564     }
 565 
 566     static void usageNoArg() {
 567         System.out.println(rb.getString(&quot;Option.lacks.argument&quot;));
 568         usage();
 569     }
 570 
 571     static void usage() {
 572         System.out.println();
 573         System.out.println(rb.getString(&quot;Please.type.jarsigner.help.for.usage&quot;));
 574         System.exit(1);
 575     }
 576 
 577     static void fullusage() {
 578         System.out.println(rb.getString
 579                 (&quot;Usage.jarsigner.options.jar.file.alias&quot;));
 580         System.out.println(rb.getString
 581                 (&quot;.jarsigner.verify.options.jar.file.alias.&quot;));
 582         System.out.println();
 583         System.out.println(rb.getString
 584                 (&quot;.keystore.url.keystore.location&quot;));
 585         System.out.println();
 586         System.out.println(rb.getString
 587                 (&quot;.storepass.password.password.for.keystore.integrity&quot;));
 588         System.out.println();
 589         System.out.println(rb.getString
 590                 (&quot;.storetype.type.keystore.type&quot;));
 591         System.out.println();
 592         System.out.println(rb.getString
 593                 (&quot;.keypass.password.password.for.private.key.if.different.&quot;));
 594         System.out.println();
 595         System.out.println(rb.getString
 596                 (&quot;.certchain.file.name.of.alternative.certchain.file&quot;));
 597         System.out.println();
 598         System.out.println(rb.getString
 599                 (&quot;.sigfile.file.name.of.SF.DSA.file&quot;));
 600         System.out.println();
 601         System.out.println(rb.getString
 602                 (&quot;.signedjar.file.name.of.signed.JAR.file&quot;));
 603         System.out.println();
 604         System.out.println(rb.getString
 605                 (&quot;.digestalg.algorithm.name.of.digest.algorithm&quot;));
 606         System.out.println();
 607         System.out.println(rb.getString
 608                 (&quot;.sigalg.algorithm.name.of.signature.algorithm&quot;));
 609         System.out.println();
 610         System.out.println(rb.getString
 611                 (&quot;.verify.verify.a.signed.JAR.file&quot;));
 612         System.out.println();
 613         System.out.println(rb.getString
 614                 (&quot;.verbose.suboptions.verbose.output.when.signing.verifying.&quot;));
 615         System.out.println(rb.getString
 616                 (&quot;.suboptions.can.be.all.grouped.or.summary&quot;));
 617         System.out.println();
 618         System.out.println(rb.getString
 619                 (&quot;.certs.display.certificates.when.verbose.and.verifying&quot;));
 620         System.out.println();
 621         System.out.println(rb.getString
 622                 (&quot;.tsa.url.location.of.the.Timestamping.Authority&quot;));
 623         System.out.println();
 624         System.out.println(rb.getString
 625                 (&quot;.tsacert.alias.public.key.certificate.for.Timestamping.Authority&quot;));
 626         System.out.println();
 627         System.out.println(rb.getString
 628                 (&quot;.tsapolicyid.tsapolicyid.for.Timestamping.Authority&quot;));
 629         System.out.println();
 630         System.out.println(rb.getString
 631                 (&quot;.tsadigestalg.algorithm.of.digest.data.in.timestamping.request&quot;));
 632         System.out.println();
 633         System.out.println(rb.getString
 634                 (&quot;.altsigner.class.class.name.of.an.alternative.signing.mechanism&quot;));
 635         System.out.println();
 636         System.out.println(rb.getString
 637                 (&quot;.altsignerpath.pathlist.location.of.an.alternative.signing.mechanism&quot;));
 638         System.out.println();
 639         System.out.println(rb.getString
 640                 (&quot;.internalsf.include.the.SF.file.inside.the.signature.block&quot;));
 641         System.out.println();
 642         System.out.println(rb.getString
 643                 (&quot;.sectionsonly.don.t.compute.hash.of.entire.manifest&quot;));
 644         System.out.println();
 645         System.out.println(rb.getString
 646                 (&quot;.protected.keystore.has.protected.authentication.path&quot;));
 647         System.out.println();
 648         System.out.println(rb.getString
 649                 (&quot;.providerName.name.provider.name&quot;));
 650         System.out.println();
 651         System.out.println(rb.getString
 652                 (&quot;.add.provider.option&quot;));
 653         System.out.println(rb.getString
 654                 (&quot;.providerArg.option.1&quot;));
 655         System.out.println();
 656         System.out.println(rb.getString
 657                 (&quot;.providerClass.option&quot;));
 658         System.out.println(rb.getString
 659                 (&quot;.providerArg.option.2&quot;));
 660         System.out.println();
 661         System.out.println(rb.getString
 662                 (&quot;.strict.treat.warnings.as.errors&quot;));
 663         System.out.println();
 664         System.out.println(rb.getString
 665                 (&quot;.conf.url.specify.a.pre.configured.options.file&quot;));
 666         System.out.println();
 667         System.out.println(rb.getString
 668                 (&quot;.print.this.help.message&quot;));
 669         System.out.println();
 670 
 671         System.exit(0);
 672     }
 673 
 674     void verifyJar(String jarName)
 675         throws Exception
 676     {
 677         boolean anySigned = false;  // if there exists entry inside jar signed
 678         JarFile jf = null;
 679         Map&lt;String,String&gt; digestMap = new HashMap&lt;&gt;();
 680         Map&lt;String,PKCS7&gt; sigMap = new HashMap&lt;&gt;();
 681         Map&lt;String,String&gt; sigNameMap = new HashMap&lt;&gt;();
 682         Map&lt;String,String&gt; unparsableSignatures = new HashMap&lt;&gt;();
 683 
 684         try {
 685             jf = new JarFile(jarName, true);
 686             Vector&lt;JarEntry&gt; entriesVec = new Vector&lt;&gt;();
 687             byte[] buffer = new byte[8192];
 688 
 689             String suffix1 = &quot;-Digest-Manifest&quot;;
 690             String suffix2 = &quot;-Digest-&quot; + ManifestDigester.MF_MAIN_ATTRS;
 691 
 692             int suffixLength1 = suffix1.length();
 693             int suffixLength2 = suffix2.length();
 694 
 695             Enumeration&lt;JarEntry&gt; entries = jf.entries();
 696             while (entries.hasMoreElements()) {
 697                 JarEntry je = entries.nextElement();
 698                 entriesVec.addElement(je);
 699                 try (InputStream is = jf.getInputStream(je)) {
 700                     String name = je.getName();
 701                     if (signatureRelated(name)
 702                             &amp;&amp; SignatureFileVerifier.isBlockOrSF(name)) {
 703                         String alias = name.substring(name.lastIndexOf(&#39;/&#39;) + 1,
 704                                 name.lastIndexOf(&#39;.&#39;));
 705                         try {
 706                             if (name.endsWith(&quot;.SF&quot;)) {
 707                                 Manifest sf = new Manifest(is);
 708                                 boolean found = false;
 709                                 for (Object obj : sf.getMainAttributes().keySet()) {
 710                                     String key = obj.toString();
 711                                     if (key.endsWith(suffix1)) {
 712                                         digestMap.put(alias, key.substring(
 713                                                 0, key.length() - suffixLength1));
 714                                         found = true;
 715                                         break;
 716                                     } else if (key.endsWith(suffix2)) {
 717                                         digestMap.put(alias, key.substring(
 718                                                 0, key.length() - suffixLength2));
 719                                         found = true;
 720                                         break;
 721                                     }
 722                                 }
 723                                 if (!found) {
 724                                     unparsableSignatures.putIfAbsent(alias,
 725                                         String.format(
 726                                             rb.getString(&quot;history.unparsable&quot;),
 727                                             name));
 728                                 }
 729                             } else {
 730                                 sigNameMap.put(alias, name);
 731                                 sigMap.put(alias, new PKCS7(is));
 732                             }
 733                         } catch (IOException ioe) {
 734                             unparsableSignatures.putIfAbsent(alias, String.format(
 735                                     rb.getString(&quot;history.unparsable&quot;), name));
 736                         }
 737                     } else {
 738                         while (is.read(buffer, 0, buffer.length) != -1) {
 739                             // we just read. this will throw a SecurityException
 740                             // if  a signature/digest check fails.
 741                         }
 742                     }
 743                 }
 744             }
 745 
 746             Manifest man = jf.getManifest();
 747             boolean hasSignature = false;
 748 
 749             // The map to record display info, only used when -verbose provided
 750             //      key: signer info string
 751             //      value: the list of files with common key
 752             Map&lt;String,List&lt;String&gt;&gt; output = new LinkedHashMap&lt;&gt;();
 753 
 754             if (man != null) {
 755                 if (verbose != null) System.out.println();
 756                 Enumeration&lt;JarEntry&gt; e = entriesVec.elements();
 757 
 758                 String tab = rb.getString(&quot;6SPACE&quot;);
 759 
 760                 while (e.hasMoreElements()) {
 761                     JarEntry je = e.nextElement();
 762                     String name = je.getName();
 763 
 764                     hasSignature = hasSignature
 765                             || SignatureFileVerifier.isBlockOrSF(name);
 766 
 767                     CodeSigner[] signers = je.getCodeSigners();
 768                     boolean isSigned = (signers != null);
 769                     anySigned |= isSigned;
 770                     hasUnsignedEntry |= !je.isDirectory() &amp;&amp; !isSigned
 771                                         &amp;&amp; !signatureRelated(name);
 772 
 773                     int inStoreWithAlias = inKeyStore(signers);
 774 
 775                     boolean inStore = (inStoreWithAlias &amp; IN_KEYSTORE) != 0;
 776 
 777                     notSignedByAlias |= (inStoreWithAlias &amp; NOT_ALIAS) != 0;
 778                     if (keystore != null) {
 779                         aliasNotInStore |= isSigned &amp;&amp; !inStore;
 780                     }
 781 
 782                     // Only used when -verbose provided
 783                     StringBuffer sb = null;
 784                     if (verbose != null) {
 785                         sb = new StringBuffer();
 786                         boolean inManifest =
 787                             ((man.getAttributes(name) != null) ||
 788                              (man.getAttributes(&quot;./&quot;+name) != null) ||
 789                              (man.getAttributes(&quot;/&quot;+name) != null));
 790                         sb.append(isSigned ? rb.getString(&quot;s&quot;) : rb.getString(&quot;SPACE&quot;))
 791                                 .append(inManifest ? rb.getString(&quot;m&quot;) : rb.getString(&quot;SPACE&quot;))
 792                                 .append(inStore ? rb.getString(&quot;k&quot;) : rb.getString(&quot;SPACE&quot;))
 793                                 .append((inStoreWithAlias &amp; NOT_ALIAS) != 0 ? &#39;X&#39; : &#39; &#39;)
 794                                 .append(rb.getString(&quot;SPACE&quot;));
 795                         sb.append(&#39;|&#39;);
 796                     }
 797 
 798                     // When -certs provided, display info has extra empty
 799                     // lines at the beginning and end.
 800                     if (isSigned) {
 801                         if (showcerts) sb.append(&#39;\n&#39;);
 802                         for (CodeSigner signer: signers) {
 803                             // signerInfo() must be called even if -verbose
 804                             // not provided. The method updates various
 805                             // warning flags.
 806                             String si = signerInfo(signer, tab);
 807                             if (showcerts) {
 808                                 sb.append(si);
 809                                 sb.append(&#39;\n&#39;);
 810                             }
 811                         }
 812                     } else if (showcerts &amp;&amp; !verbose.equals(&quot;all&quot;)) {
 813                         // Print no info for unsigned entries when -verbose:all,
 814                         // to be consistent with old behavior.
 815                         if (signatureRelated(name)) {
 816                             sb.append(&#39;\n&#39;)
 817                                     .append(tab)
 818                                     .append(rb
 819                                             .getString(&quot;.Signature.related.entries.&quot;))
 820                                     .append(&quot;\n\n&quot;);
 821                         } else {
 822                             sb.append(&#39;\n&#39;).append(tab)
 823                                     .append(rb.getString(&quot;.Unsigned.entries.&quot;))
 824                                     .append(&quot;\n\n&quot;);
 825                         }
 826                     }
 827 
 828                     if (verbose != null) {
 829                         String label = sb.toString();
 830                         if (signatureRelated(name)) {
 831                             // Entries inside META-INF and other unsigned
 832                             // entries are grouped separately.
 833                             label = &quot;-&quot; + label;
 834                         }
 835 
 836                         // The label finally contains 2 parts separated by &#39;|&#39;:
 837                         // The legend displayed before the entry names, and
 838                         // the cert info (if -certs specified).
 839 
 840                         if (!output.containsKey(label)) {
 841                             output.put(label, new ArrayList&lt;String&gt;());
 842                         }
 843 
 844                         StringBuilder fb = new StringBuilder();
 845                         String s = Long.toString(je.getSize());
 846                         for (int i = 6 - s.length(); i &gt; 0; --i) {
 847                             fb.append(&#39; &#39;);
 848                         }
 849                         fb.append(s).append(&#39; &#39;).
 850                                 append(new Date(je.getTime()).toString());
 851                         fb.append(&#39; &#39;).append(name);
 852 
 853                         output.get(label).add(fb.toString());
 854                     }
 855                 }
 856             }
 857             if (verbose != null) {
 858                 for (Entry&lt;String,List&lt;String&gt;&gt; s: output.entrySet()) {
 859                     List&lt;String&gt; files = s.getValue();
 860                     String key = s.getKey();
 861                     if (key.charAt(0) == &#39;-&#39;) { // the signature-related group
 862                         key = key.substring(1);
 863                     }
 864                     int pipe = key.indexOf(&#39;|&#39;);
 865                     if (verbose.equals(&quot;all&quot;)) {
 866                         for (String f: files) {
 867                             System.out.println(key.substring(0, pipe) + f);
 868                             System.out.printf(key.substring(pipe+1));
 869                         }
 870                     } else {
 871                         if (verbose.equals(&quot;grouped&quot;)) {
 872                             for (String f: files) {
 873                                 System.out.println(key.substring(0, pipe) + f);
 874                             }
 875                         } else if (verbose.equals(&quot;summary&quot;)) {
 876                             System.out.print(key.substring(0, pipe));
 877                             if (files.size() &gt; 1) {
 878                                 System.out.println(files.get(0) + &quot; &quot; +
 879                                         String.format(rb.getString(
 880                                         &quot;.and.d.more.&quot;), files.size()-1));
 881                             } else {
 882                                 System.out.println(files.get(0));
 883                             }
 884                         }
 885                         System.out.printf(key.substring(pipe+1));
 886                     }
 887                 }
 888                 System.out.println();
 889                 System.out.println(rb.getString(
 890                     &quot;.s.signature.was.verified.&quot;));
 891                 System.out.println(rb.getString(
 892                     &quot;.m.entry.is.listed.in.manifest&quot;));
 893                 System.out.println(rb.getString(
 894                     &quot;.k.at.least.one.certificate.was.found.in.keystore&quot;));
 895                 if (ckaliases.size() &gt; 0) {
 896                     System.out.println(rb.getString(
 897                         &quot;.X.not.signed.by.specified.alias.es.&quot;));
 898                 }
 899             }
 900             if (man == null) {
 901                 System.out.println();
 902                 System.out.println(rb.getString(&quot;no.manifest.&quot;));
 903             }
 904 
 905             // If signer is a trusted cert or private entry in user&#39;s own
 906             // keystore, it can be self-signed. Please note aliasNotInStore
 907             // is always false when ~/.keystore is used.
 908             if (!aliasNotInStore &amp;&amp; keystore != null) {
 909                 signerSelfSigned = false;
 910             }
 911 
 912             // Even if the verbose option is not specified, all out strings
 913             // must be generated so seeWeak can be updated.
 914             if (!digestMap.isEmpty()
 915                     || !sigMap.isEmpty()
 916                     || !unparsableSignatures.isEmpty()) {
 917                 if (verbose != null) {
 918                     System.out.println();
 919                 }
 920                 for (String s : sigMap.keySet()) {
 921                     if (!digestMap.containsKey(s)) {
 922                         unparsableSignatures.putIfAbsent(s, String.format(
 923                                 rb.getString(&quot;history.nosf&quot;), s));
 924                     }
 925                 }
 926                 for (String s : digestMap.keySet()) {
 927                     PKCS7 p7 = sigMap.get(s);
 928                     if (p7 != null) {
 929                         String history;
 930                         try {
 931                             SignerInfo si = p7.getSignerInfos()[0];
 932                             X509Certificate signer = si.getCertificate(p7);
 933                             String digestAlg = digestMap.get(s);
 934                             String sigAlg = AlgorithmId.makeSigAlg(
 935                                     si.getDigestAlgorithmId().getName(),
 936                                     si.getDigestEncryptionAlgorithmId().getName());
 937                             PublicKey key = signer.getPublicKey();
 938                             PKCS7 tsToken = si.getTsToken();
 939                             if (tsToken != null) {
 940                                 hasTimestampBlock = true;
 941                                 SignerInfo tsSi = tsToken.getSignerInfos()[0];
 942                                 X509Certificate tsSigner = tsSi.getCertificate(tsToken);
 943                                 byte[] encTsTokenInfo = tsToken.getContentInfo().getData();
 944                                 TimestampToken tsTokenInfo = new TimestampToken(encTsTokenInfo);
 945                                 PublicKey tsKey = tsSigner.getPublicKey();
 946                                 String tsDigestAlg = tsTokenInfo.getHashAlgorithm().getName();
 947                                 String tsSigAlg = AlgorithmId.makeSigAlg(
 948                                         tsSi.getDigestAlgorithmId().getName(),
 949                                         tsSi.getDigestEncryptionAlgorithmId().getName());
 950                                 Calendar c = Calendar.getInstance(
 951                                         TimeZone.getTimeZone(&quot;UTC&quot;),
 952                                         Locale.getDefault(Locale.Category.FORMAT));
 953                                 c.setTime(tsTokenInfo.getDate());
 954                                 history = String.format(
 955                                         rb.getString(&quot;history.with.ts&quot;),
 956                                         signer.getSubjectX500Principal(),
 957                                         withWeak(digestAlg, DIGEST_PRIMITIVE_SET),
 958                                         withWeak(sigAlg, SIG_PRIMITIVE_SET),
 959                                         withWeak(key),
 960                                         c,
 961                                         tsSigner.getSubjectX500Principal(),
 962                                         withWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET),
 963                                         withWeak(tsSigAlg, SIG_PRIMITIVE_SET),
 964                                         withWeak(tsKey));
 965                             } else {
 966                                 history = String.format(
 967                                         rb.getString(&quot;history.without.ts&quot;),
 968                                         signer.getSubjectX500Principal(),
 969                                         withWeak(digestAlg, DIGEST_PRIMITIVE_SET),
 970                                         withWeak(sigAlg, SIG_PRIMITIVE_SET),
 971                                         withWeak(key));
 972                             }
 973                         } catch (Exception e) {
 974                             // The only usage of sigNameMap, remember the name
 975                             // of the block file if it&#39;s invalid.
 976                             history = String.format(
 977                                     rb.getString(&quot;history.unparsable&quot;),
 978                                     sigNameMap.get(s));
 979                         }
 980                         if (verbose != null) {
 981                             System.out.println(history);
 982                         }
 983                     } else {
 984                         unparsableSignatures.putIfAbsent(s, String.format(
 985                                 rb.getString(&quot;history.nobk&quot;), s));
 986                     }
 987                 }
 988                 if (verbose != null) {
 989                     for (String s : unparsableSignatures.keySet()) {
 990                         System.out.println(unparsableSignatures.get(s));
 991                     }
 992                 }
 993             }
 994             System.out.println();
 995             if (!anySigned) {
 996                 if (seeWeak) {
 997                     if (verbose != null) {
 998                         System.out.println(rb.getString(&quot;jar.treated.unsigned.see.weak.verbose&quot;));
 999                         System.out.println(&quot;\n  &quot; +
1000                                 DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS +
1001                                 &quot;=&quot; + Security.getProperty(DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS));
1002                     } else {
1003                         System.out.println(rb.getString(&quot;jar.treated.unsigned.see.weak&quot;));
1004                     }
1005                 } else if (hasSignature) {
1006                     System.out.println(rb.getString(&quot;jar.treated.unsigned&quot;));
1007                 } else {
1008                     System.out.println(rb.getString(&quot;jar.is.unsigned&quot;));
1009                 }
1010             } else {
1011                 displayMessagesAndResult(false);
1012             }
1013             return;
1014         } catch (Exception e) {
1015             System.out.println(rb.getString(&quot;jarsigner.&quot;) + e);
1016             if (debug) {
1017                 e.printStackTrace();
1018             }
1019         } finally { // close the resource
1020             if (jf != null) {
1021                 jf.close();
1022             }
1023         }
1024 
1025         System.exit(1);
1026     }
1027 
1028     private void displayMessagesAndResult(boolean isSigning) {
1029         String result;
1030         List&lt;String&gt; errors = new ArrayList&lt;&gt;();
1031         List&lt;String&gt; warnings = new ArrayList&lt;&gt;();
1032         List&lt;String&gt; info = new ArrayList&lt;&gt;();
1033 
1034         boolean signerNotExpired = expireDate == null
1035                 || expireDate.after(new Date());
1036 
1037         if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType ||
1038                 notYetValidCert || chainNotValidated || hasExpiredCert ||
1039                 hasUnsignedEntry || signerSelfSigned || (weakAlg != 0) ||
1040                 aliasNotInStore || notSignedByAlias ||
1041                 tsaChainNotValidated ||
1042                 (hasExpiredTsaCert &amp;&amp; !signerNotExpired)) {
1043 
1044             if (strict) {
1045                 result = isSigning
1046                         ? rb.getString(&quot;jar.signed.with.signer.errors.&quot;)
1047                         : rb.getString(&quot;jar.verified.with.signer.errors.&quot;);
1048             } else {
1049                 result = isSigning
1050                         ? rb.getString(&quot;jar.signed.&quot;)
1051                         : rb.getString(&quot;jar.verified.&quot;);
1052             }
1053 
1054             if (badKeyUsage) {
1055                 errors.add(isSigning
1056                         ? rb.getString(&quot;The.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.&quot;)
1057                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.&quot;));
1058             }
1059 
1060             if (badExtendedKeyUsage) {
1061                 errors.add(isSigning
1062                         ? rb.getString(&quot;The.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.&quot;)
1063                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.&quot;));
1064             }
1065 
1066             if (badNetscapeCertType) {
1067                 errors.add(isSigning
1068                         ? rb.getString(&quot;The.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.&quot;)
1069                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.&quot;));
1070             }
1071 
1072             // only in verifying
1073             if (hasUnsignedEntry) {
1074                 errors.add(rb.getString(
1075                         &quot;This.jar.contains.unsigned.entries.which.have.not.been.integrity.checked.&quot;));
1076             }
1077             if (hasExpiredCert) {
1078                 errors.add(isSigning
1079                         ? rb.getString(&quot;The.signer.certificate.has.expired.&quot;)
1080                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.has.expired.&quot;));
1081             }
1082             if (notYetValidCert) {
1083                 errors.add(isSigning
1084                         ? rb.getString(&quot;The.signer.certificate.is.not.yet.valid.&quot;)
1085                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.is.not.yet.valid.&quot;));
1086             }
1087 
1088             if (chainNotValidated) {
1089                 errors.add(String.format(isSigning
1090                                 ? rb.getString(&quot;The.signer.s.certificate.chain.is.invalid.reason.1&quot;)
1091                                 : rb.getString(&quot;This.jar.contains.entries.whose.certificate.chain.is.invalid.reason.1&quot;),
1092                         chainNotValidatedReason.getLocalizedMessage()));
1093             }
1094 
1095             if (hasExpiredTsaCert) {
1096                 errors.add(rb.getString(&quot;The.timestamp.has.expired.&quot;));
1097             }
1098             if (tsaChainNotValidated) {
1099                 errors.add(String.format(isSigning
1100                                 ? rb.getString(&quot;The.tsa.certificate.chain.is.invalid.reason.1&quot;)
1101                                 : rb.getString(&quot;This.jar.contains.entries.whose.tsa.certificate.chain.is.invalid.reason.1&quot;),
1102                         tsaChainNotValidatedReason.getLocalizedMessage()));
1103             }
1104 
1105             // only in verifying
1106             if (notSignedByAlias) {
1107                 errors.add(
1108                         rb.getString(&quot;This.jar.contains.signed.entries.which.is.not.signed.by.the.specified.alias.es.&quot;));
1109             }
1110 
1111             // only in verifying
1112             if (aliasNotInStore) {
1113                 errors.add(rb.getString(&quot;This.jar.contains.signed.entries.that.s.not.signed.by.alias.in.this.keystore.&quot;));
1114             }
1115 
1116             if (signerSelfSigned) {
1117                 errors.add(isSigning
1118                         ? rb.getString(&quot;The.signer.s.certificate.is.self.signed.&quot;)
1119                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.is.self.signed.&quot;));
1120             }
1121 
1122             // weakAlg only detected in signing. The jar file is
1123             // now simply treated unsigned in verifying.
1124             if ((weakAlg &amp; 1) == 1) {
1125                 errors.add(String.format(
1126                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.&quot;),
1127                         digestalg, &quot;-digestalg&quot;));
1128             }
1129 
1130             if ((weakAlg &amp; 2) == 2) {
1131                 errors.add(String.format(
1132                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.&quot;),
1133                         sigalg, &quot;-sigalg&quot;));
1134             }
1135             if ((weakAlg &amp; 4) == 4) {
1136                 errors.add(String.format(
1137                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.&quot;),
1138                         tSADigestAlg, &quot;-tsadigestalg&quot;));
1139             }
1140             if ((weakAlg &amp; 8) == 8) {
1141                 errors.add(String.format(
1142                         rb.getString(&quot;The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk.&quot;),
1143                         privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));
1144             }
1145         } else {
1146             result = isSigning ? rb.getString(&quot;jar.signed.&quot;) : rb.getString(&quot;jar.verified.&quot;);
1147         }
1148 
1149         if (hasExpiredTsaCert) {
1150             // No need to warn about expiring if already expired
1151             hasExpiringTsaCert = false;
1152         }
1153 
1154         if (hasExpiringCert ||
1155                 (hasExpiringTsaCert  &amp;&amp; expireDate != null) ||
1156                 (noTimestamp &amp;&amp; expireDate != null) ||
1157                 (hasExpiredTsaCert &amp;&amp; signerNotExpired)) {
1158 
1159             if (hasExpiredTsaCert &amp;&amp; signerNotExpired) {
1160                 if (expireDate != null) {
1161                     warnings.add(String.format(
1162                             rb.getString(&quot;The.timestamp.expired.1.but.usable.2&quot;),
1163                             tsaExpireDate,
1164                             expireDate));
1165                 }
1166                 // Reset the flag so exit code is 0
1167                 hasExpiredTsaCert = false;
1168             }
1169             if (hasExpiringCert) {
1170                 warnings.add(isSigning
1171                         ? rb.getString(&quot;The.signer.certificate.will.expire.within.six.months.&quot;)
1172                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.will.expire.within.six.months.&quot;));
1173             }
1174             if (hasExpiringTsaCert &amp;&amp; expireDate != null) {
1175                 if (expireDate.after(tsaExpireDate)) {
1176                     warnings.add(String.format(rb.getString(
1177                             &quot;The.timestamp.will.expire.within.one.year.on.1.but.2&quot;), tsaExpireDate, expireDate));
1178                 } else {
1179                     warnings.add(String.format(rb.getString(
1180                             &quot;The.timestamp.will.expire.within.one.year.on.1&quot;), tsaExpireDate));
1181                 }
1182             }
1183             if (noTimestamp &amp;&amp; expireDate != null) {
1184                 if (hasTimestampBlock) {
1185                     warnings.add(String.format(isSigning
1186                             ? rb.getString(&quot;invalid.timestamp.signing&quot;)
1187                             : rb.getString(&quot;bad.timestamp.verifying&quot;), expireDate));
1188                 } else {
1189                     warnings.add(String.format(isSigning
1190                             ? rb.getString(&quot;no.timestamp.signing&quot;)
1191                             : rb.getString(&quot;no.timestamp.verifying&quot;), expireDate));
1192                 }
1193             }
1194         }
1195 
1196         System.out.println(result);
1197         if (strict) {
1198             if (!errors.isEmpty()) {
1199                 System.out.println();
1200                 System.out.println(rb.getString(&quot;Error.&quot;));
1201                 errors.forEach(System.out::println);
1202             }
1203             if (!warnings.isEmpty()) {
1204                 System.out.println();
1205                 System.out.println(rb.getString(&quot;Warning.&quot;));
1206                 warnings.forEach(System.out::println);
1207             }
1208         } else {
1209             if (!errors.isEmpty() || !warnings.isEmpty()) {
1210                 System.out.println();
1211                 System.out.println(rb.getString(&quot;Warning.&quot;));
1212                 errors.forEach(System.out::println);
1213                 warnings.forEach(System.out::println);
1214             }
1215         }
1216         if (!isSigning &amp;&amp; (!errors.isEmpty() || !warnings.isEmpty())) {
1217             if (! (verbose != null &amp;&amp; showcerts)) {
1218                 System.out.println();
1219                 System.out.println(rb.getString(
1220                         &quot;Re.run.with.the.verbose.and.certs.options.for.more.details.&quot;));
1221             }
1222         }
1223 
1224         if (isSigning || verbose != null) {
1225             // Always print out expireDate, unless expired or expiring.
1226             if (!hasExpiringCert &amp;&amp; !hasExpiredCert
1227                     &amp;&amp; expireDate != null &amp;&amp; signerNotExpired) {
1228                 info.add(String.format(rb.getString(
1229                         &quot;The.signer.certificate.will.expire.on.1.&quot;), expireDate));
1230             }
1231             if (!noTimestamp) {
1232                 if (!hasExpiringTsaCert &amp;&amp; !hasExpiredTsaCert &amp;&amp; tsaExpireDate != null) {
1233                     if (signerNotExpired) {
1234                         info.add(String.format(rb.getString(
1235                                 &quot;The.timestamp.will.expire.on.1.&quot;), tsaExpireDate));
1236                     } else {
1237                         info.add(String.format(rb.getString(
1238                                 &quot;signer.cert.expired.1.but.timestamp.good.2.&quot;),
1239                                 expireDate,
1240                                 tsaExpireDate));
1241                     }
1242                 }
1243             }
1244         }
1245 
1246         if (!info.isEmpty()) {
1247             System.out.println();
1248             info.forEach(System.out::println);
1249         }
1250     }
1251 
1252     private String withWeak(String alg, Set&lt;CryptoPrimitive&gt; primitiveSet) {
1253         if (DISABLED_CHECK.permits(primitiveSet, alg, null)) {
1254             return alg;
1255         } else {
1256             seeWeak = true;
1257             return String.format(rb.getString(&quot;with.weak&quot;), alg);
1258         }
1259     }
1260 
1261     private String withWeak(PublicKey key) {
1262         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1263             int kLen = KeyUtil.getKeySize(key);
1264             if (kLen &gt;= 0) {
1265                 return String.format(rb.getString(&quot;key.bit&quot;), kLen);
1266             } else {
1267                 return rb.getString(&quot;unknown.size&quot;);
1268             }
1269         } else {
1270             seeWeak = true;
1271             return String.format(
1272                     rb.getString(&quot;key.bit.weak&quot;), KeyUtil.getKeySize(key));
1273         }
1274     }
1275 
1276     private static MessageFormat validityTimeForm = null;
1277     private static MessageFormat notYetTimeForm = null;
1278     private static MessageFormat expiredTimeForm = null;
1279     private static MessageFormat expiringTimeForm = null;
1280 
1281     /**
1282      * Returns a string about a certificate:
1283      *
1284      * [&lt;tab&gt;] &lt;cert-type&gt; [&quot;, &quot; &lt;subject-DN&gt;] [&quot; (&quot; &lt;keystore-entry-alias&gt; &quot;)&quot;]
1285      * [&lt;validity-period&gt; | &lt;expiry-warning&gt;]
1286      * [&lt;key-usage-warning&gt;]
1287      *
1288      * Note: no newline character at the end.
1289      *
1290      * This method sets global flags like hasExpiringCert, hasExpiredCert,
1291      * notYetValidCert, badKeyUsage, badExtendedKeyUsage, badNetscapeCertType,
1292      * hasExpiringTsaCert, hasExpiredTsaCert.
1293      *
1294      * @param isTsCert true if c is in the TSA cert chain, false otherwise.
1295      * @param checkUsage true to check code signer keyUsage
1296      */
1297     String printCert(boolean isTsCert, String tab, Certificate c,
1298         Date timestamp, boolean checkUsage) throws Exception {
1299 
1300         StringBuilder certStr = new StringBuilder();
1301         String space = rb.getString(&quot;SPACE&quot;);
1302         X509Certificate x509Cert = null;
1303 
1304         if (c instanceof X509Certificate) {
1305             x509Cert = (X509Certificate) c;
1306             certStr.append(tab).append(x509Cert.getType())
1307                 .append(rb.getString(&quot;COMMA&quot;))
1308                 .append(x509Cert.getSubjectDN().getName());
1309         } else {
1310             certStr.append(tab).append(c.getType());
1311         }
1312 
1313         String alias = storeHash.get(c);
1314         if (alias != null) {
1315             certStr.append(space).append(&quot;(&quot;).append(alias).append(&quot;)&quot;);
1316         }
1317 
1318         if (x509Cert != null) {
1319 
1320             certStr.append(&quot;\n&quot;).append(tab).append(&quot;[&quot;);
1321 
1322             if (trustedCerts.contains(x509Cert)) {
1323                 certStr.append(rb.getString(&quot;trusted.certificate&quot;));
1324             } else {
1325                 Date notAfter = x509Cert.getNotAfter();
1326                 try {
1327                     boolean printValidity = true;
1328                     if (isTsCert) {
1329                         if (tsaExpireDate == null || tsaExpireDate.after(notAfter)) {
1330                             tsaExpireDate = notAfter;
1331                         }
1332                     } else {
1333                         if (expireDate == null || expireDate.after(notAfter)) {
1334                             expireDate = notAfter;
1335                         }
1336                     }
1337                     if (timestamp == null) {
1338                         x509Cert.checkValidity();
1339                         // test if cert will expire within six months (or one year for tsa)
1340                         long age = isTsCert ? ONE_YEAR : SIX_MONTHS;
1341                         if (notAfter.getTime() &lt; System.currentTimeMillis() + age) {
1342                             if (isTsCert) {
1343                                 hasExpiringTsaCert = true;
1344                             } else {
1345                                 hasExpiringCert = true;
1346                             }
1347                             if (expiringTimeForm == null) {
1348                                 expiringTimeForm = new MessageFormat(
1349                                         rb.getString(&quot;certificate.will.expire.on&quot;));
1350                             }
1351                             Object[] source = {notAfter};
1352                             certStr.append(expiringTimeForm.format(source));
1353                             printValidity = false;
1354                         }
1355                     } else {
1356                         x509Cert.checkValidity(timestamp);
1357                     }
1358                     if (printValidity) {
1359                         if (validityTimeForm == null) {
1360                             validityTimeForm = new MessageFormat(
1361                                     rb.getString(&quot;certificate.is.valid.from&quot;));
1362                         }
1363                         Object[] source = {x509Cert.getNotBefore(), notAfter};
1364                         certStr.append(validityTimeForm.format(source));
1365                     }
1366                 } catch (CertificateExpiredException cee) {
1367                     if (isTsCert) {
1368                         hasExpiredTsaCert = true;
1369                     } else {
1370                         hasExpiredCert = true;
1371                     }
1372 
1373                     if (expiredTimeForm == null) {
1374                         expiredTimeForm = new MessageFormat(
1375                                 rb.getString(&quot;certificate.expired.on&quot;));
1376                     }
1377                     Object[] source = {notAfter};
1378                     certStr.append(expiredTimeForm.format(source));
1379 
1380                 } catch (CertificateNotYetValidException cnyve) {
1381                     if (!isTsCert) notYetValidCert = true;
1382 
1383                     if (notYetTimeForm == null) {
1384                         notYetTimeForm = new MessageFormat(
1385                                 rb.getString(&quot;certificate.is.not.valid.until&quot;));
1386                     }
1387                     Object[] source = {x509Cert.getNotBefore()};
1388                     certStr.append(notYetTimeForm.format(source));
1389                 }
1390             }
1391             certStr.append(&quot;]&quot;);
1392 
1393             if (checkUsage) {
1394                 boolean[] bad = new boolean[3];
1395                 checkCertUsage(x509Cert, bad);
1396                 if (bad[0] || bad[1] || bad[2]) {
1397                     String x = &quot;&quot;;
1398                     if (bad[0]) {
1399                         x =&quot;KeyUsage&quot;;
1400                     }
1401                     if (bad[1]) {
1402                         if (x.length() &gt; 0) x = x + &quot;, &quot;;
1403                         x = x + &quot;ExtendedKeyUsage&quot;;
1404                     }
1405                     if (bad[2]) {
1406                         if (x.length() &gt; 0) x = x + &quot;, &quot;;
1407                         x = x + &quot;NetscapeCertType&quot;;
1408                     }
1409                     certStr.append(&quot;\n&quot;).append(tab)
1410                         .append(MessageFormat.format(rb.getString(
1411                         &quot;.{0}.extension.does.not.support.code.signing.&quot;), x));
1412                 }
1413             }
1414         }
1415         return certStr.toString();
1416     }
1417 
1418     private static MessageFormat signTimeForm = null;
1419 
1420     private String printTimestamp(String tab, Timestamp timestamp) {
1421 
1422         if (signTimeForm == null) {
1423             signTimeForm =
1424                 new MessageFormat(rb.getString(&quot;entry.was.signed.on&quot;));
1425         }
1426         Object[] source = { timestamp.getTimestamp() };
1427 
1428         return new StringBuilder().append(tab).append(&quot;[&quot;)
1429             .append(signTimeForm.format(source)).append(&quot;]&quot;).toString();
1430     }
1431 
1432     private Map&lt;CodeSigner,Integer&gt; cacheForInKS = new IdentityHashMap&lt;&gt;();
1433 
1434     private int inKeyStoreForOneSigner(CodeSigner signer) {
1435         if (cacheForInKS.containsKey(signer)) {
1436             return cacheForInKS.get(signer);
1437         }
1438 
1439         int result = 0;
1440         if (store != null) {
1441             try {
1442                 List&lt;? extends Certificate&gt; certs =
1443                         signer.getSignerCertPath().getCertificates();
1444                 for (Certificate c : certs) {
1445                     String alias = storeHash.get(c);
1446                     if (alias == null) {
1447                         alias = store.getCertificateAlias(c);
1448                         if (alias != null) {
1449                             storeHash.put(c, alias);
1450                         }
1451                     }
1452                     if (alias != null) {
1453                         result |= IN_KEYSTORE;
1454                     }
1455                     for (String ckalias : ckaliases) {
1456                         if (c.equals(store.getCertificate(ckalias))) {
1457                             result |= SIGNED_BY_ALIAS;
1458                             // must continue with next certificate c and cannot
1459                             // return or break outer loop because has to fill
1460                             // storeHash for printCert
1461                             break;
1462                         }
1463                     }
1464                 }
1465             } catch (KeyStoreException kse) {
1466                 // never happens, because keystore has been loaded
1467             }
1468         }
1469         cacheForInKS.put(signer, result);
1470         return result;
1471     }
1472 
1473     /**
1474      * Maps certificates (as keys) to alias names associated in the keystore
1475      * {@link #store} (as values).
1476      */
1477     Hashtable&lt;Certificate, String&gt; storeHash = new Hashtable&lt;&gt;();
1478 
1479     int inKeyStore(CodeSigner[] signers) {
1480 
1481         if (signers == null)
1482             return 0;
1483 
1484         int output = 0;
1485 
1486         for (CodeSigner signer: signers) {
1487             int result = inKeyStoreForOneSigner(signer);
1488             output |= result;
1489         }
1490         if (ckaliases.size() &gt; 0 &amp;&amp; (output &amp; SIGNED_BY_ALIAS) == 0) {
1491             output |= NOT_ALIAS;
1492         }
1493         return output;
1494     }
1495 
1496     void signJar(String jarName, String alias)
1497             throws Exception {
1498 
1499         if (digestalg != null &amp;&amp; !DISABLED_CHECK.permits(
1500                 DIGEST_PRIMITIVE_SET, digestalg, null)) {
1501             weakAlg |= 1;
1502         }
1503         if (tSADigestAlg != null &amp;&amp; !DISABLED_CHECK.permits(
1504                 DIGEST_PRIMITIVE_SET, tSADigestAlg, null)) {
1505             weakAlg |= 4;
1506         }
1507         if (sigalg != null &amp;&amp; !DISABLED_CHECK.permits(
1508                 SIG_PRIMITIVE_SET , sigalg, null)) {
1509             weakAlg |= 2;
1510         }
1511         if (!DISABLED_CHECK.permits(
1512                 SIG_PRIMITIVE_SET, privateKey)) {
1513             weakAlg |= 8;
1514         }
1515 
1516         boolean aliasUsed = false;
1517         X509Certificate tsaCert = null;
1518 
1519         if (sigfile == null) {
1520             sigfile = alias;
1521             aliasUsed = true;
1522         }
1523 
1524         if (sigfile.length() &gt; 8) {
1525             sigfile = sigfile.substring(0, 8).toUpperCase(Locale.ENGLISH);
1526         } else {
1527             sigfile = sigfile.toUpperCase(Locale.ENGLISH);
1528         }
1529 
1530         StringBuilder tmpSigFile = new StringBuilder(sigfile.length());
1531         for (int j = 0; j &lt; sigfile.length(); j++) {
1532             char c = sigfile.charAt(j);
1533             if (!
1534                     ((c&gt;= &#39;A&#39; &amp;&amp; c&lt;= &#39;Z&#39;) ||
1535                             (c&gt;= &#39;0&#39; &amp;&amp; c&lt;= &#39;9&#39;) ||
1536                             (c == &#39;-&#39;) ||
1537                             (c == &#39;_&#39;))) {
1538                 if (aliasUsed) {
1539                     // convert illegal characters from the alias to be _&#39;s
1540                     c = &#39;_&#39;;
1541                 } else {
1542                     throw new
1543                             RuntimeException(rb.getString
1544                             (&quot;signature.filename.must.consist.of.the.following.characters.A.Z.0.9.or.&quot;));
1545                 }
1546             }
1547             tmpSigFile.append(c);
1548         }
1549 
1550         sigfile = tmpSigFile.toString();
1551 
1552         String tmpJarName;
1553         if (signedjar == null) tmpJarName = jarName+&quot;.sig&quot;;
1554         else tmpJarName = signedjar;
1555 
1556         File jarFile = new File(jarName);
1557         File signedJarFile = new File(tmpJarName);
1558 
1559         // Open the jar (zip) file
1560         try {
1561             zipFile = new ZipFile(jarName);
1562         } catch (IOException ioe) {
1563             error(rb.getString(&quot;unable.to.open.jar.file.&quot;)+jarName, ioe);
1564         }
1565 
1566         CertPath cp = CertificateFactory.getInstance(&quot;X.509&quot;)
1567                 .generateCertPath(Arrays.asList(certChain));
1568         JarSigner.Builder builder = new JarSigner.Builder(privateKey, cp);
1569 
1570         if (verbose != null) {
1571             builder.eventHandler((action, file) -&gt; {
1572                 switch (action) {
1573                     case &quot;signing&quot;:
1574                         System.out.println(rb.getString(&quot;.signing.&quot;) + file);
1575                         break;
1576                     case &quot;adding&quot;:
1577                         System.out.println(rb.getString(&quot;.adding.&quot;) + file);
1578                         break;
1579                     case &quot;updating&quot;:
1580                         System.out.println(rb.getString(&quot;.updating.&quot;) + file);
1581                         break;
1582                     default:
1583                         throw new IllegalArgumentException(&quot;unknown action: &quot;
1584                                 + action);
1585                 }
1586             });
1587         }
1588 
1589         if (digestalg != null) {
1590             builder.digestAlgorithm(digestalg);
1591         }
1592         if (sigalg != null) {
1593             builder.signatureAlgorithm(sigalg);
1594         }
1595 
1596         URI tsaURI = null;
1597 
1598         if (tsaUrl != null) {
1599             tsaURI = new URI(tsaUrl);
1600         } else if (tsaAlias != null) {
1601             tsaCert = getTsaCert(tsaAlias);
1602             tsaURI = TimestampedSigner.getTimestampingURI(tsaCert);
1603         }
1604 
1605         if (tsaURI != null) {
1606             if (verbose != null) {
1607                 System.out.println(
1608                         rb.getString(&quot;requesting.a.signature.timestamp&quot;));
1609                 if (tsaUrl != null) {
1610                     System.out.println(rb.getString(&quot;TSA.location.&quot;) + tsaUrl);
1611                 } else if (tsaCert != null) {
1612                     System.out.println(rb.getString(&quot;TSA.certificate.&quot;) +
1613                             printCert(true, &quot;&quot;, tsaCert, null, false));
1614                 }
1615             }
1616             builder.tsa(tsaURI);
1617             if (tSADigestAlg != null) {
1618                 builder.setProperty(&quot;tsaDigestAlg&quot;, tSADigestAlg);
1619             }
1620 
1621             if (tSAPolicyID != null) {
1622                 builder.setProperty(&quot;tsaPolicyId&quot;, tSAPolicyID);
1623             }
1624         }
1625 
1626         if (altSignerClass != null) {
1627             builder.setProperty(&quot;altSigner&quot;, altSignerClass);
1628             if (verbose != null) {
1629                 System.out.println(
1630                         rb.getString(&quot;using.an.alternative.signing.mechanism&quot;));
1631             }
1632         }
1633 
1634         if (altSignerClasspath != null) {
1635             builder.setProperty(&quot;altSignerPath&quot;, altSignerClasspath);
1636         }
1637 
1638         builder.signerName(sigfile);
1639 
1640         builder.setProperty(&quot;sectionsOnly&quot;, Boolean.toString(!signManifest));
1641         builder.setProperty(&quot;internalSF&quot;, Boolean.toString(!externalSF));
1642 
1643         FileOutputStream fos = null;
1644         try {
1645             fos = new FileOutputStream(signedJarFile);
1646         } catch (IOException ioe) {
1647             error(rb.getString(&quot;unable.to.create.&quot;)+tmpJarName, ioe);
1648         }
1649 
1650         Throwable failedCause = null;
1651         String failedMessage = null;
1652 
1653         try {
1654             builder.build().sign(zipFile, fos);
1655         } catch (JarSignerException e) {
1656             failedCause = e.getCause();
1657             if (failedCause instanceof SocketTimeoutException
1658                     || failedCause instanceof UnknownHostException) {
1659                 // Provide a helpful message when TSA is beyond a firewall
1660                 failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) +
1661                         rb.getString(&quot;no.response.from.the.Timestamping.Authority.&quot;) +
1662                         &quot;\n  -J-Dhttp.proxyHost=&lt;hostname&gt;&quot; +
1663                         &quot;\n  -J-Dhttp.proxyPort=&lt;portnumber&gt;\n&quot; +
1664                         rb.getString(&quot;or&quot;) +
1665                         &quot;\n  -J-Dhttps.proxyHost=&lt;hostname&gt; &quot; +
1666                         &quot;\n  -J-Dhttps.proxyPort=&lt;portnumber&gt; &quot;;
1667             } else {
1668                 // JarSignerException might have a null cause
1669                 if (failedCause == null) {
1670                     failedCause = e;
1671                 }
1672                 failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) + failedCause;
1673             }
1674         } catch (Exception e) {
1675             failedCause = e;
1676             failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) + failedCause;
1677         } finally {
1678             // close the resources
1679             if (zipFile != null) {
1680                 zipFile.close();
1681                 zipFile = null;
1682             }
1683 
1684             if (fos != null) {
1685                 fos.close();
1686             }
1687 
1688         }
1689 
1690         if (failedCause != null) {
1691             signedJarFile.delete();
1692             error(failedMessage, failedCause);
1693         }
1694 
1695         if (verbose != null) {
1696             System.out.println();
1697         }
1698 
1699         // The JarSigner API always accepts the timestamp received.
1700         // We need to extract the certs from the signed jar to
1701         // validate it.
1702         try (JarFile check = new JarFile(signedJarFile)) {
1703             PKCS7 p7 = new PKCS7(check.getInputStream(check.getEntry(
1704                     &quot;META-INF/&quot; + sigfile + &quot;.&quot; + privateKey.getAlgorithm())));
1705             Timestamp ts = null;
1706             try {
1707                 SignerInfo si = p7.getSignerInfos()[0];
1708                 if (si.getTsToken() != null) {
1709                     hasTimestampBlock = true;
1710                 }
1711                 ts = si.getTimestamp();
1712             } catch (Exception e) {
1713                 tsaChainNotValidated = true;
1714                 tsaChainNotValidatedReason = e;
1715             }
1716             // Spaces before the &quot;&gt;&gt;&gt; Signer&quot; and other lines are different
1717             String result = certsAndTSInfo(&quot;&quot;, &quot;    &quot;, Arrays.asList(certChain), ts);
1718             if (verbose != null) {
1719                 System.out.println(result);
1720             }
1721         } catch (Exception e) {
1722             if (debug) {
1723                 e.printStackTrace();
1724             }
1725         }
1726 
1727         if (signedjar == null) {
1728             // attempt an atomic rename. If that fails,
1729             // rename the original jar file, then the signed
1730             // one, then delete the original.
1731             if (!signedJarFile.renameTo(jarFile)) {
1732                 File origJar = new File(jarName+&quot;.orig&quot;);
1733 
1734                 if (jarFile.renameTo(origJar)) {
1735                     if (signedJarFile.renameTo(jarFile)) {
1736                         origJar.delete();
1737                     } else {
1738                         MessageFormat form = new MessageFormat(rb.getString
1739                     (&quot;attempt.to.rename.signedJarFile.to.jarFile.failed&quot;));
1740                         Object[] source = {signedJarFile, jarFile};
1741                         error(form.format(source));
1742                     }
1743                 } else {
1744                     MessageFormat form = new MessageFormat(rb.getString
1745                         (&quot;attempt.to.rename.jarFile.to.origJar.failed&quot;));
1746                     Object[] source = {jarFile, origJar};
1747                     error(form.format(source));
1748                 }
1749             }
1750         }
1751 
1752         displayMessagesAndResult(true);
1753     }
1754 
1755     /**
1756      * signature-related files include:
1757      * . META-INF/MANIFEST.MF
1758      * . META-INF/SIG-*
1759      * . META-INF/*.SF
1760      * . META-INF/*.DSA
1761      * . META-INF/*.RSA
1762      * . META-INF/*.EC
1763      */
1764     private boolean signatureRelated(String name) {
1765         return SignatureFileVerifier.isSigningRelated(name);
1766     }
1767 
1768     Map&lt;CodeSigner,String&gt; cacheForSignerInfo = new IdentityHashMap&lt;&gt;();
1769 
1770     /**
1771      * Returns a string of signer info, with a newline at the end.
1772      * Called by verifyJar().
1773      */
1774     private String signerInfo(CodeSigner signer, String tab) throws Exception {
1775         if (cacheForSignerInfo.containsKey(signer)) {
1776             return cacheForSignerInfo.get(signer);
1777         }
1778         List&lt;? extends Certificate&gt; certs = signer.getSignerCertPath().getCertificates();
1779         // signing time is only displayed on verification
1780         Timestamp ts = signer.getTimestamp();
1781         String tsLine = &quot;&quot;;
1782         if (ts != null) {
1783             tsLine = printTimestamp(tab, ts) + &quot;\n&quot;;
1784         }
1785         // Spaces before the &quot;&gt;&gt;&gt; Signer&quot; and other lines are the same.
1786 
1787         String result = certsAndTSInfo(tab, tab, certs, ts);
1788         cacheForSignerInfo.put(signer, tsLine + result);
1789         return result;
1790     }
1791 
1792     /**
1793      * Fills info on certs and timestamp into a StringBuilder, sets
1794      * warning flags (through printCert) and validates cert chains.
1795      *
1796      * @param tab1 spaces before the &quot;&gt;&gt;&gt; Signer&quot; line
1797      * @param tab2 spaces before the other lines
1798      * @param certs the signer cert
1799      * @param ts the timestamp, can be null
1800      * @return the info as a string
1801      */
1802     private String certsAndTSInfo(
1803             String tab1,
1804             String tab2,
1805             List&lt;? extends Certificate&gt; certs, Timestamp ts)
1806             throws Exception {
1807 
1808         Date timestamp;
1809         if (ts != null) {
1810             timestamp = ts.getTimestamp();
1811             noTimestamp = false;
1812         } else {
1813             timestamp = null;
1814         }
1815         // display the certificate(sb). The first one is end-entity cert and
1816         // its KeyUsage should be checked.
1817         boolean first = true;
1818         StringBuilder sb = new StringBuilder();
1819         sb.append(tab1).append(rb.getString(&quot;...Signer&quot;)).append(&#39;\n&#39;);
1820         for (Certificate c : certs) {
1821             sb.append(printCert(false, tab2, c, timestamp, first));
1822             sb.append(&#39;\n&#39;);
1823             first = false;
1824         }
1825         try {
1826             validateCertChain(Validator.VAR_CODE_SIGNING, certs, ts);
1827         } catch (Exception e) {
1828             chainNotValidated = true;
1829             chainNotValidatedReason = e;
1830             sb.append(tab2).append(rb.getString(&quot;.Invalid.certificate.chain.&quot;))
1831                     .append(e.getLocalizedMessage()).append(&quot;]\n&quot;);
1832         }
1833         if (ts != null) {
1834             sb.append(tab1).append(rb.getString(&quot;...TSA&quot;)).append(&#39;\n&#39;);
1835             for (Certificate c : ts.getSignerCertPath().getCertificates()) {
1836                 sb.append(printCert(true, tab2, c, null, false));
1837                 sb.append(&#39;\n&#39;);
1838             }
1839             try {
1840                 validateCertChain(Validator.VAR_TSA_SERVER,
1841                         ts.getSignerCertPath().getCertificates(), null);
1842             } catch (Exception e) {
1843                 tsaChainNotValidated = true;
1844                 tsaChainNotValidatedReason = e;
1845                 sb.append(tab2).append(rb.getString(&quot;.Invalid.TSA.certificate.chain.&quot;))
1846                         .append(e.getLocalizedMessage()).append(&quot;]\n&quot;);
1847             }
1848         }
1849         if (certs.size() == 1
1850                 &amp;&amp; KeyStoreUtil.isSelfSigned((X509Certificate)certs.get(0))) {
1851             signerSelfSigned = true;
1852         }
1853 
1854         return sb.toString();
1855     }
1856 
1857     void loadKeyStore(String keyStoreName, boolean prompt) {
1858 
1859         if (!nullStream &amp;&amp; keyStoreName == null) {
1860             keyStoreName = System.getProperty(&quot;user.home&quot;) + File.separator
1861                 + &quot;.keystore&quot;;
1862         }
1863 
1864         try {
1865             try {
1866                 KeyStore caks = KeyStoreUtil.getCacertsKeyStore();
1867                 if (caks != null) {
1868                     Enumeration&lt;String&gt; aliases = caks.aliases();
1869                     while (aliases.hasMoreElements()) {
1870                         String a = aliases.nextElement();
1871                         try {
1872                             trustedCerts.add((X509Certificate)caks.getCertificate(a));
1873                         } catch (Exception e2) {
1874                             // ignore, when a SecretkeyEntry does not include a cert
1875                         }
1876                     }
1877                 }
1878             } catch (Exception e) {
1879                 // Ignore, if cacerts cannot be loaded
1880             }
1881 
1882             if (providerName == null) {
1883                 store = KeyStore.getInstance(storetype);
1884             } else {
1885                 store = KeyStore.getInstance(storetype, providerName);
1886             }
1887 
1888             // Get pass phrase
1889             // XXX need to disable echo; on UNIX, call getpass(char *prompt)Z
1890             // and on NT call ??
1891             if (token &amp;&amp; storepass == null &amp;&amp; !protectedPath
1892                     &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)) {
1893                 storepass = getPass
1894                         (rb.getString(&quot;Enter.Passphrase.for.keystore.&quot;));
1895             } else if (!token &amp;&amp; storepass == null &amp;&amp; prompt) {
1896                 storepass = getPass
1897                         (rb.getString(&quot;Enter.Passphrase.for.keystore.&quot;));
1898             }
1899 
1900             try {
1901                 if (nullStream) {
1902                     store.load(null, storepass);
1903                 } else {
1904                     keyStoreName = keyStoreName.replace(File.separatorChar, &#39;/&#39;);
1905                     URL url = null;
1906                     try {
1907                         url = new URL(keyStoreName);
1908                     } catch (java.net.MalformedURLException e) {
1909                         // try as file
1910                         url = new File(keyStoreName).toURI().toURL();
1911                     }
1912                     InputStream is = null;
1913                     try {
1914                         is = url.openStream();
1915                         store.load(is, storepass);
1916                     } finally {
1917                         if (is != null) {
1918                             is.close();
1919                         }
1920                     }
1921                 }
1922                 Enumeration&lt;String&gt; aliases = store.aliases();
1923                 while (aliases.hasMoreElements()) {
1924                     String a = aliases.nextElement();
1925                     try {
1926                         X509Certificate c = (X509Certificate)store.getCertificate(a);
1927                         // Only add TrustedCertificateEntry and self-signed
1928                         // PrivateKeyEntry
1929                         if (store.isCertificateEntry(a) ||
1930                                 c.getSubjectDN().equals(c.getIssuerDN())) {
1931                             trustedCerts.add(c);
1932                         }
1933                     } catch (Exception e2) {
1934                         // ignore, when a SecretkeyEntry does not include a cert
1935                     }
1936                 }
1937             } finally {
1938                 try {
1939                     pkixParameters = new PKIXBuilderParameters(
1940                             trustedCerts.stream()
1941                                     .map(c -&gt; new TrustAnchor(c, null))
1942                                     .collect(Collectors.toSet()),
1943                             null);
1944                     pkixParameters.setRevocationEnabled(false);
1945                 } catch (InvalidAlgorithmParameterException ex) {
1946                     // Only if tas is empty
1947                 }
1948             }
1949         } catch (IOException ioe) {
1950             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
1951                                         ioe.getMessage());
1952         } catch (java.security.cert.CertificateException ce) {
1953             throw new RuntimeException(rb.getString(&quot;certificate.exception.&quot;) +
1954                                         ce.getMessage());
1955         } catch (NoSuchProviderException pe) {
1956             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
1957                                         pe.getMessage());
1958         } catch (NoSuchAlgorithmException nsae) {
1959             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
1960                                         nsae.getMessage());
1961         } catch (KeyStoreException kse) {
1962             throw new RuntimeException
1963                 (rb.getString(&quot;unable.to.instantiate.keystore.class.&quot;) +
1964                 kse.getMessage());
1965         }
1966     }
1967 
1968     X509Certificate getTsaCert(String alias) {
1969 
1970         java.security.cert.Certificate cs = null;
1971 
1972         try {
1973             cs = store.getCertificate(alias);
1974         } catch (KeyStoreException kse) {
1975             // this never happens, because keystore has been loaded
1976         }
1977         if (cs == null || (!(cs instanceof X509Certificate))) {
1978             MessageFormat form = new MessageFormat(rb.getString
1979                 (&quot;Certificate.not.found.for.alias.alias.must.reference.a.valid.KeyStore.entry.containing.an.X.509.public.key.certificate.for.the&quot;));
1980             Object[] source = {alias, alias};
1981             error(form.format(source));
1982         }
1983         return (X509Certificate) cs;
1984     }
1985 
1986     /**
1987      * Check if userCert is designed to be a code signer
1988      * @param userCert the certificate to be examined
1989      * @param bad 3 booleans to show if the KeyUsage, ExtendedKeyUsage,
1990      *            NetscapeCertType has codeSigning flag turned on.
1991      *            If null, the class field badKeyUsage, badExtendedKeyUsage,
1992      *            badNetscapeCertType will be set.
1993      */
1994     void checkCertUsage(X509Certificate userCert, boolean[] bad) {
1995 
1996         // Can act as a signer?
1997         // 1. if KeyUsage, then [0:digitalSignature] or
1998         //    [1:nonRepudiation] should be true
1999         // 2. if ExtendedKeyUsage, then should contains ANY or CODE_SIGNING
2000         // 3. if NetscapeCertType, then should contains OBJECT_SIGNING
2001         // 1,2,3 must be true
2002 
2003         if (bad != null) {
2004             bad[0] = bad[1] = bad[2] = false;
2005         }
2006 
2007         boolean[] keyUsage = userCert.getKeyUsage();
2008         if (keyUsage != null) {
2009             keyUsage = Arrays.copyOf(keyUsage, 9);
2010             if (!keyUsage[0] &amp;&amp; !keyUsage[1]) {
2011                 if (bad != null) {
2012                     bad[0] = true;
2013                     badKeyUsage = true;
2014                 }
2015             }
2016         }
2017 
2018         try {
2019             List&lt;String&gt; xKeyUsage = userCert.getExtendedKeyUsage();
2020             if (xKeyUsage != null) {
2021                 if (!xKeyUsage.contains(&quot;2.5.29.37.0&quot;) // anyExtendedKeyUsage
2022                         &amp;&amp; !xKeyUsage.contains(&quot;1.3.6.1.5.5.7.3.3&quot;)) {  // codeSigning
2023                     if (bad != null) {
2024                         bad[1] = true;
2025                         badExtendedKeyUsage = true;
2026                     }
2027                 }
2028             }
2029         } catch (java.security.cert.CertificateParsingException e) {
2030             // shouldn&#39;t happen
2031         }
2032 
2033         try {
2034             // OID_NETSCAPE_CERT_TYPE
2035             byte[] netscapeEx = userCert.getExtensionValue
2036                     (&quot;2.16.840.1.113730.1.1&quot;);
2037             if (netscapeEx != null) {
2038                 DerInputStream in = new DerInputStream(netscapeEx);
2039                 byte[] encoded = in.getOctetString();
2040                 encoded = new DerValue(encoded).getUnalignedBitString()
2041                         .toByteArray();
2042 
2043                 NetscapeCertTypeExtension extn =
2044                         new NetscapeCertTypeExtension(encoded);
2045 
2046                 Boolean val = extn.get(NetscapeCertTypeExtension.OBJECT_SIGNING);
2047                 if (!val) {
2048                     if (bad != null) {
2049                         bad[2] = true;
2050                         badNetscapeCertType = true;
2051                     }
2052                 }
2053             }
2054         } catch (IOException e) {
2055             //
2056         }
2057     }
2058 
2059     // Called by signJar().
2060     void getAliasInfo(String alias) throws Exception {
2061 
2062         Key key = null;
2063 
2064         try {
2065             java.security.cert.Certificate[] cs = null;
2066             if (altCertChain != null) {
2067                 try (FileInputStream fis = new FileInputStream(altCertChain)) {
2068                     cs = CertificateFactory.getInstance(&quot;X.509&quot;).
2069                             generateCertificates(fis).
2070                             toArray(new Certificate[0]);
2071                 } catch (FileNotFoundException ex) {
2072                     error(rb.getString(&quot;File.specified.by.certchain.does.not.exist&quot;));
2073                 } catch (CertificateException | IOException ex) {
2074                     error(rb.getString(&quot;Cannot.restore.certchain.from.file.specified&quot;));
2075                 }
2076             } else {
2077                 try {
2078                     cs = store.getCertificateChain(alias);
2079                 } catch (KeyStoreException kse) {
2080                     // this never happens, because keystore has been loaded
2081                 }
2082             }
2083             if (cs == null || cs.length == 0) {
2084                 if (altCertChain != null) {
2085                     error(rb.getString
2086                             (&quot;Certificate.chain.not.found.in.the.file.specified.&quot;));
2087                 } else {
2088                     MessageFormat form = new MessageFormat(rb.getString
2089                         (&quot;Certificate.chain.not.found.for.alias.alias.must.reference.a.valid.KeyStore.key.entry.containing.a.private.key.and&quot;));
2090                     Object[] source = {alias, alias};
2091                     error(form.format(source));
2092                 }
2093             }
2094 
2095             certChain = new X509Certificate[cs.length];
2096             for (int i=0; i&lt;cs.length; i++) {
2097                 if (!(cs[i] instanceof X509Certificate)) {
2098                     error(rb.getString
2099                         (&quot;found.non.X.509.certificate.in.signer.s.chain&quot;));
2100                 }
2101                 certChain[i] = (X509Certificate)cs[i];
2102             }
2103 
2104             try {
2105                 if (!token &amp;&amp; keypass == null)
2106                     key = store.getKey(alias, storepass);
2107                 else
2108                     key = store.getKey(alias, keypass);
2109             } catch (UnrecoverableKeyException e) {
2110                 if (token) {
2111                     throw e;
2112                 } else if (keypass == null) {
2113                     // Did not work out, so prompt user for key password
2114                     MessageFormat form = new MessageFormat(rb.getString
2115                         (&quot;Enter.key.password.for.alias.&quot;));
2116                     Object[] source = {alias};
2117                     keypass = getPass(form.format(source));
2118                     key = store.getKey(alias, keypass);
2119                 }
2120             }
2121         } catch (NoSuchAlgorithmException e) {
2122             error(e.getMessage());
2123         } catch (UnrecoverableKeyException e) {
2124             error(rb.getString(&quot;unable.to.recover.key.from.keystore&quot;));
2125         } catch (KeyStoreException kse) {
2126             // this never happens, because keystore has been loaded
2127         }
2128 
2129         if (!(key instanceof PrivateKey)) {
2130             MessageFormat form = new MessageFormat(rb.getString
2131                 (&quot;key.associated.with.alias.not.a.private.key&quot;));
2132             Object[] source = {alias};
2133             error(form.format(source));
2134         } else {
2135             privateKey = (PrivateKey)key;
2136         }
2137     }
2138 
2139     void error(String message) {
2140         System.out.println(rb.getString(&quot;jarsigner.&quot;)+message);
2141         System.exit(1);
2142     }
2143 
2144 
2145     void error(String message, Throwable e) {
2146         System.out.println(rb.getString(&quot;jarsigner.&quot;)+message);
2147         if (debug) {
2148             e.printStackTrace();
2149         }
2150         System.exit(1);
2151     }
2152 
2153     /**
2154      * Validates a cert chain.
2155      *
2156      * @param parameter this might be a timestamp
2157      */
2158     void validateCertChain(String variant, List&lt;? extends Certificate&gt; certs,
2159                            Timestamp parameter)
2160             throws Exception {
2161         try {
2162             Validator.getInstance(Validator.TYPE_PKIX,
2163                     variant,
2164                     pkixParameters)
2165                     .validate(certs.toArray(new X509Certificate[certs.size()]),
2166                             null, parameter);
2167         } catch (Exception e) {
2168             if (debug) {
2169                 e.printStackTrace();
2170             }
2171 
2172             // Exception might be dismissed if another warning flag
2173             // is already set by printCert.
2174 
2175             if (variant.equals(Validator.VAR_TSA_SERVER) &amp;&amp;
2176                     e instanceof ValidatorException) {
2177                 // Throw cause if it&#39;s CertPathValidatorException,
2178                 if (e.getCause() != null &amp;&amp;
2179                         e.getCause() instanceof CertPathValidatorException) {
2180                     e = (Exception) e.getCause();
2181                     Throwable t = e.getCause();
2182                     if ((t instanceof CertificateExpiredException &amp;&amp;
2183                             hasExpiredTsaCert)) {
2184                         // we already have hasExpiredTsaCert
2185                         return;
2186                     }
2187                 }
2188             }
2189 
2190             if (variant.equals(Validator.VAR_CODE_SIGNING) &amp;&amp;
2191                     e instanceof ValidatorException) {
2192                 // Throw cause if it&#39;s CertPathValidatorException,
2193                 if (e.getCause() != null &amp;&amp;
2194                         e.getCause() instanceof CertPathValidatorException) {
2195                     e = (Exception) e.getCause();
2196                     Throwable t = e.getCause();
2197                     if ((t instanceof CertificateExpiredException &amp;&amp;
2198                                 hasExpiredCert) ||
2199                             (t instanceof CertificateNotYetValidException &amp;&amp;
2200                                     notYetValidCert)) {
2201                         // we already have hasExpiredCert and notYetValidCert
2202                         return;
2203                     }
2204                 }
2205                 if (e instanceof ValidatorException) {
2206                     ValidatorException ve = (ValidatorException)e;
2207                     if (ve.getErrorType() == ValidatorException.T_EE_EXTENSIONS &amp;&amp;
2208                             (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType)) {
2209                         // We already have badKeyUsage, badExtendedKeyUsage
2210                         // and badNetscapeCertType
2211                         return;
2212                     }
2213                 }
2214             }
2215             throw e;
2216         }
2217     }
2218 
2219     char[] getPass(String prompt) {
2220         System.err.print(prompt);
2221         System.err.flush();
2222         try {
2223             char[] pass = Password.readPassword(System.in);
2224 
2225             if (pass == null) {
2226                 error(rb.getString(&quot;you.must.enter.key.password&quot;));
2227             } else {
2228                 return pass;
2229             }
2230         } catch (IOException ioe) {
2231             error(rb.getString(&quot;unable.to.read.password.&quot;)+ioe.getMessage());
2232         }
2233         // this shouldn&#39;t happen
2234         return null;
2235     }
2236 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
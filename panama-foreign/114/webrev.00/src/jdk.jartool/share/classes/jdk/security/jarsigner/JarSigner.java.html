<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jartool/share/classes/jdk/security/jarsigner/JarSigner.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.security.jarsigner;
  27 
  28 import com.sun.jarsigner.ContentSigner;
  29 import com.sun.jarsigner.ContentSignerParameters;
  30 import sun.security.tools.PathList;
  31 import sun.security.tools.jarsigner.TimestampedSigner;
  32 import sun.security.util.ManifestDigester;
  33 import sun.security.util.SignatureFileVerifier;
  34 import sun.security.x509.AlgorithmId;
  35 
  36 import java.io.*;
  37 import java.lang.reflect.InvocationTargetException;
  38 import java.net.SocketTimeoutException;
  39 import java.net.URI;
  40 import java.net.URL;
  41 import java.net.URLClassLoader;
  42 import java.security.*;
  43 import java.security.cert.CertPath;
  44 import java.security.cert.Certificate;
  45 import java.security.cert.CertificateException;
  46 import java.security.cert.X509Certificate;
  47 import java.util.*;
  48 import java.util.function.BiConsumer;
  49 import java.util.jar.Attributes;
  50 import java.util.jar.JarEntry;
  51 import java.util.jar.JarFile;
  52 import java.util.jar.Manifest;
  53 import java.util.zip.ZipEntry;
  54 import java.util.zip.ZipFile;
  55 import java.util.zip.ZipOutputStream;
  56 
  57 /**
  58  * An immutable utility class to sign a jar file.
  59  * &lt;p&gt;
  60  * A caller creates a {@code JarSigner.Builder} object, (optionally) sets
  61  * some parameters, and calls {@link JarSigner.Builder#build build} to create
  62  * a {@code JarSigner} object. This {@code JarSigner} object can then
  63  * be used to sign a jar file.
  64  * &lt;p&gt;
  65  * Unless otherwise stated, calling a method of {@code JarSigner} or
  66  * {@code JarSigner.Builder} with a null argument will throw
  67  * a {@link NullPointerException}.
  68  * &lt;p&gt;
  69  * Example:
  70  * &lt;pre&gt;
  71  * JarSigner signer = new JarSigner.Builder(key, certPath)
  72  *         .digestAlgorithm(&quot;SHA-1&quot;)
  73  *         .signatureAlgorithm(&quot;SHA1withDSA&quot;)
  74  *         .build();
  75  * try (ZipFile in = new ZipFile(inputFile);
  76  *         FileOutputStream out = new FileOutputStream(outputFile)) {
  77  *     signer.sign(in, out);
  78  * }
  79  * &lt;/pre&gt;
  80  *
  81  * @since 9
  82  */
  83 public final class JarSigner {
  84 
  85     /**
  86      * A mutable builder class that can create an immutable {@code JarSigner}
  87      * from various signing-related parameters.
  88      *
  89      * @since 9
  90      */
  91     public static class Builder {
  92 
  93         // Signer materials:
  94         final PrivateKey privateKey;
  95         final X509Certificate[] certChain;
  96 
  97         // JarSigner options:
  98         // Support multiple digestalg internally. Can be null, but not empty
  99         String[] digestalg;
 100         String sigalg;
 101         // Precisely should be one provider for each digestalg, maybe later
 102         Provider digestProvider;
 103         Provider sigProvider;
 104         URI tsaUrl;
 105         String signerName;
 106         BiConsumer&lt;String,String&gt; handler;
 107 
 108         // Implementation-specific properties:
 109         String tSAPolicyID;
 110         String tSADigestAlg;
 111         boolean signManifest = true;
 112         boolean externalSF = true;
 113         String altSignerPath;
 114         String altSigner;
 115 
 116         /**
 117          * Creates a {@code JarSigner.Builder} object with
 118          * a {@link KeyStore.PrivateKeyEntry} object.
 119          *
 120          * @param entry the {@link KeyStore.PrivateKeyEntry} of the signer.
 121          */
 122         public Builder(KeyStore.PrivateKeyEntry entry) {
 123             this.privateKey = entry.getPrivateKey();
 124             try {
 125                 // called internally, no need to clone
 126                 Certificate[] certs = entry.getCertificateChain();
 127                 this.certChain = Arrays.copyOf(certs, certs.length,
 128                         X509Certificate[].class);
 129             } catch (ArrayStoreException ase) {
 130                 // Wrong type, not X509Certificate. Won&#39;t document.
 131                 throw new IllegalArgumentException(
 132                         &quot;Entry does not contain X509Certificate&quot;);
 133             }
 134         }
 135 
 136         /**
 137          * Creates a {@code JarSigner.Builder} object with a private key and
 138          * a certification path.
 139          *
 140          * @param privateKey the private key of the signer.
 141          * @param certPath the certification path of the signer.
 142          * @throws IllegalArgumentException if {@code certPath} is empty, or
 143          *      the {@code privateKey} algorithm does not match the algorithm
 144          *      of the {@code PublicKey} in the end entity certificate
 145          *      (the first certificate in {@code certPath}).
 146          */
 147         public Builder(PrivateKey privateKey, CertPath certPath) {
 148             List&lt;? extends Certificate&gt; certs = certPath.getCertificates();
 149             if (certs.isEmpty()) {
 150                 throw new IllegalArgumentException(&quot;certPath cannot be empty&quot;);
 151             }
 152             if (!privateKey.getAlgorithm().equals
 153                     (certs.get(0).getPublicKey().getAlgorithm())) {
 154                 throw new IllegalArgumentException
 155                         (&quot;private key algorithm does not match &quot; +
 156                                 &quot;algorithm of public key in end entity &quot; +
 157                                 &quot;certificate (the 1st in certPath)&quot;);
 158             }
 159             this.privateKey = privateKey;
 160             try {
 161                 this.certChain = certs.toArray(new X509Certificate[certs.size()]);
 162             } catch (ArrayStoreException ase) {
 163                 // Wrong type, not X509Certificate.
 164                 throw new IllegalArgumentException(
 165                         &quot;Entry does not contain X509Certificate&quot;);
 166             }
 167         }
 168 
 169         /**
 170          * Sets the digest algorithm. If no digest algorithm is specified,
 171          * the default algorithm returned by {@link #getDefaultDigestAlgorithm}
 172          * will be used.
 173          *
 174          * @param algorithm the standard name of the algorithm. See
 175          *      the {@code MessageDigest} section in the &lt;a href=
 176          *      &quot;{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms&quot;&gt;
 177          *      Java Cryptography Architecture Standard Algorithm Name
 178          *      Documentation&lt;/a&gt; for information about standard algorithm names.
 179          * @return the {@code JarSigner.Builder} itself.
 180          * @throws NoSuchAlgorithmException if {@code algorithm} is not available.
 181          */
 182         public Builder digestAlgorithm(String algorithm) throws NoSuchAlgorithmException {
 183             MessageDigest.getInstance(Objects.requireNonNull(algorithm));
 184             this.digestalg = new String[]{algorithm};
 185             this.digestProvider = null;
 186             return this;
 187         }
 188 
 189         /**
 190          * Sets the digest algorithm from the specified provider.
 191          * If no digest algorithm is specified, the default algorithm
 192          * returned by {@link #getDefaultDigestAlgorithm} will be used.
 193          *
 194          * @param algorithm the standard name of the algorithm. See
 195          *      the {@code MessageDigest} section in the &lt;a href=
 196          *      &quot;{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms&quot;&gt;
 197          *      Java Cryptography Architecture Standard Algorithm Name
 198          *      Documentation&lt;/a&gt; for information about standard algorithm names.
 199          * @param provider the provider.
 200          * @return the {@code JarSigner.Builder} itself.
 201          * @throws NoSuchAlgorithmException if {@code algorithm} is not
 202          *      available in the specified provider.
 203          */
 204         public Builder digestAlgorithm(String algorithm, Provider provider)
 205                 throws NoSuchAlgorithmException {
 206             MessageDigest.getInstance(
 207                     Objects.requireNonNull(algorithm),
 208                     Objects.requireNonNull(provider));
 209             this.digestalg = new String[]{algorithm};
 210             this.digestProvider = provider;
 211             return this;
 212         }
 213 
 214         /**
 215          * Sets the signature algorithm. If no signature algorithm
 216          * is specified, the default signature algorithm returned by
 217          * {@link #getDefaultSignatureAlgorithm} for the private key
 218          * will be used.
 219          *
 220          * @param algorithm the standard name of the algorithm. See
 221          *      the {@code Signature} section in the &lt;a href=
 222          *      &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 223          *      Java Cryptography Architecture Standard Algorithm Name
 224          *      Documentation&lt;/a&gt; for information about standard algorithm names.
 225          * @return the {@code JarSigner.Builder} itself.
 226          * @throws NoSuchAlgorithmException if {@code algorithm} is not available.
 227          * @throws IllegalArgumentException if {@code algorithm} is not
 228          *      compatible with the algorithm of the signer&#39;s private key.
 229          */
 230         public Builder signatureAlgorithm(String algorithm)
 231                 throws NoSuchAlgorithmException {
 232             // Check availability
 233             Signature.getInstance(Objects.requireNonNull(algorithm));
 234             AlgorithmId.checkKeyAndSigAlgMatch(
 235                     privateKey.getAlgorithm(), algorithm);
 236             this.sigalg = algorithm;
 237             this.sigProvider = null;
 238             return this;
 239         }
 240 
 241         /**
 242          * Sets the signature algorithm from the specified provider. If no
 243          * signature algorithm is specified, the default signature algorithm
 244          * returned by {@link #getDefaultSignatureAlgorithm} for the private
 245          * key will be used.
 246          *
 247          * @param algorithm the standard name of the algorithm. See
 248          *      the {@code Signature} section in the &lt;a href=
 249          *      &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 250          *      Java Cryptography Architecture Standard Algorithm Name
 251          *      Documentation&lt;/a&gt; for information about standard algorithm names.
 252          * @param provider  the provider.
 253          * @return the {@code JarSigner.Builder} itself.
 254          * @throws NoSuchAlgorithmException if {@code algorithm} is not
 255          *      available in the specified provider.
 256          * @throws IllegalArgumentException if {@code algorithm} is not
 257          *      compatible with the algorithm of the signer&#39;s private key.
 258          */
 259         public Builder signatureAlgorithm(String algorithm, Provider provider)
 260                 throws NoSuchAlgorithmException {
 261             // Check availability
 262             Signature.getInstance(
 263                     Objects.requireNonNull(algorithm),
 264                     Objects.requireNonNull(provider));
 265             AlgorithmId.checkKeyAndSigAlgMatch(
 266                     privateKey.getAlgorithm(), algorithm);
 267             this.sigalg = algorithm;
 268             this.sigProvider = provider;
 269             return this;
 270         }
 271 
 272         /**
 273          * Sets the URI of the Time Stamping Authority (TSA).
 274          *
 275          * @param uri the URI.
 276          * @return the {@code JarSigner.Builder} itself.
 277          */
 278         public Builder tsa(URI uri) {
 279             this.tsaUrl = Objects.requireNonNull(uri);
 280             return this;
 281         }
 282 
 283         /**
 284          * Sets the signer name. The name will be used as the base name for
 285          * the signature files. All lowercase characters will be converted to
 286          * uppercase for signature file names. If a signer name is not
 287          * specified, the string &quot;SIGNER&quot; will be used.
 288          *
 289          * @param name the signer name.
 290          * @return the {@code JarSigner.Builder} itself.
 291          * @throws IllegalArgumentException if {@code name} is empty or has
 292          *      a size bigger than 8, or it contains characters not from the
 293          *      set &quot;a-zA-Z0-9_-&quot;.
 294          */
 295         public Builder signerName(String name) {
 296             if (name.isEmpty() || name.length() &gt; 8) {
 297                 throw new IllegalArgumentException(&quot;Name too long&quot;);
 298             }
 299 
 300             name = name.toUpperCase(Locale.ENGLISH);
 301 
 302             for (int j = 0; j &lt; name.length(); j++) {
 303                 char c = name.charAt(j);
 304                 if (!
 305                         ((c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) ||
 306                                 (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) ||
 307                                 (c == &#39;-&#39;) ||
 308                                 (c == &#39;_&#39;))) {
 309                     throw new IllegalArgumentException(
 310                             &quot;Invalid characters in name&quot;);
 311                 }
 312             }
 313             this.signerName = name;
 314             return this;
 315         }
 316 
 317         /**
 318          * Sets en event handler that will be triggered when a {@link JarEntry}
 319          * is to be added, signed, or updated during the signing process.
 320          * &lt;p&gt;
 321          * The handler can be used to display signing progress. The first
 322          * argument of the handler can be &quot;adding&quot;, &quot;signing&quot;, or &quot;updating&quot;,
 323          * and the second argument is the name of the {@link JarEntry}
 324          * being processed.
 325          *
 326          * @param handler the event handler.
 327          * @return the {@code JarSigner.Builder} itself.
 328          */
 329         public Builder eventHandler(BiConsumer&lt;String,String&gt; handler) {
 330             this.handler = Objects.requireNonNull(handler);
 331             return this;
 332         }
 333 
 334         /**
 335          * Sets an additional implementation-specific property indicated by
 336          * the specified key.
 337          *
 338          * @implNote This implementation supports the following properties:
 339          * &lt;ul&gt;
 340          * &lt;li&gt;&quot;tsaDigestAlg&quot;: algorithm of digest data in the timestamping
 341          * request. The default value is the same as the result of
 342          * {@link #getDefaultDigestAlgorithm}.
 343          * &lt;li&gt;&quot;tsaPolicyId&quot;: TSAPolicyID for Timestamping Authority.
 344          * No default value.
 345          * &lt;li&gt;&quot;internalsf&quot;: &quot;true&quot; if the .SF file is included inside the
 346          * signature block, &quot;false&quot; otherwise. Default &quot;false&quot;.
 347          * &lt;li&gt;&quot;sectionsonly&quot;: &quot;true&quot; if the .SF file only contains the hash
 348          * value for each section of the manifest and not for the whole
 349          * manifest, &quot;false&quot; otherwise. Default &quot;false&quot;.
 350          * &lt;/ul&gt;
 351          * All property names are case-insensitive.
 352          *
 353          * @param key the name of the property.
 354          * @param value the value of the property.
 355          * @return the {@code JarSigner.Builder} itself.
 356          * @throws UnsupportedOperationException if the key is not supported
 357          *      by this implementation.
 358          * @throws IllegalArgumentException if the value is not accepted as
 359          *      a legal value for this key.
 360          */
 361         public Builder setProperty(String key, String value) {
 362             Objects.requireNonNull(key);
 363             Objects.requireNonNull(value);
 364             switch (key.toLowerCase(Locale.US)) {
 365                 case &quot;tsadigestalg&quot;:
 366                     try {
 367                         MessageDigest.getInstance(value);
 368                     } catch (NoSuchAlgorithmException nsae) {
 369                         throw new IllegalArgumentException(
 370                                 &quot;Invalid tsadigestalg&quot;, nsae);
 371                     }
 372                     this.tSADigestAlg = value;
 373                     break;
 374                 case &quot;tsapolicyid&quot;:
 375                     this.tSAPolicyID = value;
 376                     break;
 377                 case &quot;internalsf&quot;:
 378                     switch (value) {
 379                         case &quot;true&quot;:
 380                             externalSF = false;
 381                             break;
 382                         case &quot;false&quot;:
 383                             externalSF = true;
 384                             break;
 385                         default:
 386                             throw new IllegalArgumentException(
 387                                 &quot;Invalid internalsf value&quot;);
 388                     }
 389                     break;
 390                 case &quot;sectionsonly&quot;:
 391                     switch (value) {
 392                         case &quot;true&quot;:
 393                             signManifest = false;
 394                             break;
 395                         case &quot;false&quot;:
 396                             signManifest = true;
 397                             break;
 398                         default:
 399                             throw new IllegalArgumentException(
 400                                 &quot;Invalid signManifest value&quot;);
 401                     }
 402                     break;
 403                 case &quot;altsignerpath&quot;:
 404                     altSignerPath = value;
 405                     break;
 406                 case &quot;altsigner&quot;:
 407                     altSigner = value;
 408                     break;
 409                 default:
 410                     throw new UnsupportedOperationException(
 411                             &quot;Unsupported key &quot; + key);
 412             }
 413             return this;
 414         }
 415 
 416         /**
 417          * Gets the default digest algorithm.
 418          *
 419          * @implNote This implementation returns &quot;SHA-256&quot;. The value may
 420          * change in the future.
 421          *
 422          * @return the default digest algorithm.
 423          */
 424         public static String getDefaultDigestAlgorithm() {
 425             return &quot;SHA-256&quot;;
 426         }
 427 
 428         /**
 429          * Gets the default signature algorithm for a private key.
 430          * For example, SHA256withRSA for a 2048-bit RSA key, and
 431          * SHA384withECDSA for a 384-bit EC key.
 432          *
 433          * @implNote This implementation makes use of comparable strengths
 434          * as defined in Tables 2 and 3 of NIST SP 800-57 Part 1-Rev.4.
 435          * Specifically, if a DSA or RSA key with a key size greater than 7680
 436          * bits, or an EC key with a key size greater than or equal to 512 bits,
 437          * SHA-512 will be used as the hash function for the signature.
 438          * If a DSA or RSA key has a key size greater than 3072 bits, or an
 439          * EC key has a key size greater than or equal to 384 bits, SHA-384 will
 440          * be used. Otherwise, SHA-256 will be used. The value may
 441          * change in the future.
 442          *
 443          * @param key the private key.
 444          * @return the default signature algorithm. Returns null if a default
 445          *      signature algorithm cannot be found. In this case,
 446          *      {@link #signatureAlgorithm} must be called to specify a
 447          *      signature algorithm. Otherwise, the {@link #build} method
 448          *      will throw an {@link IllegalArgumentException}.
 449          */
 450         public static String getDefaultSignatureAlgorithm(PrivateKey key) {
 451             return AlgorithmId.getDefaultSigAlgForKey(Objects.requireNonNull(key));
 452         }
 453 
 454         /**
 455          * Builds a {@code JarSigner} object from the parameters set by the
 456          * setter methods.
 457          * &lt;p&gt;
 458          * This method does not modify internal state of this {@code Builder}
 459          * object and can be called multiple times to generate multiple
 460          * {@code JarSigner} objects. After this method is called, calling
 461          * any method on this {@code Builder} will have no effect on
 462          * the newly built {@code JarSigner} object.
 463          *
 464          * @return the {@code JarSigner} object.
 465          * @throws IllegalArgumentException if a signature algorithm is not
 466          *      set and cannot be derived from the private key using the
 467          *      {@link #getDefaultSignatureAlgorithm} method.
 468          */
 469         public JarSigner build() {
 470             return new JarSigner(this);
 471         }
 472     }
 473 
 474     private static final String META_INF = &quot;META-INF/&quot;;
 475 
 476     // All fields in Builder are duplicated here as final. Those not
 477     // provided but has a default value will be filled with default value.
 478 
 479     // Precisely, a final array field can still be modified if only
 480     // reference is copied, no clone is done because we are concerned about
 481     // casual change instead of malicious attack.
 482 
 483     // Signer materials:
 484     private final PrivateKey privateKey;
 485     private final X509Certificate[] certChain;
 486 
 487     // JarSigner options:
 488     private final String[] digestalg;
 489     private final String sigalg;
 490     private final Provider digestProvider;
 491     private final Provider sigProvider;
 492     private final URI tsaUrl;
 493     private final String signerName;
 494     private final BiConsumer&lt;String,String&gt; handler;
 495 
 496     // Implementation-specific properties:
 497     private final String tSAPolicyID;
 498     private final String tSADigestAlg;
 499     private final boolean signManifest; // &quot;sign&quot; the whole manifest
 500     private final boolean externalSF; // leave the .SF out of the PKCS7 block
 501     private final String altSignerPath;
 502     private final String altSigner;
 503 
 504     private JarSigner(JarSigner.Builder builder) {
 505 
 506         this.privateKey = builder.privateKey;
 507         this.certChain = builder.certChain;
 508         if (builder.digestalg != null) {
 509             // No need to clone because builder only accepts one alg now
 510             this.digestalg = builder.digestalg;
 511         } else {
 512             this.digestalg = new String[] {
 513                     Builder.getDefaultDigestAlgorithm() };
 514         }
 515         this.digestProvider = builder.digestProvider;
 516         if (builder.sigalg != null) {
 517             this.sigalg = builder.sigalg;
 518         } else {
 519             this.sigalg = JarSigner.Builder
 520                     .getDefaultSignatureAlgorithm(privateKey);
 521             if (this.sigalg == null) {
 522                 throw new IllegalArgumentException(
 523                         &quot;No signature alg for &quot; + privateKey.getAlgorithm());
 524             }
 525         }
 526         this.sigProvider = builder.sigProvider;
 527         this.tsaUrl = builder.tsaUrl;
 528 
 529         if (builder.signerName == null) {
 530             this.signerName = &quot;SIGNER&quot;;
 531         } else {
 532             this.signerName = builder.signerName;
 533         }
 534         this.handler = builder.handler;
 535 
 536         if (builder.tSADigestAlg != null) {
 537             this.tSADigestAlg = builder.tSADigestAlg;
 538         } else {
 539             this.tSADigestAlg = Builder.getDefaultDigestAlgorithm();
 540         }
 541         this.tSAPolicyID = builder.tSAPolicyID;
 542         this.signManifest = builder.signManifest;
 543         this.externalSF = builder.externalSF;
 544         this.altSigner = builder.altSigner;
 545         this.altSignerPath = builder.altSignerPath;
 546     }
 547 
 548     /**
 549      * Signs a file into an {@link OutputStream}. This method will not close
 550      * {@code file} or {@code os}.
 551      * &lt;p&gt;
 552      * If an I/O error or signing error occurs during the signing, then it may
 553      * do so after some bytes have been written. Consequently, the output
 554      * stream may be in an inconsistent state. It is strongly recommended that
 555      * it be promptly closed in this case.
 556      *
 557      * @param file the file to sign.
 558      * @param os the output stream.
 559      * @throws JarSignerException if the signing fails.
 560      */
 561     public void sign(ZipFile file, OutputStream os) {
 562         try {
 563             sign0(Objects.requireNonNull(file),
 564                     Objects.requireNonNull(os));
 565         } catch (SocketTimeoutException | CertificateException e) {
 566             // CertificateException is thrown when the received cert from TSA
 567             // has no id-kp-timeStamping in its Extended Key Usages extension.
 568             throw new JarSignerException(&quot;Error applying timestamp&quot;, e);
 569         } catch (IOException ioe) {
 570             throw new JarSignerException(&quot;I/O error&quot;, ioe);
 571         } catch (NoSuchAlgorithmException | InvalidKeyException e) {
 572             throw new JarSignerException(&quot;Error in signer materials&quot;, e);
 573         } catch (SignatureException se) {
 574             throw new JarSignerException(&quot;Error creating signature&quot;, se);
 575         }
 576     }
 577 
 578     /**
 579      * Returns the digest algorithm for this {@code JarSigner}.
 580      * &lt;p&gt;
 581      * The return value is never null.
 582      *
 583      * @return the digest algorithm.
 584      */
 585     public String getDigestAlgorithm() {
 586         return digestalg[0];
 587     }
 588 
 589     /**
 590      * Returns the signature algorithm for this {@code JarSigner}.
 591      * &lt;p&gt;
 592      * The return value is never null.
 593      *
 594      * @return the signature algorithm.
 595      */
 596     public String getSignatureAlgorithm() {
 597         return sigalg;
 598     }
 599 
 600     /**
 601      * Returns the URI of the Time Stamping Authority (TSA).
 602      *
 603      * @return the URI of the TSA.
 604      */
 605     public URI getTsa() {
 606         return tsaUrl;
 607     }
 608 
 609     /**
 610      * Returns the signer name of this {@code JarSigner}.
 611      * &lt;p&gt;
 612      * The return value is never null.
 613      *
 614      * @return the signer name.
 615      */
 616     public String getSignerName() {
 617         return signerName;
 618     }
 619 
 620     /**
 621      * Returns the value of an additional implementation-specific property
 622      * indicated by the specified key. If a property is not set but has a
 623      * default value, the default value will be returned.
 624      *
 625      * @implNote See {@link JarSigner.Builder#setProperty} for a list of
 626      * properties this implementation supports. All property names are
 627      * case-insensitive.
 628      *
 629      * @param key the name of the property.
 630      * @return the value for the property.
 631      * @throws UnsupportedOperationException if the key is not supported
 632      *      by this implementation.
 633      */
 634     public String getProperty(String key) {
 635         Objects.requireNonNull(key);
 636         switch (key.toLowerCase(Locale.US)) {
 637             case &quot;tsadigestalg&quot;:
 638                 return tSADigestAlg;
 639             case &quot;tsapolicyid&quot;:
 640                 return tSAPolicyID;
 641             case &quot;internalsf&quot;:
 642                 return Boolean.toString(!externalSF);
 643             case &quot;sectionsonly&quot;:
 644                 return Boolean.toString(!signManifest);
 645             case &quot;altsignerpath&quot;:
 646                 return altSignerPath;
 647             case &quot;altsigner&quot;:
 648                 return altSigner;
 649             default:
 650                 throw new UnsupportedOperationException(
 651                         &quot;Unsupported key &quot; + key);
 652         }
 653     }
 654 
 655     private void sign0(ZipFile zipFile, OutputStream os)
 656             throws IOException, CertificateException, NoSuchAlgorithmException,
 657             SignatureException, InvalidKeyException {
 658         MessageDigest[] digests;
 659         try {
 660             digests = new MessageDigest[digestalg.length];
 661             for (int i = 0; i &lt; digestalg.length; i++) {
 662                 if (digestProvider == null) {
 663                     digests[i] = MessageDigest.getInstance(digestalg[i]);
 664                 } else {
 665                     digests[i] = MessageDigest.getInstance(
 666                             digestalg[i], digestProvider);
 667                 }
 668             }
 669         } catch (NoSuchAlgorithmException asae) {
 670             // Should not happen. User provided alg were checked, and default
 671             // alg should always be available.
 672             throw new AssertionError(asae);
 673         }
 674 
 675         ZipOutputStream zos = new ZipOutputStream(os);
 676 
 677         Manifest manifest = new Manifest();
 678         byte[] mfRawBytes = null;
 679 
 680         // Check if manifest exists
 681         ZipEntry mfFile = getManifestFile(zipFile);
 682         boolean mfCreated = mfFile == null;
 683         if (!mfCreated) {
 684             // Manifest exists. Read its raw bytes.
 685             mfRawBytes = zipFile.getInputStream(mfFile).readAllBytes();
 686             manifest.read(new ByteArrayInputStream(mfRawBytes));
 687         } else {
 688             // Create new manifest
 689             Attributes mattr = manifest.getMainAttributes();
 690             mattr.putValue(Attributes.Name.MANIFEST_VERSION.toString(),
 691                     &quot;1.0&quot;);
 692             String javaVendor = System.getProperty(&quot;java.vendor&quot;);
 693             String jdkVersion = System.getProperty(&quot;java.version&quot;);
 694             mattr.putValue(&quot;Created-By&quot;, jdkVersion + &quot; (&quot; + javaVendor
 695                     + &quot;)&quot;);
 696             mfFile = new ZipEntry(JarFile.MANIFEST_NAME);
 697         }
 698 
 699         /*
 700          * For each entry in jar
 701          * (except for signature-related META-INF entries),
 702          * do the following:
 703          *
 704          * - if entry is not contained in manifest, add it to manifest;
 705          * - if entry is contained in manifest, calculate its hash and
 706          *   compare it with the one in the manifest; if they are
 707          *   different, replace the hash in the manifest with the newly
 708          *   generated one. (This may invalidate existing signatures!)
 709          */
 710         Vector&lt;ZipEntry&gt; mfFiles = new Vector&lt;&gt;();
 711 
 712         boolean wasSigned = false;
 713 
 714         for (Enumeration&lt;? extends ZipEntry&gt; enum_ = zipFile.entries();
 715              enum_.hasMoreElements(); ) {
 716             ZipEntry ze = enum_.nextElement();
 717 
 718             if (ze.getName().startsWith(META_INF)) {
 719                 // Store META-INF files in vector, so they can be written
 720                 // out first
 721                 mfFiles.addElement(ze);
 722 
 723                 String zeNameUp = ze.getName().toUpperCase(Locale.ENGLISH);
 724                 if (SignatureFileVerifier.isBlockOrSF(zeNameUp)
 725                     // no need to preserve binary manifest portions
 726                     // if the only existing signature will be replaced
 727                         &amp;&amp; !zeNameUp.startsWith(SignatureFile
 728                             .getBaseSignatureFilesName(signerName))) {
 729                     wasSigned = true;
 730                 }
 731 
 732                 if (SignatureFileVerifier.isSigningRelated(ze.getName())) {
 733                     // ignore signature-related and manifest files
 734                     continue;
 735                 }
 736             }
 737 
 738             if (manifest.getAttributes(ze.getName()) != null) {
 739                 // jar entry is contained in manifest, check and
 740                 // possibly update its digest attributes
 741                 updateDigests(ze, zipFile, digests, manifest);
 742             } else if (!ze.isDirectory()) {
 743                 // Add entry to manifest
 744                 Attributes attrs = getDigestAttributes(ze, zipFile, digests);
 745                 manifest.getEntries().put(ze.getName(), attrs);
 746             }
 747         }
 748 
 749         /*
 750          * Note:
 751          *
 752          * The Attributes object is based on HashMap and can handle
 753          * continuation lines. Therefore, even if the contents are not changed
 754          * (in a Map view), the bytes that it write() may be different from
 755          * the original bytes that it read() from. Since the signature is
 756          * based on raw bytes, we must retain the exact bytes.
 757          */
 758         boolean mfModified;
 759         ByteArrayOutputStream baos = new ByteArrayOutputStream();
 760         if (mfCreated || !wasSigned) {
 761             mfModified = true;
 762             manifest.write(baos);
 763             mfRawBytes = baos.toByteArray();
 764         } else {
 765 
 766             // the manifest before updating
 767             Manifest oldManifest = new Manifest(
 768                     new ByteArrayInputStream(mfRawBytes));
 769             mfModified = !oldManifest.equals(manifest);
 770             if (!mfModified) {
 771                 // leave whole manifest (mfRawBytes) unmodified
 772             } else {
 773                 // reproduce the manifest raw bytes for unmodified sections
 774                 manifest.write(baos);
 775                 byte[] mfNewRawBytes = baos.toByteArray();
 776                 baos.reset();
 777 
 778                 ManifestDigester oldMd = new ManifestDigester(mfRawBytes);
 779                 ManifestDigester newMd = new ManifestDigester(mfNewRawBytes);
 780 
 781                 // main attributes
 782                 if (manifest.getMainAttributes().equals(
 783                         oldManifest.getMainAttributes())
 784                         &amp;&amp; (manifest.getEntries().isEmpty() ||
 785                             oldMd.getMainAttsEntry().isProperlyDelimited())) {
 786                     oldMd.getMainAttsEntry().reproduceRaw(baos);
 787                 } else {
 788                     newMd.getMainAttsEntry().reproduceRaw(baos);
 789                 }
 790 
 791                 // individual sections
 792                 for (Map.Entry&lt;String,Attributes&gt; entry :
 793                         manifest.getEntries().entrySet()) {
 794                     String sectionName = entry.getKey();
 795                     Attributes entryAtts = entry.getValue();
 796                     if (entryAtts.equals(oldManifest.getAttributes(sectionName))
 797                             &amp;&amp; oldMd.get(sectionName).isProperlyDelimited()) {
 798                         oldMd.get(sectionName).reproduceRaw(baos);
 799                     } else {
 800                         newMd.get(sectionName).reproduceRaw(baos);
 801                     }
 802                 }
 803 
 804                 mfRawBytes = baos.toByteArray();
 805             }
 806         }
 807 
 808         // Write out the manifest
 809         if (mfModified) {
 810             // manifest file has new length
 811             mfFile = new ZipEntry(JarFile.MANIFEST_NAME);
 812         }
 813         if (handler != null) {
 814             if (mfCreated || !mfModified) {
 815                 handler.accept(&quot;adding&quot;, mfFile.getName());
 816             } else {
 817                 handler.accept(&quot;updating&quot;, mfFile.getName());
 818             }
 819         }
 820         zos.putNextEntry(mfFile);
 821         zos.write(mfRawBytes);
 822 
 823         // Calculate SignatureFile (&quot;.SF&quot;) and SignatureBlockFile
 824         ManifestDigester manDig = new ManifestDigester(mfRawBytes);
 825         SignatureFile sf = new SignatureFile(digests, manifest, manDig,
 826                 signerName, signManifest);
 827 
 828         byte[] block;
 829 
 830         Signature signer;
 831         if (sigProvider == null ) {
 832             signer = Signature.getInstance(sigalg);
 833         } else {
 834             signer = Signature.getInstance(sigalg, sigProvider);
 835         }
 836         signer.initSign(privateKey);
 837 
 838         baos.reset();
 839         sf.write(baos);
 840         byte[] content = baos.toByteArray();
 841 
 842         signer.update(content);
 843         byte[] signature = signer.sign();
 844 
 845         @SuppressWarnings(&quot;removal&quot;)
 846         ContentSigner signingMechanism = null;
 847         if (altSigner != null) {
 848             signingMechanism = loadSigningMechanism(altSigner,
 849                     altSignerPath);
 850         }
 851 
 852         @SuppressWarnings(&quot;removal&quot;)
 853         ContentSignerParameters params =
 854                 new JarSignerParameters(null, tsaUrl, tSAPolicyID,
 855                         tSADigestAlg, signature,
 856                         signer.getAlgorithm(), certChain, content, zipFile);
 857         block = sf.generateBlock(params, externalSF, signingMechanism);
 858 
 859         String sfFilename = sf.getMetaName();
 860         String bkFilename = sf.getBlockName(privateKey);
 861 
 862         ZipEntry sfFile = new ZipEntry(sfFilename);
 863         ZipEntry bkFile = new ZipEntry(bkFilename);
 864 
 865         long time = System.currentTimeMillis();
 866         sfFile.setTime(time);
 867         bkFile.setTime(time);
 868 
 869         // signature file
 870         zos.putNextEntry(sfFile);
 871         sf.write(zos);
 872 
 873         if (handler != null) {
 874             if (zipFile.getEntry(sfFilename) != null) {
 875                 handler.accept(&quot;updating&quot;, sfFilename);
 876             } else {
 877                 handler.accept(&quot;adding&quot;, sfFilename);
 878             }
 879         }
 880 
 881         // signature block file
 882         zos.putNextEntry(bkFile);
 883         zos.write(block);
 884 
 885         if (handler != null) {
 886             if (zipFile.getEntry(bkFilename) != null) {
 887                 handler.accept(&quot;updating&quot;, bkFilename);
 888             } else {
 889                 handler.accept(&quot;adding&quot;, bkFilename);
 890             }
 891         }
 892 
 893         // Write out all other META-INF files that we stored in the
 894         // vector
 895         for (int i = 0; i &lt; mfFiles.size(); i++) {
 896             ZipEntry ze = mfFiles.elementAt(i);
 897             if (!ze.getName().equalsIgnoreCase(JarFile.MANIFEST_NAME)
 898                     &amp;&amp; !ze.getName().equalsIgnoreCase(sfFilename)
 899                     &amp;&amp; !ze.getName().equalsIgnoreCase(bkFilename)) {
 900                 if (ze.getName().startsWith(SignatureFile
 901                         .getBaseSignatureFilesName(signerName))
 902                         &amp;&amp; SignatureFileVerifier.isBlockOrSF(ze.getName())) {
 903                     if (handler != null) {
 904                         handler.accept(&quot;updating&quot;, ze.getName());
 905                     }
 906                     continue;
 907                 }
 908                 if (handler != null) {
 909                     if (manifest.getAttributes(ze.getName()) != null) {
 910                         handler.accept(&quot;signing&quot;, ze.getName());
 911                     } else if (!ze.isDirectory()) {
 912                         handler.accept(&quot;adding&quot;, ze.getName());
 913                     }
 914                 }
 915                 writeEntry(zipFile, zos, ze);
 916             }
 917         }
 918 
 919         // Write out all other files
 920         for (Enumeration&lt;? extends ZipEntry&gt; enum_ = zipFile.entries();
 921              enum_.hasMoreElements(); ) {
 922             ZipEntry ze = enum_.nextElement();
 923 
 924             if (!ze.getName().startsWith(META_INF)) {
 925                 if (handler != null) {
 926                     if (manifest.getAttributes(ze.getName()) != null) {
 927                         handler.accept(&quot;signing&quot;, ze.getName());
 928                     } else {
 929                         handler.accept(&quot;adding&quot;, ze.getName());
 930                     }
 931                 }
 932                 writeEntry(zipFile, zos, ze);
 933             }
 934         }
 935         zipFile.close();
 936         zos.close();
 937     }
 938 
 939     private void writeEntry(ZipFile zf, ZipOutputStream os, ZipEntry ze)
 940             throws IOException {
 941         ZipEntry ze2 = new ZipEntry(ze.getName());
 942         ze2.setMethod(ze.getMethod());
 943         ze2.setTime(ze.getTime());
 944         ze2.setComment(ze.getComment());
 945         ze2.setExtra(ze.getExtra());
 946         if (ze.getMethod() == ZipEntry.STORED) {
 947             ze2.setSize(ze.getSize());
 948             ze2.setCrc(ze.getCrc());
 949         }
 950         os.putNextEntry(ze2);
 951         writeBytes(zf, ze, os);
 952     }
 953 
 954     private void writeBytes
 955             (ZipFile zf, ZipEntry ze, ZipOutputStream os) throws IOException {
 956         try (InputStream is = zf.getInputStream(ze)) {
 957             is.transferTo(os);
 958         }
 959     }
 960 
 961     private void updateDigests(ZipEntry ze, ZipFile zf,
 962                                   MessageDigest[] digests,
 963                                   Manifest mf) throws IOException {
 964         Attributes attrs = mf.getAttributes(ze.getName());
 965         String[] base64Digests = getDigests(ze, zf, digests);
 966 
 967         for (int i = 0; i &lt; digests.length; i++) {
 968             // The entry name to be written into attrs
 969             String name = null;
 970             try {
 971                 // Find if the digest already exists. An algorithm could have
 972                 // different names. For example, last time it was SHA, and this
 973                 // time it&#39;s SHA-1.
 974                 AlgorithmId aid = AlgorithmId.get(digests[i].getAlgorithm());
 975                 for (Object key : attrs.keySet()) {
 976                     if (key instanceof Attributes.Name) {
 977                         String n = key.toString();
 978                         if (n.toUpperCase(Locale.ENGLISH).endsWith(&quot;-DIGEST&quot;)) {
 979                             String tmp = n.substring(0, n.length() - 7);
 980                             if (AlgorithmId.get(tmp).equals(aid)) {
 981                                 name = n;
 982                                 break;
 983                             }
 984                         }
 985                     }
 986                 }
 987             } catch (NoSuchAlgorithmException nsae) {
 988                 // Ignored. Writing new digest entry.
 989             }
 990 
 991             if (name == null) {
 992                 name = digests[i].getAlgorithm() + &quot;-Digest&quot;;
 993             }
 994             attrs.putValue(name, base64Digests[i]);
 995         }
 996     }
 997 
 998     private Attributes getDigestAttributes(
 999             ZipEntry ze, ZipFile zf, MessageDigest[] digests)
1000             throws IOException {
1001 
1002         String[] base64Digests = getDigests(ze, zf, digests);
1003         Attributes attrs = new Attributes();
1004 
1005         for (int i = 0; i &lt; digests.length; i++) {
1006             attrs.putValue(digests[i].getAlgorithm() + &quot;-Digest&quot;,
1007                     base64Digests[i]);
1008         }
1009         return attrs;
1010     }
1011 
1012     /*
1013      * Returns manifest entry from given jar file, or null if given jar file
1014      * does not have a manifest entry.
1015      */
1016     private ZipEntry getManifestFile(ZipFile zf) {
1017         ZipEntry ze = zf.getEntry(JarFile.MANIFEST_NAME);
1018         if (ze == null) {
1019             // Check all entries for matching name
1020             Enumeration&lt;? extends ZipEntry&gt; enum_ = zf.entries();
1021             while (enum_.hasMoreElements() &amp;&amp; ze == null) {
1022                 ze = enum_.nextElement();
1023                 if (!JarFile.MANIFEST_NAME.equalsIgnoreCase
1024                         (ze.getName())) {
1025                     ze = null;
1026                 }
1027             }
1028         }
1029         return ze;
1030     }
1031 
1032     private String[] getDigests(
1033             ZipEntry ze, ZipFile zf, MessageDigest[] digests)
1034             throws IOException {
1035 
1036         int n, i;
1037         try (InputStream is = zf.getInputStream(ze)) {
1038             long left = ze.getSize();
1039             byte[] buffer = new byte[8192];
1040             while ((left &gt; 0)
1041                     &amp;&amp; (n = is.read(buffer, 0, buffer.length)) != -1) {
1042                 for (i = 0; i &lt; digests.length; i++) {
1043                     digests[i].update(buffer, 0, n);
1044                 }
1045                 left -= n;
1046             }
1047         }
1048 
1049         // complete the digests
1050         String[] base64Digests = new String[digests.length];
1051         for (i = 0; i &lt; digests.length; i++) {
1052             base64Digests[i] = Base64.getEncoder()
1053                     .encodeToString(digests[i].digest());
1054         }
1055         return base64Digests;
1056     }
1057 
1058     /*
1059      * Try to load the specified signing mechanism.
1060      * The URL class loader is used.
1061      */
1062     @SuppressWarnings(&quot;removal&quot;)
1063     private ContentSigner loadSigningMechanism(String signerClassName,
1064                                                String signerClassPath) {
1065 
1066         // If there is no signerClassPath provided, search from here
1067         if (signerClassPath == null) {
1068             signerClassPath = &quot;.&quot;;
1069         }
1070 
1071         // construct class loader
1072         String cpString;   // make sure env.class.path defaults to dot
1073 
1074         // do prepends to get correct ordering
1075         cpString = PathList.appendPath(
1076                 System.getProperty(&quot;env.class.path&quot;), null);
1077         cpString = PathList.appendPath(
1078                 System.getProperty(&quot;java.class.path&quot;), cpString);
1079         cpString = PathList.appendPath(signerClassPath, cpString);
1080         URL[] urls = PathList.pathToURLs(cpString);
1081         ClassLoader appClassLoader = new URLClassLoader(urls);
1082 
1083         try {
1084             // attempt to find signer
1085             Class&lt;?&gt; signerClass = appClassLoader.loadClass(signerClassName);
1086             Object signer = signerClass.getDeclaredConstructor().newInstance();
1087             return (ContentSigner) signer;
1088         } catch (ClassNotFoundException|InstantiationException|
1089                 IllegalAccessException|ClassCastException|
1090                 NoSuchMethodException| InvocationTargetException e) {
1091             throw new IllegalArgumentException(
1092                     &quot;Invalid altSigner or altSignerPath&quot;, e);
1093         }
1094     }
1095 
1096     static class SignatureFile {
1097 
1098         /**
1099          * SignatureFile
1100          */
1101         Manifest sf;
1102 
1103         /**
1104          * .SF base name
1105          */
1106         String baseName;
1107 
1108         public SignatureFile(MessageDigest digests[],
1109                              Manifest mf,
1110                              ManifestDigester md,
1111                              String baseName,
1112                              boolean signManifest) {
1113 
1114             this.baseName = baseName;
1115 
1116             String version = System.getProperty(&quot;java.version&quot;);
1117             String javaVendor = System.getProperty(&quot;java.vendor&quot;);
1118 
1119             sf = new Manifest();
1120             Attributes mattr = sf.getMainAttributes();
1121 
1122             mattr.putValue(Attributes.Name.SIGNATURE_VERSION.toString(), &quot;1.0&quot;);
1123             mattr.putValue(&quot;Created-By&quot;, version + &quot; (&quot; + javaVendor + &quot;)&quot;);
1124 
1125             if (signManifest) {
1126                 for (MessageDigest digest: digests) {
1127                     mattr.putValue(digest.getAlgorithm() + &quot;-Digest-Manifest&quot;,
1128                             Base64.getEncoder().encodeToString(
1129                                     md.manifestDigest(digest)));
1130                 }
1131             }
1132 
1133             // create digest of the manifest main attributes
1134             ManifestDigester.Entry mde = md.getMainAttsEntry(false);
1135             if (mde != null) {
1136                 for (MessageDigest digest : digests) {
1137                     mattr.putValue(digest.getAlgorithm() + &quot;-Digest-&quot; +
1138                             ManifestDigester.MF_MAIN_ATTRS,
1139                             Base64.getEncoder().encodeToString(mde.digest(digest)));
1140                 }
1141             } else {
1142                 throw new IllegalStateException
1143                         (&quot;ManifestDigester failed to create &quot; +
1144                                 &quot;Manifest-Main-Attribute entry&quot;);
1145             }
1146 
1147             // go through the manifest entries and create the digests
1148             Map&lt;String, Attributes&gt; entries = sf.getEntries();
1149             for (String name: mf.getEntries().keySet()) {
1150                 mde = md.get(name, false);
1151                 if (mde != null) {
1152                     Attributes attr = new Attributes();
1153                     for (MessageDigest digest: digests) {
1154                         attr.putValue(digest.getAlgorithm() + &quot;-Digest&quot;,
1155                                 Base64.getEncoder().encodeToString(
1156                                         mde.digest(digest)));
1157                     }
1158                     entries.put(name, attr);
1159                 }
1160             }
1161         }
1162 
1163         // Write .SF file
1164         public void write(OutputStream out) throws IOException {
1165             sf.write(out);
1166         }
1167 
1168         private static String getBaseSignatureFilesName(String baseName) {
1169             return &quot;META-INF/&quot; + baseName + &quot;.&quot;;
1170         }
1171 
1172         // get .SF file name
1173         public String getMetaName() {
1174             return getBaseSignatureFilesName(baseName) + &quot;SF&quot;;
1175         }
1176 
1177         // get .DSA (or .DSA, .EC) file name
1178         public String getBlockName(PrivateKey privateKey) {
1179             String keyAlgorithm = privateKey.getAlgorithm();
1180             return getBaseSignatureFilesName(baseName) + keyAlgorithm;
1181         }
1182 
1183         // Generates the PKCS#7 content of block file
1184         @SuppressWarnings(&quot;removal&quot;)
1185         public byte[] generateBlock(ContentSignerParameters params,
1186                                     boolean externalSF,
1187                                     ContentSigner signingMechanism)
1188                 throws NoSuchAlgorithmException,
1189                        IOException, CertificateException {
1190 
1191             if (signingMechanism == null) {
1192                 signingMechanism = new TimestampedSigner();
1193             }
1194             return signingMechanism.generateSignedData(
1195                     params,
1196                     externalSF,
1197                     params.getTimestampingAuthority() != null
1198                         || params.getTimestampingAuthorityCertificate() != null);
1199         }
1200     }
1201 
1202     @SuppressWarnings(&quot;removal&quot;)
1203     class JarSignerParameters implements ContentSignerParameters {
1204 
1205         private String[] args;
1206         private URI tsa;
1207         private byte[] signature;
1208         private String signatureAlgorithm;
1209         private X509Certificate[] signerCertificateChain;
1210         private byte[] content;
1211         private ZipFile source;
1212         private String tSAPolicyID;
1213         private String tSADigestAlg;
1214 
1215         JarSignerParameters(String[] args, URI tsa,
1216                             String tSAPolicyID, String tSADigestAlg,
1217                             byte[] signature, String signatureAlgorithm,
1218                             X509Certificate[] signerCertificateChain,
1219                             byte[] content, ZipFile source) {
1220 
1221             Objects.requireNonNull(signature);
1222             Objects.requireNonNull(signatureAlgorithm);
1223             Objects.requireNonNull(signerCertificateChain);
1224 
1225             this.args = args;
1226             this.tsa = tsa;
1227             this.tSAPolicyID = tSAPolicyID;
1228             this.tSADigestAlg = tSADigestAlg;
1229             this.signature = signature;
1230             this.signatureAlgorithm = signatureAlgorithm;
1231             this.signerCertificateChain = signerCertificateChain;
1232             this.content = content;
1233             this.source = source;
1234         }
1235 
1236         public String[] getCommandLine() {
1237             return args;
1238         }
1239 
1240         public URI getTimestampingAuthority() {
1241             return tsa;
1242         }
1243 
1244         public X509Certificate getTimestampingAuthorityCertificate() {
1245             // We don&#39;t use this param. Always provide tsaURI.
1246             return null;
1247         }
1248 
1249         public String getTSAPolicyID() {
1250             return tSAPolicyID;
1251         }
1252 
1253         public String getTSADigestAlg() {
1254             return tSADigestAlg;
1255         }
1256 
1257         public byte[] getSignature() {
1258             return signature;
1259         }
1260 
1261         public String getSignatureAlgorithm() {
1262             return signatureAlgorithm;
1263         }
1264 
1265         public X509Certificate[] getSignerCertificateChain() {
1266             return signerCertificateChain;
1267         }
1268 
1269         public byte[] getContent() {
1270             return content;
1271         }
1272 
1273         public ZipFile getSource() {
1274             return source;
1275         }
1276     }
1277 }
    </pre>
  </body>
</html>
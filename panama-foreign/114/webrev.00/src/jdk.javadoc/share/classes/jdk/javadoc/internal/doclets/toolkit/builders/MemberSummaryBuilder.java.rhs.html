<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/builders/MemberSummaryBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.builders;
 27 
 28 import java.text.MessageFormat;
 29 import java.util.*;
 30 import java.util.stream.Collectors;
 31 
 32 import javax.lang.model.element.Element;
 33 import javax.lang.model.element.ExecutableElement;
 34 import javax.lang.model.element.TypeElement;
 35 import javax.lang.model.element.VariableElement;
 36 import javax.lang.model.util.ElementFilter;
 37 
 38 import com.sun.source.doctree.DocCommentTree;
 39 import com.sun.source.doctree.DocTree;
 40 import com.sun.source.doctree.DocTree.Kind;
 41 import com.sun.source.doctree.UnknownBlockTagTree;
 42 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
 43 import jdk.javadoc.internal.doclets.toolkit.Content;
 44 import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;
 45 import jdk.javadoc.internal.doclets.toolkit.WriterFactory;
 46 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 47 import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;
 48 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 49 import jdk.javadoc.internal.doclets.toolkit.CommentUtils;
 50 
 51 import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;
 52 
 53 /**
 54  * Builds the member summary.
 55  * There are two anonymous subtype variants of this builder, created
 56  * in the {@link #getInstance} methods. One is for general types;
 57  * the other is for annotation types.
 58  *
 59  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 60  *  If you write code that depends on this, you do so at your own risk.
 61  *  This code and its internal interfaces are subject to change or
 62  *  deletion without notice.&lt;/b&gt;
 63  */
 64 public abstract class MemberSummaryBuilder extends AbstractMemberBuilder {
 65 
 66     /*
 67      * Comparator used to sort the members in the summary.
 68      */
 69     private final Comparator&lt;Element&gt; comparator;
 70 
 71     /**
 72      * The member summary writers for the given class.
 73      */
 74     private final EnumMap&lt;VisibleMemberTable.Kind, MemberSummaryWriter&gt; memberSummaryWriters;
 75 
 76     final PropertyHelper pHelper;
 77 
 78     /**
 79      * Construct a new MemberSummaryBuilder.
 80      *
 81      * @param context       the build context.
 82      * @param typeElement   the type element.
 83      */
 84     private MemberSummaryBuilder(Context context, TypeElement typeElement) {
 85         super(context, typeElement);
 86         memberSummaryWriters = new EnumMap&lt;&gt;(VisibleMemberTable.Kind.class);
 87         comparator = utils.comparators.makeIndexElementComparator();
 88         pHelper = new PropertyHelper(this);
 89     }
 90 
 91     /**
 92      * Construct a new MemberSummaryBuilder for a general type.
 93      *
 94      * @param classWriter   the writer for the class whose members are being
 95      *                      summarized.
 96      * @param context       the build context.
 97      * @return              the instance
 98      */
 99     public static MemberSummaryBuilder getInstance(
100             ClassWriter classWriter, Context context) {
101         MemberSummaryBuilder builder = new MemberSummaryBuilder(context, classWriter.getTypeElement()) {
102             @Override
<a name="1" id="anc1"></a><span class="line-modified">103             public void build(Content summariesList) {</span>
<span class="line-modified">104                 buildPropertiesSummary(summariesList);</span>
<span class="line-modified">105                 buildNestedClassesSummary(summariesList);</span>
<span class="line-modified">106                 buildEnumConstantsSummary(summariesList);</span>
<span class="line-modified">107                 buildAnnotationTypeRequiredMemberSummary(summariesList);</span>
<span class="line-modified">108                 buildAnnotationTypeOptionalMemberSummary(summariesList);</span>
<span class="line-modified">109                 buildFieldsSummary(summariesList);</span>
<span class="line-modified">110                 buildConstructorsSummary(summariesList);</span>
<span class="line-modified">111                 buildMethodsSummary(summariesList);</span>
112             }
113 
114             @Override
115             public boolean hasMembersToDocument() {
116                 return visibleMemberTable.hasVisibleMembers();
117             }
118         };
119         WriterFactory wf = context.configuration.getWriterFactory();
120         for (VisibleMemberTable.Kind kind : VisibleMemberTable.Kind.values()) {
121             MemberSummaryWriter msw = builder.getVisibleMemberTable().hasVisibleMembers(kind)
122                     ? wf.getMemberSummaryWriter(classWriter, kind)
123                     : null;
124             builder.memberSummaryWriters.put(kind, msw);
125         }
126         return builder;
127     }
128 
129     /**
130      * Return the specified visible member map.
131      *
132      * @return the specified visible member map.
133      * @throws ArrayIndexOutOfBoundsException when the type is invalid.
134      * @see VisibleMemberTable
135      */
136     public VisibleMemberTable getVisibleMemberTable() {
137         return visibleMemberTable;
138     }
139 
140     /**.
141      * Return the specified member summary writer.
142      *
143      * @param kind the kind of member summary writer to return.
144      * @return the specified member summary writer.
145      * @throws ArrayIndexOutOfBoundsException when the type is invalid.
146      * @see VisibleMemberTable
147      */
148     public MemberSummaryWriter getMemberSummaryWriter(VisibleMemberTable.Kind kind) {
149         return memberSummaryWriters.get(kind);
150     }
151 
152     /**
153      * Returns a list of methods that will be documented for the given class.
154      * This information can be used for doclet specific documentation
155      * generation.
156      *
157      * @param kind the kind of elements to return.
158      * @return a list of methods that will be documented.
159      * @see VisibleMemberTable
160      */
161     public SortedSet&lt;Element&gt; members(VisibleMemberTable.Kind kind) {
162         TreeSet&lt;Element&gt; out = new TreeSet&lt;&gt;(comparator);
163         out.addAll(getVisibleMembers(kind));
164         return out;
165     }
166 
167     /**
168      * Returns true if there are members of the given kind, false otherwise.
169      * @param kind
170      * @return true if there are members of the given kind, false otherwise
171      */
172     public boolean hasMembers(VisibleMemberTable.Kind kind) {
173         return !getVisibleMembers(kind).isEmpty();
174     }
175 
176     /**
<a name="2" id="anc2"></a><span class="line-modified">177      * Builds the summary for any optional members of an annotation type.</span>
178      *
<a name="3" id="anc3"></a><span class="line-modified">179      * @param summariesList the list of summaries to which the summary will be added</span>
180      */
<a name="4" id="anc4"></a><span class="line-modified">181     protected void buildAnnotationTypeOptionalMemberSummary(Content summariesList) {</span>
<span class="line-modified">182         MemberSummaryWriter writer = memberSummaryWriters.get(ANNOTATION_TYPE_MEMBER_OPTIONAL);</span>
<span class="line-modified">183         addSummary(writer, ANNOTATION_TYPE_MEMBER_OPTIONAL, false, summariesList);</span>










184     }
185 
186     /**
<a name="5" id="anc5"></a><span class="line-modified">187      * Builds the summary for any required members of an annotation type.</span>
188      *
<a name="6" id="anc6"></a><span class="line-modified">189      * @param summariesList the list of summaries to which the summary will be added</span>
190      */
<a name="7" id="anc7"></a><span class="line-modified">191     protected void buildAnnotationTypeRequiredMemberSummary(Content summariesList) {</span>
<span class="line-modified">192         MemberSummaryWriter writer = memberSummaryWriters.get(ANNOTATION_TYPE_MEMBER_REQUIRED);</span>
<span class="line-modified">193         addSummary(writer, ANNOTATION_TYPE_MEMBER_REQUIRED, false, summariesList);</span>
194     }
195 
196     /**
<a name="8" id="anc8"></a><span class="line-modified">197      * Builds the summary for any enum constants of an enum type.</span>
198      *
<a name="9" id="anc9"></a><span class="line-modified">199      * @param summariesList the list of summaries to which the summary will be added</span>
200      */
<a name="10" id="anc10"></a><span class="line-modified">201     protected void buildEnumConstantsSummary(Content summariesList) {</span>
<span class="line-modified">202         MemberSummaryWriter writer = memberSummaryWriters.get(ENUM_CONSTANTS);</span>
<span class="line-modified">203         addSummary(writer, ENUM_CONSTANTS, false, summariesList);</span>
204     }
205 
206     /**
<a name="11" id="anc11"></a><span class="line-modified">207      * Builds the summary for any fields.</span>
208      *
<a name="12" id="anc12"></a><span class="line-modified">209      * @param summariesList the list of summaries to which the summary will be added</span>
210      */
<a name="13" id="anc13"></a><span class="line-modified">211     protected void buildFieldsSummary(Content summariesList) {</span>
212         MemberSummaryWriter writer = memberSummaryWriters.get(FIELDS);
<a name="14" id="anc14"></a><span class="line-modified">213         addSummary(writer, FIELDS, true, summariesList);</span>
214     }
215 
216     /**
<a name="15" id="anc15"></a><span class="line-modified">217      * Builds the summary for any properties.</span>
218      *
<a name="16" id="anc16"></a><span class="line-modified">219      * @param summariesList the list of summaries to which the summary will be added</span>
220      */
<a name="17" id="anc17"></a><span class="line-modified">221     protected void buildPropertiesSummary(Content summariesList) {</span>
222         MemberSummaryWriter writer = memberSummaryWriters.get(PROPERTIES);
<a name="18" id="anc18"></a><span class="line-modified">223         addSummary(writer, PROPERTIES, true, summariesList);</span>
224     }
225 
226     /**
<a name="19" id="anc19"></a><span class="line-modified">227      * Builds the summary for any nested classes.</span>
228      *
<a name="20" id="anc20"></a><span class="line-modified">229      * @param summariesList the list of summaries to which the summary will be added</span>
230      */
<a name="21" id="anc21"></a><span class="line-modified">231     protected void buildNestedClassesSummary(Content summariesList) {</span>
232         MemberSummaryWriter writer = memberSummaryWriters.get(INNER_CLASSES);
<a name="22" id="anc22"></a><span class="line-modified">233         addSummary(writer, INNER_CLASSES, true, summariesList);</span>
234     }
235 
236     /**
<a name="23" id="anc23"></a><span class="line-modified">237      * Builds the summary for any methods.</span>
238      *
<a name="24" id="anc24"></a><span class="line-modified">239      * @param summariesList the content tree to which the documentation will be added</span>
240      */
<a name="25" id="anc25"></a><span class="line-modified">241     protected void buildMethodsSummary(Content summariesList) {</span>
242         MemberSummaryWriter writer = memberSummaryWriters.get(METHODS);
<a name="26" id="anc26"></a><span class="line-modified">243         addSummary(writer, METHODS, true, summariesList);</span>
244     }
245 
246     /**
<a name="27" id="anc27"></a><span class="line-modified">247      * Builds the summary for any constructors.</span>
248      *
<a name="28" id="anc28"></a><span class="line-modified">249      * @param summariesList the content tree to which the documentation will be added</span>
250      */
<a name="29" id="anc29"></a><span class="line-modified">251     protected void buildConstructorsSummary(Content summariesList) {</span>
252         MemberSummaryWriter writer = memberSummaryWriters.get(CONSTRUCTORS);
<a name="30" id="anc30"></a><span class="line-modified">253         addSummary(writer, CONSTRUCTORS, false, summariesList);</span>
254     }
255 
256     /**
257      * Build the member summary for the given members.
258      *
259      * @param writer the summary writer to write the output.
260      * @param kind the kind of  members to summarize.
261      * @param summaryTreeList list of content trees to which the documentation will be added
262      */
263     private void buildSummary(MemberSummaryWriter writer,
264             VisibleMemberTable.Kind kind, LinkedList&lt;Content&gt; summaryTreeList) {
265         SortedSet&lt;? extends Element&gt; members = asSortedSet(getVisibleMembers(kind));
266         if (!members.isEmpty()) {
267             for (Element member : members) {
268                 final Element property = pHelper.getPropertyElement(member);
269                 if (property != null) {
270                     processProperty(member, property);
271                 }
272                 List&lt;? extends DocTree&gt; firstSentenceTags = utils.getFirstSentenceTrees(member);
273                 if (utils.isExecutableElement(member) &amp;&amp; firstSentenceTags.isEmpty()) {
274                     //Inherit comments from overridden or implemented method if
275                     //necessary.
276                     DocFinder.Output inheritedDoc =
277                             DocFinder.search(configuration,
278                                     new DocFinder.Input(utils, member));
279                     if (inheritedDoc.holder != null
280                             &amp;&amp; !utils.getFirstSentenceTrees(inheritedDoc.holder).isEmpty()) {
281                         // let the comment helper know of the overridden element
282                         CommentHelper ch = utils.getCommentHelper(member);
283                         ch.setOverrideElement(inheritedDoc.holder);
284                         firstSentenceTags = utils.getFirstSentenceTrees(inheritedDoc.holder);
285                     }
286                 }
287                 writer.addMemberSummary(typeElement, member, firstSentenceTags);
288             }
289             summaryTreeList.add(writer.getSummaryTableTree(typeElement));
290         }
291     }
292 
293     /**
294      * Process the property method, property setter and/or property getter
295      * comment text so that it contains the documentation from
296      * the property field. The method adds the leading sentence,
297      * copied documentation including the defaultValue tag and
298      * the see tags if the appropriate property getter and setter are
299      * available.
300      *
301      * @param member the member which is to be augmented.
302      * @param property the original property documentation.
303      */
304     private void processProperty(Element member,
305                                  Element property) {
306         CommentUtils cmtutils = configuration.cmtUtils;
307         final boolean isSetter = isSetter(member);
308         final boolean isGetter = isGetter(member);
309 
310         List&lt;DocTree&gt; fullBody = new ArrayList&lt;&gt;();
311         List&lt;DocTree&gt; blockTags = new ArrayList&lt;&gt;();
312         if (isGetter || isSetter) {
313             //add &quot;[GS]ets the value of the property PROPERTY_NAME.&quot;
314             if (isSetter) {
315                 String text = MessageFormat.format(
316                         resources.getText(&quot;doclet.PropertySetterWithName&quot;),
317                         utils.propertyName((ExecutableElement)member));
318                 fullBody.addAll(cmtutils.makeFirstSentenceTree(text));
319             }
320             if (isGetter) {
321                 String text = MessageFormat.format(
322                         resources.getText(&quot;doclet.PropertyGetterWithName&quot;),
323                         utils.propertyName((ExecutableElement) member));
324                 fullBody.addAll(cmtutils.makeFirstSentenceTree(text));
325             }
326             List&lt;? extends DocTree&gt; propertyTags = utils.getBlockTags(property,
327                     t -&gt; (t instanceof UnknownBlockTagTree)
328                             &amp;&amp; ((UnknownBlockTagTree) t).getTagName().equals(&quot;propertyDescription&quot;));
329             if (propertyTags.isEmpty()) {
330                 List&lt;? extends DocTree&gt; comment = utils.getFullBody(property);
331                 blockTags.addAll(cmtutils.makePropertyDescriptionTree(comment));
332             }
333         } else {
334             fullBody.addAll(utils.getFullBody(property));
335         }
336 
337         // copy certain tags
338         List&lt;? extends DocTree&gt; tags = utils.getBlockTags(property, Kind.SINCE);
339         blockTags.addAll(tags);
340 
341         List&lt;? extends DocTree&gt; bTags = utils.getBlockTags(property,
342                 t -&gt; (t instanceof UnknownBlockTagTree)
343                         &amp;&amp; ((UnknownBlockTagTree) t).getTagName().equals(&quot;defaultValue&quot;));
344         blockTags.addAll(bTags);
345 
346         //add @see tags
347         if (!isGetter &amp;&amp; !isSetter) {
348             ExecutableElement getter = pHelper.getGetterForProperty((ExecutableElement)member);
349             ExecutableElement setter = pHelper.getSetterForProperty((ExecutableElement)member);
350 
351             if (null != getter) {
352                 StringBuilder sb = new StringBuilder(&quot;#&quot;);
353                 sb.append(utils.getSimpleName(getter)).append(&quot;()&quot;);
354                 blockTags.add(cmtutils.makeSeeTree(sb.toString(), getter));
355             }
356 
357             if (null != setter) {
358                 VariableElement param = setter.getParameters().get(0);
359                 StringBuilder sb = new StringBuilder(&quot;#&quot;);
360                 sb.append(utils.getSimpleName(setter));
361                 if (!utils.isTypeVariable(param.asType())) {
362                     sb.append(&quot;(&quot;).append(utils.getTypeSignature(param.asType(), false, true)).append(&quot;)&quot;);
363                 }
364                 blockTags.add(cmtutils.makeSeeTree(sb.toString(), setter));
365             }
366         }
367         cmtutils.setDocCommentTree(member, fullBody, blockTags);
368     }
369 
370     /**
371      * Test whether the method is a getter.
372      * @param element property method documentation. Needs to be either property
373      * method, property getter, or property setter.
374      * @return true if the given documentation belongs to a getter.
375      */
376     private boolean isGetter(Element element) {
377         final String pedName = element.getSimpleName().toString();
378         return pedName.startsWith(&quot;get&quot;) || pedName.startsWith(&quot;is&quot;);
379     }
380 
381     /**
382      * Test whether the method is a setter.
383      * @param element property method documentation. Needs to be either property
384      * method, property getter, or property setter.
385      * @return true if the given documentation belongs to a setter.
386      */
387     private boolean isSetter(Element element) {
388         return element.getSimpleName().toString().startsWith(&quot;set&quot;);
389     }
390 
391     /**
392      * Build the inherited member summary for the given methods.
393      *
394      * @param writer the writer for this member summary.
395      * @param kind the kind of members to document.
396      * @param summaryTreeList list of content trees to which the documentation will be added
397      */
398     private void buildInheritedSummary(MemberSummaryWriter writer,
399             VisibleMemberTable.Kind kind, LinkedList&lt;Content&gt; summaryTreeList) {
400         VisibleMemberTable visibleMemberTable = getVisibleMemberTable();
401         SortedSet&lt;? extends Element&gt; inheritedMembersFromMap = asSortedSet(visibleMemberTable.getAllVisibleMembers(kind));
402 
403         for (TypeElement inheritedClass : visibleMemberTable.getVisibleTypeElements()) {
404             if (!(utils.isPublic(inheritedClass) || utils.isLinkable(inheritedClass))) {
405                 continue;
406             }
407             if (inheritedClass == typeElement) {
408                 continue;
409             }
410 
411             List&lt;Element&gt; members = inheritedMembersFromMap.stream()
412                     .filter(e -&gt; utils.getEnclosingTypeElement(e) == inheritedClass)
413                     .collect(Collectors.toList());
414             if (!members.isEmpty()) {
415                 SortedSet&lt;Element&gt; inheritedMembers = new TreeSet&lt;&gt;(comparator);
416                 inheritedMembers.addAll(members);
417                 Content inheritedTree = writer.getInheritedSummaryHeader(inheritedClass);
418                 Content linksTree = writer.getInheritedSummaryLinksTree();
419                 addSummaryFootNote(inheritedClass, inheritedMembers, linksTree, writer);
420                 inheritedTree.add(linksTree);
421                 summaryTreeList.add(inheritedTree);
422             }
423         }
424     }
425 
426     private void addSummaryFootNote(TypeElement inheritedClass, SortedSet&lt;Element&gt; inheritedMembers,
427                                     Content linksTree, MemberSummaryWriter writer) {
428         for (Element member : inheritedMembers) {
429             TypeElement t = utils.isUndocumentedEnclosure(inheritedClass)
430                     ? typeElement : inheritedClass;
431             writer.addInheritedMemberSummary(t, member, inheritedMembers.first() == member,
432                     inheritedMembers.last() == member, linksTree);
433         }
434     }
435 
436     /**
<a name="31" id="anc31"></a><span class="line-modified">437      * Adds the summary for the documentation.</span>
438      *
<a name="32" id="anc32"></a><span class="line-modified">439      * @param writer               the writer for this member summary</span>
<span class="line-modified">440      * @param kind                 the kind of members to document</span>
<span class="line-modified">441      * @param showInheritedSummary true if a summary of any inherited elements should be documented</span>
<span class="line-modified">442      * @param summariesList        the list of summaries to which the summary will be added</span>
443      */
444     private void addSummary(MemberSummaryWriter writer,
445                             VisibleMemberTable.Kind kind,
446                             boolean showInheritedSummary,
<a name="33" id="anc33"></a><span class="line-modified">447                             Content summariesList)</span>
448     {
449         LinkedList&lt;Content&gt; summaryTreeList = new LinkedList&lt;&gt;();
450         buildSummary(writer, kind, summaryTreeList);
451         if (showInheritedSummary)
452             buildInheritedSummary(writer, kind, summaryTreeList);
453         if (!summaryTreeList.isEmpty()) {
<a name="34" id="anc34"></a><span class="line-modified">454             Content memberTree = writer.getMemberSummaryHeader(typeElement, summariesList);</span>
455             summaryTreeList.forEach(memberTree::add);
<a name="35" id="anc35"></a><span class="line-modified">456             writer.addSummary(summariesList, memberTree);</span>
457         }
458     }
459 
460     private SortedSet&lt;? extends Element&gt; asSortedSet(Collection&lt;? extends Element&gt; members) {
461         SortedSet&lt;Element&gt; out = new TreeSet&lt;&gt;(comparator);
462         out.addAll(members);
463         return out;
464     }
465 
466     static class PropertyHelper {
467 
468         private final Map&lt;Element, Element&gt; classPropertiesMap = new HashMap&lt;&gt;();
469 
470         private final MemberSummaryBuilder  builder;
471 
472         PropertyHelper(MemberSummaryBuilder builder) {
473             this.builder = builder;
474             computeProperties();
475         }
476 
477         private void computeProperties() {
478             VisibleMemberTable vmt = builder.getVisibleMemberTable();
479             List&lt;ExecutableElement&gt; props = ElementFilter.methodsIn(vmt.getVisibleMembers(PROPERTIES));
480             for (ExecutableElement propertyMethod : props) {
481                 ExecutableElement getter = vmt.getPropertyGetter(propertyMethod);
482                 ExecutableElement setter = vmt.getPropertySetter(propertyMethod);
483                 VariableElement field = vmt.getPropertyField(propertyMethod);
484 
485                 addToPropertiesMap(propertyMethod, field, getter, setter);
486             }
487         }
488 
489         private void addToPropertiesMap(ExecutableElement propertyMethod,
490                                         VariableElement field,
491                                         ExecutableElement getter,
492                                         ExecutableElement setter) {
493             if (field == null || builder.utils.getDocCommentTree(field) == null) {
494                 addToPropertiesMap(propertyMethod, propertyMethod);
495                 addToPropertiesMap(getter, propertyMethod);
496                 addToPropertiesMap(setter, propertyMethod);
497             } else {
498                 addToPropertiesMap(propertyMethod, field);
499                 addToPropertiesMap(getter, field);
500                 addToPropertiesMap(setter, field);
501             }
502         }
503 
504         private void addToPropertiesMap(Element propertyMethod,
505                                         Element commentSource) {
506             if (null == propertyMethod || null == commentSource) {
507                 return;
508             }
509             DocCommentTree docTree = builder.utils.getDocCommentTree(propertyMethod);
510 
511             /* The second condition is required for the property buckets. In
512              * this case the comment is at the property method (not at the field)
513              * and it needs to be listed in the map.
514              */
515             if ((docTree == null) || propertyMethod.equals(commentSource)) {
516                 classPropertiesMap.put(propertyMethod, commentSource);
517             }
518         }
519 
520         /**
521          * Returns the property field documentation belonging to the given member.
522          * @param element the member for which the property documentation is needed.
523          * @return the property field documentation, null if there is none.
524          */
525         public Element getPropertyElement(Element element) {
526             return classPropertiesMap.get(element);
527         }
528 
529         /**
530          * Returns the getter documentation belonging to the given property method.
531          * @param propertyMethod the method for which the getter is needed.
532          * @return the getter documentation, null if there is none.
533          */
534         public ExecutableElement getGetterForProperty(ExecutableElement propertyMethod) {
535             return builder.getVisibleMemberTable().getPropertyGetter(propertyMethod);
536         }
537 
538         /**
539          * Returns the setter documentation belonging to the given property method.
540          * @param propertyMethod the method for which the setter is needed.
541          * @return the setter documentation, null if there is none.
542          */
543         public ExecutableElement getSetterForProperty(ExecutableElement propertyMethod) {
544             return builder.getVisibleMemberTable().getPropertySetter(propertyMethod);
545         }
546     }
547 }
<a name="36" id="anc36"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="36" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipFileSystem.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.nio.zipfs;
  27 
  28 import java.io.BufferedOutputStream;
  29 import java.io.ByteArrayInputStream;
  30 import java.io.ByteArrayOutputStream;
  31 import java.io.EOFException;
  32 import java.io.FilterOutputStream;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.OutputStream;
  36 import java.lang.Runtime.Version;
  37 import java.nio.ByteBuffer;
  38 import java.nio.MappedByteBuffer;
  39 import java.nio.channels.FileChannel;
  40 import java.nio.channels.FileLock;
  41 import java.nio.channels.ReadableByteChannel;
  42 import java.nio.channels.SeekableByteChannel;
  43 import java.nio.channels.WritableByteChannel;
  44 import java.nio.file.*;
  45 import java.nio.file.attribute.*;
  46 import java.nio.file.spi.FileSystemProvider;
  47 import java.security.AccessController;
  48 import java.security.PrivilegedAction;
  49 import java.security.PrivilegedActionException;
  50 import java.security.PrivilegedExceptionAction;
  51 import java.util.*;
  52 import java.util.concurrent.locks.ReadWriteLock;
  53 import java.util.concurrent.locks.ReentrantReadWriteLock;
  54 import java.util.function.Consumer;
  55 import java.util.function.Function;
  56 import java.util.jar.Attributes;
  57 import java.util.jar.Manifest;
  58 import java.util.regex.Pattern;
  59 import java.util.zip.CRC32;
  60 import java.util.zip.Deflater;
  61 import java.util.zip.DeflaterOutputStream;
  62 import java.util.zip.Inflater;
  63 import java.util.zip.InflaterInputStream;
  64 import java.util.zip.ZipException;
  65 
  66 import static java.lang.Boolean.TRUE;
  67 import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;
  68 import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
  69 import static java.nio.file.StandardOpenOption.APPEND;
  70 import static java.nio.file.StandardOpenOption.CREATE;
  71 import static java.nio.file.StandardOpenOption.CREATE_NEW;
  72 import static java.nio.file.StandardOpenOption.READ;
  73 import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;
  74 import static java.nio.file.StandardOpenOption.WRITE;
  75 import static jdk.nio.zipfs.ZipConstants.*;
  76 import static jdk.nio.zipfs.ZipUtils.*;
  77 
  78 /**
  79  * A FileSystem built on a zip file
  80  *
  81  * @author Xueming Shen
  82  */
  83 class ZipFileSystem extends FileSystem {
  84     // statics
  85     private static final boolean isWindows = AccessController.doPrivileged(
  86         (PrivilegedAction&lt;Boolean&gt;)()-&gt;System.getProperty(&quot;os.name&quot;)
  87                                              .startsWith(&quot;Windows&quot;));
  88     private static final byte[] ROOTPATH = new byte[] { &#39;/&#39; };
  89     private static final String PROPERTY_POSIX = &quot;enablePosixFileAttributes&quot;;
  90     private static final String PROPERTY_DEFAULT_OWNER = &quot;defaultOwner&quot;;
  91     private static final String PROPERTY_DEFAULT_GROUP = &quot;defaultGroup&quot;;
  92     private static final String PROPERTY_DEFAULT_PERMISSIONS = &quot;defaultPermissions&quot;;
  93     // Property used to specify the entry version to use for a multi-release JAR
  94     private static final String PROPERTY_RELEASE_VERSION = &quot;releaseVersion&quot;;
  95     // Original property used to specify the entry version to use for a
  96     // multi-release JAR which is kept for backwards compatibility.
  97     private static final String PROPERTY_MULTI_RELEASE = &quot;multi-release&quot;;
  98 
  99     private static final Set&lt;PosixFilePermission&gt; DEFAULT_PERMISSIONS =
 100         PosixFilePermissions.fromString(&quot;rwxrwxrwx&quot;);
 101     // Property used to specify the compression mode to use
 102     private static final String PROPERTY_COMPRESSION_METHOD = &quot;compressionMethod&quot;;
 103     // Value specified for compressionMethod property to compress Zip entries
 104     private static final String COMPRESSION_METHOD_DEFLATED = &quot;DEFLATED&quot;;
 105     // Value specified for compressionMethod property to not compress Zip entries
 106     private static final String COMPRESSION_METHOD_STORED = &quot;STORED&quot;;
 107 
 108     private final ZipFileSystemProvider provider;
 109     private final Path zfpath;
 110     final ZipCoder zc;
 111     private final ZipPath rootdir;
 112     private boolean readOnly; // readonly file system, false by default
 113 
 114     // default time stamp for pseudo entries
 115     private final long zfsDefaultTimeStamp = System.currentTimeMillis();
 116 
 117     // configurable by env map
 118     private final boolean noExtt;        // see readExtra()
 119     private final boolean useTempFile;   // use a temp file for newOS, default
 120                                          // is to use BAOS for better performance
 121     private final boolean forceEnd64;
 122     private final int defaultCompressionMethod; // METHOD_STORED if &quot;noCompression=true&quot;
 123                                                 // METHOD_DEFLATED otherwise
 124 
 125     // entryLookup is identity by default, will be overridden for multi-release jars
 126     private Function&lt;byte[], byte[]&gt; entryLookup = Function.identity();
 127 
 128     // POSIX support
 129     final boolean supportPosix;
 130     private final UserPrincipal defaultOwner;
 131     private final GroupPrincipal defaultGroup;
 132     private final Set&lt;PosixFilePermission&gt; defaultPermissions;
 133 
 134     private final Set&lt;String&gt; supportedFileAttributeViews;
 135 
 136     ZipFileSystem(ZipFileSystemProvider provider,
 137                   Path zfpath,
 138                   Map&lt;String, ?&gt; env) throws IOException
 139     {
 140         // default encoding for name/comment
 141         String nameEncoding = env.containsKey(&quot;encoding&quot;) ?
 142             (String)env.get(&quot;encoding&quot;) : &quot;UTF-8&quot;;
 143         this.noExtt = &quot;false&quot;.equals(env.get(&quot;zipinfo-time&quot;));
 144         this.useTempFile  = isTrue(env, &quot;useTempFile&quot;);
 145         this.forceEnd64 = isTrue(env, &quot;forceZIP64End&quot;);
 146         this.defaultCompressionMethod = getDefaultCompressionMethod(env);
 147         this.supportPosix = isTrue(env, PROPERTY_POSIX);
 148         this.defaultOwner = initOwner(zfpath, env);
 149         this.defaultGroup = initGroup(zfpath, env);
 150         this.defaultPermissions = initPermissions(env);
 151         this.supportedFileAttributeViews = supportPosix ?
 152             Set.of(&quot;basic&quot;, &quot;posix&quot;, &quot;zip&quot;) : Set.of(&quot;basic&quot;, &quot;zip&quot;);
 153         if (Files.notExists(zfpath)) {
 154             // create a new zip if it doesn&#39;t exist
 155             if (isTrue(env, &quot;create&quot;)) {
 156                 try (OutputStream os = Files.newOutputStream(zfpath, CREATE_NEW, WRITE)) {
 157                     new END().write(os, 0, forceEnd64);
 158                 }
 159             } else {
 160                 throw new NoSuchFileException(zfpath.toString());
 161             }
 162         }
 163         // sm and existence check
 164         zfpath.getFileSystem().provider().checkAccess(zfpath, AccessMode.READ);
 165         boolean writeable = AccessController.doPrivileged(
 166             (PrivilegedAction&lt;Boolean&gt;)()-&gt;Files.isWritable(zfpath));
 167         this.readOnly = !writeable;
 168         this.zc = ZipCoder.get(nameEncoding);
 169         this.rootdir = new ZipPath(this, new byte[]{&#39;/&#39;});
 170         this.ch = Files.newByteChannel(zfpath, READ);
 171         try {
 172             this.cen = initCEN();
 173         } catch (IOException x) {
 174             try {
 175                 this.ch.close();
 176             } catch (IOException xx) {
 177                 x.addSuppressed(xx);
 178             }
 179             throw x;
 180         }
 181         this.provider = provider;
 182         this.zfpath = zfpath;
 183 
 184         initializeReleaseVersion(env);
 185     }
 186 
 187     /**
 188      * Return the compression method to use (STORED or DEFLATED).  If the
 189      * property {@code commpressionMethod} is set use its value to determine
 190      * the compression method to use.  If the property is not set, then the
 191      * default compression is DEFLATED unless the property {@code noCompression}
 192      * is set which is supported for backwards compatibility.
 193      * @param env Zip FS map of properties
 194      * @return The Compression method to use
 195      */
 196     private int getDefaultCompressionMethod(Map&lt;String, ?&gt; env) {
 197         int result =
 198                 isTrue(env, &quot;noCompression&quot;) ? METHOD_STORED : METHOD_DEFLATED;
 199         if (env.containsKey(PROPERTY_COMPRESSION_METHOD)) {
 200             Object compressionMethod =  env.get(PROPERTY_COMPRESSION_METHOD);
 201             if (compressionMethod != null) {
 202                 if (compressionMethod instanceof String) {
 203                     switch (((String) compressionMethod).toUpperCase()) {
 204                         case COMPRESSION_METHOD_STORED:
 205                             result = METHOD_STORED;
 206                             break;
 207                         case COMPRESSION_METHOD_DEFLATED:
 208                             result = METHOD_DEFLATED;
 209                             break;
 210                         default:
 211                             throw new IllegalArgumentException(String.format(
 212                                     &quot;The value for the %s property must be %s or %s&quot;,
 213                                     PROPERTY_COMPRESSION_METHOD, COMPRESSION_METHOD_STORED,
 214                                     COMPRESSION_METHOD_DEFLATED));
 215                     }
 216                 } else {
 217                     throw new IllegalArgumentException(String.format(
 218                             &quot;The Object type for the %s property must be a String&quot;,
 219                             PROPERTY_COMPRESSION_METHOD));
 220                 }
 221             } else {
 222                 throw new IllegalArgumentException(String.format(
 223                         &quot;The value for the %s property must be %s or %s&quot;,
 224                         PROPERTY_COMPRESSION_METHOD, COMPRESSION_METHOD_STORED,
 225                         COMPRESSION_METHOD_DEFLATED));
 226             }
 227         }
 228         return result;
 229     }
 230 
 231     // returns true if there is a name=true/&quot;true&quot; setting in env
 232     private static boolean isTrue(Map&lt;String, ?&gt; env, String name) {
 233         return &quot;true&quot;.equals(env.get(name)) || TRUE.equals(env.get(name));
 234     }
 235 
 236     // Initialize the default owner for files inside the zip archive.
 237     // If not specified in env, it is the owner of the archive. If no owner can
 238     // be determined, we try to go with system property &quot;user.name&quot;. If that&#39;s not
 239     // accessible, we return &quot;&lt;zipfs_default&gt;&quot;.
 240     private UserPrincipal initOwner(Path zfpath, Map&lt;String, ?&gt; env) throws IOException {
 241         Object o = env.get(PROPERTY_DEFAULT_OWNER);
 242         if (o == null) {
 243             try {
 244                 PrivilegedExceptionAction&lt;UserPrincipal&gt; pa = ()-&gt;Files.getOwner(zfpath);
 245                 return AccessController.doPrivileged(pa);
 246             } catch (UnsupportedOperationException | PrivilegedActionException e) {
 247                 if (e instanceof UnsupportedOperationException ||
 248                     e.getCause() instanceof NoSuchFileException)
 249                 {
 250                     PrivilegedAction&lt;String&gt; pa = ()-&gt;System.getProperty(&quot;user.name&quot;);
 251                     String userName = AccessController.doPrivileged(pa);
 252                     return ()-&gt;userName;
 253                 } else {
 254                     throw new IOException(e);
 255                 }
 256             }
 257         }
 258         if (o instanceof String) {
 259             if (((String)o).isEmpty()) {
 260                 throw new IllegalArgumentException(&quot;Value for property &quot; +
 261                         PROPERTY_DEFAULT_OWNER + &quot; must not be empty.&quot;);
 262             }
 263             return ()-&gt;(String)o;
 264         }
 265         if (o instanceof UserPrincipal) {
 266             return (UserPrincipal)o;
 267         }
 268         throw new IllegalArgumentException(&quot;Value for property &quot; +
 269                 PROPERTY_DEFAULT_OWNER + &quot; must be of type &quot; + String.class +
 270             &quot; or &quot; + UserPrincipal.class);
 271     }
 272 
 273     // Initialize the default group for files inside the zip archive.
 274     // If not specified in env, we try to determine the group of the zip archive itself.
 275     // If this is not possible/unsupported, we will return a group principal going by
 276     // the same name as the default owner.
 277     private GroupPrincipal initGroup(Path zfpath, Map&lt;String, ?&gt; env) throws IOException {
 278         Object o = env.get(PROPERTY_DEFAULT_GROUP);
 279         if (o == null) {
 280             try {
 281                 PosixFileAttributeView zfpv = Files.getFileAttributeView(zfpath, PosixFileAttributeView.class);
 282                 if (zfpv == null) {
 283                     return defaultOwner::getName;
 284                 }
 285                 PrivilegedExceptionAction&lt;GroupPrincipal&gt; pa = ()-&gt;zfpv.readAttributes().group();
 286                 return AccessController.doPrivileged(pa);
 287             } catch (UnsupportedOperationException | PrivilegedActionException e) {
 288                 if (e instanceof UnsupportedOperationException ||
 289                     e.getCause() instanceof NoSuchFileException)
 290                 {
 291                     return defaultOwner::getName;
 292                 } else {
 293                     throw new IOException(e);
 294                 }
 295             }
 296         }
 297         if (o instanceof String) {
 298             if (((String)o).isEmpty()) {
 299                 throw new IllegalArgumentException(&quot;Value for property &quot; +
 300                         PROPERTY_DEFAULT_GROUP + &quot; must not be empty.&quot;);
 301             }
 302             return ()-&gt;(String)o;
 303         }
 304         if (o instanceof GroupPrincipal) {
 305             return (GroupPrincipal)o;
 306         }
 307         throw new IllegalArgumentException(&quot;Value for property &quot; +
 308                 PROPERTY_DEFAULT_GROUP + &quot; must be of type &quot; + String.class +
 309             &quot; or &quot; + GroupPrincipal.class);
 310     }
 311 
 312     // Initialize the default permissions for files inside the zip archive.
 313     // If not specified in env, it will return 777.
 314     private Set&lt;PosixFilePermission&gt; initPermissions(Map&lt;String, ?&gt; env) {
 315         Object o = env.get(PROPERTY_DEFAULT_PERMISSIONS);
 316         if (o == null) {
 317             return DEFAULT_PERMISSIONS;
 318         }
 319         if (o instanceof String) {
 320             return PosixFilePermissions.fromString((String)o);
 321         }
 322         if (!(o instanceof Set)) {
 323             throw new IllegalArgumentException(&quot;Value for property &quot; +
 324                 PROPERTY_DEFAULT_PERMISSIONS + &quot; must be of type &quot; + String.class +
 325                 &quot; or &quot; + Set.class);
 326         }
 327         Set&lt;PosixFilePermission&gt; perms = new HashSet&lt;&gt;();
 328         for (Object o2 : (Set&lt;?&gt;)o) {
 329             if (o2 instanceof PosixFilePermission) {
 330                 perms.add((PosixFilePermission)o2);
 331             } else {
 332                 throw new IllegalArgumentException(PROPERTY_DEFAULT_PERMISSIONS +
 333                     &quot; must only contain objects of type &quot; + PosixFilePermission.class);
 334             }
 335         }
 336         return perms;
 337     }
 338 
 339     @Override
 340     public FileSystemProvider provider() {
 341         return provider;
 342     }
 343 
 344     @Override
 345     public String getSeparator() {
 346         return &quot;/&quot;;
 347     }
 348 
 349     @Override
 350     public boolean isOpen() {
 351         return isOpen;
 352     }
 353 
 354     @Override
 355     public boolean isReadOnly() {
 356         return readOnly;
 357     }
 358 
 359     private void checkWritable() {
 360         if (readOnly) {
 361             throw new ReadOnlyFileSystemException();
 362         }
 363     }
 364 
 365     void setReadOnly() {
 366         this.readOnly = true;
 367     }
 368 
 369     @Override
 370     public Iterable&lt;Path&gt; getRootDirectories() {
 371         return List.of(rootdir);
 372     }
 373 
 374     ZipPath getRootDir() {
 375         return rootdir;
 376     }
 377 
 378     @Override
 379     public ZipPath getPath(String first, String... more) {
 380         if (more.length == 0) {
 381             return new ZipPath(this, first);
 382         }
 383         StringBuilder sb = new StringBuilder();
 384         sb.append(first);
 385         for (String path : more) {
 386             if (path.length() &gt; 0) {
 387                 if (sb.length() &gt; 0) {
 388                     sb.append(&#39;/&#39;);
 389                 }
 390                 sb.append(path);
 391             }
 392         }
 393         return new ZipPath(this, sb.toString());
 394     }
 395 
 396     @Override
 397     public UserPrincipalLookupService getUserPrincipalLookupService() {
 398         throw new UnsupportedOperationException();
 399     }
 400 
 401     @Override
 402     public WatchService newWatchService() {
 403         throw new UnsupportedOperationException();
 404     }
 405 
 406     FileStore getFileStore(ZipPath path) {
 407         return new ZipFileStore(path);
 408     }
 409 
 410     @Override
 411     public Iterable&lt;FileStore&gt; getFileStores() {
 412         return List.of(new ZipFileStore(rootdir));
 413     }
 414 
 415     @Override
 416     public Set&lt;String&gt; supportedFileAttributeViews() {
 417         return supportedFileAttributeViews;
 418     }
 419 
 420     @Override
 421     public String toString() {
 422         return zfpath.toString();
 423     }
 424 
 425     Path getZipFile() {
 426         return zfpath;
 427     }
 428 
 429     private static final String GLOB_SYNTAX = &quot;glob&quot;;
 430     private static final String REGEX_SYNTAX = &quot;regex&quot;;
 431 
 432     @Override
 433     public PathMatcher getPathMatcher(String syntaxAndInput) {
 434         int pos = syntaxAndInput.indexOf(&#39;:&#39;);
 435         if (pos &lt;= 0 || pos == syntaxAndInput.length()) {
 436             throw new IllegalArgumentException();
 437         }
 438         String syntax = syntaxAndInput.substring(0, pos);
 439         String input = syntaxAndInput.substring(pos + 1);
 440         String expr;
 441         if (syntax.equalsIgnoreCase(GLOB_SYNTAX)) {
 442             expr = toRegexPattern(input);
 443         } else {
 444             if (syntax.equalsIgnoreCase(REGEX_SYNTAX)) {
 445                 expr = input;
 446             } else {
 447                 throw new UnsupportedOperationException(&quot;Syntax &#39;&quot; + syntax +
 448                     &quot;&#39; not recognized&quot;);
 449             }
 450         }
 451         // return matcher
 452         final Pattern pattern = Pattern.compile(expr);
 453         return (path)-&gt;pattern.matcher(path.toString()).matches();
 454     }
 455 
 456     @Override
 457     public void close() throws IOException {
 458         beginWrite();
 459         try {
 460             if (!isOpen)
 461                 return;
 462             isOpen = false;          // set closed
 463         } finally {
 464             endWrite();
 465         }
 466         if (!streams.isEmpty()) {    // unlock and close all remaining streams
 467             Set&lt;InputStream&gt; copy = new HashSet&lt;&gt;(streams);
 468             for (InputStream is : copy)
 469                 is.close();
 470         }
 471         beginWrite();                // lock and sync
 472         try {
 473             AccessController.doPrivileged((PrivilegedExceptionAction&lt;Void&gt;)() -&gt; {
 474                 sync(); return null;
 475             });
 476             ch.close();              // close the ch just in case no update
 477                                      // and sync didn&#39;t close the ch
 478         } catch (PrivilegedActionException e) {
 479             throw (IOException)e.getException();
 480         } finally {
 481             endWrite();
 482         }
 483 
 484         synchronized (inflaters) {
 485             for (Inflater inf : inflaters)
 486                 inf.end();
 487         }
 488         synchronized (deflaters) {
 489             for (Deflater def : deflaters)
 490                 def.end();
 491         }
 492 
 493         beginWrite();                // lock and sync
 494         try {
 495             // Clear the map so that its keys &amp; values can be garbage collected
 496             inodes = null;
 497         } finally {
 498             endWrite();
 499         }
 500 
 501         IOException ioe = null;
 502         synchronized (tmppaths) {
 503             for (Path p : tmppaths) {
 504                 try {
 505                     AccessController.doPrivileged(
 506                         (PrivilegedExceptionAction&lt;Boolean&gt;)() -&gt; Files.deleteIfExists(p));
 507                 } catch (PrivilegedActionException e) {
 508                     IOException x = (IOException)e.getException();
 509                     if (ioe == null)
 510                         ioe = x;
 511                     else
 512                         ioe.addSuppressed(x);
 513                 }
 514             }
 515         }
 516         provider.removeFileSystem(zfpath, this);
 517         if (ioe != null)
 518            throw ioe;
 519     }
 520 
 521     ZipFileAttributes getFileAttributes(byte[] path)
 522         throws IOException
 523     {
 524         beginRead();
 525         try {
 526             ensureOpen();
 527             IndexNode inode = getInode(path);
 528             if (inode == null) {
 529                 return null;
 530             } else if (inode instanceof Entry) {
 531                 return (Entry)inode;
 532             } else if (inode.pos == -1) {
 533                 // pseudo directory, uses METHOD_STORED
 534                 Entry e = supportPosix ?
 535                     new PosixEntry(inode.name, inode.isdir, METHOD_STORED) :
 536                     new Entry(inode.name, inode.isdir, METHOD_STORED);
 537                 e.mtime = e.atime = e.ctime = zfsDefaultTimeStamp;
 538                 return e;
 539             } else {
 540                 return supportPosix ? new PosixEntry(this, inode) : new Entry(this, inode);
 541             }
 542         } finally {
 543             endRead();
 544         }
 545     }
 546 
 547     void checkAccess(byte[] path) throws IOException {
 548         beginRead();
 549         try {
 550             ensureOpen();
 551             // is it necessary to readCEN as a sanity check?
 552             if (getInode(path) == null) {
 553                 throw new NoSuchFileException(toString());
 554             }
 555 
 556         } finally {
 557             endRead();
 558         }
 559     }
 560 
 561     void setTimes(byte[] path, FileTime mtime, FileTime atime, FileTime ctime)
 562         throws IOException
 563     {
 564         checkWritable();
 565         beginWrite();
 566         try {
 567             ensureOpen();
 568             Entry e = getEntry(path);    // ensureOpen checked
 569             if (e == null)
 570                 throw new NoSuchFileException(getString(path));
 571             if (e.type == Entry.CEN)
 572                 e.type = Entry.COPY;     // copy e
 573             if (mtime != null)
 574                 e.mtime = mtime.toMillis();
 575             if (atime != null)
 576                 e.atime = atime.toMillis();
 577             if (ctime != null)
 578                 e.ctime = ctime.toMillis();
 579             update(e);
 580         } finally {
 581             endWrite();
 582         }
 583     }
 584 
 585     void setOwner(byte[] path, UserPrincipal owner) throws IOException {
 586         checkWritable();
 587         beginWrite();
 588         try {
 589             ensureOpen();
 590             Entry e = getEntry(path);    // ensureOpen checked
 591             if (e == null) {
 592                 throw new NoSuchFileException(getString(path));
 593             }
 594             // as the owner information is not persistent, we don&#39;t need to
 595             // change e.type to Entry.COPY
 596             if (e instanceof PosixEntry) {
 597                 ((PosixEntry)e).owner = owner;
 598                 update(e);
 599             }
 600         } finally {
 601             endWrite();
 602         }
 603     }
 604 
 605     void setGroup(byte[] path, GroupPrincipal group) throws IOException {
 606         checkWritable();
 607         beginWrite();
 608         try {
 609             ensureOpen();
 610             Entry e = getEntry(path);    // ensureOpen checked
 611             if (e == null) {
 612                 throw new NoSuchFileException(getString(path));
 613             }
 614             // as the group information is not persistent, we don&#39;t need to
 615             // change e.type to Entry.COPY
 616             if (e instanceof PosixEntry) {
 617                 ((PosixEntry)e).group = group;
 618                 update(e);
 619             }
 620         } finally {
 621             endWrite();
 622         }
 623     }
 624 
 625     void setPermissions(byte[] path, Set&lt;PosixFilePermission&gt; perms) throws IOException {
 626         checkWritable();
 627         beginWrite();
 628         try {
 629             ensureOpen();
 630             Entry e = getEntry(path);    // ensureOpen checked
 631             if (e == null) {
 632                 throw new NoSuchFileException(getString(path));
 633             }
 634             if (e.type == Entry.CEN) {
 635                 e.type = Entry.COPY;     // copy e
 636             }
 637             e.posixPerms = perms == null ? -1 : ZipUtils.permsToFlags(perms);
 638             update(e);
 639         } finally {
 640             endWrite();
 641         }
 642     }
 643 
 644     boolean exists(byte[] path) {
 645         beginRead();
 646         try {
 647             ensureOpen();
 648             return getInode(path) != null;
 649         } finally {
 650             endRead();
 651         }
 652     }
 653 
 654     boolean isDirectory(byte[] path) {
 655         beginRead();
 656         try {
 657             IndexNode n = getInode(path);
 658             return n != null &amp;&amp; n.isDir();
 659         } finally {
 660             endRead();
 661         }
 662     }
 663 
 664     // returns the list of child paths of &quot;path&quot;
 665     Iterator&lt;Path&gt; iteratorOf(ZipPath dir,
 666                               DirectoryStream.Filter&lt;? super Path&gt; filter)
 667         throws IOException
 668     {
 669         beginWrite();    // iteration of inodes needs exclusive lock
 670         try {
 671             ensureOpen();
 672             byte[] path = dir.getResolvedPath();
 673             IndexNode inode = getInode(path);
 674             if (inode == null)
 675                 throw new NotDirectoryException(getString(path));
 676             List&lt;Path&gt; list = new ArrayList&lt;&gt;();
 677             IndexNode child = inode.child;
 678             while (child != null) {
 679                 // (1) Assume each path from the zip file itself is &quot;normalized&quot;
 680                 // (2) IndexNode.name is absolute. see IndexNode(byte[],int,int)
 681                 // (3) If parent &quot;dir&quot; is relative when ZipDirectoryStream
 682                 //     is created, the returned child path needs to be relative
 683                 //     as well.
 684                 ZipPath childPath = new ZipPath(this, child.name, true);
 685                 ZipPath childFileName = childPath.getFileName();
 686                 ZipPath zpath = dir.resolve(childFileName);
 687                 if (filter == null || filter.accept(zpath))
 688                     list.add(zpath);
 689                 child = child.sibling;
 690             }
 691             return list.iterator();
 692         } finally {
 693             endWrite();
 694         }
 695     }
 696 
 697     void createDirectory(byte[] dir, FileAttribute&lt;?&gt;... attrs) throws IOException {
 698         checkWritable();
 699         beginWrite();
 700         try {
 701             ensureOpen();
 702             if (dir.length == 0 || exists(dir))  // root dir, or existing dir
 703                 throw new FileAlreadyExistsException(getString(dir));
 704             checkParents(dir);
 705             Entry e = supportPosix ?
 706                 new PosixEntry(dir, Entry.NEW, true, METHOD_STORED, attrs) :
 707                 new Entry(dir, Entry.NEW, true, METHOD_STORED, attrs);
 708             update(e);
 709         } finally {
 710             endWrite();
 711         }
 712     }
 713 
 714     void copyFile(boolean deletesrc, byte[]src, byte[] dst, CopyOption... options)
 715         throws IOException
 716     {
 717         checkWritable();
 718         if (Arrays.equals(src, dst))
 719             return;    // do nothing, src and dst are the same
 720 
 721         beginWrite();
 722         try {
 723             ensureOpen();
 724             Entry eSrc = getEntry(src);  // ensureOpen checked
 725 
 726             if (eSrc == null)
 727                 throw new NoSuchFileException(getString(src));
 728             if (eSrc.isDir()) {    // spec says to create dst dir
 729                 createDirectory(dst);
 730                 return;
 731             }
 732             boolean hasReplace = false;
 733             boolean hasCopyAttrs = false;
 734             for (CopyOption opt : options) {
 735                 if (opt == REPLACE_EXISTING)
 736                     hasReplace = true;
 737                 else if (opt == COPY_ATTRIBUTES)
 738                     hasCopyAttrs = true;
 739             }
 740             Entry eDst = getEntry(dst);
 741             if (eDst != null) {
 742                 if (!hasReplace)
 743                     throw new FileAlreadyExistsException(getString(dst));
 744             } else {
 745                 checkParents(dst);
 746             }
 747             // copy eSrc entry and change name
 748             Entry u = supportPosix ?
 749                 new PosixEntry((PosixEntry)eSrc, Entry.COPY) :
 750                 new Entry(eSrc, Entry.COPY);
 751             u.name(dst);
 752             if (eSrc.type == Entry.NEW || eSrc.type == Entry.FILECH) {
 753                 u.type = eSrc.type;    // make it the same type
 754                 if (deletesrc) {       // if it&#39;s a &quot;rename&quot;, take the data
 755                     u.bytes = eSrc.bytes;
 756                     u.file = eSrc.file;
 757                 } else {               // if it&#39;s not &quot;rename&quot;, copy the data
 758                     if (eSrc.bytes != null)
 759                         u.bytes = Arrays.copyOf(eSrc.bytes, eSrc.bytes.length);
 760                     else if (eSrc.file != null) {
 761                         u.file = getTempPathForEntry(null);
 762                         Files.copy(eSrc.file, u.file, REPLACE_EXISTING);
 763                     }
 764                 }
 765             } else if (eSrc.type == Entry.CEN &amp;&amp; eSrc.method != defaultCompressionMethod) {
 766 
 767                 /**
 768                  * We are copying a file within the same Zip file using a
 769                  * different compression method.
 770                  */
 771                 try (InputStream in = newInputStream(src);
 772                      OutputStream out = newOutputStream(dst,
 773                              CREATE, TRUNCATE_EXISTING, WRITE)) {
 774                     in.transferTo(out);
 775                 }
 776                 u = getEntry(dst);
 777             }
 778 
 779             if (!hasCopyAttrs)
 780                 u.mtime = u.atime= u.ctime = System.currentTimeMillis();
 781             update(u);
 782             if (deletesrc)
 783                 updateDelete(eSrc);
 784         } finally {
 785             endWrite();
 786         }
 787     }
 788 
 789     // Returns an output stream for writing the contents into the specified
 790     // entry.
 791     OutputStream newOutputStream(byte[] path, OpenOption... options)
 792         throws IOException
 793     {
 794         checkWritable();
 795         boolean hasCreateNew = false;
 796         boolean hasCreate = false;
 797         boolean hasAppend = false;
 798         boolean hasTruncate = false;
 799         for (OpenOption opt : options) {
 800             if (opt == READ)
 801                 throw new IllegalArgumentException(&quot;READ not allowed&quot;);
 802             if (opt == CREATE_NEW)
 803                 hasCreateNew = true;
 804             if (opt == CREATE)
 805                 hasCreate = true;
 806             if (opt == APPEND)
 807                 hasAppend = true;
 808             if (opt == TRUNCATE_EXISTING)
 809                 hasTruncate = true;
 810         }
 811         if (hasAppend &amp;&amp; hasTruncate)
 812             throw new IllegalArgumentException(&quot;APPEND + TRUNCATE_EXISTING not allowed&quot;);
 813         beginRead();                 // only need a readlock, the &quot;update()&quot; will
 814         try {                        // try to obtain a writelock when the os is
 815             ensureOpen();            // being closed.
 816             Entry e = getEntry(path);
 817             if (e != null) {
 818                 if (e.isDir() || hasCreateNew)
 819                     throw new FileAlreadyExistsException(getString(path));
 820                 if (hasAppend) {
 821                     OutputStream os = getOutputStream(new Entry(e, Entry.NEW));
 822                     try (InputStream is = getInputStream(e)) {
 823                         is.transferTo(os);
 824                     }
 825                     return os;
 826                 }
 827                 return getOutputStream(supportPosix ?
 828                     new PosixEntry((PosixEntry)e, Entry.NEW, defaultCompressionMethod)
 829                         : new Entry(e, Entry.NEW, defaultCompressionMethod));
 830             } else {
 831                 if (!hasCreate &amp;&amp; !hasCreateNew)
 832                     throw new NoSuchFileException(getString(path));
 833                 checkParents(path);
 834                 return getOutputStream(supportPosix ?
 835                     new PosixEntry(path, Entry.NEW, false, defaultCompressionMethod) :
 836                     new Entry(path, Entry.NEW, false, defaultCompressionMethod));
 837             }
 838         } finally {
 839             endRead();
 840         }
 841     }
 842 
 843     // Returns an input stream for reading the contents of the specified
 844     // file entry.
 845     InputStream newInputStream(byte[] path) throws IOException {
 846         beginRead();
 847         try {
 848             ensureOpen();
 849             Entry e = getEntry(path);
 850             if (e == null)
 851                 throw new NoSuchFileException(getString(path));
 852             if (e.isDir())
 853                 throw new FileSystemException(getString(path), &quot;is a directory&quot;, null);
 854             return getInputStream(e);
 855         } finally {
 856             endRead();
 857         }
 858     }
 859 
 860     private void checkOptions(Set&lt;? extends OpenOption&gt; options) {
 861         // check for options of null type and option is an intance of StandardOpenOption
 862         for (OpenOption option : options) {
 863             if (option == null)
 864                 throw new NullPointerException();
 865             if (!(option instanceof StandardOpenOption))
 866                 throw new IllegalArgumentException();
 867         }
 868         if (options.contains(APPEND) &amp;&amp; options.contains(TRUNCATE_EXISTING))
 869             throw new IllegalArgumentException(&quot;APPEND + TRUNCATE_EXISTING not allowed&quot;);
 870     }
 871 
 872     // Returns an output SeekableByteChannel for either
 873     // (1) writing the contents of a new entry, if the entry doesn&#39;t exist, or
 874     // (2) updating/replacing the contents of an existing entry.
 875     // Note: The content of the channel is not compressed until the
 876     // channel is closed
 877     private class EntryOutputChannel extends ByteArrayChannel {
 878         final Entry e;
 879 
 880         EntryOutputChannel(Entry e) {
 881             super(e.size &gt; 0? (int)e.size : 8192, false);
 882             this.e = e;
 883             if (e.mtime == -1)
 884                 e.mtime = System.currentTimeMillis();
 885             if (e.method == -1)
 886                 e.method = defaultCompressionMethod;
 887             // store size, compressed size, and crc-32 in datadescriptor
 888             e.flag = FLAG_DATADESCR;
 889             if (zc.isUTF8())
 890                 e.flag |= FLAG_USE_UTF8;
 891         }
 892 
 893         @Override
 894         public void close() throws IOException {
<a name="1" id="anc1"></a><span class="line-modified"> 895             super.beginWrite();</span>
<span class="line-modified"> 896             try {</span>
<span class="line-modified"> 897                 if (!isOpen())</span>
<span class="line-added"> 898                     return;</span>
<span class="line-added"> 899                 // will update the entry</span>
<span class="line-added"> 900                 try (OutputStream os = getOutputStream(e)) {</span>
<span class="line-added"> 901                     os.write(toByteArray());</span>
<span class="line-added"> 902                 }</span>
<span class="line-added"> 903                 super.close();</span>
<span class="line-added"> 904             } finally {</span>
<span class="line-added"> 905                 super.endWrite();</span>
 906             }
<a name="2" id="anc2"></a>
 907         }
 908     }
 909 
 910     // Returns a Writable/ReadByteChannel for now. Might consider to use
 911     // newFileChannel() instead, which dump the entry data into a regular
 912     // file on the default file system and create a FileChannel on top of it.
 913     SeekableByteChannel newByteChannel(byte[] path,
 914                                        Set&lt;? extends OpenOption&gt; options,
 915                                        FileAttribute&lt;?&gt;... attrs)
 916         throws IOException
 917     {
 918         checkOptions(options);
 919         if (options.contains(StandardOpenOption.WRITE) ||
 920             options.contains(StandardOpenOption.APPEND)) {
 921             checkWritable();
 922             beginRead();    // only need a read lock, the &quot;update()&quot; will obtain
 923                             // the write lock when the channel is closed
 924             ensureOpen();
 925             try {
 926                 Entry e = getEntry(path);
 927                 if (e != null) {
 928                     if (e.isDir() || options.contains(CREATE_NEW))
 929                         throw new FileAlreadyExistsException(getString(path));
 930                     SeekableByteChannel sbc =
 931                             new EntryOutputChannel(supportPosix ?
 932                                 new PosixEntry((PosixEntry)e, Entry.NEW) :
 933                                 new Entry(e, Entry.NEW));
 934                     if (options.contains(APPEND)) {
 935                         try (InputStream is = getInputStream(e)) {  // copyover
 936                             byte[] buf = new byte[8192];
 937                             ByteBuffer bb = ByteBuffer.wrap(buf);
 938                             int n;
 939                             while ((n = is.read(buf)) != -1) {
 940                                 bb.position(0);
 941                                 bb.limit(n);
 942                                 sbc.write(bb);
 943                             }
 944                         }
 945                     }
 946                     return sbc;
 947                 }
 948                 if (!options.contains(CREATE) &amp;&amp; !options.contains(CREATE_NEW))
 949                     throw new NoSuchFileException(getString(path));
 950                 checkParents(path);
 951                 return new EntryOutputChannel(
 952                     supportPosix ?
 953                         new PosixEntry(path, Entry.NEW, false, defaultCompressionMethod, attrs) :
 954                         new Entry(path, Entry.NEW, false, defaultCompressionMethod, attrs));
 955             } finally {
 956                 endRead();
 957             }
 958         } else {
 959             beginRead();
 960             try {
 961                 ensureOpen();
 962                 Entry e = getEntry(path);
 963                 if (e == null || e.isDir())
 964                     throw new NoSuchFileException(getString(path));
 965                 try (InputStream is = getInputStream(e)) {
 966                     // TBD: if (e.size &lt; NNNNN);
 967                     return new ByteArrayChannel(is.readAllBytes(), true);
 968                 }
 969             } finally {
 970                 endRead();
 971             }
 972         }
 973     }
 974 
 975     // Returns a FileChannel of the specified entry.
 976     //
 977     // This implementation creates a temporary file on the default file system,
 978     // copy the entry data into it if the entry exists, and then create a
 979     // FileChannel on top of it.
 980     FileChannel newFileChannel(byte[] path,
 981                                Set&lt;? extends OpenOption&gt; options,
 982                                FileAttribute&lt;?&gt;... attrs)
 983         throws IOException
 984     {
 985         checkOptions(options);
 986         final  boolean forWrite = (options.contains(StandardOpenOption.WRITE) ||
 987                                    options.contains(StandardOpenOption.APPEND));
 988         beginRead();
 989         try {
 990             ensureOpen();
 991             Entry e = getEntry(path);
 992             if (forWrite) {
 993                 checkWritable();
 994                 if (e == null) {
 995                     if (!options.contains(StandardOpenOption.CREATE) &amp;&amp;
 996                         !options.contains(StandardOpenOption.CREATE_NEW)) {
 997                         throw new NoSuchFileException(getString(path));
 998                     }
 999                 } else {
1000                     if (options.contains(StandardOpenOption.CREATE_NEW)) {
1001                         throw new FileAlreadyExistsException(getString(path));
1002                     }
1003                     if (e.isDir())
1004                         throw new FileAlreadyExistsException(&quot;directory &lt;&quot;
1005                             + getString(path) + &quot;&gt; exists&quot;);
1006                 }
1007                 options = new HashSet&lt;&gt;(options);
1008                 options.remove(StandardOpenOption.CREATE_NEW); // for tmpfile
1009             } else if (e == null || e.isDir()) {
1010                 throw new NoSuchFileException(getString(path));
1011             }
1012 
1013             final boolean isFCH = (e != null &amp;&amp; e.type == Entry.FILECH);
1014             final Path tmpfile = isFCH ? e.file : getTempPathForEntry(path);
1015             final FileChannel fch = tmpfile.getFileSystem()
1016                                            .provider()
1017                                            .newFileChannel(tmpfile, options, attrs);
1018             final Entry u = isFCH ? e : (
1019                 supportPosix ?
1020                 new PosixEntry(path, tmpfile, Entry.FILECH, attrs) :
1021                 new Entry(path, tmpfile, Entry.FILECH, attrs));
1022             if (forWrite) {
1023                 u.flag = FLAG_DATADESCR;
1024                 u.method = defaultCompressionMethod;
1025             }
1026             // is there a better way to hook into the FileChannel&#39;s close method?
1027             return new FileChannel() {
1028                 public int write(ByteBuffer src) throws IOException {
1029                     return fch.write(src);
1030                 }
1031                 public long write(ByteBuffer[] srcs, int offset, int length)
1032                     throws IOException
1033                 {
1034                     return fch.write(srcs, offset, length);
1035                 }
1036                 public long position() throws IOException {
1037                     return fch.position();
1038                 }
1039                 public FileChannel position(long newPosition)
1040                     throws IOException
1041                 {
1042                     fch.position(newPosition);
1043                     return this;
1044                 }
1045                 public long size() throws IOException {
1046                     return fch.size();
1047                 }
1048                 public FileChannel truncate(long size)
1049                     throws IOException
1050                 {
1051                     fch.truncate(size);
1052                     return this;
1053                 }
1054                 public void force(boolean metaData)
1055                     throws IOException
1056                 {
1057                     fch.force(metaData);
1058                 }
1059                 public long transferTo(long position, long count,
1060                                        WritableByteChannel target)
1061                     throws IOException
1062                 {
1063                     return fch.transferTo(position, count, target);
1064                 }
1065                 public long transferFrom(ReadableByteChannel src,
1066                                          long position, long count)
1067                     throws IOException
1068                 {
1069                     return fch.transferFrom(src, position, count);
1070                 }
1071                 public int read(ByteBuffer dst) throws IOException {
1072                     return fch.read(dst);
1073                 }
1074                 public int read(ByteBuffer dst, long position)
1075                     throws IOException
1076                 {
1077                     return fch.read(dst, position);
1078                 }
1079                 public long read(ByteBuffer[] dsts, int offset, int length)
1080                     throws IOException
1081                 {
1082                     return fch.read(dsts, offset, length);
1083                 }
1084                 public int write(ByteBuffer src, long position)
1085                     throws IOException
1086                 {
1087                    return fch.write(src, position);
1088                 }
1089                 public MappedByteBuffer map(MapMode mode,
1090                                             long position, long size)
1091                 {
1092                     throw new UnsupportedOperationException();
1093                 }
1094                 public FileLock lock(long position, long size, boolean shared)
1095                     throws IOException
1096                 {
1097                     return fch.lock(position, size, shared);
1098                 }
1099                 public FileLock tryLock(long position, long size, boolean shared)
1100                     throws IOException
1101                 {
1102                     return fch.tryLock(position, size, shared);
1103                 }
1104                 protected void implCloseChannel() throws IOException {
1105                     fch.close();
1106                     if (forWrite) {
1107                         u.mtime = System.currentTimeMillis();
1108                         u.size = Files.size(u.file);
1109                         update(u);
1110                     } else {
1111                         if (!isFCH)    // if this is a new fch for reading
1112                             removeTempPathForEntry(tmpfile);
1113                     }
1114                }
1115             };
1116         } finally {
1117             endRead();
1118         }
1119     }
1120 
1121     // the outstanding input streams that need to be closed
1122     private Set&lt;InputStream&gt; streams =
1123         Collections.synchronizedSet(new HashSet&lt;&gt;());
1124 
1125     private final Set&lt;Path&gt; tmppaths = Collections.synchronizedSet(new HashSet&lt;&gt;());
1126     private Path getTempPathForEntry(byte[] path) throws IOException {
1127         Path tmpPath = createTempFileInSameDirectoryAs(zfpath);
1128         if (path != null) {
1129             Entry e = getEntry(path);
1130             if (e != null) {
1131                 try (InputStream is = newInputStream(path)) {
1132                     Files.copy(is, tmpPath, REPLACE_EXISTING);
1133                 }
1134             }
1135         }
1136         return tmpPath;
1137     }
1138 
1139     private void removeTempPathForEntry(Path path) throws IOException {
1140         Files.delete(path);
1141         tmppaths.remove(path);
1142     }
1143 
1144     // check if all parents really exist. ZIP spec does not require
1145     // the existence of any &quot;parent directory&quot;.
1146     private void checkParents(byte[] path) throws IOException {
1147         beginRead();
1148         try {
1149             while ((path = getParent(path)) != null &amp;&amp;
1150                     path != ROOTPATH) {
1151                 if (!inodes.containsKey(IndexNode.keyOf(path))) {
1152                     throw new NoSuchFileException(getString(path));
1153                 }
1154             }
1155         } finally {
1156             endRead();
1157         }
1158     }
1159 
1160     private static byte[] getParent(byte[] path) {
1161         int off = getParentOff(path);
1162         if (off &lt;= 1)
1163             return ROOTPATH;
1164         return Arrays.copyOf(path, off);
1165     }
1166 
1167     private static int getParentOff(byte[] path) {
1168         int off = path.length - 1;
1169         if (off &gt; 0 &amp;&amp; path[off] == &#39;/&#39;)  // isDirectory
1170             off--;
1171         while (off &gt; 0 &amp;&amp; path[off] != &#39;/&#39;) { off--; }
1172         return off;
1173     }
1174 
1175     private void beginWrite() {
1176         rwlock.writeLock().lock();
1177     }
1178 
1179     private void endWrite() {
1180         rwlock.writeLock().unlock();
1181     }
1182 
1183     private void beginRead() {
1184         rwlock.readLock().lock();
1185     }
1186 
1187     private void endRead() {
1188         rwlock.readLock().unlock();
1189     }
1190 
1191     ///////////////////////////////////////////////////////////////////
1192 
1193     private volatile boolean isOpen = true;
1194     private final SeekableByteChannel ch; // channel to the zipfile
1195     final byte[]  cen;     // CEN &amp; ENDHDR
1196     private END  end;
1197     private long locpos;   // position of first LOC header (usually 0)
1198 
1199     private final ReadWriteLock rwlock = new ReentrantReadWriteLock();
1200 
1201     // name -&gt; pos (in cen), IndexNode itself can be used as a &quot;key&quot;
1202     private LinkedHashMap&lt;IndexNode, IndexNode&gt; inodes;
1203 
1204     final byte[] getBytes(String name) {
1205         return zc.getBytes(name);
1206     }
1207 
1208     final String getString(byte[] name) {
1209         return zc.toString(name);
1210     }
1211 
1212     @SuppressWarnings(&quot;deprecation&quot;)
1213     protected void finalize() throws IOException {
1214         close();
1215     }
1216 
1217     // Reads len bytes of data from the specified offset into buf.
1218     // Returns the total number of bytes read.
1219     // Each/every byte read from here (except the cen, which is mapped).
1220     final long readFullyAt(byte[] buf, int off, long len, long pos)
1221         throws IOException
1222     {
1223         ByteBuffer bb = ByteBuffer.wrap(buf);
1224         bb.position(off);
1225         bb.limit((int)(off + len));
1226         return readFullyAt(bb, pos);
1227     }
1228 
1229     private long readFullyAt(ByteBuffer bb, long pos) throws IOException {
1230         synchronized(ch) {
1231             return ch.position(pos).read(bb);
1232         }
1233     }
1234 
1235     // Searches for end of central directory (END) header. The contents of
1236     // the END header will be read and placed in endbuf. Returns the file
1237     // position of the END header, otherwise returns -1 if the END header
1238     // was not found or an error occurred.
1239     private END findEND() throws IOException {
1240         byte[] buf = new byte[READBLOCKSZ];
1241         long ziplen = ch.size();
1242         long minHDR = (ziplen - END_MAXLEN) &gt; 0 ? ziplen - END_MAXLEN : 0;
1243         long minPos = minHDR - (buf.length - ENDHDR);
1244 
1245         for (long pos = ziplen - buf.length; pos &gt;= minPos; pos -= (buf.length - ENDHDR)) {
1246             int off = 0;
1247             if (pos &lt; 0) {
1248                 // Pretend there are some NUL bytes before start of file
1249                 off = (int)-pos;
1250                 Arrays.fill(buf, 0, off, (byte)0);
1251             }
1252             int len = buf.length - off;
1253             if (readFullyAt(buf, off, len, pos + off) != len)
1254                 throw new ZipException(&quot;zip END header not found&quot;);
1255 
1256             // Now scan the block backwards for END header signature
1257             for (int i = buf.length - ENDHDR; i &gt;= 0; i--) {
1258                 if (buf[i]   == (byte)&#39;P&#39;    &amp;&amp;
1259                     buf[i+1] == (byte)&#39;K&#39;    &amp;&amp;
1260                     buf[i+2] == (byte)&#39;\005&#39; &amp;&amp;
1261                     buf[i+3] == (byte)&#39;\006&#39; &amp;&amp;
1262                     (pos + i + ENDHDR + ENDCOM(buf, i) == ziplen)) {
1263                     // Found END header
1264                     buf = Arrays.copyOfRange(buf, i, i + ENDHDR);
1265                     END end = new END();
1266                     // end.endsub = ENDSUB(buf); // not used
1267                     end.centot = ENDTOT(buf);
1268                     end.cenlen = ENDSIZ(buf);
1269                     end.cenoff = ENDOFF(buf);
1270                     // end.comlen = ENDCOM(buf); // not used
1271                     end.endpos = pos + i;
1272                     // try if there is zip64 end;
1273                     byte[] loc64 = new byte[ZIP64_LOCHDR];
1274                     if (end.endpos &lt; ZIP64_LOCHDR ||
1275                         readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)
1276                         != loc64.length ||
1277                         !locator64SigAt(loc64, 0)) {
1278                         return end;
1279                     }
1280                     long end64pos = ZIP64_LOCOFF(loc64);
1281                     byte[] end64buf = new byte[ZIP64_ENDHDR];
1282                     if (readFullyAt(end64buf, 0, end64buf.length, end64pos)
1283                         != end64buf.length ||
1284                         !end64SigAt(end64buf, 0)) {
1285                         return end;
1286                     }
1287                     // end64 found,
1288                     long cenlen64 = ZIP64_ENDSIZ(end64buf);
1289                     long cenoff64 = ZIP64_ENDOFF(end64buf);
1290                     long centot64 = ZIP64_ENDTOT(end64buf);
1291                     // double-check
1292                     if (cenlen64 != end.cenlen &amp;&amp; end.cenlen != ZIP64_MINVAL ||
1293                         cenoff64 != end.cenoff &amp;&amp; end.cenoff != ZIP64_MINVAL ||
1294                         centot64 != end.centot &amp;&amp; end.centot != ZIP64_MINVAL32) {
1295                         return end;
1296                     }
1297                     // to use the end64 values
1298                     end.cenlen = cenlen64;
1299                     end.cenoff = cenoff64;
1300                     end.centot = (int)centot64; // assume total &lt; 2g
1301                     end.endpos = end64pos;
1302                     return end;
1303                 }
1304             }
1305         }
1306         throw new ZipException(&quot;zip END header not found&quot;);
1307     }
1308 
1309     private void makeParentDirs(IndexNode node, IndexNode root) {
1310         IndexNode parent;
1311         ParentLookup lookup = new ParentLookup();
1312         while (true) {
1313             int off = getParentOff(node.name);
1314             // parent is root
1315             if (off &lt;= 1) {
1316                 node.sibling = root.child;
1317                 root.child = node;
1318                 break;
1319             }
1320             // parent exists
1321             lookup = lookup.as(node.name, off);
1322             if (inodes.containsKey(lookup)) {
1323                 parent = inodes.get(lookup);
1324                 node.sibling = parent.child;
1325                 parent.child = node;
1326                 break;
1327             }
1328             // parent does not exist, add new pseudo directory entry
1329             parent = new IndexNode(Arrays.copyOf(node.name, off), true);
1330             inodes.put(parent, parent);
1331             node.sibling = parent.child;
1332             parent.child = node;
1333             node = parent;
1334         }
1335     }
1336 
1337     // ZIP directory has two issues:
1338     // (1) ZIP spec does not require the ZIP file to include
1339     //     directory entry
1340     // (2) all entries are not stored/organized in a &quot;tree&quot;
1341     //     structure.
1342     // A possible solution is to build the node tree ourself as
1343     // implemented below.
1344     private void buildNodeTree() {
1345         beginWrite();
1346         try {
1347             IndexNode root = inodes.remove(LOOKUPKEY.as(ROOTPATH));
1348             if (root == null) {
1349                 root = new IndexNode(ROOTPATH, true);
1350             }
1351             IndexNode[] nodes = inodes.values().toArray(new IndexNode[0]);
1352             inodes.put(root, root);
1353             for (IndexNode node : nodes) {
1354                 makeParentDirs(node, root);
1355             }
1356         } finally {
1357             endWrite();
1358         }
1359     }
1360 
1361     private void removeFromTree(IndexNode inode) {
1362         IndexNode parent = inodes.get(LOOKUPKEY.as(getParent(inode.name)));
1363         IndexNode child = parent.child;
1364         if (child.equals(inode)) {
1365             parent.child = child.sibling;
1366         } else {
1367             IndexNode last = child;
1368             while ((child = child.sibling) != null) {
1369                 if (child.equals(inode)) {
1370                     last.sibling = child.sibling;
1371                     break;
1372                 } else {
1373                     last = child;
1374                 }
1375             }
1376         }
1377     }
1378 
1379     /**
1380      * If a version property has been specified and the file represents a multi-release JAR,
1381      * determine the requested runtime version and initialize the ZipFileSystem instance accordingly.
1382      *
1383      * Checks if the Zip File System property &quot;releaseVersion&quot; has been specified. If it has,
1384      * use its value to determine the requested version. If not use the value of the &quot;multi-release&quot; property.
1385      */
1386     private void initializeReleaseVersion(Map&lt;String, ?&gt; env) throws IOException {
1387         Object o = env.containsKey(PROPERTY_RELEASE_VERSION) ?
1388             env.get(PROPERTY_RELEASE_VERSION) :
1389             env.get(PROPERTY_MULTI_RELEASE);
1390 
1391         if (o != null &amp;&amp; isMultiReleaseJar()) {
1392             int version;
1393             if (o instanceof String) {
1394                 String s = (String)o;
1395                 if (s.equals(&quot;runtime&quot;)) {
1396                     version = Runtime.version().feature();
1397                 } else if (s.matches(&quot;^[1-9][0-9]*$&quot;)) {
1398                     version = Version.parse(s).feature();
1399                 } else {
1400                     throw new IllegalArgumentException(&quot;Invalid runtime version&quot;);
1401                 }
1402             } else if (o instanceof Integer) {
1403                 version = Version.parse(((Integer)o).toString()).feature();
1404             } else if (o instanceof Version) {
1405                 version = ((Version)o).feature();
1406             } else {
1407                 throw new IllegalArgumentException(&quot;env parameter must be String, &quot; +
1408                     &quot;Integer, or Version&quot;);
1409             }
1410             createVersionedLinks(version &lt; 0 ? 0 : version);
1411             setReadOnly();
1412         }
1413     }
1414 
1415     /**
1416      * Returns true if the Manifest main attribute &quot;Multi-Release&quot; is set to true; false otherwise.
1417      */
1418     private boolean isMultiReleaseJar() throws IOException {
1419         try (InputStream is = newInputStream(getBytes(&quot;/META-INF/MANIFEST.MF&quot;))) {
1420             String multiRelease = new Manifest(is).getMainAttributes()
1421                 .getValue(Attributes.Name.MULTI_RELEASE);
1422             return &quot;true&quot;.equalsIgnoreCase(multiRelease);
1423         } catch (NoSuchFileException x) {
1424             return false;
1425         }
1426     }
1427 
1428     /**
1429      * Create a map of aliases for versioned entries, for example:
1430      *   version/PackagePrivate.class -&gt; META-INF/versions/9/version/PackagePrivate.class
1431      *   version/PackagePrivate.java -&gt; META-INF/versions/9/version/PackagePrivate.java
1432      *   version/Version.class -&gt; META-INF/versions/10/version/Version.class
1433      *   version/Version.java -&gt; META-INF/versions/10/version/Version.java
1434      *
1435      * Then wrap the map in a function that getEntry can use to override root
1436      * entry lookup for entries that have corresponding versioned entries.
1437      */
1438     private void createVersionedLinks(int version) {
1439         IndexNode verdir = getInode(getBytes(&quot;/META-INF/versions&quot;));
1440         // nothing to do, if no /META-INF/versions
1441         if (verdir == null) {
1442             return;
1443         }
1444         // otherwise, create a map and for each META-INF/versions/{n} directory
1445         // put all the leaf inodes, i.e. entries, into the alias map
1446         // possibly shadowing lower versioned entries
1447         HashMap&lt;IndexNode, byte[]&gt; aliasMap = new HashMap&lt;&gt;();
1448         getVersionMap(version, verdir).values().forEach(versionNode -&gt;
1449             walk(versionNode.child, entryNode -&gt;
1450                 aliasMap.put(
1451                     getOrCreateInode(getRootName(entryNode, versionNode), entryNode.isdir),
1452                     entryNode.name))
1453         );
1454         entryLookup = path -&gt; {
1455             byte[] entry = aliasMap.get(IndexNode.keyOf(path));
1456             return entry == null ? path : entry;
1457         };
1458     }
1459 
1460     /**
1461      * Create a sorted version map of version -&gt; inode, for inodes &lt;= max version.
1462      *   9 -&gt; META-INF/versions/9
1463      *  10 -&gt; META-INF/versions/10
1464      */
1465     private TreeMap&lt;Integer, IndexNode&gt; getVersionMap(int version, IndexNode metaInfVersions) {
1466         TreeMap&lt;Integer,IndexNode&gt; map = new TreeMap&lt;&gt;();
1467         IndexNode child = metaInfVersions.child;
1468         while (child != null) {
1469             Integer key = getVersion(child, metaInfVersions);
1470             if (key != null &amp;&amp; key &lt;= version) {
1471                 map.put(key, child);
1472             }
1473             child = child.sibling;
1474         }
1475         return map;
1476     }
1477 
1478     /**
1479      * Extract the integer version number -- META-INF/versions/9 returns 9.
1480      */
1481     private Integer getVersion(IndexNode inode, IndexNode metaInfVersions) {
1482         try {
1483             byte[] fullName = inode.name;
1484             return Integer.parseInt(getString(Arrays
1485                 .copyOfRange(fullName, metaInfVersions.name.length + 1, fullName.length)));
1486         } catch (NumberFormatException x) {
1487             // ignore this even though it might indicate issues with the JAR structure
1488             return null;
1489         }
1490     }
1491 
1492     /**
1493      * Walk the IndexNode tree processing all leaf nodes.
1494      */
1495     private void walk(IndexNode inode, Consumer&lt;IndexNode&gt; consumer) {
1496         if (inode == null) return;
1497         if (inode.isDir()) {
1498             walk(inode.child, consumer);
1499         } else {
1500             consumer.accept(inode);
1501         }
1502         walk(inode.sibling, consumer);
1503     }
1504 
1505     /**
1506      * Extract the root name from a versioned entry name.
1507      * E.g. given inode &#39;META-INF/versions/9/foo/bar.class&#39;
1508      * and prefix &#39;META-INF/versions/9/&#39; returns &#39;foo/bar.class&#39;.
1509      */
1510     private byte[] getRootName(IndexNode inode, IndexNode prefix) {
1511         byte[] fullName = inode.name;
1512         return Arrays.copyOfRange(fullName, prefix.name.length, fullName.length);
1513     }
1514 
1515     // Reads zip file central directory. Returns the file position of first
1516     // CEN header, otherwise returns -1 if an error occurred. If zip-&gt;msg != NULL
1517     // then the error was a zip format error and zip-&gt;msg has the error text.
1518     // Always pass in -1 for knownTotal; it&#39;s used for a recursive call.
1519     private byte[] initCEN() throws IOException {
1520         end = findEND();
1521         if (end.endpos == 0) {
1522             inodes = new LinkedHashMap&lt;&gt;(10);
1523             locpos = 0;
1524             buildNodeTree();
1525             return null;         // only END header present
1526         }
1527         if (end.cenlen &gt; end.endpos)
1528             throw new ZipException(&quot;invalid END header (bad central directory size)&quot;);
1529         long cenpos = end.endpos - end.cenlen;     // position of CEN table
1530 
1531         // Get position of first local file (LOC) header, taking into
1532         // account that there may be a stub prefixed to the zip file.
1533         locpos = cenpos - end.cenoff;
1534         if (locpos &lt; 0)
1535             throw new ZipException(&quot;invalid END header (bad central directory offset)&quot;);
1536 
1537         // read in the CEN and END
1538         byte[] cen = new byte[(int)(end.cenlen + ENDHDR)];
1539         if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
1540             throw new ZipException(&quot;read CEN tables failed&quot;);
1541         }
1542         // Iterate through the entries in the central directory
1543         inodes = new LinkedHashMap&lt;&gt;(end.centot + 1);
1544         int pos = 0;
1545         int limit = cen.length - ENDHDR;
1546         while (pos &lt; limit) {
1547             if (!cenSigAt(cen, pos))
1548                 throw new ZipException(&quot;invalid CEN header (bad signature)&quot;);
1549             int method = CENHOW(cen, pos);
1550             int nlen   = CENNAM(cen, pos);
1551             int elen   = CENEXT(cen, pos);
1552             int clen   = CENCOM(cen, pos);
1553             if ((CENFLG(cen, pos) &amp; 1) != 0) {
1554                 throw new ZipException(&quot;invalid CEN header (encrypted entry)&quot;);
1555             }
1556             if (method != METHOD_STORED &amp;&amp; method != METHOD_DEFLATED) {
1557                 throw new ZipException(&quot;invalid CEN header (unsupported compression method: &quot; + method + &quot;)&quot;);
1558             }
1559             if (pos + CENHDR + nlen &gt; limit) {
1560                 throw new ZipException(&quot;invalid CEN header (bad header size)&quot;);
1561             }
1562             IndexNode inode = new IndexNode(cen, pos, nlen);
1563             inodes.put(inode, inode);
1564 
1565             // skip ext and comment
1566             pos += (CENHDR + nlen + elen + clen);
1567         }
1568         if (pos + ENDHDR != cen.length) {
1569             throw new ZipException(&quot;invalid CEN header (bad header size)&quot;);
1570         }
1571         buildNodeTree();
1572         return cen;
1573     }
1574 
1575     private void ensureOpen() {
1576         if (!isOpen)
1577             throw new ClosedFileSystemException();
1578     }
1579 
1580     // Creates a new empty temporary file in the same directory as the
1581     // specified file.  A variant of Files.createTempFile.
1582     private Path createTempFileInSameDirectoryAs(Path path) throws IOException {
1583         Path parent = path.toAbsolutePath().getParent();
1584         Path dir = (parent == null) ? path.getFileSystem().getPath(&quot;.&quot;) : parent;
1585         Path tmpPath = Files.createTempFile(dir, &quot;zipfstmp&quot;, null);
1586         tmppaths.add(tmpPath);
1587         return tmpPath;
1588     }
1589 
1590     ////////////////////update &amp; sync //////////////////////////////////////
1591 
1592     private boolean hasUpdate = false;
1593 
1594     // shared key. consumer guarantees the &quot;writeLock&quot; before use it.
1595     private final IndexNode LOOKUPKEY = new IndexNode(null, -1);
1596 
1597     private void updateDelete(IndexNode inode) {
1598         beginWrite();
1599         try {
1600             removeFromTree(inode);
1601             inodes.remove(inode);
1602             hasUpdate = true;
1603         } finally {
1604              endWrite();
1605         }
1606     }
1607 
1608     private void update(Entry e) {
1609         beginWrite();
1610         try {
1611             IndexNode old = inodes.put(e, e);
1612             if (old != null) {
1613                 removeFromTree(old);
1614             }
1615             if (e.type == Entry.NEW || e.type == Entry.FILECH || e.type == Entry.COPY) {
1616                 IndexNode parent = inodes.get(LOOKUPKEY.as(getParent(e.name)));
1617                 e.sibling = parent.child;
1618                 parent.child = e;
1619             }
1620             hasUpdate = true;
1621         } finally {
1622             endWrite();
1623         }
1624     }
1625 
1626     // copy over the whole LOC entry (header if necessary, data and ext) from
1627     // old zip to the new one.
1628     private long copyLOCEntry(Entry e, boolean updateHeader,
1629                               OutputStream os,
1630                               long written, byte[] buf)
1631         throws IOException
1632     {
1633         long locoff = e.locoff;  // where to read
1634         e.locoff = written;      // update the e.locoff with new value
1635 
1636         // calculate the size need to write out
1637         long size = 0;
1638         //  if there is A ext
1639         if ((e.flag &amp; FLAG_DATADESCR) != 0) {
1640             if (e.size &gt;= ZIP64_MINVAL || e.csize &gt;= ZIP64_MINVAL)
1641                 size = 24;
1642             else
1643                 size = 16;
1644         }
1645         // read loc, use the original loc.elen/nlen
1646         //
1647         // an extra byte after loc is read, which should be the first byte of the
1648         // &#39;name&#39; field of the loc. if this byte is &#39;/&#39;, which means the original
1649         // entry has an absolute path in original zip/jar file, the e.writeLOC()
1650         // is used to output the loc, in which the leading &quot;/&quot; will be removed
1651         if (readFullyAt(buf, 0, LOCHDR + 1 , locoff) != LOCHDR + 1)
1652             throw new ZipException(&quot;loc: reading failed&quot;);
1653 
1654         if (updateHeader || LOCNAM(buf) &gt; 0 &amp;&amp; buf[LOCHDR] == &#39;/&#39;) {
1655             locoff += LOCHDR + LOCNAM(buf) + LOCEXT(buf);  // skip header
1656             size += e.csize;
1657             written = e.writeLOC(os) + size;
1658         } else {
1659             os.write(buf, 0, LOCHDR);    // write out the loc header
1660             locoff += LOCHDR;
1661             // use e.csize,  LOCSIZ(buf) is zero if FLAG_DATADESCR is on
1662             // size += LOCNAM(buf) + LOCEXT(buf) + LOCSIZ(buf);
1663             size += LOCNAM(buf) + LOCEXT(buf) + e.csize;
1664             written = LOCHDR + size;
1665         }
1666         int n;
1667         while (size &gt; 0 &amp;&amp;
1668             (n = (int)readFullyAt(buf, 0, buf.length, locoff)) != -1)
1669         {
1670             if (size &lt; n)
1671                 n = (int)size;
1672             os.write(buf, 0, n);
1673             size -= n;
1674             locoff += n;
1675         }
1676         return written;
1677     }
1678 
1679     private long writeEntry(Entry e, OutputStream os)
1680         throws IOException {
1681 
1682         if (e.bytes == null &amp;&amp; e.file == null)    // dir, 0-length data
1683             return 0;
1684 
1685         long written = 0;
1686         if (e.method != METHOD_STORED &amp;&amp; e.csize &gt; 0 &amp;&amp; (e.crc != 0 || e.size == 0)) {
1687             // pre-compressed entry, write directly to output stream
1688             writeTo(e, os);
1689         } else {
1690             try (OutputStream os2 = (e.method == METHOD_STORED) ?
1691                     new EntryOutputStreamCRC32(e, os) : new EntryOutputStreamDef(e, os)) {
1692                 writeTo(e, os2);
1693             }
1694         }
1695         written += e.csize;
1696         if ((e.flag &amp; FLAG_DATADESCR) != 0) {
1697             written += e.writeEXT(os);
1698         }
1699         return written;
1700     }
1701 
1702     private void writeTo(Entry e, OutputStream os) throws IOException {
1703         if (e.bytes != null) {
1704             os.write(e.bytes, 0, e.bytes.length);
1705         } else if (e.file != null) {
1706             if (e.type == Entry.NEW || e.type == Entry.FILECH) {
1707                 try (InputStream is = Files.newInputStream(e.file)) {
1708                     is.transferTo(os);
1709                 }
1710             }
1711             Files.delete(e.file);
1712             tmppaths.remove(e.file);
1713         }
1714     }
1715 
1716     // sync the zip file system, if there is any update
1717     private void sync() throws IOException {
1718         if (!hasUpdate)
1719             return;
1720         PosixFileAttributes attrs = getPosixAttributes(zfpath);
1721         Path tmpFile = createTempFileInSameDirectoryAs(zfpath);
1722         try (OutputStream os = new BufferedOutputStream(Files.newOutputStream(tmpFile, WRITE))) {
1723             ArrayList&lt;Entry&gt; elist = new ArrayList&lt;&gt;(inodes.size());
1724             long written = 0;
1725             byte[] buf = null;
1726             Entry e;
1727 
1728             final IndexNode manifestInode = inodes.get(
1729                     IndexNode.keyOf(getBytes(&quot;/META-INF/MANIFEST.MF&quot;)));
1730             final Iterator&lt;IndexNode&gt; inodeIterator = inodes.values().iterator();
1731             boolean manifestProcessed = false;
1732 
1733             // write loc
1734             while (inodeIterator.hasNext()) {
1735                 final IndexNode inode;
1736 
1737                 // write the manifest inode (if any) first so that
1738                 // java.util.jar.JarInputStream can find it
1739                 if (manifestInode == null) {
1740                     inode = inodeIterator.next();
1741                 } else {
1742                     if (manifestProcessed) {
1743                         // advance to next node, filtering out the manifest
1744                         // which was already written
1745                         inode = inodeIterator.next();
1746                         if (inode == manifestInode) {
1747                             continue;
1748                         }
1749                     } else {
1750                         inode = manifestInode;
1751                         manifestProcessed = true;
1752                     }
1753                 }
1754 
1755                 if (inode instanceof Entry) {    // an updated inode
1756                     e = (Entry)inode;
1757                     try {
1758                         if (e.type == Entry.COPY) {
1759                             // entry copy: the only thing changed is the &quot;name&quot;
1760                             // and &quot;nlen&quot; in LOC header, so we update/rewrite the
1761                             // LOC in new file and simply copy the rest (data and
1762                             // ext) without enflating/deflating from the old zip
1763                             // file LOC entry.
1764                             if (buf == null)
1765                                 buf = new byte[8192];
1766                             written += copyLOCEntry(e, true, os, written, buf);
1767                         } else {                          // NEW, FILECH or CEN
1768                             e.locoff = written;
1769                             written += e.writeLOC(os);    // write loc header
1770                             written += writeEntry(e, os);
1771                         }
1772                         elist.add(e);
1773                     } catch (IOException x) {
1774                         x.printStackTrace();    // skip any in-accurate entry
1775                     }
1776                 } else {                        // unchanged inode
1777                     if (inode.pos == -1) {
1778                         continue;               // pseudo directory node
1779                     }
1780                     if (inode.name.length == 1 &amp;&amp; inode.name[0] == &#39;/&#39;) {
1781                         continue;               // no root &#39;/&#39; directory even if it
1782                                                 // exists in original zip/jar file.
1783                     }
1784                     e = supportPosix ? new PosixEntry(this, inode) : new Entry(this, inode);
1785                     try {
1786                         if (buf == null)
1787                             buf = new byte[8192];
1788                         written += copyLOCEntry(e, false, os, written, buf);
1789                         elist.add(e);
1790                     } catch (IOException x) {
1791                         x.printStackTrace();    // skip any wrong entry
1792                     }
1793                 }
1794             }
1795 
1796             // now write back the cen and end table
1797             end.cenoff = written;
1798             for (Entry entry : elist) {
1799                 written += entry.writeCEN(os);
1800             }
1801             end.centot = elist.size();
1802             end.cenlen = written - end.cenoff;
1803             end.write(os, written, forceEnd64);
1804         }
1805         ch.close();
1806         Files.delete(zfpath);
1807 
1808         // Set the POSIX permissions of the original Zip File if available
1809         // before moving the temp file
1810         if (attrs != null) {
1811             Files.setPosixFilePermissions(tmpFile, attrs.permissions());
1812         }
1813         Files.move(tmpFile, zfpath, REPLACE_EXISTING);
1814         hasUpdate = false;    // clear
1815     }
1816 
1817     /**
1818      * Returns a file&#39;s POSIX file attributes.
1819      * @param path The path to the file
1820      * @return The POSIX file attributes for the specified file or
1821      *         null if the POSIX attribute view is not available
1822      * @throws IOException If an error occurs obtaining the POSIX attributes for
1823      *                    the specified file
1824      */
1825     private PosixFileAttributes getPosixAttributes(Path path) throws IOException {
1826         try {
1827             PosixFileAttributeView view =
1828                     Files.getFileAttributeView(path, PosixFileAttributeView.class);
1829             // Return if the attribute view is not supported
1830             if (view == null) {
1831                 return null;
1832             }
1833             return view.readAttributes();
1834         } catch (UnsupportedOperationException e) {
1835             // PosixFileAttributes not available
1836             return null;
1837         }
1838     }
1839 
1840     private IndexNode getInode(byte[] path) {
1841         return inodes.get(IndexNode.keyOf(Objects.requireNonNull(entryLookup.apply(path), &quot;path&quot;)));
1842     }
1843 
1844     /**
1845      * Return the IndexNode from the root tree. If it doesn&#39;t exist,
1846      * it gets created along with all parent directory IndexNodes.
1847      */
1848     private IndexNode getOrCreateInode(byte[] path, boolean isdir) {
1849         IndexNode node = getInode(path);
1850         // if node exists, return it
1851         if (node != null) {
1852             return node;
1853         }
1854 
1855         // otherwise create new pseudo node and parent directory hierarchy
1856         node = new IndexNode(path, isdir);
1857         beginWrite();
1858         try {
1859             makeParentDirs(node, Objects.requireNonNull(inodes.get(IndexNode.keyOf(ROOTPATH)), &quot;no root node found&quot;));
1860             return node;
1861         } finally {
1862             endWrite();
1863         }
1864     }
1865 
1866     private Entry getEntry(byte[] path) throws IOException {
1867         IndexNode inode = getInode(path);
1868         if (inode instanceof Entry)
1869             return (Entry)inode;
1870         if (inode == null || inode.pos == -1)
1871             return null;
1872         return supportPosix ? new PosixEntry(this, inode): new Entry(this, inode);
1873     }
1874 
1875     public void deleteFile(byte[] path, boolean failIfNotExists)
1876         throws IOException
1877     {
1878         checkWritable();
1879         IndexNode inode = getInode(path);
1880         if (inode == null) {
1881             if (path != null &amp;&amp; path.length == 0)
1882                 throw new ZipException(&quot;root directory &lt;/&gt; can&#39;t not be delete&quot;);
1883             if (failIfNotExists)
1884                 throw new NoSuchFileException(getString(path));
1885         } else {
1886             if (inode.isDir() &amp;&amp; inode.child != null)
1887                 throw new DirectoryNotEmptyException(getString(path));
1888             updateDelete(inode);
1889         }
1890     }
1891 
1892     // Returns an out stream for either
1893     // (1) writing the contents of a new entry, if the entry exists, or
1894     // (2) updating/replacing the contents of the specified existing entry.
1895     private OutputStream getOutputStream(Entry e) throws IOException {
1896         if (e.mtime == -1)
1897             e.mtime = System.currentTimeMillis();
1898         if (e.method == -1)
1899             e.method = defaultCompressionMethod;
1900         // store size, compressed size, and crc-32 in datadescr
1901         e.flag = FLAG_DATADESCR;
1902         if (zc.isUTF8())
1903             e.flag |= FLAG_USE_UTF8;
1904         OutputStream os;
1905         if (useTempFile) {
1906             e.file = getTempPathForEntry(null);
1907             os = Files.newOutputStream(e.file, WRITE);
1908         } else {
1909             os = new ByteArrayOutputStream((e.size &gt; 0)? (int)e.size : 8192);
1910         }
1911         if (e.method == METHOD_DEFLATED) {
1912             return new DeflatingEntryOutputStream(e, os);
1913         } else {
1914             return new EntryOutputStream(e, os);
1915         }
1916     }
1917 
1918     private class EntryOutputStream extends FilterOutputStream {
1919         private final Entry e;
1920         private long written;
1921         private boolean isClosed;
1922 
1923         EntryOutputStream(Entry e, OutputStream os) {
1924             super(os);
1925             this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
1926             // this.written = 0;
1927         }
1928 
1929         @Override
1930         public synchronized void write(int b) throws IOException {
1931             out.write(b);
1932             written += 1;
1933         }
1934 
1935         @Override
1936         public synchronized void write(byte[] b, int off, int len)
1937                 throws IOException {
1938             out.write(b, off, len);
1939             written += len;
1940         }
1941 
1942         @Override
1943         public synchronized void close() throws IOException {
1944             if (isClosed) {
1945                 return;
1946             }
1947             isClosed = true;
1948             e.size = written;
1949             if (out instanceof ByteArrayOutputStream)
1950                 e.bytes = ((ByteArrayOutputStream)out).toByteArray();
1951             super.close();
1952             update(e);
1953         }
1954     }
1955 
1956     // Output stream returned when writing &quot;deflated&quot; entries into memory,
1957     // to enable eager (possibly parallel) deflation and reduce memory required.
1958     private class DeflatingEntryOutputStream extends DeflaterOutputStream {
1959         private final CRC32 crc;
1960         private final Entry e;
1961         private boolean isClosed;
1962 
1963         DeflatingEntryOutputStream(Entry e, OutputStream os) {
1964             super(os, getDeflater());
1965             this.e = Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
1966             this.crc = new CRC32();
1967         }
1968 
1969         @Override
1970         public synchronized void write(byte[] b, int off, int len)
1971                 throws IOException {
1972             super.write(b, off, len);
1973             crc.update(b, off, len);
1974         }
1975 
1976         @Override
1977         public synchronized void close() throws IOException {
1978             if (isClosed)
1979                 return;
1980             isClosed = true;
1981             finish();
1982             e.size  = def.getBytesRead();
1983             e.csize = def.getBytesWritten();
1984             e.crc = crc.getValue();
1985             if (out instanceof ByteArrayOutputStream)
1986                 e.bytes = ((ByteArrayOutputStream)out).toByteArray();
1987             super.close();
1988             update(e);
1989             releaseDeflater(def);
1990         }
1991     }
1992 
1993     // Wrapper output stream class to write out a &quot;stored&quot; entry.
1994     // (1) this class does not close the underlying out stream when
1995     //     being closed.
1996     // (2) no need to be &quot;synchronized&quot;, only used by sync()
1997     private class EntryOutputStreamCRC32 extends FilterOutputStream {
1998         private final CRC32 crc;
1999         private final Entry e;
2000         private long written;
2001         private boolean isClosed;
2002 
2003         EntryOutputStreamCRC32(Entry e, OutputStream os) {
2004             super(os);
2005             this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
2006             this.crc = new CRC32();
2007         }
2008 
2009         @Override
2010         public void write(int b) throws IOException {
2011             out.write(b);
2012             crc.update(b);
2013             written += 1;
2014         }
2015 
2016         @Override
2017         public void write(byte[] b, int off, int len)
2018                 throws IOException {
2019             out.write(b, off, len);
2020             crc.update(b, off, len);
2021             written += len;
2022         }
2023 
2024         @Override
2025         public void close() {
2026             if (isClosed)
2027                 return;
2028             isClosed = true;
2029             e.size = e.csize = written;
2030             e.crc = crc.getValue();
2031         }
2032     }
2033 
2034     // Wrapper output stream class to write out a &quot;deflated&quot; entry.
2035     // (1) this class does not close the underlying out stream when
2036     //     being closed.
2037     // (2) no need to be &quot;synchronized&quot;, only used by sync()
2038     private class EntryOutputStreamDef extends DeflaterOutputStream {
2039         private final CRC32 crc;
2040         private final Entry e;
2041         private boolean isClosed;
2042 
2043         EntryOutputStreamDef(Entry e, OutputStream os) {
2044             super(os, getDeflater());
2045             this.e = Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
2046             this.crc = new CRC32();
2047         }
2048 
2049         @Override
2050         public void write(byte[] b, int off, int len) throws IOException {
2051             super.write(b, off, len);
2052             crc.update(b, off, len);
2053         }
2054 
2055         @Override
2056         public void close() throws IOException {
2057             if (isClosed)
2058                 return;
2059             isClosed = true;
2060             finish();
2061             e.size = def.getBytesRead();
2062             e.csize = def.getBytesWritten();
2063             e.crc = crc.getValue();
2064             releaseDeflater(def);
2065         }
2066     }
2067 
2068     private InputStream getInputStream(Entry e)
2069         throws IOException
2070     {
2071         InputStream eis;
2072         if (e.type == Entry.NEW) {
2073             if (e.bytes != null)
2074                 eis = new ByteArrayInputStream(e.bytes);
2075             else if (e.file != null)
2076                 eis = Files.newInputStream(e.file);
2077             else
2078                 throw new ZipException(&quot;update entry data is missing&quot;);
2079         } else if (e.type == Entry.FILECH) {
2080             // FILECH result is un-compressed.
2081             eis = Files.newInputStream(e.file);
2082             // TBD: wrap to hook close()
2083             // streams.add(eis);
2084             return eis;
2085         } else {  // untouched CEN or COPY
2086             eis = new EntryInputStream(e, ch);
2087         }
2088         if (e.method == METHOD_DEFLATED) {
2089             // MORE: Compute good size for inflater stream:
2090             long bufSize = e.size + 2; // Inflater likes a bit of slack
2091             if (bufSize &gt; 65536)
2092                 bufSize = 8192;
2093             final long size = e.size;
2094             eis = new InflaterInputStream(eis, getInflater(), (int)bufSize) {
2095                 private boolean isClosed = false;
2096                 public void close() throws IOException {
2097                     if (!isClosed) {
2098                         releaseInflater(inf);
2099                         this.in.close();
2100                         isClosed = true;
2101                         streams.remove(this);
2102                     }
2103                 }
2104                 // Override fill() method to provide an extra &quot;dummy&quot; byte
2105                 // at the end of the input stream. This is required when
2106                 // using the &quot;nowrap&quot; Inflater option. (it appears the new
2107                 // zlib in 7 does not need it, but keep it for now)
2108                 protected void fill() throws IOException {
2109                     if (eof) {
2110                         throw new EOFException(
2111                             &quot;Unexpected end of ZLIB input stream&quot;);
2112                     }
2113                     len = this.in.read(buf, 0, buf.length);
2114                     if (len == -1) {
2115                         buf[0] = 0;
2116                         len = 1;
2117                         eof = true;
2118                     }
2119                     inf.setInput(buf, 0, len);
2120                 }
2121                 private boolean eof;
2122 
2123                 public int available() {
2124                     if (isClosed)
2125                         return 0;
2126                     long avail = size - inf.getBytesWritten();
2127                     return avail &gt; (long) Integer.MAX_VALUE ?
2128                         Integer.MAX_VALUE : (int) avail;
2129                 }
2130             };
2131         } else if (e.method == METHOD_STORED) {
2132             // TBD: wrap/ it does not seem necessary
2133         } else {
2134             throw new ZipException(&quot;invalid compression method&quot;);
2135         }
2136         streams.add(eis);
2137         return eis;
2138     }
2139 
2140     // Inner class implementing the input stream used to read
2141     // a (possibly compressed) zip file entry.
2142     private class EntryInputStream extends InputStream {
2143         private final SeekableByteChannel zfch; // local ref to zipfs&#39;s &quot;ch&quot;. zipfs.ch might
2144                                                 // point to a new channel after sync()
2145         private long pos;                       // current position within entry data
2146         private long rem;                       // number of remaining bytes within entry
2147 
2148         EntryInputStream(Entry e, SeekableByteChannel zfch)
2149             throws IOException
2150         {
2151             this.zfch = zfch;
2152             rem = e.csize;
2153             pos = e.locoff;
2154             if (pos == -1) {
2155                 Entry e2 = getEntry(e.name);
2156                 if (e2 == null) {
2157                     throw new ZipException(&quot;invalid loc for entry &lt;&quot; + getString(e.name) + &quot;&gt;&quot;);
2158                 }
2159                 pos = e2.locoff;
2160             }
2161             pos = -pos;  // lazy initialize the real data offset
2162         }
2163 
2164         public int read(byte[] b, int off, int len) throws IOException {
2165             ensureOpen();
2166             initDataPos();
2167             if (rem == 0) {
2168                 return -1;
2169             }
2170             if (len &lt;= 0) {
2171                 return 0;
2172             }
2173             if (len &gt; rem) {
2174                 len = (int) rem;
2175             }
2176             // readFullyAt()
2177             long n;
2178             ByteBuffer bb = ByteBuffer.wrap(b);
2179             bb.position(off);
2180             bb.limit(off + len);
2181             synchronized(zfch) {
2182                 n = zfch.position(pos).read(bb);
2183             }
2184             if (n &gt; 0) {
2185                 pos += n;
2186                 rem -= n;
2187             }
2188             if (rem == 0) {
2189                 close();
2190             }
2191             return (int)n;
2192         }
2193 
2194         public int read() throws IOException {
2195             byte[] b = new byte[1];
2196             if (read(b, 0, 1) == 1) {
2197                 return b[0] &amp; 0xff;
2198             } else {
2199                 return -1;
2200             }
2201         }
2202 
2203         public long skip(long n) {
2204             ensureOpen();
2205             if (n &gt; rem)
2206                 n = rem;
2207             pos += n;
2208             rem -= n;
2209             if (rem == 0) {
2210                 close();
2211             }
2212             return n;
2213         }
2214 
2215         public int available() {
2216             return rem &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) rem;
2217         }
2218 
2219         public void close() {
2220             rem = 0;
2221             streams.remove(this);
2222         }
2223 
2224         private void initDataPos() throws IOException {
2225             if (pos &lt;= 0) {
2226                 pos = -pos + locpos;
2227                 byte[] buf = new byte[LOCHDR];
2228                 if (readFullyAt(buf, 0, buf.length, pos) != LOCHDR) {
2229                     throw new ZipException(&quot;invalid loc &quot; + pos + &quot; for entry reading&quot;);
2230                 }
2231                 pos += LOCHDR + LOCNAM(buf) + LOCEXT(buf);
2232             }
2233         }
2234     }
2235 
2236     // Maxmum number of de/inflater we cache
2237     private final int MAX_FLATER = 20;
2238     // List of available Inflater objects for decompression
2239     private final List&lt;Inflater&gt; inflaters = new ArrayList&lt;&gt;();
2240 
2241     // Gets an inflater from the list of available inflaters or allocates
2242     // a new one.
2243     private Inflater getInflater() {
2244         synchronized (inflaters) {
2245             int size = inflaters.size();
2246             if (size &gt; 0) {
2247                 return inflaters.remove(size - 1);
2248             } else {
2249                 return new Inflater(true);
2250             }
2251         }
2252     }
2253 
2254     // Releases the specified inflater to the list of available inflaters.
2255     private void releaseInflater(Inflater inf) {
2256         synchronized (inflaters) {
2257             if (inflaters.size() &lt; MAX_FLATER) {
2258                 inf.reset();
2259                 inflaters.add(inf);
2260             } else {
2261                 inf.end();
2262             }
2263         }
2264     }
2265 
2266     // List of available Deflater objects for compression
2267     private final List&lt;Deflater&gt; deflaters = new ArrayList&lt;&gt;();
2268 
2269     // Gets a deflater from the list of available deflaters or allocates
2270     // a new one.
2271     private Deflater getDeflater() {
2272         synchronized (deflaters) {
2273             int size = deflaters.size();
2274             if (size &gt; 0) {
2275                 return deflaters.remove(size - 1);
2276             } else {
2277                 return new Deflater(Deflater.DEFAULT_COMPRESSION, true);
2278             }
2279         }
2280     }
2281 
2282     // Releases the specified inflater to the list of available inflaters.
2283     private void releaseDeflater(Deflater def) {
2284         synchronized (deflaters) {
2285             if (deflaters.size() &lt; MAX_FLATER) {
2286                def.reset();
2287                deflaters.add(def);
2288             } else {
2289                def.end();
2290             }
2291         }
2292     }
2293 
2294     // End of central directory record
2295     static class END {
2296         // The fields that are commented out below are not used by anyone and write() uses &quot;0&quot;
2297         // int  disknum;
2298         // int  sdisknum;
2299         // int  endsub;
2300         int  centot;        // 4 bytes
2301         long cenlen;        // 4 bytes
2302         long cenoff;        // 4 bytes
2303         // int  comlen;     // comment length
2304         // byte[] comment;
2305 
2306         // members of Zip64 end of central directory locator
2307         // int diskNum;
2308         long endpos;
2309         // int disktot;
2310 
2311         void write(OutputStream os, long offset, boolean forceEnd64) throws IOException {
2312             boolean hasZip64 = forceEnd64; // false;
2313             long xlen = cenlen;
2314             long xoff = cenoff;
2315             if (xlen &gt;= ZIP64_MINVAL) {
2316                 xlen = ZIP64_MINVAL;
2317                 hasZip64 = true;
2318             }
2319             if (xoff &gt;= ZIP64_MINVAL) {
2320                 xoff = ZIP64_MINVAL;
2321                 hasZip64 = true;
2322             }
2323             int count = centot;
2324             if (count &gt;= ZIP64_MINVAL32) {
2325                 count = ZIP64_MINVAL32;
2326                 hasZip64 = true;
2327             }
2328             if (hasZip64) {
2329                 //zip64 end of central directory record
2330                 writeInt(os, ZIP64_ENDSIG);       // zip64 END record signature
2331                 writeLong(os, ZIP64_ENDHDR - 12); // size of zip64 end
2332                 writeShort(os, 45);               // version made by
2333                 writeShort(os, 45);               // version needed to extract
2334                 writeInt(os, 0);                  // number of this disk
2335                 writeInt(os, 0);                  // central directory start disk
2336                 writeLong(os, centot);            // number of directory entries on disk
2337                 writeLong(os, centot);            // number of directory entries
2338                 writeLong(os, cenlen);            // length of central directory
2339                 writeLong(os, cenoff);            // offset of central directory
2340 
2341                 //zip64 end of central directory locator
2342                 writeInt(os, ZIP64_LOCSIG);       // zip64 END locator signature
2343                 writeInt(os, 0);                  // zip64 END start disk
2344                 writeLong(os, offset);            // offset of zip64 END
2345                 writeInt(os, 1);                  // total number of disks (?)
2346             }
2347             writeInt(os, ENDSIG);                 // END record signature
2348             writeShort(os, 0);                    // number of this disk
2349             writeShort(os, 0);                    // central directory start disk
2350             writeShort(os, count);                // number of directory entries on disk
2351             writeShort(os, count);                // total number of directory entries
2352             writeInt(os, xlen);                   // length of central directory
2353             writeInt(os, xoff);                   // offset of central directory
2354             writeShort(os, 0);                    // zip file comment, not used
2355         }
2356     }
2357 
2358     // Internal node that links a &quot;name&quot; to its pos in cen table.
2359     // The node itself can be used as a &quot;key&quot; to lookup itself in
2360     // the HashMap inodes.
2361     static class IndexNode {
2362         byte[]  name;
2363         int     hashcode;    // node is hashable/hashed by its name
2364         boolean isdir;
2365         int     pos = -1;    // position in cen table, -1 means the
2366                              // entry does not exist in zip file
2367         IndexNode child;     // first child
2368         IndexNode sibling;   // next sibling
2369 
2370         IndexNode() {}
2371 
2372         IndexNode(byte[] name, boolean isdir) {
2373             name(name);
2374             this.isdir = isdir;
2375             this.pos = -1;
2376         }
2377 
2378         IndexNode(byte[] name, int pos) {
2379             name(name);
2380             this.pos = pos;
2381         }
2382 
2383         // constructor for initCEN() (1) remove trailing &#39;/&#39; (2) pad leading &#39;/&#39;
2384         IndexNode(byte[] cen, int pos, int nlen) {
2385             int noff = pos + CENHDR;
2386             if (cen[noff + nlen - 1] == &#39;/&#39;) {
2387                 isdir = true;
2388                 nlen--;
2389             }
2390             if (nlen &gt; 0 &amp;&amp; cen[noff] == &#39;/&#39;) {
2391                 name = Arrays.copyOfRange(cen, noff, noff + nlen);
2392             } else {
2393                 name = new byte[nlen + 1];
2394                 System.arraycopy(cen, noff, name, 1, nlen);
2395                 name[0] = &#39;/&#39;;
2396             }
2397             name(normalize(name));
2398             this.pos = pos;
2399         }
2400 
2401         // Normalize the IndexNode.name field.
2402         private byte[] normalize(byte[] path) {
2403             int len = path.length;
2404             if (len == 0)
2405                 return path;
2406             byte prevC = 0;
2407             for (int pathPos = 0; pathPos &lt; len; pathPos++) {
2408                 byte c = path[pathPos];
2409                 if (c == &#39;/&#39; &amp;&amp; prevC == &#39;/&#39;)
2410                     return normalize(path, pathPos - 1);
2411                 prevC = c;
2412             }
2413             if (len &gt; 1 &amp;&amp; prevC == &#39;/&#39;) {
2414                 return Arrays.copyOf(path, len - 1);
2415             }
2416             return path;
2417         }
2418 
2419         private byte[] normalize(byte[] path, int off) {
2420             // As we know we have at least one / to trim, we can reduce
2421             // the size of the resulting array
2422             byte[] to = new byte[path.length - 1];
2423             int pathPos = 0;
2424             while (pathPos &lt; off) {
2425                 to[pathPos] = path[pathPos];
2426                 pathPos++;
2427             }
2428             int toPos = pathPos;
2429             byte prevC = 0;
2430             while (pathPos &lt; path.length) {
2431                 byte c = path[pathPos++];
2432                 if (c == &#39;/&#39; &amp;&amp; prevC == &#39;/&#39;)
2433                     continue;
2434                 to[toPos++] = c;
2435                 prevC = c;
2436             }
2437             if (toPos &gt; 1 &amp;&amp; to[toPos - 1] == &#39;/&#39;)
2438                 toPos--;
2439             return (toPos == to.length) ? to : Arrays.copyOf(to, toPos);
2440         }
2441 
2442         private static final ThreadLocal&lt;IndexNode&gt; cachedKey = new ThreadLocal&lt;&gt;();
2443 
2444         static final IndexNode keyOf(byte[] name) { // get a lookup key;
2445             IndexNode key = cachedKey.get();
2446             if (key == null) {
2447                 key = new IndexNode(name, -1);
2448                 cachedKey.set(key);
2449             }
2450             return key.as(name);
2451         }
2452 
2453         final void name(byte[] name) {
2454             this.name = name;
2455             this.hashcode = Arrays.hashCode(name);
2456         }
2457 
2458         final IndexNode as(byte[] name) {           // reuse the node, mostly
2459             name(name);                             // as a lookup &quot;key&quot;
2460             return this;
2461         }
2462 
2463         boolean isDir() {
2464             return isdir;
2465         }
2466 
2467         @Override
2468         public boolean equals(Object other) {
2469             if (!(other instanceof IndexNode)) {
2470                 return false;
2471             }
2472             if (other instanceof ParentLookup) {
2473                 return ((ParentLookup)other).equals(this);
2474             }
2475             return Arrays.equals(name, ((IndexNode)other).name);
2476         }
2477 
2478         @Override
2479         public int hashCode() {
2480             return hashcode;
2481         }
2482 
2483         @Override
2484         public String toString() {
2485             return new String(name) + (isdir ? &quot; (dir)&quot; : &quot; &quot;) + &quot;, index: &quot; + pos;
2486         }
2487     }
2488 
2489     static class Entry extends IndexNode implements ZipFileAttributes {
2490         static final int CEN    = 1;  // entry read from cen
2491         static final int NEW    = 2;  // updated contents in bytes or file
2492         static final int FILECH = 3;  // fch update in &quot;file&quot;
2493         static final int COPY   = 4;  // copy of a CEN entry
2494 
2495         byte[] bytes;                 // updated content bytes
2496         Path   file;                  // use tmp file to store bytes;
2497         int    type = CEN;            // default is the entry read from cen
2498 
2499         // entry attributes
2500         int    version;
2501         int    flag;
2502         int    posixPerms = -1; // posix permissions
2503         int    method = -1;    // compression method
2504         long   mtime  = -1;    // last modification time (in DOS time)
2505         long   atime  = -1;    // last access time
2506         long   ctime  = -1;    // create time
2507         long   crc    = -1;    // crc-32 of entry data
2508         long   csize  = -1;    // compressed size of entry data
2509         long   size   = -1;    // uncompressed size of entry data
2510         byte[] extra;
2511 
2512         // CEN
2513         // The fields that are commented out below are not used by anyone and write() uses &quot;0&quot;
2514         // int    versionMade;
2515         // int    disk;
2516         // int    attrs;
2517         // long   attrsEx;
2518         long   locoff;
2519         byte[] comment;
2520 
2521         Entry(byte[] name, boolean isdir, int method) {
2522             name(name);
2523             this.isdir = isdir;
2524             this.mtime  = this.ctime = this.atime = System.currentTimeMillis();
2525             this.crc    = 0;
2526             this.size   = 0;
2527             this.csize  = 0;
2528             this.method = method;
2529         }
2530 
2531         @SuppressWarnings(&quot;unchecked&quot;)
2532         Entry(byte[] name, int type, boolean isdir, int method, FileAttribute&lt;?&gt;... attrs) {
2533             this(name, isdir, method);
2534             this.type = type;
2535             for (FileAttribute&lt;?&gt; attr : attrs) {
2536                 String attrName = attr.name();
2537                 if (attrName.equals(&quot;posix:permissions&quot;)) {
2538                     posixPerms = ZipUtils.permsToFlags((Set&lt;PosixFilePermission&gt;)attr.value());
2539                 }
2540             }
2541         }
2542 
2543         Entry(byte[] name, Path file, int type, FileAttribute&lt;?&gt;... attrs) {
2544             this(name, type, false, METHOD_STORED, attrs);
2545             this.file = file;
2546         }
2547 
2548         Entry(Entry e, int type, int compressionMethod) {
2549             this(e, type);
2550             this.method = compressionMethod;
2551         }
2552 
2553         Entry(Entry e, int type) {
2554             name(e.name);
2555             this.isdir     = e.isdir;
2556             this.version   = e.version;
2557             this.ctime     = e.ctime;
2558             this.atime     = e.atime;
2559             this.mtime     = e.mtime;
2560             this.crc       = e.crc;
2561             this.size      = e.size;
2562             this.csize     = e.csize;
2563             this.method    = e.method;
2564             this.extra     = e.extra;
2565             /*
2566             this.versionMade = e.versionMade;
2567             this.disk      = e.disk;
2568             this.attrs     = e.attrs;
2569             this.attrsEx   = e.attrsEx;
2570             */
2571             this.locoff    = e.locoff;
2572             this.comment   = e.comment;
2573             this.posixPerms = e.posixPerms;
2574             this.type      = type;
2575         }
2576 
2577         Entry(ZipFileSystem zipfs, IndexNode inode) throws IOException {
2578             readCEN(zipfs, inode);
2579         }
2580 
2581         // Calculates a suitable base for the version number to
2582         // be used for fields version made by/version needed to extract.
2583         // The lower bytes of these 2 byte fields hold the version number
2584         // (value/10 = major; value%10 = minor)
2585         // For different features certain minimum versions apply:
2586         // stored = 10 (1.0), deflated = 20 (2.0), zip64 = 45 (4.5)
2587         private int version(boolean zip64) throws ZipException {
2588             if (zip64) {
2589                 return 45;
2590             }
2591             if (method == METHOD_DEFLATED)
2592                 return 20;
2593             else if (method == METHOD_STORED)
2594                 return 10;
2595             throw new ZipException(&quot;unsupported compression method&quot;);
2596         }
2597 
2598         /**
2599          * Adds information about compatibility of file attribute information
2600          * to a version value.
2601          */
2602         private int versionMadeBy(int version) {
2603             return (posixPerms &lt; 0) ? version :
2604                 VERSION_MADE_BY_BASE_UNIX | (version &amp; 0xff);
2605         }
2606 
2607         ///////////////////// CEN //////////////////////
2608         private void readCEN(ZipFileSystem zipfs, IndexNode inode) throws IOException {
2609             byte[] cen = zipfs.cen;
2610             int pos = inode.pos;
2611             if (!cenSigAt(cen, pos))
2612                 throw new ZipException(&quot;invalid CEN header (bad signature)&quot;);
2613             version     = CENVER(cen, pos);
2614             flag        = CENFLG(cen, pos);
2615             method      = CENHOW(cen, pos);
2616             mtime       = dosToJavaTime(CENTIM(cen, pos));
2617             crc         = CENCRC(cen, pos);
2618             csize       = CENSIZ(cen, pos);
2619             size        = CENLEN(cen, pos);
2620             int nlen    = CENNAM(cen, pos);
2621             int elen    = CENEXT(cen, pos);
2622             int clen    = CENCOM(cen, pos);
2623             /*
2624             versionMade = CENVEM(cen, pos);
2625             disk        = CENDSK(cen, pos);
2626             attrs       = CENATT(cen, pos);
2627             attrsEx     = CENATX(cen, pos);
2628             */
2629             if (CENVEM_FA(cen, pos) == FILE_ATTRIBUTES_UNIX) {
2630                 posixPerms = CENATX_PERMS(cen, pos) &amp; 0xFFF; // 12 bits for setuid, setgid, sticky + perms
2631             }
2632             locoff      = CENOFF(cen, pos);
2633             pos += CENHDR;
2634             this.name = inode.name;
2635             this.isdir = inode.isdir;
2636             this.hashcode = inode.hashcode;
2637 
2638             pos += nlen;
2639             if (elen &gt; 0) {
2640                 extra = Arrays.copyOfRange(cen, pos, pos + elen);
2641                 pos += elen;
2642                 readExtra(zipfs);
2643             }
2644             if (clen &gt; 0) {
2645                 comment = Arrays.copyOfRange(cen, pos, pos + clen);
2646             }
2647         }
2648 
2649         private int writeCEN(OutputStream os) throws IOException {
2650             long csize0  = csize;
2651             long size0   = size;
2652             long locoff0 = locoff;
2653             int elen64   = 0;                // extra for ZIP64
2654             int elenNTFS = 0;                // extra for NTFS (a/c/mtime)
2655             int elenEXTT = 0;                // extra for Extended Timestamp
2656             boolean foundExtraTime = false;  // if time stamp NTFS, EXTT present
2657 
2658             byte[] zname = isdir ? toDirectoryPath(name) : name;
2659 
2660             // confirm size/length
2661             int nlen = (zname != null) ? zname.length - 1 : 0;  // name has [0] as &quot;slash&quot;
2662             int elen = (extra != null) ? extra.length : 0;
2663             int eoff = 0;
2664             int clen = (comment != null) ? comment.length : 0;
2665             if (csize &gt;= ZIP64_MINVAL) {
2666                 csize0 = ZIP64_MINVAL;
2667                 elen64 += 8;                 // csize(8)
2668             }
2669             if (size &gt;= ZIP64_MINVAL) {
2670                 size0 = ZIP64_MINVAL;        // size(8)
2671                 elen64 += 8;
2672             }
2673             if (locoff &gt;= ZIP64_MINVAL) {
2674                 locoff0 = ZIP64_MINVAL;
2675                 elen64 += 8;                 // offset(8)
2676             }
2677             if (elen64 != 0) {
2678                 elen64 += 4;                 // header and data sz 4 bytes
2679             }
2680             boolean zip64 = (elen64 != 0);
2681             int version0 = version(zip64);
2682             while (eoff + 4 &lt; elen) {
2683                 int tag = SH(extra, eoff);
2684                 int sz = SH(extra, eoff + 2);
2685                 if (tag == EXTID_EXTT || tag == EXTID_NTFS) {
2686                     foundExtraTime = true;
2687                 }
2688                 eoff += (4 + sz);
2689             }
2690             if (!foundExtraTime) {
2691                 if (isWindows) {             // use NTFS
2692                     elenNTFS = 36;           // total 36 bytes
2693                 } else {                     // Extended Timestamp otherwise
2694                     elenEXTT = 9;            // only mtime in cen
2695                 }
2696             }
2697             writeInt(os, CENSIG);            // CEN header signature
2698             writeShort(os, versionMadeBy(version0)); // version made by
2699             writeShort(os, version0);        // version needed to extract
2700             writeShort(os, flag);            // general purpose bit flag
2701             writeShort(os, method);          // compression method
2702                                              // last modification time
2703             writeInt(os, (int)javaToDosTime(mtime));
2704             writeInt(os, crc);               // crc-32
2705             writeInt(os, csize0);            // compressed size
2706             writeInt(os, size0);             // uncompressed size
2707             writeShort(os, nlen);
2708             writeShort(os, elen + elen64 + elenNTFS + elenEXTT);
2709 
2710             if (comment != null) {
2711                 writeShort(os, Math.min(clen, 0xffff));
2712             } else {
2713                 writeShort(os, 0);
2714             }
2715             writeShort(os, 0);              // starting disk number
2716             writeShort(os, 0);              // internal file attributes (unused)
2717             writeInt(os, posixPerms &gt; 0 ? posixPerms &lt;&lt; 16 : 0); // external file
2718                                             // attributes, used for storing posix
2719                                             // permissions
2720             writeInt(os, locoff0);          // relative offset of local header
2721             writeBytes(os, zname, 1, nlen);
2722             if (zip64) {
2723                 writeShort(os, EXTID_ZIP64);// Zip64 extra
2724                 writeShort(os, elen64 - 4); // size of &quot;this&quot; extra block
2725                 if (size0 == ZIP64_MINVAL)
2726                     writeLong(os, size);
2727                 if (csize0 == ZIP64_MINVAL)
2728                     writeLong(os, csize);
2729                 if (locoff0 == ZIP64_MINVAL)
2730                     writeLong(os, locoff);
2731             }
2732             if (elenNTFS != 0) {
2733                 writeShort(os, EXTID_NTFS);
2734                 writeShort(os, elenNTFS - 4);
2735                 writeInt(os, 0);            // reserved
2736                 writeShort(os, 0x0001);     // NTFS attr tag
2737                 writeShort(os, 24);
2738                 writeLong(os, javaToWinTime(mtime));
2739                 writeLong(os, javaToWinTime(atime));
2740                 writeLong(os, javaToWinTime(ctime));
2741             }
2742             if (elenEXTT != 0) {
2743                 writeShort(os, EXTID_EXTT);
2744                 writeShort(os, elenEXTT - 4);
2745                 if (ctime == -1)
2746                     os.write(0x3);          // mtime and atime
2747                 else
2748                     os.write(0x7);          // mtime, atime and ctime
2749                 writeInt(os, javaToUnixTime(mtime));
2750             }
2751             if (extra != null)              // whatever not recognized
2752                 writeBytes(os, extra);
2753             if (comment != null)            //TBD: 0, Math.min(commentBytes.length, 0xffff));
2754                 writeBytes(os, comment);
2755             return CENHDR + nlen + elen + clen + elen64 + elenNTFS + elenEXTT;
2756         }
2757 
2758         ///////////////////// LOC //////////////////////
2759 
2760         private int writeLOC(OutputStream os) throws IOException {
2761             byte[] zname = isdir ? toDirectoryPath(name) : name;
2762             int nlen = (zname != null) ? zname.length - 1 : 0; // [0] is slash
2763             int elen = (extra != null) ? extra.length : 0;
2764             boolean foundExtraTime = false;     // if extra timestamp present
2765             int eoff = 0;
2766             int elen64 = 0;
2767             boolean zip64 = false;
2768             int elenEXTT = 0;
2769             int elenNTFS = 0;
2770             writeInt(os, LOCSIG);               // LOC header signature
2771             if ((flag &amp; FLAG_DATADESCR) != 0) {
2772                 writeShort(os, version(false)); // version needed to extract
2773                 writeShort(os, flag);           // general purpose bit flag
2774                 writeShort(os, method);         // compression method
2775                 // last modification time
2776                 writeInt(os, (int)javaToDosTime(mtime));
2777                 // store size, uncompressed size, and crc-32 in data descriptor
2778                 // immediately following compressed entry data
2779                 writeInt(os, 0);
2780                 writeInt(os, 0);
2781                 writeInt(os, 0);
2782             } else {
2783                 if (csize &gt;= ZIP64_MINVAL || size &gt;= ZIP64_MINVAL) {
2784                     elen64 = 20;    //headid(2) + size(2) + size(8) + csize(8)
2785                     zip64 = true;
2786                 }
2787                 writeShort(os, version(zip64)); // version needed to extract
2788                 writeShort(os, flag);           // general purpose bit flag
2789                 writeShort(os, method);         // compression method
2790                                                 // last modification time
2791                 writeInt(os, (int)javaToDosTime(mtime));
2792                 writeInt(os, crc);              // crc-32
2793                 if (zip64) {
2794                     writeInt(os, ZIP64_MINVAL);
2795                     writeInt(os, ZIP64_MINVAL);
2796                 } else {
2797                     writeInt(os, csize);        // compressed size
2798                     writeInt(os, size);         // uncompressed size
2799                 }
2800             }
2801             while (eoff + 4 &lt; elen) {
2802                 int tag = SH(extra, eoff);
2803                 int sz = SH(extra, eoff + 2);
2804                 if (tag == EXTID_EXTT || tag == EXTID_NTFS) {
2805                     foundExtraTime = true;
2806                 }
2807                 eoff += (4 + sz);
2808             }
2809             if (!foundExtraTime) {
2810                 if (isWindows) {
2811                     elenNTFS = 36;              // NTFS, total 36 bytes
2812                 } else {                        // on unix use &quot;ext time&quot;
2813                     elenEXTT = 9;
2814                     if (atime != -1)
2815                         elenEXTT += 4;
2816                     if (ctime != -1)
2817                         elenEXTT += 4;
2818                 }
2819             }
2820             writeShort(os, nlen);
2821             writeShort(os, elen + elen64 + elenNTFS + elenEXTT);
2822             writeBytes(os, zname, 1, nlen);
2823             if (zip64) {
2824                 writeShort(os, EXTID_ZIP64);
2825                 writeShort(os, 16);
2826                 writeLong(os, size);
2827                 writeLong(os, csize);
2828             }
2829             if (elenNTFS != 0) {
2830                 writeShort(os, EXTID_NTFS);
2831                 writeShort(os, elenNTFS - 4);
2832                 writeInt(os, 0);            // reserved
2833                 writeShort(os, 0x0001);     // NTFS attr tag
2834                 writeShort(os, 24);
2835                 writeLong(os, javaToWinTime(mtime));
2836                 writeLong(os, javaToWinTime(atime));
2837                 writeLong(os, javaToWinTime(ctime));
2838             }
2839             if (elenEXTT != 0) {
2840                 writeShort(os, EXTID_EXTT);
2841                 writeShort(os, elenEXTT - 4);// size for the folowing data block
2842                 int fbyte = 0x1;
2843                 if (atime != -1)           // mtime and atime
2844                     fbyte |= 0x2;
2845                 if (ctime != -1)           // mtime, atime and ctime
2846                     fbyte |= 0x4;
2847                 os.write(fbyte);           // flags byte
2848                 writeInt(os, javaToUnixTime(mtime));
2849                 if (atime != -1)
2850                     writeInt(os, javaToUnixTime(atime));
2851                 if (ctime != -1)
2852                     writeInt(os, javaToUnixTime(ctime));
2853             }
2854             if (extra != null) {
2855                 writeBytes(os, extra);
2856             }
2857             return LOCHDR + nlen + elen + elen64 + elenNTFS + elenEXTT;
2858         }
2859 
2860         // Data Descriptor
2861         private int writeEXT(OutputStream os) throws IOException {
2862             writeInt(os, EXTSIG);           // EXT header signature
2863             writeInt(os, crc);              // crc-32
2864             if (csize &gt;= ZIP64_MINVAL || size &gt;= ZIP64_MINVAL) {
2865                 writeLong(os, csize);
2866                 writeLong(os, size);
2867                 return 24;
2868             } else {
2869                 writeInt(os, csize);        // compressed size
2870                 writeInt(os, size);         // uncompressed size
2871                 return 16;
2872             }
2873         }
2874 
2875         // read NTFS, UNIX and ZIP64 data from cen.extra
2876         private void readExtra(ZipFileSystem zipfs) throws IOException {
2877             if (extra == null)
2878                 return;
2879             int elen = extra.length;
2880             int off = 0;
2881             int newOff = 0;
2882             while (off + 4 &lt; elen) {
2883                 // extra spec: HeaderID+DataSize+Data
2884                 int pos = off;
2885                 int tag = SH(extra, pos);
2886                 int sz = SH(extra, pos + 2);
2887                 pos += 4;
2888                 if (pos + sz &gt; elen)         // invalid data
2889                     break;
2890                 switch (tag) {
2891                 case EXTID_ZIP64 :
2892                     if (size == ZIP64_MINVAL) {
2893                         if (pos + 8 &gt; elen)  // invalid zip64 extra
2894                             break;           // fields, just skip
2895                         size = LL(extra, pos);
2896                         pos += 8;
2897                     }
2898                     if (csize == ZIP64_MINVAL) {
2899                         if (pos + 8 &gt; elen)
2900                             break;
2901                         csize = LL(extra, pos);
2902                         pos += 8;
2903                     }
2904                     if (locoff == ZIP64_MINVAL) {
2905                         if (pos + 8 &gt; elen)
2906                             break;
2907                         locoff = LL(extra, pos);
2908                     }
2909                     break;
2910                 case EXTID_NTFS:
2911                     if (sz &lt; 32)
2912                         break;
2913                     pos += 4;    // reserved 4 bytes
2914                     if (SH(extra, pos) !=  0x0001)
2915                         break;
2916                     if (SH(extra, pos + 2) != 24)
2917                         break;
2918                     // override the loc field, datatime here is
2919                     // more &quot;accurate&quot;
2920                     mtime  = winToJavaTime(LL(extra, pos + 4));
2921                     atime  = winToJavaTime(LL(extra, pos + 12));
2922                     ctime  = winToJavaTime(LL(extra, pos + 20));
2923                     break;
2924                 case EXTID_EXTT:
2925                     // spec says the Extened timestamp in cen only has mtime
2926                     // need to read the loc to get the extra a/ctime, if flag
2927                     // &quot;zipinfo-time&quot; is not specified to false;
2928                     // there is performance cost (move up to loc and read) to
2929                     // access the loc table foreach entry;
2930                     if (zipfs.noExtt) {
2931                         if (sz == 5)
2932                             mtime = unixToJavaTime(LG(extra, pos + 1));
2933                          break;
2934                     }
2935                     byte[] buf = new byte[LOCHDR];
2936                     if (zipfs.readFullyAt(buf, 0, buf.length , locoff)
2937                         != buf.length)
2938                         throw new ZipException(&quot;loc: reading failed&quot;);
2939                     if (!locSigAt(buf, 0))
2940                         throw new ZipException(&quot;loc: wrong sig -&gt;&quot;
2941                                            + Long.toString(getSig(buf, 0), 16));
2942                     int locElen = LOCEXT(buf);
2943                     if (locElen &lt; 9)    // EXTT is at least 9 bytes
2944                         break;
2945                     int locNlen = LOCNAM(buf);
2946                     buf = new byte[locElen];
2947                     if (zipfs.readFullyAt(buf, 0, buf.length , locoff + LOCHDR + locNlen)
2948                         != buf.length)
2949                         throw new ZipException(&quot;loc extra: reading failed&quot;);
2950                     int locPos = 0;
2951                     while (locPos + 4 &lt; buf.length) {
2952                         int locTag = SH(buf, locPos);
2953                         int locSZ  = SH(buf, locPos + 2);
2954                         locPos += 4;
2955                         if (locTag  != EXTID_EXTT) {
2956                             locPos += locSZ;
2957                              continue;
2958                         }
2959                         int end = locPos + locSZ - 4;
2960                         int flag = CH(buf, locPos++);
2961                         if ((flag &amp; 0x1) != 0 &amp;&amp; locPos &lt;= end) {
2962                             mtime = unixToJavaTime(LG(buf, locPos));
2963                             locPos += 4;
2964                         }
2965                         if ((flag &amp; 0x2) != 0 &amp;&amp; locPos &lt;= end) {
2966                             atime = unixToJavaTime(LG(buf, locPos));
2967                             locPos += 4;
2968                         }
2969                         if ((flag &amp; 0x4) != 0 &amp;&amp; locPos &lt;= end) {
2970                             ctime = unixToJavaTime(LG(buf, locPos));
2971                         }
2972                         break;
2973                     }
2974                     break;
2975                 default:    // unknown tag
2976                     System.arraycopy(extra, off, extra, newOff, sz + 4);
2977                     newOff += (sz + 4);
2978                 }
2979                 off += (sz + 4);
2980             }
2981             if (newOff != 0 &amp;&amp; newOff != extra.length)
2982                 extra = Arrays.copyOf(extra, newOff);
2983             else
2984                 extra = null;
2985         }
2986 
2987         @Override
2988         public String toString() {
2989             StringBuilder sb = new StringBuilder(1024);
2990             Formatter fm = new Formatter(sb);
2991             fm.format(&quot;    name            : %s%n&quot;, new String(name));
2992             fm.format(&quot;    creationTime    : %tc%n&quot;, creationTime().toMillis());
2993             fm.format(&quot;    lastAccessTime  : %tc%n&quot;, lastAccessTime().toMillis());
2994             fm.format(&quot;    lastModifiedTime: %tc%n&quot;, lastModifiedTime().toMillis());
2995             fm.format(&quot;    isRegularFile   : %b%n&quot;, isRegularFile());
2996             fm.format(&quot;    isDirectory     : %b%n&quot;, isDirectory());
2997             fm.format(&quot;    isSymbolicLink  : %b%n&quot;, isSymbolicLink());
2998             fm.format(&quot;    isOther         : %b%n&quot;, isOther());
2999             fm.format(&quot;    fileKey         : %s%n&quot;, fileKey());
3000             fm.format(&quot;    size            : %d%n&quot;, size());
3001             fm.format(&quot;    compressedSize  : %d%n&quot;, compressedSize());
3002             fm.format(&quot;    crc             : %x%n&quot;, crc());
3003             fm.format(&quot;    method          : %d%n&quot;, method());
3004             Set&lt;PosixFilePermission&gt; permissions = storedPermissions().orElse(null);
3005             if (permissions != null) {
3006                 fm.format(&quot;    permissions     : %s%n&quot;, permissions);
3007             }
3008             fm.close();
3009             return sb.toString();
3010         }
3011 
3012         ///////// basic file attributes ///////////
3013         @Override
3014         public FileTime creationTime() {
3015             return FileTime.fromMillis(ctime == -1 ? mtime : ctime);
3016         }
3017 
3018         @Override
3019         public boolean isDirectory() {
3020             return isDir();
3021         }
3022 
3023         @Override
3024         public boolean isOther() {
3025             return false;
3026         }
3027 
3028         @Override
3029         public boolean isRegularFile() {
3030             return !isDir();
3031         }
3032 
3033         @Override
3034         public FileTime lastAccessTime() {
3035             return FileTime.fromMillis(atime == -1 ? mtime : atime);
3036         }
3037 
3038         @Override
3039         public FileTime lastModifiedTime() {
3040             return FileTime.fromMillis(mtime);
3041         }
3042 
3043         @Override
3044         public long size() {
3045             return size;
3046         }
3047 
3048         @Override
3049         public boolean isSymbolicLink() {
3050             return false;
3051         }
3052 
3053         @Override
3054         public Object fileKey() {
3055             return null;
3056         }
3057 
3058         ///////// zip file attributes ///////////
3059 
3060         @Override
3061         public long compressedSize() {
3062             return csize;
3063         }
3064 
3065         @Override
3066         public long crc() {
3067             return crc;
3068         }
3069 
3070         @Override
3071         public int method() {
3072             return method;
3073         }
3074 
3075         @Override
3076         public byte[] extra() {
3077             if (extra != null)
3078                 return Arrays.copyOf(extra, extra.length);
3079             return null;
3080         }
3081 
3082         @Override
3083         public byte[] comment() {
3084             if (comment != null)
3085                 return Arrays.copyOf(comment, comment.length);
3086             return null;
3087         }
3088 
3089         @Override
3090         public Optional&lt;Set&lt;PosixFilePermission&gt;&gt; storedPermissions() {
3091             Set&lt;PosixFilePermission&gt; perms = null;
3092             if (posixPerms != -1) {
3093                 perms = new HashSet&lt;&gt;(PosixFilePermission.values().length);
3094                 for (PosixFilePermission perm : PosixFilePermission.values()) {
3095                     if ((posixPerms &amp; ZipUtils.permToFlag(perm)) != 0) {
3096                         perms.add(perm);
3097                     }
3098                 }
3099             }
3100             return Optional.ofNullable(perms);
3101         }
3102     }
3103 
3104     final class PosixEntry extends Entry implements PosixFileAttributes {
3105         private UserPrincipal owner = defaultOwner;
3106         private GroupPrincipal group = defaultGroup;
3107 
3108         PosixEntry(byte[] name, boolean isdir, int method) {
3109             super(name, isdir, method);
3110         }
3111 
3112         PosixEntry(byte[] name, int type, boolean isdir, int method, FileAttribute&lt;?&gt;... attrs) {
3113             super(name, type, isdir, method, attrs);
3114         }
3115 
3116         PosixEntry(byte[] name, Path file, int type, FileAttribute&lt;?&gt;... attrs) {
3117             super(name, file, type, attrs);
3118         }
3119 
3120         PosixEntry(PosixEntry e, int type, int compressionMethod) {
3121             super(e, type);
3122             this.method = compressionMethod;
3123         }
3124 
3125         PosixEntry(PosixEntry e, int type) {
3126             super(e, type);
3127             this.owner = e.owner;
3128             this.group = e.group;
3129         }
3130 
3131         PosixEntry(ZipFileSystem zipfs, IndexNode inode) throws IOException {
3132             super(zipfs, inode);
3133         }
3134 
3135         @Override
3136         public UserPrincipal owner() {
3137             return owner;
3138         }
3139 
3140         @Override
3141         public GroupPrincipal group() {
3142             return group;
3143         }
3144 
3145         @Override
3146         public Set&lt;PosixFilePermission&gt; permissions() {
3147             return storedPermissions().orElse(Set.copyOf(defaultPermissions));
3148         }
3149     }
3150 
3151     // purely for parent lookup, so we don&#39;t have to copy the parent
3152     // name every time
3153     static class ParentLookup extends IndexNode {
3154         int len;
3155         ParentLookup() {}
3156 
3157         final ParentLookup as(byte[] name, int len) { // as a lookup &quot;key&quot;
3158             name(name, len);
3159             return this;
3160         }
3161 
3162         void name(byte[] name, int len) {
3163             this.name = name;
3164             this.len = len;
3165             // calculate the hashcode the same way as Arrays.hashCode() does
3166             int result = 1;
3167             for (int i = 0; i &lt; len; i++)
3168                 result = 31 * result + name[i];
3169             this.hashcode = result;
3170         }
3171 
3172         @Override
3173         public boolean equals(Object other) {
3174             if (!(other instanceof IndexNode)) {
3175                 return false;
3176             }
3177             byte[] oname = ((IndexNode)other).name;
3178             return Arrays.equals(name, 0, len,
3179                                  oname, 0, oname.length);
3180         }
3181     }
3182 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordedObject.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../jdk.jdwp.agent/share/native/libjdwp/log_messages.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../internal/dcmd/DCmdConfigure.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordedObject.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
487      * This method can be used on the following types: {@code short} and {@code byte}.
488      * &lt;p&gt;
489      * If the field has the {@code @Unsigned} annotation and is of a narrower type
490      * than {@code short}, then the value is returned as an unsigned.
491      * &lt;p&gt;
492      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
493      * {@code &quot;aaa.bbb&quot;}).
494      * &lt;p&gt;
495      * A field might change or be removed in a future JDK release. A best practice
496      * for callers of this method is to validate the field before attempting access.
497      *
498      * @param name of the field to get, not {@code null}
499      *
500      * @return the value of the field converted to type {@code short}
501      *
502      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
503      *         value can&#39;t be converted to the type {@code short} by a widening
504      *         conversion
505      *
506      * @see #hasField(String)
<span class="line-modified">507      * @set #getValue(String)</span>
508      */
509     public final short getShort(String name) {
510         Object o = getValue(name, true);
511         if (o instanceof Short) {
512             return ((Short) o).shortValue();
513         }
514         if (o instanceof Byte) {
515             return ((Byte) o).byteValue();
516         }
517         if (o instanceof UnsignedValue) {
518             Object u = ((UnsignedValue) o).value();
519             if (u instanceof Short) {
520                 return ((Short) u).shortValue();
521             }
522             if (u instanceof Byte) {
523                 return (short) Byte.toUnsignedInt(((Byte) u));
524             }
525         }
526         throw newIllegalArgumentException(name, &quot;short&quot;);
527     }
</pre>
<hr />
<pre>
534      * {@code short}, {@code char}, and {@code byte}.
535      * &lt;p&gt;
536      * If the field has the {@code @Unsigned} annotation and is of a narrower type
537      * than {@code int}, then the value will be returned as an unsigned.
538      * &lt;p&gt;
539      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
540      * {@code &quot;aaa.bbb&quot;}).
541      * &lt;p&gt;
542      * A field might change or be removed in a future JDK release. A best practice
543      * for callers of this method is to validate the field before attempting access.
544      *
545      * @param name of the field to get, not {@code null}
546      *
547      * @return the value of the field converted to type {@code int}
548      *
549      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
550      *         value can&#39;t be converted to the type {@code int} by a widening
551      *         conversion
552      *
553      * @see #hasField(String)
<span class="line-modified">554      * @set #getValue(String)</span>
555      */
556     public final int getInt(String name) {
557         Object o = getValue(name, true);
558         if (o instanceof Integer) {
559             return ((Integer) o).intValue();
560         }
561         if (o instanceof Short) {
562             return ((Short) o).intValue();
563         }
564         if (o instanceof Character) {
565             return ((Character) o).charValue();
566         }
567         if (o instanceof Byte) {
568             return ((Byte) o).intValue();
569         }
570         if (o instanceof UnsignedValue) {
571             Object u = ((UnsignedValue) o).value();
572             if (u instanceof Integer) {
573                 return ((Integer) u).intValue();
574             }
</pre>
<hr />
<pre>
587      * type convertible to type {@code float} by a widening conversion.
588      * &lt;p&gt;
589      * This method can be used on fields of the following types: {@code float},
590      * {@code long}, {@code int}, {@code short}, {@code char}, and {@code byte}.
591      * &lt;p&gt;
592      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
593      * {@code &quot;aaa.bbb&quot;}).
594      * &lt;p&gt;
595      * A field might change or be removed in a future JDK release. A best practice
596      * for callers of this method is to validate the field before attempting access.
597      *
598      * @param name of the field to get, not {@code null}
599      *
600      * @return the value of the field converted to type {@code float}
601      *
602      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
603      *         value can&#39;t be converted to the type {@code float} by a widening
604      *         conversion
605      *
606      * @see #hasField(String)
<span class="line-modified">607      * @set #getValue(String)</span>
608      */
609     public final float getFloat(String name) {
610         Object o = getValue(name);
611         if (o instanceof Float) {
612             return ((Float) o).floatValue();
613         }
614         if (o instanceof Long) {
615             return ((Long) o).floatValue();
616         }
617         if (o instanceof Integer) {
618             return ((Integer) o).floatValue();
619         }
620         if (o instanceof Short) {
621             return ((Short) o).floatValue();
622         }
623         if (o instanceof Byte) {
624             return ((Byte) o).byteValue();
625         }
626         if (o instanceof Character) {
627             return ((Character) o).charValue();
</pre>
<hr />
<pre>
637      * {@code int}, {@code short}, {@code char}, and {@code byte}.
638      * &lt;p&gt;
639      * If the field has the {@code @Unsigned} annotation and is of a narrower type
640      * than {@code long}, then the value will be returned as an unsigned.
641      * &lt;p&gt;
642      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
643      * {@code &quot;aaa.bbb&quot;}).
644      * &lt;p&gt;
645      * A field might change or be removed in a future JDK release. A best practice
646      * for callers of this method is to validate the field before attempting access.
647      *
648      * @param name of the field to get, not {@code null}
649      *
650      * @return the value of the field converted to type {@code long}
651      *
652      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
653      *         value can&#39;t be converted to the type {@code long} via a widening
654      *         conversion
655      *
656      * @see #hasField(String)
<span class="line-modified">657      * @set #getValue(String)</span>
658      */
659     public final long getLong(String name) {
660         Object o = getValue(name, true);
661         if (o instanceof Long) {
662             return ((Long) o).longValue();
663         }
664         if (o instanceof Integer) {
665             return ((Integer) o).longValue();
666         }
667         if (o instanceof Short) {
668             return ((Short) o).longValue();
669         }
670         if (o instanceof Character) {
671             return ((Character) o).charValue();
672         }
673         if (o instanceof Byte) {
674             return ((Byte) o).longValue();
675         }
676         if (o instanceof UnsignedValue) {
677             Object u = ((UnsignedValue) o).value();
</pre>
<hr />
<pre>
693      * type that is convertible to type {@code double} by a widening conversion.
694      * &lt;p&gt;
695      * This method can be used on fields of the following types: {@code double}, {@code float},
696      * {@code long}, {@code int}, {@code short}, {@code char}, and {@code byte}.
697      * &lt;p&gt;
698      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
699      * {@code &quot;aaa.bbb&quot;}).
700      * &lt;p&gt;
701      * A field might change or be removed in a future JDK release. A best practice
702      * for callers of this method is to validate the field before attempting access.
703      *
704      * @param name of the field to get, not {@code null}
705      *
706      * @return the value of the field converted to type {@code double}
707      *
708      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
709      *         value can&#39;t be converted to the type {@code double} by a widening
710      *         conversion
711      *
712      * @see #hasField(String)
<span class="line-modified">713      * @set #getValue(String)</span>
714      */
715     public final double getDouble(String name) {
716         Object o = getValue(name);
717         if (o instanceof Double) {
718             return ((Double) o).doubleValue();
719         }
720         if (o instanceof Float) {
721             return ((Float) o).doubleValue();
722         }
723         if (o instanceof Long) {
724             return ((Long) o).doubleValue();
725         }
726         if (o instanceof Integer) {
727             return ((Integer) o).doubleValue();
728         }
729         if (o instanceof Short) {
730             return ((Short) o).doubleValue();
731         }
732         if (o instanceof Byte) {
733             return ((Byte) o).byteValue();
</pre>
<hr />
<pre>
738         throw newIllegalArgumentException(name, &quot;double&quot;);
739     }
740 
741     /**
742      * Returns the value of a field of type {@code String}.
743      * &lt;p&gt;
744      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
745      * {@code &quot;foo.bar&quot;}).
746      * &lt;p&gt;
747      * A field might change or be removed in a future JDK release. A best practice
748      * for callers of this method is to validate the field before attempting access.
749      *
750      * @param name of the field to get, not {@code null}
751      *
752      * @return the value of the field as a {@code String}, can be {@code null}
753      *
754      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
755      *         isn&#39;t of type {@code String}
756      *
757      * @see #hasField(String)
<span class="line-modified">758      * @set #getValue(String)</span>
759      */
760     public final String getString(String name) {
761         return getTypedValue(name, &quot;java.lang.String&quot;);
762     }
763 
764     /**
765      * Returns the value of a timespan field.
766      * &lt;p&gt;
767      * This method can be used on fields annotated with {@code @Timespan}, and of
768      * the following types: {@code long}, {@code int}, {@code short}, {@code char},
769      * and {@code byte}.
770      * &lt;p&gt;
771      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
772      * {@code &quot;aaa.bbb&quot;}).
773      * &lt;p&gt;
774      * A field might change or be removed in a future JDK release. A best practice
775      * for callers of this method is to validate the field before attempting access.
776      *
777      * @param name of the field to get, not {@code null}
778      *
779      * @return a time span represented as a {@code Duration}, not {@code null}
780      *
781      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
782      *         value can&#39;t be converted to a {@code Duration} object
783      *
784      * @see #hasField(String)
<span class="line-modified">785      * @set #getValue(String)</span>
786      */
787     public final Duration getDuration(String name) {
788         Object o = getValue(name);
789         if (o instanceof Long) {
790             return getDuration(((Long) o).longValue(), name);
791         }
792         if (o instanceof Integer) {
793             return getDuration(((Integer) o).longValue(), name);
794         }
795         if (o instanceof Short) {
796             return getDuration(((Short) o).longValue(), name);
797         }
798         if (o instanceof Character) {
799             return getDuration(((Character) o).charValue(), name);
800         }
801         if (o instanceof Byte) {
802             return getDuration(((Byte) o).longValue(), name);
803         }
804         if (o instanceof UnsignedValue) {
805             Object u = ((UnsignedValue) o).value();
806             if (u instanceof Integer) {
807                 return getDuration(Integer.toUnsignedLong((Integer) u), name);
808             }
809             if (u instanceof Short) {
810                 return getDuration(Short.toUnsignedLong((Short) u), name);
811             }
812             if (u instanceof Byte) {
813                 return getDuration(Short.toUnsignedLong((Byte) u), name);
814             }
815         }
<span class="line-modified">816         throw newIllegalArgumentException(name, &quot;java,time.Duration&quot;);</span>
817     }
818 
819     private Duration getDuration(long timespan, String name) throws InternalError {
820         ValueDescriptor v = getValueDescriptor(objectContext.fields, name, null);
821         if (timespan == Long.MIN_VALUE) {
822             return Duration.ofSeconds(Long.MIN_VALUE, 0);
823         }
824         Timespan ts = v.getAnnotation(Timespan.class);
825         if (ts != null) {
826             switch (ts.value()) {
827             case Timespan.MICROSECONDS:
828                 return Duration.ofNanos(1000 * timespan);
829             case Timespan.SECONDS:
830                 return Duration.ofSeconds(timespan);
831             case Timespan.MILLISECONDS:
832                 return Duration.ofMillis(timespan);
833             case Timespan.NANOSECONDS:
834                 return Duration.ofNanos(timespan);
835             case Timespan.TICKS:
836                 return Duration.ofNanos(objectContext.convertTimespan(timespan));
</pre>
<hr />
<pre>
844      * Returns the value of a timestamp field.
845      * &lt;p&gt;
846      * This method can be used on fields annotated with {@code @Timestamp}, and of
847      * the following types: {@code long}, {@code int}, {@code short}, {@code char}
848      * and {@code byte}.
849      * &lt;p&gt;
850      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
851      * {@code &quot;aaa.bbb&quot;}).
852      * &lt;p&gt;
853      * A field might change or be removed in a future JDK release. A best practice
854      * for callers of this method is to validate the field before attempting access.
855      *
856      * @param name of the field to get, not {@code null}
857      *
858      * @return a timstamp represented as an {@code Instant}, not {@code null}
859      *
860      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
861      *         value can&#39;t be converted to an {@code Instant} object
862      *
863      * @see #hasField(String)
<span class="line-modified">864      * @set #getValue(String)</span>
865      */
866     public final Instant getInstant(String name) {
867         Object o = getValue(name, true);
868         if (o instanceof Long) {
869             return getInstant(((Long) o).longValue(), name);
870         }
871         if (o instanceof Integer) {
872             return getInstant(((Integer) o).longValue(), name);
873         }
874         if (o instanceof Short) {
875             return getInstant(((Short) o).longValue(), name);
876         }
877         if (o instanceof Character) {
878             return getInstant(((Character) o).charValue(), name);
879         }
880         if (o instanceof Byte) {
881             return getInstant(((Byte) o).longValue(), name);
882         }
883         if (o instanceof UnsignedValue) {
884             Object u = ((UnsignedValue) o).value();
</pre>
<hr />
<pre>
914     }
915 
916     /**
917      * Returns the value of a field of type {@code Class}.
918      * &lt;p&gt;
919      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
920      * {@code &quot;aaa.bbb&quot;}).
921      * &lt;p&gt;
922      * A field might change or be removed in a future JDK release. A best practice
923      * for callers of this method is to validate the field before attempting access.
924      *
925      * @param name of the field to get, not {@code null}
926      *
927      * @return the value of the field as a {@code RecordedClass}, can be
928      *         {@code null}
929      *
930      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
931      *         isn&#39;t of type {@code Class}
932      *
933      * @see #hasField(String)
<span class="line-modified">934      * @set #getValue(String)</span>
935      */
936     public final RecordedClass getClass(String name) {
937         return getTypedValue(name, &quot;java.lang.Class&quot;);
938     }
939 
940     /**
941      * Returns the value of a field of type {@code Thread}.
942      * &lt;p&gt;
943      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
944      * {@code &quot;foo.bar&quot;}).
945      * &lt;p&gt;
946      * A field might change or be removed in a future JDK release. A best practice
947      * for callers of this method is to validate the field before attempting access.
948      *
949      * @param name of the field to get, not {@code null}
950      *
951      * @return the value of the field as a {@code RecordedThread} object, can be
952      *         {@code null}
953      *
954      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
955      *         isn&#39;t of type {@code Thread}
956      *
957      * @see #hasField(String)
<span class="line-modified">958      * @set #getValue(String)</span>
959      */
960     public final RecordedThread getThread(String name) {
961         return getTypedValue(name, &quot;java.lang.Thread&quot;);
962     }
963 
964     /**
965      * Returns a textual representation of this object.
966      *
967      * @return textual description of this object
968      */
969     @Override
970     final public String toString() {
971         StringWriter s = new StringWriter();
972         PrettyWriter p = new PrettyWriter(new PrintWriter(s));
973         p.setStackDepth(5);
974         if (this instanceof RecordedEvent) {
975             p.print((RecordedEvent) this);
976         } else {
977             p.print(this, &quot;&quot;);
978         }
</pre>
</td>
<td>
<hr />
<pre>
487      * This method can be used on the following types: {@code short} and {@code byte}.
488      * &lt;p&gt;
489      * If the field has the {@code @Unsigned} annotation and is of a narrower type
490      * than {@code short}, then the value is returned as an unsigned.
491      * &lt;p&gt;
492      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
493      * {@code &quot;aaa.bbb&quot;}).
494      * &lt;p&gt;
495      * A field might change or be removed in a future JDK release. A best practice
496      * for callers of this method is to validate the field before attempting access.
497      *
498      * @param name of the field to get, not {@code null}
499      *
500      * @return the value of the field converted to type {@code short}
501      *
502      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
503      *         value can&#39;t be converted to the type {@code short} by a widening
504      *         conversion
505      *
506      * @see #hasField(String)
<span class="line-modified">507      * @see #getValue(String)</span>
508      */
509     public final short getShort(String name) {
510         Object o = getValue(name, true);
511         if (o instanceof Short) {
512             return ((Short) o).shortValue();
513         }
514         if (o instanceof Byte) {
515             return ((Byte) o).byteValue();
516         }
517         if (o instanceof UnsignedValue) {
518             Object u = ((UnsignedValue) o).value();
519             if (u instanceof Short) {
520                 return ((Short) u).shortValue();
521             }
522             if (u instanceof Byte) {
523                 return (short) Byte.toUnsignedInt(((Byte) u));
524             }
525         }
526         throw newIllegalArgumentException(name, &quot;short&quot;);
527     }
</pre>
<hr />
<pre>
534      * {@code short}, {@code char}, and {@code byte}.
535      * &lt;p&gt;
536      * If the field has the {@code @Unsigned} annotation and is of a narrower type
537      * than {@code int}, then the value will be returned as an unsigned.
538      * &lt;p&gt;
539      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
540      * {@code &quot;aaa.bbb&quot;}).
541      * &lt;p&gt;
542      * A field might change or be removed in a future JDK release. A best practice
543      * for callers of this method is to validate the field before attempting access.
544      *
545      * @param name of the field to get, not {@code null}
546      *
547      * @return the value of the field converted to type {@code int}
548      *
549      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
550      *         value can&#39;t be converted to the type {@code int} by a widening
551      *         conversion
552      *
553      * @see #hasField(String)
<span class="line-modified">554      * @see #getValue(String)</span>
555      */
556     public final int getInt(String name) {
557         Object o = getValue(name, true);
558         if (o instanceof Integer) {
559             return ((Integer) o).intValue();
560         }
561         if (o instanceof Short) {
562             return ((Short) o).intValue();
563         }
564         if (o instanceof Character) {
565             return ((Character) o).charValue();
566         }
567         if (o instanceof Byte) {
568             return ((Byte) o).intValue();
569         }
570         if (o instanceof UnsignedValue) {
571             Object u = ((UnsignedValue) o).value();
572             if (u instanceof Integer) {
573                 return ((Integer) u).intValue();
574             }
</pre>
<hr />
<pre>
587      * type convertible to type {@code float} by a widening conversion.
588      * &lt;p&gt;
589      * This method can be used on fields of the following types: {@code float},
590      * {@code long}, {@code int}, {@code short}, {@code char}, and {@code byte}.
591      * &lt;p&gt;
592      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
593      * {@code &quot;aaa.bbb&quot;}).
594      * &lt;p&gt;
595      * A field might change or be removed in a future JDK release. A best practice
596      * for callers of this method is to validate the field before attempting access.
597      *
598      * @param name of the field to get, not {@code null}
599      *
600      * @return the value of the field converted to type {@code float}
601      *
602      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
603      *         value can&#39;t be converted to the type {@code float} by a widening
604      *         conversion
605      *
606      * @see #hasField(String)
<span class="line-modified">607      * @see #getValue(String)</span>
608      */
609     public final float getFloat(String name) {
610         Object o = getValue(name);
611         if (o instanceof Float) {
612             return ((Float) o).floatValue();
613         }
614         if (o instanceof Long) {
615             return ((Long) o).floatValue();
616         }
617         if (o instanceof Integer) {
618             return ((Integer) o).floatValue();
619         }
620         if (o instanceof Short) {
621             return ((Short) o).floatValue();
622         }
623         if (o instanceof Byte) {
624             return ((Byte) o).byteValue();
625         }
626         if (o instanceof Character) {
627             return ((Character) o).charValue();
</pre>
<hr />
<pre>
637      * {@code int}, {@code short}, {@code char}, and {@code byte}.
638      * &lt;p&gt;
639      * If the field has the {@code @Unsigned} annotation and is of a narrower type
640      * than {@code long}, then the value will be returned as an unsigned.
641      * &lt;p&gt;
642      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
643      * {@code &quot;aaa.bbb&quot;}).
644      * &lt;p&gt;
645      * A field might change or be removed in a future JDK release. A best practice
646      * for callers of this method is to validate the field before attempting access.
647      *
648      * @param name of the field to get, not {@code null}
649      *
650      * @return the value of the field converted to type {@code long}
651      *
652      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
653      *         value can&#39;t be converted to the type {@code long} via a widening
654      *         conversion
655      *
656      * @see #hasField(String)
<span class="line-modified">657      * @see #getValue(String)</span>
658      */
659     public final long getLong(String name) {
660         Object o = getValue(name, true);
661         if (o instanceof Long) {
662             return ((Long) o).longValue();
663         }
664         if (o instanceof Integer) {
665             return ((Integer) o).longValue();
666         }
667         if (o instanceof Short) {
668             return ((Short) o).longValue();
669         }
670         if (o instanceof Character) {
671             return ((Character) o).charValue();
672         }
673         if (o instanceof Byte) {
674             return ((Byte) o).longValue();
675         }
676         if (o instanceof UnsignedValue) {
677             Object u = ((UnsignedValue) o).value();
</pre>
<hr />
<pre>
693      * type that is convertible to type {@code double} by a widening conversion.
694      * &lt;p&gt;
695      * This method can be used on fields of the following types: {@code double}, {@code float},
696      * {@code long}, {@code int}, {@code short}, {@code char}, and {@code byte}.
697      * &lt;p&gt;
698      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
699      * {@code &quot;aaa.bbb&quot;}).
700      * &lt;p&gt;
701      * A field might change or be removed in a future JDK release. A best practice
702      * for callers of this method is to validate the field before attempting access.
703      *
704      * @param name of the field to get, not {@code null}
705      *
706      * @return the value of the field converted to type {@code double}
707      *
708      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
709      *         value can&#39;t be converted to the type {@code double} by a widening
710      *         conversion
711      *
712      * @see #hasField(String)
<span class="line-modified">713      * @see #getValue(String)</span>
714      */
715     public final double getDouble(String name) {
716         Object o = getValue(name);
717         if (o instanceof Double) {
718             return ((Double) o).doubleValue();
719         }
720         if (o instanceof Float) {
721             return ((Float) o).doubleValue();
722         }
723         if (o instanceof Long) {
724             return ((Long) o).doubleValue();
725         }
726         if (o instanceof Integer) {
727             return ((Integer) o).doubleValue();
728         }
729         if (o instanceof Short) {
730             return ((Short) o).doubleValue();
731         }
732         if (o instanceof Byte) {
733             return ((Byte) o).byteValue();
</pre>
<hr />
<pre>
738         throw newIllegalArgumentException(name, &quot;double&quot;);
739     }
740 
741     /**
742      * Returns the value of a field of type {@code String}.
743      * &lt;p&gt;
744      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
745      * {@code &quot;foo.bar&quot;}).
746      * &lt;p&gt;
747      * A field might change or be removed in a future JDK release. A best practice
748      * for callers of this method is to validate the field before attempting access.
749      *
750      * @param name of the field to get, not {@code null}
751      *
752      * @return the value of the field as a {@code String}, can be {@code null}
753      *
754      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
755      *         isn&#39;t of type {@code String}
756      *
757      * @see #hasField(String)
<span class="line-modified">758      * @see #getValue(String)</span>
759      */
760     public final String getString(String name) {
761         return getTypedValue(name, &quot;java.lang.String&quot;);
762     }
763 
764     /**
765      * Returns the value of a timespan field.
766      * &lt;p&gt;
767      * This method can be used on fields annotated with {@code @Timespan}, and of
768      * the following types: {@code long}, {@code int}, {@code short}, {@code char},
769      * and {@code byte}.
770      * &lt;p&gt;
771      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
772      * {@code &quot;aaa.bbb&quot;}).
773      * &lt;p&gt;
774      * A field might change or be removed in a future JDK release. A best practice
775      * for callers of this method is to validate the field before attempting access.
776      *
777      * @param name of the field to get, not {@code null}
778      *
779      * @return a time span represented as a {@code Duration}, not {@code null}
780      *
781      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
782      *         value can&#39;t be converted to a {@code Duration} object
783      *
784      * @see #hasField(String)
<span class="line-modified">785      * @see #getValue(String)</span>
786      */
787     public final Duration getDuration(String name) {
788         Object o = getValue(name);
789         if (o instanceof Long) {
790             return getDuration(((Long) o).longValue(), name);
791         }
792         if (o instanceof Integer) {
793             return getDuration(((Integer) o).longValue(), name);
794         }
795         if (o instanceof Short) {
796             return getDuration(((Short) o).longValue(), name);
797         }
798         if (o instanceof Character) {
799             return getDuration(((Character) o).charValue(), name);
800         }
801         if (o instanceof Byte) {
802             return getDuration(((Byte) o).longValue(), name);
803         }
804         if (o instanceof UnsignedValue) {
805             Object u = ((UnsignedValue) o).value();
806             if (u instanceof Integer) {
807                 return getDuration(Integer.toUnsignedLong((Integer) u), name);
808             }
809             if (u instanceof Short) {
810                 return getDuration(Short.toUnsignedLong((Short) u), name);
811             }
812             if (u instanceof Byte) {
813                 return getDuration(Short.toUnsignedLong((Byte) u), name);
814             }
815         }
<span class="line-modified">816         throw newIllegalArgumentException(name, &quot;java.time.Duration&quot;);</span>
817     }
818 
819     private Duration getDuration(long timespan, String name) throws InternalError {
820         ValueDescriptor v = getValueDescriptor(objectContext.fields, name, null);
821         if (timespan == Long.MIN_VALUE) {
822             return Duration.ofSeconds(Long.MIN_VALUE, 0);
823         }
824         Timespan ts = v.getAnnotation(Timespan.class);
825         if (ts != null) {
826             switch (ts.value()) {
827             case Timespan.MICROSECONDS:
828                 return Duration.ofNanos(1000 * timespan);
829             case Timespan.SECONDS:
830                 return Duration.ofSeconds(timespan);
831             case Timespan.MILLISECONDS:
832                 return Duration.ofMillis(timespan);
833             case Timespan.NANOSECONDS:
834                 return Duration.ofNanos(timespan);
835             case Timespan.TICKS:
836                 return Duration.ofNanos(objectContext.convertTimespan(timespan));
</pre>
<hr />
<pre>
844      * Returns the value of a timestamp field.
845      * &lt;p&gt;
846      * This method can be used on fields annotated with {@code @Timestamp}, and of
847      * the following types: {@code long}, {@code int}, {@code short}, {@code char}
848      * and {@code byte}.
849      * &lt;p&gt;
850      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
851      * {@code &quot;aaa.bbb&quot;}).
852      * &lt;p&gt;
853      * A field might change or be removed in a future JDK release. A best practice
854      * for callers of this method is to validate the field before attempting access.
855      *
856      * @param name of the field to get, not {@code null}
857      *
858      * @return a timstamp represented as an {@code Instant}, not {@code null}
859      *
860      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
861      *         value can&#39;t be converted to an {@code Instant} object
862      *
863      * @see #hasField(String)
<span class="line-modified">864      * @see #getValue(String)</span>
865      */
866     public final Instant getInstant(String name) {
867         Object o = getValue(name, true);
868         if (o instanceof Long) {
869             return getInstant(((Long) o).longValue(), name);
870         }
871         if (o instanceof Integer) {
872             return getInstant(((Integer) o).longValue(), name);
873         }
874         if (o instanceof Short) {
875             return getInstant(((Short) o).longValue(), name);
876         }
877         if (o instanceof Character) {
878             return getInstant(((Character) o).charValue(), name);
879         }
880         if (o instanceof Byte) {
881             return getInstant(((Byte) o).longValue(), name);
882         }
883         if (o instanceof UnsignedValue) {
884             Object u = ((UnsignedValue) o).value();
</pre>
<hr />
<pre>
914     }
915 
916     /**
917      * Returns the value of a field of type {@code Class}.
918      * &lt;p&gt;
919      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
920      * {@code &quot;aaa.bbb&quot;}).
921      * &lt;p&gt;
922      * A field might change or be removed in a future JDK release. A best practice
923      * for callers of this method is to validate the field before attempting access.
924      *
925      * @param name of the field to get, not {@code null}
926      *
927      * @return the value of the field as a {@code RecordedClass}, can be
928      *         {@code null}
929      *
930      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
931      *         isn&#39;t of type {@code Class}
932      *
933      * @see #hasField(String)
<span class="line-modified">934      * @see #getValue(String)</span>
935      */
936     public final RecordedClass getClass(String name) {
937         return getTypedValue(name, &quot;java.lang.Class&quot;);
938     }
939 
940     /**
941      * Returns the value of a field of type {@code Thread}.
942      * &lt;p&gt;
943      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
944      * {@code &quot;foo.bar&quot;}).
945      * &lt;p&gt;
946      * A field might change or be removed in a future JDK release. A best practice
947      * for callers of this method is to validate the field before attempting access.
948      *
949      * @param name of the field to get, not {@code null}
950      *
951      * @return the value of the field as a {@code RecordedThread} object, can be
952      *         {@code null}
953      *
954      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
955      *         isn&#39;t of type {@code Thread}
956      *
957      * @see #hasField(String)
<span class="line-modified">958      * @see #getValue(String)</span>
959      */
960     public final RecordedThread getThread(String name) {
961         return getTypedValue(name, &quot;java.lang.Thread&quot;);
962     }
963 
964     /**
965      * Returns a textual representation of this object.
966      *
967      * @return textual description of this object
968      */
969     @Override
970     final public String toString() {
971         StringWriter s = new StringWriter();
972         PrettyWriter p = new PrettyWriter(new PrintWriter(s));
973         p.setStackDepth(5);
974         if (this instanceof RecordedEvent) {
975             p.print((RecordedEvent) this);
976         } else {
977             p.print(this, &quot;&quot;);
978         }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../jdk.jdwp.agent/share/native/libjdwp/log_messages.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../internal/dcmd/DCmdConfigure.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
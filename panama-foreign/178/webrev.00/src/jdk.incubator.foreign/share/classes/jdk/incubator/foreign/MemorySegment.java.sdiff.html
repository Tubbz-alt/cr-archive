<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/jdk/java/foreign/TestArrays.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
339      * (see {@link ByteBuffer#isReadOnly()}. Additionally, if this is a native memory segment, the resulting buffer is
340      * &lt;em&gt;direct&lt;/em&gt; (see {@link ByteBuffer#isDirect()}).
341      * &lt;p&gt;
342      * The life-cycle of the returned buffer will be tied to that of this segment. That means that if the this segment
343      * is closed (see {@link MemorySegment#close()}, accessing the returned
344      * buffer will throw an {@link IllegalStateException}.
345      * &lt;p&gt;
346      * The resulting buffer&#39;s byte order is {@link java.nio.ByteOrder#BIG_ENDIAN}; this can be changed using
347      * {@link ByteBuffer#order(java.nio.ByteOrder)}.
348      *
349      * @return a {@link ByteBuffer} view of this memory segment.
350      * @throws UnsupportedOperationException if this segment cannot be mapped onto a {@link ByteBuffer} instance,
351      * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater
352      * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link #READ} access mode.
353      */
354     ByteBuffer asByteBuffer();
355 
356     /**
357      * Copy the contents of this memory segment into a fresh byte array.
358      * @return a fresh byte array copy of this memory segment.
<span class="line-modified">359      * @throws UnsupportedOperationException if this segment&#39;s contents cannot be copied into a {@link byte[]} instance,</span>
<span class="line-modified">360      * e.g. its size is greater than {@link Integer#MAX_VALUE}.</span>
361      * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the
362      * thread owning this segment.
363      */
364     byte[] toByteArray();
365 
366     /**
367      * Creates a new buffer memory segment that models the memory associated with the given byte
368      * buffer. The segment starts relative to the buffer&#39;s position (inclusive)
369      * and ends relative to the buffer&#39;s limit (exclusive).
370      * &lt;p&gt;
371      * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
372      * for the life-time of the segment.
373      *
374      * @param bb the byte buffer backing the buffer memory segment.
375      * @return a new buffer memory segment.
376      */
377     static MemorySegment ofByteBuffer(ByteBuffer bb) {
378         return AbstractMemorySegmentImpl.ofBuffer(bb);
379     }
380 
</pre>
</td>
<td>
<hr />
<pre>
339      * (see {@link ByteBuffer#isReadOnly()}. Additionally, if this is a native memory segment, the resulting buffer is
340      * &lt;em&gt;direct&lt;/em&gt; (see {@link ByteBuffer#isDirect()}).
341      * &lt;p&gt;
342      * The life-cycle of the returned buffer will be tied to that of this segment. That means that if the this segment
343      * is closed (see {@link MemorySegment#close()}, accessing the returned
344      * buffer will throw an {@link IllegalStateException}.
345      * &lt;p&gt;
346      * The resulting buffer&#39;s byte order is {@link java.nio.ByteOrder#BIG_ENDIAN}; this can be changed using
347      * {@link ByteBuffer#order(java.nio.ByteOrder)}.
348      *
349      * @return a {@link ByteBuffer} view of this memory segment.
350      * @throws UnsupportedOperationException if this segment cannot be mapped onto a {@link ByteBuffer} instance,
351      * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater
352      * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link #READ} access mode.
353      */
354     ByteBuffer asByteBuffer();
355 
356     /**
357      * Copy the contents of this memory segment into a fresh byte array.
358      * @return a fresh byte array copy of this memory segment.
<span class="line-modified">359      * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this</span>
<span class="line-modified">360      * segment&#39;s contents cannot be copied into a {@link byte[]} instance, e.g. its size is greater than {@link Integer#MAX_VALUE},</span>
361      * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the
362      * thread owning this segment.
363      */
364     byte[] toByteArray();
365 
366     /**
367      * Creates a new buffer memory segment that models the memory associated with the given byte
368      * buffer. The segment starts relative to the buffer&#39;s position (inclusive)
369      * and ends relative to the buffer&#39;s limit (exclusive).
370      * &lt;p&gt;
371      * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
372      * for the life-time of the segment.
373      *
374      * @param bb the byte buffer backing the buffer memory segment.
375      * @return a new buffer memory segment.
376      */
377     static MemorySegment ofByteBuffer(ByteBuffer bb) {
378         return AbstractMemorySegmentImpl.ofBuffer(bb);
379     }
380 
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/jdk/java/foreign/TestArrays.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
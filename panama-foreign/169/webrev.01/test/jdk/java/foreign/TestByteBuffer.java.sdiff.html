<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/TestByteBuffer.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestMemoryCopy.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/TestByteBuffer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
412         }
413         ByteBuffer byteBuffer = leaked.asByteBuffer(); // ok
414         byteBuffer.get(); // should throw
415     }
416 
417     @Test(expectedExceptions = { UnsupportedOperationException.class,
418                                  IllegalArgumentException.class })
419     public void testTooBigForByteBuffer() {
420         try (MemorySegment segment = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L)) {
421             segment.asByteBuffer();
422         }
423     }
424 
425     @Test(dataProvider=&quot;resizeOps&quot;)
426     public void testCopyHeapToNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
427         checkByteArrayAlignment(seq.elementLayout());
428         int bytes = (int)seq.byteSize();
429         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
430              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
431             initializer.accept(heapArray.baseAddress());
<span class="line-modified">432             MemoryAddress.copy(heapArray.baseAddress(), nativeArray.baseAddress(), bytes);</span>
433             checker.accept(nativeArray.baseAddress());
434         }
435     }
436 
437     @Test(dataProvider=&quot;resizeOps&quot;)
438     public void testCopyNativeToHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
439         checkByteArrayAlignment(seq.elementLayout());
440         int bytes = (int)seq.byteSize();
441         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
442              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
443             initializer.accept(nativeArray.baseAddress());
<span class="line-modified">444             MemoryAddress.copy(nativeArray.baseAddress(), heapArray.baseAddress(), bytes);</span>
445             checker.accept(heapArray.baseAddress());
446         }
447     }
448 
449     @Test(dataProvider=&quot;bufferSources&quot;)
450     public void testBufferToSegment(ByteBuffer bb, Predicate&lt;MemorySegment&gt; segmentChecker) {
451         MemorySegment segment = MemorySegment.ofByteBuffer(bb);
452         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
453         assertTrue(segmentChecker.test(segment));
454         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
455         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
456         assertEquals(bb.capacity(), segment.byteSize());
457         //another round trip
458         segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());
459         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
460         assertTrue(segmentChecker.test(segment));
461         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
462         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
463         assertEquals(bb.capacity(), segment.byteSize());
464     }
</pre>
</td>
<td>
<hr />
<pre>
412         }
413         ByteBuffer byteBuffer = leaked.asByteBuffer(); // ok
414         byteBuffer.get(); // should throw
415     }
416 
417     @Test(expectedExceptions = { UnsupportedOperationException.class,
418                                  IllegalArgumentException.class })
419     public void testTooBigForByteBuffer() {
420         try (MemorySegment segment = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L)) {
421             segment.asByteBuffer();
422         }
423     }
424 
425     @Test(dataProvider=&quot;resizeOps&quot;)
426     public void testCopyHeapToNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
427         checkByteArrayAlignment(seq.elementLayout());
428         int bytes = (int)seq.byteSize();
429         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
430              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
431             initializer.accept(heapArray.baseAddress());
<span class="line-modified">432             nativeArray.copyFrom(heapArray);</span>
433             checker.accept(nativeArray.baseAddress());
434         }
435     }
436 
437     @Test(dataProvider=&quot;resizeOps&quot;)
438     public void testCopyNativeToHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
439         checkByteArrayAlignment(seq.elementLayout());
440         int bytes = (int)seq.byteSize();
441         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
442              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
443             initializer.accept(nativeArray.baseAddress());
<span class="line-modified">444             heapArray.copyFrom(nativeArray);</span>
445             checker.accept(heapArray.baseAddress());
446         }
447     }
448 
449     @Test(dataProvider=&quot;bufferSources&quot;)
450     public void testBufferToSegment(ByteBuffer bb, Predicate&lt;MemorySegment&gt; segmentChecker) {
451         MemorySegment segment = MemorySegment.ofByteBuffer(bb);
452         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
453         assertTrue(segmentChecker.test(segment));
454         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
455         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
456         assertEquals(bb.capacity(), segment.byteSize());
457         //another round trip
458         segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());
459         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
460         assertTrue(segmentChecker.test(segment));
461         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
462         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
463         assertEquals(bb.capacity(), segment.byteSize());
464     }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestMemoryCopy.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
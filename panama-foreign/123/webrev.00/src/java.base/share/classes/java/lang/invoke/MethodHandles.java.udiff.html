<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleImpl.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarHandles.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -4071,11 +4071,11 @@</span>
              }
              return ~zeroPos;
          }
      }
  
<span class="udiff-line-modified-removed">-     private static boolean permuteArgumentChecks(int[] reorder, MethodType newType, MethodType oldType) {</span>
<span class="udiff-line-modified-added">+     static boolean permuteArgumentChecks(int[] reorder, MethodType newType, MethodType oldType) {</span>
          if (newType.returnType() != oldType.returnType())
              throw newIllegalArgumentException(&quot;return types do not match&quot;,
                      oldType, newType);
          if (reorder.length == oldType.parameterCount()) {
              int limit = newType.parameterCount();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4936,414 +4936,10 @@</span>
                  ? (rtype != void.class)
                  : (rtype != filterType.parameterType(0) || filterValues != 1))
              throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
      }
  
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Adapts a target var handle by pre-processing incoming and outgoing values using a pair of unary filter functions.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var handle, the incoming value (of type {@code T}, where</span>
<span class="udiff-line-removed">-      * {@code T} is the parameter type of the first filter function) is processed using the first filter and then passed</span>
<span class="udiff-line-removed">-      * to the target var handle.</span>
<span class="udiff-line-removed">-      * Conversely, when calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the return value obtained from</span>
<span class="udiff-line-removed">-      * the target var handle (of type {@code T}, where {@code T} is the parameter type of the second filter function)</span>
<span class="udiff-line-removed">-      * is processed using the second filter and returned to the caller. More advanced access mode types, such as</span>
<span class="udiff-line-removed">-      * {@link java.lang.invoke.VarHandle.AccessMode#COMPARE_AND_EXCHANGE} might apply both filters at the same time.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * For the boxing and unboxing filters to be well formed, their types must be of the form {@code S -&gt; T} and {@code T -&gt; S},</span>
<span class="udiff-line-removed">-      * respectively, where {@code T} is the type of the target var handle. If this is the case, the resulting var handle will</span>
<span class="udiff-line-removed">-      * have type {@code S}.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and</span>
<span class="udiff-line-removed">-      * atomic access guarantees as those featured by the target var handle.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param target the target var handle</span>
<span class="udiff-line-removed">-      * @param filterToTarget a filter to convert some type {@code S} into the type of {@code target}</span>
<span class="udiff-line-removed">-      * @param filterFromTarget a filter to convert the type of {@code target} to some type {@code S}</span>
<span class="udiff-line-removed">-      * @return an adapter var handle which accepts a new type, performing the provided boxing/unboxing conversions.</span>
<span class="udiff-line-removed">-      * @throws NullPointerException if either {@code target}, {@code filterToTarget} or {@code filterFromTarget} are {@code == null}.</span>
<span class="udiff-line-removed">-      * @throws IllegalArgumentException if {@code filterFromTarget} and {@code filterToTarget} are not well-formed, that is, they have types</span>
<span class="udiff-line-removed">-      * other than {@code S -&gt; T} and {@code T -&gt; S}, respectively, where {@code T} is the type of the target var handle,</span>
<span class="udiff-line-removed">-      * or if either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {</span>
<span class="udiff-line-removed">-         Objects.nonNull(target);</span>
<span class="udiff-line-removed">-         Objects.nonNull(filterToTarget);</span>
<span class="udiff-line-removed">-         Objects.nonNull(filterFromTarget);</span>
<span class="udiff-line-removed">-         //check that from/to filters do not throw checked exceptions</span>
<span class="udiff-line-removed">-         noCheckedExceptions(filterToTarget);</span>
<span class="udiff-line-removed">-         noCheckedExceptions(filterFromTarget);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         //check that from/to filters have right signatures</span>
<span class="udiff-line-removed">-         if (filterFromTarget.type().parameterCount() != 1) {</span>
<span class="udiff-line-removed">-             throw newIllegalArgumentException(&quot;filterFromTarget filter type has wrong arity&quot;, filterFromTarget.type());</span>
<span class="udiff-line-removed">-         } else if (filterToTarget.type().parameterCount() != 1) {</span>
<span class="udiff-line-removed">-             throw newIllegalArgumentException(&quot;filterToTarget filter type has wrong arity&quot;, filterFromTarget.type());</span>
<span class="udiff-line-removed">-         } else if (filterFromTarget.type().parameterType(0) != filterToTarget.type().returnType() ||</span>
<span class="udiff-line-removed">-                 filterToTarget.type().parameterType(0) != filterFromTarget.type().returnType()) {</span>
<span class="udiff-line-removed">-             throw newIllegalArgumentException(&quot;filterFromTarget and filterToTarget filter types do not match&quot;, filterFromTarget.type(), filterToTarget.type());</span>
<span class="udiff-line-removed">-         } else if (target.varType() != filterFromTarget.type().parameterType(0)) {</span>
<span class="udiff-line-removed">-             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterFromTarget.type(), target.varType());</span>
<span class="udiff-line-removed">-         } else if (target.varType() != filterToTarget.type().returnType()) {</span>
<span class="udiff-line-removed">-             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterToTarget.type(), target.varType());</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         return new IndirectVarHandle(target, filterFromTarget.type().returnType(), target.coordinateTypes().toArray(new Class&lt;?&gt;[0]),</span>
<span class="udiff-line-removed">-                 (mode, modeHandle) -&gt; {</span>
<span class="udiff-line-removed">-                     int lastParameterPos = modeHandle.type().parameterCount() - 1;</span>
<span class="udiff-line-removed">-                     return switch (mode.at) {</span>
<span class="udiff-line-removed">-                         case GET -&gt; MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="udiff-line-removed">-                         case SET -&gt; MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);</span>
<span class="udiff-line-removed">-                         case GET_AND_UPDATE -&gt; {</span>
<span class="udiff-line-removed">-                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="udiff-line-removed">-                             yield MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         case COMPARE_AND_EXCHANGE -&gt; {</span>
<span class="udiff-line-removed">-                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="udiff-line-removed">-                             adapter = MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);</span>
<span class="udiff-line-removed">-                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         case COMPARE_AND_SET -&gt; {</span>
<span class="udiff-line-removed">-                             MethodHandle adapter = MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);</span>
<span class="udiff-line-removed">-                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     };</span>
<span class="udiff-line-removed">-                 });</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Adapts a target var handle by pre-processing incoming coordinate values using unary filter functions.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * When calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the incoming coordinate values</span>
<span class="udiff-line-removed">-      * starting at position {@code pos} (of type {@code C1, C2 ... Cn}, where {@code C1, C2 ... Cn} are the return type</span>
<span class="udiff-line-removed">-      * of the unary filter functions) are transformed into new values (of type {@code S1, S2 ... Sn}, where {@code S1, S2 ... Sn} are the</span>
<span class="udiff-line-removed">-      * parameter types of the unary filter functions), and then passed (along with any coordinate that was left unaltered</span>
<span class="udiff-line-removed">-      * by the adaptation) to the target var handle.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * For the coordinate filters to be well formed, their types must be of the form {@code S1 -&gt; T1, S2 -&gt; T1 ... Sn -&gt; Tn},</span>
<span class="udiff-line-removed">-      * where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos} of the target var handle.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and</span>
<span class="udiff-line-removed">-      * atomic access guarantees as those featured by the target var handle.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param target the target var handle</span>
<span class="udiff-line-removed">-      * @param pos the position of the first coordinate to be transformed</span>
<span class="udiff-line-removed">-      * @param filters the unary functions which are used to transform coordinates starting at position {@code pos}</span>
<span class="udiff-line-removed">-      * @return an adapter var handle which accepts new coordinate types, applying the provided transformation</span>
<span class="udiff-line-removed">-      * to the new coordinate values.</span>
<span class="udiff-line-removed">-      * @throws NullPointerException if either {@code target}, {@code filters} are {@code == null}.</span>
<span class="udiff-line-removed">-      * @throws IllegalArgumentException if the handles in {@code filters} are not well-formed, that is, they have types</span>
<span class="udiff-line-removed">-      * other than {@code S1 -&gt; T1, S2 -&gt; T2, ... Sn -&gt; Tn} where {@code T1, T2 ... Tn} are the coordinate types starting</span>
<span class="udiff-line-removed">-      * at position {@code pos} of the target var handle, if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,</span>
<span class="udiff-line-removed">-      * or if more filters are provided than the actual number of coordinate types, or if any of the filters throws any</span>
<span class="udiff-line-removed">-      * checked exceptions.</span>
<span class="udiff-line-removed">-      * available starting at {@code pos}.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {</span>
<span class="udiff-line-removed">-         Objects.nonNull(target);</span>
<span class="udiff-line-removed">-         Objects.nonNull(filters);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="udiff-line-removed">-         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="udiff-line-removed">-             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="udiff-line-removed">-         } else if (pos + filters.length &gt; targetCoordinates.size()) {</span>
<span class="udiff-line-removed">-             throw new IllegalArgumentException(&quot;Too many filters&quot;);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (filters.length == 0) return target;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="udiff-line-removed">-         for (int i = 0 ; i &lt; filters.length ; i++) {</span>
<span class="udiff-line-removed">-             noCheckedExceptions(filters[i]);</span>
<span class="udiff-line-removed">-             MethodType filterType = filters[i].type();</span>
<span class="udiff-line-removed">-             if (filterType.parameterCount() != 1) {</span>
<span class="udiff-line-removed">-                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType);</span>
<span class="udiff-line-removed">-             } else if (newCoordinates.get(pos + i) != filterType.returnType()) {</span>
<span class="udiff-line-removed">-                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType + &quot; for coordinate type &quot; + newCoordinates.get(i));</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             newCoordinates.set(pos + i, filters[i].type().parameterType(0));</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="udiff-line-removed">-                 (mode, modeHandle) -&gt; MethodHandles.filterArguments(modeHandle, 1 + pos, filters));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Provides a target var handle with one or more &lt;em&gt;bound coordinates&lt;/em&gt;</span>
<span class="udiff-line-removed">-      * in advance of the var handle&#39;s invocation. As a consequence, the resulting var handle will feature less</span>
<span class="udiff-line-removed">-      * coordinate types than the target var handle.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * When calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, incoming coordinate values</span>
<span class="udiff-line-removed">-      * are joined with bound coordinate values, and then passed to the target var handle.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * For the bound coordinates to be well formed, their types must be {@code T1, T2 ... Tn },</span>
<span class="udiff-line-removed">-      * where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos} of the target var handle.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and</span>
<span class="udiff-line-removed">-      * atomic access guarantees as those featured by the target var handle.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param target the var handle to invoke after the bound coordinates are inserted</span>
<span class="udiff-line-removed">-      * @param pos the position of the first coordinate to be inserted</span>
<span class="udiff-line-removed">-      * @param values the series of bound coordinates to insert</span>
<span class="udiff-line-removed">-      * @return an adapter var handle which inserts an additional coordinates,</span>
<span class="udiff-line-removed">-      *         before calling the target var handle</span>
<span class="udiff-line-removed">-      * @throws NullPointerException if either {@code target}, {@code values} are {@code == null}.</span>
<span class="udiff-line-removed">-      * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,</span>
<span class="udiff-line-removed">-      * or if more values are provided than the actual number of coordinate types available starting at {@code pos}.</span>
<span class="udiff-line-removed">-      * @throws ClassCastException if the bound coordinates in {@code values} are not well-formed, that is, they have types</span>
<span class="udiff-line-removed">-      * other than {@code T1, T2 ... Tn }, where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos}</span>
<span class="udiff-line-removed">-      * of the target var handle.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {</span>
<span class="udiff-line-removed">-         Objects.nonNull(target);</span>
<span class="udiff-line-removed">-         Objects.nonNull(values);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="udiff-line-removed">-         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="udiff-line-removed">-             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="udiff-line-removed">-         } else if (pos + values.length &gt; targetCoordinates.size()) {</span>
<span class="udiff-line-removed">-             throw new IllegalArgumentException(&quot;Too many values&quot;);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (values.length == 0) return target;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="udiff-line-removed">-         for (int i = 0 ; i &lt; values.length ; i++) {</span>
<span class="udiff-line-removed">-             Class&lt;?&gt; pt = newCoordinates.get(pos);</span>
<span class="udiff-line-removed">-             if (pt.isPrimitive()) {</span>
<span class="udiff-line-removed">-                 Wrapper w = Wrapper.forPrimitiveType(pt);</span>
<span class="udiff-line-removed">-                 w.convert(values[i], pt);</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 pt.cast(values[i]);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             newCoordinates.remove(pos);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="udiff-line-removed">-                 (mode, modeHandle) -&gt; MethodHandles.insertArguments(modeHandle, 1 + pos, values));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Provides a var handle which adapts the coordinate values of the target var handle, by re-arranging them</span>
<span class="udiff-line-removed">-      * so that the new coordinates match the provided ones.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * The given array controls the reordering.</span>
<span class="udiff-line-removed">-      * Call {@code #I} the number of incoming coordinates (the value</span>
<span class="udiff-line-removed">-      * {@code newCoordinates.size()}, and call {@code #O} the number</span>
<span class="udiff-line-removed">-      * of outgoing coordinates (the number of coordinates associated with the target var handle).</span>
<span class="udiff-line-removed">-      * Then the length of the reordering array must be {@code #O},</span>
<span class="udiff-line-removed">-      * and each element must be a non-negative number less than {@code #I}.</span>
<span class="udiff-line-removed">-      * For every {@code N} less than {@code #O}, the {@code N}-th</span>
<span class="udiff-line-removed">-      * outgoing coordinate will be taken from the {@code I}-th incoming</span>
<span class="udiff-line-removed">-      * coordinate, where {@code I} is {@code reorder[N]}.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * No coordinate value conversions are applied.</span>
<span class="udiff-line-removed">-      * The type of each incoming coordinate, as determined by {@code newCoordinates},</span>
<span class="udiff-line-removed">-      * must be identical to the type of the corresponding outgoing coordinate</span>
<span class="udiff-line-removed">-      * in the target var handle.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * The reordering array need not specify an actual permutation.</span>
<span class="udiff-line-removed">-      * An incoming coordinate will be duplicated if its index appears</span>
<span class="udiff-line-removed">-      * more than once in the array, and an incoming coordinate will be dropped</span>
<span class="udiff-line-removed">-      * if its index does not appear in the array.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and</span>
<span class="udiff-line-removed">-      * atomic access guarantees as those featured by the target var handle.</span>
<span class="udiff-line-removed">-      * @param target the var handle to invoke after the coordinates have been reordered</span>
<span class="udiff-line-removed">-      * @param newCoordinates the new coordinate types</span>
<span class="udiff-line-removed">-      * @param reorder an index array which controls the reordering</span>
<span class="udiff-line-removed">-      * @return an adapter var handle which re-arranges the incoming coordinate values,</span>
<span class="udiff-line-removed">-      * before calling the target var handle</span>
<span class="udiff-line-removed">-      * @throws NullPointerException if either {@code target}, {@code newCoordinates} or {@code reorder} are {@code == null}.</span>
<span class="udiff-line-removed">-      * @throws IllegalArgumentException if the index array length is not equal to</span>
<span class="udiff-line-removed">-      * the number of coordinates of the target var handle, or if any index array element is not a valid index for</span>
<span class="udiff-line-removed">-      * a coordinate of {@code newCoordinates}, or if two corresponding coordinate types in</span>
<span class="udiff-line-removed">-      * the target var handle and in {@code newCoordinates} are not identical.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     public static VarHandle permuteCoordinates(VarHandle target, List&lt;Class&lt;?&gt;&gt; newCoordinates, int... reorder) {</span>
<span class="udiff-line-removed">-         Objects.nonNull(target);</span>
<span class="udiff-line-removed">-         Objects.nonNull(newCoordinates);</span>
<span class="udiff-line-removed">-         Objects.nonNull(reorder);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="udiff-line-removed">-         permuteArgumentChecks(reorder,</span>
<span class="udiff-line-removed">-                 MethodType.methodType(void.class, newCoordinates),</span>
<span class="udiff-line-removed">-                 MethodType.methodType(void.class, targetCoordinates));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="udiff-line-removed">-                 (mode, modeHandle) -&gt;</span>
<span class="udiff-line-removed">-                     MethodHandles.permuteArguments(modeHandle,</span>
<span class="udiff-line-removed">-                         methodTypeFor(mode.at, modeHandle.type(), targetCoordinates, newCoordinates),</span>
<span class="udiff-line-removed">-                         reorderArrayFor(mode.at, newCoordinates, reorder)));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     private static int numTrailingArgs(VarHandle.AccessType at) {</span>
<span class="udiff-line-removed">-         return switch (at) {</span>
<span class="udiff-line-removed">-             case GET -&gt; 0;</span>
<span class="udiff-line-removed">-             case GET_AND_UPDATE, SET -&gt; 1;</span>
<span class="udiff-line-removed">-             case COMPARE_AND_SET, COMPARE_AND_EXCHANGE -&gt; 2;</span>
<span class="udiff-line-removed">-         };</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     private static int[] reorderArrayFor(VarHandle.AccessType at, List&lt;Class&lt;?&gt;&gt; newCoordinates, int[] reorder) {</span>
<span class="udiff-line-removed">-         int numTrailingArgs = numTrailingArgs(at);</span>
<span class="udiff-line-removed">-         int[] adjustedReorder = new int[reorder.length + 1 + numTrailingArgs];</span>
<span class="udiff-line-removed">-         adjustedReorder[0] = 0;</span>
<span class="udiff-line-removed">-         for (int i = 0 ; i &lt; reorder.length ; i++) {</span>
<span class="udiff-line-removed">-             adjustedReorder[i + 1] = reorder[i] + 1;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {</span>
<span class="udiff-line-removed">-             adjustedReorder[i + reorder.length + 1] = i + newCoordinates.size() + 1;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return adjustedReorder;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     private static MethodType methodTypeFor(VarHandle.AccessType at, MethodType oldType, List&lt;Class&lt;?&gt;&gt; oldCoordinates, List&lt;Class&lt;?&gt;&gt; newCoordinates) {</span>
<span class="udiff-line-removed">-         int numTrailingArgs = numTrailingArgs(at);</span>
<span class="udiff-line-removed">-         MethodType adjustedType = MethodType.methodType(oldType.returnType(), oldType.parameterType(0));</span>
<span class="udiff-line-removed">-         adjustedType = adjustedType.appendParameterTypes(newCoordinates);</span>
<span class="udiff-line-removed">-         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {</span>
<span class="udiff-line-removed">-             adjustedType = adjustedType.appendParameterTypes(oldType.parameterType(1 + oldCoordinates.size() + i));</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return adjustedType;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Adapts a target var handle handle by pre-processing</span>
<span class="udiff-line-removed">-      * a sub-sequence of its coordinate values with a filter (a method handle).</span>
<span class="udiff-line-removed">-      * The pre-processed coordinates are replaced by the result (if any) of the</span>
<span class="udiff-line-removed">-      * filter function and the target var handle is then called on the modified (usually shortened)</span>
<span class="udiff-line-removed">-      * coordinate list.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * If {code R} is the return type of the filter (which cannot be void), the target var handle must accept a value of</span>
<span class="udiff-line-removed">-      * type {@code R} as its coordinate in position {@code pos}, preceded and/or followed by</span>
<span class="udiff-line-removed">-      * any coordinate not passed to the filter.</span>
<span class="udiff-line-removed">-      * No coordinates are reordered, and the result returned from the filter</span>
<span class="udiff-line-removed">-      * replaces (in order) the whole subsequence of coordinates originally</span>
<span class="udiff-line-removed">-      * passed to the adapter.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * The argument types (if any) of the filter</span>
<span class="udiff-line-removed">-      * replace zero or one coordinate types of the target var handle, at position {@code pos},</span>
<span class="udiff-line-removed">-      * in the resulting adapted var handle.</span>
<span class="udiff-line-removed">-      * The return type of the filter must be identical to the</span>
<span class="udiff-line-removed">-      * coordinate type of the target var handle at position {@code pos}, and that target var handle</span>
<span class="udiff-line-removed">-      * coordinate is supplied by the return value of the filter.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and</span>
<span class="udiff-line-removed">-      * atomic access guarantees as those featured by the target var handle.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param target the var handle to invoke after the coordinates have been filtered</span>
<span class="udiff-line-removed">-      * @param pos the position of the coordinate to be filtered</span>
<span class="udiff-line-removed">-      * @param filter the filter method handle</span>
<span class="udiff-line-removed">-      * @return an adapter var handle which filters the incoming coordinate values,</span>
<span class="udiff-line-removed">-      * before calling the target var handle</span>
<span class="udiff-line-removed">-      * @throws NullPointerException if either {@code target}, {@code filter} are {@code == null}.</span>
<span class="udiff-line-removed">-      * @throws IllegalArgumentException if the return type of {@code filter}</span>
<span class="udiff-line-removed">-      * is void, or it is not the same as the {@code pos} coordinate of the target var handle,</span>
<span class="udiff-line-removed">-      * if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,</span>
<span class="udiff-line-removed">-      * if the resulting var handle&#39;s type would have &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many coordinates&lt;/a&gt;,</span>
<span class="udiff-line-removed">-      * or if {@code filter} throws any checked exceptions.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {</span>
<span class="udiff-line-removed">-         Objects.nonNull(target);</span>
<span class="udiff-line-removed">-         Objects.nonNull(filter);</span>
<span class="udiff-line-removed">-         noCheckedExceptions(filter);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="udiff-line-removed">-         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="udiff-line-removed">-             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="udiff-line-removed">-         } else if (filter.type().returnType() == void.class) {</span>
<span class="udiff-line-removed">-             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; ; filter cannot be void&quot;);</span>
<span class="udiff-line-removed">-         } else if (filter.type().returnType() != targetCoordinates.get(pos)) {</span>
<span class="udiff-line-removed">-             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; for coordinate type &quot; + targetCoordinates.get(pos));</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="udiff-line-removed">-         newCoordinates.remove(pos);</span>
<span class="udiff-line-removed">-         newCoordinates.addAll(pos, filter.type().parameterList());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="udiff-line-removed">-                 (mode, modeHandle) -&gt; MethodHandles.collectArguments(modeHandle, 1 + pos, filter));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Returns a var handle which will discard some dummy coordinates before delegating to the</span>
<span class="udiff-line-removed">-      * target var handle. As a consequence, the resulting var handle will feature more</span>
<span class="udiff-line-removed">-      * coordinate types than the target var handle.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * The {@code pos} argument may range between zero and &lt;i&gt;N&lt;/i&gt;, where &lt;i&gt;N&lt;/i&gt; is the arity of the</span>
<span class="udiff-line-removed">-      * target var handle&#39;s coordinate types. If {@code pos} is zero, the dummy coordinates will precede</span>
<span class="udiff-line-removed">-      * the target&#39;s real arguments; if {@code pos} is &lt;i&gt;N&lt;/i&gt; they will come after.</span>
<span class="udiff-line-removed">-      * &lt;p&gt;</span>
<span class="udiff-line-removed">-      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and</span>
<span class="udiff-line-removed">-      * atomic access guarantees as those featured by the target var handle.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param target the var handle to invoke after the dummy coordinates are dropped</span>
<span class="udiff-line-removed">-      * @param pos position of first coordinate to drop (zero for the leftmost)</span>
<span class="udiff-line-removed">-      * @param valueTypes the type(s) of the coordinate(s) to drop</span>
<span class="udiff-line-removed">-      * @return an adapter var handle which drops some dummy coordinates,</span>
<span class="udiff-line-removed">-      *         before calling the target var handle</span>
<span class="udiff-line-removed">-      * @throws NullPointerException if either {@code target}, {@code valueTypes} are {@code == null}.</span>
<span class="udiff-line-removed">-      * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     public static VarHandle dropCoordinates(VarHandle target, int pos, Class&lt;?&gt;... valueTypes) {</span>
<span class="udiff-line-removed">-         Objects.nonNull(target);</span>
<span class="udiff-line-removed">-         Objects.nonNull(valueTypes);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="udiff-line-removed">-         if (pos &lt; 0 || pos &gt; targetCoordinates.size()) {</span>
<span class="udiff-line-removed">-             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (valueTypes.length == 0) return target;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="udiff-line-removed">-         newCoordinates.addAll(pos, List.of(valueTypes));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="udiff-line-removed">-                 (mode, modeHandle) -&gt; MethodHandles.dropArguments(modeHandle, 1 + pos, valueTypes));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     private static void noCheckedExceptions(MethodHandle handle) {</span>
<span class="udiff-line-removed">-         if (handle instanceof DirectMethodHandle) {</span>
<span class="udiff-line-removed">-             DirectMethodHandle directHandle = (DirectMethodHandle)handle;</span>
<span class="udiff-line-removed">-             MethodHandleInfo info = Lookup.IMPL_LOOKUP.revealDirect(directHandle);</span>
<span class="udiff-line-removed">-             Class&lt;?&gt;[] exceptionTypes = switch (info.getReferenceKind()) {</span>
<span class="udiff-line-removed">-                 case MethodHandleInfo.REF_invokeInterface, MethodHandleInfo.REF_invokeSpecial,</span>
<span class="udiff-line-removed">-                      MethodHandleInfo.REF_invokeStatic, MethodHandleInfo.REF_invokeVirtual -&gt;</span>
<span class="udiff-line-removed">-                         info.reflectAs(Method.class, Lookup.IMPL_LOOKUP).getExceptionTypes();</span>
<span class="udiff-line-removed">-                 case MethodHandleInfo.REF_newInvokeSpecial -&gt;</span>
<span class="udiff-line-removed">-                         info.reflectAs(Constructor.class, Lookup.IMPL_LOOKUP).getExceptionTypes();</span>
<span class="udiff-line-removed">-                 case MethodHandleInfo.REF_getField, MethodHandleInfo.REF_getStatic,</span>
<span class="udiff-line-removed">-                      MethodHandleInfo.REF_putField, MethodHandleInfo.REF_putStatic -&gt; null;</span>
<span class="udiff-line-removed">-                 default -&gt; throw new AssertionError(&quot;Cannot get here&quot;);</span>
<span class="udiff-line-removed">-             };</span>
<span class="udiff-line-removed">-             if (exceptionTypes != null) {</span>
<span class="udiff-line-removed">-                 if (Stream.of(exceptionTypes).anyMatch(MethodHandles::isCheckedException)) {</span>
<span class="udiff-line-removed">-                     throw newIllegalArgumentException(&quot;Cannot adapt a var handle with a method handle which throws checked exceptions&quot;);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         } else if (handle instanceof DelegatingMethodHandle) {</span>
<span class="udiff-line-removed">-             noCheckedExceptions(((DelegatingMethodHandle)handle).getTarget());</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-             //bound</span>
<span class="udiff-line-removed">-             BoundMethodHandle boundHandle = (BoundMethodHandle)handle;</span>
<span class="udiff-line-removed">-             for (int i = 0 ; i &lt; boundHandle.fieldCount() ; i++) {</span>
<span class="udiff-line-removed">-                 Object arg = boundHandle.arg(i);</span>
<span class="udiff-line-removed">-                 if (arg instanceof MethodHandle){</span>
<span class="udiff-line-removed">-                     noCheckedExceptions((MethodHandle) arg);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     private static boolean isCheckedException(Class&lt;?&gt; clazz) {</span>
<span class="udiff-line-removed">-         return Throwable.class.isAssignableFrom(clazz) &amp;&amp;</span>
<span class="udiff-line-removed">-                 !RuntimeException.class.isAssignableFrom(clazz) &amp;&amp;</span>
<span class="udiff-line-removed">-                 !Error.class.isAssignableFrom(clazz);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      /**
       * Adapts a target method handle by pre-processing
       * some of its arguments, and then calling the target with
       * the result of the pre-processing, inserted into the original
       * sequence of arguments.
</pre>
<center><a href="MethodHandleImpl.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarHandles.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
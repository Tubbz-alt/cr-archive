diff a/src/java.base/share/classes/java/lang/invoke/MethodHandles.java b/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
@@ -4071,11 +4071,11 @@
             }
             return ~zeroPos;
         }
     }
 
-    private static boolean permuteArgumentChecks(int[] reorder, MethodType newType, MethodType oldType) {
+    static boolean permuteArgumentChecks(int[] reorder, MethodType newType, MethodType oldType) {
         if (newType.returnType() != oldType.returnType())
             throw newIllegalArgumentException("return types do not match",
                     oldType, newType);
         if (reorder.length == oldType.parameterCount()) {
             int limit = newType.parameterCount();
@@ -4936,414 +4936,10 @@
                 ? (rtype != void.class)
                 : (rtype != filterType.parameterType(0) || filterValues != 1))
             throw newIllegalArgumentException("target and filter types do not match", targetType, filterType);
     }
 
-    /**
-     * Adapts a target var handle by pre-processing incoming and outgoing values using a pair of unary filter functions.
-     * <p>
-     * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var handle, the incoming value (of type {@code T}, where
-     * {@code T} is the parameter type of the first filter function) is processed using the first filter and then passed
-     * to the target var handle.
-     * Conversely, when calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the return value obtained from
-     * the target var handle (of type {@code T}, where {@code T} is the parameter type of the second filter function)
-     * is processed using the second filter and returned to the caller. More advanced access mode types, such as
-     * {@link java.lang.invoke.VarHandle.AccessMode#COMPARE_AND_EXCHANGE} might apply both filters at the same time.
-     * <p>
-     * For the boxing and unboxing filters to be well formed, their types must be of the form {@code S -> T} and {@code T -> S},
-     * respectively, where {@code T} is the type of the target var handle. If this is the case, the resulting var handle will
-     * have type {@code S}.
-     * <p>
-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
-     * atomic access guarantees as those featured by the target var handle.
-     *
-     * @param target the target var handle
-     * @param filterToTarget a filter to convert some type {@code S} into the type of {@code target}
-     * @param filterFromTarget a filter to convert the type of {@code target} to some type {@code S}
-     * @return an adapter var handle which accepts a new type, performing the provided boxing/unboxing conversions.
-     * @throws NullPointerException if either {@code target}, {@code filterToTarget} or {@code filterFromTarget} are {@code == null}.
-     * @throws IllegalArgumentException if {@code filterFromTarget} and {@code filterToTarget} are not well-formed, that is, they have types
-     * other than {@code S -> T} and {@code T -> S}, respectively, where {@code T} is the type of the target var handle,
-     * or if either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.
-     */
-    public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {
-        Objects.nonNull(target);
-        Objects.nonNull(filterToTarget);
-        Objects.nonNull(filterFromTarget);
-        //check that from/to filters do not throw checked exceptions
-        noCheckedExceptions(filterToTarget);
-        noCheckedExceptions(filterFromTarget);
-
-        //check that from/to filters have right signatures
-        if (filterFromTarget.type().parameterCount() != 1) {
-            throw newIllegalArgumentException("filterFromTarget filter type has wrong arity", filterFromTarget.type());
-        } else if (filterToTarget.type().parameterCount() != 1) {
-            throw newIllegalArgumentException("filterToTarget filter type has wrong arity", filterFromTarget.type());
-        } else if (filterFromTarget.type().parameterType(0) != filterToTarget.type().returnType() ||
-                filterToTarget.type().parameterType(0) != filterFromTarget.type().returnType()) {
-            throw newIllegalArgumentException("filterFromTarget and filterToTarget filter types do not match", filterFromTarget.type(), filterToTarget.type());
-        } else if (target.varType() != filterFromTarget.type().parameterType(0)) {
-            throw newIllegalArgumentException("filterFromTarget filter type does not match target var handle type", filterFromTarget.type(), target.varType());
-        } else if (target.varType() != filterToTarget.type().returnType()) {
-            throw newIllegalArgumentException("filterFromTarget filter type does not match target var handle type", filterToTarget.type(), target.varType());
-        }
-
-        return new IndirectVarHandle(target, filterFromTarget.type().returnType(), target.coordinateTypes().toArray(new Class<?>[0]),
-                (mode, modeHandle) -> {
-                    int lastParameterPos = modeHandle.type().parameterCount() - 1;
-                    return switch (mode.at) {
-                        case GET -> MethodHandles.filterReturnValue(modeHandle, filterFromTarget);
-                        case SET -> MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);
-                        case GET_AND_UPDATE -> {
-                            MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);
-                            yield MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);
-                        }
-                        case COMPARE_AND_EXCHANGE -> {
-                            MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);
-                            adapter = MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);
-                            yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);
-                        }
-                        case COMPARE_AND_SET -> {
-                            MethodHandle adapter = MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);
-                            yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);
-                        }
-                    };
-                });
-    }
-
-    /**
-     * Adapts a target var handle by pre-processing incoming coordinate values using unary filter functions.
-     * <p>
-     * When calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the incoming coordinate values
-     * starting at position {@code pos} (of type {@code C1, C2 ... Cn}, where {@code C1, C2 ... Cn} are the return type
-     * of the unary filter functions) are transformed into new values (of type {@code S1, S2 ... Sn}, where {@code S1, S2 ... Sn} are the
-     * parameter types of the unary filter functions), and then passed (along with any coordinate that was left unaltered
-     * by the adaptation) to the target var handle.
-     * <p>
-     * For the coordinate filters to be well formed, their types must be of the form {@code S1 -> T1, S2 -> T1 ... Sn -> Tn},
-     * where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos} of the target var handle.
-     * <p>
-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
-     * atomic access guarantees as those featured by the target var handle.
-     *
-     * @param target the target var handle
-     * @param pos the position of the first coordinate to be transformed
-     * @param filters the unary functions which are used to transform coordinates starting at position {@code pos}
-     * @return an adapter var handle which accepts new coordinate types, applying the provided transformation
-     * to the new coordinate values.
-     * @throws NullPointerException if either {@code target}, {@code filters} are {@code == null}.
-     * @throws IllegalArgumentException if the handles in {@code filters} are not well-formed, that is, they have types
-     * other than {@code S1 -> T1, S2 -> T2, ... Sn -> Tn} where {@code T1, T2 ... Tn} are the coordinate types starting
-     * at position {@code pos} of the target var handle, if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,
-     * or if more filters are provided than the actual number of coordinate types, or if any of the filters throws any
-     * checked exceptions.
-     * available starting at {@code pos}.
-     */
-    public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {
-        Objects.nonNull(target);
-        Objects.nonNull(filters);
-
-        List<Class<?>> targetCoordinates = target.coordinateTypes();
-        if (pos < 0 || pos >= targetCoordinates.size()) {
-            throw newIllegalArgumentException("Invalid position " + pos + " for coordinate types", targetCoordinates);
-        } else if (pos + filters.length > targetCoordinates.size()) {
-            throw new IllegalArgumentException("Too many filters");
-        }
-
-        if (filters.length == 0) return target;
-
-        List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
-        for (int i = 0 ; i < filters.length ; i++) {
-            noCheckedExceptions(filters[i]);
-            MethodType filterType = filters[i].type();
-            if (filterType.parameterCount() != 1) {
-                throw newIllegalArgumentException("Invalid filter type " + filterType);
-            } else if (newCoordinates.get(pos + i) != filterType.returnType()) {
-                throw newIllegalArgumentException("Invalid filter type " + filterType + " for coordinate type " + newCoordinates.get(i));
-            }
-            newCoordinates.set(pos + i, filters[i].type().parameterType(0));
-        }
-
-        return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class<?>[0]),
-                (mode, modeHandle) -> MethodHandles.filterArguments(modeHandle, 1 + pos, filters));
-    }
-
-    /**
-     * Provides a target var handle with one or more <em>bound coordinates</em>
-     * in advance of the var handle's invocation. As a consequence, the resulting var handle will feature less
-     * coordinate types than the target var handle.
-     * <p>
-     * When calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, incoming coordinate values
-     * are joined with bound coordinate values, and then passed to the target var handle.
-     * <p>
-     * For the bound coordinates to be well formed, their types must be {@code T1, T2 ... Tn },
-     * where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos} of the target var handle.
-     * <p>
-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
-     * atomic access guarantees as those featured by the target var handle.
-     *
-     * @param target the var handle to invoke after the bound coordinates are inserted
-     * @param pos the position of the first coordinate to be inserted
-     * @param values the series of bound coordinates to insert
-     * @return an adapter var handle which inserts an additional coordinates,
-     *         before calling the target var handle
-     * @throws NullPointerException if either {@code target}, {@code values} are {@code == null}.
-     * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,
-     * or if more values are provided than the actual number of coordinate types available starting at {@code pos}.
-     * @throws ClassCastException if the bound coordinates in {@code values} are not well-formed, that is, they have types
-     * other than {@code T1, T2 ... Tn }, where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos}
-     * of the target var handle.
-     */
-    public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {
-        Objects.nonNull(target);
-        Objects.nonNull(values);
-
-        List<Class<?>> targetCoordinates = target.coordinateTypes();
-        if (pos < 0 || pos >= targetCoordinates.size()) {
-            throw newIllegalArgumentException("Invalid position " + pos + " for coordinate types", targetCoordinates);
-        } else if (pos + values.length > targetCoordinates.size()) {
-            throw new IllegalArgumentException("Too many values");
-        }
-
-        if (values.length == 0) return target;
-
-        List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
-        for (int i = 0 ; i < values.length ; i++) {
-            Class<?> pt = newCoordinates.get(pos);
-            if (pt.isPrimitive()) {
-                Wrapper w = Wrapper.forPrimitiveType(pt);
-                w.convert(values[i], pt);
-            } else {
-                pt.cast(values[i]);
-            }
-            newCoordinates.remove(pos);
-        }
-
-        return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class<?>[0]),
-                (mode, modeHandle) -> MethodHandles.insertArguments(modeHandle, 1 + pos, values));
-    }
-
-    /**
-     * Provides a var handle which adapts the coordinate values of the target var handle, by re-arranging them
-     * so that the new coordinates match the provided ones.
-     * <p>
-     * The given array controls the reordering.
-     * Call {@code #I} the number of incoming coordinates (the value
-     * {@code newCoordinates.size()}, and call {@code #O} the number
-     * of outgoing coordinates (the number of coordinates associated with the target var handle).
-     * Then the length of the reordering array must be {@code #O},
-     * and each element must be a non-negative number less than {@code #I}.
-     * For every {@code N} less than {@code #O}, the {@code N}-th
-     * outgoing coordinate will be taken from the {@code I}-th incoming
-     * coordinate, where {@code I} is {@code reorder[N]}.
-     * <p>
-     * No coordinate value conversions are applied.
-     * The type of each incoming coordinate, as determined by {@code newCoordinates},
-     * must be identical to the type of the corresponding outgoing coordinate
-     * in the target var handle.
-     * <p>
-     * The reordering array need not specify an actual permutation.
-     * An incoming coordinate will be duplicated if its index appears
-     * more than once in the array, and an incoming coordinate will be dropped
-     * if its index does not appear in the array.
-     * <p>
-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
-     * atomic access guarantees as those featured by the target var handle.
-     * @param target the var handle to invoke after the coordinates have been reordered
-     * @param newCoordinates the new coordinate types
-     * @param reorder an index array which controls the reordering
-     * @return an adapter var handle which re-arranges the incoming coordinate values,
-     * before calling the target var handle
-     * @throws NullPointerException if either {@code target}, {@code newCoordinates} or {@code reorder} are {@code == null}.
-     * @throws IllegalArgumentException if the index array length is not equal to
-     * the number of coordinates of the target var handle, or if any index array element is not a valid index for
-     * a coordinate of {@code newCoordinates}, or if two corresponding coordinate types in
-     * the target var handle and in {@code newCoordinates} are not identical.
-     */
-    public static VarHandle permuteCoordinates(VarHandle target, List<Class<?>> newCoordinates, int... reorder) {
-        Objects.nonNull(target);
-        Objects.nonNull(newCoordinates);
-        Objects.nonNull(reorder);
-
-        List<Class<?>> targetCoordinates = target.coordinateTypes();
-        permuteArgumentChecks(reorder,
-                MethodType.methodType(void.class, newCoordinates),
-                MethodType.methodType(void.class, targetCoordinates));
-
-        return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class<?>[0]),
-                (mode, modeHandle) ->
-                    MethodHandles.permuteArguments(modeHandle,
-                        methodTypeFor(mode.at, modeHandle.type(), targetCoordinates, newCoordinates),
-                        reorderArrayFor(mode.at, newCoordinates, reorder)));
-    }
-
-    private static int numTrailingArgs(VarHandle.AccessType at) {
-        return switch (at) {
-            case GET -> 0;
-            case GET_AND_UPDATE, SET -> 1;
-            case COMPARE_AND_SET, COMPARE_AND_EXCHANGE -> 2;
-        };
-    }
-
-    private static int[] reorderArrayFor(VarHandle.AccessType at, List<Class<?>> newCoordinates, int[] reorder) {
-        int numTrailingArgs = numTrailingArgs(at);
-        int[] adjustedReorder = new int[reorder.length + 1 + numTrailingArgs];
-        adjustedReorder[0] = 0;
-        for (int i = 0 ; i < reorder.length ; i++) {
-            adjustedReorder[i + 1] = reorder[i] + 1;
-        }
-        for (int i = 0 ; i < numTrailingArgs ; i++) {
-            adjustedReorder[i + reorder.length + 1] = i + newCoordinates.size() + 1;
-        }
-        return adjustedReorder;
-    }
-
-    private static MethodType methodTypeFor(VarHandle.AccessType at, MethodType oldType, List<Class<?>> oldCoordinates, List<Class<?>> newCoordinates) {
-        int numTrailingArgs = numTrailingArgs(at);
-        MethodType adjustedType = MethodType.methodType(oldType.returnType(), oldType.parameterType(0));
-        adjustedType = adjustedType.appendParameterTypes(newCoordinates);
-        for (int i = 0 ; i < numTrailingArgs ; i++) {
-            adjustedType = adjustedType.appendParameterTypes(oldType.parameterType(1 + oldCoordinates.size() + i));
-        }
-        return adjustedType;
-    }
-
-    /**
-     * Adapts a target var handle handle by pre-processing
-     * a sub-sequence of its coordinate values with a filter (a method handle).
-     * The pre-processed coordinates are replaced by the result (if any) of the
-     * filter function and the target var handle is then called on the modified (usually shortened)
-     * coordinate list.
-     * <p>
-     * If {code R} is the return type of the filter (which cannot be void), the target var handle must accept a value of
-     * type {@code R} as its coordinate in position {@code pos}, preceded and/or followed by
-     * any coordinate not passed to the filter.
-     * No coordinates are reordered, and the result returned from the filter
-     * replaces (in order) the whole subsequence of coordinates originally
-     * passed to the adapter.
-     * <p>
-     * The argument types (if any) of the filter
-     * replace zero or one coordinate types of the target var handle, at position {@code pos},
-     * in the resulting adapted var handle.
-     * The return type of the filter must be identical to the
-     * coordinate type of the target var handle at position {@code pos}, and that target var handle
-     * coordinate is supplied by the return value of the filter.
-     * <p>
-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
-     * atomic access guarantees as those featured by the target var handle.
-     *
-     * @param target the var handle to invoke after the coordinates have been filtered
-     * @param pos the position of the coordinate to be filtered
-     * @param filter the filter method handle
-     * @return an adapter var handle which filters the incoming coordinate values,
-     * before calling the target var handle
-     * @throws NullPointerException if either {@code target}, {@code filter} are {@code == null}.
-     * @throws IllegalArgumentException if the return type of {@code filter}
-     * is void, or it is not the same as the {@code pos} coordinate of the target var handle,
-     * if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,
-     * if the resulting var handle's type would have <a href="MethodHandle.html#maxarity">too many coordinates</a>,
-     * or if {@code filter} throws any checked exceptions.
-     */
-    public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {
-        Objects.nonNull(target);
-        Objects.nonNull(filter);
-        noCheckedExceptions(filter);
-
-        List<Class<?>> targetCoordinates = target.coordinateTypes();
-        if (pos < 0 || pos >= targetCoordinates.size()) {
-            throw newIllegalArgumentException("Invalid position " + pos + " for coordinate types", targetCoordinates);
-        } else if (filter.type().returnType() == void.class) {
-            throw newIllegalArgumentException("Invalid filter type " + filter.type() + " ; filter cannot be void");
-        } else if (filter.type().returnType() != targetCoordinates.get(pos)) {
-            throw newIllegalArgumentException("Invalid filter type " + filter.type() + " for coordinate type " + targetCoordinates.get(pos));
-        }
-
-        List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
-        newCoordinates.remove(pos);
-        newCoordinates.addAll(pos, filter.type().parameterList());
-
-        return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class<?>[0]),
-                (mode, modeHandle) -> MethodHandles.collectArguments(modeHandle, 1 + pos, filter));
-    }
-
-    /**
-     * Returns a var handle which will discard some dummy coordinates before delegating to the
-     * target var handle. As a consequence, the resulting var handle will feature more
-     * coordinate types than the target var handle.
-     * <p>
-     * The {@code pos} argument may range between zero and <i>N</i>, where <i>N</i> is the arity of the
-     * target var handle's coordinate types. If {@code pos} is zero, the dummy coordinates will precede
-     * the target's real arguments; if {@code pos} is <i>N</i> they will come after.
-     * <p>
-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
-     * atomic access guarantees as those featured by the target var handle.
-     *
-     * @param target the var handle to invoke after the dummy coordinates are dropped
-     * @param pos position of first coordinate to drop (zero for the leftmost)
-     * @param valueTypes the type(s) of the coordinate(s) to drop
-     * @return an adapter var handle which drops some dummy coordinates,
-     *         before calling the target var handle
-     * @throws NullPointerException if either {@code target}, {@code valueTypes} are {@code == null}.
-     * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive.
-     */
-    public static VarHandle dropCoordinates(VarHandle target, int pos, Class<?>... valueTypes) {
-        Objects.nonNull(target);
-        Objects.nonNull(valueTypes);
-
-        List<Class<?>> targetCoordinates = target.coordinateTypes();
-        if (pos < 0 || pos > targetCoordinates.size()) {
-            throw newIllegalArgumentException("Invalid position " + pos + " for coordinate types", targetCoordinates);
-        }
-
-        if (valueTypes.length == 0) return target;
-
-        List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
-        newCoordinates.addAll(pos, List.of(valueTypes));
-
-        return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class<?>[0]),
-                (mode, modeHandle) -> MethodHandles.dropArguments(modeHandle, 1 + pos, valueTypes));
-    }
-
-    private static void noCheckedExceptions(MethodHandle handle) {
-        if (handle instanceof DirectMethodHandle) {
-            DirectMethodHandle directHandle = (DirectMethodHandle)handle;
-            MethodHandleInfo info = Lookup.IMPL_LOOKUP.revealDirect(directHandle);
-            Class<?>[] exceptionTypes = switch (info.getReferenceKind()) {
-                case MethodHandleInfo.REF_invokeInterface, MethodHandleInfo.REF_invokeSpecial,
-                     MethodHandleInfo.REF_invokeStatic, MethodHandleInfo.REF_invokeVirtual ->
-                        info.reflectAs(Method.class, Lookup.IMPL_LOOKUP).getExceptionTypes();
-                case MethodHandleInfo.REF_newInvokeSpecial ->
-                        info.reflectAs(Constructor.class, Lookup.IMPL_LOOKUP).getExceptionTypes();
-                case MethodHandleInfo.REF_getField, MethodHandleInfo.REF_getStatic,
-                     MethodHandleInfo.REF_putField, MethodHandleInfo.REF_putStatic -> null;
-                default -> throw new AssertionError("Cannot get here");
-            };
-            if (exceptionTypes != null) {
-                if (Stream.of(exceptionTypes).anyMatch(MethodHandles::isCheckedException)) {
-                    throw newIllegalArgumentException("Cannot adapt a var handle with a method handle which throws checked exceptions");
-                }
-            }
-        } else if (handle instanceof DelegatingMethodHandle) {
-            noCheckedExceptions(((DelegatingMethodHandle)handle).getTarget());
-        } else {
-            //bound
-            BoundMethodHandle boundHandle = (BoundMethodHandle)handle;
-            for (int i = 0 ; i < boundHandle.fieldCount() ; i++) {
-                Object arg = boundHandle.arg(i);
-                if (arg instanceof MethodHandle){
-                    noCheckedExceptions((MethodHandle) arg);
-                }
-            }
-        }
-    }
-
-    private static boolean isCheckedException(Class<?> clazz) {
-        return Throwable.class.isAssignableFrom(clazz) &&
-                !RuntimeException.class.isAssignableFrom(clazz) &&
-                !Error.class.isAssignableFrom(clazz);
-    }
-
     /**
      * Adapts a target method handle by pre-processing
      * some of its arguments, and then calling the target with
      * the result of the pre-processing, inserted into the original
      * sequence of arguments.

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarHandles.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
4056             BitSet mask = new BitSet(newArity);
4057             for (int i = 0; i &lt; reorder.length; i++) {
4058                 int arg = reorder[i];
4059                 if (arg &gt;= newArity) {
4060                     return reorder.length;
4061                 }
4062                 if (mask.get(arg)) {
4063                     return i;  // &gt;0 indicates a dup
4064                 }
4065                 mask.set(arg);
4066             }
4067             int zeroPos = mask.nextClearBit(0);
4068             assert(zeroPos &lt;= newArity);
4069             if (zeroPos == newArity) {
4070                 return 0;
4071             }
4072             return ~zeroPos;
4073         }
4074     }
4075 
<span class="line-modified">4076     private static boolean permuteArgumentChecks(int[] reorder, MethodType newType, MethodType oldType) {</span>
4077         if (newType.returnType() != oldType.returnType())
4078             throw newIllegalArgumentException(&quot;return types do not match&quot;,
4079                     oldType, newType);
4080         if (reorder.length == oldType.parameterCount()) {
4081             int limit = newType.parameterCount();
4082             boolean bad = false;
4083             for (int j = 0; j &lt; reorder.length; j++) {
4084                 int i = reorder[j];
4085                 if (i &lt; 0 || i &gt;= limit) {
4086                     bad = true; break;
4087                 }
4088                 Class&lt;?&gt; src = newType.parameterType(i);
4089                 Class&lt;?&gt; dst = oldType.parameterType(j);
4090                 if (src != dst)
4091                     throw newIllegalArgumentException(&quot;parameter types do not match after reorder&quot;,
4092                             oldType, newType);
4093             }
4094             if (!bad)  return true;
4095         }
4096         throw newIllegalArgumentException(&quot;bad reorder array: &quot;+Arrays.toString(reorder));
</pre>
<hr />
<pre>
4921         MethodType targetType = target.type();
4922         MethodType filterType = filter.type();
4923         filterReturnValueChecks(targetType, filterType);
4924         BoundMethodHandle result = target.rebind();
4925         BasicType rtype = BasicType.basicType(filterType.returnType());
4926         LambdaForm lform = result.editor().filterReturnForm(rtype, false);
4927         MethodType newType = targetType.changeReturnType(filterType.returnType());
4928         result = result.copyWithExtendL(newType, lform, filter);
4929         return result;
4930     }
4931 
4932     private static void filterReturnValueChecks(MethodType targetType, MethodType filterType) throws RuntimeException {
4933         Class&lt;?&gt; rtype = targetType.returnType();
4934         int filterValues = filterType.parameterCount();
4935         if (filterValues == 0
4936                 ? (rtype != void.class)
4937                 : (rtype != filterType.parameterType(0) || filterValues != 1))
4938             throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
4939     }
4940 
<span class="line-removed">4941     /**</span>
<span class="line-removed">4942      * Adapts a target var handle by pre-processing incoming and outgoing values using a pair of unary filter functions.</span>
<span class="line-removed">4943      * &lt;p&gt;</span>
<span class="line-removed">4944      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var handle, the incoming value (of type {@code T}, where</span>
<span class="line-removed">4945      * {@code T} is the parameter type of the first filter function) is processed using the first filter and then passed</span>
<span class="line-removed">4946      * to the target var handle.</span>
<span class="line-removed">4947      * Conversely, when calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the return value obtained from</span>
<span class="line-removed">4948      * the target var handle (of type {@code T}, where {@code T} is the parameter type of the second filter function)</span>
<span class="line-removed">4949      * is processed using the second filter and returned to the caller. More advanced access mode types, such as</span>
<span class="line-removed">4950      * {@link java.lang.invoke.VarHandle.AccessMode#COMPARE_AND_EXCHANGE} might apply both filters at the same time.</span>
<span class="line-removed">4951      * &lt;p&gt;</span>
<span class="line-removed">4952      * For the boxing and unboxing filters to be well formed, their types must be of the form {@code S -&gt; T} and {@code T -&gt; S},</span>
<span class="line-removed">4953      * respectively, where {@code T} is the type of the target var handle. If this is the case, the resulting var handle will</span>
<span class="line-removed">4954      * have type {@code S}.</span>
<span class="line-removed">4955      * &lt;p&gt;</span>
<span class="line-removed">4956      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and</span>
<span class="line-removed">4957      * atomic access guarantees as those featured by the target var handle.</span>
<span class="line-removed">4958      *</span>
<span class="line-removed">4959      * @param target the target var handle</span>
<span class="line-removed">4960      * @param filterToTarget a filter to convert some type {@code S} into the type of {@code target}</span>
<span class="line-removed">4961      * @param filterFromTarget a filter to convert the type of {@code target} to some type {@code S}</span>
<span class="line-removed">4962      * @return an adapter var handle which accepts a new type, performing the provided boxing/unboxing conversions.</span>
<span class="line-removed">4963      * @throws NullPointerException if either {@code target}, {@code filterToTarget} or {@code filterFromTarget} are {@code == null}.</span>
<span class="line-removed">4964      * @throws IllegalArgumentException if {@code filterFromTarget} and {@code filterToTarget} are not well-formed, that is, they have types</span>
<span class="line-removed">4965      * other than {@code S -&gt; T} and {@code T -&gt; S}, respectively, where {@code T} is the type of the target var handle,</span>
<span class="line-removed">4966      * or if either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.</span>
<span class="line-removed">4967      */</span>
<span class="line-removed">4968     public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {</span>
<span class="line-removed">4969         Objects.nonNull(target);</span>
<span class="line-removed">4970         Objects.nonNull(filterToTarget);</span>
<span class="line-removed">4971         Objects.nonNull(filterFromTarget);</span>
<span class="line-removed">4972         //check that from/to filters do not throw checked exceptions</span>
<span class="line-removed">4973         noCheckedExceptions(filterToTarget);</span>
<span class="line-removed">4974         noCheckedExceptions(filterFromTarget);</span>
<span class="line-removed">4975 </span>
<span class="line-removed">4976         //check that from/to filters have right signatures</span>
<span class="line-removed">4977         if (filterFromTarget.type().parameterCount() != 1) {</span>
<span class="line-removed">4978             throw newIllegalArgumentException(&quot;filterFromTarget filter type has wrong arity&quot;, filterFromTarget.type());</span>
<span class="line-removed">4979         } else if (filterToTarget.type().parameterCount() != 1) {</span>
<span class="line-removed">4980             throw newIllegalArgumentException(&quot;filterToTarget filter type has wrong arity&quot;, filterFromTarget.type());</span>
<span class="line-removed">4981         } else if (filterFromTarget.type().parameterType(0) != filterToTarget.type().returnType() ||</span>
<span class="line-removed">4982                 filterToTarget.type().parameterType(0) != filterFromTarget.type().returnType()) {</span>
<span class="line-removed">4983             throw newIllegalArgumentException(&quot;filterFromTarget and filterToTarget filter types do not match&quot;, filterFromTarget.type(), filterToTarget.type());</span>
<span class="line-removed">4984         } else if (target.varType() != filterFromTarget.type().parameterType(0)) {</span>
<span class="line-removed">4985             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterFromTarget.type(), target.varType());</span>
<span class="line-removed">4986         } else if (target.varType() != filterToTarget.type().returnType()) {</span>
<span class="line-removed">4987             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterToTarget.type(), target.varType());</span>
<span class="line-removed">4988         }</span>
<span class="line-removed">4989 </span>
<span class="line-removed">4990         return new IndirectVarHandle(target, filterFromTarget.type().returnType(), target.coordinateTypes().toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-removed">4991                 (mode, modeHandle) -&gt; {</span>
<span class="line-removed">4992                     int lastParameterPos = modeHandle.type().parameterCount() - 1;</span>
<span class="line-removed">4993                     return switch (mode.at) {</span>
<span class="line-removed">4994                         case GET -&gt; MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="line-removed">4995                         case SET -&gt; MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);</span>
<span class="line-removed">4996                         case GET_AND_UPDATE -&gt; {</span>
<span class="line-removed">4997                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="line-removed">4998                             yield MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);</span>
<span class="line-removed">4999                         }</span>
<span class="line-removed">5000                         case COMPARE_AND_EXCHANGE -&gt; {</span>
<span class="line-removed">5001                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="line-removed">5002                             adapter = MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);</span>
<span class="line-removed">5003                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);</span>
<span class="line-removed">5004                         }</span>
<span class="line-removed">5005                         case COMPARE_AND_SET -&gt; {</span>
<span class="line-removed">5006                             MethodHandle adapter = MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);</span>
<span class="line-removed">5007                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);</span>
<span class="line-removed">5008                         }</span>
<span class="line-removed">5009                     };</span>
<span class="line-removed">5010                 });</span>
<span class="line-removed">5011     }</span>
<span class="line-removed">5012 </span>
<span class="line-removed">5013     /**</span>
<span class="line-removed">5014      * Adapts a target var handle by pre-processing incoming coordinate values using unary filter functions.</span>
<span class="line-removed">5015      * &lt;p&gt;</span>
<span class="line-removed">5016      * When calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the incoming coordinate values</span>
<span class="line-removed">5017      * starting at position {@code pos} (of type {@code C1, C2 ... Cn}, where {@code C1, C2 ... Cn} are the return type</span>
<span class="line-removed">5018      * of the unary filter functions) are transformed into new values (of type {@code S1, S2 ... Sn}, where {@code S1, S2 ... Sn} are the</span>
<span class="line-removed">5019      * parameter types of the unary filter functions), and then passed (along with any coordinate that was left unaltered</span>
<span class="line-removed">5020      * by the adaptation) to the target var handle.</span>
<span class="line-removed">5021      * &lt;p&gt;</span>
<span class="line-removed">5022      * For the coordinate filters to be well formed, their types must be of the form {@code S1 -&gt; T1, S2 -&gt; T1 ... Sn -&gt; Tn},</span>
<span class="line-removed">5023      * where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos} of the target var handle.</span>
<span class="line-removed">5024      * &lt;p&gt;</span>
<span class="line-removed">5025      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and</span>
<span class="line-removed">5026      * atomic access guarantees as those featured by the target var handle.</span>
<span class="line-removed">5027      *</span>
<span class="line-removed">5028      * @param target the target var handle</span>
<span class="line-removed">5029      * @param pos the position of the first coordinate to be transformed</span>
<span class="line-removed">5030      * @param filters the unary functions which are used to transform coordinates starting at position {@code pos}</span>
<span class="line-removed">5031      * @return an adapter var handle which accepts new coordinate types, applying the provided transformation</span>
<span class="line-removed">5032      * to the new coordinate values.</span>
<span class="line-removed">5033      * @throws NullPointerException if either {@code target}, {@code filters} are {@code == null}.</span>
<span class="line-removed">5034      * @throws IllegalArgumentException if the handles in {@code filters} are not well-formed, that is, they have types</span>
<span class="line-removed">5035      * other than {@code S1 -&gt; T1, S2 -&gt; T2, ... Sn -&gt; Tn} where {@code T1, T2 ... Tn} are the coordinate types starting</span>
<span class="line-removed">5036      * at position {@code pos} of the target var handle, if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,</span>
<span class="line-removed">5037      * or if more filters are provided than the actual number of coordinate types, or if any of the filters throws any</span>
<span class="line-removed">5038      * checked exceptions.</span>
<span class="line-removed">5039      * available starting at {@code pos}.</span>
<span class="line-removed">5040      */</span>
<span class="line-removed">5041     public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {</span>
<span class="line-removed">5042         Objects.nonNull(target);</span>
<span class="line-removed">5043         Objects.nonNull(filters);</span>
<span class="line-removed">5044 </span>
<span class="line-removed">5045         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-removed">5046         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="line-removed">5047             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="line-removed">5048         } else if (pos + filters.length &gt; targetCoordinates.size()) {</span>
<span class="line-removed">5049             throw new IllegalArgumentException(&quot;Too many filters&quot;);</span>
<span class="line-removed">5050         }</span>
<span class="line-removed">5051 </span>
<span class="line-removed">5052         if (filters.length == 0) return target;</span>
<span class="line-removed">5053 </span>
<span class="line-removed">5054         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="line-removed">5055         for (int i = 0 ; i &lt; filters.length ; i++) {</span>
<span class="line-removed">5056             noCheckedExceptions(filters[i]);</span>
<span class="line-removed">5057             MethodType filterType = filters[i].type();</span>
<span class="line-removed">5058             if (filterType.parameterCount() != 1) {</span>
<span class="line-removed">5059                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType);</span>
<span class="line-removed">5060             } else if (newCoordinates.get(pos + i) != filterType.returnType()) {</span>
<span class="line-removed">5061                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType + &quot; for coordinate type &quot; + newCoordinates.get(i));</span>
<span class="line-removed">5062             }</span>
<span class="line-removed">5063             newCoordinates.set(pos + i, filters[i].type().parameterType(0));</span>
<span class="line-removed">5064         }</span>
<span class="line-removed">5065 </span>
<span class="line-removed">5066         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-removed">5067                 (mode, modeHandle) -&gt; MethodHandles.filterArguments(modeHandle, 1 + pos, filters));</span>
<span class="line-removed">5068     }</span>
<span class="line-removed">5069 </span>
<span class="line-removed">5070     /**</span>
<span class="line-removed">5071      * Provides a target var handle with one or more &lt;em&gt;bound coordinates&lt;/em&gt;</span>
<span class="line-removed">5072      * in advance of the var handle&#39;s invocation. As a consequence, the resulting var handle will feature less</span>
<span class="line-removed">5073      * coordinate types than the target var handle.</span>
<span class="line-removed">5074      * &lt;p&gt;</span>
<span class="line-removed">5075      * When calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, incoming coordinate values</span>
<span class="line-removed">5076      * are joined with bound coordinate values, and then passed to the target var handle.</span>
<span class="line-removed">5077      * &lt;p&gt;</span>
<span class="line-removed">5078      * For the bound coordinates to be well formed, their types must be {@code T1, T2 ... Tn },</span>
<span class="line-removed">5079      * where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos} of the target var handle.</span>
<span class="line-removed">5080      * &lt;p&gt;</span>
<span class="line-removed">5081      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and</span>
<span class="line-removed">5082      * atomic access guarantees as those featured by the target var handle.</span>
<span class="line-removed">5083      *</span>
<span class="line-removed">5084      * @param target the var handle to invoke after the bound coordinates are inserted</span>
<span class="line-removed">5085      * @param pos the position of the first coordinate to be inserted</span>
<span class="line-removed">5086      * @param values the series of bound coordinates to insert</span>
<span class="line-removed">5087      * @return an adapter var handle which inserts an additional coordinates,</span>
<span class="line-removed">5088      *         before calling the target var handle</span>
<span class="line-removed">5089      * @throws NullPointerException if either {@code target}, {@code values} are {@code == null}.</span>
<span class="line-removed">5090      * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,</span>
<span class="line-removed">5091      * or if more values are provided than the actual number of coordinate types available starting at {@code pos}.</span>
<span class="line-removed">5092      * @throws ClassCastException if the bound coordinates in {@code values} are not well-formed, that is, they have types</span>
<span class="line-removed">5093      * other than {@code T1, T2 ... Tn }, where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos}</span>
<span class="line-removed">5094      * of the target var handle.</span>
<span class="line-removed">5095      */</span>
<span class="line-removed">5096     public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {</span>
<span class="line-removed">5097         Objects.nonNull(target);</span>
<span class="line-removed">5098         Objects.nonNull(values);</span>
<span class="line-removed">5099 </span>
<span class="line-removed">5100         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-removed">5101         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="line-removed">5102             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="line-removed">5103         } else if (pos + values.length &gt; targetCoordinates.size()) {</span>
<span class="line-removed">5104             throw new IllegalArgumentException(&quot;Too many values&quot;);</span>
<span class="line-removed">5105         }</span>
<span class="line-removed">5106 </span>
<span class="line-removed">5107         if (values.length == 0) return target;</span>
<span class="line-removed">5108 </span>
<span class="line-removed">5109         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="line-removed">5110         for (int i = 0 ; i &lt; values.length ; i++) {</span>
<span class="line-removed">5111             Class&lt;?&gt; pt = newCoordinates.get(pos);</span>
<span class="line-removed">5112             if (pt.isPrimitive()) {</span>
<span class="line-removed">5113                 Wrapper w = Wrapper.forPrimitiveType(pt);</span>
<span class="line-removed">5114                 w.convert(values[i], pt);</span>
<span class="line-removed">5115             } else {</span>
<span class="line-removed">5116                 pt.cast(values[i]);</span>
<span class="line-removed">5117             }</span>
<span class="line-removed">5118             newCoordinates.remove(pos);</span>
<span class="line-removed">5119         }</span>
<span class="line-removed">5120 </span>
<span class="line-removed">5121         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-removed">5122                 (mode, modeHandle) -&gt; MethodHandles.insertArguments(modeHandle, 1 + pos, values));</span>
<span class="line-removed">5123     }</span>
<span class="line-removed">5124 </span>
<span class="line-removed">5125     /**</span>
<span class="line-removed">5126      * Provides a var handle which adapts the coordinate values of the target var handle, by re-arranging them</span>
<span class="line-removed">5127      * so that the new coordinates match the provided ones.</span>
<span class="line-removed">5128      * &lt;p&gt;</span>
<span class="line-removed">5129      * The given array controls the reordering.</span>
<span class="line-removed">5130      * Call {@code #I} the number of incoming coordinates (the value</span>
<span class="line-removed">5131      * {@code newCoordinates.size()}, and call {@code #O} the number</span>
<span class="line-removed">5132      * of outgoing coordinates (the number of coordinates associated with the target var handle).</span>
<span class="line-removed">5133      * Then the length of the reordering array must be {@code #O},</span>
<span class="line-removed">5134      * and each element must be a non-negative number less than {@code #I}.</span>
<span class="line-removed">5135      * For every {@code N} less than {@code #O}, the {@code N}-th</span>
<span class="line-removed">5136      * outgoing coordinate will be taken from the {@code I}-th incoming</span>
<span class="line-removed">5137      * coordinate, where {@code I} is {@code reorder[N]}.</span>
<span class="line-removed">5138      * &lt;p&gt;</span>
<span class="line-removed">5139      * No coordinate value conversions are applied.</span>
<span class="line-removed">5140      * The type of each incoming coordinate, as determined by {@code newCoordinates},</span>
<span class="line-removed">5141      * must be identical to the type of the corresponding outgoing coordinate</span>
<span class="line-removed">5142      * in the target var handle.</span>
<span class="line-removed">5143      * &lt;p&gt;</span>
<span class="line-removed">5144      * The reordering array need not specify an actual permutation.</span>
<span class="line-removed">5145      * An incoming coordinate will be duplicated if its index appears</span>
<span class="line-removed">5146      * more than once in the array, and an incoming coordinate will be dropped</span>
<span class="line-removed">5147      * if its index does not appear in the array.</span>
<span class="line-removed">5148      * &lt;p&gt;</span>
<span class="line-removed">5149      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and</span>
<span class="line-removed">5150      * atomic access guarantees as those featured by the target var handle.</span>
<span class="line-removed">5151      * @param target the var handle to invoke after the coordinates have been reordered</span>
<span class="line-removed">5152      * @param newCoordinates the new coordinate types</span>
<span class="line-removed">5153      * @param reorder an index array which controls the reordering</span>
<span class="line-removed">5154      * @return an adapter var handle which re-arranges the incoming coordinate values,</span>
<span class="line-removed">5155      * before calling the target var handle</span>
<span class="line-removed">5156      * @throws NullPointerException if either {@code target}, {@code newCoordinates} or {@code reorder} are {@code == null}.</span>
<span class="line-removed">5157      * @throws IllegalArgumentException if the index array length is not equal to</span>
<span class="line-removed">5158      * the number of coordinates of the target var handle, or if any index array element is not a valid index for</span>
<span class="line-removed">5159      * a coordinate of {@code newCoordinates}, or if two corresponding coordinate types in</span>
<span class="line-removed">5160      * the target var handle and in {@code newCoordinates} are not identical.</span>
<span class="line-removed">5161      */</span>
<span class="line-removed">5162     public static VarHandle permuteCoordinates(VarHandle target, List&lt;Class&lt;?&gt;&gt; newCoordinates, int... reorder) {</span>
<span class="line-removed">5163         Objects.nonNull(target);</span>
<span class="line-removed">5164         Objects.nonNull(newCoordinates);</span>
<span class="line-removed">5165         Objects.nonNull(reorder);</span>
<span class="line-removed">5166 </span>
<span class="line-removed">5167         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-removed">5168         permuteArgumentChecks(reorder,</span>
<span class="line-removed">5169                 MethodType.methodType(void.class, newCoordinates),</span>
<span class="line-removed">5170                 MethodType.methodType(void.class, targetCoordinates));</span>
<span class="line-removed">5171 </span>
<span class="line-removed">5172         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-removed">5173                 (mode, modeHandle) -&gt;</span>
<span class="line-removed">5174                     MethodHandles.permuteArguments(modeHandle,</span>
<span class="line-removed">5175                         methodTypeFor(mode.at, modeHandle.type(), targetCoordinates, newCoordinates),</span>
<span class="line-removed">5176                         reorderArrayFor(mode.at, newCoordinates, reorder)));</span>
<span class="line-removed">5177     }</span>
<span class="line-removed">5178 </span>
<span class="line-removed">5179     private static int numTrailingArgs(VarHandle.AccessType at) {</span>
<span class="line-removed">5180         return switch (at) {</span>
<span class="line-removed">5181             case GET -&gt; 0;</span>
<span class="line-removed">5182             case GET_AND_UPDATE, SET -&gt; 1;</span>
<span class="line-removed">5183             case COMPARE_AND_SET, COMPARE_AND_EXCHANGE -&gt; 2;</span>
<span class="line-removed">5184         };</span>
<span class="line-removed">5185     }</span>
<span class="line-removed">5186 </span>
<span class="line-removed">5187     private static int[] reorderArrayFor(VarHandle.AccessType at, List&lt;Class&lt;?&gt;&gt; newCoordinates, int[] reorder) {</span>
<span class="line-removed">5188         int numTrailingArgs = numTrailingArgs(at);</span>
<span class="line-removed">5189         int[] adjustedReorder = new int[reorder.length + 1 + numTrailingArgs];</span>
<span class="line-removed">5190         adjustedReorder[0] = 0;</span>
<span class="line-removed">5191         for (int i = 0 ; i &lt; reorder.length ; i++) {</span>
<span class="line-removed">5192             adjustedReorder[i + 1] = reorder[i] + 1;</span>
<span class="line-removed">5193         }</span>
<span class="line-removed">5194         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {</span>
<span class="line-removed">5195             adjustedReorder[i + reorder.length + 1] = i + newCoordinates.size() + 1;</span>
<span class="line-removed">5196         }</span>
<span class="line-removed">5197         return adjustedReorder;</span>
<span class="line-removed">5198     }</span>
<span class="line-removed">5199 </span>
<span class="line-removed">5200     private static MethodType methodTypeFor(VarHandle.AccessType at, MethodType oldType, List&lt;Class&lt;?&gt;&gt; oldCoordinates, List&lt;Class&lt;?&gt;&gt; newCoordinates) {</span>
<span class="line-removed">5201         int numTrailingArgs = numTrailingArgs(at);</span>
<span class="line-removed">5202         MethodType adjustedType = MethodType.methodType(oldType.returnType(), oldType.parameterType(0));</span>
<span class="line-removed">5203         adjustedType = adjustedType.appendParameterTypes(newCoordinates);</span>
<span class="line-removed">5204         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {</span>
<span class="line-removed">5205             adjustedType = adjustedType.appendParameterTypes(oldType.parameterType(1 + oldCoordinates.size() + i));</span>
<span class="line-removed">5206         }</span>
<span class="line-removed">5207         return adjustedType;</span>
<span class="line-removed">5208     }</span>
<span class="line-removed">5209 </span>
<span class="line-removed">5210     /**</span>
<span class="line-removed">5211      * Adapts a target var handle handle by pre-processing</span>
<span class="line-removed">5212      * a sub-sequence of its coordinate values with a filter (a method handle).</span>
<span class="line-removed">5213      * The pre-processed coordinates are replaced by the result (if any) of the</span>
<span class="line-removed">5214      * filter function and the target var handle is then called on the modified (usually shortened)</span>
<span class="line-removed">5215      * coordinate list.</span>
<span class="line-removed">5216      * &lt;p&gt;</span>
<span class="line-removed">5217      * If {code R} is the return type of the filter (which cannot be void), the target var handle must accept a value of</span>
<span class="line-removed">5218      * type {@code R} as its coordinate in position {@code pos}, preceded and/or followed by</span>
<span class="line-removed">5219      * any coordinate not passed to the filter.</span>
<span class="line-removed">5220      * No coordinates are reordered, and the result returned from the filter</span>
<span class="line-removed">5221      * replaces (in order) the whole subsequence of coordinates originally</span>
<span class="line-removed">5222      * passed to the adapter.</span>
<span class="line-removed">5223      * &lt;p&gt;</span>
<span class="line-removed">5224      * The argument types (if any) of the filter</span>
<span class="line-removed">5225      * replace zero or one coordinate types of the target var handle, at position {@code pos},</span>
<span class="line-removed">5226      * in the resulting adapted var handle.</span>
<span class="line-removed">5227      * The return type of the filter must be identical to the</span>
<span class="line-removed">5228      * coordinate type of the target var handle at position {@code pos}, and that target var handle</span>
<span class="line-removed">5229      * coordinate is supplied by the return value of the filter.</span>
<span class="line-removed">5230      * &lt;p&gt;</span>
<span class="line-removed">5231      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and</span>
<span class="line-removed">5232      * atomic access guarantees as those featured by the target var handle.</span>
<span class="line-removed">5233      *</span>
<span class="line-removed">5234      * @param target the var handle to invoke after the coordinates have been filtered</span>
<span class="line-removed">5235      * @param pos the position of the coordinate to be filtered</span>
<span class="line-removed">5236      * @param filter the filter method handle</span>
<span class="line-removed">5237      * @return an adapter var handle which filters the incoming coordinate values,</span>
<span class="line-removed">5238      * before calling the target var handle</span>
<span class="line-removed">5239      * @throws NullPointerException if either {@code target}, {@code filter} are {@code == null}.</span>
<span class="line-removed">5240      * @throws IllegalArgumentException if the return type of {@code filter}</span>
<span class="line-removed">5241      * is void, or it is not the same as the {@code pos} coordinate of the target var handle,</span>
<span class="line-removed">5242      * if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,</span>
<span class="line-removed">5243      * if the resulting var handle&#39;s type would have &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many coordinates&lt;/a&gt;,</span>
<span class="line-removed">5244      * or if {@code filter} throws any checked exceptions.</span>
<span class="line-removed">5245      */</span>
<span class="line-removed">5246     public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {</span>
<span class="line-removed">5247         Objects.nonNull(target);</span>
<span class="line-removed">5248         Objects.nonNull(filter);</span>
<span class="line-removed">5249         noCheckedExceptions(filter);</span>
<span class="line-removed">5250 </span>
<span class="line-removed">5251         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-removed">5252         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="line-removed">5253             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="line-removed">5254         } else if (filter.type().returnType() == void.class) {</span>
<span class="line-removed">5255             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; ; filter cannot be void&quot;);</span>
<span class="line-removed">5256         } else if (filter.type().returnType() != targetCoordinates.get(pos)) {</span>
<span class="line-removed">5257             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; for coordinate type &quot; + targetCoordinates.get(pos));</span>
<span class="line-removed">5258         }</span>
<span class="line-removed">5259 </span>
<span class="line-removed">5260         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="line-removed">5261         newCoordinates.remove(pos);</span>
<span class="line-removed">5262         newCoordinates.addAll(pos, filter.type().parameterList());</span>
<span class="line-removed">5263 </span>
<span class="line-removed">5264         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-removed">5265                 (mode, modeHandle) -&gt; MethodHandles.collectArguments(modeHandle, 1 + pos, filter));</span>
<span class="line-removed">5266     }</span>
<span class="line-removed">5267 </span>
<span class="line-removed">5268     /**</span>
<span class="line-removed">5269      * Returns a var handle which will discard some dummy coordinates before delegating to the</span>
<span class="line-removed">5270      * target var handle. As a consequence, the resulting var handle will feature more</span>
<span class="line-removed">5271      * coordinate types than the target var handle.</span>
<span class="line-removed">5272      * &lt;p&gt;</span>
<span class="line-removed">5273      * The {@code pos} argument may range between zero and &lt;i&gt;N&lt;/i&gt;, where &lt;i&gt;N&lt;/i&gt; is the arity of the</span>
<span class="line-removed">5274      * target var handle&#39;s coordinate types. If {@code pos} is zero, the dummy coordinates will precede</span>
<span class="line-removed">5275      * the target&#39;s real arguments; if {@code pos} is &lt;i&gt;N&lt;/i&gt; they will come after.</span>
<span class="line-removed">5276      * &lt;p&gt;</span>
<span class="line-removed">5277      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and</span>
<span class="line-removed">5278      * atomic access guarantees as those featured by the target var handle.</span>
<span class="line-removed">5279      *</span>
<span class="line-removed">5280      * @param target the var handle to invoke after the dummy coordinates are dropped</span>
<span class="line-removed">5281      * @param pos position of first coordinate to drop (zero for the leftmost)</span>
<span class="line-removed">5282      * @param valueTypes the type(s) of the coordinate(s) to drop</span>
<span class="line-removed">5283      * @return an adapter var handle which drops some dummy coordinates,</span>
<span class="line-removed">5284      *         before calling the target var handle</span>
<span class="line-removed">5285      * @throws NullPointerException if either {@code target}, {@code valueTypes} are {@code == null}.</span>
<span class="line-removed">5286      * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive.</span>
<span class="line-removed">5287      */</span>
<span class="line-removed">5288     public static VarHandle dropCoordinates(VarHandle target, int pos, Class&lt;?&gt;... valueTypes) {</span>
<span class="line-removed">5289         Objects.nonNull(target);</span>
<span class="line-removed">5290         Objects.nonNull(valueTypes);</span>
<span class="line-removed">5291 </span>
<span class="line-removed">5292         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-removed">5293         if (pos &lt; 0 || pos &gt; targetCoordinates.size()) {</span>
<span class="line-removed">5294             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="line-removed">5295         }</span>
<span class="line-removed">5296 </span>
<span class="line-removed">5297         if (valueTypes.length == 0) return target;</span>
<span class="line-removed">5298 </span>
<span class="line-removed">5299         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="line-removed">5300         newCoordinates.addAll(pos, List.of(valueTypes));</span>
<span class="line-removed">5301 </span>
<span class="line-removed">5302         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-removed">5303                 (mode, modeHandle) -&gt; MethodHandles.dropArguments(modeHandle, 1 + pos, valueTypes));</span>
<span class="line-removed">5304     }</span>
<span class="line-removed">5305 </span>
<span class="line-removed">5306     private static void noCheckedExceptions(MethodHandle handle) {</span>
<span class="line-removed">5307         if (handle instanceof DirectMethodHandle) {</span>
<span class="line-removed">5308             DirectMethodHandle directHandle = (DirectMethodHandle)handle;</span>
<span class="line-removed">5309             MethodHandleInfo info = Lookup.IMPL_LOOKUP.revealDirect(directHandle);</span>
<span class="line-removed">5310             Class&lt;?&gt;[] exceptionTypes = switch (info.getReferenceKind()) {</span>
<span class="line-removed">5311                 case MethodHandleInfo.REF_invokeInterface, MethodHandleInfo.REF_invokeSpecial,</span>
<span class="line-removed">5312                      MethodHandleInfo.REF_invokeStatic, MethodHandleInfo.REF_invokeVirtual -&gt;</span>
<span class="line-removed">5313                         info.reflectAs(Method.class, Lookup.IMPL_LOOKUP).getExceptionTypes();</span>
<span class="line-removed">5314                 case MethodHandleInfo.REF_newInvokeSpecial -&gt;</span>
<span class="line-removed">5315                         info.reflectAs(Constructor.class, Lookup.IMPL_LOOKUP).getExceptionTypes();</span>
<span class="line-removed">5316                 case MethodHandleInfo.REF_getField, MethodHandleInfo.REF_getStatic,</span>
<span class="line-removed">5317                      MethodHandleInfo.REF_putField, MethodHandleInfo.REF_putStatic -&gt; null;</span>
<span class="line-removed">5318                 default -&gt; throw new AssertionError(&quot;Cannot get here&quot;);</span>
<span class="line-removed">5319             };</span>
<span class="line-removed">5320             if (exceptionTypes != null) {</span>
<span class="line-removed">5321                 if (Stream.of(exceptionTypes).anyMatch(MethodHandles::isCheckedException)) {</span>
<span class="line-removed">5322                     throw newIllegalArgumentException(&quot;Cannot adapt a var handle with a method handle which throws checked exceptions&quot;);</span>
<span class="line-removed">5323                 }</span>
<span class="line-removed">5324             }</span>
<span class="line-removed">5325         } else if (handle instanceof DelegatingMethodHandle) {</span>
<span class="line-removed">5326             noCheckedExceptions(((DelegatingMethodHandle)handle).getTarget());</span>
<span class="line-removed">5327         } else {</span>
<span class="line-removed">5328             //bound</span>
<span class="line-removed">5329             BoundMethodHandle boundHandle = (BoundMethodHandle)handle;</span>
<span class="line-removed">5330             for (int i = 0 ; i &lt; boundHandle.fieldCount() ; i++) {</span>
<span class="line-removed">5331                 Object arg = boundHandle.arg(i);</span>
<span class="line-removed">5332                 if (arg instanceof MethodHandle){</span>
<span class="line-removed">5333                     noCheckedExceptions((MethodHandle) arg);</span>
<span class="line-removed">5334                 }</span>
<span class="line-removed">5335             }</span>
<span class="line-removed">5336         }</span>
<span class="line-removed">5337     }</span>
<span class="line-removed">5338 </span>
<span class="line-removed">5339     private static boolean isCheckedException(Class&lt;?&gt; clazz) {</span>
<span class="line-removed">5340         return Throwable.class.isAssignableFrom(clazz) &amp;&amp;</span>
<span class="line-removed">5341                 !RuntimeException.class.isAssignableFrom(clazz) &amp;&amp;</span>
<span class="line-removed">5342                 !Error.class.isAssignableFrom(clazz);</span>
<span class="line-removed">5343     }</span>
<span class="line-removed">5344 </span>
5345     /**
5346      * Adapts a target method handle by pre-processing
5347      * some of its arguments, and then calling the target with
5348      * the result of the pre-processing, inserted into the original
5349      * sequence of arguments.
5350      * &lt;p&gt;
5351      * The pre-processing is performed by {@code combiner}, a second method handle.
5352      * Of the arguments passed to the adapter, the first {@code N} arguments
5353      * are copied to the combiner, which is then called.
5354      * (Here, {@code N} is defined as the parameter count of the combiner.)
5355      * After this, control passes to the target, with any result
5356      * from the combiner inserted before the original {@code N} incoming
5357      * arguments.
5358      * &lt;p&gt;
5359      * If the combiner returns a value, the first parameter type of the target
5360      * must be identical with the return type of the combiner, and the next
5361      * {@code N} parameter types of the target must exactly match the parameters
5362      * of the combiner.
5363      * &lt;p&gt;
5364      * If the combiner has a void return, no result will be inserted,
</pre>
</td>
<td>
<hr />
<pre>
4056             BitSet mask = new BitSet(newArity);
4057             for (int i = 0; i &lt; reorder.length; i++) {
4058                 int arg = reorder[i];
4059                 if (arg &gt;= newArity) {
4060                     return reorder.length;
4061                 }
4062                 if (mask.get(arg)) {
4063                     return i;  // &gt;0 indicates a dup
4064                 }
4065                 mask.set(arg);
4066             }
4067             int zeroPos = mask.nextClearBit(0);
4068             assert(zeroPos &lt;= newArity);
4069             if (zeroPos == newArity) {
4070                 return 0;
4071             }
4072             return ~zeroPos;
4073         }
4074     }
4075 
<span class="line-modified">4076     static boolean permuteArgumentChecks(int[] reorder, MethodType newType, MethodType oldType) {</span>
4077         if (newType.returnType() != oldType.returnType())
4078             throw newIllegalArgumentException(&quot;return types do not match&quot;,
4079                     oldType, newType);
4080         if (reorder.length == oldType.parameterCount()) {
4081             int limit = newType.parameterCount();
4082             boolean bad = false;
4083             for (int j = 0; j &lt; reorder.length; j++) {
4084                 int i = reorder[j];
4085                 if (i &lt; 0 || i &gt;= limit) {
4086                     bad = true; break;
4087                 }
4088                 Class&lt;?&gt; src = newType.parameterType(i);
4089                 Class&lt;?&gt; dst = oldType.parameterType(j);
4090                 if (src != dst)
4091                     throw newIllegalArgumentException(&quot;parameter types do not match after reorder&quot;,
4092                             oldType, newType);
4093             }
4094             if (!bad)  return true;
4095         }
4096         throw newIllegalArgumentException(&quot;bad reorder array: &quot;+Arrays.toString(reorder));
</pre>
<hr />
<pre>
4921         MethodType targetType = target.type();
4922         MethodType filterType = filter.type();
4923         filterReturnValueChecks(targetType, filterType);
4924         BoundMethodHandle result = target.rebind();
4925         BasicType rtype = BasicType.basicType(filterType.returnType());
4926         LambdaForm lform = result.editor().filterReturnForm(rtype, false);
4927         MethodType newType = targetType.changeReturnType(filterType.returnType());
4928         result = result.copyWithExtendL(newType, lform, filter);
4929         return result;
4930     }
4931 
4932     private static void filterReturnValueChecks(MethodType targetType, MethodType filterType) throws RuntimeException {
4933         Class&lt;?&gt; rtype = targetType.returnType();
4934         int filterValues = filterType.parameterCount();
4935         if (filterValues == 0
4936                 ? (rtype != void.class)
4937                 : (rtype != filterType.parameterType(0) || filterValues != 1))
4938             throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
4939     }
4940 




















































































































































































































































































































































































































4941     /**
4942      * Adapts a target method handle by pre-processing
4943      * some of its arguments, and then calling the target with
4944      * the result of the pre-processing, inserted into the original
4945      * sequence of arguments.
4946      * &lt;p&gt;
4947      * The pre-processing is performed by {@code combiner}, a second method handle.
4948      * Of the arguments passed to the adapter, the first {@code N} arguments
4949      * are copied to the combiner, which is then called.
4950      * (Here, {@code N} is defined as the parameter count of the combiner.)
4951      * After this, control passes to the target, with any result
4952      * from the combiner inserted before the original {@code N} incoming
4953      * arguments.
4954      * &lt;p&gt;
4955      * If the combiner returns a value, the first parameter type of the target
4956      * must be identical with the return type of the combiner, and the next
4957      * {@code N} parameter types of the target must exactly match the parameters
4958      * of the combiner.
4959      * &lt;p&gt;
4960      * If the combiner has a void return, no result will be inserted,
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandleImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarHandles.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.base/share/classes/module-info.java b/src/java.base/share/classes/module-info.java
--- a/src/java.base/share/classes/module-info.java
+++ b/src/java.base/share/classes/module-info.java
@@ -172,11 +172,12 @@
         java.logging;
     exports jdk.internal.org.objectweb.asm to
         jdk.jartool,
         jdk.jfr,
         jdk.jlink,
-        jdk.scripting.nashorn;
+        jdk.scripting.nashorn,
+        jdk.incubator.jextract;
     exports jdk.internal.org.objectweb.asm.tree to
         jdk.jfr,
         jdk.jlink;
     exports jdk.internal.org.objectweb.asm.util to
         jdk.jfr,
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
@@ -211,10 +211,15 @@
     /**
      * The {@code double} native type.
      */
     public static final ValueLayout C_DOUBLE;
 
+    /**
+     * The {@code long double} native type.
+     */
+    public static final ValueLayout C_LONGDOUBLE;
+
     /**
      * The {@code T*} native type.
      */
     public static final ValueLayout C_POINTER;
 
@@ -234,10 +239,11 @@
                 C_ULONG = SysV.C_ULONG;
                 C_LONGLONG = SysV.C_LONGLONG;
                 C_ULONGLONG = SysV.C_ULONGLONG;
                 C_FLOAT = SysV.C_FLOAT;
                 C_DOUBLE = SysV.C_DOUBLE;
+                C_LONGDOUBLE = SysV.C_LONGDOUBLE;
                 C_POINTER = SysV.C_POINTER;
             }
             case ABI_WINDOWS -> {
                 C_BOOL = WinABI.C_BOOL;
                 C_UCHAR = WinABI.C_UCHAR;
@@ -251,10 +257,11 @@
                 C_ULONG = WinABI.C_ULONG;
                 C_LONGLONG = WinABI.C_LONGLONG;
                 C_ULONGLONG = WinABI.C_ULONGLONG;
                 C_FLOAT = WinABI.C_FLOAT;
                 C_DOUBLE = WinABI.C_DOUBLE;
+                C_LONGDOUBLE = WinABI.C_LONGDOUBLE;
                 C_POINTER = WinABI.C_POINTER;
             }
             case ABI_AARCH64 -> {
                 C_BOOL = AArch64ABI.C_BOOL;
                 C_UCHAR = AArch64ABI.C_UCHAR;
@@ -268,10 +275,11 @@
                 C_ULONG = AArch64ABI.C_ULONG;
                 C_LONGLONG = AArch64ABI.C_LONGLONG;
                 C_ULONGLONG = AArch64ABI.C_ULONGLONG;
                 C_FLOAT = AArch64ABI.C_FLOAT;
                 C_DOUBLE = AArch64ABI.C_DOUBLE;
+                C_LONGDOUBLE = AArch64ABI.C_LONGDOUBLE;
                 C_POINTER = AArch64ABI.C_POINTER;
             }
             default -> throw new IllegalStateException("Unsupported ABI: " + abi.name());
         }
     }
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/ConstantHelper.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/ConstantHelper.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/ConstantHelper.java
@@ -0,0 +1,503 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.incubator.jextract.tool;
+
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.LibraryLookup;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.org.objectweb.asm.ClassWriter;
+import jdk.internal.org.objectweb.asm.ConstantDynamic;
+import jdk.internal.org.objectweb.asm.Handle;
+import jdk.internal.org.objectweb.asm.MethodVisitor;
+import jdk.internal.org.objectweb.asm.Type;
+
+import javax.tools.JavaFileObject;
+import javax.tools.SimpleJavaFileObject;
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.Constable;
+import java.lang.constant.ConstantDesc;
+import java.lang.constant.ConstantDescs;
+import java.lang.constant.DirectMethodHandleDesc;
+import java.lang.constant.DirectMethodHandleDesc.Kind;
+import java.lang.constant.DynamicConstantDesc;
+import java.lang.constant.MethodHandleDesc;
+import java.lang.constant.MethodTypeDesc;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+import java.lang.invoke.VarHandle;
+import java.net.URI;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Consumer;
+
+import static java.lang.constant.ConstantDescs.*;
+import static java.lang.invoke.MethodHandleInfo.*;
+import static java.lang.invoke.MethodType.methodType;
+import static jdk.internal.org.objectweb.asm.Opcodes.*;
+
+class ConstantHelper {
+
+    private static final String INTR_OBJECT = Type.getInternalName(Object.class);
+
+    private static final ClassDesc CD_LIBRARIES = desc(LibraryLookup[].class);
+
+    private static final DirectMethodHandleDesc MH_MemoryLayout_varHandle = MethodHandleDesc.ofMethod(
+            Kind.INTERFACE_VIRTUAL,
+            desc(MemoryLayout.class),
+            "varHandle",
+            desc(methodType(
+                    VarHandle.class,
+                    Class.class,
+                    MemoryLayout.PathElement[].class))
+    );
+
+    private static final DirectMethodHandleDesc MH_PathElement_groupElement = MethodHandleDesc.ofMethod(
+            Kind.INTERFACE_STATIC,
+            desc(MemoryLayout.PathElement.class),
+            "groupElement",
+            desc(methodType(MemoryLayout.PathElement.class, String.class))
+    );
+
+    private static final DirectMethodHandleDesc MH_MemoryAddress_ofLong = MethodHandleDesc.ofMethod(
+            Kind.INTERFACE_STATIC,
+            desc(MemoryAddress.class),
+            "ofLong",
+            desc(methodType(MemoryAddress.class, long.class))
+    );
+
+    private static final DirectMethodHandleDesc MH_MemorySegment_baseAddress = MethodHandleDesc.ofMethod(
+            Kind.INTERFACE_VIRTUAL,
+            desc(MemorySegment.class),
+            "baseAddress",
+            desc(methodType(MemoryAddress.class))
+    );
+
+    private static final DirectMethodHandleDesc BSM_GET_STATIC_FINAL = ConstantDescs.ofConstantBootstrap(
+            CD_ConstantBootstraps,
+            "getStaticFinal",
+            CD_Object,
+            CD_Class
+    );
+
+    private static final ConstantDesc TRUE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, "TRUE", ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
+    private static final ConstantDesc FALSE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, "FALSE", ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
+    private static final ClassDesc CD_PathElelemt = desc(MemoryLayout.PathElement.class);
+    private static final ClassDesc CD_MemoryAddress = desc(MemoryAddress.class);
+    private static final ClassDesc CD_MemorySegment = desc(MemorySegment.class);
+
+    private final DirectMethodHandleDesc MH_downcallHandle;
+    private final DirectMethodHandleDesc MH_lookupGlobalVariable;
+    private final DirectMethodHandleDesc MH_makeCString;
+
+    private ClassWriter cw;
+    private final String internalClassName;
+    private final ClassDesc CD_constantsHelper;
+    private final ConstantDesc LIBRARIES;
+
+    private final Map<String, DirectMethodHandleDesc> pool = new HashMap<>();
+
+    ConstantHelper(String parentClassName, ClassDesc runtimeHelper, ClassDesc cString, String[] libraryNames) {
+        this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
+        String className = parentClassName + "$constants";
+        this.CD_constantsHelper = ClassDesc.of(className);
+        this.internalClassName = className.replace('.', '/');
+
+        this.MH_downcallHandle = findRuntimeHelperBootstrap(
+                runtimeHelper,
+                "downcallHandle",
+                methodType(
+                        MethodHandle.class,
+                        LibraryLookup[].class,
+                        String.class,
+                        String.class,
+                        FunctionDescriptor.class,
+                        boolean.class)
+        );
+        this.MH_lookupGlobalVariable = findRuntimeHelperBootstrap(
+                runtimeHelper,
+                "lookupGlobalVariable",
+                methodType(
+                        MemoryAddress.class,
+                        LibraryLookup[].class,
+                        String.class)
+        );
+        this.MH_makeCString = findRuntimeHelperBootstrap(
+                cString,
+                "toCString",
+                methodType(
+                        MemorySegment.class,
+                        String.class)
+        );
+
+        this.LIBRARIES = librariesDesc(findRuntimeHelperBootstrap(
+                runtimeHelper,
+                "libraries",
+                methodType(
+                        LibraryLookup[].class,
+                        String[].class)
+        ), libraryNames);
+
+        cw.visit(V15, ACC_PUBLIC, internalClassName, null, INTR_OBJECT, null);
+    }
+
+    private static DirectMethodHandleDesc findRuntimeHelperBootstrap(ClassDesc runtimeHelper, String name, MethodType type) {
+        return MethodHandleDesc.ofMethod(
+                Kind.STATIC,
+                runtimeHelper,
+                name,
+                desc(type)
+        );
+    }
+
+    public DirectMethodHandleDesc addLayout(String javaName, MemoryLayout layout) {
+        return emitCondyGetter(javaName + "$LAYOUT", MemoryLayout.class, desc(layout));
+    }
+
+    public DirectMethodHandleDesc addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        return emitCondyGetter(javaName + "$VH", VarHandle.class, varHandleDesc(javaName, nativeName, layout, type, parentLayout));
+    }
+
+    public DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
+        return emitCondyGetter(javaName + "$MH", MethodHandle.class, methodHandleDesc(nativeName, mtype, desc, varargs));
+    }
+
+    public DirectMethodHandleDesc addAddress(String javaName, String nativeName) {
+        return emitCondyGetter(javaName + "$ADDR", MemoryAddress.class, globalVarAddressDesc(nativeName));
+    }
+
+    public DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor fDesc) {
+        return emitCondyGetter(javaName + "$DESC", FunctionDescriptor.class, desc(fDesc));
+    }
+
+    public DirectMethodHandleDesc addConstant(String name, Class<?> type, Object value) {
+        if (type == MemoryAddress.class) {
+            if (value instanceof Long) {
+                return emitCondyGetter(name, type, addressDesc((Long) value));
+            } else if (value instanceof String) {
+                return emitCondyGetter(name, type, cStringDesc((String) value));
+            } else {
+                throw new IllegalStateException("Unhandled constant value type: " + value.getClass());
+            }
+        } else if (type.isPrimitive()) {
+            if (type == int.class || type == byte.class || type == short.class || type == char.class) {
+                return emitConIntGetter(name, type, ((Long) value).intValue());
+            } else if (type == float.class) {
+                return emitConFloatGetter(name, type, ((Double) value).floatValue());
+            } else if (type == long.class) {
+                return emitConLongGetter(name, type, (Long) value);
+            } else if (type == double.class) {
+                return emitConDoubleGetter(name, type, (Double) value);
+            } else { // boolean and void
+                throw new IllegalStateException("Unhandled primitive target type: " + type);
+            }
+        } else if (type == value.getClass() && value instanceof Constable) {
+            // Constable value that requires no conversion
+            return emitCondyGetter(name, type, desc((Constable) value));
+        } else {
+            System.out.println("Warning: Skipping constant generation for: " + name + " of type: " + type.getSimpleName()
+                + " with value: " + value + " of type: " + value.getClass());
+            return null;
+        }
+    }
+
+    public List<JavaFileObject> getClasses() {
+        cw.visitEnd();
+        byte[] bytes = cw.toByteArray();
+        cw = null;
+        return List.of(jfoFromByteArray(internalClassName, bytes));
+    }
+
+    // Utility
+
+    private static JavaFileObject jfoFromByteArray(String name, byte[] bytes) {
+        return new SimpleJavaFileObject(URI.create(name + ".class"), JavaFileObject.Kind.CLASS) {
+            @Override
+            public InputStream openInputStream() {
+                return new ByteArrayInputStream(bytes);
+            }
+        };
+    }
+
+    private static String descriptorToInternalName(String s) {
+        return s.substring(1, s.length() - 1);
+    }
+
+    @SuppressWarnings("unchecked")
+    private static <T extends ConstantDesc> T desc(Constable constable) {
+        return (T) constable.describeConstable().orElseThrow();
+    }
+
+    // ASM helpers
+
+    private static void emitConShort(MethodVisitor mv, short value) {
+        if (value >= -1 && value <= 5) {
+            mv.visitInsn(
+                switch (value) {
+                    case -1 -> ICONST_M1;
+                    case 0 -> ICONST_0;
+                    case 1 -> ICONST_1;
+                    case 2 -> ICONST_2;
+                    case 3 -> ICONST_3;
+                    case 4 -> ICONST_4;
+                    case 5 -> ICONST_5;
+                    default -> throw new IllegalStateException("Should not reach here");
+                });
+        } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {
+            mv.visitIntInsn(BIPUSH, value);
+        } else {
+            mv.visitIntInsn(SIPUSH, value);
+        }
+    }
+
+    private static void emitConInt(MethodVisitor mv, int value) {
+        if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {
+            emitConShort(mv, (short) value);
+        } else {
+            mv.visitLdcInsn(value);
+        }
+    }
+
+    private static void emitConLong(MethodVisitor mv, long value) {
+        if (value == 0) {
+            mv.visitInsn(LCONST_0);
+        } else if (value == 1) {
+            mv.visitInsn(LCONST_1);
+        } else if (value >= Integer.MIN_VALUE && value <= Integer.MAX_VALUE) {
+            // saves a constant pool slot
+            emitConInt(mv, (int) value);
+            mv.visitInsn(I2L);
+        } else {
+            mv.visitLdcInsn(value);
+        }
+    }
+
+    private static void emitConFloat(MethodVisitor mv, float value) {
+        if (value == 0.0F) {
+            mv.visitInsn(FCONST_0);
+        } else if (value == 1.0F) {
+            mv.visitInsn(FCONST_1);
+        } else if (value == 2.0F) {
+            mv.visitInsn(FCONST_2);
+        } else if (value == (short) value) {
+            emitConShort(mv, (short) value);
+            mv.visitInsn(I2F);
+        } else {
+            mv.visitLdcInsn(value);
+        }
+    }
+
+    private static void emitConDouble(MethodVisitor mv, double value) {
+        if (value == 0.0D) {
+            mv.visitInsn(DCONST_0);
+        } else if (value == 1.0D) {
+            mv.visitInsn(DCONST_1);
+        } else if (value == (short) value) {
+            emitConShort(mv, (short) value);
+            mv.visitInsn(I2D);
+        } else if (value >= Float.MIN_VALUE && value <= Float.MAX_VALUE) {
+            // saves a constant pool slot
+            mv.visitLdcInsn((float) value);
+            mv.visitInsn(F2D);
+        } else {
+            mv.visitLdcInsn(value);
+        }
+    }
+
+    private DirectMethodHandleDesc emitGetter(String name, Class<?> type, Consumer<MethodVisitor> action) {
+        return pool.computeIfAbsent(name, nameKey -> {
+            MethodType mt = methodType(type);
+            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, nameKey, mt.descriptorString(), null, null);
+            mv.visitCode();
+            action.accept(mv);
+            emitReturn(mv, type);
+            mv.visitMaxs(-1, -1);
+            mv.visitEnd();
+            return MethodHandleDesc.ofMethod(
+                    Kind.STATIC,
+                    CD_constantsHelper,
+                    nameKey,
+                    mt.describeConstable().orElseThrow()
+            );
+        });
+    }
+
+    private DirectMethodHandleDesc emitConDoubleGetter(String name, Class<?> type, double value) {
+        return emitGetter(name, type, mv -> emitConDouble(mv, value));
+    }
+
+    private DirectMethodHandleDesc emitConLongGetter(String name, Class<?> type, long value) {
+        return emitGetter(name, type, mv -> emitConLong(mv, value));
+    }
+
+    private DirectMethodHandleDesc emitConFloatGetter(String name, Class<?> type, float value) {
+        return emitGetter(name, type, mv -> emitConFloat(mv, value));
+    }
+
+    private DirectMethodHandleDesc emitConIntGetter(String name, Class<?> type, int value) {
+        return emitGetter(name, type, mv -> emitConInt(mv, value));
+    }
+
+    private DirectMethodHandleDesc emitCondyGetter(String name, Class<?> type, ConstantDesc desc) {
+        return emitGetter(name, type, mv -> mv.visitLdcInsn(asmConstant(desc)));
+    }
+
+    private static void emitReturn(MethodVisitor mv, Class<?> type) {
+        if (type == int.class
+                || type == short.class
+                || type == byte.class
+                || type == char.class
+                || type == boolean.class) {
+            mv.visitInsn(IRETURN);
+        } else if (type == long.class) {
+            mv.visitInsn(LRETURN);
+        } else if (type == float.class) {
+            mv.visitInsn(FRETURN);
+        } else if (type == double.class) {
+            mv.visitInsn(DRETURN);
+        } else if (type == void.class) {
+            mv.visitInsn(RETURN);
+        } else if (Object.class.isAssignableFrom(type)) {
+            mv.visitInsn(ARETURN);
+        } else {
+            throw new IllegalArgumentException("Type not handled: " + type);
+        }
+    }
+
+    // Condy factories
+
+    private static ConstantDesc librariesDesc(DirectMethodHandleDesc MH_libraries, String[] libraryNames) {
+        ConstantDesc[] args = new ConstantDesc[libraryNames.length + 1];
+        args[0] = MH_libraries;
+        System.arraycopy(libraryNames, 0, args, 1, libraryNames.length);
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "libraries", CD_LIBRARIES, args);
+    }
+
+    private static ConstantDesc varHandleDesc(String name, ConstantDesc memoryLayout, ClassDesc carrier, ConstantDesc path) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "VH_" + name, CD_VarHandle, MH_MemoryLayout_varHandle, memoryLayout, carrier, path);
+    }
+
+    private static ConstantDesc varHandleDesc(String name, ConstantDesc memoryLayout, ClassDesc carrier) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "VH_" + name, CD_VarHandle, MH_MemoryLayout_varHandle, memoryLayout, carrier);
+    }
+
+    private static ConstantDesc groupElementDesc(String fieldName) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "groupElement_" + fieldName, CD_PathElelemt, MH_PathElement_groupElement, fieldName);
+    }
+
+    private static ConstantDesc varHandleDesc(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        if (parentLayout != null) {
+            return varHandleDesc(javaName, desc(parentLayout), desc(type), groupElementDesc(nativeName));
+        } else {
+            return varHandleDesc(javaName, desc(layout), desc(type));
+        }
+    }
+
+    private ConstantDesc globalVarAddressDesc(String name) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "ADDR_" + name, CD_MemoryAddress, MH_lookupGlobalVariable, LIBRARIES, name);
+    }
+
+    private ConstantDesc addressDesc(long value) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "MA_" + value, CD_MemoryAddress, MH_MemoryAddress_ofLong, value);
+    }
+
+    private ConstantDesc cStringDesc(String value) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "BASEADDRESS", CD_MemoryAddress, MH_MemorySegment_baseAddress,
+            DynamicConstantDesc.ofNamed(BSM_INVOKE, "CSTRING", CD_MemorySegment, MH_makeCString, value)
+        );
+    }
+
+    private ConstantDesc methodHandleDesc(String name, MethodType mtype, FunctionDescriptor funcDesc, boolean varargs) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "MH_" + name, CD_MethodHandle, MH_downcallHandle,
+            LIBRARIES,
+            name,
+            mtype.descriptorString(),
+            desc(funcDesc),
+            varargs ? TRUE : FALSE);
+    }
+
+    // To ASM constant translation
+
+    private static Handle asmHandle(DirectMethodHandleDesc desc) {
+        int tag = switch(desc.refKind()) {
+            case REF_getField         -> H_GETFIELD;
+            case REF_getStatic        -> H_GETSTATIC;
+            case REF_putField         -> H_PUTFIELD;
+            case REF_putStatic        -> H_PUTSTATIC;
+            case REF_invokeVirtual    -> H_INVOKEVIRTUAL;
+            case REF_invokeStatic     -> H_INVOKESTATIC;
+            case REF_invokeSpecial    -> H_INVOKESPECIAL;
+            case REF_newInvokeSpecial -> H_NEWINVOKESPECIAL;
+            case REF_invokeInterface  -> H_INVOKEINTERFACE;
+            default -> throw new InternalError("Should not reach here");
+        };
+        return new Handle(tag,
+                descriptorToInternalName(desc.owner().descriptorString()),
+                desc.methodName(),
+                desc.lookupDescriptor(),
+                desc.isOwnerInterface());
+    }
+
+    private static ConstantDynamic asmCondy(DynamicConstantDesc<?> condy) {
+        return new ConstantDynamic(
+                condy.constantName(),
+                condy.constantType().descriptorString(),
+                asmHandle(condy.bootstrapMethod()),
+                asmConstantArgs(condy.bootstrapArgs()));
+    }
+
+    private static Object[] asmConstantArgs(ConstantDesc[] descs) {
+        Object[] objects = new Object[descs.length];
+        for (int i = 0; i < objects.length; i++) {
+            objects[i] = asmConstant(descs[i]);
+        }
+        return objects;
+    }
+
+    private static Object asmConstant(ConstantDesc desc) {
+        if (desc instanceof DynamicConstantDesc<?>) {
+            return asmCondy((DynamicConstantDesc<?>) desc);
+        } else if (desc instanceof Integer
+            || desc instanceof Float
+            || desc instanceof Long
+            || desc instanceof Double
+            || desc instanceof String) {
+            return desc;
+        } else if (desc instanceof ClassDesc) {
+            // Primitives should be caught above
+            return Type.getType(((ClassDesc) desc).descriptorString());
+        } else if (desc instanceof MethodTypeDesc) {
+            return Type.getMethodType(((MethodTypeDesc) desc).descriptorString());
+        } else if (desc instanceof DirectMethodHandleDesc) {
+            return asmHandle((DirectMethodHandleDesc) desc);
+        }
+        throw new IllegalArgumentException("ConstantDesc type not handled: " + desc);
+    }
+
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HandleSourceFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HandleSourceFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HandleSourceFactory.java
+++ /dev/null
@@ -1,356 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.jextract.tool;
-
-import jdk.incubator.jextract.Declaration;
-import jdk.incubator.jextract.Type;
-import jdk.incubator.foreign.FunctionDescriptor;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.SystemABI;
-import jdk.internal.foreign.InternalForeign;
-
-import javax.tools.JavaFileObject;
-import javax.tools.SimpleJavaFileObject;
-import java.io.IOException;
-import java.io.UncheckedIOException;
-import java.lang.invoke.MethodType;
-import java.net.URI;
-import java.net.URL;
-import java.net.URISyntaxException;
-import java.nio.file.Files;
-import java.nio.file.Paths;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.stream.Collectors;
-
-/*
- * Scan a header file and generate Java source items for entities defined in that header
- * file. Tree visitor visit methods return true/false depending on whether a
- * particular Tree is processed or skipped.
- */
-public class HandleSourceFactory implements Declaration.Visitor<Void, Declaration> {
-    private final Set<String> constants = new HashSet<>();
-    // To detect duplicate Variable and Function declarations.
-    private final Set<Declaration.Variable> variables = new HashSet<>();
-    private final Set<Declaration.Function> functions = new HashSet<>();
-
-    private final Set<String> structsAndVars = new HashSet<>();
-    private final Map<String, String> mangledNames = new HashMap<>();
-
-    protected final JavaSourceBuilder builder = new JavaSourceBuilder();
-    protected final TypeTranslator typeTranslator = new TypeTranslator();
-    private final List<String> libraryNames;
-    private final String clsName;
-    private final String pkgName;
-
-    // have we visited this Variable earlier?
-    protected boolean visitedVariable(Declaration.Variable tree) {
-        return !variables.add(tree);
-    }
-
-    // have we visited this Function earlier?
-    protected boolean visitedFunction(Declaration.Function tree) {
-        return !functions.add(tree);
-    }
-
-    // have we visited a struct/union or a global variable of given name?
-    protected boolean visitedStructOrVariable(String name) {
-        return !structsAndVars.add(name);
-    }
-
-    private void setMangledName(String name, String prefix) {
-        if (!name.isEmpty() && visitedStructOrVariable(name)) {
-            mangledNames.put(name, prefix + name);
-        }
-    }
-
-    protected void setMangledName(Declaration.Scoped d) {
-        switch (d.kind()) {
-            case STRUCT:
-                setMangledName(d.name(), "struct$");
-                break;
-            case UNION:
-                setMangledName(d.name(), "union$");
-                break;
-        }
-    }
-
-    protected void setMangledName(Declaration.Variable v) {
-        setMangledName(v.name(), "var$");
-    }
-
-    protected String getMangledName(Declaration d) {
-        String name = d.name();
-        return name.isEmpty()? name : mangledNames.getOrDefault(name, name);
-    }
-
-    static JavaFileObject[] generateRaw(Declaration.Scoped decl, String clsName, String pkgName, List<String> libraryNames) {
-        return new HandleSourceFactory(clsName, pkgName, libraryNames).generate(decl);
-    }
-
-    static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String clsName, String pkgName, List<String> libraryNames) {
-        return new StaticWrapperSourceFactory(clsName, pkgName, libraryNames).generate(decl);
-    }
-
-    public HandleSourceFactory(String clsName, String pkgName, List<String> libraryNames) {
-        this.libraryNames = libraryNames;
-        this.clsName = clsName;
-        this.pkgName = pkgName;
-    }
-
-    private static String getCLangConstantsHolder() {
-        String prefix = "jdk.incubator.foreign.MemoryLayouts.";
-        String abi = InternalForeign.getInstancePrivileged().getSystemABI().name();
-        switch (abi) {
-            case SystemABI.ABI_SYSV:
-                return prefix + "SysV";
-            case SystemABI.ABI_WINDOWS:
-                return prefix + "WinABI";
-            case SystemABI.ABI_AARCH64:
-                return prefix + "AArch64ABI";
-            default:
-                throw new UnsupportedOperationException("Unsupported ABI: " + abi);
-        }
-    }
-
-    static final String C_LANG_CONSTANTS_HOLDER = getCLangConstantsHolder();
-
-    public JavaFileObject[] generate(Declaration.Scoped decl) {
-        builder.addPackagePrefix(pkgName);
-        builder.classBegin(clsName);
-        builder.addLibraries(libraryNames.toArray(new String[0]));
-        //generate all decls
-        decl.members().forEach(this::generateDecl);
-
-        //generate functional interfaces
-        generateFunctionalInterfaces(decl);
-
-        builder.classEnd();
-        String src = builder.build();
-
-        URL runtimeHelper = HandleSourceFactory.class.getResource("resources/RuntimeHelper.java.template");
-
-        try {
-            List<JavaFileObject> files = new ArrayList<>();
-            files.add(fileFromString(pkgName, clsName, src));
-            files.add(fileFromString(pkgName,"RuntimeHelper", (pkgName.isEmpty()? "" : "package " + pkgName + ";\n") +
-                            Files.readAllLines(Paths.get(runtimeHelper.toURI()))
-                            .stream().collect(Collectors.joining("\n")).replace("${C_LANG}", C_LANG_CONSTANTS_HOLDER)));
-            files.add(getCstringFile(pkgName));
-            files.addAll(getPrimitiveTypeFiles(pkgName));
-            return files.toArray(new JavaFileObject[0]);
-        } catch (IOException ex) {
-            throw new UncheckedIOException(ex);
-        } catch (URISyntaxException ex2) {
-            throw new RuntimeException(ex2);
-        }
-    }
-
-    protected void generateFunctionalInterfaces(Declaration.Scoped decl) {
-        //generate functional interfaces
-        Set<FunctionDescriptor> functionalInterfaces = new HashSet<>();
-        new FunctionalInterfaceScanner(functionalInterfaces).scan(decl);
-        functionalInterfaces.forEach(builder::addUpcallFactory);
-    }
-
-    private void generateDecl(Declaration tree) {
-        try {
-            tree.accept(this, null);
-        } catch (Exception ex) {
-            ex.printStackTrace();
-        }
-    }
-
-    private JavaFileObject getCstringFile(String pkgName) throws IOException, URISyntaxException {
-        var cstringFile = HandleSourceFactory.class.getResource("resources/Cstring.java.template");
-        var lines = Files.readAllLines(Paths.get(cstringFile.toURI()));
-        String pkgPrefix = pkgName.isEmpty()? "" : "package " + pkgName + ";\n";
-        String contents =  pkgPrefix +
-                lines.stream().collect(Collectors.joining("\n"));
-        return fileFromString(pkgName,"Cstring", contents);
-    }
-
-    private List<JavaFileObject> getPrimitiveTypeFiles(String pkgName) throws IOException, URISyntaxException {
-        var abi = InternalForeign.getInstancePrivileged().getSystemABI();
-        var cXJavaFile = HandleSourceFactory.class.getResource("resources/C-X.java.template");
-        var lines = Files.readAllLines(Paths.get(cXJavaFile.toURI()));
-
-        List<JavaFileObject> files = new ArrayList<>();
-        String pkgPrefix = pkgName.isEmpty()? "" : "package " + pkgName + ";\n";
-        for (SystemABI.Type type : SystemABI.Type.values()) {
-            // FIXME: ignore pointer and complex type
-            if (type == SystemABI.Type.POINTER || type == SystemABI.Type.COMPLEX_LONG_DOUBLE) {
-                continue;
-            }
-
-            String typeName = type.name().toLowerCase();
-            MemoryLayout layout = abi.layoutFor(type).get();
-            String contents =  pkgPrefix +
-                    lines.stream().collect(Collectors.joining("\n")).
-                            replace("-X", typeName).
-                            replace("${C_LANG}", C_LANG_CONSTANTS_HOLDER).
-                            replace("${LAYOUT}", TypeTranslator.typeToLayoutName(type)).
-                            replace("${CARRIER}", classForType(type, layout).getName());
-            files.add(fileFromString(pkgName,"C" + typeName, contents));
-        }
-        return files;
-    }
-
-    private static Class<?> classForType(SystemABI.Type type, MemoryLayout layout) {
-        boolean isFloat = switch(type) {
-            case FLOAT, DOUBLE, LONG_DOUBLE -> true;
-            default-> false;
-        };
-        return TypeTranslator.layoutToClass(isFloat, layout);
-    }
-
-    private JavaFileObject fileFromString(String pkgName, String clsName, String contents) {
-        String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
-        return new SimpleJavaFileObject(URI.create(pkgPrefix + clsName + ".java"), JavaFileObject.Kind.SOURCE) {
-            @Override
-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
-                return contents;
-            }
-        };
-    }
-
-    @Override
-    public Void visitVariable(Declaration.Variable tree, Declaration parent) {
-        if (parent == null && visitedVariable(tree)) {
-            return null;
-        }
-
-        String fieldName = tree.name();
-        String symbol = tree.name();
-        assert !symbol.isEmpty();
-        assert !fieldName.isEmpty();
-
-        // FIXME: we need tree transformer. The mangling should be a separate tree transform phase
-        if (parent == null) {
-            setMangledName(tree);
-            fieldName = getMangledName(tree);
-        }
-
-        Type type = tree.type();
-        MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));
-        if (layout == null) {
-            //no layout - abort
-            return null;
-        }
-        Class<?> clazz = typeTranslator.getJavaType(type);
-        if (tree.kind() == Declaration.Variable.Kind.BITFIELD || clazz == MemoryAddress.class ||
-                clazz == MemorySegment.class || layout.byteSize() > 8) {
-            //skip
-            return null;
-        }
-
-        if (parent != null) {
-            //struct field
-            builder.addVarHandle(fieldName, clazz, getMangledName(parent));
-        } else {
-            builder.addLayout(fieldName, layout);
-            builder.addVarHandle(fieldName, clazz, null);
-            builder.addAddress(fieldName);
-        }
-
-        return null;
-    }
-
-    @Override
-    public Void visitFunction(Declaration.Function funcTree, Declaration parent) {
-        if (visitedFunction(funcTree)) {
-            return null;
-        }
-
-        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);
-        if (descriptor == null) {
-            //abort
-        }
-        MethodType mtype = typeTranslator.getMethodType(funcTree.type());
-        builder.addMethodHandle(funcTree, mtype, descriptor);
-        return null;
-    }
-
-    @Override
-    public Void visitConstant(Declaration.Constant constant, Declaration parent) {
-        if (!constants.add(constant.name())) {
-            //skip
-            return null;
-        }
-
-        builder.addConstant(constant.name(), typeTranslator.getJavaType(constant.type()), constant.value());
-        return null;
-    }
-
-    @Override
-    public Void visitScoped(Declaration.Scoped d, Declaration parent) {
-        if (d.kind() == Declaration.Scoped.Kind.TYPEDEF) {
-            return d.members().get(0).accept(this, d);
-        }
-        if (d.layout().isEmpty()) {
-            //skip decl-only
-            return null;
-        }
-        String name = d.name();
-        // FIXME: we need tree transformer. The mangling should be a separate tree transform phase
-        if (d.name().isEmpty() && parent != null) {
-            name = getMangledName(parent);
-        } else {
-            setMangledName(d);
-            name = getMangledName(d);
-        }
-        if (!d.name().isEmpty() || !isRecord(parent)) {
-            //only add explicit struct layout if the struct is not to be flattened inside another struct
-            switch (d.kind()) {
-                case STRUCT:
-                case UNION: {
-                    builder.addLayout(name, d.layout().get());
-                    break;
-                }
-            }
-        }
-        d.members().forEach(fieldTree -> fieldTree.accept(this, d.name().isEmpty() ? parent : d));
-        return null;
-    }
-
-    private boolean isRecord(Declaration declaration) {
-        if (declaration == null) {
-            return false;
-        } else if (!(declaration instanceof Declaration.Scoped)) {
-            return false;
-        } else {
-            Declaration.Scoped scope = (Declaration.Scoped)declaration;
-            return scope.kind() == Declaration.Scoped.Kind.CLASS ||
-                    scope.kind() == Declaration.Scoped.Kind.STRUCT ||
-                    scope.kind() == Declaration.Scoped.Kind.UNION;
-        }
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
@@ -22,354 +22,123 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.incubator.jextract.tool;
 
-import jdk.incubator.jextract.Declaration;
 import jdk.incubator.foreign.FunctionDescriptor;
-import jdk.incubator.foreign.GroupLayout;
-import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.SequenceLayout;
-import jdk.incubator.foreign.SystemABI;
-import jdk.incubator.foreign.ValueLayout;
-import jdk.internal.foreign.InternalForeign;
 
+import javax.tools.JavaFileObject;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.DirectMethodHandleDesc;
 import java.lang.invoke.MethodType;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-import javax.lang.model.SourceVersion;
-
-import static jdk.incubator.foreign.SystemABI.NATIVE_TYPE;
 
 /**
  * A helper class to generate header interface class in source form.
  * After aggregating various constituents of a .java source, build
  * method is called to get overall generated source string.
  */
 class JavaSourceBuilder {
-    private static final String ABI = InternalForeign.getInstancePrivileged().getSystemABI().name();
+
+    private static final String PUB_CLS_MODS = "public final ";
+    private static final String PUB_MODS = "public static final ";
+
+    private final String pkgName;
+    private final String[] libraryNames;
     // buffer
     protected StringBuffer sb;
     // current line alignment (number of 4-spaces)
     protected int align;
 
-    JavaSourceBuilder(int align) {
+    private String className = null;
+    private ConstantHelper constantHelper;
+
+    JavaSourceBuilder(int align, String pkgName, String[] libraryNames) {
         this.align = align;
+        this.libraryNames = libraryNames;
         this.sb = new StringBuffer();
+        this.pkgName = pkgName;
     }
 
-    JavaSourceBuilder() {
-        this(0);
+    JavaSourceBuilder(String pkgName, String[] libraryNames) {
+        this(0, pkgName, libraryNames);
     }
 
-    protected int align() {
-        return align;
-    }
-
-    final String PUB_CLS_MODS = "public final ";
-    final String PUB_MODS = "public static final ";
-    final String PRI_MODS = "private static final ";
+    public void classBegin(String name) {
+        className = name;
+        String qualName = pkgName.isEmpty() ? name : pkgName + "." + name;
+        constantHelper = new ConstantHelper(qualName,
+                ClassDesc.of(pkgName, "RuntimeHelper"), ClassDesc.of(pkgName, "Cstring"), libraryNames);
 
-    protected void addPackagePrefix(String pkgName) {
-        assert pkgName.indexOf('/') == -1 : "package name invalid: " + pkgName;
-        sb.append("// Generated by jextract\n\n");
-        if (!pkgName.isEmpty()) {
-            sb.append("package ");
-            sb.append(pkgName);
-            sb.append(";\n\n");
-        }
+        addPackagePrefix();
         addImportSection();
-    }
-
-    protected void addImportSection() {
-        sb.append("import java.lang.invoke.MethodHandle;\n");
-        sb.append("import java.lang.invoke.VarHandle;\n");
-        sb.append("import jdk.incubator.foreign.*;\n");
-        sb.append("import jdk.incubator.foreign.MemoryLayout.PathElement;\n");
-        sb.append("import static ");
-        sb.append(HandleSourceFactory.C_LANG_CONSTANTS_HOLDER);
-        sb.append(".*;\n");
-    }
 
-    protected void classBegin(String name) {
         indent();
         sb.append(PUB_CLS_MODS + "class ");
         sb.append(name);
         sb.append(" {\n\n");
     }
 
-    protected void classEnd() {
+    public void classEnd() {
         indent();
         sb.append("}\n\n");
     }
 
-    protected void addLibraries(String[] libraryNames) {
-        incrAlign();
-        indent();
-        sb.append(PRI_MODS + "LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(");
-        sb.append(stringArray(libraryNames) + ");\n");
-        decrAlign();
+    public void addLayoutGetter(String javaName, MemoryLayout layout) {
+        emitForwardGetter(constantHelper.addLayout(javaName, layout));
     }
 
-    private String stringArray(String[] elements) {
-        return Stream.of(elements)
-                .map(n -> "\"" + n + "\"")
-                .collect(Collectors.joining(",", "new String[] {", "}"));
+    public void addVarHandleGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        emitForwardGetter(constantHelper.addVarHandle(javaName, nativeName, layout, type, parentLayout));
     }
 
-    protected void addLayout(String elementName, MemoryLayout layout) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + "MemoryLayout " + javaSafeIdentifier(elementName) + "$LAYOUT = ");
-        addLayout(layout);
-        sb.append(";\n");
-        decrAlign();
+    public void addMethodHandleGetter(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
+        emitForwardGetter(constantHelper.addMethodHandle(javaName, nativeName, mtype, desc, varargs));
     }
 
-    private void addLayout(MemoryLayout l) {
-        if (l instanceof ValueLayout) {
-            SystemABI.Type type = l.attribute(NATIVE_TYPE)
-                                   .map(SystemABI.Type.class::cast)
-                                   .orElseThrow(()->new AssertionError("Should not get here: " + l));
-            sb.append(TypeTranslator.typeToLayoutName(type));
-        } else if (l instanceof SequenceLayout) {
-            sb.append("MemoryLayout.ofSequence(");
-            if (((SequenceLayout) l).elementCount().isPresent()) {
-                sb.append(((SequenceLayout) l).elementCount().getAsLong() + ", ");
-            }
-            addLayout(((SequenceLayout) l).elementLayout());
-            sb.append(")");
-        } else if (l instanceof GroupLayout) {
-            SystemABI.Type type = l.attribute(NATIVE_TYPE)
-                                   .map(SystemABI.Type.class::cast)
-                                   .orElse(null);
-            if (type == SystemABI.Type.COMPLEX_LONG_DOUBLE) {
-                if (!ABI.equals(SystemABI.ABI_SYSV)) {
-                    throw new RuntimeException("complex long double is supported only for SysV ABI");
-                } else {
-                    sb.append("C_COMPLEX_LONGDOUBLE");
-                }
-            } else {
-                if (((GroupLayout) l).isStruct()) {
-                    sb.append("MemoryLayout.ofStruct(\n");
-                } else {
-                    sb.append("MemoryLayout.ofUnion(\n");
-                }
-                incrAlign();
-                String delim = "";
-                for (MemoryLayout e : ((GroupLayout) l).memberLayouts()) {
-                    sb.append(delim);
-                    indent();
-                    addLayout(e);
-                    delim = ",\n";
-                }
-                sb.append("\n");
-                decrAlign();
-                indent();
-                sb.append(")");
-            }
-        } else {
-            //padding
-            sb.append("MemoryLayout.ofPaddingBits(" + l.bitSize() + ")");
-        }
-        if (l.name().isPresent()) {
-            sb.append(".withName(\"" +  l.name().get() + "\")");
-        }
+    public void addAddressGetter(String javaName, String nativeName) {
+        emitForwardGetter(constantHelper.addAddress(javaName, nativeName));
     }
 
-    protected void addVarHandle(String name, Class<?> type, String parentName) {
-        incrAlign();
-        indent();
-        parentName = parentName != null? javaSafeIdentifier(parentName) : parentName;
-        name = javaSafeIdentifier(name);
-        String vhName = parentName != null ?
-                parentName + "$" + name : name;
-        sb.append(PUB_MODS + "VarHandle " + vhName + " = ");
-        if (parentName != null) {
-            addHandlePath(type, parentName, name);
-        } else {
-            addHandlePath(type, name);
-        }
-        sb.append(";\n");
-        decrAlign();
-    }
-
-    protected void addHandlePath(Class<?> type, String strName, String fieldName) {
-        String ty = type.getName();
-        boolean isAddress = ty.contains("MemoryAddress");
-        if (isAddress) {
-            sb.append("MemoryHandles.asAddressVarHandle(");
-            ty = "long";
-        }
-        sb.append(strName + "$LAYOUT.varHandle(" + ty + ".class, ");
-        sb.append("PathElement.groupElement(\"" + fieldName +"\")");
-        sb.append(")");
-        if (isAddress) {
-            sb.append(")");
-        }
+    public void addConstantGetter(String javaName, Class<?> type, Object value) {
+        emitForwardGetter(constantHelper.addConstant(javaName, type, value));
     }
 
-    protected void addHandlePath(Class<?> type, String varName) {
-        String ty = type.getName();
-        boolean isAddress = ty.contains("MemoryAddress");
-        if (isAddress) {
-            sb.append("MemoryHandles.asAddressVarHandle(");
-            ty = "long";
-        }
-        sb.append(varName + "$LAYOUT.varHandle(" + ty + ".class)");
-        if (isAddress) {
-            sb.append(")");
-        }
-    }
-
-    protected void addMethodHandle(Declaration.Function funcTree, MethodType mtype, FunctionDescriptor desc) {
+    public void addFunctionalFactory(String className, MethodType mtype, FunctionDescriptor fDesc) {
         incrAlign();
         indent();
-        sb.append(PUB_MODS + "MethodHandle " + javaSafeIdentifier(funcTree.name()) + " = ");
-        sb.append("RuntimeHelper.downcallHandle(\n");
+        sb.append(PUB_MODS + "MemoryAddress " + className + "$make(" + className + " fi) {\n");
         incrAlign();
         indent();
-        sb.append("LIBRARIES, \"" + funcTree.name() + "\"");
-        sb.append(",\n");
-        indent();
-        sb.append("\"" + mtype.toMethodDescriptorString() + "\",\n");
-        indent();
-        addFunction(desc);
-        sb.append(",\n");
-        indent();
-        sb.append(funcTree.type().varargs());
-        decrAlign();
-        sb.append("\n");
-        indent();
-        sb.append(");\n");
-        decrAlign();
-    }
-
-    protected void addAddressLookup(String name) {
-        sb.append("RuntimeHelper.lookupGlobalVariable(LIBRARIES, \"" + name + "\")");
-    }
-
-    private void addFunction(FunctionDescriptor f) {
-        final boolean noArgs = f.argumentLayouts().isEmpty();
-        if (f.returnLayout().isPresent()) {
-            sb.append("FunctionDescriptor.of(");
-            addLayout(f.returnLayout().get());
-            if (!noArgs) {
-                sb.append(", ");
-            }
-        } else {
-            sb.append("FunctionDescriptor.ofVoid(");
-        }
-        if (!noArgs) {
-            sb.append("\n");
-            incrAlign();
-            String delim = "";
-            for (MemoryLayout e : f.argumentLayouts()) {
-                sb.append(delim);
-                indent();
-                addLayout(e);
-                delim = ",\n";
-            }
-            sb.append("\n");
-            decrAlign();
-            indent();
-        }
-        sb.append(")");
-    }
-
-    protected void addAddress(String name) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + "MemoryAddress " + javaSafeIdentifier(name) + "$ADDR" + " = ");
-        addAddressLookup(name);
-        sb.append(";\n");
-        decrAlign();
-    }
-
-    protected void addConstant(String name, Class<?> type, Object value) {
-        incrAlign();
-        indent();
-        if (type == MemoryAddress.class || type == MemorySegment.class) {
-            //todo, skip for now (address constants and string constants)
-        } else {
-            sb.append(PUB_MODS + type.getName() + " " + javaSafeIdentifier(name));
-            sb.append(" = ");
-            if (type == float.class) {
-                float f = ((Number)value).floatValue();
-                if (Float.isNaN(f)) {
-                    sb.append("Float.NaN");
-                } else if (Float.isInfinite(f)) {
-                    sb.append(f > 0? "Float.POSITIVE_INFINITY" : "Float.NEGATIVE_INFINITY");
-                } else {
-                    sb.append(value);
-                    sb.append("f");
-                }
-            } else if (type == long.class) {
-                sb.append(value);
-                sb.append("L");
-            } else if (type == double.class) {
-                double d = ((Number)value).doubleValue();
-                if (Double.isNaN(d)) {
-                    sb.append("Double.NaN");
-                } else if (Double.isInfinite(d)) {
-                    sb.append(d > 0? "Double.POSITIVE_INFINITY" : "Double.NEGATIVE_INFINITY");
-                } else {
-                   sb.append(value);
-                   sb.append("d");
-                }
-            } else {
-                sb.append("(" + type.getName() + ")");
-                sb.append(value + "L");
-            }
-            sb.append(";\n");
-        }
-
-        decrAlign();
-    }
-
-    static int funcIntfCounter = 0;
-
-    protected void addUpcallFactory(FunctionDescriptor desc) {
-        String fnName = "FI" + funcIntfCounter++;
-        incrAlign();
-        indent();
-        sb.append(PRI_MODS + "FunctionDescriptor " + fnName + "$DESC = ");
-        addFunction(desc);
-        sb.append(";\n");
-        indent();
-        sb.append(PUB_MODS + "MemoryAddress " + fnName + "$make(MethodHandle handle) {\n");
-        incrAlign();
-        indent();
-        sb.append("return RuntimeHelper.upcallStub(handle, " + fnName + "$DESC);\n");
+        sb.append("return RuntimeHelper.upcallStub(" + className + ".class, fi, " + functionGetCallString(className, fDesc) + ", " +
+                "\"" + mtype.toMethodDescriptorString() + "\");\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
-    protected void addStaticFunctionWrapper(Declaration.Function f, MethodType mtype) {
+    public void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {
         incrAlign();
         indent();
-        sb.append(PUB_MODS + mtype.returnType().getName() + " " + javaSafeIdentifier(f.name()) + " (");
+        sb.append(PUB_MODS + mtype.returnType().getName() + " " + javaName + " (");
         String delim = "";
         List<String> pNames = new ArrayList<>();
-        final int numParams = f.parameters().size();
+        final int numParams = paramNames.size();
         for (int i = 0 ; i < numParams; i++) {
-            String pName = f.parameters().get(i).name();
+            String pName = paramNames.get(i);
             if (pName.isEmpty()) {
                 pName = "x" + i;
             }
-            pName = javaSafeIdentifier(pName);
             pNames.add(pName);
             sb.append(delim + mtype.parameterType(i).getName() + " " + pName);
             delim = ", ";
         }
-        if (f.type().varargs()) {
+        if (varargs) {
             String lastArg = "x" + numParams;
             if (numParams > 0) {
                 sb.append(", ");
             }
             sb.append("Object... " + lastArg);
@@ -382,11 +151,11 @@
         incrAlign();
         indent();
         if (!mtype.returnType().equals(void.class)) {
             sb.append("return (" + mtype.returnType().getName() + ")");
         }
-        sb.append(f.name() + ".invokeExact(" + String.join(", ", pNames) + ");\n");
+        sb.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + ".invokeExact(" + String.join(", ", pNames) + ");\n");
         decrAlign();
         indent();
         sb.append("} catch (Throwable ex) {\n");
         incrAlign();
         indent();
@@ -398,24 +167,14 @@
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
-    void addDescriptor(String name, FunctionDescriptor desc) {
+    public void addFunctionalInterface(String name, MethodType mtype) {
         incrAlign();
         indent();
-        sb.append(PRI_MODS + "FunctionDescriptor " + name + "$DESC = ");
-        addFunction(desc);
-        sb.append(";\n");
-        decrAlign();
-        indent();
-    }
-
-    void addFunctionalInterface(String name, MethodType mtype) {
-        incrAlign();
-        indent();
-        sb.append("public interface " + javaSafeIdentifier(name) + " {\n");
+        sb.append("public interface " + name + " {\n");
         incrAlign();
         indent();
         sb.append(mtype.returnType().getName() + " apply(");
         String delim = "";
         for (int i = 0 ; i < mtype.parameterCount() ; i++) {
@@ -428,83 +187,120 @@
         sb.append("}\n");
         decrAlign();
         indent();
     }
 
-    protected void addFunctionalFactory(String name, MethodType mtype) {
+    public void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
         incrAlign();
         indent();
-        sb.append(PUB_MODS + "MemoryAddress " + name + "$make(" + name + " fi) {\n");
+        String param = parentLayout != null ? (MemorySegment.class.getName() + " seg") : "";
+        sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(" + param + ") {\n");
         incrAlign();
         indent();
-        sb.append("return RuntimeHelper.upcallStub(" + name + ".class, fi, " + name + "$DESC, " +
-                "\"" + mtype.toMethodDescriptorString() + "\");\n");
+        String vhParam = parentLayout != null ?
+                "seg.baseAddress()" : addressGetCallString(javaName, nativeName);
+        sb.append("return (" + type.getName() + ")"
+                + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(" + vhParam + ");\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
-    void addGetter(String name, Class<?> type, String parent) {
+    public void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
         incrAlign();
         indent();
-        name = javaSafeIdentifier(name);
-        String vhName = (parent != null ? (javaSafeIdentifier(parent) + "$") : "") + name;
-        String param = parent != null ? (MemorySegment.class.getName() + " seg") : "";
-        sb.append(PUB_MODS + type.getName() + " " + vhName + "$get(" + param + ") {\n");
+        String param = parentLayout != null ? (MemorySegment.class.getName() + " seg, ") : "";
+        sb.append(PUB_MODS + "void " + javaName + "$set(" + param + type.getName() + " x) {\n");
         incrAlign();
         indent();
-        String vhParam = parent != null ?
-                "seg.baseAddress()" : name + "$ADDR";
-        sb.append("return (" + type.getName() + ")" + vhName + ".get(" + vhParam + ");\n");
+        String vhParam = parentLayout != null ?
+                "seg.baseAddress()" : addressGetCallString(javaName, nativeName);
+        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".set(" + vhParam + ", x);\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
-    void addSetter(String name, Class<?> type, String parent) {
+    public List<JavaFileObject> build() {
+        String res = sb.toString();
+        this.sb = null;
+        List<JavaFileObject> outputs = new ArrayList<>(constantHelper.getClasses());
+        outputs.add(Utils.fileFromString(pkgName, className, res));
+        return outputs;
+    }
+
+    // Utility
+
+    private void addPackagePrefix() {
+        assert pkgName.indexOf('/') == -1 : "package name invalid: " + pkgName;
+        sb.append("// Generated by jextract\n\n");
+        if (!pkgName.isEmpty()) {
+            sb.append("package ");
+            sb.append(pkgName);
+            sb.append(";\n\n");
+        }
+    }
+
+    private void addImportSection() {
+        sb.append("import java.lang.invoke.MethodHandle;\n");
+        sb.append("import java.lang.invoke.VarHandle;\n");
+        sb.append("import jdk.incubator.foreign.*;\n");
+        sb.append("import jdk.incubator.foreign.MemoryLayout.PathElement;\n");
+        sb.append("import static ");
+        sb.append(OutputFactory.C_LANG_CONSTANTS_HOLDER);
+        sb.append(".*;\n");
+    }
+
+    private void emitForwardGetter(DirectMethodHandleDesc desc) {
         incrAlign();
         indent();
-        name = javaSafeIdentifier(name);
-        String vhName = (parent != null ? (javaSafeIdentifier(parent) + "$") : "") + name;
-        String param = parent != null ? (MemorySegment.class.getName() + " seg, ") : "";
-        sb.append(PUB_MODS + "void " + vhName + "$set(" + param + type.getName() + " x) {\n");
+        sb.append(PUB_MODS + displayName(desc.invocationType().returnType()) + " " + desc.methodName() + "() {\n");
         incrAlign();
         indent();
-        String vhParam = parent != null ?
-                "seg.baseAddress()" : name + "$ADDR";
-        sb.append(vhName + ".set(" + vhParam + ", x);\n");
+        sb.append("return " + getCallString(desc) + ";\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
-    protected String build() {
-        String res = sb.toString();
-        this.sb = null;
-        return res.toString();
+    private String getCallString(DirectMethodHandleDesc desc) {
+        return desc.owner().displayName() + "." + desc.methodName() + "()";
+    }
+
+    private String displayName(ClassDesc returnType) {
+        return returnType.displayName(); // TODO shorten based on imports
+    }
+
+    private String functionGetCallString(String javaName, FunctionDescriptor fDesc) {
+        return getCallString(constantHelper.addFunctionDesc(javaName, fDesc));
     }
 
-    protected void indent() {
+    private String methodHandleGetCallString(String javaName, String nativeName, MethodType mt, FunctionDescriptor fDesc, boolean varargs) {
+        return getCallString(constantHelper.addMethodHandle(javaName, nativeName, mt, fDesc, varargs));
+    }
+
+    private String varHandleGetCallString(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        return getCallString(constantHelper.addVarHandle(javaName, nativeName, layout, type, parentLayout));
+    }
+
+    private String addressGetCallString(String javaName, String nativeName) {
+        return getCallString(constantHelper.addAddress(javaName, nativeName));
+    }
+
+    private void indent() {
         for (int i = 0; i < align; i++) {
             sb.append("    ");
         }
     }
 
-    protected void incrAlign() {
+    private void incrAlign() {
         align++;
     }
 
-    protected void decrAlign() {
+    private void decrAlign() {
         align--;
     }
 
-    protected final String javaSafeIdentifier(String name) {
-        // We never get the problem of Java non-identifiers (like 123, ab-xy) as
-        // C identifiers. But we may have a java keyword used as a C identifier.
-        assert SourceVersion.isIdentifier(name);
-
-        return SourceVersion.isKeyword(name)? (name + "_") : name;
-    }
 }
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Main.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Main.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Main.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Main.java
@@ -28,11 +28,10 @@
 import jdk.incubator.jextract.Declaration;
 import jdk.incubator.jextract.JextractTask;
 import jdk.internal.joptsimple.OptionException;
 import jdk.internal.joptsimple.OptionParser;
 import jdk.internal.joptsimple.OptionSet;
-import jdk.internal.joptsimple.util.KeyValuePair;
 
 import javax.tools.JavaFileObject;
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
@@ -145,11 +144,10 @@
         }
 
         if (optionSet.has("source")) {
             builder.setGenerateSource();
         }
-
         boolean librariesSpecified = optionSet.has("l");
         if (librariesSpecified) {
             for (Object arg : optionSet.valuesOf("l")) {
                 String lib = (String)arg;
                 if (lib.indexOf(File.separatorChar) != -1) {
@@ -185,11 +183,11 @@
                 System.out.println(toplevel);
             }
 
             Path output = Path.of(options.outputDir);
 
-            JavaFileObject[] files = HandleSourceFactory.generateWrapped(
+            JavaFileObject[] files = OutputFactory.generateWrapped(
                 toplevel,
                 header.getFileName().toString().replace(".h", "_h"),
                 options.targetPackage,
                 options.libraryNames);
             jextractTask.write(output, files);
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Options.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Options.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Options.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Options.java
@@ -73,11 +73,11 @@
             this.clangArgs = new ArrayList<>();
             this.libraryNames = new ArrayList<>();
             this.filters = new ArrayList<>();
             this.targetPackage = "";
             this.outputDir = ".";
-            this.source = source;
+            this.source = false;
         }
 
         public Options build() {
             return new Options(
                     Collections.unmodifiableList(clangArgs),
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
@@ -0,0 +1,398 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.incubator.jextract.tool;
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Type;
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SystemABI;
+import jdk.internal.foreign.InternalForeign;
+
+import javax.tools.JavaFileObject;
+import javax.tools.SimpleJavaFileObject;
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.lang.invoke.MethodType;
+import java.net.URI;
+import java.net.URL;
+import java.net.URISyntaxException;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/*
+ * Scan a header file and generate Java source items for entities defined in that header
+ * file. Tree visitor visit methods return true/false depending on whether a
+ * particular Tree is processed or skipped.
+ */
+public class OutputFactory implements Declaration.Visitor<Void, Declaration> {
+    private final Set<String> constants = new HashSet<>();
+    // To detect duplicate Variable and Function declarations.
+    private final Set<Declaration.Variable> variables = new HashSet<>();
+    private final Set<Declaration.Function> functions = new HashSet<>();
+
+    private final Set<String> structsAndVars = new HashSet<>();
+    private final Map<String, String> mangledNames = new HashMap<>();
+
+    protected final JavaSourceBuilder builder;
+    protected final TypeTranslator typeTranslator = new TypeTranslator();
+    private final String clsName;
+    private final String pkgName;
+
+    // have we seen this Variable earlier?
+    protected boolean variableSeen(Declaration.Variable tree) {
+        return !variables.add(tree);
+    }
+
+    // have we seen this Function earlier?
+    protected boolean functionSeen(Declaration.Function tree) {
+        return !functions.add(tree);
+    }
+
+    // have we visited a struct/union or a global variable of given name?
+    protected boolean structOrVariableSeen(String name) {
+        return !structsAndVars.add(name);
+    }
+
+    private void setMangledName(String name, String prefix) {
+        if (!name.isEmpty() && structOrVariableSeen(name)) {
+            mangledNames.put(name, prefix + name);
+        }
+    }
+
+    protected void setMangledName(Declaration.Scoped d) {
+        switch (d.kind()) {
+            case STRUCT:
+                setMangledName(d.name(), "struct$");
+                break;
+            case UNION:
+                setMangledName(d.name(), "union$");
+                break;
+        }
+    }
+
+    protected void setMangledName(Declaration.Variable v) {
+        setMangledName(v.name(), "var$");
+    }
+
+    protected String getMangledName(Declaration d) {
+        String name = d.name();
+        return name.isEmpty()? name : mangledNames.getOrDefault(name, name);
+    }
+
+    static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String clsName, String pkgName, List<String> libraryNames) {
+        return new OutputFactory(clsName, pkgName, libraryNames,
+                new JavaSourceBuilder(pkgName, libraryNames.toArray(String[]::new))).generate(decl);
+    }
+
+    public OutputFactory(String clsName, String pkgName, List<String> libraryNames, JavaSourceBuilder builder) {
+        this.clsName = clsName;
+        this.pkgName = pkgName;
+        this.builder = builder;
+    }
+
+    private static String getCLangConstantsHolder() {
+        String prefix = "jdk.incubator.foreign.MemoryLayouts.";
+        String abi = InternalForeign.getInstancePrivileged().getSystemABI().name();
+        switch (abi) {
+            case SystemABI.ABI_SYSV:
+                return prefix + "SysV";
+            case SystemABI.ABI_WINDOWS:
+                return prefix + "WinABI";
+            case SystemABI.ABI_AARCH64:
+                return prefix + "AArch64ABI";
+            default:
+                throw new UnsupportedOperationException("Unsupported ABI: " + abi);
+        }
+    }
+
+    static final String C_LANG_CONSTANTS_HOLDER = getCLangConstantsHolder();
+
+    public JavaFileObject[] generate(Declaration.Scoped decl) {
+        builder.classBegin(clsName);
+        //generate all decls
+        decl.members().forEach(this::generateDecl);
+
+        builder.classEnd();
+        List<JavaFileObject> outputs = builder.build();
+        try {
+            List<JavaFileObject> files = new ArrayList<>(outputs);
+            files.add(fileFromString(pkgName,"RuntimeHelper", getRuntimeHelperSource()));
+            files.add(getCstringFile(pkgName));
+            files.addAll(getPrimitiveTypeFiles(pkgName));
+            return files.toArray(new JavaFileObject[0]);
+        } catch (IOException ex) {
+            throw new UncheckedIOException(ex);
+        } catch (URISyntaxException ex2) {
+            throw new RuntimeException(ex2);
+        }
+    }
+
+    private String getRuntimeHelperSource() throws URISyntaxException, IOException {
+        URL runtimeHelper = OutputFactory.class.getResource("resources/RuntimeHelper.java.template");
+        return (pkgName.isEmpty()? "" : "package " + pkgName + ";\n") +
+                        String.join("\n", Files.readAllLines(Paths.get(runtimeHelper.toURI())))
+                                .replace("${C_LANG}", C_LANG_CONSTANTS_HOLDER);
+    }
+
+    private void generateDecl(Declaration tree) {
+        try {
+            tree.accept(this, null);
+        } catch (Exception ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    private JavaFileObject getCstringFile(String pkgName) throws IOException, URISyntaxException {
+        var cstringFile = OutputFactory.class.getResource("resources/Cstring.java.template");
+        var lines = Files.readAllLines(Paths.get(cstringFile.toURI()));
+        String pkgPrefix = pkgName.isEmpty()? "" : "package " + pkgName + ";\n";
+        String contents =  pkgPrefix +
+                lines.stream().collect(Collectors.joining("\n"));
+        return fileFromString(pkgName,"Cstring", contents);
+    }
+
+    private List<JavaFileObject> getPrimitiveTypeFiles(String pkgName) throws IOException, URISyntaxException {
+        var abi = InternalForeign.getInstancePrivileged().getSystemABI();
+        var cXJavaFile = OutputFactory.class.getResource("resources/C-X.java.template");
+        var lines = Files.readAllLines(Paths.get(cXJavaFile.toURI()));
+
+        List<JavaFileObject> files = new ArrayList<>();
+        String pkgPrefix = pkgName.isEmpty()? "" : "package " + pkgName + ";\n";
+        for (SystemABI.Type type : SystemABI.Type.values()) {
+            // FIXME: ignore pointer and complex type
+            if (type == SystemABI.Type.POINTER || type == SystemABI.Type.COMPLEX_LONG_DOUBLE) {
+                continue;
+            }
+
+            String typeName = type.name().toLowerCase();
+            MemoryLayout layout = abi.layoutFor(type).get();
+            String contents =  pkgPrefix +
+                    lines.stream().collect(Collectors.joining("\n")).
+                            replace("-X", typeName).
+                            replace("${C_LANG}", C_LANG_CONSTANTS_HOLDER).
+                            replace("${LAYOUT}", TypeTranslator.typeToLayoutName(type)).
+                            replace("${CARRIER}", classForType(type, layout).getName());
+            files.add(fileFromString(pkgName,"C" + typeName, contents));
+        }
+        return files;
+    }
+
+    private static Class<?> classForType(SystemABI.Type type, MemoryLayout layout) {
+        boolean isFloat = switch(type) {
+            case FLOAT, DOUBLE, LONG_DOUBLE -> true;
+            default-> false;
+        };
+        return TypeTranslator.layoutToClass(isFloat, layout);
+    }
+
+    private JavaFileObject fileFromString(String pkgName, String clsName, String contents) {
+        String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
+        return new SimpleJavaFileObject(URI.create(pkgPrefix + clsName + ".java"), JavaFileObject.Kind.SOURCE) {
+            @Override
+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
+                return contents;
+            }
+        };
+    }
+
+    @Override
+    public Void visitConstant(Declaration.Constant constant, Declaration parent) {
+        if (!constants.add(constant.name())) {
+            //skip
+            return null;
+        }
+
+        builder.addConstantGetter(Utils.javaSafeIdentifier(constant.name()), typeTranslator.getJavaType(constant.type()), constant.value());
+        return null;
+    }
+
+    @Override
+    public Void visitScoped(Declaration.Scoped d, Declaration parent) {
+        if (d.kind() == Declaration.Scoped.Kind.TYPEDEF) {
+            return d.members().get(0).accept(this, d);
+        }
+        if (d.layout().isEmpty()) {
+            //skip decl-only
+            return null;
+        }
+        String name;
+        // FIXME: we need tree transformer. The mangling should be a separate tree transform phase
+        if (d.name().isEmpty() && parent != null) {
+            name = getMangledName(parent);
+        } else {
+            setMangledName(d);
+            name = getMangledName(d);
+        }
+
+        if (!d.name().isEmpty() || !isRecord(parent)) {
+            //only add explicit struct layout if the struct is not to be flattened inside another struct
+            switch (d.kind()) {
+                case STRUCT:
+                case UNION: {
+                    builder.addLayoutGetter(Utils.javaSafeIdentifier(name), d.layout().get());
+                    break;
+                }
+            }
+        }
+        d.members().forEach(fieldTree -> fieldTree.accept(this, d.name().isEmpty() ? parent : d));
+        return null;
+    }
+
+    @Override
+    public Void visitFunction(Declaration.Function funcTree, Declaration parent) {
+        if (functionSeen(funcTree)) {
+            return null;
+        }
+
+        MethodType mtype = typeTranslator.getMethodType(funcTree.type());
+        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);
+        if (descriptor == null) {
+            //abort
+            return null;
+        }
+        String mhName = Utils.javaSafeIdentifier(funcTree.name());
+        builder.addMethodHandleGetter(mhName, funcTree.name(), mtype, descriptor, funcTree.type().varargs());
+        //generate static wrapper for function
+        List<String> paramNames = funcTree.parameters()
+                                          .stream()
+                                          .map(Declaration.Variable::name)
+                                          .map(p -> !p.isEmpty() ? Utils.javaSafeIdentifier(p) : p)
+                                          .collect(Collectors.toList());
+        builder.addStaticFunctionWrapper(Utils.javaSafeIdentifier(funcTree.name()), funcTree.name(), mtype,
+                Type.descriptorFor(funcTree.type()).orElseThrow(), funcTree.type().varargs(), paramNames);
+        int i = 0;
+        for (Declaration.Variable param : funcTree.parameters()) {
+            Type.Function f = getAsFunctionPointer(param.type());
+            if (f != null) {
+                String name = funcTree.name() + "$" + (param.name().isEmpty() ? "x" + i : param.name());
+                name = Utils.javaSafeIdentifier(name);
+                //generate functional interface
+                MethodType fitype = typeTranslator.getMethodType(f);
+                builder.addFunctionalInterface(name, fitype);
+                //generate helper
+                builder.addFunctionalFactory(name, fitype, Type.descriptorFor(f).orElseThrow());
+                i++;
+            }
+        }
+        return null;
+    }
+
+    Type.Function getAsFunctionPointer(Type type) {
+        if (type instanceof Type.Delegated) {
+            switch (((Type.Delegated) type).kind()) {
+                case POINTER: {
+                    Type pointee = ((Type.Delegated) type).type();
+                    return (pointee instanceof Type.Function) ?
+                        (Type.Function)pointee : null;
+                }
+                default:
+                    return getAsFunctionPointer(((Type.Delegated) type).type());
+            }
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public Void visitVariable(Declaration.Variable tree, Declaration parent) {
+        if (parent == null && variableSeen(tree)) {
+            return null;
+        }
+
+        String fieldName = tree.name();
+        String symbol = tree.name();
+        assert !symbol.isEmpty();
+        assert !fieldName.isEmpty();
+
+        // FIXME: we need tree transformer. The mangling should be a separate tree transform phase
+        if (parent == null) {
+            setMangledName(tree);
+            fieldName = getMangledName(tree);
+        }
+        fieldName = Utils.javaSafeIdentifier(fieldName);
+
+        Type type = tree.type();
+        MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));
+        if (layout == null) {
+            //no layout - abort
+            return null;
+        }
+        Class<?> clazz = typeTranslator.getJavaType(type);
+        if (tree.kind() == Declaration.Variable.Kind.BITFIELD || clazz == MemoryAddress.class ||
+                clazz == MemorySegment.class || layout.byteSize() > 8) {
+            //skip
+            return null;
+        }
+
+        MemoryLayout treeLayout = tree.layout().orElseThrow();
+        if (parent != null) { //struct field
+            Declaration.Scoped parentC = (Declaration.Scoped) parent;
+            String parentName = Utils.javaSafeIdentifier(getMangledName(parentC));
+            fieldName = parentName + "$" + fieldName;
+            MemoryLayout parentLayout = parentLayout(parentC);
+            builder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+            builder.addGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+            builder.addSetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+        } else {
+            builder.addLayoutGetter(fieldName, layout);
+            builder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, null);
+            builder.addAddressGetter(fieldName, tree.name());
+            builder.addGetter(fieldName, tree.name(), treeLayout, clazz, null);
+            builder.addSetter(fieldName, tree.name(), treeLayout, clazz, null);
+        }
+
+        return null;
+    }
+
+    private boolean isRecord(Declaration declaration) {
+        if (declaration == null) {
+            return false;
+        } else if (!(declaration instanceof Declaration.Scoped)) {
+            return false;
+        } else {
+            Declaration.Scoped scope = (Declaration.Scoped)declaration;
+            return scope.kind() == Declaration.Scoped.Kind.CLASS ||
+                    scope.kind() == Declaration.Scoped.Kind.STRUCT ||
+                    scope.kind() == Declaration.Scoped.Kind.UNION;
+        }
+    }
+
+    protected static MemoryLayout parentLayout(Declaration.Scoped parent) {
+        // case like `typedef struct { ... } Foo`
+        return (parent.kind() == Declaration.Scoped.Kind.TYPEDEF
+            ? (Declaration.Scoped) parent.members().get(0)
+            : parent).layout().orElseThrow();
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StaticWrapperSourceFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StaticWrapperSourceFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StaticWrapperSourceFactory.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package jdk.incubator.jextract.tool;
-
-import java.lang.invoke.MethodType;
-import java.util.List;
-import jdk.incubator.foreign.FunctionDescriptor;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.jextract.Declaration;
-import jdk.incubator.jextract.Type;
-
-public class StaticWrapperSourceFactory extends HandleSourceFactory {
-    public StaticWrapperSourceFactory(String clsName, String pkgName, List<String> libraryNames) {
-        super(clsName, pkgName, libraryNames);
-    }
-
-    @Override
-    protected void generateFunctionalInterfaces(Declaration.Scoped decl) {
-        //do nothing
-    }
-
-    @Override
-    public Void visitFunction(Declaration.Function funcTree, Declaration parent) {
-        if (visitedFunction(funcTree)) {
-            return null;
-        }
-
-        MethodType mtype = typeTranslator.getMethodType(funcTree.type());
-        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);
-        if (descriptor == null) {
-            //abort
-            return null;
-        }
-        builder.addMethodHandle(funcTree, mtype, descriptor);
-        //generate static wrapper for function
-        builder.addStaticFunctionWrapper(funcTree, mtype);
-        int i = 0;
-        for (Declaration.Variable param : funcTree.parameters()) {
-            Type.Function f = getAsFunctionPointer(param.type());
-            if (f != null) {
-                String name = funcTree.name() + "$" + (param.name().isEmpty() ? "x" + i : param.name());
-                //add descriptor constant
-                builder.addDescriptor(name, Type.descriptorFor(f).get());
-                //generate functional interface
-                MethodType fitype = typeTranslator.getMethodType(f);
-                builder.addFunctionalInterface(name, fitype);
-                //generate helper
-                builder.addFunctionalFactory(name, fitype);
-                i++;
-            }
-        }
-        return null;
-    }
-
-    Type.Function getAsFunctionPointer(Type type) {
-        if (type instanceof Type.Delegated) {
-            switch (((Type.Delegated) type).kind()) {
-                case POINTER: {
-                    Type pointee = ((Type.Delegated) type).type();
-                    return (pointee instanceof Type.Function) ?
-                        (Type.Function)pointee : null;
-                }
-                default:
-                    return getAsFunctionPointer(((Type.Delegated) type).type());
-            }
-        } else {
-            return null;
-        }
-    }
-
-    @Override
-    public Void visitVariable(Declaration.Variable tree, Declaration parent) {
-        if (parent == null && visitedVariable(tree)) {
-            return null;
-        }
-
-        String fieldName = tree.name();
-        String symbol = tree.name();
-        assert !symbol.isEmpty();
-        assert !fieldName.isEmpty();
-
-        // FIXME: we need tree transformer. The mangling should be a separate tree transform phase
-        if (parent == null) {
-            setMangledName(tree);
-            fieldName = getMangledName(tree);
-        }
-
-        Type type = tree.type();
-        MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));
-        if (layout == null) {
-            //no layout - abort
-            return null;
-        }
-        Class<?> clazz = typeTranslator.getJavaType(type);
-        if (tree.kind() == Declaration.Variable.Kind.BITFIELD || clazz == MemoryAddress.class ||
-                clazz == MemorySegment.class || layout.byteSize() > 8) {
-            //skip
-            return null;
-        }
-
-        String parentName = parent != null? getMangledName(parent) : null;
-        if (parent != null) {
-            //struct field
-            builder.addVarHandle(fieldName, clazz, parentName);
-        } else {
-            builder.addLayout(fieldName, layout);
-            builder.addVarHandle(fieldName, clazz, null);
-            builder.addAddress(fieldName);
-        }
-        //add getter and setters
-        builder.addGetter(fieldName, clazz, parentName);
-        builder.addSetter(fieldName, clazz, parentName);
-
-        return null;
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Utils.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Utils.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Utils.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.incubator.jextract.tool;
+
+import javax.lang.model.SourceVersion;
+import javax.tools.JavaFileObject;
+import javax.tools.SimpleJavaFileObject;
+import java.io.IOException;
+import java.net.URI;
+
+final class Utils {
+
+    private Utils() {}
+
+    private static URI fileName(String pkgName, String clsName, String extension) {
+        String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
+        return URI.create(pkgPrefix + clsName + extension);
+    }
+
+    static JavaFileObject fileFromString(String pkgName, String clsName, String contents) {
+        return new SimpleJavaFileObject(fileName(pkgName, clsName, ".java"), JavaFileObject.Kind.SOURCE) {
+            @Override
+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
+                return contents;
+            }
+        };
+    }
+
+    static String javaSafeIdentifier(String name) {
+        // We never get the problem of Java non-identifiers (like 123, ab-xy) as
+        // C identifiers. But we may have a java keyword used as a C identifier.
+        assert SourceVersion.isIdentifier(name);
+
+        return SourceVersion.isKeyword(name)? (name + "_") : name;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template
@@ -9,10 +9,11 @@
 import jdk.incubator.foreign.SystemABI;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
+import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
 import java.util.Optional;
 
 import static ${C_LANG}.*;
 
@@ -22,11 +23,11 @@
 
     private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();
 
     private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();
 
-    static final LibraryLookup[] libraries(String[] libNames) {
+    static final LibraryLookup[] libraries(String... libNames) {
         if (libNames.length == 0) {
             return new LibraryLookup[] { LibraryLookup.ofDefault() };
         } else {
             return Arrays.stream(libNames)
                 .map(libName -> LibraryLookup.ofLibrary(MH_LOOKUP, libName))
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Utils.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Utils.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Utils.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Utils.java
@@ -131,11 +131,11 @@
             strcpy(str.baseAddress(), address);
             StringBuilder buf = new StringBuilder();
             byte curr = (byte)BYTE_ARR_VH.get(str.baseAddress(), 0);
             long offset = 0;
             while (curr != 0) {
-                buf.append((char)curr);
+                buf.append((char)curr); // interpreting as UTF-16 ?
                 curr = (byte)BYTE_ARR_VH.get(str.baseAddress(), ++offset);
             }
             return buf.toString();
         }
     }
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Writer.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Writer.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Writer.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Writer.java
@@ -49,11 +49,12 @@
         if (sources.isEmpty()) {
             return List.of();
         } else {
             return InMemoryJavaCompiler.compile(sources, 
                 "--add-modules", "jdk.incubator.foreign",
-                "-d", dest.toAbsolutePath().toString());
+                "-d", dest.toAbsolutePath().toString(),
+                "-cp", dest.toAbsolutePath().toString());
         }
     }
 
     void writeAll(boolean compileSources) throws IOException {
         writeClassFiles(resources());
diff a/test/jdk/tools/jextract/ConstantsTest.java b/test/jdk/tools/jextract/ConstantsTest.java
--- a/test/jdk/tools/jextract/ConstantsTest.java
+++ b/test/jdk/tools/jextract/ConstantsTest.java
@@ -24,16 +24,20 @@
 import org.testng.annotations.AfterTest;
 import org.testng.annotations.BeforeTest;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 import java.nio.file.Path;
+import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.SystemABI.Type;
+
+import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertSame;
 import static org.testng.Assert.assertTrue;
 
 /*
  * @test
  * @modules jdk.incubator.jextract
@@ -61,19 +65,19 @@
     }
 
 
     @Test(dataProvider = "definedConstants")
     public void checkConstantsSignatures(String name, Class<?> type, Object value) {
-        var f = findField(constants, name);
+        var f = findMethod(constants, name);
         assertNotNull(f);
-        assertTrue(f.getType() == type);
+        assertSame(f.getReturnType(), type);
     }
 
     @Test(dataProvider = "definedConstants")
-    public void checkConstantsValues(String name, Class<?> type, Predicate<Object> checker) throws ReflectiveOperationException {
-        Object actual = findField(constants, name).get(null);
-        assertTrue(checker.test(actual));
+    public void checkConstantsValues(String name, Class<?> type, Consumer<Object> checker) throws ReflectiveOperationException {
+        Object actual = findMethod(constants, name).invoke(null);
+        checker.accept(actual);
     }
 
     @Test(dataProvider = "missingConstants")
     public void checkMissingConstants(String name) {
         assertTrue(Stream.of(constants.getDeclaredFields())
@@ -90,20 +94,20 @@
                 { "THREE", int.class, equalsTo(3) },
                 { "FOUR", long.class, equalsTo(4L) },
                 { "FIVE", long.class, equalsTo(5L) },
                 { "SIX", int.class, equalsTo(6) },
                 { "FLOAT_VALUE", float.class, equalsTo(1.32f) },
-                { "DOUBLE_VALUE", double.class, equalsTo(1.32) },
+                { "DOUBLE_VALUE", double.class, (Consumer<Double>) (actual -> assertEquals(actual, 1.32, 0.1)) },
                 { "CHAR_VALUE", int.class, equalsTo(104) }, //integer char constants have type int
                 { "MULTICHAR_VALUE", int.class, equalsTo(26728) },  //integer char constants have type int
                 { "BOOL_VALUE", byte.class, equalsTo((byte)1) },
                 { "SUB", int.class, equalsTo( 7 ) }
         };
     }
 
-    static Predicate<Object> equalsTo(Object that) {
-        return o -> o.equals(that);
+    static Consumer<Object> equalsTo(Object expected) {
+        return actual -> assertEquals(actual, expected);
     }
 
     @DataProvider
     public static Object[][] missingConstants() {
         return new Object[][] {
diff a/test/jdk/tools/jextract/JextractToolRunner.java b/test/jdk/tools/jextract/JextractToolRunner.java
--- a/test/jdk/tools/jextract/JextractToolRunner.java
+++ b/test/jdk/tools/jextract/JextractToolRunner.java
@@ -22,20 +22,22 @@
  */
 
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.lang.invoke.MethodType;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.net.URL;
 import java.net.URLClassLoader;
 import java.nio.file.FileVisitResult;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.SimpleFileVisitor;
 import java.nio.file.attribute.BasicFileAttributes;
+import java.util.Arrays;
 import java.util.Objects;
 import java.util.spi.ToolProvider;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
 import jdk.incubator.foreign.SystemABI;
@@ -111,10 +113,14 @@
             assertTrue(output.trim().matches(regex), "Output does not match regex: " + regex);
             return this;
         }
     }
 
+    protected static JextractResult run(Object... options) {
+        return run(Arrays.stream(options).map(Objects::toString).toArray(String[]::new));
+    }
+
     protected static JextractResult run(String... options) {
         StringWriter writer = new StringWriter();
         PrintWriter pw = new PrintWriter(writer);
         String[] args = new String[options.length + 1];
         int result = JEXTRACT_TOOL.run(pw, pw, options);
@@ -173,21 +179,21 @@
             System.err.println(e);
             return null;
         }
     }
 
-    protected Field checkIntField(Class<?> cls, String name, int value) {
-        Field field = findField(cls, name);
-        assertNotNull(field);
-        assertEquals(field.getType(), int.class);
+    protected Method checkIntGetter(Class<?> cls, String name, int value) {
+        Method method = findMethod(cls, name);
+        assertNotNull(method);
+        assertEquals(method.getReturnType(), int.class);
         try {
-            assertEquals((int)field.get(null), value);
+            assertEquals((int)method.invoke(null), value);
         } catch (Exception exp) {
             System.err.println(exp);
             assertTrue(false, "should not reach here");
         }
-        return field;
+        return method;
     }
 
     protected static Method findMethod(Class<?> cls, String name, Class<?>... argTypes) {
         try {
             return cls.getMethod(name, argTypes);
@@ -209,36 +215,41 @@
             System.err.println(e);
             return null;
         }
     }
 
-    protected Class<?> findClass(Class<?>[] clz, String name) {
+    protected static Class<?> findNestedClass(Class<?> clz, String name) {
+        return findClass(clz.getClasses(), name);
+    }
+
+    protected static Class<?> findClass(Class<?>[] clz, String name) {
         for (Class<?> cls: clz) {
             if (cls.getSimpleName().equals(name)) {
                 return cls;
             }
         }
         return null;
     }
 
+    protected Method checkMethod(Class<?> cls, String name, MethodType type) {
+        return checkMethod(cls, name, type.returnType(), type.parameterArray());
+    }
+
     protected Method checkMethod(Class<?> cls, String name, Class<?> returnType, Class<?>... args) {
-        try {
-            Method m = cls.getDeclaredMethod(name, args);
-            assertTrue(m.getReturnType() == returnType);
-            return m;
-        } catch (NoSuchMethodException nsme) {
-            fail("Expect method " + name);
-        }
-        return null;
+        Method m = findMethod(cls, name, args);
+        assertNotNull(m);
+        assertEquals(m.getReturnType(), returnType);
+        assertEquals(m.getParameterTypes(), args);
+        return m;
     }
 
     protected MemoryLayout findLayout(Class<?> cls, String name) {
-        Field field = findField(cls, name + "$LAYOUT");
-        assertNotNull(field);
-        assertEquals(field.getType(), MemoryLayout.class);
+        Method method = findMethod(cls, name + "$LAYOUT");
+        assertNotNull(method);
+        assertEquals(method.getReturnType(), MemoryLayout.class);
         try {
-            return (MemoryLayout)field.get(null);
+            return (MemoryLayout)method.invoke(null);
         } catch (Exception exp) {
             System.err.println(exp);
             assertTrue(false, "should not reach here");
         }
         return null;
diff a/test/jdk/tools/jextract/RepeatedDeclsTest.java b/test/jdk/tools/jextract/RepeatedDeclsTest.java
--- a/test/jdk/tools/jextract/RepeatedDeclsTest.java
+++ b/test/jdk/tools/jextract/RepeatedDeclsTest.java
@@ -21,11 +21,10 @@
  * questions.
  */
 
 import org.testng.annotations.Test;
 
-import java.lang.reflect.Method;
 import java.nio.file.Path;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
@@ -73,16 +72,16 @@
 
             // check a setter method for "i"
             assertNotNull(findMethod(cls, "i$set", int.class));
 
             // make sure that enum constants are generated fine
-            checkIntField(cls, "R", 0);
-            checkIntField(cls, "G", 1);
-            checkIntField(cls, "B", 2);
-            checkIntField(cls, "C", 0);
-            checkIntField(cls, "M", 1);
-            checkIntField(cls, "Y", 2);
+            checkIntGetter(cls, "R", 0);
+            checkIntGetter(cls, "G", 1);
+            checkIntGetter(cls, "B", 2);
+            checkIntGetter(cls, "C", 0);
+            checkIntGetter(cls, "M", 1);
+            checkIntGetter(cls, "Y", 2);
 
             // check Point layout
             MemoryLayout pointLayout = findLayout(cls, "Point");
             assertNotNull(pointLayout);
             assertTrue(((GroupLayout)pointLayout).isStruct());
diff a/test/jdk/tools/jextract/Test8240181.java b/test/jdk/tools/jextract/Test8240181.java
--- a/test/jdk/tools/jextract/Test8240181.java
+++ b/test/jdk/tools/jextract/Test8240181.java
@@ -37,20 +37,20 @@
         Path anonenumOutput = getOutputFilePath("anonenumgen");
         Path anonenumH = getInputFilePath("anonenum.h");
         run("-d", anonenumOutput.toString(), anonenumH.toString()).checkSuccess();
         try(Loader loader = classLoader(anonenumOutput)) {
             Class<?> cls = loader.loadClass("anonenum_h");
-            checkIntField(cls, "RED", 0xff0000);
-            checkIntField(cls, "GREEN", 0x00ff00);
-            checkIntField(cls, "BLUE", 0x0000ff);
-            checkIntField(cls, "Java", 0);
-            checkIntField(cls, "C", 1);
-            checkIntField(cls, "CPP", 2);
-            checkIntField(cls, "Python", 3);
-            checkIntField(cls, "Ruby", 4);
-            checkIntField(cls, "ONE", 1);
-            checkIntField(cls, "TWO", 2);
+            checkIntGetter(cls, "RED", 0xff0000);
+            checkIntGetter(cls, "GREEN", 0x00ff00);
+            checkIntGetter(cls, "BLUE", 0x0000ff);
+            checkIntGetter(cls, "Java", 0);
+            checkIntGetter(cls, "C", 1);
+            checkIntGetter(cls, "CPP", 2);
+            checkIntGetter(cls, "Python", 3);
+            checkIntGetter(cls, "Ruby", 4);
+            checkIntGetter(cls, "ONE", 1);
+            checkIntGetter(cls, "TWO", 2);
         } finally {
             deleteDir(anonenumOutput);
         }
     }
 }
diff a/test/jdk/tools/jextract/Test8240752.java b/test/jdk/tools/jextract/Test8240752.java
--- a/test/jdk/tools/jextract/Test8240752.java
+++ b/test/jdk/tools/jextract/Test8240752.java
@@ -20,10 +20,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 import java.lang.reflect.Field;
+import java.lang.reflect.Method;
 import java.nio.file.Path;
 import org.testng.annotations.Test;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertTrue;
@@ -36,28 +37,28 @@
  * @summary jextract generates non-compilable code for special floating point values
  * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit Test8240752
  */
 public class Test8240752 extends JextractToolRunner {
     private float getFloatConstant(Class<?> cls, String name) {
-        Field field = findField(cls, name);
-        assertNotNull(field);
-        assertEquals(field.getType(), float.class);
+        Method method = findMethod(cls, name);
+        assertNotNull(method);
+        assertEquals(method.getReturnType(), float.class);
         try {
-            return (float)field.get(null);
+            return (float)method.invoke(null);
         } catch (Exception exp) {
             System.err.println(exp);
             assertTrue(false, "should not reach here");
         }
         return 0.0f;
     }
 
     private double getDoubleConstant(Class<?> cls, String name) {
-        Field field = findField(cls, name);
-        assertNotNull(field);
-        assertEquals(field.getType(), double.class);
+        Method method = findMethod(cls, name);
+        assertNotNull(method);
+        assertEquals(method.getReturnType(), double.class);
         try {
-            return (double)field.get(null);
+            return (double)method.invoke(null);
         } catch (Exception exp) {
             System.err.println(exp);
             assertTrue(false, "should not reach here");
         }
         return 0.0d;
diff a/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java b/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java
--- /dev/null
+++ b/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java
@@ -0,0 +1,245 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @modules jdk.incubator.jextract
+ *          jdk.incubator.foreign/jdk.incubator.foreign.unsafe
+ *          jdk.incubator.foreign/jdk.internal.foreign
+ *          jdk.incubator.foreign/jdk.internal.foreign.abi
+ *          java.base/sun.security.action
+ * @library ..
+ * @build JextractToolRunner
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit -Duser.language=en TestClassGeneration
+ */
+
+import jdk.incubator.foreign.Foreign;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+import java.lang.invoke.VarHandle;
+import java.lang.reflect.Method;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Path;
+
+import static java.lang.invoke.MethodType.methodType;
+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;
+import static jdk.incubator.foreign.MemoryLayouts.C_CHAR;
+import static jdk.incubator.foreign.MemoryLayouts.C_DOUBLE;
+import static jdk.incubator.foreign.MemoryLayouts.C_FLOAT;
+import static jdk.incubator.foreign.MemoryLayouts.C_INT;
+import static jdk.incubator.foreign.MemoryLayouts.C_LONGLONG;
+import static jdk.incubator.foreign.MemoryLayouts.C_SHORT;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
+public class TestClassGeneration extends JextractToolRunner {
+
+    private static final Foreign FOREIGN = Foreign.getInstance();
+
+    private static final VarHandle VH_bytes = MemoryLayout.ofSequence(C_CHAR).varHandle(byte.class, sequenceElement());
+
+    private Path outputDir;
+    private Loader loader;
+    private Class<?> cls;
+
+    @DataProvider
+    public static Object[][] simpleConstants() {
+        return new Object[][]{
+            { "macro_byte",         byte.class,   (byte) 1                         },
+            { "macro_short",        short.class, (short) 1                         },
+            { "macro_int",          int.class,           1                         },
+            { "macro_long",         long.class,          1L                        },
+            { "macro_float",        float.class,         1.0F                      },
+            { "macro_double",       double.class,        1.0D                      },
+            { "macro_address_NULL", MemoryAddress.class, MemoryAddress.NULL        },
+            { "macro_address_123",  MemoryAddress.class, MemoryAddress.ofLong(123) },
+            { "enum_0",             int.class,           0                         },
+            { "enum_1",             int.class,           1                         },
+            { "enum_2",             int.class,           2                         },
+            { "enum_anon_0",        int.class,           0                         },
+            { "enum_anon_1",        int.class,           1                         },
+            { "enum_anon_2",        int.class,           2                         },
+        };
+    }
+
+    @DataProvider
+    public static Object[][] stringConstants() {
+        return new Object[][]{
+            { "macro_string",         "abc"      },
+            { "macro_string_noident", "123.asdf" },
+        };
+    }
+
+    private static final Object[] NO_ARGS = {};
+
+    @DataProvider
+    public static Object[][] method() {
+        return new Object[][]{
+            { "func_byte",   methodType(byte.class),   (byte) 1,  NO_ARGS },
+            { "func_short",  methodType(short.class), (short) 2,  NO_ARGS },
+            { "func_int",    methodType(int.class),           3,  NO_ARGS },
+            { "func_long",   methodType(long.class),          4L, NO_ARGS },
+            { "func_float",  methodType(float.class),         5F, NO_ARGS },
+            { "func_double", methodType(double.class),        6D, NO_ARGS },
+        };
+    }
+
+    @DataProvider
+    public static Object[][] globals() {
+        return new Object[][]{
+            { "global_byte",   byte.class,   C_CHAR,   (byte) 1  },
+            { "global_short",  short.class,  C_SHORT, (short) 2  },
+            { "global_int",    int.class,    C_INT,           3  },
+            { "global_long",   long.class,   C_LONGLONG,      4L },
+            { "global_float",  float.class,  C_FLOAT,         5F },
+            { "global_double", double.class, C_DOUBLE,        6D },
+        };
+    }
+
+    @DataProvider
+    public static Object[][] structMembers() {
+        return new Object[][] {
+            { "Foo", C_CHAR.withName("c"),      byte.class,   (byte) 10  },
+            { "Foo", C_SHORT.withName("s"),     short.class, (short) 10  },
+            { "Foo", C_INT.withName("i"),       int.class,           10  },
+            { "Foo", C_LONGLONG.withName("ll"), long.class,          10L },
+            { "Foo", C_FLOAT.withName("f"),     float.class,         10F },
+            { "Foo", C_DOUBLE.withName("d"),    double.class,        10D },
+            { "Bar", C_INT.withName("a"),       int.class,           10 },
+            { "Bar", C_INT.withName("b"),       int.class,           10 },
+        };
+    }
+
+    @DataProvider
+    public static Object[][] functionalInterfaces() {
+        return new Object[][]{
+            { "func_cb$cb", methodType(void.class, int.class) }
+        };
+    }
+
+    @Test(dataProvider = "simpleConstants")
+    public void testConstant(String name, Class<?> expectedType, Object expectedValue) throws Throwable {
+        Method getter = checkMethod(cls, name, expectedType);
+        assertEquals(getter.invoke(null), expectedValue);
+    }
+
+    @Test(dataProvider = "stringConstants")
+    public void testStringConstant(String name, String expectedValue) throws Throwable {
+        Method getter = checkMethod(cls, name, MemoryAddress.class);
+        MemoryAddress ma = (MemoryAddress) getter.invoke(null);
+        byte[] expected = expectedValue.getBytes(StandardCharsets.UTF_8);
+        MemoryAddress actual = FOREIGN.withSize(ma, expected.length);
+        for (int i = 0; i < expected.length; i++) {
+            assertEquals((byte) VH_bytes.get(actual, (long) i), expected[i]);
+        }
+    }
+
+    @Test(dataProvider = "method")
+    public void testMethod(String name, MethodType expectedType, Object expectedReturn, Object[] args) throws Throwable {
+        Method mh_getter = checkMethod(cls, name + "$MH", MethodHandle.class);
+        MethodHandle mh = (MethodHandle) mh_getter.invoke(null);
+        assertEquals(mh.type(), expectedType);
+
+        Object actualReturn = mh.invokeWithArguments(args);
+        assertEquals(actualReturn.getClass(), expectedReturn.getClass());
+        assertEquals(actualReturn, expectedReturn);
+
+        Method func = checkMethod(cls, name, expectedType);
+        assertEquals(func.invoke(null, args), expectedReturn);
+    }
+
+    @Test(dataProvider = "globals")
+    public void testGlobal(String name, Class<?> expectedType, MemoryLayout expectedLayout, Object expectedValue) throws Throwable {
+        Method layout_getter = checkMethod(cls, name + "$LAYOUT", MemoryLayout.class);
+        assertEquals(layout_getter.invoke(null), expectedLayout);
+
+        Method addr_getter = checkMethod(cls, name + "$ADDR", MemoryAddress.class);
+        MemoryAddress addr = FOREIGN.withSize((MemoryAddress) addr_getter.invoke(null), expectedLayout.byteSize());
+
+        Method vh_getter = checkMethod(cls, name + "$VH", VarHandle.class);
+        VarHandle vh = (VarHandle) vh_getter.invoke(null);
+        assertEquals(vh.varType(), expectedType);
+        assertEquals(vh.get(addr), expectedValue);
+
+        checkMethod(cls, name + "$get", expectedType);
+        checkMethod(cls, name + "$set", void.class, expectedType);
+    }
+
+    @Test(dataProvider = "structMembers")
+    public void testStructMember(String structName, MemoryLayout memberLayout, Class<?> expectedType, Object testValue) throws Throwable {
+        String memberName = memberLayout.name().orElseThrow();
+        String combinedName = structName + "$" + memberName;
+
+        Method layout_getter = checkMethod(cls, structName + "$LAYOUT", MemoryLayout.class);
+        MemoryLayout structLayout = (MemoryLayout) layout_getter.invoke(null);
+        try (MemorySegment struct = MemorySegment.allocateNative(structLayout)) {
+            Method vh_getter = checkMethod(cls, combinedName + "$VH", VarHandle.class);
+            VarHandle vh = (VarHandle) vh_getter.invoke(null);
+            assertEquals(vh.varType(), expectedType);
+
+            Method getter = checkMethod(cls, combinedName + "$get", expectedType, MemorySegment.class);
+            Method setter = checkMethod(cls, combinedName + "$set", void.class, MemorySegment.class, expectedType);
+
+            setter.invoke(null, struct, testValue);
+            assertEquals(getter.invoke(null, struct), testValue);
+        }
+    }
+
+    @Test(dataProvider = "functionalInterfaces")
+    public void testFunctionalInterface(String name, MethodType type) {
+        Class<?> fiClass = findNestedClass(cls, name);
+        assertNotNull(fiClass);
+        checkMethod(fiClass, "apply", type);
+        checkMethod(cls, name + "$make", MemoryAddress.class, fiClass);
+    }
+
+    @BeforeClass
+    public void setup() {
+        outputDir = getOutputFilePath("exmples_out");
+        Path inputHeader = getInputFilePath("examples.h");
+        run(
+            "-t", "com.acme",
+            "-d", outputDir,
+            "-l", "Examples",
+            "--",
+            inputHeader
+        ).checkSuccess();
+        loader = classLoader(outputDir);
+        cls = loader.loadClass("com.acme.examples_h");
+    }
+
+    @AfterClass
+    public void tearDown() {
+        loader.close();
+        deleteDir(outputDir);
+    }
+
+}
diff a/test/jdk/tools/jextract/testClassGen/examples.h b/test/jdk/tools/jextract/testClassGen/examples.h
--- /dev/null
+++ b/test/jdk/tools/jextract/testClassGen/examples.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifdef _WIN64
+#define EXPORT __declspec(dllexport)
+#else
+#define EXPORT
+#endif
+
+#define macro_byte (char) 1
+#define macro_short (short) 1
+#define macro_int 1
+#define macro_long 1LL
+#define macro_float 1.0F
+#define macro_double 1.0
+#define macro_address_NULL (void*) 0
+#define macro_address_123 (void*) 123
+#define macro_string "abc"
+#define macro_string_noident "123.asdf"
+
+EXPORT char func_byte(void);
+EXPORT short func_short(void);
+EXPORT int func_int(void);
+EXPORT long long func_long(void);
+EXPORT float func_float(void);
+EXPORT double func_double(void);
+
+EXPORT extern char global_byte;
+EXPORT extern short global_short;
+EXPORT extern int global_int;
+EXPORT extern long long global_long;
+EXPORT extern float global_float;
+EXPORT extern double global_double;
+
+typedef void(*CB)(int);
+EXPORT void func_cb(CB cb);
+
+struct Foo {
+    char c;
+    short s;
+    int i;
+    long long ll;
+    float f;
+    double d;
+};
+
+typedef struct {
+    int a;
+    int b;
+} Bar;
+
+enum Enum {
+    enum_0,
+    enum_1,
+    enum_2,
+};
+
+enum {
+    enum_anon_0,
+    enum_anon_1,
+    enum_anon_2,
+};
diff a/test/jdk/tools/jextract/testClassGen/libExamples.c b/test/jdk/tools/jextract/testClassGen/libExamples.c
--- /dev/null
+++ b/test/jdk/tools/jextract/testClassGen/libExamples.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "examples.h"
+
+#ifdef _WIN64
+#define EXPORT __declspec(dllexport)
+#else
+#define EXPORT
+#endif
+
+EXPORT char func_byte(void) { return 1; }
+EXPORT short func_short(void) { return 2; }
+EXPORT int func_int(void) { return 3; }
+EXPORT long long func_long(void) { return 4; }
+EXPORT float func_float(void) { return 5; }
+EXPORT double func_double(void) { return 6; }
+
+EXPORT char global_byte = 1;
+EXPORT short global_short = 2;
+EXPORT int global_int = 3;
+EXPORT long long global_long = 4;
+EXPORT float global_float = 5;
+EXPORT double global_double = 6;
+
+EXPORT void func_cb(CB cb) {
+    cb(1);
+}
diff a/test/jdk/tools/jextract/testStruct/LibStructTest.java b/test/jdk/tools/jextract/testStruct/LibStructTest.java
--- a/test/jdk/tools/jextract/testStruct/LibStructTest.java
+++ b/test/jdk/tools/jextract/testStruct/LibStructTest.java
@@ -53,11 +53,11 @@
                                                                       .orElseThrow(), expected);
     }
 
     @Test
     public void testFieldTypes() {
-        GroupLayout g = (GroupLayout)AllTypes$LAYOUT;
+        GroupLayout g = (GroupLayout)AllTypes$LAYOUT();
         checkFieldABIType(g, "sc",  Type.SIGNED_CHAR);
         checkFieldABIType(g, "uc",  Type.UNSIGNED_CHAR);
         checkFieldABIType(g, "s",   Type.SHORT);
         checkFieldABIType(g, "us",  Type.UNSIGNED_SHORT);
         checkFieldABIType(g, "i",   Type.INT);

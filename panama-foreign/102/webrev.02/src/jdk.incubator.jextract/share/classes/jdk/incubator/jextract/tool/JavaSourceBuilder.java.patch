diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
@@ -22,354 +22,123 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.incubator.jextract.tool;
 
-import jdk.incubator.jextract.Declaration;
 import jdk.incubator.foreign.FunctionDescriptor;
-import jdk.incubator.foreign.GroupLayout;
-import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.SequenceLayout;
-import jdk.incubator.foreign.SystemABI;
-import jdk.incubator.foreign.ValueLayout;
-import jdk.internal.foreign.InternalForeign;
 
+import javax.tools.JavaFileObject;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.DirectMethodHandleDesc;
 import java.lang.invoke.MethodType;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-import javax.lang.model.SourceVersion;
-
-import static jdk.incubator.foreign.SystemABI.NATIVE_TYPE;
 
 /**
  * A helper class to generate header interface class in source form.
  * After aggregating various constituents of a .java source, build
  * method is called to get overall generated source string.
  */
 class JavaSourceBuilder {
-    private static final String ABI = InternalForeign.getInstancePrivileged().getSystemABI().name();
+
+    private static final String PUB_CLS_MODS = "public final ";
+    private static final String PUB_MODS = "public static final ";
+
+    private final String pkgName;
+    private final String[] libraryNames;
     // buffer
     protected StringBuffer sb;
     // current line alignment (number of 4-spaces)
     protected int align;
 
-    JavaSourceBuilder(int align) {
+    private String className = null;
+    private ConstantHelper constantHelper;
+
+    JavaSourceBuilder(int align, String pkgName, String[] libraryNames) {
         this.align = align;
+        this.libraryNames = libraryNames;
         this.sb = new StringBuffer();
+        this.pkgName = pkgName;
     }
 
-    JavaSourceBuilder() {
-        this(0);
+    JavaSourceBuilder(String pkgName, String[] libraryNames) {
+        this(0, pkgName, libraryNames);
     }
 
-    protected int align() {
-        return align;
-    }
-
-    final String PUB_CLS_MODS = "public final ";
-    final String PUB_MODS = "public static final ";
-    final String PRI_MODS = "private static final ";
+    public void classBegin(String name) {
+        className = name;
+        String qualName = pkgName.isEmpty() ? name : pkgName + "." + name;
+        constantHelper = new ConstantHelper(qualName,
+                ClassDesc.of(pkgName, "RuntimeHelper"), ClassDesc.of(pkgName, "Cstring"), libraryNames);
 
-    protected void addPackagePrefix(String pkgName) {
-        assert pkgName.indexOf('/') == -1 : "package name invalid: " + pkgName;
-        sb.append("// Generated by jextract\n\n");
-        if (!pkgName.isEmpty()) {
-            sb.append("package ");
-            sb.append(pkgName);
-            sb.append(";\n\n");
-        }
+        addPackagePrefix();
         addImportSection();
-    }
-
-    protected void addImportSection() {
-        sb.append("import java.lang.invoke.MethodHandle;\n");
-        sb.append("import java.lang.invoke.VarHandle;\n");
-        sb.append("import jdk.incubator.foreign.*;\n");
-        sb.append("import jdk.incubator.foreign.MemoryLayout.PathElement;\n");
-        sb.append("import static ");
-        sb.append(HandleSourceFactory.C_LANG_CONSTANTS_HOLDER);
-        sb.append(".*;\n");
-    }
 
-    protected void classBegin(String name) {
         indent();
         sb.append(PUB_CLS_MODS + "class ");
         sb.append(name);
         sb.append(" {\n\n");
     }
 
-    protected void classEnd() {
+    public void classEnd() {
         indent();
         sb.append("}\n\n");
     }
 
-    protected void addLibraries(String[] libraryNames) {
-        incrAlign();
-        indent();
-        sb.append(PRI_MODS + "LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(");
-        sb.append(stringArray(libraryNames) + ");\n");
-        decrAlign();
+    public void addLayoutGetter(String javaName, MemoryLayout layout) {
+        emitForwardGetter(constantHelper.addLayout(javaName, layout));
     }
 
-    private String stringArray(String[] elements) {
-        return Stream.of(elements)
-                .map(n -> "\"" + n + "\"")
-                .collect(Collectors.joining(",", "new String[] {", "}"));
+    public void addVarHandleGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        emitForwardGetter(constantHelper.addVarHandle(javaName, nativeName, layout, type, parentLayout));
     }
 
-    protected void addLayout(String elementName, MemoryLayout layout) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + "MemoryLayout " + javaSafeIdentifier(elementName) + "$LAYOUT = ");
-        addLayout(layout);
-        sb.append(";\n");
-        decrAlign();
+    public void addMethodHandleGetter(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
+        emitForwardGetter(constantHelper.addMethodHandle(javaName, nativeName, mtype, desc, varargs));
     }
 
-    private void addLayout(MemoryLayout l) {
-        if (l instanceof ValueLayout) {
-            SystemABI.Type type = l.attribute(NATIVE_TYPE)
-                                   .map(SystemABI.Type.class::cast)
-                                   .orElseThrow(()->new AssertionError("Should not get here: " + l));
-            sb.append(TypeTranslator.typeToLayoutName(type));
-        } else if (l instanceof SequenceLayout) {
-            sb.append("MemoryLayout.ofSequence(");
-            if (((SequenceLayout) l).elementCount().isPresent()) {
-                sb.append(((SequenceLayout) l).elementCount().getAsLong() + ", ");
-            }
-            addLayout(((SequenceLayout) l).elementLayout());
-            sb.append(")");
-        } else if (l instanceof GroupLayout) {
-            SystemABI.Type type = l.attribute(NATIVE_TYPE)
-                                   .map(SystemABI.Type.class::cast)
-                                   .orElse(null);
-            if (type == SystemABI.Type.COMPLEX_LONG_DOUBLE) {
-                if (!ABI.equals(SystemABI.ABI_SYSV)) {
-                    throw new RuntimeException("complex long double is supported only for SysV ABI");
-                } else {
-                    sb.append("C_COMPLEX_LONGDOUBLE");
-                }
-            } else {
-                if (((GroupLayout) l).isStruct()) {
-                    sb.append("MemoryLayout.ofStruct(\n");
-                } else {
-                    sb.append("MemoryLayout.ofUnion(\n");
-                }
-                incrAlign();
-                String delim = "";
-                for (MemoryLayout e : ((GroupLayout) l).memberLayouts()) {
-                    sb.append(delim);
-                    indent();
-                    addLayout(e);
-                    delim = ",\n";
-                }
-                sb.append("\n");
-                decrAlign();
-                indent();
-                sb.append(")");
-            }
-        } else {
-            //padding
-            sb.append("MemoryLayout.ofPaddingBits(" + l.bitSize() + ")");
-        }
-        if (l.name().isPresent()) {
-            sb.append(".withName(\"" +  l.name().get() + "\")");
-        }
+    public void addAddressGetter(String javaName, String nativeName) {
+        emitForwardGetter(constantHelper.addAddress(javaName, nativeName));
     }
 
-    protected void addVarHandle(String name, Class<?> type, String parentName) {
-        incrAlign();
-        indent();
-        parentName = parentName != null? javaSafeIdentifier(parentName) : parentName;
-        name = javaSafeIdentifier(name);
-        String vhName = parentName != null ?
-                parentName + "$" + name : name;
-        sb.append(PUB_MODS + "VarHandle " + vhName + " = ");
-        if (parentName != null) {
-            addHandlePath(type, parentName, name);
-        } else {
-            addHandlePath(type, name);
-        }
-        sb.append(";\n");
-        decrAlign();
-    }
-
-    protected void addHandlePath(Class<?> type, String strName, String fieldName) {
-        String ty = type.getName();
-        boolean isAddress = ty.contains("MemoryAddress");
-        if (isAddress) {
-            sb.append("MemoryHandles.asAddressVarHandle(");
-            ty = "long";
-        }
-        sb.append(strName + "$LAYOUT.varHandle(" + ty + ".class, ");
-        sb.append("PathElement.groupElement(\"" + fieldName +"\")");
-        sb.append(")");
-        if (isAddress) {
-            sb.append(")");
-        }
+    public void addConstantGetter(String javaName, Class<?> type, Object value) {
+        emitForwardGetter(constantHelper.addConstant(javaName, type, value));
     }
 
-    protected void addHandlePath(Class<?> type, String varName) {
-        String ty = type.getName();
-        boolean isAddress = ty.contains("MemoryAddress");
-        if (isAddress) {
-            sb.append("MemoryHandles.asAddressVarHandle(");
-            ty = "long";
-        }
-        sb.append(varName + "$LAYOUT.varHandle(" + ty + ".class)");
-        if (isAddress) {
-            sb.append(")");
-        }
-    }
-
-    protected void addMethodHandle(Declaration.Function funcTree, MethodType mtype, FunctionDescriptor desc) {
+    public void addFunctionalFactory(String className, MethodType mtype, FunctionDescriptor fDesc) {
         incrAlign();
         indent();
-        sb.append(PUB_MODS + "MethodHandle " + javaSafeIdentifier(funcTree.name()) + " = ");
-        sb.append("RuntimeHelper.downcallHandle(\n");
+        sb.append(PUB_MODS + "MemoryAddress " + className + "$make(" + className + " fi) {\n");
         incrAlign();
         indent();
-        sb.append("LIBRARIES, \"" + funcTree.name() + "\"");
-        sb.append(",\n");
-        indent();
-        sb.append("\"" + mtype.toMethodDescriptorString() + "\",\n");
-        indent();
-        addFunction(desc);
-        sb.append(",\n");
-        indent();
-        sb.append(funcTree.type().varargs());
-        decrAlign();
-        sb.append("\n");
-        indent();
-        sb.append(");\n");
-        decrAlign();
-    }
-
-    protected void addAddressLookup(String name) {
-        sb.append("RuntimeHelper.lookupGlobalVariable(LIBRARIES, \"" + name + "\")");
-    }
-
-    private void addFunction(FunctionDescriptor f) {
-        final boolean noArgs = f.argumentLayouts().isEmpty();
-        if (f.returnLayout().isPresent()) {
-            sb.append("FunctionDescriptor.of(");
-            addLayout(f.returnLayout().get());
-            if (!noArgs) {
-                sb.append(", ");
-            }
-        } else {
-            sb.append("FunctionDescriptor.ofVoid(");
-        }
-        if (!noArgs) {
-            sb.append("\n");
-            incrAlign();
-            String delim = "";
-            for (MemoryLayout e : f.argumentLayouts()) {
-                sb.append(delim);
-                indent();
-                addLayout(e);
-                delim = ",\n";
-            }
-            sb.append("\n");
-            decrAlign();
-            indent();
-        }
-        sb.append(")");
-    }
-
-    protected void addAddress(String name) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + "MemoryAddress " + javaSafeIdentifier(name) + "$ADDR" + " = ");
-        addAddressLookup(name);
-        sb.append(";\n");
-        decrAlign();
-    }
-
-    protected void addConstant(String name, Class<?> type, Object value) {
-        incrAlign();
-        indent();
-        if (type == MemoryAddress.class || type == MemorySegment.class) {
-            //todo, skip for now (address constants and string constants)
-        } else {
-            sb.append(PUB_MODS + type.getName() + " " + javaSafeIdentifier(name));
-            sb.append(" = ");
-            if (type == float.class) {
-                float f = ((Number)value).floatValue();
-                if (Float.isNaN(f)) {
-                    sb.append("Float.NaN");
-                } else if (Float.isInfinite(f)) {
-                    sb.append(f > 0? "Float.POSITIVE_INFINITY" : "Float.NEGATIVE_INFINITY");
-                } else {
-                    sb.append(value);
-                    sb.append("f");
-                }
-            } else if (type == long.class) {
-                sb.append(value);
-                sb.append("L");
-            } else if (type == double.class) {
-                double d = ((Number)value).doubleValue();
-                if (Double.isNaN(d)) {
-                    sb.append("Double.NaN");
-                } else if (Double.isInfinite(d)) {
-                    sb.append(d > 0? "Double.POSITIVE_INFINITY" : "Double.NEGATIVE_INFINITY");
-                } else {
-                   sb.append(value);
-                   sb.append("d");
-                }
-            } else {
-                sb.append("(" + type.getName() + ")");
-                sb.append(value + "L");
-            }
-            sb.append(";\n");
-        }
-
-        decrAlign();
-    }
-
-    static int funcIntfCounter = 0;
-
-    protected void addUpcallFactory(FunctionDescriptor desc) {
-        String fnName = "FI" + funcIntfCounter++;
-        incrAlign();
-        indent();
-        sb.append(PRI_MODS + "FunctionDescriptor " + fnName + "$DESC = ");
-        addFunction(desc);
-        sb.append(";\n");
-        indent();
-        sb.append(PUB_MODS + "MemoryAddress " + fnName + "$make(MethodHandle handle) {\n");
-        incrAlign();
-        indent();
-        sb.append("return RuntimeHelper.upcallStub(handle, " + fnName + "$DESC);\n");
+        sb.append("return RuntimeHelper.upcallStub(" + className + ".class, fi, " + functionGetCallString(className, fDesc) + ", " +
+                "\"" + mtype.toMethodDescriptorString() + "\");\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
-    protected void addStaticFunctionWrapper(Declaration.Function f, MethodType mtype) {
+    public void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {
         incrAlign();
         indent();
-        sb.append(PUB_MODS + mtype.returnType().getName() + " " + javaSafeIdentifier(f.name()) + " (");
+        sb.append(PUB_MODS + mtype.returnType().getName() + " " + javaName + " (");
         String delim = "";
         List<String> pNames = new ArrayList<>();
-        final int numParams = f.parameters().size();
+        final int numParams = paramNames.size();
         for (int i = 0 ; i < numParams; i++) {
-            String pName = f.parameters().get(i).name();
+            String pName = paramNames.get(i);
             if (pName.isEmpty()) {
                 pName = "x" + i;
             }
-            pName = javaSafeIdentifier(pName);
             pNames.add(pName);
             sb.append(delim + mtype.parameterType(i).getName() + " " + pName);
             delim = ", ";
         }
-        if (f.type().varargs()) {
+        if (varargs) {
             String lastArg = "x" + numParams;
             if (numParams > 0) {
                 sb.append(", ");
             }
             sb.append("Object... " + lastArg);
@@ -382,11 +151,11 @@
         incrAlign();
         indent();
         if (!mtype.returnType().equals(void.class)) {
             sb.append("return (" + mtype.returnType().getName() + ")");
         }
-        sb.append(f.name() + ".invokeExact(" + String.join(", ", pNames) + ");\n");
+        sb.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + ".invokeExact(" + String.join(", ", pNames) + ");\n");
         decrAlign();
         indent();
         sb.append("} catch (Throwable ex) {\n");
         incrAlign();
         indent();
@@ -398,24 +167,14 @@
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
-    void addDescriptor(String name, FunctionDescriptor desc) {
+    public void addFunctionalInterface(String name, MethodType mtype) {
         incrAlign();
         indent();
-        sb.append(PRI_MODS + "FunctionDescriptor " + name + "$DESC = ");
-        addFunction(desc);
-        sb.append(";\n");
-        decrAlign();
-        indent();
-    }
-
-    void addFunctionalInterface(String name, MethodType mtype) {
-        incrAlign();
-        indent();
-        sb.append("public interface " + javaSafeIdentifier(name) + " {\n");
+        sb.append("public interface " + name + " {\n");
         incrAlign();
         indent();
         sb.append(mtype.returnType().getName() + " apply(");
         String delim = "";
         for (int i = 0 ; i < mtype.parameterCount() ; i++) {
@@ -428,83 +187,120 @@
         sb.append("}\n");
         decrAlign();
         indent();
     }
 
-    protected void addFunctionalFactory(String name, MethodType mtype) {
+    public void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
         incrAlign();
         indent();
-        sb.append(PUB_MODS + "MemoryAddress " + name + "$make(" + name + " fi) {\n");
+        String param = parentLayout != null ? (MemorySegment.class.getName() + " seg") : "";
+        sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(" + param + ") {\n");
         incrAlign();
         indent();
-        sb.append("return RuntimeHelper.upcallStub(" + name + ".class, fi, " + name + "$DESC, " +
-                "\"" + mtype.toMethodDescriptorString() + "\");\n");
+        String vhParam = parentLayout != null ?
+                "seg.baseAddress()" : addressGetCallString(javaName, nativeName);
+        sb.append("return (" + type.getName() + ")"
+                + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(" + vhParam + ");\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
-    void addGetter(String name, Class<?> type, String parent) {
+    public void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
         incrAlign();
         indent();
-        name = javaSafeIdentifier(name);
-        String vhName = (parent != null ? (javaSafeIdentifier(parent) + "$") : "") + name;
-        String param = parent != null ? (MemorySegment.class.getName() + " seg") : "";
-        sb.append(PUB_MODS + type.getName() + " " + vhName + "$get(" + param + ") {\n");
+        String param = parentLayout != null ? (MemorySegment.class.getName() + " seg, ") : "";
+        sb.append(PUB_MODS + "void " + javaName + "$set(" + param + type.getName() + " x) {\n");
         incrAlign();
         indent();
-        String vhParam = parent != null ?
-                "seg.baseAddress()" : name + "$ADDR";
-        sb.append("return (" + type.getName() + ")" + vhName + ".get(" + vhParam + ");\n");
+        String vhParam = parentLayout != null ?
+                "seg.baseAddress()" : addressGetCallString(javaName, nativeName);
+        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".set(" + vhParam + ", x);\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
-    void addSetter(String name, Class<?> type, String parent) {
+    public List<JavaFileObject> build() {
+        String res = sb.toString();
+        this.sb = null;
+        List<JavaFileObject> outputs = new ArrayList<>(constantHelper.getClasses());
+        outputs.add(Utils.fileFromString(pkgName, className, res));
+        return outputs;
+    }
+
+    // Utility
+
+    private void addPackagePrefix() {
+        assert pkgName.indexOf('/') == -1 : "package name invalid: " + pkgName;
+        sb.append("// Generated by jextract\n\n");
+        if (!pkgName.isEmpty()) {
+            sb.append("package ");
+            sb.append(pkgName);
+            sb.append(";\n\n");
+        }
+    }
+
+    private void addImportSection() {
+        sb.append("import java.lang.invoke.MethodHandle;\n");
+        sb.append("import java.lang.invoke.VarHandle;\n");
+        sb.append("import jdk.incubator.foreign.*;\n");
+        sb.append("import jdk.incubator.foreign.MemoryLayout.PathElement;\n");
+        sb.append("import static ");
+        sb.append(OutputFactory.C_LANG_CONSTANTS_HOLDER);
+        sb.append(".*;\n");
+    }
+
+    private void emitForwardGetter(DirectMethodHandleDesc desc) {
         incrAlign();
         indent();
-        name = javaSafeIdentifier(name);
-        String vhName = (parent != null ? (javaSafeIdentifier(parent) + "$") : "") + name;
-        String param = parent != null ? (MemorySegment.class.getName() + " seg, ") : "";
-        sb.append(PUB_MODS + "void " + vhName + "$set(" + param + type.getName() + " x) {\n");
+        sb.append(PUB_MODS + displayName(desc.invocationType().returnType()) + " " + desc.methodName() + "() {\n");
         incrAlign();
         indent();
-        String vhParam = parent != null ?
-                "seg.baseAddress()" : name + "$ADDR";
-        sb.append(vhName + ".set(" + vhParam + ", x);\n");
+        sb.append("return " + getCallString(desc) + ";\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
-    protected String build() {
-        String res = sb.toString();
-        this.sb = null;
-        return res.toString();
+    private String getCallString(DirectMethodHandleDesc desc) {
+        return desc.owner().displayName() + "." + desc.methodName() + "()";
+    }
+
+    private String displayName(ClassDesc returnType) {
+        return returnType.displayName(); // TODO shorten based on imports
+    }
+
+    private String functionGetCallString(String javaName, FunctionDescriptor fDesc) {
+        return getCallString(constantHelper.addFunctionDesc(javaName, fDesc));
     }
 
-    protected void indent() {
+    private String methodHandleGetCallString(String javaName, String nativeName, MethodType mt, FunctionDescriptor fDesc, boolean varargs) {
+        return getCallString(constantHelper.addMethodHandle(javaName, nativeName, mt, fDesc, varargs));
+    }
+
+    private String varHandleGetCallString(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        return getCallString(constantHelper.addVarHandle(javaName, nativeName, layout, type, parentLayout));
+    }
+
+    private String addressGetCallString(String javaName, String nativeName) {
+        return getCallString(constantHelper.addAddress(javaName, nativeName));
+    }
+
+    private void indent() {
         for (int i = 0; i < align; i++) {
             sb.append("    ");
         }
     }
 
-    protected void incrAlign() {
+    private void incrAlign() {
         align++;
     }
 
-    protected void decrAlign() {
+    private void decrAlign() {
         align--;
     }
 
-    protected final String javaSafeIdentifier(String name) {
-        // We never get the problem of Java non-identifiers (like 123, ab-xy) as
-        // C identifiers. But we may have a java keyword used as a C identifier.
-        assert SourceVersion.isIdentifier(name);
-
-        return SourceVersion.isKeyword(name)? (name + "_") : name;
-    }
 }

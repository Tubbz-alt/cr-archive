diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/ConstantHelper.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/ConstantHelper.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/ConstantHelper.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/ConstantHelper.java
@@ -26,10 +26,11 @@
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
 import jdk.internal.org.objectweb.asm.ClassWriter;
 import jdk.internal.org.objectweb.asm.ConstantDynamic;
 import jdk.internal.org.objectweb.asm.Handle;
 import jdk.internal.org.objectweb.asm.MethodVisitor;
 import jdk.internal.org.objectweb.asm.Type;
@@ -89,10 +90,17 @@
             desc(MemoryAddress.class),
             "ofLong",
             desc(methodType(MemoryAddress.class, long.class))
     );
 
+    private static final DirectMethodHandleDesc MH_MemorySegment_baseAddress = MethodHandleDesc.ofMethod(
+            Kind.INTERFACE_VIRTUAL,
+            desc(MemorySegment.class),
+            "baseAddress",
+            desc(methodType(MemoryAddress.class))
+    );
+
     private static final DirectMethodHandleDesc BSM_GET_STATIC_FINAL = ConstantDescs.ofConstantBootstrap(
             CD_ConstantBootstraps,
             "getStaticFinal",
             CD_Object,
             CD_Class
@@ -100,10 +108,11 @@
 
     private static final ConstantDesc TRUE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, "TRUE", ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
     private static final ConstantDesc FALSE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, "FALSE", ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
     private static final ClassDesc CD_PathElelemt = desc(MemoryLayout.PathElement.class);
     private static final ClassDesc CD_MemoryAddress = desc(MemoryAddress.class);
+    private static final ClassDesc CD_MemorySegment = desc(MemorySegment.class);
 
     private final DirectMethodHandleDesc MH_downcallHandle;
     private final DirectMethodHandleDesc MH_lookupGlobalVariable;
     private final DirectMethodHandleDesc MH_makeCString;
 
@@ -112,11 +121,11 @@
     private final ClassDesc CD_constantsHelper;
     private final ConstantDesc LIBRARIES;
 
     private final Map<String, DirectMethodHandleDesc> pool = new HashMap<>();
 
-    ConstantHelper(String parentClassName, ClassDesc runtimeHelper, String[] libraryNames) {
+    ConstantHelper(String parentClassName, ClassDesc runtimeHelper, ClassDesc cString, String[] libraryNames) {
         this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
         String className = parentClassName + "$constants";
         this.CD_constantsHelper = ClassDesc.of(className);
         this.internalClassName = className.replace('.', '/');
 
@@ -138,14 +147,14 @@
                         MemoryAddress.class,
                         LibraryLookup[].class,
                         String.class)
         );
         this.MH_makeCString = findRuntimeHelperBootstrap(
-                runtimeHelper,
-                "makeCString",
+                cString,
+                "toCString",
                 methodType(
-                        MemoryAddress.class,
+                        MemorySegment.class,
                         String.class)
         );
 
         this.LIBRARIES = librariesDesc(findRuntimeHelperBootstrap(
                 runtimeHelper,
@@ -196,17 +205,17 @@
             } else {
                 throw new IllegalStateException("Unhandled constant value type: " + value.getClass());
             }
         } else if (type.isPrimitive()) {
             if (type == int.class || type == byte.class || type == short.class || type == char.class) {
-                return emitGetter(name, type, mv -> emitConInt(mv, ((Long) value).intValue()));
+                return emitConIntGetter(name, type, ((Long) value).intValue());
             } else if (type == float.class) {
-                return emitGetter(name, type, mv -> emitConFloat(mv, ((Double) value).floatValue()));
+                return emitConFloatGetter(name, type, ((Double) value).floatValue());
             } else if (type == long.class) {
-                return emitGetter(name, type, mv -> emitConLong(mv, (Long) value));
+                return emitConLongGetter(name, type, (Long) value);
             } else if (type == double.class) {
-                return emitGetter(name, type, mv -> emitConDouble(mv, (Double) value));
+                return emitConDoubleGetter(name, type, (Double) value);
             } else { // boolean and void
                 throw new IllegalStateException("Unhandled primitive target type: " + type);
             }
         } else if (type == value.getClass() && value instanceof Constable) {
             // Constable value that requires no conversion
@@ -337,10 +346,26 @@
                     mt.describeConstable().orElseThrow()
             );
         });
     }
 
+    private DirectMethodHandleDesc emitConDoubleGetter(String name, Class<?> type, double value) {
+        return emitGetter(name, type, mv -> emitConDouble(mv, value));
+    }
+
+    private DirectMethodHandleDesc emitConLongGetter(String name, Class<?> type, long value) {
+        return emitGetter(name, type, mv -> emitConLong(mv, value));
+    }
+
+    private DirectMethodHandleDesc emitConFloatGetter(String name, Class<?> type, float value) {
+        return emitGetter(name, type, mv -> emitConFloat(mv, value));
+    }
+
+    private DirectMethodHandleDesc emitConIntGetter(String name, Class<?> type, int value) {
+        return emitGetter(name, type, mv -> emitConInt(mv, value));
+    }
+
     private DirectMethodHandleDesc emitCondyGetter(String name, Class<?> type, ConstantDesc desc) {
         return emitGetter(name, type, mv -> mv.visitLdcInsn(asmConstant(desc)));
     }
 
     private static void emitReturn(MethodVisitor mv, Class<?> type) {
@@ -401,11 +426,13 @@
     private ConstantDesc addressDesc(long value) {
         return DynamicConstantDesc.ofNamed(BSM_INVOKE, "MA_" + value, CD_MemoryAddress, MH_MemoryAddress_ofLong, value);
     }
 
     private ConstantDesc cStringDesc(String value) {
-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "CSTRING", CD_MemoryAddress, MH_makeCString, value);
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "BASEADDRESS", CD_MemoryAddress, MH_MemorySegment_baseAddress,
+            DynamicConstantDesc.ofNamed(BSM_INVOKE, "CSTRING", CD_MemorySegment, MH_makeCString, value)
+        );
     }
 
     private ConstantDesc methodHandleDesc(String name, MethodType mtype, FunctionDescriptor funcDesc, boolean varargs) {
         return DynamicConstantDesc.ofNamed(BSM_INVOKE, "MH_" + name, CD_MethodHandle, MH_downcallHandle,
             LIBRARIES,
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
@@ -39,10 +39,14 @@
  * A helper class to generate header interface class in source form.
  * After aggregating various constituents of a .java source, build
  * method is called to get overall generated source string.
  */
 class JavaSourceBuilder {
+
+    private static final String PUB_CLS_MODS = "public final ";
+    private static final String PUB_MODS = "public static final ";
+
     private final String pkgName;
     private final String[] libraryNames;
     // buffer
     protected StringBuffer sb;
     // current line alignment (number of 4-spaces)
@@ -60,37 +64,15 @@
 
     JavaSourceBuilder(String pkgName, String[] libraryNames) {
         this(0, pkgName, libraryNames);
     }
 
-    final String PUB_CLS_MODS = "public final ";
-    final String PUB_MODS = "public static final ";
-
-    private void addPackagePrefix() {
-        assert pkgName.indexOf('/') == -1 : "package name invalid: " + pkgName;
-        sb.append("// Generated by jextract\n\n");
-        if (!pkgName.isEmpty()) {
-            sb.append("package ");
-            sb.append(pkgName);
-            sb.append(";\n\n");
-        }
-    }
-
-    private void addImportSection() {
-        sb.append("import java.lang.invoke.MethodHandle;\n");
-        sb.append("import java.lang.invoke.VarHandle;\n");
-        sb.append("import jdk.incubator.foreign.*;\n");
-        sb.append("import jdk.incubator.foreign.MemoryLayout.PathElement;\n");
-        sb.append("import static ");
-        sb.append(OutputFactory.C_LANG_CONSTANTS_HOLDER);
-        sb.append(".*;\n");
-    }
-
     public void classBegin(String name) {
         className = name;
         String qualName = pkgName.isEmpty() ? name : pkgName + "." + name;
-        constantHelper = new ConstantHelper(qualName, ClassDesc.of(pkgName, "RuntimeHelper"), libraryNames);
+        constantHelper = new ConstantHelper(qualName,
+                ClassDesc.of(pkgName, "RuntimeHelper"), ClassDesc.of(pkgName, "Cstring"), libraryNames);
 
         addPackagePrefix();
         addImportSection();
 
         indent();
@@ -102,82 +84,44 @@
     public void classEnd() {
         indent();
         sb.append("}\n\n");
     }
 
-    private String getterCall(DirectMethodHandleDesc desc) {
-        return desc.owner().displayName() + "." + desc.methodName() + "()";
-    }
-
-    private void emitForwardGetter(DirectMethodHandleDesc desc) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + displayName(desc.invocationType().returnType()) + " " + desc.methodName() + "() {\n");
-        incrAlign();
-        indent();
-        sb.append("return " + getterCall(desc) + ";\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    private String displayName(ClassDesc returnType) {
-        return returnType.displayName(); // TODO shorten based on imports
-    }
-
-    private String getFunction(String javaName, FunctionDescriptor fDesc) {
-        return getterCall(constantHelper.addFunctionDesc(javaName, fDesc));
-    }
-
-    private String getMethodHandle(String javaName, String nativeName, MethodType mt, FunctionDescriptor fDesc, boolean varargs) {
-        return getterCall(constantHelper.addMethodHandle(javaName, nativeName, mt, fDesc, varargs));
-    }
-
-    private String getVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        return getterCall(constantHelper.addVarHandle(javaName, nativeName, layout, type, parentLayout));
-    }
-
-    private String getAddress(String javaName, String nativeName) {
-        return getterCall(constantHelper.addAddress(javaName, nativeName));
-    }
-
-    public void addLayout(String javaName, MemoryLayout layout) {
+    public void addLayoutGetter(String javaName, MemoryLayout layout) {
         emitForwardGetter(constantHelper.addLayout(javaName, layout));
     }
 
-    public void addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+    public void addVarHandleGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
         emitForwardGetter(constantHelper.addVarHandle(javaName, nativeName, layout, type, parentLayout));
     }
 
-    public void addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
+    public void addMethodHandleGetter(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
         emitForwardGetter(constantHelper.addMethodHandle(javaName, nativeName, mtype, desc, varargs));
     }
 
-    public void addAddress(String javaName, String nativeName) {
+    public void addAddressGetter(String javaName, String nativeName) {
         emitForwardGetter(constantHelper.addAddress(javaName, nativeName));
     }
 
-    public void addConstant(String javaName, Class<?> type, Object value) {
+    public void addConstantGetter(String javaName, Class<?> type, Object value) {
         emitForwardGetter(constantHelper.addConstant(javaName, type, value));
     }
 
     public void addFunctionalFactory(String className, MethodType mtype, FunctionDescriptor fDesc) {
         incrAlign();
         indent();
         sb.append(PUB_MODS + "MemoryAddress " + className + "$make(" + className + " fi) {\n");
         incrAlign();
         indent();
-        sb.append("return RuntimeHelper.upcallStub(" + className + ".class, fi, " + getFunction(className, fDesc) + ", " +
+        sb.append("return RuntimeHelper.upcallStub(" + className + ".class, fi, " + functionGetCallString(className, fDesc) + ", " +
                 "\"" + mtype.toMethodDescriptorString() + "\");\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
-
     public void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {
         incrAlign();
         indent();
         sb.append(PUB_MODS + mtype.returnType().getName() + " " + javaName + " (");
         String delim = "";
@@ -207,11 +151,11 @@
         incrAlign();
         indent();
         if (!mtype.returnType().equals(void.class)) {
             sb.append("return (" + mtype.returnType().getName() + ")");
         }
-        sb.append(getMethodHandle(javaName, nativeName, mtype, desc, varargs) + ".invokeExact(" + String.join(", ", pNames) + ");\n");
+        sb.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + ".invokeExact(" + String.join(", ", pNames) + ");\n");
         decrAlign();
         indent();
         sb.append("} catch (Throwable ex) {\n");
         incrAlign();
         indent();
@@ -251,13 +195,13 @@
         String param = parentLayout != null ? (MemorySegment.class.getName() + " seg") : "";
         sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(" + param + ") {\n");
         incrAlign();
         indent();
         String vhParam = parentLayout != null ?
-                "seg.baseAddress()" : getAddress(javaName, nativeName);
+                "seg.baseAddress()" : addressGetCallString(javaName, nativeName);
         sb.append("return (" + type.getName() + ")"
-                + getVarHandle(javaName, nativeName, layout, type, parentLayout) + ".get(" + vhParam + ");\n");
+                + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(" + vhParam + ");\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
@@ -268,12 +212,12 @@
         String param = parentLayout != null ? (MemorySegment.class.getName() + " seg, ") : "";
         sb.append(PUB_MODS + "void " + javaName + "$set(" + param + type.getName() + " x) {\n");
         incrAlign();
         indent();
         String vhParam = parentLayout != null ?
-                "seg.baseAddress()" : getAddress(javaName, nativeName);
-        sb.append(getVarHandle(javaName, nativeName, layout, type, parentLayout) + ".set(" + vhParam + ", x);\n");
+                "seg.baseAddress()" : addressGetCallString(javaName, nativeName);
+        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".set(" + vhParam + ", x);\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
@@ -284,10 +228,69 @@
         List<JavaFileObject> outputs = new ArrayList<>(constantHelper.getClasses());
         outputs.add(Utils.fileFromString(pkgName, className, res));
         return outputs;
     }
 
+    // Utility
+
+    private void addPackagePrefix() {
+        assert pkgName.indexOf('/') == -1 : "package name invalid: " + pkgName;
+        sb.append("// Generated by jextract\n\n");
+        if (!pkgName.isEmpty()) {
+            sb.append("package ");
+            sb.append(pkgName);
+            sb.append(";\n\n");
+        }
+    }
+
+    private void addImportSection() {
+        sb.append("import java.lang.invoke.MethodHandle;\n");
+        sb.append("import java.lang.invoke.VarHandle;\n");
+        sb.append("import jdk.incubator.foreign.*;\n");
+        sb.append("import jdk.incubator.foreign.MemoryLayout.PathElement;\n");
+        sb.append("import static ");
+        sb.append(OutputFactory.C_LANG_CONSTANTS_HOLDER);
+        sb.append(".*;\n");
+    }
+
+    private void emitForwardGetter(DirectMethodHandleDesc desc) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + displayName(desc.invocationType().returnType()) + " " + desc.methodName() + "() {\n");
+        incrAlign();
+        indent();
+        sb.append("return " + getCallString(desc) + ";\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    private String getCallString(DirectMethodHandleDesc desc) {
+        return desc.owner().displayName() + "." + desc.methodName() + "()";
+    }
+
+    private String displayName(ClassDesc returnType) {
+        return returnType.displayName(); // TODO shorten based on imports
+    }
+
+    private String functionGetCallString(String javaName, FunctionDescriptor fDesc) {
+        return getCallString(constantHelper.addFunctionDesc(javaName, fDesc));
+    }
+
+    private String methodHandleGetCallString(String javaName, String nativeName, MethodType mt, FunctionDescriptor fDesc, boolean varargs) {
+        return getCallString(constantHelper.addMethodHandle(javaName, nativeName, mt, fDesc, varargs));
+    }
+
+    private String varHandleGetCallString(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        return getCallString(constantHelper.addVarHandle(javaName, nativeName, layout, type, parentLayout));
+    }
+
+    private String addressGetCallString(String javaName, String nativeName) {
+        return getCallString(constantHelper.addAddress(javaName, nativeName));
+    }
+
     private void indent() {
         for (int i = 0; i < align; i++) {
             sb.append("    ");
         }
     }
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
@@ -68,27 +68,27 @@
     protected final JavaSourceBuilder builder;
     protected final TypeTranslator typeTranslator = new TypeTranslator();
     private final String clsName;
     private final String pkgName;
 
-    // have we visited this Variable earlier?
-    protected boolean visitedVariable(Declaration.Variable tree) {
+    // have we seen this Variable earlier?
+    protected boolean variableSeen(Declaration.Variable tree) {
         return !variables.add(tree);
     }
 
-    // have we visited this Function earlier?
-    protected boolean visitedFunction(Declaration.Function tree) {
+    // have we seen this Function earlier?
+    protected boolean functionSeen(Declaration.Function tree) {
         return !functions.add(tree);
     }
 
     // have we visited a struct/union or a global variable of given name?
-    protected boolean visitedStructOrVariable(String name) {
+    protected boolean structOrVariableSeen(String name) {
         return !structsAndVars.add(name);
     }
 
     private void setMangledName(String name, String prefix) {
-        if (!name.isEmpty() && visitedStructOrVariable(name)) {
+        if (!name.isEmpty() && structOrVariableSeen(name)) {
             mangledNames.put(name, prefix + name);
         }
     }
 
     protected void setMangledName(Declaration.Scoped d) {
@@ -232,11 +232,11 @@
         if (!constants.add(constant.name())) {
             //skip
             return null;
         }
 
-        builder.addConstant(Utils.javaSafeIdentifier(constant.name()), typeTranslator.getJavaType(constant.type()), constant.value());
+        builder.addConstantGetter(Utils.javaSafeIdentifier(constant.name()), typeTranslator.getJavaType(constant.type()), constant.value());
         return null;
     }
 
     @Override
     public Void visitScoped(Declaration.Scoped d, Declaration parent) {
@@ -259,33 +259,33 @@
         if (!d.name().isEmpty() || !isRecord(parent)) {
             //only add explicit struct layout if the struct is not to be flattened inside another struct
             switch (d.kind()) {
                 case STRUCT:
                 case UNION: {
-                    builder.addLayout(Utils.javaSafeIdentifier(name), d.layout().get());
+                    builder.addLayoutGetter(Utils.javaSafeIdentifier(name), d.layout().get());
                     break;
                 }
             }
         }
         d.members().forEach(fieldTree -> fieldTree.accept(this, d.name().isEmpty() ? parent : d));
         return null;
     }
 
     @Override
     public Void visitFunction(Declaration.Function funcTree, Declaration parent) {
-        if (visitedFunction(funcTree)) {
+        if (functionSeen(funcTree)) {
             return null;
         }
 
         MethodType mtype = typeTranslator.getMethodType(funcTree.type());
         FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);
         if (descriptor == null) {
             //abort
             return null;
         }
         String mhName = Utils.javaSafeIdentifier(funcTree.name());
-        builder.addMethodHandle(mhName, funcTree.name(), mtype, descriptor, funcTree.type().varargs());
+        builder.addMethodHandleGetter(mhName, funcTree.name(), mtype, descriptor, funcTree.type().varargs());
         //generate static wrapper for function
         List<String> paramNames = funcTree.parameters()
                                           .stream()
                                           .map(Declaration.Variable::name)
                                           .map(p -> !p.isEmpty() ? Utils.javaSafeIdentifier(p) : p)
@@ -325,11 +325,11 @@
         }
     }
 
     @Override
     public Void visitVariable(Declaration.Variable tree, Declaration parent) {
-        if (parent == null && visitedVariable(tree)) {
+        if (parent == null && variableSeen(tree)) {
             return null;
         }
 
         String fieldName = tree.name();
         String symbol = tree.name();
@@ -360,17 +360,17 @@
         if (parent != null) { //struct field
             Declaration.Scoped parentC = (Declaration.Scoped) parent;
             String parentName = Utils.javaSafeIdentifier(getMangledName(parentC));
             fieldName = parentName + "$" + fieldName;
             MemoryLayout parentLayout = parentLayout(parentC);
-            builder.addVarHandle(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+            builder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
             builder.addGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
             builder.addSetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
         } else {
-            builder.addLayout(fieldName, layout);
-            builder.addVarHandle(fieldName, tree.name(), treeLayout, clazz, null);
-            builder.addAddress(fieldName, tree.name());
+            builder.addLayoutGetter(fieldName, layout);
+            builder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, null);
+            builder.addAddressGetter(fieldName, tree.name());
             builder.addGetter(fieldName, tree.name(), treeLayout, clazz, null);
             builder.addSetter(fieldName, tree.name(), treeLayout, clazz, null);
         }
 
         return null;
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Utils.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Utils.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Utils.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Utils.java
@@ -22,21 +22,19 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.incubator.jextract.tool;
 
-import jdk.incubator.foreign.FunctionDescriptor;
-
 import javax.lang.model.SourceVersion;
 import javax.tools.JavaFileObject;
 import javax.tools.SimpleJavaFileObject;
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.net.URI;
 
-class Utils {
+final class Utils {
+
+    private Utils() {}
 
     private static URI fileName(String pkgName, String clsName, String extension) {
         String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
         return URI.create(pkgPrefix + clsName + extension);
     }
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template
@@ -51,26 +51,10 @@
 
     public static final MemoryAddress lookupGlobalVariable(LibraryLookup[] LIBRARIES, String name) {
         return lookup(LIBRARIES, name).orElse(null);
     }
 
-    public static final MemoryAddress makeCString(String value) {
-        value += '\0';
-        MemorySegment dest = MemorySegment.allocateNative(value.length());
-        // Utils::toJavaString casts bytes to 'char'
-        //     -> interpreted as UTF-16
-        //     -> get back as UTF-8 assuming no surrogate pairs
-        byte[] bytes = value.getBytes(StandardCharsets.UTF_8);
-        if (bytes.length != value.length()) {
-            throw new IllegalStateException("bytes.length != value.length(). " +
-                    "bytes: " + Arrays.toString(bytes) + ", value: " + value);
-        }
-        MemorySegment src = MemorySegment.ofArray(bytes);
-        MemoryAddress.copy(src.baseAddress(), dest.baseAddress(), value.length());
-        return dest.baseAddress();
-    }
-
     public static final MethodHandle downcallHandle(LibraryLookup[] LIBRARIES, String name, String desc, FunctionDescriptor fdesc, boolean variadic) {
         return lookup(LIBRARIES, name).map(
                 addr -> {
                     MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);
                     return variadic ?
diff a/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java b/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java
--- /dev/null
+++ b/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java
@@ -0,0 +1,245 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @modules jdk.incubator.jextract
+ *          jdk.incubator.foreign/jdk.incubator.foreign.unsafe
+ *          jdk.incubator.foreign/jdk.internal.foreign
+ *          jdk.incubator.foreign/jdk.internal.foreign.abi
+ *          java.base/sun.security.action
+ * @library ..
+ * @build JextractToolRunner
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit -Duser.language=en TestClassGeneration
+ */
+
+import jdk.incubator.foreign.Foreign;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+import java.lang.invoke.VarHandle;
+import java.lang.reflect.Method;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Path;
+
+import static java.lang.invoke.MethodType.methodType;
+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;
+import static jdk.incubator.foreign.MemoryLayouts.C_CHAR;
+import static jdk.incubator.foreign.MemoryLayouts.C_DOUBLE;
+import static jdk.incubator.foreign.MemoryLayouts.C_FLOAT;
+import static jdk.incubator.foreign.MemoryLayouts.C_INT;
+import static jdk.incubator.foreign.MemoryLayouts.C_LONGLONG;
+import static jdk.incubator.foreign.MemoryLayouts.C_SHORT;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
+public class TestClassGeneration extends JextractToolRunner {
+
+    private static final Foreign FOREIGN = Foreign.getInstance();
+
+    private static final VarHandle VH_bytes = MemoryLayout.ofSequence(C_CHAR).varHandle(byte.class, sequenceElement());
+
+    private Path outputDir;
+    private Loader loader;
+    private Class<?> cls;
+
+    @DataProvider
+    public static Object[][] simpleConstants() {
+        return new Object[][]{
+            { "macro_byte",         byte.class,   (byte) 1                         },
+            { "macro_short",        short.class, (short) 1                         },
+            { "macro_int",          int.class,           1                         },
+            { "macro_long",         long.class,          1L                        },
+            { "macro_float",        float.class,         1.0F                      },
+            { "macro_double",       double.class,        1.0D                      },
+            { "macro_address_NULL", MemoryAddress.class, MemoryAddress.NULL        },
+            { "macro_address_123",  MemoryAddress.class, MemoryAddress.ofLong(123) },
+            { "enum_0",             int.class,           0                         },
+            { "enum_1",             int.class,           1                         },
+            { "enum_2",             int.class,           2                         },
+            { "enum_anon_0",        int.class,           0                         },
+            { "enum_anon_1",        int.class,           1                         },
+            { "enum_anon_2",        int.class,           2                         },
+        };
+    }
+
+    @DataProvider
+    public static Object[][] stringConstants() {
+        return new Object[][]{
+            { "macro_string",         "abc"      },
+            { "macro_string_noident", "123.asdf" },
+        };
+    }
+
+    private static final Object[] NO_ARGS = {};
+
+    @DataProvider
+    public static Object[][] method() {
+        return new Object[][]{
+            { "func_byte",   methodType(byte.class),   (byte) 1,  NO_ARGS },
+            { "func_short",  methodType(short.class), (short) 2,  NO_ARGS },
+            { "func_int",    methodType(int.class),           3,  NO_ARGS },
+            { "func_long",   methodType(long.class),          4L, NO_ARGS },
+            { "func_float",  methodType(float.class),         5F, NO_ARGS },
+            { "func_double", methodType(double.class),        6D, NO_ARGS },
+        };
+    }
+
+    @DataProvider
+    public static Object[][] globals() {
+        return new Object[][]{
+            { "global_byte",   byte.class,   C_CHAR,   (byte) 1  },
+            { "global_short",  short.class,  C_SHORT, (short) 2  },
+            { "global_int",    int.class,    C_INT,           3  },
+            { "global_long",   long.class,   C_LONGLONG,      4L },
+            { "global_float",  float.class,  C_FLOAT,         5F },
+            { "global_double", double.class, C_DOUBLE,        6D },
+        };
+    }
+
+    @DataProvider
+    public static Object[][] structMembers() {
+        return new Object[][] {
+            { "Foo", C_CHAR.withName("c"),      byte.class,   (byte) 10  },
+            { "Foo", C_SHORT.withName("s"),     short.class, (short) 10  },
+            { "Foo", C_INT.withName("i"),       int.class,           10  },
+            { "Foo", C_LONGLONG.withName("ll"), long.class,          10L },
+            { "Foo", C_FLOAT.withName("f"),     float.class,         10F },
+            { "Foo", C_DOUBLE.withName("d"),    double.class,        10D },
+            { "Bar", C_INT.withName("a"),       int.class,           10 },
+            { "Bar", C_INT.withName("b"),       int.class,           10 },
+        };
+    }
+
+    @DataProvider
+    public static Object[][] functionalInterfaces() {
+        return new Object[][]{
+            { "func_cb$cb", methodType(void.class, int.class) }
+        };
+    }
+
+    @Test(dataProvider = "simpleConstants")
+    public void testConstant(String name, Class<?> expectedType, Object expectedValue) throws Throwable {
+        Method getter = checkMethod(cls, name, expectedType);
+        assertEquals(getter.invoke(null), expectedValue);
+    }
+
+    @Test(dataProvider = "stringConstants")
+    public void testStringConstant(String name, String expectedValue) throws Throwable {
+        Method getter = checkMethod(cls, name, MemoryAddress.class);
+        MemoryAddress ma = (MemoryAddress) getter.invoke(null);
+        byte[] expected = expectedValue.getBytes(StandardCharsets.UTF_8);
+        MemoryAddress actual = FOREIGN.withSize(ma, expected.length);
+        for (int i = 0; i < expected.length; i++) {
+            assertEquals((byte) VH_bytes.get(actual, (long) i), expected[i]);
+        }
+    }
+
+    @Test(dataProvider = "method")
+    public void testMethod(String name, MethodType expectedType, Object expectedReturn, Object[] args) throws Throwable {
+        Method mh_getter = checkMethod(cls, name + "$MH", MethodHandle.class);
+        MethodHandle mh = (MethodHandle) mh_getter.invoke(null);
+        assertEquals(mh.type(), expectedType);
+
+        Object actualReturn = mh.invokeWithArguments(args);
+        assertEquals(actualReturn.getClass(), expectedReturn.getClass());
+        assertEquals(actualReturn, expectedReturn);
+
+        Method func = checkMethod(cls, name, expectedType);
+        assertEquals(func.invoke(null, args), expectedReturn);
+    }
+
+    @Test(dataProvider = "globals")
+    public void testGlobal(String name, Class<?> expectedType, MemoryLayout expectedLayout, Object expectedValue) throws Throwable {
+        Method layout_getter = checkMethod(cls, name + "$LAYOUT", MemoryLayout.class);
+        assertEquals(layout_getter.invoke(null), expectedLayout);
+
+        Method addr_getter = checkMethod(cls, name + "$ADDR", MemoryAddress.class);
+        MemoryAddress addr = FOREIGN.withSize((MemoryAddress) addr_getter.invoke(null), expectedLayout.byteSize());
+
+        Method vh_getter = checkMethod(cls, name + "$VH", VarHandle.class);
+        VarHandle vh = (VarHandle) vh_getter.invoke(null);
+        assertEquals(vh.varType(), expectedType);
+        assertEquals(vh.get(addr), expectedValue);
+
+        checkMethod(cls, name + "$get", expectedType);
+        checkMethod(cls, name + "$set", void.class, expectedType);
+    }
+
+    @Test(dataProvider = "structMembers")
+    public void testStructMember(String structName, MemoryLayout memberLayout, Class<?> expectedType, Object testValue) throws Throwable {
+        String memberName = memberLayout.name().orElseThrow();
+        String combinedName = structName + "$" + memberName;
+
+        Method layout_getter = checkMethod(cls, structName + "$LAYOUT", MemoryLayout.class);
+        MemoryLayout structLayout = (MemoryLayout) layout_getter.invoke(null);
+        try (MemorySegment struct = MemorySegment.allocateNative(structLayout)) {
+            Method vh_getter = checkMethod(cls, combinedName + "$VH", VarHandle.class);
+            VarHandle vh = (VarHandle) vh_getter.invoke(null);
+            assertEquals(vh.varType(), expectedType);
+
+            Method getter = checkMethod(cls, combinedName + "$get", expectedType, MemorySegment.class);
+            Method setter = checkMethod(cls, combinedName + "$set", void.class, MemorySegment.class, expectedType);
+
+            setter.invoke(null, struct, testValue);
+            assertEquals(getter.invoke(null, struct), testValue);
+        }
+    }
+
+    @Test(dataProvider = "functionalInterfaces")
+    public void testFunctionalInterface(String name, MethodType type) {
+        Class<?> fiClass = findNestedClass(cls, name);
+        assertNotNull(fiClass);
+        checkMethod(fiClass, "apply", type);
+        checkMethod(cls, name + "$make", MemoryAddress.class, fiClass);
+    }
+
+    @BeforeClass
+    public void setup() {
+        outputDir = getOutputFilePath("exmples_out");
+        Path inputHeader = getInputFilePath("examples.h");
+        run(
+            "-t", "com.acme",
+            "-d", outputDir,
+            "-l", "Examples",
+            "--",
+            inputHeader
+        ).checkSuccess();
+        loader = classLoader(outputDir);
+        cls = loader.loadClass("com.acme.examples_h");
+    }
+
+    @AfterClass
+    public void tearDown() {
+        loader.close();
+        deleteDir(outputDir);
+    }
+
+}
diff a/test/jdk/tools/jextract/testClassGen/examples.h b/test/jdk/tools/jextract/testClassGen/examples.h
--- /dev/null
+++ b/test/jdk/tools/jextract/testClassGen/examples.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifdef _WIN64
+#define EXPORT __declspec(dllexport)
+#else
+#define EXPORT
+#endif
+
+#define macro_byte (char) 1
+#define macro_short (short) 1
+#define macro_int 1
+#define macro_long 1LL
+#define macro_float 1.0F
+#define macro_double 1.0
+#define macro_address_NULL (void*) 0
+#define macro_address_123 (void*) 123
+#define macro_string "abc"
+#define macro_string_noident "123.asdf"
+
+EXPORT char func_byte(void);
+EXPORT short func_short(void);
+EXPORT int func_int(void);
+EXPORT long long func_long(void);
+EXPORT float func_float(void);
+EXPORT double func_double(void);
+
+EXPORT extern char global_byte;
+EXPORT extern short global_short;
+EXPORT extern int global_int;
+EXPORT extern long long global_long;
+EXPORT extern float global_float;
+EXPORT extern double global_double;
+
+typedef void(*CB)(int);
+EXPORT void func_cb(CB cb);
+
+struct Foo {
+    char c;
+    short s;
+    int i;
+    long long ll;
+    float f;
+    double d;
+};
+
+typedef struct {
+    int a;
+    int b;
+} Bar;
+
+enum Enum {
+    enum_0,
+    enum_1,
+    enum_2,
+};
+
+enum {
+    enum_anon_0,
+    enum_anon_1,
+    enum_anon_2,
+};
diff a/test/jdk/tools/jextract/testClassGen/libExamples.c b/test/jdk/tools/jextract/testClassGen/libExamples.c
--- /dev/null
+++ b/test/jdk/tools/jextract/testClassGen/libExamples.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "examples.h"
+
+#ifdef _WIN64
+#define EXPORT __declspec(dllexport)
+#else
+#define EXPORT
+#endif
+
+EXPORT char func_byte(void) { return 1; }
+EXPORT short func_short(void) { return 2; }
+EXPORT int func_int(void) { return 3; }
+EXPORT long long func_long(void) { return 4; }
+EXPORT float func_float(void) { return 5; }
+EXPORT double func_double(void) { return 6; }
+
+EXPORT char global_byte = 1;
+EXPORT short global_short = 2;
+EXPORT int global_int = 3;
+EXPORT long long global_long = 4;
+EXPORT float global_float = 5;
+EXPORT double global_double = 6;
+
+EXPORT void func_cb(CB cb) {
+    cb(1);
+}

diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
@@ -68,27 +68,27 @@
     protected final JavaSourceBuilder builder;
     protected final TypeTranslator typeTranslator = new TypeTranslator();
     private final String clsName;
     private final String pkgName;
 
-    // have we visited this Variable earlier?
-    protected boolean visitedVariable(Declaration.Variable tree) {
+    // have we seen this Variable earlier?
+    protected boolean variableSeen(Declaration.Variable tree) {
         return !variables.add(tree);
     }
 
-    // have we visited this Function earlier?
-    protected boolean visitedFunction(Declaration.Function tree) {
+    // have we seen this Function earlier?
+    protected boolean functionSeen(Declaration.Function tree) {
         return !functions.add(tree);
     }
 
     // have we visited a struct/union or a global variable of given name?
-    protected boolean visitedStructOrVariable(String name) {
+    protected boolean structOrVariableSeen(String name) {
         return !structsAndVars.add(name);
     }
 
     private void setMangledName(String name, String prefix) {
-        if (!name.isEmpty() && visitedStructOrVariable(name)) {
+        if (!name.isEmpty() && structOrVariableSeen(name)) {
             mangledNames.put(name, prefix + name);
         }
     }
 
     protected void setMangledName(Declaration.Scoped d) {
@@ -232,11 +232,11 @@
         if (!constants.add(constant.name())) {
             //skip
             return null;
         }
 
-        builder.addConstant(Utils.javaSafeIdentifier(constant.name()), typeTranslator.getJavaType(constant.type()), constant.value());
+        builder.addConstantGetter(Utils.javaSafeIdentifier(constant.name()), typeTranslator.getJavaType(constant.type()), constant.value());
         return null;
     }
 
     @Override
     public Void visitScoped(Declaration.Scoped d, Declaration parent) {
@@ -259,33 +259,33 @@
         if (!d.name().isEmpty() || !isRecord(parent)) {
             //only add explicit struct layout if the struct is not to be flattened inside another struct
             switch (d.kind()) {
                 case STRUCT:
                 case UNION: {
-                    builder.addLayout(Utils.javaSafeIdentifier(name), d.layout().get());
+                    builder.addLayoutGetter(Utils.javaSafeIdentifier(name), d.layout().get());
                     break;
                 }
             }
         }
         d.members().forEach(fieldTree -> fieldTree.accept(this, d.name().isEmpty() ? parent : d));
         return null;
     }
 
     @Override
     public Void visitFunction(Declaration.Function funcTree, Declaration parent) {
-        if (visitedFunction(funcTree)) {
+        if (functionSeen(funcTree)) {
             return null;
         }
 
         MethodType mtype = typeTranslator.getMethodType(funcTree.type());
         FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);
         if (descriptor == null) {
             //abort
             return null;
         }
         String mhName = Utils.javaSafeIdentifier(funcTree.name());
-        builder.addMethodHandle(mhName, funcTree.name(), mtype, descriptor, funcTree.type().varargs());
+        builder.addMethodHandleGetter(mhName, funcTree.name(), mtype, descriptor, funcTree.type().varargs());
         //generate static wrapper for function
         List<String> paramNames = funcTree.parameters()
                                           .stream()
                                           .map(Declaration.Variable::name)
                                           .map(p -> !p.isEmpty() ? Utils.javaSafeIdentifier(p) : p)
@@ -325,11 +325,11 @@
         }
     }
 
     @Override
     public Void visitVariable(Declaration.Variable tree, Declaration parent) {
-        if (parent == null && visitedVariable(tree)) {
+        if (parent == null && variableSeen(tree)) {
             return null;
         }
 
         String fieldName = tree.name();
         String symbol = tree.name();
@@ -360,17 +360,17 @@
         if (parent != null) { //struct field
             Declaration.Scoped parentC = (Declaration.Scoped) parent;
             String parentName = Utils.javaSafeIdentifier(getMangledName(parentC));
             fieldName = parentName + "$" + fieldName;
             MemoryLayout parentLayout = parentLayout(parentC);
-            builder.addVarHandle(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+            builder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
             builder.addGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
             builder.addSetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
         } else {
-            builder.addLayout(fieldName, layout);
-            builder.addVarHandle(fieldName, tree.name(), treeLayout, clazz, null);
-            builder.addAddress(fieldName, tree.name());
+            builder.addLayoutGetter(fieldName, layout);
+            builder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, null);
+            builder.addAddressGetter(fieldName, tree.name());
             builder.addGetter(fieldName, tree.name(), treeLayout, clazz, null);
             builder.addSetter(fieldName, tree.name(), treeLayout, clazz, null);
         }
 
         return null;

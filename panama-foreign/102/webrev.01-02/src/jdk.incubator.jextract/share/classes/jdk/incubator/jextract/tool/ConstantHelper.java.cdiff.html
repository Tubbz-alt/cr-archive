<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/ConstantHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JavaSourceBuilder.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/ConstantHelper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  
  import jdk.incubator.foreign.FunctionDescriptor;
  import jdk.incubator.foreign.LibraryLookup;
  import jdk.incubator.foreign.MemoryAddress;
  import jdk.incubator.foreign.MemoryLayout;
<span class="line-added">+ import jdk.incubator.foreign.MemorySegment;</span>
  import jdk.internal.org.objectweb.asm.ClassWriter;
  import jdk.internal.org.objectweb.asm.ConstantDynamic;
  import jdk.internal.org.objectweb.asm.Handle;
  import jdk.internal.org.objectweb.asm.MethodVisitor;
  import jdk.internal.org.objectweb.asm.Type;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,10 ***</span>
<span class="line-new-header">--- 90,17 ---</span>
              desc(MemoryAddress.class),
              &quot;ofLong&quot;,
              desc(methodType(MemoryAddress.class, long.class))
      );
  
<span class="line-added">+     private static final DirectMethodHandleDesc MH_MemorySegment_baseAddress = MethodHandleDesc.ofMethod(</span>
<span class="line-added">+             Kind.INTERFACE_VIRTUAL,</span>
<span class="line-added">+             desc(MemorySegment.class),</span>
<span class="line-added">+             &quot;baseAddress&quot;,</span>
<span class="line-added">+             desc(methodType(MemoryAddress.class))</span>
<span class="line-added">+     );</span>
<span class="line-added">+ </span>
      private static final DirectMethodHandleDesc BSM_GET_STATIC_FINAL = ConstantDescs.ofConstantBootstrap(
              CD_ConstantBootstraps,
              &quot;getStaticFinal&quot;,
              CD_Object,
              CD_Class
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,10 ***</span>
<span class="line-new-header">--- 108,11 ---</span>
  
      private static final ConstantDesc TRUE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, &quot;TRUE&quot;, ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
      private static final ConstantDesc FALSE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, &quot;FALSE&quot;, ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
      private static final ClassDesc CD_PathElelemt = desc(MemoryLayout.PathElement.class);
      private static final ClassDesc CD_MemoryAddress = desc(MemoryAddress.class);
<span class="line-added">+     private static final ClassDesc CD_MemorySegment = desc(MemorySegment.class);</span>
  
      private final DirectMethodHandleDesc MH_downcallHandle;
      private final DirectMethodHandleDesc MH_lookupGlobalVariable;
      private final DirectMethodHandleDesc MH_makeCString;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,11 ***</span>
      private final ClassDesc CD_constantsHelper;
      private final ConstantDesc LIBRARIES;
  
      private final Map&lt;String, DirectMethodHandleDesc&gt; pool = new HashMap&lt;&gt;();
  
<span class="line-modified">!     ConstantHelper(String parentClassName, ClassDesc runtimeHelper, String[] libraryNames) {</span>
          this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
          String className = parentClassName + &quot;$constants&quot;;
          this.CD_constantsHelper = ClassDesc.of(className);
          this.internalClassName = className.replace(&#39;.&#39;, &#39;/&#39;);
  
<span class="line-new-header">--- 121,11 ---</span>
      private final ClassDesc CD_constantsHelper;
      private final ConstantDesc LIBRARIES;
  
      private final Map&lt;String, DirectMethodHandleDesc&gt; pool = new HashMap&lt;&gt;();
  
<span class="line-modified">!     ConstantHelper(String parentClassName, ClassDesc runtimeHelper, ClassDesc cString, String[] libraryNames) {</span>
          this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
          String className = parentClassName + &quot;$constants&quot;;
          this.CD_constantsHelper = ClassDesc.of(className);
          this.internalClassName = className.replace(&#39;.&#39;, &#39;/&#39;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,14 ***</span>
                          MemoryAddress.class,
                          LibraryLookup[].class,
                          String.class)
          );
          this.MH_makeCString = findRuntimeHelperBootstrap(
<span class="line-modified">!                 runtimeHelper,</span>
<span class="line-modified">!                 &quot;makeCString&quot;,</span>
                  methodType(
<span class="line-modified">!                         MemoryAddress.class,</span>
                          String.class)
          );
  
          this.LIBRARIES = librariesDesc(findRuntimeHelperBootstrap(
                  runtimeHelper,
<span class="line-new-header">--- 147,14 ---</span>
                          MemoryAddress.class,
                          LibraryLookup[].class,
                          String.class)
          );
          this.MH_makeCString = findRuntimeHelperBootstrap(
<span class="line-modified">!                 cString,</span>
<span class="line-modified">!                 &quot;toCString&quot;,</span>
                  methodType(
<span class="line-modified">!                         MemorySegment.class,</span>
                          String.class)
          );
  
          this.LIBRARIES = librariesDesc(findRuntimeHelperBootstrap(
                  runtimeHelper,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 196,17 ***</span>
              } else {
                  throw new IllegalStateException(&quot;Unhandled constant value type: &quot; + value.getClass());
              }
          } else if (type.isPrimitive()) {
              if (type == int.class || type == byte.class || type == short.class || type == char.class) {
<span class="line-modified">!                 return emitGetter(name, type, mv -&gt; emitConInt(mv, ((Long) value).intValue()));</span>
              } else if (type == float.class) {
<span class="line-modified">!                 return emitGetter(name, type, mv -&gt; emitConFloat(mv, ((Double) value).floatValue()));</span>
              } else if (type == long.class) {
<span class="line-modified">!                 return emitGetter(name, type, mv -&gt; emitConLong(mv, (Long) value));</span>
              } else if (type == double.class) {
<span class="line-modified">!                 return emitGetter(name, type, mv -&gt; emitConDouble(mv, (Double) value));</span>
              } else { // boolean and void
                  throw new IllegalStateException(&quot;Unhandled primitive target type: &quot; + type);
              }
          } else if (type == value.getClass() &amp;&amp; value instanceof Constable) {
              // Constable value that requires no conversion
<span class="line-new-header">--- 205,17 ---</span>
              } else {
                  throw new IllegalStateException(&quot;Unhandled constant value type: &quot; + value.getClass());
              }
          } else if (type.isPrimitive()) {
              if (type == int.class || type == byte.class || type == short.class || type == char.class) {
<span class="line-modified">!                 return emitConIntGetter(name, type, ((Long) value).intValue());</span>
              } else if (type == float.class) {
<span class="line-modified">!                 return emitConFloatGetter(name, type, ((Double) value).floatValue());</span>
              } else if (type == long.class) {
<span class="line-modified">!                 return emitConLongGetter(name, type, (Long) value);</span>
              } else if (type == double.class) {
<span class="line-modified">!                 return emitConDoubleGetter(name, type, (Double) value);</span>
              } else { // boolean and void
                  throw new IllegalStateException(&quot;Unhandled primitive target type: &quot; + type);
              }
          } else if (type == value.getClass() &amp;&amp; value instanceof Constable) {
              // Constable value that requires no conversion
</pre>
<hr />
<pre>
<span class="line-old-header">*** 337,10 ***</span>
<span class="line-new-header">--- 346,26 ---</span>
                      mt.describeConstable().orElseThrow()
              );
          });
      }
  
<span class="line-added">+     private DirectMethodHandleDesc emitConDoubleGetter(String name, Class&lt;?&gt; type, double value) {</span>
<span class="line-added">+         return emitGetter(name, type, mv -&gt; emitConDouble(mv, value));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private DirectMethodHandleDesc emitConLongGetter(String name, Class&lt;?&gt; type, long value) {</span>
<span class="line-added">+         return emitGetter(name, type, mv -&gt; emitConLong(mv, value));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private DirectMethodHandleDesc emitConFloatGetter(String name, Class&lt;?&gt; type, float value) {</span>
<span class="line-added">+         return emitGetter(name, type, mv -&gt; emitConFloat(mv, value));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private DirectMethodHandleDesc emitConIntGetter(String name, Class&lt;?&gt; type, int value) {</span>
<span class="line-added">+         return emitGetter(name, type, mv -&gt; emitConInt(mv, value));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private DirectMethodHandleDesc emitCondyGetter(String name, Class&lt;?&gt; type, ConstantDesc desc) {
          return emitGetter(name, type, mv -&gt; mv.visitLdcInsn(asmConstant(desc)));
      }
  
      private static void emitReturn(MethodVisitor mv, Class&lt;?&gt; type) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 401,11 ***</span>
      private ConstantDesc addressDesc(long value) {
          return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;MA_&quot; + value, CD_MemoryAddress, MH_MemoryAddress_ofLong, value);
      }
  
      private ConstantDesc cStringDesc(String value) {
<span class="line-modified">!         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;CSTRING&quot;, CD_MemoryAddress, MH_makeCString, value);</span>
      }
  
      private ConstantDesc methodHandleDesc(String name, MethodType mtype, FunctionDescriptor funcDesc, boolean varargs) {
          return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;MH_&quot; + name, CD_MethodHandle, MH_downcallHandle,
              LIBRARIES,
<span class="line-new-header">--- 426,13 ---</span>
      private ConstantDesc addressDesc(long value) {
          return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;MA_&quot; + value, CD_MemoryAddress, MH_MemoryAddress_ofLong, value);
      }
  
      private ConstantDesc cStringDesc(String value) {
<span class="line-modified">!         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;BASEADDRESS&quot;, CD_MemoryAddress, MH_MemorySegment_baseAddress,</span>
<span class="line-added">+             DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;CSTRING&quot;, CD_MemorySegment, MH_makeCString, value)</span>
<span class="line-added">+         );</span>
      }
  
      private ConstantDesc methodHandleDesc(String name, MethodType mtype, FunctionDescriptor funcDesc, boolean varargs) {
          return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;MH_&quot; + name, CD_MethodHandle, MH_downcallHandle,
              LIBRARIES,
</pre>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JavaSourceBuilder.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
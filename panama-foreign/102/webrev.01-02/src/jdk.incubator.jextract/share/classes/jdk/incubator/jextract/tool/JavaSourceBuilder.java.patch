diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
@@ -39,10 +39,14 @@
  * A helper class to generate header interface class in source form.
  * After aggregating various constituents of a .java source, build
  * method is called to get overall generated source string.
  */
 class JavaSourceBuilder {
+
+    private static final String PUB_CLS_MODS = "public final ";
+    private static final String PUB_MODS = "public static final ";
+
     private final String pkgName;
     private final String[] libraryNames;
     // buffer
     protected StringBuffer sb;
     // current line alignment (number of 4-spaces)
@@ -60,37 +64,15 @@
 
     JavaSourceBuilder(String pkgName, String[] libraryNames) {
         this(0, pkgName, libraryNames);
     }
 
-    final String PUB_CLS_MODS = "public final ";
-    final String PUB_MODS = "public static final ";
-
-    private void addPackagePrefix() {
-        assert pkgName.indexOf('/') == -1 : "package name invalid: " + pkgName;
-        sb.append("// Generated by jextract\n\n");
-        if (!pkgName.isEmpty()) {
-            sb.append("package ");
-            sb.append(pkgName);
-            sb.append(";\n\n");
-        }
-    }
-
-    private void addImportSection() {
-        sb.append("import java.lang.invoke.MethodHandle;\n");
-        sb.append("import java.lang.invoke.VarHandle;\n");
-        sb.append("import jdk.incubator.foreign.*;\n");
-        sb.append("import jdk.incubator.foreign.MemoryLayout.PathElement;\n");
-        sb.append("import static ");
-        sb.append(OutputFactory.C_LANG_CONSTANTS_HOLDER);
-        sb.append(".*;\n");
-    }
-
     public void classBegin(String name) {
         className = name;
         String qualName = pkgName.isEmpty() ? name : pkgName + "." + name;
-        constantHelper = new ConstantHelper(qualName, ClassDesc.of(pkgName, "RuntimeHelper"), libraryNames);
+        constantHelper = new ConstantHelper(qualName,
+                ClassDesc.of(pkgName, "RuntimeHelper"), ClassDesc.of(pkgName, "Cstring"), libraryNames);
 
         addPackagePrefix();
         addImportSection();
 
         indent();
@@ -102,82 +84,44 @@
     public void classEnd() {
         indent();
         sb.append("}\n\n");
     }
 
-    private String getterCall(DirectMethodHandleDesc desc) {
-        return desc.owner().displayName() + "." + desc.methodName() + "()";
-    }
-
-    private void emitForwardGetter(DirectMethodHandleDesc desc) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + displayName(desc.invocationType().returnType()) + " " + desc.methodName() + "() {\n");
-        incrAlign();
-        indent();
-        sb.append("return " + getterCall(desc) + ";\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    private String displayName(ClassDesc returnType) {
-        return returnType.displayName(); // TODO shorten based on imports
-    }
-
-    private String getFunction(String javaName, FunctionDescriptor fDesc) {
-        return getterCall(constantHelper.addFunctionDesc(javaName, fDesc));
-    }
-
-    private String getMethodHandle(String javaName, String nativeName, MethodType mt, FunctionDescriptor fDesc, boolean varargs) {
-        return getterCall(constantHelper.addMethodHandle(javaName, nativeName, mt, fDesc, varargs));
-    }
-
-    private String getVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        return getterCall(constantHelper.addVarHandle(javaName, nativeName, layout, type, parentLayout));
-    }
-
-    private String getAddress(String javaName, String nativeName) {
-        return getterCall(constantHelper.addAddress(javaName, nativeName));
-    }
-
-    public void addLayout(String javaName, MemoryLayout layout) {
+    public void addLayoutGetter(String javaName, MemoryLayout layout) {
         emitForwardGetter(constantHelper.addLayout(javaName, layout));
     }
 
-    public void addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+    public void addVarHandleGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
         emitForwardGetter(constantHelper.addVarHandle(javaName, nativeName, layout, type, parentLayout));
     }
 
-    public void addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
+    public void addMethodHandleGetter(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
         emitForwardGetter(constantHelper.addMethodHandle(javaName, nativeName, mtype, desc, varargs));
     }
 
-    public void addAddress(String javaName, String nativeName) {
+    public void addAddressGetter(String javaName, String nativeName) {
         emitForwardGetter(constantHelper.addAddress(javaName, nativeName));
     }
 
-    public void addConstant(String javaName, Class<?> type, Object value) {
+    public void addConstantGetter(String javaName, Class<?> type, Object value) {
         emitForwardGetter(constantHelper.addConstant(javaName, type, value));
     }
 
     public void addFunctionalFactory(String className, MethodType mtype, FunctionDescriptor fDesc) {
         incrAlign();
         indent();
         sb.append(PUB_MODS + "MemoryAddress " + className + "$make(" + className + " fi) {\n");
         incrAlign();
         indent();
-        sb.append("return RuntimeHelper.upcallStub(" + className + ".class, fi, " + getFunction(className, fDesc) + ", " +
+        sb.append("return RuntimeHelper.upcallStub(" + className + ".class, fi, " + functionGetCallString(className, fDesc) + ", " +
                 "\"" + mtype.toMethodDescriptorString() + "\");\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
-
     public void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {
         incrAlign();
         indent();
         sb.append(PUB_MODS + mtype.returnType().getName() + " " + javaName + " (");
         String delim = "";
@@ -207,11 +151,11 @@
         incrAlign();
         indent();
         if (!mtype.returnType().equals(void.class)) {
             sb.append("return (" + mtype.returnType().getName() + ")");
         }
-        sb.append(getMethodHandle(javaName, nativeName, mtype, desc, varargs) + ".invokeExact(" + String.join(", ", pNames) + ");\n");
+        sb.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + ".invokeExact(" + String.join(", ", pNames) + ");\n");
         decrAlign();
         indent();
         sb.append("} catch (Throwable ex) {\n");
         incrAlign();
         indent();
@@ -251,13 +195,13 @@
         String param = parentLayout != null ? (MemorySegment.class.getName() + " seg") : "";
         sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(" + param + ") {\n");
         incrAlign();
         indent();
         String vhParam = parentLayout != null ?
-                "seg.baseAddress()" : getAddress(javaName, nativeName);
+                "seg.baseAddress()" : addressGetCallString(javaName, nativeName);
         sb.append("return (" + type.getName() + ")"
-                + getVarHandle(javaName, nativeName, layout, type, parentLayout) + ".get(" + vhParam + ");\n");
+                + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(" + vhParam + ");\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
@@ -268,12 +212,12 @@
         String param = parentLayout != null ? (MemorySegment.class.getName() + " seg, ") : "";
         sb.append(PUB_MODS + "void " + javaName + "$set(" + param + type.getName() + " x) {\n");
         incrAlign();
         indent();
         String vhParam = parentLayout != null ?
-                "seg.baseAddress()" : getAddress(javaName, nativeName);
-        sb.append(getVarHandle(javaName, nativeName, layout, type, parentLayout) + ".set(" + vhParam + ", x);\n");
+                "seg.baseAddress()" : addressGetCallString(javaName, nativeName);
+        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".set(" + vhParam + ", x);\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
@@ -284,10 +228,69 @@
         List<JavaFileObject> outputs = new ArrayList<>(constantHelper.getClasses());
         outputs.add(Utils.fileFromString(pkgName, className, res));
         return outputs;
     }
 
+    // Utility
+
+    private void addPackagePrefix() {
+        assert pkgName.indexOf('/') == -1 : "package name invalid: " + pkgName;
+        sb.append("// Generated by jextract\n\n");
+        if (!pkgName.isEmpty()) {
+            sb.append("package ");
+            sb.append(pkgName);
+            sb.append(";\n\n");
+        }
+    }
+
+    private void addImportSection() {
+        sb.append("import java.lang.invoke.MethodHandle;\n");
+        sb.append("import java.lang.invoke.VarHandle;\n");
+        sb.append("import jdk.incubator.foreign.*;\n");
+        sb.append("import jdk.incubator.foreign.MemoryLayout.PathElement;\n");
+        sb.append("import static ");
+        sb.append(OutputFactory.C_LANG_CONSTANTS_HOLDER);
+        sb.append(".*;\n");
+    }
+
+    private void emitForwardGetter(DirectMethodHandleDesc desc) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + displayName(desc.invocationType().returnType()) + " " + desc.methodName() + "() {\n");
+        incrAlign();
+        indent();
+        sb.append("return " + getCallString(desc) + ";\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    private String getCallString(DirectMethodHandleDesc desc) {
+        return desc.owner().displayName() + "." + desc.methodName() + "()";
+    }
+
+    private String displayName(ClassDesc returnType) {
+        return returnType.displayName(); // TODO shorten based on imports
+    }
+
+    private String functionGetCallString(String javaName, FunctionDescriptor fDesc) {
+        return getCallString(constantHelper.addFunctionDesc(javaName, fDesc));
+    }
+
+    private String methodHandleGetCallString(String javaName, String nativeName, MethodType mt, FunctionDescriptor fDesc, boolean varargs) {
+        return getCallString(constantHelper.addMethodHandle(javaName, nativeName, mt, fDesc, varargs));
+    }
+
+    private String varHandleGetCallString(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        return getCallString(constantHelper.addVarHandle(javaName, nativeName, layout, type, parentLayout));
+    }
+
+    private String addressGetCallString(String javaName, String nativeName) {
+        return getCallString(constantHelper.addAddress(javaName, nativeName));
+    }
+
     private void indent() {
         for (int i = 0; i < align; i++) {
             sb.append("    ");
         }
     }

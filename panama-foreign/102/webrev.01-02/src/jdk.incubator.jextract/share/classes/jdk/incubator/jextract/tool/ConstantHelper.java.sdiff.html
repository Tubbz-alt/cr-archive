<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/ConstantHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JavaSourceBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/ConstantHelper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.incubator.jextract.tool;
 26 
 27 import jdk.incubator.foreign.FunctionDescriptor;
 28 import jdk.incubator.foreign.LibraryLookup;
 29 import jdk.incubator.foreign.MemoryAddress;
 30 import jdk.incubator.foreign.MemoryLayout;

 31 import jdk.internal.org.objectweb.asm.ClassWriter;
 32 import jdk.internal.org.objectweb.asm.ConstantDynamic;
 33 import jdk.internal.org.objectweb.asm.Handle;
 34 import jdk.internal.org.objectweb.asm.MethodVisitor;
 35 import jdk.internal.org.objectweb.asm.Type;
 36 
 37 import javax.tools.JavaFileObject;
 38 import javax.tools.SimpleJavaFileObject;
 39 import java.io.ByteArrayInputStream;
 40 import java.io.InputStream;
 41 import java.lang.constant.ClassDesc;
 42 import java.lang.constant.Constable;
 43 import java.lang.constant.ConstantDesc;
 44 import java.lang.constant.ConstantDescs;
 45 import java.lang.constant.DirectMethodHandleDesc;
 46 import java.lang.constant.DirectMethodHandleDesc.Kind;
 47 import java.lang.constant.DynamicConstantDesc;
 48 import java.lang.constant.MethodHandleDesc;
 49 import java.lang.constant.MethodTypeDesc;
 50 import java.lang.invoke.MethodHandle;
</pre>
<hr />
<pre>
 74             desc(methodType(
 75                     VarHandle.class,
 76                     Class.class,
 77                     MemoryLayout.PathElement[].class))
 78     );
 79 
 80     private static final DirectMethodHandleDesc MH_PathElement_groupElement = MethodHandleDesc.ofMethod(
 81             Kind.INTERFACE_STATIC,
 82             desc(MemoryLayout.PathElement.class),
 83             &quot;groupElement&quot;,
 84             desc(methodType(MemoryLayout.PathElement.class, String.class))
 85     );
 86 
 87     private static final DirectMethodHandleDesc MH_MemoryAddress_ofLong = MethodHandleDesc.ofMethod(
 88             Kind.INTERFACE_STATIC,
 89             desc(MemoryAddress.class),
 90             &quot;ofLong&quot;,
 91             desc(methodType(MemoryAddress.class, long.class))
 92     );
 93 







 94     private static final DirectMethodHandleDesc BSM_GET_STATIC_FINAL = ConstantDescs.ofConstantBootstrap(
 95             CD_ConstantBootstraps,
 96             &quot;getStaticFinal&quot;,
 97             CD_Object,
 98             CD_Class
 99     );
100 
101     private static final ConstantDesc TRUE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, &quot;TRUE&quot;, ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
102     private static final ConstantDesc FALSE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, &quot;FALSE&quot;, ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
103     private static final ClassDesc CD_PathElelemt = desc(MemoryLayout.PathElement.class);
104     private static final ClassDesc CD_MemoryAddress = desc(MemoryAddress.class);

105 
106     private final DirectMethodHandleDesc MH_downcallHandle;
107     private final DirectMethodHandleDesc MH_lookupGlobalVariable;
108     private final DirectMethodHandleDesc MH_makeCString;
109 
110     private ClassWriter cw;
111     private final String internalClassName;
112     private final ClassDesc CD_constantsHelper;
113     private final ConstantDesc LIBRARIES;
114 
115     private final Map&lt;String, DirectMethodHandleDesc&gt; pool = new HashMap&lt;&gt;();
116 
<span class="line-modified">117     ConstantHelper(String parentClassName, ClassDesc runtimeHelper, String[] libraryNames) {</span>
118         this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
119         String className = parentClassName + &quot;$constants&quot;;
120         this.CD_constantsHelper = ClassDesc.of(className);
121         this.internalClassName = className.replace(&#39;.&#39;, &#39;/&#39;);
122 
123         this.MH_downcallHandle = findRuntimeHelperBootstrap(
124                 runtimeHelper,
125                 &quot;downcallHandle&quot;,
126                 methodType(
127                         MethodHandle.class,
128                         LibraryLookup[].class,
129                         String.class,
130                         String.class,
131                         FunctionDescriptor.class,
132                         boolean.class)
133         );
134         this.MH_lookupGlobalVariable = findRuntimeHelperBootstrap(
135                 runtimeHelper,
136                 &quot;lookupGlobalVariable&quot;,
137                 methodType(
138                         MemoryAddress.class,
139                         LibraryLookup[].class,
140                         String.class)
141         );
142         this.MH_makeCString = findRuntimeHelperBootstrap(
<span class="line-modified">143                 runtimeHelper,</span>
<span class="line-modified">144                 &quot;makeCString&quot;,</span>
145                 methodType(
<span class="line-modified">146                         MemoryAddress.class,</span>
147                         String.class)
148         );
149 
150         this.LIBRARIES = librariesDesc(findRuntimeHelperBootstrap(
151                 runtimeHelper,
152                 &quot;libraries&quot;,
153                 methodType(
154                         LibraryLookup[].class,
155                         String[].class)
156         ), libraryNames);
157 
158         cw.visit(V15, ACC_PUBLIC, internalClassName, null, INTR_OBJECT, null);
159     }
160 
161     private static DirectMethodHandleDesc findRuntimeHelperBootstrap(ClassDesc runtimeHelper, String name, MethodType type) {
162         return MethodHandleDesc.ofMethod(
163                 Kind.STATIC,
164                 runtimeHelper,
165                 name,
166                 desc(type)
</pre>
<hr />
<pre>
181 
182     public DirectMethodHandleDesc addAddress(String javaName, String nativeName) {
183         return emitCondyGetter(javaName + &quot;$ADDR&quot;, MemoryAddress.class, globalVarAddressDesc(nativeName));
184     }
185 
186     public DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor fDesc) {
187         return emitCondyGetter(javaName + &quot;$DESC&quot;, FunctionDescriptor.class, desc(fDesc));
188     }
189 
190     public DirectMethodHandleDesc addConstant(String name, Class&lt;?&gt; type, Object value) {
191         if (type == MemoryAddress.class) {
192             if (value instanceof Long) {
193                 return emitCondyGetter(name, type, addressDesc((Long) value));
194             } else if (value instanceof String) {
195                 return emitCondyGetter(name, type, cStringDesc((String) value));
196             } else {
197                 throw new IllegalStateException(&quot;Unhandled constant value type: &quot; + value.getClass());
198             }
199         } else if (type.isPrimitive()) {
200             if (type == int.class || type == byte.class || type == short.class || type == char.class) {
<span class="line-modified">201                 return emitGetter(name, type, mv -&gt; emitConInt(mv, ((Long) value).intValue()));</span>
202             } else if (type == float.class) {
<span class="line-modified">203                 return emitGetter(name, type, mv -&gt; emitConFloat(mv, ((Double) value).floatValue()));</span>
204             } else if (type == long.class) {
<span class="line-modified">205                 return emitGetter(name, type, mv -&gt; emitConLong(mv, (Long) value));</span>
206             } else if (type == double.class) {
<span class="line-modified">207                 return emitGetter(name, type, mv -&gt; emitConDouble(mv, (Double) value));</span>
208             } else { // boolean and void
209                 throw new IllegalStateException(&quot;Unhandled primitive target type: &quot; + type);
210             }
211         } else if (type == value.getClass() &amp;&amp; value instanceof Constable) {
212             // Constable value that requires no conversion
213             return emitCondyGetter(name, type, desc((Constable) value));
214         } else {
215             System.out.println(&quot;Warning: Skipping constant generation for: &quot; + name + &quot; of type: &quot; + type.getSimpleName()
216                 + &quot; with value: &quot; + value + &quot; of type: &quot; + value.getClass());
217             return null;
218         }
219     }
220 
221     public List&lt;JavaFileObject&gt; getClasses() {
222         cw.visitEnd();
223         byte[] bytes = cw.toByteArray();
224         cw = null;
225         return List.of(jfoFromByteArray(internalClassName, bytes));
226     }
227 
</pre>
<hr />
<pre>
322     }
323 
324     private DirectMethodHandleDesc emitGetter(String name, Class&lt;?&gt; type, Consumer&lt;MethodVisitor&gt; action) {
325         return pool.computeIfAbsent(name, nameKey -&gt; {
326             MethodType mt = methodType(type);
327             MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, nameKey, mt.descriptorString(), null, null);
328             mv.visitCode();
329             action.accept(mv);
330             emitReturn(mv, type);
331             mv.visitMaxs(-1, -1);
332             mv.visitEnd();
333             return MethodHandleDesc.ofMethod(
334                     Kind.STATIC,
335                     CD_constantsHelper,
336                     nameKey,
337                     mt.describeConstable().orElseThrow()
338             );
339         });
340     }
341 
















342     private DirectMethodHandleDesc emitCondyGetter(String name, Class&lt;?&gt; type, ConstantDesc desc) {
343         return emitGetter(name, type, mv -&gt; mv.visitLdcInsn(asmConstant(desc)));
344     }
345 
346     private static void emitReturn(MethodVisitor mv, Class&lt;?&gt; type) {
347         if (type == int.class
348                 || type == short.class
349                 || type == byte.class
350                 || type == char.class
351                 || type == boolean.class) {
352             mv.visitInsn(IRETURN);
353         } else if (type == long.class) {
354             mv.visitInsn(LRETURN);
355         } else if (type == float.class) {
356             mv.visitInsn(FRETURN);
357         } else if (type == double.class) {
358             mv.visitInsn(DRETURN);
359         } else if (type == void.class) {
360             mv.visitInsn(RETURN);
361         } else if (Object.class.isAssignableFrom(type)) {
</pre>
<hr />
<pre>
386         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;groupElement_&quot; + fieldName, CD_PathElelemt, MH_PathElement_groupElement, fieldName);
387     }
388 
389     private static ConstantDesc varHandleDesc(String javaName, String nativeName, MemoryLayout layout, Class&lt;?&gt; type, MemoryLayout parentLayout) {
390         if (parentLayout != null) {
391             return varHandleDesc(javaName, desc(parentLayout), desc(type), groupElementDesc(nativeName));
392         } else {
393             return varHandleDesc(javaName, desc(layout), desc(type));
394         }
395     }
396 
397     private ConstantDesc globalVarAddressDesc(String name) {
398         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;ADDR_&quot; + name, CD_MemoryAddress, MH_lookupGlobalVariable, LIBRARIES, name);
399     }
400 
401     private ConstantDesc addressDesc(long value) {
402         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;MA_&quot; + value, CD_MemoryAddress, MH_MemoryAddress_ofLong, value);
403     }
404 
405     private ConstantDesc cStringDesc(String value) {
<span class="line-modified">406         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;CSTRING&quot;, CD_MemoryAddress, MH_makeCString, value);</span>


407     }
408 
409     private ConstantDesc methodHandleDesc(String name, MethodType mtype, FunctionDescriptor funcDesc, boolean varargs) {
410         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;MH_&quot; + name, CD_MethodHandle, MH_downcallHandle,
411             LIBRARIES,
412             name,
413             mtype.descriptorString(),
414             desc(funcDesc),
415             varargs ? TRUE : FALSE);
416     }
417 
418     // To ASM constant translation
419 
420     private static Handle asmHandle(DirectMethodHandleDesc desc) {
421         int tag = switch(desc.refKind()) {
422             case REF_getField         -&gt; H_GETFIELD;
423             case REF_getStatic        -&gt; H_GETSTATIC;
424             case REF_putField         -&gt; H_PUTFIELD;
425             case REF_putStatic        -&gt; H_PUTSTATIC;
426             case REF_invokeVirtual    -&gt; H_INVOKEVIRTUAL;
</pre>
</td>
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.incubator.jextract.tool;
 26 
 27 import jdk.incubator.foreign.FunctionDescriptor;
 28 import jdk.incubator.foreign.LibraryLookup;
 29 import jdk.incubator.foreign.MemoryAddress;
 30 import jdk.incubator.foreign.MemoryLayout;
<span class="line-added"> 31 import jdk.incubator.foreign.MemorySegment;</span>
 32 import jdk.internal.org.objectweb.asm.ClassWriter;
 33 import jdk.internal.org.objectweb.asm.ConstantDynamic;
 34 import jdk.internal.org.objectweb.asm.Handle;
 35 import jdk.internal.org.objectweb.asm.MethodVisitor;
 36 import jdk.internal.org.objectweb.asm.Type;
 37 
 38 import javax.tools.JavaFileObject;
 39 import javax.tools.SimpleJavaFileObject;
 40 import java.io.ByteArrayInputStream;
 41 import java.io.InputStream;
 42 import java.lang.constant.ClassDesc;
 43 import java.lang.constant.Constable;
 44 import java.lang.constant.ConstantDesc;
 45 import java.lang.constant.ConstantDescs;
 46 import java.lang.constant.DirectMethodHandleDesc;
 47 import java.lang.constant.DirectMethodHandleDesc.Kind;
 48 import java.lang.constant.DynamicConstantDesc;
 49 import java.lang.constant.MethodHandleDesc;
 50 import java.lang.constant.MethodTypeDesc;
 51 import java.lang.invoke.MethodHandle;
</pre>
<hr />
<pre>
 75             desc(methodType(
 76                     VarHandle.class,
 77                     Class.class,
 78                     MemoryLayout.PathElement[].class))
 79     );
 80 
 81     private static final DirectMethodHandleDesc MH_PathElement_groupElement = MethodHandleDesc.ofMethod(
 82             Kind.INTERFACE_STATIC,
 83             desc(MemoryLayout.PathElement.class),
 84             &quot;groupElement&quot;,
 85             desc(methodType(MemoryLayout.PathElement.class, String.class))
 86     );
 87 
 88     private static final DirectMethodHandleDesc MH_MemoryAddress_ofLong = MethodHandleDesc.ofMethod(
 89             Kind.INTERFACE_STATIC,
 90             desc(MemoryAddress.class),
 91             &quot;ofLong&quot;,
 92             desc(methodType(MemoryAddress.class, long.class))
 93     );
 94 
<span class="line-added"> 95     private static final DirectMethodHandleDesc MH_MemorySegment_baseAddress = MethodHandleDesc.ofMethod(</span>
<span class="line-added"> 96             Kind.INTERFACE_VIRTUAL,</span>
<span class="line-added"> 97             desc(MemorySegment.class),</span>
<span class="line-added"> 98             &quot;baseAddress&quot;,</span>
<span class="line-added"> 99             desc(methodType(MemoryAddress.class))</span>
<span class="line-added">100     );</span>
<span class="line-added">101 </span>
102     private static final DirectMethodHandleDesc BSM_GET_STATIC_FINAL = ConstantDescs.ofConstantBootstrap(
103             CD_ConstantBootstraps,
104             &quot;getStaticFinal&quot;,
105             CD_Object,
106             CD_Class
107     );
108 
109     private static final ConstantDesc TRUE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, &quot;TRUE&quot;, ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
110     private static final ConstantDesc FALSE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, &quot;FALSE&quot;, ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
111     private static final ClassDesc CD_PathElelemt = desc(MemoryLayout.PathElement.class);
112     private static final ClassDesc CD_MemoryAddress = desc(MemoryAddress.class);
<span class="line-added">113     private static final ClassDesc CD_MemorySegment = desc(MemorySegment.class);</span>
114 
115     private final DirectMethodHandleDesc MH_downcallHandle;
116     private final DirectMethodHandleDesc MH_lookupGlobalVariable;
117     private final DirectMethodHandleDesc MH_makeCString;
118 
119     private ClassWriter cw;
120     private final String internalClassName;
121     private final ClassDesc CD_constantsHelper;
122     private final ConstantDesc LIBRARIES;
123 
124     private final Map&lt;String, DirectMethodHandleDesc&gt; pool = new HashMap&lt;&gt;();
125 
<span class="line-modified">126     ConstantHelper(String parentClassName, ClassDesc runtimeHelper, ClassDesc cString, String[] libraryNames) {</span>
127         this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
128         String className = parentClassName + &quot;$constants&quot;;
129         this.CD_constantsHelper = ClassDesc.of(className);
130         this.internalClassName = className.replace(&#39;.&#39;, &#39;/&#39;);
131 
132         this.MH_downcallHandle = findRuntimeHelperBootstrap(
133                 runtimeHelper,
134                 &quot;downcallHandle&quot;,
135                 methodType(
136                         MethodHandle.class,
137                         LibraryLookup[].class,
138                         String.class,
139                         String.class,
140                         FunctionDescriptor.class,
141                         boolean.class)
142         );
143         this.MH_lookupGlobalVariable = findRuntimeHelperBootstrap(
144                 runtimeHelper,
145                 &quot;lookupGlobalVariable&quot;,
146                 methodType(
147                         MemoryAddress.class,
148                         LibraryLookup[].class,
149                         String.class)
150         );
151         this.MH_makeCString = findRuntimeHelperBootstrap(
<span class="line-modified">152                 cString,</span>
<span class="line-modified">153                 &quot;toCString&quot;,</span>
154                 methodType(
<span class="line-modified">155                         MemorySegment.class,</span>
156                         String.class)
157         );
158 
159         this.LIBRARIES = librariesDesc(findRuntimeHelperBootstrap(
160                 runtimeHelper,
161                 &quot;libraries&quot;,
162                 methodType(
163                         LibraryLookup[].class,
164                         String[].class)
165         ), libraryNames);
166 
167         cw.visit(V15, ACC_PUBLIC, internalClassName, null, INTR_OBJECT, null);
168     }
169 
170     private static DirectMethodHandleDesc findRuntimeHelperBootstrap(ClassDesc runtimeHelper, String name, MethodType type) {
171         return MethodHandleDesc.ofMethod(
172                 Kind.STATIC,
173                 runtimeHelper,
174                 name,
175                 desc(type)
</pre>
<hr />
<pre>
190 
191     public DirectMethodHandleDesc addAddress(String javaName, String nativeName) {
192         return emitCondyGetter(javaName + &quot;$ADDR&quot;, MemoryAddress.class, globalVarAddressDesc(nativeName));
193     }
194 
195     public DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor fDesc) {
196         return emitCondyGetter(javaName + &quot;$DESC&quot;, FunctionDescriptor.class, desc(fDesc));
197     }
198 
199     public DirectMethodHandleDesc addConstant(String name, Class&lt;?&gt; type, Object value) {
200         if (type == MemoryAddress.class) {
201             if (value instanceof Long) {
202                 return emitCondyGetter(name, type, addressDesc((Long) value));
203             } else if (value instanceof String) {
204                 return emitCondyGetter(name, type, cStringDesc((String) value));
205             } else {
206                 throw new IllegalStateException(&quot;Unhandled constant value type: &quot; + value.getClass());
207             }
208         } else if (type.isPrimitive()) {
209             if (type == int.class || type == byte.class || type == short.class || type == char.class) {
<span class="line-modified">210                 return emitConIntGetter(name, type, ((Long) value).intValue());</span>
211             } else if (type == float.class) {
<span class="line-modified">212                 return emitConFloatGetter(name, type, ((Double) value).floatValue());</span>
213             } else if (type == long.class) {
<span class="line-modified">214                 return emitConLongGetter(name, type, (Long) value);</span>
215             } else if (type == double.class) {
<span class="line-modified">216                 return emitConDoubleGetter(name, type, (Double) value);</span>
217             } else { // boolean and void
218                 throw new IllegalStateException(&quot;Unhandled primitive target type: &quot; + type);
219             }
220         } else if (type == value.getClass() &amp;&amp; value instanceof Constable) {
221             // Constable value that requires no conversion
222             return emitCondyGetter(name, type, desc((Constable) value));
223         } else {
224             System.out.println(&quot;Warning: Skipping constant generation for: &quot; + name + &quot; of type: &quot; + type.getSimpleName()
225                 + &quot; with value: &quot; + value + &quot; of type: &quot; + value.getClass());
226             return null;
227         }
228     }
229 
230     public List&lt;JavaFileObject&gt; getClasses() {
231         cw.visitEnd();
232         byte[] bytes = cw.toByteArray();
233         cw = null;
234         return List.of(jfoFromByteArray(internalClassName, bytes));
235     }
236 
</pre>
<hr />
<pre>
331     }
332 
333     private DirectMethodHandleDesc emitGetter(String name, Class&lt;?&gt; type, Consumer&lt;MethodVisitor&gt; action) {
334         return pool.computeIfAbsent(name, nameKey -&gt; {
335             MethodType mt = methodType(type);
336             MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, nameKey, mt.descriptorString(), null, null);
337             mv.visitCode();
338             action.accept(mv);
339             emitReturn(mv, type);
340             mv.visitMaxs(-1, -1);
341             mv.visitEnd();
342             return MethodHandleDesc.ofMethod(
343                     Kind.STATIC,
344                     CD_constantsHelper,
345                     nameKey,
346                     mt.describeConstable().orElseThrow()
347             );
348         });
349     }
350 
<span class="line-added">351     private DirectMethodHandleDesc emitConDoubleGetter(String name, Class&lt;?&gt; type, double value) {</span>
<span class="line-added">352         return emitGetter(name, type, mv -&gt; emitConDouble(mv, value));</span>
<span class="line-added">353     }</span>
<span class="line-added">354 </span>
<span class="line-added">355     private DirectMethodHandleDesc emitConLongGetter(String name, Class&lt;?&gt; type, long value) {</span>
<span class="line-added">356         return emitGetter(name, type, mv -&gt; emitConLong(mv, value));</span>
<span class="line-added">357     }</span>
<span class="line-added">358 </span>
<span class="line-added">359     private DirectMethodHandleDesc emitConFloatGetter(String name, Class&lt;?&gt; type, float value) {</span>
<span class="line-added">360         return emitGetter(name, type, mv -&gt; emitConFloat(mv, value));</span>
<span class="line-added">361     }</span>
<span class="line-added">362 </span>
<span class="line-added">363     private DirectMethodHandleDesc emitConIntGetter(String name, Class&lt;?&gt; type, int value) {</span>
<span class="line-added">364         return emitGetter(name, type, mv -&gt; emitConInt(mv, value));</span>
<span class="line-added">365     }</span>
<span class="line-added">366 </span>
367     private DirectMethodHandleDesc emitCondyGetter(String name, Class&lt;?&gt; type, ConstantDesc desc) {
368         return emitGetter(name, type, mv -&gt; mv.visitLdcInsn(asmConstant(desc)));
369     }
370 
371     private static void emitReturn(MethodVisitor mv, Class&lt;?&gt; type) {
372         if (type == int.class
373                 || type == short.class
374                 || type == byte.class
375                 || type == char.class
376                 || type == boolean.class) {
377             mv.visitInsn(IRETURN);
378         } else if (type == long.class) {
379             mv.visitInsn(LRETURN);
380         } else if (type == float.class) {
381             mv.visitInsn(FRETURN);
382         } else if (type == double.class) {
383             mv.visitInsn(DRETURN);
384         } else if (type == void.class) {
385             mv.visitInsn(RETURN);
386         } else if (Object.class.isAssignableFrom(type)) {
</pre>
<hr />
<pre>
411         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;groupElement_&quot; + fieldName, CD_PathElelemt, MH_PathElement_groupElement, fieldName);
412     }
413 
414     private static ConstantDesc varHandleDesc(String javaName, String nativeName, MemoryLayout layout, Class&lt;?&gt; type, MemoryLayout parentLayout) {
415         if (parentLayout != null) {
416             return varHandleDesc(javaName, desc(parentLayout), desc(type), groupElementDesc(nativeName));
417         } else {
418             return varHandleDesc(javaName, desc(layout), desc(type));
419         }
420     }
421 
422     private ConstantDesc globalVarAddressDesc(String name) {
423         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;ADDR_&quot; + name, CD_MemoryAddress, MH_lookupGlobalVariable, LIBRARIES, name);
424     }
425 
426     private ConstantDesc addressDesc(long value) {
427         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;MA_&quot; + value, CD_MemoryAddress, MH_MemoryAddress_ofLong, value);
428     }
429 
430     private ConstantDesc cStringDesc(String value) {
<span class="line-modified">431         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;BASEADDRESS&quot;, CD_MemoryAddress, MH_MemorySegment_baseAddress,</span>
<span class="line-added">432             DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;CSTRING&quot;, CD_MemorySegment, MH_makeCString, value)</span>
<span class="line-added">433         );</span>
434     }
435 
436     private ConstantDesc methodHandleDesc(String name, MethodType mtype, FunctionDescriptor funcDesc, boolean varargs) {
437         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;MH_&quot; + name, CD_MethodHandle, MH_downcallHandle,
438             LIBRARIES,
439             name,
440             mtype.descriptorString(),
441             desc(funcDesc),
442             varargs ? TRUE : FALSE);
443     }
444 
445     // To ASM constant translation
446 
447     private static Handle asmHandle(DirectMethodHandleDesc desc) {
448         int tag = switch(desc.refKind()) {
449             case REF_getField         -&gt; H_GETFIELD;
450             case REF_getStatic        -&gt; H_GETSTATIC;
451             case REF_putField         -&gt; H_PUTFIELD;
452             case REF_putStatic        -&gt; H_PUTSTATIC;
453             case REF_invokeVirtual    -&gt; H_INVOKEVIRTUAL;
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JavaSourceBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
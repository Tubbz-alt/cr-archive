diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StaticWrapperSourceFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StaticWrapperSourceFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StaticWrapperSourceFactory.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StaticWrapperSourceFactory.java
@@ -24,19 +24,24 @@
  */
 
 package jdk.incubator.jextract.tool;
 
 import java.lang.invoke.MethodType;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.jextract.Declaration;
 import jdk.incubator.jextract.Type;
 
 public class StaticWrapperSourceFactory extends HandleSourceFactory {
+    private final Set<Declaration.Variable> variables = new HashSet<>();
+    private final Set<Declaration.Function> functions = new HashSet<>();
+
     public StaticWrapperSourceFactory(String clsName, String pkgName, List<String> libraryNames) {
         super(clsName, pkgName, libraryNames);
     }
 
     @Override
@@ -44,10 +49,13 @@
         //do nothing
     }
 
     @Override
     public Void visitFunction(Declaration.Function funcTree, Declaration parent) {
+        if (! functions.add(funcTree)) {
+            return null;
+        }
         MethodType mtype = typeTranslator.getMethodType(funcTree.type());
         FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);
         if (descriptor == null) {
             //abort
             return null;
@@ -89,10 +97,14 @@
         }
     }
 
     @Override
     public Void visitVariable(Declaration.Variable tree, Declaration parent) {
+        if (parent == null && !(variables.add(tree))) {
+            return null;
+        }
+
         String fieldName = tree.name();
         String symbol = tree.name();
         assert !symbol.isEmpty();
         assert !fieldName.isEmpty();
         Type type = tree.type();
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java
@@ -29,10 +29,11 @@
 import java.lang.constant.Constable;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.jextract.Declaration;
 import jdk.incubator.jextract.Position;
@@ -91,13 +92,13 @@
         final Type type;
         final Optional<MemoryLayout> layout;
 
         private VariableImpl(Type type, Optional<MemoryLayout> layout, Variable.Kind kind, String name, Position pos, Map<String, List<Constable>> attrs) {
             super(name, pos, attrs);
-            this.kind = kind;
-            this.type = type;
-            this.layout = layout;
+            this.kind = Objects.requireNonNull(kind);
+            this.type = Objects.requireNonNull(type);
+            this.layout = Objects.requireNonNull(layout);
         }
 
         public VariableImpl(Type type, Variable.Kind kind, String name, Position pos) {
             this(type, LayoutUtils.getLayout(type), kind, name, pos, null);
         }
@@ -133,10 +134,24 @@
 
         @Override
         public Variable stripAttributes() {
             return new VariableImpl(type, layout, kind, name(), pos(), null);
         }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            VariableImpl variable = (VariableImpl) o;
+            return kind == variable.kind &&
+                    type.equals(variable.type);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(kind, type);
+        }
     }
 
     public static class FunctionImpl extends DeclarationImpl implements Declaration.Function {
 
         final List<Variable> params;
@@ -146,12 +161,12 @@
             this(type, params, name, pos, null);
         }
 
         public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos, Map<String, List<Constable>> attrs) {
             super(name, pos, attrs);
-            this.params = params;
-            this.type = type;
+            this.params = Objects.requireNonNull(params);
+            this.type = Objects.requireNonNull(type);
         }
 
         @Override
         public <R, D> R accept(Visitor<R, D> visitor, D data) {
             return visitor.visitFunction(this, data);
@@ -174,10 +189,24 @@
 
         @Override
         public Function stripAttributes() {
             return new FunctionImpl(type, params, name(), pos(), null);
         }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            FunctionImpl function = (FunctionImpl) o;
+            return params.equals(function.params) &&
+                    type.equals(function.type);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(params, type);
+        }
     }
 
     public static class ScopedImpl extends DeclarationImpl implements Declaration.Scoped {
 
         private final Scoped.Kind kind;
@@ -193,13 +222,13 @@
         }
 
         ScopedImpl(Kind kind, Optional<MemoryLayout> optLayout, List<Declaration> declarations,
                 String name, Position pos, Map<String, List<Constable>> attrs) {
             super(name, pos, attrs);
-            this.kind = kind;
-            this.declarations = declarations;
-            this.optLayout = optLayout;
+            this.kind = Objects.requireNonNull(kind);
+            this.declarations = Objects.requireNonNull(declarations);
+            this.optLayout = Objects.requireNonNull(optLayout);
         }
 
         @Override
         public <R, D> R accept(Visitor<R, D> visitor, D data) {
             return visitor.visitScoped(this, data);
@@ -227,10 +256,24 @@
 
         @Override
         public Scoped stripAttributes() {
             return new ScopedImpl(kind, optLayout, declarations, name(), pos(), null);
         }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            ScopedImpl scoped = (ScopedImpl) o;
+            return kind == scoped.kind &&
+                    declarations.equals(scoped.declarations);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(kind, declarations);
+        }
     }
 
     public static class ConstantImpl extends DeclarationImpl implements Declaration.Constant {
 
         final Object value;
@@ -240,12 +283,12 @@
             this(type, value, name, pos, null);
         }
 
         public ConstantImpl(Type type, Object value, String name, Position pos, Map<String, List<Constable>> attrs) {
             super(name, pos, attrs);
-            this.value = value;
-            this.type = type;
+            this.value = Objects.requireNonNull(value);
+            this.type = Objects.requireNonNull(type);
         }
 
         @Override
         public <R, D> R accept(Visitor<R, D> visitor, D data) {
             return visitor.visitConstant(this, data);
@@ -268,7 +311,21 @@
 
         @Override
         public Constant stripAttributes() {
             return new ConstantImpl(type, value, name(), pos(), null);
         }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            ConstantImpl constant = (ConstantImpl) o;
+            return value.equals(constant.value) &&
+                    type.equals(constant.type);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(value, type);
+        }
     }
 }
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeImpl.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeImpl.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeImpl.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeImpl.java
@@ -25,10 +25,11 @@
  */
 
 package jdk.internal.jextract.impl;
 
 import java.util.List;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalLong;
 import java.util.function.Supplier;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.jextract.Declaration;
@@ -51,11 +52,11 @@
         public boolean isErroneous() {
             return true;
         }
     };
 
-    public static class PrimitiveImpl extends TypeImpl implements Type.Primitive {
+    public static final class PrimitiveImpl extends TypeImpl implements Type.Primitive {
 
         private final Primitive.Kind kind;
         private final Optional<MemoryLayout> layoutOpt;
 
         public PrimitiveImpl(Kind kind, MemoryLayout layout) {
@@ -66,12 +67,12 @@
             this(kind, Optional.empty());
         }
 
         private PrimitiveImpl(Kind kind, Optional<MemoryLayout> layoutOpt) {
             super();
-            this.kind = kind;
-            this.layoutOpt = layoutOpt;
+            this.kind = Objects.requireNonNull(kind);
+            this.layoutOpt = Objects.requireNonNull(layoutOpt);
         }
 
         @Override
         public <R, D> R accept(Visitor<R, D> visitor, D data) {
             return visitor.visitPrimitive(this, data);
@@ -84,19 +85,32 @@
 
         @Override
         public Optional<MemoryLayout> layout() {
             return layoutOpt;
         }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            PrimitiveImpl primitive = (PrimitiveImpl) o;
+            return kind == primitive.kind;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(kind);
+        }
     }
 
     static abstract class DelegatedBase extends TypeImpl implements Type.Delegated {
         Delegated.Kind kind;
         Optional<String> name;
 
         DelegatedBase(Kind kind, Optional<String> name) {
-            this.kind = kind;
-            this.name = name;
+            this.kind = Objects.requireNonNull(kind);
+            this.name = Objects.requireNonNull(name);
         }
 
         @Override
         public <R, D> R accept(Visitor<R, D> visitor, D data) {
             return visitor.visitDelegated(this, data);
@@ -109,10 +123,24 @@
 
         @Override
         public Optional<String> name() {
             return name;
         }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            DelegatedBase that = (DelegatedBase) o;
+            return kind == that.kind &&
+                    name.equals(that.name);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(kind, name);
+        }
     }
 
     public static class QualifiedImpl extends DelegatedBase {
         private final Type type;
 
@@ -131,18 +159,32 @@
 
         @Override
         public Type type() {
             return type;
         }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            if (!super.equals(o)) return false;
+            QualifiedImpl qualified = (QualifiedImpl) o;
+            return Objects.equals(type, qualified.type);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(super.hashCode(), type);
+        }
     }
 
     public static class PointerImpl extends DelegatedBase {
         private final Supplier<Type> pointeeFactory;
 
         public PointerImpl(Supplier<Type> pointeeFactory) {
             super(Kind.POINTER, Optional.empty());
-            this.pointeeFactory = pointeeFactory;
+            this.pointeeFactory = Objects.requireNonNull(pointeeFactory);
         }
 
         public PointerImpl(Type pointee) {
             this(() -> pointee);
         }
@@ -157,11 +199,11 @@
 
         private final Declaration.Scoped declaration;
 
         public DeclaredImpl(Declaration.Scoped declaration) {
             super();
-            this.declaration = declaration;
+            this.declaration = Objects.requireNonNull(declaration);
         }
 
         @Override
         public <R, D> R accept(Visitor<R, D> visitor, D data) {
             return visitor.visitDeclared(this, data);
@@ -169,10 +211,23 @@
 
         @Override
         public Declaration.Scoped tree() {
             return declaration;
         }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            DeclaredImpl declared = (DeclaredImpl) o;
+            return declaration.equals(declared.declaration);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(declaration);
+        }
     }
 
     public static class FunctionImpl extends TypeImpl implements Type.Function {
 
         private final boolean varargs;
@@ -180,12 +235,12 @@
         private final Type restype;
 
         public FunctionImpl(boolean varargs, List<Type> argtypes, Type restype) {
             super();
             this.varargs = varargs;
-            this.argtypes = argtypes;
-            this.restype = restype;
+            this.argtypes = Objects.requireNonNull(argtypes);
+            this.restype = Objects.requireNonNull(restype);
         }
 
         @Override
         public <R, D> R accept(Visitor<R, D> visitor, D data) {
             return visitor.visitFunction(this, data);
@@ -203,10 +258,25 @@
 
         @Override
         public Type returnType() {
             return restype;
         }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            FunctionImpl function = (FunctionImpl) o;
+            return varargs == function.varargs &&
+                    argtypes.equals(function.argtypes) &&
+                    restype.equals(function.restype);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(varargs, argtypes, restype);
+        }
     }
 
     public static class ArrayImpl extends TypeImpl implements Type.Array {
 
         private final Kind kind;
@@ -221,13 +291,13 @@
             this(kind, elemType, OptionalLong.empty());
         }
 
         private ArrayImpl(Kind kind, Type elemType, OptionalLong elemCount) {
             super();
-            this.kind = kind;
-            this.elemCount = elemCount;
-            this.elemType = elemType;
+            this.kind = Objects.requireNonNull(kind);
+            this.elemCount = Objects.requireNonNull(elemCount);
+            this.elemType = Objects.requireNonNull(elemType);
         }
 
         @Override
         public <R, D> R accept(Visitor<R, D> visitor, D data) {
             return visitor.visitArray(this, data);
@@ -245,10 +315,24 @@
 
         @Override
         public Kind kind() {
             return kind;
         }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            ArrayImpl array = (ArrayImpl) o;
+            return kind == array.kind &&
+                    elemType.equals(array.elemType);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(kind, elemType);
+        }
     }
 
     @Override
     public String toString() {
         return PrettyPrinter.type(this);
diff a/test/jdk/tools/jextract/RepeatedDeclsTest.java b/test/jdk/tools/jextract/RepeatedDeclsTest.java
--- /dev/null
+++ b/test/jdk/tools/jextract/RepeatedDeclsTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import org.testng.annotations.Test;
+
+import java.lang.reflect.Method;
+import java.nio.file.Path;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+
+/*
+ * @test
+ * @bug 8240300
+ * @summary jextract produces non compilable code with repeated declarations
+ * @modules jdk.incubator.jextract
+ * @build JextractToolRunner
+ * @run testng RepeatedDeclsTest
+ */
+public class RepeatedDeclsTest extends JextractToolRunner {
+    @Test
+    public void repeatedDecls() {
+        Path repeatedDeclsOutput = getOutputFilePath("repeatedDeclsgen");
+        Path repeatedDeclsH = getInputFilePath("repeatedDecls.h");
+        run("-d", repeatedDeclsOutput.toString(), repeatedDeclsH.toString()).checkSuccess();
+        try(Loader loader = classLoader(repeatedDeclsOutput)) {
+            Class<?> cls = loader.loadClass("repeatedDecls_h");
+            // check a method for "void func(int)"
+            assertNotNull(findMethod(cls, "func", int.class));
+
+            // check a getter method for "i"
+            assertNotNull(findMethod(cls, "i$get"));
+
+            // check a setter method for "i"
+            assertNotNull(findMethod(cls, "i$set", int.class));
+        } finally {
+            deleteDir(repeatedDeclsOutput);
+        }
+    }
+}
diff a/test/jdk/tools/jextract/repeatedDecls.h b/test/jdk/tools/jextract/repeatedDecls.h
--- /dev/null
+++ b/test/jdk/tools/jextract/repeatedDecls.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+struct Point;
+struct Point;
+
+int i;
+int i;
+
+void func(int);
+void func(int);
+
+struct Point;
+struct Point {
+   int i;
+   int j;
+};
+
+struct Point3D {
+    int i;
+    int j;
+    int k;
+};
+struct Point3D;
+
+enum RGBColor;
+enum RGBColor {
+   R, G, B
+};
+
+enum CMYColor {
+  C, M, Y
+};
+enum CMYColor;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DeclarationImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../test/jdk/tools/jextract/JextractToolProviderTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 
 27 package jdk.internal.jextract.impl;
 28 
 29 import java.util.List;

 30 import java.util.Optional;
 31 import java.util.OptionalLong;
 32 import java.util.function.Supplier;
 33 import jdk.incubator.foreign.MemoryLayout;
 34 import jdk.incubator.jextract.Declaration;
 35 import jdk.incubator.jextract.Type;
 36 
 37 public abstract class TypeImpl implements Type {
 38 
 39     @Override
 40     public boolean isErroneous() {
 41         return false;
 42     }
 43 







 44     public static final TypeImpl ERROR = new TypeImpl() {
 45         @Override
 46         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
 47             return visitor.visitType(this, data);
 48         }
 49 
 50         @Override
 51         public boolean isErroneous() {
 52             return true;
 53         }
 54     };
 55 
<span class="line-modified"> 56     public static class PrimitiveImpl extends TypeImpl implements Type.Primitive {</span>
 57 
 58         private final Primitive.Kind kind;
 59         private final Optional&lt;MemoryLayout&gt; layoutOpt;
 60 
 61         public PrimitiveImpl(Kind kind, MemoryLayout layout) {
 62             this(kind, Optional.of(layout));
 63         }
 64 
 65         public PrimitiveImpl(Kind kind) {
 66             this(kind, Optional.empty());
 67         }
 68 
 69         private PrimitiveImpl(Kind kind, Optional&lt;MemoryLayout&gt; layoutOpt) {
 70             super();
<span class="line-modified"> 71             this.kind = kind;</span>
<span class="line-modified"> 72             this.layoutOpt = layoutOpt;</span>
 73         }
 74 
 75         @Override
 76         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
 77             return visitor.visitPrimitive(this, data);
 78         }
 79 
 80         @Override
 81         public Kind kind() {
 82             return kind;
 83         }
 84 
 85         @Override
 86         public Optional&lt;MemoryLayout&gt; layout() {
 87             return layoutOpt;
 88         }















 89     }
 90 
 91     static abstract class DelegatedBase extends TypeImpl implements Type.Delegated {
 92         Delegated.Kind kind;
 93         Optional&lt;String&gt; name;
 94 
 95         DelegatedBase(Kind kind, Optional&lt;String&gt; name) {
<span class="line-modified"> 96             this.kind = kind;</span>
<span class="line-modified"> 97             this.name = name;</span>
 98         }
 99 
100         @Override
101         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
102             return visitor.visitDelegated(this, data);
103         }
104 
105         @Override
<span class="line-modified">106         public Delegated.Kind kind() {</span>
107             return kind;
108         }
109 
110         @Override
<span class="line-modified">111         public Optional&lt;String&gt; name() {</span>
112             return name;
113         }
















114     }
115 
<span class="line-modified">116     public static class QualifiedImpl extends DelegatedBase {</span>
117         private final Type type;
118 
119         public QualifiedImpl(Kind kind, Type type) {
120             this(kind, Optional.empty(), type);
121         }
122 
123         public QualifiedImpl(Kind kind, String name, Type type) {
124             this(kind, Optional.of(name), type);
125         }
126 
127         private QualifiedImpl(Kind kind, Optional&lt;String&gt; name, Type type) {
128             super(kind, name);
129             this.type = type;
130         }
131 
132         @Override
133         public Type type() {
134             return type;
135         }
















136     }
137 
<span class="line-modified">138     public static class PointerImpl extends DelegatedBase {</span>
139         private final Supplier&lt;Type&gt; pointeeFactory;
140 
141         public PointerImpl(Supplier&lt;Type&gt; pointeeFactory) {
142             super(Kind.POINTER, Optional.empty());
<span class="line-modified">143             this.pointeeFactory = pointeeFactory;</span>
144         }
145 
146         public PointerImpl(Type pointee) {
147             this(() -&gt; pointee);
148         }
149 
150         @Override
151         public Type type() {
152             return pointeeFactory.get();
153         }
154     }
155 
<span class="line-modified">156     public static class DeclaredImpl extends TypeImpl implements Type.Declared {</span>
157 
158         private final Declaration.Scoped declaration;
159 
160         public DeclaredImpl(Declaration.Scoped declaration) {
161             super();
<span class="line-modified">162             this.declaration = declaration;</span>
163         }
164 
165         @Override
166         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
167             return visitor.visitDeclared(this, data);
168         }
169 
170         @Override
171         public Declaration.Scoped tree() {
172             return declaration;
173         }















174     }
175 
<span class="line-modified">176     public static class FunctionImpl extends TypeImpl implements Type.Function {</span>
177 
178         private final boolean varargs;
179         private final List&lt;Type&gt; argtypes;
180         private final Type restype;
181 
182         public FunctionImpl(boolean varargs, List&lt;Type&gt; argtypes, Type restype) {
183             super();
184             this.varargs = varargs;
<span class="line-modified">185             this.argtypes = argtypes;</span>
<span class="line-modified">186             this.restype = restype;</span>
187         }
188 
189         @Override
190         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
191             return visitor.visitFunction(this, data);
192         }
193 
194         @Override
195         public boolean varargs() {
196             return varargs;
197         }
198 
199         @Override
200         public List&lt;Type&gt; argumentTypes() {
201             return argtypes;
202         }
203 
204         @Override
205         public Type returnType() {
206             return restype;
207         }

















208     }
209 
<span class="line-modified">210     public static class ArrayImpl extends TypeImpl implements Type.Array {</span>
211 
212         private final Kind kind;
213         private final OptionalLong elemCount;
214         private final Type elemType;
215 
216         public ArrayImpl(Kind kind, long count, Type elemType) {
217             this(kind, elemType, OptionalLong.of(count));
218         }
219 
220         public ArrayImpl(Kind kind, Type elemType) {
221             this(kind, elemType, OptionalLong.empty());
222         }
223 
224         private ArrayImpl(Kind kind, Type elemType, OptionalLong elemCount) {
225             super();
<span class="line-modified">226             this.kind = kind;</span>
<span class="line-modified">227             this.elemCount = elemCount;</span>
<span class="line-modified">228             this.elemType = elemType;</span>
229         }
230 
231         @Override
232         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
233             return visitor.visitArray(this, data);
234         }
235 
236         @Override
237         public OptionalLong elementCount() {
238             return elemCount;
239         }
240 
241         @Override
242         public Type elementType() {
243             return elemType;
244         }
245 
246         @Override
247         public Kind kind() {
248             return kind;
249         }
















250     }
251 
252     @Override
253     public String toString() {
254         return PrettyPrinter.type(this);
255     }
256 }
</pre>
</td>
<td>
<hr />
<pre>
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 
 27 package jdk.internal.jextract.impl;
 28 
 29 import java.util.List;
<span class="line-added"> 30 import java.util.Objects;</span>
 31 import java.util.Optional;
 32 import java.util.OptionalLong;
 33 import java.util.function.Supplier;
 34 import jdk.incubator.foreign.MemoryLayout;
 35 import jdk.incubator.jextract.Declaration;
 36 import jdk.incubator.jextract.Type;
 37 
 38 public abstract class TypeImpl implements Type {
 39 
 40     @Override
 41     public boolean isErroneous() {
 42         return false;
 43     }
 44 
<span class="line-added"> 45     static boolean equals(Type t1, Type.Delegated t2) {</span>
<span class="line-added"> 46         assert t1 != null;</span>
<span class="line-added"> 47         assert t2 != null;</span>
<span class="line-added"> 48 </span>
<span class="line-added"> 49         return (t2.kind() == Delegated.Kind.TYPEDEF)? t1.equals(t2.type()) : false;</span>
<span class="line-added"> 50     }</span>
<span class="line-added"> 51 </span>
 52     public static final TypeImpl ERROR = new TypeImpl() {
 53         @Override
 54         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
 55             return visitor.visitType(this, data);
 56         }
 57 
 58         @Override
 59         public boolean isErroneous() {
 60             return true;
 61         }
 62     };
 63 
<span class="line-modified"> 64     public static final class PrimitiveImpl extends TypeImpl implements Type.Primitive {</span>
 65 
 66         private final Primitive.Kind kind;
 67         private final Optional&lt;MemoryLayout&gt; layoutOpt;
 68 
 69         public PrimitiveImpl(Kind kind, MemoryLayout layout) {
 70             this(kind, Optional.of(layout));
 71         }
 72 
 73         public PrimitiveImpl(Kind kind) {
 74             this(kind, Optional.empty());
 75         }
 76 
 77         private PrimitiveImpl(Kind kind, Optional&lt;MemoryLayout&gt; layoutOpt) {
 78             super();
<span class="line-modified"> 79             this.kind = Objects.requireNonNull(kind);</span>
<span class="line-modified"> 80             this.layoutOpt = Objects.requireNonNull(layoutOpt);</span>
 81         }
 82 
 83         @Override
 84         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
 85             return visitor.visitPrimitive(this, data);
 86         }
 87 
 88         @Override
 89         public Kind kind() {
 90             return kind;
 91         }
 92 
 93         @Override
 94         public Optional&lt;MemoryLayout&gt; layout() {
 95             return layoutOpt;
 96         }
<span class="line-added"> 97 </span>
<span class="line-added"> 98         @Override</span>
<span class="line-added"> 99         public boolean equals(Object o) {</span>
<span class="line-added">100             if (this == o) return true;</span>
<span class="line-added">101             if (!(o instanceof Type.Primitive)) {</span>
<span class="line-added">102                 return (o instanceof Type.Delegated)? equals(this, (Type.Delegated)o) : false;</span>
<span class="line-added">103             }</span>
<span class="line-added">104             Type.Primitive primitive = (Type.Primitive) o;</span>
<span class="line-added">105             return kind == primitive.kind();</span>
<span class="line-added">106         }</span>
<span class="line-added">107 </span>
<span class="line-added">108         @Override</span>
<span class="line-added">109         public int hashCode() {</span>
<span class="line-added">110             return Objects.hash(kind);</span>
<span class="line-added">111         }</span>
112     }
113 
114     static abstract class DelegatedBase extends TypeImpl implements Type.Delegated {
115         Delegated.Kind kind;
116         Optional&lt;String&gt; name;
117 
118         DelegatedBase(Kind kind, Optional&lt;String&gt; name) {
<span class="line-modified">119             this.kind = Objects.requireNonNull(kind);</span>
<span class="line-modified">120             this.name = Objects.requireNonNull(name);</span>
121         }
122 
123         @Override
124         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
125             return visitor.visitDelegated(this, data);
126         }
127 
128         @Override
<span class="line-modified">129         public final Delegated.Kind kind() {</span>
130             return kind;
131         }
132 
133         @Override
<span class="line-modified">134         public final Optional&lt;String&gt; name() {</span>
135             return name;
136         }
<span class="line-added">137 </span>
<span class="line-added">138         @Override</span>
<span class="line-added">139         public boolean equals(Object o) {</span>
<span class="line-added">140             if (this == o) return true;</span>
<span class="line-added">141             if (!(o instanceof Type.Delegated)) {</span>
<span class="line-added">142                 return (o instanceof Type)? equals((Type)o, this) : false;</span>
<span class="line-added">143             }</span>
<span class="line-added">144             Type.Delegated that = (Type.Delegated) o;</span>
<span class="line-added">145             return kind == that.kind() &amp;&amp;</span>
<span class="line-added">146                     name.equals(that.name());</span>
<span class="line-added">147         }</span>
<span class="line-added">148 </span>
<span class="line-added">149         @Override</span>
<span class="line-added">150         public int hashCode() {</span>
<span class="line-added">151             return Objects.hash(kind, name);</span>
<span class="line-added">152         }</span>
153     }
154 
<span class="line-modified">155     public static final class QualifiedImpl extends DelegatedBase {</span>
156         private final Type type;
157 
158         public QualifiedImpl(Kind kind, Type type) {
159             this(kind, Optional.empty(), type);
160         }
161 
162         public QualifiedImpl(Kind kind, String name, Type type) {
163             this(kind, Optional.of(name), type);
164         }
165 
166         private QualifiedImpl(Kind kind, Optional&lt;String&gt; name, Type type) {
167             super(kind, name);
168             this.type = type;
169         }
170 
171         @Override
172         public Type type() {
173             return type;
174         }
<span class="line-added">175 </span>
<span class="line-added">176         @Override</span>
<span class="line-added">177         public boolean equals(Object o) {</span>
<span class="line-added">178             if (this == o) return true;</span>
<span class="line-added">179             if (!(o instanceof Type.Delegated)) return false;</span>
<span class="line-added">180             if (!super.equals(o)) {</span>
<span class="line-added">181                 return (o instanceof Type.Delegated)? equals(this, (Type.Delegated)o) : false;</span>
<span class="line-added">182             }</span>
<span class="line-added">183             Type.Delegated qualified = (Type.Delegated) o;</span>
<span class="line-added">184             return Objects.equals(type, qualified.type());</span>
<span class="line-added">185         }</span>
<span class="line-added">186 </span>
<span class="line-added">187         @Override</span>
<span class="line-added">188         public int hashCode() {</span>
<span class="line-added">189             return (kind() == Kind.TYPEDEF)? type().hashCode() : Objects.hash(super.hashCode(), type);</span>
<span class="line-added">190         }</span>
191     }
192 
<span class="line-modified">193     public static final class PointerImpl extends DelegatedBase {</span>
194         private final Supplier&lt;Type&gt; pointeeFactory;
195 
196         public PointerImpl(Supplier&lt;Type&gt; pointeeFactory) {
197             super(Kind.POINTER, Optional.empty());
<span class="line-modified">198             this.pointeeFactory = Objects.requireNonNull(pointeeFactory);</span>
199         }
200 
201         public PointerImpl(Type pointee) {
202             this(() -&gt; pointee);
203         }
204 
205         @Override
206         public Type type() {
207             return pointeeFactory.get();
208         }
209     }
210 
<span class="line-modified">211     public static final class DeclaredImpl extends TypeImpl implements Type.Declared {</span>
212 
213         private final Declaration.Scoped declaration;
214 
215         public DeclaredImpl(Declaration.Scoped declaration) {
216             super();
<span class="line-modified">217             this.declaration = Objects.requireNonNull(declaration);</span>
218         }
219 
220         @Override
221         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
222             return visitor.visitDeclared(this, data);
223         }
224 
225         @Override
226         public Declaration.Scoped tree() {
227             return declaration;
228         }
<span class="line-added">229 </span>
<span class="line-added">230         @Override</span>
<span class="line-added">231         public boolean equals(Object o) {</span>
<span class="line-added">232             if (this == o) return true;</span>
<span class="line-added">233             if (!(o instanceof Type.Declared)) {</span>
<span class="line-added">234                 return (o instanceof Type.Delegated)? equals(this, (Type.Delegated)o) : false;</span>
<span class="line-added">235             }</span>
<span class="line-added">236             Type.Declared declared = (Type.Declared) o;</span>
<span class="line-added">237             return declaration.equals(declared.tree());</span>
<span class="line-added">238         }</span>
<span class="line-added">239 </span>
<span class="line-added">240         @Override</span>
<span class="line-added">241         public int hashCode() {</span>
<span class="line-added">242             return Objects.hash(declaration);</span>
<span class="line-added">243         }</span>
244     }
245 
<span class="line-modified">246     public static final class FunctionImpl extends TypeImpl implements Type.Function {</span>
247 
248         private final boolean varargs;
249         private final List&lt;Type&gt; argtypes;
250         private final Type restype;
251 
252         public FunctionImpl(boolean varargs, List&lt;Type&gt; argtypes, Type restype) {
253             super();
254             this.varargs = varargs;
<span class="line-modified">255             this.argtypes = Objects.requireNonNull(argtypes);</span>
<span class="line-modified">256             this.restype = Objects.requireNonNull(restype);</span>
257         }
258 
259         @Override
260         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
261             return visitor.visitFunction(this, data);
262         }
263 
264         @Override
265         public boolean varargs() {
266             return varargs;
267         }
268 
269         @Override
270         public List&lt;Type&gt; argumentTypes() {
271             return argtypes;
272         }
273 
274         @Override
275         public Type returnType() {
276             return restype;
277         }
<span class="line-added">278 </span>
<span class="line-added">279         @Override</span>
<span class="line-added">280         public boolean equals(Object o) {</span>
<span class="line-added">281             if (this == o) return true;</span>
<span class="line-added">282             if (!(o instanceof Type.Function)) {</span>
<span class="line-added">283                 return (o instanceof Type.Delegated)? equals(this, (Type.Delegated)o) : false;</span>
<span class="line-added">284             }</span>
<span class="line-added">285             Type.Function function = (Type.Function) o;</span>
<span class="line-added">286             return varargs == function.varargs() &amp;&amp;</span>
<span class="line-added">287                     argtypes.equals(function.argumentTypes()) &amp;&amp;</span>
<span class="line-added">288                     restype.equals(function.returnType());</span>
<span class="line-added">289         }</span>
<span class="line-added">290 </span>
<span class="line-added">291         @Override</span>
<span class="line-added">292         public int hashCode() {</span>
<span class="line-added">293             return Objects.hash(varargs, argtypes, restype);</span>
<span class="line-added">294         }</span>
295     }
296 
<span class="line-modified">297     public static final class ArrayImpl extends TypeImpl implements Type.Array {</span>
298 
299         private final Kind kind;
300         private final OptionalLong elemCount;
301         private final Type elemType;
302 
303         public ArrayImpl(Kind kind, long count, Type elemType) {
304             this(kind, elemType, OptionalLong.of(count));
305         }
306 
307         public ArrayImpl(Kind kind, Type elemType) {
308             this(kind, elemType, OptionalLong.empty());
309         }
310 
311         private ArrayImpl(Kind kind, Type elemType, OptionalLong elemCount) {
312             super();
<span class="line-modified">313             this.kind = Objects.requireNonNull(kind);</span>
<span class="line-modified">314             this.elemCount = Objects.requireNonNull(elemCount);</span>
<span class="line-modified">315             this.elemType = Objects.requireNonNull(elemType);</span>
316         }
317 
318         @Override
319         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
320             return visitor.visitArray(this, data);
321         }
322 
323         @Override
324         public OptionalLong elementCount() {
325             return elemCount;
326         }
327 
328         @Override
329         public Type elementType() {
330             return elemType;
331         }
332 
333         @Override
334         public Kind kind() {
335             return kind;
336         }
<span class="line-added">337 </span>
<span class="line-added">338         @Override</span>
<span class="line-added">339         public boolean equals(Object o) {</span>
<span class="line-added">340             if (this == o) return true;</span>
<span class="line-added">341             if (!(o instanceof Type.Array)) {</span>
<span class="line-added">342                 return (o instanceof Type.Delegated)? equals(this, (Type.Delegated)o) : false;</span>
<span class="line-added">343             }</span>
<span class="line-added">344             Type.Array array = (Type.Array) o;</span>
<span class="line-added">345             return kind == array.kind() &amp;&amp;</span>
<span class="line-added">346                     elemType.equals(array.elementType());</span>
<span class="line-added">347         }</span>
<span class="line-added">348 </span>
<span class="line-added">349         @Override</span>
<span class="line-added">350         public int hashCode() {</span>
<span class="line-added">351             return Objects.hash(kind, elemType);</span>
<span class="line-added">352         }</span>
353     }
354 
355     @Override
356     public String toString() {
357         return PrettyPrinter.type(this);
358     }
359 }
</pre>
</td>
</tr>
</table>
<center><a href="DeclarationImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../test/jdk/tools/jextract/JextractToolProviderTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/VarHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import java.lang.constant.ClassDesc;
  29 import java.lang.constant.Constable;
  30 import java.lang.constant.ConstantDesc;
  31 import java.lang.constant.ConstantDescs;
  32 import java.lang.constant.DirectMethodHandleDesc;
  33 import java.lang.constant.DynamicConstantDesc;
  34 import java.util.HashMap;
  35 import java.util.List;
  36 import java.util.Map;
  37 import java.util.Objects;
  38 import java.util.Optional;
  39 import java.util.function.BiFunction;
  40 import java.util.function.Function;
  41 
  42 import jdk.internal.HotSpotIntrinsicCandidate;
  43 import jdk.internal.util.Preconditions;
  44 import jdk.internal.vm.annotation.ForceInline;
  45 import jdk.internal.vm.annotation.Stable;
  46 
  47 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  48 
  49 /**
  50  * A VarHandle is a dynamically strongly typed reference to a variable, or to a
  51  * parametrically-defined family of variables, including static fields,
  52  * non-static fields, array elements, or components of an off-heap data
  53  * structure.  Access to such variables is supported under various
  54  * &lt;em&gt;access modes&lt;/em&gt;, including plain read/write access, volatile
  55  * read/write access, and compare-and-set.
  56  *
  57  * &lt;p&gt;VarHandles are immutable and have no visible state.  VarHandles cannot be
  58  * subclassed by the user.
  59  *
  60  * &lt;p&gt;A VarHandle has:
  61  * &lt;ul&gt;
  62  * &lt;li&gt;a {@link #varType variable type} T, the type of every variable referenced
  63  * by this VarHandle; and
  64  * &lt;li&gt;a list of {@link #coordinateTypes coordinate types}
  65  * {@code CT1, CT2, ..., CTn}, the types of &lt;em&gt;coordinate expressions&lt;/em&gt; that
  66  * jointly locate a variable referenced by this VarHandle.
  67  * &lt;/ul&gt;
  68  * Variable and coordinate types may be primitive or reference, and are
  69  * represented by {@code Class} objects.  The list of coordinate types may be
  70  * empty.
  71  *
  72  * &lt;p&gt;Factory methods that produce or {@link java.lang.invoke.MethodHandles.Lookup
  73  * lookup} VarHandle instances document the supported variable type and the list
  74  * of coordinate types.
  75  *
  76  * &lt;p&gt;Each access mode is associated with one &lt;em&gt;access mode method&lt;/em&gt;, a
  77  * &lt;a href=&quot;MethodHandle.html#sigpoly&quot;&gt;signature polymorphic&lt;/a&gt; method named
  78  * for the access mode.  When an access mode method is invoked on a VarHandle
  79  * instance, the initial arguments to the invocation are coordinate expressions
  80  * that indicate in precisely which object the variable is to be accessed.
  81  * Trailing arguments to the invocation represent values of importance to the
  82  * access mode.  For example, the various compare-and-set or compare-and-exchange
  83  * access modes require two trailing arguments for the variable&#39;s expected value
  84  * and new value.
  85  *
  86  * &lt;p&gt;The arity and types of arguments to the invocation of an access mode
  87  * method are not checked statically.  Instead, each access mode method
  88  * specifies an {@link #accessModeType(AccessMode) access mode type},
  89  * represented as an instance of {@link MethodType}, that serves as a kind of
  90  * method signature against which the arguments are checked dynamically.  An
  91  * access mode type gives formal parameter types in terms of the coordinate
  92  * types of a VarHandle instance and the types for values of importance to the
  93  * access mode.  An access mode type also gives a return type, often in terms of
  94  * the variable type of a VarHandle instance.  When an access mode method is
  95  * invoked on a VarHandle instance, the symbolic type descriptor at the
  96  * call site, the run time types of arguments to the invocation, and the run
  97  * time type of the return value, must &lt;a href=&quot;#invoke&quot;&gt;match&lt;/a&gt; the types
  98  * given in the access mode type.  A runtime exception will be thrown if the
  99  * match fails.
 100  *
 101  * For example, the access mode method {@link #compareAndSet} specifies that if
 102  * its receiver is a VarHandle instance with coordinate types
 103  * {@code CT1, ..., CTn} and variable type {@code T}, then its access mode type
 104  * is {@code (CT1 c1, ..., CTn cn, T expectedValue, T newValue)boolean}.
 105  * Suppose that a VarHandle instance can access array elements, and that its
 106  * coordinate types are {@code String[]} and {@code int} while its variable type
 107  * is {@code String}.  The access mode type for {@code compareAndSet} on this
 108  * VarHandle instance would be
 109  * {@code (String[] c1, int c2, String expectedValue, String newValue)boolean}.
 110  * Such a VarHandle instance may be produced by the
 111  * {@link MethodHandles#arrayElementVarHandle(Class) array factory method} and
 112  * access array elements as follows:
 113  * &lt;pre&gt; {@code
 114  * String[] sa = ...
 115  * VarHandle avh = MethodHandles.arrayElementVarHandle(String[].class);
 116  * boolean r = avh.compareAndSet(sa, 10, &quot;expected&quot;, &quot;new&quot;);
 117  * }&lt;/pre&gt;
 118  *
 119  * &lt;p&gt;Access modes control atomicity and consistency properties.
 120  * &lt;em&gt;Plain&lt;/em&gt; read ({@code get}) and write ({@code set})
 121  * accesses are guaranteed to be bitwise atomic only for references
 122  * and for primitive values of at most 32 bits, and impose no observable
 123  * ordering constraints with respect to threads other than the
 124  * executing thread. &lt;em&gt;Opaque&lt;/em&gt; operations are bitwise atomic and
 125  * coherently ordered with respect to accesses to the same variable.
 126  * In addition to obeying Opaque properties, &lt;em&gt;Acquire&lt;/em&gt; mode
 127  * reads and their subsequent accesses are ordered after matching
 128  * &lt;em&gt;Release&lt;/em&gt; mode writes and their previous accesses.  In
 129  * addition to obeying Acquire and Release properties, all
 130  * &lt;em&gt;Volatile&lt;/em&gt; operations are totally ordered with respect to
 131  * each other.
 132  *
 133  * &lt;p&gt;Access modes are grouped into the following categories:
 134  * &lt;ul&gt;
 135  * &lt;li&gt;read access modes that get the value of a variable under specified
 136  * memory ordering effects.
 137  * The set of corresponding access mode methods belonging to this group
 138  * consists of the methods
 139  * {@link #get get},
 140  * {@link #getVolatile getVolatile},
 141  * {@link #getAcquire getAcquire},
 142  * {@link #getOpaque getOpaque}.
 143  * &lt;li&gt;write access modes that set the value of a variable under specified
 144  * memory ordering effects.
 145  * The set of corresponding access mode methods belonging to this group
 146  * consists of the methods
 147  * {@link #set set},
 148  * {@link #setVolatile setVolatile},
 149  * {@link #setRelease setRelease},
 150  * {@link #setOpaque setOpaque}.
 151  * &lt;li&gt;atomic update access modes that, for example, atomically compare and set
 152  * the value of a variable under specified memory ordering effects.
 153  * The set of corresponding access mode methods belonging to this group
 154  * consists of the methods
 155  * {@link #compareAndSet compareAndSet},
 156  * {@link #weakCompareAndSetPlain weakCompareAndSetPlain},
 157  * {@link #weakCompareAndSet weakCompareAndSet},
 158  * {@link #weakCompareAndSetAcquire weakCompareAndSetAcquire},
 159  * {@link #weakCompareAndSetRelease weakCompareAndSetRelease},
 160  * {@link #compareAndExchangeAcquire compareAndExchangeAcquire},
 161  * {@link #compareAndExchange compareAndExchange},
 162  * {@link #compareAndExchangeRelease compareAndExchangeRelease},
 163  * {@link #getAndSet getAndSet},
 164  * {@link #getAndSetAcquire getAndSetAcquire},
 165  * {@link #getAndSetRelease getAndSetRelease}.
 166  * &lt;li&gt;numeric atomic update access modes that, for example, atomically get and
 167  * set with addition the value of a variable under specified memory ordering
 168  * effects.
 169  * The set of corresponding access mode methods belonging to this group
 170  * consists of the methods
 171  * {@link #getAndAdd getAndAdd},
 172  * {@link #getAndAddAcquire getAndAddAcquire},
 173  * {@link #getAndAddRelease getAndAddRelease},
 174  * &lt;li&gt;bitwise atomic update access modes that, for example, atomically get and
 175  * bitwise OR the value of a variable under specified memory ordering
 176  * effects.
 177  * The set of corresponding access mode methods belonging to this group
 178  * consists of the methods
 179  * {@link #getAndBitwiseOr getAndBitwiseOr},
 180  * {@link #getAndBitwiseOrAcquire getAndBitwiseOrAcquire},
 181  * {@link #getAndBitwiseOrRelease getAndBitwiseOrRelease},
 182  * {@link #getAndBitwiseAnd getAndBitwiseAnd},
 183  * {@link #getAndBitwiseAndAcquire getAndBitwiseAndAcquire},
 184  * {@link #getAndBitwiseAndRelease getAndBitwiseAndRelease},
 185  * {@link #getAndBitwiseXor getAndBitwiseXor},
 186  * {@link #getAndBitwiseXorAcquire getAndBitwiseXorAcquire},
 187  * {@link #getAndBitwiseXorRelease getAndBitwiseXorRelease}.
 188  * &lt;/ul&gt;
 189  *
 190  * &lt;p&gt;Factory methods that produce or {@link java.lang.invoke.MethodHandles.Lookup
 191  * lookup} VarHandle instances document the set of access modes that are
 192  * supported, which may also include documenting restrictions based on the
 193  * variable type and whether a variable is read-only.  If an access mode is not
 194  * supported then the corresponding access mode method will on invocation throw
 195  * an {@code UnsupportedOperationException}.  Factory methods should document
 196  * any additional undeclared exceptions that may be thrown by access mode
 197  * methods.
 198  * The {@link #get get} access mode is supported for all
 199  * VarHandle instances and the corresponding method never throws
 200  * {@code UnsupportedOperationException}.
 201  * If a VarHandle references a read-only variable (for example a {@code final}
 202  * field) then write, atomic update, numeric atomic update, and bitwise atomic
 203  * update access modes are not supported and corresponding methods throw
 204  * {@code UnsupportedOperationException}.
 205  * Read/write access modes (if supported), with the exception of
 206  * {@code get} and {@code set}, provide atomic access for
 207  * reference types and all primitive types.
 208  * Unless stated otherwise in the documentation of a factory method, the access
 209  * modes {@code get} and {@code set} (if supported) provide atomic access for
 210  * reference types and all primitives types, with the exception of {@code long}
 211  * and {@code double} on 32-bit platforms.
 212  *
 213  * &lt;p&gt;Access modes will override any memory ordering effects specified at
 214  * the declaration site of a variable.  For example, a VarHandle accessing
 215  * a field using the {@code get} access mode will access the field as
 216  * specified &lt;em&gt;by its access mode&lt;/em&gt; even if that field is declared
 217  * {@code volatile}.  When mixed access is performed extreme care should be
 218  * taken since the Java Memory Model may permit surprising results.
 219  *
 220  * &lt;p&gt;In addition to supporting access to variables under various access modes,
 221  * a set of static methods, referred to as memory fence methods, is also
 222  * provided for fine-grained control of memory ordering.
 223  *
 224  * The Java Language Specification permits other threads to observe operations
 225  * as if they were executed in orders different than are apparent in program
 226  * source code, subject to constraints arising, for example, from the use of
 227  * locks, {@code volatile} fields or VarHandles.  The static methods,
 228  * {@link #fullFence fullFence}, {@link #acquireFence acquireFence},
 229  * {@link #releaseFence releaseFence}, {@link #loadLoadFence loadLoadFence} and
 230  * {@link #storeStoreFence storeStoreFence}, can also be used to impose
 231  * constraints.  Their specifications, as is the case for certain access modes,
 232  * are phrased in terms of the lack of &quot;reorderings&quot; -- observable ordering
 233  * effects that might otherwise occur if the fence was not present.  More
 234  * precise phrasing of the specification of access mode methods and memory fence
 235  * methods may accompany future updates of the Java Language Specification.
 236  *
 237  * &lt;h2&gt;Compiling invocation of access mode methods&lt;/h2&gt;
 238  * A Java method call expression naming an access mode method can invoke a
 239  * VarHandle from Java source code.  From the viewpoint of source code, these
 240  * methods can take any arguments and their polymorphic result (if expressed)
 241  * can be cast to any return type.  Formally this is accomplished by giving the
 242  * access mode methods variable arity {@code Object} arguments and
 243  * {@code Object} return types (if the return type is polymorphic), but they
 244  * have an additional quality called &lt;em&gt;signature polymorphism&lt;/em&gt; which
 245  * connects this freedom of invocation directly to the JVM execution stack.
 246  * &lt;p&gt;
 247  * As is usual with virtual methods, source-level calls to access mode methods
 248  * compile to an {@code invokevirtual} instruction.  More unusually, the
 249  * compiler must record the actual argument types, and may not perform method
 250  * invocation conversions on the arguments.  Instead, it must generate
 251  * instructions to push them on the stack according to their own unconverted
 252  * types.  The VarHandle object itself will be pushed on the stack before the
 253  * arguments.  The compiler then generates an {@code invokevirtual} instruction
 254  * that invokes the access mode method with a symbolic type descriptor which
 255  * describes the argument and return types.
 256  * &lt;p&gt;
 257  * To issue a complete symbolic type descriptor, the compiler must also
 258  * determine the return type (if polymorphic).  This is based on a cast on the
 259  * method invocation expression, if there is one, or else {@code Object} if the
 260  * invocation is an expression, or else {@code void} if the invocation is a
 261  * statement.  The cast may be to a primitive type (but not {@code void}).
 262  * &lt;p&gt;
 263  * As a corner case, an uncasted {@code null} argument is given a symbolic type
 264  * descriptor of {@code java.lang.Void}.  The ambiguity with the type
 265  * {@code Void} is harmless, since there are no references of type {@code Void}
 266  * except the null reference.
 267  *
 268  *
 269  * &lt;h2&gt;&lt;a id=&quot;invoke&quot;&gt;Performing invocation of access mode methods&lt;/a&gt;&lt;/h2&gt;
 270  * The first time an {@code invokevirtual} instruction is executed it is linked
 271  * by symbolically resolving the names in the instruction and verifying that
 272  * the method call is statically legal.  This also holds for calls to access mode
 273  * methods.  In this case, the symbolic type descriptor emitted by the compiler
 274  * is checked for correct syntax, and names it contains are resolved.  Thus, an
 275  * {@code invokevirtual} instruction which invokes an access mode method will
 276  * always link, as long as the symbolic type descriptor is syntactically
 277  * well-formed and the types exist.
 278  * &lt;p&gt;
 279  * When the {@code invokevirtual} is executed after linking, the receiving
 280  * VarHandle&#39;s access mode type is first checked by the JVM to ensure that it
 281  * matches the symbolic type descriptor.  If the type
 282  * match fails, it means that the access mode method which the caller is
 283  * invoking is not present on the individual VarHandle being invoked.
 284  *
 285  * &lt;p&gt;
 286  * Invocation of an access mode method behaves as if an invocation of
 287  * {@link MethodHandle#invoke}, where the receiving method handle accepts the
 288  * VarHandle instance as the leading argument.  More specifically, the
 289  * following, where {@code {access-mode}} corresponds to the access mode method
 290  * name:
 291  * &lt;pre&gt; {@code
 292  * VarHandle vh = ..
 293  * R r = (R) vh.{access-mode}(p1, p2, ..., pN);
 294  * }&lt;/pre&gt;
 295  * behaves as if:
 296  * &lt;pre&gt; {@code
 297  * VarHandle vh = ..
 298  * VarHandle.AccessMode am = VarHandle.AccessMode.valueFromMethodName(&quot;{access-mode}&quot;);
 299  * MethodHandle mh = MethodHandles.varHandleExactInvoker(
 300  *                       am,
 301  *                       vh.accessModeType(am));
 302  *
 303  * R r = (R) mh.invoke(vh, p1, p2, ..., pN)
 304  * }&lt;/pre&gt;
 305  * (modulo access mode methods do not declare throwing of {@code Throwable}).
 306  * This is equivalent to:
 307  * &lt;pre&gt; {@code
 308  * MethodHandle mh = MethodHandles.lookup().findVirtual(
 309  *                       VarHandle.class,
 310  *                       &quot;{access-mode}&quot;,
 311  *                       MethodType.methodType(R, p1, p2, ..., pN));
 312  *
 313  * R r = (R) mh.invokeExact(vh, p1, p2, ..., pN)
 314  * }&lt;/pre&gt;
 315  * where the desired method type is the symbolic type descriptor and a
 316  * {@link MethodHandle#invokeExact} is performed, since before invocation of the
 317  * target, the handle will apply reference casts as necessary and box, unbox, or
 318  * widen primitive values, as if by {@link MethodHandle#asType asType} (see also
 319  * {@link MethodHandles#varHandleInvoker}).
 320  *
 321  * More concisely, such behaviour is equivalent to:
 322  * &lt;pre&gt; {@code
 323  * VarHandle vh = ..
 324  * VarHandle.AccessMode am = VarHandle.AccessMode.valueFromMethodName(&quot;{access-mode}&quot;);
 325  * MethodHandle mh = vh.toMethodHandle(am);
 326  *
 327  * R r = (R) mh.invoke(p1, p2, ..., pN)
 328  * }&lt;/pre&gt;
 329  * Where, in this case, the method handle is bound to the VarHandle instance.
 330  *
 331  *
 332  * &lt;h2&gt;Invocation checking&lt;/h2&gt;
 333  * In typical programs, VarHandle access mode type matching will usually
 334  * succeed.  But if a match fails, the JVM will throw a
 335  * {@link WrongMethodTypeException}.
 336  * &lt;p&gt;
 337  * Thus, an access mode type mismatch which might show up as a linkage error
 338  * in a statically typed program can show up as a dynamic
 339  * {@code WrongMethodTypeException} in a program which uses VarHandles.
 340  * &lt;p&gt;
 341  * Because access mode types contain &quot;live&quot; {@code Class} objects, method type
 342  * matching takes into account both type names and class loaders.
 343  * Thus, even if a VarHandle {@code VH} is created in one class loader
 344  * {@code L1} and used in another {@code L2}, VarHandle access mode method
 345  * calls are type-safe, because the caller&#39;s symbolic type descriptor, as
 346  * resolved in {@code L2}, is matched against the original callee method&#39;s
 347  * symbolic type descriptor, as resolved in {@code L1}.  The resolution in
 348  * {@code L1} happens when {@code VH} is created and its access mode types are
 349  * assigned, while the resolution in {@code L2} happens when the
 350  * {@code invokevirtual} instruction is linked.
 351  * &lt;p&gt;
 352  * Apart from type descriptor checks, a VarHandles&#39;s capability to
 353  * access it&#39;s variables is unrestricted.
 354  * If a VarHandle is formed on a non-public variable by a class that has access
 355  * to that variable, the resulting VarHandle can be used in any place by any
 356  * caller who receives a reference to it.
 357  * &lt;p&gt;
 358  * Unlike with the Core Reflection API, where access is checked every time a
 359  * reflective method is invoked, VarHandle access checking is performed
 360  * &lt;a href=&quot;MethodHandles.Lookup.html#access&quot;&gt;when the VarHandle is
 361  * created&lt;/a&gt;.
 362  * Thus, VarHandles to non-public variables, or to variables in non-public
 363  * classes, should generally be kept secret.  They should not be passed to
 364  * untrusted code unless their use from the untrusted code would be harmless.
 365  *
 366  *
 367  * &lt;h2&gt;VarHandle creation&lt;/h2&gt;
 368  * Java code can create a VarHandle that directly accesses any field that is
 369  * accessible to that code.  This is done via a reflective, capability-based
 370  * API called {@link java.lang.invoke.MethodHandles.Lookup
 371  * MethodHandles.Lookup}.
 372  * For example, a VarHandle for a non-static field can be obtained
 373  * from {@link java.lang.invoke.MethodHandles.Lookup#findVarHandle
 374  * Lookup.findVarHandle}.
 375  * There is also a conversion method from Core Reflection API objects,
 376  * {@link java.lang.invoke.MethodHandles.Lookup#unreflectVarHandle
 377  * Lookup.unreflectVarHandle}.
 378  * &lt;p&gt;
 379  * Access to protected field members is restricted to receivers only of the
 380  * accessing class, or one of its subclasses, and the accessing class must in
 381  * turn be a subclass (or package sibling) of the protected member&#39;s defining
 382  * class.  If a VarHandle refers to a protected non-static field of a declaring
 383  * class outside the current package, the receiver argument will be narrowed to
 384  * the type of the accessing class.
 385  *
 386  * &lt;h2&gt;Interoperation between VarHandles and the Core Reflection API&lt;/h2&gt;
 387  * Using factory methods in the {@link java.lang.invoke.MethodHandles.Lookup
 388  * Lookup} API, any field represented by a Core Reflection API object
 389  * can be converted to a behaviorally equivalent VarHandle.
 390  * For example, a reflective {@link java.lang.reflect.Field Field} can
 391  * be converted to a VarHandle using
 392  * {@link java.lang.invoke.MethodHandles.Lookup#unreflectVarHandle
 393  * Lookup.unreflectVarHandle}.
 394  * The resulting VarHandles generally provide more direct and efficient
 395  * access to the underlying fields.
 396  * &lt;p&gt;
 397  * As a special case, when the Core Reflection API is used to view the
 398  * signature polymorphic access mode methods in this class, they appear as
 399  * ordinary non-polymorphic methods.  Their reflective appearance, as viewed by
 400  * {@link java.lang.Class#getDeclaredMethod Class.getDeclaredMethod},
 401  * is unaffected by their special status in this API.
 402  * For example, {@link java.lang.reflect.Method#getModifiers
 403  * Method.getModifiers}
 404  * will report exactly those modifier bits required for any similarly
 405  * declared method, including in this case {@code native} and {@code varargs}
 406  * bits.
 407  * &lt;p&gt;
 408  * As with any reflected method, these methods (when reflected) may be invoked
 409  * directly via {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke},
 410  * via JNI, or indirectly via
 411  * {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.
 412  * However, such reflective calls do not result in access mode method
 413  * invocations.  Such a call, if passed the required argument (a single one, of
 414  * type {@code Object[]}), will ignore the argument and will throw an
 415  * {@code UnsupportedOperationException}.
 416  * &lt;p&gt;
 417  * Since {@code invokevirtual} instructions can natively invoke VarHandle
 418  * access mode methods under any symbolic type descriptor, this reflective view
 419  * conflicts with the normal presentation of these methods via bytecodes.
 420  * Thus, these native methods, when reflectively viewed by
 421  * {@code Class.getDeclaredMethod}, may be regarded as placeholders only.
 422  * &lt;p&gt;
 423  * In order to obtain an invoker method for a particular access mode type,
 424  * use {@link java.lang.invoke.MethodHandles#varHandleExactInvoker} or
 425  * {@link java.lang.invoke.MethodHandles#varHandleInvoker}.  The
 426  * {@link java.lang.invoke.MethodHandles.Lookup#findVirtual Lookup.findVirtual}
 427  * API is also able to return a method handle to call an access mode method for
 428  * any specified access mode type and is equivalent in behaviour to
 429  * {@link java.lang.invoke.MethodHandles#varHandleInvoker}.
 430  *
 431  * &lt;h2&gt;Interoperation between VarHandles and Java generics&lt;/h2&gt;
 432  * A VarHandle can be obtained for a variable, such as a field, which is
 433  * declared with Java generic types.  As with the Core Reflection API, the
 434  * VarHandle&#39;s variable type will be constructed from the erasure of the
 435  * source-level type.  When a VarHandle access mode method is invoked, the
 436  * types
 437  * of its arguments or the return value cast type may be generic types or type
 438  * instances.  If this occurs, the compiler will replace those types by their
 439  * erasures when it constructs the symbolic type descriptor for the
 440  * {@code invokevirtual} instruction.
 441  *
 442  * @see MethodHandle
 443  * @see MethodHandles
 444  * @see MethodType
 445  * @since 9
 446  */
 447 public abstract class VarHandle implements Constable {
 448     final VarForm vform;
 449 
 450     VarHandle(VarForm vform) {
 451         this.vform = vform;
 452     }
 453 
 454     RuntimeException unsupported() {
 455         return new UnsupportedOperationException();
 456     }
 457 
 458     boolean isDirect() {
 459         return true;
 460     }
 461 
 462     VarHandle asDirect() {
 463         return this;
 464     }
 465 
<a name="1" id="anc1"></a><span class="line-added"> 466     VarHandle target() { return null; }</span>
<span class="line-added"> 467 </span>
 468     // Plain accessors
 469 
 470     /**
 471      * Returns the value of a variable, with memory semantics of reading as
 472      * if the variable was declared non-{@code volatile}.  Commonly referred to
 473      * as plain read access.
 474      *
 475      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn)T}.
 476      *
 477      * &lt;p&gt;The symbolic type descriptor at the call site of {@code get}
 478      * must match the access mode type that is the result of calling
 479      * {@code accessModeType(VarHandle.AccessMode.GET)} on this VarHandle.
 480      *
 481      * &lt;p&gt;This access mode is supported by all VarHandle instances and never
 482      * throws {@code UnsupportedOperationException}.
 483      *
 484      * @param args the signature-polymorphic parameter list of the form
 485      * {@code (CT1 ct1, ..., CTn)}
 486      * , statically represented using varargs.
 487      * @return the signature-polymorphic result that is the value of the
 488      * variable
 489      * , statically represented using {@code Object}.
 490      * @throws WrongMethodTypeException if the access mode type does not
 491      * match the caller&#39;s symbolic type descriptor.
 492      * @throws ClassCastException if the access mode type matches the caller&#39;s
 493      * symbolic type descriptor, but a reference cast fails.
 494      */
 495     public final native
 496     @MethodHandle.PolymorphicSignature
 497     @HotSpotIntrinsicCandidate
 498     Object get(Object... args);
 499 
 500     /**
 501      * Sets the value of a variable to the {@code newValue}, with memory
 502      * semantics of setting as if the variable was declared non-{@code volatile}
 503      * and non-{@code final}.  Commonly referred to as plain write access.
 504      *
 505      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T newValue)void}
 506      *
 507      * &lt;p&gt;The symbolic type descriptor at the call site of {@code set}
 508      * must match the access mode type that is the result of calling
 509      * {@code accessModeType(VarHandle.AccessMode.SET)} on this VarHandle.
 510      *
 511      * @param args the signature-polymorphic parameter list of the form
 512      * {@code (CT1 ct1, ..., CTn ctn, T newValue)}
 513      * , statically represented using varargs.
 514      * @throws UnsupportedOperationException if the access mode is unsupported
 515      * for this VarHandle.
 516      * @throws WrongMethodTypeException if the access mode type does not
 517      * match the caller&#39;s symbolic type descriptor.
 518      * @throws ClassCastException if the access mode type matches the caller&#39;s
 519      * symbolic type descriptor, but a reference cast fails.
 520      */
 521     public final native
 522     @MethodHandle.PolymorphicSignature
 523     @HotSpotIntrinsicCandidate
 524     void set(Object... args);
 525 
 526 
 527     // Volatile accessors
 528 
 529     /**
 530      * Returns the value of a variable, with memory semantics of reading as if
 531      * the variable was declared {@code volatile}.
 532      *
 533      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn)T}.
 534      *
 535      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getVolatile}
 536      * must match the access mode type that is the result of calling
 537      * {@code accessModeType(VarHandle.AccessMode.GET_VOLATILE)} on this
 538      * VarHandle.
 539      *
 540      * @param args the signature-polymorphic parameter list of the form
 541      * {@code (CT1 ct1, ..., CTn ctn)}
 542      * , statically represented using varargs.
 543      * @return the signature-polymorphic result that is the value of the
 544      * variable
 545      * , statically represented using {@code Object}.
 546      * @throws UnsupportedOperationException if the access mode is unsupported
 547      * for this VarHandle.
 548      * @throws WrongMethodTypeException if the access mode type does not
 549      * match the caller&#39;s symbolic type descriptor.
 550      * @throws ClassCastException if the access mode type matches the caller&#39;s
 551      * symbolic type descriptor, but a reference cast fails.
 552      */
 553     public final native
 554     @MethodHandle.PolymorphicSignature
 555     @HotSpotIntrinsicCandidate
 556     Object getVolatile(Object... args);
 557 
 558     /**
 559      * Sets the value of a variable to the {@code newValue}, with memory
 560      * semantics of setting as if the variable was declared {@code volatile}.
 561      *
 562      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T newValue)void}.
 563      *
 564      * &lt;p&gt;The symbolic type descriptor at the call site of {@code setVolatile}
 565      * must match the access mode type that is the result of calling
 566      * {@code accessModeType(VarHandle.AccessMode.SET_VOLATILE)} on this
 567      * VarHandle.
 568      *
 569      * @apiNote
 570      * Ignoring the many semantic differences from C and C++, this method has
 571      * memory ordering effects compatible with {@code memory_order_seq_cst}.
 572      *
 573      * @param args the signature-polymorphic parameter list of the form
 574      * {@code (CT1 ct1, ..., CTn ctn, T newValue)}
 575      * , statically represented using varargs.
 576      * @throws UnsupportedOperationException if the access mode is unsupported
 577      * for this VarHandle.
 578      * @throws WrongMethodTypeException if the access mode type does not
 579      * match the caller&#39;s symbolic type descriptor.
 580      * @throws ClassCastException if the access mode type matches the caller&#39;s
 581      * symbolic type descriptor, but a reference cast fails.
 582      */
 583     public final native
 584     @MethodHandle.PolymorphicSignature
 585     @HotSpotIntrinsicCandidate
 586     void setVolatile(Object... args);
 587 
 588 
 589     /**
 590      * Returns the value of a variable, accessed in program order, but with no
 591      * assurance of memory ordering effects with respect to other threads.
 592      *
 593      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn)T}.
 594      *
 595      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getOpaque}
 596      * must match the access mode type that is the result of calling
 597      * {@code accessModeType(VarHandle.AccessMode.GET_OPAQUE)} on this
 598      * VarHandle.
 599      *
 600      * @param args the signature-polymorphic parameter list of the form
 601      * {@code (CT1 ct1, ..., CTn ctn)}
 602      * , statically represented using varargs.
 603      * @return the signature-polymorphic result that is the value of the
 604      * variable
 605      * , statically represented using {@code Object}.
 606      * @throws UnsupportedOperationException if the access mode is unsupported
 607      * for this VarHandle.
 608      * @throws WrongMethodTypeException if the access mode type does not
 609      * match the caller&#39;s symbolic type descriptor.
 610      * @throws ClassCastException if the access mode type matches the caller&#39;s
 611      * symbolic type descriptor, but a reference cast fails.
 612      */
 613     public final native
 614     @MethodHandle.PolymorphicSignature
 615     @HotSpotIntrinsicCandidate
 616     Object getOpaque(Object... args);
 617 
 618     /**
 619      * Sets the value of a variable to the {@code newValue}, in program order,
 620      * but with no assurance of memory ordering effects with respect to other
 621      * threads.
 622      *
 623      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T newValue)void}.
 624      *
 625      * &lt;p&gt;The symbolic type descriptor at the call site of {@code setOpaque}
 626      * must match the access mode type that is the result of calling
 627      * {@code accessModeType(VarHandle.AccessMode.SET_OPAQUE)} on this
 628      * VarHandle.
 629      *
 630      * @param args the signature-polymorphic parameter list of the form
 631      * {@code (CT1 ct1, ..., CTn ctn, T newValue)}
 632      * , statically represented using varargs.
 633      * @throws UnsupportedOperationException if the access mode is unsupported
 634      * for this VarHandle.
 635      * @throws WrongMethodTypeException if the access mode type does not
 636      * match the caller&#39;s symbolic type descriptor.
 637      * @throws ClassCastException if the access mode type matches the caller&#39;s
 638      * symbolic type descriptor, but a reference cast fails.
 639      */
 640     public final native
 641     @MethodHandle.PolymorphicSignature
 642     @HotSpotIntrinsicCandidate
 643     void setOpaque(Object... args);
 644 
 645 
 646     // Lazy accessors
 647 
 648     /**
 649      * Returns the value of a variable, and ensures that subsequent loads and
 650      * stores are not reordered before this access.
 651      *
 652      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn)T}.
 653      *
 654      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAcquire}
 655      * must match the access mode type that is the result of calling
 656      * {@code accessModeType(VarHandle.AccessMode.GET_ACQUIRE)} on this
 657      * VarHandle.
 658      *
 659      * @apiNote
 660      * Ignoring the many semantic differences from C and C++, this method has
 661      * memory ordering effects compatible with {@code memory_order_acquire}
 662      * ordering.
 663      *
 664      * @param args the signature-polymorphic parameter list of the form
 665      * {@code (CT1 ct1, ..., CTn ctn)}
 666      * , statically represented using varargs.
 667      * @return the signature-polymorphic result that is the value of the
 668      * variable
 669      * , statically represented using {@code Object}.
 670      * @throws UnsupportedOperationException if the access mode is unsupported
 671      * for this VarHandle.
 672      * @throws WrongMethodTypeException if the access mode type does not
 673      * match the caller&#39;s symbolic type descriptor.
 674      * @throws ClassCastException if the access mode type matches the caller&#39;s
 675      * symbolic type descriptor, but a reference cast fails.
 676      */
 677     public final native
 678     @MethodHandle.PolymorphicSignature
 679     @HotSpotIntrinsicCandidate
 680     Object getAcquire(Object... args);
 681 
 682     /**
 683      * Sets the value of a variable to the {@code newValue}, and ensures that
 684      * prior loads and stores are not reordered after this access.
 685      *
 686      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T newValue)void}.
 687      *
 688      * &lt;p&gt;The symbolic type descriptor at the call site of {@code setRelease}
 689      * must match the access mode type that is the result of calling
 690      * {@code accessModeType(VarHandle.AccessMode.SET_RELEASE)} on this
 691      * VarHandle.
 692      *
 693      * @apiNote
 694      * Ignoring the many semantic differences from C and C++, this method has
 695      * memory ordering effects compatible with {@code memory_order_release}
 696      * ordering.
 697      *
 698      * @param args the signature-polymorphic parameter list of the form
 699      * {@code (CT1 ct1, ..., CTn ctn, T newValue)}
 700      * , statically represented using varargs.
 701      * @throws UnsupportedOperationException if the access mode is unsupported
 702      * for this VarHandle.
 703      * @throws WrongMethodTypeException if the access mode type does not
 704      * match the caller&#39;s symbolic type descriptor.
 705      * @throws ClassCastException if the access mode type matches the caller&#39;s
 706      * symbolic type descriptor, but a reference cast fails.
 707      */
 708     public final native
 709     @MethodHandle.PolymorphicSignature
 710     @HotSpotIntrinsicCandidate
 711     void setRelease(Object... args);
 712 
 713 
 714     // Compare and set accessors
 715 
 716     /**
 717      * Atomically sets the value of a variable to the {@code newValue} with the
 718      * memory semantics of {@link #setVolatile} if the variable&#39;s current value,
 719      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 720      * {@code expectedValue}, as accessed with the memory semantics of
 721      * {@link #getVolatile}.
 722      *
 723      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean}.
 724      *
 725      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 726      * compareAndSet} must match the access mode type that is the result of
 727      * calling {@code accessModeType(VarHandle.AccessMode.COMPARE_AND_SET)} on
 728      * this VarHandle.
 729      *
 730      * @param args the signature-polymorphic parameter list of the form
 731      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 732      * , statically represented using varargs.
 733      * @return {@code true} if successful, otherwise {@code false} if the
 734      * witness value was not the same as the {@code expectedValue}.
 735      * @throws UnsupportedOperationException if the access mode is unsupported
 736      * for this VarHandle.
 737      * @throws WrongMethodTypeException if the access mode type does not
 738      * match the caller&#39;s symbolic type descriptor.
 739      * @throws ClassCastException if the access mode type matches the caller&#39;s
 740      * symbolic type descriptor, but a reference cast fails.
 741      * @see #setVolatile(Object...)
 742      * @see #getVolatile(Object...)
 743      */
 744     public final native
 745     @MethodHandle.PolymorphicSignature
 746     @HotSpotIntrinsicCandidate
 747     boolean compareAndSet(Object... args);
 748 
 749     /**
 750      * Atomically sets the value of a variable to the {@code newValue} with the
 751      * memory semantics of {@link #setVolatile} if the variable&#39;s current value,
 752      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 753      * {@code expectedValue}, as accessed with the memory semantics of
 754      * {@link #getVolatile}.
 755      *
 756      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T}.
 757      *
 758      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 759      * compareAndExchange}
 760      * must match the access mode type that is the result of calling
 761      * {@code accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE)}
 762      * on this VarHandle.
 763      *
 764      * @param args the signature-polymorphic parameter list of the form
 765      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 766      * , statically represented using varargs.
 767      * @return the signature-polymorphic result that is the witness value, which
 768      * will be the same as the {@code expectedValue} if successful
 769      * , statically represented using {@code Object}.
 770      * @throws UnsupportedOperationException if the access mode is unsupported
 771      * for this VarHandle.
 772      * @throws WrongMethodTypeException if the access mode type is not
 773      * compatible with the caller&#39;s symbolic type descriptor.
 774      * @throws ClassCastException if the access mode type is compatible with the
 775      * caller&#39;s symbolic type descriptor, but a reference cast fails.
 776      * @see #setVolatile(Object...)
 777      * @see #getVolatile(Object...)
 778      */
 779     public final native
 780     @MethodHandle.PolymorphicSignature
 781     @HotSpotIntrinsicCandidate
 782     Object compareAndExchange(Object... args);
 783 
 784     /**
 785      * Atomically sets the value of a variable to the {@code newValue} with the
 786      * memory semantics of {@link #set} if the variable&#39;s current value,
 787      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 788      * {@code expectedValue}, as accessed with the memory semantics of
 789      * {@link #getAcquire}.
 790      *
 791      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T}.
 792      *
 793      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 794      * compareAndExchangeAcquire}
 795      * must match the access mode type that is the result of calling
 796      * {@code accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_ACQUIRE)} on
 797      * this VarHandle.
 798      *
 799      * @param args the signature-polymorphic parameter list of the form
 800      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 801      * , statically represented using varargs.
 802      * @return the signature-polymorphic result that is the witness value, which
 803      * will be the same as the {@code expectedValue} if successful
 804      * , statically represented using {@code Object}.
 805      * @throws UnsupportedOperationException if the access mode is unsupported
 806      * for this VarHandle.
 807      * @throws WrongMethodTypeException if the access mode type does not
 808      * match the caller&#39;s symbolic type descriptor.
 809      * @throws ClassCastException if the access mode type matches the caller&#39;s
 810      * symbolic type descriptor, but a reference cast fails.
 811      * @see #set(Object...)
 812      * @see #getAcquire(Object...)
 813      */
 814     public final native
 815     @MethodHandle.PolymorphicSignature
 816     @HotSpotIntrinsicCandidate
 817     Object compareAndExchangeAcquire(Object... args);
 818 
 819     /**
 820      * Atomically sets the value of a variable to the {@code newValue} with the
 821      * memory semantics of {@link #setRelease} if the variable&#39;s current value,
 822      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 823      * {@code expectedValue}, as accessed with the memory semantics of
 824      * {@link #get}.
 825      *
 826      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T}.
 827      *
 828      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 829      * compareAndExchangeRelease}
 830      * must match the access mode type that is the result of calling
 831      * {@code accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_RELEASE)}
 832      * on this VarHandle.
 833      *
 834      * @param args the signature-polymorphic parameter list of the form
 835      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 836      * , statically represented using varargs.
 837      * @return the signature-polymorphic result that is the witness value, which
 838      * will be the same as the {@code expectedValue} if successful
 839      * , statically represented using {@code Object}.
 840      * @throws UnsupportedOperationException if the access mode is unsupported
 841      * for this VarHandle.
 842      * @throws WrongMethodTypeException if the access mode type does not
 843      * match the caller&#39;s symbolic type descriptor.
 844      * @throws ClassCastException if the access mode type matches the caller&#39;s
 845      * symbolic type descriptor, but a reference cast fails.
 846      * @see #setRelease(Object...)
 847      * @see #get(Object...)
 848      */
 849     public final native
 850     @MethodHandle.PolymorphicSignature
 851     @HotSpotIntrinsicCandidate
 852     Object compareAndExchangeRelease(Object... args);
 853 
 854     // Weak (spurious failures allowed)
 855 
 856     /**
 857      * Possibly atomically sets the value of a variable to the {@code newValue}
 858      * with the semantics of {@link #set} if the variable&#39;s current value,
 859      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 860      * {@code expectedValue}, as accessed with the memory semantics of
 861      * {@link #get}.
 862      *
 863      * &lt;p&gt;This operation may fail spuriously (typically, due to memory
 864      * contention) even if the witness value does match the expected value.
 865      *
 866      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean}.
 867      *
 868      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 869      * weakCompareAndSetPlain} must match the access mode type that is the result of
 870      * calling {@code accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_PLAIN)}
 871      * on this VarHandle.
 872      *
 873      * @param args the signature-polymorphic parameter list of the form
 874      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 875      * , statically represented using varargs.
 876      * @return {@code true} if successful, otherwise {@code false} if the
 877      * witness value was not the same as the {@code expectedValue} or if this
 878      * operation spuriously failed.
 879      * @throws UnsupportedOperationException if the access mode is unsupported
 880      * for this VarHandle.
 881      * @throws WrongMethodTypeException if the access mode type does not
 882      * match the caller&#39;s symbolic type descriptor.
 883      * @throws ClassCastException if the access mode type matches the caller&#39;s
 884      * symbolic type descriptor, but a reference cast fails.
 885      * @see #set(Object...)
 886      * @see #get(Object...)
 887      */
 888     public final native
 889     @MethodHandle.PolymorphicSignature
 890     @HotSpotIntrinsicCandidate
 891     boolean weakCompareAndSetPlain(Object... args);
 892 
 893     /**
 894      * Possibly atomically sets the value of a variable to the {@code newValue}
 895      * with the memory semantics of {@link #setVolatile} if the variable&#39;s
 896      * current value, referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 897      * {@code expectedValue}, as accessed with the memory semantics of
 898      * {@link #getVolatile}.
 899      *
 900      * &lt;p&gt;This operation may fail spuriously (typically, due to memory
 901      * contention) even if the witness value does match the expected value.
 902      *
 903      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean}.
 904      *
 905      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 906      * weakCompareAndSet} must match the access mode type that is the
 907      * result of calling {@code accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET)}
 908      * on this VarHandle.
 909      *
 910      * @param args the signature-polymorphic parameter list of the form
 911      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 912      * , statically represented using varargs.
 913      * @return {@code true} if successful, otherwise {@code false} if the
 914      * witness value was not the same as the {@code expectedValue} or if this
 915      * operation spuriously failed.
 916      * @throws UnsupportedOperationException if the access mode is unsupported
 917      * for this VarHandle.
 918      * @throws WrongMethodTypeException if the access mode type does not
 919      * match the caller&#39;s symbolic type descriptor.
 920      * @throws ClassCastException if the access mode type matches the caller&#39;s
 921      * symbolic type descriptor, but a reference cast fails.
 922      * @see #setVolatile(Object...)
 923      * @see #getVolatile(Object...)
 924      */
 925     public final native
 926     @MethodHandle.PolymorphicSignature
 927     @HotSpotIntrinsicCandidate
 928     boolean weakCompareAndSet(Object... args);
 929 
 930     /**
 931      * Possibly atomically sets the value of a variable to the {@code newValue}
 932      * with the semantics of {@link #set} if the variable&#39;s current value,
 933      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 934      * {@code expectedValue}, as accessed with the memory semantics of
 935      * {@link #getAcquire}.
 936      *
 937      * &lt;p&gt;This operation may fail spuriously (typically, due to memory
 938      * contention) even if the witness value does match the expected value.
 939      *
 940      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean}.
 941      *
 942      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 943      * weakCompareAndSetAcquire}
 944      * must match the access mode type that is the result of calling
 945      * {@code accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_ACQUIRE)}
 946      * on this VarHandle.
 947      *
 948      * @param args the signature-polymorphic parameter list of the form
 949      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 950      * , statically represented using varargs.
 951      * @return {@code true} if successful, otherwise {@code false} if the
 952      * witness value was not the same as the {@code expectedValue} or if this
 953      * operation spuriously failed.
 954      * @throws UnsupportedOperationException if the access mode is unsupported
 955      * for this VarHandle.
 956      * @throws WrongMethodTypeException if the access mode type does not
 957      * match the caller&#39;s symbolic type descriptor.
 958      * @throws ClassCastException if the access mode type matches the caller&#39;s
 959      * symbolic type descriptor, but a reference cast fails.
 960      * @see #set(Object...)
 961      * @see #getAcquire(Object...)
 962      */
 963     public final native
 964     @MethodHandle.PolymorphicSignature
 965     @HotSpotIntrinsicCandidate
 966     boolean weakCompareAndSetAcquire(Object... args);
 967 
 968     /**
 969      * Possibly atomically sets the value of a variable to the {@code newValue}
 970      * with the semantics of {@link #setRelease} if the variable&#39;s current
 971      * value, referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 972      * {@code expectedValue}, as accessed with the memory semantics of
 973      * {@link #get}.
 974      *
 975      * &lt;p&gt;This operation may fail spuriously (typically, due to memory
 976      * contention) even if the witness value does match the expected value.
 977      *
 978      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean}.
 979      *
 980      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 981      * weakCompareAndSetRelease}
 982      * must match the access mode type that is the result of calling
 983      * {@code accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_RELEASE)}
 984      * on this VarHandle.
 985      *
 986      * @param args the signature-polymorphic parameter list of the form
 987      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 988      * , statically represented using varargs.
 989      * @return {@code true} if successful, otherwise {@code false} if the
 990      * witness value was not the same as the {@code expectedValue} or if this
 991      * operation spuriously failed.
 992      * @throws UnsupportedOperationException if the access mode is unsupported
 993      * for this VarHandle.
 994      * @throws WrongMethodTypeException if the access mode type does not
 995      * match the caller&#39;s symbolic type descriptor.
 996      * @throws ClassCastException if the access mode type matches the caller&#39;s
 997      * symbolic type descriptor, but a reference cast fails.
 998      * @see #setRelease(Object...)
 999      * @see #get(Object...)
1000      */
1001     public final native
1002     @MethodHandle.PolymorphicSignature
1003     @HotSpotIntrinsicCandidate
1004     boolean weakCompareAndSetRelease(Object... args);
1005 
1006     /**
1007      * Atomically sets the value of a variable to the {@code newValue} with the
1008      * memory semantics of {@link #setVolatile} and returns the variable&#39;s
1009      * previous value, as accessed with the memory semantics of
1010      * {@link #getVolatile}.
1011      *
1012      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T newValue)T}.
1013      *
1014      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndSet}
1015      * must match the access mode type that is the result of calling
1016      * {@code accessModeType(VarHandle.AccessMode.GET_AND_SET)} on this
1017      * VarHandle.
1018      *
1019      * @param args the signature-polymorphic parameter list of the form
1020      * {@code (CT1 ct1, ..., CTn ctn, T newValue)}
1021      * , statically represented using varargs.
1022      * @return the signature-polymorphic result that is the previous value of
1023      * the variable
1024      * , statically represented using {@code Object}.
1025      * @throws UnsupportedOperationException if the access mode is unsupported
1026      * for this VarHandle.
1027      * @throws WrongMethodTypeException if the access mode type does not
1028      * match the caller&#39;s symbolic type descriptor.
1029      * @throws ClassCastException if the access mode type matches the caller&#39;s
1030      * symbolic type descriptor, but a reference cast fails.
1031      * @see #setVolatile(Object...)
1032      * @see #getVolatile(Object...)
1033      */
1034     public final native
1035     @MethodHandle.PolymorphicSignature
1036     @HotSpotIntrinsicCandidate
1037     Object getAndSet(Object... args);
1038 
1039     /**
1040      * Atomically sets the value of a variable to the {@code newValue} with the
1041      * memory semantics of {@link #set} and returns the variable&#39;s
1042      * previous value, as accessed with the memory semantics of
1043      * {@link #getAcquire}.
1044      *
1045      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T newValue)T}.
1046      *
1047      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndSetAcquire}
1048      * must match the access mode type that is the result of calling
1049      * {@code accessModeType(VarHandle.AccessMode.GET_AND_SET_ACQUIRE)} on this
1050      * VarHandle.
1051      *
1052      * @param args the signature-polymorphic parameter list of the form
1053      * {@code (CT1 ct1, ..., CTn ctn, T newValue)}
1054      * , statically represented using varargs.
1055      * @return the signature-polymorphic result that is the previous value of
1056      * the variable
1057      * , statically represented using {@code Object}.
1058      * @throws UnsupportedOperationException if the access mode is unsupported
1059      * for this VarHandle.
1060      * @throws WrongMethodTypeException if the access mode type does not
1061      * match the caller&#39;s symbolic type descriptor.
1062      * @throws ClassCastException if the access mode type matches the caller&#39;s
1063      * symbolic type descriptor, but a reference cast fails.
1064      * @see #setVolatile(Object...)
1065      * @see #getVolatile(Object...)
1066      */
1067     public final native
1068     @MethodHandle.PolymorphicSignature
1069     @HotSpotIntrinsicCandidate
1070     Object getAndSetAcquire(Object... args);
1071 
1072     /**
1073      * Atomically sets the value of a variable to the {@code newValue} with the
1074      * memory semantics of {@link #setRelease} and returns the variable&#39;s
1075      * previous value, as accessed with the memory semantics of
1076      * {@link #get}.
1077      *
1078      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T newValue)T}.
1079      *
1080      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndSetRelease}
1081      * must match the access mode type that is the result of calling
1082      * {@code accessModeType(VarHandle.AccessMode.GET_AND_SET_RELEASE)} on this
1083      * VarHandle.
1084      *
1085      * @param args the signature-polymorphic parameter list of the form
1086      * {@code (CT1 ct1, ..., CTn ctn, T newValue)}
1087      * , statically represented using varargs.
1088      * @return the signature-polymorphic result that is the previous value of
1089      * the variable
1090      * , statically represented using {@code Object}.
1091      * @throws UnsupportedOperationException if the access mode is unsupported
1092      * for this VarHandle.
1093      * @throws WrongMethodTypeException if the access mode type does not
1094      * match the caller&#39;s symbolic type descriptor.
1095      * @throws ClassCastException if the access mode type matches the caller&#39;s
1096      * symbolic type descriptor, but a reference cast fails.
1097      * @see #setVolatile(Object...)
1098      * @see #getVolatile(Object...)
1099      */
1100     public final native
1101     @MethodHandle.PolymorphicSignature
1102     @HotSpotIntrinsicCandidate
1103     Object getAndSetRelease(Object... args);
1104 
1105     // Primitive adders
1106     // Throw UnsupportedOperationException for refs
1107 
1108     /**
1109      * Atomically adds the {@code value} to the current value of a variable with
1110      * the memory semantics of {@link #setVolatile}, and returns the variable&#39;s
1111      * previous value, as accessed with the memory semantics of
1112      * {@link #getVolatile}.
1113      *
1114      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T value)T}.
1115      *
1116      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndAdd}
1117      * must match the access mode type that is the result of calling
1118      * {@code accessModeType(VarHandle.AccessMode.GET_AND_ADD)} on this
1119      * VarHandle.
1120      *
1121      * @param args the signature-polymorphic parameter list of the form
1122      * {@code (CT1 ct1, ..., CTn ctn, T value)}
1123      * , statically represented using varargs.
1124      * @return the signature-polymorphic result that is the previous value of
1125      * the variable
1126      * , statically represented using {@code Object}.
1127      * @throws UnsupportedOperationException if the access mode is unsupported
1128      * for this VarHandle.
1129      * @throws WrongMethodTypeException if the access mode type does not
1130      * match the caller&#39;s symbolic type descriptor.
1131      * @throws ClassCastException if the access mode type matches the caller&#39;s
1132      * symbolic type descriptor, but a reference cast fails.
1133      * @see #setVolatile(Object...)
1134      * @see #getVolatile(Object...)
1135      */
1136     public final native
1137     @MethodHandle.PolymorphicSignature
1138     @HotSpotIntrinsicCandidate
1139     Object getAndAdd(Object... args);
1140 
1141     /**
1142      * Atomically adds the {@code value} to the current value of a variable with
1143      * the memory semantics of {@link #set}, and returns the variable&#39;s
1144      * previous value, as accessed with the memory semantics of
1145      * {@link #getAcquire}.
1146      *
1147      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T value)T}.
1148      *
1149      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndAddAcquire}
1150      * must match the access mode type that is the result of calling
1151      * {@code accessModeType(VarHandle.AccessMode.GET_AND_ADD_ACQUIRE)} on this
1152      * VarHandle.
1153      *
1154      * @param args the signature-polymorphic parameter list of the form
1155      * {@code (CT1 ct1, ..., CTn ctn, T value)}
1156      * , statically represented using varargs.
1157      * @return the signature-polymorphic result that is the previous value of
1158      * the variable
1159      * , statically represented using {@code Object}.
1160      * @throws UnsupportedOperationException if the access mode is unsupported
1161      * for this VarHandle.
1162      * @throws WrongMethodTypeException if the access mode type does not
1163      * match the caller&#39;s symbolic type descriptor.
1164      * @throws ClassCastException if the access mode type matches the caller&#39;s
1165      * symbolic type descriptor, but a reference cast fails.
1166      * @see #setVolatile(Object...)
1167      * @see #getVolatile(Object...)
1168      */
1169     public final native
1170     @MethodHandle.PolymorphicSignature
1171     @HotSpotIntrinsicCandidate
1172     Object getAndAddAcquire(Object... args);
1173 
1174     /**
1175      * Atomically adds the {@code value} to the current value of a variable with
1176      * the memory semantics of {@link #setRelease}, and returns the variable&#39;s
1177      * previous value, as accessed with the memory semantics of
1178      * {@link #get}.
1179      *
1180      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T value)T}.
1181      *
1182      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndAddRelease}
1183      * must match the access mode type that is the result of calling
1184      * {@code accessModeType(VarHandle.AccessMode.GET_AND_ADD_RELEASE)} on this
1185      * VarHandle.
1186      *
1187      * @param args the signature-polymorphic parameter list of the form
1188      * {@code (CT1 ct1, ..., CTn ctn, T value)}
1189      * , statically represented using varargs.
1190      * @return the signature-polymorphic result that is the previous value of
1191      * the variable
1192      * , statically represented using {@code Object}.
1193      * @throws UnsupportedOperationException if the access mode is unsupported
1194      * for this VarHandle.
1195      * @throws WrongMethodTypeException if the access mode type does not
1196      * match the caller&#39;s symbolic type descriptor.
1197      * @throws ClassCastException if the access mode type matches the caller&#39;s
1198      * symbolic type descriptor, but a reference cast fails.
1199      * @see #setVolatile(Object...)
1200      * @see #getVolatile(Object...)
1201      */
1202     public final native
1203     @MethodHandle.PolymorphicSignature
1204     @HotSpotIntrinsicCandidate
1205     Object getAndAddRelease(Object... args);
1206 
1207 
1208     // Bitwise operations
1209     // Throw UnsupportedOperationException for refs
1210 
1211     /**
1212      * Atomically sets the value of a variable to the result of
1213      * bitwise OR between the variable&#39;s current value and the {@code mask}
1214      * with the memory semantics of {@link #setVolatile} and returns the
1215      * variable&#39;s previous value, as accessed with the memory semantics of
1216      * {@link #getVolatile}.
1217      *
1218      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1219      * logical OR is performed instead of a bitwise OR.
1220      *
1221      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1222      *
1223      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseOr}
1224      * must match the access mode type that is the result of calling
1225      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR)} on this
1226      * VarHandle.
1227      *
1228      * @param args the signature-polymorphic parameter list of the form
1229      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1230      * , statically represented using varargs.
1231      * @return the signature-polymorphic result that is the previous value of
1232      * the variable
1233      * , statically represented using {@code Object}.
1234      * @throws UnsupportedOperationException if the access mode is unsupported
1235      * for this VarHandle.
1236      * @throws WrongMethodTypeException if the access mode type does not
1237      * match the caller&#39;s symbolic type descriptor.
1238      * @throws ClassCastException if the access mode type matches the caller&#39;s
1239      * symbolic type descriptor, but a reference cast fails.
1240      * @see #setVolatile(Object...)
1241      * @see #getVolatile(Object...)
1242      */
1243     public final native
1244     @MethodHandle.PolymorphicSignature
1245     @HotSpotIntrinsicCandidate
1246     Object getAndBitwiseOr(Object... args);
1247 
1248     /**
1249      * Atomically sets the value of a variable to the result of
1250      * bitwise OR between the variable&#39;s current value and the {@code mask}
1251      * with the memory semantics of {@link #set} and returns the
1252      * variable&#39;s previous value, as accessed with the memory semantics of
1253      * {@link #getAcquire}.
1254      *
1255      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1256      * logical OR is performed instead of a bitwise OR.
1257      *
1258      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1259      *
1260      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseOrAcquire}
1261      * must match the access mode type that is the result of calling
1262      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_ACQUIRE)} on this
1263      * VarHandle.
1264      *
1265      * @param args the signature-polymorphic parameter list of the form
1266      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1267      * , statically represented using varargs.
1268      * @return the signature-polymorphic result that is the previous value of
1269      * the variable
1270      * , statically represented using {@code Object}.
1271      * @throws UnsupportedOperationException if the access mode is unsupported
1272      * for this VarHandle.
1273      * @throws WrongMethodTypeException if the access mode type does not
1274      * match the caller&#39;s symbolic type descriptor.
1275      * @throws ClassCastException if the access mode type matches the caller&#39;s
1276      * symbolic type descriptor, but a reference cast fails.
1277      * @see #set(Object...)
1278      * @see #getAcquire(Object...)
1279      */
1280     public final native
1281     @MethodHandle.PolymorphicSignature
1282     @HotSpotIntrinsicCandidate
1283     Object getAndBitwiseOrAcquire(Object... args);
1284 
1285     /**
1286      * Atomically sets the value of a variable to the result of
1287      * bitwise OR between the variable&#39;s current value and the {@code mask}
1288      * with the memory semantics of {@link #setRelease} and returns the
1289      * variable&#39;s previous value, as accessed with the memory semantics of
1290      * {@link #get}.
1291      *
1292      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1293      * logical OR is performed instead of a bitwise OR.
1294      *
1295      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1296      *
1297      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseOrRelease}
1298      * must match the access mode type that is the result of calling
1299      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_RELEASE)} on this
1300      * VarHandle.
1301      *
1302      * @param args the signature-polymorphic parameter list of the form
1303      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1304      * , statically represented using varargs.
1305      * @return the signature-polymorphic result that is the previous value of
1306      * the variable
1307      * , statically represented using {@code Object}.
1308      * @throws UnsupportedOperationException if the access mode is unsupported
1309      * for this VarHandle.
1310      * @throws WrongMethodTypeException if the access mode type does not
1311      * match the caller&#39;s symbolic type descriptor.
1312      * @throws ClassCastException if the access mode type matches the caller&#39;s
1313      * symbolic type descriptor, but a reference cast fails.
1314      * @see #setRelease(Object...)
1315      * @see #get(Object...)
1316      */
1317     public final native
1318     @MethodHandle.PolymorphicSignature
1319     @HotSpotIntrinsicCandidate
1320     Object getAndBitwiseOrRelease(Object... args);
1321 
1322     /**
1323      * Atomically sets the value of a variable to the result of
1324      * bitwise AND between the variable&#39;s current value and the {@code mask}
1325      * with the memory semantics of {@link #setVolatile} and returns the
1326      * variable&#39;s previous value, as accessed with the memory semantics of
1327      * {@link #getVolatile}.
1328      *
1329      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1330      * logical AND is performed instead of a bitwise AND.
1331      *
1332      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1333      *
1334      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseAnd}
1335      * must match the access mode type that is the result of calling
1336      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND)} on this
1337      * VarHandle.
1338      *
1339      * @param args the signature-polymorphic parameter list of the form
1340      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1341      * , statically represented using varargs.
1342      * @return the signature-polymorphic result that is the previous value of
1343      * the variable
1344      * , statically represented using {@code Object}.
1345      * @throws UnsupportedOperationException if the access mode is unsupported
1346      * for this VarHandle.
1347      * @throws WrongMethodTypeException if the access mode type does not
1348      * match the caller&#39;s symbolic type descriptor.
1349      * @throws ClassCastException if the access mode type matches the caller&#39;s
1350      * symbolic type descriptor, but a reference cast fails.
1351      * @see #setVolatile(Object...)
1352      * @see #getVolatile(Object...)
1353      */
1354     public final native
1355     @MethodHandle.PolymorphicSignature
1356     @HotSpotIntrinsicCandidate
1357     Object getAndBitwiseAnd(Object... args);
1358 
1359     /**
1360      * Atomically sets the value of a variable to the result of
1361      * bitwise AND between the variable&#39;s current value and the {@code mask}
1362      * with the memory semantics of {@link #set} and returns the
1363      * variable&#39;s previous value, as accessed with the memory semantics of
1364      * {@link #getAcquire}.
1365      *
1366      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1367      * logical AND is performed instead of a bitwise AND.
1368      *
1369      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1370      *
1371      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseAndAcquire}
1372      * must match the access mode type that is the result of calling
1373      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_ACQUIRE)} on this
1374      * VarHandle.
1375      *
1376      * @param args the signature-polymorphic parameter list of the form
1377      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1378      * , statically represented using varargs.
1379      * @return the signature-polymorphic result that is the previous value of
1380      * the variable
1381      * , statically represented using {@code Object}.
1382      * @throws UnsupportedOperationException if the access mode is unsupported
1383      * for this VarHandle.
1384      * @throws WrongMethodTypeException if the access mode type does not
1385      * match the caller&#39;s symbolic type descriptor.
1386      * @throws ClassCastException if the access mode type matches the caller&#39;s
1387      * symbolic type descriptor, but a reference cast fails.
1388      * @see #set(Object...)
1389      * @see #getAcquire(Object...)
1390      */
1391     public final native
1392     @MethodHandle.PolymorphicSignature
1393     @HotSpotIntrinsicCandidate
1394     Object getAndBitwiseAndAcquire(Object... args);
1395 
1396     /**
1397      * Atomically sets the value of a variable to the result of
1398      * bitwise AND between the variable&#39;s current value and the {@code mask}
1399      * with the memory semantics of {@link #setRelease} and returns the
1400      * variable&#39;s previous value, as accessed with the memory semantics of
1401      * {@link #get}.
1402      *
1403      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1404      * logical AND is performed instead of a bitwise AND.
1405      *
1406      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1407      *
1408      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseAndRelease}
1409      * must match the access mode type that is the result of calling
1410      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_RELEASE)} on this
1411      * VarHandle.
1412      *
1413      * @param args the signature-polymorphic parameter list of the form
1414      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1415      * , statically represented using varargs.
1416      * @return the signature-polymorphic result that is the previous value of
1417      * the variable
1418      * , statically represented using {@code Object}.
1419      * @throws UnsupportedOperationException if the access mode is unsupported
1420      * for this VarHandle.
1421      * @throws WrongMethodTypeException if the access mode type does not
1422      * match the caller&#39;s symbolic type descriptor.
1423      * @throws ClassCastException if the access mode type matches the caller&#39;s
1424      * symbolic type descriptor, but a reference cast fails.
1425      * @see #setRelease(Object...)
1426      * @see #get(Object...)
1427      */
1428     public final native
1429     @MethodHandle.PolymorphicSignature
1430     @HotSpotIntrinsicCandidate
1431     Object getAndBitwiseAndRelease(Object... args);
1432 
1433     /**
1434      * Atomically sets the value of a variable to the result of
1435      * bitwise XOR between the variable&#39;s current value and the {@code mask}
1436      * with the memory semantics of {@link #setVolatile} and returns the
1437      * variable&#39;s previous value, as accessed with the memory semantics of
1438      * {@link #getVolatile}.
1439      *
1440      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1441      * logical XOR is performed instead of a bitwise XOR.
1442      *
1443      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1444      *
1445      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseXor}
1446      * must match the access mode type that is the result of calling
1447      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR)} on this
1448      * VarHandle.
1449      *
1450      * @param args the signature-polymorphic parameter list of the form
1451      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1452      * , statically represented using varargs.
1453      * @return the signature-polymorphic result that is the previous value of
1454      * the variable
1455      * , statically represented using {@code Object}.
1456      * @throws UnsupportedOperationException if the access mode is unsupported
1457      * for this VarHandle.
1458      * @throws WrongMethodTypeException if the access mode type does not
1459      * match the caller&#39;s symbolic type descriptor.
1460      * @throws ClassCastException if the access mode type matches the caller&#39;s
1461      * symbolic type descriptor, but a reference cast fails.
1462      * @see #setVolatile(Object...)
1463      * @see #getVolatile(Object...)
1464      */
1465     public final native
1466     @MethodHandle.PolymorphicSignature
1467     @HotSpotIntrinsicCandidate
1468     Object getAndBitwiseXor(Object... args);
1469 
1470     /**
1471      * Atomically sets the value of a variable to the result of
1472      * bitwise XOR between the variable&#39;s current value and the {@code mask}
1473      * with the memory semantics of {@link #set} and returns the
1474      * variable&#39;s previous value, as accessed with the memory semantics of
1475      * {@link #getAcquire}.
1476      *
1477      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1478      * logical XOR is performed instead of a bitwise XOR.
1479      *
1480      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1481      *
1482      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseXorAcquire}
1483      * must match the access mode type that is the result of calling
1484      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE)} on this
1485      * VarHandle.
1486      *
1487      * @param args the signature-polymorphic parameter list of the form
1488      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1489      * , statically represented using varargs.
1490      * @return the signature-polymorphic result that is the previous value of
1491      * the variable
1492      * , statically represented using {@code Object}.
1493      * @throws UnsupportedOperationException if the access mode is unsupported
1494      * for this VarHandle.
1495      * @throws WrongMethodTypeException if the access mode type does not
1496      * match the caller&#39;s symbolic type descriptor.
1497      * @throws ClassCastException if the access mode type matches the caller&#39;s
1498      * symbolic type descriptor, but a reference cast fails.
1499      * @see #set(Object...)
1500      * @see #getAcquire(Object...)
1501      */
1502     public final native
1503     @MethodHandle.PolymorphicSignature
1504     @HotSpotIntrinsicCandidate
1505     Object getAndBitwiseXorAcquire(Object... args);
1506 
1507     /**
1508      * Atomically sets the value of a variable to the result of
1509      * bitwise XOR between the variable&#39;s current value and the {@code mask}
1510      * with the memory semantics of {@link #setRelease} and returns the
1511      * variable&#39;s previous value, as accessed with the memory semantics of
1512      * {@link #get}.
1513      *
1514      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1515      * logical XOR is performed instead of a bitwise XOR.
1516      *
1517      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1518      *
1519      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseXorRelease}
1520      * must match the access mode type that is the result of calling
1521      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_RELEASE)} on this
1522      * VarHandle.
1523      *
1524      * @param args the signature-polymorphic parameter list of the form
1525      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1526      * , statically represented using varargs.
1527      * @return the signature-polymorphic result that is the previous value of
1528      * the variable
1529      * , statically represented using {@code Object}.
1530      * @throws UnsupportedOperationException if the access mode is unsupported
1531      * for this VarHandle.
1532      * @throws WrongMethodTypeException if the access mode type does not
1533      * match the caller&#39;s symbolic type descriptor.
1534      * @throws ClassCastException if the access mode type matches the caller&#39;s
1535      * symbolic type descriptor, but a reference cast fails.
1536      * @see #setRelease(Object...)
1537      * @see #get(Object...)
1538      */
1539     public final native
1540     @MethodHandle.PolymorphicSignature
1541     @HotSpotIntrinsicCandidate
1542     Object getAndBitwiseXorRelease(Object... args);
1543 
1544 
1545     enum AccessType {
1546         GET(Object.class),
1547         SET(void.class),
1548         COMPARE_AND_SET(boolean.class),
1549         COMPARE_AND_EXCHANGE(Object.class),
1550         GET_AND_UPDATE(Object.class);
1551 
1552         final Class&lt;?&gt; returnType;
1553         final boolean isMonomorphicInReturnType;
1554 
1555         AccessType(Class&lt;?&gt; returnType) {
1556             this.returnType = returnType;
1557             isMonomorphicInReturnType = returnType != Object.class;
1558         }
1559 
1560         MethodType accessModeType(Class&lt;?&gt; receiver, Class&lt;?&gt; value,
1561                                   Class&lt;?&gt;... intermediate) {
1562             Class&lt;?&gt;[] ps;
1563             int i;
1564             switch (this) {
1565                 case GET:
1566                     ps = allocateParameters(0, receiver, intermediate);
1567                     fillParameters(ps, receiver, intermediate);
1568                     return MethodType.methodType(value, ps);
1569                 case SET:
1570                     ps = allocateParameters(1, receiver, intermediate);
1571                     i = fillParameters(ps, receiver, intermediate);
1572                     ps[i] = value;
1573                     return MethodType.methodType(void.class, ps);
1574                 case COMPARE_AND_SET:
1575                     ps = allocateParameters(2, receiver, intermediate);
1576                     i = fillParameters(ps, receiver, intermediate);
1577                     ps[i++] = value;
1578                     ps[i] = value;
1579                     return MethodType.methodType(boolean.class, ps);
1580                 case COMPARE_AND_EXCHANGE:
1581                     ps = allocateParameters(2, receiver, intermediate);
1582                     i = fillParameters(ps, receiver, intermediate);
1583                     ps[i++] = value;
1584                     ps[i] = value;
1585                     return MethodType.methodType(value, ps);
1586                 case GET_AND_UPDATE:
1587                     ps = allocateParameters(1, receiver, intermediate);
1588                     i = fillParameters(ps, receiver, intermediate);
1589                     ps[i] = value;
1590                     return MethodType.methodType(value, ps);
1591                 default:
1592                     throw new InternalError(&quot;Unknown AccessType&quot;);
1593             }
1594         }
1595 
1596         private static Class&lt;?&gt;[] allocateParameters(int values,
1597                                                      Class&lt;?&gt; receiver, Class&lt;?&gt;... intermediate) {
1598             int size = ((receiver != null) ? 1 : 0) + intermediate.length + values;
1599             return new Class&lt;?&gt;[size];
1600         }
1601 
1602         private static int fillParameters(Class&lt;?&gt;[] ps,
1603                                           Class&lt;?&gt; receiver, Class&lt;?&gt;... intermediate) {
1604             int i = 0;
1605             if (receiver != null)
1606                 ps[i++] = receiver;
1607             for (int j = 0; j &lt; intermediate.length; j++)
1608                 ps[i++] = intermediate[j];
1609             return i;
1610         }
1611     }
1612 
1613     /**
1614      * The set of access modes that specify how a variable, referenced by a
1615      * VarHandle, is accessed.
1616      */
1617     public enum AccessMode {
1618         /**
1619          * The access mode whose access is specified by the corresponding
1620          * method
1621          * {@link VarHandle#get VarHandle.get}
1622          */
1623         GET(&quot;get&quot;, AccessType.GET),
1624         /**
1625          * The access mode whose access is specified by the corresponding
1626          * method
1627          * {@link VarHandle#set VarHandle.set}
1628          */
1629         SET(&quot;set&quot;, AccessType.SET),
1630         /**
1631          * The access mode whose access is specified by the corresponding
1632          * method
1633          * {@link VarHandle#getVolatile VarHandle.getVolatile}
1634          */
1635         GET_VOLATILE(&quot;getVolatile&quot;, AccessType.GET),
1636         /**
1637          * The access mode whose access is specified by the corresponding
1638          * method
1639          * {@link VarHandle#setVolatile VarHandle.setVolatile}
1640          */
1641         SET_VOLATILE(&quot;setVolatile&quot;, AccessType.SET),
1642         /**
1643          * The access mode whose access is specified by the corresponding
1644          * method
1645          * {@link VarHandle#getAcquire VarHandle.getAcquire}
1646          */
1647         GET_ACQUIRE(&quot;getAcquire&quot;, AccessType.GET),
1648         /**
1649          * The access mode whose access is specified by the corresponding
1650          * method
1651          * {@link VarHandle#setRelease VarHandle.setRelease}
1652          */
1653         SET_RELEASE(&quot;setRelease&quot;, AccessType.SET),
1654         /**
1655          * The access mode whose access is specified by the corresponding
1656          * method
1657          * {@link VarHandle#getOpaque VarHandle.getOpaque}
1658          */
1659         GET_OPAQUE(&quot;getOpaque&quot;, AccessType.GET),
1660         /**
1661          * The access mode whose access is specified by the corresponding
1662          * method
1663          * {@link VarHandle#setOpaque VarHandle.setOpaque}
1664          */
1665         SET_OPAQUE(&quot;setOpaque&quot;, AccessType.SET),
1666         /**
1667          * The access mode whose access is specified by the corresponding
1668          * method
1669          * {@link VarHandle#compareAndSet VarHandle.compareAndSet}
1670          */
1671         COMPARE_AND_SET(&quot;compareAndSet&quot;, AccessType.COMPARE_AND_SET),
1672         /**
1673          * The access mode whose access is specified by the corresponding
1674          * method
1675          * {@link VarHandle#compareAndExchange VarHandle.compareAndExchange}
1676          */
1677         COMPARE_AND_EXCHANGE(&quot;compareAndExchange&quot;, AccessType.COMPARE_AND_EXCHANGE),
1678         /**
1679          * The access mode whose access is specified by the corresponding
1680          * method
1681          * {@link VarHandle#compareAndExchangeAcquire VarHandle.compareAndExchangeAcquire}
1682          */
1683         COMPARE_AND_EXCHANGE_ACQUIRE(&quot;compareAndExchangeAcquire&quot;, AccessType.COMPARE_AND_EXCHANGE),
1684         /**
1685          * The access mode whose access is specified by the corresponding
1686          * method
1687          * {@link VarHandle#compareAndExchangeRelease VarHandle.compareAndExchangeRelease}
1688          */
1689         COMPARE_AND_EXCHANGE_RELEASE(&quot;compareAndExchangeRelease&quot;, AccessType.COMPARE_AND_EXCHANGE),
1690         /**
1691          * The access mode whose access is specified by the corresponding
1692          * method
1693          * {@link VarHandle#weakCompareAndSetPlain VarHandle.weakCompareAndSetPlain}
1694          */
1695         WEAK_COMPARE_AND_SET_PLAIN(&quot;weakCompareAndSetPlain&quot;, AccessType.COMPARE_AND_SET),
1696         /**
1697          * The access mode whose access is specified by the corresponding
1698          * method
1699          * {@link VarHandle#weakCompareAndSet VarHandle.weakCompareAndSet}
1700          */
1701         WEAK_COMPARE_AND_SET(&quot;weakCompareAndSet&quot;, AccessType.COMPARE_AND_SET),
1702         /**
1703          * The access mode whose access is specified by the corresponding
1704          * method
1705          * {@link VarHandle#weakCompareAndSetAcquire VarHandle.weakCompareAndSetAcquire}
1706          */
1707         WEAK_COMPARE_AND_SET_ACQUIRE(&quot;weakCompareAndSetAcquire&quot;, AccessType.COMPARE_AND_SET),
1708         /**
1709          * The access mode whose access is specified by the corresponding
1710          * method
1711          * {@link VarHandle#weakCompareAndSetRelease VarHandle.weakCompareAndSetRelease}
1712          */
1713         WEAK_COMPARE_AND_SET_RELEASE(&quot;weakCompareAndSetRelease&quot;, AccessType.COMPARE_AND_SET),
1714         /**
1715          * The access mode whose access is specified by the corresponding
1716          * method
1717          * {@link VarHandle#getAndSet VarHandle.getAndSet}
1718          */
1719         GET_AND_SET(&quot;getAndSet&quot;, AccessType.GET_AND_UPDATE),
1720         /**
1721          * The access mode whose access is specified by the corresponding
1722          * method
1723          * {@link VarHandle#getAndSetAcquire VarHandle.getAndSetAcquire}
1724          */
1725         GET_AND_SET_ACQUIRE(&quot;getAndSetAcquire&quot;, AccessType.GET_AND_UPDATE),
1726         /**
1727          * The access mode whose access is specified by the corresponding
1728          * method
1729          * {@link VarHandle#getAndSetRelease VarHandle.getAndSetRelease}
1730          */
1731         GET_AND_SET_RELEASE(&quot;getAndSetRelease&quot;, AccessType.GET_AND_UPDATE),
1732         /**
1733          * The access mode whose access is specified by the corresponding
1734          * method
1735          * {@link VarHandle#getAndAdd VarHandle.getAndAdd}
1736          */
1737         GET_AND_ADD(&quot;getAndAdd&quot;, AccessType.GET_AND_UPDATE),
1738         /**
1739          * The access mode whose access is specified by the corresponding
1740          * method
1741          * {@link VarHandle#getAndAddAcquire VarHandle.getAndAddAcquire}
1742          */
1743         GET_AND_ADD_ACQUIRE(&quot;getAndAddAcquire&quot;, AccessType.GET_AND_UPDATE),
1744         /**
1745          * The access mode whose access is specified by the corresponding
1746          * method
1747          * {@link VarHandle#getAndAddRelease VarHandle.getAndAddRelease}
1748          */
1749         GET_AND_ADD_RELEASE(&quot;getAndAddRelease&quot;, AccessType.GET_AND_UPDATE),
1750         /**
1751          * The access mode whose access is specified by the corresponding
1752          * method
1753          * {@link VarHandle#getAndBitwiseOr VarHandle.getAndBitwiseOr}
1754          */
1755         GET_AND_BITWISE_OR(&quot;getAndBitwiseOr&quot;, AccessType.GET_AND_UPDATE),
1756         /**
1757          * The access mode whose access is specified by the corresponding
1758          * method
1759          * {@link VarHandle#getAndBitwiseOrRelease VarHandle.getAndBitwiseOrRelease}
1760          */
1761         GET_AND_BITWISE_OR_RELEASE(&quot;getAndBitwiseOrRelease&quot;, AccessType.GET_AND_UPDATE),
1762         /**
1763          * The access mode whose access is specified by the corresponding
1764          * method
1765          * {@link VarHandle#getAndBitwiseOrAcquire VarHandle.getAndBitwiseOrAcquire}
1766          */
1767         GET_AND_BITWISE_OR_ACQUIRE(&quot;getAndBitwiseOrAcquire&quot;, AccessType.GET_AND_UPDATE),
1768         /**
1769          * The access mode whose access is specified by the corresponding
1770          * method
1771          * {@link VarHandle#getAndBitwiseAnd VarHandle.getAndBitwiseAnd}
1772          */
1773         GET_AND_BITWISE_AND(&quot;getAndBitwiseAnd&quot;, AccessType.GET_AND_UPDATE),
1774         /**
1775          * The access mode whose access is specified by the corresponding
1776          * method
1777          * {@link VarHandle#getAndBitwiseAndRelease VarHandle.getAndBitwiseAndRelease}
1778          */
1779         GET_AND_BITWISE_AND_RELEASE(&quot;getAndBitwiseAndRelease&quot;, AccessType.GET_AND_UPDATE),
1780         /**
1781          * The access mode whose access is specified by the corresponding
1782          * method
1783          * {@link VarHandle#getAndBitwiseAndAcquire VarHandle.getAndBitwiseAndAcquire}
1784          */
1785         GET_AND_BITWISE_AND_ACQUIRE(&quot;getAndBitwiseAndAcquire&quot;, AccessType.GET_AND_UPDATE),
1786         /**
1787          * The access mode whose access is specified by the corresponding
1788          * method
1789          * {@link VarHandle#getAndBitwiseXor VarHandle.getAndBitwiseXor}
1790          */
1791         GET_AND_BITWISE_XOR(&quot;getAndBitwiseXor&quot;, AccessType.GET_AND_UPDATE),
1792         /**
1793          * The access mode whose access is specified by the corresponding
1794          * method
1795          * {@link VarHandle#getAndBitwiseXorRelease VarHandle.getAndBitwiseXorRelease}
1796          */
1797         GET_AND_BITWISE_XOR_RELEASE(&quot;getAndBitwiseXorRelease&quot;, AccessType.GET_AND_UPDATE),
1798         /**
1799          * The access mode whose access is specified by the corresponding
1800          * method
1801          * {@link VarHandle#getAndBitwiseXorAcquire VarHandle.getAndBitwiseXorAcquire}
1802          */
1803         GET_AND_BITWISE_XOR_ACQUIRE(&quot;getAndBitwiseXorAcquire&quot;, AccessType.GET_AND_UPDATE),
1804         ;
1805 
1806         static final Map&lt;String, AccessMode&gt; methodNameToAccessMode;
1807         static {
1808             AccessMode[] values = AccessMode.values();
1809             // Initial capacity of # values divided by the load factor is sufficient
1810             // to avoid resizes for the smallest table size (64)
1811             int initialCapacity = (int)(values.length / 0.75f) + 1;
1812             methodNameToAccessMode = new HashMap&lt;&gt;(initialCapacity);
1813             for (AccessMode am : values) {
1814                 methodNameToAccessMode.put(am.methodName, am);
1815             }
1816         }
1817 
1818         final String methodName;
1819         final AccessType at;
1820 
1821         AccessMode(final String methodName, AccessType at) {
1822             this.methodName = methodName;
1823             this.at = at;
1824         }
1825 
1826         /**
1827          * Returns the {@code VarHandle} signature-polymorphic method name
1828          * associated with this {@code AccessMode} value.
1829          *
1830          * @return the signature-polymorphic method name
1831          * @see #valueFromMethodName
1832          */
1833         public String methodName() {
1834             return methodName;
1835         }
1836 
1837         /**
1838          * Returns the {@code AccessMode} value associated with the specified
1839          * {@code VarHandle} signature-polymorphic method name.
1840          *
1841          * @param methodName the signature-polymorphic method name
1842          * @return the {@code AccessMode} value
1843          * @throws IllegalArgumentException if there is no {@code AccessMode}
1844          *         value associated with method name (indicating the method
1845          *         name does not correspond to a {@code VarHandle}
1846          *         signature-polymorphic method name).
1847          * @see #methodName()
1848          */
1849         public static AccessMode valueFromMethodName(String methodName) {
1850             AccessMode am = methodNameToAccessMode.get(methodName);
1851             if (am != null) return am;
1852             throw new IllegalArgumentException(&quot;No AccessMode value for method name &quot; + methodName);
1853         }
1854 
1855         @ForceInline
1856         static MemberName getMemberName(int ordinal, VarForm vform) {
1857             return vform.memberName_table[ordinal];
1858         }
1859     }
1860 
1861     static final class AccessDescriptor {
1862         final MethodType symbolicMethodTypeErased;
1863         final MethodType symbolicMethodTypeInvoker;
1864         final Class&lt;?&gt; returnType;
1865         final int type;
1866         final int mode;
1867 
1868         public AccessDescriptor(MethodType symbolicMethodType, int type, int mode) {
1869             this.symbolicMethodTypeErased = symbolicMethodType.erase();
1870             this.symbolicMethodTypeInvoker = symbolicMethodType.insertParameterTypes(0, VarHandle.class);
1871             this.returnType = symbolicMethodType.returnType();
1872             this.type = type;
1873             this.mode = mode;
1874         }
1875     }
1876 
1877     /**
1878      * Returns a compact textual description of this {@linkplain VarHandle},
1879      * including the type of variable described, and a description of its coordinates.
1880      *
1881      * @return A compact textual description of this {@linkplain VarHandle}
1882      */
1883     @Override
1884     public final String toString() {
1885         return String.format(&quot;VarHandle[varType=%s, coord=%s]&quot;,
1886                              varType().getName(),
1887                              coordinateTypes());
1888     }
1889 
1890     /**
1891      * Returns the variable type of variables referenced by this VarHandle.
1892      *
1893      * @return the variable type of variables referenced by this VarHandle
1894      */
1895     public Class&lt;?&gt; varType() {
1896         MethodType typeSet = accessModeType(AccessMode.SET);
1897         return typeSet.parameterType(typeSet.parameterCount() - 1);
1898     }
1899 
1900     /**
1901      * Returns the coordinate types for this VarHandle.
1902      *
1903      * @return the coordinate types for this VarHandle. The returned
1904      * list is unmodifiable
1905      */
1906     public List&lt;Class&lt;?&gt;&gt; coordinateTypes() {
1907         MethodType typeGet = accessModeType(AccessMode.GET);
1908         return typeGet.parameterList();
1909     }
1910 
1911     /**
1912      * Obtains the access mode type for this VarHandle and a given access mode.
1913      *
1914      * &lt;p&gt;The access mode type&#39;s parameter types will consist of a prefix that
1915      * is the coordinate types of this VarHandle followed by further
1916      * types as defined by the access mode method.
1917      * The access mode type&#39;s return type is defined by the return type of the
1918      * access mode method.
1919      *
1920      * @param accessMode the access mode, corresponding to the
1921      * signature-polymorphic method of the same name
1922      * @return the access mode type for the given access mode
1923      */
1924     public final MethodType accessModeType(AccessMode accessMode) {
1925         TypesAndInvokers tis = getTypesAndInvokers();
1926         MethodType mt = tis.methodType_table[accessMode.at.ordinal()];
1927         if (mt == null) {
1928             mt = tis.methodType_table[accessMode.at.ordinal()] =
1929                     accessModeTypeUncached(accessMode);
1930         }
1931         return mt;
1932     }
1933     abstract MethodType accessModeTypeUncached(AccessMode accessMode);
1934 
1935     /**
1936      * Returns {@code true} if the given access mode is supported, otherwise
1937      * {@code false}.
1938      *
1939      * &lt;p&gt;The return of a {@code false} value for a given access mode indicates
1940      * that an {@code UnsupportedOperationException} is thrown on invocation
1941      * of the corresponding access mode method.
1942      *
1943      * @param accessMode the access mode, corresponding to the
1944      * signature-polymorphic method of the same name
1945      * @return {@code true} if the given access mode is supported, otherwise
1946      * {@code false}.
1947      */
1948     public final boolean isAccessModeSupported(AccessMode accessMode) {
1949         return AccessMode.getMemberName(accessMode.ordinal(), vform) != null;
1950     }
1951 
1952     /**
1953      * Obtains a method handle bound to this VarHandle and the given access
1954      * mode.
1955      *
1956      * @apiNote This method, for a VarHandle {@code vh} and access mode
1957      * {@code {access-mode}}, returns a method handle that is equivalent to
1958      * method handle {@code bmh} in the following code (though it may be more
1959      * efficient):
1960      * &lt;pre&gt;{@code
1961      * MethodHandle mh = MethodHandles.varHandleExactInvoker(
1962      *                       vh.accessModeType(VarHandle.AccessMode.{access-mode}));
1963      *
1964      * MethodHandle bmh = mh.bindTo(vh);
1965      * }&lt;/pre&gt;
1966      *
1967      * @param accessMode the access mode, corresponding to the
1968      * signature-polymorphic method of the same name
1969      * @return a method handle bound to this VarHandle and the given access mode
1970      */
1971     public MethodHandle toMethodHandle(AccessMode accessMode) {
1972         MemberName mn = AccessMode.getMemberName(accessMode.ordinal(), vform);
1973         if (mn != null) {
1974             MethodHandle mh = getMethodHandle(accessMode.ordinal());
1975             return mh.bindTo(this);
1976         }
1977         else {
1978             // Ensure an UnsupportedOperationException is thrown
1979             return MethodHandles.varHandleInvoker(accessMode, accessModeType(accessMode)).
1980                     bindTo(this);
1981         }
1982     }
1983 
1984     /**
1985      * Return a nominal descriptor for this instance, if one can be
1986      * constructed, or an empty {@link Optional} if one cannot be.
1987      *
1988      * @return An {@link Optional} containing the resulting nominal descriptor,
1989      * or an empty {@link Optional} if one cannot be constructed.
1990      * @since 12
1991      */
1992     @Override
1993     public Optional&lt;VarHandleDesc&gt; describeConstable() {
1994         // partial function for field and array only
1995         return Optional.empty();
1996     }
1997 
1998     @Stable
1999     TypesAndInvokers typesAndInvokers;
2000 
2001     static class TypesAndInvokers {
2002         final @Stable
2003         MethodType[] methodType_table =
2004                 new MethodType[VarHandle.AccessType.values().length];
2005 
2006         final @Stable
2007         MethodHandle[] methodHandle_table =
2008                 new MethodHandle[AccessMode.values().length];
2009     }
2010 
2011     @ForceInline
2012     private final TypesAndInvokers getTypesAndInvokers() {
2013         TypesAndInvokers tis = typesAndInvokers;
2014         if (tis == null) {
2015             tis = typesAndInvokers = new TypesAndInvokers();
2016         }
2017         return tis;
2018     }
2019 
2020     @ForceInline
2021     MethodHandle getMethodHandle(int mode) {
2022         TypesAndInvokers tis = getTypesAndInvokers();
2023         MethodHandle mh = tis.methodHandle_table[mode];
2024         if (mh == null) {
2025             mh = tis.methodHandle_table[mode] = getMethodHandleUncached(mode);
2026         }
2027         return mh;
2028     }
2029     private final MethodHandle getMethodHandleUncached(int mode) {
2030         MethodType mt = accessModeType(AccessMode.values()[mode]).
2031                 insertParameterTypes(0, VarHandle.class);
2032         MemberName mn = vform.getMemberName(mode);
2033         DirectMethodHandle dmh = DirectMethodHandle.make(mn);
2034         // Such a method handle must not be publically exposed directly
2035         // otherwise it can be cracked, it must be transformed or rebound
2036         // before exposure
2037         MethodHandle mh = dmh.copyWith(mt, dmh.form);
2038         assert mh.type().erase() == mn.getMethodType().erase();
2039         return mh;
2040     }
2041 
2042 
2043     /*non-public*/
2044     final void updateVarForm(VarForm newVForm) {
2045         if (vform == newVForm) return;
2046         UNSAFE.putReference(this, VFORM_OFFSET, newVForm);
2047         UNSAFE.fullFence();
2048     }
2049 
2050     static final BiFunction&lt;String, List&lt;Integer&gt;, ArrayIndexOutOfBoundsException&gt;
2051             AIOOBE_SUPPLIER = Preconditions.outOfBoundsExceptionFormatter(
2052             new Function&lt;String, ArrayIndexOutOfBoundsException&gt;() {
2053                 @Override
2054                 public ArrayIndexOutOfBoundsException apply(String s) {
2055                     return new ArrayIndexOutOfBoundsException(s);
2056                 }
2057             });
2058 
2059     private static final long VFORM_OFFSET;
2060 
2061     static {
2062         VFORM_OFFSET = UNSAFE.objectFieldOffset(VarHandle.class, &quot;vform&quot;);
2063 
2064         // The VarHandleGuards must be initialized to ensure correct
2065         // compilation of the guard methods
2066         UNSAFE.ensureClassInitialized(VarHandleGuards.class);
2067     }
2068 
2069 
2070     // Fence methods
2071 
2072     /**
2073      * Ensures that loads and stores before the fence will not be reordered
2074      * with
2075      * loads and stores after the fence.
2076      *
2077      * @apiNote Ignoring the many semantic differences from C and C++, this
2078      * method has memory ordering effects compatible with
2079      * {@code atomic_thread_fence(memory_order_seq_cst)}
2080      */
2081     @ForceInline
2082     public static void fullFence() {
2083         UNSAFE.fullFence();
2084     }
2085 
2086     /**
2087      * Ensures that loads before the fence will not be reordered with loads and
2088      * stores after the fence.
2089      *
2090      * @apiNote Ignoring the many semantic differences from C and C++, this
2091      * method has memory ordering effects compatible with
2092      * {@code atomic_thread_fence(memory_order_acquire)}
2093      */
2094     @ForceInline
2095     public static void acquireFence() {
2096         UNSAFE.loadFence();
2097     }
2098 
2099     /**
2100      * Ensures that loads and stores before the fence will not be
2101      * reordered with stores after the fence.
2102      *
2103      * @apiNote Ignoring the many semantic differences from C and C++, this
2104      * method has memory ordering effects compatible with
2105      * {@code atomic_thread_fence(memory_order_release)}
2106      */
2107     @ForceInline
2108     public static void releaseFence() {
2109         UNSAFE.storeFence();
2110     }
2111 
2112     /**
2113      * Ensures that loads before the fence will not be reordered with
2114      * loads after the fence.
2115      */
2116     @ForceInline
2117     public static void loadLoadFence() {
2118         UNSAFE.loadLoadFence();
2119     }
2120 
2121     /**
2122      * Ensures that stores before the fence will not be reordered with
2123      * stores after the fence.
2124      */
2125     @ForceInline
2126     public static void storeStoreFence() {
2127         UNSAFE.storeStoreFence();
2128     }
2129 
2130     /**
2131      * A &lt;a href=&quot;{@docRoot}/java.base/java/lang/constant/package-summary.html#nominal&quot;&gt;nominal descriptor&lt;/a&gt; for a
2132      * {@link VarHandle} constant.
2133      *
2134      * @since 12
2135      */
2136     public static final class VarHandleDesc extends DynamicConstantDesc&lt;VarHandle&gt; {
2137 
2138         /**
2139          * Kinds of variable handle descs
2140          */
2141         private enum Kind {
2142             FIELD(ConstantDescs.BSM_VARHANDLE_FIELD),
2143             STATIC_FIELD(ConstantDescs.BSM_VARHANDLE_STATIC_FIELD),
2144             ARRAY(ConstantDescs.BSM_VARHANDLE_ARRAY);
2145 
2146             final DirectMethodHandleDesc bootstrapMethod;
2147 
2148             Kind(DirectMethodHandleDesc bootstrapMethod) {
2149                 this.bootstrapMethod = bootstrapMethod;
2150             }
2151 
2152             ConstantDesc[] toBSMArgs(ClassDesc declaringClass, ClassDesc varType) {
2153                 switch (this) {
2154                     case FIELD:
2155                     case STATIC_FIELD:
2156                         return new ConstantDesc[] {declaringClass, varType };
2157                     case ARRAY:
2158                         return new ConstantDesc[] {declaringClass };
2159                     default:
2160                         throw new InternalError(&quot;Cannot reach here&quot;);
2161                 }
2162             }
2163         }
2164 
2165         private final Kind kind;
2166         private final ClassDesc declaringClass;
2167         private final ClassDesc varType;
2168 
2169         /**
2170          * Construct a {@linkplain VarHandleDesc} given a kind, name, and declaring
2171          * class.
2172          *
2173          * @param kind the kind of the var handle
2174          * @param name the unqualified name of the field, for field var handles; otherwise ignored
2175          * @param declaringClass a {@link ClassDesc} describing the declaring class,
2176          *                       for field var handles
2177          * @param varType a {@link ClassDesc} describing the type of the variable
2178          * @throws NullPointerException if any required argument is null
2179          * @jvms 4.2.2 Unqualified Names
2180          */
2181         private VarHandleDesc(Kind kind, String name, ClassDesc declaringClass, ClassDesc varType) {
2182             super(kind.bootstrapMethod, name,
2183                   ConstantDescs.CD_VarHandle,
2184                   kind.toBSMArgs(declaringClass, varType));
2185             this.kind = kind;
2186             this.declaringClass = declaringClass;
2187             this.varType = varType;
2188         }
2189 
2190         /**
2191          * Returns a {@linkplain VarHandleDesc} corresponding to a {@link VarHandle}
2192          * for an instance field.
2193          *
2194          * @param name the unqualifed name of the field
2195          * @param declaringClass a {@link ClassDesc} describing the declaring class,
2196          *                       for field var handles
2197          * @param fieldType a {@link ClassDesc} describing the type of the field
2198          * @return the {@linkplain VarHandleDesc}
2199          * @throws NullPointerException if any of the arguments are null
2200          * @jvms 4.2.2 Unqualified Names
2201          */
2202         public static VarHandleDesc ofField(ClassDesc declaringClass, String name, ClassDesc fieldType) {
2203             Objects.requireNonNull(declaringClass);
2204             Objects.requireNonNull(name);
2205             Objects.requireNonNull(fieldType);
2206             return new VarHandleDesc(Kind.FIELD, name, declaringClass, fieldType);
2207         }
2208 
2209         /**
2210          * Returns a {@linkplain VarHandleDesc} corresponding to a {@link VarHandle}
2211          * for a static field.
2212          *
2213          * @param name the unqualified name of the field
2214          * @param declaringClass a {@link ClassDesc} describing the declaring class,
2215          *                       for field var handles
2216          * @param fieldType a {@link ClassDesc} describing the type of the field
2217          * @return the {@linkplain VarHandleDesc}
2218          * @throws NullPointerException if any of the arguments are null
2219          * @jvms 4.2.2 Unqualified Names
2220          */
2221         public static VarHandleDesc ofStaticField(ClassDesc declaringClass, String name, ClassDesc fieldType) {
2222             Objects.requireNonNull(declaringClass);
2223             Objects.requireNonNull(name);
2224             Objects.requireNonNull(fieldType);
2225             return new VarHandleDesc(Kind.STATIC_FIELD, name, declaringClass, fieldType);
2226         }
2227 
2228         /**
2229          * Returns a {@linkplain VarHandleDesc} corresponding to a {@link VarHandle}
2230          * for an array type.
2231          *
2232          * @param arrayClass a {@link ClassDesc} describing the type of the array
2233          * @return the {@linkplain VarHandleDesc}
2234          * @throws NullPointerException if any of the arguments are null
2235          */
2236         public static VarHandleDesc ofArray(ClassDesc arrayClass) {
2237             Objects.requireNonNull(arrayClass);
2238             if (!arrayClass.isArray())
2239                 throw new IllegalArgumentException(&quot;Array class argument not an array: &quot; + arrayClass);
2240             return new VarHandleDesc(Kind.ARRAY, ConstantDescs.DEFAULT_NAME, arrayClass, arrayClass.componentType());
2241         }
2242 
2243         /**
2244          * Returns a {@link ClassDesc} describing the type of the variable described
2245          * by this descriptor.
2246          *
2247          * @return the variable type
2248          */
2249         public ClassDesc varType() {
2250             return varType;
2251         }
2252 
2253         @Override
2254         public VarHandle resolveConstantDesc(MethodHandles.Lookup lookup)
2255                 throws ReflectiveOperationException {
2256             switch (kind) {
2257                 case FIELD:
2258                     return lookup.findVarHandle((Class&lt;?&gt;) declaringClass.resolveConstantDesc(lookup),
2259                                                 constantName(),
2260                                                 (Class&lt;?&gt;) varType.resolveConstantDesc(lookup));
2261                 case STATIC_FIELD:
2262                     return lookup.findStaticVarHandle((Class&lt;?&gt;) declaringClass.resolveConstantDesc(lookup),
2263                                                       constantName(),
2264                                                       (Class&lt;?&gt;) varType.resolveConstantDesc(lookup));
2265                 case ARRAY:
2266                     return MethodHandles.arrayElementVarHandle((Class&lt;?&gt;) declaringClass.resolveConstantDesc(lookup));
2267                 default:
2268                     throw new InternalError(&quot;Cannot reach here&quot;);
2269             }
2270         }
2271 
2272         /**
2273          * Returns a compact textual description of this constant description.
2274          * For a field {@linkplain VarHandle}, includes the owner, name, and type
2275          * of the field, and whether it is static; for an array {@linkplain VarHandle},
2276          * the name of the component type.
2277          *
2278          * @return A compact textual description of this descriptor
2279          */
2280         @Override
2281         public String toString() {
2282             switch (kind) {
2283                 case FIELD:
2284                 case STATIC_FIELD:
2285                     return String.format(&quot;VarHandleDesc[%s%s.%s:%s]&quot;,
2286                                          (kind == Kind.STATIC_FIELD) ? &quot;static &quot; : &quot;&quot;,
2287                                          declaringClass.displayName(), constantName(), varType.displayName());
2288                 case ARRAY:
2289                     return String.format(&quot;VarHandleDesc[%s[]]&quot;, declaringClass.displayName());
2290                 default:
2291                     throw new InternalError(&quot;Cannot reach here&quot;);
2292             }
2293         }
2294     }
2295 
2296 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
diff a/make/gensrc/GensrcVarHandles.gmk b/make/gensrc/GensrcVarHandles.gmk
--- a/make/gensrc/GensrcVarHandles.gmk
+++ b/make/gensrc/GensrcVarHandles.gmk
@@ -158,18 +158,18 @@
 endef
 
 ################################################################################
 
 ################################################################################
-# Setup a rule for generating a VarHandleMemoryAddress java class
+# Setup a rule for generating a memory access var handle helper classes
 # Param 1 - Variable declaration prefix
 # Param 2 - Type with first letter capitalized
-define GenerateVarHandleMemoryAddress
+define GenerateVarHandleMemoryAccess
 
   $1_Type := $2
 
-  $1_FILENAME := $(VARHANDLES_GENSRC_DIR)/VarHandleMemoryAddressAs$$($1_Type)s.java
+  $1_FILENAME := $(VARHANDLES_GENSRC_DIR)/MemoryAccessVarHandle$$($1_Type)Helper.java
 
   ifeq ($$($1_Type), Byte)
     $1_type := byte
     $1_BoxType := $$($1_Type)
 
@@ -246,11 +246,11 @@
 
     $1_ARGS += -KCAS
     $1_ARGS += -KfloatingPoint
   endif
 
-  $$($1_FILENAME): $(VARHANDLES_SRC_DIR)/X-VarHandleMemoryAddressView.java.template $(BUILD_TOOLS_JDK)
+  $$($1_FILENAME): $(VARHANDLES_SRC_DIR)/X-VarHandleMemoryAccess.java.template $(BUILD_TOOLS_JDK)
 	$$(call MakeDir, $$(@D))
 	$(RM) $$@
 	$(TOOL_SPP) -nel -K$$($1_type) \
 	    -Dtype=$$($1_type) -DType=$$($1_Type) -DBoxType=$$($1_BoxType) \
 	    -DrawType=$$($1_rawType) -DRawType=$$($1_RawType) -DRawBoxType=$$($1_RawBoxType) \
@@ -272,11 +272,11 @@
   $(eval $(call GenerateVarHandleByteArray,VAR_HANDLE_BYTE_ARRAY_$t,$t)))
 
 # List the types to generate source for, with capitalized first letter
 VARHANDLES_MEMORY_ADDRESS_TYPES := Byte Short Char Int Long Float Double
 $(foreach t, $(VARHANDLES_MEMORY_ADDRESS_TYPES), \
-  $(eval $(call GenerateVarHandleMemoryAddress,VAR_HANDLE_MEMORY_ADDRESS_$t,$t)))
+  $(eval $(call GenerateVarHandleMemoryAccess,VAR_HANDLE_MEMORY_ADDRESS_$t,$t)))
 
 GENSRC_JAVA_BASE += $(GENSRC_VARHANDLES)
 
 # Include custom extension post hook
 $(eval $(call IncludeCustomExtension, gensrc/GensrcVarHandles-post.gmk))
diff a/src/java.base/share/classes/java/lang/invoke/AddressVarHandleGenerator.java b/src/java.base/share/classes/java/lang/invoke/AddressVarHandleGenerator.java
--- a/src/java.base/share/classes/java/lang/invoke/AddressVarHandleGenerator.java
+++ /dev/null
@@ -1,525 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package java.lang.invoke;
-
-import jdk.internal.access.foreign.MemoryAddressProxy;
-import jdk.internal.misc.Unsafe;
-import jdk.internal.org.objectweb.asm.ClassReader;
-import jdk.internal.org.objectweb.asm.ClassWriter;
-import jdk.internal.org.objectweb.asm.MethodVisitor;
-import jdk.internal.org.objectweb.asm.Opcodes;
-import jdk.internal.org.objectweb.asm.Type;
-import jdk.internal.org.objectweb.asm.util.TraceClassVisitor;
-import jdk.internal.vm.annotation.ForceInline;
-import sun.security.action.GetBooleanAction;
-import sun.security.action.GetPropertyAction;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_FINAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PRIVATE;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_STATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_SUPER;
-import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;
-import static jdk.internal.org.objectweb.asm.Opcodes.BIPUSH;
-import static jdk.internal.org.objectweb.asm.Opcodes.CHECKCAST;
-import static jdk.internal.org.objectweb.asm.Opcodes.GETFIELD;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_0;
-import static jdk.internal.org.objectweb.asm.Opcodes.ILOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.LALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.LASTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.LLOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.NEWARRAY;
-import static jdk.internal.org.objectweb.asm.Opcodes.PUTFIELD;
-import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;
-import static jdk.internal.org.objectweb.asm.Opcodes.DUP;
-import static jdk.internal.org.objectweb.asm.Opcodes.SIPUSH;
-import static jdk.internal.org.objectweb.asm.Opcodes.T_LONG;
-
-class AddressVarHandleGenerator {
-    private static final String DEBUG_DUMP_CLASSES_DIR_PROPERTY = "jdk.internal.foreign.ClassGenerator.DEBUG_DUMP_CLASSES_DIR";
-
-    private static final boolean DEBUG =
-        GetBooleanAction.privilegedGetProperty("jdk.internal.foreign.ClassGenerator.DEBUG");
-
-    private static final Class<?> BASE_CLASS = VarHandleMemoryAddressBase.class;
-
-    private static final HashMap<Class<?>, Class<?>> helperClassCache;
-
-    private final static MethodType OFFSET_OP_TYPE;
-
-    private final static MethodHandle ADD_OFFSETS_HANDLE;
-    private final static MethodHandle MUL_OFFSETS_HANDLE;
-
-    static {
-        helperClassCache = new HashMap<>();
-        helperClassCache.put(byte.class, VarHandleMemoryAddressAsBytes.class);
-        helperClassCache.put(short.class, VarHandleMemoryAddressAsShorts.class);
-        helperClassCache.put(char.class, VarHandleMemoryAddressAsChars.class);
-        helperClassCache.put(int.class, VarHandleMemoryAddressAsInts.class);
-        helperClassCache.put(long.class, VarHandleMemoryAddressAsLongs.class);
-        helperClassCache.put(float.class, VarHandleMemoryAddressAsFloats.class);
-        helperClassCache.put(double.class, VarHandleMemoryAddressAsDoubles.class);
-
-        OFFSET_OP_TYPE = MethodType.methodType(long.class, long.class, long.class, MemoryAddressProxy.class);
-
-        try {
-            ADD_OFFSETS_HANDLE = MethodHandles.Lookup.IMPL_LOOKUP.findStatic(MemoryAddressProxy.class, "addOffsets", OFFSET_OP_TYPE);
-            MUL_OFFSETS_HANDLE = MethodHandles.Lookup.IMPL_LOOKUP.findStatic(MemoryAddressProxy.class, "multiplyOffsets", OFFSET_OP_TYPE);
-        } catch (Throwable ex) {
-            throw new ExceptionInInitializerError(ex);
-        }
-    }
-
-    private static final File DEBUG_DUMP_CLASSES_DIR;
-
-    static {
-        String path = GetPropertyAction.privilegedGetProperty(DEBUG_DUMP_CLASSES_DIR_PROPERTY);
-        if (path == null) {
-            DEBUG_DUMP_CLASSES_DIR = null;
-        } else {
-            DEBUG_DUMP_CLASSES_DIR = new File(path);
-        }
-    }
-
-    private static final Unsafe U = Unsafe.getUnsafe();
-
-    private final String implClassName;
-    private final int dimensions;
-    private final Class<?> carrier;
-    private final Class<?> helperClass;
-    private final VarForm form;
-
-    AddressVarHandleGenerator(Class<?> carrier, int dims) {
-        this.dimensions = dims;
-        this.carrier = carrier;
-        Class<?>[] components = new Class<?>[dimensions];
-        Arrays.fill(components, long.class);
-        this.form = new VarForm(BASE_CLASS, MemoryAddressProxy.class, carrier, components);
-        this.helperClass = helperClassCache.get(carrier);
-        this.implClassName = helperClass.getName().replace('.', '/') + dimensions;
-    }
-
-    /*
-     * Generate a VarHandle memory access factory.
-     * The factory has type (ZJJ[J)VarHandle.
-     */
-    MethodHandle generateHandleFactory() {
-        Class<?> implCls = generateClass();
-        try {
-            Class<?>[] components = new Class<?>[dimensions];
-            Arrays.fill(components, long.class);
-
-            VarForm form = new VarForm(implCls, MemoryAddressProxy.class, carrier, components);
-
-            MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);
-            MethodHandle constr = MethodHandles.Lookup.IMPL_LOOKUP.findConstructor(implCls, constrType);
-            constr = MethodHandles.insertArguments(constr, 0, form);
-            return constr;
-        } catch (Throwable ex) {
-            throw new AssertionError(ex);
-        }
-    }
-
-    /*
-     * Generate a specialized VarHandle class for given carrier
-     * and access coordinates.
-     */
-    Class<?> generateClass() {
-        BinderClassWriter cw = new BinderClassWriter();
-
-        if (DEBUG) {
-            System.out.println("Generating header implementation class");
-        }
-
-        cw.visit(52, ACC_PUBLIC | ACC_SUPER, implClassName, null, Type.getInternalName(BASE_CLASS), null);
-
-        //add dimension fields
-        for (int i = 0; i < dimensions; i++) {
-            cw.visitField(ACC_PRIVATE | ACC_FINAL, "dim" + i, "J", null, null);
-        }
-
-        addConstructor(cw);
-
-        addAccessModeTypeMethod(cw);
-
-        addStridesAccessor(cw);
-
-        addCarrierAccessor(cw);
-
-        for (VarHandle.AccessMode mode : VarHandle.AccessMode.values()) {
-            addAccessModeMethodIfNeeded(mode, cw);
-        }
-
-
-        cw.visitEnd();
-        byte[] classBytes = cw.toByteArray();
-        return defineClass(cw, classBytes);
-    }
-
-    void addConstructor(BinderClassWriter cw) {
-        MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);
-        MethodVisitor mv = cw.visitMethod(0, "<init>", constrType.toMethodDescriptorString(), null, null);
-        mv.visitCode();
-        //super call
-        mv.visitVarInsn(ALOAD, 0);
-        mv.visitVarInsn(ALOAD, 1);
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(VarForm.class));
-        mv.visitVarInsn(ILOAD, 2);
-        mv.visitVarInsn(LLOAD, 3);
-        mv.visitVarInsn(LLOAD, 5);
-        mv.visitVarInsn(LLOAD, 7);
-        mv.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(BASE_CLASS), "<init>",
-                MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class).toMethodDescriptorString(), false);
-        //init dimensions
-        for (int i = 0 ; i < dimensions ; i++) {
-            mv.visitVarInsn(ALOAD, 0);
-            mv.visitVarInsn(ALOAD, 9);
-            mv.visitLdcInsn(i);
-            mv.visitInsn(LALOAD);
-            mv.visitFieldInsn(PUTFIELD, implClassName, "dim" + i, "J");
-        }
-        mv.visitInsn(RETURN);
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    void addAccessModeTypeMethod(BinderClassWriter cw) {
-        MethodType modeMethType = MethodType.methodType(MethodType.class, VarHandle.AccessMode.class);
-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "accessModeTypeUncached", modeMethType.toMethodDescriptorString(), null, null);
-        mv.visitCode();
-        mv.visitVarInsn(ALOAD, 1);
-        mv.visitFieldInsn(GETFIELD, Type.getInternalName(VarHandle.AccessMode.class), "at", Type.getDescriptor(VarHandle.AccessType.class));
-        mv.visitLdcInsn(cw.makeConstantPoolPatch(MemoryAddressProxy.class));
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
-        mv.visitLdcInsn(cw.makeConstantPoolPatch(carrier));
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
-
-        Class<?>[] dims = new Class<?>[dimensions];
-        Arrays.fill(dims, long.class);
-        mv.visitLdcInsn(cw.makeConstantPoolPatch(dims));
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class[].class));
-
-        mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(VarHandle.AccessType.class),
-                "accessModeType", MethodType.methodType(MethodType.class, Class.class, Class.class, Class[].class).toMethodDescriptorString(), false);
-
-        mv.visitInsn(ARETURN);
-
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    void addAccessModeMethodIfNeeded(VarHandle.AccessMode mode, BinderClassWriter cw) {
-        String methName = mode.methodName();
-        MethodType methType = form.getMethodType(mode.at.ordinal())
-                .insertParameterTypes(0, VarHandle.class);
-
-        try {
-            MethodType helperType = methType.insertParameterTypes(2, long.class);
-            if (dimensions > 0) {
-                helperType = helperType.dropParameterTypes(3, 3 + dimensions);
-            }
-            //try to resolve...
-            String helperMethodName = methName + "0";
-            MethodHandles.Lookup.IMPL_LOOKUP
-                    .findStatic(helperClass,
-                            helperMethodName,
-                            helperType);
-
-
-            MethodVisitor mv = cw.visitMethod(ACC_STATIC, methName, methType.toMethodDescriptorString(), null, null);
-            mv.visitAnnotation(Type.getDescriptor(ForceInline.class), true);
-            mv.visitCode();
-
-            mv.visitVarInsn(ALOAD, 0); // handle impl
-            mv.visitVarInsn(ALOAD, 1); // receiver
-
-            // offset calculation
-            int slot = 2;
-            mv.visitVarInsn(ALOAD, 0); // load recv
-            mv.visitTypeInsn(CHECKCAST, Type.getInternalName(BASE_CLASS));
-            mv.visitFieldInsn(GETFIELD, Type.getInternalName(BASE_CLASS), "offset", "J");
-            for (int i = 0 ; i < dimensions ; i++) {
-                // load ADD MH
-                mv.visitLdcInsn(cw.makeConstantPoolPatch(ADD_OFFSETS_HANDLE));
-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
-
-                //fixup stack so that ADD MH ends up bottom
-                mv.visitInsn(Opcodes.DUP_X2);
-                mv.visitInsn(Opcodes.POP);
-
-                // load MUL MH
-                mv.visitLdcInsn(cw.makeConstantPoolPatch(MUL_OFFSETS_HANDLE));
-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
-
-                mv.visitVarInsn(ALOAD, 0); // load recv
-                mv.visitTypeInsn(CHECKCAST, implClassName);
-                mv.visitFieldInsn(GETFIELD, implClassName, "dim" + i, "J");
-                mv.visitVarInsn(LLOAD, slot);
-
-                mv.visitVarInsn(ALOAD, 1); // receiver
-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MemoryAddressProxy.class));
-
-                //MUL
-                mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(MethodHandle.class), "invokeExact",
-                        OFFSET_OP_TYPE.toMethodDescriptorString(), false);
-
-                mv.visitVarInsn(ALOAD, 1); // receiver
-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MemoryAddressProxy.class));
-
-                //ADD
-                mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(MethodHandle.class), "invokeExact",
-                        OFFSET_OP_TYPE.toMethodDescriptorString(), false);
-                slot += 2;
-            }
-
-            for (int i = 2 + dimensions; i < methType.parameterCount() ; i++) {
-                Class<?> param = methType.parameterType(i);
-                mv.visitVarInsn(loadInsn(param), slot); // load index
-                slot += getSlotsForType(param);
-            }
-
-            //call helper
-            mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(helperClass), helperMethodName,
-                    helperType.toMethodDescriptorString(), false);
-
-            mv.visitInsn(returnInsn(helperType.returnType()));
-
-            mv.visitMaxs(0, 0);
-            mv.visitEnd();
-        } catch (ReflectiveOperationException ex) {
-            //not found, skip
-        }
-    }
-
-    void addStridesAccessor(BinderClassWriter cw) {
-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "strides", "()[J", null, null);
-        mv.visitCode();
-        iConstInsn(mv, dimensions);
-        mv.visitIntInsn(NEWARRAY, T_LONG);
-
-        for (int i = 0 ; i < dimensions ; i++) {
-            mv.visitInsn(DUP);
-            iConstInsn(mv, i);
-            mv.visitVarInsn(ALOAD, 0);
-            mv.visitFieldInsn(GETFIELD, implClassName, "dim" + i, "J");
-            mv.visitInsn(LASTORE);
-        }
-
-        mv.visitInsn(ARETURN);
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    void addCarrierAccessor(BinderClassWriter cw) {
-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "carrier", "()Ljava/lang/Class;", null, null);
-        mv.visitCode();
-        mv.visitLdcInsn(cw.makeConstantPoolPatch(carrier));
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
-        mv.visitInsn(ARETURN);
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    //where
-    private Class<?> defineClass(BinderClassWriter cw, byte[] classBytes) {
-        try {
-            if (DEBUG_DUMP_CLASSES_DIR != null) {
-                debugWriteClassToFile(classBytes);
-            }
-            Object[] patches = cw.resolvePatches(classBytes);
-            Class<?> c = U.defineAnonymousClass(BASE_CLASS, classBytes, patches);
-            return c;
-        } catch (Throwable e) {
-            debugPrintClass(classBytes);
-            throw e;
-        }
-    }
-
-    // shared code generation helpers
-
-    private static int getSlotsForType(Class<?> c) {
-        if (c == long.class || c == double.class) {
-            return 2;
-        }
-        return 1;
-    }
-
-    /**
-     * Emits an actual return instruction conforming to the given return type.
-     */
-    private int returnInsn(Class<?> type) {
-        return switch (LambdaForm.BasicType.basicType(type)) {
-            case I_TYPE -> Opcodes.IRETURN;
-            case J_TYPE -> Opcodes.LRETURN;
-            case F_TYPE -> Opcodes.FRETURN;
-            case D_TYPE -> Opcodes.DRETURN;
-            case L_TYPE -> Opcodes.ARETURN;
-            case V_TYPE -> RETURN;
-        };
-    }
-
-    private int loadInsn(Class<?> type) {
-        return switch (LambdaForm.BasicType.basicType(type)) {
-            case I_TYPE -> Opcodes.ILOAD;
-            case J_TYPE -> LLOAD;
-            case F_TYPE -> Opcodes.FLOAD;
-            case D_TYPE -> Opcodes.DLOAD;
-            case L_TYPE -> Opcodes.ALOAD;
-            case V_TYPE -> throw new IllegalStateException("Cannot load void");
-        };
-    }
-
-    private static void iConstInsn(MethodVisitor mv, int i) {
-        switch (i) {
-            case -1, 0, 1, 2, 3, 4, 5:
-                mv.visitInsn(ICONST_0 + i);
-                break;
-            default:
-                if(i >= Byte.MIN_VALUE && i <= Byte.MAX_VALUE) {
-                    mv.visitIntInsn(BIPUSH, i);
-                } else if (i >= Short.MIN_VALUE && i <= Short.MAX_VALUE) {
-                    mv.visitIntInsn(SIPUSH, i);
-                } else {
-                    mv.visitLdcInsn(i);
-                }
-        }
-    }
-
-    // debug helpers
-
-    private static String debugPrintClass(byte[] classFile) {
-        ClassReader cr = new ClassReader(classFile);
-        StringWriter sw = new StringWriter();
-        cr.accept(new TraceClassVisitor(new PrintWriter(sw)), 0);
-        return sw.toString();
-    }
-
-    private void debugWriteClassToFile(byte[] classFile) {
-        File file = new File(DEBUG_DUMP_CLASSES_DIR, implClassName + ".class");
-
-        if (DEBUG) {
-            System.err.println("Dumping class " + implClassName + " to " + file);
-        }
-
-        try {
-            debugWriteDataToFile(classFile, file);
-        } catch (Exception e) {
-            throw new RuntimeException("Failed to write class " + implClassName + " to file " + file);
-        }
-    }
-
-    private void debugWriteDataToFile(byte[] data, File file) {
-        if (file.exists()) {
-            file.delete();
-        }
-        if (file.exists()) {
-            throw new RuntimeException("Failed to remove pre-existing file " + file);
-        }
-
-        File parent = file.getParentFile();
-        if (!parent.exists()) {
-            parent.mkdirs();
-        }
-        if (!parent.exists()) {
-            throw new RuntimeException("Failed to create " + parent);
-        }
-        if (!parent.isDirectory()) {
-            throw new RuntimeException(parent + " is not a directory");
-        }
-
-        try (FileOutputStream fos = new FileOutputStream(file)) {
-            fos.write(data);
-        } catch (IOException e) {
-            throw new RuntimeException("Failed to write class " + implClassName + " to file " + file);
-        }
-    }
-
-    static class BinderClassWriter extends ClassWriter {
-
-        private final ArrayList<ConstantPoolPatch> cpPatches = new ArrayList<>();
-        private int curUniquePatchIndex = 0;
-
-        BinderClassWriter() {
-            super(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
-        }
-
-        public String makeConstantPoolPatch(Object o) {
-            int myUniqueIndex = curUniquePatchIndex++;
-            String cpPlaceholder = "CONSTANT_PLACEHOLDER_" + myUniqueIndex;
-            int index = newConst(cpPlaceholder);
-            cpPatches.add(new ConstantPoolPatch(index, cpPlaceholder, o));
-            return cpPlaceholder;
-        }
-
-        public Object[] resolvePatches(byte[] classFile) {
-            if (cpPatches.isEmpty()) {
-                return null;
-            }
-
-            int size = ((classFile[8] & 0xFF) << 8) | (classFile[9] & 0xFF);
-
-            Object[] patches = new Object[size];
-            for (ConstantPoolPatch p : cpPatches) {
-                if (p.index >= size) {
-                    throw new InternalError("Failed to resolve constant pool patch entries");
-                }
-                patches[p.index] = p.value;
-            }
-
-            return patches;
-        }
-
-        static class ConstantPoolPatch {
-            final int index;
-            final String placeholder;
-            final Object value;
-
-            ConstantPoolPatch(int index, String placeholder, Object value) {
-                this.index = index;
-                this.placeholder = placeholder;
-                this.value = value;
-            }
-
-            @Override
-            public String toString() {
-                return "CpPatch/index="+index+",placeholder="+placeholder+",value="+value;
-            }
-        }
-    }
-}
diff a/src/java.base/share/classes/java/lang/invoke/IndirectVarHandle.java b/src/java.base/share/classes/java/lang/invoke/IndirectVarHandle.java
--- a/src/java.base/share/classes/java/lang/invoke/IndirectVarHandle.java
+++ b/src/java.base/share/classes/java/lang/invoke/IndirectVarHandle.java
@@ -84,10 +84,14 @@
     @Override
     VarHandle asDirect() {
         return directTarget;
     }
 
+    VarHandle target() {
+        return target;
+    }
+
     @Override
     @ForceInline
     MethodHandle getMethodHandle(int mode) {
         MethodHandle handle = handleMap[mode];
         if (handle == null) {
diff a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java
--- /dev/null
+++ b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang.invoke;
+
+/**
+ * Base class for memory access var handle implementations.
+ */
+abstract class MemoryAccessVarHandleBase extends VarHandle {
+
+    /** endianness **/
+    final boolean be;
+
+    /** access size (in bytes, computed from var handle carrier type) **/
+    final long length;
+
+    /** access offset (in bytes); must be compatible with {@code alignmentMask} **/
+    final long offset;
+
+    /** alignment constraint (in bytes, expressed as a bit mask) **/
+    final long alignmentMask;
+
+    MemoryAccessVarHandleBase(VarForm form, boolean be, long length, long offset, long alignmentMask) {
+        super(form);
+        this.be = be;
+        this.length = length;
+        this.offset = offset;
+        this.alignmentMask = alignmentMask;
+    }
+
+    static IllegalStateException newIllegalStateExceptionForMisalignedAccess(long address) {
+        return new IllegalStateException("Misaligned access at address: " + address);
+    }
+
+    /**
+     * Strides used for multi-dimensional access; each stride must be compatible with {@code alignmentMask}.
+     */
+    abstract long[] strides();
+
+    abstract Class<?> carrier();
+}
diff a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java
--- /dev/null
+++ b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java
@@ -0,0 +1,525 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang.invoke;
+
+import jdk.internal.access.foreign.MemoryAddressProxy;
+import jdk.internal.misc.Unsafe;
+import jdk.internal.org.objectweb.asm.ClassReader;
+import jdk.internal.org.objectweb.asm.ClassWriter;
+import jdk.internal.org.objectweb.asm.MethodVisitor;
+import jdk.internal.org.objectweb.asm.Opcodes;
+import jdk.internal.org.objectweb.asm.Type;
+import jdk.internal.org.objectweb.asm.util.TraceClassVisitor;
+import jdk.internal.vm.annotation.ForceInline;
+import sun.security.action.GetBooleanAction;
+import sun.security.action.GetPropertyAction;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+
+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_FINAL;
+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PRIVATE;
+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;
+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_STATIC;
+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_SUPER;
+import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;
+import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;
+import static jdk.internal.org.objectweb.asm.Opcodes.BIPUSH;
+import static jdk.internal.org.objectweb.asm.Opcodes.CHECKCAST;
+import static jdk.internal.org.objectweb.asm.Opcodes.GETFIELD;
+import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_0;
+import static jdk.internal.org.objectweb.asm.Opcodes.ILOAD;
+import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;
+import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESTATIC;
+import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
+import static jdk.internal.org.objectweb.asm.Opcodes.LALOAD;
+import static jdk.internal.org.objectweb.asm.Opcodes.LASTORE;
+import static jdk.internal.org.objectweb.asm.Opcodes.LLOAD;
+import static jdk.internal.org.objectweb.asm.Opcodes.NEWARRAY;
+import static jdk.internal.org.objectweb.asm.Opcodes.PUTFIELD;
+import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;
+import static jdk.internal.org.objectweb.asm.Opcodes.DUP;
+import static jdk.internal.org.objectweb.asm.Opcodes.SIPUSH;
+import static jdk.internal.org.objectweb.asm.Opcodes.T_LONG;
+
+class MemoryAccessVarHandleGenerator {
+    private static final String DEBUG_DUMP_CLASSES_DIR_PROPERTY = "jdk.internal.foreign.ClassGenerator.DEBUG_DUMP_CLASSES_DIR";
+
+    private static final boolean DEBUG =
+        GetBooleanAction.privilegedGetProperty("jdk.internal.foreign.ClassGenerator.DEBUG");
+
+    private static final Class<?> BASE_CLASS = MemoryAccessVarHandleBase.class;
+
+    private static final HashMap<Class<?>, Class<?>> helperClassCache;
+
+    private final static MethodType OFFSET_OP_TYPE;
+
+    private final static MethodHandle ADD_OFFSETS_HANDLE;
+    private final static MethodHandle MUL_OFFSETS_HANDLE;
+
+    static {
+        helperClassCache = new HashMap<>();
+        helperClassCache.put(byte.class, MemoryAccessVarHandleByteHelper.class);
+        helperClassCache.put(short.class, MemoryAccessVarHandleShortHelper.class);
+        helperClassCache.put(char.class, MemoryAccessVarHandleCharHelper.class);
+        helperClassCache.put(int.class, MemoryAccessVarHandleIntHelper.class);
+        helperClassCache.put(long.class, MemoryAccessVarHandleLongHelper.class);
+        helperClassCache.put(float.class, MemoryAccessVarHandleFloatHelper.class);
+        helperClassCache.put(double.class, MemoryAccessVarHandleDoubleHelper.class);
+
+        OFFSET_OP_TYPE = MethodType.methodType(long.class, long.class, long.class, MemoryAddressProxy.class);
+
+        try {
+            ADD_OFFSETS_HANDLE = MethodHandles.Lookup.IMPL_LOOKUP.findStatic(MemoryAddressProxy.class, "addOffsets", OFFSET_OP_TYPE);
+            MUL_OFFSETS_HANDLE = MethodHandles.Lookup.IMPL_LOOKUP.findStatic(MemoryAddressProxy.class, "multiplyOffsets", OFFSET_OP_TYPE);
+        } catch (Throwable ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
+
+    private static final File DEBUG_DUMP_CLASSES_DIR;
+
+    static {
+        String path = GetPropertyAction.privilegedGetProperty(DEBUG_DUMP_CLASSES_DIR_PROPERTY);
+        if (path == null) {
+            DEBUG_DUMP_CLASSES_DIR = null;
+        } else {
+            DEBUG_DUMP_CLASSES_DIR = new File(path);
+        }
+    }
+
+    private static final Unsafe U = Unsafe.getUnsafe();
+
+    private final String implClassName;
+    private final int dimensions;
+    private final Class<?> carrier;
+    private final Class<?> helperClass;
+    private final VarForm form;
+
+    MemoryAccessVarHandleGenerator(Class<?> carrier, int dims) {
+        this.dimensions = dims;
+        this.carrier = carrier;
+        Class<?>[] components = new Class<?>[dimensions];
+        Arrays.fill(components, long.class);
+        this.form = new VarForm(BASE_CLASS, MemoryAddressProxy.class, carrier, components);
+        this.helperClass = helperClassCache.get(carrier);
+        this.implClassName = helperClass.getName().replace('.', '/') + dimensions;
+    }
+
+    /*
+     * Generate a VarHandle memory access factory.
+     * The factory has type (ZJJ[J)VarHandle.
+     */
+    MethodHandle generateHandleFactory() {
+        Class<?> implCls = generateClass();
+        try {
+            Class<?>[] components = new Class<?>[dimensions];
+            Arrays.fill(components, long.class);
+
+            VarForm form = new VarForm(implCls, MemoryAddressProxy.class, carrier, components);
+
+            MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);
+            MethodHandle constr = MethodHandles.Lookup.IMPL_LOOKUP.findConstructor(implCls, constrType);
+            constr = MethodHandles.insertArguments(constr, 0, form);
+            return constr;
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+
+    /*
+     * Generate a specialized VarHandle class for given carrier
+     * and access coordinates.
+     */
+    Class<?> generateClass() {
+        BinderClassWriter cw = new BinderClassWriter();
+
+        if (DEBUG) {
+            System.out.println("Generating header implementation class");
+        }
+
+        cw.visit(52, ACC_PUBLIC | ACC_SUPER, implClassName, null, Type.getInternalName(BASE_CLASS), null);
+
+        //add dimension fields
+        for (int i = 0; i < dimensions; i++) {
+            cw.visitField(ACC_PRIVATE | ACC_FINAL, "dim" + i, "J", null, null);
+        }
+
+        addConstructor(cw);
+
+        addAccessModeTypeMethod(cw);
+
+        addStridesAccessor(cw);
+
+        addCarrierAccessor(cw);
+
+        for (VarHandle.AccessMode mode : VarHandle.AccessMode.values()) {
+            addAccessModeMethodIfNeeded(mode, cw);
+        }
+
+
+        cw.visitEnd();
+        byte[] classBytes = cw.toByteArray();
+        return defineClass(cw, classBytes);
+    }
+
+    void addConstructor(BinderClassWriter cw) {
+        MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);
+        MethodVisitor mv = cw.visitMethod(0, "<init>", constrType.toMethodDescriptorString(), null, null);
+        mv.visitCode();
+        //super call
+        mv.visitVarInsn(ALOAD, 0);
+        mv.visitVarInsn(ALOAD, 1);
+        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(VarForm.class));
+        mv.visitVarInsn(ILOAD, 2);
+        mv.visitVarInsn(LLOAD, 3);
+        mv.visitVarInsn(LLOAD, 5);
+        mv.visitVarInsn(LLOAD, 7);
+        mv.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(BASE_CLASS), "<init>",
+                MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class).toMethodDescriptorString(), false);
+        //init dimensions
+        for (int i = 0 ; i < dimensions ; i++) {
+            mv.visitVarInsn(ALOAD, 0);
+            mv.visitVarInsn(ALOAD, 9);
+            mv.visitLdcInsn(i);
+            mv.visitInsn(LALOAD);
+            mv.visitFieldInsn(PUTFIELD, implClassName, "dim" + i, "J");
+        }
+        mv.visitInsn(RETURN);
+        mv.visitMaxs(0, 0);
+        mv.visitEnd();
+    }
+
+    void addAccessModeTypeMethod(BinderClassWriter cw) {
+        MethodType modeMethType = MethodType.methodType(MethodType.class, VarHandle.AccessMode.class);
+        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "accessModeTypeUncached", modeMethType.toMethodDescriptorString(), null, null);
+        mv.visitCode();
+        mv.visitVarInsn(ALOAD, 1);
+        mv.visitFieldInsn(GETFIELD, Type.getInternalName(VarHandle.AccessMode.class), "at", Type.getDescriptor(VarHandle.AccessType.class));
+        mv.visitLdcInsn(cw.makeConstantPoolPatch(MemoryAddressProxy.class));
+        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
+        mv.visitLdcInsn(cw.makeConstantPoolPatch(carrier));
+        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
+
+        Class<?>[] dims = new Class<?>[dimensions];
+        Arrays.fill(dims, long.class);
+        mv.visitLdcInsn(cw.makeConstantPoolPatch(dims));
+        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class[].class));
+
+        mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(VarHandle.AccessType.class),
+                "accessModeType", MethodType.methodType(MethodType.class, Class.class, Class.class, Class[].class).toMethodDescriptorString(), false);
+
+        mv.visitInsn(ARETURN);
+
+        mv.visitMaxs(0, 0);
+        mv.visitEnd();
+    }
+
+    void addAccessModeMethodIfNeeded(VarHandle.AccessMode mode, BinderClassWriter cw) {
+        String methName = mode.methodName();
+        MethodType methType = form.getMethodType(mode.at.ordinal())
+                .insertParameterTypes(0, VarHandle.class);
+
+        try {
+            MethodType helperType = methType.insertParameterTypes(2, long.class);
+            if (dimensions > 0) {
+                helperType = helperType.dropParameterTypes(3, 3 + dimensions);
+            }
+            //try to resolve...
+            String helperMethodName = methName + "0";
+            MethodHandles.Lookup.IMPL_LOOKUP
+                    .findStatic(helperClass,
+                            helperMethodName,
+                            helperType);
+
+
+            MethodVisitor mv = cw.visitMethod(ACC_STATIC, methName, methType.toMethodDescriptorString(), null, null);
+            mv.visitAnnotation(Type.getDescriptor(ForceInline.class), true);
+            mv.visitCode();
+
+            mv.visitVarInsn(ALOAD, 0); // handle impl
+            mv.visitVarInsn(ALOAD, 1); // receiver
+
+            // offset calculation
+            int slot = 2;
+            mv.visitVarInsn(ALOAD, 0); // load recv
+            mv.visitTypeInsn(CHECKCAST, Type.getInternalName(BASE_CLASS));
+            mv.visitFieldInsn(GETFIELD, Type.getInternalName(BASE_CLASS), "offset", "J");
+            for (int i = 0 ; i < dimensions ; i++) {
+                // load ADD MH
+                mv.visitLdcInsn(cw.makeConstantPoolPatch(ADD_OFFSETS_HANDLE));
+                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
+
+                //fixup stack so that ADD MH ends up bottom
+                mv.visitInsn(Opcodes.DUP_X2);
+                mv.visitInsn(Opcodes.POP);
+
+                // load MUL MH
+                mv.visitLdcInsn(cw.makeConstantPoolPatch(MUL_OFFSETS_HANDLE));
+                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
+
+                mv.visitVarInsn(ALOAD, 0); // load recv
+                mv.visitTypeInsn(CHECKCAST, implClassName);
+                mv.visitFieldInsn(GETFIELD, implClassName, "dim" + i, "J");
+                mv.visitVarInsn(LLOAD, slot);
+
+                mv.visitVarInsn(ALOAD, 1); // receiver
+                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MemoryAddressProxy.class));
+
+                //MUL
+                mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(MethodHandle.class), "invokeExact",
+                        OFFSET_OP_TYPE.toMethodDescriptorString(), false);
+
+                mv.visitVarInsn(ALOAD, 1); // receiver
+                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MemoryAddressProxy.class));
+
+                //ADD
+                mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(MethodHandle.class), "invokeExact",
+                        OFFSET_OP_TYPE.toMethodDescriptorString(), false);
+                slot += 2;
+            }
+
+            for (int i = 2 + dimensions; i < methType.parameterCount() ; i++) {
+                Class<?> param = methType.parameterType(i);
+                mv.visitVarInsn(loadInsn(param), slot); // load index
+                slot += getSlotsForType(param);
+            }
+
+            //call helper
+            mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(helperClass), helperMethodName,
+                    helperType.toMethodDescriptorString(), false);
+
+            mv.visitInsn(returnInsn(helperType.returnType()));
+
+            mv.visitMaxs(0, 0);
+            mv.visitEnd();
+        } catch (ReflectiveOperationException ex) {
+            //not found, skip
+        }
+    }
+
+    void addStridesAccessor(BinderClassWriter cw) {
+        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "strides", "()[J", null, null);
+        mv.visitCode();
+        iConstInsn(mv, dimensions);
+        mv.visitIntInsn(NEWARRAY, T_LONG);
+
+        for (int i = 0 ; i < dimensions ; i++) {
+            mv.visitInsn(DUP);
+            iConstInsn(mv, i);
+            mv.visitVarInsn(ALOAD, 0);
+            mv.visitFieldInsn(GETFIELD, implClassName, "dim" + i, "J");
+            mv.visitInsn(LASTORE);
+        }
+
+        mv.visitInsn(ARETURN);
+        mv.visitMaxs(0, 0);
+        mv.visitEnd();
+    }
+
+    void addCarrierAccessor(BinderClassWriter cw) {
+        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "carrier", "()Ljava/lang/Class;", null, null);
+        mv.visitCode();
+        mv.visitLdcInsn(cw.makeConstantPoolPatch(carrier));
+        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
+        mv.visitInsn(ARETURN);
+        mv.visitMaxs(0, 0);
+        mv.visitEnd();
+    }
+
+    //where
+    private Class<?> defineClass(BinderClassWriter cw, byte[] classBytes) {
+        try {
+            if (DEBUG_DUMP_CLASSES_DIR != null) {
+                debugWriteClassToFile(classBytes);
+            }
+            Object[] patches = cw.resolvePatches(classBytes);
+            Class<?> c = U.defineAnonymousClass(BASE_CLASS, classBytes, patches);
+            return c;
+        } catch (Throwable e) {
+            debugPrintClass(classBytes);
+            throw e;
+        }
+    }
+
+    // shared code generation helpers
+
+    private static int getSlotsForType(Class<?> c) {
+        if (c == long.class || c == double.class) {
+            return 2;
+        }
+        return 1;
+    }
+
+    /**
+     * Emits an actual return instruction conforming to the given return type.
+     */
+    private int returnInsn(Class<?> type) {
+        return switch (LambdaForm.BasicType.basicType(type)) {
+            case I_TYPE -> Opcodes.IRETURN;
+            case J_TYPE -> Opcodes.LRETURN;
+            case F_TYPE -> Opcodes.FRETURN;
+            case D_TYPE -> Opcodes.DRETURN;
+            case L_TYPE -> Opcodes.ARETURN;
+            case V_TYPE -> RETURN;
+        };
+    }
+
+    private int loadInsn(Class<?> type) {
+        return switch (LambdaForm.BasicType.basicType(type)) {
+            case I_TYPE -> Opcodes.ILOAD;
+            case J_TYPE -> LLOAD;
+            case F_TYPE -> Opcodes.FLOAD;
+            case D_TYPE -> Opcodes.DLOAD;
+            case L_TYPE -> Opcodes.ALOAD;
+            case V_TYPE -> throw new IllegalStateException("Cannot load void");
+        };
+    }
+
+    private static void iConstInsn(MethodVisitor mv, int i) {
+        switch (i) {
+            case -1, 0, 1, 2, 3, 4, 5:
+                mv.visitInsn(ICONST_0 + i);
+                break;
+            default:
+                if(i >= Byte.MIN_VALUE && i <= Byte.MAX_VALUE) {
+                    mv.visitIntInsn(BIPUSH, i);
+                } else if (i >= Short.MIN_VALUE && i <= Short.MAX_VALUE) {
+                    mv.visitIntInsn(SIPUSH, i);
+                } else {
+                    mv.visitLdcInsn(i);
+                }
+        }
+    }
+
+    // debug helpers
+
+    private static String debugPrintClass(byte[] classFile) {
+        ClassReader cr = new ClassReader(classFile);
+        StringWriter sw = new StringWriter();
+        cr.accept(new TraceClassVisitor(new PrintWriter(sw)), 0);
+        return sw.toString();
+    }
+
+    private void debugWriteClassToFile(byte[] classFile) {
+        File file = new File(DEBUG_DUMP_CLASSES_DIR, implClassName + ".class");
+
+        if (DEBUG) {
+            System.err.println("Dumping class " + implClassName + " to " + file);
+        }
+
+        try {
+            debugWriteDataToFile(classFile, file);
+        } catch (Exception e) {
+            throw new RuntimeException("Failed to write class " + implClassName + " to file " + file);
+        }
+    }
+
+    private void debugWriteDataToFile(byte[] data, File file) {
+        if (file.exists()) {
+            file.delete();
+        }
+        if (file.exists()) {
+            throw new RuntimeException("Failed to remove pre-existing file " + file);
+        }
+
+        File parent = file.getParentFile();
+        if (!parent.exists()) {
+            parent.mkdirs();
+        }
+        if (!parent.exists()) {
+            throw new RuntimeException("Failed to create " + parent);
+        }
+        if (!parent.isDirectory()) {
+            throw new RuntimeException(parent + " is not a directory");
+        }
+
+        try (FileOutputStream fos = new FileOutputStream(file)) {
+            fos.write(data);
+        } catch (IOException e) {
+            throw new RuntimeException("Failed to write class " + implClassName + " to file " + file);
+        }
+    }
+
+    static class BinderClassWriter extends ClassWriter {
+
+        private final ArrayList<ConstantPoolPatch> cpPatches = new ArrayList<>();
+        private int curUniquePatchIndex = 0;
+
+        BinderClassWriter() {
+            super(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
+        }
+
+        public String makeConstantPoolPatch(Object o) {
+            int myUniqueIndex = curUniquePatchIndex++;
+            String cpPlaceholder = "CONSTANT_PLACEHOLDER_" + myUniqueIndex;
+            int index = newConst(cpPlaceholder);
+            cpPatches.add(new ConstantPoolPatch(index, cpPlaceholder, o));
+            return cpPlaceholder;
+        }
+
+        public Object[] resolvePatches(byte[] classFile) {
+            if (cpPatches.isEmpty()) {
+                return null;
+            }
+
+            int size = ((classFile[8] & 0xFF) << 8) | (classFile[9] & 0xFF);
+
+            Object[] patches = new Object[size];
+            for (ConstantPoolPatch p : cpPatches) {
+                if (p.index >= size) {
+                    throw new InternalError("Failed to resolve constant pool patch entries");
+                }
+                patches[p.index] = p.value;
+            }
+
+            return patches;
+        }
+
+        static class ConstantPoolPatch {
+            final int index;
+            final String placeholder;
+            final Object value;
+
+            ConstantPoolPatch(int index, String placeholder, Object value) {
+                this.index = index;
+                this.placeholder = placeholder;
+                this.value = value;
+            }
+
+            @Override
+            public String toString() {
+                return "CpPatch/index="+index+",placeholder="+placeholder+",value="+value;
+            }
+        }
+    }
+}
diff a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
@@ -1790,46 +1790,64 @@
                         .generateInvokersHolderClassBytes(className,
                                 invokerMethodTypes, callSiteMethodTypes);
             }
 
             @Override
-            public VarHandle memoryAddressViewVarHandle(Class<?> carrier, long alignmentMask,
-                                                        ByteOrder order, long offset, long[] strides) {
+            public VarHandle memoryAccessVarHandle(Class<?> carrier, long alignmentMask,
+                                                   ByteOrder order, long offset, long[] strides) {
                 return VarHandles.makeMemoryAddressViewHandle(carrier, alignmentMask, order, offset, strides);
             }
 
             @Override
             public Class<?> memoryAddressCarrier(VarHandle handle) {
-                return checkMemAccessHandle(handle).carrier();
+                return checkMemoryAccessHandle(handle).carrier();
             }
 
             @Override
             public long memoryAddressAlignmentMask(VarHandle handle) {
-                return checkMemAccessHandle(handle).alignmentMask;
+                return checkMemoryAccessHandle(handle).alignmentMask;
             }
 
             @Override
             public ByteOrder memoryAddressByteOrder(VarHandle handle) {
-                return checkMemAccessHandle(handle).be ?
+                return checkMemoryAccessHandle(handle).be ?
                         ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
             }
 
             @Override
             public long memoryAddressOffset(VarHandle handle) {
-                return checkMemAccessHandle(handle).offset;
+                return checkMemoryAccessHandle(handle).offset;
             }
 
             @Override
             public long[] memoryAddressStrides(VarHandle handle) {
-                return checkMemAccessHandle(handle).strides();
+                return checkMemoryAccessHandle(handle).strides();
             }
 
-            private VarHandleMemoryAddressBase checkMemAccessHandle(VarHandle handle) {
-                if (!(handle.asDirect() instanceof VarHandleMemoryAddressBase)) {
+            @Override
+            public boolean isMemoryAccessVarHandle(VarHandle handle) {
+                return asMemoryAccessVarHandle(handle) != null;
+            }
+
+            private MemoryAccessVarHandleBase asMemoryAccessVarHandle(VarHandle handle) {
+                if (handle instanceof MemoryAccessVarHandleBase) {
+                    return (MemoryAccessVarHandleBase)handle;
+                } else if (handle.target() instanceof MemoryAccessVarHandleBase) {
+                    // skip first adaptation, since we have to step over MemoryAddressProxy
+                    // see JDK-8237349
+                    return (MemoryAccessVarHandleBase)handle.target();
+                } else {
+                    return null;
+                }
+            }
+
+            private MemoryAccessVarHandleBase checkMemoryAccessHandle(VarHandle handle) {
+                MemoryAccessVarHandleBase base = asMemoryAccessVarHandle(handle);
+                if (base == null) {
                     throw new IllegalArgumentException("Not a memory access varhandle: " + handle);
                 }
-                return (VarHandleMemoryAddressBase) handle.asDirect();
+                return base;
             }
         });
     }
 
     /** Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore(). */
diff a/src/java.base/share/classes/java/lang/invoke/MethodHandles.java b/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
@@ -5039,19 +5039,20 @@
      * available starting at {@code pos}.
      */
     public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {
         Objects.nonNull(target);
         Objects.nonNull(filters);
-        if (filters.length == 0) return target;
 
         List<Class<?>> targetCoordinates = target.coordinateTypes();
         if (pos < 0 || pos >= targetCoordinates.size()) {
             throw newIllegalArgumentException("Invalid position " + pos + " for coordinate types", targetCoordinates);
         } else if (pos + filters.length > targetCoordinates.size()) {
             throw new IllegalArgumentException("Too many filters");
         }
 
+        if (filters.length == 0) return target;
+
         List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
         for (int i = 0 ; i < filters.length ; i++) {
             noCheckedExceptions(filters[i]);
             MethodType filterType = filters[i].type();
             if (filterType.parameterCount() != 1) {
@@ -5093,19 +5094,20 @@
      * of the target var handle.
      */
     public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {
         Objects.nonNull(target);
         Objects.nonNull(values);
-        if (values.length == 0) return target;
 
         List<Class<?>> targetCoordinates = target.coordinateTypes();
         if (pos < 0 || pos >= targetCoordinates.size()) {
             throw newIllegalArgumentException("Invalid position " + pos + " for coordinate types", targetCoordinates);
         } else if (pos + values.length > targetCoordinates.size()) {
             throw new IllegalArgumentException("Too many values");
         }
 
+        if (values.length == 0) return target;
+
         List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
         for (int i = 0 ; i < values.length ; i++) {
             Class<?> pt = newCoordinates.get(pos);
             if (pt.isPrimitive()) {
                 Wrapper w = Wrapper.forPrimitiveType(pt);
@@ -5254,18 +5256,55 @@
         } else if (filter.type().returnType() != targetCoordinates.get(pos)) {
             throw newIllegalArgumentException("Invalid filter type " + filter.type() + " for coordinate type " + targetCoordinates.get(pos));
         }
 
         List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
-        for (Class<?> arg : filter.type().parameterList()) {
-            newCoordinates.add(pos, arg);
-        }
+        newCoordinates.remove(pos);
+        newCoordinates.addAll(pos, filter.type().parameterList());
 
         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class<?>[0]),
                 (mode, modeHandle) -> MethodHandles.collectArguments(modeHandle, 1 + pos, filter));
     }
 
+    /**
+     * Returns a var handle which will discard some dummy coordinates before delegating to the
+     * target var handle. As a consequence, the resulting var handle will feature more
+     * coordinate types than the target var handle.
+     * <p>
+     * The {@code pos} argument may range between zero and <i>N</i>, where <i>N</i> is the arity of the
+     * target var handle's coordinate types. If {@code pos} is zero, the dummy coordinates will precede
+     * the target's real arguments; if {@code pos} is <i>N</i> they will come after.
+     * <p>
+     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
+     * atomic access guarantees as those featured by the target var handle.
+     *
+     * @param target the var handle to invoke after the dummy coordinates are dropped
+     * @param pos position of first coordinate to drop (zero for the leftmost)
+     * @param valueTypes the type(s) of the coordinate(s) to drop
+     * @return an adapter var handle which drops some dummy coordinates,
+     *         before calling the target var handle
+     * @throws NullPointerException if either {@code target}, {@code valueTypes} are {@code == null}.
+     * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive.
+     */
+    public static VarHandle dropCoordinates(VarHandle target, int pos, Class<?>... valueTypes) {
+        Objects.nonNull(target);
+        Objects.nonNull(valueTypes);
+
+        List<Class<?>> targetCoordinates = target.coordinateTypes();
+        if (pos < 0 || pos > targetCoordinates.size()) {
+            throw newIllegalArgumentException("Invalid position " + pos + " for coordinate types", targetCoordinates);
+        }
+
+        if (valueTypes.length == 0) return target;
+
+        List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
+        newCoordinates.addAll(pos, List.of(valueTypes));
+
+        return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class<?>[0]),
+                (mode, modeHandle) -> MethodHandles.dropArguments(modeHandle, 1 + pos, valueTypes));
+    }
+
     private static void noCheckedExceptions(MethodHandle handle) {
         if (handle instanceof DirectMethodHandle) {
             DirectMethodHandle directHandle = (DirectMethodHandle)handle;
             MethodHandleInfo info = Lookup.IMPL_LOOKUP.revealDirect(directHandle);
             Class<?>[] exceptionTypes = switch (info.getReferenceKind()) {
diff a/src/java.base/share/classes/java/lang/invoke/VarHandle.java b/src/java.base/share/classes/java/lang/invoke/VarHandle.java
--- a/src/java.base/share/classes/java/lang/invoke/VarHandle.java
+++ b/src/java.base/share/classes/java/lang/invoke/VarHandle.java
@@ -461,10 +461,12 @@
 
     VarHandle asDirect() {
         return this;
     }
 
+    VarHandle target() { return null; }
+
     // Plain accessors
 
     /**
      * Returns the value of a variable, with memory semantics of reading as
      * if the variable was declared non-{@code volatile}.  Commonly referred to
diff a/src/java.base/share/classes/java/lang/invoke/VarHandleMemoryAddressBase.java b/src/java.base/share/classes/java/lang/invoke/VarHandleMemoryAddressBase.java
--- a/src/java.base/share/classes/java/lang/invoke/VarHandleMemoryAddressBase.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package java.lang.invoke;
-
-/**
- * Base class for memory access var handle implementations.
- */
-abstract class VarHandleMemoryAddressBase extends VarHandle {
-
-    /** endianness **/
-    final boolean be;
-
-    /** access size (in bytes, computed from var handle carrier type) **/
-    final long length;
-
-    /** access offset (in bytes); must be compatible with {@code alignmentMask} **/
-    final long offset;
-
-    /** alignment constraint (in bytes, expressed as a bit mask) **/
-    final long alignmentMask;
-
-    VarHandleMemoryAddressBase(VarForm form, boolean be, long length, long offset, long alignmentMask) {
-        super(form);
-        this.be = be;
-        this.length = length;
-        this.offset = offset;
-        this.alignmentMask = alignmentMask;
-    }
-
-    static IllegalStateException newIllegalStateExceptionForMisalignedAccess(long address) {
-        return new IllegalStateException("Misaligned access at address: " + address);
-    }
-
-    /**
-     * Strides used for multi-dimensional access; each stride must be compatible with {@code alignmentMask}.
-     */
-    abstract long[] strides();
-
-    abstract Class<?> carrier();
-}
diff a/src/java.base/share/classes/java/lang/invoke/VarHandles.java b/src/java.base/share/classes/java/lang/invoke/VarHandles.java
--- a/src/java.base/share/classes/java/lang/invoke/VarHandles.java
+++ b/src/java.base/share/classes/java/lang/invoke/VarHandles.java
@@ -318,11 +318,11 @@
         long size = Wrapper.forPrimitiveType(carrier).bitWidth() / 8;
         boolean be = byteOrder == ByteOrder.BIG_ENDIAN;
 
         Map<Integer, MethodHandle> carrierFactory = ADDRESS_FACTORIES.get(carrier);
         MethodHandle fac = carrierFactory.computeIfAbsent(strides.length,
-                dims -> new AddressVarHandleGenerator(carrier, dims)
+                dims -> new MemoryAccessVarHandleGenerator(carrier, dims)
                             .generateHandleFactory());
 
         try {
             return maybeAdapt((VarHandle)fac.invoke(be, size, offset, alignmentMask, strides));
         } catch (Throwable ex) {
diff a/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template b/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template
--- /dev/null
+++ b/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template
@@ -0,0 +1,543 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package java.lang.invoke;
+
+import jdk.internal.access.foreign.MemoryAddressProxy;
+import jdk.internal.vm.annotation.ForceInline;
+
+import java.util.Objects;
+
+import static java.lang.invoke.MethodHandleStatics.UNSAFE;
+
+#warn
+
+final class MemoryAccessVarHandle$Type$Helper {
+
+    static final boolean BE = UNSAFE.isBigEndian();
+
+    static final int VM_ALIGN = $BoxType$.BYTES - 1;
+
+#if[floatingPoint]
+    @ForceInline
+    static $rawType$ convEndian(boolean big, $type$ v) {
+        $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
+        return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
+    }
+
+    @ForceInline
+    static $type$ convEndian(boolean big, $rawType$ rv) {
+        rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);
+        return $Type$.$rawType$BitsTo$Type$(rv);
+    }
+#else[floatingPoint]
+#if[byte]
+    @ForceInline
+    static $type$ convEndian(boolean big, $type$ n) {
+        return n;
+    }
+#else[byte]
+    @ForceInline
+    static $type$ convEndian(boolean big, $type$ n) {
+        return big == BE ? n : $BoxType$.reverseBytes(n);
+    }
+#end[byte]
+#end[floatingPoint]
+
+    @ForceInline
+    static MemoryAddressProxy checkAddress(Object obb, long offset, long length, boolean ro) {
+        MemoryAddressProxy oo = (MemoryAddressProxy)Objects.requireNonNull(obb);
+        oo.checkAccess(offset, length, ro);
+        return oo;
+    }
+    
+    @ForceInline
+    static long offset(MemoryAddressProxy bb, long offset, long alignmentMask) {
+        long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);
+        if ((address & VM_ALIGN) != 0) {
+            throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
+        }
+        return address;
+    }
+
+    @ForceInline
+    static long offsetNoVMAlignCheck(MemoryAddressProxy bb, long offset, long alignmentMask) {
+        long base = bb.unsafeGetOffset();
+        long address = base + offset;
+        //note: the offset portion has already been aligned-checked, by construction
+        if ((base & alignmentMask) != 0) {
+            throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
+        }
+        return address;
+    }
+    
+    @ForceInline
+    static $type$ get0(VarHandle ob, Object obb, long base) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+#if[floatingPoint]
+        $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
+                bb.unsafeGetBase(),
+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                handle.be);
+        return $Type$.$rawType$BitsTo$Type$(rawValue);
+#else[floatingPoint]
+#if[byte]
+        return UNSAFE.get$Type$(
+                bb.unsafeGetBase(),
+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask));
+#else[byte]
+        return UNSAFE.get$Type$Unaligned(
+                bb.unsafeGetBase(),
+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                handle.be);
+#end[byte]
+#end[floatingPoint]
+    }
+
+    @ForceInline
+    static void set0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+#if[floatingPoint]
+        UNSAFE.put$RawType$Unaligned(
+                bb.unsafeGetBase(),
+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                $Type$.$type$ToRaw$RawType$Bits(value),
+                handle.be);
+#else[floatingPoint]
+#if[byte]
+        UNSAFE.put$Type$(
+                bb.unsafeGetBase(),
+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                value);
+#else[byte]
+        UNSAFE.put$Type$Unaligned(
+                bb.unsafeGetBase(),
+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                value,
+                handle.be);
+#end[byte]
+#end[floatingPoint]
+    }
+
+    @ForceInline
+    static $type$ getVolatile0(VarHandle ob, Object obb, long base) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+        return convEndian(handle.be,
+                          UNSAFE.get$RawType$Volatile(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask)));
+    }
+
+    @ForceInline
+    static void setVolatile0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        UNSAFE.put$RawType$Volatile(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, value));
+    }
+
+    @ForceInline
+    static $type$ getAcquire0(VarHandle ob, Object obb, long base) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+        return convEndian(handle.be,
+                          UNSAFE.get$RawType$Acquire(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask)));
+    }
+
+    @ForceInline
+    static void setRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        UNSAFE.put$RawType$Release(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, value));
+    }
+
+    @ForceInline
+    static $type$ getOpaque0(VarHandle ob, Object obb, long base) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+        return convEndian(handle.be,
+                          UNSAFE.get$RawType$Opaque(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask)));
+    }
+
+    @ForceInline
+    static void setOpaque0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        UNSAFE.put$RawType$Opaque(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, value));
+    }
+#if[CAS]
+
+    @ForceInline
+    static boolean compareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return UNSAFE.compareAndSet$RawType$(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, expected), convEndian(handle.be, value));
+    }
+
+    @ForceInline
+    static $type$ compareAndExchange0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return convEndian(handle.be,
+                          UNSAFE.compareAndExchange$RawType$(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask),
+                                  convEndian(handle.be, expected), convEndian(handle.be, value)));
+    }
+
+    @ForceInline
+    static $type$ compareAndExchangeAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return convEndian(handle.be,
+                          UNSAFE.compareAndExchange$RawType$Acquire(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask),
+                                  convEndian(handle.be, expected), convEndian(handle.be, value)));
+    }
+
+    @ForceInline
+    static $type$ compareAndExchangeRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return convEndian(handle.be,
+                          UNSAFE.compareAndExchange$RawType$Release(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask),
+                                  convEndian(handle.be, expected), convEndian(handle.be, value)));
+    }
+
+    @ForceInline
+    static boolean weakCompareAndSetPlain0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return UNSAFE.weakCompareAndSet$RawType$Plain(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, expected), convEndian(handle.be, value));
+    }
+
+    @ForceInline
+    static boolean weakCompareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return UNSAFE.weakCompareAndSet$RawType$(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, expected), convEndian(handle.be, value));
+    }
+
+    @ForceInline
+    static boolean weakCompareAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return UNSAFE.weakCompareAndSet$RawType$Acquire(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, expected), convEndian(handle.be, value));
+    }
+
+    @ForceInline
+    static boolean weakCompareAndSetRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return UNSAFE.weakCompareAndSet$RawType$Release(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, expected), convEndian(handle.be, value));
+    }
+
+    @ForceInline
+    static $type$ getAndSet0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return convEndian(handle.be,
+                          UNSAFE.getAndSet$RawType$(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask),
+                                  convEndian(handle.be, value)));
+    }
+
+    @ForceInline
+    static $type$ getAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return convEndian(handle.be,
+                          UNSAFE.getAndSet$RawType$Acquire(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask),
+                                  convEndian(handle.be, value)));
+    }
+
+    @ForceInline
+    static $type$ getAndSetRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return convEndian(handle.be,
+                          UNSAFE.getAndSet$RawType$Release(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask),
+                                  convEndian(handle.be, value)));
+    }
+#end[CAS]
+#if[AtomicAdd]
+
+    @ForceInline
+    static $type$ getAndAdd0(VarHandle ob, Object obb, long base, $type$ delta) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndAdd$RawType$(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    delta);
+        } else {
+            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndAddAcquire0(VarHandle ob, Object obb, long base, $type$ delta) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndAdd$RawType$Acquire(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    delta);
+        } else {
+            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndAddRelease0(VarHandle ob, Object obb, long base, $type$ delta) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndAdd$RawType$Release(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    delta);
+        } else {
+            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndAddConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ delta) {
+        $type$ nativeExpectedValue, expectedValue;
+        Object base = bb.unsafeGetBase();
+        do {
+            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
+            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
+        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
+                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
+        return expectedValue;
+    }
+#end[AtomicAdd]
+#if[Bitwise]
+
+    @ForceInline
+    static $type$ getAndBitwiseOr0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseOr$RawType$(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseOrRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseOr$RawType$Release(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseOrAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseOr$RawType$Acquire(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseOrConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
+        $type$ nativeExpectedValue, expectedValue;
+        Object base = bb.unsafeGetBase();
+        do {
+            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
+            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
+        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
+                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
+        return expectedValue;
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseAnd0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseAnd$RawType$(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseAndRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseAnd$RawType$Release(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseAndAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseAndConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
+        $type$ nativeExpectedValue, expectedValue;
+        Object base = bb.unsafeGetBase();
+        do {
+            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
+            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
+        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
+                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue & value)));
+        return expectedValue;
+    }
+
+
+    @ForceInline
+    static $type$ getAndBitwiseXor0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseXor$RawType$(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseXorRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseXor$RawType$Release(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseXorAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseXor$RawType$Acquire(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseXorConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
+        $type$ nativeExpectedValue, expectedValue;
+        Object base = bb.unsafeGetBase();
+        do {
+            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
+            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
+        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
+                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
+        return expectedValue;
+    }
+#end[Bitwise]
+}
diff a/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAddressView.java.template b/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAddressView.java.template
--- a/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAddressView.java.template
+++ /dev/null
@@ -1,543 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package java.lang.invoke;
-
-import jdk.internal.access.foreign.MemoryAddressProxy;
-import jdk.internal.vm.annotation.ForceInline;
-
-import java.util.Objects;
-
-import static java.lang.invoke.MethodHandleStatics.UNSAFE;
-
-#warn
-
-final class VarHandleMemoryAddressAs$Type$s {
-
-    static final boolean BE = UNSAFE.isBigEndian();
-
-    static final int VM_ALIGN = $BoxType$.BYTES - 1;
-
-#if[floatingPoint]
-    @ForceInline
-    static $rawType$ convEndian(boolean big, $type$ v) {
-        $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
-        return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
-    }
-
-    @ForceInline
-    static $type$ convEndian(boolean big, $rawType$ rv) {
-        rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);
-        return $Type$.$rawType$BitsTo$Type$(rv);
-    }
-#else[floatingPoint]
-#if[byte]
-    @ForceInline
-    static $type$ convEndian(boolean big, $type$ n) {
-        return n;
-    }
-#else[byte]
-    @ForceInline
-    static $type$ convEndian(boolean big, $type$ n) {
-        return big == BE ? n : $BoxType$.reverseBytes(n);
-    }
-#end[byte]
-#end[floatingPoint]
-
-    @ForceInline
-    static MemoryAddressProxy checkAddress(Object obb, long offset, long length, boolean ro) {
-        MemoryAddressProxy oo = (MemoryAddressProxy)Objects.requireNonNull(obb);
-        oo.checkAccess(offset, length, ro);
-        return oo;
-    }
-    
-    @ForceInline
-    static long offset(MemoryAddressProxy bb, long offset, long alignmentMask) {
-        long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);
-        if ((address & VM_ALIGN) != 0) {
-            throw VarHandleMemoryAddressBase.newIllegalStateExceptionForMisalignedAccess(address);
-        }
-        return address;
-    }
-
-    @ForceInline
-    static long offsetNoVMAlignCheck(MemoryAddressProxy bb, long offset, long alignmentMask) {
-        long base = bb.unsafeGetOffset();
-        long address = base + offset;
-        //note: the offset portion has already been aligned-checked, by construction
-        if ((base & alignmentMask) != 0) {
-            throw VarHandleMemoryAddressBase.newIllegalStateExceptionForMisalignedAccess(address);
-        }
-        return address;
-    }
-    
-    @ForceInline
-    static $type$ get0(VarHandle ob, Object obb, long base) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
-#if[floatingPoint]
-        $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
-                bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
-                handle.be);
-        return $Type$.$rawType$BitsTo$Type$(rawValue);
-#else[floatingPoint]
-#if[byte]
-        return UNSAFE.get$Type$(
-                bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask));
-#else[byte]
-        return UNSAFE.get$Type$Unaligned(
-                bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
-                handle.be);
-#end[byte]
-#end[floatingPoint]
-    }
-
-    @ForceInline
-    static void set0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-#if[floatingPoint]
-        UNSAFE.put$RawType$Unaligned(
-                bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
-                $Type$.$type$ToRaw$RawType$Bits(value),
-                handle.be);
-#else[floatingPoint]
-#if[byte]
-        UNSAFE.put$Type$(
-                bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
-                value);
-#else[byte]
-        UNSAFE.put$Type$Unaligned(
-                bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
-                value,
-                handle.be);
-#end[byte]
-#end[floatingPoint]
-    }
-
-    @ForceInline
-    static $type$ getVolatile0(VarHandle ob, Object obb, long base) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
-        return convEndian(handle.be,
-                          UNSAFE.get$RawType$Volatile(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask)));
-    }
-
-    @ForceInline
-    static void setVolatile0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        UNSAFE.put$RawType$Volatile(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, value));
-    }
-
-    @ForceInline
-    static $type$ getAcquire0(VarHandle ob, Object obb, long base) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
-        return convEndian(handle.be,
-                          UNSAFE.get$RawType$Acquire(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask)));
-    }
-
-    @ForceInline
-    static void setRelease0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        UNSAFE.put$RawType$Release(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, value));
-    }
-
-    @ForceInline
-    static $type$ getOpaque0(VarHandle ob, Object obb, long base) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
-        return convEndian(handle.be,
-                          UNSAFE.get$RawType$Opaque(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask)));
-    }
-
-    @ForceInline
-    static void setOpaque0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        UNSAFE.put$RawType$Opaque(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, value));
-    }
-#if[CAS]
-
-    @ForceInline
-    static boolean compareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return UNSAFE.compareAndSet$RawType$(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, expected), convEndian(handle.be, value));
-    }
-
-    @ForceInline
-    static $type$ compareAndExchange0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return convEndian(handle.be,
-                          UNSAFE.compareAndExchange$RawType$(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
-                                  convEndian(handle.be, expected), convEndian(handle.be, value)));
-    }
-
-    @ForceInline
-    static $type$ compareAndExchangeAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return convEndian(handle.be,
-                          UNSAFE.compareAndExchange$RawType$Acquire(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
-                                  convEndian(handle.be, expected), convEndian(handle.be, value)));
-    }
-
-    @ForceInline
-    static $type$ compareAndExchangeRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return convEndian(handle.be,
-                          UNSAFE.compareAndExchange$RawType$Release(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
-                                  convEndian(handle.be, expected), convEndian(handle.be, value)));
-    }
-
-    @ForceInline
-    static boolean weakCompareAndSetPlain0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return UNSAFE.weakCompareAndSet$RawType$Plain(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, expected), convEndian(handle.be, value));
-    }
-
-    @ForceInline
-    static boolean weakCompareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return UNSAFE.weakCompareAndSet$RawType$(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, expected), convEndian(handle.be, value));
-    }
-
-    @ForceInline
-    static boolean weakCompareAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return UNSAFE.weakCompareAndSet$RawType$Acquire(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, expected), convEndian(handle.be, value));
-    }
-
-    @ForceInline
-    static boolean weakCompareAndSetRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return UNSAFE.weakCompareAndSet$RawType$Release(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, expected), convEndian(handle.be, value));
-    }
-
-    @ForceInline
-    static $type$ getAndSet0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return convEndian(handle.be,
-                          UNSAFE.getAndSet$RawType$(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
-                                  convEndian(handle.be, value)));
-    }
-
-    @ForceInline
-    static $type$ getAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return convEndian(handle.be,
-                          UNSAFE.getAndSet$RawType$Acquire(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
-                                  convEndian(handle.be, value)));
-    }
-
-    @ForceInline
-    static $type$ getAndSetRelease0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return convEndian(handle.be,
-                          UNSAFE.getAndSet$RawType$Release(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
-                                  convEndian(handle.be, value)));
-    }
-#end[CAS]
-#if[AtomicAdd]
-
-    @ForceInline
-    static $type$ getAndAdd0(VarHandle ob, Object obb, long base, $type$ delta) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndAdd$RawType$(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    delta);
-        } else {
-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndAddAcquire0(VarHandle ob, Object obb, long base, $type$ delta) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndAdd$RawType$Acquire(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    delta);
-        } else {
-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndAddRelease0(VarHandle ob, Object obb, long base, $type$ delta) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndAdd$RawType$Release(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    delta);
-        } else {
-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndAddConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ delta) {
-        $type$ nativeExpectedValue, expectedValue;
-        Object base = bb.unsafeGetBase();
-        do {
-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
-        return expectedValue;
-    }
-#end[AtomicAdd]
-#if[Bitwise]
-
-    @ForceInline
-    static $type$ getAndBitwiseOr0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseOr$RawType$(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseOrRelease0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseOr$RawType$Release(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseOrAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseOr$RawType$Acquire(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseOrConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
-        $type$ nativeExpectedValue, expectedValue;
-        Object base = bb.unsafeGetBase();
-        do {
-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
-        return expectedValue;
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseAnd0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseAnd$RawType$(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseAndRelease0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseAnd$RawType$Release(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseAndAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseAndConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
-        $type$ nativeExpectedValue, expectedValue;
-        Object base = bb.unsafeGetBase();
-        do {
-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue & value)));
-        return expectedValue;
-    }
-
-
-    @ForceInline
-    static $type$ getAndBitwiseXor0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseXor$RawType$(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseXorRelease0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseXor$RawType$Release(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseXorAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseXor$RawType$Acquire(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseXorConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
-        $type$ nativeExpectedValue, expectedValue;
-        Object base = bb.unsafeGetBase();
-        do {
-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
-        return expectedValue;
-    }
-#end[Bitwise]
-}
diff a/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
--- a/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
@@ -111,12 +111,18 @@
     /**
      * Returns a var handle view of a given memory address.
      * Used by {@code jdk.internal.foreign.LayoutPath} and
      * {@code jdk.incubator.foreign.MemoryHandles}.
      */
-    VarHandle memoryAddressViewVarHandle(Class<?> carrier, long alignmentMask,
-                                         ByteOrder order, long offset, long[] strides);
+    VarHandle memoryAccessVarHandle(Class<?> carrier, long alignmentMask,
+                                    ByteOrder order, long offset, long[] strides);
+
+    /**
+     * Is {@code handle} a memory access varhandle?
+     * Used by {@code jdk.incubator.foreign.MemoryHandles}.
+     */
+    boolean isMemoryAccessVarHandle(VarHandle handle);
 
     /**
      * Returns the carrier associated with a memory access var handle.
      * Used by {@code jdk.incubator.foreign.MemoryHandles}.
      */
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
@@ -124,16 +124,24 @@
      */
     static void copy(MemoryAddress src, MemoryAddress dst, long bytes) {
         MemoryAddressImpl.copy((MemoryAddressImpl)src, (MemoryAddressImpl)dst, bytes);
     }
 
+    /**
+     * A native memory address instance modelling the {@code NULL} pointer. This address is backed by a memory segment
+     * which can be neither closed, nor dereferenced.
+     */
+    MemoryAddress NULL = MemorySegmentImpl.NOTHING.baseAddress();
+
     /**
      * Obtain a new memory address instance from given long address. The returned address is backed by a memory segment
      * which can be neither closed, nor dereferenced.
      * @param value the long address.
      * @return the new memory address instance.
      */
     static MemoryAddress ofLong(long value) {
-        return MemorySegmentImpl.NOTHING.baseAddress().addOffset(value);
+        return value == 0 ?
+                NULL :
+                MemorySegmentImpl.NOTHING.baseAddress().addOffset(value);
     }
 
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
@@ -25,13 +25,17 @@
  */
 package jdk.incubator.foreign;
 
 import jdk.internal.access.JavaLangInvokeAccess;
 import jdk.internal.access.SharedSecrets;
+import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.Utils;
 import sun.invoke.util.Wrapper;
 
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
 
 /**
  * This class defines several factory methods for constructing and combining memory access var handles.
@@ -121,10 +125,31 @@
 
     private MemoryHandles() {
         //sorry, just the one!
     }
 
+    private static final MethodHandle LONG_TO_ADDRESS;
+    private static final MethodHandle ADDRESS_TO_LONG;
+    private static final MethodHandle ADD_OFFSET;
+    private static final MethodHandle ADD_STRIDE;
+
+    static {
+        try {
+            LONG_TO_ADDRESS = MethodHandles.lookup().findStatic(MemoryHandles.class, "longToAddress",
+                    MethodType.methodType(MemoryAddress.class, long.class));
+            ADDRESS_TO_LONG = MethodHandles.lookup().findStatic(MemoryHandles.class, "addressToLong",
+                    MethodType.methodType(long.class, MemoryAddress.class));
+            ADD_OFFSET = MethodHandles.lookup().findStatic(MemoryHandles.class, "addOffset",
+                    MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class));
+
+            ADD_STRIDE = MethodHandles.lookup().findStatic(MemoryHandles.class, "addStride",
+                    MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class, long.class));
+        } catch (Throwable ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
+
     /**
      * Creates a memory access var handle with the given carrier type and byte order.
      *
      * The resulting memory access var handle features a single {@link MemoryAddress} access coordinate,
      * and its variable type is set by the given carrier type.
@@ -172,89 +197,132 @@
         if (alignmentBytes <= 0
                 || (alignmentBytes & (alignmentBytes - 1)) != 0) { // is power of 2?
             throw new IllegalArgumentException("Bad alignment: " + alignmentBytes);
         }
 
-        return Utils.fixUpVarHandle(JLI.memoryAddressViewVarHandle(carrier, alignmentBytes - 1, byteOrder, 0, new long[]{}));
+        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, alignmentBytes - 1, byteOrder, 0, new long[]{}));
     }
 
     /**
-     * Creates a memory access var handle with a fixed offset added to the accessed offset. That is,
-     * if the target memory access var handle accesses a memory location at offset <em>O</em>, the new memory access var
-     * handle will access a memory location at offset <em>O' + O</em>.
-     *
-     * The resulting memory access var handle will feature the same access coordinates as the ones in the target memory access var handle.
+     * Returns a var handle that adds a <em>fixed</em> offset to the incoming {@link MemoryAddress} coordinate
+     * and then propagates such value to the target var handle. That is,
+     * when the returned var handle receives a memory address coordinate pointing at a memory location at
+     * offset <em>O</em>, a memory address coordinate pointing at a memory location at offset <em>O' + O</em>
+     * is created, and then passed to the target var handle.
      *
-     * @apiNote the resulting var handle features certain <a href="#memaccess-mode">access mode restrictions</a>,
-     * which are common to all memory access var handles.
+     * The returned var handle will feature the same type and access coordinates as the target var handle.
      *
      * @param target the target memory access handle to access after the offset adjustment.
      * @param bytesOffset the offset, in bytes. Must be positive or zero.
-     * @return the new memory access var handle.
-     * @throws IllegalArgumentException when the target var handle is not a memory access var handle,
-     * or when {@code bytesOffset < 0}, or otherwise incompatible with the alignment constraint.
+     * @return the adapted var handle.
+     * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.
      */
     public static VarHandle withOffset(VarHandle target, long bytesOffset) {
-        if (bytesOffset < 0) {
-            throw new IllegalArgumentException("Illegal offset: " + bytesOffset);
+        if (bytesOffset == 0) {
+            return target; //nothing to do
         }
 
-        long alignMask = JLI.memoryAddressAlignmentMask(target);
+        checkAddressFirstCoordinate(target);
 
-        if ((bytesOffset & alignMask) != 0) {
-            throw new IllegalArgumentException("Offset " + bytesOffset + " does not conform to alignment " + (alignMask + 1));
+        if (JLI.isMemoryAccessVarHandle(target) &&
+                (bytesOffset & JLI.memoryAddressAlignmentMask(target)) == 0) {
+            //flatten
+            return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(
+                    JLI.memoryAddressCarrier(target),
+                    JLI.memoryAddressAlignmentMask(target),
+                    JLI.memoryAddressByteOrder(target),
+                    JLI.memoryAddressOffset(target) + bytesOffset,
+                    JLI.memoryAddressStrides(target)));
+        } else {
+            //slow path
+            VarHandle res = MethodHandles.collectCoordinates(target, 0, ADD_OFFSET);
+            return MethodHandles.insertCoordinates(res, 1, bytesOffset);
         }
-
-        return Utils.fixUpVarHandle(JLI.memoryAddressViewVarHandle(
-                JLI.memoryAddressCarrier(target),
-                alignMask,
-                JLI.memoryAddressByteOrder(target),
-                JLI.memoryAddressOffset(target) + bytesOffset,
-                JLI.memoryAddressStrides(target)));
     }
 
     /**
-     * Creates a memory access var handle with a <em>variable</em> offset added to the accessed offset.
-     * That is, if the target memory access var handle accesses a memory location at offset <em>O</em>,
-     * the new memory access var handle will access a memory location at offset <em>(S * X) + O</em>, where <em>S</em>
-     * is a constant <em>stride</em>, whereas <em>X</em> is a dynamic value that will be provided as an additional access
-     * coordinate (of type {@code long}). The new access coordinate will be <em>prepended</em> to the ones available
-     * in the target memory access var handles (if any).
+     * Returns a var handle which adds a <em>variable</em> offset to the incoming {@link MemoryAddress}
+     * access coordinate value and then propagates such value to the target var handle.
+     * That is, when the returned var handle receives a memory address coordinate pointing at a memory location at
+     * offset <em>O</em>, a new memory address coordinate pointing at a memory location at offset <em>(S * X) + O</em>
+     * is created, and then passed to the target var handle,
+     * where <em>S</em> is a constant <em>stride</em>, whereas <em>X</em> is a dynamic value that will be
+     * provided as an additional access coordinate (of type {@code long}).
      *
-     * @apiNote the resulting var handle features certain <a href="#memaccess-mode">access mode restrictions</a>,
-     * which are common to all memory access var handles.
+     * The returned var handle will feature the same type as the target var handle; an additional access coordinate
+     * of type {@code long} will be added to the access coordinate types of the target var handle at the position
+     * immediately following the leading access coordinate of type {@link MemoryAddress}.
      *
      * @param target the target memory access handle to access after the scale adjustment.
      * @param bytesStride the stride, in bytes, by which to multiply the coordinate value. Must be greater than zero.
-     * @return the new memory access var handle.
-     * @throws IllegalArgumentException when the target var handle is not a memory access var handle,
-     * or if {@code bytesStride <= 0}, or otherwise incompatible with the alignment constraint.
+     * @return the adapted var handle.
+     * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.
      */
     public static VarHandle withStride(VarHandle target, long bytesStride) {
         if (bytesStride == 0) {
-            throw new IllegalArgumentException("Stride must be positive: " + bytesStride);
+            return MethodHandles.dropCoordinates(target, 1, long.class); // dummy coordinate
         }
 
-        long alignMask = JLI.memoryAddressAlignmentMask(target);
+        checkAddressFirstCoordinate(target);
+
+        if (JLI.isMemoryAccessVarHandle(target) &&
+                (bytesStride & JLI.memoryAddressAlignmentMask(target)) == 0) {
+            //flatten
+            long[] strides = JLI.memoryAddressStrides(target);
+            long[] newStrides = new long[strides.length + 1];
+            System.arraycopy(strides, 0, newStrides, 1, strides.length);
+            newStrides[0] = bytesStride;
 
-        if ((bytesStride & alignMask) != 0) {
-            throw new IllegalArgumentException("Stride " + bytesStride + " does not conform to alignment " + (alignMask + 1));
+            return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(
+                    JLI.memoryAddressCarrier(target),
+                    JLI.memoryAddressAlignmentMask(target),
+                    JLI.memoryAddressByteOrder(target),
+                    JLI.memoryAddressOffset(target),
+                    newStrides));
+        } else {
+            //slow path
+            VarHandle res = MethodHandles.collectCoordinates(target, 0, ADD_STRIDE);
+            return MethodHandles.insertCoordinates(res, 2, bytesStride);
         }
+    }
 
-        long offset = JLI.memoryAddressOffset(target);
+    /**
+     * Adapt an existing var handle into a new var handle whose carrier type is {@link MemoryAddress}.
+     * That is, when calling {@link VarHandle#get(Object...)} on the returned var handle,
+     * the read numeric value will be turned into a memory address (as if by calling {@link MemoryAddress#ofLong(long)});
+     * similarly, when calling {@link VarHandle#set(Object...)}, the memory address to be set will be converted
+     * into a numeric value, and then written into memory. The amount of bytes read (resp. written) from (resp. to)
+     * memory depends on the carrier of the original memory access var handle.
+     *
+     * @param target the memory access var handle to be adapted
+     * @return the adapted var handle.
+     * @throws IllegalArgumentException if the carrier type of {@code varHandle} is either {@code boolean},
+     * {@code float}, or {@code double}, or is not a primitive type.
+     */
+    public static VarHandle asAddressVarHandle(VarHandle target) {
+        Class<?> carrier = target.varType();
+        if (!carrier.isPrimitive() || carrier == boolean.class ||
+                carrier == float.class || carrier == double.class) {
+            throw new IllegalArgumentException("Unsupported carrier type: " + carrier.getName());
+        }
 
-        long[] strides = JLI.memoryAddressStrides(target);
-        long[] newStrides = new long[strides.length + 1];
-        System.arraycopy(strides, 0, newStrides, 1, strides.length);
-        newStrides[0] = bytesStride;
+        if (carrier != long.class) {
+            // slow-path, we need to adapt
+            return MethodHandles.filterValue(target,
+                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(carrier, MemoryAddress.class)),
+                    MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, carrier)));
+        } else {
+            // fast-path
+            return MethodHandles.filterValue(target, ADDRESS_TO_LONG, LONG_TO_ADDRESS);
+        }
+    }
 
-        return Utils.fixUpVarHandle(JLI.memoryAddressViewVarHandle(
-                JLI.memoryAddressCarrier(target),
-                alignMask,
-                JLI.memoryAddressByteOrder(target),
-                offset,
-                newStrides));
+    private static void checkAddressFirstCoordinate(VarHandle handle) {
+        if (handle.coordinateTypes().size() < 1 ||
+                handle.coordinateTypes().get(0) != MemoryAddress.class) {
+            throw new IllegalArgumentException("Expected var handle with leading coordinate of type MemoryAddress");
+        }
     }
 
     private static void checkCarrier(Class<?> carrier) {
         if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
             throw new IllegalArgumentException("Illegal carrier: " + carrier.getSimpleName());
@@ -263,6 +331,22 @@
 
     private static long carrierSize(Class<?> carrier) {
         long bitsAlignment = Math.max(8, Wrapper.forPrimitiveType(carrier).bitWidth());
         return Utils.bitsToBytesOrThrow(bitsAlignment, IllegalStateException::new);
     }
+
+    private static MemoryAddress longToAddress(long value) {
+        return MemoryAddress.ofLong(value);
+    }
+
+    private static long addressToLong(MemoryAddress value) {
+        return MemoryAddressImpl.addressof(value);
+    }
+
+    private static MemoryAddress addOffset(MemoryAddress address, long offset) {
+        return address.addOffset(offset);
+    }
+
+    private static MemoryAddress addStride(MemoryAddress address, long index, long stride) {
+        return address.addOffset(index * stride);
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
@@ -139,11 +139,11 @@
             throw new IllegalArgumentException("Invalid carrier: " + carrier + ", for layout " + layout);
         }
 
         checkAlignment(this);
 
-        return Utils.fixUpVarHandle(JLI.memoryAddressViewVarHandle(
+        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(
                 carrier,
                 layout.byteAlignment() - 1, //mask
                 ((ValueLayout) layout).order(),
                 Utils.bitsToBytesOrThrow(offset, IllegalStateException::new),
                 LongStream.of(strides).map(s -> Utils.bitsToBytesOrThrow(s, IllegalStateException::new)).toArray()));
diff a/test/jdk/java/foreign/TestAdaptVarHandles.java b/test/jdk/java/foreign/TestAdaptVarHandles.java
--- a/test/jdk/java/foreign/TestAdaptVarHandles.java
+++ b/test/jdk/java/foreign/TestAdaptVarHandles.java
@@ -392,10 +392,52 @@
     public void testBadCollectCoordinatesWrongFilterException() {
         VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MethodHandles.collectCoordinates(intHandle, 0, S2L_EX);
     }
 
+    @Test
+    public void testDropCoordinates() throws Throwable {
+        ValueLayout layout = MemoryLayouts.JAVA_INT;
+        MemorySegment segment = MemorySegment.allocateNative(layout);
+        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
+        VarHandle intHandle_dummy = MethodHandles.dropCoordinates(intHandle, 1, float.class, String.class);
+        intHandle_dummy.set(segment.baseAddress(), 1f, "hello", 0L, 1);
+        int oldValue = (int)intHandle_dummy.getAndAdd(segment.baseAddress(), 1f, "hello", 0L, 42);
+        assertEquals(oldValue, 1);
+        int value = (int)intHandle_dummy.get(segment.baseAddress(), 1f, "hello", 0L);
+        assertEquals(value, 43);
+        boolean swapped = (boolean)intHandle_dummy.compareAndSet(segment.baseAddress(), 1f, "hello", 0L, 43, 12);
+        assertTrue(swapped);
+        oldValue = (int)intHandle_dummy.compareAndExchange(segment.baseAddress(), 1f, "hello", 0L, 12, 42);
+        assertEquals(oldValue, 12);
+        value = (int)intHandle_dummy.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress(), 1f, "hello", 0L);
+        assertEquals(value, 42);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadDropCoordinatesNegativePos() {
+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
+        MethodHandles.dropCoordinates(intHandle, -1);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadDropCoordinatesPosTooBig() {
+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
+        MethodHandles.dropCoordinates(intHandle, 2);
+    }
+
+    @Test(expectedExceptions = NullPointerException.class)
+    public void testBadDropCoordinatesNullValueTypes() {
+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
+        MethodHandles.dropCoordinates(intHandle, 1, null);
+    }
+
+    @Test(expectedExceptions = NullPointerException.class)
+    public void testBadDropCoordinatesNullTarget() {
+        MethodHandles.dropCoordinates(null, 1);
+    }
+
     //helper methods
 
     static int stringToInt(String s) {
         return Integer.valueOf(s);
     }
diff a/test/jdk/java/foreign/TestAddressHandle.java b/test/jdk/java/foreign/TestAddressHandle.java
--- /dev/null
+++ b/test/jdk/java/foreign/TestAddressHandle.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+/*
+ * @test
+ * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAddressHandle
+ * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAddressHandle
+ * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAddressHandle
+ * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAddressHandle
+ */
+
+import java.lang.invoke.*;
+import java.nio.ByteOrder;
+import jdk.incubator.foreign.*;
+
+import org.testng.annotations.*;
+import static org.testng.Assert.*;
+
+public class TestAddressHandle {
+
+    static final MethodHandle INT_TO_BOOL;
+    static final MethodHandle BOOL_TO_INT;
+    static final MethodHandle INT_TO_STRING;
+    static final MethodHandle STRING_TO_INT;
+
+    static {
+        try {
+            INT_TO_BOOL = MethodHandles.lookup().findStatic(TestAddressHandle.class, "intToBool",
+                    MethodType.methodType(boolean.class, int.class));
+            BOOL_TO_INT = MethodHandles.lookup().findStatic(TestAddressHandle.class, "boolToInt",
+                    MethodType.methodType(int.class, boolean.class));
+            INT_TO_STRING = MethodHandles.lookup().findStatic(TestAddressHandle.class, "intToString",
+                    MethodType.methodType(String.class, int.class));
+            STRING_TO_INT = MethodHandles.lookup().findStatic(TestAddressHandle.class, "stringToInt",
+                    MethodType.methodType(int.class, String.class));
+        } catch (Throwable ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
+
+    @Test(dataProvider = "addressHandles")
+    public void testAddressHandle(VarHandle addrHandle) {
+        VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
+        try (MemorySegment segment = MemorySegment.allocateNative(8)) {
+            longHandle.set(segment.baseAddress(), 42L);
+            MemoryAddress address = (MemoryAddress)addrHandle.get(segment.baseAddress());
+            assertEquals(address.offset(), 42L);
+            try {
+                longHandle.get(address); // check OOB
+                fail();
+            } catch (UnsupportedOperationException ex) {
+                assertTrue(true);
+            }
+            addrHandle.set(segment.baseAddress(), address.addOffset(1));
+            long result = (long)longHandle.get(segment.baseAddress());
+            assertEquals(43L, result);
+        }
+    }
+
+    @Test(dataProvider = "addressHandles")
+    public void testNull(VarHandle addrHandle) {
+        VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
+        try (MemorySegment segment = MemorySegment.allocateNative(8)) {
+            longHandle.set(segment.baseAddress(), 0L);
+            MemoryAddress address = (MemoryAddress)addrHandle.get(segment.baseAddress());
+            assertTrue(address == MemoryAddress.NULL);
+        }
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadAdaptFloat() {
+        VarHandle floatHandle = MemoryHandles.varHandle(float.class, ByteOrder.nativeOrder());
+        MemoryHandles.asAddressVarHandle(floatHandle);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadAdaptDouble() {
+        VarHandle doubleHandle = MemoryHandles.varHandle(double.class, ByteOrder.nativeOrder());
+        MemoryHandles.asAddressVarHandle(doubleHandle);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadAdaptBoolean() {
+        VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle boolHandle = MethodHandles.filterValue(intHandle, BOOL_TO_INT, INT_TO_BOOL);
+        MemoryHandles.asAddressVarHandle(boolHandle);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadAdaptString() {
+        VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle stringHandle = MethodHandles.filterValue(intHandle, STRING_TO_INT, INT_TO_STRING);
+        MemoryHandles.asAddressVarHandle(stringHandle);
+    }
+
+    @DataProvider(name = "addressHandles")
+    static Object[][] addressHandles() {
+        return new Object[][] {
+                // long
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_LONG.varHandle(long.class)) },
+
+                // int
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_INT.varHandle(int.class)) },
+
+                // short
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_SHORT.varHandle(short.class)) },
+
+                // char
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_CHAR.varHandle(char.class)) },
+
+                // byte
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_BYTE.varHandle(byte.class)) }
+        };
+    }
+
+    static int boolToInt(boolean value) {
+        return value ? 1 : 0;
+    }
+
+    static boolean intToBool(int value) {
+        return value != 0;
+    }
+
+    static int stringToInt(String value) {
+        return value.length();
+    }
+
+    static String intToString(int value) {
+        return String.valueOf(value);
+    }
+}
diff a/test/jdk/java/foreign/TestVarHandleCombinators.java b/test/jdk/java/foreign/TestVarHandleCombinators.java
--- a/test/jdk/java/foreign/TestVarHandleCombinators.java
+++ b/test/jdk/java/foreign/TestVarHandleCombinators.java
@@ -32,10 +32,11 @@
 import org.testng.annotations.Test;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 
+import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
 
 import static org.testng.Assert.assertEquals;
 
@@ -51,20 +52,31 @@
         MemoryAddress addr = segment.baseAddress();
 
         assertEquals((byte) vh.get(addr, 2), (byte) -1);
     }
 
-    @Test(expectedExceptions = IllegalArgumentException.class)
+    @Test(expectedExceptions = IllegalStateException.class)
     public void testUnalignedElement() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());
-        MemoryHandles.withStride(vh, 2);
+        vh = MemoryHandles.withStride(vh, 2);
+        MemorySegment segment = MemorySegment.ofArray(new byte[4]);
+        vh.get(segment.baseAddress(), 1L); //should throw
     }
 
-    @Test(expectedExceptions = IllegalArgumentException.class)
-    public void testBadStrideElement() {
+    public void testZeroStrideElement() {
         VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
-        MemoryHandles.withStride(vh, 0); //scale factor cant be zero
+        VarHandle strided_vh = MemoryHandles.withStride(vh, 0);
+        MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
+        for (int i = 0 ; i < 100 ; i++) {
+            assertEquals((int)vh.get(segment.baseAddress()), strided_vh.get(segment.baseAddress(), (long)i));
+        }
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testStrideWrongHandle() {
+        VarHandle vh = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());
+        MemoryHandles.withStride(vh, 10);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testAlignNotPowerOf2() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 3, ByteOrder.nativeOrder());
@@ -84,31 +96,42 @@
 
         vh.set(address, (byte) 10); // fine, memory region is aligned
         assertEquals((byte) vh.get(address), (byte) 10);
     }
 
-    @Test(expectedExceptions = IllegalArgumentException.class)
+    @Test(expectedExceptions = IllegalStateException.class)
     public void testAlignBadAccess() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());
         vh = MemoryHandles.withOffset(vh, 1); // offset by 1 byte
 
         MemorySegment segment = MemorySegment.allocateNative(2, 2);
         MemoryAddress address = segment.baseAddress();
 
         vh.set(address, (byte) 10); // should be bad align
     }
 
-    @Test(expectedExceptions = IllegalArgumentException.class)
-    public void testOffsetNegative() {
-        VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
-        MemoryHandles.withOffset(vh, -1);
+    public void testZeroOffsetElement() {
+        VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle offset_vh = MemoryHandles.withOffset(vh, 0);
+        MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
+        for (int i = 0 ; i < 100 ; i++) {
+            assertEquals((int)vh.get(segment.baseAddress()), offset_vh.get(segment.baseAddress(), (long)i));
+        }
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testOffsetWrongHandle() {
+        VarHandle vh = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());
+        MemoryHandles.withOffset(vh, 1);
+    }
+
+    @Test(expectedExceptions = IllegalStateException.class)
     public void testUnalignedOffset() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());
-        MemoryHandles.withOffset(vh, 2);
+        vh = MemoryHandles.withOffset(vh, 2);
+        MemorySegment segment = MemorySegment.ofArray(new byte[4]);
+        vh.get(segment.baseAddress()); //should throw
     }
 
     @Test
     public void testOffset() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());

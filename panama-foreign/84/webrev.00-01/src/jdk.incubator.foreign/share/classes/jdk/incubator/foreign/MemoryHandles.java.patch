diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
@@ -212,16 +212,15 @@
      * The returned var handle will feature the same type and access coordinates as the target var handle.
      *
      * @param target the target memory access handle to access after the offset adjustment.
      * @param bytesOffset the offset, in bytes. Must be positive or zero.
      * @return the adapted var handle.
-     * @throws IllegalArgumentException if {@code bytesOffset < 0}, or if the first access coordinate type
-     * is not of type {@link MemoryAddress}.
+     * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.
      */
     public static VarHandle withOffset(VarHandle target, long bytesOffset) {
-        if (bytesOffset < 0) {
-            throw new IllegalArgumentException("Illegal offset: " + bytesOffset);
+        if (bytesOffset == 0) {
+            return target; //nothing to do
         }
 
         checkAddressFirstCoordinate(target);
 
         if (JLI.isMemoryAccessVarHandle(target) &&
@@ -248,21 +247,21 @@
      * is created, and then passed to the target var handle,
      * where <em>S</em> is a constant <em>stride</em>, whereas <em>X</em> is a dynamic value that will be
      * provided as an additional access coordinate (of type {@code long}).
      *
      * The returned var handle will feature the same type as the target var handle; an additional access coordinate
-     * of type {@code long} will be <em>prepended</em> to the access coordinate types of the target var handle.
+     * of type {@code long} will be added to the access coordinate types of the target var handle at the position
+     * immediately following the leading access coordinate of type {@link MemoryAddress}.
      *
      * @param target the target memory access handle to access after the scale adjustment.
      * @param bytesStride the stride, in bytes, by which to multiply the coordinate value. Must be greater than zero.
      * @return the adapted var handle.
-     * @throws IllegalArgumentException if {@code bytesStride <= 0}, or if the first access coordinate type
-     * is not of type {@link MemoryAddress}.
+     * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.
      */
     public static VarHandle withStride(VarHandle target, long bytesStride) {
         if (bytesStride == 0) {
-            throw new IllegalArgumentException("Stride must be positive: " + bytesStride);
+            return MethodHandles.dropCoordinates(target, 1, long.class); // dummy coordinate
         }
 
         checkAddressFirstCoordinate(target);
 
         if (JLI.isMemoryAccessVarHandle(target) &&
@@ -294,16 +293,17 @@
      * into a numeric value, and then written into memory. The amount of bytes read (resp. written) from (resp. to)
      * memory depends on the carrier of the original memory access var handle.
      *
      * @param target the memory access var handle to be adapted
      * @return the adapted var handle.
-     * @throws IllegalArgumentException if the carrier type of {@code varHandle} is either {@code float},
-     * or {@code double}, or is not a primitive type.
+     * @throws IllegalArgumentException if the carrier type of {@code varHandle} is either {@code boolean},
+     * {@code float}, or {@code double}, or is not a primitive type.
      */
     public static VarHandle asAddressVarHandle(VarHandle target) {
         Class<?> carrier = target.varType();
-        if (!carrier.isPrimitive() || carrier == float.class || carrier == double.class) {
+        if (!carrier.isPrimitive() || carrier == boolean.class ||
+                carrier == float.class || carrier == double.class) {
             throw new IllegalArgumentException("Unsupported carrier type: " + carrier.getName());
         }
 
         if (carrier != long.class) {
             // slow-path, we need to adapt
@@ -337,11 +337,11 @@
     private static MemoryAddress longToAddress(long value) {
         return MemoryAddress.ofLong(value);
     }
 
     private static long addressToLong(MemoryAddress value) {
-        return ((MemoryAddressImpl)value).unsafeGetOffset();
+        return MemoryAddressImpl.addressof(value);
     }
 
     private static MemoryAddress addOffset(MemoryAddress address, long offset) {
         return address.addOffset(offset);
     }

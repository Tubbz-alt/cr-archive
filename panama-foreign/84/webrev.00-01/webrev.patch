diff a/src/java.base/share/classes/java/lang/invoke/MethodHandles.java b/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
@@ -5039,19 +5039,20 @@
      * available starting at {@code pos}.
      */
     public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {
         Objects.nonNull(target);
         Objects.nonNull(filters);
-        if (filters.length == 0) return target;
 
         List<Class<?>> targetCoordinates = target.coordinateTypes();
         if (pos < 0 || pos >= targetCoordinates.size()) {
             throw newIllegalArgumentException("Invalid position " + pos + " for coordinate types", targetCoordinates);
         } else if (pos + filters.length > targetCoordinates.size()) {
             throw new IllegalArgumentException("Too many filters");
         }
 
+        if (filters.length == 0) return target;
+
         List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
         for (int i = 0 ; i < filters.length ; i++) {
             noCheckedExceptions(filters[i]);
             MethodType filterType = filters[i].type();
             if (filterType.parameterCount() != 1) {
@@ -5093,19 +5094,20 @@
      * of the target var handle.
      */
     public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {
         Objects.nonNull(target);
         Objects.nonNull(values);
-        if (values.length == 0) return target;
 
         List<Class<?>> targetCoordinates = target.coordinateTypes();
         if (pos < 0 || pos >= targetCoordinates.size()) {
             throw newIllegalArgumentException("Invalid position " + pos + " for coordinate types", targetCoordinates);
         } else if (pos + values.length > targetCoordinates.size()) {
             throw new IllegalArgumentException("Too many values");
         }
 
+        if (values.length == 0) return target;
+
         List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
         for (int i = 0 ; i < values.length ; i++) {
             Class<?> pt = newCoordinates.get(pos);
             if (pt.isPrimitive()) {
                 Wrapper w = Wrapper.forPrimitiveType(pt);
@@ -5261,10 +5263,48 @@
 
         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class<?>[0]),
                 (mode, modeHandle) -> MethodHandles.collectArguments(modeHandle, 1 + pos, filter));
     }
 
+    /**
+     * Returns a var handle which will discard some dummy coordinates before delegating to the
+     * target var handle. As a consequence, the resulting var handle will feature more
+     * coordinate types than the target var handle.
+     * <p>
+     * The {@code pos} argument may range between zero and <i>N</i>, where <i>N</i> is the arity of the
+     * target var handle's coordinate types. If {@code pos} is zero, the dummy coordinates will precede
+     * the target's real arguments; if {@code pos} is <i>N</i> they will come after.
+     * <p>
+     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
+     * atomic access guarantees as those featured by the target var handle.
+     *
+     * @param target the var handle to invoke after the dummy coordinates are dropped
+     * @param pos position of first coordinate to drop (zero for the leftmost)
+     * @param valueTypes the type(s) of the coordinate(s) to drop
+     * @return an adapter var handle which drops some dummy coordinates,
+     *         before calling the target var handle
+     * @throws NullPointerException if either {@code target}, {@code valueTypes} are {@code == null}.
+     * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive.
+     */
+    public static VarHandle dropCoordinates(VarHandle target, int pos, Class<?>... valueTypes) {
+        Objects.nonNull(target);
+        Objects.nonNull(valueTypes);
+
+        List<Class<?>> targetCoordinates = target.coordinateTypes();
+        if (pos < 0 || pos > targetCoordinates.size()) {
+            throw newIllegalArgumentException("Invalid position " + pos + " for coordinate types", targetCoordinates);
+        }
+
+        if (valueTypes.length == 0) return target;
+
+        List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
+        newCoordinates.addAll(pos, List.of(valueTypes));
+
+        return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class<?>[0]),
+                (mode, modeHandle) -> MethodHandles.dropArguments(modeHandle, 1 + pos, valueTypes));
+    }
+
     private static void noCheckedExceptions(MethodHandle handle) {
         if (handle instanceof DirectMethodHandle) {
             DirectMethodHandle directHandle = (DirectMethodHandle)handle;
             MethodHandleInfo info = Lookup.IMPL_LOOKUP.revealDirect(directHandle);
             Class<?>[] exceptionTypes = switch (info.getReferenceKind()) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
@@ -212,16 +212,15 @@
      * The returned var handle will feature the same type and access coordinates as the target var handle.
      *
      * @param target the target memory access handle to access after the offset adjustment.
      * @param bytesOffset the offset, in bytes. Must be positive or zero.
      * @return the adapted var handle.
-     * @throws IllegalArgumentException if {@code bytesOffset < 0}, or if the first access coordinate type
-     * is not of type {@link MemoryAddress}.
+     * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.
      */
     public static VarHandle withOffset(VarHandle target, long bytesOffset) {
-        if (bytesOffset < 0) {
-            throw new IllegalArgumentException("Illegal offset: " + bytesOffset);
+        if (bytesOffset == 0) {
+            return target; //nothing to do
         }
 
         checkAddressFirstCoordinate(target);
 
         if (JLI.isMemoryAccessVarHandle(target) &&
@@ -248,21 +247,21 @@
      * is created, and then passed to the target var handle,
      * where <em>S</em> is a constant <em>stride</em>, whereas <em>X</em> is a dynamic value that will be
      * provided as an additional access coordinate (of type {@code long}).
      *
      * The returned var handle will feature the same type as the target var handle; an additional access coordinate
-     * of type {@code long} will be <em>prepended</em> to the access coordinate types of the target var handle.
+     * of type {@code long} will be added to the access coordinate types of the target var handle at the position
+     * immediately following the leading access coordinate of type {@link MemoryAddress}.
      *
      * @param target the target memory access handle to access after the scale adjustment.
      * @param bytesStride the stride, in bytes, by which to multiply the coordinate value. Must be greater than zero.
      * @return the adapted var handle.
-     * @throws IllegalArgumentException if {@code bytesStride <= 0}, or if the first access coordinate type
-     * is not of type {@link MemoryAddress}.
+     * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.
      */
     public static VarHandle withStride(VarHandle target, long bytesStride) {
         if (bytesStride == 0) {
-            throw new IllegalArgumentException("Stride must be positive: " + bytesStride);
+            return MethodHandles.dropCoordinates(target, 1, long.class); // dummy coordinate
         }
 
         checkAddressFirstCoordinate(target);
 
         if (JLI.isMemoryAccessVarHandle(target) &&
@@ -294,16 +293,17 @@
      * into a numeric value, and then written into memory. The amount of bytes read (resp. written) from (resp. to)
      * memory depends on the carrier of the original memory access var handle.
      *
      * @param target the memory access var handle to be adapted
      * @return the adapted var handle.
-     * @throws IllegalArgumentException if the carrier type of {@code varHandle} is either {@code float},
-     * or {@code double}, or is not a primitive type.
+     * @throws IllegalArgumentException if the carrier type of {@code varHandle} is either {@code boolean},
+     * {@code float}, or {@code double}, or is not a primitive type.
      */
     public static VarHandle asAddressVarHandle(VarHandle target) {
         Class<?> carrier = target.varType();
-        if (!carrier.isPrimitive() || carrier == float.class || carrier == double.class) {
+        if (!carrier.isPrimitive() || carrier == boolean.class ||
+                carrier == float.class || carrier == double.class) {
             throw new IllegalArgumentException("Unsupported carrier type: " + carrier.getName());
         }
 
         if (carrier != long.class) {
             // slow-path, we need to adapt
@@ -337,11 +337,11 @@
     private static MemoryAddress longToAddress(long value) {
         return MemoryAddress.ofLong(value);
     }
 
     private static long addressToLong(MemoryAddress value) {
-        return ((MemoryAddressImpl)value).unsafeGetOffset();
+        return MemoryAddressImpl.addressof(value);
     }
 
     private static MemoryAddress addOffset(MemoryAddress address, long offset) {
         return address.addOffset(offset);
     }
diff a/test/jdk/java/foreign/TestAdaptVarHandles.java b/test/jdk/java/foreign/TestAdaptVarHandles.java
--- a/test/jdk/java/foreign/TestAdaptVarHandles.java
+++ b/test/jdk/java/foreign/TestAdaptVarHandles.java
@@ -392,10 +392,52 @@
     public void testBadCollectCoordinatesWrongFilterException() {
         VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MethodHandles.collectCoordinates(intHandle, 0, S2L_EX);
     }
 
+    @Test
+    public void testDropCoordinates() throws Throwable {
+        ValueLayout layout = MemoryLayouts.JAVA_INT;
+        MemorySegment segment = MemorySegment.allocateNative(layout);
+        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
+        VarHandle intHandle_dummy = MethodHandles.dropCoordinates(intHandle, 1, float.class, String.class);
+        intHandle_dummy.set(segment.baseAddress(), 1f, "hello", 0L, 1);
+        int oldValue = (int)intHandle_dummy.getAndAdd(segment.baseAddress(), 1f, "hello", 0L, 42);
+        assertEquals(oldValue, 1);
+        int value = (int)intHandle_dummy.get(segment.baseAddress(), 1f, "hello", 0L);
+        assertEquals(value, 43);
+        boolean swapped = (boolean)intHandle_dummy.compareAndSet(segment.baseAddress(), 1f, "hello", 0L, 43, 12);
+        assertTrue(swapped);
+        oldValue = (int)intHandle_dummy.compareAndExchange(segment.baseAddress(), 1f, "hello", 0L, 12, 42);
+        assertEquals(oldValue, 12);
+        value = (int)intHandle_dummy.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress(), 1f, "hello", 0L);
+        assertEquals(value, 42);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadDropCoordinatesNegativePos() {
+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
+        MethodHandles.dropCoordinates(intHandle, -1);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadDropCoordinatesPosTooBig() {
+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
+        MethodHandles.dropCoordinates(intHandle, 2);
+    }
+
+    @Test(expectedExceptions = NullPointerException.class)
+    public void testBadDropCoordinatesNullValueTypes() {
+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
+        MethodHandles.dropCoordinates(intHandle, 1, null);
+    }
+
+    @Test(expectedExceptions = NullPointerException.class)
+    public void testBadDropCoordinatesNullTarget() {
+        MethodHandles.dropCoordinates(null, 1);
+    }
+
     //helper methods
 
     static int stringToInt(String s) {
         return Integer.valueOf(s);
     }
diff a/test/jdk/java/foreign/TestAddressHandle.java b/test/jdk/java/foreign/TestAddressHandle.java
--- a/test/jdk/java/foreign/TestAddressHandle.java
+++ b/test/jdk/java/foreign/TestAddressHandle.java
@@ -36,10 +36,31 @@
 
 import org.testng.annotations.*;
 import static org.testng.Assert.*;
 
 public class TestAddressHandle {
+
+    static final MethodHandle INT_TO_BOOL;
+    static final MethodHandle BOOL_TO_INT;
+    static final MethodHandle INT_TO_STRING;
+    static final MethodHandle STRING_TO_INT;
+
+    static {
+        try {
+            INT_TO_BOOL = MethodHandles.lookup().findStatic(TestAddressHandle.class, "intToBool",
+                    MethodType.methodType(boolean.class, int.class));
+            BOOL_TO_INT = MethodHandles.lookup().findStatic(TestAddressHandle.class, "boolToInt",
+                    MethodType.methodType(int.class, boolean.class));
+            INT_TO_STRING = MethodHandles.lookup().findStatic(TestAddressHandle.class, "intToString",
+                    MethodType.methodType(String.class, int.class));
+            STRING_TO_INT = MethodHandles.lookup().findStatic(TestAddressHandle.class, "stringToInt",
+                    MethodType.methodType(int.class, String.class));
+        } catch (Throwable ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
+
     @Test(dataProvider = "addressHandles")
     public void testAddressHandle(VarHandle addrHandle) {
         VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
         try (MemorySegment segment = MemorySegment.allocateNative(8)) {
             longHandle.set(segment.baseAddress(), 42L);
@@ -77,10 +98,24 @@
     public void testBadAdaptDouble() {
         VarHandle doubleHandle = MemoryHandles.varHandle(double.class, ByteOrder.nativeOrder());
         MemoryHandles.asAddressVarHandle(doubleHandle);
     }
 
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadAdaptBoolean() {
+        VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle boolHandle = MethodHandles.filterValue(intHandle, BOOL_TO_INT, INT_TO_BOOL);
+        MemoryHandles.asAddressVarHandle(boolHandle);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadAdaptString() {
+        VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle stringHandle = MethodHandles.filterValue(intHandle, STRING_TO_INT, INT_TO_STRING);
+        MemoryHandles.asAddressVarHandle(stringHandle);
+    }
+
     @DataProvider(name = "addressHandles")
     static Object[][] addressHandles() {
         return new Object[][] {
                 // long
                 { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder())) },
@@ -106,6 +141,22 @@
                 { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder())) },
                 { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder()), 0)) },
                 { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_BYTE.varHandle(byte.class)) }
         };
     }
+
+    static int boolToInt(boolean value) {
+        return value ? 1 : 0;
+    }
+
+    static boolean intToBool(int value) {
+        return value != 0;
+    }
+
+    static int stringToInt(String value) {
+        return value.length();
+    }
+
+    static String intToString(int value) {
+        return String.valueOf(value);
+    }
 }
diff a/test/jdk/java/foreign/TestVarHandleCombinators.java b/test/jdk/java/foreign/TestVarHandleCombinators.java
--- a/test/jdk/java/foreign/TestVarHandleCombinators.java
+++ b/test/jdk/java/foreign/TestVarHandleCombinators.java
@@ -60,14 +60,17 @@
         vh = MemoryHandles.withStride(vh, 2);
         MemorySegment segment = MemorySegment.ofArray(new byte[4]);
         vh.get(segment.baseAddress(), 1L); //should throw
     }
 
-    @Test(expectedExceptions = IllegalArgumentException.class)
-    public void testBadStrideElement() {
+    public void testZeroStrideElement() {
         VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
-        MemoryHandles.withStride(vh, 0); //scale factor cant be zero
+        VarHandle strided_vh = MemoryHandles.withStride(vh, 0);
+        MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
+        for (int i = 0 ; i < 100 ; i++) {
+            assertEquals((int)vh.get(segment.baseAddress()), strided_vh.get(segment.baseAddress(), (long)i));
+        }
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testStrideWrongHandle() {
         VarHandle vh = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());
@@ -104,14 +107,17 @@
         MemoryAddress address = segment.baseAddress();
 
         vh.set(address, (byte) 10); // should be bad align
     }
 
-    @Test(expectedExceptions = IllegalArgumentException.class)
-    public void testOffsetNegative() {
-        VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
-        MemoryHandles.withOffset(vh, -1);
+    public void testZeroOffsetElement() {
+        VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle offset_vh = MemoryHandles.withOffset(vh, 0);
+        MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
+        for (int i = 0 ; i < 100 ; i++) {
+            assertEquals((int)vh.get(segment.baseAddress()), offset_vh.get(segment.baseAddress(), (long)i));
+        }
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testOffsetWrongHandle() {
         VarHandle vh = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());

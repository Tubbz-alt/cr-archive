<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BindingInterpreter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../test/jdk/java/foreign/Cstring.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
163     }
164 
165     /**
166      * Takes a MethodHandle that returns a MemorySegment, and adapts it to take an input buffer as a first argument
167      * (a MemoryAddress), and upon invocation, copies the contents of the returned MemorySegment into the input buffer
168      * passed as the first argument.
169      *
170      * @param target the target handle to adapt
171      * @return the adapted handle
172      */
173     public static MethodHandle adaptUpcallForIMR(MethodHandle target) {
174         if (target.type().returnType() != MemorySegment.class)
175             throw new IllegalArgumentException(&quot;Must return MemorySegment for IMR&quot;);
176 
177         target = collectArguments(MH_BUFFER_COPY, 1, target); // (MemoryAddress, ...) MemoryAddress
178 
179         return target;
180     }
181 
182     private static MemoryAddress bufferCopy(MemoryAddress dest, MemorySegment buffer) {
<span class="line-modified">183         MemoryAddress.copy(buffer.baseAddress(),</span>
<span class="line-modified">184                 MemoryAddressImpl.ofLongUnchecked(dest.toRawLongValue(), buffer.byteSize()),</span>
<span class="line-removed">185                 buffer.byteSize());</span>
186         return dest;
187     }
188 
189     private static void checkCompatibleType(Class&lt;?&gt; carrier, MemoryLayout layout, long addressSize) {
190         if (carrier.isPrimitive()) {
191             Utils.checkPrimitiveCarrierCompat(carrier, layout);
192         } else if (carrier == MemoryAddress.class) {
193             Utils.checkLayoutType(layout, ValueLayout.class);
194             if (layout.bitSize() != addressSize)
195                 throw new IllegalArgumentException(&quot;Address size mismatch: &quot; + addressSize + &quot; != &quot; + layout.bitSize());
196         } else if(carrier == MemorySegment.class) {
197            Utils.checkLayoutType(layout, GroupLayout.class);
198         } else {
199             throw new IllegalArgumentException(&quot;Unsupported carrier: &quot; + carrier);
200         }
201     }
202 
203     public static void checkFunctionTypes(MethodType mt, FunctionDescriptor cDesc, long addressSize) {
204         if (mt.returnType() == void.class != cDesc.returnLayout().isEmpty())
205             throw new IllegalArgumentException(&quot;Return type mismatch: &quot; + mt + &quot; != &quot; + cDesc);
</pre>
</td>
<td>
<hr />
<pre>
163     }
164 
165     /**
166      * Takes a MethodHandle that returns a MemorySegment, and adapts it to take an input buffer as a first argument
167      * (a MemoryAddress), and upon invocation, copies the contents of the returned MemorySegment into the input buffer
168      * passed as the first argument.
169      *
170      * @param target the target handle to adapt
171      * @return the adapted handle
172      */
173     public static MethodHandle adaptUpcallForIMR(MethodHandle target) {
174         if (target.type().returnType() != MemorySegment.class)
175             throw new IllegalArgumentException(&quot;Must return MemorySegment for IMR&quot;);
176 
177         target = collectArguments(MH_BUFFER_COPY, 1, target); // (MemoryAddress, ...) MemoryAddress
178 
179         return target;
180     }
181 
182     private static MemoryAddress bufferCopy(MemoryAddress dest, MemorySegment buffer) {
<span class="line-modified">183         MemoryAddressImpl.ofLongUnchecked(dest.toRawLongValue(), buffer.byteSize())</span>
<span class="line-modified">184                 .segment().copyFrom(buffer);</span>

185         return dest;
186     }
187 
188     private static void checkCompatibleType(Class&lt;?&gt; carrier, MemoryLayout layout, long addressSize) {
189         if (carrier.isPrimitive()) {
190             Utils.checkPrimitiveCarrierCompat(carrier, layout);
191         } else if (carrier == MemoryAddress.class) {
192             Utils.checkLayoutType(layout, ValueLayout.class);
193             if (layout.bitSize() != addressSize)
194                 throw new IllegalArgumentException(&quot;Address size mismatch: &quot; + addressSize + &quot; != &quot; + layout.bitSize());
195         } else if(carrier == MemorySegment.class) {
196            Utils.checkLayoutType(layout, GroupLayout.class);
197         } else {
198             throw new IllegalArgumentException(&quot;Unsupported carrier: &quot; + carrier);
199         }
200     }
201 
202     public static void checkFunctionTypes(MethodType mt, FunctionDescriptor cDesc, long addressSize) {
203         if (mt.returnType() == void.class != cDesc.returnLayout().isEmpty())
204             throw new IllegalArgumentException(&quot;Return type mismatch: &quot; + mt + &quot; != &quot; + cDesc);
</pre>
</td>
</tr>
</table>
<center><a href="BindingInterpreter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../test/jdk/java/foreign/Cstring.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StructBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 64     protected final ConstantHelper constantHelper;
 65     protected final TypeTranslator typeTranslator = new TypeTranslator();
 66     private final String clsName;
 67     private final String pkgName;
 68     private StructBuilder structBuilder;
 69     private Map&lt;Declaration, String&gt; structClassNames = new HashMap&lt;&gt;();
 70     private List&lt;String&gt; structSources = new ArrayList&lt;&gt;();
 71     private Set&lt;String&gt; nestedClassNames = new HashSet&lt;&gt;();
 72     private Set&lt;Declaration.Typedef&gt; unresolvedStructTypedefs = new HashSet&lt;&gt;();
 73     private int nestedClassNameCount = 0;
 74     /*
 75      * We may have case-insensitive name collision! A C program may have
 76      * defined structs/unions/typedefs with the names FooS, fooS, FoOs, fOOs.
 77      * Because we map structs/unions/typedefs to nested classes of header classes,
 78      * such a case-insensitive name collision is problematic. This is because in
 79      * a case-insensitive file system javac will overwrite classes for
 80      * Header$CFooS, Header$CfooS, Header$CFoOs and so on! We solve this by
 81      * generating unique case-insensitive names for nested classes.
 82      */
 83     private String uniqueNestedClassName(String name) {

 84         return nestedClassNames.add(name.toLowerCase())? name : (name + &quot;$&quot; + nestedClassNameCount++);
 85     }
 86 
 87     private String structClassName(Declaration decl) {
<span class="line-modified"> 88         return structClassNames.computeIfAbsent(decl, d -&gt; uniqueNestedClassName(&quot;C&quot; + d.name()));</span>
 89     }
 90 
 91     private boolean structDefinitionSeen(Declaration decl) {
 92         return structClassNames.containsKey(decl);
 93     }
 94 
 95     // have we seen this Variable earlier?
 96     protected boolean variableSeen(Declaration.Variable tree) {
 97         return !variables.add(tree);
 98     }
 99 
100     // have we seen this Function earlier?
101     protected boolean functionSeen(Declaration.Function tree) {
102         return !functions.add(tree);
103     }
104 
105     static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String clsName, String pkgName, List&lt;String&gt; libraryNames) {
106         String qualName = pkgName.isEmpty() ? clsName : pkgName + &quot;.&quot; + clsName;
107         ConstantHelper constantHelper = new ConstantHelper(qualName,
108                 ClassDesc.of(pkgName, &quot;RuntimeHelper&quot;), ClassDesc.of(pkgName, &quot;Cstring&quot;),
</pre>
<hr />
<pre>
129             case CSupport.AArch64.NAME:
130                 return prefix + &quot;AArch64&quot;;
131             default:
132                 throw new UnsupportedOperationException(&quot;Unsupported ABI: &quot; + abi);
133         }
134     }
135 
136     static final String C_LANG_CONSTANTS_HOLDER = getCLangConstantsHolder();
137 
138     public JavaFileObject[] generate(Declaration.Scoped decl) {
139         builder.classBegin();
140         //generate all decls
141         decl.members().forEach(this::generateDecl);
142         for (String src : structSources) {
143             builder.addContent(src);
144         }
145         // check if unresolved typedefs can be resolved now!
146         for (Declaration.Typedef td : unresolvedStructTypedefs) {
147             Declaration.Scoped structDef = ((Type.Declared)td.type()).tree();
148             if (structDefinitionSeen(structDef)) {
<span class="line-modified">149                 builder.emitTypedef(uniqueNestedClassName(&quot;C&quot; + td.name()), structClassName(structDef));</span>
150             }
151         }
152         builder.classEnd();
153         try {
154             List&lt;JavaFileObject&gt; files = new ArrayList&lt;&gt;();
155             files.add(builder.build());
156             files.addAll(constantHelper.getClasses());
157             files.add(fileFromString(pkgName,&quot;RuntimeHelper&quot;, getRuntimeHelperSource()));
158             files.add(getCstringFile(pkgName));
159             files.add(getCpointerFile(pkgName));
160             files.addAll(getPrimitiveTypeFiles(pkgName));
161             return files.toArray(new JavaFileObject[0]);
162         } catch (IOException ex) {
163             throw new UncheckedIOException(ex);
164         } catch (URISyntaxException ex2) {
165             throw new RuntimeException(ex2);
166         }
167     }
168 
169     private String getRuntimeHelperSource() throws URISyntaxException, IOException {
</pre>
<hr />
<pre>
341             Declaration.Scoped s = ((Type.Declared) type).tree();
342             if (!s.name().equals(tree.name())) {
343                 switch (s.kind()) {
344                     case STRUCT:
345                     case UNION: {
346                         if (s.name().isEmpty()) {
347                             visitScoped(s, tree);
348                         } else {
349                             /*
350                              * If typedef is seen after the struct/union definition, we can generate subclass
351                              * right away. If not, we&#39;ve to save it and revisit after all the declarations are
352                              * seen. This is to support forward declaration of typedefs.
353                              *
354                              * typedef struct Foo Bar;
355                              *
356                              * struct Foo {
357                              *     int x, y;
358                              * };
359                              */
360                             if (structDefinitionSeen(s)) {
<span class="line-modified">361                                 builder.emitTypedef(uniqueNestedClassName(&quot;C&quot; + tree.name()), structClassName(s));</span>
362                             } else {
363                                 /*
364                                  * Definition of typedef&#39;ed struct/union not seen yet. May be the definition comes later.
365                                  * Save it to visit at the end of all declarations.
366                                  */
367                                 unresolvedStructTypedefs.add(tree);
368                             }
369                         }
370                     }
371                     break;
372                     default:
373                         visitScoped(s, tree);
374                 }
375             }
376         } else if (type instanceof Type.Primitive) {
<span class="line-modified">377              builder.emitPrimitiveTypedef((Type.Primitive)type, uniqueNestedClassName(&quot;C&quot; + tree.name()));</span>
378         }
379         return null;
380     }
381 
382     @Override
383     public Void visitVariable(Declaration.Variable tree, Declaration parent) {
384         if (parent == null &amp;&amp; variableSeen(tree)) {
385             return null;
386         }
387 
388         String fieldName = tree.name();
389         String symbol = tree.name();
390         assert !symbol.isEmpty();
391         assert !fieldName.isEmpty();
392         fieldName = Utils.javaSafeIdentifier(fieldName);
393 
394         Type type = tree.type();
395         MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));
396         if (layout == null) {
397             //no layout - abort
</pre>
</td>
<td>
<hr />
<pre>
 64     protected final ConstantHelper constantHelper;
 65     protected final TypeTranslator typeTranslator = new TypeTranslator();
 66     private final String clsName;
 67     private final String pkgName;
 68     private StructBuilder structBuilder;
 69     private Map&lt;Declaration, String&gt; structClassNames = new HashMap&lt;&gt;();
 70     private List&lt;String&gt; structSources = new ArrayList&lt;&gt;();
 71     private Set&lt;String&gt; nestedClassNames = new HashSet&lt;&gt;();
 72     private Set&lt;Declaration.Typedef&gt; unresolvedStructTypedefs = new HashSet&lt;&gt;();
 73     private int nestedClassNameCount = 0;
 74     /*
 75      * We may have case-insensitive name collision! A C program may have
 76      * defined structs/unions/typedefs with the names FooS, fooS, FoOs, fOOs.
 77      * Because we map structs/unions/typedefs to nested classes of header classes,
 78      * such a case-insensitive name collision is problematic. This is because in
 79      * a case-insensitive file system javac will overwrite classes for
 80      * Header$CFooS, Header$CfooS, Header$CFoOs and so on! We solve this by
 81      * generating unique case-insensitive names for nested classes.
 82      */
 83     private String uniqueNestedClassName(String name) {
<span class="line-added"> 84         name = Utils.javaSafeIdentifier(name);</span>
 85         return nestedClassNames.add(name.toLowerCase())? name : (name + &quot;$&quot; + nestedClassNameCount++);
 86     }
 87 
 88     private String structClassName(Declaration decl) {
<span class="line-modified"> 89         return structClassNames.computeIfAbsent(decl, d -&gt; uniqueNestedClassName(d.name()));</span>
 90     }
 91 
 92     private boolean structDefinitionSeen(Declaration decl) {
 93         return structClassNames.containsKey(decl);
 94     }
 95 
 96     // have we seen this Variable earlier?
 97     protected boolean variableSeen(Declaration.Variable tree) {
 98         return !variables.add(tree);
 99     }
100 
101     // have we seen this Function earlier?
102     protected boolean functionSeen(Declaration.Function tree) {
103         return !functions.add(tree);
104     }
105 
106     static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String clsName, String pkgName, List&lt;String&gt; libraryNames) {
107         String qualName = pkgName.isEmpty() ? clsName : pkgName + &quot;.&quot; + clsName;
108         ConstantHelper constantHelper = new ConstantHelper(qualName,
109                 ClassDesc.of(pkgName, &quot;RuntimeHelper&quot;), ClassDesc.of(pkgName, &quot;Cstring&quot;),
</pre>
<hr />
<pre>
130             case CSupport.AArch64.NAME:
131                 return prefix + &quot;AArch64&quot;;
132             default:
133                 throw new UnsupportedOperationException(&quot;Unsupported ABI: &quot; + abi);
134         }
135     }
136 
137     static final String C_LANG_CONSTANTS_HOLDER = getCLangConstantsHolder();
138 
139     public JavaFileObject[] generate(Declaration.Scoped decl) {
140         builder.classBegin();
141         //generate all decls
142         decl.members().forEach(this::generateDecl);
143         for (String src : structSources) {
144             builder.addContent(src);
145         }
146         // check if unresolved typedefs can be resolved now!
147         for (Declaration.Typedef td : unresolvedStructTypedefs) {
148             Declaration.Scoped structDef = ((Type.Declared)td.type()).tree();
149             if (structDefinitionSeen(structDef)) {
<span class="line-modified">150                 builder.emitTypedef(uniqueNestedClassName(td.name()), structClassName(structDef));</span>
151             }
152         }
153         builder.classEnd();
154         try {
155             List&lt;JavaFileObject&gt; files = new ArrayList&lt;&gt;();
156             files.add(builder.build());
157             files.addAll(constantHelper.getClasses());
158             files.add(fileFromString(pkgName,&quot;RuntimeHelper&quot;, getRuntimeHelperSource()));
159             files.add(getCstringFile(pkgName));
160             files.add(getCpointerFile(pkgName));
161             files.addAll(getPrimitiveTypeFiles(pkgName));
162             return files.toArray(new JavaFileObject[0]);
163         } catch (IOException ex) {
164             throw new UncheckedIOException(ex);
165         } catch (URISyntaxException ex2) {
166             throw new RuntimeException(ex2);
167         }
168     }
169 
170     private String getRuntimeHelperSource() throws URISyntaxException, IOException {
</pre>
<hr />
<pre>
342             Declaration.Scoped s = ((Type.Declared) type).tree();
343             if (!s.name().equals(tree.name())) {
344                 switch (s.kind()) {
345                     case STRUCT:
346                     case UNION: {
347                         if (s.name().isEmpty()) {
348                             visitScoped(s, tree);
349                         } else {
350                             /*
351                              * If typedef is seen after the struct/union definition, we can generate subclass
352                              * right away. If not, we&#39;ve to save it and revisit after all the declarations are
353                              * seen. This is to support forward declaration of typedefs.
354                              *
355                              * typedef struct Foo Bar;
356                              *
357                              * struct Foo {
358                              *     int x, y;
359                              * };
360                              */
361                             if (structDefinitionSeen(s)) {
<span class="line-modified">362                                 builder.emitTypedef(uniqueNestedClassName(tree.name()), structClassName(s));</span>
363                             } else {
364                                 /*
365                                  * Definition of typedef&#39;ed struct/union not seen yet. May be the definition comes later.
366                                  * Save it to visit at the end of all declarations.
367                                  */
368                                 unresolvedStructTypedefs.add(tree);
369                             }
370                         }
371                     }
372                     break;
373                     default:
374                         visitScoped(s, tree);
375                 }
376             }
377         } else if (type instanceof Type.Primitive) {
<span class="line-modified">378              builder.emitPrimitiveTypedef((Type.Primitive)type, uniqueNestedClassName(tree.name()));</span>
379         }
380         return null;
381     }
382 
383     @Override
384     public Void visitVariable(Declaration.Variable tree, Declaration parent) {
385         if (parent == null &amp;&amp; variableSeen(tree)) {
386             return null;
387         }
388 
389         String fieldName = tree.name();
390         String symbol = tree.name();
391         assert !symbol.isEmpty();
392         assert !fieldName.isEmpty();
393         fieldName = Utils.javaSafeIdentifier(fieldName);
394 
395         Type type = tree.type();
396         MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));
397         if (layout == null) {
398             //no layout - abort
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StructBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OutputFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 23  * questions.
 24  */
 25 package jdk.incubator.jextract.tool;
 26 
 27 import jdk.incubator.foreign.FunctionDescriptor;
 28 import java.lang.invoke.MethodType;
 29 import java.util.ArrayList;
 30 import java.util.List;
 31 import jdk.incubator.jextract.Type;
 32 
 33 /**
 34  * A helper class to generate header interface class in source form.
 35  * After aggregating various constituents of a .java source, build
 36  * method is called to get overall generated source string.
 37  */
 38 class HeaderBuilder extends JavaSourceBuilder {
 39     HeaderBuilder(String className, String pkgName, ConstantHelper constantHelper) {
 40         super(className, pkgName, constantHelper);
 41     }
 42 
<span class="line-removed"> 43     private String getArrayTypeName(Class&lt;?&gt; type) {</span>
<span class="line-removed"> 44         assert type.isArray();</span>
<span class="line-removed"> 45         Class&lt;?&gt; elemType = type.getComponentType();</span>
<span class="line-removed"> 46         return elemType.isArray()? getArrayTypeName(elemType) + &quot;[]&quot; : elemType.getName() + &quot;[]&quot;;</span>
<span class="line-removed"> 47     }</span>
<span class="line-removed"> 48 </span>
 49     public void addFunctionalInterface(String name, MethodType mtype,  FunctionDescriptor fDesc) {
 50         incrAlign();
 51         indent();
 52         sb.append(&quot;public interface &quot; + name + &quot; {\n&quot;);
 53         incrAlign();
 54         indent();
 55         sb.append(mtype.returnType().getName() + &quot; apply(&quot;);
 56         String delim = &quot;&quot;;
 57         for (int i = 0 ; i &lt; mtype.parameterCount(); i++) {
<span class="line-modified"> 58             Class&lt;?&gt; paramType = mtype.parameterType(i);</span>
<span class="line-removed"> 59             if (paramType.isArray()) {</span>
<span class="line-removed"> 60                 sb.append(delim + getArrayTypeName(paramType) + &quot; x&quot; + i);</span>
<span class="line-removed"> 61             } else {</span>
<span class="line-removed"> 62                 sb.append(delim + paramType.getName() + &quot; x&quot; + i);</span>
<span class="line-removed"> 63             }</span>
 64             delim = &quot;, &quot;;
 65         }
 66         sb.append(&quot;);\n&quot;);
 67         addFunctionalFactory(name, mtype, fDesc);
 68         decrAlign();
 69         indent();
 70         sb.append(&quot;}\n&quot;);
 71         decrAlign();
 72         indent();
 73     }
 74 
 75     public void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List&lt;String&gt; paramNames) {
 76         incrAlign();
 77         indent();
 78         sb.append(PUB_MODS + mtype.returnType().getName() + &quot; &quot; + javaName + &quot; (&quot;);
 79         String delim = &quot;&quot;;
 80         List&lt;String&gt; pNames = new ArrayList&lt;&gt;();
 81         final int numParams = paramNames.size();
 82         for (int i = 0 ; i &lt; numParams; i++) {
 83             String pName = paramNames.get(i);
 84             if (pName.isEmpty()) {
 85                 pName = &quot;x&quot; + i;
 86             }
 87             pNames.add(pName);
<span class="line-modified"> 88             Class&lt;?&gt; paramType = mtype.parameterType(i);</span>
<span class="line-removed"> 89             sb.append(delim + (paramType.isArray()? getArrayTypeName(paramType) : paramType.getName()) + &quot; &quot; + pName);</span>
 90             delim = &quot;, &quot;;
 91         }
 92         if (varargs) {
 93             String lastArg = &quot;x&quot; + numParams;
 94             if (numParams &gt; 0) {
 95                 sb.append(&quot;, &quot;);
 96             }
 97             sb.append(&quot;Object... &quot; + lastArg);
 98             pNames.add(lastArg);
 99         }
100         sb.append(&quot;) {\n&quot;);
101         incrAlign();
102         indent();
103         sb.append(&quot;try {\n&quot;);
104         incrAlign();
105         indent();
106         if (!mtype.returnType().equals(void.class)) {
107             sb.append(&quot;return (&quot; + mtype.returnType().getName() + &quot;)&quot;);
108         }
109         sb.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + &quot;.invokeExact(&quot; + String.join(&quot;, &quot;, pNames) + &quot;);\n&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 23  * questions.
 24  */
 25 package jdk.incubator.jextract.tool;
 26 
 27 import jdk.incubator.foreign.FunctionDescriptor;
 28 import java.lang.invoke.MethodType;
 29 import java.util.ArrayList;
 30 import java.util.List;
 31 import jdk.incubator.jextract.Type;
 32 
 33 /**
 34  * A helper class to generate header interface class in source form.
 35  * After aggregating various constituents of a .java source, build
 36  * method is called to get overall generated source string.
 37  */
 38 class HeaderBuilder extends JavaSourceBuilder {
 39     HeaderBuilder(String className, String pkgName, ConstantHelper constantHelper) {
 40         super(className, pkgName, constantHelper);
 41     }
 42 






 43     public void addFunctionalInterface(String name, MethodType mtype,  FunctionDescriptor fDesc) {
 44         incrAlign();
 45         indent();
 46         sb.append(&quot;public interface &quot; + name + &quot; {\n&quot;);
 47         incrAlign();
 48         indent();
 49         sb.append(mtype.returnType().getName() + &quot; apply(&quot;);
 50         String delim = &quot;&quot;;
 51         for (int i = 0 ; i &lt; mtype.parameterCount(); i++) {
<span class="line-modified"> 52             sb.append(delim + mtype.parameterType(i).getName() + &quot; x&quot; + i);</span>





 53             delim = &quot;, &quot;;
 54         }
 55         sb.append(&quot;);\n&quot;);
 56         addFunctionalFactory(name, mtype, fDesc);
 57         decrAlign();
 58         indent();
 59         sb.append(&quot;}\n&quot;);
 60         decrAlign();
 61         indent();
 62     }
 63 
 64     public void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List&lt;String&gt; paramNames) {
 65         incrAlign();
 66         indent();
 67         sb.append(PUB_MODS + mtype.returnType().getName() + &quot; &quot; + javaName + &quot; (&quot;);
 68         String delim = &quot;&quot;;
 69         List&lt;String&gt; pNames = new ArrayList&lt;&gt;();
 70         final int numParams = paramNames.size();
 71         for (int i = 0 ; i &lt; numParams; i++) {
 72             String pName = paramNames.get(i);
 73             if (pName.isEmpty()) {
 74                 pName = &quot;x&quot; + i;
 75             }
 76             pNames.add(pName);
<span class="line-modified"> 77             sb.append(delim + mtype.parameterType(i).getName() + &quot; &quot; + pName);</span>

 78             delim = &quot;, &quot;;
 79         }
 80         if (varargs) {
 81             String lastArg = &quot;x&quot; + numParams;
 82             if (numParams &gt; 0) {
 83                 sb.append(&quot;, &quot;);
 84             }
 85             sb.append(&quot;Object... &quot; + lastArg);
 86             pNames.add(lastArg);
 87         }
 88         sb.append(&quot;) {\n&quot;);
 89         incrAlign();
 90         indent();
 91         sb.append(&quot;try {\n&quot;);
 92         incrAlign();
 93         indent();
 94         if (!mtype.returnType().equals(void.class)) {
 95             sb.append(&quot;return (&quot; + mtype.returnType().getName() + &quot;)&quot;);
 96         }
 97         sb.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + &quot;.invokeExact(&quot; + String.join(&quot;, &quot;, pNames) + &quot;);\n&quot;);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OutputFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
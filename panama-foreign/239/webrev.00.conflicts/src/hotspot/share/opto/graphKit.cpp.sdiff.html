<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/graphKit.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/hotspot/share/opto/graphKit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciUtilities.hpp&quot;

  27 #include &quot;classfile/javaClasses.hpp&quot;





  28 #include &quot;compiler/compileLog.hpp&quot;
  29 #include &quot;gc/shared/barrierSet.hpp&quot;
  30 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;memory/resourceArea.hpp&quot;
  33 #include &quot;opto/addnode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/convertnode.hpp&quot;
  36 #include &quot;opto/graphKit.hpp&quot;
  37 #include &quot;opto/idealKit.hpp&quot;
  38 #include &quot;opto/intrinsicnode.hpp&quot;
  39 #include &quot;opto/locknode.hpp&quot;
  40 #include &quot;opto/machnode.hpp&quot;
  41 #include &quot;opto/opaquenode.hpp&quot;
  42 #include &quot;opto/parse.hpp&quot;
  43 #include &quot;opto/rootnode.hpp&quot;
  44 #include &quot;opto/runtime.hpp&quot;
  45 #include &quot;opto/subtypenode.hpp&quot;
  46 #include &quot;runtime/deoptimization.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;utilities/bitMap.inline.hpp&quot;
  49 #include &quot;utilities/powerOfTwo.hpp&quot;

  50 
  51 //----------------------------GraphKit-----------------------------------------
  52 // Main utility constructor.
  53 GraphKit::GraphKit(JVMState* jvms)
  54   : Phase(Phase::Parser),
  55     _env(C-&gt;env()),
  56     _gvn(*C-&gt;initial_gvn()),
  57     _barrier_set(BarrierSet::barrier_set()-&gt;barrier_set_c2())
  58 {
  59   _exceptions = jvms-&gt;map()-&gt;next_exception();
  60   if (_exceptions != NULL)  jvms-&gt;map()-&gt;set_next_exception(NULL);
  61   set_jvms(jvms);
  62 }
  63 
  64 // Private constructor for parser.
  65 GraphKit::GraphKit()
  66   : Phase(Phase::Parser),
  67     _env(C-&gt;env()),
  68     _gvn(*C-&gt;initial_gvn()),
  69     _barrier_set(BarrierSet::barrier_set()-&gt;barrier_set_c2())
</pre>
<hr />
<pre>
2543   }
2544 
2545   Node* c = _gvn.transform(call);
2546   assert(c == call, &quot;cannot disappear&quot;);
2547 
2548   if (wide_out) {
2549     // Slow path call has full side-effects.
2550     set_predefined_output_for_runtime_call(call);
2551   } else {
2552     // Slow path call has few side-effects, and/or sets few values.
2553     set_predefined_output_for_runtime_call(call, prev_mem, adr_type);
2554   }
2555 
2556   if (has_io) {
2557     set_i_o(_gvn.transform(new ProjNode(call, TypeFunc::I_O)));
2558   }
2559   return call;
2560 
2561 }
2562 
































































































































2563 //------------------------------merge_memory-----------------------------------
2564 // Merge memory from one path into the current memory state.
2565 void GraphKit::merge_memory(Node* new_mem, Node* region, int new_path) {
2566   for (MergeMemStream mms(merged_memory(), new_mem-&gt;as_MergeMem()); mms.next_non_empty2(); ) {
2567     Node* old_slice = mms.force_memory();
2568     Node* new_slice = mms.memory2();
2569     if (old_slice != new_slice) {
2570       PhiNode* phi;
2571       if (old_slice-&gt;is_Phi() &amp;&amp; old_slice-&gt;as_Phi()-&gt;region() == region) {
2572         if (mms.is_empty()) {
2573           // clone base memory Phi&#39;s inputs for this memory slice
2574           assert(old_slice == mms.base_memory(), &quot;sanity&quot;);
2575           phi = PhiNode::make(region, NULL, Type::MEMORY, mms.adr_type(C));
2576           _gvn.set_type(phi, Type::MEMORY);
2577           for (uint i = 1; i &lt; phi-&gt;req(); i++) {
2578             phi-&gt;init_req(i, old_slice-&gt;in(i));
2579           }
2580         } else {
2581           phi = old_slice-&gt;as_Phi(); // Phi was generated already
2582         }
</pre>
</td>
<td>
<hr />
<pre>
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciUtilities.hpp&quot;
<span class="line-added">  27 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
  28 #include &quot;classfile/javaClasses.hpp&quot;
<span class="line-added">  29 =======</span>
<span class="line-added">  30 #include &quot;ci/ciNativeEntryPoint.hpp&quot;</span>
<span class="line-added">  31 #include &quot;ci/ciObjArray.hpp&quot;</span>
<span class="line-added">  32 #include &quot;asm/register.hpp&quot;</span>
<span class="line-added">  33 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 27368a8b78142d4a66f19daaf9094a0e320d06c0</span>
  34 #include &quot;compiler/compileLog.hpp&quot;
  35 #include &quot;gc/shared/barrierSet.hpp&quot;
  36 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  37 #include &quot;interpreter/interpreter.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;opto/addnode.hpp&quot;
  40 #include &quot;opto/castnode.hpp&quot;
  41 #include &quot;opto/convertnode.hpp&quot;
  42 #include &quot;opto/graphKit.hpp&quot;
  43 #include &quot;opto/idealKit.hpp&quot;
  44 #include &quot;opto/intrinsicnode.hpp&quot;
  45 #include &quot;opto/locknode.hpp&quot;
  46 #include &quot;opto/machnode.hpp&quot;
  47 #include &quot;opto/opaquenode.hpp&quot;
  48 #include &quot;opto/parse.hpp&quot;
  49 #include &quot;opto/rootnode.hpp&quot;
  50 #include &quot;opto/runtime.hpp&quot;
  51 #include &quot;opto/subtypenode.hpp&quot;
  52 #include &quot;runtime/deoptimization.hpp&quot;
  53 #include &quot;runtime/sharedRuntime.hpp&quot;
  54 #include &quot;utilities/bitMap.inline.hpp&quot;
  55 #include &quot;utilities/powerOfTwo.hpp&quot;
<span class="line-added">  56 #include &quot;utilities/growableArray.hpp&quot;</span>
  57 
  58 //----------------------------GraphKit-----------------------------------------
  59 // Main utility constructor.
  60 GraphKit::GraphKit(JVMState* jvms)
  61   : Phase(Phase::Parser),
  62     _env(C-&gt;env()),
  63     _gvn(*C-&gt;initial_gvn()),
  64     _barrier_set(BarrierSet::barrier_set()-&gt;barrier_set_c2())
  65 {
  66   _exceptions = jvms-&gt;map()-&gt;next_exception();
  67   if (_exceptions != NULL)  jvms-&gt;map()-&gt;set_next_exception(NULL);
  68   set_jvms(jvms);
  69 }
  70 
  71 // Private constructor for parser.
  72 GraphKit::GraphKit()
  73   : Phase(Phase::Parser),
  74     _env(C-&gt;env()),
  75     _gvn(*C-&gt;initial_gvn()),
  76     _barrier_set(BarrierSet::barrier_set()-&gt;barrier_set_c2())
</pre>
<hr />
<pre>
2550   }
2551 
2552   Node* c = _gvn.transform(call);
2553   assert(c == call, &quot;cannot disappear&quot;);
2554 
2555   if (wide_out) {
2556     // Slow path call has full side-effects.
2557     set_predefined_output_for_runtime_call(call);
2558   } else {
2559     // Slow path call has few side-effects, and/or sets few values.
2560     set_predefined_output_for_runtime_call(call, prev_mem, adr_type);
2561   }
2562 
2563   if (has_io) {
2564     set_i_o(_gvn.transform(new ProjNode(call, TypeFunc::I_O)));
2565   }
2566   return call;
2567 
2568 }
2569 
<span class="line-added">2570 // i2b</span>
<span class="line-added">2571 Node* GraphKit::sign_extend_byte(Node* in) {</span>
<span class="line-added">2572   Node* tmp = _gvn.transform(new LShiftINode(in, _gvn.intcon(24)));</span>
<span class="line-added">2573   return _gvn.transform(new RShiftINode(tmp, _gvn.intcon(24)));</span>
<span class="line-added">2574 }</span>
<span class="line-added">2575 </span>
<span class="line-added">2576 // i2s</span>
<span class="line-added">2577 Node* GraphKit::sign_extend_short(Node* in) {</span>
<span class="line-added">2578   Node* tmp = _gvn.transform(new LShiftINode(in, _gvn.intcon(16)));</span>
<span class="line-added">2579   return _gvn.transform(new RShiftINode(tmp, _gvn.intcon(16)));</span>
<span class="line-added">2580 }</span>
<span class="line-added">2581 </span>
<span class="line-added">2582 //-----------------------------make_native_call-------------------------------</span>
<span class="line-added">2583 Node* GraphKit::make_native_call(const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep) {</span>
<span class="line-added">2584   uint n_filtered_args = nargs - 2; // -fallback, -nep;</span>
<span class="line-added">2585   ResourceMark rm;</span>
<span class="line-added">2586   Node** argument_nodes = NEW_RESOURCE_ARRAY(Node*, n_filtered_args);</span>
<span class="line-added">2587   const Type** arg_types = NEW_RESOURCE_ARRAY(const Type*, n_filtered_args);</span>
<span class="line-added">2588   GrowableArray&lt;VMReg&gt; arg_regs(C-&gt;comp_arena(), n_filtered_args, n_filtered_args, VMRegImpl::Bad());</span>
<span class="line-added">2589 </span>
<span class="line-added">2590   VMReg* argRegs = nep-&gt;argMoves();</span>
<span class="line-added">2591   {</span>
<span class="line-added">2592     for (uint vm_arg_pos = 0, java_arg_read_pos = 0;</span>
<span class="line-added">2593         vm_arg_pos &lt; n_filtered_args; vm_arg_pos++) {</span>
<span class="line-added">2594       uint vm_unfiltered_arg_pos = vm_arg_pos + 1; // +1 to skip fallback handle argument</span>
<span class="line-added">2595       Node* node = argument(vm_unfiltered_arg_pos);</span>
<span class="line-added">2596       const Type* type = call_type-&gt;domain()-&gt;field_at(TypeFunc::Parms + vm_unfiltered_arg_pos);</span>
<span class="line-added">2597       VMReg reg = type == Type::HALF</span>
<span class="line-added">2598         ? VMRegImpl::Bad()</span>
<span class="line-added">2599         : argRegs[java_arg_read_pos++];</span>
<span class="line-added">2600 </span>
<span class="line-added">2601       argument_nodes[vm_arg_pos] = node;</span>
<span class="line-added">2602       arg_types[vm_arg_pos] = type;</span>
<span class="line-added">2603       arg_regs.at_put(vm_arg_pos, reg);</span>
<span class="line-added">2604     }</span>
<span class="line-added">2605   }</span>
<span class="line-added">2606 </span>
<span class="line-added">2607   uint n_returns = call_type-&gt;range()-&gt;cnt() - TypeFunc::Parms;</span>
<span class="line-added">2608   GrowableArray&lt;VMReg&gt; ret_regs(C-&gt;comp_arena(), n_returns, n_returns, VMRegImpl::Bad());</span>
<span class="line-added">2609   const Type** ret_types = NEW_RESOURCE_ARRAY(const Type*, n_returns);</span>
<span class="line-added">2610 </span>
<span class="line-added">2611   VMReg* retRegs = nep-&gt;returnMoves();</span>
<span class="line-added">2612   {</span>
<span class="line-added">2613     for (uint vm_ret_pos = 0, java_ret_read_pos = 0;</span>
<span class="line-added">2614         vm_ret_pos &lt; n_returns; vm_ret_pos++) { // 0 or 1</span>
<span class="line-added">2615       const Type* type = call_type-&gt;range()-&gt;field_at(TypeFunc::Parms + vm_ret_pos);</span>
<span class="line-added">2616       VMReg reg = type == Type::HALF</span>
<span class="line-added">2617         ? VMRegImpl::Bad()</span>
<span class="line-added">2618         : retRegs[java_ret_read_pos++];</span>
<span class="line-added">2619 </span>
<span class="line-added">2620       ret_regs.at_put(vm_ret_pos, reg);</span>
<span class="line-added">2621       ret_types[vm_ret_pos] = type;</span>
<span class="line-added">2622     }</span>
<span class="line-added">2623   }</span>
<span class="line-added">2624 </span>
<span class="line-added">2625   const TypeFunc* new_call_type = TypeFunc::make(</span>
<span class="line-added">2626     TypeTuple::make_func(n_filtered_args, arg_types),</span>
<span class="line-added">2627     TypeTuple::make_func(n_returns, ret_types)</span>
<span class="line-added">2628   );</span>
<span class="line-added">2629 </span>
<span class="line-added">2630   address call_addr = nep-&gt;entry_point();</span>
<span class="line-added">2631   if (nep-&gt;need_transition()) {</span>
<span class="line-added">2632     call_addr = SharedRuntime::make_native_invoker(call_addr,</span>
<span class="line-added">2633                                                    nep-&gt;shadow_space(),</span>
<span class="line-added">2634                                                    arg_regs, ret_regs);</span>
<span class="line-added">2635     C-&gt;add_native_stub(call_addr);</span>
<span class="line-added">2636   }</span>
<span class="line-added">2637   assert(call_addr != NULL, &quot;sanity&quot;);</span>
<span class="line-added">2638 </span>
<span class="line-added">2639   CallNativeNode* call = new CallNativeNode(new_call_type, call_addr, nep-&gt;name(), TypePtr::BOTTOM,</span>
<span class="line-added">2640                                             arg_regs,</span>
<span class="line-added">2641                                             ret_regs,</span>
<span class="line-added">2642                                             nep-&gt;shadow_space(),</span>
<span class="line-added">2643                                             nep-&gt;need_transition());</span>
<span class="line-added">2644 </span>
<span class="line-added">2645   if (call-&gt;_need_transition) {</span>
<span class="line-added">2646     add_safepoint_edges(call);</span>
<span class="line-added">2647   }</span>
<span class="line-added">2648 </span>
<span class="line-added">2649   set_predefined_input_for_runtime_call(call);</span>
<span class="line-added">2650 </span>
<span class="line-added">2651   for (uint i = 0; i &lt; n_filtered_args; i++) {</span>
<span class="line-added">2652     call-&gt;init_req(i + TypeFunc::Parms, argument_nodes[i]);</span>
<span class="line-added">2653   }</span>
<span class="line-added">2654 </span>
<span class="line-added">2655   Node* c = gvn().transform(call);</span>
<span class="line-added">2656   assert(c == call, &quot;cannot disappear&quot;);</span>
<span class="line-added">2657 </span>
<span class="line-added">2658   set_predefined_output_for_runtime_call(call);</span>
<span class="line-added">2659 </span>
<span class="line-added">2660   Node* ret;</span>
<span class="line-added">2661   if (method() == NULL || method()-&gt;return_type()-&gt;basic_type() == T_VOID) {</span>
<span class="line-added">2662     ret = top();</span>
<span class="line-added">2663   } else {</span>
<span class="line-added">2664     Node* current_value = NULL;</span>
<span class="line-added">2665     for (uint vm_ret_pos = 0; vm_ret_pos &lt; n_returns; vm_ret_pos++) {</span>
<span class="line-added">2666       if (new_call_type-&gt;range()-&gt;field_at(TypeFunc::Parms + vm_ret_pos)  == Type::HALF) {</span>
<span class="line-added">2667         // FIXME is this needed?</span>
<span class="line-added">2668         gvn().transform(new ProjNode(call, TypeFunc::Parms + vm_ret_pos));</span>
<span class="line-added">2669       } else {</span>
<span class="line-added">2670         assert(current_value == NULL, &quot;Must not overwrite&quot;);</span>
<span class="line-added">2671         current_value = gvn().transform(new ProjNode(call, TypeFunc::Parms + vm_ret_pos));</span>
<span class="line-added">2672       }</span>
<span class="line-added">2673     }</span>
<span class="line-added">2674     assert(current_value != NULL, &quot;Should not be null&quot;);</span>
<span class="line-added">2675     // Unpack native results if needed</span>
<span class="line-added">2676     // Need this method type since it&#39;s unerased</span>
<span class="line-added">2677     switch (nep-&gt;method_type()-&gt;rtype()-&gt;basic_type()) {</span>
<span class="line-added">2678       case T_CHAR:</span>
<span class="line-added">2679         current_value = _gvn.transform(new AndINode(current_value, _gvn.intcon(0xFFFF)));</span>
<span class="line-added">2680         break;</span>
<span class="line-added">2681       case T_BYTE:</span>
<span class="line-added">2682         current_value = sign_extend_byte(current_value);</span>
<span class="line-added">2683         break;</span>
<span class="line-added">2684       case T_SHORT:</span>
<span class="line-added">2685         current_value = sign_extend_short(current_value);</span>
<span class="line-added">2686         break;</span>
<span class="line-added">2687       default: // do nothing</span>
<span class="line-added">2688         break;</span>
<span class="line-added">2689     }</span>
<span class="line-added">2690     ret = current_value;</span>
<span class="line-added">2691   }</span>
<span class="line-added">2692 </span>
<span class="line-added">2693   push_node(method()-&gt;return_type()-&gt;basic_type(), ret);</span>
<span class="line-added">2694 </span>
<span class="line-added">2695   return call;</span>
<span class="line-added">2696 }</span>
<span class="line-added">2697 </span>
2698 //------------------------------merge_memory-----------------------------------
2699 // Merge memory from one path into the current memory state.
2700 void GraphKit::merge_memory(Node* new_mem, Node* region, int new_path) {
2701   for (MergeMemStream mms(merged_memory(), new_mem-&gt;as_MergeMem()); mms.next_non_empty2(); ) {
2702     Node* old_slice = mms.force_memory();
2703     Node* new_slice = mms.memory2();
2704     if (old_slice != new_slice) {
2705       PhiNode* phi;
2706       if (old_slice-&gt;is_Phi() &amp;&amp; old_slice-&gt;as_Phi()-&gt;region() == region) {
2707         if (mms.is_empty()) {
2708           // clone base memory Phi&#39;s inputs for this memory slice
2709           assert(old_slice == mms.base_memory(), &quot;sanity&quot;);
2710           phi = PhiNode::make(region, NULL, Type::MEMORY, mms.adr_type(C));
2711           _gvn.set_type(phi, Type::MEMORY);
2712           for (uint i = 1; i &lt; phi-&gt;req(); i++) {
2713             phi-&gt;init_req(i, old_slice-&gt;in(i));
2714           }
2715         } else {
2716           phi = old_slice-&gt;as_Phi(); // Phi was generated already
2717         }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacPkgBundler.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MacDmgBundler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="resources/MacResources_ja.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacPkgBundler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
<span class="line-removed"> 28 import java.io.File;</span>
 29 import java.io.IOException;
 30 import java.io.PrintWriter;
 31 import java.net.URI;
 32 import java.net.URISyntaxException;
 33 import java.nio.file.Files;
 34 import java.nio.file.Path;
 35 import java.text.MessageFormat;
 36 import java.util.ArrayList;
 37 import java.util.HashMap;
 38 import java.util.List;
 39 import java.util.Map;
 40 import java.util.Objects;
 41 import java.util.Optional;
 42 import java.util.ResourceBundle;
 43 
 44 import static jdk.incubator.jpackage.internal.StandardBundlerParam.CONFIG_ROOT;
 45 import static jdk.incubator.jpackage.internal.StandardBundlerParam.TEMP_ROOT;
 46 import static jdk.incubator.jpackage.internal.StandardBundlerParam.VERBOSE;
 47 import static jdk.incubator.jpackage.internal.StandardBundlerParam.APP_NAME;
 48 import static jdk.incubator.jpackage.internal.StandardBundlerParam.LICENSE_FILE;
 49 import static jdk.incubator.jpackage.internal.StandardBundlerParam.VERSION;
 50 import static jdk.incubator.jpackage.internal.MacBaseInstallerBundler.SIGNING_KEYCHAIN;
 51 import static jdk.incubator.jpackage.internal.MacBaseInstallerBundler.SIGNING_KEY_USER;
 52 import static jdk.incubator.jpackage.internal.MacAppImageBuilder.MAC_CF_BUNDLE_IDENTIFIER;
 53 import static jdk.incubator.jpackage.internal.OverridableResource.createResource;
 54 
 55 public class MacPkgBundler extends MacBaseInstallerBundler {
 56 
 57     private static final ResourceBundle I18N = ResourceBundle.getBundle(
 58             &quot;jdk.incubator.jpackage.internal.resources.MacResources&quot;);
 59 
 60     private static final String DEFAULT_BACKGROUND_IMAGE = &quot;background_pkg.png&quot;;
 61 
 62     private static final String TEMPLATE_PREINSTALL_SCRIPT =
 63             &quot;preinstall.template&quot;;
 64     private static final String TEMPLATE_POSTINSTALL_SCRIPT =
 65             &quot;postinstall.template&quot;;
 66 
<span class="line-modified"> 67     private static final BundlerParamInfo&lt;File&gt; PACKAGES_ROOT =</span>
 68             new StandardBundlerParam&lt;&gt;(
 69             &quot;mac.pkg.packagesRoot&quot;,
<span class="line-modified"> 70             File.class,</span>
 71             params -&gt; {
<span class="line-modified"> 72                 File packagesRoot =</span>
<span class="line-modified"> 73                         new File(TEMP_ROOT.fetchFrom(params), &quot;packages&quot;);</span>
<span class="line-modified"> 74                 packagesRoot.mkdirs();</span>




 75                 return packagesRoot;
 76             },
<span class="line-modified"> 77             (s, p) -&gt; new File(s));</span>
 78 
 79 
<span class="line-modified"> 80     protected final BundlerParamInfo&lt;File&gt; SCRIPTS_DIR =</span>
 81             new StandardBundlerParam&lt;&gt;(
 82             &quot;mac.pkg.scriptsDir&quot;,
<span class="line-modified"> 83             File.class,</span>
 84             params -&gt; {
<span class="line-modified"> 85                 File scriptsDir =</span>
<span class="line-modified"> 86                         new File(CONFIG_ROOT.fetchFrom(params), &quot;scripts&quot;);</span>
<span class="line-modified"> 87                 scriptsDir.mkdirs();</span>




 88                 return scriptsDir;
 89             },
<span class="line-modified"> 90             (s, p) -&gt; new File(s));</span>
 91 
 92     public static final
 93             BundlerParamInfo&lt;String&gt; DEVELOPER_ID_INSTALLER_SIGNING_KEY =
 94             new StandardBundlerParam&lt;&gt;(
 95             &quot;mac.signing-key-developer-id-installer&quot;,
 96             String.class,
 97             params -&gt; {
 98                     String result = MacBaseInstallerBundler.findKey(
 99                             &quot;Developer ID Installer: &quot;
100                             + SIGNING_KEY_USER.fetchFrom(params),
101                             SIGNING_KEYCHAIN.fetchFrom(params),
102                             VERBOSE.fetchFrom(params));
103                     if (result != null) {
104                         MacCertificate certificate = new MacCertificate(result);
105 
106                         if (!certificate.isValid()) {
107                             Log.error(MessageFormat.format(
108                                     I18N.getString(&quot;error.certificate.expired&quot;),
109                                     result));
110                         }
111                     }
112 
113                     return result;
114                 },
115             (s, p) -&gt; s);
116 
117     public static final BundlerParamInfo&lt;String&gt; INSTALLER_SUFFIX =
118             new StandardBundlerParam&lt;&gt; (
119             &quot;mac.pkg.installerName.suffix&quot;,
120             String.class,
121             params -&gt; &quot;&quot;,
122             (s, p) -&gt; s);
123 
<span class="line-modified">124     public File bundle(Map&lt;String, ? super Object&gt; params,</span>
<span class="line-modified">125             File outdir) throws PackagerException {</span>
126         Log.verbose(MessageFormat.format(I18N.getString(&quot;message.building-pkg&quot;),
127                 APP_NAME.fetchFrom(params)));
128 
<span class="line-modified">129         IOUtils.writableOutputDir(outdir.toPath());</span>
130 
131         try {
<span class="line-modified">132             File appImageDir = prepareAppBundle(params);</span>
133 
134             if (appImageDir != null &amp;&amp; prepareConfigFiles(params)) {
135 
<span class="line-modified">136                 File configScript = getConfig_Script(params);</span>
<span class="line-modified">137                 if (configScript.exists()) {</span>
138                     Log.verbose(MessageFormat.format(I18N.getString(
139                             &quot;message.running-script&quot;),
<span class="line-modified">140                             configScript.getAbsolutePath()));</span>
141                     IOUtils.run(&quot;bash&quot;, configScript);
142                 }
143 
144                 return createPKG(params, outdir, appImageDir);
145             }
146             return null;
147         } catch (IOException ex) {
148             Log.verbose(ex);
149             throw new PackagerException(ex);
150         }
151     }
152 
<span class="line-modified">153     private File getPackages_AppPackage(Map&lt;String, ? super Object&gt; params) {</span>
<span class="line-modified">154         return new File(PACKAGES_ROOT.fetchFrom(params),</span>
155                 APP_NAME.fetchFrom(params) + &quot;-app.pkg&quot;);
156     }
157 
<span class="line-modified">158     private File getConfig_DistributionXMLFile(</span>
159             Map&lt;String, ? super Object&gt; params) {
<span class="line-modified">160         return new File(CONFIG_ROOT.fetchFrom(params), &quot;distribution.dist&quot;);</span>
161     }
162 
<span class="line-modified">163     private File getConfig_BackgroundImage(Map&lt;String, ? super Object&gt; params) {</span>
<span class="line-modified">164         return new File(CONFIG_ROOT.fetchFrom(params),</span>
165                 APP_NAME.fetchFrom(params) + &quot;-background.png&quot;);
166     }
167 
<span class="line-modified">168     private File getConfig_BackgroundImageDarkAqua(Map&lt;String, ? super Object&gt; params) {</span>
<span class="line-modified">169         return new File(CONFIG_ROOT.fetchFrom(params),</span>
170                 APP_NAME.fetchFrom(params) + &quot;-background-darkAqua.png&quot;);
171     }
172 
<span class="line-modified">173     private File getScripts_PreinstallFile(Map&lt;String, ? super Object&gt; params) {</span>
<span class="line-modified">174         return new File(SCRIPTS_DIR.fetchFrom(params), &quot;preinstall&quot;);</span>
175     }
176 
<span class="line-modified">177     private File getScripts_PostinstallFile(</span>
178             Map&lt;String, ? super Object&gt; params) {
<span class="line-modified">179         return new File(SCRIPTS_DIR.fetchFrom(params), &quot;postinstall&quot;);</span>
180     }
181 
182     private String getAppIdentifier(Map&lt;String, ? super Object&gt; params) {
183         return MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params);
184     }
185 
186     private void preparePackageScripts(Map&lt;String, ? super Object&gt; params)
187             throws IOException {
188         Log.verbose(I18N.getString(&quot;message.preparing-scripts&quot;));
189 
190         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
191 
192         Path appLocation = Path.of(getInstallDir(params),
193                          APP_NAME.fetchFrom(params) + &quot;.app&quot;, &quot;Contents&quot;, &quot;app&quot;);
194 
195         data.put(&quot;INSTALL_LOCATION&quot;, getInstallDir(params));
196         data.put(&quot;APP_LOCATION&quot;, appLocation.toString());
197 
198         createResource(TEMPLATE_PREINSTALL_SCRIPT, params)
199                 .setCategory(I18N.getString(&quot;resource.pkg-preinstall-script&quot;))
200                 .setSubstitutionData(data)
201                 .saveToFile(getScripts_PreinstallFile(params));
<span class="line-modified">202         getScripts_PreinstallFile(params).setExecutable(true, false);</span>
203 
204         createResource(TEMPLATE_POSTINSTALL_SCRIPT, params)
205                 .setCategory(I18N.getString(&quot;resource.pkg-postinstall-script&quot;))
206                 .setSubstitutionData(data)
207                 .saveToFile(getScripts_PostinstallFile(params));
<span class="line-modified">208         getScripts_PostinstallFile(params).setExecutable(true, false);</span>
209     }
210 
211     private static String URLEncoding(String pkgName) throws URISyntaxException {
212         URI uri = new URI(null, null, pkgName, null);
213         return uri.toASCIIString();
214     }
215 
216     private void prepareDistributionXMLFile(Map&lt;String, ? super Object&gt; params)
217             throws IOException {
<span class="line-modified">218         File f = getConfig_DistributionXMLFile(params);</span>
219 
220         Log.verbose(MessageFormat.format(I18N.getString(
<span class="line-modified">221                 &quot;message.preparing-distribution-dist&quot;), f.getAbsolutePath()));</span>
222 
<span class="line-modified">223         IOUtils.createXml(f.toPath(), xml -&gt; {</span>
224             xml.writeStartElement(&quot;installer-gui-script&quot;);
225             xml.writeAttribute(&quot;minSpecVersion&quot;, &quot;1&quot;);
226 
227             xml.writeStartElement(&quot;title&quot;);
228             xml.writeCharacters(APP_NAME.fetchFrom(params));
229             xml.writeEndElement();
230 
231             xml.writeStartElement(&quot;background&quot;);
<span class="line-modified">232             xml.writeAttribute(&quot;file&quot;, getConfig_BackgroundImage(params).getName());</span>

233             xml.writeAttribute(&quot;mime-type&quot;, &quot;image/png&quot;);
234             xml.writeAttribute(&quot;alignment&quot;, &quot;bottomleft&quot;);
235             xml.writeAttribute(&quot;scaling&quot;, &quot;none&quot;);
236             xml.writeEndElement();
237 
238             xml.writeStartElement(&quot;background-darkAqua&quot;);
<span class="line-modified">239             xml.writeAttribute(&quot;file&quot;, getConfig_BackgroundImageDarkAqua(params).getName());</span>

240             xml.writeAttribute(&quot;mime-type&quot;, &quot;image/png&quot;);
241             xml.writeAttribute(&quot;alignment&quot;, &quot;bottomleft&quot;);
242             xml.writeAttribute(&quot;scaling&quot;, &quot;none&quot;);
243             xml.writeEndElement();
244 
245             String licFileStr = LICENSE_FILE.fetchFrom(params);
246             if (licFileStr != null) {
<span class="line-modified">247                 File licFile = new File(licFileStr);</span>
248                 xml.writeStartElement(&quot;license&quot;);
<span class="line-modified">249                 xml.writeAttribute(&quot;file&quot;, licFile.getAbsolutePath());</span>
250                 xml.writeAttribute(&quot;mime-type&quot;, &quot;text/rtf&quot;);
251                 xml.writeEndElement();
252             }
253 
254             /*
255              * Note that the content of the distribution file
256              * below is generated by productbuild --synthesize
257              */
258             String appId = getAppIdentifier(params);
259 
260             xml.writeStartElement(&quot;pkg-ref&quot;);
261             xml.writeAttribute(&quot;id&quot;, appId);
262             xml.writeEndElement(); // &lt;/pkg-ref&gt;
263             xml.writeStartElement(&quot;options&quot;);
264             xml.writeAttribute(&quot;customize&quot;, &quot;never&quot;);
265             xml.writeAttribute(&quot;require-scripts&quot;, &quot;false&quot;);
266             xml.writeEndElement(); // &lt;/options&gt;
267             xml.writeStartElement(&quot;choices-outline&quot;);
268             xml.writeStartElement(&quot;line&quot;);
269             xml.writeAttribute(&quot;choice&quot;, &quot;default&quot;);
</pre>
<hr />
<pre>
271             xml.writeAttribute(&quot;choice&quot;, appId);
272             xml.writeEndElement(); // &lt;/line&gt;
273             xml.writeEndElement(); // &lt;/line&gt;
274             xml.writeEndElement(); // &lt;/choices-outline&gt;
275             xml.writeStartElement(&quot;choice&quot;);
276             xml.writeAttribute(&quot;id&quot;, &quot;default&quot;);
277             xml.writeEndElement(); // &lt;/choice&gt;
278             xml.writeStartElement(&quot;choice&quot;);
279             xml.writeAttribute(&quot;id&quot;, appId);
280             xml.writeAttribute(&quot;visible&quot;, &quot;false&quot;);
281             xml.writeStartElement(&quot;pkg-ref&quot;);
282             xml.writeAttribute(&quot;id&quot;, appId);
283             xml.writeEndElement(); // &lt;/pkg-ref&gt;
284             xml.writeEndElement(); // &lt;/choice&gt;
285             xml.writeStartElement(&quot;pkg-ref&quot;);
286             xml.writeAttribute(&quot;id&quot;, appId);
287             xml.writeAttribute(&quot;version&quot;, VERSION.fetchFrom(params));
288             xml.writeAttribute(&quot;onConclusion&quot;, &quot;none&quot;);
289             try {
290                 xml.writeCharacters(URLEncoding(
<span class="line-modified">291                         getPackages_AppPackage(params).getName()));</span>
292             } catch (URISyntaxException ex) {
293                 throw new IOException(ex);
294             }
295             xml.writeEndElement(); // &lt;/pkg-ref&gt;
296 
297             xml.writeEndElement(); // &lt;/installer-gui-script&gt;
298         });
299     }
300 
301     private boolean prepareConfigFiles(Map&lt;String, ? super Object&gt; params)
302             throws IOException {
303 
304         createResource(DEFAULT_BACKGROUND_IMAGE, params)
305                 .setCategory(I18N.getString(&quot;resource.pkg-background-image&quot;))
306                 .saveToFile(getConfig_BackgroundImage(params));
307 
308         createResource(DEFAULT_BACKGROUND_IMAGE, params)
309                 .setCategory(I18N.getString(&quot;resource.pkg-background-image&quot;))
310                 .saveToFile(getConfig_BackgroundImageDarkAqua(params));
311 
312         prepareDistributionXMLFile(params);
313 
314         createResource(null, params)
315                 .setCategory(I18N.getString(&quot;resource.post-install-script&quot;))
316                 .saveToFile(getConfig_Script(params));
317 
318         return true;
319     }
320 
321     // name of post-image script
<span class="line-modified">322     private File getConfig_Script(Map&lt;String, ? super Object&gt; params) {</span>
<span class="line-modified">323         return new File(CONFIG_ROOT.fetchFrom(params),</span>
324                 APP_NAME.fetchFrom(params) + &quot;-post-image.sh&quot;);
325     }
326 
<span class="line-modified">327     private void patchCPLFile(File cpl) throws IOException {</span>
<span class="line-modified">328         String cplData = Files.readString(cpl.toPath());</span>
329         String[] lines = cplData.split(&quot;\n&quot;);
<span class="line-modified">330         try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(</span>
<span class="line-removed">331                 cpl.toPath()))) {</span>
332             int skip = 0;
333             // Used to skip Java.runtime bundle, since
334             // pkgbuild with --root will find two bundles app and Java runtime.
335             // We cannot generate component proprty list when using
336             // --component argument.
337             for (int i = 0; i &lt; lines.length; i++) {
338                 if (lines[i].trim().equals(&quot;&lt;key&gt;BundleIsRelocatable&lt;/key&gt;&quot;)) {
339                     out.println(lines[i]);
340                     out.println(&quot;&lt;false/&gt;&quot;);
341                     i++;
342                 } else if (lines[i].trim().equals(&quot;&lt;key&gt;ChildBundles&lt;/key&gt;&quot;)) {
343                     ++skip;
344                 } else if ((skip &gt; 0) &amp;&amp; lines[i].trim().equals(&quot;&lt;/array&gt;&quot;)) {
345                     --skip;
346                 } else {
347                     if (skip == 0) {
348                         out.println(lines[i]);
349                     }
350                 }
351             }
352         }
353     }
354 
355     // pkgbuild includes all components from &quot;--root&quot; and subfolders,
356     // so if we have app image in folder which contains other images, then they
357     // will be included as well. It does have &quot;--filter&quot; option which use regex
358     // to exclude files/folder, but it will overwrite default one which excludes
359     // based on doc &quot;any .svn or CVS directories, and any .DS_Store files&quot;.
360     // So easy aproach will be to copy user provided app-image into temp folder
361     // if root path contains other files.
362     private String getRoot(Map&lt;String, ? super Object&gt; params,
<span class="line-modified">363             File appLocation) throws IOException {</span>
<span class="line-modified">364         String root = appLocation.getParent() == null ?</span>
<span class="line-modified">365                 &quot;.&quot; : appLocation.getParent();</span>
<span class="line-removed">366         File rootDir = new File(root);</span>
367 
<span class="line-modified">368         File[] list = rootDir.listFiles();</span>
369         if (list != null) { // Should not happend
370             // We should only have app image and/or .DS_Store
371             if (list.length == 1) {
<span class="line-modified">372                 return root;</span>
373             } else if (list.length == 2) {
374                 // Check case with app image and .DS_Store
375                 if (list[0].toString().toLowerCase().endsWith(&quot;.ds_store&quot;) ||
376                     list[1].toString().toLowerCase().endsWith(&quot;.ds_store&quot;)) {
<span class="line-modified">377                     return root; // Only app image and .DS_Store</span>
378                 }
379             }
380         }
381 
382         // Copy to new root
383         Path newRoot = Files.createTempDirectory(
<span class="line-modified">384                 TEMP_ROOT.fetchFrom(params).toPath(), &quot;root-&quot;);</span>
385 
386         Path source, dest;
387 
388         if (StandardBundlerParam.isRuntimeInstaller(params)) {
389             // firs, is this already a runtime with
390             // &lt;runtime&gt;/Contents/Home - if so we need the Home dir
<span class="line-modified">391             Path original = appLocation.toPath();</span>
392             Path home = original.resolve(&quot;Contents/Home&quot;);
393             source = (Files.exists(home)) ? home : original;
394 
395             // Then we need to put back the &lt;NAME&gt;/Content/Home
396             dest = newRoot.resolve(
397                 MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) + &quot;/Contents/Home&quot;);
398         } else {
<span class="line-modified">399             source = appLocation.toPath();</span>
<span class="line-modified">400             dest = newRoot.resolve(appLocation.getName());</span>
401         }
402         IOUtils.copyRecursive(source, dest);
403 
404         return newRoot.toString();
405     }
406 
<span class="line-modified">407     private File createPKG(Map&lt;String, ? super Object&gt; params,</span>
<span class="line-modified">408             File outdir, File appLocation) {</span>
409         // generic find attempt
410         try {
<span class="line-modified">411             File appPKG = getPackages_AppPackage(params);</span>
412 
413             String root = getRoot(params, appLocation);
414 
415             // Generate default CPL file
<span class="line-modified">416             File cpl = new File(CONFIG_ROOT.fetchFrom(params).getAbsolutePath()</span>
<span class="line-removed">417                     + File.separator + &quot;cpl.plist&quot;);</span>
418             ProcessBuilder pb = new ProcessBuilder(&quot;pkgbuild&quot;,
419                     &quot;--root&quot;,
420                     root,
421                     &quot;--install-location&quot;,
422                     getInstallDir(params),
423                     &quot;--analyze&quot;,
<span class="line-modified">424                     cpl.getAbsolutePath());</span>
425 
426             IOUtils.exec(pb);
427 
428             patchCPLFile(cpl);
429 
430             preparePackageScripts(params);
431 
432             // build application package
433             pb = new ProcessBuilder(&quot;pkgbuild&quot;,
434                     &quot;--root&quot;,
435                     root,
436                     &quot;--install-location&quot;,
437                     getInstallDir(params),
438                     &quot;--component-plist&quot;,
<span class="line-modified">439                     cpl.getAbsolutePath(),</span>
440                     &quot;--scripts&quot;,
<span class="line-modified">441                     SCRIPTS_DIR.fetchFrom(params).getAbsolutePath(),</span>
442                     &quot;--identifier&quot;,
443                      MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params),
<span class="line-modified">444                     appPKG.getAbsolutePath());</span>
445             IOUtils.exec(pb);
446 
447             // build final package
<span class="line-modified">448             File finalPKG = new File(outdir, INSTALLER_NAME.fetchFrom(params)</span>
449                     + INSTALLER_SUFFIX.fetchFrom(params)
450                     + &quot;.pkg&quot;);
<span class="line-modified">451             outdir.mkdirs();</span>
452 
453             List&lt;String&gt; commandLine = new ArrayList&lt;&gt;();
454             commandLine.add(&quot;productbuild&quot;);
455 
456             commandLine.add(&quot;--resources&quot;);
<span class="line-modified">457             commandLine.add(CONFIG_ROOT.fetchFrom(params).getAbsolutePath());</span>
458 
459             // maybe sign
460             if (Optional.ofNullable(MacAppImageBuilder.
461                     SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.TRUE)) {
462                 if (Platform.getMajorVersion() &gt; 10 ||
463                     (Platform.getMajorVersion() == 10 &amp;&amp;
464                     Platform.getMinorVersion() &gt;= 12)) {
465                     // we need this for OS X 10.12+
466                     Log.verbose(I18N.getString(&quot;message.signing.pkg&quot;));
467                 }
468 
469                 String signingIdentity =
470                         DEVELOPER_ID_INSTALLER_SIGNING_KEY.fetchFrom(params);
471                 if (signingIdentity != null) {
472                     commandLine.add(&quot;--sign&quot;);
473                     commandLine.add(signingIdentity);
474                 }
475 
476                 String keychainName = SIGNING_KEYCHAIN.fetchFrom(params);
477                 if (keychainName != null &amp;&amp; !keychainName.isEmpty()) {
478                     commandLine.add(&quot;--keychain&quot;);
479                     commandLine.add(keychainName);
480                 }
481             }
482 
483             commandLine.add(&quot;--distribution&quot;);
484             commandLine.add(
<span class="line-modified">485                     getConfig_DistributionXMLFile(params).getAbsolutePath());</span>
486             commandLine.add(&quot;--package-path&quot;);
<span class="line-modified">487             commandLine.add(PACKAGES_ROOT.fetchFrom(params).getAbsolutePath());</span>
488 
<span class="line-modified">489             commandLine.add(finalPKG.getAbsolutePath());</span>
490 
491             pb = new ProcessBuilder(commandLine);
492             IOUtils.exec(pb);
493 
494             return finalPKG;
495         } catch (Exception ignored) {
496             Log.verbose(ignored);
497             return null;
498         }
499     }
500 
501     //////////////////////////////////////////////////////////////////////////
502     // Implement Bundler
503     //////////////////////////////////////////////////////////////////////////
504 
505     @Override
506     public String getName() {
507         return I18N.getString(&quot;pkg.bundler.name&quot;);
508     }
509 
</pre>
<hr />
<pre>
560                             I18N.getString(&quot;error.explicit-sign-no-cert&quot;),
561                             I18N.getString(
562                             &quot;error.explicit-sign-no-cert.advice&quot;));
563                 }
564             }
565 
566             // hdiutil is always available so there&#39;s no need
567             // to test for availability.
568 
569             return true;
570         } catch (RuntimeException re) {
571             if (re.getCause() instanceof ConfigException) {
572                 throw (ConfigException) re.getCause();
573             } else {
574                 throw new ConfigException(re);
575             }
576         }
577     }
578 
579     @Override
<span class="line-modified">580     public File execute(Map&lt;String, ? super Object&gt; params,</span>
<span class="line-modified">581             File outputParentDir) throws PackagerException {</span>
582         return bundle(params, outputParentDir);
583     }
584 
585     @Override
586     public boolean supported(boolean runtimeInstaller) {
587         return true;
588     }
589 
590     @Override
591     public boolean isDefault() {
592         return false;
593     }
594 
595 }
</pre>
</td>
<td>
<hr />
<pre>
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 

 28 import java.io.IOException;
 29 import java.io.PrintWriter;
 30 import java.net.URI;
 31 import java.net.URISyntaxException;
 32 import java.nio.file.Files;
 33 import java.nio.file.Path;
 34 import java.text.MessageFormat;
 35 import java.util.ArrayList;
 36 import java.util.HashMap;
 37 import java.util.List;
 38 import java.util.Map;
 39 import java.util.Objects;
 40 import java.util.Optional;
 41 import java.util.ResourceBundle;
 42 
 43 import static jdk.incubator.jpackage.internal.StandardBundlerParam.CONFIG_ROOT;
 44 import static jdk.incubator.jpackage.internal.StandardBundlerParam.TEMP_ROOT;
 45 import static jdk.incubator.jpackage.internal.StandardBundlerParam.VERBOSE;
 46 import static jdk.incubator.jpackage.internal.StandardBundlerParam.APP_NAME;
 47 import static jdk.incubator.jpackage.internal.StandardBundlerParam.LICENSE_FILE;
 48 import static jdk.incubator.jpackage.internal.StandardBundlerParam.VERSION;
 49 import static jdk.incubator.jpackage.internal.MacBaseInstallerBundler.SIGNING_KEYCHAIN;
 50 import static jdk.incubator.jpackage.internal.MacBaseInstallerBundler.SIGNING_KEY_USER;
 51 import static jdk.incubator.jpackage.internal.MacAppImageBuilder.MAC_CF_BUNDLE_IDENTIFIER;
 52 import static jdk.incubator.jpackage.internal.OverridableResource.createResource;
 53 
 54 public class MacPkgBundler extends MacBaseInstallerBundler {
 55 
 56     private static final ResourceBundle I18N = ResourceBundle.getBundle(
 57             &quot;jdk.incubator.jpackage.internal.resources.MacResources&quot;);
 58 
 59     private static final String DEFAULT_BACKGROUND_IMAGE = &quot;background_pkg.png&quot;;
 60 
 61     private static final String TEMPLATE_PREINSTALL_SCRIPT =
 62             &quot;preinstall.template&quot;;
 63     private static final String TEMPLATE_POSTINSTALL_SCRIPT =
 64             &quot;postinstall.template&quot;;
 65 
<span class="line-modified"> 66     private static final BundlerParamInfo&lt;Path&gt; PACKAGES_ROOT =</span>
 67             new StandardBundlerParam&lt;&gt;(
 68             &quot;mac.pkg.packagesRoot&quot;,
<span class="line-modified"> 69             Path.class,</span>
 70             params -&gt; {
<span class="line-modified"> 71                 Path packagesRoot =</span>
<span class="line-modified"> 72                         TEMP_ROOT.fetchFrom(params).resolve(&quot;packages&quot;);</span>
<span class="line-modified"> 73                 try {</span>
<span class="line-added"> 74                     Files.createDirectories(packagesRoot);</span>
<span class="line-added"> 75                 } catch (IOException ioe) {</span>
<span class="line-added"> 76                     return null;</span>
<span class="line-added"> 77                 }</span>
 78                 return packagesRoot;
 79             },
<span class="line-modified"> 80             (s, p) -&gt; Path.of(s));</span>
 81 
 82 
<span class="line-modified"> 83     protected final BundlerParamInfo&lt;Path&gt; SCRIPTS_DIR =</span>
 84             new StandardBundlerParam&lt;&gt;(
 85             &quot;mac.pkg.scriptsDir&quot;,
<span class="line-modified"> 86             Path.class,</span>
 87             params -&gt; {
<span class="line-modified"> 88                 Path scriptsDir =</span>
<span class="line-modified"> 89                         CONFIG_ROOT.fetchFrom(params).resolve(&quot;scripts&quot;);</span>
<span class="line-modified"> 90                 try {</span>
<span class="line-added"> 91                     Files.createDirectories(scriptsDir);</span>
<span class="line-added"> 92                 } catch (IOException ioe) {</span>
<span class="line-added"> 93                     return null;</span>
<span class="line-added"> 94                 }</span>
 95                 return scriptsDir;
 96             },
<span class="line-modified"> 97             (s, p) -&gt; Path.of(s));</span>
 98 
 99     public static final
100             BundlerParamInfo&lt;String&gt; DEVELOPER_ID_INSTALLER_SIGNING_KEY =
101             new StandardBundlerParam&lt;&gt;(
102             &quot;mac.signing-key-developer-id-installer&quot;,
103             String.class,
104             params -&gt; {
105                     String result = MacBaseInstallerBundler.findKey(
106                             &quot;Developer ID Installer: &quot;
107                             + SIGNING_KEY_USER.fetchFrom(params),
108                             SIGNING_KEYCHAIN.fetchFrom(params),
109                             VERBOSE.fetchFrom(params));
110                     if (result != null) {
111                         MacCertificate certificate = new MacCertificate(result);
112 
113                         if (!certificate.isValid()) {
114                             Log.error(MessageFormat.format(
115                                     I18N.getString(&quot;error.certificate.expired&quot;),
116                                     result));
117                         }
118                     }
119 
120                     return result;
121                 },
122             (s, p) -&gt; s);
123 
124     public static final BundlerParamInfo&lt;String&gt; INSTALLER_SUFFIX =
125             new StandardBundlerParam&lt;&gt; (
126             &quot;mac.pkg.installerName.suffix&quot;,
127             String.class,
128             params -&gt; &quot;&quot;,
129             (s, p) -&gt; s);
130 
<span class="line-modified">131     public Path bundle(Map&lt;String, ? super Object&gt; params,</span>
<span class="line-modified">132             Path outdir) throws PackagerException {</span>
133         Log.verbose(MessageFormat.format(I18N.getString(&quot;message.building-pkg&quot;),
134                 APP_NAME.fetchFrom(params)));
135 
<span class="line-modified">136         IOUtils.writableOutputDir(outdir);</span>
137 
138         try {
<span class="line-modified">139             Path appImageDir = prepareAppBundle(params);</span>
140 
141             if (appImageDir != null &amp;&amp; prepareConfigFiles(params)) {
142 
<span class="line-modified">143                 Path configScript = getConfig_Script(params);</span>
<span class="line-modified">144                 if (IOUtils.exists(configScript)) {</span>
145                     Log.verbose(MessageFormat.format(I18N.getString(
146                             &quot;message.running-script&quot;),
<span class="line-modified">147                             configScript.toAbsolutePath().toString()));</span>
148                     IOUtils.run(&quot;bash&quot;, configScript);
149                 }
150 
151                 return createPKG(params, outdir, appImageDir);
152             }
153             return null;
154         } catch (IOException ex) {
155             Log.verbose(ex);
156             throw new PackagerException(ex);
157         }
158     }
159 
<span class="line-modified">160     private Path getPackages_AppPackage(Map&lt;String, ? super Object&gt; params) {</span>
<span class="line-modified">161         return PACKAGES_ROOT.fetchFrom(params).resolve(</span>
162                 APP_NAME.fetchFrom(params) + &quot;-app.pkg&quot;);
163     }
164 
<span class="line-modified">165     private Path getConfig_DistributionXMLFile(</span>
166             Map&lt;String, ? super Object&gt; params) {
<span class="line-modified">167         return CONFIG_ROOT.fetchFrom(params).resolve(&quot;distribution.dist&quot;);</span>
168     }
169 
<span class="line-modified">170     private Path getConfig_BackgroundImage(Map&lt;String, ? super Object&gt; params) {</span>
<span class="line-modified">171         return CONFIG_ROOT.fetchFrom(params).resolve(</span>
172                 APP_NAME.fetchFrom(params) + &quot;-background.png&quot;);
173     }
174 
<span class="line-modified">175     private Path getConfig_BackgroundImageDarkAqua(Map&lt;String, ? super Object&gt; params) {</span>
<span class="line-modified">176         return CONFIG_ROOT.fetchFrom(params).resolve(</span>
177                 APP_NAME.fetchFrom(params) + &quot;-background-darkAqua.png&quot;);
178     }
179 
<span class="line-modified">180     private Path getScripts_PreinstallFile(Map&lt;String, ? super Object&gt; params) {</span>
<span class="line-modified">181         return SCRIPTS_DIR.fetchFrom(params).resolve(&quot;preinstall&quot;);</span>
182     }
183 
<span class="line-modified">184     private Path getScripts_PostinstallFile(</span>
185             Map&lt;String, ? super Object&gt; params) {
<span class="line-modified">186         return SCRIPTS_DIR.fetchFrom(params).resolve(&quot;postinstall&quot;);</span>
187     }
188 
189     private String getAppIdentifier(Map&lt;String, ? super Object&gt; params) {
190         return MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params);
191     }
192 
193     private void preparePackageScripts(Map&lt;String, ? super Object&gt; params)
194             throws IOException {
195         Log.verbose(I18N.getString(&quot;message.preparing-scripts&quot;));
196 
197         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
198 
199         Path appLocation = Path.of(getInstallDir(params),
200                          APP_NAME.fetchFrom(params) + &quot;.app&quot;, &quot;Contents&quot;, &quot;app&quot;);
201 
202         data.put(&quot;INSTALL_LOCATION&quot;, getInstallDir(params));
203         data.put(&quot;APP_LOCATION&quot;, appLocation.toString());
204 
205         createResource(TEMPLATE_PREINSTALL_SCRIPT, params)
206                 .setCategory(I18N.getString(&quot;resource.pkg-preinstall-script&quot;))
207                 .setSubstitutionData(data)
208                 .saveToFile(getScripts_PreinstallFile(params));
<span class="line-modified">209         getScripts_PreinstallFile(params).toFile().setExecutable(true, false);</span>
210 
211         createResource(TEMPLATE_POSTINSTALL_SCRIPT, params)
212                 .setCategory(I18N.getString(&quot;resource.pkg-postinstall-script&quot;))
213                 .setSubstitutionData(data)
214                 .saveToFile(getScripts_PostinstallFile(params));
<span class="line-modified">215         getScripts_PostinstallFile(params).toFile().setExecutable(true, false);</span>
216     }
217 
218     private static String URLEncoding(String pkgName) throws URISyntaxException {
219         URI uri = new URI(null, null, pkgName, null);
220         return uri.toASCIIString();
221     }
222 
223     private void prepareDistributionXMLFile(Map&lt;String, ? super Object&gt; params)
224             throws IOException {
<span class="line-modified">225         Path f = getConfig_DistributionXMLFile(params);</span>
226 
227         Log.verbose(MessageFormat.format(I18N.getString(
<span class="line-modified">228                 &quot;message.preparing-distribution-dist&quot;), f.toAbsolutePath().toString()));</span>
229 
<span class="line-modified">230         IOUtils.createXml(f, xml -&gt; {</span>
231             xml.writeStartElement(&quot;installer-gui-script&quot;);
232             xml.writeAttribute(&quot;minSpecVersion&quot;, &quot;1&quot;);
233 
234             xml.writeStartElement(&quot;title&quot;);
235             xml.writeCharacters(APP_NAME.fetchFrom(params));
236             xml.writeEndElement();
237 
238             xml.writeStartElement(&quot;background&quot;);
<span class="line-modified">239             xml.writeAttribute(&quot;file&quot;,</span>
<span class="line-added">240                     getConfig_BackgroundImage(params).getFileName().toString());</span>
241             xml.writeAttribute(&quot;mime-type&quot;, &quot;image/png&quot;);
242             xml.writeAttribute(&quot;alignment&quot;, &quot;bottomleft&quot;);
243             xml.writeAttribute(&quot;scaling&quot;, &quot;none&quot;);
244             xml.writeEndElement();
245 
246             xml.writeStartElement(&quot;background-darkAqua&quot;);
<span class="line-modified">247             xml.writeAttribute(&quot;file&quot;,</span>
<span class="line-added">248                     getConfig_BackgroundImageDarkAqua(params).getFileName().toString());</span>
249             xml.writeAttribute(&quot;mime-type&quot;, &quot;image/png&quot;);
250             xml.writeAttribute(&quot;alignment&quot;, &quot;bottomleft&quot;);
251             xml.writeAttribute(&quot;scaling&quot;, &quot;none&quot;);
252             xml.writeEndElement();
253 
254             String licFileStr = LICENSE_FILE.fetchFrom(params);
255             if (licFileStr != null) {
<span class="line-modified">256                 Path licFile = Path.of(licFileStr);</span>
257                 xml.writeStartElement(&quot;license&quot;);
<span class="line-modified">258                 xml.writeAttribute(&quot;file&quot;, licFile.toAbsolutePath().toString());</span>
259                 xml.writeAttribute(&quot;mime-type&quot;, &quot;text/rtf&quot;);
260                 xml.writeEndElement();
261             }
262 
263             /*
264              * Note that the content of the distribution file
265              * below is generated by productbuild --synthesize
266              */
267             String appId = getAppIdentifier(params);
268 
269             xml.writeStartElement(&quot;pkg-ref&quot;);
270             xml.writeAttribute(&quot;id&quot;, appId);
271             xml.writeEndElement(); // &lt;/pkg-ref&gt;
272             xml.writeStartElement(&quot;options&quot;);
273             xml.writeAttribute(&quot;customize&quot;, &quot;never&quot;);
274             xml.writeAttribute(&quot;require-scripts&quot;, &quot;false&quot;);
275             xml.writeEndElement(); // &lt;/options&gt;
276             xml.writeStartElement(&quot;choices-outline&quot;);
277             xml.writeStartElement(&quot;line&quot;);
278             xml.writeAttribute(&quot;choice&quot;, &quot;default&quot;);
</pre>
<hr />
<pre>
280             xml.writeAttribute(&quot;choice&quot;, appId);
281             xml.writeEndElement(); // &lt;/line&gt;
282             xml.writeEndElement(); // &lt;/line&gt;
283             xml.writeEndElement(); // &lt;/choices-outline&gt;
284             xml.writeStartElement(&quot;choice&quot;);
285             xml.writeAttribute(&quot;id&quot;, &quot;default&quot;);
286             xml.writeEndElement(); // &lt;/choice&gt;
287             xml.writeStartElement(&quot;choice&quot;);
288             xml.writeAttribute(&quot;id&quot;, appId);
289             xml.writeAttribute(&quot;visible&quot;, &quot;false&quot;);
290             xml.writeStartElement(&quot;pkg-ref&quot;);
291             xml.writeAttribute(&quot;id&quot;, appId);
292             xml.writeEndElement(); // &lt;/pkg-ref&gt;
293             xml.writeEndElement(); // &lt;/choice&gt;
294             xml.writeStartElement(&quot;pkg-ref&quot;);
295             xml.writeAttribute(&quot;id&quot;, appId);
296             xml.writeAttribute(&quot;version&quot;, VERSION.fetchFrom(params));
297             xml.writeAttribute(&quot;onConclusion&quot;, &quot;none&quot;);
298             try {
299                 xml.writeCharacters(URLEncoding(
<span class="line-modified">300                         getPackages_AppPackage(params).getFileName().toString()));</span>
301             } catch (URISyntaxException ex) {
302                 throw new IOException(ex);
303             }
304             xml.writeEndElement(); // &lt;/pkg-ref&gt;
305 
306             xml.writeEndElement(); // &lt;/installer-gui-script&gt;
307         });
308     }
309 
310     private boolean prepareConfigFiles(Map&lt;String, ? super Object&gt; params)
311             throws IOException {
312 
313         createResource(DEFAULT_BACKGROUND_IMAGE, params)
314                 .setCategory(I18N.getString(&quot;resource.pkg-background-image&quot;))
315                 .saveToFile(getConfig_BackgroundImage(params));
316 
317         createResource(DEFAULT_BACKGROUND_IMAGE, params)
318                 .setCategory(I18N.getString(&quot;resource.pkg-background-image&quot;))
319                 .saveToFile(getConfig_BackgroundImageDarkAqua(params));
320 
321         prepareDistributionXMLFile(params);
322 
323         createResource(null, params)
324                 .setCategory(I18N.getString(&quot;resource.post-install-script&quot;))
325                 .saveToFile(getConfig_Script(params));
326 
327         return true;
328     }
329 
330     // name of post-image script
<span class="line-modified">331     private Path getConfig_Script(Map&lt;String, ? super Object&gt; params) {</span>
<span class="line-modified">332         return CONFIG_ROOT.fetchFrom(params).resolve(</span>
333                 APP_NAME.fetchFrom(params) + &quot;-post-image.sh&quot;);
334     }
335 
<span class="line-modified">336     private void patchCPLFile(Path cpl) throws IOException {</span>
<span class="line-modified">337         String cplData = Files.readString(cpl);</span>
338         String[] lines = cplData.split(&quot;\n&quot;);
<span class="line-modified">339         try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(cpl))) {</span>

340             int skip = 0;
341             // Used to skip Java.runtime bundle, since
342             // pkgbuild with --root will find two bundles app and Java runtime.
343             // We cannot generate component proprty list when using
344             // --component argument.
345             for (int i = 0; i &lt; lines.length; i++) {
346                 if (lines[i].trim().equals(&quot;&lt;key&gt;BundleIsRelocatable&lt;/key&gt;&quot;)) {
347                     out.println(lines[i]);
348                     out.println(&quot;&lt;false/&gt;&quot;);
349                     i++;
350                 } else if (lines[i].trim().equals(&quot;&lt;key&gt;ChildBundles&lt;/key&gt;&quot;)) {
351                     ++skip;
352                 } else if ((skip &gt; 0) &amp;&amp; lines[i].trim().equals(&quot;&lt;/array&gt;&quot;)) {
353                     --skip;
354                 } else {
355                     if (skip == 0) {
356                         out.println(lines[i]);
357                     }
358                 }
359             }
360         }
361     }
362 
363     // pkgbuild includes all components from &quot;--root&quot; and subfolders,
364     // so if we have app image in folder which contains other images, then they
365     // will be included as well. It does have &quot;--filter&quot; option which use regex
366     // to exclude files/folder, but it will overwrite default one which excludes
367     // based on doc &quot;any .svn or CVS directories, and any .DS_Store files&quot;.
368     // So easy aproach will be to copy user provided app-image into temp folder
369     // if root path contains other files.
370     private String getRoot(Map&lt;String, ? super Object&gt; params,
<span class="line-modified">371             Path appLocation) throws IOException {</span>
<span class="line-modified">372         Path rootDir = appLocation.getParent() == null ?</span>
<span class="line-modified">373                 Path.of(&quot;.&quot;) : appLocation.getParent();</span>

374 
<span class="line-modified">375         Path[] list = Files.list(rootDir).toArray(Path[]::new);</span>
376         if (list != null) { // Should not happend
377             // We should only have app image and/or .DS_Store
378             if (list.length == 1) {
<span class="line-modified">379                 return rootDir.toString();</span>
380             } else if (list.length == 2) {
381                 // Check case with app image and .DS_Store
382                 if (list[0].toString().toLowerCase().endsWith(&quot;.ds_store&quot;) ||
383                     list[1].toString().toLowerCase().endsWith(&quot;.ds_store&quot;)) {
<span class="line-modified">384                     return rootDir.toString(); // Only app image and .DS_Store</span>
385                 }
386             }
387         }
388 
389         // Copy to new root
390         Path newRoot = Files.createTempDirectory(
<span class="line-modified">391                 TEMP_ROOT.fetchFrom(params), &quot;root-&quot;);</span>
392 
393         Path source, dest;
394 
395         if (StandardBundlerParam.isRuntimeInstaller(params)) {
396             // firs, is this already a runtime with
397             // &lt;runtime&gt;/Contents/Home - if so we need the Home dir
<span class="line-modified">398             Path original = appLocation;</span>
399             Path home = original.resolve(&quot;Contents/Home&quot;);
400             source = (Files.exists(home)) ? home : original;
401 
402             // Then we need to put back the &lt;NAME&gt;/Content/Home
403             dest = newRoot.resolve(
404                 MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) + &quot;/Contents/Home&quot;);
405         } else {
<span class="line-modified">406             source = appLocation;</span>
<span class="line-modified">407             dest = newRoot.resolve(appLocation.getFileName());</span>
408         }
409         IOUtils.copyRecursive(source, dest);
410 
411         return newRoot.toString();
412     }
413 
<span class="line-modified">414     private Path createPKG(Map&lt;String, ? super Object&gt; params,</span>
<span class="line-modified">415             Path outdir, Path appLocation) {</span>
416         // generic find attempt
417         try {
<span class="line-modified">418             Path appPKG = getPackages_AppPackage(params);</span>
419 
420             String root = getRoot(params, appLocation);
421 
422             // Generate default CPL file
<span class="line-modified">423             Path cpl = CONFIG_ROOT.fetchFrom(params).resolve(&quot;cpl.plist&quot;);</span>

424             ProcessBuilder pb = new ProcessBuilder(&quot;pkgbuild&quot;,
425                     &quot;--root&quot;,
426                     root,
427                     &quot;--install-location&quot;,
428                     getInstallDir(params),
429                     &quot;--analyze&quot;,
<span class="line-modified">430                     cpl.toAbsolutePath().toString());</span>
431 
432             IOUtils.exec(pb);
433 
434             patchCPLFile(cpl);
435 
436             preparePackageScripts(params);
437 
438             // build application package
439             pb = new ProcessBuilder(&quot;pkgbuild&quot;,
440                     &quot;--root&quot;,
441                     root,
442                     &quot;--install-location&quot;,
443                     getInstallDir(params),
444                     &quot;--component-plist&quot;,
<span class="line-modified">445                     cpl.toAbsolutePath().toString(),</span>
446                     &quot;--scripts&quot;,
<span class="line-modified">447                     SCRIPTS_DIR.fetchFrom(params).toAbsolutePath().toString(),</span>
448                     &quot;--identifier&quot;,
449                      MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params),
<span class="line-modified">450                     appPKG.toAbsolutePath().toString());</span>
451             IOUtils.exec(pb);
452 
453             // build final package
<span class="line-modified">454             Path finalPKG = outdir.resolve(INSTALLER_NAME.fetchFrom(params)</span>
455                     + INSTALLER_SUFFIX.fetchFrom(params)
456                     + &quot;.pkg&quot;);
<span class="line-modified">457             Files.createDirectories(outdir);</span>
458 
459             List&lt;String&gt; commandLine = new ArrayList&lt;&gt;();
460             commandLine.add(&quot;productbuild&quot;);
461 
462             commandLine.add(&quot;--resources&quot;);
<span class="line-modified">463             commandLine.add(CONFIG_ROOT.fetchFrom(params).toAbsolutePath().toString());</span>
464 
465             // maybe sign
466             if (Optional.ofNullable(MacAppImageBuilder.
467                     SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.TRUE)) {
468                 if (Platform.getMajorVersion() &gt; 10 ||
469                     (Platform.getMajorVersion() == 10 &amp;&amp;
470                     Platform.getMinorVersion() &gt;= 12)) {
471                     // we need this for OS X 10.12+
472                     Log.verbose(I18N.getString(&quot;message.signing.pkg&quot;));
473                 }
474 
475                 String signingIdentity =
476                         DEVELOPER_ID_INSTALLER_SIGNING_KEY.fetchFrom(params);
477                 if (signingIdentity != null) {
478                     commandLine.add(&quot;--sign&quot;);
479                     commandLine.add(signingIdentity);
480                 }
481 
482                 String keychainName = SIGNING_KEYCHAIN.fetchFrom(params);
483                 if (keychainName != null &amp;&amp; !keychainName.isEmpty()) {
484                     commandLine.add(&quot;--keychain&quot;);
485                     commandLine.add(keychainName);
486                 }
487             }
488 
489             commandLine.add(&quot;--distribution&quot;);
490             commandLine.add(
<span class="line-modified">491                     getConfig_DistributionXMLFile(params).toAbsolutePath().toString());</span>
492             commandLine.add(&quot;--package-path&quot;);
<span class="line-modified">493             commandLine.add(PACKAGES_ROOT.fetchFrom(params).toAbsolutePath().toString());</span>
494 
<span class="line-modified">495             commandLine.add(finalPKG.toAbsolutePath().toString());</span>
496 
497             pb = new ProcessBuilder(commandLine);
498             IOUtils.exec(pb);
499 
500             return finalPKG;
501         } catch (Exception ignored) {
502             Log.verbose(ignored);
503             return null;
504         }
505     }
506 
507     //////////////////////////////////////////////////////////////////////////
508     // Implement Bundler
509     //////////////////////////////////////////////////////////////////////////
510 
511     @Override
512     public String getName() {
513         return I18N.getString(&quot;pkg.bundler.name&quot;);
514     }
515 
</pre>
<hr />
<pre>
566                             I18N.getString(&quot;error.explicit-sign-no-cert&quot;),
567                             I18N.getString(
568                             &quot;error.explicit-sign-no-cert.advice&quot;));
569                 }
570             }
571 
572             // hdiutil is always available so there&#39;s no need
573             // to test for availability.
574 
575             return true;
576         } catch (RuntimeException re) {
577             if (re.getCause() instanceof ConfigException) {
578                 throw (ConfigException) re.getCause();
579             } else {
580                 throw new ConfigException(re);
581             }
582         }
583     }
584 
585     @Override
<span class="line-modified">586     public Path execute(Map&lt;String, ? super Object&gt; params,</span>
<span class="line-modified">587             Path outputParentDir) throws PackagerException {</span>
588         return bundle(params, outputParentDir);
589     }
590 
591     @Override
592     public boolean supported(boolean runtimeInstaller) {
593         return true;
594     }
595 
596     @Override
597     public boolean isDefault() {
598         return false;
599     }
600 
601 }
</pre>
</td>
</tr>
</table>
<center><a href="MacDmgBundler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="resources/MacResources_ja.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
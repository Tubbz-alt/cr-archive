diff a/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacAppImageBuilder.java b/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacAppImageBuilder.java
--- a/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacAppImageBuilder.java
+++ b/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacAppImageBuilder.java
@@ -23,12 +23,10 @@
  * questions.
  */
 
 package jdk.incubator.jpackage.internal;
 
-import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.Writer;
 import java.nio.file.Files;
 import java.nio.file.Path;
@@ -118,24 +116,25 @@
 
                         return MacAppBundler.getIdentifier(params);
                     },
                     (s, p) -> s);
 
-    public static final BundlerParamInfo<File> ICON_ICNS =
+    public static final BundlerParamInfo<Path> ICON_ICNS =
             new StandardBundlerParam<>(
             "icon.icns",
-            File.class,
+            Path.class,
             params -> {
-                File f = ICON.fetchFrom(params);
-                if (f != null && !f.getName().toLowerCase().endsWith(".icns")) {
+                Path f = ICON.fetchFrom(params);
+                if (f != null && f.getFileName() != null && !f.getFileName()
+                        .toString().toLowerCase().endsWith(".icns")) {
                     Log.error(MessageFormat.format(
                             I18N.getString("message.icon-not-icns"), f));
                     return null;
                 }
                 return f;
             },
-            (s, p) -> new File(s));
+            (s, p) -> Path.of(s));
 
     public static final StandardBundlerParam<Boolean> SIGN_BUNDLE  =
             new StandardBundlerParam<>(
             Arguments.CLIOptions.MAC_SIGN.getId(),
             Boolean.class,
@@ -240,12 +239,12 @@
             throws IOException {
         Files.createDirectories(macOSDir);
 
         Map<String, ? super Object> originalParams = new HashMap<>(params);
         // Generate PkgInfo
-        File pkgInfoFile = new File(contentsDir.toFile(), "PkgInfo");
-        pkgInfoFile.createNewFile();
+        Path pkgInfoFile = contentsDir.resolve("PkgInfo");
+        Files.createFile(pkgInfoFile);
         writePkgInfo(pkgInfoFile);
 
         Path executable = macOSDir.resolve(getLauncherName(params));
 
         // create the main app launcher
@@ -288,15 +287,13 @@
                         + ".icns"));
 
         // copy file association icons
         for (Map<String, ?
                 super Object> fa : FILE_ASSOCIATIONS.fetchFrom(params)) {
-            File f = FA_ICON.fetchFrom(fa);
-            if (f != null && f.exists()) {
-                try (InputStream in2 = new FileInputStream(f)) {
-                    Files.copy(in2, resourcesDir.resolve(f.getName()));
-                }
+            Path f = FA_ICON.fetchFrom(fa);
+            if (IOUtils.exists(f)) {
+                IOUtils.copyFile(f, resourcesDir.resolve(f.getFileName()));
 
             }
         }
 
         copyRuntimeFiles(params);
@@ -304,15 +301,15 @@
     }
 
     private void copyRuntimeFiles(Map<String, ? super Object> params)
             throws IOException {
         // Generate Info.plist
-        writeInfoPlist(contentsDir.resolve("Info.plist").toFile(), params);
+        writeInfoPlist(contentsDir.resolve("Info.plist"), params);
 
         // generate java runtime info.plist
         writeRuntimeInfoPlist(
-                runtimeDir.resolve("Contents/Info.plist").toFile(), params);
+                runtimeDir.resolve("Contents/Info.plist"), params);
 
         // copy library
         Path runtimeMacOSDir = Files.createDirectories(
                 runtimeDir.resolve("Contents/MacOS"));
 
@@ -344,12 +341,12 @@
             }
             restoreKeychainList(params);
         }
     }
 
-    static File getConfig_Entitlements(Map<String, ? super Object> params) {
-        return new File(CONFIG_ROOT.fetchFrom(params),
+    static Path getConfig_Entitlements(Map<String, ? super Object> params) {
+        return CONFIG_ROOT.fetchFrom(params).resolve(
                 getLauncherName(params) + ".entitlements");
     }
 
     static void prepareEntitlements(Map<String, ? super Object> params)
             throws IOException {
@@ -380,11 +377,11 @@
             }
             return nm;
         }
     }
 
-    private void writeRuntimeInfoPlist(File file,
+    private void writeRuntimeInfoPlist(Path file,
             Map<String, ? super Object> params) throws IOException {
         Map<String, String> data = new HashMap<>();
         String identifier = StandardBundlerParam.isRuntimeInstaller(params) ?
                 MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) :
                 "com.oracle.java." + MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params);
@@ -425,14 +422,14 @@
             sb.append("  <key>").append(key).append("</key>\n").append("  <")
                     .append(value).append("/>\n").append("\n");
          }
     }
 
-    private void writeInfoPlist(File file, Map<String, ? super Object> params)
+    private void writeInfoPlist(Path file, Map<String, ? super Object> params)
             throws IOException {
         Log.verbose(MessageFormat.format(I18N.getString(
-                "message.preparing-info-plist"), file.getAbsolutePath()));
+                "message.preparing-info-plist"), file.toAbsolutePath()));
 
         //prepare config for exe
         //Note: do not need CFBundleDisplayName if we don't support localization
         Map<String, String> data = new HashMap<>();
         data.put("DEPLOY_ICON_FILE", APP_NAME.fetchFrom(params) + ".icns");
@@ -458,11 +455,11 @@
 
             String itemContentType = MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params)
                     + "." + ((extensions == null || extensions.isEmpty())
                     ? "mime" : extensions.get(0));
             String description = FA_DESCRIPTION.fetchFrom(fileAssociation);
-            File icon = FA_ICON.fetchFrom(fileAssociation);
+            Path icon = FA_ICON.fetchFrom(fileAssociation);
 
             bundleDocumentTypes.append(" <dict>\n");
             writeStringArrayPlist(bundleDocumentTypes, "LSItemContentTypes",
                     Arrays.asList(itemContentType));
             writeStringPlist(bundleDocumentTypes, "CFBundleTypeName", description);
@@ -480,13 +477,13 @@
                     FA_MAC_LSTYPEISPACKAGE.fetchFrom(fileAssociation));
             writeBoolPlist(bundleDocumentTypes, "LSSupportsOpeningDocumentsInPlace",
                     FA_MAC_LSDOCINPLACE.fetchFrom(fileAssociation));
             writeBoolPlist(bundleDocumentTypes, "UISupportsDocumentBrowser",
                     FA_MAC_UIDOCBROWSER.fetchFrom(fileAssociation));
-            if (icon != null && icon.exists()) {
+            if (IOUtils.exists(icon)) {
                 writeStringPlist(bundleDocumentTypes, "CFBundleTypeIconFile",
-                        icon.getName());
+                        icon.getFileName().toString());
             }
             bundleDocumentTypes.append("  </dict>\n");
 
             exportedTypes.append("  <dict>\n");
             writeStringPlist(exportedTypes, "UTTypeIdentifier",
@@ -494,12 +491,13 @@
             writeStringPlist(exportedTypes, "UTTypeDescription",
                     description);
             writeStringArrayPlist(exportedTypes, "UTTypeConformsTo",
                     FA_MAC_UTTYPECONFORMSTO.fetchFrom(fileAssociation));
 
-            if (icon != null && icon.exists()) {
-                writeStringPlist(exportedTypes, "UTTypeIconFile", icon.getName());
+            if (IOUtils.exists(icon)) {
+                writeStringPlist(exportedTypes, "UTTypeIconFile",
+                        icon.getFileName().toString());
             }
             exportedTypes.append("\n")
                     .append("  <key>UTTypeTagSpecification</key>\n")
                     .append("  <dict>\n")
                     .append("\n");
@@ -530,15 +528,15 @@
                 .setSubstitutionData(data)
                 .setPublicName("Info.plist")
                 .saveToFile(file);
     }
 
-    private void writePkgInfo(File file) throws IOException {
+    private void writePkgInfo(Path file) throws IOException {
         //hardcoded as it does not seem we need to change it ever
         String signature = "????";
 
-        try (Writer out = Files.newBufferedWriter(file.toPath())) {
+        try (Writer out = Files.newBufferedWriter(file)) {
             out.write(OS_TYPE_CODE + signature);
             out.flush();
         }
     }
 
@@ -555,11 +553,11 @@
         if (keyChain == null || keyChain.isEmpty()) {
             return;
         }
 
         // get current keychain list
-        String keyChainPath = new File (keyChain).getAbsolutePath().toString();
+        String keyChainPath = Path.of(keyChain).toAbsolutePath().toString();
         List<String> keychainList = new ArrayList<>();
         int ret = IOUtils.getProcessOutput(
                 keychainList, "security", "list-keychains");
         if (ret != 0) {
             Log.error(I18N.getString("message.keychain.error"));
@@ -619,11 +617,11 @@
         IOUtils.exec(pb);
     }
 
     static void signAppBundle(
             Map<String, ? super Object> params, Path appLocation,
-            String signingIdentity, String identifierPrefix, File entitlements)
+            String signingIdentity, String identifierPrefix, Path entitlements)
             throws IOException {
         AtomicReference<IOException> toThrow = new AtomicReference<>();
         String appExecutable = "/Contents/MacOS/" + APP_NAME.fetchFrom(params);
         String keyChain = SIGNING_KEYCHAIN.fetchFrom(params);
 
@@ -681,12 +679,11 @@
                     args.add(p.toString());
 
                     try {
                         Set<PosixFilePermission> oldPermissions =
                                 Files.getPosixFilePermissions(p);
-                        File f = p.toFile();
-                        f.setWritable(true, true);
+                        p.toFile().setWritable(true, true);
 
                         ProcessBuilder pb = new ProcessBuilder(args);
 
                         IOUtils.exec(pb);
 
@@ -796,21 +793,19 @@
         if (PREDEFINED_APP_IMAGE.fetchFrom(params) == null) {
             return null;
         }
 
         try {
-            File infoPList = new File(PREDEFINED_APP_IMAGE.fetchFrom(params) +
-                                      File.separator + "Contents" +
-                                      File.separator + "Info.plist");
+            Path infoPList = PREDEFINED_APP_IMAGE.fetchFrom(params).resolve("Contents").
+                    resolve("Info.plist");
 
             DocumentBuilderFactory dbf
                     = DocumentBuilderFactory.newDefaultInstance();
             dbf.setFeature("http://apache.org/xml/features/" +
                            "nonvalidating/load-external-dtd", false);
             DocumentBuilder b = dbf.newDocumentBuilder();
-            org.w3c.dom.Document doc = b.parse(new FileInputStream(
-                    infoPList.getAbsolutePath()));
+            org.w3c.dom.Document doc = b.parse(Files.newInputStream(infoPList));
 
             XPath xPath = XPathFactory.newInstance().newXPath();
             // Query for the value of <string> element preceding <key>
             // element with value equal to CFBundleIdentifier
             String v = (String) xPath.evaluate(

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jpackage/windows/classes/jdk/incubator/jpackage/internal/WinMsiBundler.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WinExeBundler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WindowsAppImageBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.jpackage/windows/classes/jdk/incubator/jpackage/internal/WinMsiBundler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
<span class="line-removed"> 28 import java.io.File;</span>
<span class="line-removed"> 29 import java.io.FileInputStream;</span>
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.Writer;
 33 import java.nio.charset.Charset;
 34 import java.nio.charset.StandardCharsets;
 35 import java.nio.file.Files;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.text.MessageFormat;
 39 import java.util.Arrays;
 40 import java.util.HashMap;
 41 import java.util.List;
 42 import java.util.Map;
 43 import java.util.UUID;
 44 import java.util.stream.Collectors;
 45 import java.util.stream.Stream;
 46 
 47 import static jdk.incubator.jpackage.internal.OverridableResource.createResource;
 48 import static jdk.incubator.jpackage.internal.StandardBundlerParam.APP_NAME;
 49 import static jdk.incubator.jpackage.internal.StandardBundlerParam.CONFIG_ROOT;
</pre>
<hr />
<pre>
 84  * &lt;li&gt;JpProductCode. Set to product code UUID of the application. Random value
 85  * generated by jpackage every time {@link #execute} method is called
 86  * &lt;li&gt;JpProductUpgradeCode. Set to upgrade code UUID of the application. Random
 87  * value generated by jpackage every time {@link #execute} method is called if
 88  * --win-upgrade-uuid command line option is not specified. Otherwise this
 89  * variable is set to the value of --win-upgrade-uuid command line option
 90  * &lt;li&gt;JpAllowDowngrades. Set to &quot;yes&quot; if --win-upgrade-uuid command line option
 91  * was specified. Undefined otherwise
 92  * &lt;li&gt;JpLicenseRtf. Set to the value of --license-file command line option.
 93  * Undefined is --license-file command line option was not specified
 94  * &lt;li&gt;JpInstallDirChooser. Set to &quot;yes&quot; if --win-dir-chooser command line
 95  * option was specified. Undefined otherwise
 96  * &lt;li&gt;JpConfigDir. Absolute path to the directory with generated WiX source
 97  * files.
 98  * &lt;li&gt;JpIsSystemWide. Set to &quot;yes&quot; if --win-per-user-install command line
 99  * option was not specified. Undefined otherwise
100  * &lt;/ul&gt;
101  */
102 public class WinMsiBundler  extends AbstractBundler {
103 
<span class="line-modified">104     public static final BundlerParamInfo&lt;File&gt; MSI_IMAGE_DIR =</span>
105             new StandardBundlerParam&lt;&gt;(
106             &quot;win.msi.imageDir&quot;,
<span class="line-modified">107             File.class,</span>
108             params -&gt; {
<span class="line-modified">109                 File imagesRoot = IMAGES_ROOT.fetchFrom(params);</span>
<span class="line-modified">110                 if (!imagesRoot.exists()) imagesRoot.mkdirs();</span>
<span class="line-modified">111                 return new File(imagesRoot, &quot;win-msi.image&quot;);</span>






112             },
113             (s, p) -&gt; null);
114 
<span class="line-modified">115     public static final BundlerParamInfo&lt;File&gt; WIN_APP_IMAGE =</span>
116             new StandardBundlerParam&lt;&gt;(
117             &quot;win.app.image&quot;,
<span class="line-modified">118             File.class,</span>
119             null,
120             (s, p) -&gt; null);
121 
122     public static final StandardBundlerParam&lt;Boolean&gt; MSI_SYSTEM_WIDE  =
123             new StandardBundlerParam&lt;&gt;(
124                     Arguments.CLIOptions.WIN_PER_USER_INSTALLATION.getId(),
125                     Boolean.class,
126                     params -&gt; true, // MSIs default to system wide
127                     // valueOf(null) is false,
128                     // and we actually do want null
129                     (s, p) -&gt; (s == null || &quot;null&quot;.equalsIgnoreCase(s))? null
130                             : Boolean.valueOf(s)
131             );
132 
133 
134     public static final StandardBundlerParam&lt;String&gt; PRODUCT_VERSION =
135             new StandardBundlerParam&lt;&gt;(
136                     &quot;win.msi.productVersion&quot;,
137                     String.class,
138                     VERSION::fetchFrom,
</pre>
<hr />
<pre>
267                 MsiVersion.of(version);
268             } catch (IllegalArgumentException ex) {
269                 throw new ConfigException(ex.getMessage(), I18N.getString(
270                         &quot;error.version-string-wrong-format.advice&quot;), ex);
271             }
272 
273             FileAssociation.verify(FileAssociation.fetchFrom(params));
274 
275             return true;
276         } catch (RuntimeException re) {
277             if (re.getCause() instanceof ConfigException) {
278                 throw (ConfigException) re.getCause();
279             } else {
280                 throw new ConfigException(re);
281             }
282         }
283     }
284 
285     private void prepareProto(Map&lt;String, ? super Object&gt; params)
286                 throws PackagerException, IOException {
<span class="line-modified">287         File appImage = StandardBundlerParam.getPredefinedAppImage(params);</span>
<span class="line-modified">288         File appDir = null;</span>
289 
290         // we either have an application image or need to build one
291         if (appImage != null) {
<span class="line-modified">292             appDir = new File(MSI_IMAGE_DIR.fetchFrom(params),</span>
<span class="line-removed">293                     APP_NAME.fetchFrom(params));</span>
294             // copy everything from appImage dir into appDir/name
<span class="line-modified">295             IOUtils.copyRecursive(appImage.toPath(), appDir.toPath());</span>
296         } else {
297             appDir = appImageBundler.execute(params, MSI_IMAGE_DIR.fetchFrom(
298                     params));
299         }
300 
301         // Configure installer icon
302         if (StandardBundlerParam.isRuntimeInstaller(params)) {
303             // Use icon from java launcher.
304             // Assume java.exe exists in Java Runtime being packed.
305             // Ignore custom icon if any as we don&#39;t want to copy anything in
306             // Java Runtime image.
307             installerIcon = ApplicationLayout.javaRuntime()
<span class="line-modified">308                     .resolveAt(appDir.toPath())</span>
309                     .runtimeDirectory()
310                     .resolve(Path.of(&quot;bin&quot;, &quot;java.exe&quot;));
311         } else {
312             installerIcon = ApplicationLayout.windowsAppImage()
<span class="line-modified">313                     .resolveAt(appDir.toPath())</span>
314                     .launchersDirectory()
315                     .resolve(APP_NAME.fetchFrom(params) + &quot;.exe&quot;);
316         }
317         installerIcon = installerIcon.toAbsolutePath();
318 
319         params.put(WIN_APP_IMAGE.getID(), appDir);
320 
321         String licenseFile = LICENSE_FILE.fetchFrom(params);
322         if (licenseFile != null) {
323             // need to copy license file to the working directory
324             // and convert to rtf if needed
<span class="line-modified">325             File lfile = new File(licenseFile);</span>
<span class="line-modified">326             File destFile = new File(CONFIG_ROOT.fetchFrom(params),</span>
<span class="line-modified">327                     lfile.getName());</span>
328 
329             IOUtils.copyFile(lfile, destFile);
<span class="line-modified">330             destFile.setWritable(true);</span>
331             ensureByMutationFileIsRTF(destFile);
332         }
333     }
334 
335     @Override
<span class="line-modified">336     public File execute(Map&lt;String, ? super Object&gt; params,</span>
<span class="line-modified">337             File outputParentDir) throws PackagerException {</span>
338 
<span class="line-modified">339         IOUtils.writableOutputDir(outputParentDir.toPath());</span>
340 
<span class="line-modified">341         Path imageDir = MSI_IMAGE_DIR.fetchFrom(params).toPath();</span>
342         try {
343             Files.createDirectories(imageDir);
344 
345             prepareProto(params);
346 
347             wixSourcesBuilder
<span class="line-modified">348             .initFromParams(WIN_APP_IMAGE.fetchFrom(params).toPath(), params)</span>
<span class="line-modified">349             .createMainFragment(CONFIG_ROOT.fetchFrom(params).toPath().resolve(</span>
350                     &quot;bundle.wxf&quot;));
351 
352             Map&lt;String, String&gt; wixVars = prepareMainProjectFile(params);
353 
354             new ScriptRunner()
355             .setDirectory(imageDir)
356             .setResourceCategoryId(&quot;resource.post-app-image-script&quot;)
357             .setScriptNameSuffix(&quot;post-image&quot;)
358             .setEnvironmentVariable(&quot;JpAppImageDir&quot;, imageDir.toAbsolutePath().toString())
359             .run(params);
360 
361             return buildMSI(params, wixVars, outputParentDir);
362         } catch (IOException ex) {
363             Log.verbose(ex);
364             throw new PackagerException(ex);
365         }
366     }
367 
368     private Map&lt;String, String&gt; prepareMainProjectFile(
369             Map&lt;String, ? super Object&gt; params) throws IOException {
</pre>
<hr />
<pre>
372         final UUID productCode = getProductCode(params);
373         final UUID upgradeCode = getUpgradeCode(params);
374 
375         data.put(&quot;JpProductCode&quot;, productCode.toString());
376         data.put(&quot;JpProductUpgradeCode&quot;, upgradeCode.toString());
377 
378         Log.verbose(MessageFormat.format(I18N.getString(&quot;message.product-code&quot;),
379                 productCode));
380         Log.verbose(MessageFormat.format(I18N.getString(&quot;message.upgrade-code&quot;),
381                 upgradeCode));
382 
383         data.put(&quot;JpAllowUpgrades&quot;, &quot;yes&quot;);
384         data.put(&quot;JpAllowDowngrades&quot;, &quot;yes&quot;);
385 
386         data.put(&quot;JpAppName&quot;, APP_NAME.fetchFrom(params));
387         data.put(&quot;JpAppDescription&quot;, DESCRIPTION.fetchFrom(params));
388         data.put(&quot;JpAppVendor&quot;, VENDOR.fetchFrom(params));
389         data.put(&quot;JpAppVersion&quot;, PRODUCT_VERSION.fetchFrom(params));
390         data.put(&quot;JpIcon&quot;, installerIcon.toString());
391 
<span class="line-modified">392         final Path configDir = CONFIG_ROOT.fetchFrom(params).toPath();</span>
393 
394         data.put(&quot;JpConfigDir&quot;, configDir.toAbsolutePath().toString());
395 
396         if (MSI_SYSTEM_WIDE.fetchFrom(params)) {
397             data.put(&quot;JpIsSystemWide&quot;, &quot;yes&quot;);
398         }
399 
400         String licenseFile = LICENSE_FILE.fetchFrom(params);
401         if (licenseFile != null) {
<span class="line-modified">402             String lname = new File(licenseFile).getName();</span>
<span class="line-modified">403             File destFile = new File(CONFIG_ROOT.fetchFrom(params), lname);</span>
<span class="line-modified">404             data.put(&quot;JpLicenseRtf&quot;, destFile.getAbsolutePath());</span>
405         }
406 
407         // Copy CA dll to include with installer
408         if (INSTALLDIR_CHOOSER.fetchFrom(params)) {
409             data.put(&quot;JpInstallDirChooser&quot;, &quot;yes&quot;);
410             String fname = &quot;wixhelper.dll&quot;;
411             try (InputStream is = OverridableResource.readDefault(fname)) {
<span class="line-modified">412                 Files.copy(is, Paths.get(</span>
<span class="line-removed">413                         CONFIG_ROOT.fetchFrom(params).getAbsolutePath(),</span>
<span class="line-removed">414                         fname));</span>
415             }
416         }
417 
418         // Copy l10n files.
419         for (String loc : Arrays.asList(&quot;en&quot;, &quot;ja&quot;, &quot;zh_CN&quot;)) {
420             String fname = &quot;MsiInstallerStrings_&quot; + loc + &quot;.wxl&quot;;
421             try (InputStream is = OverridableResource.readDefault(fname)) {
<span class="line-modified">422                 Files.copy(is, Paths.get(</span>
<span class="line-removed">423                         CONFIG_ROOT.fetchFrom(params).getAbsolutePath(),</span>
<span class="line-removed">424                         fname));</span>
425             }
426         }
427 
428         createResource(&quot;main.wxs&quot;, params)
429                 .setCategory(I18N.getString(&quot;resource.main-wix-file&quot;))
430                 .saveToFile(configDir.resolve(&quot;main.wxs&quot;));
431 
432         createResource(&quot;overrides.wxi&quot;, params)
433                 .setCategory(I18N.getString(&quot;resource.overrides-wix-file&quot;))
434                 .saveToFile(configDir.resolve(&quot;overrides.wxi&quot;));
435 
436         return data;
437     }
438 
<span class="line-modified">439     private File buildMSI(Map&lt;String, ? super Object&gt; params,</span>
<span class="line-modified">440             Map&lt;String, String&gt; wixVars, File outdir)</span>
441             throws IOException {
442 
<span class="line-modified">443         File msiOut = new File(</span>
<span class="line-removed">444                 outdir, INSTALLER_FILE_NAME.fetchFrom(params) + &quot;.msi&quot;);</span>
445 
446         Log.verbose(MessageFormat.format(I18N.getString(
<span class="line-modified">447                 &quot;message.preparing-msi-config&quot;), msiOut.getAbsolutePath()));</span>

448 
449         WixPipeline wixPipeline = new WixPipeline()
450         .setToolset(wixToolset.entrySet().stream().collect(
451                 Collectors.toMap(
452                         entry -&gt; entry.getKey(),
453                         entry -&gt; entry.getValue().path)))
<span class="line-modified">454         .setWixObjDir(TEMP_ROOT.fetchFrom(params).toPath().resolve(&quot;wixobj&quot;))</span>
<span class="line-modified">455         .setWorkDir(WIN_APP_IMAGE.fetchFrom(params).toPath())</span>
<span class="line-modified">456         .addSource(CONFIG_ROOT.fetchFrom(params).toPath().resolve(&quot;main.wxs&quot;), wixVars)</span>
<span class="line-modified">457         .addSource(CONFIG_ROOT.fetchFrom(params).toPath().resolve(&quot;bundle.wxf&quot;), null);</span>
458 
459         Log.verbose(MessageFormat.format(I18N.getString(
<span class="line-modified">460                 &quot;message.generating-msi&quot;), msiOut.getAbsolutePath()));</span>
461 
462         boolean enableLicenseUI = (LICENSE_FILE.fetchFrom(params) != null);
463         boolean enableInstalldirUI = INSTALLDIR_CHOOSER.fetchFrom(params);
464 
465         wixPipeline.addLightOptions(&quot;-sice:ICE27&quot;);
466 
467         if (!MSI_SYSTEM_WIDE.fetchFrom(params)) {
468             wixPipeline.addLightOptions(&quot;-sice:ICE91&quot;);
469         }
470         if (enableLicenseUI || enableInstalldirUI) {
471             wixPipeline.addLightOptions(&quot;-ext&quot;, &quot;WixUIExtension&quot;);
472         }
473 
474         wixPipeline.addLightOptions(&quot;-loc&quot;,
<span class="line-modified">475                 CONFIG_ROOT.fetchFrom(params).toPath().resolve(I18N.getString(</span>
476                         &quot;resource.wxl-file-name&quot;)).toAbsolutePath().toString());
477 
478         // Only needed if we using CA dll, so Wix can find it
479         if (enableInstalldirUI) {
<span class="line-modified">480             wixPipeline.addLightOptions(&quot;-b&quot;, CONFIG_ROOT.fetchFrom(params).getAbsolutePath());</span>

481         }
482 
<span class="line-modified">483         wixPipeline.buildMsi(msiOut.toPath().toAbsolutePath());</span>
484 
485         return msiOut;
486     }
487 
<span class="line-modified">488     private static void ensureByMutationFileIsRTF(File f) {</span>
<span class="line-modified">489         if (f == null || !f.isFile()) return;</span>
490 
491         try {
492             boolean existingLicenseIsRTF = false;
493 
<span class="line-modified">494             try (FileInputStream fin = new FileInputStream(f)) {</span>
495                 byte[] firstBits = new byte[7];
496 
497                 if (fin.read(firstBits) == firstBits.length) {
498                     String header = new String(firstBits);
499                     existingLicenseIsRTF = &quot;{\\rtf1\\&quot;.equals(header);
500                 }
501             }
502 
503             if (!existingLicenseIsRTF) {
<span class="line-modified">504                 List&lt;String&gt; oldLicense = Files.readAllLines(f.toPath());</span>
505                 try (Writer w = Files.newBufferedWriter(
<span class="line-modified">506                         f.toPath(), Charset.forName(&quot;Windows-1252&quot;))) {</span>
507                     w.write(&quot;{\\rtf1\\ansi\\ansicpg1252\\deff0\\deflang1033&quot;
508                             + &quot;{\\fonttbl{\\f0\\fnil\\fcharset0 Arial;}}\n&quot;
509                             + &quot;\\viewkind4\\uc1\\pard\\sa200\\sl276&quot;
510                             + &quot;\\slmult1\\lang9\\fs20 &quot;);
511                     oldLicense.forEach(l -&gt; {
512                         try {
513                             for (char c : l.toCharArray()) {
514                                 // 0x00 &lt;= ch &lt; 0x20 Escaped (\&#39;hh)
515                                 // 0x20 &lt;= ch &lt; 0x80 Raw(non - escaped) char
516                                 // 0x80 &lt;= ch &lt;= 0xFF Escaped(\ &#39;hh)
517                                 // 0x5C, 0x7B, 0x7D (special RTF characters
518                                 // \,{,})Escaped(\&#39;hh)
519                                 // ch &gt; 0xff Escaped (\\ud###?)
520                                 if (c &lt; 0x10) {
521                                     w.write(&quot;\\&#39;0&quot;);
522                                     w.write(Integer.toHexString(c));
523                                 } else if (c &gt; 0xff) {
524                                     w.write(&quot;\\ud&quot;);
525                                     w.write(Integer.toString(c));
526                                     // \\uc1 is in the header and in effect
</pre>
</td>
<td>
<hr />
<pre>
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 


 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.io.Writer;
 31 import java.nio.charset.Charset;
 32 import java.nio.charset.StandardCharsets;
 33 import java.nio.file.Files;
 34 import java.nio.file.Path;
 35 import java.nio.file.Paths;
 36 import java.text.MessageFormat;
 37 import java.util.Arrays;
 38 import java.util.HashMap;
 39 import java.util.List;
 40 import java.util.Map;
 41 import java.util.UUID;
 42 import java.util.stream.Collectors;
 43 import java.util.stream.Stream;
 44 
 45 import static jdk.incubator.jpackage.internal.OverridableResource.createResource;
 46 import static jdk.incubator.jpackage.internal.StandardBundlerParam.APP_NAME;
 47 import static jdk.incubator.jpackage.internal.StandardBundlerParam.CONFIG_ROOT;
</pre>
<hr />
<pre>
 82  * &lt;li&gt;JpProductCode. Set to product code UUID of the application. Random value
 83  * generated by jpackage every time {@link #execute} method is called
 84  * &lt;li&gt;JpProductUpgradeCode. Set to upgrade code UUID of the application. Random
 85  * value generated by jpackage every time {@link #execute} method is called if
 86  * --win-upgrade-uuid command line option is not specified. Otherwise this
 87  * variable is set to the value of --win-upgrade-uuid command line option
 88  * &lt;li&gt;JpAllowDowngrades. Set to &quot;yes&quot; if --win-upgrade-uuid command line option
 89  * was specified. Undefined otherwise
 90  * &lt;li&gt;JpLicenseRtf. Set to the value of --license-file command line option.
 91  * Undefined is --license-file command line option was not specified
 92  * &lt;li&gt;JpInstallDirChooser. Set to &quot;yes&quot; if --win-dir-chooser command line
 93  * option was specified. Undefined otherwise
 94  * &lt;li&gt;JpConfigDir. Absolute path to the directory with generated WiX source
 95  * files.
 96  * &lt;li&gt;JpIsSystemWide. Set to &quot;yes&quot; if --win-per-user-install command line
 97  * option was not specified. Undefined otherwise
 98  * &lt;/ul&gt;
 99  */
100 public class WinMsiBundler  extends AbstractBundler {
101 
<span class="line-modified">102     public static final BundlerParamInfo&lt;Path&gt; MSI_IMAGE_DIR =</span>
103             new StandardBundlerParam&lt;&gt;(
104             &quot;win.msi.imageDir&quot;,
<span class="line-modified">105             Path.class,</span>
106             params -&gt; {
<span class="line-modified">107                 Path imagesRoot = IMAGES_ROOT.fetchFrom(params);</span>
<span class="line-modified">108                 if (!Files.exists(imagesRoot)) {</span>
<span class="line-modified">109                     try {</span>
<span class="line-added">110                         Files.createDirectories(imagesRoot);</span>
<span class="line-added">111                     } catch (IOException ioe) {</span>
<span class="line-added">112                         return null;</span>
<span class="line-added">113                     }</span>
<span class="line-added">114                 }</span>
<span class="line-added">115                 return imagesRoot.resolve(&quot;win-msi.image&quot;);</span>
116             },
117             (s, p) -&gt; null);
118 
<span class="line-modified">119     public static final BundlerParamInfo&lt;Path&gt; WIN_APP_IMAGE =</span>
120             new StandardBundlerParam&lt;&gt;(
121             &quot;win.app.image&quot;,
<span class="line-modified">122             Path.class,</span>
123             null,
124             (s, p) -&gt; null);
125 
126     public static final StandardBundlerParam&lt;Boolean&gt; MSI_SYSTEM_WIDE  =
127             new StandardBundlerParam&lt;&gt;(
128                     Arguments.CLIOptions.WIN_PER_USER_INSTALLATION.getId(),
129                     Boolean.class,
130                     params -&gt; true, // MSIs default to system wide
131                     // valueOf(null) is false,
132                     // and we actually do want null
133                     (s, p) -&gt; (s == null || &quot;null&quot;.equalsIgnoreCase(s))? null
134                             : Boolean.valueOf(s)
135             );
136 
137 
138     public static final StandardBundlerParam&lt;String&gt; PRODUCT_VERSION =
139             new StandardBundlerParam&lt;&gt;(
140                     &quot;win.msi.productVersion&quot;,
141                     String.class,
142                     VERSION::fetchFrom,
</pre>
<hr />
<pre>
271                 MsiVersion.of(version);
272             } catch (IllegalArgumentException ex) {
273                 throw new ConfigException(ex.getMessage(), I18N.getString(
274                         &quot;error.version-string-wrong-format.advice&quot;), ex);
275             }
276 
277             FileAssociation.verify(FileAssociation.fetchFrom(params));
278 
279             return true;
280         } catch (RuntimeException re) {
281             if (re.getCause() instanceof ConfigException) {
282                 throw (ConfigException) re.getCause();
283             } else {
284                 throw new ConfigException(re);
285             }
286         }
287     }
288 
289     private void prepareProto(Map&lt;String, ? super Object&gt; params)
290                 throws PackagerException, IOException {
<span class="line-modified">291         Path appImage = StandardBundlerParam.getPredefinedAppImage(params);</span>
<span class="line-modified">292         Path appDir;</span>
293 
294         // we either have an application image or need to build one
295         if (appImage != null) {
<span class="line-modified">296             appDir = MSI_IMAGE_DIR.fetchFrom(params).resolve(APP_NAME.fetchFrom(params));</span>

297             // copy everything from appImage dir into appDir/name
<span class="line-modified">298             IOUtils.copyRecursive(appImage, appDir);</span>
299         } else {
300             appDir = appImageBundler.execute(params, MSI_IMAGE_DIR.fetchFrom(
301                     params));
302         }
303 
304         // Configure installer icon
305         if (StandardBundlerParam.isRuntimeInstaller(params)) {
306             // Use icon from java launcher.
307             // Assume java.exe exists in Java Runtime being packed.
308             // Ignore custom icon if any as we don&#39;t want to copy anything in
309             // Java Runtime image.
310             installerIcon = ApplicationLayout.javaRuntime()
<span class="line-modified">311                     .resolveAt(appDir)</span>
312                     .runtimeDirectory()
313                     .resolve(Path.of(&quot;bin&quot;, &quot;java.exe&quot;));
314         } else {
315             installerIcon = ApplicationLayout.windowsAppImage()
<span class="line-modified">316                     .resolveAt(appDir)</span>
317                     .launchersDirectory()
318                     .resolve(APP_NAME.fetchFrom(params) + &quot;.exe&quot;);
319         }
320         installerIcon = installerIcon.toAbsolutePath();
321 
322         params.put(WIN_APP_IMAGE.getID(), appDir);
323 
324         String licenseFile = LICENSE_FILE.fetchFrom(params);
325         if (licenseFile != null) {
326             // need to copy license file to the working directory
327             // and convert to rtf if needed
<span class="line-modified">328             Path lfile = Path.of(licenseFile);</span>
<span class="line-modified">329             Path destFile = CONFIG_ROOT.fetchFrom(params)</span>
<span class="line-modified">330                     .resolve(lfile.getFileName());</span>
331 
332             IOUtils.copyFile(lfile, destFile);
<span class="line-modified">333             destFile.toFile().setWritable(true);</span>
334             ensureByMutationFileIsRTF(destFile);
335         }
336     }
337 
338     @Override
<span class="line-modified">339     public Path execute(Map&lt;String, ? super Object&gt; params,</span>
<span class="line-modified">340             Path outputParentDir) throws PackagerException {</span>
341 
<span class="line-modified">342         IOUtils.writableOutputDir(outputParentDir);</span>
343 
<span class="line-modified">344         Path imageDir = MSI_IMAGE_DIR.fetchFrom(params);</span>
345         try {
346             Files.createDirectories(imageDir);
347 
348             prepareProto(params);
349 
350             wixSourcesBuilder
<span class="line-modified">351             .initFromParams(WIN_APP_IMAGE.fetchFrom(params), params)</span>
<span class="line-modified">352             .createMainFragment(CONFIG_ROOT.fetchFrom(params).resolve(</span>
353                     &quot;bundle.wxf&quot;));
354 
355             Map&lt;String, String&gt; wixVars = prepareMainProjectFile(params);
356 
357             new ScriptRunner()
358             .setDirectory(imageDir)
359             .setResourceCategoryId(&quot;resource.post-app-image-script&quot;)
360             .setScriptNameSuffix(&quot;post-image&quot;)
361             .setEnvironmentVariable(&quot;JpAppImageDir&quot;, imageDir.toAbsolutePath().toString())
362             .run(params);
363 
364             return buildMSI(params, wixVars, outputParentDir);
365         } catch (IOException ex) {
366             Log.verbose(ex);
367             throw new PackagerException(ex);
368         }
369     }
370 
371     private Map&lt;String, String&gt; prepareMainProjectFile(
372             Map&lt;String, ? super Object&gt; params) throws IOException {
</pre>
<hr />
<pre>
375         final UUID productCode = getProductCode(params);
376         final UUID upgradeCode = getUpgradeCode(params);
377 
378         data.put(&quot;JpProductCode&quot;, productCode.toString());
379         data.put(&quot;JpProductUpgradeCode&quot;, upgradeCode.toString());
380 
381         Log.verbose(MessageFormat.format(I18N.getString(&quot;message.product-code&quot;),
382                 productCode));
383         Log.verbose(MessageFormat.format(I18N.getString(&quot;message.upgrade-code&quot;),
384                 upgradeCode));
385 
386         data.put(&quot;JpAllowUpgrades&quot;, &quot;yes&quot;);
387         data.put(&quot;JpAllowDowngrades&quot;, &quot;yes&quot;);
388 
389         data.put(&quot;JpAppName&quot;, APP_NAME.fetchFrom(params));
390         data.put(&quot;JpAppDescription&quot;, DESCRIPTION.fetchFrom(params));
391         data.put(&quot;JpAppVendor&quot;, VENDOR.fetchFrom(params));
392         data.put(&quot;JpAppVersion&quot;, PRODUCT_VERSION.fetchFrom(params));
393         data.put(&quot;JpIcon&quot;, installerIcon.toString());
394 
<span class="line-modified">395         final Path configDir = CONFIG_ROOT.fetchFrom(params);</span>
396 
397         data.put(&quot;JpConfigDir&quot;, configDir.toAbsolutePath().toString());
398 
399         if (MSI_SYSTEM_WIDE.fetchFrom(params)) {
400             data.put(&quot;JpIsSystemWide&quot;, &quot;yes&quot;);
401         }
402 
403         String licenseFile = LICENSE_FILE.fetchFrom(params);
404         if (licenseFile != null) {
<span class="line-modified">405             String lname = Path.of(licenseFile).getFileName().toString();</span>
<span class="line-modified">406             Path destFile = CONFIG_ROOT.fetchFrom(params).resolve(lname);</span>
<span class="line-modified">407             data.put(&quot;JpLicenseRtf&quot;, destFile.toAbsolutePath().toString());</span>
408         }
409 
410         // Copy CA dll to include with installer
411         if (INSTALLDIR_CHOOSER.fetchFrom(params)) {
412             data.put(&quot;JpInstallDirChooser&quot;, &quot;yes&quot;);
413             String fname = &quot;wixhelper.dll&quot;;
414             try (InputStream is = OverridableResource.readDefault(fname)) {
<span class="line-modified">415                 Files.copy(is, CONFIG_ROOT.fetchFrom(params).resolve(fname));</span>


416             }
417         }
418 
419         // Copy l10n files.
420         for (String loc : Arrays.asList(&quot;en&quot;, &quot;ja&quot;, &quot;zh_CN&quot;)) {
421             String fname = &quot;MsiInstallerStrings_&quot; + loc + &quot;.wxl&quot;;
422             try (InputStream is = OverridableResource.readDefault(fname)) {
<span class="line-modified">423                 Files.copy(is, CONFIG_ROOT.fetchFrom(params).resolve(fname));</span>


424             }
425         }
426 
427         createResource(&quot;main.wxs&quot;, params)
428                 .setCategory(I18N.getString(&quot;resource.main-wix-file&quot;))
429                 .saveToFile(configDir.resolve(&quot;main.wxs&quot;));
430 
431         createResource(&quot;overrides.wxi&quot;, params)
432                 .setCategory(I18N.getString(&quot;resource.overrides-wix-file&quot;))
433                 .saveToFile(configDir.resolve(&quot;overrides.wxi&quot;));
434 
435         return data;
436     }
437 
<span class="line-modified">438     private Path buildMSI(Map&lt;String, ? super Object&gt; params,</span>
<span class="line-modified">439             Map&lt;String, String&gt; wixVars, Path outdir)</span>
440             throws IOException {
441 
<span class="line-modified">442         Path msiOut = outdir.resolve(INSTALLER_FILE_NAME.fetchFrom(params) + &quot;.msi&quot;);</span>

443 
444         Log.verbose(MessageFormat.format(I18N.getString(
<span class="line-modified">445                 &quot;message.preparing-msi-config&quot;), msiOut.toAbsolutePath()</span>
<span class="line-added">446                         .toString()));</span>
447 
448         WixPipeline wixPipeline = new WixPipeline()
449         .setToolset(wixToolset.entrySet().stream().collect(
450                 Collectors.toMap(
451                         entry -&gt; entry.getKey(),
452                         entry -&gt; entry.getValue().path)))
<span class="line-modified">453         .setWixObjDir(TEMP_ROOT.fetchFrom(params).resolve(&quot;wixobj&quot;))</span>
<span class="line-modified">454         .setWorkDir(WIN_APP_IMAGE.fetchFrom(params))</span>
<span class="line-modified">455         .addSource(CONFIG_ROOT.fetchFrom(params).resolve(&quot;main.wxs&quot;), wixVars)</span>
<span class="line-modified">456         .addSource(CONFIG_ROOT.fetchFrom(params).resolve(&quot;bundle.wxf&quot;), null);</span>
457 
458         Log.verbose(MessageFormat.format(I18N.getString(
<span class="line-modified">459                 &quot;message.generating-msi&quot;), msiOut.toAbsolutePath().toString()));</span>
460 
461         boolean enableLicenseUI = (LICENSE_FILE.fetchFrom(params) != null);
462         boolean enableInstalldirUI = INSTALLDIR_CHOOSER.fetchFrom(params);
463 
464         wixPipeline.addLightOptions(&quot;-sice:ICE27&quot;);
465 
466         if (!MSI_SYSTEM_WIDE.fetchFrom(params)) {
467             wixPipeline.addLightOptions(&quot;-sice:ICE91&quot;);
468         }
469         if (enableLicenseUI || enableInstalldirUI) {
470             wixPipeline.addLightOptions(&quot;-ext&quot;, &quot;WixUIExtension&quot;);
471         }
472 
473         wixPipeline.addLightOptions(&quot;-loc&quot;,
<span class="line-modified">474                 CONFIG_ROOT.fetchFrom(params).resolve(I18N.getString(</span>
475                         &quot;resource.wxl-file-name&quot;)).toAbsolutePath().toString());
476 
477         // Only needed if we using CA dll, so Wix can find it
478         if (enableInstalldirUI) {
<span class="line-modified">479             wixPipeline.addLightOptions(&quot;-b&quot;, CONFIG_ROOT.fetchFrom(params)</span>
<span class="line-added">480                     .toAbsolutePath().toString());</span>
481         }
482 
<span class="line-modified">483         wixPipeline.buildMsi(msiOut.toAbsolutePath());</span>
484 
485         return msiOut;
486     }
487 
<span class="line-modified">488     private static void ensureByMutationFileIsRTF(Path f) {</span>
<span class="line-modified">489         if (f == null || !Files.isRegularFile(f)) return;</span>
490 
491         try {
492             boolean existingLicenseIsRTF = false;
493 
<span class="line-modified">494             try (InputStream fin = Files.newInputStream(f)) {</span>
495                 byte[] firstBits = new byte[7];
496 
497                 if (fin.read(firstBits) == firstBits.length) {
498                     String header = new String(firstBits);
499                     existingLicenseIsRTF = &quot;{\\rtf1\\&quot;.equals(header);
500                 }
501             }
502 
503             if (!existingLicenseIsRTF) {
<span class="line-modified">504                 List&lt;String&gt; oldLicense = Files.readAllLines(f);</span>
505                 try (Writer w = Files.newBufferedWriter(
<span class="line-modified">506                         f, Charset.forName(&quot;Windows-1252&quot;))) {</span>
507                     w.write(&quot;{\\rtf1\\ansi\\ansicpg1252\\deff0\\deflang1033&quot;
508                             + &quot;{\\fonttbl{\\f0\\fnil\\fcharset0 Arial;}}\n&quot;
509                             + &quot;\\viewkind4\\uc1\\pard\\sa200\\sl276&quot;
510                             + &quot;\\slmult1\\lang9\\fs20 &quot;);
511                     oldLicense.forEach(l -&gt; {
512                         try {
513                             for (char c : l.toCharArray()) {
514                                 // 0x00 &lt;= ch &lt; 0x20 Escaped (\&#39;hh)
515                                 // 0x20 &lt;= ch &lt; 0x80 Raw(non - escaped) char
516                                 // 0x80 &lt;= ch &lt;= 0xFF Escaped(\ &#39;hh)
517                                 // 0x5C, 0x7B, 0x7D (special RTF characters
518                                 // \,{,})Escaped(\&#39;hh)
519                                 // ch &gt; 0xff Escaped (\\ud###?)
520                                 if (c &lt; 0x10) {
521                                     w.write(&quot;\\&#39;0&quot;);
522                                     w.write(Integer.toHexString(c));
523                                 } else if (c &gt; 0xff) {
524                                     w.write(&quot;\\ud&quot;);
525                                     w.write(Integer.toString(c));
526                                     // \\uc1 is in the header and in effect
</pre>
</td>
</tr>
</table>
<center><a href="WinExeBundler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WindowsAppImageBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
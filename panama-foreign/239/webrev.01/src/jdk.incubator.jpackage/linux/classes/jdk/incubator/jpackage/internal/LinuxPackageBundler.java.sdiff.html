<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jpackage/linux/classes/jdk/incubator/jpackage/internal/LinuxPackageBundler.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LinuxDebBundler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LinuxRpmBundler.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.jpackage/linux/classes/jdk/incubator/jpackage/internal/LinuxPackageBundler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.incubator.jpackage.internal;
 26 
<span class="line-removed"> 27 import java.io.File;</span>
 28 import java.io.IOException;
 29 import java.nio.file.InvalidPathException;
 30 import java.nio.file.Path;
 31 import java.text.MessageFormat;
 32 import java.util.Collections;
 33 import java.util.HashMap;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.Objects;
 37 import java.util.Set;
 38 import java.util.function.Function;
 39 import java.util.function.Predicate;
 40 import java.util.function.Supplier;
 41 import java.util.stream.Collectors;
 42 import java.util.stream.Stream;
 43 import static jdk.incubator.jpackage.internal.DesktopIntegration.*;
 44 import static jdk.incubator.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;
 45 import static jdk.incubator.jpackage.internal.StandardBundlerParam.VERSION;
 46 import static jdk.incubator.jpackage.internal.StandardBundlerParam.RELEASE;
 47 import static jdk.incubator.jpackage.internal.StandardBundlerParam.VENDOR;
</pre>
<hr />
<pre>
 87             } else {
 88                 advice = &quot;message.rpm-ldd-not-available.advice&quot;;
 89             }
 90             // Let user know package dependencies will not be generated.
 91             Log.error(String.format(&quot;%s\n%s&quot;, I18N.getString(
 92                     &quot;message.ldd-not-available&quot;), I18N.getString(advice)));
 93         }
 94 
 95         // Packaging specific validation
 96         doValidate(params);
 97 
 98         return true;
 99     }
100 
101     @Override
102     final public String getBundleType() {
103         return &quot;INSTALLER&quot;;
104     }
105 
106     @Override
<span class="line-modified">107     final public File execute(Map&lt;String, ? super Object&gt; params,</span>
<span class="line-modified">108             File outputParentDir) throws PackagerException {</span>
<span class="line-modified">109         IOUtils.writableOutputDir(outputParentDir.toPath());</span>
110 
111         PlatformPackage thePackage = createMetaPackage(params);
112 
<span class="line-modified">113         Function&lt;File, ApplicationLayout&gt; initAppImageLayout = imageRoot -&gt; {</span>
114             ApplicationLayout layout = appImageLayout(params);
115             layout.pathGroup().setPath(new Object(),
116                     AppImageFile.getPathInAppImage(Path.of(&quot;&quot;)));
<span class="line-modified">117             return layout.resolveAt(imageRoot.toPath());</span>
118         };
119 
120         try {
<span class="line-modified">121             File appImage = StandardBundlerParam.getPredefinedAppImage(params);</span>
122 
123             // we either have an application image or need to build one
124             if (appImage != null) {
125                 initAppImageLayout.apply(appImage).copy(
126                         thePackage.sourceApplicationLayout());
127             } else {
128                 final Path srcAppImageRoot = thePackage.sourceRoot().resolve(&quot;src&quot;);
<span class="line-modified">129                 appImage = appImageBundler.execute(params, srcAppImageRoot.toFile());</span>
130                 ApplicationLayout srcAppLayout = initAppImageLayout.apply(
131                         appImage);
132                 if (appImage.equals(PREDEFINED_RUNTIME_IMAGE.fetchFrom(params))) {
133                     // Application image points to run-time image.
134                     // Copy it.
135                     srcAppLayout.copy(thePackage.sourceApplicationLayout());
136                 } else {
137                     // Application image is a newly created directory tree.
138                     // Move it.
139                     srcAppLayout.move(thePackage.sourceApplicationLayout());
<span class="line-modified">140                     IOUtils.deleteRecursive(srcAppImageRoot.toFile());</span>
141                 }
142             }
143 
144             desktopIntegration = DesktopIntegration.create(thePackage, params);
145 
146             Map&lt;String, String&gt; data = createDefaultReplacementData(params);
147             if (desktopIntegration != null) {
148                 data.putAll(desktopIntegration.create());
149             } else {
150                 Stream.of(DESKTOP_COMMANDS_INSTALL, DESKTOP_COMMANDS_UNINSTALL,
151                         UTILITY_SCRIPTS).forEach(v -&gt; data.put(v, &quot;&quot;));
152             }
153 
154             data.putAll(createReplacementData(params));
155 
<span class="line-modified">156             File packageBundle = buildPackageBundle(Collections.unmodifiableMap(</span>
157                     data), params, outputParentDir);
158 
<span class="line-modified">159             verifyOutputBundle(params, packageBundle.toPath()).stream()</span>
160                     .filter(Objects::nonNull)
161                     .forEachOrdered(ex -&gt; {
162                 Log.verbose(ex.getLocalizedMessage());
163                 Log.verbose(ex.getAdvice());
164             });
165 
166             return packageBundle;
167         } catch (IOException ex) {
168             Log.verbose(ex);
169             throw new PackagerException(ex);
170         }
171     }
172 
173     private List&lt;String&gt; getListOfNeededPackages(
174             Map&lt;String, ? super Object&gt; params) throws IOException {
175 
176         PlatformPackage thePackage = createMetaPackage(params);
177 
178         final List&lt;String&gt; xdgUtilsPackage;
179         if (desktopIntegration != null) {
</pre>
<hr />
<pre>
223 
224         return data;
225     }
226 
227     abstract protected List&lt;ConfigException&gt; verifyOutputBundle(
228             Map&lt;String, ? super Object&gt; params, Path packageBundle);
229 
230     abstract protected void initLibProvidersLookup(
231             Map&lt;String, ? super Object&gt; params,
232             LibProvidersLookup libProvidersLookup);
233 
234     abstract protected List&lt;ToolValidator&gt; getToolValidators(
235             Map&lt;String, ? super Object&gt; params);
236 
237     abstract protected void doValidate(Map&lt;String, ? super Object&gt; params)
238             throws ConfigException;
239 
240     abstract protected Map&lt;String, String&gt; createReplacementData(
241             Map&lt;String, ? super Object&gt; params) throws IOException;
242 
<span class="line-modified">243     abstract protected File buildPackageBundle(</span>
244             Map&lt;String, String&gt; replacementData,
<span class="line-modified">245             Map&lt;String, ? super Object&gt; params, File outputParentDir) throws</span>
246             PackagerException, IOException;
247 
248     final protected PlatformPackage createMetaPackage(
249             Map&lt;String, ? super Object&gt; params) {
250 
251         Supplier&lt;ApplicationLayout&gt; packageLayout = () -&gt; {
252             String installDir = LINUX_INSTALL_DIR.fetchFrom(params);
253             if (isInstallDirInUsrTree(installDir)) {
254                 return ApplicationLayout.linuxUsrTreePackageImage(
255                         Path.of(&quot;/&quot;).relativize(Path.of(installDir)),
256                         packageName.fetchFrom(params));
257             }
258             return appImageLayout(params);
259         };
260 
261         return new PlatformPackage() {
262             @Override
263             public String name() {
264                 return packageName.fetchFrom(params);
265             }
266 
267             @Override
268             public Path sourceRoot() {
<span class="line-modified">269                 return IMAGES_ROOT.fetchFrom(params).toPath().toAbsolutePath();</span>
270             }
271 
272             @Override
273             public ApplicationLayout sourceApplicationLayout() {
274                 return packageLayout.get().resolveAt(
275                         applicationInstallDir(sourceRoot()));
276             }
277 
278             @Override
279             public ApplicationLayout installedApplicationLayout() {
280                 return packageLayout.get().resolveAt(
281                         applicationInstallDir(Path.of(&quot;/&quot;)));
282             }
283 
284             private Path applicationInstallDir(Path root) {
285                 String installRoot = LINUX_INSTALL_DIR.fetchFrom(params);
286                 if (isInstallDirInUsrTree(installRoot)) {
287                     return root;
288                 }
289 
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.incubator.jpackage.internal;
 26 

 27 import java.io.IOException;
 28 import java.nio.file.InvalidPathException;
 29 import java.nio.file.Path;
 30 import java.text.MessageFormat;
 31 import java.util.Collections;
 32 import java.util.HashMap;
 33 import java.util.List;
 34 import java.util.Map;
 35 import java.util.Objects;
 36 import java.util.Set;
 37 import java.util.function.Function;
 38 import java.util.function.Predicate;
 39 import java.util.function.Supplier;
 40 import java.util.stream.Collectors;
 41 import java.util.stream.Stream;
 42 import static jdk.incubator.jpackage.internal.DesktopIntegration.*;
 43 import static jdk.incubator.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;
 44 import static jdk.incubator.jpackage.internal.StandardBundlerParam.VERSION;
 45 import static jdk.incubator.jpackage.internal.StandardBundlerParam.RELEASE;
 46 import static jdk.incubator.jpackage.internal.StandardBundlerParam.VENDOR;
</pre>
<hr />
<pre>
 86             } else {
 87                 advice = &quot;message.rpm-ldd-not-available.advice&quot;;
 88             }
 89             // Let user know package dependencies will not be generated.
 90             Log.error(String.format(&quot;%s\n%s&quot;, I18N.getString(
 91                     &quot;message.ldd-not-available&quot;), I18N.getString(advice)));
 92         }
 93 
 94         // Packaging specific validation
 95         doValidate(params);
 96 
 97         return true;
 98     }
 99 
100     @Override
101     final public String getBundleType() {
102         return &quot;INSTALLER&quot;;
103     }
104 
105     @Override
<span class="line-modified">106     final public Path execute(Map&lt;String, ? super Object&gt; params,</span>
<span class="line-modified">107             Path outputParentDir) throws PackagerException {</span>
<span class="line-modified">108         IOUtils.writableOutputDir(outputParentDir);</span>
109 
110         PlatformPackage thePackage = createMetaPackage(params);
111 
<span class="line-modified">112         Function&lt;Path, ApplicationLayout&gt; initAppImageLayout = imageRoot -&gt; {</span>
113             ApplicationLayout layout = appImageLayout(params);
114             layout.pathGroup().setPath(new Object(),
115                     AppImageFile.getPathInAppImage(Path.of(&quot;&quot;)));
<span class="line-modified">116             return layout.resolveAt(imageRoot);</span>
117         };
118 
119         try {
<span class="line-modified">120             Path appImage = StandardBundlerParam.getPredefinedAppImage(params);</span>
121 
122             // we either have an application image or need to build one
123             if (appImage != null) {
124                 initAppImageLayout.apply(appImage).copy(
125                         thePackage.sourceApplicationLayout());
126             } else {
127                 final Path srcAppImageRoot = thePackage.sourceRoot().resolve(&quot;src&quot;);
<span class="line-modified">128                 appImage = appImageBundler.execute(params, srcAppImageRoot);</span>
129                 ApplicationLayout srcAppLayout = initAppImageLayout.apply(
130                         appImage);
131                 if (appImage.equals(PREDEFINED_RUNTIME_IMAGE.fetchFrom(params))) {
132                     // Application image points to run-time image.
133                     // Copy it.
134                     srcAppLayout.copy(thePackage.sourceApplicationLayout());
135                 } else {
136                     // Application image is a newly created directory tree.
137                     // Move it.
138                     srcAppLayout.move(thePackage.sourceApplicationLayout());
<span class="line-modified">139                     IOUtils.deleteRecursive(srcAppImageRoot);</span>
140                 }
141             }
142 
143             desktopIntegration = DesktopIntegration.create(thePackage, params);
144 
145             Map&lt;String, String&gt; data = createDefaultReplacementData(params);
146             if (desktopIntegration != null) {
147                 data.putAll(desktopIntegration.create());
148             } else {
149                 Stream.of(DESKTOP_COMMANDS_INSTALL, DESKTOP_COMMANDS_UNINSTALL,
150                         UTILITY_SCRIPTS).forEach(v -&gt; data.put(v, &quot;&quot;));
151             }
152 
153             data.putAll(createReplacementData(params));
154 
<span class="line-modified">155             Path packageBundle = buildPackageBundle(Collections.unmodifiableMap(</span>
156                     data), params, outputParentDir);
157 
<span class="line-modified">158             verifyOutputBundle(params, packageBundle).stream()</span>
159                     .filter(Objects::nonNull)
160                     .forEachOrdered(ex -&gt; {
161                 Log.verbose(ex.getLocalizedMessage());
162                 Log.verbose(ex.getAdvice());
163             });
164 
165             return packageBundle;
166         } catch (IOException ex) {
167             Log.verbose(ex);
168             throw new PackagerException(ex);
169         }
170     }
171 
172     private List&lt;String&gt; getListOfNeededPackages(
173             Map&lt;String, ? super Object&gt; params) throws IOException {
174 
175         PlatformPackage thePackage = createMetaPackage(params);
176 
177         final List&lt;String&gt; xdgUtilsPackage;
178         if (desktopIntegration != null) {
</pre>
<hr />
<pre>
222 
223         return data;
224     }
225 
226     abstract protected List&lt;ConfigException&gt; verifyOutputBundle(
227             Map&lt;String, ? super Object&gt; params, Path packageBundle);
228 
229     abstract protected void initLibProvidersLookup(
230             Map&lt;String, ? super Object&gt; params,
231             LibProvidersLookup libProvidersLookup);
232 
233     abstract protected List&lt;ToolValidator&gt; getToolValidators(
234             Map&lt;String, ? super Object&gt; params);
235 
236     abstract protected void doValidate(Map&lt;String, ? super Object&gt; params)
237             throws ConfigException;
238 
239     abstract protected Map&lt;String, String&gt; createReplacementData(
240             Map&lt;String, ? super Object&gt; params) throws IOException;
241 
<span class="line-modified">242     abstract protected Path buildPackageBundle(</span>
243             Map&lt;String, String&gt; replacementData,
<span class="line-modified">244             Map&lt;String, ? super Object&gt; params, Path outputParentDir) throws</span>
245             PackagerException, IOException;
246 
247     final protected PlatformPackage createMetaPackage(
248             Map&lt;String, ? super Object&gt; params) {
249 
250         Supplier&lt;ApplicationLayout&gt; packageLayout = () -&gt; {
251             String installDir = LINUX_INSTALL_DIR.fetchFrom(params);
252             if (isInstallDirInUsrTree(installDir)) {
253                 return ApplicationLayout.linuxUsrTreePackageImage(
254                         Path.of(&quot;/&quot;).relativize(Path.of(installDir)),
255                         packageName.fetchFrom(params));
256             }
257             return appImageLayout(params);
258         };
259 
260         return new PlatformPackage() {
261             @Override
262             public String name() {
263                 return packageName.fetchFrom(params);
264             }
265 
266             @Override
267             public Path sourceRoot() {
<span class="line-modified">268                 return IMAGES_ROOT.fetchFrom(params).toAbsolutePath();</span>
269             }
270 
271             @Override
272             public ApplicationLayout sourceApplicationLayout() {
273                 return packageLayout.get().resolveAt(
274                         applicationInstallDir(sourceRoot()));
275             }
276 
277             @Override
278             public ApplicationLayout installedApplicationLayout() {
279                 return packageLayout.get().resolveAt(
280                         applicationInstallDir(Path.of(&quot;/&quot;)));
281             }
282 
283             private Path applicationInstallDir(Path root) {
284                 String installRoot = LINUX_INSTALL_DIR.fetchFrom(params);
285                 if (isInstallDirInUsrTree(installRoot)) {
286                     return root;
287                 }
288 
</pre>
</td>
</tr>
</table>
<center><a href="LinuxDebBundler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LinuxRpmBundler.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/linux/classes/jdk/incubator/jpackage/internal/LinuxDebBundler.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.FileVisitResult;
 30 import java.nio.file.Files;
 31 import java.nio.file.Path;
 32 import java.nio.file.SimpleFileVisitor;
 33 import java.nio.file.attribute.BasicFileAttributes;
 34 
 35 import java.nio.file.attribute.PosixFilePermission;
 36 import java.nio.file.attribute.PosixFilePermissions;
 37 import java.text.MessageFormat;
 38 import java.util.ArrayList;
 39 import java.util.HashMap;
 40 import java.util.HashSet;
 41 import java.util.List;
 42 import java.util.Map;
 43 import java.util.Set;
 44 import java.util.regex.Matcher;
 45 import java.util.regex.Pattern;
 46 import java.util.stream.Collectors;
 47 import java.util.stream.Stream;
 48 import static jdk.incubator.jpackage.internal.OverridableResource.createResource;
 49 import static jdk.incubator.jpackage.internal.StandardBundlerParam.APP_NAME;
 50 import static jdk.incubator.jpackage.internal.StandardBundlerParam.VERSION;
 51 import static jdk.incubator.jpackage.internal.StandardBundlerParam.RELEASE;
 52 import static jdk.incubator.jpackage.internal.StandardBundlerParam.VENDOR;
 53 import static jdk.incubator.jpackage.internal.StandardBundlerParam.LICENSE_FILE;
 54 import static jdk.incubator.jpackage.internal.StandardBundlerParam.COPYRIGHT;
 55 
 56 public class LinuxDebBundler extends LinuxPackageBundler {
 57 
 58     // Debian rules for package naming are used here
 59     // https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Source
 60     //
 61     // Package names must consist only of lower case letters (a-z),
 62     // digits (0-9), plus (+) and minus (-) signs, and periods (.).
 63     // They must be at least two characters long and
 64     // must start with an alphanumeric character.
 65     //
 66     private static final Pattern DEB_PACKAGE_NAME_PATTERN =
 67             Pattern.compile(&quot;^[a-z][a-z\\d\\+\\-\\.]+&quot;);
 68 
 69     private static final BundlerParamInfo&lt;String&gt; PACKAGE_NAME =
 70             new StandardBundlerParam&lt;&gt; (
 71             Arguments.CLIOptions.LINUX_BUNDLE_NAME.getId(),
 72             String.class,
 73             params -&gt; {
 74                 String nm = APP_NAME.fetchFrom(params);
 75 
 76                 if (nm == null) return null;
 77 
 78                 // make sure to lower case and spaces/underscores become dashes
 79                 nm = nm.toLowerCase().replaceAll(&quot;[ _]&quot;, &quot;-&quot;);
 80                 return nm;
 81             },
 82             (s, p) -&gt; {
 83                 if (!DEB_PACKAGE_NAME_PATTERN.matcher(s).matches()) {
 84                     throw new IllegalArgumentException(new ConfigException(
 85                             MessageFormat.format(I18N.getString(
 86                             &quot;error.invalid-value-for-package-name&quot;), s),
 87                             I18N.getString(
 88                             &quot;error.invalid-value-for-package-name.advice&quot;)));
 89                 }
 90 
 91                 return s;
 92             });
 93 
 94     private final static String TOOL_DPKG_DEB = &quot;dpkg-deb&quot;;
 95     private final static String TOOL_DPKG = &quot;dpkg&quot;;
 96     private final static String TOOL_FAKEROOT = &quot;fakeroot&quot;;
 97 
 98     private final static String DEB_ARCH;
 99     static {
100         String debArch;
101         try {
102             debArch = Executor.of(TOOL_DPKG, &quot;--print-architecture&quot;).saveOutput(
103                     true).executeExpectSuccess().getOutput().get(0);
104         } catch (IOException ex) {
105             debArch = null;
106         }
107         DEB_ARCH = debArch;
108     }
109 
110     private static final BundlerParamInfo&lt;String&gt; FULL_PACKAGE_NAME =
111             new StandardBundlerParam&lt;&gt;(
112                     &quot;linux.deb.fullPackageName&quot;, String.class, params -&gt; {
113                         return PACKAGE_NAME.fetchFrom(params)
114                             + &quot;_&quot; + VERSION.fetchFrom(params)
115                             + &quot;-&quot; + RELEASE.fetchFrom(params)
116                             + &quot;_&quot; + DEB_ARCH;
117                     }, (s, p) -&gt; s);
118 
119     private static final BundlerParamInfo&lt;String&gt; EMAIL =
120             new StandardBundlerParam&lt;&gt; (
121             Arguments.CLIOptions.LINUX_DEB_MAINTAINER.getId(),
122             String.class,
123             params -&gt; &quot;Unknown&quot;,
124             (s, p) -&gt; s);
125 
126     private static final BundlerParamInfo&lt;String&gt; MAINTAINER =
127             new StandardBundlerParam&lt;&gt; (
128             Arguments.CLIOptions.LINUX_DEB_MAINTAINER.getId() + &quot;.internal&quot;,
129             String.class,
130             params -&gt; VENDOR.fetchFrom(params) + &quot; &lt;&quot;
131                     + EMAIL.fetchFrom(params) + &quot;&gt;&quot;,
132             (s, p) -&gt; s);
133 
134     private static final BundlerParamInfo&lt;String&gt; SECTION =
135             new StandardBundlerParam&lt;&gt;(
136             Arguments.CLIOptions.LINUX_CATEGORY.getId(),
137             String.class,
138             params -&gt; &quot;misc&quot;,
139             (s, p) -&gt; s);
140 
141     private static final BundlerParamInfo&lt;String&gt; LICENSE_TEXT =
142             new StandardBundlerParam&lt;&gt; (
143             &quot;linux.deb.licenseText&quot;,
144             String.class,
145             params -&gt; {
146                 try {
147                     String licenseFile = LICENSE_FILE.fetchFrom(params);
148                     if (licenseFile != null) {
149                         return Files.readString(Path.of(licenseFile));
150                     }
151                 } catch (IOException e) {
152                     Log.verbose(e);
153                 }
154                 return &quot;Unknown&quot;;
155             },
156             (s, p) -&gt; s);
157 
158     public LinuxDebBundler() {
159         super(PACKAGE_NAME);
160     }
161 
162     @Override
163     public void doValidate(Map&lt;String, ? super Object&gt; params)
164             throws ConfigException {
165 
166         // Show warning if license file is missing
167         if (LICENSE_FILE.fetchFrom(params) == null) {
168             Log.verbose(I18N.getString(&quot;message.debs-like-licenses&quot;));
169         }
170     }
171 
172     @Override
173     protected List&lt;ToolValidator&gt; getToolValidators(
174             Map&lt;String, ? super Object&gt; params) {
175         return Stream.of(TOOL_DPKG_DEB, TOOL_DPKG, TOOL_FAKEROOT).map(
176                 ToolValidator::new).collect(Collectors.toList());
177     }
178 
179     @Override
180     protected Path buildPackageBundle(
181             Map&lt;String, String&gt; replacementData,
182             Map&lt;String, ? super Object&gt; params, Path outputParentDir) throws
183             PackagerException, IOException {
184 
185         prepareProjectConfig(replacementData, params);
186         adjustPermissionsRecursive(createMetaPackage(params).sourceRoot());
187         return buildDeb(params, outputParentDir);
188     }
189 
190     private static final Pattern PACKAGE_NAME_REGEX = Pattern.compile(&quot;^(^\\S+):&quot;);
191 
192     @Override
193     protected void initLibProvidersLookup(
194             Map&lt;String, ? super Object&gt; params,
195             LibProvidersLookup libProvidersLookup) {
196 
197         //
198         // `dpkg -S` command does glob pattern lookup. If not the absolute path
199         // to the file is specified it might return mltiple package names.
200         // Even for full paths multiple package names can be returned as
201         // it is OK for multiple packages to provide the same file. `/opt`
202         // directory is such an example. So we have to deal with multiple
203         // packages per file situation.
204         //
205         // E.g.: `dpkg -S libc.so.6` command reports three packages:
206         // libc6-x32: /libx32/libc.so.6
207         // libc6:amd64: /lib/x86_64-linux-gnu/libc.so.6
208         // libc6-i386: /lib32/libc.so.6
209         // `:amd64` is architecture suffix and can (should) be dropped.
210         // Still need to decide what package to choose from three.
211         // libc6-x32 and libc6-i386 both depend on libc6:
212         // $ dpkg -s libc6-x32
213         // Package: libc6-x32
214         // Status: install ok installed
215         // Priority: optional
216         // Section: libs
217         // Installed-Size: 10840
218         // Maintainer: Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;
219         // Architecture: amd64
220         // Source: glibc
221         // Version: 2.23-0ubuntu10
222         // Depends: libc6 (= 2.23-0ubuntu10)
223         //
224         // We can dive into tracking dependencies, but this would be overly
225         // complicated.
226         //
227         // For simplicity lets consider the following rules:
228         // 1. If there is one item in `dpkg -S` output, accept it.
229         // 2. If there are multiple items in `dpkg -S` output and there is at
230         //  least one item with the default arch suffix (DEB_ARCH),
231         //  accept only these items.
232         // 3. If there are multiple items in `dpkg -S` output and there are
233         //  no with the default arch suffix (DEB_ARCH), accept all items.
234         // So lets use this heuristics: don&#39;t accept packages for whom
235         //  `dpkg -p` command fails.
236         // 4. Arch suffix should be stripped from accepted package names.
237         //
238 
239         libProvidersLookup.setPackageLookup(file -&gt; {
240             Set&lt;String&gt; archPackages = new HashSet&lt;&gt;();
241             Set&lt;String&gt; otherPackages = new HashSet&lt;&gt;();
242 
243             Executor.of(TOOL_DPKG, &quot;-S&quot;, file.toString())
244                     .saveOutput(true).executeExpectSuccess()
245                     .getOutput().forEach(line -&gt; {
246                         Matcher matcher = PACKAGE_NAME_REGEX.matcher(line);
247                         if (matcher.find()) {
248                             String name = matcher.group(1);
249                             if (name.endsWith(&quot;:&quot; + DEB_ARCH)) {
250                                 // Strip arch suffix
251                                 name = name.substring(0,
252                                         name.length() - (DEB_ARCH.length() + 1));
253                                 archPackages.add(name);
254                             } else {
255                                 otherPackages.add(name);
256                             }
257                         }
258                     });
259 
260             if (!archPackages.isEmpty()) {
261                 return archPackages.stream();
262             }
263             return otherPackages.stream();
264         });
265     }
266 
267     @Override
268     protected List&lt;ConfigException&gt; verifyOutputBundle(
269             Map&lt;String, ? super Object&gt; params, Path packageBundle) {
270         List&lt;ConfigException&gt; errors = new ArrayList&lt;&gt;();
271 
272         String controlFileName = &quot;control&quot;;
273 
274         List&lt;PackageProperty&gt; properties = List.of(
275                 new PackageProperty(&quot;Package&quot;, PACKAGE_NAME.fetchFrom(params),
276                         &quot;APPLICATION_PACKAGE&quot;, controlFileName),
277                 new PackageProperty(&quot;Version&quot;, String.format(&quot;%s-%s&quot;,
278                         VERSION.fetchFrom(params), RELEASE.fetchFrom(params)),
279                         &quot;APPLICATION_VERSION-APPLICATION_RELEASE&quot;,
280                         controlFileName),
281                 new PackageProperty(&quot;Architecture&quot;, DEB_ARCH, &quot;APPLICATION_ARCH&quot;,
282                         controlFileName));
283 
284         List&lt;String&gt; cmdline = new ArrayList&lt;&gt;(List.of(TOOL_DPKG_DEB, &quot;-f&quot;,
285                 packageBundle.toString()));
286         properties.forEach(property -&gt; cmdline.add(property.name));
287         try {
288             Map&lt;String, String&gt; actualValues = Executor.of(cmdline.toArray(String[]::new))
289                     .saveOutput(true)
290                     .executeExpectSuccess()
291                     .getOutput().stream()
292                             .map(line -&gt; line.split(&quot;:\\s+&quot;, 2))
293                             .collect(Collectors.toMap(
294                                     components -&gt; components[0],
295                                     components -&gt; components[1]));
296             properties.forEach(property -&gt; errors.add(property.verifyValue(
297                     actualValues.get(property.name))));
298         } catch (IOException ex) {
299             // Ignore error as it is not critical. Just report it.
300             Log.verbose(ex);
301         }
302 
303         return errors;
304     }
305 
306     /*
307      * set permissions with a string like &quot;rwxr-xr-x&quot;
308      *
309      * This cannot be directly backport to 22u which is built with 1.6
310      */
311     private void setPermissions(Path file, String permissions) {
312         Set&lt;PosixFilePermission&gt; filePermissions =
313                 PosixFilePermissions.fromString(permissions);
314         try {
315             if (Files.exists(file)) {
316                 Files.setPosixFilePermissions(file, filePermissions);
317             }
318         } catch (IOException ex) {
319             Log.error(ex.getMessage());
320             Log.verbose(ex);
321         }
322 
323     }
324 
325     public static boolean isDebian() {
326         // we are just going to run &quot;dpkg -s coreutils&quot; and assume Debian
327         // or deritive if no error is returned.
328         try {
329             Executor.of(TOOL_DPKG, &quot;-s&quot;, &quot;coreutils&quot;).executeExpectSuccess();
330             return true;
331         } catch (IOException e) {
332             // just fall thru
333         }
334         return false;
335     }
336 
337     private void adjustPermissionsRecursive(Path dir) throws IOException {
338         Files.walkFileTree(dir, new SimpleFileVisitor&lt;Path&gt;() {
339             @Override
340             public FileVisitResult visitFile(Path file,
341                     BasicFileAttributes attrs)
342                     throws IOException {
343                 if (file.endsWith(&quot;.so&quot;) || !Files.isExecutable(file)) {
344                     setPermissions(file, &quot;rw-r--r--&quot;);
345                 } else if (Files.isExecutable(file)) {
346                     setPermissions(file, &quot;rwxr-xr-x&quot;);
347                 }
348                 return FileVisitResult.CONTINUE;
349             }
350 
351             @Override
352             public FileVisitResult postVisitDirectory(Path dir, IOException e)
353                     throws IOException {
354                 if (e == null) {
355                     setPermissions(dir, &quot;rwxr-xr-x&quot;);
356                     return FileVisitResult.CONTINUE;
357                 } else {
358                     // directory iteration failed
359                     throw e;
360                 }
361             }
362         });
363     }
364 
365     private class DebianFile {
366 
367         DebianFile(Path dstFilePath, String comment) {
368             this.dstFilePath = dstFilePath;
369             this.comment = comment;
370         }
371 
372         DebianFile setExecutable() {
373             permissions = &quot;rwxr-xr-x&quot;;
374             return this;
375         }
376 
377         void create(Map&lt;String, String&gt; data, Map&lt;String, ? super Object&gt; params)
378                 throws IOException {
379             createResource(&quot;template.&quot; + dstFilePath.getFileName().toString(),
380                     params)
381                     .setCategory(I18N.getString(comment))
382                     .setSubstitutionData(data)
383                     .saveToFile(dstFilePath);
384             if (permissions != null) {
385                 setPermissions(dstFilePath, permissions);
386             }
387         }
388 
389         private final Path dstFilePath;
390         private final String comment;
391         private String permissions;
392     }
393 
394     private void prepareProjectConfig(Map&lt;String, String&gt; data,
395             Map&lt;String, ? super Object&gt; params) throws IOException {
396 
397         Path configDir = createMetaPackage(params).sourceRoot().resolve(&quot;DEBIAN&quot;);
398         List&lt;DebianFile&gt; debianFiles = new ArrayList&lt;&gt;();
399         debianFiles.add(new DebianFile(
400                 configDir.resolve(&quot;control&quot;),
401                 &quot;resource.deb-control-file&quot;));
402         debianFiles.add(new DebianFile(
403                 configDir.resolve(&quot;preinst&quot;),
404                 &quot;resource.deb-preinstall-script&quot;).setExecutable());
405         debianFiles.add(new DebianFile(
406                 configDir.resolve(&quot;prerm&quot;),
407                 &quot;resource.deb-prerm-script&quot;).setExecutable());
408         debianFiles.add(new DebianFile(
409                 configDir.resolve(&quot;postinst&quot;),
410                 &quot;resource.deb-postinstall-script&quot;).setExecutable());
411         debianFiles.add(new DebianFile(
412                 configDir.resolve(&quot;postrm&quot;),
413                 &quot;resource.deb-postrm-script&quot;).setExecutable());
414 
415         if (!StandardBundlerParam.isRuntimeInstaller(params)) {
416             debianFiles.add(new DebianFile(
417                     getConfig_CopyrightFile(params),
418                     &quot;resource.copyright-file&quot;));
419         }
420 
421         for (DebianFile debianFile : debianFiles) {
422             debianFile.create(data, params);
423         }
424     }
425 
426     @Override
427     protected Map&lt;String, String&gt; createReplacementData(
428             Map&lt;String, ? super Object&gt; params) throws IOException {
429         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
430 
431         data.put(&quot;APPLICATION_MAINTAINER&quot;, MAINTAINER.fetchFrom(params));
432         data.put(&quot;APPLICATION_SECTION&quot;, SECTION.fetchFrom(params));
433         data.put(&quot;APPLICATION_COPYRIGHT&quot;, COPYRIGHT.fetchFrom(params));
434         data.put(&quot;APPLICATION_LICENSE_TEXT&quot;, LICENSE_TEXT.fetchFrom(params));
435         data.put(&quot;APPLICATION_ARCH&quot;, DEB_ARCH);
436         data.put(&quot;APPLICATION_INSTALLED_SIZE&quot;, Long.toString(
437                 createMetaPackage(params).sourceApplicationLayout().sizeInBytes() &gt;&gt; 10));
438 
439         return data;
440     }
441 
442     private Path getConfig_CopyrightFile(Map&lt;String, ? super Object&gt; params) {
443         final String installDir = LINUX_INSTALL_DIR.fetchFrom(params);
444         final String packageName = PACKAGE_NAME.fetchFrom(params);
445 
446         final Path installPath;
447         if (isInstallDirInUsrTree(installDir) || installDir.startsWith(&quot;/usr/&quot;)) {
448             installPath = Path.of(&quot;/usr/share/doc/&quot;, packageName, &quot;copyright&quot;);
449         } else {
450             installPath = Path.of(installDir, packageName, &quot;share/doc/copyright&quot;);
451         }
452 
453         return createMetaPackage(params).sourceRoot().resolve(
454                 Path.of(&quot;/&quot;).relativize(installPath));
455     }
456 
457     private Path buildDeb(Map&lt;String, ? super Object&gt; params,
458             Path outdir) throws IOException {
459         Path outFile = outdir.resolve(
460                 FULL_PACKAGE_NAME.fetchFrom(params)+&quot;.deb&quot;);
461         Log.verbose(MessageFormat.format(I18N.getString(
462                 &quot;message.outputting-to-location&quot;), outFile.toAbsolutePath().toString()));
463 
464         PlatformPackage thePackage = createMetaPackage(params);
465 
466         List&lt;String&gt; cmdline = new ArrayList&lt;&gt;();
467         cmdline.addAll(List.of(TOOL_FAKEROOT, TOOL_DPKG_DEB));
468         if (Log.isVerbose()) {
469             cmdline.add(&quot;--verbose&quot;);
470         }
471         cmdline.addAll(List.of(&quot;-b&quot;, thePackage.sourceRoot().toString(),
472                 outFile.toAbsolutePath().toString()));
473 
474         // run dpkg
475         Executor.of(cmdline.toArray(String[]::new)).executeExpectSuccess();
476 
477         Log.verbose(MessageFormat.format(I18N.getString(
478                 &quot;message.output-to-location&quot;), outFile.toAbsolutePath().toString()));
479 
480         return outFile;
481     }
482 
483     @Override
484     public String getName() {
485         return I18N.getString(&quot;deb.bundler.name&quot;);
486     }
487 
488     @Override
489     public String getID() {
490         return &quot;deb&quot;;
491     }
492 
493     @Override
494     public boolean supported(boolean runtimeInstaller) {
495         return Platform.isLinux() &amp;&amp; (new ToolValidator(TOOL_DPKG_DEB).validate() == null);
496     }
497 
498     @Override
499     public boolean isDefault() {
500         return isDebian();
501     }
502 }
    </pre>
  </body>
</html>
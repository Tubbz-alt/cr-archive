<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/LauncherData.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IOUtils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PathGroup.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/LauncherData.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
128         final String moduleName;
129         if (sepIdx &gt; 0) {
130             launcherData.qualifiedClassName = mainModule.substring(sepIdx + 1);
131             moduleName = mainModule.substring(0, sepIdx);
132         } else {
133             moduleName = mainModule;
134         }
135         launcherData.modulePath = getModulePath(params);
136 
137         // Try to find module in the specified module path list.
138         ModuleReference moduleRef = JLinkBundlerHelper.createModuleFinder(
139                 launcherData.modulePath).find(moduleName).orElse(null);
140 
141         if (moduleRef != null) {
142             launcherData.moduleInfo = ModuleInfo.fromModuleDescriptor(
143                     moduleRef.descriptor());
144         } else if (params.containsKey(PREDEFINED_RUNTIME_IMAGE.getID())) {
145             // Failed to find module in the specified module path list and
146             // there is external runtime given to jpackage.
147             // Lookup module in this runtime.
<span class="line-modified">148             Path cookedRuntime = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params).toPath();</span>
149             launcherData.moduleInfo = ModuleInfo.fromCookedRuntime(moduleName,
150                     cookedRuntime);
151         }
152 
153         if (launcherData.moduleInfo == null) {
154             throw new ConfigException(MessageFormat.format(I18N.getString(
155                     &quot;error.no-module-in-path&quot;), moduleName), null);
156         }
157 
158         if (launcherData.qualifiedClassName == null) {
159             launcherData.qualifiedClassName = launcherData.moduleInfo.mainClass;
160             if (launcherData.qualifiedClassName == null) {
161                 throw new ConfigException(I18N.getString(&quot;ERR_NoMainClass&quot;), null);
162             }
163         }
164 
165         return launcherData;
166     }
167 
168     private static LauncherData createNonModular(
</pre>
<hr />
<pre>
214         }
215 
216         if (launcherData.qualifiedClassName == null) {
217             throw new ConfigException(MessageFormat.format(I18N.getString(
218                     &quot;error.no-main-class-with-main-jar&quot;),
219                     launcherData.mainJarName), MessageFormat.format(
220                             I18N.getString(
221                                     &quot;error.no-main-class-with-main-jar.advice&quot;),
222                             launcherData.mainJarName));
223         }
224 
225         return launcherData;
226     }
227 
228     private void initClasspath(Map&lt;String, ? super Object&gt; params)
229             throws IOException {
230         Path inputDir = StandardBundlerParam.SOURCE_DIR.fetchFrom(params);
231         if (inputDir == null) {
232             classPath = Collections.emptyList();
233         } else {
<span class="line-modified">234             try (Stream&lt;Path&gt; walk = Files.walk(inputDir, 1)) {</span>
235                 Set&lt;Path&gt; jars = walk.filter(Files::isRegularFile)
236                         .filter(file -&gt; file.toString().endsWith(&quot;.jar&quot;))
<span class="line-modified">237                         .map(Path::getFileName)</span>

238                         .collect(Collectors.toSet());
239                 jars.remove(mainJarName);
240                 classPath = jars.stream().sorted().collect(Collectors.toList());
241             }
242         }
243     }
244 
245     private static String getMainClass(Map&lt;String, ? super Object&gt; params) {
246        return getStringParam(params, Arguments.CLIOptions.APPCLASS.getId());
247     }
248 
249     private static Path getMainJarName(Map&lt;String, ? super Object&gt; params)
250             throws ConfigException {
251        return getPathParam(params, Arguments.CLIOptions.MAIN_JAR.getId());
252     }
253 
254     private static String getMainModule(Map&lt;String, ? super Object&gt; params) {
255        return getStringParam(params, Arguments.CLIOptions.MODULE.getId());
256     }
257 
</pre>
<hr />
<pre>
275         }
276     }
277 
278     private static Path getPathParam(Map&lt;String, ? super Object&gt; params,
279             String paramName) throws ConfigException {
280         return getPathParam(params, paramName, () -&gt; {
281             String value = getStringParam(params, paramName);
282             Path result = null;
283             if (value != null) {
284                 result = Path.of(value);
285             }
286             return result;
287         });
288     }
289 
290     private static List&lt;Path&gt; getModulePath(Map&lt;String, ? super Object&gt; params)
291             throws ConfigException {
292         List&lt;Path&gt; modulePath = getPathListParameter(Arguments.CLIOptions.MODULE_PATH.getId(), params);
293 
294         if (params.containsKey(PREDEFINED_RUNTIME_IMAGE.getID())) {
<span class="line-modified">295             Path runtimePath = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params).toPath();</span>
296             runtimePath = runtimePath.resolve(&quot;lib&quot;);
297             modulePath = Stream.of(modulePath, List.of(runtimePath))
298                     .flatMap(List::stream)
299                     .collect(Collectors.toUnmodifiableList());
300         }
301 
302         return modulePath;
303     }
304 
305     private static List&lt;Path&gt; getPathListParameter(String paramName,
306             Map&lt;String, ? super Object&gt; params) throws ConfigException {
307         return getPathParam(params, paramName, () -&gt; {
308             String value = params.getOrDefault(paramName, &quot;&quot;).toString();
309         return List.of(value.split(File.pathSeparator)).stream()
310                 .map(Path::of)
311                 .collect(Collectors.toUnmodifiableList());
312         });
313     }
314 
315     private String qualifiedClassName;
</pre>
</td>
<td>
<hr />
<pre>
128         final String moduleName;
129         if (sepIdx &gt; 0) {
130             launcherData.qualifiedClassName = mainModule.substring(sepIdx + 1);
131             moduleName = mainModule.substring(0, sepIdx);
132         } else {
133             moduleName = mainModule;
134         }
135         launcherData.modulePath = getModulePath(params);
136 
137         // Try to find module in the specified module path list.
138         ModuleReference moduleRef = JLinkBundlerHelper.createModuleFinder(
139                 launcherData.modulePath).find(moduleName).orElse(null);
140 
141         if (moduleRef != null) {
142             launcherData.moduleInfo = ModuleInfo.fromModuleDescriptor(
143                     moduleRef.descriptor());
144         } else if (params.containsKey(PREDEFINED_RUNTIME_IMAGE.getID())) {
145             // Failed to find module in the specified module path list and
146             // there is external runtime given to jpackage.
147             // Lookup module in this runtime.
<span class="line-modified">148             Path cookedRuntime = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);</span>
149             launcherData.moduleInfo = ModuleInfo.fromCookedRuntime(moduleName,
150                     cookedRuntime);
151         }
152 
153         if (launcherData.moduleInfo == null) {
154             throw new ConfigException(MessageFormat.format(I18N.getString(
155                     &quot;error.no-module-in-path&quot;), moduleName), null);
156         }
157 
158         if (launcherData.qualifiedClassName == null) {
159             launcherData.qualifiedClassName = launcherData.moduleInfo.mainClass;
160             if (launcherData.qualifiedClassName == null) {
161                 throw new ConfigException(I18N.getString(&quot;ERR_NoMainClass&quot;), null);
162             }
163         }
164 
165         return launcherData;
166     }
167 
168     private static LauncherData createNonModular(
</pre>
<hr />
<pre>
214         }
215 
216         if (launcherData.qualifiedClassName == null) {
217             throw new ConfigException(MessageFormat.format(I18N.getString(
218                     &quot;error.no-main-class-with-main-jar&quot;),
219                     launcherData.mainJarName), MessageFormat.format(
220                             I18N.getString(
221                                     &quot;error.no-main-class-with-main-jar.advice&quot;),
222                             launcherData.mainJarName));
223         }
224 
225         return launcherData;
226     }
227 
228     private void initClasspath(Map&lt;String, ? super Object&gt; params)
229             throws IOException {
230         Path inputDir = StandardBundlerParam.SOURCE_DIR.fetchFrom(params);
231         if (inputDir == null) {
232             classPath = Collections.emptyList();
233         } else {
<span class="line-modified">234             try (Stream&lt;Path&gt; walk = Files.walk(inputDir, Integer.MAX_VALUE)) {</span>
235                 Set&lt;Path&gt; jars = walk.filter(Files::isRegularFile)
236                         .filter(file -&gt; file.toString().endsWith(&quot;.jar&quot;))
<span class="line-modified">237                         .map(p -&gt; inputDir.toAbsolutePath()</span>
<span class="line-added">238                                   .relativize(p.toAbsolutePath()))</span>
239                         .collect(Collectors.toSet());
240                 jars.remove(mainJarName);
241                 classPath = jars.stream().sorted().collect(Collectors.toList());
242             }
243         }
244     }
245 
246     private static String getMainClass(Map&lt;String, ? super Object&gt; params) {
247        return getStringParam(params, Arguments.CLIOptions.APPCLASS.getId());
248     }
249 
250     private static Path getMainJarName(Map&lt;String, ? super Object&gt; params)
251             throws ConfigException {
252        return getPathParam(params, Arguments.CLIOptions.MAIN_JAR.getId());
253     }
254 
255     private static String getMainModule(Map&lt;String, ? super Object&gt; params) {
256        return getStringParam(params, Arguments.CLIOptions.MODULE.getId());
257     }
258 
</pre>
<hr />
<pre>
276         }
277     }
278 
279     private static Path getPathParam(Map&lt;String, ? super Object&gt; params,
280             String paramName) throws ConfigException {
281         return getPathParam(params, paramName, () -&gt; {
282             String value = getStringParam(params, paramName);
283             Path result = null;
284             if (value != null) {
285                 result = Path.of(value);
286             }
287             return result;
288         });
289     }
290 
291     private static List&lt;Path&gt; getModulePath(Map&lt;String, ? super Object&gt; params)
292             throws ConfigException {
293         List&lt;Path&gt; modulePath = getPathListParameter(Arguments.CLIOptions.MODULE_PATH.getId(), params);
294 
295         if (params.containsKey(PREDEFINED_RUNTIME_IMAGE.getID())) {
<span class="line-modified">296             Path runtimePath = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);</span>
297             runtimePath = runtimePath.resolve(&quot;lib&quot;);
298             modulePath = Stream.of(modulePath, List.of(runtimePath))
299                     .flatMap(List::stream)
300                     .collect(Collectors.toUnmodifiableList());
301         }
302 
303         return modulePath;
304     }
305 
306     private static List&lt;Path&gt; getPathListParameter(String paramName,
307             Map&lt;String, ? super Object&gt; params) throws ConfigException {
308         return getPathParam(params, paramName, () -&gt; {
309             String value = params.getOrDefault(paramName, &quot;&quot;).toString();
310         return List.of(value.split(File.pathSeparator)).stream()
311                 .map(Path::of)
312                 .collect(Collectors.toUnmodifiableList());
313         });
314     }
315 
316     private String qualifiedClassName;
</pre>
</td>
</tr>
</table>
<center><a href="IOUtils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PathGroup.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
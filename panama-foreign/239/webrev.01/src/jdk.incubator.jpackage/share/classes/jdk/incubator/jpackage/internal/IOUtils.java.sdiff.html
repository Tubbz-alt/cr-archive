<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/IOUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FileAssociation.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LauncherData.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/IOUtils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
 28 import java.io.BufferedReader;
 29 import java.io.InputStreamReader;
 30 import java.io.IOException;
<span class="line-removed"> 31 import java.io.File;</span>
 32 import java.io.PrintStream;
 33 import java.io.Writer;
 34 import java.lang.reflect.InvocationHandler;
 35 import java.lang.reflect.Method;
 36 import java.lang.reflect.Proxy;
 37 import java.nio.file.FileVisitResult;
 38 import java.nio.file.Files;
 39 import java.nio.file.Path;
 40 import java.nio.file.SimpleFileVisitor;
 41 import java.nio.file.StandardCopyOption;
 42 import java.nio.file.attribute.BasicFileAttributes;
 43 import java.util.ArrayList;
 44 import java.util.HashMap;
 45 import java.util.List;
 46 import java.util.Map;
 47 import java.util.Optional;
 48 import javax.xml.stream.XMLOutputFactory;
 49 import javax.xml.stream.XMLStreamException;
 50 import javax.xml.stream.XMLStreamWriter;
 51 
 52 /**
 53  * IOUtils
 54  *
 55  * A collection of static utility methods.
 56  */
 57 public class IOUtils {
 58 
<span class="line-modified"> 59     public static void deleteRecursive(File path) throws IOException {</span>
<span class="line-modified"> 60         if (!path.exists()) {</span>
 61             return;
 62         }
<span class="line-modified"> 63         Path directory = path.toPath();</span>
 64         Files.walkFileTree(directory, new SimpleFileVisitor&lt;Path&gt;() {
 65             @Override
 66             public FileVisitResult visitFile(Path file,
 67                             BasicFileAttributes attr) throws IOException {
 68                 if (Platform.getPlatform() == Platform.WINDOWS) {
 69                     Files.setAttribute(file, &quot;dos:readonly&quot;, false);
 70                 }
 71                 Files.delete(file);
 72                 return FileVisitResult.CONTINUE;
 73             }
 74 
 75             @Override
 76             public FileVisitResult preVisitDirectory(Path dir,
 77                             BasicFileAttributes attr) throws IOException {
 78                 if (Platform.getPlatform() == Platform.WINDOWS) {
 79                     Files.setAttribute(dir, &quot;dos:readonly&quot;, false);
 80                 }
 81                 return FileVisitResult.CONTINUE;
 82             }
 83 
</pre>
<hr />
<pre>
102                     final BasicFileAttributes attrs) throws IOException {
103                 if (excludes.contains(dir.toFile().getName())) {
104                     return FileVisitResult.SKIP_SUBTREE;
105                 } else {
106                     Files.createDirectories(dest.resolve(src.relativize(dir)));
107                     return FileVisitResult.CONTINUE;
108                 }
109             }
110 
111             @Override
112             public FileVisitResult visitFile(final Path file,
113                     final BasicFileAttributes attrs) throws IOException {
114                 if (!excludes.contains(file.toFile().getName())) {
115                     Files.copy(file, dest.resolve(src.relativize(file)));
116                 }
117                 return FileVisitResult.CONTINUE;
118             }
119         });
120     }
121 
<span class="line-modified">122     public static void copyFile(File sourceFile, File destFile)</span>
123             throws IOException {
<span class="line-modified">124         Files.createDirectories(destFile.getParentFile().toPath());</span>
125 
<span class="line-modified">126         Files.copy(sourceFile.toPath(), destFile.toPath(),</span>
127                    StandardCopyOption.REPLACE_EXISTING,
128                    StandardCopyOption.COPY_ATTRIBUTES);
129     }
130 








131     // run &quot;launcher paramfile&quot; in the directory where paramfile is kept
<span class="line-modified">132     public static void run(String launcher, File paramFile)</span>
133             throws IOException {
<span class="line-modified">134         if (paramFile != null &amp;&amp; paramFile.exists()) {</span>
135             ProcessBuilder pb =
<span class="line-modified">136                     new ProcessBuilder(launcher, paramFile.getName());</span>
<span class="line-modified">137             pb = pb.directory(paramFile.getParentFile());</span>
138             exec(pb);
139         }
140     }
141 
142     public static void exec(ProcessBuilder pb)
143             throws IOException {
144         exec(pb, false, null, false);
145     }
146 
147     // See JDK-8236282
148     // Reading output from some processes (currently known &quot;hdiutil attach&quot;)
149     // might hang even if process already exited. Only possible workaround found
150     // in &quot;hdiutil attach&quot; case is to redirect the output to a temp file and then
151     // read this file back.
152     public static void exec(ProcessBuilder pb, boolean writeOutputToFile)
153             throws IOException {
154         exec(pb, false, null, writeOutputToFile);
155     }
156 
157     static void exec(ProcessBuilder pb, boolean testForPresenceOnly,
</pre>
<hr />
<pre>
205                 String line;
206                 while ((line = err.readLine()) != null) {
207                     Log.error(line);
208                 }
209             } catch (IOException ioe) {
210                   Log.verbose(ioe);
211             }
212         });
213         t.setDaemon(true);
214         t.start();
215 
216         int ret = p.waitFor();
217 
218         result.clear();
219         result.addAll(list);
220 
221         return ret;
222     }
223 
224     static void writableOutputDir(Path outdir) throws PackagerException {
<span class="line-modified">225         File file = outdir.toFile();</span>
<span class="line-modified">226 </span>
<span class="line-modified">227         if (!file.isDirectory() &amp;&amp; !file.mkdirs()) {</span>
<span class="line-modified">228             throw new PackagerException(&quot;error.cannot-create-output-dir&quot;,</span>
<span class="line-modified">229                     file.getAbsolutePath());</span>


230         }
<span class="line-modified">231         if (!file.canWrite()) {</span>

232             throw new PackagerException(&quot;error.cannot-write-to-output-dir&quot;,
<span class="line-modified">233                     file.getAbsolutePath());</span>
234         }
235     }
236 
237     public static Path replaceSuffix(Path path, String suffix) {
238         Path parent = path.getParent();
239         String filename = path.getFileName().toString().replaceAll(&quot;\\.[^.]*$&quot;, &quot;&quot;)
240                 + Optional.ofNullable(suffix).orElse(&quot;&quot;);
241         return parent != null ? parent.resolve(filename) : Path.of(filename);
242     }
243 
244     public static Path addSuffix(Path path, String suffix) {
245         Path parent = path.getParent();
246         String filename = path.getFileName().toString() + suffix;
247         return parent != null ? parent.resolve(filename) : Path.of(filename);
248     }
249 
250     public static String getSuffix(Path path) {
251         String filename = replaceSuffix(path.getFileName(), null).toString();
252         return path.getFileName().toString().substring(filename.length());
253     }
</pre>
</td>
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
 28 import java.io.BufferedReader;
 29 import java.io.InputStreamReader;
 30 import java.io.IOException;

 31 import java.io.PrintStream;
 32 import java.io.Writer;
 33 import java.lang.reflect.InvocationHandler;
 34 import java.lang.reflect.Method;
 35 import java.lang.reflect.Proxy;
 36 import java.nio.file.FileVisitResult;
 37 import java.nio.file.Files;
 38 import java.nio.file.Path;
 39 import java.nio.file.SimpleFileVisitor;
 40 import java.nio.file.StandardCopyOption;
 41 import java.nio.file.attribute.BasicFileAttributes;
 42 import java.util.ArrayList;
 43 import java.util.HashMap;
 44 import java.util.List;
 45 import java.util.Map;
 46 import java.util.Optional;
 47 import javax.xml.stream.XMLOutputFactory;
 48 import javax.xml.stream.XMLStreamException;
 49 import javax.xml.stream.XMLStreamWriter;
 50 
 51 /**
 52  * IOUtils
 53  *
 54  * A collection of static utility methods.
 55  */
 56 public class IOUtils {
 57 
<span class="line-modified"> 58     public static void deleteRecursive(Path directory) throws IOException {</span>
<span class="line-modified"> 59         if (!Files.exists(directory)) {</span>
 60             return;
 61         }
<span class="line-modified"> 62 </span>
 63         Files.walkFileTree(directory, new SimpleFileVisitor&lt;Path&gt;() {
 64             @Override
 65             public FileVisitResult visitFile(Path file,
 66                             BasicFileAttributes attr) throws IOException {
 67                 if (Platform.getPlatform() == Platform.WINDOWS) {
 68                     Files.setAttribute(file, &quot;dos:readonly&quot;, false);
 69                 }
 70                 Files.delete(file);
 71                 return FileVisitResult.CONTINUE;
 72             }
 73 
 74             @Override
 75             public FileVisitResult preVisitDirectory(Path dir,
 76                             BasicFileAttributes attr) throws IOException {
 77                 if (Platform.getPlatform() == Platform.WINDOWS) {
 78                     Files.setAttribute(dir, &quot;dos:readonly&quot;, false);
 79                 }
 80                 return FileVisitResult.CONTINUE;
 81             }
 82 
</pre>
<hr />
<pre>
101                     final BasicFileAttributes attrs) throws IOException {
102                 if (excludes.contains(dir.toFile().getName())) {
103                     return FileVisitResult.SKIP_SUBTREE;
104                 } else {
105                     Files.createDirectories(dest.resolve(src.relativize(dir)));
106                     return FileVisitResult.CONTINUE;
107                 }
108             }
109 
110             @Override
111             public FileVisitResult visitFile(final Path file,
112                     final BasicFileAttributes attrs) throws IOException {
113                 if (!excludes.contains(file.toFile().getName())) {
114                     Files.copy(file, dest.resolve(src.relativize(file)));
115                 }
116                 return FileVisitResult.CONTINUE;
117             }
118         });
119     }
120 
<span class="line-modified">121     public static void copyFile(Path sourceFile, Path destFile)</span>
122             throws IOException {
<span class="line-modified">123         Files.createDirectories(destFile.getParent());</span>
124 
<span class="line-modified">125         Files.copy(sourceFile, destFile,</span>
126                    StandardCopyOption.REPLACE_EXISTING,
127                    StandardCopyOption.COPY_ATTRIBUTES);
128     }
129 
<span class="line-added">130     public static boolean exists(Path path) {</span>
<span class="line-added">131         if (path == null) {</span>
<span class="line-added">132             return false;</span>
<span class="line-added">133         }</span>
<span class="line-added">134 </span>
<span class="line-added">135         return Files.exists(path);</span>
<span class="line-added">136     }</span>
<span class="line-added">137 </span>
138     // run &quot;launcher paramfile&quot; in the directory where paramfile is kept
<span class="line-modified">139     public static void run(String launcher, Path paramFile)</span>
140             throws IOException {
<span class="line-modified">141         if (IOUtils.exists(paramFile)) {</span>
142             ProcessBuilder pb =
<span class="line-modified">143                     new ProcessBuilder(launcher, paramFile.getFileName().toString());</span>
<span class="line-modified">144             pb = pb.directory(paramFile.getParent().toFile());</span>
145             exec(pb);
146         }
147     }
148 
149     public static void exec(ProcessBuilder pb)
150             throws IOException {
151         exec(pb, false, null, false);
152     }
153 
154     // See JDK-8236282
155     // Reading output from some processes (currently known &quot;hdiutil attach&quot;)
156     // might hang even if process already exited. Only possible workaround found
157     // in &quot;hdiutil attach&quot; case is to redirect the output to a temp file and then
158     // read this file back.
159     public static void exec(ProcessBuilder pb, boolean writeOutputToFile)
160             throws IOException {
161         exec(pb, false, null, writeOutputToFile);
162     }
163 
164     static void exec(ProcessBuilder pb, boolean testForPresenceOnly,
</pre>
<hr />
<pre>
212                 String line;
213                 while ((line = err.readLine()) != null) {
214                     Log.error(line);
215                 }
216             } catch (IOException ioe) {
217                   Log.verbose(ioe);
218             }
219         });
220         t.setDaemon(true);
221         t.start();
222 
223         int ret = p.waitFor();
224 
225         result.clear();
226         result.addAll(list);
227 
228         return ret;
229     }
230 
231     static void writableOutputDir(Path outdir) throws PackagerException {
<span class="line-modified">232         if (!Files.isDirectory(outdir)) {</span>
<span class="line-modified">233             try {</span>
<span class="line-modified">234                 Files.createDirectories(outdir);</span>
<span class="line-modified">235             } catch (IOException ex) {</span>
<span class="line-modified">236                 throw new PackagerException(&quot;error.cannot-create-output-dir&quot;,</span>
<span class="line-added">237                     outdir.toAbsolutePath().toString());</span>
<span class="line-added">238             }</span>
239         }
<span class="line-modified">240 </span>
<span class="line-added">241         if (!Files.isWritable(outdir)) {</span>
242             throw new PackagerException(&quot;error.cannot-write-to-output-dir&quot;,
<span class="line-modified">243                     outdir.toAbsolutePath().toString());</span>
244         }
245     }
246 
247     public static Path replaceSuffix(Path path, String suffix) {
248         Path parent = path.getParent();
249         String filename = path.getFileName().toString().replaceAll(&quot;\\.[^.]*$&quot;, &quot;&quot;)
250                 + Optional.ofNullable(suffix).orElse(&quot;&quot;);
251         return parent != null ? parent.resolve(filename) : Path.of(filename);
252     }
253 
254     public static Path addSuffix(Path path, String suffix) {
255         Path parent = path.getParent();
256         String filename = path.getFileName().toString() + suffix;
257         return parent != null ? parent.resolve(filename) : Path.of(filename);
258     }
259 
260     public static String getSuffix(Path path) {
261         String filename = replaceSuffix(path.getFileName(), null).toString();
262         return path.getFileName().toString().substring(filename.length());
263     }
</pre>
</td>
</tr>
</table>
<center><a href="FileAssociation.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LauncherData.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
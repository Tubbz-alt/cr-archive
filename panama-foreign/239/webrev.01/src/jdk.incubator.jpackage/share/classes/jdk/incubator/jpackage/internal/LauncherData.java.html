<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/LauncherData.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.incubator.jpackage.internal;
 26 
 27 import java.io.File;
 28 import java.io.IOException;
 29 import java.io.Reader;
 30 import java.lang.module.ModuleDescriptor;
 31 import java.lang.module.ModuleReference;
 32 import java.nio.file.Files;
 33 import java.nio.file.InvalidPathException;
 34 import java.nio.file.Path;
 35 import java.text.MessageFormat;
 36 import java.util.Collections;
 37 import java.util.List;
 38 import java.util.Map;
 39 import java.util.Objects;
 40 import java.util.Optional;
 41 import java.util.Properties;
 42 import java.util.Set;
 43 import java.util.function.Supplier;
 44 import java.util.jar.Attributes;
 45 import java.util.jar.JarFile;
 46 import java.util.jar.Manifest;
 47 import java.util.stream.Collectors;
 48 import java.util.stream.Stream;
 49 import static jdk.incubator.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;
 50 
 51 /**
 52  * Extracts data needed to run application from parameters.
 53  */
 54 final class LauncherData {
 55     boolean isModular() {
 56         return moduleInfo != null;
 57     }
 58 
 59     String qualifiedClassName() {
 60         return qualifiedClassName;
 61     }
 62 
 63     String packageName() {
 64         int sepIdx = qualifiedClassName.lastIndexOf(&#39;.&#39;);
 65         if (sepIdx &lt; 0) {
 66             return &quot;&quot;;
 67         }
 68         return qualifiedClassName.substring(sepIdx + 1);
 69     }
 70 
 71     String moduleName() {
 72         verifyIsModular(true);
 73         return moduleInfo.name;
 74     }
 75 
 76     List&lt;Path&gt; modulePath() {
 77         verifyIsModular(true);
 78         return modulePath;
 79     }
 80 
 81     Path mainJarName() {
 82         verifyIsModular(false);
 83         return mainJarName;
 84     }
 85 
 86     List&lt;Path&gt; classPath() {
 87         return classPath;
 88     }
 89 
 90     String getAppVersion() {
 91         if (isModular()) {
 92             return moduleInfo.version;
 93         }
 94 
 95         return null;
 96     }
 97 
 98     private LauncherData() {
 99     }
100 
101     private void verifyIsModular(boolean isModular) {
102         if ((moduleInfo != null) != isModular) {
103             throw new IllegalStateException();
104         }
105     }
106 
107     static LauncherData create(Map&lt;String, ? super Object&gt; params) throws
108             ConfigException, IOException {
109 
110         final String mainModule = getMainModule(params);
111         final LauncherData result;
112         if (mainModule == null) {
113             result = createNonModular(params);
114         } else {
115             result = createModular(mainModule, params);
116         }
117         result.initClasspath(params);
118         return result;
119     }
120 
121     private static LauncherData createModular(String mainModule,
122             Map&lt;String, ? super Object&gt; params) throws ConfigException,
123             IOException {
124 
125         LauncherData launcherData = new LauncherData();
126 
127         final int sepIdx = mainModule.indexOf(&quot;/&quot;);
128         final String moduleName;
129         if (sepIdx &gt; 0) {
130             launcherData.qualifiedClassName = mainModule.substring(sepIdx + 1);
131             moduleName = mainModule.substring(0, sepIdx);
132         } else {
133             moduleName = mainModule;
134         }
135         launcherData.modulePath = getModulePath(params);
136 
137         // Try to find module in the specified module path list.
138         ModuleReference moduleRef = JLinkBundlerHelper.createModuleFinder(
139                 launcherData.modulePath).find(moduleName).orElse(null);
140 
141         if (moduleRef != null) {
142             launcherData.moduleInfo = ModuleInfo.fromModuleDescriptor(
143                     moduleRef.descriptor());
144         } else if (params.containsKey(PREDEFINED_RUNTIME_IMAGE.getID())) {
145             // Failed to find module in the specified module path list and
146             // there is external runtime given to jpackage.
147             // Lookup module in this runtime.
148             Path cookedRuntime = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);
149             launcherData.moduleInfo = ModuleInfo.fromCookedRuntime(moduleName,
150                     cookedRuntime);
151         }
152 
153         if (launcherData.moduleInfo == null) {
154             throw new ConfigException(MessageFormat.format(I18N.getString(
155                     &quot;error.no-module-in-path&quot;), moduleName), null);
156         }
157 
158         if (launcherData.qualifiedClassName == null) {
159             launcherData.qualifiedClassName = launcherData.moduleInfo.mainClass;
160             if (launcherData.qualifiedClassName == null) {
161                 throw new ConfigException(I18N.getString(&quot;ERR_NoMainClass&quot;), null);
162             }
163         }
164 
165         return launcherData;
166     }
167 
168     private static LauncherData createNonModular(
169             Map&lt;String, ? super Object&gt; params) throws ConfigException, IOException {
170         LauncherData launcherData = new LauncherData();
171 
172         launcherData.qualifiedClassName = getMainClass(params);
173 
174         launcherData.mainJarName = getMainJarName(params);
175         if (launcherData.mainJarName == null &amp;&amp; launcherData.qualifiedClassName
176                 == null) {
177             throw new ConfigException(I18N.getString(&quot;error.no-main-jar-parameter&quot;),
178                     null);
179         }
180 
181         Path mainJarDir = StandardBundlerParam.SOURCE_DIR.fetchFrom(params);
182         if (mainJarDir == null &amp;&amp; launcherData.qualifiedClassName == null) {
183             throw new ConfigException(I18N.getString(&quot;error.no-input-parameter&quot;),
184                     null);
185         }
186 
187         final Path mainJarPath;
188         if (launcherData.mainJarName != null &amp;&amp; mainJarDir != null) {
189             mainJarPath = mainJarDir.resolve(launcherData.mainJarName);
190             if (!Files.exists(mainJarPath)) {
191                 throw new ConfigException(MessageFormat.format(I18N.getString(
192                         &quot;error.main-jar-does-not-exist&quot;),
193                         launcherData.mainJarName), I18N.getString(
194                         &quot;error.main-jar-does-not-exist.advice&quot;));
195             }
196         } else {
197             mainJarPath = null;
198         }
199 
200         if (launcherData.qualifiedClassName == null) {
201             if (mainJarPath == null) {
202                 throw new ConfigException(I18N.getString(&quot;error.no-main-class&quot;),
203                         I18N.getString(&quot;error.no-main-class.advice&quot;));
204             }
205 
206             try (JarFile jf = new JarFile(mainJarPath.toFile())) {
207                 Manifest m = jf.getManifest();
208                 Attributes attrs = (m != null) ? m.getMainAttributes() : null;
209                 if (attrs != null) {
210                     launcherData.qualifiedClassName = attrs.getValue(
211                             Attributes.Name.MAIN_CLASS);
212                 }
213             }
214         }
215 
216         if (launcherData.qualifiedClassName == null) {
217             throw new ConfigException(MessageFormat.format(I18N.getString(
218                     &quot;error.no-main-class-with-main-jar&quot;),
219                     launcherData.mainJarName), MessageFormat.format(
220                             I18N.getString(
221                                     &quot;error.no-main-class-with-main-jar.advice&quot;),
222                             launcherData.mainJarName));
223         }
224 
225         return launcherData;
226     }
227 
228     private void initClasspath(Map&lt;String, ? super Object&gt; params)
229             throws IOException {
230         Path inputDir = StandardBundlerParam.SOURCE_DIR.fetchFrom(params);
231         if (inputDir == null) {
232             classPath = Collections.emptyList();
233         } else {
234             try (Stream&lt;Path&gt; walk = Files.walk(inputDir, Integer.MAX_VALUE)) {
235                 Set&lt;Path&gt; jars = walk.filter(Files::isRegularFile)
236                         .filter(file -&gt; file.toString().endsWith(&quot;.jar&quot;))
237                         .map(p -&gt; inputDir.toAbsolutePath()
238                                   .relativize(p.toAbsolutePath()))
239                         .collect(Collectors.toSet());
240                 jars.remove(mainJarName);
241                 classPath = jars.stream().sorted().collect(Collectors.toList());
242             }
243         }
244     }
245 
246     private static String getMainClass(Map&lt;String, ? super Object&gt; params) {
247        return getStringParam(params, Arguments.CLIOptions.APPCLASS.getId());
248     }
249 
250     private static Path getMainJarName(Map&lt;String, ? super Object&gt; params)
251             throws ConfigException {
252        return getPathParam(params, Arguments.CLIOptions.MAIN_JAR.getId());
253     }
254 
255     private static String getMainModule(Map&lt;String, ? super Object&gt; params) {
256        return getStringParam(params, Arguments.CLIOptions.MODULE.getId());
257     }
258 
259     private static String getStringParam(Map&lt;String, ? super Object&gt; params,
260             String paramName) {
261         Optional&lt;Object&gt; value = Optional.ofNullable(params.get(paramName));
262         if (value.isPresent()) {
263             return value.get().toString();
264         }
265         return null;
266     }
267 
268     private static &lt;T&gt; T getPathParam(Map&lt;String, ? super Object&gt; params,
269             String paramName, Supplier&lt;T&gt; func) throws ConfigException {
270         try {
271             return func.get();
272         } catch (InvalidPathException ex) {
273             throw new ConfigException(MessageFormat.format(I18N.getString(
274                     &quot;error.not-path-parameter&quot;), paramName,
275                     ex.getLocalizedMessage()), null, ex);
276         }
277     }
278 
279     private static Path getPathParam(Map&lt;String, ? super Object&gt; params,
280             String paramName) throws ConfigException {
281         return getPathParam(params, paramName, () -&gt; {
282             String value = getStringParam(params, paramName);
283             Path result = null;
284             if (value != null) {
285                 result = Path.of(value);
286             }
287             return result;
288         });
289     }
290 
291     private static List&lt;Path&gt; getModulePath(Map&lt;String, ? super Object&gt; params)
292             throws ConfigException {
293         List&lt;Path&gt; modulePath = getPathListParameter(Arguments.CLIOptions.MODULE_PATH.getId(), params);
294 
295         if (params.containsKey(PREDEFINED_RUNTIME_IMAGE.getID())) {
296             Path runtimePath = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);
297             runtimePath = runtimePath.resolve(&quot;lib&quot;);
298             modulePath = Stream.of(modulePath, List.of(runtimePath))
299                     .flatMap(List::stream)
300                     .collect(Collectors.toUnmodifiableList());
301         }
302 
303         return modulePath;
304     }
305 
306     private static List&lt;Path&gt; getPathListParameter(String paramName,
307             Map&lt;String, ? super Object&gt; params) throws ConfigException {
308         return getPathParam(params, paramName, () -&gt; {
309             String value = params.getOrDefault(paramName, &quot;&quot;).toString();
310         return List.of(value.split(File.pathSeparator)).stream()
311                 .map(Path::of)
312                 .collect(Collectors.toUnmodifiableList());
313         });
314     }
315 
316     private String qualifiedClassName;
317     private Path mainJarName;
318     private List&lt;Path&gt; classPath;
319     private List&lt;Path&gt; modulePath;
320     private ModuleInfo moduleInfo;
321 
322     private static final class ModuleInfo {
323         String name;
324         String version;
325         String mainClass;
326 
327         static ModuleInfo fromModuleDescriptor(ModuleDescriptor md) {
328             ModuleInfo result = new ModuleInfo();
329             result.name = md.name();
330             result.mainClass = md.mainClass().orElse(null);
331 
332             ModuleDescriptor.Version ver = md.version().orElse(null);
333             if (ver != null) {
334                 result.version = ver.toString();
335             } else {
336                 result.version = md.rawVersion().orElse(null);
337             }
338 
339             return result;
340         }
341 
342         static ModuleInfo fromCookedRuntime(String moduleName,
343                 Path cookedRuntime) {
344             Objects.requireNonNull(moduleName);
345 
346             // We can&#39;t extract info about version and main class of a module
347             // linked in external runtime without running ModuleFinder in that
348             // runtime. But this is too much work as the runtime might have been
349             // coocked without native launchers. So just make sure the module
350             // is linked in the runtime by simply analysing the data
351             // of `release` file.
352 
353             final Path releaseFile;
354             if (!Platform.isMac()) {
355                 releaseFile = cookedRuntime.resolve(&quot;release&quot;);
356             } else {
357                 // On Mac `cookedRuntime` can be runtime root or runtime home.
358                 Path runtimeHome = cookedRuntime.resolve(&quot;Contents/Home&quot;);
359                 if (!Files.isDirectory(runtimeHome)) {
360                     runtimeHome = cookedRuntime;
361                 }
362                 releaseFile = runtimeHome.resolve(&quot;release&quot;);
363             }
364 
365             try (Reader reader = Files.newBufferedReader(releaseFile)) {
366                 Properties props = new Properties();
367                 props.load(reader);
368                 String moduleList = props.getProperty(&quot;MODULES&quot;);
369                 if (moduleList == null) {
370                     return null;
371                 }
372 
373                 if ((moduleList.startsWith(&quot;\&quot;&quot;) &amp;&amp; moduleList.endsWith(&quot;\&quot;&quot;))
374                         || (moduleList.startsWith(&quot;\&#39;&quot;) &amp;&amp; moduleList.endsWith(
375                         &quot;\&#39;&quot;))) {
376                     moduleList = moduleList.substring(1, moduleList.length() - 1);
377                 }
378 
379                 if (!List.of(moduleList.split(&quot;\\s+&quot;)).contains(moduleName)) {
380                     return null;
381                 }
382             } catch (IOException|IllegalArgumentException ex) {
383                 Log.verbose(ex);
384                 return null;
385             }
386 
387             ModuleInfo result = new ModuleInfo();
388             result.name = moduleName;
389 
390             return result;
391         }
392     }
393 }
    </pre>
  </body>
</html>
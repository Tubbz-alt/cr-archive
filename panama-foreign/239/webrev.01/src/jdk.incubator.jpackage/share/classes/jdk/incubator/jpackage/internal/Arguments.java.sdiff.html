<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/Arguments.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AppImageFile.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BundleParams.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/Arguments.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.incubator.jpackage.internal;
 26 
<span class="line-removed"> 27 import java.io.File;</span>
<span class="line-removed"> 28 import java.io.FileInputStream;</span>
 29 import java.io.IOException;



 30 import java.nio.file.Paths;
 31 import java.text.MessageFormat;
 32 import java.util.ArrayList;
 33 import java.util.EnumSet;
 34 import java.util.HashMap;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.Properties;
 38 import java.util.ResourceBundle;
 39 import java.util.jar.Attributes;
 40 import java.util.jar.JarFile;
 41 import java.util.jar.Manifest;
 42 import java.util.regex.Matcher;
 43 import java.util.regex.Pattern;
 44 
 45 /**
 46  * Arguments
 47  *
 48  * This class encapsulates and processes the command line arguments,
 49  * in effect, implementing all the work of jpackage tool.
</pre>
<hr />
<pre>
 72     // Boolean
 73     public static final String MAC_LSTYPEISPACKAGE = &quot;mac.LSTypeIsPackage&quot;;
 74     public static final String MAC_LSDOCINPLACE = &quot;mac.LSSupportsOpeningDocumentsInPlace&quot;;
 75     public static final String MAC_UIDOCBROWSER = &quot;mac.UISupportsDocumentBrowser&quot;;
 76      // Array of strings
 77     public static final String MAC_NSEXPORTABLETYPES = &quot;mac.NSExportableTypes&quot;;
 78     public static final String MAC_UTTYPECONFORMSTO = &quot;mac.UTTypeConformsTo&quot;;
 79 
 80     // regexp for parsing args (for example, for additional launchers)
 81     private static Pattern pattern = Pattern.compile(
 82           &quot;(?:(?:([\&quot;&#39;])(?:\\\\\\1|.)*?(?:\\1|$))|(?:\\\\[\&quot;&#39;\\s]|[^\\s]))++&quot;);
 83 
 84     private DeployParams deployParams = null;
 85 
 86     private int pos = 0;
 87     private List&lt;String&gt; argList = null;
 88 
 89     private List&lt;CLIOptions&gt; allOptions = null;
 90 
 91     private String input = null;
<span class="line-modified"> 92     private String output = null;</span>
 93 
 94     private boolean hasMainJar = false;
 95     private boolean hasMainClass = false;
 96     private boolean hasMainModule = false;
 97     public boolean userProvidedBuildRoot = false;
 98 
 99     private String buildRoot = null;
100     private String mainJarPath = null;
101 
102     private static boolean runtimeInstaller = false;
103 
104     private List&lt;AddLauncherArguments&gt; addLaunchers = null;
105 
106     private static Map&lt;String, CLIOptions&gt; argIds = new HashMap&lt;&gt;();
107     private static Map&lt;String, CLIOptions&gt; argShortIds = new HashMap&lt;&gt;();
108 
109     static {
110         // init maps for parsing arguments
111         (EnumSet.allOf(CLIOptions.class)).forEach(option -&gt; {
112             argIds.put(option.getIdWithPrefix(), option);
113             if (option.getShortIdWithPrefix() != null) {
114                 argShortIds.put(option.getShortIdWithPrefix(), option);
115             }
116         });
117     }
118 
119     public Arguments(String[] args) {
120         argList = new ArrayList&lt;String&gt;(args.length);
121         for (String arg : args) {
122             argList.add(arg);
123         }
124         Log.verbose (&quot;\njpackage argument list: \n&quot; + argList + &quot;\n&quot;);
125         pos = 0;
126 
127         deployParams = new DeployParams();
128 
129         allOptions = new ArrayList&lt;&gt;();
130 
131         addLaunchers = new ArrayList&lt;&gt;();
132 
<span class="line-modified">133         output = Paths.get(&quot;&quot;).toAbsolutePath().toString();</span>
<span class="line-modified">134         deployParams.setOutput(new File(output));</span>
135     }
136 
137     // CLIOptions is public for DeployParamsTest
138     public enum CLIOptions {
139         PACKAGE_TYPE(&quot;type&quot;, &quot;t&quot;, OptionCategories.PROPERTY, () -&gt; {
140             context().deployParams.setTargetFormat(popArg());
141         }),
142 
143         INPUT (&quot;input&quot;, &quot;i&quot;, OptionCategories.PROPERTY, () -&gt; {
144             context().input = popArg();
145             setOptionValue(&quot;input&quot;, context().input);
146         }),
147 
148         OUTPUT (&quot;dest&quot;, &quot;d&quot;, OptionCategories.PROPERTY, () -&gt; {
<span class="line-modified">149             context().output = popArg();</span>
<span class="line-modified">150             context().deployParams.setOutput(new File(context().output));</span>
151         }),
152 
153         DESCRIPTION (&quot;description&quot;, OptionCategories.PROPERTY),
154 
155         VENDOR (&quot;vendor&quot;, OptionCategories.PROPERTY),
156 
157         APPCLASS (&quot;main-class&quot;, OptionCategories.PROPERTY, () -&gt; {
158             context().hasMainClass = true;
159             setOptionValue(&quot;main-class&quot;, popArg());
160         }),
161 
162         NAME (&quot;name&quot;, &quot;n&quot;, OptionCategories.PROPERTY),
163 
164         VERBOSE (&quot;verbose&quot;, OptionCategories.PROPERTY, () -&gt; {
165             setOptionValue(&quot;verbose&quot;, true);
166             Log.setVerbose();
167         }),
168 
169         RESOURCE_DIR(&quot;resource-dir&quot;,
170                 OptionCategories.PROPERTY, () -&gt; {
</pre>
<hr />
<pre>
653 
654         // the temp dir needs to be fetched from the params early,
655         // to prevent each copy of the params (such as may be used for
656         // additional launchers) from generating a separate temp dir when
657         // the default is used (the default is a new temp directory)
658         // The bundler.cleanup() below would not otherwise be able to
659         // clean these extra (and unneeded) temp directories.
660         StandardBundlerParam.TEMP_ROOT.fetchFrom(params);
661 
662         // determine what bundler to run
663         jdk.incubator.jpackage.internal.Bundler bundler = getPlatformBundler();
664 
665         if (bundler == null) {
666             throw new PackagerException(&quot;ERR_InvalidInstallerType&quot;,
667                       deployParams.getTargetFormat());
668         }
669 
670         Map&lt;String, ? super Object&gt; localParams = new HashMap&lt;&gt;(params);
671         try {
672             bundler.validate(localParams);
<span class="line-modified">673             File result = bundler.execute(localParams, deployParams.outdir);</span>
674             if (result == null) {
675                 throw new PackagerException(&quot;MSG_BundlerFailed&quot;,
676                         bundler.getID(), bundler.getName());
677             }
678             Log.verbose(MessageFormat.format(
679                     I18N.getString(&quot;message.bundle-created&quot;),
680                     bundler.getName()));
681         } catch (ConfigException e) {
682             Log.verbose(e);
683             if (e.getAdvice() != null)  {
684                 throw new PackagerException(e, &quot;MSG_BundlerConfigException&quot;,
685                         bundler.getName(), e.getMessage(), e.getAdvice());
686             } else {
687                 throw new PackagerException(e,
688                        &quot;MSG_BundlerConfigExceptionNoAdvice&quot;,
689                         bundler.getName(), e.getMessage());
690             }
691         } catch (RuntimeException re) {
692             Log.verbose(re);
693             throw new PackagerException(re, &quot;MSG_BundlerRuntimeException&quot;,
694                     bundler.getName(), re.toString());
695         } finally {
696             if (userProvidedBuildRoot) {
697                 Log.verbose(MessageFormat.format(
698                         I18N.getString(&quot;message.debug-working-directory&quot;),
<span class="line-modified">699                         (new File(buildRoot)).getAbsolutePath()));</span>
700             } else {
701                 // always clean up the temporary directory created
702                 // when --temp option not used.
703                 bundler.cleanup(localParams);
704             }
705         }
706     }
707 
708     static CLIOptions toCLIOption(String arg) {
709         CLIOptions option;
710         if ((option = argIds.get(arg)) == null) {
711             option = argShortIds.get(arg);
712         }
713         return option;
714     }
715 
716     static Map&lt;String, String&gt; getPropertiesFromFile(String filename) {
717         Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
718         // load properties file
<span class="line-removed">719         File file = new File(filename);</span>
720         Properties properties = new Properties();
<span class="line-modified">721         try (FileInputStream in = new FileInputStream(file)) {</span>
<span class="line-modified">722             properties.load(in);</span>
723         } catch (IOException e) {
724             Log.error(&quot;Exception: &quot; + e.getMessage());
725         }
726 
727         for (final String name: properties.stringPropertyNames()) {
728             map.put(name, properties.getProperty(name));
729         }
730 
731         return map;
732     }
733 
734     static List&lt;String&gt; getArgumentList(String inputString) {
735         List&lt;String&gt; list = new ArrayList&lt;&gt;();
736         if (inputString == null || inputString.isEmpty()) {
737              return list;
738         }
739 
740         // The &quot;pattern&quot; regexp attempts to abide to the rule that
741         // strings are delimited by whitespace unless surrounded by
742         // quotes, then it is anything (including spaces) in the quotes.
</pre>
<hr />
<pre>
791                     }
792                 } else {
793                     // opening quote, skip char
794                     quoteChar = code;
795                 }
796             } else {
797                 sb.appendCodePoint(code);
798             }
799         }
800         return sb.toString();
801     }
802 
803     private String getMainClassFromManifest() {
804         if (mainJarPath == null ||
805             input == null ) {
806             return null;
807         }
808 
809         JarFile jf;
810         try {
<span class="line-modified">811             File file = new File(input, mainJarPath);</span>
<span class="line-modified">812             if (!file.exists()) {</span>
813                 return null;
814             }
<span class="line-modified">815             jf = new JarFile(file);</span>
816             Manifest m = jf.getManifest();
817             Attributes attrs = (m != null) ? m.getMainAttributes() : null;
818             if (attrs != null) {
819                 return attrs.getValue(Attributes.Name.MAIN_CLASS);
820             }
821         } catch (IOException ignore) {}
822         return null;
823     }
824 
825     private static void showDeprecation(String option) {
826         Log.error(MessageFormat.format(I18N.getString(&quot;warning.deprecation&quot;),
827                 option));
828     }
829 }
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.incubator.jpackage.internal;
 26 


 27 import java.io.IOException;
<span class="line-added"> 28 import java.io.Reader;</span>
<span class="line-added"> 29 import java.nio.file.Files;</span>
<span class="line-added"> 30 import java.nio.file.Path;</span>
 31 import java.nio.file.Paths;
 32 import java.text.MessageFormat;
 33 import java.util.ArrayList;
 34 import java.util.EnumSet;
 35 import java.util.HashMap;
 36 import java.util.List;
 37 import java.util.Map;
 38 import java.util.Properties;
 39 import java.util.ResourceBundle;
 40 import java.util.jar.Attributes;
 41 import java.util.jar.JarFile;
 42 import java.util.jar.Manifest;
 43 import java.util.regex.Matcher;
 44 import java.util.regex.Pattern;
 45 
 46 /**
 47  * Arguments
 48  *
 49  * This class encapsulates and processes the command line arguments,
 50  * in effect, implementing all the work of jpackage tool.
</pre>
<hr />
<pre>
 73     // Boolean
 74     public static final String MAC_LSTYPEISPACKAGE = &quot;mac.LSTypeIsPackage&quot;;
 75     public static final String MAC_LSDOCINPLACE = &quot;mac.LSSupportsOpeningDocumentsInPlace&quot;;
 76     public static final String MAC_UIDOCBROWSER = &quot;mac.UISupportsDocumentBrowser&quot;;
 77      // Array of strings
 78     public static final String MAC_NSEXPORTABLETYPES = &quot;mac.NSExportableTypes&quot;;
 79     public static final String MAC_UTTYPECONFORMSTO = &quot;mac.UTTypeConformsTo&quot;;
 80 
 81     // regexp for parsing args (for example, for additional launchers)
 82     private static Pattern pattern = Pattern.compile(
 83           &quot;(?:(?:([\&quot;&#39;])(?:\\\\\\1|.)*?(?:\\1|$))|(?:\\\\[\&quot;&#39;\\s]|[^\\s]))++&quot;);
 84 
 85     private DeployParams deployParams = null;
 86 
 87     private int pos = 0;
 88     private List&lt;String&gt; argList = null;
 89 
 90     private List&lt;CLIOptions&gt; allOptions = null;
 91 
 92     private String input = null;
<span class="line-modified"> 93     private Path output = null;</span>
 94 
 95     private boolean hasMainJar = false;
 96     private boolean hasMainClass = false;
 97     private boolean hasMainModule = false;
 98     public boolean userProvidedBuildRoot = false;
 99 
100     private String buildRoot = null;
101     private String mainJarPath = null;
102 
103     private static boolean runtimeInstaller = false;
104 
105     private List&lt;AddLauncherArguments&gt; addLaunchers = null;
106 
107     private static Map&lt;String, CLIOptions&gt; argIds = new HashMap&lt;&gt;();
108     private static Map&lt;String, CLIOptions&gt; argShortIds = new HashMap&lt;&gt;();
109 
110     static {
111         // init maps for parsing arguments
112         (EnumSet.allOf(CLIOptions.class)).forEach(option -&gt; {
113             argIds.put(option.getIdWithPrefix(), option);
114             if (option.getShortIdWithPrefix() != null) {
115                 argShortIds.put(option.getShortIdWithPrefix(), option);
116             }
117         });
118     }
119 
120     public Arguments(String[] args) {
121         argList = new ArrayList&lt;String&gt;(args.length);
122         for (String arg : args) {
123             argList.add(arg);
124         }
125         Log.verbose (&quot;\njpackage argument list: \n&quot; + argList + &quot;\n&quot;);
126         pos = 0;
127 
128         deployParams = new DeployParams();
129 
130         allOptions = new ArrayList&lt;&gt;();
131 
132         addLaunchers = new ArrayList&lt;&gt;();
133 
<span class="line-modified">134         output = Paths.get(&quot;&quot;).toAbsolutePath();</span>
<span class="line-modified">135         deployParams.setOutput(output);</span>
136     }
137 
138     // CLIOptions is public for DeployParamsTest
139     public enum CLIOptions {
140         PACKAGE_TYPE(&quot;type&quot;, &quot;t&quot;, OptionCategories.PROPERTY, () -&gt; {
141             context().deployParams.setTargetFormat(popArg());
142         }),
143 
144         INPUT (&quot;input&quot;, &quot;i&quot;, OptionCategories.PROPERTY, () -&gt; {
145             context().input = popArg();
146             setOptionValue(&quot;input&quot;, context().input);
147         }),
148 
149         OUTPUT (&quot;dest&quot;, &quot;d&quot;, OptionCategories.PROPERTY, () -&gt; {
<span class="line-modified">150             context().output = Path.of(popArg());</span>
<span class="line-modified">151             context().deployParams.setOutput(context().output);</span>
152         }),
153 
154         DESCRIPTION (&quot;description&quot;, OptionCategories.PROPERTY),
155 
156         VENDOR (&quot;vendor&quot;, OptionCategories.PROPERTY),
157 
158         APPCLASS (&quot;main-class&quot;, OptionCategories.PROPERTY, () -&gt; {
159             context().hasMainClass = true;
160             setOptionValue(&quot;main-class&quot;, popArg());
161         }),
162 
163         NAME (&quot;name&quot;, &quot;n&quot;, OptionCategories.PROPERTY),
164 
165         VERBOSE (&quot;verbose&quot;, OptionCategories.PROPERTY, () -&gt; {
166             setOptionValue(&quot;verbose&quot;, true);
167             Log.setVerbose();
168         }),
169 
170         RESOURCE_DIR(&quot;resource-dir&quot;,
171                 OptionCategories.PROPERTY, () -&gt; {
</pre>
<hr />
<pre>
654 
655         // the temp dir needs to be fetched from the params early,
656         // to prevent each copy of the params (such as may be used for
657         // additional launchers) from generating a separate temp dir when
658         // the default is used (the default is a new temp directory)
659         // The bundler.cleanup() below would not otherwise be able to
660         // clean these extra (and unneeded) temp directories.
661         StandardBundlerParam.TEMP_ROOT.fetchFrom(params);
662 
663         // determine what bundler to run
664         jdk.incubator.jpackage.internal.Bundler bundler = getPlatformBundler();
665 
666         if (bundler == null) {
667             throw new PackagerException(&quot;ERR_InvalidInstallerType&quot;,
668                       deployParams.getTargetFormat());
669         }
670 
671         Map&lt;String, ? super Object&gt; localParams = new HashMap&lt;&gt;(params);
672         try {
673             bundler.validate(localParams);
<span class="line-modified">674             Path result = bundler.execute(localParams, deployParams.outdir);</span>
675             if (result == null) {
676                 throw new PackagerException(&quot;MSG_BundlerFailed&quot;,
677                         bundler.getID(), bundler.getName());
678             }
679             Log.verbose(MessageFormat.format(
680                     I18N.getString(&quot;message.bundle-created&quot;),
681                     bundler.getName()));
682         } catch (ConfigException e) {
683             Log.verbose(e);
684             if (e.getAdvice() != null)  {
685                 throw new PackagerException(e, &quot;MSG_BundlerConfigException&quot;,
686                         bundler.getName(), e.getMessage(), e.getAdvice());
687             } else {
688                 throw new PackagerException(e,
689                        &quot;MSG_BundlerConfigExceptionNoAdvice&quot;,
690                         bundler.getName(), e.getMessage());
691             }
692         } catch (RuntimeException re) {
693             Log.verbose(re);
694             throw new PackagerException(re, &quot;MSG_BundlerRuntimeException&quot;,
695                     bundler.getName(), re.toString());
696         } finally {
697             if (userProvidedBuildRoot) {
698                 Log.verbose(MessageFormat.format(
699                         I18N.getString(&quot;message.debug-working-directory&quot;),
<span class="line-modified">700                         (Path.of(buildRoot)).toAbsolutePath().toString()));</span>
701             } else {
702                 // always clean up the temporary directory created
703                 // when --temp option not used.
704                 bundler.cleanup(localParams);
705             }
706         }
707     }
708 
709     static CLIOptions toCLIOption(String arg) {
710         CLIOptions option;
711         if ((option = argIds.get(arg)) == null) {
712             option = argShortIds.get(arg);
713         }
714         return option;
715     }
716 
717     static Map&lt;String, String&gt; getPropertiesFromFile(String filename) {
718         Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
719         // load properties file

720         Properties properties = new Properties();
<span class="line-modified">721         try (Reader reader = Files.newBufferedReader(Path.of(filename))) {</span>
<span class="line-modified">722             properties.load(reader);</span>
723         } catch (IOException e) {
724             Log.error(&quot;Exception: &quot; + e.getMessage());
725         }
726 
727         for (final String name: properties.stringPropertyNames()) {
728             map.put(name, properties.getProperty(name));
729         }
730 
731         return map;
732     }
733 
734     static List&lt;String&gt; getArgumentList(String inputString) {
735         List&lt;String&gt; list = new ArrayList&lt;&gt;();
736         if (inputString == null || inputString.isEmpty()) {
737              return list;
738         }
739 
740         // The &quot;pattern&quot; regexp attempts to abide to the rule that
741         // strings are delimited by whitespace unless surrounded by
742         // quotes, then it is anything (including spaces) in the quotes.
</pre>
<hr />
<pre>
791                     }
792                 } else {
793                     // opening quote, skip char
794                     quoteChar = code;
795                 }
796             } else {
797                 sb.appendCodePoint(code);
798             }
799         }
800         return sb.toString();
801     }
802 
803     private String getMainClassFromManifest() {
804         if (mainJarPath == null ||
805             input == null ) {
806             return null;
807         }
808 
809         JarFile jf;
810         try {
<span class="line-modified">811             Path file = Path.of(input, mainJarPath);</span>
<span class="line-modified">812             if (!Files.exists(file)) {</span>
813                 return null;
814             }
<span class="line-modified">815             jf = new JarFile(file.toFile());</span>
816             Manifest m = jf.getManifest();
817             Attributes attrs = (m != null) ? m.getMainAttributes() : null;
818             if (attrs != null) {
819                 return attrs.getValue(Attributes.Name.MAIN_CLASS);
820             }
821         } catch (IOException ignore) {}
822         return null;
823     }
824 
825     private static void showDeprecation(String option) {
826         Log.error(MessageFormat.format(I18N.getString(&quot;warning.deprecation&quot;),
827                 option));
828     }
829 }
</pre>
</td>
</tr>
</table>
<center><a href="AppImageFile.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BundleParams.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
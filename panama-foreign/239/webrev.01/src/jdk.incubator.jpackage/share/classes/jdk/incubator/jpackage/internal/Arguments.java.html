<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/Arguments.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.incubator.jpackage.internal;
 26 
 27 import java.io.IOException;
 28 import java.io.Reader;
 29 import java.nio.file.Files;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.text.MessageFormat;
 33 import java.util.ArrayList;
 34 import java.util.EnumSet;
 35 import java.util.HashMap;
 36 import java.util.List;
 37 import java.util.Map;
 38 import java.util.Properties;
 39 import java.util.ResourceBundle;
 40 import java.util.jar.Attributes;
 41 import java.util.jar.JarFile;
 42 import java.util.jar.Manifest;
 43 import java.util.regex.Matcher;
 44 import java.util.regex.Pattern;
 45 
 46 /**
 47  * Arguments
 48  *
 49  * This class encapsulates and processes the command line arguments,
 50  * in effect, implementing all the work of jpackage tool.
 51  *
 52  * The primary entry point, processArguments():
 53  * Processes and validates command line arguments, constructing DeployParams.
 54  * Validates the DeployParams, and generate the BundleParams.
 55  * Generates List of Bundlers from BundleParams valid for this platform.
 56  * Executes each Bundler in the list.
 57  */
 58 public class Arguments {
 59     private static final ResourceBundle I18N = ResourceBundle.getBundle(
 60             &quot;jdk.incubator.jpackage.internal.resources.MainResources&quot;);
 61 
 62     private static final String FA_EXTENSIONS = &quot;extension&quot;;
 63     private static final String FA_CONTENT_TYPE = &quot;mime-type&quot;;
 64     private static final String FA_DESCRIPTION = &quot;description&quot;;
 65     private static final String FA_ICON = &quot;icon&quot;;
 66 
 67     // Mac specific file association keys
 68     // String
 69     public static final String MAC_CFBUNDLETYPEROLE = &quot;mac.CFBundleTypeRole&quot;;
 70     public static final String MAC_LSHANDLERRANK = &quot;mac.LSHandlerRank&quot;;
 71     public static final String MAC_NSSTORETYPEKEY = &quot;mac.NSPersistentStoreTypeKey&quot;;
 72     public static final String MAC_NSDOCUMENTCLASS = &quot;mac.NSDocumentClass&quot;;
 73     // Boolean
 74     public static final String MAC_LSTYPEISPACKAGE = &quot;mac.LSTypeIsPackage&quot;;
 75     public static final String MAC_LSDOCINPLACE = &quot;mac.LSSupportsOpeningDocumentsInPlace&quot;;
 76     public static final String MAC_UIDOCBROWSER = &quot;mac.UISupportsDocumentBrowser&quot;;
 77      // Array of strings
 78     public static final String MAC_NSEXPORTABLETYPES = &quot;mac.NSExportableTypes&quot;;
 79     public static final String MAC_UTTYPECONFORMSTO = &quot;mac.UTTypeConformsTo&quot;;
 80 
 81     // regexp for parsing args (for example, for additional launchers)
 82     private static Pattern pattern = Pattern.compile(
 83           &quot;(?:(?:([\&quot;&#39;])(?:\\\\\\1|.)*?(?:\\1|$))|(?:\\\\[\&quot;&#39;\\s]|[^\\s]))++&quot;);
 84 
 85     private DeployParams deployParams = null;
 86 
 87     private int pos = 0;
 88     private List&lt;String&gt; argList = null;
 89 
 90     private List&lt;CLIOptions&gt; allOptions = null;
 91 
 92     private String input = null;
 93     private Path output = null;
 94 
 95     private boolean hasMainJar = false;
 96     private boolean hasMainClass = false;
 97     private boolean hasMainModule = false;
 98     public boolean userProvidedBuildRoot = false;
 99 
100     private String buildRoot = null;
101     private String mainJarPath = null;
102 
103     private static boolean runtimeInstaller = false;
104 
105     private List&lt;AddLauncherArguments&gt; addLaunchers = null;
106 
107     private static Map&lt;String, CLIOptions&gt; argIds = new HashMap&lt;&gt;();
108     private static Map&lt;String, CLIOptions&gt; argShortIds = new HashMap&lt;&gt;();
109 
110     static {
111         // init maps for parsing arguments
112         (EnumSet.allOf(CLIOptions.class)).forEach(option -&gt; {
113             argIds.put(option.getIdWithPrefix(), option);
114             if (option.getShortIdWithPrefix() != null) {
115                 argShortIds.put(option.getShortIdWithPrefix(), option);
116             }
117         });
118     }
119 
120     public Arguments(String[] args) {
121         argList = new ArrayList&lt;String&gt;(args.length);
122         for (String arg : args) {
123             argList.add(arg);
124         }
125         Log.verbose (&quot;\njpackage argument list: \n&quot; + argList + &quot;\n&quot;);
126         pos = 0;
127 
128         deployParams = new DeployParams();
129 
130         allOptions = new ArrayList&lt;&gt;();
131 
132         addLaunchers = new ArrayList&lt;&gt;();
133 
134         output = Paths.get(&quot;&quot;).toAbsolutePath();
135         deployParams.setOutput(output);
136     }
137 
138     // CLIOptions is public for DeployParamsTest
139     public enum CLIOptions {
140         PACKAGE_TYPE(&quot;type&quot;, &quot;t&quot;, OptionCategories.PROPERTY, () -&gt; {
141             context().deployParams.setTargetFormat(popArg());
142         }),
143 
144         INPUT (&quot;input&quot;, &quot;i&quot;, OptionCategories.PROPERTY, () -&gt; {
145             context().input = popArg();
146             setOptionValue(&quot;input&quot;, context().input);
147         }),
148 
149         OUTPUT (&quot;dest&quot;, &quot;d&quot;, OptionCategories.PROPERTY, () -&gt; {
150             context().output = Path.of(popArg());
151             context().deployParams.setOutput(context().output);
152         }),
153 
154         DESCRIPTION (&quot;description&quot;, OptionCategories.PROPERTY),
155 
156         VENDOR (&quot;vendor&quot;, OptionCategories.PROPERTY),
157 
158         APPCLASS (&quot;main-class&quot;, OptionCategories.PROPERTY, () -&gt; {
159             context().hasMainClass = true;
160             setOptionValue(&quot;main-class&quot;, popArg());
161         }),
162 
163         NAME (&quot;name&quot;, &quot;n&quot;, OptionCategories.PROPERTY),
164 
165         VERBOSE (&quot;verbose&quot;, OptionCategories.PROPERTY, () -&gt; {
166             setOptionValue(&quot;verbose&quot;, true);
167             Log.setVerbose();
168         }),
169 
170         RESOURCE_DIR(&quot;resource-dir&quot;,
171                 OptionCategories.PROPERTY, () -&gt; {
172             String resourceDir = popArg();
173             setOptionValue(&quot;resource-dir&quot;, resourceDir);
174         }),
175 
176         ARGUMENTS (&quot;arguments&quot;, OptionCategories.PROPERTY, () -&gt; {
177             List&lt;String&gt; arguments = getArgumentList(popArg());
178             setOptionValue(&quot;arguments&quot;, arguments);
179         }),
180 
181         JLINK_OPTIONS (&quot;jlink-options&quot;, OptionCategories.PROPERTY, () -&gt; {
182             List&lt;String&gt; options = getArgumentList(popArg());
183             setOptionValue(&quot;jlink-options&quot;, options);
184         }),
185 
186         ICON (&quot;icon&quot;, OptionCategories.PROPERTY),
187 
188         COPYRIGHT (&quot;copyright&quot;, OptionCategories.PROPERTY),
189 
190         LICENSE_FILE (&quot;license-file&quot;, OptionCategories.PROPERTY),
191 
192         VERSION (&quot;app-version&quot;, OptionCategories.PROPERTY),
193 
194         RELEASE (&quot;linux-app-release&quot;, OptionCategories.PROPERTY),
195 
196         JAVA_OPTIONS (&quot;java-options&quot;, OptionCategories.PROPERTY, () -&gt; {
197             List&lt;String&gt; args = getArgumentList(popArg());
198             args.forEach(a -&gt; setOptionValue(&quot;java-options&quot;, a));
199         }),
200 
201         FILE_ASSOCIATIONS (&quot;file-associations&quot;,
202                 OptionCategories.PROPERTY, () -&gt; {
203             Map&lt;String, ? super Object&gt; args = new HashMap&lt;&gt;();
204 
205             // load .properties file
206             Map&lt;String, String&gt; initialMap = getPropertiesFromFile(popArg());
207 
208             putUnlessNull(args, StandardBundlerParam.FA_EXTENSIONS.getID(),
209                     initialMap.get(FA_EXTENSIONS));
210 
211             putUnlessNull(args, StandardBundlerParam.FA_CONTENT_TYPE.getID(),
212                     initialMap.get(FA_CONTENT_TYPE));
213 
214             putUnlessNull(args, StandardBundlerParam.FA_DESCRIPTION.getID(),
215                     initialMap.get(FA_DESCRIPTION));
216 
217             putUnlessNull(args, StandardBundlerParam.FA_ICON.getID(),
218                     initialMap.get(FA_ICON));
219 
220             // Mac extended file association arguments
221             putUnlessNull(args, MAC_CFBUNDLETYPEROLE,
222                     initialMap.get(MAC_CFBUNDLETYPEROLE));
223 
224             putUnlessNull(args, MAC_LSHANDLERRANK,
225                     initialMap.get(MAC_LSHANDLERRANK));
226 
227             putUnlessNull(args, MAC_NSSTORETYPEKEY,
228                     initialMap.get(MAC_NSSTORETYPEKEY));
229 
230             putUnlessNull(args, MAC_NSDOCUMENTCLASS,
231                     initialMap.get(MAC_NSDOCUMENTCLASS));
232 
233             putUnlessNull(args, MAC_LSTYPEISPACKAGE,
234                     initialMap.get(MAC_LSTYPEISPACKAGE));
235 
236             putUnlessNull(args, MAC_LSDOCINPLACE,
237                     initialMap.get(MAC_LSDOCINPLACE));
238 
239             putUnlessNull(args, MAC_UIDOCBROWSER,
240                     initialMap.get(MAC_UIDOCBROWSER));
241 
242             putUnlessNull(args, MAC_NSEXPORTABLETYPES,
243                     initialMap.get(MAC_NSEXPORTABLETYPES));
244 
245             putUnlessNull(args, MAC_UTTYPECONFORMSTO,
246                     initialMap.get(MAC_UTTYPECONFORMSTO));
247 
248             ArrayList&lt;Map&lt;String, ? super Object&gt;&gt; associationList =
249                 new ArrayList&lt;Map&lt;String, ? super Object&gt;&gt;();
250 
251             associationList.add(args);
252 
253             // check that we really add _another_ value to the list
254             setOptionValue(&quot;file-associations&quot;, associationList);
255 
256         }),
257 
258         ADD_LAUNCHER (&quot;add-launcher&quot;,
259                     OptionCategories.PROPERTY, () -&gt; {
260             String spec = popArg();
261             String name = null;
262             String filename = spec;
263             if (spec.contains(&quot;=&quot;)) {
264                 String[] values = spec.split(&quot;=&quot;, 2);
265                 name = values[0];
266                 filename = values[1];
267             }
268             context().addLaunchers.add(
269                 new AddLauncherArguments(name, filename));
270         }),
271 
272         TEMP_ROOT (&quot;temp&quot;, OptionCategories.PROPERTY, () -&gt; {
273             context().buildRoot = popArg();
274             context().userProvidedBuildRoot = true;
275             setOptionValue(&quot;temp&quot;, context().buildRoot);
276         }),
277 
278         INSTALL_DIR (&quot;install-dir&quot;, OptionCategories.PROPERTY),
279 
280         PREDEFINED_APP_IMAGE (&quot;app-image&quot;, OptionCategories.PROPERTY),
281 
282         PREDEFINED_RUNTIME_IMAGE (&quot;runtime-image&quot;, OptionCategories.PROPERTY),
283 
284         MAIN_JAR (&quot;main-jar&quot;,  OptionCategories.PROPERTY, () -&gt; {
285             context().mainJarPath = popArg();
286             context().hasMainJar = true;
287             setOptionValue(&quot;main-jar&quot;, context().mainJarPath);
288         }),
289 
290         MODULE (&quot;module&quot;, &quot;m&quot;, OptionCategories.MODULAR, () -&gt; {
291             context().hasMainModule = true;
292             setOptionValue(&quot;module&quot;, popArg());
293         }),
294 
295         ADD_MODULES (&quot;add-modules&quot;, OptionCategories.MODULAR),
296 
297         MODULE_PATH (&quot;module-path&quot;, &quot;p&quot;, OptionCategories.MODULAR),
298 
299         BIND_SERVICES (&quot;bind-services&quot;, OptionCategories.PROPERTY, () -&gt; {
300             showDeprecation(&quot;bind-services&quot;);
301             setOptionValue(&quot;bind-services&quot;, true);
302         }),
303 
304         MAC_SIGN (&quot;mac-sign&quot;, &quot;s&quot;, OptionCategories.PLATFORM_MAC, () -&gt; {
305             setOptionValue(&quot;mac-sign&quot;, true);
306         }),
307 
308         MAC_BUNDLE_NAME (&quot;mac-package-name&quot;, OptionCategories.PLATFORM_MAC),
309 
310         MAC_BUNDLE_IDENTIFIER(&quot;mac-package-identifier&quot;,
311                     OptionCategories.PLATFORM_MAC),
312 
313         MAC_BUNDLE_SIGNING_PREFIX (&quot;mac-package-signing-prefix&quot;,
314                     OptionCategories.PLATFORM_MAC),
315 
316         MAC_SIGNING_KEY_NAME (&quot;mac-signing-key-user-name&quot;,
317                     OptionCategories.PLATFORM_MAC),
318 
319         MAC_SIGNING_KEYCHAIN (&quot;mac-signing-keychain&quot;,
320                     OptionCategories.PLATFORM_MAC),
321 
322         WIN_MENU_HINT (&quot;win-menu&quot;, OptionCategories.PLATFORM_WIN, () -&gt; {
323             setOptionValue(&quot;win-menu&quot;, true);
324         }),
325 
326         WIN_MENU_GROUP (&quot;win-menu-group&quot;, OptionCategories.PLATFORM_WIN),
327 
328         WIN_SHORTCUT_HINT (&quot;win-shortcut&quot;,
329                 OptionCategories.PLATFORM_WIN, () -&gt; {
330             setOptionValue(&quot;win-shortcut&quot;, true);
331         }),
332 
333         WIN_PER_USER_INSTALLATION (&quot;win-per-user-install&quot;,
334                 OptionCategories.PLATFORM_WIN, () -&gt; {
335             setOptionValue(&quot;win-per-user-install&quot;, false);
336         }),
337 
338         WIN_DIR_CHOOSER (&quot;win-dir-chooser&quot;,
339                 OptionCategories.PLATFORM_WIN, () -&gt; {
340             setOptionValue(&quot;win-dir-chooser&quot;, true);
341         }),
342 
343         WIN_UPGRADE_UUID (&quot;win-upgrade-uuid&quot;,
344                 OptionCategories.PLATFORM_WIN),
345 
346         WIN_CONSOLE_HINT (&quot;win-console&quot;, OptionCategories.PLATFORM_WIN, () -&gt; {
347             setOptionValue(&quot;win-console&quot;, true);
348         }),
349 
350         LINUX_BUNDLE_NAME (&quot;linux-package-name&quot;,
351                 OptionCategories.PLATFORM_LINUX),
352 
353         LINUX_DEB_MAINTAINER (&quot;linux-deb-maintainer&quot;,
354                 OptionCategories.PLATFORM_LINUX),
355 
356         LINUX_CATEGORY (&quot;linux-app-category&quot;,
357                 OptionCategories.PLATFORM_LINUX),
358 
359         LINUX_RPM_LICENSE_TYPE (&quot;linux-rpm-license-type&quot;,
360                 OptionCategories.PLATFORM_LINUX),
361 
362         LINUX_PACKAGE_DEPENDENCIES (&quot;linux-package-deps&quot;,
363                 OptionCategories.PLATFORM_LINUX),
364 
365         LINUX_SHORTCUT_HINT (&quot;linux-shortcut&quot;,
366                 OptionCategories.PLATFORM_LINUX, () -&gt; {
367             setOptionValue(&quot;linux-shortcut&quot;, true);
368         }),
369 
370         LINUX_MENU_GROUP (&quot;linux-menu-group&quot;, OptionCategories.PLATFORM_LINUX);
371 
372         private final String id;
373         private final String shortId;
374         private final OptionCategories category;
375         private final Runnable action;
376         private static Arguments argContext;
377 
378         private CLIOptions(String id, OptionCategories category) {
379             this(id, null, category, null);
380         }
381 
382         private CLIOptions(String id, String shortId,
383                            OptionCategories category) {
384             this(id, shortId, category, null);
385         }
386 
387         private CLIOptions(String id,
388                 OptionCategories category, Runnable action) {
389             this(id, null, category, action);
390         }
391 
392         private CLIOptions(String id, String shortId,
393                            OptionCategories category, Runnable action) {
394             this.id = id;
395             this.shortId = shortId;
396             this.action = action;
397             this.category = category;
398         }
399 
400         static void setContext(Arguments context) {
401             argContext = context;
402         }
403 
404         public static Arguments context() {
405             if (argContext != null) {
406                 return argContext;
407             } else {
408                 throw new RuntimeException(&quot;Argument context is not set.&quot;);
409             }
410         }
411 
412         public String getId() {
413             return this.id;
414         }
415 
416         String getIdWithPrefix() {
417             return &quot;--&quot; + this.id;
418         }
419 
420         String getShortIdWithPrefix() {
421             return this.shortId == null ? null : &quot;-&quot; + this.shortId;
422         }
423 
424         void execute() {
425             if (action != null) {
426                 action.run();
427             } else {
428                 defaultAction();
429             }
430         }
431 
432         private void defaultAction() {
433             context().deployParams.addBundleArgument(id, popArg());
434         }
435 
436         private static void setOptionValue(String option, Object value) {
437             context().deployParams.addBundleArgument(option, value);
438         }
439 
440         private static String popArg() {
441             nextArg();
442             return (context().pos &gt;= context().argList.size()) ?
443                             &quot;&quot; : context().argList.get(context().pos);
444         }
445 
446         private static String getArg() {
447             return (context().pos &gt;= context().argList.size()) ?
448                         &quot;&quot; : context().argList.get(context().pos);
449         }
450 
451         private static void nextArg() {
452             context().pos++;
453         }
454 
455         private static boolean hasNextArg() {
456             return context().pos &lt; context().argList.size();
457         }
458     }
459 
460     enum OptionCategories {
461         MODULAR,
462         PROPERTY,
463         PLATFORM_MAC,
464         PLATFORM_WIN,
465         PLATFORM_LINUX;
466     }
467 
468     public boolean processArguments() {
469         try {
470 
471             // init context of arguments
472             CLIOptions.setContext(this);
473 
474             // parse cmd line
475             String arg;
476             CLIOptions option;
477             for (; CLIOptions.hasNextArg(); CLIOptions.nextArg()) {
478                 arg = CLIOptions.getArg();
479                 if ((option = toCLIOption(arg)) != null) {
480                     // found a CLI option
481                     allOptions.add(option);
482                     option.execute();
483                 } else {
484                     throw new PackagerException(&quot;ERR_InvalidOption&quot;, arg);
485                 }
486             }
487 
488             if (hasMainJar &amp;&amp; !hasMainClass) {
489                 // try to get main-class from manifest
490                 String mainClass = getMainClassFromManifest();
491                 if (mainClass != null) {
492                     CLIOptions.setOptionValue(
493                             CLIOptions.APPCLASS.getId(), mainClass);
494                 }
495             }
496 
497             // display error for arguments that are not supported
498             // for current configuration.
499 
500             validateArguments();
501 
502             List&lt;Map&lt;String, ? super Object&gt;&gt; launchersAsMap =
503                     new ArrayList&lt;&gt;();
504 
505             for (AddLauncherArguments sl : addLaunchers) {
506                 launchersAsMap.add(sl.getLauncherMap());
507             }
508 
509             deployParams.addBundleArgument(
510                     StandardBundlerParam.ADD_LAUNCHERS.getID(),
511                     launchersAsMap);
512 
513             // at this point deployParams should be already configured
514 
515             deployParams.validate();
516 
517             BundleParams bp = deployParams.getBundleParams();
518 
519             // validate name(s)
520             ArrayList&lt;String&gt; usedNames = new ArrayList&lt;String&gt;();
521             usedNames.add(bp.getName()); // add main app name
522 
523             for (AddLauncherArguments sl : addLaunchers) {
524                 Map&lt;String, ? super Object&gt; slMap = sl.getLauncherMap();
525                 String slName =
526                         (String) slMap.get(Arguments.CLIOptions.NAME.getId());
527                 if (slName == null) {
528                     throw new PackagerException(&quot;ERR_NoAddLauncherName&quot;);
529                 }
530                 // same rules apply to additional launcher names as app name
531                 DeployParams.validateName(slName, false);
532                 for (String usedName : usedNames) {
533                     if (slName.equals(usedName)) {
534                         throw new PackagerException(&quot;ERR_NoUniqueName&quot;);
535                     }
536                 }
537                 usedNames.add(slName);
538             }
539             if (runtimeInstaller &amp;&amp; bp.getName() == null) {
540                 throw new PackagerException(&quot;ERR_NoJreInstallerName&quot;);
541             }
542 
543             generateBundle(bp.getBundleParamsAsMap());
544             return true;
545         } catch (Exception e) {
546             if (Log.isVerbose()) {
547                 Log.verbose(e);
548             } else {
549                 String msg1 = e.getMessage();
550                 Log.error(msg1);
551                 if (e.getCause() != null &amp;&amp; e.getCause() != e) {
552                     String msg2 = e.getCause().getMessage();
553                     if (msg2 != null &amp;&amp; !msg1.contains(msg2)) {
554                         Log.error(msg2);
555                     }
556                 }
557             }
558             return false;
559         }
560     }
561 
562     private void validateArguments() throws PackagerException {
563         String type = deployParams.getTargetFormat();
564         String ptype = (type != null) ? type : &quot;default&quot;;
565         boolean imageOnly = deployParams.isTargetAppImage();
566         boolean hasAppImage = allOptions.contains(
567                 CLIOptions.PREDEFINED_APP_IMAGE);
568         boolean hasRuntime = allOptions.contains(
569                 CLIOptions.PREDEFINED_RUNTIME_IMAGE);
570         boolean installerOnly = !imageOnly &amp;&amp; hasAppImage;
571         runtimeInstaller = !imageOnly &amp;&amp; hasRuntime &amp;&amp; !hasAppImage &amp;&amp;
572                 !hasMainModule &amp;&amp; !hasMainJar;
573 
574         for (CLIOptions option : allOptions) {
575             if (!ValidOptions.checkIfSupported(option)) {
576                 // includes option valid only on different platform
577                 throw new PackagerException(&quot;ERR_UnsupportedOption&quot;,
578                         option.getIdWithPrefix());
579             }
580             if (imageOnly) {
581                 if (!ValidOptions.checkIfImageSupported(option)) {
582                     throw new PackagerException(&quot;ERR_InvalidTypeOption&quot;,
583                         option.getIdWithPrefix(), type);
584                 }
585             } else if (installerOnly || runtimeInstaller) {
586                 if (!ValidOptions.checkIfInstallerSupported(option)) {
587                     if (runtimeInstaller) {
588                         throw new PackagerException(&quot;ERR_NoInstallerEntryPoint&quot;,
589                             option.getIdWithPrefix());
590                     } else {
591                         throw new PackagerException(&quot;ERR_InvalidTypeOption&quot;,
592                             option.getIdWithPrefix(), ptype);
593                    }
594                 }
595             }
596         }
597         if (hasRuntime) {
598             if (hasAppImage) {
599                 // note --runtime-image is only for image or runtime installer.
600                 throw new PackagerException(&quot;ERR_MutuallyExclusiveOptions&quot;,
601                         CLIOptions.PREDEFINED_RUNTIME_IMAGE.getIdWithPrefix(),
602                         CLIOptions.PREDEFINED_APP_IMAGE.getIdWithPrefix());
603             }
604             if (allOptions.contains(CLIOptions.ADD_MODULES)) {
605                 throw new PackagerException(&quot;ERR_MutuallyExclusiveOptions&quot;,
606                         CLIOptions.PREDEFINED_RUNTIME_IMAGE.getIdWithPrefix(),
607                         CLIOptions.ADD_MODULES.getIdWithPrefix());
608             }
609             if (allOptions.contains(CLIOptions.BIND_SERVICES)) {
610                 throw new PackagerException(&quot;ERR_MutuallyExclusiveOptions&quot;,
611                         CLIOptions.PREDEFINED_RUNTIME_IMAGE.getIdWithPrefix(),
612                         CLIOptions.BIND_SERVICES.getIdWithPrefix());
613             }
614             if (allOptions.contains(CLIOptions.JLINK_OPTIONS)) {
615                 throw new PackagerException(&quot;ERR_MutuallyExclusiveOptions&quot;,
616                         CLIOptions.PREDEFINED_RUNTIME_IMAGE.getIdWithPrefix(),
617                         CLIOptions.JLINK_OPTIONS.getIdWithPrefix());
618             }
619         }
620         if (hasMainJar &amp;&amp; hasMainModule) {
621             throw new PackagerException(&quot;ERR_BothMainJarAndModule&quot;);
622         }
623         if (imageOnly &amp;&amp; !hasMainJar &amp;&amp; !hasMainModule) {
624             throw new PackagerException(&quot;ERR_NoEntryPoint&quot;);
625         }
626     }
627 
628     private jdk.incubator.jpackage.internal.Bundler getPlatformBundler() {
629         boolean appImage = deployParams.isTargetAppImage();
630         String type = deployParams.getTargetFormat();
631         String bundleType = (appImage ?  &quot;IMAGE&quot; : &quot;INSTALLER&quot;);
632 
633         for (jdk.incubator.jpackage.internal.Bundler bundler :
634                 Bundlers.createBundlersInstance().getBundlers(bundleType)) {
635             if (type == null) {
636                  if (bundler.isDefault()
637                          &amp;&amp; bundler.supported(runtimeInstaller)) {
638                      return bundler;
639                  }
640             } else {
641                  if ((appImage || type.equalsIgnoreCase(bundler.getID()))
642                          &amp;&amp; bundler.supported(runtimeInstaller)) {
643                      return bundler;
644                  }
645             }
646         }
647         return null;
648     }
649 
650     private void generateBundle(Map&lt;String,? super Object&gt; params)
651             throws PackagerException {
652 
653         boolean bundleCreated = false;
654 
655         // the temp dir needs to be fetched from the params early,
656         // to prevent each copy of the params (such as may be used for
657         // additional launchers) from generating a separate temp dir when
658         // the default is used (the default is a new temp directory)
659         // The bundler.cleanup() below would not otherwise be able to
660         // clean these extra (and unneeded) temp directories.
661         StandardBundlerParam.TEMP_ROOT.fetchFrom(params);
662 
663         // determine what bundler to run
664         jdk.incubator.jpackage.internal.Bundler bundler = getPlatformBundler();
665 
666         if (bundler == null) {
667             throw new PackagerException(&quot;ERR_InvalidInstallerType&quot;,
668                       deployParams.getTargetFormat());
669         }
670 
671         Map&lt;String, ? super Object&gt; localParams = new HashMap&lt;&gt;(params);
672         try {
673             bundler.validate(localParams);
674             Path result = bundler.execute(localParams, deployParams.outdir);
675             if (result == null) {
676                 throw new PackagerException(&quot;MSG_BundlerFailed&quot;,
677                         bundler.getID(), bundler.getName());
678             }
679             Log.verbose(MessageFormat.format(
680                     I18N.getString(&quot;message.bundle-created&quot;),
681                     bundler.getName()));
682         } catch (ConfigException e) {
683             Log.verbose(e);
684             if (e.getAdvice() != null)  {
685                 throw new PackagerException(e, &quot;MSG_BundlerConfigException&quot;,
686                         bundler.getName(), e.getMessage(), e.getAdvice());
687             } else {
688                 throw new PackagerException(e,
689                        &quot;MSG_BundlerConfigExceptionNoAdvice&quot;,
690                         bundler.getName(), e.getMessage());
691             }
692         } catch (RuntimeException re) {
693             Log.verbose(re);
694             throw new PackagerException(re, &quot;MSG_BundlerRuntimeException&quot;,
695                     bundler.getName(), re.toString());
696         } finally {
697             if (userProvidedBuildRoot) {
698                 Log.verbose(MessageFormat.format(
699                         I18N.getString(&quot;message.debug-working-directory&quot;),
700                         (Path.of(buildRoot)).toAbsolutePath().toString()));
701             } else {
702                 // always clean up the temporary directory created
703                 // when --temp option not used.
704                 bundler.cleanup(localParams);
705             }
706         }
707     }
708 
709     static CLIOptions toCLIOption(String arg) {
710         CLIOptions option;
711         if ((option = argIds.get(arg)) == null) {
712             option = argShortIds.get(arg);
713         }
714         return option;
715     }
716 
717     static Map&lt;String, String&gt; getPropertiesFromFile(String filename) {
718         Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
719         // load properties file
720         Properties properties = new Properties();
721         try (Reader reader = Files.newBufferedReader(Path.of(filename))) {
722             properties.load(reader);
723         } catch (IOException e) {
724             Log.error(&quot;Exception: &quot; + e.getMessage());
725         }
726 
727         for (final String name: properties.stringPropertyNames()) {
728             map.put(name, properties.getProperty(name));
729         }
730 
731         return map;
732     }
733 
734     static List&lt;String&gt; getArgumentList(String inputString) {
735         List&lt;String&gt; list = new ArrayList&lt;&gt;();
736         if (inputString == null || inputString.isEmpty()) {
737              return list;
738         }
739 
740         // The &quot;pattern&quot; regexp attempts to abide to the rule that
741         // strings are delimited by whitespace unless surrounded by
742         // quotes, then it is anything (including spaces) in the quotes.
743         Matcher m = pattern.matcher(inputString);
744         while (m.find()) {
745             String s = inputString.substring(m.start(), m.end()).trim();
746             // Ensure we do not have an empty string. trim() will take care of
747             // whitespace only strings. The regex preserves quotes and escaped
748             // chars so we need to clean them before adding to the List
749             if (!s.isEmpty()) {
750                 list.add(unquoteIfNeeded(s));
751             }
752         }
753         return list;
754     }
755 
756     static void putUnlessNull(Map&lt;String, ? super Object&gt; params,
757             String param, Object value) {
758         if (value != null) {
759             params.put(param, value);
760         }
761     }
762 
763     private static String unquoteIfNeeded(String in) {
764         if (in == null) {
765             return null;
766         }
767 
768         if (in.isEmpty()) {
769             return &quot;&quot;;
770         }
771 
772         // Use code points to preserve non-ASCII chars
773         StringBuilder sb = new StringBuilder();
774         int codeLen = in.codePointCount(0, in.length());
775         int quoteChar = -1;
776         for (int i = 0; i &lt; codeLen; i++) {
777             int code = in.codePointAt(i);
778             if (code == &#39;&quot;&#39; || code == &#39;\&#39;&#39;) {
779                 // If quote is escaped make sure to copy it
780                 if (i &gt; 0 &amp;&amp; in.codePointAt(i - 1) == &#39;\\&#39;) {
781                     sb.deleteCharAt(sb.length() - 1);
782                     sb.appendCodePoint(code);
783                     continue;
784                 }
785                 if (quoteChar != -1) {
786                     if (code == quoteChar) {
787                         // close quote, skip char
788                         quoteChar = -1;
789                     } else {
790                         sb.appendCodePoint(code);
791                     }
792                 } else {
793                     // opening quote, skip char
794                     quoteChar = code;
795                 }
796             } else {
797                 sb.appendCodePoint(code);
798             }
799         }
800         return sb.toString();
801     }
802 
803     private String getMainClassFromManifest() {
804         if (mainJarPath == null ||
805             input == null ) {
806             return null;
807         }
808 
809         JarFile jf;
810         try {
811             Path file = Path.of(input, mainJarPath);
812             if (!Files.exists(file)) {
813                 return null;
814             }
815             jf = new JarFile(file.toFile());
816             Manifest m = jf.getManifest();
817             Attributes attrs = (m != null) ? m.getMainAttributes() : null;
818             if (attrs != null) {
819                 return attrs.getValue(Attributes.Name.MAIN_CLASS);
820             }
821         } catch (IOException ignore) {}
822         return null;
823     }
824 
825     private static void showDeprecation(String option) {
826         Log.error(MessageFormat.format(I18N.getString(&quot;warning.deprecation&quot;),
827                 option));
828     }
829 }
    </pre>
  </body>
</html>
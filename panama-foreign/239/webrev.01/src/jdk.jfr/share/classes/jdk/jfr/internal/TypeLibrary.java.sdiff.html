<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/TypeLibrary.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PrivateAccess.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Utils.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/TypeLibrary.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 36 import java.util.ArrayDeque;
 37 import java.util.ArrayList;
 38 import java.util.Collection;
 39 import java.util.Collections;
 40 import java.util.HashMap;
 41 import java.util.HashSet;
 42 import java.util.LinkedHashMap;
 43 import java.util.List;
 44 import java.util.Map;
 45 import java.util.Queue;
 46 import java.util.Set;
 47 import java.util.function.Consumer;
 48 import java.util.function.Predicate;
 49 import java.util.stream.Stream;
 50 
 51 import jdk.jfr.AnnotationElement;
 52 import jdk.jfr.Description;
 53 import jdk.jfr.Label;
 54 import jdk.jfr.MetadataDefinition;
 55 import jdk.jfr.Name;

 56 import jdk.jfr.SettingDescriptor;
 57 import jdk.jfr.Timespan;
 58 import jdk.jfr.Timestamp;
 59 import jdk.jfr.ValueDescriptor;
 60 import jdk.jfr.internal.tool.PrettyWriter;
 61 
 62 public final class TypeLibrary {
 63 
 64     private static TypeLibrary instance;
 65     private static boolean implicitFieldTypes;
 66     private static final Map&lt;Long, Type&gt; types = new LinkedHashMap&lt;&gt;(100);
 67     static final ValueDescriptor DURATION_FIELD = createDurationField();
 68     static final ValueDescriptor THREAD_FIELD = createThreadField();
 69     static final ValueDescriptor STACK_TRACE_FIELD = createStackTraceField();
 70     static final ValueDescriptor START_TIME_FIELD = createStartTimeField();
 71 
 72     private TypeLibrary(List&lt;Type&gt; jvmTypes) {
 73         visitReachable(jvmTypes, t -&gt; !types.containsKey(t.getId()), t -&gt; types.put(t.getId(), t));
 74         if (Logger.shouldLog(LogTag.JFR_SYSTEM_METADATA, LogLevel.INFO)) {
 75             Stream&lt;Type&gt; s = types.values().stream().sorted((x, y) -&gt; Long.compare(x.getId(), y.getId()));
</pre>
<hr />
<pre>
229 
230         if (isDefined(clazz)) {
231             return getType(clazz);
232         }
233 
234         if (clazz.isPrimitive()) {
235             return defineType(clazz, null,false);
236         }
237 
238         if (clazz.isArray()) {
239             throw new InternalError(&quot;Arrays not supported&quot;);
240         }
241 
242         // STRUCT
243         String superType = null;
244         boolean eventType = false;
245         if (jdk.internal.event.Event.class.isAssignableFrom(clazz)) {
246             superType = Type.SUPER_TYPE_EVENT;
247             eventType= true;
248         }
<span class="line-modified">249         if (Control.class.isAssignableFrom(clazz)) {</span>
250             superType = Type.SUPER_TYPE_SETTING;
251         }
252 
253         // forward declare to avoid infinite recursion
254         defineType(clazz, superType, eventType);
255         Type type = getType(clazz);
256 
257         if (eventType) {
258             addImplicitFields(type, true, true, true, true ,false);
259             addUserFields(clazz, type, dynamicFields);
260             type.trimFields();
261         }
262         addAnnotations(clazz, type, dynamicAnnotations);
263 
264         if (clazz.getClassLoader() == null) {
265             type.log(&quot;Added&quot;, LogTag.JFR_SYSTEM_METADATA, LogLevel.INFO);
266         } else {
267             type.log(&quot;Added&quot;, LogTag.JFR_METADATA, LogLevel.INFO);
268         }
269         return type;
</pre>
</td>
<td>
<hr />
<pre>
 36 import java.util.ArrayDeque;
 37 import java.util.ArrayList;
 38 import java.util.Collection;
 39 import java.util.Collections;
 40 import java.util.HashMap;
 41 import java.util.HashSet;
 42 import java.util.LinkedHashMap;
 43 import java.util.List;
 44 import java.util.Map;
 45 import java.util.Queue;
 46 import java.util.Set;
 47 import java.util.function.Consumer;
 48 import java.util.function.Predicate;
 49 import java.util.stream.Stream;
 50 
 51 import jdk.jfr.AnnotationElement;
 52 import jdk.jfr.Description;
 53 import jdk.jfr.Label;
 54 import jdk.jfr.MetadataDefinition;
 55 import jdk.jfr.Name;
<span class="line-added"> 56 import jdk.jfr.SettingControl;</span>
 57 import jdk.jfr.SettingDescriptor;
 58 import jdk.jfr.Timespan;
 59 import jdk.jfr.Timestamp;
 60 import jdk.jfr.ValueDescriptor;
 61 import jdk.jfr.internal.tool.PrettyWriter;
 62 
 63 public final class TypeLibrary {
 64 
 65     private static TypeLibrary instance;
 66     private static boolean implicitFieldTypes;
 67     private static final Map&lt;Long, Type&gt; types = new LinkedHashMap&lt;&gt;(100);
 68     static final ValueDescriptor DURATION_FIELD = createDurationField();
 69     static final ValueDescriptor THREAD_FIELD = createThreadField();
 70     static final ValueDescriptor STACK_TRACE_FIELD = createStackTraceField();
 71     static final ValueDescriptor START_TIME_FIELD = createStartTimeField();
 72 
 73     private TypeLibrary(List&lt;Type&gt; jvmTypes) {
 74         visitReachable(jvmTypes, t -&gt; !types.containsKey(t.getId()), t -&gt; types.put(t.getId(), t));
 75         if (Logger.shouldLog(LogTag.JFR_SYSTEM_METADATA, LogLevel.INFO)) {
 76             Stream&lt;Type&gt; s = types.values().stream().sorted((x, y) -&gt; Long.compare(x.getId(), y.getId()));
</pre>
<hr />
<pre>
230 
231         if (isDefined(clazz)) {
232             return getType(clazz);
233         }
234 
235         if (clazz.isPrimitive()) {
236             return defineType(clazz, null,false);
237         }
238 
239         if (clazz.isArray()) {
240             throw new InternalError(&quot;Arrays not supported&quot;);
241         }
242 
243         // STRUCT
244         String superType = null;
245         boolean eventType = false;
246         if (jdk.internal.event.Event.class.isAssignableFrom(clazz)) {
247             superType = Type.SUPER_TYPE_EVENT;
248             eventType= true;
249         }
<span class="line-modified">250         if (SettingControl.class.isAssignableFrom(clazz)) {</span>
251             superType = Type.SUPER_TYPE_SETTING;
252         }
253 
254         // forward declare to avoid infinite recursion
255         defineType(clazz, superType, eventType);
256         Type type = getType(clazz);
257 
258         if (eventType) {
259             addImplicitFields(type, true, true, true, true ,false);
260             addUserFields(clazz, type, dynamicFields);
261             type.trimFields();
262         }
263         addAnnotations(clazz, type, dynamicAnnotations);
264 
265         if (clazz.getClassLoader() == null) {
266             type.log(&quot;Added&quot;, LogTag.JFR_SYSTEM_METADATA, LogLevel.INFO);
267         } else {
268             type.log(&quot;Added&quot;, LogTag.JFR_METADATA, LogLevel.INFO);
269         }
270         return type;
</pre>
</td>
</tr>
</table>
<center><a href="PrivateAccess.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Utils.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
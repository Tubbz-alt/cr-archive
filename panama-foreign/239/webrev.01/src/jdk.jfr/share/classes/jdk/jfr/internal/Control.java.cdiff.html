<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.jfr/share/classes/jdk/jfr/internal/Control.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../consumer/RecordedObject.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="EventControl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/Control.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,85 ***</span>
   * questions.
   */
  
  package jdk.jfr.internal;
  
<span class="line-removed">- import java.io.IOException;</span>
<span class="line-removed">- import java.io.ObjectInputStream;</span>
<span class="line-removed">- import java.io.ObjectOutputStream;</span>
  import java.security.AccessControlContext;
  import java.security.AccessController;
  import java.security.PrivilegedAction;
  import java.util.Collections;
  import java.util.HashSet;
  import java.util.Objects;
  import java.util.Set;
  
<span class="line-modified">! // User must never be able to subclass directly.</span>
<span class="line-modified">! //</span>
<span class="line-modified">! // Never put Control or Setting Control in a collections</span>
<span class="line-modified">! // so overridable versions of hashCode or equals are</span>
<span class="line-removed">- // executed in the wrong context. TODO: wrap this class</span>
<span class="line-removed">- // in SsecureControl directly when it is instantiated and</span>
<span class="line-removed">- // forward calls using AccessControlContext</span>
<span class="line-removed">- abstract public class Control {</span>
      private final AccessControlContext context;
      private final static int CACHE_SIZE = 5;
      private final Set&lt;?&gt;[] cachedUnions = new HashSet&lt;?&gt;[CACHE_SIZE];
      private final String[] cachedValues = new String[CACHE_SIZE];
      private String defaultValue;
      private String lastValue;
  
      // called by exposed subclass in external API
<span class="line-modified">!     public Control(AccessControlContext acc) {</span>
<span class="line-modified">!         Objects.requireNonNull(acc);</span>
<span class="line-modified">!         this.context = acc;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // only to be called by trusted VM code</span>
<span class="line-removed">-     public Control(String defaultValue) {</span>
          this.defaultValue = defaultValue;
<span class="line-modified">!         this.context = null;</span>
      }
  
<span class="line-modified">!     // For user code to override, must never be called from jdk.jfr.internal</span>
<span class="line-modified">!     // for user defined settings</span>
<span class="line-modified">!     public abstract String combine(Set&lt;String&gt; values);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // For user code to override, must never be called from jdk.jfr.internal</span>
<span class="line-removed">-     // for user defined settings</span>
<span class="line-removed">-     public abstract void setValue(String value);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // For user code to override, must never be called from jdk.jfr.internal</span>
<span class="line-removed">-     // for user defined settings</span>
<span class="line-removed">-     public abstract String getValue();</span>
  
<span class="line-removed">-       // Package private, user code should not have access to this method</span>
      final void apply(Set&lt;String&gt; values) {
<span class="line-modified">!         setValueSafe(findCombineSafe(values));</span>
      }
  
<span class="line-removed">-     // Package private, user code should not have access to this method.</span>
<span class="line-removed">-     // Only called during event registration</span>
      final void setDefault() {
          if (defaultValue == null) {
<span class="line-modified">!             defaultValue = getValueSafe();</span>
          }
          apply(defaultValue);
      }
  
<span class="line-modified">!     final String getValueSafe() {</span>
          if (context == null) {
              // VM events requires no access control context
              return getValue();
          } else {
              return AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
                  @Override
                  public String run() {
                      try {
<span class="line-modified">!                         return getValue();</span>
                      } catch (Throwable t) {
                          // Prevent malicious user to propagate exception callback in the wrong context
                          Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, &quot;Exception occurred when trying to get value for &quot; + getClass());
                      }
                      return defaultValue != null ? defaultValue : &quot;&quot;; // Need to return something
<span class="line-new-header">--- 23,65 ---</span>
   * questions.
   */
  
  package jdk.jfr.internal;
  
  import java.security.AccessControlContext;
  import java.security.AccessController;
  import java.security.PrivilegedAction;
  import java.util.Collections;
  import java.util.HashSet;
  import java.util.Objects;
  import java.util.Set;
  
<span class="line-modified">! import jdk.jfr.SettingControl;</span>
<span class="line-modified">! import jdk.jfr.internal.settings.JDKSettingControl;</span>
<span class="line-modified">! </span>
<span class="line-modified">! public final class Control {</span>
      private final AccessControlContext context;
      private final static int CACHE_SIZE = 5;
      private final Set&lt;?&gt;[] cachedUnions = new HashSet&lt;?&gt;[CACHE_SIZE];
      private final String[] cachedValues = new String[CACHE_SIZE];
<span class="line-added">+     private final SettingControl delegate;</span>
      private String defaultValue;
      private String lastValue;
  
      // called by exposed subclass in external API
<span class="line-modified">!     public Control(SettingControl delegate, String defaultValue) {</span>
<span class="line-modified">!         this.context = PrivateAccess.getInstance().getContext(delegate);</span>
<span class="line-modified">!         this.delegate = delegate;</span>
          this.defaultValue = defaultValue;
<span class="line-modified">!         if (this.context == null &amp;&amp; !(delegate instanceof JDKSettingControl)) {</span>
<span class="line-added">+             throw new InternalError(&quot;Security context can only be null for trusted setting controls&quot;);</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     boolean isType(Class&lt;? extends SettingControl&gt; clazz) {</span>
<span class="line-modified">!         return delegate.getClass() == clazz;</span>
<span class="line-modified">!     }</span>
  
      final void apply(Set&lt;String&gt; values) {
<span class="line-modified">!         setValue(findCombine(values));</span>
      }
  
      final void setDefault() {
          if (defaultValue == null) {
<span class="line-modified">!             defaultValue = getValue();</span>
          }
          apply(defaultValue);
      }
  
<span class="line-modified">!     public String getValue() {</span>
          if (context == null) {
              // VM events requires no access control context
              return getValue();
          } else {
              return AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
                  @Override
                  public String run() {
                      try {
<span class="line-modified">!                         return delegate.getValue();</span>
                      } catch (Throwable t) {
                          // Prevent malicious user to propagate exception callback in the wrong context
                          Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, &quot;Exception occurred when trying to get value for &quot; + getClass());
                      }
                      return defaultValue != null ? defaultValue : &quot;&quot;; // Need to return something
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,27 ***</span>
  
      private void apply(String value) {
          if (lastValue != null &amp;&amp; Objects.equals(value, lastValue)) {
              return;
          }
<span class="line-modified">!         setValueSafe(value);</span>
      }
  
<span class="line-modified">!     final void setValueSafe(String value) {</span>
          if (context == null) {
              // VM events requires no access control context
              try {
<span class="line-modified">!                 setValue(value);</span>
              } catch (Throwable t) {
                  Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, &quot;Exception occurred when setting value \&quot;&quot; + value + &quot;\&quot; for &quot; + getClass());
              }
          } else {
              AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
                  @Override
                  public Void run() {
                      try {
<span class="line-modified">!                         setValue(value);</span>
                      } catch (Throwable t) {
                          // Prevent malicious user to propagate exception callback in the wrong context
                          Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, &quot;Exception occurred when setting value \&quot;&quot; + value + &quot;\&quot; for &quot; + getClass());
                      }
                      return null;
<span class="line-new-header">--- 92,27 ---</span>
  
      private void apply(String value) {
          if (lastValue != null &amp;&amp; Objects.equals(value, lastValue)) {
              return;
          }
<span class="line-modified">!         setValue(value);</span>
      }
  
<span class="line-modified">!     public void setValue(String value) {</span>
          if (context == null) {
              // VM events requires no access control context
              try {
<span class="line-modified">!                 delegate.setValue(value);</span>
              } catch (Throwable t) {
                  Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, &quot;Exception occurred when setting value \&quot;&quot; + value + &quot;\&quot; for &quot; + getClass());
              }
          } else {
              AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
                  @Override
                  public Void run() {
                      try {
<span class="line-modified">!                         delegate.setValue(value);</span>
                      } catch (Throwable t) {
                          // Prevent malicious user to propagate exception callback in the wrong context
                          Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, &quot;Exception occurred when setting value \&quot;&quot; + value + &quot;\&quot; for &quot; + getClass());
                      }
                      return null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,69 ***</span>
          }
          lastValue = value;
      }
  
  
<span class="line-modified">!     private String combineSafe(Set&lt;String&gt; values) {</span>
          if (context == null) {
              // VM events requires no access control context
<span class="line-modified">!             return combine(values);</span>
          }
          return AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
              @Override
              public String run() {
                  try {
<span class="line-modified">!                     combine(Collections.unmodifiableSet(values));</span>
                  } catch (Throwable t) {
                      // Prevent malicious user to propagate exception callback in the wrong context
                      Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, &quot;Exception occurred when combining &quot; + values + &quot; for &quot; + getClass());
                  }
                  return null;
              }
          }, context);
      }
  
<span class="line-modified">!     private final String findCombineSafe(Set&lt;String&gt; values) {</span>
          if (values.size() == 1) {
              return values.iterator().next();
          }
          for (int i = 0; i &lt; CACHE_SIZE; i++) {
              if (Objects.equals(cachedUnions[i], values)) {
                  return cachedValues[i];
              }
          }
<span class="line-modified">!         String result = combineSafe(values);</span>
          for (int i = 0; i &lt; CACHE_SIZE - 1; i++) {
              cachedUnions[i + 1] = cachedUnions[i];
              cachedValues[i + 1] = cachedValues[i];
          }
          cachedValues[0] = result;
          cachedUnions[0] = values;
          return result;
      }
  
<span class="line-removed">- </span>
<span class="line-removed">-     // package private, user code should not have access to this method</span>
      final String getDefaultValue() {
          return defaultValue;
      }
  
<span class="line-removed">-     // package private, user code should not have access to this method</span>
      final String getLastValue() {
          return lastValue;
      }
<span class="line-removed">- </span>
<span class="line-removed">-     // Precaution to prevent a malicious user from instantiating instances</span>
<span class="line-removed">-     // of a control where the context has not been set up.</span>
<span class="line-removed">-     @Override</span>
<span class="line-removed">-     public final Object clone() throws java.lang.CloneNotSupportedException {</span>
<span class="line-removed">-         throw new CloneNotSupportedException();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private final void writeObject(ObjectOutputStream out) throws IOException {</span>
<span class="line-removed">-         throw new IOException(&quot;Object cannot be serialized&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private final void readObject(ObjectInputStream in) throws IOException {</span>
<span class="line-removed">-         throw new IOException(&quot;Class cannot be deserialized&quot;);</span>
<span class="line-removed">-     }</span>
  }
<span class="line-new-header">--- 121,51 ---</span>
          }
          lastValue = value;
      }
  
  
<span class="line-modified">!     public String combine(Set&lt;String&gt; values) {</span>
          if (context == null) {
              // VM events requires no access control context
<span class="line-modified">!             return delegate.combine(values);</span>
          }
          return AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
              @Override
              public String run() {
                  try {
<span class="line-modified">!                     delegate.combine(Collections.unmodifiableSet(values));</span>
                  } catch (Throwable t) {
                      // Prevent malicious user to propagate exception callback in the wrong context
                      Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, &quot;Exception occurred when combining &quot; + values + &quot; for &quot; + getClass());
                  }
                  return null;
              }
          }, context);
      }
  
<span class="line-modified">!     private final String findCombine(Set&lt;String&gt; values) {</span>
          if (values.size() == 1) {
              return values.iterator().next();
          }
          for (int i = 0; i &lt; CACHE_SIZE; i++) {
              if (Objects.equals(cachedUnions[i], values)) {
                  return cachedValues[i];
              }
          }
<span class="line-modified">!         String result = combine(values);</span>
          for (int i = 0; i &lt; CACHE_SIZE - 1; i++) {
              cachedUnions[i + 1] = cachedUnions[i];
              cachedValues[i + 1] = cachedValues[i];
          }
          cachedValues[0] = result;
          cachedUnions[0] = values;
          return result;
      }
  
      final String getDefaultValue() {
          return defaultValue;
      }
  
      final String getLastValue() {
          return lastValue;
      }
  }
</pre>
<center><a href="../consumer/RecordedObject.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="EventControl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/EventControl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Control.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="EventInstrumentation.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/EventControl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
150 
151                             if (!hasControl(name)) {
152                                 defineSetting((Class&lt;? extends SettingControl&gt;) settingClass, m, type, name);
153                             }
154                         }
155                     }
156                 }
157             }
158             eventClass = eventClass.getSuperclass();
159             allowPrivateMethod = false;
160         }
161     }
162 
163     private void defineSetting(Class&lt;? extends SettingControl&gt; settingsClass, Method method, PlatformEventType eventType, String settingName) {
164         try {
165             Module settingModule = settingsClass.getModule();
166             Modules.addReads(settingModule, EventControl.class.getModule());
167             int index = settingInfos.size();
168             SettingInfo si = new SettingInfo(FIELD_SETTING_PREFIX + index, index);
169             si.settingControl = instantiateSettingControl(settingsClass);
<span class="line-modified">170             Control c = si.settingControl;</span>
171             c.setDefault();
<span class="line-modified">172             String defaultValue = c.getValueSafe();</span>
173             if (defaultValue != null) {
174                 Type settingType = TypeLibrary.createType(settingsClass);
175                 ArrayList&lt;AnnotationElement&gt; aes = new ArrayList&lt;&gt;();
176                 for (Annotation a : method.getDeclaredAnnotations()) {
177                     AnnotationElement ae = TypeLibrary.createAnnotation(a);
178                     if (ae != null) {
179                         aes.add(ae);
180                     }
181                 }
182                 aes.trimToSize();
<span class="line-modified">183                 addControl(settingName, si.settingControl);</span>
184                 eventType.add(PrivateAccess.getInstance().newSettingDescriptor(settingType, settingName, defaultValue, aes));
185                 settingInfos.add(si);
186             }
187         } catch (InstantiationException e) {
188             // Programming error by user, fail fast
189             throw new InstantiationError(&quot;Could not instantiate setting &quot; + settingsClass.getName() + &quot; for event &quot; + eventType.getLogName() + &quot;. &quot; + e.getMessage());
190         } catch (IllegalAccessException e) {
191             // Programming error by user, fail fast
192             throw new IllegalAccessError(&quot;Could not access setting &quot; + settingsClass.getName() + &quot; for event &quot; + eventType.getLogName() + &quot;. &quot; + e.getMessage());
193         }
194     }
195 
196     private SettingControl instantiateSettingControl(Class&lt;? extends SettingControl&gt; settingControlClass) throws IllegalAccessException, InstantiationException {
197         SecuritySupport.makeVisibleToJFR(settingControlClass);
198         final Constructor&lt;?&gt; cc;
199         try {
200             cc = settingControlClass.getDeclaredConstructors()[0];
201         } catch (Exception e) {
202             throw (Error) new InternalError(&quot;Could not get constructor for &quot; + settingControlClass.getName()).initCause(e);
203         }
204         SecuritySupport.setAccessible(cc);
205         try {
206             return (SettingControl) cc.newInstance();
207         } catch (IllegalArgumentException | InvocationTargetException e) {
<span class="line-modified">208             throw (Error) new InternalError(&quot;Could not instantiate setting for class &quot; + settingControlClass.getName());</span>
209         }
210     }
211 
212     private static Control defineEnabled(PlatformEventType type) {
213         Enabled enabled = type.getAnnotation(Enabled.class);
214         // Java events are enabled by default,
215         // JVM events are not, maybe they should be? Would lower learning curve
216         // there too.
217         String def = type.isJVM() ? &quot;false&quot; : &quot;true&quot;;
218         if (enabled != null) {
219             def = Boolean.toString(enabled.value());
220         }
221         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_ENABLED, Enabled.NAME, def, Collections.emptyList()));
<span class="line-modified">222         return new EnabledSetting(type, def);</span>
223     }
224 
225     private static Control defineThreshold(PlatformEventType type) {
226         Threshold threshold = type.getAnnotation(Threshold.class);
227         String def = &quot;0 ns&quot;;
228         if (threshold != null) {
229             def = threshold.value();
230         }
231         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_THRESHOLD, Threshold.NAME, def, Collections.emptyList()));
<span class="line-modified">232         return new ThresholdSetting(type, def);</span>
233     }
234 
235     private static Control defineStackTrace(PlatformEventType type) {
236         StackTrace stackTrace = type.getAnnotation(StackTrace.class);
237         String def = &quot;true&quot;;
238         if (stackTrace != null) {
239             def = Boolean.toString(stackTrace.value());
240         }
241         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_STACK_TRACE, StackTrace.NAME, def, Collections.emptyList()));
<span class="line-modified">242         return new StackTraceSetting(type, def);</span>
243     }
244 
245     private static Control defineCutoff(PlatformEventType type) {
246         Cutoff cutoff = type.getAnnotation(Cutoff.class);
247         String def = Cutoff.INFINITY;
248         if (cutoff != null) {
249             def = cutoff.value();
250         }
251         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_CUTOFF, Cutoff.NAME, def, Collections.emptyList()));
<span class="line-modified">252         return new CutoffSetting(type, def);</span>
253     }
254 
255 
256     private static Control definePeriod(PlatformEventType type) {
257         Period period = type.getAnnotation(Period.class);
258         String def = &quot;everyChunk&quot;;
259         if (period != null) {
260             def = period.value();
261         }
262         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_PERIOD, PeriodSetting.NAME, def, Collections.emptyList()));
<span class="line-modified">263         return new PeriodSetting(type, def);</span>
264     }
265 
266     void disable() {
267         for (NamedControl nc : namedControls) {
<span class="line-modified">268             if (nc.control instanceof EnabledSetting) {</span>
<span class="line-modified">269                 nc.control.setValueSafe(&quot;false&quot;);</span>
270                 return;
271             }
272         }
273     }
274 
275     void writeActiveSettingEvent() {
276         if (!type.isRegistered()) {
277             return;
278         }
279         ActiveSettingEvent event = ActiveSettingEvent.EVENT.get();
280         for (NamedControl nc : namedControls) {
281             if (Utils.isSettingVisible(nc.control, type.hasEventHook())) {
282                 String value = nc.control.getLastValue();
283                 if (value == null) {
284                     value = nc.control.getDefaultValue();
285                 }
286                 event.id = type.getId();
287                 event.name = nc.name;
288                 event.value = value;
289                 event.commit();
</pre>
</td>
<td>
<hr />
<pre>
150 
151                             if (!hasControl(name)) {
152                                 defineSetting((Class&lt;? extends SettingControl&gt;) settingClass, m, type, name);
153                             }
154                         }
155                     }
156                 }
157             }
158             eventClass = eventClass.getSuperclass();
159             allowPrivateMethod = false;
160         }
161     }
162 
163     private void defineSetting(Class&lt;? extends SettingControl&gt; settingsClass, Method method, PlatformEventType eventType, String settingName) {
164         try {
165             Module settingModule = settingsClass.getModule();
166             Modules.addReads(settingModule, EventControl.class.getModule());
167             int index = settingInfos.size();
168             SettingInfo si = new SettingInfo(FIELD_SETTING_PREFIX + index, index);
169             si.settingControl = instantiateSettingControl(settingsClass);
<span class="line-modified">170             Control c = new Control(si.settingControl, null);</span>
171             c.setDefault();
<span class="line-modified">172             String defaultValue = c.getValue();</span>
173             if (defaultValue != null) {
174                 Type settingType = TypeLibrary.createType(settingsClass);
175                 ArrayList&lt;AnnotationElement&gt; aes = new ArrayList&lt;&gt;();
176                 for (Annotation a : method.getDeclaredAnnotations()) {
177                     AnnotationElement ae = TypeLibrary.createAnnotation(a);
178                     if (ae != null) {
179                         aes.add(ae);
180                     }
181                 }
182                 aes.trimToSize();
<span class="line-modified">183                 addControl(settingName, c);</span>
184                 eventType.add(PrivateAccess.getInstance().newSettingDescriptor(settingType, settingName, defaultValue, aes));
185                 settingInfos.add(si);
186             }
187         } catch (InstantiationException e) {
188             // Programming error by user, fail fast
189             throw new InstantiationError(&quot;Could not instantiate setting &quot; + settingsClass.getName() + &quot; for event &quot; + eventType.getLogName() + &quot;. &quot; + e.getMessage());
190         } catch (IllegalAccessException e) {
191             // Programming error by user, fail fast
192             throw new IllegalAccessError(&quot;Could not access setting &quot; + settingsClass.getName() + &quot; for event &quot; + eventType.getLogName() + &quot;. &quot; + e.getMessage());
193         }
194     }
195 
196     private SettingControl instantiateSettingControl(Class&lt;? extends SettingControl&gt; settingControlClass) throws IllegalAccessException, InstantiationException {
197         SecuritySupport.makeVisibleToJFR(settingControlClass);
198         final Constructor&lt;?&gt; cc;
199         try {
200             cc = settingControlClass.getDeclaredConstructors()[0];
201         } catch (Exception e) {
202             throw (Error) new InternalError(&quot;Could not get constructor for &quot; + settingControlClass.getName()).initCause(e);
203         }
204         SecuritySupport.setAccessible(cc);
205         try {
206             return (SettingControl) cc.newInstance();
207         } catch (IllegalArgumentException | InvocationTargetException e) {
<span class="line-modified">208             throw new InternalError(&quot;Could not instantiate setting for class &quot; + settingControlClass.getName());</span>
209         }
210     }
211 
212     private static Control defineEnabled(PlatformEventType type) {
213         Enabled enabled = type.getAnnotation(Enabled.class);
214         // Java events are enabled by default,
215         // JVM events are not, maybe they should be? Would lower learning curve
216         // there too.
217         String def = type.isJVM() ? &quot;false&quot; : &quot;true&quot;;
218         if (enabled != null) {
219             def = Boolean.toString(enabled.value());
220         }
221         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_ENABLED, Enabled.NAME, def, Collections.emptyList()));
<span class="line-modified">222         return new Control(new EnabledSetting(type, def), def);</span>
223     }
224 
225     private static Control defineThreshold(PlatformEventType type) {
226         Threshold threshold = type.getAnnotation(Threshold.class);
227         String def = &quot;0 ns&quot;;
228         if (threshold != null) {
229             def = threshold.value();
230         }
231         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_THRESHOLD, Threshold.NAME, def, Collections.emptyList()));
<span class="line-modified">232         return new Control(new ThresholdSetting(type), def);</span>
233     }
234 
235     private static Control defineStackTrace(PlatformEventType type) {
236         StackTrace stackTrace = type.getAnnotation(StackTrace.class);
237         String def = &quot;true&quot;;
238         if (stackTrace != null) {
239             def = Boolean.toString(stackTrace.value());
240         }
241         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_STACK_TRACE, StackTrace.NAME, def, Collections.emptyList()));
<span class="line-modified">242         return new Control(new StackTraceSetting(type, def), def);</span>
243     }
244 
245     private static Control defineCutoff(PlatformEventType type) {
246         Cutoff cutoff = type.getAnnotation(Cutoff.class);
247         String def = Cutoff.INFINITY;
248         if (cutoff != null) {
249             def = cutoff.value();
250         }
251         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_CUTOFF, Cutoff.NAME, def, Collections.emptyList()));
<span class="line-modified">252         return new Control(new CutoffSetting(type), def);</span>
253     }
254 
255 
256     private static Control definePeriod(PlatformEventType type) {
257         Period period = type.getAnnotation(Period.class);
258         String def = &quot;everyChunk&quot;;
259         if (period != null) {
260             def = period.value();
261         }
262         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_PERIOD, PeriodSetting.NAME, def, Collections.emptyList()));
<span class="line-modified">263         return new Control(new PeriodSetting(type), def);</span>
264     }
265 
266     void disable() {
267         for (NamedControl nc : namedControls) {
<span class="line-modified">268             if (nc.control.isType(EnabledSetting.class)) {</span>
<span class="line-modified">269                 nc.control.setValue(&quot;false&quot;);</span>
270                 return;
271             }
272         }
273     }
274 
275     void writeActiveSettingEvent() {
276         if (!type.isRegistered()) {
277             return;
278         }
279         ActiveSettingEvent event = ActiveSettingEvent.EVENT.get();
280         for (NamedControl nc : namedControls) {
281             if (Utils.isSettingVisible(nc.control, type.hasEventHook())) {
282                 String value = nc.control.getLastValue();
283                 if (value == null) {
284                     value = nc.control.getDefaultValue();
285                 }
286                 event.id = type.getId();
287                 event.name = nc.name;
288                 event.value = value;
289                 event.commit();
</pre>
</td>
</tr>
</table>
<center><a href="Control.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="EventInstrumentation.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
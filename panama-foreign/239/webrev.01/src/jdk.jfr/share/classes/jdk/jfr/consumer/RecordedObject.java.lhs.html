<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordedObject.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.consumer;
 27 
 28 import java.io.IOException;
 29 import java.io.PrintWriter;
 30 import java.io.StringWriter;
 31 import java.time.Duration;
 32 import java.time.Instant;
 33 import java.time.OffsetDateTime;
 34 import java.util.Comparator;
 35 import java.util.List;
 36 import java.util.Objects;
 37 
 38 import jdk.jfr.Timespan;
 39 import jdk.jfr.Timestamp;
 40 import jdk.jfr.ValueDescriptor;
 41 import jdk.jfr.internal.consumer.JdkJfrConsumer;
 42 import jdk.jfr.internal.consumer.ObjectFactory;
 43 import jdk.jfr.internal.PrivateAccess;
 44 import jdk.jfr.internal.Type;
 45 import jdk.jfr.internal.consumer.ObjectContext;
 46 import jdk.jfr.internal.tool.PrettyWriter;
 47 
 48 /**
 49  * A complex data type that consists of one or more fields.
 50  * &lt;p&gt;
 51  * This class provides methods to select and query nested objects by passing a
 52  * dot {@code &quot;.&quot;} delimited {@code String} object (for instance,
 53  * {@code &quot;aaa.bbb&quot;}). A method evaluates a nested object from left to right,
 54  * and if a part is {@code null}, it throws {@code NullPointerException}.
 55  *
 56  * @since 9
 57  */
 58 public class RecordedObject {
 59 
 60     static{
 61         JdkJfrConsumer access = new JdkJfrConsumer() {
 62             public List&lt;Type&gt; readTypes(RecordingFile file) throws IOException {
 63                 return file.readTypes();
 64             }
 65 
 66             public boolean isLastEventInChunk(RecordingFile file) {
 67                 return file.isLastEventInChunk();
 68             }
 69 
 70             @Override
 71             public Object getOffsetDataTime(RecordedObject event, String name) {
 72                 return event.getOffsetDateTime(name);
 73             }
 74 
 75             @Override
 76             public RecordedClass newRecordedClass(ObjectContext objectContext, long id, Object[] values) {
 77                 return new RecordedClass(objectContext, id, values);
 78             }
 79 
 80             @Override
 81             public RecordedClassLoader newRecordedClassLoader(ObjectContext objectContext, long id, Object[] values) {
 82                 return new RecordedClassLoader(objectContext, id, values);
 83             }
 84 
 85             @Override
 86             public Comparator&lt;? super RecordedEvent&gt; eventComparator() {
 87                 return new Comparator&lt;RecordedEvent&gt;()  {
 88                     @Override
 89                     public int compare(RecordedEvent e1, RecordedEvent e2) {
 90                         return Long.compare(e1.endTimeTicks, e2.endTimeTicks);
 91                     }
 92                 };
 93             }
 94 
 95             @Override
 96             public RecordedStackTrace newRecordedStackTrace(ObjectContext objectContext, Object[] values) {
 97                 return new RecordedStackTrace(objectContext, values);
 98             }
 99 
100             @Override
101             public RecordedThreadGroup newRecordedThreadGroup(ObjectContext objectContext, Object[] values) {
102                 return new RecordedThreadGroup(objectContext, values);
103             }
104 
105             @Override
106             public RecordedFrame newRecordedFrame(ObjectContext objectContext, Object[] values) {
107                 return new RecordedFrame(objectContext, values);
108             }
109 
110             @Override
111             public RecordedThread newRecordedThread(ObjectContext objectContext, long id, Object[] values) {
112                 return new RecordedThread(objectContext, id, values);
113             }
114 
115             @Override
116             public RecordedMethod newRecordedMethod(ObjectContext objectContext, Object[] values) {
117                 return new RecordedMethod(objectContext, values);
118             }
119 
120             @Override
121             public RecordedEvent newRecordedEvent(ObjectContext objectContext, Object[] values, long startTimeTicks, long endTimeTicks) {
122                 return new RecordedEvent(objectContext, values, startTimeTicks, endTimeTicks);
123             }
124 
125             @Override
126             public void setStartTicks(RecordedEvent event, long startTicks) {
127                event.startTimeTicks = startTicks;
128             }
129 
130             @Override
131             public void setEndTicks(RecordedEvent event, long endTicks) {
132                event.endTimeTicks = endTicks;
133             }
134 
135             @Override
136             public Object[] eventValues(RecordedEvent event) {
137                 return event.objects;
138             }
139         };
140         JdkJfrConsumer.setAccess(access);
141     }
142 
143     private final static class UnsignedValue {
144         private final Object o;
145 
146         UnsignedValue(Object o) {
147             this.o = o;
148         }
149 
150         Object value() {
151             return o;
152         }
153     }
154 
155     final Object[] objects;
156     final ObjectContext objectContext;
157 
158     // package private, not to be subclassed outside this package
159     RecordedObject(ObjectContext objectContext, Object[] objects) {
160         this.objectContext = objectContext;
161         this.objects = objects;
162     }
163 
164     // package private
165     final &lt;T&gt; T getTyped(String name, Class&lt;T&gt; clazz, T defaultValue) {
166         // Unnecessary to check field presence twice, but this
167         // will do for now.
168         if (!hasField(name)) {
169             return defaultValue;
170         }
171         T object = getValue(name);
172         if (object == null || object.getClass().isAssignableFrom(clazz)) {
173             return object;
174         } else {
175             return defaultValue;
176         }
177     }
178 
179     /**
180      * Returns {@code true} if a field with the given name exists, {@code false}
181      * otherwise.
182      *
183      * @param name name of the field to get, not {@code null}
184      *
185      * @return {@code true} if the field exists, {@code false} otherwise
186      *
187      * @see #getFields()
188      */
189     public boolean hasField(String name) {
190         Objects.requireNonNull(name);
191         for (ValueDescriptor v : objectContext.fields) {
192             if (v.getName().equals(name)) {
193                 return true;
194             }
195         }
196         int dotIndex = name.indexOf(&quot;.&quot;);
197         if (dotIndex &gt; 0) {
198             String structName = name.substring(0, dotIndex);
199             for (ValueDescriptor v : objectContext.fields) {
200                 if (!v.getFields().isEmpty() &amp;&amp; v.getName().equals(structName)) {
201                     RecordedObject child = getValue(structName);
202                     if (child != null) {
203                         return child.hasField(name.substring(dotIndex + 1));
204                     }
205                 }
206             }
207         }
208         return false;
209     }
210 
211     /**
212      * Returns the value of the field with the given name.
213      * &lt;p&gt;
214      * The return type may be a primitive type or a subclass of
215      * {@link RecordedObject}.
216      * &lt;p&gt;
217      * It&#39;s possible to index into a nested object by using {@code &quot;.&quot;} (for
218      * instance {@code &quot;thread.group.parent.name}&quot;).
219      * &lt;p&gt;
220      * A field might change or be removed in a future JDK release. A best practice
221      * for callers of this method is to validate the field before attempting access.
222      * &lt;p&gt;
223      * Example
224      *
225      * &lt;pre&gt;{@literal
226      * if (event.hasField(&quot;intValue&quot;)) {
227      *   int intValue = event.getValue(&quot;intValue&quot;);
228      *   System.out.println(&quot;Int value: &quot; + intValue);
229      * }
230      *
231      * if (event.hasField(&quot;objectClass&quot;)) {
232      *   RecordedClass clazz = event.getValue(&quot;objectClass&quot;);
233      *   System.out.println(&quot;Class name: &quot; + clazz.getName());
234      * }
235      *
236      * if (event.hasField(&quot;sampledThread&quot;)) {
237      *   RecordedThread sampledThread = event.getValue(&quot;sampledThread&quot;);
238      *   System.out.println(&quot;Sampled thread: &quot; + sampledThread.getJavaName());
239      * }
240      * }&lt;/pre&gt;
241      *
242      * @param &lt;T&gt; the return type
243      * @param  name of the field to get, not {@code null}
244      * @throws IllegalArgumentException if no field called {@code name} exists
245      *
246      * @return the value, can be {@code null}
247      *
248      * @see #hasField(String)
249      *
250      */
251     final public &lt;T&gt; T getValue(String name) {
252         @SuppressWarnings(&quot;unchecked&quot;)
253         T t = (T) getValue(name, false);
254         return t;
255     }
256 
<a name="1" id="anc1"></a><span class="line-modified">257     protected Object objectAt(int index) {</span>
258         return objects[index];
259     }
260 
261     private Object getValue(String name, boolean allowUnsigned) {
262         Objects.requireNonNull(name);
263         int index = 0;
264         for (ValueDescriptor v : objectContext.fields) {
265             if (name.equals(v.getName())) {
266                 Object object = objectAt(index);
267                 if (object == null) {
268                     // error or missing
269                     return null;
270                 }
271                 if (v.getFields().isEmpty()) {
272                     if (allowUnsigned &amp;&amp; PrivateAccess.getInstance().isUnsigned(v)) {
273                         // Types that are meaningless to widen
274                         if (object instanceof Character || object instanceof Long) {
275                             return object;
276                         }
277                         return new UnsignedValue(object);
278                     }
279                     return object; // primitives and primitive arrays
280                 } else {
281                     if (object instanceof RecordedObject) {
282                         // known types from factory
283                         return object;
284                     }
285                     // must be array type
286                     Object[] array = (Object[]) object;
287                     if (v.isArray()) {
288                         // struct array
289                         return structifyArray(v, array, 0);
290                     }
291                     // struct
292                     return new RecordedObject(objectContext.getInstance(v), (Object[]) object);
293                 }
294             }
295             index++;
296         }
297 
298         int dotIndex = name.indexOf(&quot;.&quot;);
299         if (dotIndex &gt; 0) {
300             String structName = name.substring(0, dotIndex);
301             for (ValueDescriptor v : objectContext.fields) {
302                 if (!v.getFields().isEmpty() &amp;&amp; v.getName().equals(structName)) {
303                     RecordedObject child = getValue(structName);
304                     String subName = name.substring(dotIndex + 1);
305                     if (child != null) {
306                         return child.getValue(subName, allowUnsigned);
307                     } else {
308                         // Call getValueDescriptor to trigger IllegalArgumentException if the name is
309                         // incorrect. Type can&#39;t be validate due to type erasure
310                         getValueDescriptor(v.getFields(), subName, null);
311                         throw new NullPointerException(&quot;Field value for \&quot;&quot; + structName + &quot;\&quot; was null. Can&#39;t access nested field \&quot;&quot; + subName + &quot;\&quot;&quot;);
312                     }
313                 }
314             }
315         }
316         throw new IllegalArgumentException(&quot;Could not find field with name &quot; + name);
317     }
318 
319     // Returns the leaf value descriptor matches both name or value, or throws an
320     // IllegalArgumentException
321     private ValueDescriptor getValueDescriptor(List&lt;ValueDescriptor&gt; descriptors, String name, String leafType) {
322         int dotIndex = name.indexOf(&quot;.&quot;);
323         if (dotIndex &gt; 0) {
324             String first = name.substring(0, dotIndex);
325             String second = name.substring(dotIndex + 1);
326             for (ValueDescriptor v : descriptors) {
327                 if (v.getName().equals(first)) {
328                     List&lt;ValueDescriptor&gt; fields = v.getFields();
329                     if (!fields.isEmpty()) {
330                         return getValueDescriptor(v.getFields(), second, leafType);
331                     }
332                 }
333             }
334             throw new IllegalArgumentException(&quot;Attempt to get unknown field \&quot;&quot; + first + &quot;\&quot;&quot;);
335         }
336         for (ValueDescriptor v : descriptors) {
337             if (v.getName().equals(name)) {
338                 if (leafType != null &amp;&amp; !v.getTypeName().equals(leafType)) {
339                     throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with illegal data type conversion &quot; + leafType);
340                 }
341                 return v;
342             }
343         }
344         throw new IllegalArgumentException(&quot;\&quot;Attempt to get unknown field \&quot;&quot; + name + &quot;\&quot;&quot;);
345     }
346 
347     // Gets a value, but checks that type and name is correct first
348     // This is to prevent a call to getString on a thread field, that is
349     // null to succeed.
350     private &lt;T&gt; T getTypedValue(String name, String typeName) {
351         Objects.requireNonNull(name);
352         // Validate name and type first
353         getValueDescriptor(objectContext.fields, name, typeName);
354         return getValue(name);
355     }
356 
357     private Object[] structifyArray(ValueDescriptor v, Object[] array, int dimension) {
358         if (array == null) {
359             return null;
360         }
361         Object[] structArray = new Object[array.length];
362         ObjectContext objContext = objectContext.getInstance(v);
363         for (int i = 0; i &lt; structArray.length; i++) {
364             Object arrayElement = array[i];
365             if (dimension == 0) {
366                 // No general way to handle structarrays
367                 // without invoking ObjectFactory for every instance (which may require id)
368                 if (isStackFrameType(v.getTypeName())) {
369                     structArray[i] = new RecordedFrame(objContext, (Object[]) arrayElement);
370                 } else {
371                     structArray[i] = new RecordedObject(objContext, (Object[]) arrayElement);
372                 }
373             } else {
374                 structArray[i] = structifyArray(v, (Object[]) arrayElement, dimension - 1);
375             }
376         }
377         return structArray;
378     }
379 
380     private boolean isStackFrameType(String typeName) {
381         if (ObjectFactory.STACK_FRAME_VERSION_1.equals(typeName)) {
382             return true;
383         }
384         if (ObjectFactory.STACK_FRAME_VERSION_2.equals(typeName)) {
385             return true;
386         }
387         return false;
388     }
389 
390     /**
391      * Returns an immutable list of the fields for this object.
392      *
393      * @return the fields, not {@code null}
394      */
395     public List&lt;ValueDescriptor&gt; getFields() {
396         return objectContext.fields;
397     }
398 
399     /**
400      * Returns the value of a field of type {@code boolean}.
401      * &lt;p&gt;
402      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
403      * {@code &quot;aaa.bbb&quot;}).
404      * &lt;p&gt;
405      * A field might change or be removed in a future JDK release. A best practice
406      * for callers of this method is to validate the field before attempting access.
407      *
408      * @param name name of the field to get, not {@code null}
409      *
410      * @return the value of the field, {@code true} or {@code false}
411      *
412      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field is
413      *         not of type {@code boolean}
414      *
415      * @see #hasField(String)
416      * @see #getValue(String)
417      */
418     public final boolean getBoolean(String name) {
419         Object o = getValue(name);
420         if (o instanceof Boolean) {
421             return ((Boolean) o).booleanValue();
422         }
423         throw newIllegalArgumentException(name, &quot;boolean&quot;);
424     }
425 
426     /**
427      * Returns the value of a field of type {@code byte}.
428      * &lt;p&gt;
429      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
430      * {@code &quot;foo.bar&quot;}).
431      * &lt;p&gt;
432      * A field might change or be removed in a future JDK release. A best practice
433      * for callers of this method is to validate the field before attempting access.
434      *
435      * @param name of the field to get, not {@code null}
436      *
437      * @return the value of the field
438      *
439      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field is
440      *         not of type {@code byte}
441      *
442      * @see #hasField(String)
443      * @see #getValue(String)
444      */
445     public final byte getByte(String name) {
446         Object o = getValue(name);
447         if (o instanceof Byte) {
448             return ((Byte) o).byteValue();
449         }
450         throw newIllegalArgumentException(name, &quot;byte&quot;);
451     }
452 
453     /**
454      * Returns the value of a field of type {@code char}.
455      * &lt;p&gt;
456      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
457      * {@code &quot;aaa.bbb&quot;}).
458      * &lt;p&gt;
459      * A field might change or be removed in a future JDK release. A best practice
460      * for callers of this method is to validate the field before attempting access.
461      *
462      * @param name of the field to get, not {@code null}
463      *
464      * @return the value of the field as a {@code char}
465      *
466      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field is
467      *         not of type {@code char}
468      *
469      * @see #hasField(String)
470      * @see #getValue(String)
471      */
472     public final char getChar(String name) {
473         Object o = getValue(name);
474         if (o instanceof Character) {
475             return ((Character) o).charValue();
476         }
477 
478         throw newIllegalArgumentException(name, &quot;char&quot;);
479     }
480 
481     /**
482      * Returns the value of a field of type {@code short} or of another primitive
483      * type convertible to type {@code short} by a widening conversion.
484      * &lt;p&gt;
485      * This method can be used on the following types: {@code short} and {@code byte}.
486      * &lt;p&gt;
487      * If the field has the {@code @Unsigned} annotation and is of a narrower type
488      * than {@code short}, then the value is returned as an unsigned.
489      * &lt;p&gt;
490      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
491      * {@code &quot;aaa.bbb&quot;}).
492      * &lt;p&gt;
493      * A field might change or be removed in a future JDK release. A best practice
494      * for callers of this method is to validate the field before attempting access.
495      *
496      * @param name of the field to get, not {@code null}
497      *
498      * @return the value of the field converted to type {@code short}
499      *
500      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
501      *         value can&#39;t be converted to the type {@code short} by a widening
502      *         conversion
503      *
504      * @see #hasField(String)
505      * @see #getValue(String)
506      */
507     public final short getShort(String name) {
508         Object o = getValue(name, true);
509         if (o instanceof Short) {
510             return ((Short) o).shortValue();
511         }
512         if (o instanceof Byte) {
513             return ((Byte) o).byteValue();
514         }
515         if (o instanceof UnsignedValue) {
516             Object u = ((UnsignedValue) o).value();
517             if (u instanceof Short) {
518                 return ((Short) u).shortValue();
519             }
520             if (u instanceof Byte) {
521                 return (short) Byte.toUnsignedInt(((Byte) u));
522             }
523         }
524         throw newIllegalArgumentException(name, &quot;short&quot;);
525     }
526 
527     /**
528      * Returns the value of a field of type {@code int} or of another primitive type
529      * that is convertible to type {@code int} by a widening conversion.
530      * &lt;p&gt;
531      * This method can be used on fields of the following types: {@code int},
532      * {@code short}, {@code char}, and {@code byte}.
533      * &lt;p&gt;
534      * If the field has the {@code @Unsigned} annotation and is of a narrower type
535      * than {@code int}, then the value will be returned as an unsigned.
536      * &lt;p&gt;
537      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
538      * {@code &quot;aaa.bbb&quot;}).
539      * &lt;p&gt;
540      * A field might change or be removed in a future JDK release. A best practice
541      * for callers of this method is to validate the field before attempting access.
542      *
543      * @param name of the field to get, not {@code null}
544      *
545      * @return the value of the field converted to type {@code int}
546      *
547      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
548      *         value can&#39;t be converted to the type {@code int} by a widening
549      *         conversion
550      *
551      * @see #hasField(String)
552      * @see #getValue(String)
553      */
554     public final int getInt(String name) {
555         Object o = getValue(name, true);
556         if (o instanceof Integer) {
557             return ((Integer) o).intValue();
558         }
559         if (o instanceof Short) {
560             return ((Short) o).intValue();
561         }
562         if (o instanceof Character) {
563             return ((Character) o).charValue();
564         }
565         if (o instanceof Byte) {
566             return ((Byte) o).intValue();
567         }
568         if (o instanceof UnsignedValue) {
569             Object u = ((UnsignedValue) o).value();
570             if (u instanceof Integer) {
571                 return ((Integer) u).intValue();
572             }
573             if (u instanceof Short) {
574                 return Short.toUnsignedInt(((Short) u));
575             }
576             if (u instanceof Byte) {
577                 return Byte.toUnsignedInt(((Byte) u));
578             }
579         }
580         throw newIllegalArgumentException(name, &quot;int&quot;);
581     }
582 
583     /**
584      * Returns the value of a field of type {@code float} or of another primitive
585      * type convertible to type {@code float} by a widening conversion.
586      * &lt;p&gt;
587      * This method can be used on fields of the following types: {@code float},
588      * {@code long}, {@code int}, {@code short}, {@code char}, and {@code byte}.
589      * &lt;p&gt;
590      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
591      * {@code &quot;aaa.bbb&quot;}).
592      * &lt;p&gt;
593      * A field might change or be removed in a future JDK release. A best practice
594      * for callers of this method is to validate the field before attempting access.
595      *
596      * @param name of the field to get, not {@code null}
597      *
598      * @return the value of the field converted to type {@code float}
599      *
600      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
601      *         value can&#39;t be converted to the type {@code float} by a widening
602      *         conversion
603      *
604      * @see #hasField(String)
605      * @see #getValue(String)
606      */
607     public final float getFloat(String name) {
608         Object o = getValue(name);
609         if (o instanceof Float) {
610             return ((Float) o).floatValue();
611         }
612         if (o instanceof Long) {
613             return ((Long) o).floatValue();
614         }
615         if (o instanceof Integer) {
616             return ((Integer) o).floatValue();
617         }
618         if (o instanceof Short) {
619             return ((Short) o).floatValue();
620         }
621         if (o instanceof Byte) {
622             return ((Byte) o).byteValue();
623         }
624         if (o instanceof Character) {
625             return ((Character) o).charValue();
626         }
627         throw newIllegalArgumentException(name, &quot;float&quot;);
628     }
629 
630     /**
631      * Returns the value of a field of type {@code long} or of another primitive
632      * type that is convertible to type {@code long} by a widening conversion.
633      * &lt;p&gt;
634      * This method can be used on fields of the following types: {@code long},
635      * {@code int}, {@code short}, {@code char}, and {@code byte}.
636      * &lt;p&gt;
637      * If the field has the {@code @Unsigned} annotation and is of a narrower type
638      * than {@code long}, then the value will be returned as an unsigned.
639      * &lt;p&gt;
640      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
641      * {@code &quot;aaa.bbb&quot;}).
642      * &lt;p&gt;
643      * A field might change or be removed in a future JDK release. A best practice
644      * for callers of this method is to validate the field before attempting access.
645      *
646      * @param name of the field to get, not {@code null}
647      *
648      * @return the value of the field converted to type {@code long}
649      *
650      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
651      *         value can&#39;t be converted to the type {@code long} via a widening
652      *         conversion
653      *
654      * @see #hasField(String)
655      * @see #getValue(String)
656      */
657     public final long getLong(String name) {
658         Object o = getValue(name, true);
659         if (o instanceof Long) {
660             return ((Long) o).longValue();
661         }
662         if (o instanceof Integer) {
663             return ((Integer) o).longValue();
664         }
665         if (o instanceof Short) {
666             return ((Short) o).longValue();
667         }
668         if (o instanceof Character) {
669             return ((Character) o).charValue();
670         }
671         if (o instanceof Byte) {
672             return ((Byte) o).longValue();
673         }
674         if (o instanceof UnsignedValue) {
675             Object u = ((UnsignedValue) o).value();
676             if (u instanceof Integer) {
677                 return Integer.toUnsignedLong(((Integer) u));
678             }
679             if (u instanceof Short) {
680                 return Short.toUnsignedLong(((Short) u));
681             }
682             if (u instanceof Byte) {
683                 return Byte.toUnsignedLong(((Byte) u));
684             }
685         }
686         throw newIllegalArgumentException(name, &quot;long&quot;);
687     }
688 
689     /**
690      * Returns the value of a field of type {@code double} or of another primitive
691      * type that is convertible to type {@code double} by a widening conversion.
692      * &lt;p&gt;
693      * This method can be used on fields of the following types: {@code double}, {@code float},
694      * {@code long}, {@code int}, {@code short}, {@code char}, and {@code byte}.
695      * &lt;p&gt;
696      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
697      * {@code &quot;aaa.bbb&quot;}).
698      * &lt;p&gt;
699      * A field might change or be removed in a future JDK release. A best practice
700      * for callers of this method is to validate the field before attempting access.
701      *
702      * @param name of the field to get, not {@code null}
703      *
704      * @return the value of the field converted to type {@code double}
705      *
706      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
707      *         value can&#39;t be converted to the type {@code double} by a widening
708      *         conversion
709      *
710      * @see #hasField(String)
711      * @see #getValue(String)
712      */
713     public final double getDouble(String name) {
714         Object o = getValue(name);
715         if (o instanceof Double) {
716             return ((Double) o).doubleValue();
717         }
718         if (o instanceof Float) {
719             return ((Float) o).doubleValue();
720         }
721         if (o instanceof Long) {
722             return ((Long) o).doubleValue();
723         }
724         if (o instanceof Integer) {
725             return ((Integer) o).doubleValue();
726         }
727         if (o instanceof Short) {
728             return ((Short) o).doubleValue();
729         }
730         if (o instanceof Byte) {
731             return ((Byte) o).byteValue();
732         }
733         if (o instanceof Character) {
734             return ((Character) o).charValue();
735         }
736         throw newIllegalArgumentException(name, &quot;double&quot;);
737     }
738 
739     /**
740      * Returns the value of a field of type {@code String}.
741      * &lt;p&gt;
742      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
743      * {@code &quot;foo.bar&quot;}).
744      * &lt;p&gt;
745      * A field might change or be removed in a future JDK release. A best practice
746      * for callers of this method is to validate the field before attempting access.
747      *
748      * @param name of the field to get, not {@code null}
749      *
750      * @return the value of the field as a {@code String}, can be {@code null}
751      *
752      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
753      *         isn&#39;t of type {@code String}
754      *
755      * @see #hasField(String)
756      * @see #getValue(String)
757      */
758     public final String getString(String name) {
759         return getTypedValue(name, &quot;java.lang.String&quot;);
760     }
761 
762     /**
763      * Returns the value of a timespan field.
764      * &lt;p&gt;
765      * This method can be used on fields annotated with {@code @Timespan}, and of
766      * the following types: {@code long}, {@code int}, {@code short}, {@code char},
767      * and {@code byte}.
768      * &lt;p&gt;
769      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
770      * {@code &quot;aaa.bbb&quot;}).
771      * &lt;p&gt;
772      * A field might change or be removed in a future JDK release. A best practice
773      * for callers of this method is to validate the field before attempting access.
774      *
775      * @param name of the field to get, not {@code null}
776      *
777      * @return a time span represented as a {@code Duration}, not {@code null}
778      *
779      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
780      *         value can&#39;t be converted to a {@code Duration} object
781      *
782      * @see #hasField(String)
783      * @see #getValue(String)
784      */
785     public final Duration getDuration(String name) {
786         Object o = getValue(name);
787         if (o instanceof Long) {
788             return getDuration(((Long) o).longValue(), name);
789         }
790         if (o instanceof Integer) {
791             return getDuration(((Integer) o).longValue(), name);
792         }
793         if (o instanceof Short) {
794             return getDuration(((Short) o).longValue(), name);
795         }
796         if (o instanceof Character) {
797             return getDuration(((Character) o).charValue(), name);
798         }
799         if (o instanceof Byte) {
800             return getDuration(((Byte) o).longValue(), name);
801         }
802         if (o instanceof UnsignedValue) {
803             Object u = ((UnsignedValue) o).value();
804             if (u instanceof Integer) {
805                 return getDuration(Integer.toUnsignedLong((Integer) u), name);
806             }
807             if (u instanceof Short) {
808                 return getDuration(Short.toUnsignedLong((Short) u), name);
809             }
810             if (u instanceof Byte) {
811                 return getDuration(Short.toUnsignedLong((Byte) u), name);
812             }
813         }
814         throw newIllegalArgumentException(name, &quot;java.time.Duration&quot;);
815     }
816 
817     private Duration getDuration(long timespan, String name) throws InternalError {
818         ValueDescriptor v = getValueDescriptor(objectContext.fields, name, null);
819         if (timespan == Long.MIN_VALUE) {
820             return Duration.ofSeconds(Long.MIN_VALUE, 0);
821         }
822         Timespan ts = v.getAnnotation(Timespan.class);
823         if (ts != null) {
824             switch (ts.value()) {
825             case Timespan.MICROSECONDS:
826                 return Duration.ofNanos(1000 * timespan);
827             case Timespan.SECONDS:
828                 return Duration.ofSeconds(timespan);
829             case Timespan.MILLISECONDS:
830                 return Duration.ofMillis(timespan);
831             case Timespan.NANOSECONDS:
832                 return Duration.ofNanos(timespan);
833             case Timespan.TICKS:
834                 return Duration.ofNanos(objectContext.convertTimespan(timespan));
835             }
836             throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with illegal timespan unit &quot; + ts.value());
837         }
838         throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with missing @Timespan&quot;);
839     }
840 
841     /**
842      * Returns the value of a timestamp field.
843      * &lt;p&gt;
844      * This method can be used on fields annotated with {@code @Timestamp}, and of
845      * the following types: {@code long}, {@code int}, {@code short}, {@code char}
846      * and {@code byte}.
847      * &lt;p&gt;
848      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
849      * {@code &quot;aaa.bbb&quot;}).
850      * &lt;p&gt;
851      * A field might change or be removed in a future JDK release. A best practice
852      * for callers of this method is to validate the field before attempting access.
853      *
854      * @param name of the field to get, not {@code null}
855      *
856      * @return a timstamp represented as an {@code Instant}, not {@code null}
857      *
858      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
859      *         value can&#39;t be converted to an {@code Instant} object
860      *
861      * @see #hasField(String)
862      * @see #getValue(String)
863      */
864     public final Instant getInstant(String name) {
865         Object o = getValue(name, true);
866         if (o instanceof Long) {
867             return getInstant(((Long) o).longValue(), name);
868         }
869         if (o instanceof Integer) {
870             return getInstant(((Integer) o).longValue(), name);
871         }
872         if (o instanceof Short) {
873             return getInstant(((Short) o).longValue(), name);
874         }
875         if (o instanceof Character) {
876             return getInstant(((Character) o).charValue(), name);
877         }
878         if (o instanceof Byte) {
879             return getInstant(((Byte) o).longValue(), name);
880         }
881         if (o instanceof UnsignedValue) {
882             Object u = ((UnsignedValue) o).value();
883             if (u instanceof Integer) {
884                 return getInstant(Integer.toUnsignedLong((Integer) u), name);
885             }
886             if (u instanceof Short) {
887                 return getInstant(Short.toUnsignedLong((Short) u), name);
888             }
889             if (u instanceof Byte) {
890                 return getInstant(Short.toUnsignedLong((Byte) u), name);
891             }
892         }
893         throw newIllegalArgumentException(name, &quot;java.time.Instant&quot;);
894     }
895 
896     private Instant getInstant(long timestamp, String name) {
897         ValueDescriptor v = getValueDescriptor(objectContext.fields, name, null);
898         Timestamp ts = v.getAnnotation(Timestamp.class);
899         if (ts != null) {
900             if (timestamp == Long.MIN_VALUE) {
901                 return Instant.MIN;
902             }
903             switch (ts.value()) {
904             case Timestamp.MILLISECONDS_SINCE_EPOCH:
905                 return Instant.ofEpochMilli(timestamp);
906             case Timestamp.TICKS:
907                 return Instant.ofEpochSecond(0, objectContext.convertTimestamp(timestamp));
908             }
909             throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with illegal timestamp unit &quot; + ts.value());
910         }
911         throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with missing @Timestamp&quot;);
912     }
913 
914     /**
915      * Returns the value of a field of type {@code Class}.
916      * &lt;p&gt;
917      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
918      * {@code &quot;aaa.bbb&quot;}).
919      * &lt;p&gt;
920      * A field might change or be removed in a future JDK release. A best practice
921      * for callers of this method is to validate the field before attempting access.
922      *
923      * @param name of the field to get, not {@code null}
924      *
925      * @return the value of the field as a {@code RecordedClass}, can be
926      *         {@code null}
927      *
928      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
929      *         isn&#39;t of type {@code Class}
930      *
931      * @see #hasField(String)
932      * @see #getValue(String)
933      */
934     public final RecordedClass getClass(String name) {
935         return getTypedValue(name, &quot;java.lang.Class&quot;);
936     }
937 
938     /**
939      * Returns the value of a field of type {@code Thread}.
940      * &lt;p&gt;
941      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
942      * {@code &quot;foo.bar&quot;}).
943      * &lt;p&gt;
944      * A field might change or be removed in a future JDK release. A best practice
945      * for callers of this method is to validate the field before attempting access.
946      *
947      * @param name of the field to get, not {@code null}
948      *
949      * @return the value of the field as a {@code RecordedThread} object, can be
950      *         {@code null}
951      *
952      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
953      *         isn&#39;t of type {@code Thread}
954      *
955      * @see #hasField(String)
956      * @see #getValue(String)
957      */
958     public final RecordedThread getThread(String name) {
959         return getTypedValue(name, &quot;java.lang.Thread&quot;);
960     }
961 
962     /**
963      * Returns a textual representation of this object.
964      *
965      * @return textual description of this object
966      */
967     @Override
968     final public String toString() {
969         StringWriter s = new StringWriter();
970         PrettyWriter p = new PrettyWriter(new PrintWriter(s));
971         p.setStackDepth(5);
972         if (this instanceof RecordedEvent) {
973             p.print((RecordedEvent) this);
974         } else {
975             p.print(this, &quot;&quot;);
976         }
977         p.flush(true);
978         return s.toString();
979     }
980 
981     // package private for now. Used by EventWriter
982     private OffsetDateTime getOffsetDateTime(String name) {
983         Instant instant = getInstant(name);
984         if (instant.equals(Instant.MIN)) {
985             return OffsetDateTime.MIN;
986         }
987         return OffsetDateTime.ofInstant(getInstant(name), objectContext.getZoneOffset());
988     }
989 
990     private static IllegalArgumentException newIllegalArgumentException(String name, String typeName) {
991         return new IllegalArgumentException(&quot;Attempt to get field \&quot;&quot; + name + &quot;\&quot; with illegal data type conversion &quot; + typeName);
992     }
993 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
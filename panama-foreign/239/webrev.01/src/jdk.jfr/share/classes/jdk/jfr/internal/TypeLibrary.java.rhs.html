<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/TypeLibrary.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.io.IOException;
 29 import java.io.PrintWriter;
 30 import java.lang.annotation.Annotation;
 31 import java.lang.annotation.Repeatable;
 32 import java.lang.reflect.Field;
 33 import java.lang.reflect.InvocationTargetException;
 34 import java.lang.reflect.Method;
 35 import java.lang.reflect.Modifier;
 36 import java.util.ArrayDeque;
 37 import java.util.ArrayList;
 38 import java.util.Collection;
 39 import java.util.Collections;
 40 import java.util.HashMap;
 41 import java.util.HashSet;
 42 import java.util.LinkedHashMap;
 43 import java.util.List;
 44 import java.util.Map;
 45 import java.util.Queue;
 46 import java.util.Set;
 47 import java.util.function.Consumer;
 48 import java.util.function.Predicate;
 49 import java.util.stream.Stream;
 50 
 51 import jdk.jfr.AnnotationElement;
 52 import jdk.jfr.Description;
 53 import jdk.jfr.Label;
 54 import jdk.jfr.MetadataDefinition;
 55 import jdk.jfr.Name;
<a name="1" id="anc1"></a><span class="line-added"> 56 import jdk.jfr.SettingControl;</span>
 57 import jdk.jfr.SettingDescriptor;
 58 import jdk.jfr.Timespan;
 59 import jdk.jfr.Timestamp;
 60 import jdk.jfr.ValueDescriptor;
 61 import jdk.jfr.internal.tool.PrettyWriter;
 62 
 63 public final class TypeLibrary {
 64 
 65     private static TypeLibrary instance;
 66     private static boolean implicitFieldTypes;
 67     private static final Map&lt;Long, Type&gt; types = new LinkedHashMap&lt;&gt;(100);
 68     static final ValueDescriptor DURATION_FIELD = createDurationField();
 69     static final ValueDescriptor THREAD_FIELD = createThreadField();
 70     static final ValueDescriptor STACK_TRACE_FIELD = createStackTraceField();
 71     static final ValueDescriptor START_TIME_FIELD = createStartTimeField();
 72 
 73     private TypeLibrary(List&lt;Type&gt; jvmTypes) {
 74         visitReachable(jvmTypes, t -&gt; !types.containsKey(t.getId()), t -&gt; types.put(t.getId(), t));
 75         if (Logger.shouldLog(LogTag.JFR_SYSTEM_METADATA, LogLevel.INFO)) {
 76             Stream&lt;Type&gt; s = types.values().stream().sorted((x, y) -&gt; Long.compare(x.getId(), y.getId()));
 77             s.forEach(t -&gt; t.log(&quot;Added&quot;, LogTag.JFR_SYSTEM_METADATA, LogLevel.INFO));
 78         }
 79     }
 80 
 81     private static ValueDescriptor createStartTimeField() {
 82         List&lt;AnnotationElement&gt; annos = createStandardAnnotations(&quot;Start Time&quot;, null);
 83         annos.add(new jdk.jfr.AnnotationElement(Timestamp.class, Timestamp.TICKS));
 84         return PrivateAccess.getInstance().newValueDescriptor(EventInstrumentation.FIELD_START_TIME, Type.LONG, annos, 0, false,
 85                 EventInstrumentation.FIELD_START_TIME);
 86 
 87     }
 88 
 89     private static ValueDescriptor createStackTraceField() {
 90         List&lt;AnnotationElement&gt; annos = new ArrayList&lt;&gt;();
 91         annos = createStandardAnnotations(&quot;Stack Trace&quot;, &quot;Stack Trace starting from the method the event was committed in&quot;);
 92         return PrivateAccess.getInstance().newValueDescriptor(EventInstrumentation.FIELD_STACK_TRACE, Type.STACK_TRACE, annos, 0, true,
 93                 EventInstrumentation.FIELD_STACK_TRACE);
 94     }
 95 
 96     private static ValueDescriptor createThreadField() {
 97         List&lt;AnnotationElement&gt; annos = new ArrayList&lt;&gt;();
 98         annos = createStandardAnnotations(&quot;Event Thread&quot;, &quot;Thread in which event was committed in&quot;);
 99         return PrivateAccess.getInstance().newValueDescriptor(EventInstrumentation.FIELD_EVENT_THREAD, Type.THREAD, annos, 0, true,
100                 EventInstrumentation.FIELD_EVENT_THREAD);
101     }
102 
103     private static ValueDescriptor createDurationField() {
104         List&lt;AnnotationElement&gt; annos = new ArrayList&lt;&gt;();
105         annos = createStandardAnnotations(&quot;Duration&quot;, null);
106         annos.add(new jdk.jfr.AnnotationElement(Timespan.class, Timespan.TICKS));
107         return PrivateAccess.getInstance().newValueDescriptor(EventInstrumentation.FIELD_DURATION, Type.LONG, annos, 0, false, EventInstrumentation.FIELD_DURATION);
108     }
109 
110     public static TypeLibrary getInstance() {
111         synchronized (TypeLibrary.class) {
112             if (instance == null) {
113                 List&lt;Type&gt; jvmTypes;
114                 try {
115                     jvmTypes = MetadataLoader.createTypes();
116                     Collections.sort(jvmTypes, (a,b) -&gt; Long.compare(a.getId(), b.getId()));
117                 } catch (IOException e) {
118                     throw new Error(&quot;JFR: Could not read metadata&quot;);
119                 }
120                 instance = new TypeLibrary(jvmTypes);
121             }
122             return instance;
123         }
124     }
125 
126     public List&lt;Type&gt; getTypes() {
127         return new ArrayList&lt;&gt;(types.values());
128     }
129 
130     public static Type createAnnotationType(Class&lt;? extends Annotation&gt; a) {
131         if (shouldPersist(a)) {
132             Type type = defineType(a, Type.SUPER_TYPE_ANNOTATION, false);
133             if (type != null) {
134                 SecuritySupport.makeVisibleToJFR(a);
135                 for (Method method : a.getDeclaredMethods()) {
136                     type.add(PrivateAccess.getInstance().newValueDescriptor(method.getReturnType(), method.getName()));
137                 }
138                 ArrayList&lt;AnnotationElement&gt; aes = new ArrayList&lt;&gt;();
139                 for (Annotation annotation : resolveRepeatedAnnotations(a.getAnnotations())) {
140                     AnnotationElement ae = createAnnotation(annotation);
141                     if (ae != null) {
142                         aes.add(ae);
143                     }
144                 }
145                 aes.trimToSize();
146                 type.setAnnotations(aes);
147             }
148             return getType(a);
149         }
150         return null;
151     }
152 
153     static AnnotationElement createAnnotation(Annotation annotation) {
154         Class&lt;? extends Annotation&gt; annotationType = annotation.annotationType();
155         Type type = createAnnotationType(annotationType);
156         if (type != null) {
157             List&lt;Object&gt; values = new ArrayList&lt;&gt;();
158             for (ValueDescriptor v : type.getFields()) {
159                 values.add(invokeAnnotation(annotation, v.getName()));
160             }
161 
162             return PrivateAccess.getInstance().newAnnotation(type, values, annotation.annotationType().getClassLoader() == null);
163         }
164         return null;
165     }
166 
167     private static Object invokeAnnotation(Annotation annotation, String methodName) {
168         final Method m;
169         try {
170             m = annotation.getClass().getMethod(methodName, new Class&lt;?&gt;[0]);
171         } catch (NoSuchMethodException e1) {
172             throw (Error) new InternalError(&quot;Could not locate method &quot; + methodName + &quot; in annotation &quot; + annotation.getClass().getName());
173         }
174         SecuritySupport.setAccessible(m);
175         try {
176             return m.invoke(annotation, new Object[0]);
177         } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
178             throw (Error) new InternalError(&quot;Could not get value for method &quot; + methodName + &quot; in annotation &quot; + annotation.getClass().getName());
179         }
180     }
181 
182     private static boolean shouldPersist(Class&lt;? extends Annotation&gt; a) {
183         if (a == MetadataDefinition.class || a.getAnnotation(MetadataDefinition.class) == null) {
184             return false;
185         }
186         return true;
187     }
188 
189     private static boolean isDefined(Class&lt;?&gt; clazz) {
190         return types.containsKey(Type.getTypeId(clazz));
191     }
192 
193     private static Type getType(Class&lt;?&gt; clazz) {
194         return types.get(Type.getTypeId(clazz));
195     }
196 
197     private static Type defineType(Class&lt;?&gt; clazz, String superType, boolean eventType) {
198         if (!isDefined(clazz)) {
199             Name name = clazz.getAnnotation(Name.class);
200             String typeName = name != null ? name.value() : clazz.getName();
201             long id = Type.getTypeId(clazz);
202             Type t;
203             if (eventType) {
204                 t = new PlatformEventType(typeName, id, clazz.getClassLoader() == null, true);
205             } else {
206                 t = new Type(typeName, superType, id);
207             }
208             types.put(t.getId(), t);
209             return t;
210         }
211         return null;
212     }
213     public static Type createType(Class&lt;?&gt; clazz) {
214         return createType(clazz, Collections.emptyList(), Collections.emptyList());
215     }
216 
217     public static Type createType(Class&lt;?&gt; clazz, List&lt;AnnotationElement&gt; dynamicAnnotations, List&lt;ValueDescriptor&gt; dynamicFields) {
218 
219         if (Thread.class == clazz) {
220             return Type.THREAD;
221         }
222 
223         if (Class.class.isAssignableFrom(clazz)) {
224             return Type.CLASS;
225         }
226 
227         if (String.class.equals(clazz)) {
228             return Type.STRING;
229         }
230 
231         if (isDefined(clazz)) {
232             return getType(clazz);
233         }
234 
235         if (clazz.isPrimitive()) {
236             return defineType(clazz, null,false);
237         }
238 
239         if (clazz.isArray()) {
240             throw new InternalError(&quot;Arrays not supported&quot;);
241         }
242 
243         // STRUCT
244         String superType = null;
245         boolean eventType = false;
246         if (jdk.internal.event.Event.class.isAssignableFrom(clazz)) {
247             superType = Type.SUPER_TYPE_EVENT;
248             eventType= true;
249         }
<a name="2" id="anc2"></a><span class="line-modified">250         if (SettingControl.class.isAssignableFrom(clazz)) {</span>
251             superType = Type.SUPER_TYPE_SETTING;
252         }
253 
254         // forward declare to avoid infinite recursion
255         defineType(clazz, superType, eventType);
256         Type type = getType(clazz);
257 
258         if (eventType) {
259             addImplicitFields(type, true, true, true, true ,false);
260             addUserFields(clazz, type, dynamicFields);
261             type.trimFields();
262         }
263         addAnnotations(clazz, type, dynamicAnnotations);
264 
265         if (clazz.getClassLoader() == null) {
266             type.log(&quot;Added&quot;, LogTag.JFR_SYSTEM_METADATA, LogLevel.INFO);
267         } else {
268             type.log(&quot;Added&quot;, LogTag.JFR_METADATA, LogLevel.INFO);
269         }
270         return type;
271     }
272 
273     private static void addAnnotations(Class&lt;?&gt; clazz, Type type, List&lt;AnnotationElement&gt; dynamicAnnotations) {
274         ArrayList&lt;AnnotationElement&gt; aes = new ArrayList&lt;&gt;();
275         if (dynamicAnnotations.isEmpty()) {
276             for (Annotation a : Utils.getAnnotations(clazz)) {
277                 AnnotationElement ae = createAnnotation(a);
278                 if (ae != null) {
279                     aes.add(ae);
280                 }
281             }
282         } else {
283             List&lt;Type&gt; newTypes = new ArrayList&lt;&gt;();
284             aes.addAll(dynamicAnnotations);
285             for (AnnotationElement ae : dynamicAnnotations) {
286                 newTypes.add(PrivateAccess.getInstance().getType(ae));
287             }
288             addTypes(newTypes);
289         }
290         type.setAnnotations(aes);
291         aes.trimToSize();
292     }
293 
294     private static void addUserFields(Class&lt;?&gt; clazz, Type type, List&lt;ValueDescriptor&gt; dynamicFields) {
295         Map&lt;String, ValueDescriptor&gt; dynamicFieldSet = new HashMap&lt;&gt;();
296         for (ValueDescriptor dynamicField : dynamicFields) {
297             dynamicFieldSet.put(dynamicField.getName(), dynamicField);
298         }
299         List&lt;Type&gt; newTypes = new ArrayList&lt;&gt;();
300         for (Field field : Utils.getVisibleEventFields(clazz)) {
301             ValueDescriptor vd = dynamicFieldSet.get(field.getName());
302             if (vd != null) {
303                 if (!vd.getTypeName().equals(field.getType().getName())) {
304                     throw new InternalError(&quot;Type expected to match for field &quot; + vd.getName() + &quot; expected &quot;  + field.getName() + &quot; but got &quot; + vd.getName());
305                 }
306                 for (AnnotationElement ae : vd.getAnnotationElements()) {
307                     newTypes.add(PrivateAccess.getInstance().getType(ae));
308                 }
309                 newTypes.add(PrivateAccess.getInstance().getType(vd));
310             } else {
311                 vd = createField(field);
312             }
313             if (vd != null) {
314                 type.add(vd);
315             }
316         }
317         addTypes(newTypes);
318     }
319 
320     // By convention all events have these fields.
321     static void addImplicitFields(Type type, boolean requestable, boolean hasDuration, boolean hasThread, boolean hasStackTrace, boolean hasCutoff) {
322         if (!implicitFieldTypes) {
323             createAnnotationType(Timespan.class);
324             createAnnotationType(Timestamp.class);
325             createAnnotationType(Label.class);
326             defineType(long.class, null, false);
327             implicitFieldTypes = true;
328         }
329         addFields(type, requestable, hasDuration, hasThread, hasStackTrace, hasCutoff);
330     }
331 
332     private static void addFields(Type type, boolean requestable, boolean hasDuration, boolean hasThread, boolean hasStackTrace, boolean hasCutoff) {
333         type.add(START_TIME_FIELD);
334         if (hasDuration || hasCutoff) {
335             type.add(DURATION_FIELD);
336         }
337         if (hasThread) {
338             type.add(THREAD_FIELD);
339         }
340         if (hasStackTrace) {
341             type.add(STACK_TRACE_FIELD);
342         }
343     }
344 
345     private static List&lt;AnnotationElement&gt; createStandardAnnotations(String name, String description) {
346         List&lt;AnnotationElement&gt; annotationElements = new ArrayList&lt;&gt;(2);
347         annotationElements.add(new jdk.jfr.AnnotationElement(Label.class, name));
348         if (description != null) {
349             annotationElements.add(new jdk.jfr.AnnotationElement(Description.class, description));
350         }
351         return annotationElements;
352     }
353 
354     private static ValueDescriptor createField(Field field) {
355         int mod = field.getModifiers();
356         if (Modifier.isTransient(mod)) {
357             return null;
358         }
359         if (Modifier.isStatic(mod)) {
360             return null;
361         }
362         Class&lt;?&gt; fieldType = field.getType();
363         if (!Type.isKnownType(fieldType)) {
364             return null;
365         }
366         boolean constantPool = Thread.class == fieldType || fieldType == Class.class;
367         Type type = createType(fieldType);
368         String fieldName = field.getName();
369         Name name = field.getAnnotation(Name.class);
370         String useName = fieldName;
371         if (name != null) {
372             useName = name.value();
373         }
374         List&lt;jdk.jfr.AnnotationElement&gt; ans = new ArrayList&lt;&gt;();
375         for (Annotation a : resolveRepeatedAnnotations(field.getAnnotations())) {
376             AnnotationElement ae = createAnnotation(a);
377             if (ae != null) {
378                 ans.add(ae);
379             }
380         }
381         return PrivateAccess.getInstance().newValueDescriptor(useName, type, ans, 0, constantPool, fieldName);
382     }
383 
384     private static List&lt;Annotation&gt; resolveRepeatedAnnotations(Annotation[] annotations) {
385         List&lt;Annotation&gt; annos = new ArrayList&lt;&gt;(annotations.length);
386         for (Annotation a : annotations) {
387             boolean repeated = false;
388             Method m;
389             try {
390                 m = a.annotationType().getMethod(&quot;value&quot;);
391                 Class&lt;?&gt; returnType = m.getReturnType();
392                 if (returnType.isArray()) {
393                     Class&lt;?&gt; ct = returnType.getComponentType();
394                     if (Annotation.class.isAssignableFrom(ct) &amp;&amp; ct.getAnnotation(Repeatable.class) != null) {
395                         Object res = m.invoke(a, new Object[0]);
396                         if (res != null &amp;&amp; Annotation[].class.isAssignableFrom(res.getClass())) {
397                             for (Annotation rep : (Annotation[]) m.invoke(a, new Object[0])) {
398                                 annos.add(rep);
399                             }
400                             repeated = true;
401                         }
402                     }
403                 }
404             } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
405                 // Ignore, can&#39;t access repeatable information
406             }
407             if (!repeated) {
408                 annos.add(a);
409             }
410         }
411         return annos;
412     }
413 
414     // Purpose of this method is to mark types that are reachable
415     // from registered event types. Those types that are not reachable can
416     // safely be removed
417     // Returns true if type was removed
418     public boolean clearUnregistered() {
419         Logger.log(LogTag.JFR_METADATA, LogLevel.TRACE, &quot;Cleaning out obsolete metadata&quot;);
420         List&lt;Type&gt; registered = new ArrayList&lt;&gt;();
421         for (Type type : types.values()) {
422             if (type instanceof PlatformEventType) {
423                 if (((PlatformEventType) type).isRegistered()) {
424                     registered.add(type);
425                 }
426             }
427         }
428         visitReachable(registered, t -&gt; t.getRemove(), t -&gt; t.setRemove(false));
429         List&lt;Long&gt; removeIds = new ArrayList&lt;&gt;();
430         for (Type type :  types.values()) {
431             if (type.getRemove() &amp;&amp; !Type.isDefinedByJVM(type.getId())) {
432                 removeIds.add(type.getId());
433                 if (Logger.shouldLog(LogTag.JFR_METADATA, LogLevel.TRACE)) {
434                     Logger.log(LogTag.JFR_METADATA, LogLevel.TRACE, &quot;Removed obsolete metadata &quot; + type.getName());
435                 }
436             }
437             // Optimization, set to true now to avoid iterating
438             // types first thing at next call to clearUnregistered
439             type.setRemove(true);
440         }
441         for (Long id : removeIds) {
442             types.remove(id);
443         }
444         return !removeIds.isEmpty();
445     }
446 
447     public void addType(Type type) {
448         addTypes(Collections.singletonList(type));
449     }
450 
451     public static void addTypes(List&lt;Type&gt; ts) {
452         if (!ts.isEmpty()) {
453             visitReachable(ts, t -&gt; !types.containsKey(t.getId()), t -&gt; types.put(t.getId(), t));
454         }
455     }
456 
457     /**
458      * Iterates all reachable types from a start collection
459      *
460      * @param rootSet the types to start from
461      * @param p if a type should be accepted
462      * @param c action to take on an accepted type
463      */
464     private  static void visitReachable(Collection&lt;Type&gt; rootSet, Predicate&lt;Type&gt; p,  Consumer&lt;Type&gt; c) {
465         Queue&lt;Type&gt; typeQ = new ArrayDeque&lt;&gt;(rootSet);
466         while (!typeQ.isEmpty()) {
467             Type type = typeQ.poll();
468             if (p.test(type)) {
469                 c.accept(type);
470                 visitAnnotations(typeQ, type.getAnnotationElements());
471                 for (ValueDescriptor v : type.getFields()) {
472                     typeQ.add(PrivateAccess.getInstance().getType(v));
473                     visitAnnotations(typeQ, v.getAnnotationElements());
474                 }
475                 if (type instanceof PlatformEventType) {
476                     PlatformEventType pe = (PlatformEventType) type;
477                     for (SettingDescriptor s : pe.getAllSettings()) {
478                         typeQ.add(PrivateAccess.getInstance().getType(s));
479                         visitAnnotations(typeQ, s.getAnnotationElements());
480                     }
481                 }
482             }
483         }
484     }
485 
486     private static void visitAnnotations(Queue&lt;Type&gt; typeQ, List&lt;AnnotationElement&gt; aes) {
487         Queue&lt;AnnotationElement&gt; aQ = new ArrayDeque&lt;&gt;(aes);
488         Set&lt;AnnotationElement&gt; visited = new HashSet&lt;&gt;();
489         while (!aQ.isEmpty()) {
490             AnnotationElement ae = aQ.poll();
491             if (!visited.contains(ae)) {
492                 Type ty = PrivateAccess.getInstance().getType(ae);
493                 typeQ.add(ty);
494                 visited.add(ae);
495             }
496             aQ.addAll(ae.getAnnotationElements());
497         }
498     }
499 
500     public void removeType(long id) {
501         types.remove(id);
502     }
503 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
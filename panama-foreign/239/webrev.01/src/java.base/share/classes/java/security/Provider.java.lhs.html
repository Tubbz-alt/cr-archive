<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/security/Provider.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.security;
  27 
  28 import java.io.*;
  29 import java.util.*;
  30 import static java.util.Locale.ENGLISH;
  31 import java.lang.ref.*;
  32 import java.lang.reflect.*;
  33 import java.util.function.BiConsumer;
  34 import java.util.function.BiFunction;
  35 import java.util.function.Function;
  36 import java.util.concurrent.ConcurrentHashMap;
  37 
  38 /**
  39  * This class represents a &quot;provider&quot; for the
  40  * Java Security API, where a provider implements some or all parts of
  41  * Java Security. Services that a provider may implement include:
  42  *
  43  * &lt;ul&gt;
  44  *
  45  * &lt;li&gt;Algorithms (such as DSA, RSA, or SHA-256).
  46  *
  47  * &lt;li&gt;Key generation, conversion, and management facilities (such as for
  48  * algorithm-specific keys).
  49  *
  50  * &lt;/ul&gt;
  51  *
  52  * &lt;p&gt;Some provider implementations may encounter unrecoverable internal
  53  * errors during their operation, for example a failure to communicate with a
  54  * security token. A {@link ProviderException} should be used to indicate
  55  * such errors.
  56  *
  57  * &lt;p&gt;Please note that a provider can be used to implement any security
  58  * service in Java that uses a pluggable architecture with a choice
  59  * of implementations that fit underneath.
  60  *
  61  * &lt;p&gt;The service type {@code Provider} is reserved for use by the
  62  * security framework. Services of this type cannot be added, removed,
  63  * or modified by applications.
  64  * The following attributes are automatically placed in each Provider object:
  65  * &lt;table class=&quot;striped&quot;&gt;
  66  * &lt;caption&gt;&lt;b&gt;Attributes Automatically Placed in a Provider Object&lt;/b&gt;&lt;/caption&gt;
  67  * &lt;thead&gt;
  68  * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Name&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Value&lt;/th&gt;
  69  * &lt;/thead&gt;
  70  * &lt;tbody style=&quot;text-align:left&quot;&gt;
  71  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Provider.id name}&lt;/th&gt;
  72  *     &lt;td&gt;{@code String.valueOf(provider.getName())}&lt;/td&gt;
  73  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Provider.id version}&lt;/th&gt;
  74  *     &lt;td&gt;{@code String.valueOf(provider.getVersionStr())}&lt;/td&gt;
  75  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Provider.id info}&lt;/th&gt;
  76  *     &lt;td&gt;{@code String.valueOf(provider.getInfo())}&lt;/td&gt;
  77  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Provider.id className}&lt;/th&gt;
  78  *     &lt;td&gt;{@code provider.getClass().getName()}&lt;/td&gt;
  79  * &lt;/tbody&gt;
  80  * &lt;/table&gt;
  81  *
  82  * &lt;p&gt;Each provider has a name and a version string. A provider normally
  83  * identifies itself with a file named {@code java.security.Provider}
  84  * in the resource directory {@code META-INF/services}.
  85  * Security providers are looked up via the {@link ServiceLoader} mechanism
  86  * using the {@link ClassLoader#getSystemClassLoader application class loader}.
  87  *
  88  * &lt;p&gt;Providers may be configured such that they are automatically
  89  * installed and made available at runtime via the
  90  * {@link Security#getProviders() Security.getProviders()} method.
  91  * The mechanism for configuring and installing security providers is
  92  * implementation-specific.
  93  *
  94  * @implNote
  95  * The JDK implementation supports static registration of the security
  96  * providers via the {@code conf/security/java.security} file in the Java
  97  * installation directory. These providers are automatically installed by
  98  * the JDK runtime, see {@extLink security_guide_jca_provider
  99  * The Provider Class}
 100  * in the Java Cryptography Architecture (JCA) Reference Guide
 101  * for information about how a particular type of provider, the cryptographic
 102  * service provider, works and is installed.
 103  *
 104  * @author Benjamin Renaud
 105  * @author Andreas Sterbenz
 106  * @since 1.1
 107  */
 108 public abstract class Provider extends Properties {
 109 
 110     // Declare serialVersionUID to be compatible with JDK1.1
 111     @java.io.Serial
 112     private static final long serialVersionUID = -4298000515446427739L;
 113 
 114     private static final sun.security.util.Debug debug =
 115         sun.security.util.Debug.getInstance(&quot;provider&quot;, &quot;Provider&quot;);
 116 
 117     /**
 118      * The provider name.
 119      *
 120      * @serial
 121      */
 122     private String name;
 123 
 124     /**
 125      * A description of the provider and its services.
 126      *
 127      * @serial
 128      */
 129     private String info;
 130 
 131     /**
 132      * The provider version number.
 133      *
 134      * @serial
 135      */
 136     private double version;
 137 
 138     /**
 139      * The provider version string.
 140      *
 141      * @serial
 142      */
 143     private String versionStr;
 144 
 145     private transient Set&lt;Map.Entry&lt;Object,Object&gt;&gt; entrySet = null;
 146     private transient int entrySetCallCount = 0;
 147 
 148     private transient boolean initialized;
 149 
 150     private static Object newInstanceUtil(final Class&lt;?&gt; clazz,
 151         final Class&lt;?&gt; ctrParamClz, final Object ctorParamObj)
 152         throws Exception {
 153         if (ctrParamClz == null) {
 154             Constructor&lt;?&gt; con = clazz.getConstructor();
 155             return con.newInstance();
 156         } else {
 157             // Looking for the constructor with a params first and fallback
 158             // to one without if not found. This is to support the enhanced
 159             // SecureRandom where both styles of constructors are supported.
 160             // Before jdk9, there was no params support (only getInstance(alg))
 161             // and an impl only had the params-less constructor. Since jdk9,
 162             // there is getInstance(alg,params) and an impl can contain
 163             // an Impl(params) constructor.
 164             try {
 165                 Constructor&lt;?&gt; con = clazz.getConstructor(ctrParamClz);
 166                 return con.newInstance(ctorParamObj);
 167             } catch (NoSuchMethodException nsme) {
 168                 // For pre-jdk9 SecureRandom implementations, they only
 169                 // have params-less constructors which still works when
 170                 // the input ctorParamObj is null.
 171                 //
 172                 // For other primitives using params, ctorParamObj should not
 173                 // be null and nsme is thrown, just like before.
 174                 if (ctorParamObj == null) {
 175                     try {
 176                         Constructor&lt;?&gt; con = clazz.getConstructor();
 177                         return con.newInstance();
 178                     } catch (NoSuchMethodException nsme2) {
 179                         nsme.addSuppressed(nsme2);
 180                         throw nsme;
 181                     }
 182                 } else {
 183                     throw nsme;
 184                 }
 185             }
 186         }
 187     }
 188 
 189     private static double parseVersionStr(String s) {
 190         try {
 191             int firstDotIdx = s.indexOf(&#39;.&#39;);
 192             int nextDotIdx = s.indexOf(&#39;.&#39;, firstDotIdx + 1);
 193             if (nextDotIdx != -1) {
 194                 s = s.substring(0, nextDotIdx);
 195             }
 196             int endIdx = s.indexOf(&#39;-&#39;);
 197             if (endIdx &gt; 0) {
 198                 s = s.substring(0, endIdx);
 199             }
 200             endIdx = s.indexOf(&#39;+&#39;);
 201             if (endIdx &gt; 0) {
 202                 s = s.substring(0, endIdx);
 203             }
 204             return Double.parseDouble(s);
 205         } catch (NullPointerException | NumberFormatException e) {
 206             return 0d;
 207         }
 208     }
 209 
 210     /**
 211      * Constructs a provider with the specified name, version number,
 212      * and information. Calling this constructor is equivalent to call the
 213      * {@link #Provider(String, String, String)} with {@code name}
 214      * name, {@code Double.toString(version)}, and {@code info}.
 215      *
 216      * @param name the provider name.
 217      *
 218      * @param version the provider version number.
 219      *
 220      * @param info a description of the provider and its services.
 221      *
 222      * @deprecated use {@link #Provider(String, String, String)} instead.
 223      */
 224     @Deprecated(since=&quot;9&quot;)
 225     protected Provider(String name, double version, String info) {
 226         this.name = name;
 227         this.version = version;
 228         this.versionStr = Double.toString(version);
 229         this.info = info;
 230         this.serviceMap = new ConcurrentHashMap&lt;&gt;();
 231         putId();
 232         initialized = true;
 233     }
 234 
 235     /**
 236      * Constructs a provider with the specified name, version string,
 237      * and information.
 238      *
 239      * &lt;p&gt;The version string contains a version number optionally followed
 240      * by other information separated by one of the characters of &#39;+&#39;, &#39;-&#39;.
 241      *
 242      * The format for the version number is:
 243      *
 244      * &lt;blockquote&gt;&lt;pre&gt;
 245      *     ^[0-9]+(\.[0-9]+)*
 246      * &lt;/pre&gt;&lt;/blockquote&gt;
 247      *
 248      * &lt;p&gt;In order to return the version number in a double, when there are
 249      * more than two components (separated by &#39;.&#39; as defined above), only
 250      * the first two components are retained. The resulting string is then
 251      * passed to {@link Double#valueOf(String)} to generate version number,
 252      * i.e. {@link #getVersion}.
 253      * &lt;p&gt;If the conversion failed, value 0 will be used.
 254      *
 255      * @param name the provider name.
 256      *
 257      * @param versionStr the provider version string.
 258      *
 259      * @param info a description of the provider and its services.
 260      *
 261      * @since 9
 262      */
 263     protected Provider(String name, String versionStr, String info) {
 264         this.name = name;
 265         this.versionStr = versionStr;
 266         this.version = parseVersionStr(versionStr);
 267         this.info = info;
 268         this.serviceMap = new ConcurrentHashMap&lt;&gt;();
 269         putId();
 270         initialized = true;
 271     }
 272 
 273     /**
 274      * Apply the supplied configuration argument to this provider instance
 275      * and return the configured provider. Note that if this provider cannot
 276      * be configured in-place, a new provider will be created and returned.
 277      * Therefore, callers should always use the returned provider.
 278      *
 279      * @implSpec
 280      * The default implementation throws {@code UnsupportedOperationException}.
 281      * Subclasses should override this method only if a configuration argument
 282      * is supported.
 283      *
 284      * @param configArg the configuration information for configuring this
 285      *         provider.
 286      *
 287      * @throws UnsupportedOperationException if a configuration argument is
 288      *         not supported.
 289      * @throws NullPointerException if the supplied configuration argument is
 290      *         null.
 291      * @throws InvalidParameterException if the supplied configuration argument
 292      *         is invalid.
 293      * @return a provider configured with the supplied configuration argument.
 294      *
 295      * @since 9
 296      */
 297     public Provider configure(String configArg) {
 298         throw new UnsupportedOperationException(&quot;configure is not supported&quot;);
 299     }
 300 
 301     /**
 302      * Check if this provider instance has been configured.
 303      *
 304      * @implSpec
 305      * The default implementation returns true.
 306      * Subclasses should override this method if the provider instance requires
 307      * an explicit {@code configure} call after being constructed.
 308      *
 309      * @return true if no further configuration is needed, false otherwise.
 310      *
 311      * @since 9
 312      */
 313     public boolean isConfigured() {
 314         return true;
 315     }
 316 
 317 
 318     /**
 319      * Returns the name of this provider.
 320      *
 321      * @return the name of this provider.
 322      */
 323     public String getName() {
 324         return name;
 325     }
 326 
 327     /**
 328      * Returns the version number for this provider.
 329      *
 330      * @return the version number for this provider.
 331      *
 332      * @deprecated use {@link #getVersionStr} instead.
 333      */
 334     @Deprecated(since=&quot;9&quot;)
 335     public double getVersion() {
 336         return version;
 337     }
 338 
 339     /**
 340      * Returns the version string for this provider.
 341      *
 342      * @return the version string for this provider.
 343      *
 344      * @since 9
 345      */
 346     public String getVersionStr() {
 347         return versionStr;
 348     }
 349 
 350     /**
 351      * Returns a human-readable description of the provider and its
 352      * services.  This may return an HTML page, with relevant links.
 353      *
 354      * @return a description of the provider and its services.
 355      */
 356     public String getInfo() {
 357         return info;
 358     }
 359 
 360     /**
 361      * Returns a string with the name and the version string
 362      * of this provider.
 363      *
 364      * @return the string with the name and the version string
 365      * for this provider.
 366      */
 367     public String toString() {
 368         return name + &quot; version &quot; + versionStr;
 369     }
 370 
 371     /*
 372      * override the following methods to ensure that provider
 373      * information can only be changed if the caller has the appropriate
 374      * permissions.
 375      */
 376 
 377     /**
 378      * Clears this provider so that it no longer contains the properties
 379      * used to look up facilities implemented by the provider.
 380      *
 381      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 382      * method is called with the string {@code &quot;clearProviderProperties.&quot;+name}
 383      * (where {@code name} is the provider name) to see if it&#39;s ok to clear
 384      * this provider.
 385      *
 386      * @throws  SecurityException
 387      *          if a security manager exists and its {@link
 388      *          java.lang.SecurityManager#checkSecurityAccess} method
 389      *          denies access to clear this provider
 390      *
 391      * @since 1.2
 392      */
 393     @Override
 394     public synchronized void clear() {
 395         check(&quot;clearProviderProperties.&quot;+name);
 396         if (debug != null) {
 397             debug.println(&quot;Remove &quot; + name + &quot; provider properties&quot;);
 398         }
 399         implClear();
 400     }
 401 
 402     /**
 403      * Reads a property list (key and element pairs) from the input stream.
 404      *
 405      * @param inStream the input stream.
 406      * @throws    IOException if an error occurred when reading from the
 407      *               input stream.
 408      * @see java.util.Properties#load
 409      */
 410     @Override
 411     public synchronized void load(InputStream inStream) throws IOException {
 412         check(&quot;putProviderProperty.&quot;+name);
 413         if (debug != null) {
 414             debug.println(&quot;Load &quot; + name + &quot; provider properties&quot;);
 415         }
 416         Properties tempProperties = new Properties();
 417         tempProperties.load(inStream);
 418         implPutAll(tempProperties);
 419     }
 420 
 421     /**
 422      * Copies all of the mappings from the specified Map to this provider.
 423      * These mappings will replace any properties that this provider had
 424      * for any of the keys currently in the specified Map.
 425      *
 426      * @since 1.2
 427      */
 428     @Override
 429     public synchronized void putAll(Map&lt;?,?&gt; t) {
 430         check(&quot;putProviderProperty.&quot;+name);
 431         if (debug != null) {
 432             debug.println(&quot;Put all &quot; + name + &quot; provider properties&quot;);
 433         }
 434         implPutAll(t);
 435     }
 436 
 437     /**
 438      * Returns an unmodifiable Set view of the property entries contained
 439      * in this Provider.
 440      *
 441      * @see   java.util.Map.Entry
 442      * @since 1.2
 443      */
 444     @Override
 445     public synchronized Set&lt;Map.Entry&lt;Object,Object&gt;&gt; entrySet() {
 446         checkInitialized();
 447         if (entrySet == null) {
 448             if (entrySetCallCount++ == 0)  // Initial call
 449                 entrySet = Collections.unmodifiableMap(this).entrySet();
 450             else
 451                 return super.entrySet();   // Recursive call
 452         }
 453 
 454         // This exception will be thrown if the implementation of
 455         // Collections.unmodifiableMap.entrySet() is changed such that it
 456         // no longer calls entrySet() on the backing Map.  (Provider&#39;s
 457         // entrySet implementation depends on this &quot;implementation detail&quot;,
 458         // which is unlikely to change.
 459         if (entrySetCallCount != 2)
 460             throw new RuntimeException(&quot;Internal error.&quot;);
 461 
 462         return entrySet;
 463     }
 464 
 465     /**
 466      * Returns an unmodifiable Set view of the property keys contained in
 467      * this provider.
 468      *
 469      * @since 1.2
 470      */
 471     @Override
 472     public Set&lt;Object&gt; keySet() {
 473         checkInitialized();
 474         return Collections.unmodifiableSet(super.keySet());
 475     }
 476 
 477     /**
 478      * Returns an unmodifiable Collection view of the property values
 479      * contained in this provider.
 480      *
 481      * @since 1.2
 482      */
 483     @Override
 484     public Collection&lt;Object&gt; values() {
 485         checkInitialized();
 486         return Collections.unmodifiableCollection(super.values());
 487     }
 488 
 489     /**
 490      * Sets the {@code key} property to have the specified
 491      * {@code value}.
 492      *
 493      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 494      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 495      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 496      * provider&#39;s property values.
 497      *
 498      * @throws  SecurityException
 499      *          if a security manager exists and its {@link
 500      *          java.lang.SecurityManager#checkSecurityAccess} method
 501      *          denies access to set property values.
 502      *
 503      * @since 1.2
 504      */
 505     @Override
 506     public synchronized Object put(Object key, Object value) {
 507         check(&quot;putProviderProperty.&quot;+name);
 508         if (debug != null) {
 509             debug.println(&quot;Set &quot; + name + &quot; provider property [&quot; +
 510                           key + &quot;/&quot; + value +&quot;]&quot;);
 511         }
 512         return implPut(key, value);
 513     }
 514 
 515     /**
 516      * If the specified key is not already associated with a value (or is mapped
 517      * to {@code null}) associates it with the given value and returns
 518      * {@code null}, else returns the current value.
 519      *
 520      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 521      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 522      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 523      * provider&#39;s property values.
 524      *
 525      * @throws  SecurityException
 526      *          if a security manager exists and its {@link
 527      *          java.lang.SecurityManager#checkSecurityAccess} method
 528      *          denies access to set property values.
 529      *
 530      * @since 1.8
 531      */
 532     @Override
 533     public synchronized Object putIfAbsent(Object key, Object value) {
 534         check(&quot;putProviderProperty.&quot;+name);
 535         if (debug != null) {
 536             debug.println(&quot;Set &quot; + name + &quot; provider property [&quot; +
 537                           key + &quot;/&quot; + value +&quot;]&quot;);
 538         }
 539         return implPutIfAbsent(key, value);
 540     }
 541 
 542     /**
 543      * Removes the {@code key} property (and its corresponding
 544      * {@code value}).
 545      *
 546      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 547      * method is called with the string {@code &quot;removeProviderProperty.&quot;+name},
 548      * where {@code name} is the provider name, to see if it&#39;s ok to remove this
 549      * provider&#39;s properties.
 550      *
 551      * @throws  SecurityException
 552      *          if a security manager exists and its {@link
 553      *          java.lang.SecurityManager#checkSecurityAccess} method
 554      *          denies access to remove this provider&#39;s properties.
 555      *
 556      * @since 1.2
 557      */
 558     @Override
 559     public synchronized Object remove(Object key) {
 560         check(&quot;removeProviderProperty.&quot;+name);
 561         if (debug != null) {
 562             debug.println(&quot;Remove &quot; + name + &quot; provider property &quot; + key);
 563         }
 564         return implRemove(key);
 565     }
 566 
 567     /**
 568      * Removes the entry for the specified key only if it is currently
 569      * mapped to the specified value.
 570      *
 571      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 572      * method is called with the string {@code &quot;removeProviderProperty.&quot;+name},
 573      * where {@code name} is the provider name, to see if it&#39;s ok to remove this
 574      * provider&#39;s properties.
 575      *
 576      * @throws  SecurityException
 577      *          if a security manager exists and its {@link
 578      *          java.lang.SecurityManager#checkSecurityAccess} method
 579      *          denies access to remove this provider&#39;s properties.
 580      *
 581      * @since 1.8
 582      */
 583     @Override
 584     public synchronized boolean remove(Object key, Object value) {
 585         check(&quot;removeProviderProperty.&quot;+name);
 586         if (debug != null) {
 587             debug.println(&quot;Remove &quot; + name + &quot; provider property &quot; + key);
 588         }
 589         return implRemove(key, value);
 590     }
 591 
 592     /**
 593      * Replaces the entry for the specified key only if currently
 594      * mapped to the specified value.
 595      *
 596      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 597      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 598      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 599      * provider&#39;s property values.
 600      *
 601      * @throws  SecurityException
 602      *          if a security manager exists and its {@link
 603      *          java.lang.SecurityManager#checkSecurityAccess} method
 604      *          denies access to set property values.
 605      *
 606      * @since 1.8
 607      */
 608     @Override
 609     public synchronized boolean replace(Object key, Object oldValue,
 610             Object newValue) {
 611         check(&quot;putProviderProperty.&quot; + name);
 612 
 613         if (debug != null) {
 614             debug.println(&quot;Replace &quot; + name + &quot; provider property &quot; + key);
 615         }
 616         return implReplace(key, oldValue, newValue);
 617     }
 618 
 619     /**
 620      * Replaces the entry for the specified key only if it is
 621      * currently mapped to some value.
 622      *
 623      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 624      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 625      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 626      * provider&#39;s property values.
 627      *
 628      * @throws  SecurityException
 629      *          if a security manager exists and its {@link
 630      *          java.lang.SecurityManager#checkSecurityAccess} method
 631      *          denies access to set property values.
 632      *
 633      * @since 1.8
 634      */
 635     @Override
 636     public synchronized Object replace(Object key, Object value) {
 637         check(&quot;putProviderProperty.&quot; + name);
 638 
 639         if (debug != null) {
 640             debug.println(&quot;Replace &quot; + name + &quot; provider property &quot; + key);
 641         }
 642         return implReplace(key, value);
 643     }
 644 
 645     /**
 646      * Replaces each entry&#39;s value with the result of invoking the given
 647      * function on that entry, in the order entries are returned by an entry
 648      * set iterator, until all entries have been processed or the function
 649      * throws an exception.
 650      *
 651      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 652      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 653      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 654      * provider&#39;s property values.
 655      *
 656      * @throws  SecurityException
 657      *          if a security manager exists and its {@link
 658      *          java.lang.SecurityManager#checkSecurityAccess} method
 659      *          denies access to set property values.
 660      *
 661      * @since 1.8
 662      */
 663     @Override
 664     public synchronized void replaceAll(BiFunction&lt;? super Object,
 665             ? super Object, ? extends Object&gt; function) {
 666         check(&quot;putProviderProperty.&quot; + name);
 667 
 668         if (debug != null) {
 669             debug.println(&quot;ReplaceAll &quot; + name + &quot; provider property &quot;);
 670         }
 671         implReplaceAll(function);
 672     }
 673 
 674     /**
 675      * Attempts to compute a mapping for the specified key and its
 676      * current mapped value (or {@code null} if there is no current
 677      * mapping).
 678      *
 679      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 680      * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
 681      * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
 682      * provider name, to see if it&#39;s ok to set this provider&#39;s property values
 683      * and remove this provider&#39;s properties.
 684      *
 685      * @throws  SecurityException
 686      *          if a security manager exists and its {@link
 687      *          java.lang.SecurityManager#checkSecurityAccess} method
 688      *          denies access to set property values or remove properties.
 689      *
 690      * @since 1.8
 691      */
 692     @Override
 693     public synchronized Object compute(Object key, BiFunction&lt;? super Object,
 694             ? super Object, ? extends Object&gt; remappingFunction) {
 695         check(&quot;putProviderProperty.&quot; + name);
 696         check(&quot;removeProviderProperty.&quot; + name);
 697 
 698         if (debug != null) {
 699             debug.println(&quot;Compute &quot; + name + &quot; provider property &quot; + key);
 700         }
 701         return implCompute(key, remappingFunction);
 702     }
 703 
 704     /**
 705      * If the specified key is not already associated with a value (or
 706      * is mapped to {@code null}), attempts to compute its value using
 707      * the given mapping function and enters it into this map unless
 708      * {@code null}.
 709      *
 710      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 711      * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
 712      * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
 713      * provider name, to see if it&#39;s ok to set this provider&#39;s property values
 714      * and remove this provider&#39;s properties.
 715      *
 716      * @throws  SecurityException
 717      *          if a security manager exists and its {@link
 718      *          java.lang.SecurityManager#checkSecurityAccess} method
 719      *          denies access to set property values and remove properties.
 720      *
 721      * @since 1.8
 722      */
 723     @Override
 724     public synchronized Object computeIfAbsent(Object key, Function&lt;? super Object,
 725             ? extends Object&gt; mappingFunction) {
 726         check(&quot;putProviderProperty.&quot; + name);
 727         check(&quot;removeProviderProperty.&quot; + name);
 728 
 729         if (debug != null) {
 730             debug.println(&quot;ComputeIfAbsent &quot; + name + &quot; provider property &quot; +
 731                     key);
 732         }
 733         return implComputeIfAbsent(key, mappingFunction);
 734     }
 735 
 736     /**
 737      * If the value for the specified key is present and non-null, attempts to
 738      * compute a new mapping given the key and its current mapped value.
 739      *
 740      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 741      * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
 742      * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
 743      * provider name, to see if it&#39;s ok to set this provider&#39;s property values
 744      * and remove this provider&#39;s properties.
 745      *
 746      * @throws  SecurityException
 747      *          if a security manager exists and its {@link
 748      *          java.lang.SecurityManager#checkSecurityAccess} method
 749      *          denies access to set property values or remove properties.
 750      *
 751      * @since 1.8
 752      */
 753     @Override
 754     public synchronized Object computeIfPresent(Object key, BiFunction&lt;? super Object,
 755             ? super Object, ? extends Object&gt; remappingFunction) {
 756         check(&quot;putProviderProperty.&quot; + name);
 757         check(&quot;removeProviderProperty.&quot; + name);
 758 
 759         if (debug != null) {
 760             debug.println(&quot;ComputeIfPresent &quot; + name + &quot; provider property &quot; +
 761                     key);
 762         }
 763         return implComputeIfPresent(key, remappingFunction);
 764     }
 765 
 766     /**
 767      * If the specified key is not already associated with a value or is
 768      * associated with null, associates it with the given value. Otherwise,
 769      * replaces the value with the results of the given remapping function,
 770      * or removes if the result is null. This method may be of use when
 771      * combining multiple mapped values for a key.
 772      *
 773      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 774      * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
 775      * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
 776      * provider name, to see if it&#39;s ok to set this provider&#39;s property values
 777      * and remove this provider&#39;s properties.
 778      *
 779      * @throws  SecurityException
 780      *          if a security manager exists and its {@link
 781      *          java.lang.SecurityManager#checkSecurityAccess} method
 782      *          denies access to set property values or remove properties.
 783      *
 784      * @since 1.8
 785      */
 786     @Override
 787     public synchronized Object merge(Object key, Object value,  BiFunction&lt;? super Object,
 788             ? super Object, ? extends Object&gt;  remappingFunction) {
 789         check(&quot;putProviderProperty.&quot; + name);
 790         check(&quot;removeProviderProperty.&quot; + name);
 791 
 792         if (debug != null) {
 793             debug.println(&quot;Merge &quot; + name + &quot; provider property &quot; + key);
 794         }
 795         return implMerge(key, value, remappingFunction);
 796     }
 797 
 798     // let javadoc show doc from superclass
 799     @Override
 800     public Object get(Object key) {
 801         checkInitialized();
 802         return super.get(key);
 803     }
 804     /**
 805      * @since 1.8
 806      */
 807     @Override
 808     public synchronized Object getOrDefault(Object key, Object defaultValue) {
 809         checkInitialized();
 810         return super.getOrDefault(key, defaultValue);
 811     }
 812 
 813     /**
 814      * @since 1.8
 815      */
 816     @Override
 817     public synchronized void forEach(BiConsumer&lt;? super Object, ? super Object&gt; action) {
 818         checkInitialized();
 819         super.forEach(action);
 820     }
 821 
 822     // let javadoc show doc from superclass
 823     @Override
 824     public Enumeration&lt;Object&gt; keys() {
 825         checkInitialized();
 826         return super.keys();
 827     }
 828 
 829     // let javadoc show doc from superclass
 830     @Override
 831     public Enumeration&lt;Object&gt; elements() {
 832         checkInitialized();
 833         return super.elements();
 834     }
 835 
 836     // let javadoc show doc from superclass
 837     public String getProperty(String key) {
 838         checkInitialized();
 839         return super.getProperty(key);
 840     }
 841 
 842     private void checkInitialized() {
 843         if (!initialized) {
 844             throw new IllegalStateException();
 845         }
 846     }
 847 
 848     private void check(String directive) {
 849         checkInitialized();
 850         SecurityManager security = System.getSecurityManager();
 851         if (security != null) {
 852             security.checkSecurityAccess(directive);
 853         }
 854     }
 855 
 856     // legacy properties changed since last call to any services method?
 857     private transient boolean legacyChanged;
 858     // serviceMap changed since last call to getServices()
 859     private volatile transient boolean servicesChanged;
 860 
 861     // Map&lt;String,String&gt; used to keep track of legacy registration
 862     private transient Map&lt;String,String&gt; legacyStrings;
 863 
 864     // Map&lt;ServiceKey,Service&gt;
 865     // used for services added via putService(), initialized on demand
 866     private transient Map&lt;ServiceKey,Service&gt; serviceMap;
 867 
 868     // For backward compatibility, the registration ordering of
 869     // SecureRandom (RNG) algorithms needs to be preserved for
 870     // &quot;new SecureRandom()&quot; calls when this provider is used
<a name="1" id="anc1"></a><span class="line-modified"> 871     private transient Set&lt;Service&gt; prngServices;</span>
 872 
 873     // Map&lt;ServiceKey,Service&gt;
 874     // used for services added via legacy methods, init on demand
 875     private transient Map&lt;ServiceKey,Service&gt; legacyMap;
 876 
 877     // Set&lt;Service&gt;
 878     // Unmodifiable set of all services. Initialized on demand.
 879     private transient Set&lt;Service&gt; serviceSet;
 880 
 881     // register the id attributes for this provider
 882     // this is to ensure that equals() and hashCode() do not incorrectly
 883     // report to different provider objects as the same
 884     private void putId() {
 885         // note: name and info may be null
 886         super.put(&quot;Provider.id name&quot;, String.valueOf(name));
 887         super.put(&quot;Provider.id version&quot;, String.valueOf(versionStr));
 888         super.put(&quot;Provider.id info&quot;, String.valueOf(info));
 889         super.put(&quot;Provider.id className&quot;, this.getClass().getName());
 890     }
 891 
 892    /**
 893     * Reads the {@code ObjectInputStream} for the default serializable fields.
 894     * If the serialized field {@code versionStr} is found in the STREAM FIELDS,
 895     * its String value will be used to populate both the version string and
 896     * version number. If {@code versionStr} is not found, but {@code version}
 897     * is, then its double value will be used to populate both fields.
 898     *
 899     * @param in the {@code ObjectInputStream} to read
 900     * @serial
 901     */
 902     @java.io.Serial
 903     private void readObject(ObjectInputStream in)
 904                 throws IOException, ClassNotFoundException {
 905         Map&lt;Object,Object&gt; copy = new HashMap&lt;&gt;();
 906         for (Map.Entry&lt;Object,Object&gt; entry : super.entrySet()) {
 907             copy.put(entry.getKey(), entry.getValue());
 908         }
 909         defaults = null;
 910         in.defaultReadObject();
 911         if (this.versionStr == null) {
 912             // set versionStr based on version when not found in serialized bytes
 913             this.versionStr = Double.toString(this.version);
 914         } else {
 915             // otherwise, set version based on versionStr
 916             this.version = parseVersionStr(this.versionStr);
 917         }
 918         this.serviceMap = new ConcurrentHashMap&lt;&gt;();
 919         implClear();
 920         initialized = true;
 921         putAll(copy);
 922     }
 923 
 924     // check whether to update &#39;legacyString&#39; with the specified key
 925     private boolean checkLegacy(Object key) {
 926         String keyString = (String)key;
 927         if (keyString.startsWith(&quot;Provider.&quot;)) {
 928             return false;
 929         }
 930 
 931         legacyChanged = true;
 932         if (legacyStrings == null) {
 933             legacyStrings = new LinkedHashMap&lt;&gt;();
 934         }
 935         return true;
 936     }
 937 
 938     /**
 939      * Copies all of the mappings from the specified Map to this provider.
 940      * Internal method to be called AFTER the security check has been
 941      * performed.
 942      */
 943     private void implPutAll(Map&lt;?,?&gt; t) {
 944         for (Map.Entry&lt;?,?&gt; e : t.entrySet()) {
 945             implPut(e.getKey(), e.getValue());
 946         }
 947     }
 948 
 949     private Object implRemove(Object key) {
 950         if (key instanceof String) {
 951             if (!checkLegacy(key)) {
 952                 return null;
 953             }
 954             legacyStrings.remove((String)key);
 955         }
 956         return super.remove(key);
 957     }
 958 
 959     private boolean implRemove(Object key, Object value) {
 960         if (key instanceof String &amp;&amp; value instanceof String) {
 961             if (!checkLegacy(key)) {
 962                 return false;
 963             }
 964             legacyStrings.remove((String)key, (String)value);
 965         }
 966         return super.remove(key, value);
 967     }
 968 
 969     private boolean implReplace(Object key, Object oldValue, Object newValue) {
 970         if ((key instanceof String) &amp;&amp; (oldValue instanceof String) &amp;&amp;
 971                 (newValue instanceof String)) {
 972             if (!checkLegacy(key)) {
 973                 return false;
 974             }
 975             legacyStrings.replace((String)key, (String)oldValue,
 976                     (String)newValue);
 977         }
 978         return super.replace(key, oldValue, newValue);
 979     }
 980 
 981     private Object implReplace(Object key, Object value) {
 982         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
 983             if (!checkLegacy(key)) {
 984                 return null;
 985             }
 986             legacyStrings.replace((String)key, (String)value);
 987         }
 988         return super.replace(key, value);
 989     }
 990 
 991     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
 992     private void implReplaceAll(BiFunction&lt;? super Object, ? super Object,
 993             ? extends Object&gt; function) {
 994         legacyChanged = true;
 995         if (legacyStrings == null) {
 996             legacyStrings = new LinkedHashMap&lt;&gt;();
 997         } else {
 998             legacyStrings.replaceAll((BiFunction&lt;? super String, ? super String,
 999                     ? extends String&gt;) function);
1000         }
1001         super.replaceAll(function);
1002     }
1003 
1004     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1005     private Object implMerge(Object key, Object value,
1006             BiFunction&lt;? super Object, ? super Object, ? extends Object&gt;
1007             remappingFunction) {
1008         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
1009             if (!checkLegacy(key)) {
1010                 return null;
1011             }
1012             legacyStrings.merge((String)key, (String)value,
1013                     (BiFunction&lt;? super String, ? super String,
1014                     ? extends String&gt;) remappingFunction);
1015         }
1016         return super.merge(key, value, remappingFunction);
1017     }
1018 
1019     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1020     private Object implCompute(Object key, BiFunction&lt;? super Object,
1021             ? super Object, ? extends Object&gt; remappingFunction) {
1022         if (key instanceof String) {
1023             if (!checkLegacy(key)) {
1024                 return null;
1025             }
1026             legacyStrings.compute((String) key,
1027                     (BiFunction&lt;? super String,? super String,
1028                     ? extends String&gt;) remappingFunction);
1029         }
1030         return super.compute(key, remappingFunction);
1031     }
1032 
1033     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1034     private Object implComputeIfAbsent(Object key, Function&lt;? super Object,
1035             ? extends Object&gt; mappingFunction) {
1036         if (key instanceof String) {
1037             if (!checkLegacy(key)) {
1038                 return null;
1039             }
1040             legacyStrings.computeIfAbsent((String) key,
1041                     (Function&lt;? super String, ? extends String&gt;)
1042                     mappingFunction);
1043         }
1044         return super.computeIfAbsent(key, mappingFunction);
1045     }
1046 
1047     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1048     private Object implComputeIfPresent(Object key, BiFunction&lt;? super Object,
1049             ? super Object, ? extends Object&gt; remappingFunction) {
1050         if (key instanceof String) {
1051             if (!checkLegacy(key)) {
1052                 return null;
1053             }
1054             legacyStrings.computeIfPresent((String) key,
1055                     (BiFunction&lt;? super String, ? super String,
1056                     ? extends String&gt;) remappingFunction);
1057         }
1058         return super.computeIfPresent(key, remappingFunction);
1059     }
1060 
1061     private Object implPut(Object key, Object value) {
1062         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
1063             if (!checkLegacy(key)) {
1064                 return null;
1065             }
1066             legacyStrings.put((String)key, (String)value);
1067         }
1068         return super.put(key, value);
1069     }
1070 
1071     private Object implPutIfAbsent(Object key, Object value) {
1072         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
1073             if (!checkLegacy(key)) {
1074                 return null;
1075             }
1076             legacyStrings.putIfAbsent((String)key, (String)value);
1077         }
1078         return super.putIfAbsent(key, value);
1079     }
1080 
1081     private void implClear() {
1082         if (legacyStrings != null) {
1083             legacyStrings.clear();
1084         }
1085         if (legacyMap != null) {
1086             legacyMap.clear();
1087         }
1088         serviceMap.clear();
1089         legacyChanged = false;
1090         servicesChanged = false;
1091         serviceSet = null;
<a name="2" id="anc2"></a><span class="line-modified">1092         prngServices = null;</span>
1093         super.clear();
1094         putId();
1095     }
1096 
1097     // used as key in the serviceMap and legacyMap HashMaps
1098     private static class ServiceKey {
1099         private final String type;
1100         private final String algorithm;
1101         private final String originalAlgorithm;
1102         private ServiceKey(String type, String algorithm, boolean intern) {
1103             this.type = type;
1104             this.originalAlgorithm = algorithm;
1105             algorithm = algorithm.toUpperCase(ENGLISH);
1106             this.algorithm = intern ? algorithm.intern() : algorithm;
1107         }
1108         public int hashCode() {
1109             return Objects.hash(type, algorithm);
1110         }
1111         public boolean equals(Object obj) {
1112             if (this == obj) {
1113                 return true;
1114             }
1115             if (!(obj instanceof ServiceKey)) {
1116                 return false;
1117             }
1118             ServiceKey other = (ServiceKey)obj;
1119             return this.type.equals(other.type)
1120                 &amp;&amp; this.algorithm.equals(other.algorithm);
1121         }
1122         boolean matches(String type, String algorithm) {
1123             return (this.type == type) &amp;&amp; (this.originalAlgorithm == algorithm);
1124         }
1125     }
1126 
1127     /**
1128      * Ensure all the legacy String properties are fully parsed into
1129      * service objects.
1130      */
1131     private void ensureLegacyParsed() {
1132         if (legacyChanged == false || (legacyStrings == null)) {
1133             return;
1134         }
1135         serviceSet = null;
1136         if (legacyMap == null) {
1137             legacyMap = new ConcurrentHashMap&lt;&gt;();
1138         } else {
1139             legacyMap.clear();
1140         }
1141         for (Map.Entry&lt;String,String&gt; entry : legacyStrings.entrySet()) {
1142             parseLegacyPut(entry.getKey(), entry.getValue());
1143         }
1144         removeInvalidServices(legacyMap);
1145         legacyChanged = false;
1146     }
1147 
1148     /**
1149      * Remove all invalid services from the Map. Invalid services can only
1150      * occur if the legacy properties are inconsistent or incomplete.
1151      */
1152     private void removeInvalidServices(Map&lt;ServiceKey,Service&gt; map) {
1153         for (Iterator&lt;Map.Entry&lt;ServiceKey, Service&gt;&gt; t =
1154                 map.entrySet().iterator(); t.hasNext(); ) {
1155             Service s = t.next().getValue();
1156             if (s.isValid() == false) {
1157                 t.remove();
1158             }
1159         }
1160     }
1161 
1162     private static String[] getTypeAndAlgorithm(String key) {
1163         int i = key.indexOf(&#39;.&#39;);
1164         if (i &lt; 1) {
1165             if (debug != null) {
1166                 debug.println(&quot;Ignoring invalid entry in provider: &quot;
1167                         + key);
1168             }
1169             return null;
1170         }
1171         String type = key.substring(0, i);
1172         String alg = key.substring(i + 1);
1173         return new String[] {type, alg};
1174     }
1175 
1176     private static final String ALIAS_PREFIX = &quot;Alg.Alias.&quot;;
1177     private static final String ALIAS_PREFIX_LOWER = &quot;alg.alias.&quot;;
1178     private static final int ALIAS_LENGTH = ALIAS_PREFIX.length();
1179 
1180     private void parseLegacyPut(String name, String value) {
1181         if (name.toLowerCase(ENGLISH).startsWith(ALIAS_PREFIX_LOWER)) {
1182             // e.g. put(&quot;Alg.Alias.MessageDigest.SHA&quot;, &quot;SHA-1&quot;);
1183             // aliasKey ~ MessageDigest.SHA
1184             String stdAlg = value;
1185             String aliasKey = name.substring(ALIAS_LENGTH);
1186             String[] typeAndAlg = getTypeAndAlgorithm(aliasKey);
1187             if (typeAndAlg == null) {
1188                 return;
1189             }
1190             String type = getEngineName(typeAndAlg[0]);
1191             String aliasAlg = typeAndAlg[1].intern();
1192             ServiceKey key = new ServiceKey(type, stdAlg, true);
1193             Service s = legacyMap.get(key);
1194             if (s == null) {
1195                 s = new Service(this);
1196                 s.type = type;
1197                 s.algorithm = stdAlg;
1198                 legacyMap.put(key, s);
1199             }
1200             legacyMap.put(new ServiceKey(type, aliasAlg, true), s);
1201             s.addAlias(aliasAlg);
1202         } else {
1203             String[] typeAndAlg = getTypeAndAlgorithm(name);
1204             if (typeAndAlg == null) {
1205                 return;
1206             }
1207             int i = typeAndAlg[1].indexOf(&#39; &#39;);
1208             if (i == -1) {
1209                 // e.g. put(&quot;MessageDigest.SHA-1&quot;, &quot;sun.security.provider.SHA&quot;);
1210                 String type = getEngineName(typeAndAlg[0]);
1211                 String stdAlg = typeAndAlg[1].intern();
1212                 String className = value;
1213                 ServiceKey key = new ServiceKey(type, stdAlg, true);
1214                 Service s = legacyMap.get(key);
1215                 if (s == null) {
1216                     s = new Service(this);
1217                     s.type = type;
1218                     s.algorithm = stdAlg;
1219                     legacyMap.put(key, s);
1220                 }
1221                 s.className = className;
1222 
1223                 if (type.equals(&quot;SecureRandom&quot;)) {
<a name="3" id="anc3"></a><span class="line-modified">1224                     updateSecureRandomEntries(true, s);</span>
1225                 }
1226             } else { // attribute
1227                 // e.g. put(&quot;MessageDigest.SHA-1 ImplementedIn&quot;, &quot;Software&quot;);
1228                 String attributeValue = value;
1229                 String type = getEngineName(typeAndAlg[0]);
1230                 String attributeString = typeAndAlg[1];
1231                 String stdAlg = attributeString.substring(0, i).intern();
1232                 String attributeName = attributeString.substring(i + 1);
1233                 // kill additional spaces
1234                 while (attributeName.startsWith(&quot; &quot;)) {
1235                     attributeName = attributeName.substring(1);
1236                 }
1237                 attributeName = attributeName.intern();
1238                 ServiceKey key = new ServiceKey(type, stdAlg, true);
1239                 Service s = legacyMap.get(key);
1240                 if (s == null) {
1241                     s = new Service(this);
1242                     s.type = type;
1243                     s.algorithm = stdAlg;
1244                     legacyMap.put(key, s);
1245                 }
1246                 s.addAttribute(attributeName, attributeValue);
1247             }
1248         }
1249     }
1250 
1251     /**
1252      * Get the service describing this Provider&#39;s implementation of the
1253      * specified type of this algorithm or alias. If no such
1254      * implementation exists, this method returns null. If there are two
1255      * matching services, one added to this provider using
1256      * {@link #putService putService()} and one added via {@link #put put()},
1257      * the service added via {@link #putService putService()} is returned.
1258      *
1259      * @param type the type of {@link Service service} requested
1260      * (for example, {@code MessageDigest})
1261      * @param algorithm the case insensitive algorithm name (or alternate
1262      * alias) of the service requested (for example, {@code SHA-1})
1263      *
1264      * @return the service describing this Provider&#39;s matching service
1265      * or null if no such service exists
1266      *
1267      * @throws NullPointerException if type or algorithm is null
1268      *
1269      * @since 1.5
1270      */
1271     public Service getService(String type, String algorithm) {
1272         checkInitialized();
1273 
1274         // avoid allocating a new ServiceKey object if possible
1275         ServiceKey key = previousKey;
1276         if (key.matches(type, algorithm) == false) {
1277             key = new ServiceKey(type, algorithm, false);
1278             previousKey = key;
1279         }
1280         if (!serviceMap.isEmpty()) {
1281             Service s = serviceMap.get(key);
1282             if (s != null) {
1283                 return s;
1284             }
1285         }
1286         synchronized (this) {
1287             ensureLegacyParsed();
1288             if (legacyMap != null &amp;&amp; !legacyMap.isEmpty()) {
1289                 return legacyMap.get(key);
1290             }
1291         }
1292         return null;
1293     }
1294 
1295     // ServiceKey from previous getService() call
1296     // by re-using it if possible we avoid allocating a new object
1297     // and the toUpperCase() call.
1298     // re-use will occur e.g. as the framework traverses the provider
1299     // list and queries each provider with the same values until it finds
1300     // a matching service
1301     private static volatile ServiceKey previousKey =
1302                                             new ServiceKey(&quot;&quot;, &quot;&quot;, false);
1303 
1304     /**
1305      * Get an unmodifiable Set of all services supported by
1306      * this Provider.
1307      *
1308      * @return an unmodifiable Set of all services supported by
1309      * this Provider
1310      *
1311      * @since 1.5
1312      */
1313     public synchronized Set&lt;Service&gt; getServices() {
1314         checkInitialized();
1315         if (legacyChanged || servicesChanged) {
1316             serviceSet = null;
1317         }
1318         if (serviceSet == null) {
1319             ensureLegacyParsed();
1320             Set&lt;Service&gt; set = new LinkedHashSet&lt;&gt;();
1321             if (!serviceMap.isEmpty()) {
1322                 set.addAll(serviceMap.values());
1323             }
1324             if (legacyMap != null &amp;&amp; !legacyMap.isEmpty()) {
1325                 set.addAll(legacyMap.values());
1326             }
1327             serviceSet = Collections.unmodifiableSet(set);
1328             servicesChanged = false;
1329         }
1330         return serviceSet;
1331     }
1332 
1333     /**
1334      * Add a service. If a service of the same type with the same algorithm
1335      * name exists and it was added using {@link #putService putService()},
1336      * it is replaced by the new service.
1337      * This method also places information about this service
1338      * in the provider&#39;s Hashtable values in the format described in the
1339      * {@extLink security_guide_jca
1340      * Java Cryptography Architecture (JCA) Reference Guide}.
1341      *
1342      * &lt;p&gt;Also, if there is a security manager, its
1343      * {@code checkSecurityAccess} method is called with the string
1344      * {@code &quot;putProviderProperty.&quot;+name}, where {@code name} is
1345      * the provider name, to see if it&#39;s ok to set this provider&#39;s property
1346      * values. If the default implementation of {@code checkSecurityAccess}
1347      * is used (that is, that method is not overridden), then this results in
1348      * a call to the security manager&#39;s {@code checkPermission} method with
1349      * a {@code SecurityPermission(&quot;putProviderProperty.&quot;+name)}
1350      * permission.
1351      *
1352      * @param s the Service to add
1353      *
1354      * @throws SecurityException
1355      *      if a security manager exists and its {@link
1356      *      java.lang.SecurityManager#checkSecurityAccess} method denies
1357      *      access to set property values.
1358      * @throws NullPointerException if s is null
1359      *
1360      * @since 1.5
1361      */
1362     protected void putService(Service s) {
1363         check(&quot;putProviderProperty.&quot; + name);
1364         if (debug != null) {
1365             debug.println(name + &quot;.putService(): &quot; + s);
1366         }
1367         if (s == null) {
1368             throw new NullPointerException();
1369         }
1370         if (s.getProvider() != this) {
1371             throw new IllegalArgumentException
1372                     (&quot;service.getProvider() must match this Provider object&quot;);
1373         }
1374         String type = s.getType();
1375         String algorithm = s.getAlgorithm();
1376         ServiceKey key = new ServiceKey(type, algorithm, true);
1377         implRemoveService(serviceMap.get(key));
1378         serviceMap.put(key, s);
1379         for (String alias : s.getAliases()) {
1380             serviceMap.put(new ServiceKey(type, alias, true), s);
1381         }
1382         servicesChanged = true;
1383         synchronized (this) {
1384             putPropertyStrings(s);
1385             if (type.equals(&quot;SecureRandom&quot;)) {
<a name="4" id="anc4"></a><span class="line-modified">1386                 updateSecureRandomEntries(true, s);</span>
1387             }
1388         }
1389     }
1390 
<a name="5" id="anc5"></a><span class="line-modified">1391     private void updateSecureRandomEntries(boolean doAdd, Service s) {</span>

1392         Objects.requireNonNull(s);
1393         if (doAdd) {
<a name="6" id="anc6"></a><span class="line-modified">1394             if (prngServices == null) {</span>
<span class="line-modified">1395                 prngServices = new LinkedHashSet&lt;Service&gt;();</span>
1396             }
<a name="7" id="anc7"></a><span class="line-modified">1397             prngServices.add(s);</span>
1398         } else {
<a name="8" id="anc8"></a><span class="line-modified">1399             prngServices.remove(s);</span>
1400         }
1401 
1402         if (debug != null) {
<a name="9" id="anc9"></a><span class="line-modified">1403             debug.println((doAdd? &quot;Add&quot;:&quot;Remove&quot;) + &quot; SecureRandom algo &quot; +</span>
<span class="line-removed">1404                 s.getAlgorithm());</span>
1405         }
1406     }
1407 
1408     // used by new SecureRandom() to find out the default SecureRandom
1409     // service for this provider
1410     synchronized Service getDefaultSecureRandomService() {
1411         checkInitialized();
1412 
1413         if (legacyChanged) {
<a name="10" id="anc10"></a><span class="line-modified">1414             prngServices = null;</span>
1415             ensureLegacyParsed();
1416         }
1417 
<a name="11" id="anc11"></a><span class="line-modified">1418         if (prngServices != null &amp;&amp; !prngServices.isEmpty()) {</span>
<span class="line-modified">1419             return prngServices.iterator().next();</span>



1420         }
1421 
1422         return null;
1423     }
1424 
1425     /**
1426      * Put the string properties for this Service in this Provider&#39;s
1427      * Hashtable.
1428      */
1429     private void putPropertyStrings(Service s) {
1430         String type = s.getType();
1431         String algorithm = s.getAlgorithm();
1432         // use super() to avoid permission check and other processing
1433         super.put(type + &quot;.&quot; + algorithm, s.getClassName());
1434         for (String alias : s.getAliases()) {
1435             super.put(ALIAS_PREFIX + type + &quot;.&quot; + alias, algorithm);
1436         }
1437         for (Map.Entry&lt;UString,String&gt; entry : s.attributes.entrySet()) {
1438             String key = type + &quot;.&quot; + algorithm + &quot; &quot; + entry.getKey();
1439             super.put(key, entry.getValue());
1440         }
1441     }
1442 
1443     /**
1444      * Remove the string properties for this Service from this Provider&#39;s
1445      * Hashtable.
1446      */
1447     private void removePropertyStrings(Service s) {
1448         String type = s.getType();
1449         String algorithm = s.getAlgorithm();
1450         // use super() to avoid permission check and other processing
1451         super.remove(type + &quot;.&quot; + algorithm);
1452         for (String alias : s.getAliases()) {
1453             super.remove(ALIAS_PREFIX + type + &quot;.&quot; + alias);
1454         }
1455         for (Map.Entry&lt;UString,String&gt; entry : s.attributes.entrySet()) {
1456             String key = type + &quot;.&quot; + algorithm + &quot; &quot; + entry.getKey();
1457             super.remove(key);
1458         }
1459     }
1460 
1461     /**
1462      * Remove a service previously added using
1463      * {@link #putService putService()}. The specified service is removed from
1464      * this provider. It will no longer be returned by
1465      * {@link #getService getService()} and its information will be removed
1466      * from this provider&#39;s Hashtable.
1467      *
1468      * &lt;p&gt;Also, if there is a security manager, its
1469      * {@code checkSecurityAccess} method is called with the string
1470      * {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is
1471      * the provider name, to see if it&#39;s ok to remove this provider&#39;s
1472      * properties. If the default implementation of
1473      * {@code checkSecurityAccess} is used (that is, that method is not
1474      * overridden), then this results in a call to the security manager&#39;s
1475      * {@code checkPermission} method with a
1476      * {@code SecurityPermission(&quot;removeProviderProperty.&quot;+name)}
1477      * permission.
1478      *
1479      * @param s the Service to be removed
1480      *
1481      * @throws  SecurityException
1482      *          if a security manager exists and its {@link
1483      *          java.lang.SecurityManager#checkSecurityAccess} method denies
1484      *          access to remove this provider&#39;s properties.
1485      * @throws NullPointerException if s is null
1486      *
1487      * @since 1.5
1488      */
1489     protected void removeService(Service s) {
1490         check(&quot;removeProviderProperty.&quot; + name);
1491         if (debug != null) {
1492             debug.println(name + &quot;.removeService(): &quot; + s);
1493         }
1494         if (s == null) {
1495             throw new NullPointerException();
1496         }
1497         implRemoveService(s);
1498     }
1499 
1500     private void implRemoveService(Service s) {
1501         if ((s == null) || serviceMap.isEmpty()) {
1502             return;
1503         }
1504         String type = s.getType();
1505         String algorithm = s.getAlgorithm();
1506         ServiceKey key = new ServiceKey(type, algorithm, false);
1507         Service oldService = serviceMap.get(key);
1508         if (s != oldService) {
1509             return;
1510         }
1511         servicesChanged = true;
1512         serviceMap.remove(key);
1513         for (String alias : s.getAliases()) {
1514             serviceMap.remove(new ServiceKey(type, alias, false));
1515         }
1516         synchronized (this) {
1517             removePropertyStrings(s);
1518             if (type.equals(&quot;SecureRandom&quot;)) {
<a name="12" id="anc12"></a><span class="line-modified">1519                 updateSecureRandomEntries(false, s);</span>
1520             }
1521         }
1522     }
1523 
1524     // Wrapped String that behaves in a case insensitive way for equals/hashCode
1525     private static class UString {
1526         final String string;
1527         final String lowerString;
1528 
1529         UString(String s) {
1530             this.string = s;
1531             this.lowerString = s.toLowerCase(ENGLISH);
1532         }
1533 
1534         public int hashCode() {
1535             return lowerString.hashCode();
1536         }
1537 
1538         public boolean equals(Object obj) {
1539             if (this == obj) {
1540                 return true;
1541             }
1542             if (obj instanceof UString == false) {
1543                 return false;
1544             }
1545             UString other = (UString)obj;
1546             return lowerString.equals(other.lowerString);
1547         }
1548 
1549         public String toString() {
1550             return string;
1551         }
1552     }
1553 
1554     // describe relevant properties of a type of engine
1555     private static class EngineDescription {
1556         final String name;
1557         final boolean supportsParameter;
1558         final String constructorParameterClassName;
1559         private volatile Class&lt;?&gt; constructorParameterClass;
1560 
1561         EngineDescription(String name, boolean sp, String paramName) {
1562             this.name = name;
1563             this.supportsParameter = sp;
1564             this.constructorParameterClassName = paramName;
1565         }
1566         Class&lt;?&gt; getConstructorParameterClass() throws ClassNotFoundException {
1567             Class&lt;?&gt; clazz = constructorParameterClass;
1568             if (clazz == null) {
1569                 clazz = Class.forName(constructorParameterClassName);
1570                 constructorParameterClass = clazz;
1571             }
1572             return clazz;
1573         }
1574     }
1575 
1576     // built in knowledge of the engine types shipped as part of the JDK
1577     private static final Map&lt;String,EngineDescription&gt; knownEngines;
1578 
1579     private static void addEngine(String name, boolean sp, String paramName) {
1580         EngineDescription ed = new EngineDescription(name, sp, paramName);
1581         // also index by canonical name to avoid toLowerCase() for some lookups
1582         knownEngines.put(name.toLowerCase(ENGLISH), ed);
1583         knownEngines.put(name, ed);
1584     }
1585 
1586     static {
1587         knownEngines = new HashMap&lt;&gt;();
1588         // JCA
1589         addEngine(&quot;AlgorithmParameterGenerator&quot;,        false, null);
1590         addEngine(&quot;AlgorithmParameters&quot;,                false, null);
1591         addEngine(&quot;KeyFactory&quot;,                         false, null);
1592         addEngine(&quot;KeyPairGenerator&quot;,                   false, null);
1593         addEngine(&quot;KeyStore&quot;,                           false, null);
1594         addEngine(&quot;MessageDigest&quot;,                      false, null);
1595         addEngine(&quot;SecureRandom&quot;,                       false,
1596                 &quot;java.security.SecureRandomParameters&quot;);
1597         addEngine(&quot;Signature&quot;,                          true,  null);
1598         addEngine(&quot;CertificateFactory&quot;,                 false, null);
1599         addEngine(&quot;CertPathBuilder&quot;,                    false, null);
1600         addEngine(&quot;CertPathValidator&quot;,                  false, null);
1601         addEngine(&quot;CertStore&quot;,                          false,
1602                             &quot;java.security.cert.CertStoreParameters&quot;);
1603         // JCE
1604         addEngine(&quot;Cipher&quot;,                             true,  null);
1605         addEngine(&quot;ExemptionMechanism&quot;,                 false, null);
1606         addEngine(&quot;Mac&quot;,                                true,  null);
1607         addEngine(&quot;KeyAgreement&quot;,                       true,  null);
1608         addEngine(&quot;KeyGenerator&quot;,                       false, null);
1609         addEngine(&quot;SecretKeyFactory&quot;,                   false, null);
1610         // JSSE
1611         addEngine(&quot;KeyManagerFactory&quot;,                  false, null);
1612         addEngine(&quot;SSLContext&quot;,                         false, null);
1613         addEngine(&quot;TrustManagerFactory&quot;,                false, null);
1614         // JGSS
1615         addEngine(&quot;GssApiMechanism&quot;,                    false, null);
1616         // SASL
1617         addEngine(&quot;SaslClientFactory&quot;,                  false, null);
1618         addEngine(&quot;SaslServerFactory&quot;,                  false, null);
1619         // POLICY
1620         addEngine(&quot;Policy&quot;,                             false,
1621                             &quot;java.security.Policy$Parameters&quot;);
1622         // CONFIGURATION
1623         addEngine(&quot;Configuration&quot;,                      false,
1624                             &quot;javax.security.auth.login.Configuration$Parameters&quot;);
1625         // XML DSig
1626         addEngine(&quot;XMLSignatureFactory&quot;,                false, null);
1627         addEngine(&quot;KeyInfoFactory&quot;,                     false, null);
1628         addEngine(&quot;TransformService&quot;,                   false, null);
1629         // Smart Card I/O
1630         addEngine(&quot;TerminalFactory&quot;,                    false,
1631                             &quot;java.lang.Object&quot;);
1632     }
1633 
1634     // get the &quot;standard&quot; (mixed-case) engine name for arbitary case engine name
1635     // if there is no known engine by that name, return s
1636     private static String getEngineName(String s) {
1637         // try original case first, usually correct
1638         EngineDescription e = knownEngines.get(s);
1639         if (e == null) {
1640             e = knownEngines.get(s.toLowerCase(ENGLISH));
1641         }
1642         return (e == null) ? s : e.name;
1643     }
1644 
1645     /**
1646      * The description of a security service. It encapsulates the properties
1647      * of a service and contains a factory method to obtain new implementation
1648      * instances of this service.
1649      *
1650      * &lt;p&gt;Each service has a provider that offers the service, a type,
1651      * an algorithm name, and the name of the class that implements the
1652      * service. Optionally, it also includes a list of alternate algorithm
1653      * names for this service (aliases) and attributes, which are a map of
1654      * (name, value) String pairs.
1655      *
1656      * &lt;p&gt;This class defines the methods {@link #supportsParameter
1657      * supportsParameter()} and {@link #newInstance newInstance()}
1658      * which are used by the Java security framework when it searches for
1659      * suitable services and instantiates them. The valid arguments to those
1660      * methods depend on the type of service. For the service types defined
1661      * within Java SE, see the
1662      * {@extLink security_guide_jca
1663      * Java Cryptography Architecture (JCA) Reference Guide}
1664      * for the valid values.
1665      * Note that components outside of Java SE can define additional types of
1666      * services and their behavior.
1667      *
1668      * &lt;p&gt;Instances of this class are immutable.
1669      *
1670      * @since 1.5
1671      */
1672     public static class Service {
1673 
1674         private String type, algorithm, className;
1675         private final Provider provider;
1676         private List&lt;String&gt; aliases;
1677         private Map&lt;UString,String&gt; attributes;
1678 
1679         // Reference to the cached implementation Class object
1680         private volatile Reference&lt;Class&lt;?&gt;&gt; classRef;
1681 
1682         // flag indicating whether this service has its attributes for
1683         // supportedKeyFormats or supportedKeyClasses set
1684         // if null, the values have not been initialized
1685         // if TRUE, at least one of supportedFormats/Classes is non null
1686         private volatile Boolean hasKeyAttributes;
1687 
1688         // supported encoding formats
1689         private String[] supportedFormats;
1690 
1691         // names of the supported key (super) classes
1692         private Class&lt;?&gt;[] supportedClasses;
1693 
1694         // whether this service has been registered with the Provider
1695         private boolean registered;
1696 
1697         private static final Class&lt;?&gt;[] CLASS0 = new Class&lt;?&gt;[0];
1698 
1699         // this constructor and these methods are used for parsing
1700         // the legacy string properties.
1701 
1702         private Service(Provider provider) {
1703             this.provider = provider;
1704             aliases = Collections.&lt;String&gt;emptyList();
1705             attributes = Collections.&lt;UString,String&gt;emptyMap();
1706         }
1707 
1708         private boolean isValid() {
1709             return (type != null) &amp;&amp; (algorithm != null) &amp;&amp; (className != null);
1710         }
1711 
1712         private void addAlias(String alias) {
1713             if (aliases.isEmpty()) {
1714                 aliases = new ArrayList&lt;&gt;(2);
1715             }
1716             aliases.add(alias);
1717         }
1718 
1719         void addAttribute(String type, String value) {
1720             if (attributes.isEmpty()) {
1721                 attributes = new HashMap&lt;&gt;(8);
1722             }
1723             attributes.put(new UString(type), value);
1724         }
1725 
1726         /**
1727          * Construct a new service.
1728          *
1729          * @param provider the provider that offers this service
1730          * @param type the type of this service
1731          * @param algorithm the algorithm name
1732          * @param className the name of the class implementing this service
1733          * @param aliases List of aliases or null if algorithm has no aliases
1734          * @param attributes Map of attributes or null if this implementation
1735          *                   has no attributes
1736          *
1737          * @throws NullPointerException if provider, type, algorithm, or
1738          * className is null
1739          */
1740         public Service(Provider provider, String type, String algorithm,
1741                 String className, List&lt;String&gt; aliases,
1742                 Map&lt;String,String&gt; attributes) {
1743             if ((provider == null) || (type == null) ||
1744                     (algorithm == null) || (className == null)) {
1745                 throw new NullPointerException();
1746             }
1747             this.provider = provider;
1748             this.type = getEngineName(type);
1749             this.algorithm = algorithm;
1750             this.className = className;
1751             if (aliases == null) {
1752                 this.aliases = Collections.&lt;String&gt;emptyList();
1753             } else {
1754                 this.aliases = new ArrayList&lt;&gt;(aliases);
1755             }
1756             if (attributes == null) {
1757                 this.attributes = Collections.&lt;UString,String&gt;emptyMap();
1758             } else {
1759                 this.attributes = new HashMap&lt;&gt;();
1760                 for (Map.Entry&lt;String,String&gt; entry : attributes.entrySet()) {
1761                     this.attributes.put(new UString(entry.getKey()), entry.getValue());
1762                 }
1763             }
1764         }
1765 
1766         /**
1767          * Get the type of this service. For example, {@code MessageDigest}.
1768          *
1769          * @return the type of this service
1770          */
1771         public final String getType() {
1772             return type;
1773         }
1774 
1775         /**
1776          * Return the name of the algorithm of this service. For example,
1777          * {@code SHA-1}.
1778          *
1779          * @return the algorithm of this service
1780          */
1781         public final String getAlgorithm() {
1782             return algorithm;
1783         }
1784 
1785         /**
1786          * Return the Provider of this service.
1787          *
1788          * @return the Provider of this service
1789          */
1790         public final Provider getProvider() {
1791             return provider;
1792         }
1793 
1794         /**
1795          * Return the name of the class implementing this service.
1796          *
1797          * @return the name of the class implementing this service
1798          */
1799         public final String getClassName() {
1800             return className;
1801         }
1802 
1803         // internal only
1804         private final List&lt;String&gt; getAliases() {
1805             return aliases;
1806         }
1807 
1808         /**
1809          * Return the value of the specified attribute or null if this
1810          * attribute is not set for this Service.
1811          *
1812          * @param name the name of the requested attribute
1813          *
1814          * @return the value of the specified attribute or null if the
1815          *         attribute is not present
1816          *
1817          * @throws NullPointerException if name is null
1818          */
1819         public final String getAttribute(String name) {
1820             if (name == null) {
1821                 throw new NullPointerException();
1822             }
1823             return attributes.get(new UString(name));
1824         }
1825 
1826         /**
1827          * Return a new instance of the implementation described by this
1828          * service. The security provider framework uses this method to
1829          * construct implementations. Applications will typically not need
1830          * to call it.
1831          *
1832          * &lt;p&gt;The default implementation uses reflection to invoke the
1833          * standard constructor for this type of service.
1834          * Security providers can override this method to implement
1835          * instantiation in a different way.
1836          * For details and the values of constructorParameter that are
1837          * valid for the various types of services see the
1838          * {@extLink security_guide_jca
1839          * Java Cryptography Architecture (JCA) Reference Guide}.
1840          *
1841          * @param constructorParameter the value to pass to the constructor,
1842          * or null if this type of service does not use a constructorParameter.
1843          *
1844          * @return a new implementation of this service
1845          *
1846          * @throws InvalidParameterException if the value of
1847          * constructorParameter is invalid for this type of service.
1848          * @throws NoSuchAlgorithmException if instantiation failed for
1849          * any other reason.
1850          */
1851         public Object newInstance(Object constructorParameter)
1852                 throws NoSuchAlgorithmException {
1853             if (registered == false) {
1854                 if (provider.getService(type, algorithm) != this) {
1855                     throw new NoSuchAlgorithmException
1856                         (&quot;Service not registered with Provider &quot;
1857                         + provider.getName() + &quot;: &quot; + this);
1858                 }
1859                 registered = true;
1860             }
1861             Class&lt;?&gt; ctrParamClz;
1862             try {
1863                 EngineDescription cap = knownEngines.get(type);
1864                 if (cap == null) {
1865                     // unknown engine type, use generic code
1866                     // this is the code path future for non-core
1867                     // optional packages
1868                     ctrParamClz = constructorParameter == null?
1869                         null : constructorParameter.getClass();
1870                 } else {
1871                     ctrParamClz = cap.constructorParameterClassName == null?
1872                         null : Class.forName(cap.constructorParameterClassName);
1873                     if (constructorParameter != null) {
1874                         if (ctrParamClz == null) {
1875                             throw new InvalidParameterException
1876                                 (&quot;constructorParameter not used with &quot; + type
1877                                 + &quot; engines&quot;);
1878                         } else {
1879                             Class&lt;?&gt; argClass = constructorParameter.getClass();
1880                             if (ctrParamClz.isAssignableFrom(argClass) == false) {
1881                                 throw new InvalidParameterException
1882                                     (&quot;constructorParameter must be instanceof &quot;
1883                                     + cap.constructorParameterClassName.replace(&#39;$&#39;, &#39;.&#39;)
1884                                     + &quot; for engine type &quot; + type);
1885                             }
1886                         }
1887                     }
1888                 }
1889                 // constructorParameter can be null if not provided
1890                 return newInstanceUtil(getImplClass(), ctrParamClz, constructorParameter);
1891             } catch (NoSuchAlgorithmException e) {
1892                 throw e;
1893             } catch (InvocationTargetException e) {
1894                 throw new NoSuchAlgorithmException
1895                     (&quot;Error constructing implementation (algorithm: &quot;
1896                     + algorithm + &quot;, provider: &quot; + provider.getName()
1897                     + &quot;, class: &quot; + className + &quot;)&quot;, e.getCause());
1898             } catch (Exception e) {
1899                 throw new NoSuchAlgorithmException
1900                     (&quot;Error constructing implementation (algorithm: &quot;
1901                     + algorithm + &quot;, provider: &quot; + provider.getName()
1902                     + &quot;, class: &quot; + className + &quot;)&quot;, e);
1903             }
1904         }
1905 
1906         // return the implementation Class object for this service
1907         private Class&lt;?&gt; getImplClass() throws NoSuchAlgorithmException {
1908             try {
1909                 Reference&lt;Class&lt;?&gt;&gt; ref = classRef;
1910                 Class&lt;?&gt; clazz = (ref == null) ? null : ref.get();
1911                 if (clazz == null) {
1912                     ClassLoader cl = provider.getClass().getClassLoader();
1913                     if (cl == null) {
1914                         clazz = Class.forName(className);
1915                     } else {
1916                         clazz = cl.loadClass(className);
1917                     }
1918                     if (!Modifier.isPublic(clazz.getModifiers())) {
1919                         throw new NoSuchAlgorithmException
1920                             (&quot;class configured for &quot; + type + &quot; (provider: &quot; +
1921                             provider.getName() + &quot;) is not public.&quot;);
1922                     }
1923                     classRef = new WeakReference&lt;&gt;(clazz);
1924                 }
1925                 return clazz;
1926             } catch (ClassNotFoundException e) {
1927                 throw new NoSuchAlgorithmException
1928                     (&quot;class configured for &quot; + type + &quot; (provider: &quot; +
1929                     provider.getName() + &quot;) cannot be found.&quot;, e);
1930             }
1931         }
1932 
1933         /**
1934          * Test whether this Service can use the specified parameter.
1935          * Returns false if this service cannot use the parameter. Returns
1936          * true if this service can use the parameter, if a fast test is
1937          * infeasible, or if the status is unknown.
1938          *
1939          * &lt;p&gt;The security provider framework uses this method with
1940          * some types of services to quickly exclude non-matching
1941          * implementations for consideration.
1942          * Applications will typically not need to call it.
1943          *
1944          * &lt;p&gt;For details and the values of parameter that are valid for the
1945          * various types of services see the top of this class and the
1946          * {@extLink security_guide_jca
1947          * Java Cryptography Architecture (JCA) Reference Guide}.
1948          * Security providers can override it to implement their own test.
1949          *
1950          * @param parameter the parameter to test
1951          *
1952          * @return false if this service cannot use the specified
1953          * parameter; true if it can possibly use the parameter
1954          *
1955          * @throws InvalidParameterException if the value of parameter is
1956          * invalid for this type of service or if this method cannot be
1957          * used with this type of service
1958          */
1959         public boolean supportsParameter(Object parameter) {
1960             EngineDescription cap = knownEngines.get(type);
1961             if (cap == null) {
1962                 // unknown engine type, return true by default
1963                 return true;
1964             }
1965             if (cap.supportsParameter == false) {
1966                 throw new InvalidParameterException(&quot;supportsParameter() not &quot;
1967                     + &quot;used with &quot; + type + &quot; engines&quot;);
1968             }
1969             // allow null for keys without attributes for compatibility
1970             if ((parameter != null) &amp;&amp; (parameter instanceof Key == false)) {
1971                 throw new InvalidParameterException
1972                     (&quot;Parameter must be instanceof Key for engine &quot; + type);
1973             }
1974             if (hasKeyAttributes() == false) {
1975                 return true;
1976             }
1977             if (parameter == null) {
1978                 return false;
1979             }
1980             Key key = (Key)parameter;
1981             if (supportsKeyFormat(key)) {
1982                 return true;
1983             }
1984             if (supportsKeyClass(key)) {
1985                 return true;
1986             }
1987             return false;
1988         }
1989 
1990         /**
1991          * Return whether this service has its supported properties for
1992          * keys defined. Parses the attributes if not yet initialized.
1993          */
1994         private boolean hasKeyAttributes() {
1995             Boolean b = hasKeyAttributes;
1996             if (b == null) {
1997                 synchronized (this) {
1998                     b = hasKeyAttributes;
1999                     if (b == null) {
2000                         String s;
2001                         s = getAttribute(&quot;SupportedKeyFormats&quot;);
2002                         if (s != null) {
2003                             supportedFormats = s.split(&quot;\\|&quot;);
2004                         }
2005                         s = getAttribute(&quot;SupportedKeyClasses&quot;);
2006                         if (s != null) {
2007                             String[] classNames = s.split(&quot;\\|&quot;);
2008                             List&lt;Class&lt;?&gt;&gt; classList =
2009                                 new ArrayList&lt;&gt;(classNames.length);
2010                             for (String className : classNames) {
2011                                 Class&lt;?&gt; clazz = getKeyClass(className);
2012                                 if (clazz != null) {
2013                                     classList.add(clazz);
2014                                 }
2015                             }
2016                             supportedClasses = classList.toArray(CLASS0);
2017                         }
2018                         boolean bool = (supportedFormats != null)
2019                             || (supportedClasses != null);
2020                         b = Boolean.valueOf(bool);
2021                         hasKeyAttributes = b;
2022                     }
2023                 }
2024             }
2025             return b.booleanValue();
2026         }
2027 
2028         // get the key class object of the specified name
2029         private Class&lt;?&gt; getKeyClass(String name) {
2030             try {
2031                 return Class.forName(name);
2032             } catch (ClassNotFoundException e) {
2033                 // ignore
2034             }
2035             try {
2036                 ClassLoader cl = provider.getClass().getClassLoader();
2037                 if (cl != null) {
2038                     return cl.loadClass(name);
2039                 }
2040             } catch (ClassNotFoundException e) {
2041                 // ignore
2042             }
2043             return null;
2044         }
2045 
2046         private boolean supportsKeyFormat(Key key) {
2047             if (supportedFormats == null) {
2048                 return false;
2049             }
2050             String format = key.getFormat();
2051             if (format == null) {
2052                 return false;
2053             }
2054             for (String supportedFormat : supportedFormats) {
2055                 if (supportedFormat.equals(format)) {
2056                     return true;
2057                 }
2058             }
2059             return false;
2060         }
2061 
2062         private boolean supportsKeyClass(Key key) {
2063             if (supportedClasses == null) {
2064                 return false;
2065             }
2066             Class&lt;?&gt; keyClass = key.getClass();
2067             for (Class&lt;?&gt; clazz : supportedClasses) {
2068                 if (clazz.isAssignableFrom(keyClass)) {
2069                     return true;
2070                 }
2071             }
2072             return false;
2073         }
2074 
2075         /**
2076          * Return a String representation of this service.
2077          *
2078          * @return a String representation of this service.
2079          */
2080         public String toString() {
2081             String aString = aliases.isEmpty()
2082                 ? &quot;&quot; : &quot;\r\n  aliases: &quot; + aliases.toString();
2083             String attrs = attributes.isEmpty()
2084                 ? &quot;&quot; : &quot;\r\n  attributes: &quot; + attributes.toString();
2085             return provider.getName() + &quot;: &quot; + type + &quot;.&quot; + algorithm
2086                 + &quot; -&gt; &quot; + className + aString + attrs + &quot;\r\n&quot;;
2087         }
2088     }
2089 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../hotspot/share/utilities/growableArray.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../net/NetworkInterface.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2597          * @return {@code targetClass} that has been initialized
2598          *
2599          * @throws  IllegalArgumentException if {@code targetClass} is a primitive type or {@code void}
2600          *          or array class
2601          * @throws  IllegalAccessException if {@code targetClass} is not
2602          *          {@linkplain #accessClass accessible} to this lookup
2603          * @throws  ExceptionInInitializerError if the class initialization provoked
2604          *          by this method fails
2605          * @throws  SecurityException if a security manager is present and it
2606          *          &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2607          * @since 15
2608          * @jvms 5.5 Initialization
2609          */
2610         public Class&lt;?&gt; ensureInitialized(Class&lt;?&gt; targetClass) throws IllegalAccessException {
2611             if (targetClass.isPrimitive())
2612                 throw new IllegalArgumentException(targetClass + &quot; is a primitive class&quot;);
2613             if (targetClass.isArray())
2614                 throw new IllegalArgumentException(targetClass + &quot; is an array class&quot;);
2615 
2616             if (!VerifyAccess.isClassAccessible(targetClass, lookupClass, prevLookupClass, allowedModes)) {
<span class="line-modified">2617                 throw new MemberName(targetClass).makeAccessException(&quot;access violation&quot;, this);</span>
2618             }
<span class="line-modified">2619             checkSecurityManager(targetClass, null);</span>
2620 
2621             // ensure class initialization
2622             Unsafe.getUnsafe().ensureClassInitialized(targetClass);
2623             return targetClass;
2624         }
2625 





















2626         /**
2627          * Determines if a class can be accessed from the lookup context defined by
2628          * this {@code Lookup} object. The static initializer of the class is not run.
2629          * &lt;p&gt;
2630          * If the {@code targetClass} is in the same module as the lookup class,
2631          * the lookup class is {@code LC} in module {@code M1} and
2632          * the previous lookup class is in module {@code M0} or
2633          * {@code null} if not present,
2634          * {@code targetClass} is accessible if and only if one of the following is true:
2635          * &lt;ul&gt;
2636          * &lt;li&gt;If this lookup has {@link #PRIVATE} access, {@code targetClass} is
2637          *     {@code LC} or other class in the same nest of {@code LC}.&lt;/li&gt;
2638          * &lt;li&gt;If this lookup has {@link #PACKAGE} access, {@code targetClass} is
2639          *     in the same runtime package of {@code LC}.&lt;/li&gt;
2640          * &lt;li&gt;If this lookup has {@link #MODULE} access, {@code targetClass} is
2641          *     a public type in {@code M1}.&lt;/li&gt;
2642          * &lt;li&gt;If this lookup has {@link #PUBLIC} access, {@code targetClass} is
2643          *     a public type in a package exported by {@code M1} to at least  {@code M0}
2644          *     if the previous lookup class is present; otherwise, {@code targetClass}
2645          *     is a public type in a package exported by {@code M1} unconditionally.&lt;/li&gt;
</pre>
<hr />
<pre>
2676          *     {@linkplain Module#reads reads} {@code M1} and the type is
2677          *     in a package that is exported to at least {@code M0}.
2678          * &lt;li&gt;{@code targetClass} is in a third module {@code M2} and both {@code M0}
2679          *     and {@code M1} reads {@code M2} and the type is in a package
2680          *     that is exported to at least both {@code M0} and {@code M2}.
2681          * &lt;/ul&gt;
2682          * &lt;p&gt;
2683          * Otherwise, {@code targetClass} is not accessible.
2684          *
2685          * @param targetClass the class to be access-checked
2686          * @return the class that has been access-checked
2687          * @throws IllegalAccessException if the class is not accessible from the lookup class
2688          * and previous lookup class, if present, using the allowed access modes.
2689          * @throws    SecurityException if a security manager is present and it
2690          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2691          * @since 9
2692          * @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
2693          */
2694         public Class&lt;?&gt; accessClass(Class&lt;?&gt; targetClass) throws IllegalAccessException {
2695             if (!VerifyAccess.isClassAccessible(targetClass, lookupClass, prevLookupClass, allowedModes)) {
<span class="line-modified">2696                 throw new MemberName(targetClass).makeAccessException(&quot;access violation&quot;, this);</span>
2697             }
<span class="line-modified">2698             checkSecurityManager(targetClass, null);</span>
2699             return targetClass;
2700         }
2701 
2702         /**
2703          * Produces an early-bound method handle for a virtual method.
2704          * It will bypass checks for overriding methods on the receiver,
2705          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if called&lt;/a&gt; from an {@code invokespecial}
2706          * instruction from within the explicitly specified {@code specialCaller}.
2707          * The type of the method handle will be that of the method,
2708          * with a suitably restricted receiver type prepended.
2709          * (The receiver type will be {@code specialCaller} or a subtype.)
2710          * The method and all its argument types must be accessible
2711          * to the lookup object.
2712          * &lt;p&gt;
2713          * Before method resolution,
2714          * if the explicitly specified caller class is not identical with the
2715          * lookup class, or if this lookup object does not have
2716          * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;
2717          * privileges, the access fails.
2718          * &lt;p&gt;
</pre>
<hr />
<pre>
3497         @Deprecated(since=&quot;14&quot;)
3498         public boolean hasPrivateAccess() {
3499             return hasFullPrivilegeAccess();
3500         }
3501 
3502         /**
3503          * Returns {@code true} if this lookup has &lt;em&gt;full privilege access&lt;/em&gt;,
3504          * i.e. {@code PRIVATE} and {@code MODULE} access.
3505          * A {@code Lookup} object must have full privilege access in order to
3506          * access all members that are allowed to the {@linkplain #lookupClass() lookup class}.
3507          *
3508          * @return {@code true} if this lookup has full privilege access.
3509          * @since 14
3510          * @see &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private and module access&lt;/a&gt;
3511          */
3512         public boolean hasFullPrivilegeAccess() {
3513             return (allowedModes &amp; (PRIVATE|MODULE)) == (PRIVATE|MODULE);
3514         }
3515 
3516         /**
<span class="line-modified">3517          * Perform necessary &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;access checks&lt;/a&gt;.</span>























3518          * Determines a trustable caller class to compare with refc, the symbolic reference class.
3519          * If this lookup object has full privilege access, then the caller class is the lookupClass.
3520          */
3521         void checkSecurityManager(Class&lt;?&gt; refc, MemberName m) {



3522             if (allowedModes == TRUSTED)  return;
3523 
3524             SecurityManager smgr = System.getSecurityManager();
3525             if (smgr == null)  return;
3526 
3527             // Step 1:
3528             boolean fullPowerLookup = hasFullPrivilegeAccess();
3529             if (!fullPowerLookup ||
3530                 !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {
3531                 ReflectUtil.checkPackageAccess(refc);
3532             }
3533 
<span class="line-removed">3534             if (m == null) {  // findClass or accessClass</span>
<span class="line-removed">3535                 // Step 2b:</span>
<span class="line-removed">3536                 if (!fullPowerLookup) {</span>
<span class="line-removed">3537                     smgr.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span>
<span class="line-removed">3538                 }</span>
<span class="line-removed">3539                 return;</span>
<span class="line-removed">3540             }</span>
<span class="line-removed">3541 </span>
3542             // Step 2a:
3543             if (m.isPublic()) return;
3544             if (!fullPowerLookup) {
3545                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3546             }
3547 
3548             // Step 3:
3549             Class&lt;?&gt; defc = m.getDeclaringClass();
3550             if (!fullPowerLookup &amp;&amp; defc != refc) {
3551                 ReflectUtil.checkPackageAccess(defc);
3552             }
3553         }
3554 
3555         void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3556             boolean wantStatic = (refKind == REF_invokeStatic);
3557             String message;
3558             if (m.isConstructor())
3559                 message = &quot;expected a method, not a constructor&quot;;
3560             else if (!m.isMethod())
3561                 message = &quot;expected a method&quot;;
</pre>
</td>
<td>
<hr />
<pre>
2597          * @return {@code targetClass} that has been initialized
2598          *
2599          * @throws  IllegalArgumentException if {@code targetClass} is a primitive type or {@code void}
2600          *          or array class
2601          * @throws  IllegalAccessException if {@code targetClass} is not
2602          *          {@linkplain #accessClass accessible} to this lookup
2603          * @throws  ExceptionInInitializerError if the class initialization provoked
2604          *          by this method fails
2605          * @throws  SecurityException if a security manager is present and it
2606          *          &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2607          * @since 15
2608          * @jvms 5.5 Initialization
2609          */
2610         public Class&lt;?&gt; ensureInitialized(Class&lt;?&gt; targetClass) throws IllegalAccessException {
2611             if (targetClass.isPrimitive())
2612                 throw new IllegalArgumentException(targetClass + &quot; is a primitive class&quot;);
2613             if (targetClass.isArray())
2614                 throw new IllegalArgumentException(targetClass + &quot; is an array class&quot;);
2615 
2616             if (!VerifyAccess.isClassAccessible(targetClass, lookupClass, prevLookupClass, allowedModes)) {
<span class="line-modified">2617                 throw makeAccessException(targetClass);</span>
2618             }
<span class="line-modified">2619             checkSecurityManager(targetClass);</span>
2620 
2621             // ensure class initialization
2622             Unsafe.getUnsafe().ensureClassInitialized(targetClass);
2623             return targetClass;
2624         }
2625 
<span class="line-added">2626         /*</span>
<span class="line-added">2627          * Returns IllegalAccessException due to access violation to the given targetClass.</span>
<span class="line-added">2628          *</span>
<span class="line-added">2629          * This method is called by {@link Lookup#accessClass} and {@link Lookup#ensureInitialized}</span>
<span class="line-added">2630          * which verifies access to a class rather a member.</span>
<span class="line-added">2631          */</span>
<span class="line-added">2632         private IllegalAccessException makeAccessException(Class&lt;?&gt; targetClass) {</span>
<span class="line-added">2633             String message = &quot;access violation: &quot;+ targetClass;</span>
<span class="line-added">2634             if (this == MethodHandles.publicLookup()) {</span>
<span class="line-added">2635                 message += &quot;, from public Lookup&quot;;</span>
<span class="line-added">2636             } else {</span>
<span class="line-added">2637                 Module m = lookupClass().getModule();</span>
<span class="line-added">2638                 message += &quot;, from &quot; + lookupClass() + &quot; (&quot; + m + &quot;)&quot;;</span>
<span class="line-added">2639                 if (prevLookupClass != null) {</span>
<span class="line-added">2640                     message += &quot;, previous lookup &quot; +</span>
<span class="line-added">2641                             prevLookupClass.getName() + &quot; (&quot; + prevLookupClass.getModule() + &quot;)&quot;;</span>
<span class="line-added">2642                 }</span>
<span class="line-added">2643             }</span>
<span class="line-added">2644             return new IllegalAccessException(message);</span>
<span class="line-added">2645         }</span>
<span class="line-added">2646 </span>
2647         /**
2648          * Determines if a class can be accessed from the lookup context defined by
2649          * this {@code Lookup} object. The static initializer of the class is not run.
2650          * &lt;p&gt;
2651          * If the {@code targetClass} is in the same module as the lookup class,
2652          * the lookup class is {@code LC} in module {@code M1} and
2653          * the previous lookup class is in module {@code M0} or
2654          * {@code null} if not present,
2655          * {@code targetClass} is accessible if and only if one of the following is true:
2656          * &lt;ul&gt;
2657          * &lt;li&gt;If this lookup has {@link #PRIVATE} access, {@code targetClass} is
2658          *     {@code LC} or other class in the same nest of {@code LC}.&lt;/li&gt;
2659          * &lt;li&gt;If this lookup has {@link #PACKAGE} access, {@code targetClass} is
2660          *     in the same runtime package of {@code LC}.&lt;/li&gt;
2661          * &lt;li&gt;If this lookup has {@link #MODULE} access, {@code targetClass} is
2662          *     a public type in {@code M1}.&lt;/li&gt;
2663          * &lt;li&gt;If this lookup has {@link #PUBLIC} access, {@code targetClass} is
2664          *     a public type in a package exported by {@code M1} to at least  {@code M0}
2665          *     if the previous lookup class is present; otherwise, {@code targetClass}
2666          *     is a public type in a package exported by {@code M1} unconditionally.&lt;/li&gt;
</pre>
<hr />
<pre>
2697          *     {@linkplain Module#reads reads} {@code M1} and the type is
2698          *     in a package that is exported to at least {@code M0}.
2699          * &lt;li&gt;{@code targetClass} is in a third module {@code M2} and both {@code M0}
2700          *     and {@code M1} reads {@code M2} and the type is in a package
2701          *     that is exported to at least both {@code M0} and {@code M2}.
2702          * &lt;/ul&gt;
2703          * &lt;p&gt;
2704          * Otherwise, {@code targetClass} is not accessible.
2705          *
2706          * @param targetClass the class to be access-checked
2707          * @return the class that has been access-checked
2708          * @throws IllegalAccessException if the class is not accessible from the lookup class
2709          * and previous lookup class, if present, using the allowed access modes.
2710          * @throws    SecurityException if a security manager is present and it
2711          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2712          * @since 9
2713          * @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
2714          */
2715         public Class&lt;?&gt; accessClass(Class&lt;?&gt; targetClass) throws IllegalAccessException {
2716             if (!VerifyAccess.isClassAccessible(targetClass, lookupClass, prevLookupClass, allowedModes)) {
<span class="line-modified">2717                 throw makeAccessException(targetClass);</span>
2718             }
<span class="line-modified">2719             checkSecurityManager(targetClass);</span>
2720             return targetClass;
2721         }
2722 
2723         /**
2724          * Produces an early-bound method handle for a virtual method.
2725          * It will bypass checks for overriding methods on the receiver,
2726          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if called&lt;/a&gt; from an {@code invokespecial}
2727          * instruction from within the explicitly specified {@code specialCaller}.
2728          * The type of the method handle will be that of the method,
2729          * with a suitably restricted receiver type prepended.
2730          * (The receiver type will be {@code specialCaller} or a subtype.)
2731          * The method and all its argument types must be accessible
2732          * to the lookup object.
2733          * &lt;p&gt;
2734          * Before method resolution,
2735          * if the explicitly specified caller class is not identical with the
2736          * lookup class, or if this lookup object does not have
2737          * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;
2738          * privileges, the access fails.
2739          * &lt;p&gt;
</pre>
<hr />
<pre>
3518         @Deprecated(since=&quot;14&quot;)
3519         public boolean hasPrivateAccess() {
3520             return hasFullPrivilegeAccess();
3521         }
3522 
3523         /**
3524          * Returns {@code true} if this lookup has &lt;em&gt;full privilege access&lt;/em&gt;,
3525          * i.e. {@code PRIVATE} and {@code MODULE} access.
3526          * A {@code Lookup} object must have full privilege access in order to
3527          * access all members that are allowed to the {@linkplain #lookupClass() lookup class}.
3528          *
3529          * @return {@code true} if this lookup has full privilege access.
3530          * @since 14
3531          * @see &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private and module access&lt;/a&gt;
3532          */
3533         public boolean hasFullPrivilegeAccess() {
3534             return (allowedModes &amp; (PRIVATE|MODULE)) == (PRIVATE|MODULE);
3535         }
3536 
3537         /**
<span class="line-modified">3538          * Perform steps 1 and 2b &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;access checks&lt;/a&gt;</span>
<span class="line-added">3539          * for ensureInitialzed, findClass or accessClass.</span>
<span class="line-added">3540          */</span>
<span class="line-added">3541         void checkSecurityManager(Class&lt;?&gt; refc) {</span>
<span class="line-added">3542             if (allowedModes == TRUSTED)  return;</span>
<span class="line-added">3543 </span>
<span class="line-added">3544             SecurityManager smgr = System.getSecurityManager();</span>
<span class="line-added">3545             if (smgr == null)  return;</span>
<span class="line-added">3546 </span>
<span class="line-added">3547             // Step 1:</span>
<span class="line-added">3548             boolean fullPowerLookup = hasFullPrivilegeAccess();</span>
<span class="line-added">3549             if (!fullPowerLookup ||</span>
<span class="line-added">3550                 !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {</span>
<span class="line-added">3551                 ReflectUtil.checkPackageAccess(refc);</span>
<span class="line-added">3552             }</span>
<span class="line-added">3553 </span>
<span class="line-added">3554             // Step 2b:</span>
<span class="line-added">3555             if (!fullPowerLookup) {</span>
<span class="line-added">3556                 smgr.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span>
<span class="line-added">3557             }</span>
<span class="line-added">3558         }</span>
<span class="line-added">3559 </span>
<span class="line-added">3560         /**</span>
<span class="line-added">3561          * Perform steps 1, 2a and 3 &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;access checks&lt;/a&gt;.</span>
3562          * Determines a trustable caller class to compare with refc, the symbolic reference class.
3563          * If this lookup object has full privilege access, then the caller class is the lookupClass.
3564          */
3565         void checkSecurityManager(Class&lt;?&gt; refc, MemberName m) {
<span class="line-added">3566             Objects.requireNonNull(refc);</span>
<span class="line-added">3567             Objects.requireNonNull(m);</span>
<span class="line-added">3568 </span>
3569             if (allowedModes == TRUSTED)  return;
3570 
3571             SecurityManager smgr = System.getSecurityManager();
3572             if (smgr == null)  return;
3573 
3574             // Step 1:
3575             boolean fullPowerLookup = hasFullPrivilegeAccess();
3576             if (!fullPowerLookup ||
3577                 !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {
3578                 ReflectUtil.checkPackageAccess(refc);
3579             }
3580 








3581             // Step 2a:
3582             if (m.isPublic()) return;
3583             if (!fullPowerLookup) {
3584                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3585             }
3586 
3587             // Step 3:
3588             Class&lt;?&gt; defc = m.getDeclaringClass();
3589             if (!fullPowerLookup &amp;&amp; defc != refc) {
3590                 ReflectUtil.checkPackageAccess(defc);
3591             }
3592         }
3593 
3594         void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3595             boolean wantStatic = (refKind == REF_invokeStatic);
3596             String message;
3597             if (m.isConstructor())
3598                 message = &quot;expected a method, not a constructor&quot;;
3599             else if (!m.isMethod())
3600                 message = &quot;expected a method&quot;;
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../hotspot/share/utilities/growableArray.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../net/NetworkInterface.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/security/Provider.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.security;
  27 
  28 import java.io.*;
  29 import java.util.*;
  30 import static java.util.Locale.ENGLISH;
  31 import java.lang.ref.*;
  32 import java.lang.reflect.*;
  33 import java.util.function.BiConsumer;
  34 import java.util.function.BiFunction;
  35 import java.util.function.Function;
  36 import java.util.concurrent.ConcurrentHashMap;
  37 
  38 /**
  39  * This class represents a &quot;provider&quot; for the
  40  * Java Security API, where a provider implements some or all parts of
  41  * Java Security. Services that a provider may implement include:
  42  *
  43  * &lt;ul&gt;
  44  *
  45  * &lt;li&gt;Algorithms (such as DSA, RSA, or SHA-256).
  46  *
  47  * &lt;li&gt;Key generation, conversion, and management facilities (such as for
  48  * algorithm-specific keys).
  49  *
  50  * &lt;/ul&gt;
  51  *
  52  * &lt;p&gt;Some provider implementations may encounter unrecoverable internal
  53  * errors during their operation, for example a failure to communicate with a
  54  * security token. A {@link ProviderException} should be used to indicate
  55  * such errors.
  56  *
  57  * &lt;p&gt;Please note that a provider can be used to implement any security
  58  * service in Java that uses a pluggable architecture with a choice
  59  * of implementations that fit underneath.
  60  *
  61  * &lt;p&gt;The service type {@code Provider} is reserved for use by the
  62  * security framework. Services of this type cannot be added, removed,
  63  * or modified by applications.
  64  * The following attributes are automatically placed in each Provider object:
  65  * &lt;table class=&quot;striped&quot;&gt;
  66  * &lt;caption&gt;&lt;b&gt;Attributes Automatically Placed in a Provider Object&lt;/b&gt;&lt;/caption&gt;
  67  * &lt;thead&gt;
  68  * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Name&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Value&lt;/th&gt;
  69  * &lt;/thead&gt;
  70  * &lt;tbody style=&quot;text-align:left&quot;&gt;
  71  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Provider.id name}&lt;/th&gt;
  72  *     &lt;td&gt;{@code String.valueOf(provider.getName())}&lt;/td&gt;
  73  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Provider.id version}&lt;/th&gt;
  74  *     &lt;td&gt;{@code String.valueOf(provider.getVersionStr())}&lt;/td&gt;
  75  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Provider.id info}&lt;/th&gt;
  76  *     &lt;td&gt;{@code String.valueOf(provider.getInfo())}&lt;/td&gt;
  77  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Provider.id className}&lt;/th&gt;
  78  *     &lt;td&gt;{@code provider.getClass().getName()}&lt;/td&gt;
  79  * &lt;/tbody&gt;
  80  * &lt;/table&gt;
  81  *
  82  * &lt;p&gt;Each provider has a name and a version string. A provider normally
  83  * identifies itself with a file named {@code java.security.Provider}
  84  * in the resource directory {@code META-INF/services}.
  85  * Security providers are looked up via the {@link ServiceLoader} mechanism
  86  * using the {@link ClassLoader#getSystemClassLoader application class loader}.
  87  *
  88  * &lt;p&gt;Providers may be configured such that they are automatically
  89  * installed and made available at runtime via the
  90  * {@link Security#getProviders() Security.getProviders()} method.
  91  * The mechanism for configuring and installing security providers is
  92  * implementation-specific.
  93  *
  94  * @implNote
  95  * The JDK implementation supports static registration of the security
  96  * providers via the {@code conf/security/java.security} file in the Java
  97  * installation directory. These providers are automatically installed by
  98  * the JDK runtime, see {@extLink security_guide_jca_provider
  99  * The Provider Class}
 100  * in the Java Cryptography Architecture (JCA) Reference Guide
 101  * for information about how a particular type of provider, the cryptographic
 102  * service provider, works and is installed.
 103  *
 104  * @author Benjamin Renaud
 105  * @author Andreas Sterbenz
 106  * @since 1.1
 107  */
 108 public abstract class Provider extends Properties {
 109 
 110     // Declare serialVersionUID to be compatible with JDK1.1
 111     @java.io.Serial
 112     private static final long serialVersionUID = -4298000515446427739L;
 113 
 114     private static final sun.security.util.Debug debug =
 115         sun.security.util.Debug.getInstance(&quot;provider&quot;, &quot;Provider&quot;);
 116 
 117     /**
 118      * The provider name.
 119      *
 120      * @serial
 121      */
 122     private String name;
 123 
 124     /**
 125      * A description of the provider and its services.
 126      *
 127      * @serial
 128      */
 129     private String info;
 130 
 131     /**
 132      * The provider version number.
 133      *
 134      * @serial
 135      */
 136     private double version;
 137 
 138     /**
 139      * The provider version string.
 140      *
 141      * @serial
 142      */
 143     private String versionStr;
 144 
 145     private transient Set&lt;Map.Entry&lt;Object,Object&gt;&gt; entrySet = null;
 146     private transient int entrySetCallCount = 0;
 147 
 148     private transient boolean initialized;
 149 
 150     private static Object newInstanceUtil(final Class&lt;?&gt; clazz,
 151         final Class&lt;?&gt; ctrParamClz, final Object ctorParamObj)
 152         throws Exception {
 153         if (ctrParamClz == null) {
 154             Constructor&lt;?&gt; con = clazz.getConstructor();
 155             return con.newInstance();
 156         } else {
 157             // Looking for the constructor with a params first and fallback
 158             // to one without if not found. This is to support the enhanced
 159             // SecureRandom where both styles of constructors are supported.
 160             // Before jdk9, there was no params support (only getInstance(alg))
 161             // and an impl only had the params-less constructor. Since jdk9,
 162             // there is getInstance(alg,params) and an impl can contain
 163             // an Impl(params) constructor.
 164             try {
 165                 Constructor&lt;?&gt; con = clazz.getConstructor(ctrParamClz);
 166                 return con.newInstance(ctorParamObj);
 167             } catch (NoSuchMethodException nsme) {
 168                 // For pre-jdk9 SecureRandom implementations, they only
 169                 // have params-less constructors which still works when
 170                 // the input ctorParamObj is null.
 171                 //
 172                 // For other primitives using params, ctorParamObj should not
 173                 // be null and nsme is thrown, just like before.
 174                 if (ctorParamObj == null) {
 175                     try {
 176                         Constructor&lt;?&gt; con = clazz.getConstructor();
 177                         return con.newInstance();
 178                     } catch (NoSuchMethodException nsme2) {
 179                         nsme.addSuppressed(nsme2);
 180                         throw nsme;
 181                     }
 182                 } else {
 183                     throw nsme;
 184                 }
 185             }
 186         }
 187     }
 188 
 189     private static double parseVersionStr(String s) {
 190         try {
 191             int firstDotIdx = s.indexOf(&#39;.&#39;);
 192             int nextDotIdx = s.indexOf(&#39;.&#39;, firstDotIdx + 1);
 193             if (nextDotIdx != -1) {
 194                 s = s.substring(0, nextDotIdx);
 195             }
 196             int endIdx = s.indexOf(&#39;-&#39;);
 197             if (endIdx &gt; 0) {
 198                 s = s.substring(0, endIdx);
 199             }
 200             endIdx = s.indexOf(&#39;+&#39;);
 201             if (endIdx &gt; 0) {
 202                 s = s.substring(0, endIdx);
 203             }
 204             return Double.parseDouble(s);
 205         } catch (NullPointerException | NumberFormatException e) {
 206             return 0d;
 207         }
 208     }
 209 
 210     /**
 211      * Constructs a provider with the specified name, version number,
 212      * and information. Calling this constructor is equivalent to call the
 213      * {@link #Provider(String, String, String)} with {@code name}
 214      * name, {@code Double.toString(version)}, and {@code info}.
 215      *
 216      * @param name the provider name.
 217      *
 218      * @param version the provider version number.
 219      *
 220      * @param info a description of the provider and its services.
 221      *
 222      * @deprecated use {@link #Provider(String, String, String)} instead.
 223      */
 224     @Deprecated(since=&quot;9&quot;)
 225     protected Provider(String name, double version, String info) {
 226         this.name = name;
 227         this.version = version;
 228         this.versionStr = Double.toString(version);
 229         this.info = info;
 230         this.serviceMap = new ConcurrentHashMap&lt;&gt;();
 231         putId();
 232         initialized = true;
 233     }
 234 
 235     /**
 236      * Constructs a provider with the specified name, version string,
 237      * and information.
 238      *
 239      * &lt;p&gt;The version string contains a version number optionally followed
 240      * by other information separated by one of the characters of &#39;+&#39;, &#39;-&#39;.
 241      *
 242      * The format for the version number is:
 243      *
 244      * &lt;blockquote&gt;&lt;pre&gt;
 245      *     ^[0-9]+(\.[0-9]+)*
 246      * &lt;/pre&gt;&lt;/blockquote&gt;
 247      *
 248      * &lt;p&gt;In order to return the version number in a double, when there are
 249      * more than two components (separated by &#39;.&#39; as defined above), only
 250      * the first two components are retained. The resulting string is then
 251      * passed to {@link Double#valueOf(String)} to generate version number,
 252      * i.e. {@link #getVersion}.
 253      * &lt;p&gt;If the conversion failed, value 0 will be used.
 254      *
 255      * @param name the provider name.
 256      *
 257      * @param versionStr the provider version string.
 258      *
 259      * @param info a description of the provider and its services.
 260      *
 261      * @since 9
 262      */
 263     protected Provider(String name, String versionStr, String info) {
 264         this.name = name;
 265         this.versionStr = versionStr;
 266         this.version = parseVersionStr(versionStr);
 267         this.info = info;
 268         this.serviceMap = new ConcurrentHashMap&lt;&gt;();
 269         putId();
 270         initialized = true;
 271     }
 272 
 273     /**
 274      * Apply the supplied configuration argument to this provider instance
 275      * and return the configured provider. Note that if this provider cannot
 276      * be configured in-place, a new provider will be created and returned.
 277      * Therefore, callers should always use the returned provider.
 278      *
 279      * @implSpec
 280      * The default implementation throws {@code UnsupportedOperationException}.
 281      * Subclasses should override this method only if a configuration argument
 282      * is supported.
 283      *
 284      * @param configArg the configuration information for configuring this
 285      *         provider.
 286      *
 287      * @throws UnsupportedOperationException if a configuration argument is
 288      *         not supported.
 289      * @throws NullPointerException if the supplied configuration argument is
 290      *         null.
 291      * @throws InvalidParameterException if the supplied configuration argument
 292      *         is invalid.
 293      * @return a provider configured with the supplied configuration argument.
 294      *
 295      * @since 9
 296      */
 297     public Provider configure(String configArg) {
 298         throw new UnsupportedOperationException(&quot;configure is not supported&quot;);
 299     }
 300 
 301     /**
 302      * Check if this provider instance has been configured.
 303      *
 304      * @implSpec
 305      * The default implementation returns true.
 306      * Subclasses should override this method if the provider instance requires
 307      * an explicit {@code configure} call after being constructed.
 308      *
 309      * @return true if no further configuration is needed, false otherwise.
 310      *
 311      * @since 9
 312      */
 313     public boolean isConfigured() {
 314         return true;
 315     }
 316 
 317 
 318     /**
 319      * Returns the name of this provider.
 320      *
 321      * @return the name of this provider.
 322      */
 323     public String getName() {
 324         return name;
 325     }
 326 
 327     /**
 328      * Returns the version number for this provider.
 329      *
 330      * @return the version number for this provider.
 331      *
 332      * @deprecated use {@link #getVersionStr} instead.
 333      */
 334     @Deprecated(since=&quot;9&quot;)
 335     public double getVersion() {
 336         return version;
 337     }
 338 
 339     /**
 340      * Returns the version string for this provider.
 341      *
 342      * @return the version string for this provider.
 343      *
 344      * @since 9
 345      */
 346     public String getVersionStr() {
 347         return versionStr;
 348     }
 349 
 350     /**
 351      * Returns a human-readable description of the provider and its
 352      * services.  This may return an HTML page, with relevant links.
 353      *
 354      * @return a description of the provider and its services.
 355      */
 356     public String getInfo() {
 357         return info;
 358     }
 359 
 360     /**
 361      * Returns a string with the name and the version string
 362      * of this provider.
 363      *
 364      * @return the string with the name and the version string
 365      * for this provider.
 366      */
 367     public String toString() {
 368         return name + &quot; version &quot; + versionStr;
 369     }
 370 
 371     /*
 372      * override the following methods to ensure that provider
 373      * information can only be changed if the caller has the appropriate
 374      * permissions.
 375      */
 376 
 377     /**
 378      * Clears this provider so that it no longer contains the properties
 379      * used to look up facilities implemented by the provider.
 380      *
 381      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 382      * method is called with the string {@code &quot;clearProviderProperties.&quot;+name}
 383      * (where {@code name} is the provider name) to see if it&#39;s ok to clear
 384      * this provider.
 385      *
 386      * @throws  SecurityException
 387      *          if a security manager exists and its {@link
 388      *          java.lang.SecurityManager#checkSecurityAccess} method
 389      *          denies access to clear this provider
 390      *
 391      * @since 1.2
 392      */
 393     @Override
 394     public synchronized void clear() {
 395         check(&quot;clearProviderProperties.&quot;+name);
 396         if (debug != null) {
 397             debug.println(&quot;Remove &quot; + name + &quot; provider properties&quot;);
 398         }
 399         implClear();
 400     }
 401 
 402     /**
 403      * Reads a property list (key and element pairs) from the input stream.
 404      *
 405      * @param inStream the input stream.
 406      * @throws    IOException if an error occurred when reading from the
 407      *               input stream.
 408      * @see java.util.Properties#load
 409      */
 410     @Override
 411     public synchronized void load(InputStream inStream) throws IOException {
 412         check(&quot;putProviderProperty.&quot;+name);
 413         if (debug != null) {
 414             debug.println(&quot;Load &quot; + name + &quot; provider properties&quot;);
 415         }
 416         Properties tempProperties = new Properties();
 417         tempProperties.load(inStream);
 418         implPutAll(tempProperties);
 419     }
 420 
 421     /**
 422      * Copies all of the mappings from the specified Map to this provider.
 423      * These mappings will replace any properties that this provider had
 424      * for any of the keys currently in the specified Map.
 425      *
 426      * @since 1.2
 427      */
 428     @Override
 429     public synchronized void putAll(Map&lt;?,?&gt; t) {
 430         check(&quot;putProviderProperty.&quot;+name);
 431         if (debug != null) {
 432             debug.println(&quot;Put all &quot; + name + &quot; provider properties&quot;);
 433         }
 434         implPutAll(t);
 435     }
 436 
 437     /**
 438      * Returns an unmodifiable Set view of the property entries contained
 439      * in this Provider.
 440      *
 441      * @see   java.util.Map.Entry
 442      * @since 1.2
 443      */
 444     @Override
 445     public synchronized Set&lt;Map.Entry&lt;Object,Object&gt;&gt; entrySet() {
 446         checkInitialized();
 447         if (entrySet == null) {
 448             if (entrySetCallCount++ == 0)  // Initial call
 449                 entrySet = Collections.unmodifiableMap(this).entrySet();
 450             else
 451                 return super.entrySet();   // Recursive call
 452         }
 453 
 454         // This exception will be thrown if the implementation of
 455         // Collections.unmodifiableMap.entrySet() is changed such that it
 456         // no longer calls entrySet() on the backing Map.  (Provider&#39;s
 457         // entrySet implementation depends on this &quot;implementation detail&quot;,
 458         // which is unlikely to change.
 459         if (entrySetCallCount != 2)
 460             throw new RuntimeException(&quot;Internal error.&quot;);
 461 
 462         return entrySet;
 463     }
 464 
 465     /**
 466      * Returns an unmodifiable Set view of the property keys contained in
 467      * this provider.
 468      *
 469      * @since 1.2
 470      */
 471     @Override
 472     public Set&lt;Object&gt; keySet() {
 473         checkInitialized();
 474         return Collections.unmodifiableSet(super.keySet());
 475     }
 476 
 477     /**
 478      * Returns an unmodifiable Collection view of the property values
 479      * contained in this provider.
 480      *
 481      * @since 1.2
 482      */
 483     @Override
 484     public Collection&lt;Object&gt; values() {
 485         checkInitialized();
 486         return Collections.unmodifiableCollection(super.values());
 487     }
 488 
 489     /**
 490      * Sets the {@code key} property to have the specified
 491      * {@code value}.
 492      *
 493      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 494      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 495      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 496      * provider&#39;s property values.
 497      *
 498      * @throws  SecurityException
 499      *          if a security manager exists and its {@link
 500      *          java.lang.SecurityManager#checkSecurityAccess} method
 501      *          denies access to set property values.
 502      *
 503      * @since 1.2
 504      */
 505     @Override
 506     public synchronized Object put(Object key, Object value) {
 507         check(&quot;putProviderProperty.&quot;+name);
 508         if (debug != null) {
 509             debug.println(&quot;Set &quot; + name + &quot; provider property [&quot; +
 510                           key + &quot;/&quot; + value +&quot;]&quot;);
 511         }
 512         return implPut(key, value);
 513     }
 514 
 515     /**
 516      * If the specified key is not already associated with a value (or is mapped
 517      * to {@code null}) associates it with the given value and returns
 518      * {@code null}, else returns the current value.
 519      *
 520      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 521      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 522      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 523      * provider&#39;s property values.
 524      *
 525      * @throws  SecurityException
 526      *          if a security manager exists and its {@link
 527      *          java.lang.SecurityManager#checkSecurityAccess} method
 528      *          denies access to set property values.
 529      *
 530      * @since 1.8
 531      */
 532     @Override
 533     public synchronized Object putIfAbsent(Object key, Object value) {
 534         check(&quot;putProviderProperty.&quot;+name);
 535         if (debug != null) {
 536             debug.println(&quot;Set &quot; + name + &quot; provider property [&quot; +
 537                           key + &quot;/&quot; + value +&quot;]&quot;);
 538         }
 539         return implPutIfAbsent(key, value);
 540     }
 541 
 542     /**
 543      * Removes the {@code key} property (and its corresponding
 544      * {@code value}).
 545      *
 546      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 547      * method is called with the string {@code &quot;removeProviderProperty.&quot;+name},
 548      * where {@code name} is the provider name, to see if it&#39;s ok to remove this
 549      * provider&#39;s properties.
 550      *
 551      * @throws  SecurityException
 552      *          if a security manager exists and its {@link
 553      *          java.lang.SecurityManager#checkSecurityAccess} method
 554      *          denies access to remove this provider&#39;s properties.
 555      *
 556      * @since 1.2
 557      */
 558     @Override
 559     public synchronized Object remove(Object key) {
 560         check(&quot;removeProviderProperty.&quot;+name);
 561         if (debug != null) {
 562             debug.println(&quot;Remove &quot; + name + &quot; provider property &quot; + key);
 563         }
 564         return implRemove(key);
 565     }
 566 
 567     /**
 568      * Removes the entry for the specified key only if it is currently
 569      * mapped to the specified value.
 570      *
 571      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 572      * method is called with the string {@code &quot;removeProviderProperty.&quot;+name},
 573      * where {@code name} is the provider name, to see if it&#39;s ok to remove this
 574      * provider&#39;s properties.
 575      *
 576      * @throws  SecurityException
 577      *          if a security manager exists and its {@link
 578      *          java.lang.SecurityManager#checkSecurityAccess} method
 579      *          denies access to remove this provider&#39;s properties.
 580      *
 581      * @since 1.8
 582      */
 583     @Override
 584     public synchronized boolean remove(Object key, Object value) {
 585         check(&quot;removeProviderProperty.&quot;+name);
 586         if (debug != null) {
 587             debug.println(&quot;Remove &quot; + name + &quot; provider property &quot; + key);
 588         }
 589         return implRemove(key, value);
 590     }
 591 
 592     /**
 593      * Replaces the entry for the specified key only if currently
 594      * mapped to the specified value.
 595      *
 596      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 597      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 598      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 599      * provider&#39;s property values.
 600      *
 601      * @throws  SecurityException
 602      *          if a security manager exists and its {@link
 603      *          java.lang.SecurityManager#checkSecurityAccess} method
 604      *          denies access to set property values.
 605      *
 606      * @since 1.8
 607      */
 608     @Override
 609     public synchronized boolean replace(Object key, Object oldValue,
 610             Object newValue) {
 611         check(&quot;putProviderProperty.&quot; + name);
 612 
 613         if (debug != null) {
 614             debug.println(&quot;Replace &quot; + name + &quot; provider property &quot; + key);
 615         }
 616         return implReplace(key, oldValue, newValue);
 617     }
 618 
 619     /**
 620      * Replaces the entry for the specified key only if it is
 621      * currently mapped to some value.
 622      *
 623      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 624      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 625      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 626      * provider&#39;s property values.
 627      *
 628      * @throws  SecurityException
 629      *          if a security manager exists and its {@link
 630      *          java.lang.SecurityManager#checkSecurityAccess} method
 631      *          denies access to set property values.
 632      *
 633      * @since 1.8
 634      */
 635     @Override
 636     public synchronized Object replace(Object key, Object value) {
 637         check(&quot;putProviderProperty.&quot; + name);
 638 
 639         if (debug != null) {
 640             debug.println(&quot;Replace &quot; + name + &quot; provider property &quot; + key);
 641         }
 642         return implReplace(key, value);
 643     }
 644 
 645     /**
 646      * Replaces each entry&#39;s value with the result of invoking the given
 647      * function on that entry, in the order entries are returned by an entry
 648      * set iterator, until all entries have been processed or the function
 649      * throws an exception.
 650      *
 651      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 652      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 653      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 654      * provider&#39;s property values.
 655      *
 656      * @throws  SecurityException
 657      *          if a security manager exists and its {@link
 658      *          java.lang.SecurityManager#checkSecurityAccess} method
 659      *          denies access to set property values.
 660      *
 661      * @since 1.8
 662      */
 663     @Override
 664     public synchronized void replaceAll(BiFunction&lt;? super Object,
 665             ? super Object, ? extends Object&gt; function) {
 666         check(&quot;putProviderProperty.&quot; + name);
 667 
 668         if (debug != null) {
 669             debug.println(&quot;ReplaceAll &quot; + name + &quot; provider property &quot;);
 670         }
 671         implReplaceAll(function);
 672     }
 673 
 674     /**
 675      * Attempts to compute a mapping for the specified key and its
 676      * current mapped value (or {@code null} if there is no current
 677      * mapping).
 678      *
 679      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 680      * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
 681      * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
 682      * provider name, to see if it&#39;s ok to set this provider&#39;s property values
 683      * and remove this provider&#39;s properties.
 684      *
 685      * @throws  SecurityException
 686      *          if a security manager exists and its {@link
 687      *          java.lang.SecurityManager#checkSecurityAccess} method
 688      *          denies access to set property values or remove properties.
 689      *
 690      * @since 1.8
 691      */
 692     @Override
 693     public synchronized Object compute(Object key, BiFunction&lt;? super Object,
 694             ? super Object, ? extends Object&gt; remappingFunction) {
 695         check(&quot;putProviderProperty.&quot; + name);
 696         check(&quot;removeProviderProperty.&quot; + name);
 697 
 698         if (debug != null) {
 699             debug.println(&quot;Compute &quot; + name + &quot; provider property &quot; + key);
 700         }
 701         return implCompute(key, remappingFunction);
 702     }
 703 
 704     /**
 705      * If the specified key is not already associated with a value (or
 706      * is mapped to {@code null}), attempts to compute its value using
 707      * the given mapping function and enters it into this map unless
 708      * {@code null}.
 709      *
 710      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 711      * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
 712      * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
 713      * provider name, to see if it&#39;s ok to set this provider&#39;s property values
 714      * and remove this provider&#39;s properties.
 715      *
 716      * @throws  SecurityException
 717      *          if a security manager exists and its {@link
 718      *          java.lang.SecurityManager#checkSecurityAccess} method
 719      *          denies access to set property values and remove properties.
 720      *
 721      * @since 1.8
 722      */
 723     @Override
 724     public synchronized Object computeIfAbsent(Object key, Function&lt;? super Object,
 725             ? extends Object&gt; mappingFunction) {
 726         check(&quot;putProviderProperty.&quot; + name);
 727         check(&quot;removeProviderProperty.&quot; + name);
 728 
 729         if (debug != null) {
 730             debug.println(&quot;ComputeIfAbsent &quot; + name + &quot; provider property &quot; +
 731                     key);
 732         }
 733         return implComputeIfAbsent(key, mappingFunction);
 734     }
 735 
 736     /**
 737      * If the value for the specified key is present and non-null, attempts to
 738      * compute a new mapping given the key and its current mapped value.
 739      *
 740      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 741      * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
 742      * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
 743      * provider name, to see if it&#39;s ok to set this provider&#39;s property values
 744      * and remove this provider&#39;s properties.
 745      *
 746      * @throws  SecurityException
 747      *          if a security manager exists and its {@link
 748      *          java.lang.SecurityManager#checkSecurityAccess} method
 749      *          denies access to set property values or remove properties.
 750      *
 751      * @since 1.8
 752      */
 753     @Override
 754     public synchronized Object computeIfPresent(Object key, BiFunction&lt;? super Object,
 755             ? super Object, ? extends Object&gt; remappingFunction) {
 756         check(&quot;putProviderProperty.&quot; + name);
 757         check(&quot;removeProviderProperty.&quot; + name);
 758 
 759         if (debug != null) {
 760             debug.println(&quot;ComputeIfPresent &quot; + name + &quot; provider property &quot; +
 761                     key);
 762         }
 763         return implComputeIfPresent(key, remappingFunction);
 764     }
 765 
 766     /**
 767      * If the specified key is not already associated with a value or is
 768      * associated with null, associates it with the given value. Otherwise,
 769      * replaces the value with the results of the given remapping function,
 770      * or removes if the result is null. This method may be of use when
 771      * combining multiple mapped values for a key.
 772      *
 773      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 774      * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
 775      * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
 776      * provider name, to see if it&#39;s ok to set this provider&#39;s property values
 777      * and remove this provider&#39;s properties.
 778      *
 779      * @throws  SecurityException
 780      *          if a security manager exists and its {@link
 781      *          java.lang.SecurityManager#checkSecurityAccess} method
 782      *          denies access to set property values or remove properties.
 783      *
 784      * @since 1.8
 785      */
 786     @Override
 787     public synchronized Object merge(Object key, Object value,  BiFunction&lt;? super Object,
 788             ? super Object, ? extends Object&gt;  remappingFunction) {
 789         check(&quot;putProviderProperty.&quot; + name);
 790         check(&quot;removeProviderProperty.&quot; + name);
 791 
 792         if (debug != null) {
 793             debug.println(&quot;Merge &quot; + name + &quot; provider property &quot; + key);
 794         }
 795         return implMerge(key, value, remappingFunction);
 796     }
 797 
 798     // let javadoc show doc from superclass
 799     @Override
 800     public Object get(Object key) {
 801         checkInitialized();
 802         return super.get(key);
 803     }
 804     /**
 805      * @since 1.8
 806      */
 807     @Override
 808     public synchronized Object getOrDefault(Object key, Object defaultValue) {
 809         checkInitialized();
 810         return super.getOrDefault(key, defaultValue);
 811     }
 812 
 813     /**
 814      * @since 1.8
 815      */
 816     @Override
 817     public synchronized void forEach(BiConsumer&lt;? super Object, ? super Object&gt; action) {
 818         checkInitialized();
 819         super.forEach(action);
 820     }
 821 
 822     // let javadoc show doc from superclass
 823     @Override
 824     public Enumeration&lt;Object&gt; keys() {
 825         checkInitialized();
 826         return super.keys();
 827     }
 828 
 829     // let javadoc show doc from superclass
 830     @Override
 831     public Enumeration&lt;Object&gt; elements() {
 832         checkInitialized();
 833         return super.elements();
 834     }
 835 
 836     // let javadoc show doc from superclass
 837     public String getProperty(String key) {
 838         checkInitialized();
 839         return super.getProperty(key);
 840     }
 841 
 842     private void checkInitialized() {
 843         if (!initialized) {
 844             throw new IllegalStateException();
 845         }
 846     }
 847 
 848     private void check(String directive) {
 849         checkInitialized();
 850         SecurityManager security = System.getSecurityManager();
 851         if (security != null) {
 852             security.checkSecurityAccess(directive);
 853         }
 854     }
 855 
 856     // legacy properties changed since last call to any services method?
 857     private transient boolean legacyChanged;
 858     // serviceMap changed since last call to getServices()
 859     private volatile transient boolean servicesChanged;
 860 
 861     // Map&lt;String,String&gt; used to keep track of legacy registration
 862     private transient Map&lt;String,String&gt; legacyStrings;
 863 
 864     // Map&lt;ServiceKey,Service&gt;
 865     // used for services added via putService(), initialized on demand
 866     private transient Map&lt;ServiceKey,Service&gt; serviceMap;
 867 
 868     // For backward compatibility, the registration ordering of
 869     // SecureRandom (RNG) algorithms needs to be preserved for
 870     // &quot;new SecureRandom()&quot; calls when this provider is used
 871     private transient Set&lt;String&gt; prngAlgos;
 872 
 873     // Map&lt;ServiceKey,Service&gt;
 874     // used for services added via legacy methods, init on demand
 875     private transient Map&lt;ServiceKey,Service&gt; legacyMap;
 876 
 877     // Set&lt;Service&gt;
 878     // Unmodifiable set of all services. Initialized on demand.
 879     private transient Set&lt;Service&gt; serviceSet;
 880 
 881     // register the id attributes for this provider
 882     // this is to ensure that equals() and hashCode() do not incorrectly
 883     // report to different provider objects as the same
 884     private void putId() {
 885         // note: name and info may be null
 886         super.put(&quot;Provider.id name&quot;, String.valueOf(name));
 887         super.put(&quot;Provider.id version&quot;, String.valueOf(versionStr));
 888         super.put(&quot;Provider.id info&quot;, String.valueOf(info));
 889         super.put(&quot;Provider.id className&quot;, this.getClass().getName());
 890     }
 891 
 892    /**
 893     * Reads the {@code ObjectInputStream} for the default serializable fields.
 894     * If the serialized field {@code versionStr} is found in the STREAM FIELDS,
 895     * its String value will be used to populate both the version string and
 896     * version number. If {@code versionStr} is not found, but {@code version}
 897     * is, then its double value will be used to populate both fields.
 898     *
 899     * @param in the {@code ObjectInputStream} to read
 900     * @serial
 901     */
 902     @java.io.Serial
 903     private void readObject(ObjectInputStream in)
 904                 throws IOException, ClassNotFoundException {
 905         Map&lt;Object,Object&gt; copy = new HashMap&lt;&gt;();
 906         for (Map.Entry&lt;Object,Object&gt; entry : super.entrySet()) {
 907             copy.put(entry.getKey(), entry.getValue());
 908         }
 909         defaults = null;
 910         in.defaultReadObject();
 911         if (this.versionStr == null) {
 912             // set versionStr based on version when not found in serialized bytes
 913             this.versionStr = Double.toString(this.version);
 914         } else {
 915             // otherwise, set version based on versionStr
 916             this.version = parseVersionStr(this.versionStr);
 917         }
 918         this.serviceMap = new ConcurrentHashMap&lt;&gt;();
 919         implClear();
 920         initialized = true;
 921         putAll(copy);
 922     }
 923 
 924     // check whether to update &#39;legacyString&#39; with the specified key
 925     private boolean checkLegacy(Object key) {
 926         String keyString = (String)key;
 927         if (keyString.startsWith(&quot;Provider.&quot;)) {
 928             return false;
 929         }
 930 
 931         legacyChanged = true;
 932         if (legacyStrings == null) {
 933             legacyStrings = new LinkedHashMap&lt;&gt;();
 934         }
 935         return true;
 936     }
 937 
 938     /**
 939      * Copies all of the mappings from the specified Map to this provider.
 940      * Internal method to be called AFTER the security check has been
 941      * performed.
 942      */
 943     private void implPutAll(Map&lt;?,?&gt; t) {
 944         for (Map.Entry&lt;?,?&gt; e : t.entrySet()) {
 945             implPut(e.getKey(), e.getValue());
 946         }
 947     }
 948 
 949     private Object implRemove(Object key) {
 950         if (key instanceof String) {
 951             if (!checkLegacy(key)) {
 952                 return null;
 953             }
 954             legacyStrings.remove((String)key);
 955         }
 956         return super.remove(key);
 957     }
 958 
 959     private boolean implRemove(Object key, Object value) {
 960         if (key instanceof String &amp;&amp; value instanceof String) {
 961             if (!checkLegacy(key)) {
 962                 return false;
 963             }
 964             legacyStrings.remove((String)key, (String)value);
 965         }
 966         return super.remove(key, value);
 967     }
 968 
 969     private boolean implReplace(Object key, Object oldValue, Object newValue) {
 970         if ((key instanceof String) &amp;&amp; (oldValue instanceof String) &amp;&amp;
 971                 (newValue instanceof String)) {
 972             if (!checkLegacy(key)) {
 973                 return false;
 974             }
 975             legacyStrings.replace((String)key, (String)oldValue,
 976                     (String)newValue);
 977         }
 978         return super.replace(key, oldValue, newValue);
 979     }
 980 
 981     private Object implReplace(Object key, Object value) {
 982         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
 983             if (!checkLegacy(key)) {
 984                 return null;
 985             }
 986             legacyStrings.replace((String)key, (String)value);
 987         }
 988         return super.replace(key, value);
 989     }
 990 
 991     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
 992     private void implReplaceAll(BiFunction&lt;? super Object, ? super Object,
 993             ? extends Object&gt; function) {
 994         legacyChanged = true;
 995         if (legacyStrings == null) {
 996             legacyStrings = new LinkedHashMap&lt;&gt;();
 997         } else {
 998             legacyStrings.replaceAll((BiFunction&lt;? super String, ? super String,
 999                     ? extends String&gt;) function);
1000         }
1001         super.replaceAll(function);
1002     }
1003 
1004     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1005     private Object implMerge(Object key, Object value,
1006             BiFunction&lt;? super Object, ? super Object, ? extends Object&gt;
1007             remappingFunction) {
1008         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
1009             if (!checkLegacy(key)) {
1010                 return null;
1011             }
1012             legacyStrings.merge((String)key, (String)value,
1013                     (BiFunction&lt;? super String, ? super String,
1014                     ? extends String&gt;) remappingFunction);
1015         }
1016         return super.merge(key, value, remappingFunction);
1017     }
1018 
1019     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1020     private Object implCompute(Object key, BiFunction&lt;? super Object,
1021             ? super Object, ? extends Object&gt; remappingFunction) {
1022         if (key instanceof String) {
1023             if (!checkLegacy(key)) {
1024                 return null;
1025             }
1026             legacyStrings.compute((String) key,
1027                     (BiFunction&lt;? super String,? super String,
1028                     ? extends String&gt;) remappingFunction);
1029         }
1030         return super.compute(key, remappingFunction);
1031     }
1032 
1033     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1034     private Object implComputeIfAbsent(Object key, Function&lt;? super Object,
1035             ? extends Object&gt; mappingFunction) {
1036         if (key instanceof String) {
1037             if (!checkLegacy(key)) {
1038                 return null;
1039             }
1040             legacyStrings.computeIfAbsent((String) key,
1041                     (Function&lt;? super String, ? extends String&gt;)
1042                     mappingFunction);
1043         }
1044         return super.computeIfAbsent(key, mappingFunction);
1045     }
1046 
1047     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1048     private Object implComputeIfPresent(Object key, BiFunction&lt;? super Object,
1049             ? super Object, ? extends Object&gt; remappingFunction) {
1050         if (key instanceof String) {
1051             if (!checkLegacy(key)) {
1052                 return null;
1053             }
1054             legacyStrings.computeIfPresent((String) key,
1055                     (BiFunction&lt;? super String, ? super String,
1056                     ? extends String&gt;) remappingFunction);
1057         }
1058         return super.computeIfPresent(key, remappingFunction);
1059     }
1060 
1061     private Object implPut(Object key, Object value) {
1062         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
1063             if (!checkLegacy(key)) {
1064                 return null;
1065             }
1066             legacyStrings.put((String)key, (String)value);
1067         }
1068         return super.put(key, value);
1069     }
1070 
1071     private Object implPutIfAbsent(Object key, Object value) {
1072         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
1073             if (!checkLegacy(key)) {
1074                 return null;
1075             }
1076             legacyStrings.putIfAbsent((String)key, (String)value);
1077         }
1078         return super.putIfAbsent(key, value);
1079     }
1080 
1081     private void implClear() {
1082         if (legacyStrings != null) {
1083             legacyStrings.clear();
1084         }
1085         if (legacyMap != null) {
1086             legacyMap.clear();
1087         }
1088         serviceMap.clear();
1089         legacyChanged = false;
1090         servicesChanged = false;
1091         serviceSet = null;
1092         prngAlgos = null;
1093         super.clear();
1094         putId();
1095     }
1096 
1097     // used as key in the serviceMap and legacyMap HashMaps
1098     private static class ServiceKey {
1099         private final String type;
1100         private final String algorithm;
1101         private final String originalAlgorithm;
1102         private ServiceKey(String type, String algorithm, boolean intern) {
1103             this.type = type;
1104             this.originalAlgorithm = algorithm;
1105             algorithm = algorithm.toUpperCase(ENGLISH);
1106             this.algorithm = intern ? algorithm.intern() : algorithm;
1107         }
1108         public int hashCode() {
1109             return Objects.hash(type, algorithm);
1110         }
1111         public boolean equals(Object obj) {
1112             if (this == obj) {
1113                 return true;
1114             }
1115             if (!(obj instanceof ServiceKey)) {
1116                 return false;
1117             }
1118             ServiceKey other = (ServiceKey)obj;
1119             return this.type.equals(other.type)
1120                 &amp;&amp; this.algorithm.equals(other.algorithm);
1121         }
1122         boolean matches(String type, String algorithm) {
1123             return (this.type == type) &amp;&amp; (this.originalAlgorithm == algorithm);
1124         }
1125     }
1126 
1127     /**
1128      * Ensure all the legacy String properties are fully parsed into
1129      * service objects.
1130      */
1131     private void ensureLegacyParsed() {
1132         if (legacyChanged == false || (legacyStrings == null)) {
1133             return;
1134         }
1135         serviceSet = null;
1136         if (legacyMap == null) {
1137             legacyMap = new ConcurrentHashMap&lt;&gt;();
1138         } else {
1139             legacyMap.clear();
1140         }
1141         for (Map.Entry&lt;String,String&gt; entry : legacyStrings.entrySet()) {
1142             parseLegacyPut(entry.getKey(), entry.getValue());
1143         }
1144         removeInvalidServices(legacyMap);
1145         legacyChanged = false;
1146     }
1147 
1148     /**
1149      * Remove all invalid services from the Map. Invalid services can only
1150      * occur if the legacy properties are inconsistent or incomplete.
1151      */
1152     private void removeInvalidServices(Map&lt;ServiceKey,Service&gt; map) {
1153         for (Iterator&lt;Map.Entry&lt;ServiceKey, Service&gt;&gt; t =
1154                 map.entrySet().iterator(); t.hasNext(); ) {
1155             Service s = t.next().getValue();
1156             if (s.isValid() == false) {
1157                 t.remove();
1158             }
1159         }
1160     }
1161 
1162     private static String[] getTypeAndAlgorithm(String key) {
1163         int i = key.indexOf(&#39;.&#39;);
1164         if (i &lt; 1) {
1165             if (debug != null) {
1166                 debug.println(&quot;Ignoring invalid entry in provider: &quot;
1167                         + key);
1168             }
1169             return null;
1170         }
1171         String type = key.substring(0, i);
1172         String alg = key.substring(i + 1);
1173         return new String[] {type, alg};
1174     }
1175 
1176     private static final String ALIAS_PREFIX = &quot;Alg.Alias.&quot;;
1177     private static final String ALIAS_PREFIX_LOWER = &quot;alg.alias.&quot;;
1178     private static final int ALIAS_LENGTH = ALIAS_PREFIX.length();
1179 
1180     private void parseLegacyPut(String name, String value) {
1181         if (name.toLowerCase(ENGLISH).startsWith(ALIAS_PREFIX_LOWER)) {
1182             // e.g. put(&quot;Alg.Alias.MessageDigest.SHA&quot;, &quot;SHA-1&quot;);
1183             // aliasKey ~ MessageDigest.SHA
1184             String stdAlg = value;
1185             String aliasKey = name.substring(ALIAS_LENGTH);
1186             String[] typeAndAlg = getTypeAndAlgorithm(aliasKey);
1187             if (typeAndAlg == null) {
1188                 return;
1189             }
1190             String type = getEngineName(typeAndAlg[0]);
1191             String aliasAlg = typeAndAlg[1].intern();
1192             ServiceKey key = new ServiceKey(type, stdAlg, true);
1193             Service s = legacyMap.get(key);
1194             if (s == null) {
1195                 s = new Service(this);
1196                 s.type = type;
1197                 s.algorithm = stdAlg;
1198                 legacyMap.put(key, s);
1199             }
1200             legacyMap.put(new ServiceKey(type, aliasAlg, true), s);
1201             s.addAlias(aliasAlg);
1202         } else {
1203             String[] typeAndAlg = getTypeAndAlgorithm(name);
1204             if (typeAndAlg == null) {
1205                 return;
1206             }
1207             int i = typeAndAlg[1].indexOf(&#39; &#39;);
1208             if (i == -1) {
1209                 // e.g. put(&quot;MessageDigest.SHA-1&quot;, &quot;sun.security.provider.SHA&quot;);
1210                 String type = getEngineName(typeAndAlg[0]);
1211                 String stdAlg = typeAndAlg[1].intern();
1212                 String className = value;
1213                 ServiceKey key = new ServiceKey(type, stdAlg, true);
1214                 Service s = legacyMap.get(key);
1215                 if (s == null) {
1216                     s = new Service(this);
1217                     s.type = type;
1218                     s.algorithm = stdAlg;
1219                     legacyMap.put(key, s);
1220                 }
1221                 s.className = className;
1222 
1223                 if (type.equals(&quot;SecureRandom&quot;)) {
1224                     updateSecureRandomEntries(true, s.algorithm);
1225                 }
1226             } else { // attribute
1227                 // e.g. put(&quot;MessageDigest.SHA-1 ImplementedIn&quot;, &quot;Software&quot;);
1228                 String attributeValue = value;
1229                 String type = getEngineName(typeAndAlg[0]);
1230                 String attributeString = typeAndAlg[1];
1231                 String stdAlg = attributeString.substring(0, i).intern();
1232                 String attributeName = attributeString.substring(i + 1);
1233                 // kill additional spaces
1234                 while (attributeName.startsWith(&quot; &quot;)) {
1235                     attributeName = attributeName.substring(1);
1236                 }
1237                 attributeName = attributeName.intern();
1238                 ServiceKey key = new ServiceKey(type, stdAlg, true);
1239                 Service s = legacyMap.get(key);
1240                 if (s == null) {
1241                     s = new Service(this);
1242                     s.type = type;
1243                     s.algorithm = stdAlg;
1244                     legacyMap.put(key, s);
1245                 }
1246                 s.addAttribute(attributeName, attributeValue);
1247             }
1248         }
1249     }
1250 
1251     /**
1252      * Get the service describing this Provider&#39;s implementation of the
1253      * specified type of this algorithm or alias. If no such
1254      * implementation exists, this method returns null. If there are two
1255      * matching services, one added to this provider using
1256      * {@link #putService putService()} and one added via {@link #put put()},
1257      * the service added via {@link #putService putService()} is returned.
1258      *
1259      * @param type the type of {@link Service service} requested
1260      * (for example, {@code MessageDigest})
1261      * @param algorithm the case insensitive algorithm name (or alternate
1262      * alias) of the service requested (for example, {@code SHA-1})
1263      *
1264      * @return the service describing this Provider&#39;s matching service
1265      * or null if no such service exists
1266      *
1267      * @throws NullPointerException if type or algorithm is null
1268      *
1269      * @since 1.5
1270      */
1271     public Service getService(String type, String algorithm) {
1272         checkInitialized();
1273 
1274         // avoid allocating a new ServiceKey object if possible
1275         ServiceKey key = previousKey;
1276         if (key.matches(type, algorithm) == false) {
1277             key = new ServiceKey(type, algorithm, false);
1278             previousKey = key;
1279         }
1280         if (!serviceMap.isEmpty()) {
1281             Service s = serviceMap.get(key);
1282             if (s != null) {
1283                 return s;
1284             }
1285         }
1286         synchronized (this) {
1287             ensureLegacyParsed();
1288             if (legacyMap != null &amp;&amp; !legacyMap.isEmpty()) {
1289                 return legacyMap.get(key);
1290             }
1291         }
1292         return null;
1293     }
1294 
1295     // ServiceKey from previous getService() call
1296     // by re-using it if possible we avoid allocating a new object
1297     // and the toUpperCase() call.
1298     // re-use will occur e.g. as the framework traverses the provider
1299     // list and queries each provider with the same values until it finds
1300     // a matching service
1301     private static volatile ServiceKey previousKey =
1302                                             new ServiceKey(&quot;&quot;, &quot;&quot;, false);
1303 
1304     /**
1305      * Get an unmodifiable Set of all services supported by
1306      * this Provider.
1307      *
1308      * @return an unmodifiable Set of all services supported by
1309      * this Provider
1310      *
1311      * @since 1.5
1312      */
1313     public synchronized Set&lt;Service&gt; getServices() {
1314         checkInitialized();
1315         if (legacyChanged || servicesChanged) {
1316             serviceSet = null;
1317         }
1318         if (serviceSet == null) {
1319             ensureLegacyParsed();
1320             Set&lt;Service&gt; set = new LinkedHashSet&lt;&gt;();
1321             if (!serviceMap.isEmpty()) {
1322                 set.addAll(serviceMap.values());
1323             }
1324             if (legacyMap != null &amp;&amp; !legacyMap.isEmpty()) {
1325                 set.addAll(legacyMap.values());
1326             }
1327             serviceSet = Collections.unmodifiableSet(set);
1328             servicesChanged = false;
1329         }
1330         return serviceSet;
1331     }
1332 
1333     /**
1334      * Add a service. If a service of the same type with the same algorithm
1335      * name exists and it was added using {@link #putService putService()},
1336      * it is replaced by the new service.
1337      * This method also places information about this service
1338      * in the provider&#39;s Hashtable values in the format described in the
1339      * {@extLink security_guide_jca
1340      * Java Cryptography Architecture (JCA) Reference Guide}.
1341      *
1342      * &lt;p&gt;Also, if there is a security manager, its
1343      * {@code checkSecurityAccess} method is called with the string
1344      * {@code &quot;putProviderProperty.&quot;+name}, where {@code name} is
1345      * the provider name, to see if it&#39;s ok to set this provider&#39;s property
1346      * values. If the default implementation of {@code checkSecurityAccess}
1347      * is used (that is, that method is not overridden), then this results in
1348      * a call to the security manager&#39;s {@code checkPermission} method with
1349      * a {@code SecurityPermission(&quot;putProviderProperty.&quot;+name)}
1350      * permission.
1351      *
1352      * @param s the Service to add
1353      *
1354      * @throws SecurityException
1355      *      if a security manager exists and its {@link
1356      *      java.lang.SecurityManager#checkSecurityAccess} method denies
1357      *      access to set property values.
1358      * @throws NullPointerException if s is null
1359      *
1360      * @since 1.5
1361      */
1362     protected void putService(Service s) {
1363         check(&quot;putProviderProperty.&quot; + name);
1364         if (debug != null) {
1365             debug.println(name + &quot;.putService(): &quot; + s);
1366         }
1367         if (s == null) {
1368             throw new NullPointerException();
1369         }
1370         if (s.getProvider() != this) {
1371             throw new IllegalArgumentException
1372                     (&quot;service.getProvider() must match this Provider object&quot;);
1373         }
1374         String type = s.getType();
1375         String algorithm = s.getAlgorithm();
1376         ServiceKey key = new ServiceKey(type, algorithm, true);
1377         implRemoveService(serviceMap.get(key));
1378         serviceMap.put(key, s);
1379         for (String alias : s.getAliases()) {
1380             serviceMap.put(new ServiceKey(type, alias, true), s);
1381         }
1382         servicesChanged = true;
1383         synchronized (this) {
1384             putPropertyStrings(s);
1385             if (type.equals(&quot;SecureRandom&quot;)) {
1386                 updateSecureRandomEntries(true, s.algorithm);
1387             }
1388         }
1389     }
1390 
1391     // keep tracks of the registered secure random algos and store them in order
1392     private void updateSecureRandomEntries(boolean doAdd, String s) {
1393         Objects.requireNonNull(s);
1394         if (doAdd) {
1395             if (prngAlgos == null) {
1396                 prngAlgos = new LinkedHashSet&lt;String&gt;();
1397             }
1398             prngAlgos.add(s);
1399         } else {
1400             prngAlgos.remove(s);
1401         }
1402 
1403         if (debug != null) {
1404             debug.println((doAdd? &quot;Add&quot;:&quot;Remove&quot;) + &quot; SecureRandom algo &quot; + s);
1405         }
1406     }
1407 
1408     // used by new SecureRandom() to find out the default SecureRandom
1409     // service for this provider
1410     synchronized Service getDefaultSecureRandomService() {
1411         checkInitialized();
1412 
1413         if (legacyChanged) {
1414             prngAlgos = null;
1415             ensureLegacyParsed();
1416         }
1417 
1418         if (prngAlgos != null &amp;&amp; !prngAlgos.isEmpty()) {
1419             // IMPORTANT: use the Service obj returned by getService(...) call
1420             // as providers may override putService(...)/getService(...) and
1421             // return their own Service objects
1422             return getService(&quot;SecureRandom&quot;, prngAlgos.iterator().next());
1423         }
1424 
1425         return null;
1426     }
1427 
1428     /**
1429      * Put the string properties for this Service in this Provider&#39;s
1430      * Hashtable.
1431      */
1432     private void putPropertyStrings(Service s) {
1433         String type = s.getType();
1434         String algorithm = s.getAlgorithm();
1435         // use super() to avoid permission check and other processing
1436         super.put(type + &quot;.&quot; + algorithm, s.getClassName());
1437         for (String alias : s.getAliases()) {
1438             super.put(ALIAS_PREFIX + type + &quot;.&quot; + alias, algorithm);
1439         }
1440         for (Map.Entry&lt;UString,String&gt; entry : s.attributes.entrySet()) {
1441             String key = type + &quot;.&quot; + algorithm + &quot; &quot; + entry.getKey();
1442             super.put(key, entry.getValue());
1443         }
1444     }
1445 
1446     /**
1447      * Remove the string properties for this Service from this Provider&#39;s
1448      * Hashtable.
1449      */
1450     private void removePropertyStrings(Service s) {
1451         String type = s.getType();
1452         String algorithm = s.getAlgorithm();
1453         // use super() to avoid permission check and other processing
1454         super.remove(type + &quot;.&quot; + algorithm);
1455         for (String alias : s.getAliases()) {
1456             super.remove(ALIAS_PREFIX + type + &quot;.&quot; + alias);
1457         }
1458         for (Map.Entry&lt;UString,String&gt; entry : s.attributes.entrySet()) {
1459             String key = type + &quot;.&quot; + algorithm + &quot; &quot; + entry.getKey();
1460             super.remove(key);
1461         }
1462     }
1463 
1464     /**
1465      * Remove a service previously added using
1466      * {@link #putService putService()}. The specified service is removed from
1467      * this provider. It will no longer be returned by
1468      * {@link #getService getService()} and its information will be removed
1469      * from this provider&#39;s Hashtable.
1470      *
1471      * &lt;p&gt;Also, if there is a security manager, its
1472      * {@code checkSecurityAccess} method is called with the string
1473      * {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is
1474      * the provider name, to see if it&#39;s ok to remove this provider&#39;s
1475      * properties. If the default implementation of
1476      * {@code checkSecurityAccess} is used (that is, that method is not
1477      * overridden), then this results in a call to the security manager&#39;s
1478      * {@code checkPermission} method with a
1479      * {@code SecurityPermission(&quot;removeProviderProperty.&quot;+name)}
1480      * permission.
1481      *
1482      * @param s the Service to be removed
1483      *
1484      * @throws  SecurityException
1485      *          if a security manager exists and its {@link
1486      *          java.lang.SecurityManager#checkSecurityAccess} method denies
1487      *          access to remove this provider&#39;s properties.
1488      * @throws NullPointerException if s is null
1489      *
1490      * @since 1.5
1491      */
1492     protected void removeService(Service s) {
1493         check(&quot;removeProviderProperty.&quot; + name);
1494         if (debug != null) {
1495             debug.println(name + &quot;.removeService(): &quot; + s);
1496         }
1497         if (s == null) {
1498             throw new NullPointerException();
1499         }
1500         implRemoveService(s);
1501     }
1502 
1503     private void implRemoveService(Service s) {
1504         if ((s == null) || serviceMap.isEmpty()) {
1505             return;
1506         }
1507         String type = s.getType();
1508         String algorithm = s.getAlgorithm();
1509         ServiceKey key = new ServiceKey(type, algorithm, false);
1510         Service oldService = serviceMap.get(key);
1511         if (s != oldService) {
1512             return;
1513         }
1514         servicesChanged = true;
1515         serviceMap.remove(key);
1516         for (String alias : s.getAliases()) {
1517             serviceMap.remove(new ServiceKey(type, alias, false));
1518         }
1519         synchronized (this) {
1520             removePropertyStrings(s);
1521             if (type.equals(&quot;SecureRandom&quot;)) {
1522                 updateSecureRandomEntries(false, s.algorithm);
1523             }
1524         }
1525     }
1526 
1527     // Wrapped String that behaves in a case insensitive way for equals/hashCode
1528     private static class UString {
1529         final String string;
1530         final String lowerString;
1531 
1532         UString(String s) {
1533             this.string = s;
1534             this.lowerString = s.toLowerCase(ENGLISH);
1535         }
1536 
1537         public int hashCode() {
1538             return lowerString.hashCode();
1539         }
1540 
1541         public boolean equals(Object obj) {
1542             if (this == obj) {
1543                 return true;
1544             }
1545             if (obj instanceof UString == false) {
1546                 return false;
1547             }
1548             UString other = (UString)obj;
1549             return lowerString.equals(other.lowerString);
1550         }
1551 
1552         public String toString() {
1553             return string;
1554         }
1555     }
1556 
1557     // describe relevant properties of a type of engine
1558     private static class EngineDescription {
1559         final String name;
1560         final boolean supportsParameter;
1561         final String constructorParameterClassName;
1562         private volatile Class&lt;?&gt; constructorParameterClass;
1563 
1564         EngineDescription(String name, boolean sp, String paramName) {
1565             this.name = name;
1566             this.supportsParameter = sp;
1567             this.constructorParameterClassName = paramName;
1568         }
1569         Class&lt;?&gt; getConstructorParameterClass() throws ClassNotFoundException {
1570             Class&lt;?&gt; clazz = constructorParameterClass;
1571             if (clazz == null) {
1572                 clazz = Class.forName(constructorParameterClassName);
1573                 constructorParameterClass = clazz;
1574             }
1575             return clazz;
1576         }
1577     }
1578 
1579     // built in knowledge of the engine types shipped as part of the JDK
1580     private static final Map&lt;String,EngineDescription&gt; knownEngines;
1581 
1582     private static void addEngine(String name, boolean sp, String paramName) {
1583         EngineDescription ed = new EngineDescription(name, sp, paramName);
1584         // also index by canonical name to avoid toLowerCase() for some lookups
1585         knownEngines.put(name.toLowerCase(ENGLISH), ed);
1586         knownEngines.put(name, ed);
1587     }
1588 
1589     static {
1590         knownEngines = new HashMap&lt;&gt;();
1591         // JCA
1592         addEngine(&quot;AlgorithmParameterGenerator&quot;,        false, null);
1593         addEngine(&quot;AlgorithmParameters&quot;,                false, null);
1594         addEngine(&quot;KeyFactory&quot;,                         false, null);
1595         addEngine(&quot;KeyPairGenerator&quot;,                   false, null);
1596         addEngine(&quot;KeyStore&quot;,                           false, null);
1597         addEngine(&quot;MessageDigest&quot;,                      false, null);
1598         addEngine(&quot;SecureRandom&quot;,                       false,
1599                 &quot;java.security.SecureRandomParameters&quot;);
1600         addEngine(&quot;Signature&quot;,                          true,  null);
1601         addEngine(&quot;CertificateFactory&quot;,                 false, null);
1602         addEngine(&quot;CertPathBuilder&quot;,                    false, null);
1603         addEngine(&quot;CertPathValidator&quot;,                  false, null);
1604         addEngine(&quot;CertStore&quot;,                          false,
1605                             &quot;java.security.cert.CertStoreParameters&quot;);
1606         // JCE
1607         addEngine(&quot;Cipher&quot;,                             true,  null);
1608         addEngine(&quot;ExemptionMechanism&quot;,                 false, null);
1609         addEngine(&quot;Mac&quot;,                                true,  null);
1610         addEngine(&quot;KeyAgreement&quot;,                       true,  null);
1611         addEngine(&quot;KeyGenerator&quot;,                       false, null);
1612         addEngine(&quot;SecretKeyFactory&quot;,                   false, null);
1613         // JSSE
1614         addEngine(&quot;KeyManagerFactory&quot;,                  false, null);
1615         addEngine(&quot;SSLContext&quot;,                         false, null);
1616         addEngine(&quot;TrustManagerFactory&quot;,                false, null);
1617         // JGSS
1618         addEngine(&quot;GssApiMechanism&quot;,                    false, null);
1619         // SASL
1620         addEngine(&quot;SaslClientFactory&quot;,                  false, null);
1621         addEngine(&quot;SaslServerFactory&quot;,                  false, null);
1622         // POLICY
1623         addEngine(&quot;Policy&quot;,                             false,
1624                             &quot;java.security.Policy$Parameters&quot;);
1625         // CONFIGURATION
1626         addEngine(&quot;Configuration&quot;,                      false,
1627                             &quot;javax.security.auth.login.Configuration$Parameters&quot;);
1628         // XML DSig
1629         addEngine(&quot;XMLSignatureFactory&quot;,                false, null);
1630         addEngine(&quot;KeyInfoFactory&quot;,                     false, null);
1631         addEngine(&quot;TransformService&quot;,                   false, null);
1632         // Smart Card I/O
1633         addEngine(&quot;TerminalFactory&quot;,                    false,
1634                             &quot;java.lang.Object&quot;);
1635     }
1636 
1637     // get the &quot;standard&quot; (mixed-case) engine name for arbitary case engine name
1638     // if there is no known engine by that name, return s
1639     private static String getEngineName(String s) {
1640         // try original case first, usually correct
1641         EngineDescription e = knownEngines.get(s);
1642         if (e == null) {
1643             e = knownEngines.get(s.toLowerCase(ENGLISH));
1644         }
1645         return (e == null) ? s : e.name;
1646     }
1647 
1648     /**
1649      * The description of a security service. It encapsulates the properties
1650      * of a service and contains a factory method to obtain new implementation
1651      * instances of this service.
1652      *
1653      * &lt;p&gt;Each service has a provider that offers the service, a type,
1654      * an algorithm name, and the name of the class that implements the
1655      * service. Optionally, it also includes a list of alternate algorithm
1656      * names for this service (aliases) and attributes, which are a map of
1657      * (name, value) String pairs.
1658      *
1659      * &lt;p&gt;This class defines the methods {@link #supportsParameter
1660      * supportsParameter()} and {@link #newInstance newInstance()}
1661      * which are used by the Java security framework when it searches for
1662      * suitable services and instantiates them. The valid arguments to those
1663      * methods depend on the type of service. For the service types defined
1664      * within Java SE, see the
1665      * {@extLink security_guide_jca
1666      * Java Cryptography Architecture (JCA) Reference Guide}
1667      * for the valid values.
1668      * Note that components outside of Java SE can define additional types of
1669      * services and their behavior.
1670      *
1671      * &lt;p&gt;Instances of this class are immutable.
1672      *
1673      * @since 1.5
1674      */
1675     public static class Service {
1676 
1677         private String type, algorithm, className;
1678         private final Provider provider;
1679         private List&lt;String&gt; aliases;
1680         private Map&lt;UString,String&gt; attributes;
1681 
1682         // Reference to the cached implementation Class object
1683         private volatile Reference&lt;Class&lt;?&gt;&gt; classRef;
1684 
1685         // flag indicating whether this service has its attributes for
1686         // supportedKeyFormats or supportedKeyClasses set
1687         // if null, the values have not been initialized
1688         // if TRUE, at least one of supportedFormats/Classes is non null
1689         private volatile Boolean hasKeyAttributes;
1690 
1691         // supported encoding formats
1692         private String[] supportedFormats;
1693 
1694         // names of the supported key (super) classes
1695         private Class&lt;?&gt;[] supportedClasses;
1696 
1697         // whether this service has been registered with the Provider
1698         private boolean registered;
1699 
1700         private static final Class&lt;?&gt;[] CLASS0 = new Class&lt;?&gt;[0];
1701 
1702         // this constructor and these methods are used for parsing
1703         // the legacy string properties.
1704 
1705         private Service(Provider provider) {
1706             this.provider = provider;
1707             aliases = Collections.&lt;String&gt;emptyList();
1708             attributes = Collections.&lt;UString,String&gt;emptyMap();
1709         }
1710 
1711         private boolean isValid() {
1712             return (type != null) &amp;&amp; (algorithm != null) &amp;&amp; (className != null);
1713         }
1714 
1715         private void addAlias(String alias) {
1716             if (aliases.isEmpty()) {
1717                 aliases = new ArrayList&lt;&gt;(2);
1718             }
1719             aliases.add(alias);
1720         }
1721 
1722         void addAttribute(String type, String value) {
1723             if (attributes.isEmpty()) {
1724                 attributes = new HashMap&lt;&gt;(8);
1725             }
1726             attributes.put(new UString(type), value);
1727         }
1728 
1729         /**
1730          * Construct a new service.
1731          *
1732          * @param provider the provider that offers this service
1733          * @param type the type of this service
1734          * @param algorithm the algorithm name
1735          * @param className the name of the class implementing this service
1736          * @param aliases List of aliases or null if algorithm has no aliases
1737          * @param attributes Map of attributes or null if this implementation
1738          *                   has no attributes
1739          *
1740          * @throws NullPointerException if provider, type, algorithm, or
1741          * className is null
1742          */
1743         public Service(Provider provider, String type, String algorithm,
1744                 String className, List&lt;String&gt; aliases,
1745                 Map&lt;String,String&gt; attributes) {
1746             if ((provider == null) || (type == null) ||
1747                     (algorithm == null) || (className == null)) {
1748                 throw new NullPointerException();
1749             }
1750             this.provider = provider;
1751             this.type = getEngineName(type);
1752             this.algorithm = algorithm;
1753             this.className = className;
1754             if (aliases == null) {
1755                 this.aliases = Collections.&lt;String&gt;emptyList();
1756             } else {
1757                 this.aliases = new ArrayList&lt;&gt;(aliases);
1758             }
1759             if (attributes == null) {
1760                 this.attributes = Collections.&lt;UString,String&gt;emptyMap();
1761             } else {
1762                 this.attributes = new HashMap&lt;&gt;();
1763                 for (Map.Entry&lt;String,String&gt; entry : attributes.entrySet()) {
1764                     this.attributes.put(new UString(entry.getKey()), entry.getValue());
1765                 }
1766             }
1767         }
1768 
1769         /**
1770          * Get the type of this service. For example, {@code MessageDigest}.
1771          *
1772          * @return the type of this service
1773          */
1774         public final String getType() {
1775             return type;
1776         }
1777 
1778         /**
1779          * Return the name of the algorithm of this service. For example,
1780          * {@code SHA-1}.
1781          *
1782          * @return the algorithm of this service
1783          */
1784         public final String getAlgorithm() {
1785             return algorithm;
1786         }
1787 
1788         /**
1789          * Return the Provider of this service.
1790          *
1791          * @return the Provider of this service
1792          */
1793         public final Provider getProvider() {
1794             return provider;
1795         }
1796 
1797         /**
1798          * Return the name of the class implementing this service.
1799          *
1800          * @return the name of the class implementing this service
1801          */
1802         public final String getClassName() {
1803             return className;
1804         }
1805 
1806         // internal only
1807         private final List&lt;String&gt; getAliases() {
1808             return aliases;
1809         }
1810 
1811         /**
1812          * Return the value of the specified attribute or null if this
1813          * attribute is not set for this Service.
1814          *
1815          * @param name the name of the requested attribute
1816          *
1817          * @return the value of the specified attribute or null if the
1818          *         attribute is not present
1819          *
1820          * @throws NullPointerException if name is null
1821          */
1822         public final String getAttribute(String name) {
1823             if (name == null) {
1824                 throw new NullPointerException();
1825             }
1826             return attributes.get(new UString(name));
1827         }
1828 
1829         /**
1830          * Return a new instance of the implementation described by this
1831          * service. The security provider framework uses this method to
1832          * construct implementations. Applications will typically not need
1833          * to call it.
1834          *
1835          * &lt;p&gt;The default implementation uses reflection to invoke the
1836          * standard constructor for this type of service.
1837          * Security providers can override this method to implement
1838          * instantiation in a different way.
1839          * For details and the values of constructorParameter that are
1840          * valid for the various types of services see the
1841          * {@extLink security_guide_jca
1842          * Java Cryptography Architecture (JCA) Reference Guide}.
1843          *
1844          * @param constructorParameter the value to pass to the constructor,
1845          * or null if this type of service does not use a constructorParameter.
1846          *
1847          * @return a new implementation of this service
1848          *
1849          * @throws InvalidParameterException if the value of
1850          * constructorParameter is invalid for this type of service.
1851          * @throws NoSuchAlgorithmException if instantiation failed for
1852          * any other reason.
1853          */
1854         public Object newInstance(Object constructorParameter)
1855                 throws NoSuchAlgorithmException {
1856             if (registered == false) {
1857                 if (provider.getService(type, algorithm) != this) {
1858                     throw new NoSuchAlgorithmException
1859                         (&quot;Service not registered with Provider &quot;
1860                         + provider.getName() + &quot;: &quot; + this);
1861                 }
1862                 registered = true;
1863             }
1864             Class&lt;?&gt; ctrParamClz;
1865             try {
1866                 EngineDescription cap = knownEngines.get(type);
1867                 if (cap == null) {
1868                     // unknown engine type, use generic code
1869                     // this is the code path future for non-core
1870                     // optional packages
1871                     ctrParamClz = constructorParameter == null?
1872                         null : constructorParameter.getClass();
1873                 } else {
1874                     ctrParamClz = cap.constructorParameterClassName == null?
1875                         null : Class.forName(cap.constructorParameterClassName);
1876                     if (constructorParameter != null) {
1877                         if (ctrParamClz == null) {
1878                             throw new InvalidParameterException
1879                                 (&quot;constructorParameter not used with &quot; + type
1880                                 + &quot; engines&quot;);
1881                         } else {
1882                             Class&lt;?&gt; argClass = constructorParameter.getClass();
1883                             if (ctrParamClz.isAssignableFrom(argClass) == false) {
1884                                 throw new InvalidParameterException
1885                                     (&quot;constructorParameter must be instanceof &quot;
1886                                     + cap.constructorParameterClassName.replace(&#39;$&#39;, &#39;.&#39;)
1887                                     + &quot; for engine type &quot; + type);
1888                             }
1889                         }
1890                     }
1891                 }
1892                 // constructorParameter can be null if not provided
1893                 return newInstanceUtil(getImplClass(), ctrParamClz, constructorParameter);
1894             } catch (NoSuchAlgorithmException e) {
1895                 throw e;
1896             } catch (InvocationTargetException e) {
1897                 throw new NoSuchAlgorithmException
1898                     (&quot;Error constructing implementation (algorithm: &quot;
1899                     + algorithm + &quot;, provider: &quot; + provider.getName()
1900                     + &quot;, class: &quot; + className + &quot;)&quot;, e.getCause());
1901             } catch (Exception e) {
1902                 throw new NoSuchAlgorithmException
1903                     (&quot;Error constructing implementation (algorithm: &quot;
1904                     + algorithm + &quot;, provider: &quot; + provider.getName()
1905                     + &quot;, class: &quot; + className + &quot;)&quot;, e);
1906             }
1907         }
1908 
1909         // return the implementation Class object for this service
1910         private Class&lt;?&gt; getImplClass() throws NoSuchAlgorithmException {
1911             try {
1912                 Reference&lt;Class&lt;?&gt;&gt; ref = classRef;
1913                 Class&lt;?&gt; clazz = (ref == null) ? null : ref.get();
1914                 if (clazz == null) {
1915                     ClassLoader cl = provider.getClass().getClassLoader();
1916                     if (cl == null) {
1917                         clazz = Class.forName(className);
1918                     } else {
1919                         clazz = cl.loadClass(className);
1920                     }
1921                     if (!Modifier.isPublic(clazz.getModifiers())) {
1922                         throw new NoSuchAlgorithmException
1923                             (&quot;class configured for &quot; + type + &quot; (provider: &quot; +
1924                             provider.getName() + &quot;) is not public.&quot;);
1925                     }
1926                     classRef = new WeakReference&lt;&gt;(clazz);
1927                 }
1928                 return clazz;
1929             } catch (ClassNotFoundException e) {
1930                 throw new NoSuchAlgorithmException
1931                     (&quot;class configured for &quot; + type + &quot; (provider: &quot; +
1932                     provider.getName() + &quot;) cannot be found.&quot;, e);
1933             }
1934         }
1935 
1936         /**
1937          * Test whether this Service can use the specified parameter.
1938          * Returns false if this service cannot use the parameter. Returns
1939          * true if this service can use the parameter, if a fast test is
1940          * infeasible, or if the status is unknown.
1941          *
1942          * &lt;p&gt;The security provider framework uses this method with
1943          * some types of services to quickly exclude non-matching
1944          * implementations for consideration.
1945          * Applications will typically not need to call it.
1946          *
1947          * &lt;p&gt;For details and the values of parameter that are valid for the
1948          * various types of services see the top of this class and the
1949          * {@extLink security_guide_jca
1950          * Java Cryptography Architecture (JCA) Reference Guide}.
1951          * Security providers can override it to implement their own test.
1952          *
1953          * @param parameter the parameter to test
1954          *
1955          * @return false if this service cannot use the specified
1956          * parameter; true if it can possibly use the parameter
1957          *
1958          * @throws InvalidParameterException if the value of parameter is
1959          * invalid for this type of service or if this method cannot be
1960          * used with this type of service
1961          */
1962         public boolean supportsParameter(Object parameter) {
1963             EngineDescription cap = knownEngines.get(type);
1964             if (cap == null) {
1965                 // unknown engine type, return true by default
1966                 return true;
1967             }
1968             if (cap.supportsParameter == false) {
1969                 throw new InvalidParameterException(&quot;supportsParameter() not &quot;
1970                     + &quot;used with &quot; + type + &quot; engines&quot;);
1971             }
1972             // allow null for keys without attributes for compatibility
1973             if ((parameter != null) &amp;&amp; (parameter instanceof Key == false)) {
1974                 throw new InvalidParameterException
1975                     (&quot;Parameter must be instanceof Key for engine &quot; + type);
1976             }
1977             if (hasKeyAttributes() == false) {
1978                 return true;
1979             }
1980             if (parameter == null) {
1981                 return false;
1982             }
1983             Key key = (Key)parameter;
1984             if (supportsKeyFormat(key)) {
1985                 return true;
1986             }
1987             if (supportsKeyClass(key)) {
1988                 return true;
1989             }
1990             return false;
1991         }
1992 
1993         /**
1994          * Return whether this service has its supported properties for
1995          * keys defined. Parses the attributes if not yet initialized.
1996          */
1997         private boolean hasKeyAttributes() {
1998             Boolean b = hasKeyAttributes;
1999             if (b == null) {
2000                 synchronized (this) {
2001                     b = hasKeyAttributes;
2002                     if (b == null) {
2003                         String s;
2004                         s = getAttribute(&quot;SupportedKeyFormats&quot;);
2005                         if (s != null) {
2006                             supportedFormats = s.split(&quot;\\|&quot;);
2007                         }
2008                         s = getAttribute(&quot;SupportedKeyClasses&quot;);
2009                         if (s != null) {
2010                             String[] classNames = s.split(&quot;\\|&quot;);
2011                             List&lt;Class&lt;?&gt;&gt; classList =
2012                                 new ArrayList&lt;&gt;(classNames.length);
2013                             for (String className : classNames) {
2014                                 Class&lt;?&gt; clazz = getKeyClass(className);
2015                                 if (clazz != null) {
2016                                     classList.add(clazz);
2017                                 }
2018                             }
2019                             supportedClasses = classList.toArray(CLASS0);
2020                         }
2021                         boolean bool = (supportedFormats != null)
2022                             || (supportedClasses != null);
2023                         b = Boolean.valueOf(bool);
2024                         hasKeyAttributes = b;
2025                     }
2026                 }
2027             }
2028             return b.booleanValue();
2029         }
2030 
2031         // get the key class object of the specified name
2032         private Class&lt;?&gt; getKeyClass(String name) {
2033             try {
2034                 return Class.forName(name);
2035             } catch (ClassNotFoundException e) {
2036                 // ignore
2037             }
2038             try {
2039                 ClassLoader cl = provider.getClass().getClassLoader();
2040                 if (cl != null) {
2041                     return cl.loadClass(name);
2042                 }
2043             } catch (ClassNotFoundException e) {
2044                 // ignore
2045             }
2046             return null;
2047         }
2048 
2049         private boolean supportsKeyFormat(Key key) {
2050             if (supportedFormats == null) {
2051                 return false;
2052             }
2053             String format = key.getFormat();
2054             if (format == null) {
2055                 return false;
2056             }
2057             for (String supportedFormat : supportedFormats) {
2058                 if (supportedFormat.equals(format)) {
2059                     return true;
2060                 }
2061             }
2062             return false;
2063         }
2064 
2065         private boolean supportsKeyClass(Key key) {
2066             if (supportedClasses == null) {
2067                 return false;
2068             }
2069             Class&lt;?&gt; keyClass = key.getClass();
2070             for (Class&lt;?&gt; clazz : supportedClasses) {
2071                 if (clazz.isAssignableFrom(keyClass)) {
2072                     return true;
2073                 }
2074             }
2075             return false;
2076         }
2077 
2078         /**
2079          * Return a String representation of this service.
2080          *
2081          * @return a String representation of this service.
2082          */
2083         public String toString() {
2084             String aString = aliases.isEmpty()
2085                 ? &quot;&quot; : &quot;\r\n  aliases: &quot; + aliases.toString();
2086             String attrs = attributes.isEmpty()
2087                 ? &quot;&quot; : &quot;\r\n  attributes: &quot; + attributes.toString();
2088             return provider.getName() + &quot;: &quot; + type + &quot;.&quot; + algorithm
2089                 + &quot; -&gt; &quot; + className + aString + attrs + &quot;\r\n&quot;;
2090         }
2091     }
2092 }
    </pre>
  </body>
</html>
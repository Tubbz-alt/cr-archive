<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/growableArray.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../services/virtualMemoryTracker.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/lang/invoke/MethodHandles.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/growableArray.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
206       if (_data[i] == elem) return i;
207     }
208     return -1;
209   }
210 
211   int  find(void* token, bool f(void*, E)) const {
212     for (int i = 0; i &lt; _len; i++) {
213       if (f(token, _data[i])) return i;
214     }
215     return -1;
216   }
217 
218   int  find_from_end(void* token, bool f(void*, E)) const {
219     // start at the end of the array
220     for (int i = _len-1; i &gt;= 0; i--) {
221       if (f(token, _data[i])) return i;
222     }
223     return -1;
224   }
225 


226   void remove(const E&amp; elem) {








227     for (int i = 0; i &lt; _len; i++) {
228       if (_data[i] == elem) {
<span class="line-modified">229         for (int j = i + 1; j &lt; _len; j++) _data[j-1] = _data[j];</span>
<span class="line-modified">230         _len--;</span>
<span class="line-removed">231         return;</span>
232       }
233     }
<span class="line-modified">234     ShouldNotReachHere();</span>
235   }
236 
<span class="line-removed">237   // The order is preserved.</span>
238   void remove_at(int index) {
239     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
<span class="line-modified">240     for (int j = index + 1; j &lt; _len; j++) _data[j-1] = _data[j];</span>


241     _len--;
242   }
243 
244   // The order is changed.
245   void delete_at(int index) {
246     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
247     if (index &lt; --_len) {
248       // Replace removed element with last one.
249       _data[index] = _data[_len];
250     }
251   }
252 
253   void sort(int f(E*, E*)) {
254     qsort(_data, length(), sizeof(E), (_sort_Fn)f);
255   }
256   // sort by fixed-stride sub arrays:
257   void sort(int f(E*, E*), int stride) {
258     qsort(_data, length() / stride, sizeof(E) * stride, (_sort_Fn)f);
259   }
260 
</pre>
</td>
<td>
<hr />
<pre>
206       if (_data[i] == elem) return i;
207     }
208     return -1;
209   }
210 
211   int  find(void* token, bool f(void*, E)) const {
212     for (int i = 0; i &lt; _len; i++) {
213       if (f(token, _data[i])) return i;
214     }
215     return -1;
216   }
217 
218   int  find_from_end(void* token, bool f(void*, E)) const {
219     // start at the end of the array
220     for (int i = _len-1; i &gt;= 0; i--) {
221       if (f(token, _data[i])) return i;
222     }
223     return -1;
224   }
225 
<span class="line-added">226   // Order preserving remove operations.</span>
<span class="line-added">227 </span>
228   void remove(const E&amp; elem) {
<span class="line-added">229     // Assuming that element does exist.</span>
<span class="line-added">230     bool removed = remove_if_existing(elem);</span>
<span class="line-added">231     if (removed) return;</span>
<span class="line-added">232     ShouldNotReachHere();</span>
<span class="line-added">233   }</span>
<span class="line-added">234 </span>
<span class="line-added">235   bool remove_if_existing(const E&amp; elem) {</span>
<span class="line-added">236     // Returns TRUE if elem is removed.</span>
237     for (int i = 0; i &lt; _len; i++) {
238       if (_data[i] == elem) {
<span class="line-modified">239         remove_at(i);</span>
<span class="line-modified">240         return true;</span>

241       }
242     }
<span class="line-modified">243     return false;</span>
244   }
245 

246   void remove_at(int index) {
247     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
<span class="line-modified">248     for (int j = index + 1; j &lt; _len; j++) {</span>
<span class="line-added">249       _data[j-1] = _data[j];</span>
<span class="line-added">250     }</span>
251     _len--;
252   }
253 
254   // The order is changed.
255   void delete_at(int index) {
256     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
257     if (index &lt; --_len) {
258       // Replace removed element with last one.
259       _data[index] = _data[_len];
260     }
261   }
262 
263   void sort(int f(E*, E*)) {
264     qsort(_data, length(), sizeof(E), (_sort_Fn)f);
265   }
266   // sort by fixed-stride sub arrays:
267   void sort(int f(E*, E*), int stride) {
268     qsort(_data, length() / stride, sizeof(E) * stride, (_sort_Fn)f);
269   }
270 
</pre>
</td>
</tr>
</table>
<center><a href="../services/virtualMemoryTracker.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/lang/invoke/MethodHandles.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
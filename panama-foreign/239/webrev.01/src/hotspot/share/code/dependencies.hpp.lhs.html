<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/code/dependencies.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_DEPENDENCIES_HPP
 26 #define SHARE_CODE_DEPENDENCIES_HPP
 27 
 28 #include &quot;ci/ciCallSite.hpp&quot;
 29 #include &quot;ci/ciKlass.hpp&quot;
 30 #include &quot;ci/ciMethod.hpp&quot;
 31 #include &quot;ci/ciMethodHandle.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 32 #include &quot;classfile/systemDictionary.hpp&quot;</span>
 33 #include &quot;code/compressedStream.hpp&quot;
 34 #include &quot;code/nmethod.hpp&quot;
 35 #include &quot;memory/resourceArea.hpp&quot;
 36 #include &quot;runtime/safepointVerifiers.hpp&quot;
 37 #include &quot;utilities/growableArray.hpp&quot;
 38 #include &quot;utilities/hashtable.hpp&quot;
 39 
 40 //** Dependencies represent assertions (approximate invariants) within
 41 // the runtime system, e.g. class hierarchy changes.  An example is an
 42 // assertion that a given method is not overridden; another example is
 43 // that a type has only one concrete subtype.  Compiled code which
 44 // relies on such assertions must be discarded if they are overturned
 45 // by changes in the runtime system.  We can think of these assertions
 46 // as approximate invariants, because we expect them to be overturned
 47 // very infrequently.  We are willing to perform expensive recovery
 48 // operations when they are overturned.  The benefit, of course, is
 49 // performing optimistic optimizations (!) on the object code.
 50 //
 51 // Changes in the class hierarchy due to dynamic linking or
 52 // class evolution can violate dependencies.  There is enough
 53 // indexing between classes and nmethods to make dependency
 54 // checking reasonably efficient.
 55 
 56 class ciEnv;
 57 class nmethod;
 58 class OopRecorder;
 59 class xmlStream;
 60 class CompileLog;
 61 class DepChange;
 62 class   KlassDepChange;
 63 class   CallSiteDepChange;
 64 class NoSafepointVerifier;
 65 
 66 class Dependencies: public ResourceObj {
 67  public:
 68   // Note: In the comments on dependency types, most uses of the terms
 69   // subtype and supertype are used in a &quot;non-strict&quot; or &quot;inclusive&quot;
 70   // sense, and are starred to remind the reader of this fact.
 71   // Strict uses of the terms use the word &quot;proper&quot;.
 72   //
 73   // Specifically, every class is its own subtype* and supertype*.
 74   // (This trick is easier than continually saying things like &quot;Y is a
 75   // subtype of X or X itself&quot;.)
 76   //
 77   // Sometimes we write X &gt; Y to mean X is a proper supertype of Y.
 78   // The notation X &gt; {Y, Z} means X has proper subtypes Y, Z.
 79   // The notation X.m &gt; Y means that Y inherits m from X, while
 80   // X.m &gt; Y.m means Y overrides X.m.  A star denotes abstractness,
 81   // as *I &gt; A, meaning (abstract) interface I is a super type of A,
 82   // or A.*m &gt; B.m, meaning B.m implements abstract method A.m.
 83   //
 84   // In this module, the terms &quot;subtype&quot; and &quot;supertype&quot; refer to
 85   // Java-level reference type conversions, as detected by
 86   // &quot;instanceof&quot; and performed by &quot;checkcast&quot; operations.  The method
 87   // Klass::is_subtype_of tests these relations.  Note that &quot;subtype&quot;
 88   // is richer than &quot;subclass&quot; (as tested by Klass::is_subclass_of),
 89   // since it takes account of relations involving interface and array
 90   // types.
 91   //
 92   // To avoid needless complexity, dependencies involving array types
 93   // are not accepted.  If you need to make an assertion about an
 94   // array type, make the assertion about its corresponding element
 95   // types.  Any assertion that might change about an array type can
 96   // be converted to an assertion about its element type.
 97   //
 98   // Most dependencies are evaluated over a &quot;context type&quot; CX, which
 99   // stands for the set Subtypes(CX) of every Java type that is a subtype*
100   // of CX.  When the system loads a new class or interface N, it is
101   // responsible for re-evaluating changed dependencies whose context
102   // type now includes N, that is, all super types of N.
103   //
104   enum DepType {
105     end_marker = 0,
106 
107     // An &#39;evol&#39; dependency simply notes that the contents of the
108     // method were used.  If it evolves (is replaced), the nmethod
109     // must be recompiled.  No other dependencies are implied.
110     evol_method,
111     FIRST_TYPE = evol_method,
112 
113     // A context type CX is a leaf it if has no proper subtype.
114     leaf_type,
115 
116     // An abstract class CX has exactly one concrete subtype CC.
117     abstract_with_unique_concrete_subtype,
118 
119     // The type CX is purely abstract, with no concrete subtype* at all.
120     abstract_with_no_concrete_subtype,
121 
122     // The concrete CX is free of concrete proper subtypes.
123     concrete_with_no_concrete_subtype,
124 
125     // Given a method M1 and a context class CX, the set MM(CX, M1) of
126     // &quot;concrete matching methods&quot; in CX of M1 is the set of every
127     // concrete M2 for which it is possible to create an invokevirtual
128     // or invokeinterface call site that can reach either M1 or M2.
129     // That is, M1 and M2 share a name, signature, and vtable index.
130     // We wish to notice when the set MM(CX, M1) is just {M1}, or
131     // perhaps a set of two {M1,M2}, and issue dependencies on this.
132 
133     // The set MM(CX, M1) can be computed by starting with any matching
134     // concrete M2 that is inherited into CX, and then walking the
135     // subtypes* of CX looking for concrete definitions.
136 
137     // The parameters to this dependency are the method M1 and the
138     // context class CX.  M1 must be either inherited in CX or defined
139     // in a subtype* of CX.  It asserts that MM(CX, M1) is no greater
140     // than {M1}.
141     unique_concrete_method,       // one unique concrete method under CX
142 
143     // An &quot;exclusive&quot; assertion concerns two methods or subtypes, and
144     // declares that there are at most two (or perhaps later N&gt;2)
145     // specific items that jointly satisfy the restriction.
146     // We list all items explicitly rather than just giving their
147     // count, for robustness in the face of complex schema changes.
148 
149     // A context class CX (which may be either abstract or concrete)
150     // has two exclusive concrete subtypes* C1, C2 if every concrete
151     // subtype* of CX is either C1 or C2.  Note that if neither C1 or C2
152     // are equal to CX, then CX itself must be abstract.  But it is
153     // also possible (for example) that C1 is CX (a concrete class)
154     // and C2 is a proper subtype of C1.
155     abstract_with_exclusive_concrete_subtypes_2,
156 
157     // This dependency asserts that MM(CX, M1) is no greater than {M1,M2}.
158     exclusive_concrete_methods_2,
159 
160     // This dependency asserts that no instances of class or it&#39;s
161     // subclasses require finalization registration.
162     no_finalizable_subclasses,
163 
164     // This dependency asserts when the CallSite.target value changed.
165     call_site_target_value,
166 
167     TYPE_LIMIT
168   };
169   enum {
170     LG2_TYPE_LIMIT = 4,  // assert(TYPE_LIMIT &lt;= (1&lt;&lt;LG2_TYPE_LIMIT))
171 
172     // handy categorizations of dependency types:
173     all_types           = ((1 &lt;&lt; TYPE_LIMIT) - 1) &amp; ((~0u) &lt;&lt; FIRST_TYPE),
174 
175     non_klass_types     = (1 &lt;&lt; call_site_target_value),
176     klass_types         = all_types &amp; ~non_klass_types,
177 
178     non_ctxk_types      = (1 &lt;&lt; evol_method) | (1 &lt;&lt; call_site_target_value),
179     implicit_ctxk_types = 0,
180     explicit_ctxk_types = all_types &amp; ~(non_ctxk_types | implicit_ctxk_types),
181 
182     max_arg_count = 3,   // current maximum number of arguments (incl. ctxk)
183 
184     // A &quot;context type&quot; is a class or interface that
185     // provides context for evaluating a dependency.
186     // When present, it is one of the arguments (dep_context_arg).
187     //
188     // If a dependency does not have a context type, there is a
189     // default context, depending on the type of the dependency.
190     // This bit signals that a default context has been compressed away.
191     default_context_type_bit = (1&lt;&lt;LG2_TYPE_LIMIT)
192   };
193 
194   static const char* dep_name(DepType dept);
195   static int         dep_args(DepType dept);
196 
197   static bool is_klass_type(           DepType dept) { return dept_in_mask(dept, klass_types        ); }
198 
199   static bool has_explicit_context_arg(DepType dept) { return dept_in_mask(dept, explicit_ctxk_types); }
200   static bool has_implicit_context_arg(DepType dept) { return dept_in_mask(dept, implicit_ctxk_types); }
201 
202   static int           dep_context_arg(DepType dept) { return has_explicit_context_arg(dept) ? 0 : -1; }
203   static int  dep_implicit_context_arg(DepType dept) { return has_implicit_context_arg(dept) ? 0 : -1; }
204 
205   static void check_valid_dependency_type(DepType dept);
206 
207 #if INCLUDE_JVMCI
208   // A Metadata* or object value recorded in an OopRecorder
209   class DepValue {
210    private:
211     // Unique identifier of the value within the associated OopRecorder that
212     // encodes both the category of the value (0: invalid, positive: metadata, negative: object)
213     // and the index within a category specific array (metadata: index + 1, object: -(index + 1))
214     int _id;
215 
216    public:
217     DepValue() : _id(0) {}
218     DepValue(OopRecorder* rec, Metadata* metadata, DepValue* candidate = NULL) {
219       assert(candidate == NULL || candidate-&gt;is_metadata(), &quot;oops&quot;);
220       if (candidate != NULL &amp;&amp; candidate-&gt;as_metadata(rec) == metadata) {
221         _id = candidate-&gt;_id;
222       } else {
223         _id = rec-&gt;find_index(metadata) + 1;
224       }
225     }
226     DepValue(OopRecorder* rec, jobject obj, DepValue* candidate = NULL) {
227       assert(candidate == NULL || candidate-&gt;is_object(), &quot;oops&quot;);
228       if (candidate != NULL &amp;&amp; candidate-&gt;as_object(rec) == obj) {
229         _id = candidate-&gt;_id;
230       } else {
231         _id = -(rec-&gt;find_index(obj) + 1);
232       }
233     }
234 
235     // Used to sort values in ascending order of index() with metadata values preceding object values
236     int sort_key() const { return -_id; }
237 
238     bool operator == (const DepValue&amp; other) const   { return other._id == _id; }
239 
240     bool is_valid() const             { return _id != 0; }
241     int  index() const                { assert(is_valid(), &quot;oops&quot;); return _id &lt; 0 ? -(_id + 1) : _id - 1; }
242     bool is_metadata() const          { assert(is_valid(), &quot;oops&quot;); return _id &gt; 0; }
243     bool is_object() const            { assert(is_valid(), &quot;oops&quot;); return _id &lt; 0; }
244 
245     Metadata*  as_metadata(OopRecorder* rec) const    { assert(is_metadata(), &quot;oops&quot;); return rec-&gt;metadata_at(index()); }
246     Klass*     as_klass(OopRecorder* rec) const {
247       Metadata* m = as_metadata(rec);
248       assert(m != NULL, &quot;as_metadata returned NULL&quot;);
249       assert(m-&gt;is_klass(), &quot;oops&quot;);
250       return (Klass*) m;
251     }
252     Method*    as_method(OopRecorder* rec) const {
253       Metadata* m = as_metadata(rec);
254       assert(m != NULL, &quot;as_metadata returned NULL&quot;);
255       assert(m-&gt;is_method(), &quot;oops&quot;);
256       return (Method*) m;
257     }
258     jobject    as_object(OopRecorder* rec) const      { assert(is_object(), &quot;oops&quot;); return rec-&gt;oop_at(index()); }
259   };
260 #endif // INCLUDE_JVMCI
261 
262  private:
263   // State for writing a new set of dependencies:
264   GrowableArray&lt;int&gt;*       _dep_seen;  // (seen[h-&gt;ident] &amp; (1&lt;&lt;dept))
265   GrowableArray&lt;ciBaseObject*&gt;*  _deps[TYPE_LIMIT];
266 #if INCLUDE_JVMCI
267   bool _using_dep_values;
268   GrowableArray&lt;DepValue&gt;*  _dep_values[TYPE_LIMIT];
269 #endif
270 
271   static const char* _dep_name[TYPE_LIMIT];
272   static int         _dep_args[TYPE_LIMIT];
273 
274   static bool dept_in_mask(DepType dept, int mask) {
275     return (int)dept &gt;= 0 &amp;&amp; dept &lt; TYPE_LIMIT &amp;&amp; ((1&lt;&lt;dept) &amp; mask) != 0;
276   }
277 
278   bool note_dep_seen(int dept, ciBaseObject* x) {
279     assert(dept &lt; BitsPerInt, &quot;oob&quot;);
280     int x_id = x-&gt;ident();
281     assert(_dep_seen != NULL, &quot;deps must be writable&quot;);
282     int seen = _dep_seen-&gt;at_grow(x_id, 0);
283     _dep_seen-&gt;at_put(x_id, seen | (1&lt;&lt;dept));
284     // return true if we&#39;ve already seen dept/x
285     return (seen &amp; (1&lt;&lt;dept)) != 0;
286   }
287 
288 #if INCLUDE_JVMCI
289   bool note_dep_seen(int dept, DepValue x) {
290     assert(dept &lt; BitsPerInt, &quot;oops&quot;);
291     // place metadata deps at even indexes, object deps at odd indexes
292     int x_id = x.is_metadata() ? x.index() * 2 : (x.index() * 2) + 1;
293     assert(_dep_seen != NULL, &quot;deps must be writable&quot;);
294     int seen = _dep_seen-&gt;at_grow(x_id, 0);
295     _dep_seen-&gt;at_put(x_id, seen | (1&lt;&lt;dept));
296     // return true if we&#39;ve already seen dept/x
297     return (seen &amp; (1&lt;&lt;dept)) != 0;
298   }
299 #endif
300 
301   bool maybe_merge_ctxk(GrowableArray&lt;ciBaseObject*&gt;* deps,
302                         int ctxk_i, ciKlass* ctxk);
303 #if INCLUDE_JVMCI
304   bool maybe_merge_ctxk(GrowableArray&lt;DepValue&gt;* deps,
305                         int ctxk_i, DepValue ctxk);
306 #endif
307 
308   void sort_all_deps();
309   size_t estimate_size_in_bytes();
310 
311   // Initialize _deps, etc.
312   void initialize(ciEnv* env);
313 
314   // State for making a new set of dependencies:
315   OopRecorder* _oop_recorder;
316 
317   // Logging support
318   CompileLog* _log;
319 
320   address  _content_bytes;  // everything but the oop references, encoded
321   size_t   _size_in_bytes;
322 
323  public:
324   // Make a new empty dependencies set.
325   Dependencies(ciEnv* env) {
326     initialize(env);
327   }
328 #if INCLUDE_JVMCI
329   Dependencies(Arena* arena, OopRecorder* oop_recorder, CompileLog* log);
330 #endif
331 
332  private:
333   // Check for a valid context type.
334   // Enforce the restriction against array types.
335   static void check_ctxk(ciKlass* ctxk) {
336     assert(ctxk-&gt;is_instance_klass(), &quot;java types only&quot;);
337   }
338   static void check_ctxk_concrete(ciKlass* ctxk) {
339     assert(is_concrete_klass(ctxk-&gt;as_instance_klass()), &quot;must be concrete&quot;);
340   }
341   static void check_ctxk_abstract(ciKlass* ctxk) {
342     check_ctxk(ctxk);
343     assert(!is_concrete_klass(ctxk-&gt;as_instance_klass()), &quot;must be abstract&quot;);
344   }
345   static void check_unique_method(ciKlass* ctxk, ciMethod* m) {
346     assert(!m-&gt;can_be_statically_bound(ctxk-&gt;as_instance_klass()), &quot;redundant&quot;);
347   }
348 
349   void assert_common_1(DepType dept, ciBaseObject* x);
350   void assert_common_2(DepType dept, ciBaseObject* x0, ciBaseObject* x1);
351   void assert_common_3(DepType dept, ciKlass* ctxk, ciBaseObject* x1, ciBaseObject* x2);
352 
353  public:
354   // Adding assertions to a new dependency set at compile time:
355   void assert_evol_method(ciMethod* m);
356   void assert_leaf_type(ciKlass* ctxk);
357   void assert_abstract_with_unique_concrete_subtype(ciKlass* ctxk, ciKlass* conck);
358   void assert_abstract_with_no_concrete_subtype(ciKlass* ctxk);
359   void assert_concrete_with_no_concrete_subtype(ciKlass* ctxk);
360   void assert_unique_concrete_method(ciKlass* ctxk, ciMethod* uniqm);
361   void assert_abstract_with_exclusive_concrete_subtypes(ciKlass* ctxk, ciKlass* k1, ciKlass* k2);
362   void assert_exclusive_concrete_methods(ciKlass* ctxk, ciMethod* m1, ciMethod* m2);
363   void assert_has_no_finalizable_subclasses(ciKlass* ctxk);
364   void assert_call_site_target_value(ciCallSite* call_site, ciMethodHandle* method_handle);
365 
366 #if INCLUDE_JVMCI
367  private:
368   static void check_ctxk(Klass* ctxk) {
369     assert(ctxk-&gt;is_instance_klass(), &quot;java types only&quot;);
370   }
371   static void check_ctxk_abstract(Klass* ctxk) {
372     check_ctxk(ctxk);
373     assert(ctxk-&gt;is_abstract(), &quot;must be abstract&quot;);
374   }
375   static void check_unique_method(Klass* ctxk, Method* m) {
376     assert(!m-&gt;can_be_statically_bound(InstanceKlass::cast(ctxk)), &quot;redundant&quot;);
377   }
378 
379   void assert_common_1(DepType dept, DepValue x);
380   void assert_common_2(DepType dept, DepValue x0, DepValue x1);
381 
382  public:
383   void assert_evol_method(Method* m);
384   void assert_has_no_finalizable_subclasses(Klass* ctxk);
385   void assert_leaf_type(Klass* ctxk);
386   void assert_unique_concrete_method(Klass* ctxk, Method* uniqm);
387   void assert_abstract_with_unique_concrete_subtype(Klass* ctxk, Klass* conck);
388   void assert_call_site_target_value(oop callSite, oop methodHandle);
389 #endif // INCLUDE_JVMCI
390 
391   // Define whether a given method or type is concrete.
392   // These methods define the term &quot;concrete&quot; as used in this module.
393   // For this module, an &quot;abstract&quot; class is one which is non-concrete.
394   //
395   // Future optimizations may allow some classes to remain
396   // non-concrete until their first instantiation, and allow some
397   // methods to remain non-concrete until their first invocation.
398   // In that case, there would be a middle ground between concrete
399   // and abstract (as defined by the Java language and VM).
400   static bool is_concrete_klass(Klass* k);    // k is instantiable
401   static bool is_concrete_method(Method* m, Klass* k);  // m is invocable
402   static Klass* find_finalizable_subclass(Klass* k);
403 
404   // These versions of the concreteness queries work through the CI.
405   // The CI versions are allowed to skew sometimes from the VM
406   // (oop-based) versions.  The cost of such a difference is a
407   // (safely) aborted compilation, or a deoptimization, or a missed
408   // optimization opportunity.
409   //
410   // In order to prevent spurious assertions, query results must
411   // remain stable within any single ciEnv instance.  (I.e., they must
412   // not go back into the VM to get their value; they must cache the
413   // bit in the CI, either eagerly or lazily.)
414   static bool is_concrete_klass(ciInstanceKlass* k); // k appears instantiable
415   static bool has_finalizable_subclass(ciInstanceKlass* k);
416 
417   // As a general rule, it is OK to compile under the assumption that
418   // a given type or method is concrete, even if it at some future
419   // point becomes abstract.  So dependency checking is one-sided, in
420   // that it permits supposedly concrete classes or methods to turn up
421   // as really abstract.  (This shouldn&#39;t happen, except during class
422   // evolution, but that&#39;s the logic of the checking.)  However, if a
423   // supposedly abstract class or method suddenly becomes concrete, a
424   // dependency on it must fail.
425 
426   // Checking old assertions at run-time (in the VM only):
427   static Klass* check_evol_method(Method* m);
428   static Klass* check_leaf_type(Klass* ctxk);
429   static Klass* check_abstract_with_unique_concrete_subtype(Klass* ctxk, Klass* conck,
430                                                               KlassDepChange* changes = NULL);
431   static Klass* check_abstract_with_no_concrete_subtype(Klass* ctxk,
432                                                           KlassDepChange* changes = NULL);
433   static Klass* check_concrete_with_no_concrete_subtype(Klass* ctxk,
434                                                           KlassDepChange* changes = NULL);
435   static Klass* check_unique_concrete_method(Klass* ctxk, Method* uniqm,
436                                                KlassDepChange* changes = NULL);
437   static Klass* check_abstract_with_exclusive_concrete_subtypes(Klass* ctxk, Klass* k1, Klass* k2,
438                                                                   KlassDepChange* changes = NULL);
439   static Klass* check_exclusive_concrete_methods(Klass* ctxk, Method* m1, Method* m2,
440                                                    KlassDepChange* changes = NULL);
441   static Klass* check_has_no_finalizable_subclasses(Klass* ctxk, KlassDepChange* changes = NULL);
442   static Klass* check_call_site_target_value(oop call_site, oop method_handle, CallSiteDepChange* changes = NULL);
443   // A returned Klass* is NULL if the dependency assertion is still
444   // valid.  A non-NULL Klass* is a &#39;witness&#39; to the assertion
445   // failure, a point in the class hierarchy where the assertion has
446   // been proven false.  For example, if check_leaf_type returns
447   // non-NULL, the value is a subtype of the supposed leaf type.  This
448   // witness value may be useful for logging the dependency failure.
449   // Note that, when a dependency fails, there may be several possible
450   // witnesses to the failure.  The value returned from the check_foo
451   // method is chosen arbitrarily.
452 
453   // The &#39;changes&#39; value, if non-null, requests a limited spot-check
454   // near the indicated recent changes in the class hierarchy.
455   // It is used by DepStream::spot_check_dependency_at.
456 
457   // Detecting possible new assertions:
458   static Klass*    find_unique_concrete_subtype(Klass* ctxk);
459   static Method*   find_unique_concrete_method(Klass* ctxk, Method* m);
460   static int       find_exclusive_concrete_subtypes(Klass* ctxk, int klen, Klass* k[]);
461 
462   // Create the encoding which will be stored in an nmethod.
463   void encode_content_bytes();
464 
465   address content_bytes() {
466     assert(_content_bytes != NULL, &quot;encode it first&quot;);
467     return _content_bytes;
468   }
469   size_t size_in_bytes() {
470     assert(_content_bytes != NULL, &quot;encode it first&quot;);
471     return _size_in_bytes;
472   }
473 
474   OopRecorder* oop_recorder() { return _oop_recorder; }
475   CompileLog*  log()          { return _log; }
476 
477   void copy_to(nmethod* nm);
478 
479   DepType validate_dependencies(CompileTask* task, char** failure_detail = NULL);
480 
481   void log_all_dependencies();
482 
483   void log_dependency(DepType dept, GrowableArray&lt;ciBaseObject*&gt;* args) {
484     ResourceMark rm;
485     int argslen = args-&gt;length();
486     write_dependency_to(log(), dept, args);
487     guarantee(argslen == args-&gt;length(),
488               &quot;args array cannot grow inside nested ResoureMark scope&quot;);
489   }
490 
491   void log_dependency(DepType dept,
492                       ciBaseObject* x0,
493                       ciBaseObject* x1 = NULL,
494                       ciBaseObject* x2 = NULL) {
495     if (log() == NULL) {
496       return;
497     }
498     ResourceMark rm;
499     GrowableArray&lt;ciBaseObject*&gt;* ciargs =
500                 new GrowableArray&lt;ciBaseObject*&gt;(dep_args(dept));
501     assert (x0 != NULL, &quot;no log x0&quot;);
502     ciargs-&gt;push(x0);
503 
504     if (x1 != NULL) {
505       ciargs-&gt;push(x1);
506     }
507     if (x2 != NULL) {
508       ciargs-&gt;push(x2);
509     }
510     assert(ciargs-&gt;length() == dep_args(dept), &quot;&quot;);
511     log_dependency(dept, ciargs);
512   }
513 
514   class DepArgument : public ResourceObj {
515    private:
516     bool  _is_oop;
517     bool  _valid;
518     void* _value;
519    public:
520     DepArgument() : _is_oop(false), _valid(false), _value(NULL) {}
521     DepArgument(oop v): _is_oop(true), _valid(true), _value(v) {}
522     DepArgument(Metadata* v): _is_oop(false), _valid(true), _value(v) {}
523 
524     bool is_null() const               { return _value == NULL; }
525     bool is_oop() const                { return _is_oop; }
526     bool is_metadata() const           { return !_is_oop; }
527     bool is_klass() const              { return is_metadata() &amp;&amp; metadata_value()-&gt;is_klass(); }
528     bool is_method() const              { return is_metadata() &amp;&amp; metadata_value()-&gt;is_method(); }
529 
530     oop oop_value() const              { assert(_is_oop &amp;&amp; _valid, &quot;must be&quot;); return (oop) _value; }
531     Metadata* metadata_value() const { assert(!_is_oop &amp;&amp; _valid, &quot;must be&quot;); return (Metadata*) _value; }
532   };
533 
534   static void print_dependency(DepType dept,
535                                GrowableArray&lt;DepArgument&gt;* args,
536                                Klass* witness = NULL, outputStream* st = tty);
537 
538  private:
539   // helper for encoding common context types as zero:
540   static ciKlass* ctxk_encoded_as_null(DepType dept, ciBaseObject* x);
541 
542   static Klass* ctxk_encoded_as_null(DepType dept, Metadata* x);
543 
544   static void write_dependency_to(CompileLog* log,
545                                   DepType dept,
546                                   GrowableArray&lt;ciBaseObject*&gt;* args,
547                                   Klass* witness = NULL);
548   static void write_dependency_to(CompileLog* log,
549                                   DepType dept,
550                                   GrowableArray&lt;DepArgument&gt;* args,
551                                   Klass* witness = NULL);
552   static void write_dependency_to(xmlStream* xtty,
553                                   DepType dept,
554                                   GrowableArray&lt;DepArgument&gt;* args,
555                                   Klass* witness = NULL);
556  public:
557   // Use this to iterate over an nmethod&#39;s dependency set.
558   // Works on new and old dependency sets.
559   // Usage:
560   //
561   // ;
562   // Dependencies::DepType dept;
563   // for (Dependencies::DepStream deps(nm); deps.next(); ) {
564   //   ...
565   // }
566   //
567   // The caller must be in the VM, since oops are not wrapped in handles.
568   class DepStream {
569   private:
570     nmethod*              _code;   // null if in a compiler thread
571     Dependencies*         _deps;   // null if not in a compiler thread
572     CompressedReadStream  _bytes;
573 #ifdef ASSERT
574     size_t                _byte_limit;
575 #endif
576 
577     // iteration variables:
578     DepType               _type;
579     int                   _xi[max_arg_count+1];
580 
581     void initial_asserts(size_t byte_limit) NOT_DEBUG({});
582 
583     inline Metadata* recorded_metadata_at(int i);
584     inline oop recorded_oop_at(int i);
585 
586     Klass* check_klass_dependency(KlassDepChange* changes);
587     Klass* check_call_site_dependency(CallSiteDepChange* changes);
588 
589     void trace_and_log_witness(Klass* witness);
590 
591   public:
592     DepStream(Dependencies* deps)
593       : _code(NULL),
594         _deps(deps),
595         _bytes(deps-&gt;content_bytes())
596     {
597       initial_asserts(deps-&gt;size_in_bytes());
598     }
599     DepStream(nmethod* code)
600       : _code(code),
601         _deps(NULL),
602         _bytes(code-&gt;dependencies_begin())
603     {
604       initial_asserts(code-&gt;dependencies_size());
605     }
606 
607     bool next();
608 
609     DepType type()               { return _type; }
610     bool is_oop_argument(int i)  { return type() == call_site_target_value; }
611     uintptr_t get_identifier(int i);
612 
613     int argument_count()         { return dep_args(type()); }
614     int argument_index(int i)    { assert(0 &lt;= i &amp;&amp; i &lt; argument_count(), &quot;oob&quot;);
615                                    return _xi[i]; }
616     Metadata* argument(int i);     // =&gt; recorded_oop_at(argument_index(i))
617     oop argument_oop(int i);         // =&gt; recorded_oop_at(argument_index(i))
618     Klass* context_type();
619 
620     bool is_klass_type()         { return Dependencies::is_klass_type(type()); }
621 
622     Method* method_argument(int i) {
623       Metadata* x = argument(i);
624       assert(x-&gt;is_method(), &quot;type&quot;);
625       return (Method*) x;
626     }
627     Klass* type_argument(int i) {
628       Metadata* x = argument(i);
629       assert(x-&gt;is_klass(), &quot;type&quot;);
630       return (Klass*) x;
631     }
632 
633     // The point of the whole exercise:  Is this dep still OK?
634     Klass* check_dependency() {
635       Klass* result = check_klass_dependency(NULL);
636       if (result != NULL)  return result;
637       return check_call_site_dependency(NULL);
638     }
639 
640     // A lighter version:  Checks only around recent changes in a class
641     // hierarchy.  (See Universe::flush_dependents_on.)
642     Klass* spot_check_dependency_at(DepChange&amp; changes);
643 
644     // Log the current dependency to xtty or compilation log.
645     void log_dependency(Klass* witness = NULL);
646 
647     // Print the current dependency to tty.
648     void print_dependency(Klass* witness = NULL, bool verbose = false, outputStream* st = tty);
649   };
650   friend class Dependencies::DepStream;
651 
652   static void print_statistics() PRODUCT_RETURN;
653 };
654 
655 
656 class DependencySignature : public ResourceObj {
657  private:
658   int                   _args_count;
659   uintptr_t             _argument_hash[Dependencies::max_arg_count];
660   Dependencies::DepType _type;
661 
662  public:
663   DependencySignature(Dependencies::DepStream&amp; dep) {
664     _args_count = dep.argument_count();
665     _type = dep.type();
666     for (int i = 0; i &lt; _args_count; i++) {
667       _argument_hash[i] = dep.get_identifier(i);
668     }
669   }
670 
671   static bool     equals(DependencySignature const&amp; s1, DependencySignature const&amp; s2);
672   static unsigned hash  (DependencySignature const&amp; s1) { return s1.arg(0) &gt;&gt; 2; }
673 
674   int args_count()             const { return _args_count; }
675   uintptr_t arg(int idx)       const { return _argument_hash[idx]; }
676   Dependencies::DepType type() const { return _type; }
677 
678 };
679 
680 
681 // Every particular DepChange is a sub-class of this class.
682 class DepChange : public StackObj {
683  public:
684   // What kind of DepChange is this?
685   virtual bool is_klass_change()     const { return false; }
686   virtual bool is_call_site_change() const { return false; }
687 
688   virtual void mark_for_deoptimization(nmethod* nm) = 0;
689 
690   // Subclass casting with assertions.
691   KlassDepChange*    as_klass_change() {
692     assert(is_klass_change(), &quot;bad cast&quot;);
693     return (KlassDepChange*) this;
694   }
695   CallSiteDepChange* as_call_site_change() {
696     assert(is_call_site_change(), &quot;bad cast&quot;);
697     return (CallSiteDepChange*) this;
698   }
699 
700   void print();
701 
702  public:
703   enum ChangeType {
704     NO_CHANGE = 0,              // an uninvolved klass
705     Change_new_type,            // a newly loaded type
706     Change_new_sub,             // a super with a new subtype
707     Change_new_impl,            // an interface with a new implementation
708     CHANGE_LIMIT,
709     Start_Klass = CHANGE_LIMIT  // internal indicator for ContextStream
710   };
711 
712   // Usage:
713   // for (DepChange::ContextStream str(changes); str.next(); ) {
714   //   Klass* k = str.klass();
715   //   switch (str.change_type()) {
716   //     ...
717   //   }
718   // }
719   class ContextStream : public StackObj {
720    private:
721     DepChange&amp;  _changes;
722     friend class DepChange;
723 
724     // iteration variables:
725     ChangeType  _change_type;
726     Klass*      _klass;
727     Array&lt;InstanceKlass*&gt;* _ti_base;    // i.e., transitive_interfaces
728     int         _ti_index;
729     int         _ti_limit;
730 
731     // start at the beginning:
732     void start();
733 
734    public:
735     ContextStream(DepChange&amp; changes)
736       : _changes(changes)
737     { start(); }
738 
739     ContextStream(DepChange&amp; changes, NoSafepointVerifier&amp; nsv)
740       : _changes(changes)
741       // the nsv argument makes it safe to hold oops like _klass
742     { start(); }
743 
744     bool next();
745 
746     ChangeType change_type()     { return _change_type; }
747     Klass*     klass()           { return _klass; }
748   };
749   friend class DepChange::ContextStream;
750 };
751 
752 
753 // A class hierarchy change coming through the VM (under the Compile_lock).
754 // The change is structured as a single new type with any number of supers
755 // and implemented interface types.  Other than the new type, any of the
756 // super types can be context types for a relevant dependency, which the
757 // new type could invalidate.
758 class KlassDepChange : public DepChange {
759  private:
760   // each change set is rooted in exactly one new type (at present):
761   Klass* _new_type;
762 
763   void initialize();
764 
765  public:
766   // notes the new type, marks it and all its super-types
767   KlassDepChange(Klass* new_type)
768     : _new_type(new_type)
769   {
770     initialize();
771   }
772 
773   // cleans up the marks
774   ~KlassDepChange();
775 
776   // What kind of DepChange is this?
777   virtual bool is_klass_change() const { return true; }
778 
779   virtual void mark_for_deoptimization(nmethod* nm) {
780     nm-&gt;mark_for_deoptimization(/*inc_recompile_counts=*/true);
781   }
782 
783   Klass* new_type() { return _new_type; }
784 
785   // involves_context(k) is true if k is new_type or any of the super types
786   bool involves_context(Klass* k);
787 };
788 
789 
790 // A CallSite has changed its target.
791 class CallSiteDepChange : public DepChange {
792  private:
793   Handle _call_site;
794   Handle _method_handle;
795 
796  public:
797   CallSiteDepChange(Handle call_site, Handle method_handle);
798 
799   // What kind of DepChange is this?
800   virtual bool is_call_site_change() const { return true; }
801 
802   virtual void mark_for_deoptimization(nmethod* nm) {
803     nm-&gt;mark_for_deoptimization(/*inc_recompile_counts=*/false);
804   }
805 
806   oop call_site()     const { return _call_site();     }
807   oop method_handle() const { return _method_handle(); }
808 };
809 
810 #endif // SHARE_CODE_DEPENDENCIES_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
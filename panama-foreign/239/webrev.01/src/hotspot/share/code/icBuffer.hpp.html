<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/code/icBuffer.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_ICBUFFER_HPP
 26 #define SHARE_CODE_ICBUFFER_HPP
 27 
 28 #include &quot;asm/codeBuffer.hpp&quot;
 29 #include &quot;code/stubs.hpp&quot;
 30 #include &quot;interpreter/bytecodes.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;runtime/safepointVerifiers.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 #include &quot;utilities/debug.hpp&quot;
 35 #include &quot;utilities/macros.hpp&quot;
 36 
 37 class CompiledIC;
 38 class CompiledICHolder;
 39 
 40 //
 41 // For CompiledIC&#39;s:
 42 //
 43 // In cases where we do not have MT-safe state transformation,
 44 // we go to a transition state, using ICStubs. At a safepoint,
 45 // the inline caches are transferred from the transitional code:
 46 //
 47 //    instruction_address --&gt; 01 set xxx_oop, Ginline_cache_klass
 48 //                            23 jump_to Gtemp, yyyy
 49 //                            4  nop
 50 
 51 class ICStub: public Stub {
 52  private:
 53   int                 _size;       // total size of the stub incl. code
 54   address             _ic_site;    // points at call instruction of owning ic-buffer
 55   /* stub code follows here */
 56  protected:
 57   friend class ICStubInterface;
 58   // This will be called only by ICStubInterface
 59   void    initialize(int size,
 60                      CodeStrings strings)        { _size = size; _ic_site = NULL; }
 61   void    finalize(); // called when a method is removed
 62 
 63   // General info
 64   int     size() const                           { return _size; }
 65   static  int code_size_to_size(int code_size)   { return align_up((int)sizeof(ICStub), CodeEntryAlignment) + code_size; }
 66 
 67  public:
 68   // Creation
 69   void set_stub(CompiledIC *ic, void* cached_value, address dest_addr);
 70 
 71   // Code info
 72   address code_begin() const                     { return (address)this + align_up(sizeof(ICStub), CodeEntryAlignment); }
 73   address code_end() const                       { return (address)this + size(); }
 74 
 75   // Call site info
 76   address ic_site() const                        { return _ic_site; }
 77   void    clear();
 78   bool    is_empty() const                       { return _ic_site == NULL; }
 79 
 80   // stub info
 81   address destination() const;  // destination of jump instruction
 82   void* cached_value() const;   // cached_value for stub
 83 
 84   // Debugging
 85   void    verify()            PRODUCT_RETURN;
 86   void    print()             PRODUCT_RETURN;
 87 
 88   // Creation
 89   friend ICStub* ICStub_from_destination_address(address destination_address);
 90 };
 91 
 92 // ICStub Creation
 93 inline ICStub* ICStub_from_destination_address(address destination_address) {
 94   ICStub* stub = (ICStub*) (destination_address - align_up(sizeof(ICStub), CodeEntryAlignment));
 95   #ifdef ASSERT
 96   stub-&gt;verify();
 97   #endif
 98   return stub;
 99 }
100 
101 #ifdef ASSERT
102 // The ICRefillVerifier class is a stack allocated RAII object used to
103 // detect if a failed IC transition that required IC stub refilling has
104 // been accidentally missed. It is up to the caller to in that case
105 // refill IC stubs.
106 class ICRefillVerifier: StackObj {
107   bool _refill_requested;
108   bool _refill_remembered;
109 
110  public:
111   ICRefillVerifier();
112   ~ICRefillVerifier();
113 
114   void request_refill() { _refill_requested = true; }
115   void request_remembered() { _refill_remembered = true; }
116 };
117 
118 // The ICRefillVerifierMark is used to set the thread&#39;s current
119 // ICRefillVerifier to a provided one. This is useful in particular
120 // when transitioning IC stubs in parallel and refilling from the
121 // master thread invoking the IC stub transitioning code.
122 class ICRefillVerifierMark: StackObj {
123  public:
124   ICRefillVerifierMark(ICRefillVerifier* verifier);
125   ~ICRefillVerifierMark();
126 };
127 #else
128 class ICRefillVerifier: StackObj {
129  public:
130   ICRefillVerifier() {}
131 };
132 class ICRefillVerifierMark: StackObj {
133  public:
134   ICRefillVerifierMark(ICRefillVerifier* verifier) {}
135 };
136 #endif
137 
138 class InlineCacheBuffer: public AllStatic {
139  private:
140   // friends
141   friend class ICStub;
142 
143   static int ic_stub_code_size();
144 
145   static StubQueue* _buffer;
146 
147   static CompiledICHolder* _pending_released;
148   static int _pending_count;
149 
150   static StubQueue* buffer()                         { return _buffer;         }
151 
152   static ICStub* new_ic_stub();
153 
154   // Machine-dependent implementation of ICBuffer
155   static void    assemble_ic_buffer_code(address code_begin, void* cached_value, address entry_point);
156   static address ic_buffer_entry_point  (address code_begin);
157   static void*   ic_buffer_cached_value (address code_begin);
158 
159  public:
160 
161     // Initialization; must be called before first usage
162   static void initialize();
163 
164   // Access
165   static bool contains(address instruction_address);
166 
167     // removes the ICStubs after backpatching
168   static void update_inline_caches();
169   static void refill_ic_stubs();
170 
171   // for debugging
172   static bool is_empty();
173 
174   static void release_pending_icholders();
175   static void queue_for_release(CompiledICHolder* icholder);
176   static int pending_icholder_count() { return _pending_count; }
177 
178   // New interface
179   static bool    create_transition_stub(CompiledIC *ic, void* cached_value, address entry);
180   static address ic_destination_for(CompiledIC *ic);
181   static void*   cached_value_for(CompiledIC *ic);
182 };
183 
184 #endif // SHARE_CODE_ICBUFFER_HPP
    </pre>
  </body>
</html>
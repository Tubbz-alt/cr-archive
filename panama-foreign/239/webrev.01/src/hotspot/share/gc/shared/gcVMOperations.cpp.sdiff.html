<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/gcVMOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="c1/barrierSetC1.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../shenandoah/c2/shenandoahBarrierSetC2.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/gcVMOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
181                                                                  uint gc_count_before,
182                                                                  uint full_gc_count_before,
183                                                                  GCCause::Cause gc_cause)
184     : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before, true),
185       _result(NULL), _size(size), _mdtype(mdtype), _loader_data(loader_data) {
186   assert(_size != 0, &quot;An allocation should always be requested with this operation.&quot;);
187   AllocTracer::send_allocation_requiring_gc_event(_size * HeapWordSize, GCId::peek());
188 }
189 
190 // Returns true iff concurrent GCs unloads metadata.
191 bool VM_CollectForMetadataAllocation::initiate_concurrent_GC() {
192 #if INCLUDE_G1GC
193   if (UseG1GC &amp;&amp; ClassUnloadingWithConcurrentMark) {
194     G1CollectedHeap* g1h = G1CollectedHeap::heap();
195     g1h-&gt;policy()-&gt;collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
196 
197     GCCauseSetter x(g1h, _gc_cause);
198 
199     // At this point we are supposed to start a concurrent cycle. We
200     // will do so if one is not already in progress.
<span class="line-modified">201     bool should_start = g1h-&gt;policy()-&gt;force_initial_mark_if_outside_cycle(_gc_cause);</span>
202 
203     if (should_start) {
204       double pause_target = g1h-&gt;policy()-&gt;max_pause_time_ms();
205       g1h-&gt;do_collection_pause_at_safepoint(pause_target);
206     }
207     return true;
208   }
209 #endif
210 
211   return false;
212 }
213 
214 void VM_CollectForMetadataAllocation::doit() {
215   SvcGCMarker sgcm(SvcGCMarker::FULL);
216 
217   CollectedHeap* heap = Universe::heap();
218   GCCauseSetter gccs(heap, _gc_cause);
219 
220   // Check again if the space is available.  Another thread
221   // may have similarly failed a metadata allocation and induced
</pre>
</td>
<td>
<hr />
<pre>
181                                                                  uint gc_count_before,
182                                                                  uint full_gc_count_before,
183                                                                  GCCause::Cause gc_cause)
184     : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before, true),
185       _result(NULL), _size(size), _mdtype(mdtype), _loader_data(loader_data) {
186   assert(_size != 0, &quot;An allocation should always be requested with this operation.&quot;);
187   AllocTracer::send_allocation_requiring_gc_event(_size * HeapWordSize, GCId::peek());
188 }
189 
190 // Returns true iff concurrent GCs unloads metadata.
191 bool VM_CollectForMetadataAllocation::initiate_concurrent_GC() {
192 #if INCLUDE_G1GC
193   if (UseG1GC &amp;&amp; ClassUnloadingWithConcurrentMark) {
194     G1CollectedHeap* g1h = G1CollectedHeap::heap();
195     g1h-&gt;policy()-&gt;collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
196 
197     GCCauseSetter x(g1h, _gc_cause);
198 
199     // At this point we are supposed to start a concurrent cycle. We
200     // will do so if one is not already in progress.
<span class="line-modified">201     bool should_start = g1h-&gt;policy()-&gt;force_concurrent_start_if_outside_cycle(_gc_cause);</span>
202 
203     if (should_start) {
204       double pause_target = g1h-&gt;policy()-&gt;max_pause_time_ms();
205       g1h-&gt;do_collection_pause_at_safepoint(pause_target);
206     }
207     return true;
208   }
209 #endif
210 
211   return false;
212 }
213 
214 void VM_CollectForMetadataAllocation::doit() {
215   SvcGCMarker sgcm(SvcGCMarker::FULL);
216 
217   CollectedHeap* heap = Universe::heap();
218   GCCauseSetter gccs(heap, _gc_cause);
219 
220   // Check again if the space is available.  Another thread
221   // may have similarly failed a metadata allocation and induced
</pre>
</td>
</tr>
</table>
<center><a href="c1/barrierSetC1.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../shenandoah/c2/shenandoahBarrierSetC2.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1IHOPControl.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1HeapSizingPolicy.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1OopClosures.inline.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1IHOPControl.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -49,11 +49,11 @@</span>
  
    // Initialize an instance with the initial IHOP value in percent. The target
    // occupancy will be updated at the first heap expansion.
    G1IHOPControl(double initial_ihop_percent);
  
<span class="udiff-line-modified-removed">-   // Most recent time from the end of the initial mark to the start of the first</span>
<span class="udiff-line-modified-added">+   // Most recent time from the end of the concurrent start to the start of the first</span>
    // mixed gc.
    virtual double last_marking_length_s() const = 0;
   public:
    virtual ~G1IHOPControl() { }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -69,22 +69,22 @@</span>
    // humongous objects that can not be used for allocation, etc.
    // Together with the target occupancy, this additional buffer should contain the
    // difference between old gen size and total heap size at the start of reclamation,
    // and space required for that reclamation.
    virtual void update_allocation_info(double allocation_time_s, size_t allocated_bytes, size_t additional_buffer_size);
<span class="udiff-line-modified-removed">-   // Update the time spent in the mutator beginning from the end of initial mark to</span>
<span class="udiff-line-modified-added">+   // Update the time spent in the mutator beginning from the end of concurrent start to</span>
    // the first mixed gc.
    virtual void update_marking_length(double marking_length_s) = 0;
  
    virtual void print();
    virtual void send_trace_event(G1NewTracer* tracer);
  };
  
  // The returned concurrent mark starting occupancy threshold is a fixed value
  // relative to the maximum heap size.
  class G1StaticIHOPControl : public G1IHOPControl {
<span class="udiff-line-modified-removed">-   // Most recent mutator time between the end of initial mark to the start of the</span>
<span class="udiff-line-modified-added">+   // Most recent mutator time between the end of concurrent mark to the start of the</span>
    // first mixed gc.
    double _last_marking_length_s;
   protected:
    double last_marking_length_s() const { return _last_marking_length_s; }
   public:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102,11 +102,11 @@</span>
  };
  
  // This algorithm tries to return a concurrent mark starting occupancy value that
  // makes sure that during marking the given target occupancy is never exceeded,
  // based on predictions of current allocation rate and time periods between
<span class="udiff-line-modified-removed">- // initial mark and the first mixed gc.</span>
<span class="udiff-line-modified-added">+ // concurrent start and the first mixed gc.</span>
  class G1AdaptiveIHOPControl : public G1IHOPControl {
    size_t _heap_reserve_percent; // Percentage of maximum heap capacity we should avoid to touch
    size_t _heap_waste_percent;   // Percentage of free heap that should be considered as waste.
  
    const G1Predictions * _predictor;
</pre>
<center><a href="g1HeapSizingPolicy.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1OopClosures.inline.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1Policy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1OopClosures.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Policy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 72,11 ***</span>
    _free_regions_at_end_of_collection(0),
    _rs_length(0),
    _rs_length_prediction(0),
    _pending_cards_at_gc_start(0),
    _old_gen_alloc_tracker(),
<span class="line-modified">!   _initial_mark_to_mixed(),</span>
    _collection_set(NULL),
    _g1h(NULL),
    _phase_times(new G1GCPhaseTimes(gc_timer, ParallelGCThreads)),
    _mark_remark_start_sec(0),
    _mark_cleanup_start_sec(0),
<span class="line-new-header">--- 72,11 ---</span>
    _free_regions_at_end_of_collection(0),
    _rs_length(0),
    _rs_length_prediction(0),
    _pending_cards_at_gc_start(0),
    _old_gen_alloc_tracker(),
<span class="line-modified">!   _concurrent_start_to_mixed(),</span>
    _collection_set(NULL),
    _g1h(NULL),
    _phase_times(new G1GCPhaseTimes(gc_timer, ParallelGCThreads)),
    _mark_remark_start_sec(0),
    _mark_cleanup_start_sec(0),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 446,11 ***</span>
    // &quot;Nuke&quot; the heuristics that control the young/mixed GC
    // transitions and make sure we start with young GCs after the Full GC.
    collector_state()-&gt;set_in_young_only_phase(true);
    collector_state()-&gt;set_in_young_gc_before_mixed(false);
    collector_state()-&gt;set_initiate_conc_mark_if_possible(need_to_start_conc_mark(&quot;end of Full GC&quot;, 0));
<span class="line-modified">!   collector_state()-&gt;set_in_initial_mark_gc(false);</span>
    collector_state()-&gt;set_mark_or_rebuild_in_progress(false);
    collector_state()-&gt;set_clearing_next_bitmap(false);
  
    _eden_surv_rate_group-&gt;start_adding_regions();
    // also call this on any additional surv rate groups
<span class="line-new-header">--- 446,11 ---</span>
    // &quot;Nuke&quot; the heuristics that control the young/mixed GC
    // transitions and make sure we start with young GCs after the Full GC.
    collector_state()-&gt;set_in_young_only_phase(true);
    collector_state()-&gt;set_in_young_gc_before_mixed(false);
    collector_state()-&gt;set_initiate_conc_mark_if_possible(need_to_start_conc_mark(&quot;end of Full GC&quot;, 0));
<span class="line-modified">!   collector_state()-&gt;set_in_concurrent_start_gc(false);</span>
    collector_state()-&gt;set_mark_or_rebuild_in_progress(false);
    collector_state()-&gt;set_clearing_next_bitmap(false);
  
    _eden_surv_rate_group-&gt;start_adding_regions();
    // also call this on any additional surv rate groups
</pre>
<hr />
<pre>
<span class="line-old-header">*** 542,11 ***</span>
    assert(_g1h-&gt;collection_set()-&gt;verify_young_ages(), &quot;region age verification failed&quot;);
  }
  
  void G1Policy::record_concurrent_mark_init_end(double mark_init_elapsed_time_ms) {
    assert(!collector_state()-&gt;initiate_conc_mark_if_possible(), &quot;we should have cleared it by now&quot;);
<span class="line-modified">!   collector_state()-&gt;set_in_initial_mark_gc(false);</span>
  }
  
  void G1Policy::record_concurrent_mark_remark_start() {
    _mark_remark_start_sec = os::elapsedTime();
  }
<span class="line-new-header">--- 542,11 ---</span>
    assert(_g1h-&gt;collection_set()-&gt;verify_young_ages(), &quot;region age verification failed&quot;);
  }
  
  void G1Policy::record_concurrent_mark_init_end(double mark_init_elapsed_time_ms) {
    assert(!collector_state()-&gt;initiate_conc_mark_if_possible(), &quot;we should have cleared it by now&quot;);
<span class="line-modified">!   collector_state()-&gt;set_in_concurrent_start_gc(false);</span>
  }
  
  void G1Policy::record_concurrent_mark_remark_start() {
    _mark_remark_start_sec = os::elapsedTime();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 630,21 ***</span>
  void G1Policy::record_collection_pause_end(double pause_time_ms) {
    G1GCPhaseTimes* p = phase_times();
  
    double end_time_sec = os::elapsedTime();
  
<span class="line-modified">!   bool this_pause_included_initial_mark = false;</span>
<span class="line-removed">-   bool this_pause_was_young_only = collector_state()-&gt;in_young_only_phase();</span>
  
    bool update_stats = !_g1h-&gt;evacuation_failed();
  
<span class="line-modified">!   record_pause(young_gc_pause_kind(), end_time_sec - pause_time_ms / 1000.0, end_time_sec);</span>
  
    _collection_pause_end_millis = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
  
<span class="line-modified">!   this_pause_included_initial_mark = collector_state()-&gt;in_initial_mark_gc();</span>
<span class="line-removed">-   if (this_pause_included_initial_mark) {</span>
      record_concurrent_mark_init_end(0.0);
    } else {
      maybe_start_marking();
    }
  
<span class="line-new-header">--- 630,19 ---</span>
  void G1Policy::record_collection_pause_end(double pause_time_ms) {
    G1GCPhaseTimes* p = phase_times();
  
    double end_time_sec = os::elapsedTime();
  
<span class="line-modified">!   PauseKind this_pause = young_gc_pause_kind();</span>
  
    bool update_stats = !_g1h-&gt;evacuation_failed();
  
<span class="line-modified">!   record_pause(this_pause, end_time_sec - pause_time_ms / 1000.0, end_time_sec);</span>
  
    _collection_pause_end_millis = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
  
<span class="line-modified">!   if (is_concurrent_start_pause(this_pause)) {</span>
      record_concurrent_mark_init_end(0.0);
    } else {
      maybe_start_marking();
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 671,27 ***</span>
  
      _analytics-&gt;compute_pause_time_ratios(end_time_sec, pause_time_ms);
      _analytics-&gt;update_recent_gc_times(end_time_sec, pause_time_ms);
    }
  
<span class="line-modified">!   if (collector_state()-&gt;in_young_gc_before_mixed()) {</span>
<span class="line-modified">!     assert(!this_pause_included_initial_mark, &quot;The young GC before mixed is not allowed to be an initial mark GC&quot;);</span>
      // This has been the young GC before we start doing mixed GCs. We already
      // decided to start mixed GCs much earlier, so there is nothing to do except
      // advancing the state.
      collector_state()-&gt;set_in_young_only_phase(false);
      collector_state()-&gt;set_in_young_gc_before_mixed(false);
<span class="line-modified">!   } else if (!this_pause_was_young_only) {</span>
      // This is a mixed GC. Here we decide whether to continue doing more
      // mixed GCs or not.
      if (!next_gc_should_be_mixed(&quot;continue mixed GCs&quot;,
                                   &quot;do not continue mixed GCs&quot;)) {
        collector_state()-&gt;set_in_young_only_phase(true);
  
        clear_collection_set_candidates();
        maybe_start_marking();
      }
    }
  
    _eden_surv_rate_group-&gt;start_adding_regions();
  
    double merge_hcc_time_ms = average_time_ms(G1GCPhaseTimes::MergeHCC);
<span class="line-new-header">--- 669,30 ---</span>
  
      _analytics-&gt;compute_pause_time_ratios(end_time_sec, pause_time_ms);
      _analytics-&gt;update_recent_gc_times(end_time_sec, pause_time_ms);
    }
  
<span class="line-modified">!   if (is_last_young_pause(this_pause)) {</span>
<span class="line-modified">!     assert(!is_concurrent_start_pause(this_pause),</span>
<span class="line-added">+            &quot;The young GC before mixed is not allowed to be concurrent start GC&quot;);</span>
      // This has been the young GC before we start doing mixed GCs. We already
      // decided to start mixed GCs much earlier, so there is nothing to do except
      // advancing the state.
      collector_state()-&gt;set_in_young_only_phase(false);
      collector_state()-&gt;set_in_young_gc_before_mixed(false);
<span class="line-modified">!   } else if (is_mixed_pause(this_pause)) {</span>
      // This is a mixed GC. Here we decide whether to continue doing more
      // mixed GCs or not.
      if (!next_gc_should_be_mixed(&quot;continue mixed GCs&quot;,
                                   &quot;do not continue mixed GCs&quot;)) {
        collector_state()-&gt;set_in_young_only_phase(true);
  
        clear_collection_set_candidates();
        maybe_start_marking();
      }
<span class="line-added">+   } else {</span>
<span class="line-added">+     assert(is_young_only_pause(this_pause), &quot;must be&quot;);</span>
    }
  
    _eden_surv_rate_group-&gt;start_adding_regions();
  
    double merge_hcc_time_ms = average_time_ms(G1GCPhaseTimes::MergeHCC);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 711,22 ***</span>
        double avg_time_merge_cards = average_time_ms(G1GCPhaseTimes::MergeER) +
                                      average_time_ms(G1GCPhaseTimes::MergeRS) +
                                      average_time_ms(G1GCPhaseTimes::MergeHCC) +
                                      average_time_ms(G1GCPhaseTimes::MergeLB) +
                                      average_time_ms(G1GCPhaseTimes::OptMergeRS);
<span class="line-modified">!       _analytics-&gt;report_cost_per_card_merge_ms(avg_time_merge_cards / total_cards_merged, this_pause_was_young_only);</span>
      }
  
      // Update prediction for card scan
      size_t const total_cards_scanned = p-&gt;sum_thread_work_items(G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::ScanHRScannedCards) +
                                         p-&gt;sum_thread_work_items(G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::ScanHRScannedCards);
  
      if (total_cards_scanned &gt; CardsNumSamplingThreshold) {
        double avg_time_dirty_card_scan = average_time_ms(G1GCPhaseTimes::ScanHR) +
                                          average_time_ms(G1GCPhaseTimes::OptScanHR);
  
<span class="line-modified">!       _analytics-&gt;report_cost_per_card_scan_ms(avg_time_dirty_card_scan / total_cards_scanned, this_pause_was_young_only);</span>
      }
  
      // Update prediction for the ratio between cards from the remembered
      // sets and actually scanned cards from the remembered sets.
      // Cards from the remembered sets are all cards not duplicated by cards from
<span class="line-new-header">--- 712,24 ---</span>
        double avg_time_merge_cards = average_time_ms(G1GCPhaseTimes::MergeER) +
                                      average_time_ms(G1GCPhaseTimes::MergeRS) +
                                      average_time_ms(G1GCPhaseTimes::MergeHCC) +
                                      average_time_ms(G1GCPhaseTimes::MergeLB) +
                                      average_time_ms(G1GCPhaseTimes::OptMergeRS);
<span class="line-modified">!       _analytics-&gt;report_cost_per_card_merge_ms(avg_time_merge_cards / total_cards_merged,</span>
<span class="line-added">+                                                 is_young_only_pause(this_pause));</span>
      }
  
      // Update prediction for card scan
      size_t const total_cards_scanned = p-&gt;sum_thread_work_items(G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::ScanHRScannedCards) +
                                         p-&gt;sum_thread_work_items(G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::ScanHRScannedCards);
  
      if (total_cards_scanned &gt; CardsNumSamplingThreshold) {
        double avg_time_dirty_card_scan = average_time_ms(G1GCPhaseTimes::ScanHR) +
                                          average_time_ms(G1GCPhaseTimes::OptScanHR);
  
<span class="line-modified">!       _analytics-&gt;report_cost_per_card_scan_ms(avg_time_dirty_card_scan / total_cards_scanned,</span>
<span class="line-added">+                                                is_young_only_pause(this_pause));</span>
      }
  
      // Update prediction for the ratio between cards from the remembered
      // sets and actually scanned cards from the remembered sets.
      // Cards from the remembered sets are all cards not duplicated by cards from
</pre>
<hr />
<pre>
<span class="line-old-header">*** 736,11 ***</span>
      const size_t from_rs_length_cards = (total_cards_scanned &gt; total_log_buffer_cards) ? total_cards_scanned - total_log_buffer_cards : 0;
      double merge_to_scan_ratio = 0.0;
      if (total_cards_scanned &gt; 0) {
        merge_to_scan_ratio = (double) from_rs_length_cards / total_cards_scanned;
      }
<span class="line-modified">!     _analytics-&gt;report_card_merge_to_scan_ratio(merge_to_scan_ratio, this_pause_was_young_only);</span>
  
      const size_t recorded_rs_length = _collection_set-&gt;recorded_rs_length();
      const size_t rs_length_diff = _rs_length &gt; recorded_rs_length ? _rs_length - recorded_rs_length : 0;
      _analytics-&gt;report_rs_length_diff(rs_length_diff);
  
<span class="line-new-header">--- 739,12 ---</span>
      const size_t from_rs_length_cards = (total_cards_scanned &gt; total_log_buffer_cards) ? total_cards_scanned - total_log_buffer_cards : 0;
      double merge_to_scan_ratio = 0.0;
      if (total_cards_scanned &gt; 0) {
        merge_to_scan_ratio = (double) from_rs_length_cards / total_cards_scanned;
      }
<span class="line-modified">!     _analytics-&gt;report_card_merge_to_scan_ratio(merge_to_scan_ratio,</span>
<span class="line-added">+                                                 is_young_only_pause(this_pause));</span>
  
      const size_t recorded_rs_length = _collection_set-&gt;recorded_rs_length();
      const size_t rs_length_diff = _rs_length &gt; recorded_rs_length ? _rs_length - recorded_rs_length : 0;
      _analytics-&gt;report_rs_length_diff(rs_length_diff);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 766,19 ***</span>
  
      // Do not update RS lengths and the number of pending cards with information from mixed gc:
      // these are is wildly different to during young only gc and mess up young gen sizing right
      // after the mixed gc phase.
      // During mixed gc we do not use them for young gen sizing.
<span class="line-modified">!     if (this_pause_was_young_only) {</span>
        _analytics-&gt;report_pending_cards((double) _pending_cards_at_gc_start);
        _analytics-&gt;report_rs_length((double) _rs_length);
      }
    }
  
<span class="line-modified">!   assert(!(this_pause_included_initial_mark &amp;&amp; collector_state()-&gt;mark_or_rebuild_in_progress()),</span>
<span class="line-modified">!          &quot;If the last pause has been an initial mark, we should not have been in the marking window&quot;);</span>
<span class="line-modified">!   if (this_pause_included_initial_mark) {</span>
      collector_state()-&gt;set_mark_or_rebuild_in_progress(true);
    }
  
    _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
  
<span class="line-new-header">--- 770,19 ---</span>
  
      // Do not update RS lengths and the number of pending cards with information from mixed gc:
      // these are is wildly different to during young only gc and mess up young gen sizing right
      // after the mixed gc phase.
      // During mixed gc we do not use them for young gen sizing.
<span class="line-modified">!     if (is_young_only_pause(this_pause)) {</span>
        _analytics-&gt;report_pending_cards((double) _pending_cards_at_gc_start);
        _analytics-&gt;report_rs_length((double) _rs_length);
      }
    }
  
<span class="line-modified">!   assert(!(is_concurrent_start_pause(this_pause) &amp;&amp; collector_state()-&gt;mark_or_rebuild_in_progress()),</span>
<span class="line-modified">!          &quot;If the last pause has been concurrent start, we should not have been in the marking window&quot;);</span>
<span class="line-modified">!   if (is_concurrent_start_pause(this_pause)) {</span>
      collector_state()-&gt;set_mark_or_rebuild_in_progress(true);
    }
  
    _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 795,21 ***</span>
  
      _old_gen_alloc_tracker.reset_after_young_gc(app_time_ms / 1000.0);
      update_ihop_prediction(_old_gen_alloc_tracker.last_cycle_duration(),
                             _old_gen_alloc_tracker.last_cycle_old_bytes(),
                             last_unrestrained_young_length * HeapRegion::GrainBytes,
<span class="line-modified">!                            this_pause_was_young_only);</span>
  
      _ihop_control-&gt;send_trace_event(_g1h-&gt;gc_tracer_stw());
    } else {
      // Any garbage collection triggered as periodic collection resets the time-to-mixed
      // measurement. Periodic collection typically means that the application is &quot;inactive&quot;, i.e.
      // the marking threads may have received an uncharacterisic amount of cpu time
      // for completing the marking, i.e. are faster than expected.
      // This skews the predicted marking length towards smaller values which might cause
      // the mark start being too late.
<span class="line-modified">!     _initial_mark_to_mixed.reset();</span>
    }
  
    // Note that _mmu_tracker-&gt;max_gc_time() returns the time in seconds.
    double scan_logged_cards_time_goal_ms = _mmu_tracker-&gt;max_gc_time() * MILLIUNITS * G1RSetUpdatingPauseTimePercent / 100.0;
  
<span class="line-new-header">--- 799,21 ---</span>
  
      _old_gen_alloc_tracker.reset_after_young_gc(app_time_ms / 1000.0);
      update_ihop_prediction(_old_gen_alloc_tracker.last_cycle_duration(),
                             _old_gen_alloc_tracker.last_cycle_old_bytes(),
                             last_unrestrained_young_length * HeapRegion::GrainBytes,
<span class="line-modified">!                            is_young_only_pause(this_pause));</span>
  
      _ihop_control-&gt;send_trace_event(_g1h-&gt;gc_tracer_stw());
    } else {
      // Any garbage collection triggered as periodic collection resets the time-to-mixed
      // measurement. Periodic collection typically means that the application is &quot;inactive&quot;, i.e.
      // the marking threads may have received an uncharacterisic amount of cpu time
      // for completing the marking, i.e. are faster than expected.
      // This skews the predicted marking length towards smaller values which might cause
      // the mark start being too late.
<span class="line-modified">!     _concurrent_start_to_mixed.reset();</span>
    }
  
    // Note that _mmu_tracker-&gt;max_gc_time() returns the time in seconds.
    double scan_logged_cards_time_goal_ms = _mmu_tracker-&gt;max_gc_time() * MILLIUNITS * G1RSetUpdatingPauseTimePercent / 100.0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 856,14 ***</span>
    double const min_valid_time = 1e-6;
  
    bool report = false;
  
    double marking_to_mixed_time = -1.0;
<span class="line-modified">!   if (!this_gc_was_young_only &amp;&amp; _initial_mark_to_mixed.has_result()) {</span>
<span class="line-modified">!     marking_to_mixed_time = _initial_mark_to_mixed.last_marking_time();</span>
      assert(marking_to_mixed_time &gt; 0.0,
<span class="line-modified">!            &quot;Initial mark to mixed time must be larger than zero but is %.3f&quot;,</span>
             marking_to_mixed_time);
      if (marking_to_mixed_time &gt; min_valid_time) {
        _ihop_control-&gt;update_marking_length(marking_to_mixed_time);
        report = true;
      }
<span class="line-new-header">--- 860,14 ---</span>
    double const min_valid_time = 1e-6;
  
    bool report = false;
  
    double marking_to_mixed_time = -1.0;
<span class="line-modified">!   if (!this_gc_was_young_only &amp;&amp; _concurrent_start_to_mixed.has_result()) {</span>
<span class="line-modified">!     marking_to_mixed_time = _concurrent_start_to_mixed.last_marking_time();</span>
      assert(marking_to_mixed_time &gt; 0.0,
<span class="line-modified">!            &quot;Concurrent start to mixed time must be larger than zero but is %.3f&quot;,</span>
             marking_to_mixed_time);
      if (marking_to_mixed_time &gt; min_valid_time) {
        _ihop_control-&gt;update_marking_length(marking_to_mixed_time);
        report = true;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1015,39 ***</span>
    // be allocated into.
    _max_survivor_regions = MIN2(desired_max_survivor_regions,
                                 _g1h-&gt;num_free_or_available_regions());
  }
  
<span class="line-modified">! bool G1Policy::force_initial_mark_if_outside_cycle(GCCause::Cause gc_cause) {</span>
    // We actually check whether we are marking here and not if we are in a
    // reclamation phase. This means that we will schedule a concurrent mark
    // even while we are still in the process of reclaiming memory.
    bool during_cycle = _g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
    if (!during_cycle) {
<span class="line-modified">!     log_debug(gc, ergo)(&quot;Request concurrent cycle initiation (requested by GC cause). GC cause: %s&quot;, GCCause::to_string(gc_cause));</span>
      collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
      return true;
    } else {
<span class="line-modified">!     log_debug(gc, ergo)(&quot;Do not request concurrent cycle initiation (concurrent cycle already in progress). GC cause: %s&quot;, GCCause::to_string(gc_cause));</span>
      return false;
    }
  }
  
  void G1Policy::initiate_conc_mark() {
<span class="line-modified">!   collector_state()-&gt;set_in_initial_mark_gc(true);</span>
    collector_state()-&gt;set_initiate_conc_mark_if_possible(false);
  }
  
  void G1Policy::decide_on_conc_mark_initiation() {
<span class="line-modified">!   // We are about to decide on whether this pause will be an</span>
<span class="line-modified">!   // initial-mark pause.</span>
  
<span class="line-modified">!   // First, collector_state()-&gt;in_initial_mark_gc() should not be already set. We</span>
    // will set it here if we have to. However, it should be cleared by
<span class="line-modified">!   // the end of the pause (it&#39;s only set for the duration of an</span>
<span class="line-modified">!   // initial-mark pause).</span>
<span class="line-modified">!   assert(!collector_state()-&gt;in_initial_mark_gc(), &quot;pre-condition&quot;);</span>
  
    if (collector_state()-&gt;initiate_conc_mark_if_possible()) {
      // We had noticed on a previous pause that the heap occupancy has
      // gone over the initiating threshold and we should start a
      // concurrent marking cycle.  Or we&#39;ve been explicitly requested
<span class="line-new-header">--- 1019,43 ---</span>
    // be allocated into.
    _max_survivor_regions = MIN2(desired_max_survivor_regions,
                                 _g1h-&gt;num_free_or_available_regions());
  }
  
<span class="line-modified">! bool G1Policy::force_concurrent_start_if_outside_cycle(GCCause::Cause gc_cause) {</span>
    // We actually check whether we are marking here and not if we are in a
    // reclamation phase. This means that we will schedule a concurrent mark
    // even while we are still in the process of reclaiming memory.
    bool during_cycle = _g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
    if (!during_cycle) {
<span class="line-modified">!     log_debug(gc, ergo)(&quot;Request concurrent cycle initiation (requested by GC cause). &quot;</span>
<span class="line-added">+                         &quot;GC cause: %s&quot;,</span>
<span class="line-added">+                         GCCause::to_string(gc_cause));</span>
      collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
      return true;
    } else {
<span class="line-modified">!     log_debug(gc, ergo)(&quot;Do not request concurrent cycle initiation &quot;</span>
<span class="line-added">+                         &quot;(concurrent cycle already in progress). GC cause: %s&quot;,</span>
<span class="line-added">+                         GCCause::to_string(gc_cause));</span>
      return false;
    }
  }
  
  void G1Policy::initiate_conc_mark() {
<span class="line-modified">!   collector_state()-&gt;set_in_concurrent_start_gc(true);</span>
    collector_state()-&gt;set_initiate_conc_mark_if_possible(false);
  }
  
  void G1Policy::decide_on_conc_mark_initiation() {
<span class="line-modified">!   // We are about to decide on whether this pause will be a</span>
<span class="line-modified">!   // concurrent start pause.</span>
  
<span class="line-modified">!   // First, collector_state()-&gt;in_concurrent_start_gc() should not be already set. We</span>
    // will set it here if we have to. However, it should be cleared by
<span class="line-modified">!   // the end of the pause (it&#39;s only set for the duration of a</span>
<span class="line-modified">!   // concurrent start pause).</span>
<span class="line-modified">!   assert(!collector_state()-&gt;in_concurrent_start_gc(), &quot;pre-condition&quot;);</span>
  
    if (collector_state()-&gt;initiate_conc_mark_if_possible()) {
      // We had noticed on a previous pause that the heap occupancy has
      // gone over the initiating threshold and we should start a
      // concurrent marking cycle.  Or we&#39;ve been explicitly requested
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1057,17 ***</span>
      GCCause::Cause cause = _g1h-&gt;gc_cause();
      if ((cause != GCCause::_wb_breakpoint) &amp;&amp;
          ConcurrentGCBreakpoints::is_controlled()) {
        log_debug(gc, ergo)(&quot;Do not initiate concurrent cycle (whitebox controlled)&quot;);
      } else if (!about_to_start_mixed_phase() &amp;&amp; collector_state()-&gt;in_young_only_phase()) {
<span class="line-modified">!       // Initiate a new initial mark if there is no marking or reclamation going on.</span>
        initiate_conc_mark();
        log_debug(gc, ergo)(&quot;Initiate concurrent cycle (concurrent cycle initiation requested)&quot;);
      } else if (_g1h-&gt;is_user_requested_concurrent_full_gc(cause) ||
                 (cause == GCCause::_wb_breakpoint)) {
<span class="line-modified">!       // Initiate a user requested initial mark or run_to a breakpoint.</span>
<span class="line-modified">!       // An initial mark must be young only GC, so the collector state</span>
        // must be updated to reflect this.
        collector_state()-&gt;set_in_young_only_phase(true);
        collector_state()-&gt;set_in_young_gc_before_mixed(false);
  
        // We might have ended up coming here about to start a mixed phase with a collection set
<span class="line-new-header">--- 1065,17 ---</span>
      GCCause::Cause cause = _g1h-&gt;gc_cause();
      if ((cause != GCCause::_wb_breakpoint) &amp;&amp;
          ConcurrentGCBreakpoints::is_controlled()) {
        log_debug(gc, ergo)(&quot;Do not initiate concurrent cycle (whitebox controlled)&quot;);
      } else if (!about_to_start_mixed_phase() &amp;&amp; collector_state()-&gt;in_young_only_phase()) {
<span class="line-modified">!       // Initiate a new concurrent start if there is no marking or reclamation going on.</span>
        initiate_conc_mark();
        log_debug(gc, ergo)(&quot;Initiate concurrent cycle (concurrent cycle initiation requested)&quot;);
      } else if (_g1h-&gt;is_user_requested_concurrent_full_gc(cause) ||
                 (cause == GCCause::_wb_breakpoint)) {
<span class="line-modified">!       // Initiate a user requested concurrent start or run to a breakpoint.</span>
<span class="line-modified">!       // A concurrent start must be young only GC, so the collector state</span>
        // must be updated to reflect this.
        collector_state()-&gt;set_in_young_only_phase(true);
        collector_state()-&gt;set_in_young_gc_before_mixed(false);
  
        // We might have ended up coming here about to start a mixed phase with a collection set
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1143,60 ***</span>
      // this pause we decided to postpone it. That&#39;s OK.
      collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
    }
  }
  
  G1Policy::PauseKind G1Policy::young_gc_pause_kind() const {
    assert(!collector_state()-&gt;in_full_gc(), &quot;must be&quot;);
<span class="line-modified">!   if (collector_state()-&gt;in_initial_mark_gc()) {</span>
      assert(!collector_state()-&gt;in_young_gc_before_mixed(), &quot;must be&quot;);
<span class="line-modified">!     return InitialMarkGC;</span>
    } else if (collector_state()-&gt;in_young_gc_before_mixed()) {
<span class="line-modified">!     assert(!collector_state()-&gt;in_initial_mark_gc(), &quot;must be&quot;);</span>
      return LastYoungGC;
    } else if (collector_state()-&gt;in_mixed_phase()) {
<span class="line-modified">!     assert(!collector_state()-&gt;in_initial_mark_gc(), &quot;must be&quot;);</span>
      assert(!collector_state()-&gt;in_young_gc_before_mixed(), &quot;must be&quot;);
      return MixedGC;
    } else {
<span class="line-modified">!     assert(!collector_state()-&gt;in_initial_mark_gc(), &quot;must be&quot;);</span>
      assert(!collector_state()-&gt;in_young_gc_before_mixed(), &quot;must be&quot;);
      return YoungOnlyGC;
    }
  }
  
  void G1Policy::record_pause(PauseKind kind, double start, double end) {
    // Manage the MMU tracker. For some reason it ignores Full GCs.
    if (kind != FullGC) {
      _mmu_tracker-&gt;add_pause(start, end);
    }
<span class="line-modified">!   // Manage the mutator time tracking from initial mark to first mixed gc.</span>
    switch (kind) {
      case FullGC:
        abort_time_to_mixed_tracking();
        break;
      case Cleanup:
      case Remark:
      case YoungOnlyGC:
      case LastYoungGC:
<span class="line-modified">!       _initial_mark_to_mixed.add_pause(end - start);</span>
        break;
<span class="line-modified">!     case InitialMarkGC:</span>
        if (_g1h-&gt;gc_cause() != GCCause::_g1_periodic_collection) {
<span class="line-modified">!         _initial_mark_to_mixed.record_initial_mark_end(end);</span>
        }
        break;
      case MixedGC:
<span class="line-modified">!       _initial_mark_to_mixed.record_mixed_gc_start(start);</span>
        break;
      default:
        ShouldNotReachHere();
    }
  }
  
  void G1Policy::abort_time_to_mixed_tracking() {
<span class="line-modified">!   _initial_mark_to_mixed.reset();</span>
  }
  
  bool G1Policy::next_gc_should_be_mixed(const char* true_action_str,
                                         const char* false_action_str) const {
    G1CollectionSetCandidates* candidates = _collection_set-&gt;candidates();
<span class="line-new-header">--- 1151,82 ---</span>
      // this pause we decided to postpone it. That&#39;s OK.
      collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
    }
  }
  
<span class="line-added">+ bool G1Policy::is_young_only_pause(PauseKind kind) {</span>
<span class="line-added">+   assert(kind != FullGC, &quot;must be&quot;);</span>
<span class="line-added">+   assert(kind != Remark, &quot;must be&quot;);</span>
<span class="line-added">+   assert(kind != Cleanup, &quot;must be&quot;);</span>
<span class="line-added">+   return kind == ConcurrentStartGC || kind == LastYoungGC || kind == YoungOnlyGC;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool G1Policy::is_mixed_pause(PauseKind kind) {</span>
<span class="line-added">+   assert(kind != FullGC, &quot;must be&quot;);</span>
<span class="line-added">+   assert(kind != Remark, &quot;must be&quot;);</span>
<span class="line-added">+   assert(kind != Cleanup, &quot;must be&quot;);</span>
<span class="line-added">+   return kind == MixedGC;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool G1Policy::is_last_young_pause(PauseKind kind) {</span>
<span class="line-added">+   return kind == LastYoungGC;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool G1Policy::is_concurrent_start_pause(PauseKind kind) {</span>
<span class="line-added">+   return kind == ConcurrentStartGC;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  G1Policy::PauseKind G1Policy::young_gc_pause_kind() const {
    assert(!collector_state()-&gt;in_full_gc(), &quot;must be&quot;);
<span class="line-modified">!   if (collector_state()-&gt;in_concurrent_start_gc()) {</span>
      assert(!collector_state()-&gt;in_young_gc_before_mixed(), &quot;must be&quot;);
<span class="line-modified">!     return ConcurrentStartGC;</span>
    } else if (collector_state()-&gt;in_young_gc_before_mixed()) {
<span class="line-modified">!     assert(!collector_state()-&gt;in_concurrent_start_gc(), &quot;must be&quot;);</span>
      return LastYoungGC;
    } else if (collector_state()-&gt;in_mixed_phase()) {
<span class="line-modified">!     assert(!collector_state()-&gt;in_concurrent_start_gc(), &quot;must be&quot;);</span>
      assert(!collector_state()-&gt;in_young_gc_before_mixed(), &quot;must be&quot;);
      return MixedGC;
    } else {
<span class="line-modified">!     assert(!collector_state()-&gt;in_concurrent_start_gc(), &quot;must be&quot;);</span>
      assert(!collector_state()-&gt;in_young_gc_before_mixed(), &quot;must be&quot;);
      return YoungOnlyGC;
    }
  }
  
  void G1Policy::record_pause(PauseKind kind, double start, double end) {
    // Manage the MMU tracker. For some reason it ignores Full GCs.
    if (kind != FullGC) {
      _mmu_tracker-&gt;add_pause(start, end);
    }
<span class="line-modified">!   // Manage the mutator time tracking from concurrent start to first mixed gc.</span>
    switch (kind) {
      case FullGC:
        abort_time_to_mixed_tracking();
        break;
      case Cleanup:
      case Remark:
      case YoungOnlyGC:
      case LastYoungGC:
<span class="line-modified">!       _concurrent_start_to_mixed.add_pause(end - start);</span>
        break;
<span class="line-modified">!     case ConcurrentStartGC:</span>
        if (_g1h-&gt;gc_cause() != GCCause::_g1_periodic_collection) {
<span class="line-modified">!         _concurrent_start_to_mixed.record_concurrent_start_end(end);</span>
        }
        break;
      case MixedGC:
<span class="line-modified">!       _concurrent_start_to_mixed.record_mixed_gc_start(start);</span>
        break;
      default:
        ShouldNotReachHere();
    }
  }
  
  void G1Policy::abort_time_to_mixed_tracking() {
<span class="line-modified">!   _concurrent_start_to_mixed.reset();</span>
  }
  
  bool G1Policy::next_gc_should_be_mixed(const char* true_action_str,
                                         const char* false_action_str) const {
    G1CollectionSetCandidates* candidates = _collection_set-&gt;candidates();
</pre>
<center><a href="g1OopClosures.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
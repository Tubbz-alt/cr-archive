<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1_globals.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1YCTypes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegion.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1_globals.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35                     develop_pd,                                             \
 36                     product,                                                \
 37                     product_pd,                                             \
 38                     diagnostic,                                             \
 39                     diagnostic_pd,                                          \
 40                     experimental,                                           \
 41                     notproduct,                                             \
 42                     manageable,                                             \
 43                     product_rw,                                             \
 44                     lp64_product,                                           \
 45                     range,                                                  \
 46                     constraint)                                             \
 47                                                                             \
 48   product(bool, G1UseAdaptiveIHOP, true,                                    \
 49           &quot;Adaptively adjust the initiating heap occupancy from the &quot;       \
 50           &quot;initial value of InitiatingHeapOccupancyPercent. The policy &quot;    \
 51           &quot;attempts to start marking in time based on application &quot;         \
 52           &quot;behavior.&quot;)                                                      \
 53                                                                             \
 54   experimental(size_t, G1AdaptiveIHOPNumInitialSamples, 3,                  \
<span class="line-modified"> 55           &quot;How many completed time periods from initial mark to first &quot;     \</span>
 56           &quot;mixed gc are required to use the input values for prediction &quot;   \
 57           &quot;of the optimal occupancy to start marking.&quot;)                     \
 58           range(1, max_intx)                                                \
 59                                                                             \
 60   product(uintx, G1ConfidencePercent, 50,                                   \
 61           &quot;Confidence level for MMU/pause predictions&quot;)                     \
 62           range(0, 100)                                                     \
 63                                                                             \
 64   diagnostic(intx, G1SummarizeRSetStatsPeriod, 0,                           \
 65           &quot;The period (in number of GCs) at which we will generate &quot;        \
 66           &quot;update buffer processing info &quot;                                  \
 67           &quot;(0 means do not periodically generate this info); &quot;              \
 68           &quot;it also requires that logging is enabled on the trace&quot;           \
 69           &quot;level for gc+remset&quot;)                                            \
 70           range(0, max_intx)                                                \
 71                                                                             \
 72   product(double, G1ConcMarkStepDurationMillis, 10.0,                       \
 73           &quot;Target duration of individual concurrent marking steps &quot;         \
 74           &quot;in milliseconds.&quot;)                                               \
 75           range(1.0, DBL_MAX)                                               \
</pre>
<hr />
<pre>
254           &quot;An upper bound for the number of old CSet regions expressed &quot;    \
255           &quot;as a percentage of the heap size.&quot;)                              \
256           range(0, 100)                                                     \
257                                                                             \
258   notproduct(bool, G1EvacuationFailureALot, false,                          \
259           &quot;Force use of evacuation failure handling during certain &quot;        \
260           &quot;evacuation pauses&quot;)                                              \
261                                                                             \
262   develop(uintx, G1EvacuationFailureALotCount, 1000,                        \
263           &quot;Number of successful evacuations between evacuation failures &quot;   \
264           &quot;occurring at object copying&quot;)                                    \
265                                                                             \
266   develop(uintx, G1EvacuationFailureALotInterval, 5,                        \
267           &quot;Total collections between forced triggering of evacuation &quot;      \
268           &quot;failures&quot;)                                                       \
269                                                                             \
270   develop(bool, G1EvacuationFailureALotDuringConcMark, true,                \
271           &quot;Force use of evacuation failure handling during evacuation &quot;     \
272           &quot;pauses when marking is in progress&quot;)                             \
273                                                                             \
<span class="line-modified">274   develop(bool, G1EvacuationFailureALotDuringInitialMark, true,             \</span>
<span class="line-modified">275           &quot;Force use of evacuation failure handling during initial mark &quot;   \</span>
<span class="line-modified">276           &quot;evacuation pauses&quot;)                                              \</span>
277                                                                             \
278   develop(bool, G1EvacuationFailureALotDuringYoungGC, true,                 \
279           &quot;Force use of evacuation failure handling during young &quot;          \
280           &quot;evacuation pauses&quot;)                                              \
281                                                                             \
282   develop(bool, G1EvacuationFailureALotDuringMixedGC, true,                 \
283           &quot;Force use of evacuation failure handling during mixed &quot;          \
284           &quot;evacuation pauses&quot;)                                              \
285                                                                             \
286   diagnostic(bool, G1VerifyRSetsDuringFullGC, false,                        \
287           &quot;If true, perform verification of each heap region&#39;s &quot;            \
288           &quot;remembered set when verifying the heap during a full GC.&quot;)       \
289                                                                             \
290   diagnostic(bool, G1VerifyHeapRegionCodeRoots, false,                      \
291           &quot;Verify the code root lists attached to each heap region.&quot;)       \
292                                                                             \
293   develop(bool, G1VerifyBitmaps, false,                                     \
294           &quot;Verifies the consistency of the marking bitmaps&quot;)                \
295                                                                             \
296   manageable(uintx, G1PeriodicGCInterval, 0,                                \
</pre>
</td>
<td>
<hr />
<pre>
 35                     develop_pd,                                             \
 36                     product,                                                \
 37                     product_pd,                                             \
 38                     diagnostic,                                             \
 39                     diagnostic_pd,                                          \
 40                     experimental,                                           \
 41                     notproduct,                                             \
 42                     manageable,                                             \
 43                     product_rw,                                             \
 44                     lp64_product,                                           \
 45                     range,                                                  \
 46                     constraint)                                             \
 47                                                                             \
 48   product(bool, G1UseAdaptiveIHOP, true,                                    \
 49           &quot;Adaptively adjust the initiating heap occupancy from the &quot;       \
 50           &quot;initial value of InitiatingHeapOccupancyPercent. The policy &quot;    \
 51           &quot;attempts to start marking in time based on application &quot;         \
 52           &quot;behavior.&quot;)                                                      \
 53                                                                             \
 54   experimental(size_t, G1AdaptiveIHOPNumInitialSamples, 3,                  \
<span class="line-modified"> 55           &quot;How many completed time periods from concurrent start to first &quot; \</span>
 56           &quot;mixed gc are required to use the input values for prediction &quot;   \
 57           &quot;of the optimal occupancy to start marking.&quot;)                     \
 58           range(1, max_intx)                                                \
 59                                                                             \
 60   product(uintx, G1ConfidencePercent, 50,                                   \
 61           &quot;Confidence level for MMU/pause predictions&quot;)                     \
 62           range(0, 100)                                                     \
 63                                                                             \
 64   diagnostic(intx, G1SummarizeRSetStatsPeriod, 0,                           \
 65           &quot;The period (in number of GCs) at which we will generate &quot;        \
 66           &quot;update buffer processing info &quot;                                  \
 67           &quot;(0 means do not periodically generate this info); &quot;              \
 68           &quot;it also requires that logging is enabled on the trace&quot;           \
 69           &quot;level for gc+remset&quot;)                                            \
 70           range(0, max_intx)                                                \
 71                                                                             \
 72   product(double, G1ConcMarkStepDurationMillis, 10.0,                       \
 73           &quot;Target duration of individual concurrent marking steps &quot;         \
 74           &quot;in milliseconds.&quot;)                                               \
 75           range(1.0, DBL_MAX)                                               \
</pre>
<hr />
<pre>
254           &quot;An upper bound for the number of old CSet regions expressed &quot;    \
255           &quot;as a percentage of the heap size.&quot;)                              \
256           range(0, 100)                                                     \
257                                                                             \
258   notproduct(bool, G1EvacuationFailureALot, false,                          \
259           &quot;Force use of evacuation failure handling during certain &quot;        \
260           &quot;evacuation pauses&quot;)                                              \
261                                                                             \
262   develop(uintx, G1EvacuationFailureALotCount, 1000,                        \
263           &quot;Number of successful evacuations between evacuation failures &quot;   \
264           &quot;occurring at object copying&quot;)                                    \
265                                                                             \
266   develop(uintx, G1EvacuationFailureALotInterval, 5,                        \
267           &quot;Total collections between forced triggering of evacuation &quot;      \
268           &quot;failures&quot;)                                                       \
269                                                                             \
270   develop(bool, G1EvacuationFailureALotDuringConcMark, true,                \
271           &quot;Force use of evacuation failure handling during evacuation &quot;     \
272           &quot;pauses when marking is in progress&quot;)                             \
273                                                                             \
<span class="line-modified">274   develop(bool, G1EvacuationFailureALotDuringConcurrentStart, true,         \</span>
<span class="line-modified">275           &quot;Force use of evacuation failure handling during concurrent &quot;     \</span>
<span class="line-modified">276           &quot;start evacuation pauses&quot;)                                        \</span>
277                                                                             \
278   develop(bool, G1EvacuationFailureALotDuringYoungGC, true,                 \
279           &quot;Force use of evacuation failure handling during young &quot;          \
280           &quot;evacuation pauses&quot;)                                              \
281                                                                             \
282   develop(bool, G1EvacuationFailureALotDuringMixedGC, true,                 \
283           &quot;Force use of evacuation failure handling during mixed &quot;          \
284           &quot;evacuation pauses&quot;)                                              \
285                                                                             \
286   diagnostic(bool, G1VerifyRSetsDuringFullGC, false,                        \
287           &quot;If true, perform verification of each heap region&#39;s &quot;            \
288           &quot;remembered set when verifying the heap during a full GC.&quot;)       \
289                                                                             \
290   diagnostic(bool, G1VerifyHeapRegionCodeRoots, false,                      \
291           &quot;Verify the code root lists attached to each heap region.&quot;)       \
292                                                                             \
293   develop(bool, G1VerifyBitmaps, false,                                     \
294           &quot;Verifies the consistency of the marking bitmaps&quot;)                \
295                                                                             \
296   manageable(uintx, G1PeriodicGCInterval, 0,                                \
</pre>
</td>
</tr>
</table>
<center><a href="g1YCTypes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegion.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
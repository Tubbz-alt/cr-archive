<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1Policy.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1Policy.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1RootClosures.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Policy.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,13 ***</span>
  
  #ifndef SHARE_GC_G1_G1POLICY_HPP
  #define SHARE_GC_G1_G1POLICY_HPP
  
  #include &quot;gc/g1/g1CollectorState.hpp&quot;
  #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
  #include &quot;gc/g1/g1HeapRegionAttr.hpp&quot;
<span class="line-removed">- #include &quot;gc/g1/g1InitialMarkToMixedTimeTracker.hpp&quot;</span>
  #include &quot;gc/g1/g1MMUTracker.hpp&quot;
  #include &quot;gc/g1/g1OldGenAllocationTracker.hpp&quot;
  #include &quot;gc/g1/g1RemSetTrackingPolicy.hpp&quot;
  #include &quot;gc/g1/g1Predictions.hpp&quot;
  #include &quot;gc/g1/g1YoungGenSizer.hpp&quot;
<span class="line-new-header">--- 24,13 ---</span>
  
  #ifndef SHARE_GC_G1_G1POLICY_HPP
  #define SHARE_GC_G1_G1POLICY_HPP
  
  #include &quot;gc/g1/g1CollectorState.hpp&quot;
<span class="line-added">+ #include &quot;gc/g1/g1ConcurrentStartToMixedTimeTracker.hpp&quot;</span>
  #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
  #include &quot;gc/g1/g1HeapRegionAttr.hpp&quot;
  #include &quot;gc/g1/g1MMUTracker.hpp&quot;
  #include &quot;gc/g1/g1OldGenAllocationTracker.hpp&quot;
  #include &quot;gc/g1/g1RemSetTrackingPolicy.hpp&quot;
  #include &quot;gc/g1/g1Predictions.hpp&quot;
  #include &quot;gc/g1/g1YoungGenSizer.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,11 ***</span>
  
    // Tracking the allocation in the old generation between
    // two GCs.
    G1OldGenAllocationTracker _old_gen_alloc_tracker;
  
<span class="line-modified">!   G1InitialMarkToMixedTimeTracker _initial_mark_to_mixed;</span>
  
    bool should_update_surv_rate_group_predictors() {
      return collector_state()-&gt;in_young_only_phase() &amp;&amp; !collector_state()-&gt;mark_or_rebuild_in_progress();
    }
  
<span class="line-new-header">--- 105,11 ---</span>
  
    // Tracking the allocation in the old generation between
    // two GCs.
    G1OldGenAllocationTracker _old_gen_alloc_tracker;
  
<span class="line-modified">!   G1ConcurrentStartToMixedTimeTracker _concurrent_start_to_mixed;</span>
  
    bool should_update_surv_rate_group_predictors() {
      return collector_state()-&gt;in_young_only_phase() &amp;&amp; !collector_state()-&gt;mark_or_rebuild_in_progress();
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,15 ***</span>
    enum PauseKind {
      FullGC,
      YoungOnlyGC,
      MixedGC,
      LastYoungGC,
<span class="line-modified">!     InitialMarkGC,</span>
      Cleanup,
      Remark
    };
  
    // Calculate PauseKind from internal state.
    PauseKind young_gc_pause_kind() const;
    // Record the given STW pause with the given start and end times (in s).
    void record_pause(PauseKind kind, double start, double end);
    // Indicate that we aborted marking before doing any mixed GCs.
<span class="line-new-header">--- 269,19 ---</span>
    enum PauseKind {
      FullGC,
      YoungOnlyGC,
      MixedGC,
      LastYoungGC,
<span class="line-modified">!     ConcurrentStartGC,</span>
      Cleanup,
      Remark
    };
  
<span class="line-added">+   static bool is_young_only_pause(PauseKind kind);</span>
<span class="line-added">+   static bool is_mixed_pause(PauseKind kind);</span>
<span class="line-added">+   static bool is_last_young_pause(PauseKind kind);</span>
<span class="line-added">+   static bool is_concurrent_start_pause(PauseKind kind);</span>
    // Calculate PauseKind from internal state.
    PauseKind young_gc_pause_kind() const;
    // Record the given STW pause with the given start and end times (in s).
    void record_pause(PauseKind kind, double start, double end);
    // Indicate that we aborted marking before doing any mixed GCs.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 362,18 ***</span>
  public:
    // This sets the initiate_conc_mark_if_possible() flag to start a
    // new cycle, as long as we are not already in one. It&#39;s best if it
    // is called during a safepoint when the test whether a cycle is in
    // progress or not is stable.
<span class="line-modified">!   bool force_initial_mark_if_outside_cycle(GCCause::Cause gc_cause);</span>
  
    // This is called at the very beginning of an evacuation pause (it
    // has to be the first thing that the pause does). If
    // initiate_conc_mark_if_possible() is true, and the concurrent
    // marking thread has completed its work during the previous cycle,
<span class="line-modified">!   // it will set in_initial_mark_gc() to so that the pause does</span>
<span class="line-modified">!   // the initial-mark work and start a marking cycle.</span>
    void decide_on_conc_mark_initiation();
  
    size_t young_list_target_length() const { return _young_list_target_length; }
  
    bool should_allocate_mutator_region() const;
<span class="line-new-header">--- 366,18 ---</span>
  public:
    // This sets the initiate_conc_mark_if_possible() flag to start a
    // new cycle, as long as we are not already in one. It&#39;s best if it
    // is called during a safepoint when the test whether a cycle is in
    // progress or not is stable.
<span class="line-modified">!   bool force_concurrent_start_if_outside_cycle(GCCause::Cause gc_cause);</span>
  
    // This is called at the very beginning of an evacuation pause (it
    // has to be the first thing that the pause does). If
    // initiate_conc_mark_if_possible() is true, and the concurrent
    // marking thread has completed its work during the previous cycle,
<span class="line-modified">!   // it will set in_concurrent_start_gc() to so that the pause does</span>
<span class="line-modified">!   // the concurrent start work and start a marking cycle.</span>
    void decide_on_conc_mark_initiation();
  
    size_t young_list_target_length() const { return _young_list_target_length; }
  
    bool should_allocate_mutator_region() const;
</pre>
<center><a href="g1Policy.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1RootClosures.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
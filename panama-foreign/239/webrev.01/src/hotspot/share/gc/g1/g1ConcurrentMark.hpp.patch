diff a/src/hotspot/share/gc/g1/g1ConcurrentMark.hpp b/src/hotspot/share/gc/g1/g1ConcurrentMark.hpp
--- a/src/hotspot/share/gc/g1/g1ConcurrentMark.hpp
+++ b/src/hotspot/share/gc/g1/g1ConcurrentMark.hpp
@@ -218,12 +218,12 @@
 
 // Root MemRegions are memory areas that contain objects which references are
 // roots wrt to the marking. They must be scanned before marking to maintain the
 // SATB invariant.
 // Typically they contain the areas from nTAMS to top of the regions.
-// We could scan and mark through these objects during the initial-mark pause, but for
-// pause time reasons we move this work to the concurrent phase.
+// We could scan and mark through these objects during the concurrent start pause,
+// but for pause time reasons we move this work to the concurrent phase.
 // We need to complete this procedure before the next GC because it might determine
 // that some of these "root objects" are dead, potentially dropping some required
 // references.
 // Root MemRegions comprise of the contents of survivor regions at the end
 // of the GC, and any objects copied into the old gen during GC.
@@ -382,11 +382,11 @@
   // Clear statistics gathered during the concurrent cycle for the given region after
   // it has been reclaimed.
   void clear_statistics(HeapRegion* r);
 
   // Resets the global marking data structures, as well as the
-  // task local ones; should be called during initial mark.
+  // task local ones; should be called during concurrent start.
   void reset();
 
   // Resets all the marking data structures. Called when we have to restart
   // marking or when marking completes (via set_non_marking_state below).
   void reset_marking_for_restart();
@@ -433,11 +433,11 @@
   // SATB guarantees (i.e. their TAMS will be equal to bottom).
   bool out_of_regions() { return _finger >= _heap.end(); }
 
   // Returns the task with the given id
   G1CMTask* task(uint id) {
-    // During initial mark we use the parallel gc threads to do some work, so
+    // During concurrent start we use the parallel gc threads to do some work, so
     // we can only compare against _max_num_tasks.
     assert(id < _max_num_tasks, "Task id %u not within bounds up to %u", id, _max_num_tasks);
     return _tasks[id];
   }
 
@@ -539,13 +539,13 @@
 
   // Clear the previous marking bitmap during safepoint.
   void clear_prev_bitmap(WorkGang* workers);
 
   // These two methods do the work that needs to be done at the start and end of the
-  // initial mark pause.
-  void pre_initial_mark();
-  void post_initial_mark();
+  // concurrent start pause.
+  void pre_concurrent_start();
+  void post_concurrent_start();
 
   // Scan all the root regions and mark everything reachable from
   // them.
   void scan_root_regions();
 

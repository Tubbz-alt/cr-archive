<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1ConcurrentMark.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentMark.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentMarkThread.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentMark.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 218,12 ***</span>
  
  // Root MemRegions are memory areas that contain objects which references are
  // roots wrt to the marking. They must be scanned before marking to maintain the
  // SATB invariant.
  // Typically they contain the areas from nTAMS to top of the regions.
<span class="line-modified">! // We could scan and mark through these objects during the initial-mark pause, but for</span>
<span class="line-modified">! // pause time reasons we move this work to the concurrent phase.</span>
  // We need to complete this procedure before the next GC because it might determine
  // that some of these &quot;root objects&quot; are dead, potentially dropping some required
  // references.
  // Root MemRegions comprise of the contents of survivor regions at the end
  // of the GC, and any objects copied into the old gen during GC.
<span class="line-new-header">--- 218,12 ---</span>
  
  // Root MemRegions are memory areas that contain objects which references are
  // roots wrt to the marking. They must be scanned before marking to maintain the
  // SATB invariant.
  // Typically they contain the areas from nTAMS to top of the regions.
<span class="line-modified">! // We could scan and mark through these objects during the concurrent start pause,</span>
<span class="line-modified">! // but for pause time reasons we move this work to the concurrent phase.</span>
  // We need to complete this procedure before the next GC because it might determine
  // that some of these &quot;root objects&quot; are dead, potentially dropping some required
  // references.
  // Root MemRegions comprise of the contents of survivor regions at the end
  // of the GC, and any objects copied into the old gen during GC.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 382,11 ***</span>
    // Clear statistics gathered during the concurrent cycle for the given region after
    // it has been reclaimed.
    void clear_statistics(HeapRegion* r);
  
    // Resets the global marking data structures, as well as the
<span class="line-modified">!   // task local ones; should be called during initial mark.</span>
    void reset();
  
    // Resets all the marking data structures. Called when we have to restart
    // marking or when marking completes (via set_non_marking_state below).
    void reset_marking_for_restart();
<span class="line-new-header">--- 382,11 ---</span>
    // Clear statistics gathered during the concurrent cycle for the given region after
    // it has been reclaimed.
    void clear_statistics(HeapRegion* r);
  
    // Resets the global marking data structures, as well as the
<span class="line-modified">!   // task local ones; should be called during concurrent start.</span>
    void reset();
  
    // Resets all the marking data structures. Called when we have to restart
    // marking or when marking completes (via set_non_marking_state below).
    void reset_marking_for_restart();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 433,11 ***</span>
    // SATB guarantees (i.e. their TAMS will be equal to bottom).
    bool out_of_regions() { return _finger &gt;= _heap.end(); }
  
    // Returns the task with the given id
    G1CMTask* task(uint id) {
<span class="line-modified">!     // During initial mark we use the parallel gc threads to do some work, so</span>
      // we can only compare against _max_num_tasks.
      assert(id &lt; _max_num_tasks, &quot;Task id %u not within bounds up to %u&quot;, id, _max_num_tasks);
      return _tasks[id];
    }
  
<span class="line-new-header">--- 433,11 ---</span>
    // SATB guarantees (i.e. their TAMS will be equal to bottom).
    bool out_of_regions() { return _finger &gt;= _heap.end(); }
  
    // Returns the task with the given id
    G1CMTask* task(uint id) {
<span class="line-modified">!     // During concurrent start we use the parallel gc threads to do some work, so</span>
      // we can only compare against _max_num_tasks.
      assert(id &lt; _max_num_tasks, &quot;Task id %u not within bounds up to %u&quot;, id, _max_num_tasks);
      return _tasks[id];
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 539,13 ***</span>
  
    // Clear the previous marking bitmap during safepoint.
    void clear_prev_bitmap(WorkGang* workers);
  
    // These two methods do the work that needs to be done at the start and end of the
<span class="line-modified">!   // initial mark pause.</span>
<span class="line-modified">!   void pre_initial_mark();</span>
<span class="line-modified">!   void post_initial_mark();</span>
  
    // Scan all the root regions and mark everything reachable from
    // them.
    void scan_root_regions();
  
<span class="line-new-header">--- 539,13 ---</span>
  
    // Clear the previous marking bitmap during safepoint.
    void clear_prev_bitmap(WorkGang* workers);
  
    // These two methods do the work that needs to be done at the start and end of the
<span class="line-modified">!   // concurrent start pause.</span>
<span class="line-modified">!   void pre_concurrent_start();</span>
<span class="line-modified">!   void post_concurrent_start();</span>
  
    // Scan all the root regions and mark everything reachable from
    // them.
    void scan_root_regions();
  
</pre>
<center><a href="g1ConcurrentMark.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentMarkThread.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
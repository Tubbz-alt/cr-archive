<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1HeapSizingPolicy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1EvacFailure.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1HeapSizingPolicy.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1HeapSizingPolicy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 65 
 66 static void log_expansion(double short_term_pause_time_ratio,
 67                           double long_term_pause_time_ratio,
 68                           double threshold,
 69                           double pause_time_ratio,
 70                           bool fully_expanded,
 71                           size_t resize_bytes) {
 72 
 73   log_debug(gc, ergo, heap)(&quot;Heap expansion: &quot;
 74                             &quot;short term pause time ratio %1.2f%% long term pause time ratio %1.2f%% &quot;
 75                             &quot;threshold %1.2f%% pause time ratio %1.2f%% fully expanded %s &quot;
 76                             &quot;resize by &quot; SIZE_FORMAT &quot;B&quot;,
 77                             short_term_pause_time_ratio * 100.0,
 78                             long_term_pause_time_ratio * 100.0,
 79                             threshold * 100.0,
 80                             pause_time_ratio * 100.0,
 81                             BOOL_TO_STR(fully_expanded),
 82                             resize_bytes);
 83 }
 84 
<span class="line-modified"> 85 size_t G1HeapSizingPolicy::expansion_amount() {</span>
 86   assert(GCTimeRatio &gt; 0, &quot;must be&quot;);
 87 
 88   double long_term_pause_time_ratio = _analytics-&gt;long_term_pause_time_ratio();
 89   double short_term_pause_time_ratio = _analytics-&gt;short_term_pause_time_ratio();
 90   const double pause_time_threshold = 1.0 / (1.0 + GCTimeRatio);
 91   double threshold = scale_with_heap(pause_time_threshold);
 92 
 93   size_t expand_bytes = 0;
 94 
 95   if (_g1h-&gt;capacity() == _g1h-&gt;max_capacity()) {
 96     log_expansion(short_term_pause_time_ratio, long_term_pause_time_ratio,
 97                   threshold, pause_time_threshold, true, 0);
 98     clear_ratio_check_data();
 99     return expand_bytes;
100   }
101 
102   // If the last GC time ratio is over the threshold, increment the count of
103   // times it has been exceeded, and add this ratio to the sum of exceeded
104   // ratios.
105   if (short_term_pause_time_ratio &gt; threshold) {
</pre>
<hr />
<pre>
178 
179     clear_ratio_check_data();
180   } else {
181     // An expansion was not triggered. If we&#39;ve started counting, increment
182     // the number of checks we&#39;ve made in the current window.  If we&#39;ve
183     // reached the end of the window without resizing, clear the counters to
184     // start again the next time we see a ratio above the threshold.
185     if (_ratio_over_threshold_count &gt; 0) {
186       _pauses_since_start++;
187       if (_pauses_since_start &gt; _num_prev_pauses_for_heuristics) {
188         clear_ratio_check_data();
189       }
190     }
191   }
192 
193   log_expansion(short_term_pause_time_ratio, long_term_pause_time_ratio,
194                 threshold, pause_time_threshold, false, expand_bytes);
195 
196   return expand_bytes;
197 }







































































</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 65 
 66 static void log_expansion(double short_term_pause_time_ratio,
 67                           double long_term_pause_time_ratio,
 68                           double threshold,
 69                           double pause_time_ratio,
 70                           bool fully_expanded,
 71                           size_t resize_bytes) {
 72 
 73   log_debug(gc, ergo, heap)(&quot;Heap expansion: &quot;
 74                             &quot;short term pause time ratio %1.2f%% long term pause time ratio %1.2f%% &quot;
 75                             &quot;threshold %1.2f%% pause time ratio %1.2f%% fully expanded %s &quot;
 76                             &quot;resize by &quot; SIZE_FORMAT &quot;B&quot;,
 77                             short_term_pause_time_ratio * 100.0,
 78                             long_term_pause_time_ratio * 100.0,
 79                             threshold * 100.0,
 80                             pause_time_ratio * 100.0,
 81                             BOOL_TO_STR(fully_expanded),
 82                             resize_bytes);
 83 }
 84 
<span class="line-modified"> 85 size_t G1HeapSizingPolicy::young_collection_expansion_amount() {</span>
 86   assert(GCTimeRatio &gt; 0, &quot;must be&quot;);
 87 
 88   double long_term_pause_time_ratio = _analytics-&gt;long_term_pause_time_ratio();
 89   double short_term_pause_time_ratio = _analytics-&gt;short_term_pause_time_ratio();
 90   const double pause_time_threshold = 1.0 / (1.0 + GCTimeRatio);
 91   double threshold = scale_with_heap(pause_time_threshold);
 92 
 93   size_t expand_bytes = 0;
 94 
 95   if (_g1h-&gt;capacity() == _g1h-&gt;max_capacity()) {
 96     log_expansion(short_term_pause_time_ratio, long_term_pause_time_ratio,
 97                   threshold, pause_time_threshold, true, 0);
 98     clear_ratio_check_data();
 99     return expand_bytes;
100   }
101 
102   // If the last GC time ratio is over the threshold, increment the count of
103   // times it has been exceeded, and add this ratio to the sum of exceeded
104   // ratios.
105   if (short_term_pause_time_ratio &gt; threshold) {
</pre>
<hr />
<pre>
178 
179     clear_ratio_check_data();
180   } else {
181     // An expansion was not triggered. If we&#39;ve started counting, increment
182     // the number of checks we&#39;ve made in the current window.  If we&#39;ve
183     // reached the end of the window without resizing, clear the counters to
184     // start again the next time we see a ratio above the threshold.
185     if (_ratio_over_threshold_count &gt; 0) {
186       _pauses_since_start++;
187       if (_pauses_since_start &gt; _num_prev_pauses_for_heuristics) {
188         clear_ratio_check_data();
189       }
190     }
191   }
192 
193   log_expansion(short_term_pause_time_ratio, long_term_pause_time_ratio,
194                 threshold, pause_time_threshold, false, expand_bytes);
195 
196   return expand_bytes;
197 }
<span class="line-added">198 </span>
<span class="line-added">199 static size_t target_heap_capacity(size_t used_bytes, uintx free_ratio) {</span>
<span class="line-added">200   const double desired_free_percentage = (double) free_ratio / 100.0;</span>
<span class="line-added">201   const double desired_used_percentage = 1.0 - desired_free_percentage;</span>
<span class="line-added">202 </span>
<span class="line-added">203   // We have to be careful here as these two calculations can overflow</span>
<span class="line-added">204   // 32-bit size_t&#39;s.</span>
<span class="line-added">205   double used_bytes_d = (double) used_bytes;</span>
<span class="line-added">206   double desired_capacity_d = used_bytes_d / desired_used_percentage;</span>
<span class="line-added">207   // Let&#39;s make sure that they are both under the max heap size, which</span>
<span class="line-added">208   // by default will make it fit into a size_t.</span>
<span class="line-added">209   double desired_capacity_upper_bound = (double) MaxHeapSize;</span>
<span class="line-added">210   desired_capacity_d = MIN2(desired_capacity_d, desired_capacity_upper_bound);</span>
<span class="line-added">211   // We can now safely turn it into size_t&#39;s.</span>
<span class="line-added">212   return (size_t) desired_capacity_d;</span>
<span class="line-added">213 }</span>
<span class="line-added">214 </span>
<span class="line-added">215 size_t G1HeapSizingPolicy::full_collection_resize_amount(bool&amp; expand) {</span>
<span class="line-added">216   // Capacity, free and used after the GC counted as full regions to</span>
<span class="line-added">217   // include the waste in the following calculations.</span>
<span class="line-added">218   const size_t capacity_after_gc = _g1h-&gt;capacity();</span>
<span class="line-added">219   const size_t used_after_gc = capacity_after_gc - _g1h-&gt;unused_committed_regions_in_bytes();</span>
<span class="line-added">220 </span>
<span class="line-added">221   size_t minimum_desired_capacity = target_heap_capacity(used_after_gc, MinHeapFreeRatio);</span>
<span class="line-added">222   size_t maximum_desired_capacity = target_heap_capacity(used_after_gc, MaxHeapFreeRatio);</span>
<span class="line-added">223 </span>
<span class="line-added">224   // This assert only makes sense here, before we adjust them</span>
<span class="line-added">225   // with respect to the min and max heap size.</span>
<span class="line-added">226   assert(minimum_desired_capacity &lt;= maximum_desired_capacity,</span>
<span class="line-added">227          &quot;minimum_desired_capacity = &quot; SIZE_FORMAT &quot;, &quot;</span>
<span class="line-added">228          &quot;maximum_desired_capacity = &quot; SIZE_FORMAT,</span>
<span class="line-added">229          minimum_desired_capacity, maximum_desired_capacity);</span>
<span class="line-added">230 </span>
<span class="line-added">231   // Should not be greater than the heap max size. No need to adjust</span>
<span class="line-added">232   // it with respect to the heap min size as it&#39;s a lower bound (i.e.,</span>
<span class="line-added">233   // we&#39;ll try to make the capacity larger than it, not smaller).</span>
<span class="line-added">234   minimum_desired_capacity = MIN2(minimum_desired_capacity, MaxHeapSize);</span>
<span class="line-added">235   // Should not be less than the heap min size. No need to adjust it</span>
<span class="line-added">236   // with respect to the heap max size as it&#39;s an upper bound (i.e.,</span>
<span class="line-added">237   // we&#39;ll try to make the capacity smaller than it, not greater).</span>
<span class="line-added">238   maximum_desired_capacity =  MAX2(maximum_desired_capacity, MinHeapSize);</span>
<span class="line-added">239 </span>
<span class="line-added">240   // Don&#39;t expand unless it&#39;s significant; prefer expansion to shrinking.</span>
<span class="line-added">241   if (capacity_after_gc &lt; minimum_desired_capacity) {</span>
<span class="line-added">242     size_t expand_bytes = minimum_desired_capacity - capacity_after_gc;</span>
<span class="line-added">243 </span>
<span class="line-added">244     log_debug(gc, ergo, heap)(&quot;Attempt heap expansion (capacity lower than min desired capacity). &quot;</span>
<span class="line-added">245                               &quot;Capacity: &quot; SIZE_FORMAT &quot;B occupancy: &quot; SIZE_FORMAT &quot;B live: &quot; SIZE_FORMAT &quot;B &quot;</span>
<span class="line-added">246                               &quot;min_desired_capacity: &quot; SIZE_FORMAT &quot;B (&quot; UINTX_FORMAT &quot; %%)&quot;,</span>
<span class="line-added">247                               capacity_after_gc, used_after_gc, _g1h-&gt;used(), minimum_desired_capacity, MinHeapFreeRatio);</span>
<span class="line-added">248 </span>
<span class="line-added">249     expand = true;</span>
<span class="line-added">250     return expand_bytes;</span>
<span class="line-added">251     // No expansion, now see if we want to shrink</span>
<span class="line-added">252   } else if (capacity_after_gc &gt; maximum_desired_capacity) {</span>
<span class="line-added">253     // Capacity too large, compute shrinking size</span>
<span class="line-added">254     size_t shrink_bytes = capacity_after_gc - maximum_desired_capacity;</span>
<span class="line-added">255 </span>
<span class="line-added">256     log_debug(gc, ergo, heap)(&quot;Attempt heap shrinking (capacity higher than max desired capacity). &quot;</span>
<span class="line-added">257                               &quot;Capacity: &quot; SIZE_FORMAT &quot;B occupancy: &quot; SIZE_FORMAT &quot;B live: &quot; SIZE_FORMAT &quot;B &quot;</span>
<span class="line-added">258                               &quot;maximum_desired_capacity: &quot; SIZE_FORMAT &quot;B (&quot; UINTX_FORMAT &quot; %%)&quot;,</span>
<span class="line-added">259                               capacity_after_gc, used_after_gc, _g1h-&gt;used(), maximum_desired_capacity, MaxHeapFreeRatio);</span>
<span class="line-added">260 </span>
<span class="line-added">261     expand = false;</span>
<span class="line-added">262     return shrink_bytes;</span>
<span class="line-added">263   }</span>
<span class="line-added">264 </span>
<span class="line-added">265   expand = true; // Does not matter.</span>
<span class="line-added">266   return 0;</span>
<span class="line-added">267 }</span>
<span class="line-added">268 </span>
</pre>
</td>
</tr>
</table>
<center><a href="g1EvacFailure.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1HeapSizingPolicy.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
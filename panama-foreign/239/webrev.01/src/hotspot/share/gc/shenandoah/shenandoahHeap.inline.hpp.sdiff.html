<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahRootVerifier.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
309     // But if it happens to contain references to evacuated regions, those references would
310     // not get updated for this stale copy during this cycle, and we will crash while scanning
311     // it the next cycle.
312     //
313     // For GCLAB allocations, it is enough to rollback the allocation ptr. Either the next
314     // object will overwrite this stale copy, or the filler object on LAB retirement will
315     // do this. For non-GCLAB allocations, we have no way to retract the allocation, and
316     // have to explicitly overwrite the copy with the filler object. With that overwrite,
317     // we have to keep the fwdptr initialized and pointing to our (stale) copy.
318     if (alloc_from_gclab) {
319       ShenandoahThreadLocalData::gclab(thread)-&gt;undo_allocation(copy, size);
320     } else {
321       fill_with_object(copy, size);
322       shenandoah_assert_correct(NULL, copy_val);
323     }
324     shenandoah_assert_correct(NULL, result);
325     return result;
326   }
327 }
328 
<span class="line-removed">329 template&lt;bool RESOLVE&gt;</span>
330 inline bool ShenandoahHeap::requires_marking(const void* entry) const {
331   oop obj = oop(entry);
<span class="line-removed">332   if (RESOLVE) {</span>
<span class="line-removed">333     obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-removed">334   }</span>
335   return !_marking_context-&gt;is_marked(obj);
336 }
337 
338 inline bool ShenandoahHeap::in_collection_set(oop p) const {
339   assert(collection_set() != NULL, &quot;Sanity&quot;);
340   return collection_set()-&gt;is_in(p);
341 }
342 
343 inline bool ShenandoahHeap::in_collection_set_loc(void* p) const {
344   assert(collection_set() != NULL, &quot;Sanity&quot;);
345   return collection_set()-&gt;is_in_loc(p);
346 }
347 
348 inline bool ShenandoahHeap::is_stable() const {
349   return _gc_state.is_clear();
350 }
351 
352 inline bool ShenandoahHeap::is_idle() const {
353   return _gc_state.is_unset(MARKING | EVACUATION | UPDATEREFS);
354 }
</pre>
</td>
<td>
<hr />
<pre>
309     // But if it happens to contain references to evacuated regions, those references would
310     // not get updated for this stale copy during this cycle, and we will crash while scanning
311     // it the next cycle.
312     //
313     // For GCLAB allocations, it is enough to rollback the allocation ptr. Either the next
314     // object will overwrite this stale copy, or the filler object on LAB retirement will
315     // do this. For non-GCLAB allocations, we have no way to retract the allocation, and
316     // have to explicitly overwrite the copy with the filler object. With that overwrite,
317     // we have to keep the fwdptr initialized and pointing to our (stale) copy.
318     if (alloc_from_gclab) {
319       ShenandoahThreadLocalData::gclab(thread)-&gt;undo_allocation(copy, size);
320     } else {
321       fill_with_object(copy, size);
322       shenandoah_assert_correct(NULL, copy_val);
323     }
324     shenandoah_assert_correct(NULL, result);
325     return result;
326   }
327 }
328 

329 inline bool ShenandoahHeap::requires_marking(const void* entry) const {
330   oop obj = oop(entry);



331   return !_marking_context-&gt;is_marked(obj);
332 }
333 
334 inline bool ShenandoahHeap::in_collection_set(oop p) const {
335   assert(collection_set() != NULL, &quot;Sanity&quot;);
336   return collection_set()-&gt;is_in(p);
337 }
338 
339 inline bool ShenandoahHeap::in_collection_set_loc(void* p) const {
340   assert(collection_set() != NULL, &quot;Sanity&quot;);
341   return collection_set()-&gt;is_in_loc(p);
342 }
343 
344 inline bool ShenandoahHeap::is_stable() const {
345   return _gc_state.is_clear();
346 }
347 
348 inline bool ShenandoahHeap::is_idle() const {
349   return _gc_state.is_unset(MARKING | EVACUATION | UPDATEREFS);
350 }
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahRootVerifier.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
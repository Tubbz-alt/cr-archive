<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/subnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stringopts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="subnode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/subnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 730 
 731 //------------------------------Idealize---------------------------------------
 732 Node *CmpINode::Ideal( PhaseGVN *phase, bool can_reshape ) {
 733   if (phase-&gt;type(in(2))-&gt;higher_equal(TypeInt::ZERO)) {
 734     switch (in(1)-&gt;Opcode()) {
 735     case Op_CmpL3:              // Collapse a CmpL3/CmpI into a CmpL
 736       return new CmpLNode(in(1)-&gt;in(1),in(1)-&gt;in(2));
 737     case Op_CmpF3:              // Collapse a CmpF3/CmpI into a CmpF
 738       return new CmpFNode(in(1)-&gt;in(1),in(1)-&gt;in(2));
 739     case Op_CmpD3:              // Collapse a CmpD3/CmpI into a CmpD
 740       return new CmpDNode(in(1)-&gt;in(1),in(1)-&gt;in(2));
 741     //case Op_SubI:
 742       // If (x - y) cannot overflow, then ((x - y) &lt;?&gt; 0)
 743       // can be turned into (x &lt;?&gt; y).
 744       // This is handled (with more general cases) by Ideal_sub_algebra.
 745     }
 746   }
 747   return NULL;                  // No change
 748 }
 749 










 750 
 751 //=============================================================================
 752 // Simplify a CmpL (compare 2 longs ) node, based on local information.
 753 // If both inputs are constants, compare them.
 754 const Type *CmpLNode::sub( const Type *t1, const Type *t2 ) const {
 755   const TypeLong *r0 = t1-&gt;is_long(); // Handy access
 756   const TypeLong *r1 = t2-&gt;is_long();
 757 
 758   if( r0-&gt;_hi &lt; r1-&gt;_lo )       // Range is always low?
 759     return TypeInt::CC_LT;
 760   else if( r0-&gt;_lo &gt; r1-&gt;_hi )  // Range is always high?
 761     return TypeInt::CC_GT;
 762 
 763   else if( r0-&gt;is_con() &amp;&amp; r1-&gt;is_con() ) { // comparing constants?
 764     assert(r0-&gt;get_con() == r1-&gt;get_con(), &quot;must be equal&quot;);
 765     return TypeInt::CC_EQ;      // Equal results.
 766   } else if( r0-&gt;_hi == r1-&gt;_lo ) // Range is never high?
 767     return TypeInt::CC_LE;
 768   else if( r0-&gt;_lo == r1-&gt;_hi ) // Range is never low?
 769     return TypeInt::CC_GE;
</pre>
</td>
<td>
<hr />
<pre>
 730 
 731 //------------------------------Idealize---------------------------------------
 732 Node *CmpINode::Ideal( PhaseGVN *phase, bool can_reshape ) {
 733   if (phase-&gt;type(in(2))-&gt;higher_equal(TypeInt::ZERO)) {
 734     switch (in(1)-&gt;Opcode()) {
 735     case Op_CmpL3:              // Collapse a CmpL3/CmpI into a CmpL
 736       return new CmpLNode(in(1)-&gt;in(1),in(1)-&gt;in(2));
 737     case Op_CmpF3:              // Collapse a CmpF3/CmpI into a CmpF
 738       return new CmpFNode(in(1)-&gt;in(1),in(1)-&gt;in(2));
 739     case Op_CmpD3:              // Collapse a CmpD3/CmpI into a CmpD
 740       return new CmpDNode(in(1)-&gt;in(1),in(1)-&gt;in(2));
 741     //case Op_SubI:
 742       // If (x - y) cannot overflow, then ((x - y) &lt;?&gt; 0)
 743       // can be turned into (x &lt;?&gt; y).
 744       // This is handled (with more general cases) by Ideal_sub_algebra.
 745     }
 746   }
 747   return NULL;                  // No change
 748 }
 749 
<span class="line-added"> 750 Node *CmpLNode::Ideal( PhaseGVN *phase, bool can_reshape ) {</span>
<span class="line-added"> 751   const TypeLong *t2 = phase-&gt;type(in(2))-&gt;isa_long();</span>
<span class="line-added"> 752   if (Opcode() == Op_CmpL &amp;&amp; in(1)-&gt;Opcode() == Op_ConvI2L &amp;&amp; t2 &amp;&amp; t2-&gt;is_con()) {</span>
<span class="line-added"> 753     const jlong con = t2-&gt;get_con();</span>
<span class="line-added"> 754     if (con &gt;= min_jint &amp;&amp; con &lt;= max_jint) {</span>
<span class="line-added"> 755       return new CmpINode(in(1)-&gt;in(1), phase-&gt;intcon((jint)con));</span>
<span class="line-added"> 756     }</span>
<span class="line-added"> 757   }</span>
<span class="line-added"> 758   return NULL;</span>
<span class="line-added"> 759 }</span>
 760 
 761 //=============================================================================
 762 // Simplify a CmpL (compare 2 longs ) node, based on local information.
 763 // If both inputs are constants, compare them.
 764 const Type *CmpLNode::sub( const Type *t1, const Type *t2 ) const {
 765   const TypeLong *r0 = t1-&gt;is_long(); // Handy access
 766   const TypeLong *r1 = t2-&gt;is_long();
 767 
 768   if( r0-&gt;_hi &lt; r1-&gt;_lo )       // Range is always low?
 769     return TypeInt::CC_LT;
 770   else if( r0-&gt;_lo &gt; r1-&gt;_hi )  // Range is always high?
 771     return TypeInt::CC_GT;
 772 
 773   else if( r0-&gt;is_con() &amp;&amp; r1-&gt;is_con() ) { // comparing constants?
 774     assert(r0-&gt;get_con() == r1-&gt;get_con(), &quot;must be equal&quot;);
 775     return TypeInt::CC_EQ;      // Equal results.
 776   } else if( r0-&gt;_hi == r1-&gt;_lo ) // Range is never high?
 777     return TypeInt::CC_LE;
 778   else if( r0-&gt;_lo == r1-&gt;_hi ) // Range is never low?
 779     return TypeInt::CC_GE;
</pre>
</td>
</tr>
</table>
<center><a href="stringopts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="subnode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
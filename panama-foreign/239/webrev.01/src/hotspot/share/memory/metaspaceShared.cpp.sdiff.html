<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspaceShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="dynamicArchive.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspaceShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 796   f(TypeArrayKlass)
 797 
 798 class CppVtableInfo {
 799   intptr_t _vtable_size;
 800   intptr_t _cloned_vtable[1];
 801 public:
 802   static int num_slots(int vtable_size) {
 803     return 1 + vtable_size; // Need to add the space occupied by _vtable_size;
 804   }
 805   int vtable_size()           { return int(uintx(_vtable_size)); }
 806   void set_vtable_size(int n) { _vtable_size = intptr_t(n); }
 807   intptr_t* cloned_vtable()   { return &amp;_cloned_vtable[0]; }
 808   void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }
 809   // Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo
 810   static size_t byte_size(int vtable_size) {
 811     CppVtableInfo i;
 812     return pointer_delta(&amp;i._cloned_vtable[vtable_size], &amp;i, sizeof(u1));
 813   }
 814 };
 815 




 816 template &lt;class T&gt; class CppVtableCloner : public T {
<span class="line-removed"> 817   static intptr_t* vtable_of(Metadata&amp; m) {</span>
<span class="line-removed"> 818     return *((intptr_t**)&amp;m);</span>
<span class="line-removed"> 819   }</span>
 820   static CppVtableInfo* _info;
 821 
 822   static int get_vtable_length(const char* name);
 823 
 824 public:
 825   // Allocate and initialize the C++ vtable, starting from top, but do not go past end.
 826   static intptr_t* allocate(const char* name);
 827 
 828   // Clone the vtable to ...
 829   static intptr_t* clone_vtable(const char* name, CppVtableInfo* info);
 830 
 831   static void zero_vtable_clone() {
 832     assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 833     _info-&gt;zero();
 834   }
 835 
 836   static bool is_valid_shared_object(const T* obj) {
 837     intptr_t* vptr = *(intptr_t**)obj;
 838     return vptr == _info-&gt;cloned_vtable();
 839   }


 840 };
 841 
 842 template &lt;class T&gt; CppVtableInfo* CppVtableCloner&lt;T&gt;::_info = NULL;
 843 
 844 template &lt;class T&gt;
 845 intptr_t* CppVtableCloner&lt;T&gt;::allocate(const char* name) {
 846   assert(is_aligned(_mc_region.top(), sizeof(intptr_t)), &quot;bad alignment&quot;);
 847   int n = get_vtable_length(name);
 848   _info = (CppVtableInfo*)_mc_region.allocate(CppVtableInfo::byte_size(n), sizeof(intptr_t));
 849   _info-&gt;set_vtable_size(n);
 850 
 851   intptr_t* p = clone_vtable(name, _info);
 852   assert((char*)p == _mc_region.top(), &quot;must be&quot;);
 853 
 854   return _info-&gt;cloned_vtable();
 855 }
 856 
 857 template &lt;class T&gt;
 858 intptr_t* CppVtableCloner&lt;T&gt;::clone_vtable(const char* name, CppVtableInfo* info) {
 859   if (!DumpSharedSpaces) {
 860     assert(_info == 0, &quot;_info is initialized only at dump time&quot;);
 861     _info = info; // Remember it -- it will be used by MetaspaceShared::is_valid_shared_method()
 862   }
 863   T tmp; // Allocate temporary dummy metadata object to get to the original vtable.
 864   int n = info-&gt;vtable_size();
<span class="line-modified"> 865   intptr_t* srcvtable = vtable_of(tmp);</span>
 866   intptr_t* dstvtable = info-&gt;cloned_vtable();
 867 
 868   // We already checked (and, if necessary, adjusted n) when the vtables were allocated, so we are
 869   // safe to do memcpy.
 870   log_debug(cds, vtables)(&quot;Copying %3d vtable entries for %s&quot;, n, name);
 871   memcpy(dstvtable, srcvtable, sizeof(intptr_t) * n);
 872   return dstvtable + n;
 873 }
 874 
 875 // To determine the size of the vtable for each type, we use the following
 876 // trick by declaring 2 subclasses:
 877 //
 878 //   class CppVtableTesterA: public InstanceKlass {virtual int   last_virtual_method() {return 1;}    };
 879 //   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };
 880 //
 881 // CppVtableTesterA and CppVtableTesterB&#39;s vtables have the following properties:
 882 // - Their size (N+1) is exactly one more than the size of InstanceKlass&#39;s vtable (N)
 883 // - The first N entries have are exactly the same as in InstanceKlass&#39;s vtable.
 884 // - Their last entry is different.
 885 //
</pre>
<hr />
<pre>
 891 
 892 template &lt;class T&gt; class CppVtableTesterB: public T {
 893 public:
 894   virtual int last_virtual_method() {return 1;}
 895 };
 896 
 897 template &lt;class T&gt; class CppVtableTesterA : public T {
 898 public:
 899   virtual void* last_virtual_method() {
 900     // Make this different than CppVtableTesterB::last_virtual_method so the C++
 901     // compiler/linker won&#39;t alias the two functions.
 902     return NULL;
 903   }
 904 };
 905 
 906 template &lt;class T&gt;
 907 int CppVtableCloner&lt;T&gt;::get_vtable_length(const char* name) {
 908   CppVtableTesterA&lt;T&gt; a;
 909   CppVtableTesterB&lt;T&gt; b;
 910 
<span class="line-modified"> 911   intptr_t* avtable = vtable_of(a);</span>
<span class="line-modified"> 912   intptr_t* bvtable = vtable_of(b);</span>
 913 
 914   // Start at slot 1, because slot 0 may be RTTI (on Solaris/Sparc)
 915   int vtable_len = 1;
 916   for (; ; vtable_len++) {
 917     if (avtable[vtable_len] != bvtable[vtable_len]) {
 918       break;
 919     }
 920   }
 921   log_debug(cds, vtables)(&quot;Found   %3d vtable entries for %s&quot;, vtable_len, name);
 922 
 923   return vtable_len;
 924 }
 925 
 926 #define ALLOC_CPP_VTABLE_CLONE(c) \
 927   _cloned_cpp_vtptrs[c##_Kind] = CppVtableCloner&lt;c&gt;::allocate(#c); \
 928   ArchivePtrMarker::mark_pointer(&amp;_cloned_cpp_vtptrs[c##_Kind]);
 929 
 930 #define CLONE_CPP_VTABLE(c) \
 931   p = CppVtableCloner&lt;c&gt;::clone_vtable(#c, (CppVtableInfo*)p);
 932 
 933 #define ZERO_CPP_VTABLE(c) \
 934  CppVtableCloner&lt;c&gt;::zero_vtable_clone();
 935 
<span class="line-modified"> 936 //------------------------------ for DynamicDumpSharedSpaces - start</span>


 937 #define DECLARE_CLONED_VTABLE_KIND(c) c ## _Kind,
 938 
<span class="line-modified"> 939 enum {</span>
<span class="line-modified"> 940   // E.g., ConstantPool_Kind == 0, InstanceKlass == 1, etc.</span>
 941   CPP_VTABLE_PATCH_TYPES_DO(DECLARE_CLONED_VTABLE_KIND)
 942   _num_cloned_vtable_kinds
 943 };
 944 















 945 // This is the index of all the cloned vtables. E.g., for
 946 //     ConstantPool* cp = ....; // an archived constant pool
 947 //     InstanceKlass* ik = ....;// an archived class
 948 // the following holds true:
 949 //     _cloned_cpp_vtptrs[ConstantPool_Kind]  == ((intptr_t**)cp)[0]
 950 //     _cloned_cpp_vtptrs[InstanceKlass_Kind] == ((intptr_t**)ik)[0]
 951 static intptr_t** _cloned_cpp_vtptrs = NULL;
 952 
 953 void MetaspaceShared::allocate_cloned_cpp_vtptrs() {
 954   assert(DumpSharedSpaces, &quot;must&quot;);
 955   size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(intptr_t*);
 956   _cloned_cpp_vtptrs = (intptr_t**)_mc_region.allocate(vtptrs_bytes, sizeof(intptr_t*));
 957 }
 958 
 959 void MetaspaceShared::serialize_cloned_cpp_vtptrs(SerializeClosure* soc) {
 960   soc-&gt;do_ptr((void**)&amp;_cloned_cpp_vtptrs);
 961 }
 962 
<span class="line-modified"> 963 intptr_t* MetaspaceShared::fix_cpp_vtable_for_dynamic_archive(MetaspaceObj::Type msotype, address obj) {</span>





 964   Arguments::assert_is_dumping_archive();
 965   int kind = -1;
 966   switch (msotype) {
 967   case MetaspaceObj::SymbolType:
 968   case MetaspaceObj::TypeArrayU1Type:
 969   case MetaspaceObj::TypeArrayU2Type:
 970   case MetaspaceObj::TypeArrayU4Type:
 971   case MetaspaceObj::TypeArrayU8Type:
 972   case MetaspaceObj::TypeArrayOtherType:
 973   case MetaspaceObj::ConstMethodType:
 974   case MetaspaceObj::ConstantPoolCacheType:
 975   case MetaspaceObj::AnnotationsType:
 976   case MetaspaceObj::MethodCountersType:
 977   case MetaspaceObj::RecordComponentType:
 978     // These have no vtables.
 979     break;
<span class="line-removed"> 980   case MetaspaceObj::ClassType:</span>
<span class="line-removed"> 981     {</span>
<span class="line-removed"> 982       Klass* k = (Klass*)obj;</span>
<span class="line-removed"> 983       assert(k-&gt;is_klass(), &quot;must be&quot;);</span>
<span class="line-removed"> 984       if (k-&gt;is_instance_klass()) {</span>
<span class="line-removed"> 985         InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-removed"> 986         if (ik-&gt;is_class_loader_instance_klass()) {</span>
<span class="line-removed"> 987           kind = InstanceClassLoaderKlass_Kind;</span>
<span class="line-removed"> 988         } else if (ik-&gt;is_reference_instance_klass()) {</span>
<span class="line-removed"> 989           kind = InstanceRefKlass_Kind;</span>
<span class="line-removed"> 990         } else if (ik-&gt;is_mirror_instance_klass()) {</span>
<span class="line-removed"> 991           kind = InstanceMirrorKlass_Kind;</span>
<span class="line-removed"> 992         } else {</span>
<span class="line-removed"> 993           kind = InstanceKlass_Kind;</span>
<span class="line-removed"> 994         }</span>
<span class="line-removed"> 995       } else if (k-&gt;is_typeArray_klass()) {</span>
<span class="line-removed"> 996         kind = TypeArrayKlass_Kind;</span>
<span class="line-removed"> 997       } else {</span>
<span class="line-removed"> 998         assert(k-&gt;is_objArray_klass(), &quot;must be&quot;);</span>
<span class="line-removed"> 999         kind = ObjArrayKlass_Kind;</span>
<span class="line-removed">1000       }</span>
<span class="line-removed">1001     }</span>
<span class="line-removed">1002     break;</span>
<span class="line-removed">1003 </span>
<span class="line-removed">1004   case MetaspaceObj::MethodType:</span>
<span class="line-removed">1005     {</span>
<span class="line-removed">1006       Method* m = (Method*)obj;</span>
<span class="line-removed">1007       assert(m-&gt;is_method(), &quot;must be&quot;);</span>
<span class="line-removed">1008       kind = Method_Kind;</span>
<span class="line-removed">1009     }</span>
<span class="line-removed">1010     break;</span>
<span class="line-removed">1011 </span>
1012   case MetaspaceObj::MethodDataType:
1013     // We don&#39;t archive MethodData &lt;-- should have been removed in removed_unsharable_info
1014     ShouldNotReachHere();
1015     break;
<span class="line-removed">1016 </span>
<span class="line-removed">1017   case MetaspaceObj::ConstantPoolType:</span>
<span class="line-removed">1018     {</span>
<span class="line-removed">1019       ConstantPool *cp = (ConstantPool*)obj;</span>
<span class="line-removed">1020       assert(cp-&gt;is_constantPool(), &quot;must be&quot;);</span>
<span class="line-removed">1021       kind = ConstantPool_Kind;</span>
<span class="line-removed">1022     }</span>
<span class="line-removed">1023     break;</span>
<span class="line-removed">1024 </span>
1025   default:
<span class="line-modified">1026     ShouldNotReachHere();</span>









1027   }
1028 
1029   if (kind &gt;= 0) {
1030     assert(kind &lt; _num_cloned_vtable_kinds, &quot;must be&quot;);
1031     return _cloned_cpp_vtptrs[kind];
1032   } else {
1033     return NULL;
1034   }
1035 }
1036 
<span class="line-removed">1037 //------------------------------ for DynamicDumpSharedSpaces - end</span>
<span class="line-removed">1038 </span>
1039 // This can be called at both dump time and run time:
1040 // - clone the contents of the c++ vtables into the space
1041 //   allocated by allocate_cpp_vtable_clones()
1042 void MetaspaceShared::clone_cpp_vtables(intptr_t* p) {
1043   assert(DumpSharedSpaces || UseSharedSpaces, &quot;sanity&quot;);
1044   CPP_VTABLE_PATCH_TYPES_DO(CLONE_CPP_VTABLE);
1045 }
1046 
1047 void MetaspaceShared::zero_cpp_vtable_clones_for_writing() {
1048   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
1049   CPP_VTABLE_PATCH_TYPES_DO(ZERO_CPP_VTABLE);
1050 }
1051 
1052 // Allocate and initialize the C++ vtables, starting from top, but do not go past end.
1053 char* MetaspaceShared::allocate_cpp_vtable_clones() {
1054   char* cloned_vtables = _mc_region.top(); // This is the beginning of all the cloned vtables
1055 
1056   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
1057   // Layout (each slot is a intptr_t):
1058   //   [number of slots in the first vtable = n1]
</pre>
<hr />
<pre>
1317       p = _ro_region.allocate(bytes, alignment);
1318       newtop = _ro_region.top();
1319     } else {
1320       oldtop = _rw_region.top();
1321       if (ref-&gt;msotype() == MetaspaceObj::ClassType) {
1322         // Save a pointer immediate in front of an InstanceKlass, so
1323         // we can do a quick lookup from InstanceKlass* -&gt; RunTimeSharedClassInfo*
1324         // without building another hashtable. See RunTimeSharedClassInfo::get_for()
1325         // in systemDictionaryShared.cpp.
1326         Klass* klass = (Klass*)obj;
1327         if (klass-&gt;is_instance_klass()) {
1328           SystemDictionaryShared::validate_before_archiving(InstanceKlass::cast(klass));
1329           _rw_region.allocate(sizeof(address), BytesPerWord);
1330         }
1331       }
1332       p = _rw_region.allocate(bytes, alignment);
1333       newtop = _rw_region.top();
1334     }
1335     memcpy(p, obj, bytes);
1336 
<span class="line-modified">1337     intptr_t* cloned_vtable = MetaspaceShared::fix_cpp_vtable_for_dynamic_archive(ref-&gt;msotype(), (address)p);</span>
<span class="line-modified">1338     if (cloned_vtable != NULL) {</span>
<span class="line-modified">1339       *(address*)p = (address)cloned_vtable;</span>
1340       ArchivePtrMarker::mark_pointer((address*)p);
1341     }
1342 
1343     assert(_new_loc_table-&gt;lookup(obj) == NULL, &quot;each object can be relocated at most once&quot;);
1344     _new_loc_table-&gt;add(obj, (address)p);
1345     log_trace(cds)(&quot;Copy: &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT &quot; %d&quot;, p2i(obj), p2i(p), bytes);
1346     if (_new_loc_table-&gt;maybe_grow(MAX_TABLE_SIZE)) {
1347       log_info(cds, hashtables)(&quot;Expanded _new_loc_table to %d&quot;, _new_loc_table-&gt;table_size());
1348     }
1349     _alloc_stats-&gt;record(ref-&gt;msotype(), int(newtop - oldtop), read_only);
1350   }
1351 
1352   static address get_new_loc(MetaspaceClosure::Ref* ref) {
1353     address* pp = _new_loc_table-&gt;lookup(ref-&gt;obj());
1354     assert(pp != NULL, &quot;must be&quot;);
1355     return *pp;
1356   }
1357 
1358 private:
1359   // Makes a shallow copy of visited MetaspaceObj&#39;s
</pre>
</td>
<td>
<hr />
<pre>
 796   f(TypeArrayKlass)
 797 
 798 class CppVtableInfo {
 799   intptr_t _vtable_size;
 800   intptr_t _cloned_vtable[1];
 801 public:
 802   static int num_slots(int vtable_size) {
 803     return 1 + vtable_size; // Need to add the space occupied by _vtable_size;
 804   }
 805   int vtable_size()           { return int(uintx(_vtable_size)); }
 806   void set_vtable_size(int n) { _vtable_size = intptr_t(n); }
 807   intptr_t* cloned_vtable()   { return &amp;_cloned_vtable[0]; }
 808   void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }
 809   // Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo
 810   static size_t byte_size(int vtable_size) {
 811     CppVtableInfo i;
 812     return pointer_delta(&amp;i._cloned_vtable[vtable_size], &amp;i, sizeof(u1));
 813   }
 814 };
 815 
<span class="line-added"> 816 static inline intptr_t* vtable_of(Metadata* m) {</span>
<span class="line-added"> 817   return *((intptr_t**)m);</span>
<span class="line-added"> 818 }</span>
<span class="line-added"> 819 </span>
 820 template &lt;class T&gt; class CppVtableCloner : public T {



 821   static CppVtableInfo* _info;
 822 
 823   static int get_vtable_length(const char* name);
 824 
 825 public:
 826   // Allocate and initialize the C++ vtable, starting from top, but do not go past end.
 827   static intptr_t* allocate(const char* name);
 828 
 829   // Clone the vtable to ...
 830   static intptr_t* clone_vtable(const char* name, CppVtableInfo* info);
 831 
 832   static void zero_vtable_clone() {
 833     assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 834     _info-&gt;zero();
 835   }
 836 
 837   static bool is_valid_shared_object(const T* obj) {
 838     intptr_t* vptr = *(intptr_t**)obj;
 839     return vptr == _info-&gt;cloned_vtable();
 840   }
<span class="line-added"> 841 </span>
<span class="line-added"> 842   static void init_orig_cpp_vtptr(int kind);</span>
 843 };
 844 
 845 template &lt;class T&gt; CppVtableInfo* CppVtableCloner&lt;T&gt;::_info = NULL;
 846 
 847 template &lt;class T&gt;
 848 intptr_t* CppVtableCloner&lt;T&gt;::allocate(const char* name) {
 849   assert(is_aligned(_mc_region.top(), sizeof(intptr_t)), &quot;bad alignment&quot;);
 850   int n = get_vtable_length(name);
 851   _info = (CppVtableInfo*)_mc_region.allocate(CppVtableInfo::byte_size(n), sizeof(intptr_t));
 852   _info-&gt;set_vtable_size(n);
 853 
 854   intptr_t* p = clone_vtable(name, _info);
 855   assert((char*)p == _mc_region.top(), &quot;must be&quot;);
 856 
 857   return _info-&gt;cloned_vtable();
 858 }
 859 
 860 template &lt;class T&gt;
 861 intptr_t* CppVtableCloner&lt;T&gt;::clone_vtable(const char* name, CppVtableInfo* info) {
 862   if (!DumpSharedSpaces) {
 863     assert(_info == 0, &quot;_info is initialized only at dump time&quot;);
 864     _info = info; // Remember it -- it will be used by MetaspaceShared::is_valid_shared_method()
 865   }
 866   T tmp; // Allocate temporary dummy metadata object to get to the original vtable.
 867   int n = info-&gt;vtable_size();
<span class="line-modified"> 868   intptr_t* srcvtable = vtable_of(&amp;tmp);</span>
 869   intptr_t* dstvtable = info-&gt;cloned_vtable();
 870 
 871   // We already checked (and, if necessary, adjusted n) when the vtables were allocated, so we are
 872   // safe to do memcpy.
 873   log_debug(cds, vtables)(&quot;Copying %3d vtable entries for %s&quot;, n, name);
 874   memcpy(dstvtable, srcvtable, sizeof(intptr_t) * n);
 875   return dstvtable + n;
 876 }
 877 
 878 // To determine the size of the vtable for each type, we use the following
 879 // trick by declaring 2 subclasses:
 880 //
 881 //   class CppVtableTesterA: public InstanceKlass {virtual int   last_virtual_method() {return 1;}    };
 882 //   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };
 883 //
 884 // CppVtableTesterA and CppVtableTesterB&#39;s vtables have the following properties:
 885 // - Their size (N+1) is exactly one more than the size of InstanceKlass&#39;s vtable (N)
 886 // - The first N entries have are exactly the same as in InstanceKlass&#39;s vtable.
 887 // - Their last entry is different.
 888 //
</pre>
<hr />
<pre>
 894 
 895 template &lt;class T&gt; class CppVtableTesterB: public T {
 896 public:
 897   virtual int last_virtual_method() {return 1;}
 898 };
 899 
 900 template &lt;class T&gt; class CppVtableTesterA : public T {
 901 public:
 902   virtual void* last_virtual_method() {
 903     // Make this different than CppVtableTesterB::last_virtual_method so the C++
 904     // compiler/linker won&#39;t alias the two functions.
 905     return NULL;
 906   }
 907 };
 908 
 909 template &lt;class T&gt;
 910 int CppVtableCloner&lt;T&gt;::get_vtable_length(const char* name) {
 911   CppVtableTesterA&lt;T&gt; a;
 912   CppVtableTesterB&lt;T&gt; b;
 913 
<span class="line-modified"> 914   intptr_t* avtable = vtable_of(&amp;a);</span>
<span class="line-modified"> 915   intptr_t* bvtable = vtable_of(&amp;b);</span>
 916 
 917   // Start at slot 1, because slot 0 may be RTTI (on Solaris/Sparc)
 918   int vtable_len = 1;
 919   for (; ; vtable_len++) {
 920     if (avtable[vtable_len] != bvtable[vtable_len]) {
 921       break;
 922     }
 923   }
 924   log_debug(cds, vtables)(&quot;Found   %3d vtable entries for %s&quot;, vtable_len, name);
 925 
 926   return vtable_len;
 927 }
 928 
 929 #define ALLOC_CPP_VTABLE_CLONE(c) \
 930   _cloned_cpp_vtptrs[c##_Kind] = CppVtableCloner&lt;c&gt;::allocate(#c); \
 931   ArchivePtrMarker::mark_pointer(&amp;_cloned_cpp_vtptrs[c##_Kind]);
 932 
 933 #define CLONE_CPP_VTABLE(c) \
 934   p = CppVtableCloner&lt;c&gt;::clone_vtable(#c, (CppVtableInfo*)p);
 935 
 936 #define ZERO_CPP_VTABLE(c) \
 937  CppVtableCloner&lt;c&gt;::zero_vtable_clone();
 938 
<span class="line-modified"> 939 #define INIT_ORIG_CPP_VTPTRS(c) \</span>
<span class="line-added"> 940   CppVtableCloner&lt;c&gt;::init_orig_cpp_vtptr(c##_Kind);</span>
<span class="line-added"> 941 </span>
 942 #define DECLARE_CLONED_VTABLE_KIND(c) c ## _Kind,
 943 
<span class="line-modified"> 944 enum ClonedVtableKind {</span>
<span class="line-modified"> 945   // E.g., ConstantPool_Kind == 0, InstanceKlass_Kind == 1, etc.</span>
 946   CPP_VTABLE_PATCH_TYPES_DO(DECLARE_CLONED_VTABLE_KIND)
 947   _num_cloned_vtable_kinds
 948 };
 949 
<span class="line-added"> 950 // This is a map of all the original vtptrs. E.g., for</span>
<span class="line-added"> 951 //     ConstantPool *cp = new (...) ConstantPool(...) ; // a dynamically allocated constant pool</span>
<span class="line-added"> 952 // the following holds true:</span>
<span class="line-added"> 953 //     _orig_cpp_vtptrs[ConstantPool_Kind] ==  ((intptr_t**)cp)[0]</span>
<span class="line-added"> 954 static intptr_t* _orig_cpp_vtptrs[_num_cloned_vtable_kinds];</span>
<span class="line-added"> 955 static bool _orig_cpp_vtptrs_inited = false;</span>
<span class="line-added"> 956 </span>
<span class="line-added"> 957 template &lt;class T&gt;</span>
<span class="line-added"> 958 void CppVtableCloner&lt;T&gt;::init_orig_cpp_vtptr(int kind) {</span>
<span class="line-added"> 959   assert(kind &lt; _num_cloned_vtable_kinds, &quot;sanity&quot;);</span>
<span class="line-added"> 960   T tmp; // Allocate temporary dummy metadata object to get to the original vtable.</span>
<span class="line-added"> 961   intptr_t* srcvtable = vtable_of(&amp;tmp);</span>
<span class="line-added"> 962   _orig_cpp_vtptrs[kind] = srcvtable;</span>
<span class="line-added"> 963 }</span>
<span class="line-added"> 964 </span>
 965 // This is the index of all the cloned vtables. E.g., for
 966 //     ConstantPool* cp = ....; // an archived constant pool
 967 //     InstanceKlass* ik = ....;// an archived class
 968 // the following holds true:
 969 //     _cloned_cpp_vtptrs[ConstantPool_Kind]  == ((intptr_t**)cp)[0]
 970 //     _cloned_cpp_vtptrs[InstanceKlass_Kind] == ((intptr_t**)ik)[0]
 971 static intptr_t** _cloned_cpp_vtptrs = NULL;
 972 
 973 void MetaspaceShared::allocate_cloned_cpp_vtptrs() {
 974   assert(DumpSharedSpaces, &quot;must&quot;);
 975   size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(intptr_t*);
 976   _cloned_cpp_vtptrs = (intptr_t**)_mc_region.allocate(vtptrs_bytes, sizeof(intptr_t*));
 977 }
 978 
 979 void MetaspaceShared::serialize_cloned_cpp_vtptrs(SerializeClosure* soc) {
 980   soc-&gt;do_ptr((void**)&amp;_cloned_cpp_vtptrs);
 981 }
 982 
<span class="line-modified"> 983 intptr_t* MetaspaceShared::get_archived_cpp_vtable(MetaspaceObj::Type msotype, address obj) {</span>
<span class="line-added"> 984   if (!_orig_cpp_vtptrs_inited) {</span>
<span class="line-added"> 985     CPP_VTABLE_PATCH_TYPES_DO(INIT_ORIG_CPP_VTPTRS);</span>
<span class="line-added"> 986     _orig_cpp_vtptrs_inited = true;</span>
<span class="line-added"> 987   }</span>
<span class="line-added"> 988 </span>
 989   Arguments::assert_is_dumping_archive();
 990   int kind = -1;
 991   switch (msotype) {
 992   case MetaspaceObj::SymbolType:
 993   case MetaspaceObj::TypeArrayU1Type:
 994   case MetaspaceObj::TypeArrayU2Type:
 995   case MetaspaceObj::TypeArrayU4Type:
 996   case MetaspaceObj::TypeArrayU8Type:
 997   case MetaspaceObj::TypeArrayOtherType:
 998   case MetaspaceObj::ConstMethodType:
 999   case MetaspaceObj::ConstantPoolCacheType:
1000   case MetaspaceObj::AnnotationsType:
1001   case MetaspaceObj::MethodCountersType:
1002   case MetaspaceObj::RecordComponentType:
1003     // These have no vtables.
1004     break;
































1005   case MetaspaceObj::MethodDataType:
1006     // We don&#39;t archive MethodData &lt;-- should have been removed in removed_unsharable_info
1007     ShouldNotReachHere();
1008     break;









1009   default:
<span class="line-modified">1010     for (kind = 0; kind &lt; _num_cloned_vtable_kinds; kind ++) {</span>
<span class="line-added">1011       if (vtable_of((Metadata*)obj) == _orig_cpp_vtptrs[kind]) {</span>
<span class="line-added">1012         break;</span>
<span class="line-added">1013       }</span>
<span class="line-added">1014     }</span>
<span class="line-added">1015     if (kind &gt;= _num_cloned_vtable_kinds) {</span>
<span class="line-added">1016       fatal(&quot;Cannot find C++ vtable for &quot; INTPTR_FORMAT &quot; -- you probably added&quot;</span>
<span class="line-added">1017             &quot; a new subtype of Klass or MetaData without updating CPP_VTABLE_PATCH_TYPES_DO&quot;,</span>
<span class="line-added">1018             p2i(obj));</span>
<span class="line-added">1019     }</span>
1020   }
1021 
1022   if (kind &gt;= 0) {
1023     assert(kind &lt; _num_cloned_vtable_kinds, &quot;must be&quot;);
1024     return _cloned_cpp_vtptrs[kind];
1025   } else {
1026     return NULL;
1027   }
1028 }
1029 


1030 // This can be called at both dump time and run time:
1031 // - clone the contents of the c++ vtables into the space
1032 //   allocated by allocate_cpp_vtable_clones()
1033 void MetaspaceShared::clone_cpp_vtables(intptr_t* p) {
1034   assert(DumpSharedSpaces || UseSharedSpaces, &quot;sanity&quot;);
1035   CPP_VTABLE_PATCH_TYPES_DO(CLONE_CPP_VTABLE);
1036 }
1037 
1038 void MetaspaceShared::zero_cpp_vtable_clones_for_writing() {
1039   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
1040   CPP_VTABLE_PATCH_TYPES_DO(ZERO_CPP_VTABLE);
1041 }
1042 
1043 // Allocate and initialize the C++ vtables, starting from top, but do not go past end.
1044 char* MetaspaceShared::allocate_cpp_vtable_clones() {
1045   char* cloned_vtables = _mc_region.top(); // This is the beginning of all the cloned vtables
1046 
1047   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
1048   // Layout (each slot is a intptr_t):
1049   //   [number of slots in the first vtable = n1]
</pre>
<hr />
<pre>
1308       p = _ro_region.allocate(bytes, alignment);
1309       newtop = _ro_region.top();
1310     } else {
1311       oldtop = _rw_region.top();
1312       if (ref-&gt;msotype() == MetaspaceObj::ClassType) {
1313         // Save a pointer immediate in front of an InstanceKlass, so
1314         // we can do a quick lookup from InstanceKlass* -&gt; RunTimeSharedClassInfo*
1315         // without building another hashtable. See RunTimeSharedClassInfo::get_for()
1316         // in systemDictionaryShared.cpp.
1317         Klass* klass = (Klass*)obj;
1318         if (klass-&gt;is_instance_klass()) {
1319           SystemDictionaryShared::validate_before_archiving(InstanceKlass::cast(klass));
1320           _rw_region.allocate(sizeof(address), BytesPerWord);
1321         }
1322       }
1323       p = _rw_region.allocate(bytes, alignment);
1324       newtop = _rw_region.top();
1325     }
1326     memcpy(p, obj, bytes);
1327 
<span class="line-modified">1328     intptr_t* archived_vtable = MetaspaceShared::get_archived_cpp_vtable(ref-&gt;msotype(), (address)p);</span>
<span class="line-modified">1329     if (archived_vtable != NULL) {</span>
<span class="line-modified">1330       *(address*)p = (address)archived_vtable;</span>
1331       ArchivePtrMarker::mark_pointer((address*)p);
1332     }
1333 
1334     assert(_new_loc_table-&gt;lookup(obj) == NULL, &quot;each object can be relocated at most once&quot;);
1335     _new_loc_table-&gt;add(obj, (address)p);
1336     log_trace(cds)(&quot;Copy: &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT &quot; %d&quot;, p2i(obj), p2i(p), bytes);
1337     if (_new_loc_table-&gt;maybe_grow(MAX_TABLE_SIZE)) {
1338       log_info(cds, hashtables)(&quot;Expanded _new_loc_table to %d&quot;, _new_loc_table-&gt;table_size());
1339     }
1340     _alloc_stats-&gt;record(ref-&gt;msotype(), int(newtop - oldtop), read_only);
1341   }
1342 
1343   static address get_new_loc(MetaspaceClosure::Ref* ref) {
1344     address* pp = _new_loc_table-&gt;lookup(ref-&gt;obj());
1345     assert(pp != NULL, &quot;must be&quot;);
1346     return *pp;
1347   }
1348 
1349 private:
1350   // Makes a shallow copy of visited MetaspaceObj&#39;s
</pre>
</td>
</tr>
</table>
<center><a href="dynamicArchive.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
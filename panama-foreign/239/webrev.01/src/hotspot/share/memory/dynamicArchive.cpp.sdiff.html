<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/dynamicArchive.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../jvmci/vmStructs_jvmci.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/dynamicArchive.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 453 
 454   address copy_impl(MetaspaceClosure::Ref* ref, bool read_only, int bytes) {
 455     if (ref-&gt;msotype() == MetaspaceObj::ClassType) {
 456       // Save a pointer immediate in front of an InstanceKlass, so
 457       // we can do a quick lookup from InstanceKlass* -&gt; RunTimeSharedClassInfo*
 458       // without building another hashtable. See RunTimeSharedClassInfo::get_for()
 459       // in systemDictionaryShared.cpp.
 460       address obj = ref-&gt;obj();
 461       Klass* klass = (Klass*)obj;
 462       if (klass-&gt;is_instance_klass()) {
 463         SystemDictionaryShared::validate_before_archiving(InstanceKlass::cast(klass));
 464         current_dump_space()-&gt;allocate(sizeof(address), BytesPerWord);
 465       }
 466     }
 467     address p = (address)current_dump_space()-&gt;allocate(bytes);
 468     address obj = ref-&gt;obj();
 469     log_debug(cds, dynamic)(&quot;COPY: &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT &quot; %5d %s&quot;,
 470                             p2i(obj), p2i(p), bytes,
 471                             MetaspaceObj::type_name(ref-&gt;msotype()));
 472     memcpy(p, obj, bytes);
<span class="line-modified"> 473     intptr_t* cloned_vtable = MetaspaceShared::fix_cpp_vtable_for_dynamic_archive(ref-&gt;msotype(), p);</span>
<span class="line-modified"> 474     if (cloned_vtable != NULL) {</span>
<span class="line-modified"> 475       update_pointer((address*)p, (address)cloned_vtable, &quot;vtb&quot;, 0, /*is_mso_pointer*/false);</span>
 476       mark_pointer((address*)p);
 477     }
 478 
 479     return (address)p;
 480   }
 481 
 482   DynamicArchiveHeader *_header;
 483   address _alloc_bottom;
 484   address _last_verified_top;
 485   size_t _other_region_used_bytes;
 486 
 487   // Conservative estimate for number of bytes needed for:
 488   size_t _estimated_metsapceobj_bytes;   // all archived MetsapceObj&#39;s.
 489   size_t _estimated_hashtable_bytes;     // symbol table and dictionaries
 490   size_t _estimated_trampoline_bytes;    // method entry trampolines
 491 
 492   size_t estimate_archive_size();
 493   size_t estimate_trampoline_size();
 494   size_t estimate_class_file_size();
 495   address reserve_space_and_init_buffer_to_target_delta();
</pre>
</td>
<td>
<hr />
<pre>
 453 
 454   address copy_impl(MetaspaceClosure::Ref* ref, bool read_only, int bytes) {
 455     if (ref-&gt;msotype() == MetaspaceObj::ClassType) {
 456       // Save a pointer immediate in front of an InstanceKlass, so
 457       // we can do a quick lookup from InstanceKlass* -&gt; RunTimeSharedClassInfo*
 458       // without building another hashtable. See RunTimeSharedClassInfo::get_for()
 459       // in systemDictionaryShared.cpp.
 460       address obj = ref-&gt;obj();
 461       Klass* klass = (Klass*)obj;
 462       if (klass-&gt;is_instance_klass()) {
 463         SystemDictionaryShared::validate_before_archiving(InstanceKlass::cast(klass));
 464         current_dump_space()-&gt;allocate(sizeof(address), BytesPerWord);
 465       }
 466     }
 467     address p = (address)current_dump_space()-&gt;allocate(bytes);
 468     address obj = ref-&gt;obj();
 469     log_debug(cds, dynamic)(&quot;COPY: &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT &quot; %5d %s&quot;,
 470                             p2i(obj), p2i(p), bytes,
 471                             MetaspaceObj::type_name(ref-&gt;msotype()));
 472     memcpy(p, obj, bytes);
<span class="line-modified"> 473     intptr_t* archived_vtable = MetaspaceShared::get_archived_cpp_vtable(ref-&gt;msotype(), p);</span>
<span class="line-modified"> 474     if (archived_vtable != NULL) {</span>
<span class="line-modified"> 475       update_pointer((address*)p, (address)archived_vtable, &quot;vtb&quot;, 0, /*is_mso_pointer*/false);</span>
 476       mark_pointer((address*)p);
 477     }
 478 
 479     return (address)p;
 480   }
 481 
 482   DynamicArchiveHeader *_header;
 483   address _alloc_bottom;
 484   address _last_verified_top;
 485   size_t _other_region_used_bytes;
 486 
 487   // Conservative estimate for number of bytes needed for:
 488   size_t _estimated_metsapceobj_bytes;   // all archived MetsapceObj&#39;s.
 489   size_t _estimated_hashtable_bytes;     // symbol table and dictionaries
 490   size_t _estimated_trampoline_bytes;    // method entry trampolines
 491 
 492   size_t estimate_archive_size();
 493   size_t estimate_trampoline_size();
 494   size_t estimate_class_file_size();
 495   address reserve_space_and_init_buffer_to_target_delta();
</pre>
</td>
</tr>
</table>
<center><a href="../jvmci/vmStructs_jvmci.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
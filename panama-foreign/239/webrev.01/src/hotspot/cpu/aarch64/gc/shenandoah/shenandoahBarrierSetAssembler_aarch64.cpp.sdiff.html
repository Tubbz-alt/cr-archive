<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/gc/shenandoah/shenandoahBarrierSetAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="c1/shenandoahBarrierSetC1_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/gc/shenandoah/shenandoahBarrierSetAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
432 void ShenandoahBarrierSetAssembler::try_resolve_jobject_in_native(MacroAssembler* masm, Register jni_env,
433                                                                   Register obj, Register tmp, Label&amp; slowpath) {
434   Label done;
435   // Resolve jobject
436   BarrierSetAssembler::try_resolve_jobject_in_native(masm, jni_env, obj, tmp, slowpath);
437 
438   // Check for null.
439   __ cbz(obj, done);
440 
441   assert(obj != rscratch2, &quot;need rscratch2&quot;);
442   Address gc_state(jni_env, ShenandoahThreadLocalData::gc_state_offset() - JavaThread::jni_environment_offset());
443   __ lea(rscratch2, gc_state);
444   __ ldrb(rscratch2, Address(rscratch2));
445 
446   // Check for heap in evacuation phase
447   __ tbnz(rscratch2, ShenandoahHeap::EVACUATION_BITPOS, slowpath);
448 
449   __ bind(done);
450 }
451 
<span class="line-modified">452 </span>
<span class="line-modified">453 void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm, Register addr, Register expected, Register new_val,</span>
<span class="line-modified">454                                                 bool acquire, bool release, bool weak, bool is_cae,</span>























































455                                                 Register result) {
456   Register tmp1 = rscratch1;
457   Register tmp2 = rscratch2;
458   bool is_narrow = UseCompressedOops;
459   Assembler::operand_size size = is_narrow ? Assembler::word : Assembler::xword;
460 
461   assert_different_registers(addr, expected, new_val, tmp1, tmp2);
462 
<span class="line-modified">463   Label retry, done, fail;</span>
464 
<span class="line-modified">465   // CAS, using LL/SC pair.</span>
<span class="line-modified">466   __ bind(retry);</span>
<span class="line-modified">467   __ load_exclusive(tmp1, addr, size, acquire);</span>
<span class="line-modified">468   if (is_narrow) {</span>
<span class="line-modified">469     __ cmpw(tmp1, expected);</span>
<span class="line-modified">470   } else {</span>
<span class="line-modified">471     __ cmp(tmp1, expected);</span>
<span class="line-modified">472   }</span>
<span class="line-modified">473   __ br(Assembler::NE, fail);</span>
<span class="line-modified">474   __ store_exclusive(tmp2, new_val, addr, size, release);</span>
<span class="line-modified">475   if (weak) {</span>
<span class="line-modified">476     __ cmpw(tmp2, 0u); // If the store fails, return NE to our caller</span>
<span class="line-modified">477   } else {</span>
<span class="line-modified">478     __ cbnzw(tmp2, retry);</span>
<span class="line-modified">479   }</span>
<span class="line-modified">480   __ b(done);</span>












































481 
<span class="line-removed">482  __  bind(fail);</span>
<span class="line-removed">483   // Check if rb(expected)==rb(tmp1)</span>
<span class="line-removed">484   // Shuffle registers so that we have memory value ready for next expected.</span>
<span class="line-removed">485   __ mov(tmp2, expected);</span>
<span class="line-removed">486   __ mov(expected, tmp1);</span>
487   if (is_narrow) {

488     __ decode_heap_oop(tmp1, tmp1);
<span class="line-removed">489     __ decode_heap_oop(tmp2, tmp2);</span>
490   }
491   resolve_forward_pointer(masm, tmp1);
<span class="line-modified">492   resolve_forward_pointer(masm, tmp2);</span>
<span class="line-modified">493   __ cmp(tmp1, tmp2);</span>
<span class="line-modified">494   // Retry with expected now being the value we just loaded from addr.</span>
<span class="line-modified">495   __ br(Assembler::EQ, retry);</span>
<span class="line-modified">496   if (is_cae &amp;&amp; is_narrow) {</span>
<span class="line-modified">497     // For cmp-and-exchange and narrow oops, we need to restore</span>
<span class="line-modified">498     // the compressed old-value. We moved it to &#39;expected&#39; a few lines up.</span>
<span class="line-modified">499     __ mov(tmp1, expected);</span>
































500   }

501   __ bind(done);




502 
503   if (is_cae) {
<span class="line-modified">504     __ mov(result, tmp1);</span>
505   } else {
506     __ cset(result, Assembler::EQ);
507   }
508 }
509 
510 #undef __
511 
512 #ifdef COMPILER1
513 
514 #define __ ce-&gt;masm()-&gt;
515 
516 void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub) {
517   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
518   // At this point we know that marking is in progress.
519   // If do_load() is true then we have to emit the
520   // load of the previous value; otherwise it has already
521   // been loaded into _pre_val.
522 
523   __ bind(*stub-&gt;entry());
524 
</pre>
</td>
<td>
<hr />
<pre>
432 void ShenandoahBarrierSetAssembler::try_resolve_jobject_in_native(MacroAssembler* masm, Register jni_env,
433                                                                   Register obj, Register tmp, Label&amp; slowpath) {
434   Label done;
435   // Resolve jobject
436   BarrierSetAssembler::try_resolve_jobject_in_native(masm, jni_env, obj, tmp, slowpath);
437 
438   // Check for null.
439   __ cbz(obj, done);
440 
441   assert(obj != rscratch2, &quot;need rscratch2&quot;);
442   Address gc_state(jni_env, ShenandoahThreadLocalData::gc_state_offset() - JavaThread::jni_environment_offset());
443   __ lea(rscratch2, gc_state);
444   __ ldrb(rscratch2, Address(rscratch2));
445 
446   // Check for heap in evacuation phase
447   __ tbnz(rscratch2, ShenandoahHeap::EVACUATION_BITPOS, slowpath);
448 
449   __ bind(done);
450 }
451 
<span class="line-modified">452 // Special Shenandoah CAS implementation that handles false negatives due</span>
<span class="line-modified">453 // to concurrent evacuation.  The service is more complex than a</span>
<span class="line-modified">454 // traditional CAS operation because the CAS operation is intended to</span>
<span class="line-added">455 // succeed if the reference at addr exactly matches expected or if the</span>
<span class="line-added">456 // reference at addr holds a pointer to a from-space object that has</span>
<span class="line-added">457 // been relocated to the location named by expected.  There are two</span>
<span class="line-added">458 // races that must be addressed:</span>
<span class="line-added">459 //  a) A parallel thread may mutate the contents of addr so that it points</span>
<span class="line-added">460 //     to a different object.  In this case, the CAS operation should fail.</span>
<span class="line-added">461 //  b) A parallel thread may heal the contents of addr, replacing a</span>
<span class="line-added">462 //     from-space pointer held in addr with the to-space pointer</span>
<span class="line-added">463 //     representing the new location of the object.</span>
<span class="line-added">464 // Upon entry to cmpxchg_oop, it is assured that new_val equals NULL</span>
<span class="line-added">465 // or it refers to an object that is not being evacuated out of</span>
<span class="line-added">466 // from-space, or it refers to the to-space version of an object that</span>
<span class="line-added">467 // is being evacuated out of from-space.</span>
<span class="line-added">468 //</span>
<span class="line-added">469 // By default, this operation implements sequential consistency and the</span>
<span class="line-added">470 // value held in the result register following execution of the</span>
<span class="line-added">471 // generated code sequence is 0 to indicate failure of CAS, non-zero</span>
<span class="line-added">472 // to indicate success.  Arguments support variations on this theme:</span>
<span class="line-added">473 //</span>
<span class="line-added">474 //  acquire: Allow relaxation of the memory ordering on CAS from</span>
<span class="line-added">475 //           sequential consistency.  This can be useful when</span>
<span class="line-added">476 //           sequential consistency is not required, such as when</span>
<span class="line-added">477 //           another sequentially consistent operation is already</span>
<span class="line-added">478 //           present in the execution stream.  If acquire, successful</span>
<span class="line-added">479 //           execution has the side effect of assuring that memory</span>
<span class="line-added">480 //           values updated by other threads and &quot;released&quot; will be</span>
<span class="line-added">481 //           visible to any read operations perfomed by this thread</span>
<span class="line-added">482 //           which follow this operation in program order.  This is a</span>
<span class="line-added">483 //           special optimization that should not be enabled by default.</span>
<span class="line-added">484 //  release: Allow relaxation of the memory ordering on CAS from</span>
<span class="line-added">485 //           sequential consistency.  This can be useful when</span>
<span class="line-added">486 //           sequential consistency is not required, such as when</span>
<span class="line-added">487 //           another sequentially consistent operation is already</span>
<span class="line-added">488 //           present in the execution stream.  If release, successful</span>
<span class="line-added">489 //           completion of this operation has the side effect of</span>
<span class="line-added">490 //           assuring that all writes to memory performed by this</span>
<span class="line-added">491 //           thread that precede this operation in program order are</span>
<span class="line-added">492 //           visible to all other threads that subsequently &quot;acquire&quot;</span>
<span class="line-added">493 //           before reading the respective memory values.  This is a</span>
<span class="line-added">494 //           special optimization that should not be enabled by default.</span>
<span class="line-added">495 //  is_cae:  This turns CAS (compare and swap) into CAE (compare and</span>
<span class="line-added">496 //           exchange).  This HotSpot convention is that CAE makes</span>
<span class="line-added">497 //           available to the caller the &quot;failure witness&quot;, which is</span>
<span class="line-added">498 //           the value that was stored in memory which did not match</span>
<span class="line-added">499 //           the expected value.  If is_cae, the result is the value</span>
<span class="line-added">500 //           most recently fetched from addr rather than a boolean</span>
<span class="line-added">501 //           success indicator.</span>
<span class="line-added">502 //</span>
<span class="line-added">503 // Clobbers rscratch1, rscratch2</span>
<span class="line-added">504 void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm,</span>
<span class="line-added">505                                                 Register addr,</span>
<span class="line-added">506                                                 Register expected,</span>
<span class="line-added">507                                                 Register new_val,</span>
<span class="line-added">508                                                 bool acquire, bool release,</span>
<span class="line-added">509                                                 bool is_cae,</span>
510                                                 Register result) {
511   Register tmp1 = rscratch1;
512   Register tmp2 = rscratch2;
513   bool is_narrow = UseCompressedOops;
514   Assembler::operand_size size = is_narrow ? Assembler::word : Assembler::xword;
515 
516   assert_different_registers(addr, expected, new_val, tmp1, tmp2);
517 
<span class="line-modified">518   Label step4, done;</span>
519 
<span class="line-modified">520   // There are two ways to reach this label.  Initial entry into the</span>
<span class="line-modified">521   // cmpxchg_oop code expansion starts at step1 (which is equivalent</span>
<span class="line-modified">522   // to label step4).  Additionally, in the rare case that four steps</span>
<span class="line-modified">523   // are required to perform the requested operation, the fourth step</span>
<span class="line-modified">524   // is the same as the first.  On a second pass through step 1,</span>
<span class="line-modified">525   // control may flow through step 2 on its way to failure.  It will</span>
<span class="line-modified">526   // not flow from step 2 to step 3 since we are assured that the</span>
<span class="line-modified">527   // memory at addr no longer holds a from-space pointer.</span>
<span class="line-modified">528   //</span>
<span class="line-modified">529   // The comments that immediately follow the step4 label apply only</span>
<span class="line-modified">530   // to the case in which control reaches this label by branch from</span>
<span class="line-modified">531   // step 3.</span>
<span class="line-modified">532 </span>
<span class="line-modified">533   __ bind (step4);</span>
<span class="line-modified">534 </span>
<span class="line-modified">535   // Step 4. CAS has failed because the value most recently fetched</span>
<span class="line-added">536   // from addr (which is now held in tmp1) is no longer the from-space</span>
<span class="line-added">537   // pointer held in tmp2.  If a different thread replaced the</span>
<span class="line-added">538   // in-memory value with its equivalent to-space pointer, then CAS</span>
<span class="line-added">539   // may still be able to succeed.  The value held in the expected</span>
<span class="line-added">540   // register has not changed.</span>
<span class="line-added">541   //</span>
<span class="line-added">542   // It is extremely rare we reach this point.  For this reason, the</span>
<span class="line-added">543   // implementation opts for smaller rather than potentially faster</span>
<span class="line-added">544   // code.  Ultimately, smaller code for this rare case most likely</span>
<span class="line-added">545   // delivers higher overall throughput by enabling improved icache</span>
<span class="line-added">546   // performance.</span>
<span class="line-added">547 </span>
<span class="line-added">548   // Step 1. Fast-path.</span>
<span class="line-added">549   //</span>
<span class="line-added">550   // Try to CAS with given arguments.  If successful, then we are done.</span>
<span class="line-added">551   //</span>
<span class="line-added">552   // No label required for step 1.</span>
<span class="line-added">553 </span>
<span class="line-added">554   __ cmpxchg(addr, expected, new_val, size, acquire, release, false, tmp2);</span>
<span class="line-added">555   // EQ flag set iff success.  tmp2 holds value fetched.</span>
<span class="line-added">556 </span>
<span class="line-added">557   // If expected equals null but tmp2 does not equal null, the</span>
<span class="line-added">558   // following branches to done to report failure of CAS.  If both</span>
<span class="line-added">559   // expected and tmp2 equal null, the following branches to done to</span>
<span class="line-added">560   // report success of CAS.  There&#39;s no need for a special test of</span>
<span class="line-added">561   // expected equal to null.</span>
<span class="line-added">562 </span>
<span class="line-added">563   __ br(Assembler::EQ, done);</span>
<span class="line-added">564   // if CAS failed, fall through to step 2</span>
<span class="line-added">565 </span>
<span class="line-added">566   // Step 2. CAS has failed because the value held at addr does not</span>
<span class="line-added">567   // match expected.  This may be a false negative because the value fetched</span>
<span class="line-added">568   // from addr (now held in tmp2) may be a from-space pointer to the</span>
<span class="line-added">569   // original copy of same object referenced by to-space pointer expected.</span>
<span class="line-added">570   //</span>
<span class="line-added">571   // To resolve this, it suffices to find the forward pointer associated</span>
<span class="line-added">572   // with fetched value.  If this matches expected, retry CAS with new</span>
<span class="line-added">573   // parameters.  If this mismatches, then we have a legitimate</span>
<span class="line-added">574   // failure, and we&#39;re done.</span>
<span class="line-added">575   //</span>
<span class="line-added">576   // No need for step2 label.</span>
<span class="line-added">577 </span>
<span class="line-added">578   // overwrite tmp1 with from-space pointer fetched from memory</span>
<span class="line-added">579   __ mov(tmp1, tmp2);</span>
580 





581   if (is_narrow) {
<span class="line-added">582     // Decode tmp1 in order to resolve its forward pointer</span>
583     __ decode_heap_oop(tmp1, tmp1);

584   }
585   resolve_forward_pointer(masm, tmp1);
<span class="line-modified">586   // Encode tmp1 to compare against expected.</span>
<span class="line-modified">587   __ encode_heap_oop(tmp1, tmp1);</span>
<span class="line-modified">588 </span>
<span class="line-modified">589   // Does forwarded value of fetched from-space pointer match original</span>
<span class="line-modified">590   // value of expected?  If tmp1 holds null, this comparison will fail</span>
<span class="line-modified">591   // because we know from step1 that expected is not null.  There is</span>
<span class="line-modified">592   // no need for a separate test for tmp1 (the value originally held</span>
<span class="line-modified">593   // in memory) equal to null.</span>
<span class="line-added">594   __ cmp(tmp1, expected);</span>
<span class="line-added">595 </span>
<span class="line-added">596   // If not, then the failure was legitimate and we&#39;re done.</span>
<span class="line-added">597   // Branching to done with NE condition denotes failure.</span>
<span class="line-added">598   __ br(Assembler::NE, done);</span>
<span class="line-added">599 </span>
<span class="line-added">600   // Fall through to step 3.  No need for step3 label.</span>
<span class="line-added">601 </span>
<span class="line-added">602   // Step 3.  We&#39;ve confirmed that the value originally held in memory</span>
<span class="line-added">603   // (now held in tmp2) pointed to from-space version of original</span>
<span class="line-added">604   // expected value.  Try the CAS again with the from-space expected</span>
<span class="line-added">605   // value.  If it now succeeds, we&#39;re good.</span>
<span class="line-added">606   //</span>
<span class="line-added">607   // Note: tmp2 holds encoded from-space pointer that matches to-space</span>
<span class="line-added">608   // object residing at expected.  tmp2 is the new &quot;expected&quot;.</span>
<span class="line-added">609 </span>
<span class="line-added">610   // Note that macro implementation of __cmpxchg cannot use same register</span>
<span class="line-added">611   // tmp2 for result and expected since it overwrites result before it</span>
<span class="line-added">612   // compares result with expected.</span>
<span class="line-added">613   __ cmpxchg(addr, tmp2, new_val, size, acquire, release, false, tmp1);</span>
<span class="line-added">614   // EQ flag set iff success.  tmp2 holds value fetched.</span>
<span class="line-added">615 </span>
<span class="line-added">616   // If fetched value did not equal the new expected, this could</span>
<span class="line-added">617   // still be a false negative because some other thread may have</span>
<span class="line-added">618   // newly overwritten the memory value with its to-space equivalent.</span>
<span class="line-added">619   __ br(Assembler::NE, step4);</span>
<span class="line-added">620 </span>
<span class="line-added">621   if (is_cae) {</span>
<span class="line-added">622     // We&#39;re falling through to done to indicate success.  Success</span>
<span class="line-added">623     // with is_cae is denoted by returning the value of expected as</span>
<span class="line-added">624     // result.</span>
<span class="line-added">625     __ mov(tmp2, expected);</span>
626   }
<span class="line-added">627 </span>
628   __ bind(done);
<span class="line-added">629   // At entry to done, the Z (EQ) flag is on iff if the CAS</span>
<span class="line-added">630   // operation was successful.  Additionally, if is_cae, tmp2 holds</span>
<span class="line-added">631   // the value most recently fetched from addr. In this case, success</span>
<span class="line-added">632   // is denoted by tmp2 matching expected.</span>
633 
634   if (is_cae) {
<span class="line-modified">635     __ mov(result, tmp2);</span>
636   } else {
637     __ cset(result, Assembler::EQ);
638   }
639 }
640 
641 #undef __
642 
643 #ifdef COMPILER1
644 
645 #define __ ce-&gt;masm()-&gt;
646 
647 void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub) {
648   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
649   // At this point we know that marking is in progress.
650   // If do_load() is true then we have to emit the
651   // load of the previous value; otherwise it has already
652   // been loaded into _pre_val.
653 
654   __ bind(*stub-&gt;entry());
655 
</pre>
</td>
</tr>
</table>
<center><a href="c1/shenandoahBarrierSetC1_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
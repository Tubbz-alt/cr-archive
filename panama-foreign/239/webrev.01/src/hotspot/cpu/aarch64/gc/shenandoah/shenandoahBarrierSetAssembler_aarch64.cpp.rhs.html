<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/gc/shenandoah/shenandoahBarrierSetAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
 27 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
 33 #include &quot;gc/shenandoah/heuristics/shenandoahHeuristics.hpp&quot;
 34 #include &quot;interpreter/interpreter.hpp&quot;
 35 #include &quot;interpreter/interp_masm.hpp&quot;
 36 #include &quot;runtime/sharedRuntime.hpp&quot;
 37 #include &quot;runtime/thread.hpp&quot;
 38 #ifdef COMPILER1
 39 #include &quot;c1/c1_LIRAssembler.hpp&quot;
 40 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 41 #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
 42 #endif
 43 
 44 #define __ masm-&gt;
 45 
 46 address ShenandoahBarrierSetAssembler::_shenandoah_lrb = NULL;
 47 
 48 void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,
 49                                                        Register src, Register dst, Register count, RegSet saved_regs) {
 50   if (is_oop) {
 51     bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
 52     if ((ShenandoahSATBBarrier &amp;&amp; !dest_uninitialized) || ShenandoahStoreValEnqueueBarrier || ShenandoahLoadRefBarrier) {
 53 
 54       Label done;
 55 
 56       // Avoid calling runtime if count == 0
 57       __ cbz(count, done);
 58 
 59       // Is GC active?
 60       Address gc_state(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 61       __ ldrb(rscratch1, gc_state);
 62       if (ShenandoahSATBBarrier &amp;&amp; dest_uninitialized) {
 63         __ tbz(rscratch1, ShenandoahHeap::HAS_FORWARDED_BITPOS, done);
 64       } else {
 65         __ mov(rscratch2, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::MARKING);
 66         __ tst(rscratch1, rscratch2);
 67         __ br(Assembler::EQ, done);
 68       }
 69 
 70       __ push(saved_regs, sp);
 71       if (UseCompressedOops) {
 72         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_narrow_oop_entry), src, dst, count);
 73       } else {
 74         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_oop_entry), src, dst, count);
 75       }
 76       __ pop(saved_regs, sp);
 77       __ bind(done);
 78     }
 79   }
 80 }
 81 
 82 void ShenandoahBarrierSetAssembler::shenandoah_write_barrier_pre(MacroAssembler* masm,
 83                                                                  Register obj,
 84                                                                  Register pre_val,
 85                                                                  Register thread,
 86                                                                  Register tmp,
 87                                                                  bool tosca_live,
 88                                                                  bool expand_call) {
 89   if (ShenandoahSATBBarrier) {
 90     satb_write_barrier_pre(masm, obj, pre_val, thread, tmp, tosca_live, expand_call);
 91   }
 92 }
 93 
 94 void ShenandoahBarrierSetAssembler::satb_write_barrier_pre(MacroAssembler* masm,
 95                                                            Register obj,
 96                                                            Register pre_val,
 97                                                            Register thread,
 98                                                            Register tmp,
 99                                                            bool tosca_live,
100                                                            bool expand_call) {
101   // If expand_call is true then we expand the call_VM_leaf macro
102   // directly to skip generating the check by
103   // InterpreterMacroAssembler::call_VM_leaf_base that checks _last_sp.
104 
105   assert(thread == rthread, &quot;must be&quot;);
106 
107   Label done;
108   Label runtime;
109 
110   assert_different_registers(obj, pre_val, tmp, rscratch1);
111   assert(pre_val != noreg &amp;&amp;  tmp != noreg, &quot;expecting a register&quot;);
112 
113   Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));
114   Address index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
115   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
116 
117   // Is marking active?
118   if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {
119     __ ldrw(tmp, in_progress);
120   } else {
121     assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, &quot;Assumption&quot;);
122     __ ldrb(tmp, in_progress);
123   }
124   __ cbzw(tmp, done);
125 
126   // Do we need to load the previous value?
127   if (obj != noreg) {
128     __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);
129   }
130 
131   // Is the previous value null?
132   __ cbz(pre_val, done);
133 
134   // Can we store original value in the thread&#39;s buffer?
135   // Is index == 0?
136   // (The index field is typed as size_t.)
137 
138   __ ldr(tmp, index);                      // tmp := *index_adr
139   __ cbz(tmp, runtime);                    // tmp == 0?
140                                         // If yes, goto runtime
141 
142   __ sub(tmp, tmp, wordSize);              // tmp := tmp - wordSize
143   __ str(tmp, index);                      // *index_adr := tmp
144   __ ldr(rscratch1, buffer);
145   __ add(tmp, tmp, rscratch1);             // tmp := tmp + *buffer_adr
146 
147   // Record the previous value
148   __ str(pre_val, Address(tmp, 0));
149   __ b(done);
150 
151   __ bind(runtime);
152   // save the live input values
153   RegSet saved = RegSet::of(pre_val);
154   if (tosca_live) saved += RegSet::of(r0);
155   if (obj != noreg) saved += RegSet::of(obj);
156 
157   __ push(saved, sp);
158 
159   // Calling the runtime using the regular call_VM_leaf mechanism generates
160   // code (generated by InterpreterMacroAssember::call_VM_leaf_base)
161   // that checks that the *(rfp+frame::interpreter_frame_last_sp) == NULL.
162   //
163   // If we care generating the pre-barrier without a frame (e.g. in the
164   // intrinsified Reference.get() routine) then ebp might be pointing to
165   // the caller frame and so this check will most likely fail at runtime.
166   //
167   // Expanding the call directly bypasses the generation of the check.
168   // So when we do not have have a full interpreter frame on the stack
169   // expand_call should be passed true.
170 
171   if (expand_call) {
172     assert(pre_val != c_rarg1, &quot;smashed arg&quot;);
173     __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);
174   } else {
175     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);
176   }
177 
178   __ pop(saved, sp);
179 
180   __ bind(done);
181 }
182 
183 void ShenandoahBarrierSetAssembler::resolve_forward_pointer(MacroAssembler* masm, Register dst, Register tmp) {
184   assert(ShenandoahLoadRefBarrier || ShenandoahCASBarrier, &quot;Should be enabled&quot;);
185   Label is_null;
186   __ cbz(dst, is_null);
187   resolve_forward_pointer_not_null(masm, dst, tmp);
188   __ bind(is_null);
189 }
190 
191 // IMPORTANT: This must preserve all registers, even rscratch1 and rscratch2, except those explicitely
192 // passed in.
193 void ShenandoahBarrierSetAssembler::resolve_forward_pointer_not_null(MacroAssembler* masm, Register dst, Register tmp) {
194   assert(ShenandoahLoadRefBarrier || ShenandoahCASBarrier, &quot;Should be enabled&quot;);
195   // The below loads the mark word, checks if the lowest two bits are
196   // set, and if so, clear the lowest two bits and copy the result
197   // to dst. Otherwise it leaves dst alone.
198   // Implementing this is surprisingly awkward. I do it here by:
199   // - Inverting the mark word
200   // - Test lowest two bits == 0
201   // - If so, set the lowest two bits
202   // - Invert the result back, and copy to dst
203 
204   bool borrow_reg = (tmp == noreg);
205   if (borrow_reg) {
206     // No free registers available. Make one useful.
207     tmp = rscratch1;
208     if (tmp == dst) {
209       tmp = rscratch2;
210     }
211     __ push(RegSet::of(tmp), sp);
212   }
213 
214   assert_different_registers(tmp, dst);
215 
216   Label done;
217   __ ldr(tmp, Address(dst, oopDesc::mark_offset_in_bytes()));
218   __ eon(tmp, tmp, zr);
219   __ ands(zr, tmp, markWord::lock_mask_in_place);
220   __ br(Assembler::NE, done);
221   __ orr(tmp, tmp, markWord::marked_value);
222   __ eon(dst, tmp, zr);
223   __ bind(done);
224 
225   if (borrow_reg) {
226     __ pop(RegSet::of(tmp), sp);
227   }
228 }
229 
230 void ShenandoahBarrierSetAssembler::load_reference_barrier_not_null(MacroAssembler* masm, Register dst, Address load_addr) {
231   assert(ShenandoahLoadRefBarrier, &quot;Should be enabled&quot;);
232   assert(dst != rscratch2, &quot;need rscratch2&quot;);
233   assert_different_registers(load_addr.base(), load_addr.index(), rscratch1, rscratch2);
234 
235   Label done;
236   __ enter();
237   Address gc_state(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
238   __ ldrb(rscratch2, gc_state);
239 
240   // Check for heap stability
241   __ tbz(rscratch2, ShenandoahHeap::HAS_FORWARDED_BITPOS, done);
242 
243   // use r1 for load address
244   Register result_dst = dst;
245   if (dst == r1) {
246     __ mov(rscratch1, dst);
247     dst = rscratch1;
248   }
249 
250   // Save r0 and r1, unless it is an output register
251   RegSet to_save = RegSet::of(r0, r1) - result_dst;
252   __ push(to_save, sp);
253   __ lea(r1, load_addr);
254   __ mov(r0, dst);
255 
256   __ far_call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_lrb())));
257 
258   __ mov(result_dst, r0);
259   __ pop(to_save, sp);
260 
261   __ bind(done);
262   __ leave();
263 }
264 
265 void ShenandoahBarrierSetAssembler::load_reference_barrier_native(MacroAssembler* masm, Register dst, Address load_addr) {
266   if (!ShenandoahLoadRefBarrier) {
267     return;
268   }
269 
270   assert(dst != rscratch2, &quot;need rscratch2&quot;);
271 
272   Label is_null;
273   Label done;
274 
275   __ block_comment(&quot;load_reference_barrier_native { &quot;);
276 
277   __ cbz(dst, is_null);
278 
279   __ enter();
280 
281   Address gc_state(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
282   __ ldrb(rscratch2, gc_state);
283 
284   // Check for heap in evacuation phase
285   __ tbz(rscratch2, ShenandoahHeap::EVACUATION_BITPOS, done);
286 
287   __ mov(rscratch2, dst);
288   __ push_call_clobbered_registers();
289   __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native));
290   __ lea(r1, load_addr);
291   __ mov(r0, rscratch2);
292   __ blr(lr);
293   __ mov(rscratch2, r0);
294   __ pop_call_clobbered_registers();
295   __ mov(dst, rscratch2);
296 
297   __ bind(done);
298   __ leave();
299   __ bind(is_null);
300   __ block_comment(&quot;} load_reference_barrier_native&quot;);
301 }
302 
303 void ShenandoahBarrierSetAssembler::storeval_barrier(MacroAssembler* masm, Register dst, Register tmp) {
304   if (ShenandoahStoreValEnqueueBarrier) {
305     // Save possibly live regs.
306     RegSet live_regs = RegSet::range(r0, r4) - dst;
307     __ push(live_regs, sp);
308     __ strd(v0, __ pre(sp, 2 * -wordSize));
309 
310     satb_write_barrier_pre(masm, noreg, dst, rthread, tmp, true, false);
311 
312     // Restore possibly live regs.
313     __ ldrd(v0, __ post(sp, 2 * wordSize));
314     __ pop(live_regs, sp);
315   }
316 }
317 
318 void ShenandoahBarrierSetAssembler::load_reference_barrier(MacroAssembler* masm, Register dst, Address load_addr) {
319   if (ShenandoahLoadRefBarrier) {
320     Label is_null;
321     __ cbz(dst, is_null);
322     load_reference_barrier_not_null(masm, dst, load_addr);
323     __ bind(is_null);
324   }
325 }
326 
327 //
328 // Arguments:
329 //
330 // Inputs:
331 //   src:        oop location to load from, might be clobbered
332 //
333 // Output:
334 //   dst:        oop loaded from src location
335 //
336 // Kill:
337 //   rscratch1 (scratch reg)
338 //
339 // Alias:
340 //   dst: rscratch1 (might use rscratch1 as temporary output register to avoid clobbering src)
341 //
342 void ShenandoahBarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
343                                             Register dst, Address src, Register tmp1, Register tmp_thread) {
344   // 1: non-reference load, no additional barrier is needed
345   if (!is_reference_type(type)) {
346     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);
347     return;
348   }
349 
350   // 2: load a reference from src location and apply LRB if needed
351   if (ShenandoahBarrierSet::need_load_reference_barrier(decorators, type)) {
352     Register result_dst = dst;
353 
354     // Preserve src location for LRB
355     if (dst == src.base() || dst == src.index()) {
356       dst = rscratch1;
357     }
358     assert_different_registers(dst, src.base(), src.index());
359 
360     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);
361 
362     if (ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type)) {
363       load_reference_barrier_native(masm, dst, src);
364     } else {
365       load_reference_barrier(masm, dst, src);
366     }
367 
368     if (dst != result_dst) {
369       __ mov(result_dst, dst);
370       dst = result_dst;
371     }
372   } else {
373     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);
374   }
375 
376   // 3: apply keep-alive barrier if needed
377   if (ShenandoahBarrierSet::need_keep_alive_barrier(decorators, type)) {
378     __ enter();
379     __ push_call_clobbered_registers();
380     satb_write_barrier_pre(masm /* masm */,
381                            noreg /* obj */,
382                            dst /* pre_val */,
383                            rthread /* thread */,
384                            tmp1 /* tmp */,
385                            true /* tosca_live */,
386                            true /* expand_call */);
387     __ pop_call_clobbered_registers();
388     __ leave();
389   }
390 }
391 
392 void ShenandoahBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
393                                              Address dst, Register val, Register tmp1, Register tmp2) {
394   bool on_oop = is_reference_type(type);
395   if (!on_oop) {
396     BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);
397     return;
398   }
399 
400   // flatten object address if needed
401   if (dst.index() == noreg &amp;&amp; dst.offset() == 0) {
402     if (dst.base() != r3) {
403       __ mov(r3, dst.base());
404     }
405   } else {
406     __ lea(r3, dst);
407   }
408 
409   shenandoah_write_barrier_pre(masm,
410                                r3 /* obj */,
411                                tmp2 /* pre_val */,
412                                rthread /* thread */,
413                                tmp1  /* tmp */,
414                                val != noreg /* tosca_live */,
415                                false /* expand_call */);
416 
417   if (val == noreg) {
418     BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), noreg, noreg, noreg);
419   } else {
420     storeval_barrier(masm, val, tmp1);
421     // G1 barrier needs uncompressed oop for region cross check.
422     Register new_val = val;
423     if (UseCompressedOops) {
424       new_val = rscratch2;
425       __ mov(new_val, val);
426     }
427     BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), val, noreg, noreg);
428   }
429 
430 }
431 
432 void ShenandoahBarrierSetAssembler::try_resolve_jobject_in_native(MacroAssembler* masm, Register jni_env,
433                                                                   Register obj, Register tmp, Label&amp; slowpath) {
434   Label done;
435   // Resolve jobject
436   BarrierSetAssembler::try_resolve_jobject_in_native(masm, jni_env, obj, tmp, slowpath);
437 
438   // Check for null.
439   __ cbz(obj, done);
440 
441   assert(obj != rscratch2, &quot;need rscratch2&quot;);
442   Address gc_state(jni_env, ShenandoahThreadLocalData::gc_state_offset() - JavaThread::jni_environment_offset());
443   __ lea(rscratch2, gc_state);
444   __ ldrb(rscratch2, Address(rscratch2));
445 
446   // Check for heap in evacuation phase
447   __ tbnz(rscratch2, ShenandoahHeap::EVACUATION_BITPOS, slowpath);
448 
449   __ bind(done);
450 }
451 
<a name="1" id="anc1"></a><span class="line-modified">452 // Special Shenandoah CAS implementation that handles false negatives due</span>
<span class="line-modified">453 // to concurrent evacuation.  The service is more complex than a</span>
<span class="line-modified">454 // traditional CAS operation because the CAS operation is intended to</span>
<span class="line-added">455 // succeed if the reference at addr exactly matches expected or if the</span>
<span class="line-added">456 // reference at addr holds a pointer to a from-space object that has</span>
<span class="line-added">457 // been relocated to the location named by expected.  There are two</span>
<span class="line-added">458 // races that must be addressed:</span>
<span class="line-added">459 //  a) A parallel thread may mutate the contents of addr so that it points</span>
<span class="line-added">460 //     to a different object.  In this case, the CAS operation should fail.</span>
<span class="line-added">461 //  b) A parallel thread may heal the contents of addr, replacing a</span>
<span class="line-added">462 //     from-space pointer held in addr with the to-space pointer</span>
<span class="line-added">463 //     representing the new location of the object.</span>
<span class="line-added">464 // Upon entry to cmpxchg_oop, it is assured that new_val equals NULL</span>
<span class="line-added">465 // or it refers to an object that is not being evacuated out of</span>
<span class="line-added">466 // from-space, or it refers to the to-space version of an object that</span>
<span class="line-added">467 // is being evacuated out of from-space.</span>
<span class="line-added">468 //</span>
<span class="line-added">469 // By default, this operation implements sequential consistency and the</span>
<span class="line-added">470 // value held in the result register following execution of the</span>
<span class="line-added">471 // generated code sequence is 0 to indicate failure of CAS, non-zero</span>
<span class="line-added">472 // to indicate success.  Arguments support variations on this theme:</span>
<span class="line-added">473 //</span>
<span class="line-added">474 //  acquire: Allow relaxation of the memory ordering on CAS from</span>
<span class="line-added">475 //           sequential consistency.  This can be useful when</span>
<span class="line-added">476 //           sequential consistency is not required, such as when</span>
<span class="line-added">477 //           another sequentially consistent operation is already</span>
<span class="line-added">478 //           present in the execution stream.  If acquire, successful</span>
<span class="line-added">479 //           execution has the side effect of assuring that memory</span>
<span class="line-added">480 //           values updated by other threads and &quot;released&quot; will be</span>
<span class="line-added">481 //           visible to any read operations perfomed by this thread</span>
<span class="line-added">482 //           which follow this operation in program order.  This is a</span>
<span class="line-added">483 //           special optimization that should not be enabled by default.</span>
<span class="line-added">484 //  release: Allow relaxation of the memory ordering on CAS from</span>
<span class="line-added">485 //           sequential consistency.  This can be useful when</span>
<span class="line-added">486 //           sequential consistency is not required, such as when</span>
<span class="line-added">487 //           another sequentially consistent operation is already</span>
<span class="line-added">488 //           present in the execution stream.  If release, successful</span>
<span class="line-added">489 //           completion of this operation has the side effect of</span>
<span class="line-added">490 //           assuring that all writes to memory performed by this</span>
<span class="line-added">491 //           thread that precede this operation in program order are</span>
<span class="line-added">492 //           visible to all other threads that subsequently &quot;acquire&quot;</span>
<span class="line-added">493 //           before reading the respective memory values.  This is a</span>
<span class="line-added">494 //           special optimization that should not be enabled by default.</span>
<span class="line-added">495 //  is_cae:  This turns CAS (compare and swap) into CAE (compare and</span>
<span class="line-added">496 //           exchange).  This HotSpot convention is that CAE makes</span>
<span class="line-added">497 //           available to the caller the &quot;failure witness&quot;, which is</span>
<span class="line-added">498 //           the value that was stored in memory which did not match</span>
<span class="line-added">499 //           the expected value.  If is_cae, the result is the value</span>
<span class="line-added">500 //           most recently fetched from addr rather than a boolean</span>
<span class="line-added">501 //           success indicator.</span>
<span class="line-added">502 //</span>
<span class="line-added">503 // Clobbers rscratch1, rscratch2</span>
<span class="line-added">504 void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm,</span>
<span class="line-added">505                                                 Register addr,</span>
<span class="line-added">506                                                 Register expected,</span>
<span class="line-added">507                                                 Register new_val,</span>
<span class="line-added">508                                                 bool acquire, bool release,</span>
<span class="line-added">509                                                 bool is_cae,</span>
510                                                 Register result) {
511   Register tmp1 = rscratch1;
512   Register tmp2 = rscratch2;
513   bool is_narrow = UseCompressedOops;
514   Assembler::operand_size size = is_narrow ? Assembler::word : Assembler::xword;
515 
516   assert_different_registers(addr, expected, new_val, tmp1, tmp2);
517 
<a name="2" id="anc2"></a><span class="line-modified">518   Label step4, done;</span>
519 
<a name="3" id="anc3"></a><span class="line-modified">520   // There are two ways to reach this label.  Initial entry into the</span>
<span class="line-modified">521   // cmpxchg_oop code expansion starts at step1 (which is equivalent</span>
<span class="line-modified">522   // to label step4).  Additionally, in the rare case that four steps</span>
<span class="line-modified">523   // are required to perform the requested operation, the fourth step</span>
<span class="line-modified">524   // is the same as the first.  On a second pass through step 1,</span>
<span class="line-modified">525   // control may flow through step 2 on its way to failure.  It will</span>
<span class="line-modified">526   // not flow from step 2 to step 3 since we are assured that the</span>
<span class="line-modified">527   // memory at addr no longer holds a from-space pointer.</span>
<span class="line-modified">528   //</span>
<span class="line-modified">529   // The comments that immediately follow the step4 label apply only</span>
<span class="line-modified">530   // to the case in which control reaches this label by branch from</span>
<span class="line-modified">531   // step 3.</span>
<span class="line-modified">532 </span>
<span class="line-modified">533   __ bind (step4);</span>
<span class="line-modified">534 </span>
<span class="line-modified">535   // Step 4. CAS has failed because the value most recently fetched</span>
<span class="line-added">536   // from addr (which is now held in tmp1) is no longer the from-space</span>
<span class="line-added">537   // pointer held in tmp2.  If a different thread replaced the</span>
<span class="line-added">538   // in-memory value with its equivalent to-space pointer, then CAS</span>
<span class="line-added">539   // may still be able to succeed.  The value held in the expected</span>
<span class="line-added">540   // register has not changed.</span>
<span class="line-added">541   //</span>
<span class="line-added">542   // It is extremely rare we reach this point.  For this reason, the</span>
<span class="line-added">543   // implementation opts for smaller rather than potentially faster</span>
<span class="line-added">544   // code.  Ultimately, smaller code for this rare case most likely</span>
<span class="line-added">545   // delivers higher overall throughput by enabling improved icache</span>
<span class="line-added">546   // performance.</span>
<span class="line-added">547 </span>
<span class="line-added">548   // Step 1. Fast-path.</span>
<span class="line-added">549   //</span>
<span class="line-added">550   // Try to CAS with given arguments.  If successful, then we are done.</span>
<span class="line-added">551   //</span>
<span class="line-added">552   // No label required for step 1.</span>
<span class="line-added">553 </span>
<span class="line-added">554   __ cmpxchg(addr, expected, new_val, size, acquire, release, false, tmp2);</span>
<span class="line-added">555   // EQ flag set iff success.  tmp2 holds value fetched.</span>
<span class="line-added">556 </span>
<span class="line-added">557   // If expected equals null but tmp2 does not equal null, the</span>
<span class="line-added">558   // following branches to done to report failure of CAS.  If both</span>
<span class="line-added">559   // expected and tmp2 equal null, the following branches to done to</span>
<span class="line-added">560   // report success of CAS.  There&#39;s no need for a special test of</span>
<span class="line-added">561   // expected equal to null.</span>
<span class="line-added">562 </span>
<span class="line-added">563   __ br(Assembler::EQ, done);</span>
<span class="line-added">564   // if CAS failed, fall through to step 2</span>
<span class="line-added">565 </span>
<span class="line-added">566   // Step 2. CAS has failed because the value held at addr does not</span>
<span class="line-added">567   // match expected.  This may be a false negative because the value fetched</span>
<span class="line-added">568   // from addr (now held in tmp2) may be a from-space pointer to the</span>
<span class="line-added">569   // original copy of same object referenced by to-space pointer expected.</span>
<span class="line-added">570   //</span>
<span class="line-added">571   // To resolve this, it suffices to find the forward pointer associated</span>
<span class="line-added">572   // with fetched value.  If this matches expected, retry CAS with new</span>
<span class="line-added">573   // parameters.  If this mismatches, then we have a legitimate</span>
<span class="line-added">574   // failure, and we&#39;re done.</span>
<span class="line-added">575   //</span>
<span class="line-added">576   // No need for step2 label.</span>
<span class="line-added">577 </span>
<span class="line-added">578   // overwrite tmp1 with from-space pointer fetched from memory</span>
<span class="line-added">579   __ mov(tmp1, tmp2);</span>
580 
<a name="4" id="anc4"></a>




581   if (is_narrow) {
<a name="5" id="anc5"></a><span class="line-added">582     // Decode tmp1 in order to resolve its forward pointer</span>
583     __ decode_heap_oop(tmp1, tmp1);
<a name="6" id="anc6"></a>
584   }
585   resolve_forward_pointer(masm, tmp1);
<a name="7" id="anc7"></a><span class="line-modified">586   // Encode tmp1 to compare against expected.</span>
<span class="line-modified">587   __ encode_heap_oop(tmp1, tmp1);</span>
<span class="line-modified">588 </span>
<span class="line-modified">589   // Does forwarded value of fetched from-space pointer match original</span>
<span class="line-modified">590   // value of expected?  If tmp1 holds null, this comparison will fail</span>
<span class="line-modified">591   // because we know from step1 that expected is not null.  There is</span>
<span class="line-modified">592   // no need for a separate test for tmp1 (the value originally held</span>
<span class="line-modified">593   // in memory) equal to null.</span>
<span class="line-added">594   __ cmp(tmp1, expected);</span>
<span class="line-added">595 </span>
<span class="line-added">596   // If not, then the failure was legitimate and we&#39;re done.</span>
<span class="line-added">597   // Branching to done with NE condition denotes failure.</span>
<span class="line-added">598   __ br(Assembler::NE, done);</span>
<span class="line-added">599 </span>
<span class="line-added">600   // Fall through to step 3.  No need for step3 label.</span>
<span class="line-added">601 </span>
<span class="line-added">602   // Step 3.  We&#39;ve confirmed that the value originally held in memory</span>
<span class="line-added">603   // (now held in tmp2) pointed to from-space version of original</span>
<span class="line-added">604   // expected value.  Try the CAS again with the from-space expected</span>
<span class="line-added">605   // value.  If it now succeeds, we&#39;re good.</span>
<span class="line-added">606   //</span>
<span class="line-added">607   // Note: tmp2 holds encoded from-space pointer that matches to-space</span>
<span class="line-added">608   // object residing at expected.  tmp2 is the new &quot;expected&quot;.</span>
<span class="line-added">609 </span>
<span class="line-added">610   // Note that macro implementation of __cmpxchg cannot use same register</span>
<span class="line-added">611   // tmp2 for result and expected since it overwrites result before it</span>
<span class="line-added">612   // compares result with expected.</span>
<span class="line-added">613   __ cmpxchg(addr, tmp2, new_val, size, acquire, release, false, tmp1);</span>
<span class="line-added">614   // EQ flag set iff success.  tmp2 holds value fetched.</span>
<span class="line-added">615 </span>
<span class="line-added">616   // If fetched value did not equal the new expected, this could</span>
<span class="line-added">617   // still be a false negative because some other thread may have</span>
<span class="line-added">618   // newly overwritten the memory value with its to-space equivalent.</span>
<span class="line-added">619   __ br(Assembler::NE, step4);</span>
<span class="line-added">620 </span>
<span class="line-added">621   if (is_cae) {</span>
<span class="line-added">622     // We&#39;re falling through to done to indicate success.  Success</span>
<span class="line-added">623     // with is_cae is denoted by returning the value of expected as</span>
<span class="line-added">624     // result.</span>
<span class="line-added">625     __ mov(tmp2, expected);</span>
626   }
<a name="8" id="anc8"></a><span class="line-added">627 </span>
628   __ bind(done);
<a name="9" id="anc9"></a><span class="line-added">629   // At entry to done, the Z (EQ) flag is on iff if the CAS</span>
<span class="line-added">630   // operation was successful.  Additionally, if is_cae, tmp2 holds</span>
<span class="line-added">631   // the value most recently fetched from addr. In this case, success</span>
<span class="line-added">632   // is denoted by tmp2 matching expected.</span>
633 
634   if (is_cae) {
<a name="10" id="anc10"></a><span class="line-modified">635     __ mov(result, tmp2);</span>
636   } else {
637     __ cset(result, Assembler::EQ);
638   }
639 }
640 
641 #undef __
642 
643 #ifdef COMPILER1
644 
645 #define __ ce-&gt;masm()-&gt;
646 
647 void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub) {
648   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
649   // At this point we know that marking is in progress.
650   // If do_load() is true then we have to emit the
651   // load of the previous value; otherwise it has already
652   // been loaded into _pre_val.
653 
654   __ bind(*stub-&gt;entry());
655 
656   assert(stub-&gt;pre_val()-&gt;is_register(), &quot;Precondition.&quot;);
657 
658   Register pre_val_reg = stub-&gt;pre_val()-&gt;as_register();
659 
660   if (stub-&gt;do_load()) {
661     ce-&gt;mem2reg(stub-&gt;addr(), stub-&gt;pre_val(), T_OBJECT, stub-&gt;patch_code(), stub-&gt;info(), false /*wide*/, false /*unaligned*/);
662   }
663   __ cbz(pre_val_reg, *stub-&gt;continuation());
664   ce-&gt;store_parameter(stub-&gt;pre_val()-&gt;as_register(), 0);
665   __ far_call(RuntimeAddress(bs-&gt;pre_barrier_c1_runtime_code_blob()-&gt;code_begin()));
666   __ b(*stub-&gt;continuation());
667 }
668 
669 void ShenandoahBarrierSetAssembler::gen_load_reference_barrier_stub(LIR_Assembler* ce, ShenandoahLoadReferenceBarrierStub* stub) {
670   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
671   __ bind(*stub-&gt;entry());
672 
673   Register obj = stub-&gt;obj()-&gt;as_register();
674   Register res = stub-&gt;result()-&gt;as_register();
675   Register addr = stub-&gt;addr()-&gt;as_pointer_register();
676   Register tmp1 = stub-&gt;tmp1()-&gt;as_register();
677   Register tmp2 = stub-&gt;tmp2()-&gt;as_register();
678 
679   assert(res == r0, &quot;result must arrive in r0&quot;);
680 
681   if (res != obj) {
682     __ mov(res, obj);
683   }
684 
685   // Check for null.
686   __ cbz(res, *stub-&gt;continuation());
687 
688   // Check for object in cset.
689   __ mov(tmp2, ShenandoahHeap::in_cset_fast_test_addr());
690   __ lsr(tmp1, res, ShenandoahHeapRegion::region_size_bytes_shift_jint());
691   __ ldrb(tmp2, Address(tmp2, tmp1));
692   __ cbz(tmp2, *stub-&gt;continuation());
693 
694   // Check if object is already forwarded.
695   Label slow_path;
696   __ ldr(tmp1, Address(res, oopDesc::mark_offset_in_bytes()));
697   __ eon(tmp1, tmp1, zr);
698   __ ands(zr, tmp1, markWord::lock_mask_in_place);
699   __ br(Assembler::NE, slow_path);
700 
701   // Decode forwarded object.
702   __ orr(tmp1, tmp1, markWord::marked_value);
703   __ eon(res, tmp1, zr);
704   __ b(*stub-&gt;continuation());
705 
706   __ bind(slow_path);
707   ce-&gt;store_parameter(res, 0);
708   ce-&gt;store_parameter(addr, 1);
709   if (stub-&gt;is_native()) {
710     __ far_call(RuntimeAddress(bs-&gt;load_reference_barrier_native_rt_code_blob()-&gt;code_begin()));
711   } else {
712     __ far_call(RuntimeAddress(bs-&gt;load_reference_barrier_rt_code_blob()-&gt;code_begin()));
713   }
714 
715   __ b(*stub-&gt;continuation());
716 }
717 
718 #undef __
719 
720 #define __ sasm-&gt;
721 
722 void ShenandoahBarrierSetAssembler::generate_c1_pre_barrier_runtime_stub(StubAssembler* sasm) {
723   __ prologue(&quot;shenandoah_pre_barrier&quot;, false);
724 
725   // arg0 : previous value of memory
726 
727   BarrierSet* bs = BarrierSet::barrier_set();
728 
729   const Register pre_val = r0;
730   const Register thread = rthread;
731   const Register tmp = rscratch1;
732 
733   Address queue_index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
734   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
735 
736   Label done;
737   Label runtime;
738 
739   // Is marking still active?
740   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
741   __ ldrb(tmp, gc_state);
742   __ mov(rscratch2, ShenandoahHeap::MARKING);
743   __ tst(tmp, rscratch2);
744   __ br(Assembler::EQ, done);
745 
746   // Can we store original value in the thread&#39;s buffer?
747   __ ldr(tmp, queue_index);
748   __ cbz(tmp, runtime);
749 
750   __ sub(tmp, tmp, wordSize);
751   __ str(tmp, queue_index);
752   __ ldr(rscratch2, buffer);
753   __ add(tmp, tmp, rscratch2);
754   __ load_parameter(0, rscratch2);
755   __ str(rscratch2, Address(tmp, 0));
756   __ b(done);
757 
758   __ bind(runtime);
759   __ push_call_clobbered_registers();
760   __ load_parameter(0, pre_val);
761   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);
762   __ pop_call_clobbered_registers();
763   __ bind(done);
764 
765   __ epilogue();
766 }
767 
768 void ShenandoahBarrierSetAssembler::generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_native) {
769   __ prologue(&quot;shenandoah_load_reference_barrier&quot;, false);
770   // arg0 : object to be resolved
771 
772   __ push_call_clobbered_registers();
773   __ load_parameter(0, r0);
774   __ load_parameter(1, r1);
775   if (is_native) {
776     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native));
777   } else if (UseCompressedOops) {
778     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow));
779   } else {
780     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier));
781   }
782   __ blr(lr);
783   __ mov(rscratch1, r0);
784   __ pop_call_clobbered_registers();
785   __ mov(r0, rscratch1);
786 
787   __ epilogue();
788 }
789 
790 #undef __
791 
792 #endif // COMPILER1
793 
794 address ShenandoahBarrierSetAssembler::shenandoah_lrb() {
795   assert(_shenandoah_lrb != NULL, &quot;need load reference barrier stub&quot;);
796   return _shenandoah_lrb;
797 }
798 
799 #define __ cgen-&gt;assembler()-&gt;
800 
801 // Shenandoah load reference barrier.
802 //
803 // Input:
804 //   r0: OOP to evacuate.  Not null.
805 //   r1: load address
806 //
807 // Output:
808 //   r0: Pointer to evacuated OOP.
809 //
810 // Trash rscratch1, rscratch2.  Preserve everything else.
811 address ShenandoahBarrierSetAssembler::generate_shenandoah_lrb(StubCodeGenerator* cgen) {
812 
813   __ align(6);
814   StubCodeMark mark(cgen, &quot;StubRoutines&quot;, &quot;shenandoah_lrb&quot;);
815   address start = __ pc();
816 
817   Label slow_path;
818   __ mov(rscratch2, ShenandoahHeap::in_cset_fast_test_addr());
819   __ lsr(rscratch1, r0, ShenandoahHeapRegion::region_size_bytes_shift_jint());
820   __ ldrb(rscratch2, Address(rscratch2, rscratch1));
821   __ tbnz(rscratch2, 0, slow_path);
822   __ ret(lr);
823 
824   __ bind(slow_path);
825   __ enter(); // required for proper stackwalking of RuntimeStub frame
826 
827   __ push_call_clobbered_registers();
828 
829   if (UseCompressedOops) {
830     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow));
831   } else {
832     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier));
833   }
834   __ blr(lr);
835   __ mov(rscratch1, r0);
836   __ pop_call_clobbered_registers();
837   __ mov(r0, rscratch1);
838 
839   __ leave(); // required for proper stackwalking of RuntimeStub frame
840   __ ret(lr);
841 
842   return start;
843 }
844 
845 #undef __
846 
847 void ShenandoahBarrierSetAssembler::barrier_stubs_init() {
848   if (ShenandoahLoadRefBarrier) {
849     int stub_code_size = 2048;
850     ResourceMark rm;
851     BufferBlob* bb = BufferBlob::create(&quot;shenandoah_barrier_stubs&quot;, stub_code_size);
852     CodeBuffer buf(bb);
853     StubCodeGenerator cgen(&amp;buf);
854     _shenandoah_lrb = generate_shenandoah_lrb(&amp;cgen);
855   }
856 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
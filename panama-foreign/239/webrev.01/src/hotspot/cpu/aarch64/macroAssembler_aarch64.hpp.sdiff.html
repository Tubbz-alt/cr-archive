<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 439     umaddl(Rd, Rn, Rm, zr);
 440   }
 441 
 442 #define WRAP(INSN)                                                            \
 443   void INSN(Register Rd, Register Rn, Register Rm, Register Ra) {             \
 444     if ((VM_Version::features() &amp; VM_Version::CPU_A53MAC) &amp;&amp; Ra != zr)        \
 445       nop();                                                                  \
 446     Assembler::INSN(Rd, Rn, Rm, Ra);                                          \
 447   }
 448 
 449   WRAP(madd) WRAP(msub) WRAP(maddw) WRAP(msubw)
 450   WRAP(smaddl) WRAP(smsubl) WRAP(umaddl) WRAP(umsubl)
 451 #undef WRAP
 452 
 453 
 454   // macro assembly operations needed for aarch64
 455 
 456   // first two private routines for loading 32 bit or 64 bit constants
 457 private:
 458 
<span class="line-modified"> 459   void mov_immediate64(Register dst, u_int64_t imm64);</span>
<span class="line-modified"> 460   void mov_immediate32(Register dst, u_int32_t imm32);</span>
 461 
 462   int push(unsigned int bitset, Register stack);
 463   int pop(unsigned int bitset, Register stack);
 464 
 465   int push_fp(unsigned int bitset, Register stack);
 466   int pop_fp(unsigned int bitset, Register stack);
 467 
 468   void mov(Register dst, Address a);
 469 
 470 public:
 471   void push(RegSet regs, Register stack) { if (regs.bits()) push(regs.bits(), stack); }
 472   void pop(RegSet regs, Register stack) { if (regs.bits()) pop(regs.bits(), stack); }
 473 
 474   void push_fp(RegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }
 475   void pop_fp(RegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }
 476 
 477   // Push and pop everything that might be clobbered by a native
 478   // runtime call except rscratch1 and rscratch2.  (They are always
 479   // scratch, so we don&#39;t have to protect them.)  Only save the lower
 480   // 64 bits of each vector register.
 481   void push_call_clobbered_registers();
 482   void pop_call_clobbered_registers();
 483 
 484   // now mov instructions for loading absolute addresses and 32 or
 485   // 64 bit integers
 486 
 487   inline void mov(Register dst, address addr)
 488   {
<span class="line-modified"> 489     mov_immediate64(dst, (u_int64_t)addr);</span>
 490   }
 491 
<span class="line-modified"> 492   inline void mov(Register dst, u_int64_t imm64)</span>
 493   {
 494     mov_immediate64(dst, imm64);
 495   }
 496 
<span class="line-modified"> 497   inline void movw(Register dst, u_int32_t imm32)</span>
 498   {
 499     mov_immediate32(dst, imm32);
 500   }
 501 
 502   inline void mov(Register dst, long l)
 503   {
<span class="line-modified"> 504     mov(dst, (u_int64_t)l);</span>
 505   }
 506 
 507   inline void mov(Register dst, int i)
 508   {
 509     mov(dst, (long)i);
 510   }
 511 
 512   void mov(Register dst, RegisterOrConstant src) {
 513     if (src.is_register())
 514       mov(dst, src.as_register());
 515     else
 516       mov(dst, src.as_constant());
 517   }
 518 
 519   void movptr(Register r, uintptr_t imm64);
 520 
<span class="line-modified"> 521   void mov(FloatRegister Vd, SIMD_Arrangement T, u_int32_t imm32);</span>
 522 
 523   void mov(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {
 524     orr(Vd, T, Vn, Vn);
 525   }
 526 
 527 public:
 528 
 529   // Generalized Test Bit And Branch, including a &quot;far&quot; variety which
 530   // spans more than 32KiB.
 531   void tbr(Condition cond, Register Rt, int bitpos, Label &amp;dest, bool far = false) {
 532     assert(cond == EQ || cond == NE, &quot;must be&quot;);
 533 
 534     if (far)
 535       cond = ~cond;
 536 
 537     void (Assembler::* branch)(Register Rt, int bitpos, Label &amp;L);
 538     if (cond == Assembler::EQ)
 539       branch = &amp;Assembler::tbz;
 540     else
 541       branch = &amp;Assembler::tbnz;
</pre>
<hr />
<pre>
1220 
1221   address read_polling_page(Register r, relocInfo::relocType rtype);
1222   void get_polling_page(Register dest, relocInfo::relocType rtype);
1223   address fetch_and_read_polling_page(Register r, relocInfo::relocType rtype);
1224 
1225   // CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.
1226   void update_byte_crc32(Register crc, Register val, Register table);
1227   void update_word_crc32(Register crc, Register v, Register tmp,
1228         Register table0, Register table1, Register table2, Register table3,
1229         bool upper = false);
1230 
1231   void has_negatives(Register ary1, Register len, Register result);
1232 
1233   void arrays_equals(Register a1, Register a2, Register result, Register cnt1,
1234                      Register tmp1, Register tmp2, Register tmp3, int elem_size);
1235 
1236   void string_equals(Register a1, Register a2, Register result, Register cnt1,
1237                      int elem_size);
1238 
1239   void fill_words(Register base, Register cnt, Register value);
<span class="line-modified">1240   void zero_words(Register base, u_int64_t cnt);</span>
1241   void zero_words(Register ptr, Register cnt);
1242   void zero_dcache_blocks(Register base, Register cnt);
1243 
1244   static const int zero_words_block_size;
1245 
1246   void byte_array_inflate(Register src, Register dst, Register len,
1247                           FloatRegister vtmp1, FloatRegister vtmp2,
1248                           FloatRegister vtmp3, Register tmp4);
1249 
1250   void char_array_compress(Register src, Register dst, Register len,
1251                            FloatRegister tmp1Reg, FloatRegister tmp2Reg,
1252                            FloatRegister tmp3Reg, FloatRegister tmp4Reg,
1253                            Register result);
1254 
1255   void encode_iso_array(Register src, Register dst,
1256                         Register len, Register result,
1257                         FloatRegister Vtmp1, FloatRegister Vtmp2,
1258                         FloatRegister Vtmp3, FloatRegister Vtmp4);
1259   void fast_log(FloatRegister vtmp0, FloatRegister vtmp1, FloatRegister vtmp2,
1260                 FloatRegister vtmp3, FloatRegister vtmp4, FloatRegister vtmp5,
</pre>
</td>
<td>
<hr />
<pre>
 439     umaddl(Rd, Rn, Rm, zr);
 440   }
 441 
 442 #define WRAP(INSN)                                                            \
 443   void INSN(Register Rd, Register Rn, Register Rm, Register Ra) {             \
 444     if ((VM_Version::features() &amp; VM_Version::CPU_A53MAC) &amp;&amp; Ra != zr)        \
 445       nop();                                                                  \
 446     Assembler::INSN(Rd, Rn, Rm, Ra);                                          \
 447   }
 448 
 449   WRAP(madd) WRAP(msub) WRAP(maddw) WRAP(msubw)
 450   WRAP(smaddl) WRAP(smsubl) WRAP(umaddl) WRAP(umsubl)
 451 #undef WRAP
 452 
 453 
 454   // macro assembly operations needed for aarch64
 455 
 456   // first two private routines for loading 32 bit or 64 bit constants
 457 private:
 458 
<span class="line-modified"> 459   void mov_immediate64(Register dst, uint64_t imm64);</span>
<span class="line-modified"> 460   void mov_immediate32(Register dst, uint32_t imm32);</span>
 461 
 462   int push(unsigned int bitset, Register stack);
 463   int pop(unsigned int bitset, Register stack);
 464 
 465   int push_fp(unsigned int bitset, Register stack);
 466   int pop_fp(unsigned int bitset, Register stack);
 467 
 468   void mov(Register dst, Address a);
 469 
 470 public:
 471   void push(RegSet regs, Register stack) { if (regs.bits()) push(regs.bits(), stack); }
 472   void pop(RegSet regs, Register stack) { if (regs.bits()) pop(regs.bits(), stack); }
 473 
 474   void push_fp(RegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }
 475   void pop_fp(RegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }
 476 
 477   // Push and pop everything that might be clobbered by a native
 478   // runtime call except rscratch1 and rscratch2.  (They are always
 479   // scratch, so we don&#39;t have to protect them.)  Only save the lower
 480   // 64 bits of each vector register.
 481   void push_call_clobbered_registers();
 482   void pop_call_clobbered_registers();
 483 
 484   // now mov instructions for loading absolute addresses and 32 or
 485   // 64 bit integers
 486 
 487   inline void mov(Register dst, address addr)
 488   {
<span class="line-modified"> 489     mov_immediate64(dst, (uint64_t)addr);</span>
 490   }
 491 
<span class="line-modified"> 492   inline void mov(Register dst, uint64_t imm64)</span>
 493   {
 494     mov_immediate64(dst, imm64);
 495   }
 496 
<span class="line-modified"> 497   inline void movw(Register dst, uint32_t imm32)</span>
 498   {
 499     mov_immediate32(dst, imm32);
 500   }
 501 
 502   inline void mov(Register dst, long l)
 503   {
<span class="line-modified"> 504     mov(dst, (uint64_t)l);</span>
 505   }
 506 
 507   inline void mov(Register dst, int i)
 508   {
 509     mov(dst, (long)i);
 510   }
 511 
 512   void mov(Register dst, RegisterOrConstant src) {
 513     if (src.is_register())
 514       mov(dst, src.as_register());
 515     else
 516       mov(dst, src.as_constant());
 517   }
 518 
 519   void movptr(Register r, uintptr_t imm64);
 520 
<span class="line-modified"> 521   void mov(FloatRegister Vd, SIMD_Arrangement T, uint32_t imm32);</span>
 522 
 523   void mov(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {
 524     orr(Vd, T, Vn, Vn);
 525   }
 526 
 527 public:
 528 
 529   // Generalized Test Bit And Branch, including a &quot;far&quot; variety which
 530   // spans more than 32KiB.
 531   void tbr(Condition cond, Register Rt, int bitpos, Label &amp;dest, bool far = false) {
 532     assert(cond == EQ || cond == NE, &quot;must be&quot;);
 533 
 534     if (far)
 535       cond = ~cond;
 536 
 537     void (Assembler::* branch)(Register Rt, int bitpos, Label &amp;L);
 538     if (cond == Assembler::EQ)
 539       branch = &amp;Assembler::tbz;
 540     else
 541       branch = &amp;Assembler::tbnz;
</pre>
<hr />
<pre>
1220 
1221   address read_polling_page(Register r, relocInfo::relocType rtype);
1222   void get_polling_page(Register dest, relocInfo::relocType rtype);
1223   address fetch_and_read_polling_page(Register r, relocInfo::relocType rtype);
1224 
1225   // CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.
1226   void update_byte_crc32(Register crc, Register val, Register table);
1227   void update_word_crc32(Register crc, Register v, Register tmp,
1228         Register table0, Register table1, Register table2, Register table3,
1229         bool upper = false);
1230 
1231   void has_negatives(Register ary1, Register len, Register result);
1232 
1233   void arrays_equals(Register a1, Register a2, Register result, Register cnt1,
1234                      Register tmp1, Register tmp2, Register tmp3, int elem_size);
1235 
1236   void string_equals(Register a1, Register a2, Register result, Register cnt1,
1237                      int elem_size);
1238 
1239   void fill_words(Register base, Register cnt, Register value);
<span class="line-modified">1240   void zero_words(Register base, uint64_t cnt);</span>
1241   void zero_words(Register ptr, Register cnt);
1242   void zero_dcache_blocks(Register base, Register cnt);
1243 
1244   static const int zero_words_block_size;
1245 
1246   void byte_array_inflate(Register src, Register dst, Register len,
1247                           FloatRegister vtmp1, FloatRegister vtmp2,
1248                           FloatRegister vtmp3, Register tmp4);
1249 
1250   void char_array_compress(Register src, Register dst, Register len,
1251                            FloatRegister tmp1Reg, FloatRegister tmp2Reg,
1252                            FloatRegister tmp3Reg, FloatRegister tmp4Reg,
1253                            Register result);
1254 
1255   void encode_iso_array(Register src, Register dst,
1256                         Register len, Register result,
1257                         FloatRegister Vtmp1, FloatRegister Vtmp2,
1258                         FloatRegister Vtmp3, FloatRegister Vtmp4);
1259   void fast_log(FloatRegister vtmp0, FloatRegister vtmp1, FloatRegister vtmp2,
1260                 FloatRegister vtmp3, FloatRegister vtmp4, FloatRegister vtmp5,
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
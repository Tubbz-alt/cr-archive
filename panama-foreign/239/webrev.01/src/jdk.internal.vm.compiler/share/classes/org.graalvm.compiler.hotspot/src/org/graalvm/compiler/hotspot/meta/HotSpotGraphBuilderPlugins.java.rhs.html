<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotGraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.meta;
 26 
 27 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
 28 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 29 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigAccess.JDK;
 30 import static org.graalvm.compiler.hotspot.HotSpotBackend.BASE64_ENCODE_BLOCK;
 31 import static org.graalvm.compiler.hotspot.HotSpotBackend.GHASH_PROCESS_BLOCKS;
 32 import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;
 33 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.JAVA_THREAD_THREAD_OBJECT_LOCATION;
 34 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
 35 
 36 import java.lang.invoke.ConstantCallSite;
 37 import java.lang.invoke.MutableCallSite;
 38 import java.lang.invoke.VolatileCallSite;
 39 import java.lang.reflect.Array;
 40 import java.lang.reflect.Type;
 41 import java.math.BigInteger;
 42 import java.util.zip.CRC32;
 43 
 44 import jdk.internal.vm.compiler.collections.Pair;
 45 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 46 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 47 import org.graalvm.compiler.core.common.type.ObjectStamp;
 48 import org.graalvm.compiler.core.common.type.StampFactory;
 49 import org.graalvm.compiler.core.common.type.TypeReference;
 50 import org.graalvm.compiler.debug.GraalError;
 51 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 52 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
 53 import org.graalvm.compiler.hotspot.nodes.CurrentJavaThreadNode;
 54 import org.graalvm.compiler.hotspot.replacements.AESCryptSubstitutions;
 55 import org.graalvm.compiler.hotspot.replacements.ArraysSupportSubstitutions;
 56 import org.graalvm.compiler.hotspot.replacements.BigIntegerSubstitutions;
 57 import org.graalvm.compiler.hotspot.replacements.CRC32CSubstitutions;
 58 import org.graalvm.compiler.hotspot.replacements.CRC32Substitutions;
 59 import org.graalvm.compiler.hotspot.replacements.CallSiteTargetNode;
 60 import org.graalvm.compiler.hotspot.replacements.CipherBlockChainingSubstitutions;
<a name="1" id="anc1"></a>
 61 import org.graalvm.compiler.hotspot.replacements.CounterModeSubstitutions;
 62 import org.graalvm.compiler.hotspot.replacements.DigestBaseSubstitutions;
 63 import org.graalvm.compiler.hotspot.replacements.FastNotifyNode;
 64 import org.graalvm.compiler.hotspot.replacements.HotSpotArraySubstitutions;
 65 import org.graalvm.compiler.hotspot.replacements.HotSpotClassSubstitutions;
 66 import org.graalvm.compiler.hotspot.replacements.HotSpotReflectionGetCallerClassNode;
 67 import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
 68 import org.graalvm.compiler.hotspot.replacements.ObjectCloneNode;
 69 import org.graalvm.compiler.hotspot.replacements.ReflectionSubstitutions;
 70 import org.graalvm.compiler.hotspot.replacements.SHA2Substitutions;
 71 import org.graalvm.compiler.hotspot.replacements.SHA5Substitutions;
 72 import org.graalvm.compiler.hotspot.replacements.SHASubstitutions;
 73 import org.graalvm.compiler.hotspot.replacements.StringUTF16Substitutions;
 74 import org.graalvm.compiler.hotspot.replacements.ThreadSubstitutions;
 75 import org.graalvm.compiler.hotspot.word.HotSpotWordTypes;
 76 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
 77 import org.graalvm.compiler.nodes.ConstantNode;
<a name="2" id="anc2"></a>
 78 import org.graalvm.compiler.nodes.NodeView;
 79 import org.graalvm.compiler.nodes.ValueNode;
 80 import org.graalvm.compiler.nodes.calc.AddNode;
<a name="3" id="anc3"></a>

 81 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 82 import org.graalvm.compiler.nodes.graphbuilderconf.ForeignCallPlugin;
 83 import org.graalvm.compiler.nodes.graphbuilderconf.GeneratedPluginFactory;
 84 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 85 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 86 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 87 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 88 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 89 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 90 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
 91 import org.graalvm.compiler.nodes.memory.OnHeapMemoryAccess.BarrierType;
 92 import org.graalvm.compiler.nodes.memory.ReadNode;
 93 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 94 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 95 import org.graalvm.compiler.nodes.spi.Replacements;
 96 import org.graalvm.compiler.nodes.util.GraphUtil;
 97 import org.graalvm.compiler.options.OptionValues;
 98 import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
 99 import org.graalvm.compiler.replacements.InlineDuringParsingPlugin;
100 import org.graalvm.compiler.replacements.MethodHandlePlugin;
101 import org.graalvm.compiler.replacements.NodeIntrinsificationProvider;
102 import org.graalvm.compiler.replacements.ReplacementsImpl;
103 import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins;
104 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
105 import org.graalvm.compiler.replacements.nodes.MacroNode.MacroParams;
106 import org.graalvm.compiler.serviceprovider.GraalServices;
107 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
<a name="4" id="anc4"></a>
108 import org.graalvm.compiler.word.WordTypes;
<a name="5" id="anc5"></a>
109 
<a name="6" id="anc6"></a>
110 import jdk.vm.ci.code.TargetDescription;
111 import jdk.vm.ci.hotspot.VMIntrinsicMethod;
112 import jdk.vm.ci.meta.ConstantReflectionProvider;
113 import jdk.vm.ci.meta.DeoptimizationAction;
114 import jdk.vm.ci.meta.JavaKind;
115 import jdk.vm.ci.meta.MetaAccessProvider;
116 import jdk.vm.ci.meta.ResolvedJavaMethod;
117 import jdk.vm.ci.services.Services;
118 import sun.misc.Unsafe;
119 
120 /**
121  * Defines the {@link Plugins} used when running on HotSpot.
122  */
123 public class HotSpotGraphBuilderPlugins {
124 
125     /**
126      * Creates a {@link Plugins} object that should be used when running on HotSpot.
127      *
128      * @param constantReflection
129      * @param snippetReflection
130      * @param foreignCalls
131      * @param options
132      * @param target
133      */
134     public static Plugins create(HotSpotGraalRuntimeProvider graalRuntime,
135                     CompilerConfiguration compilerConfiguration,
136                     GraalHotSpotVMConfig config,
137                     HotSpotWordTypes wordTypes,
138                     MetaAccessProvider metaAccess,
139                     ConstantReflectionProvider constantReflection,
140                     SnippetReflectionProvider snippetReflection,
141                     ForeignCallsProvider foreignCalls,
142                     ReplacementsImpl replacements,
143                     OptionValues options,
144                     TargetDescription target) {
145         InvocationPlugins invocationPlugins = new HotSpotInvocationPlugins(graalRuntime, config, compilerConfiguration);
146 
147         Plugins plugins = new Plugins(invocationPlugins);
148         if (!IS_IN_NATIVE_IMAGE) {
149             // In libgraal all word related operations have been fully processed so this is unneeded
150             HotSpotWordOperationPlugin wordOperationPlugin = new HotSpotWordOperationPlugin(snippetReflection, wordTypes);
151             HotSpotNodePlugin nodePlugin = new HotSpotNodePlugin(wordOperationPlugin, config, wordTypes);
152 
153             plugins.appendTypePlugin(nodePlugin);
154             plugins.appendNodePlugin(nodePlugin);
155         }
156         if (!GeneratePIC.getValue(options)) {
157             plugins.appendNodePlugin(new MethodHandlePlugin(constantReflection.getMethodHandleAccess(), !config.supportsMethodHandleDeoptimizationEntry()));
158         }
159         plugins.appendInlineInvokePlugin(replacements);
160         if (InlineDuringParsing.getValue(options)) {
161             plugins.appendInlineInvokePlugin(new InlineDuringParsingPlugin());
162         }
163 
164         if (GeneratePIC.getValue(options)) {
165             plugins.setClassInitializationPlugin(new HotSpotAOTClassInitializationPlugin());
166             if (TieredAOT.getValue(options)) {
167                 plugins.setProfilingPlugin(new HotSpotAOTProfilingPlugin());
168             }
169         } else {
170             if (config.instanceKlassInitThreadOffset != -1) {
171                 plugins.setClassInitializationPlugin(new HotSpotJITClassInitializationPlugin());
172             }
173         }
174 
175         invocationPlugins.defer(new Runnable() {
176 
177             @Override
178             public void run() {
179                 registerObjectPlugins(invocationPlugins, options, config, replacements);
180                 registerClassPlugins(plugins, config, replacements);
181                 registerSystemPlugins(invocationPlugins);
182                 registerThreadPlugins(invocationPlugins, metaAccess, wordTypes, config, replacements);
183                 if (!GeneratePIC.getValue(options)) {
184                     registerCallSitePlugins(invocationPlugins);
185                 }
186                 registerReflectionPlugins(invocationPlugins, replacements);
<a name="7" id="anc7"></a>
187                 registerAESPlugins(invocationPlugins, config, replacements);
188                 registerCRC32Plugins(invocationPlugins, config, replacements);
189                 registerCRC32CPlugins(invocationPlugins, config, replacements);
190                 registerBigIntegerPlugins(invocationPlugins, config, replacements);
191                 registerSHAPlugins(invocationPlugins, config, replacements);
192                 registerGHASHPlugins(invocationPlugins, config, metaAccess);
193                 registerCounterModePlugins(invocationPlugins, config, replacements);
194                 registerBase64Plugins(invocationPlugins, config, metaAccess);
195                 registerUnsafePlugins(invocationPlugins, config, replacements);
196                 StandardGraphBuilderPlugins.registerInvocationPlugins(metaAccess, snippetReflection, invocationPlugins, replacements, true, false, true);
197                 registerArrayPlugins(invocationPlugins, replacements);
198                 registerStringPlugins(invocationPlugins, replacements);
199                 registerArraysSupportPlugins(invocationPlugins, config, replacements);
200             }
201         });
202         if (!IS_IN_NATIVE_IMAGE) {
203             // In libgraal all NodeIntrinsics been converted into special nodes so the plugins
204             // aren&#39;t needed.
205             NodeIntrinsificationProvider nodeIntrinsificationProvider = new NodeIntrinsificationProvider(metaAccess, snippetReflection, foreignCalls, wordTypes, target);
206             invocationPlugins.defer(new Runnable() {
207 
208                 @Override
209                 public void run() {
210 
211                     for (GeneratedPluginFactory factory : GraalServices.load(GeneratedPluginFactory.class)) {
212                         factory.registerPlugins(invocationPlugins, nodeIntrinsificationProvider);
213                     }
214 
215                 }
216             });
217         }
218         return plugins;
219     }
220 
221     private static void registerObjectPlugins(InvocationPlugins plugins, OptionValues options, GraalHotSpotVMConfig config, Replacements replacements) {
222         Registration r = new Registration(plugins, Object.class, replacements);
223         if (!GeneratePIC.getValue(options)) {
224             // FIXME: clone() requires speculation and requires a fix in here (to check that
225             // b.getAssumptions() != null), and in ReplacementImpl.getSubstitution() where there is
226             // an instantiation of IntrinsicGraphBuilder using a constructor that sets
227             // AllowAssumptions to YES automatically. The former has to inherit the assumptions
228             // settings from the root compile instead. So, for now, I&#39;m disabling it for
229             // GeneratePIC.
230             r.register1(&quot;clone&quot;, Receiver.class, new InvocationPlugin() {
231                 @Override
232                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
233                     ValueNode object = receiver.get();
234                     b.addPush(JavaKind.Object, new ObjectCloneNode(MacroParams.of(b, targetMethod, object)));
235                     return true;
236                 }
237 
238                 @Override
239                 public boolean inlineOnly() {
240                     return true;
241                 }
242             });
243         }
244         r.register1(&quot;hashCode&quot;, Receiver.class, new InvocationPlugin() {
245             @Override
246             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
247                 ValueNode object = receiver.get();
248                 b.addPush(JavaKind.Int, new IdentityHashCodeNode(object, b.bci()));
249                 return true;
250             }
251 
252             @Override
253             public boolean inlineOnly() {
254                 return true;
255             }
256         });
257         if (config.inlineNotify()) {
258             r.register1(&quot;notify&quot;, Receiver.class, new InvocationPlugin() {
259                 @Override
260                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
261                     ValueNode object = receiver.get();
262                     b.add(new FastNotifyNode(object, false, b.bci()));
263                     return true;
264                 }
265 
266                 @Override
267                 public boolean inlineOnly() {
268                     return true;
269                 }
270             });
271         }
272         if (config.inlineNotifyAll()) {
273             r.register1(&quot;notifyAll&quot;, Receiver.class, new InvocationPlugin() {
274                 @Override
275                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
276                     ValueNode object = receiver.get();
277                     b.add(new FastNotifyNode(object, true, b.bci()));
278                     return true;
279                 }
280 
281                 @Override
282                 public boolean inlineOnly() {
283                     return true;
284                 }
285             });
286         }
287     }
288 
289     private static void registerClassPlugins(Plugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
290         Registration r = new Registration(plugins.getInvocationPlugins(), Class.class, replacements);
291 
292         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getModifiers&quot;, Receiver.class);
293         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isInterface&quot;, Receiver.class);
294         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isArray&quot;, Receiver.class);
295         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isPrimitive&quot;, Receiver.class);
296         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getSuperclass&quot;, Receiver.class);
297 
298         if (config.jvmAccIsHiddenClass != 0) {
299             r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isHidden&quot;, Receiver.class);
300         }
301 
302         if (config.getFieldOffset(&quot;ArrayKlass::_component_mirror&quot;, Integer.class, &quot;oop&quot;, Integer.MAX_VALUE, JDK &lt;= 8) != Integer.MAX_VALUE) {
303             r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getComponentType&quot;, Receiver.class);
304         }
305     }
306 
307     private static void registerCallSitePlugins(InvocationPlugins plugins) {
308         InvocationPlugin plugin = new InvocationPlugin() {
309             @Override
310             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
311                 ValueNode callSite = receiver.get();
312                 ValueNode folded = CallSiteTargetNode.tryFold(GraphUtil.originalValue(callSite, true), b.getMetaAccess(), b.getAssumptions());
313                 if (folded != null) {
314                     b.addPush(JavaKind.Object, folded);
315                 } else {
316                     b.addPush(JavaKind.Object, new CallSiteTargetNode(MacroParams.of(b, targetMethod, callSite)));
317                 }
318                 return true;
319             }
320 
321             @Override
322             public boolean inlineOnly() {
323                 return true;
324             }
325         };
326         plugins.register(plugin, ConstantCallSite.class, &quot;getTarget&quot;, Receiver.class);
327         plugins.register(plugin, MutableCallSite.class, &quot;getTarget&quot;, Receiver.class);
328         plugins.register(plugin, VolatileCallSite.class, &quot;getTarget&quot;, Receiver.class);
329     }
330 
331     private static void registerReflectionPlugins(InvocationPlugins plugins, Replacements replacements) {
332         Registration r = new Registration(plugins, reflectionClass, replacements);
333         r.register0(&quot;getCallerClass&quot;, new InvocationPlugin() {
334             @Override
335             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
336                 b.addPush(JavaKind.Object, new HotSpotReflectionGetCallerClassNode(MacroParams.of(b, targetMethod)));
337                 return true;
338             }
339 
340             @Override
341             public boolean inlineOnly() {
342                 return true;
343             }
344         });
345         r.registerMethodSubstitution(ReflectionSubstitutions.class, &quot;getClassAccessFlags&quot;, Class.class);
346     }
347 
348     private static void registerUnsafePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
349         Registration r;
350         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
351             r = new Registration(plugins, Unsafe.class, replacements);
352         } else {
353             r = new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements);
354         }
355         String substituteMethodName = config.doingUnsafeAccessOffset != Integer.MAX_VALUE ? &quot;copyMemoryGuarded&quot; : &quot;copyMemory&quot;;
356         r.registerMethodSubstitution(HotSpotUnsafeSubstitutions.class, HotSpotUnsafeSubstitutions.copyMemoryName, substituteMethodName, Receiver.class, Object.class, long.class, Object.class,
357                         long.class, long.class);
358 
359         r.register2(&quot;allocateInstance&quot;, Receiver.class, Class.class, new InvocationPlugin() {
360             @Override
361             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode clazz) {
362                 /* Emits a null-check for the otherwise unused receiver. */
363                 unsafe.get();
364                 /*
365                  * Note that the provided clazz might not be initialized. The HotSpot lowering
366                  * snippet for DynamicNewInstanceNode performs the necessary class initialization
367                  * check. Such a DynamicNewInstanceNode is also never constant folded to a
368                  * NewInstanceNode.
369                  */
370                 b.addPush(JavaKind.Object, new DynamicNewInstanceNode(b.nullCheckedValue(clazz, DeoptimizationAction.None), true));
371                 return true;
372             }
373         });
374     }
375 
<a name="8" id="anc8"></a>














































































376     private static void registerSystemPlugins(InvocationPlugins plugins) {
377         Registration r = new Registration(plugins, System.class);
378         r.register0(&quot;currentTimeMillis&quot;, new ForeignCallPlugin(HotSpotHostForeignCallsProvider.JAVA_TIME_MILLIS));
379         r.register0(&quot;nanoTime&quot;, new ForeignCallPlugin(HotSpotHostForeignCallsProvider.JAVA_TIME_NANOS));
380         r.register1(&quot;identityHashCode&quot;, Object.class, new InvocationPlugin() {
381             @Override
382             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
383                 b.addPush(JavaKind.Int, new IdentityHashCodeNode(object, b.bci()));
384                 return true;
385             }
386 
387             @Override
388             public boolean inlineOnly() {
389                 return true;
390             }
391         });
392         r.register5(&quot;arraycopy&quot;, Object.class, int.class, Object.class, int.class, int.class, new InvocationPlugin() {
393             @Override
394             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode src, ValueNode srcPos, ValueNode dst, ValueNode dstPos, ValueNode length) {
395                 b.add(new ArrayCopyNode(b.bci(), src, srcPos, dst, dstPos, length));
396                 return true;
397             }
398 
399             @Override
400             public boolean inlineOnly() {
401                 return true;
402             }
403         });
404     }
405 
406     private static void registerArrayPlugins(InvocationPlugins plugins, Replacements replacements) {
407         Registration r = new Registration(plugins, Array.class, replacements);
408         r.setAllowOverwrite(true);
409         r.registerMethodSubstitution(HotSpotArraySubstitutions.class, &quot;newInstance&quot;, Class.class, int.class);
410     }
411 
412     private static void registerStringPlugins(InvocationPlugins plugins, Replacements replacements) {
413         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
414             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacements);
415             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;toBytes&quot;, char[].class, int.class, int.class);
416             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChars&quot;, byte[].class, int.class, int.class, char[].class, int.class);
417         }
418     }
419 
420     private static void registerThreadPlugins(InvocationPlugins plugins, MetaAccessProvider metaAccess, WordTypes wordTypes, GraalHotSpotVMConfig config, Replacements replacements) {
421         Registration r = new Registration(plugins, Thread.class, replacements);
422         r.register0(&quot;currentThread&quot;, new InvocationPlugin() {
423             @Override
424             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
425                 CurrentJavaThreadNode thread = b.add(new CurrentJavaThreadNode(wordTypes.getWordKind()));
426                 ValueNode offset = b.add(ConstantNode.forLong(config.threadObjectOffset));
427                 AddressNode address = b.add(new OffsetAddressNode(thread, offset));
428                 // JavaThread::_threadObj is never compressed
429                 ObjectStamp stamp = StampFactory.objectNonNull(TypeReference.create(b.getAssumptions(), metaAccess.lookupJavaType(Thread.class)));
430                 b.addPush(JavaKind.Object, new ReadNode(address, JAVA_THREAD_THREAD_OBJECT_LOCATION, stamp, BarrierType.NONE));
431                 return true;
432             }
433         });
434 
435         if (config.osThreadInterruptedOffset != Integer.MAX_VALUE) {
436             r.registerMethodSubstitution(ThreadSubstitutions.class, &quot;isInterrupted&quot;, Receiver.class, boolean.class);
437         }
438 
439     }
440 
441     public static final String reflectionClass;
<a name="9" id="anc9"></a>
442 
443     static {
444         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
445             reflectionClass = &quot;sun.reflect.Reflection&quot;;
<a name="10" id="anc10"></a>
446         } else {
447             reflectionClass = &quot;jdk.internal.reflect.Reflection&quot;;
<a name="11" id="anc11"></a>
448         }
449     }
450 
451     public static String lookupIntrinsicName(GraalHotSpotVMConfig config, String className, String name1, String name2) {
452         return selectIntrinsicName(config, className, name1, name2).getLeft();
453     }
454 
455     /**
456      * Returns a pair of Strings where the left one represents the matched intrinsic name and the
457      * right one represents the mismatched intrinsic name.
458      */
459     public static Pair&lt;String, String&gt; selectIntrinsicName(GraalHotSpotVMConfig config, String className, String name1, String name2) {
460         boolean foundName1 = false;
461         boolean foundName2 = false;
462         for (VMIntrinsicMethod intrinsic : config.getStore().getIntrinsics()) {
463             if (className.equals(intrinsic.declaringClass)) {
464                 if (name1.equals(intrinsic.name)) {
465                     foundName1 = true;
466                 } else if (name2.equals(intrinsic.name)) {
467                     foundName2 = true;
468                 }
469             }
470         }
471         if (foundName1 &amp;&amp; !foundName2) {
472             return Pair.create(name1, name2);
473         } else if (foundName2 &amp;&amp; !foundName1) {
474             return Pair.create(name2, name1);
475         }
476         throw GraalError.shouldNotReachHere();
477     }
478 
479     public static boolean isIntrinsicName(GraalHotSpotVMConfig config, String className, String name) {
480         for (VMIntrinsicMethod intrinsic : config.getStore().getIntrinsics()) {
481             if (className.equals(intrinsic.declaringClass)) {
482                 if (name.equals(intrinsic.name)) {
483                     return true;
484                 }
485             }
486         }
487         return false;
488     }
489 
490     private static void registerAESPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
491         if (config.useAESIntrinsics) {
492             assert config.aescryptEncryptBlockStub != 0L;
493             assert config.aescryptDecryptBlockStub != 0L;
494             assert config.cipherBlockChainingEncryptAESCryptStub != 0L;
495             assert config.cipherBlockChainingDecryptAESCryptStub != 0L;
496             String arch = config.osArch;
497             String decryptSuffix = arch.equals(&quot;sparc&quot;) ? &quot;WithOriginalKey&quot; : &quot;&quot;;
498 
499             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CipherBlockChaining&quot;, replacements);
500 
501             Pair&lt;String, String&gt; cbcEncryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implEncrypt&quot;, &quot;encrypt&quot;);
502             registerAndCheckMismatch(r, CipherBlockChainingSubstitutions.class, cbcEncryptName, Receiver.class, byte[].class, int.class, int.class,
503                             byte[].class, int.class);
504 
505             Pair&lt;String, String&gt; cbcDecryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implDecrypt&quot;, &quot;decrypt&quot;);
506             registerAndCheckMismatch(r, CipherBlockChainingSubstitutions.class, cbcDecryptName, cbcDecryptName.getLeft() + decryptSuffix, Receiver.class, byte[].class, int.class, int.class,
507                             byte[].class, int.class);
508 
509             r = new Registration(plugins, &quot;com.sun.crypto.provider.AESCrypt&quot;, replacements);
510 
511             Pair&lt;String, String&gt; aesEncryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implEncryptBlock&quot;, &quot;encryptBlock&quot;);
512             registerAndCheckMismatch(r, AESCryptSubstitutions.class, aesEncryptName, Receiver.class, byte[].class, int.class, byte[].class, int.class);
513 
514             Pair&lt;String, String&gt; aesDecryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implDecryptBlock&quot;, &quot;decryptBlock&quot;);
515             registerAndCheckMismatch(r, AESCryptSubstitutions.class, aesDecryptName, aesDecryptName.getLeft() + decryptSuffix, Receiver.class, byte[].class, int.class, byte[].class, int.class);
516         }
517     }
518 
519     private static void registerAndCheckMismatch(Registration r, Class&lt;?&gt; substitutionClass, Pair&lt;String, String&gt; intrinsicNames, Type... argumentTypes) {
520         try {
521             r.registerMethodSubstitution(substitutionClass, intrinsicNames.getLeft(), argumentTypes);
522         } catch (NoSuchMethodError e) {
523             throw new GraalError(e, &quot;Found method named &#39;%s&#39; instead of &#39;%s&#39; in class &#39;%s&#39;. This is most likely because the JVMCI JDK in %s was built on an incompatible base JDK.&quot;,
524                             intrinsicNames.getRight(), intrinsicNames.getLeft(), r.getDeclaringType().getTypeName(), Services.getSavedProperties().get(&quot;java.home&quot;));
525         }
526     }
527 
528     private static void registerAndCheckMismatch(Registration r, Class&lt;?&gt; substitutionClass, Pair&lt;String, String&gt; intrinsicNames, String substituteName, Type... argumentTypes) {
529         try {
530             r.registerMethodSubstitution(substitutionClass, intrinsicNames.getLeft(), substituteName, argumentTypes);
531         } catch (NoSuchMethodError e) {
532             throw new GraalError(e, &quot;Found method named &#39;%s&#39; instead of &#39;%s&#39; in class &#39;%s&#39;. This is most likely because the JVMCI JDK in %s was built on an incompatible base JDK.&quot;,
533                             intrinsicNames.getRight(), intrinsicNames.getLeft(), r.getDeclaringType().getTypeName(), Services.getSavedProperties().get(&quot;java.home&quot;));
534         }
535     }
536 
537     private static void registerBigIntegerPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
538         Registration r = new Registration(plugins, BigInteger.class, replacements);
539         assert !config.useMultiplyToLenIntrinsic() || config.multiplyToLen != 0L;
540         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
541             r.registerConditionalMethodSubstitution(config.useMultiplyToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;multiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class,
542                             int.class, int[].class);
543         } else {
544             r.registerConditionalMethodSubstitution(config.useMultiplyToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;implMultiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class,
545                             int.class, int[].class);
546         }
547         r.registerConditionalMethodSubstitution(config.useMulAddIntrinsic(), BigIntegerSubstitutions.class, &quot;implMulAdd&quot;, int[].class, int[].class, int.class, int.class, int.class);
548         r.registerConditionalMethodSubstitution(config.useMontgomeryMultiplyIntrinsic(), BigIntegerSubstitutions.class, &quot;implMontgomeryMultiply&quot;, int[].class, int[].class, int[].class, int.class,
549                         long.class, int[].class);
550         r.registerConditionalMethodSubstitution(config.useMontgomerySquareIntrinsic(), BigIntegerSubstitutions.class, &quot;implMontgomerySquare&quot;, int[].class, int[].class, int.class, long.class,
551                         int[].class);
552         r.registerConditionalMethodSubstitution(config.useSquareToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;implSquareToLen&quot;, int[].class, int.class, int[].class, int.class);
553     }
554 
555     private static void registerSHAPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
556         boolean useSha1 = config.useSHA1Intrinsics();
557         boolean useSha256 = config.useSHA256Intrinsics();
558         boolean useSha512 = config.useSHA512Intrinsics();
559 
560         if (isIntrinsicName(config, &quot;sun/security/provider/DigestBase&quot;, &quot;implCompressMultiBlock0&quot;) &amp;&amp; (useSha1 || useSha256 || useSha512)) {
561             Registration r = new Registration(plugins, &quot;sun.security.provider.DigestBase&quot;, replacements);
562             r.registerMethodSubstitution(DigestBaseSubstitutions.class, &quot;implCompressMultiBlock0&quot;, Receiver.class, byte[].class, int.class, int.class);
563         }
564 
565         Pair&lt;String, String&gt; implCompressName = selectIntrinsicName(config, &quot;sun/security/provider/SHA&quot;, &quot;implCompress&quot;, &quot;implCompress0&quot;);
566         if (useSha1) {
567             assert config.sha1ImplCompress != 0L;
568             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA&quot;, replacements);
569             registerAndCheckMismatch(r, SHASubstitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);
570         }
571         if (useSha256) {
572             assert config.sha256ImplCompress != 0L;
573             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA2&quot;, replacements);
574             registerAndCheckMismatch(r, SHA2Substitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);
575         }
576         if (useSha512) {
577             assert config.sha512ImplCompress != 0L;
578             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA5&quot;, replacements);
579             registerAndCheckMismatch(r, SHA5Substitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);
580         }
581     }
582 
583     private static void registerGHASHPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess) {
584         if (config.useGHASHIntrinsics()) {
585             assert config.ghashProcessBlocks != 0L;
586             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.GHASH&quot;);
587             r.register5(&quot;processBlocks&quot;,
588                             byte[].class,
589                             int.class,
590                             int.class,
591                             long[].class,
592                             long[].class,
593                             new InvocationPlugin() {
594                                 @Override
595                                 public boolean apply(GraphBuilderContext b,
596                                                 ResolvedJavaMethod targetMethod,
597                                                 Receiver receiver,
598                                                 ValueNode data,
599                                                 ValueNode inOffset,
600                                                 ValueNode blocks,
601                                                 ValueNode state,
602                                                 ValueNode hashSubkey) {
603                                     int longArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Long);
604                                     int byteArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Byte);
605                                     ValueNode dataOffset = AddNode.create(ConstantNode.forInt(byteArrayBaseOffset), inOffset, NodeView.DEFAULT);
606                                     ComputeObjectAddressNode dataAddress = b.add(new ComputeObjectAddressNode(data, dataOffset));
607                                     ComputeObjectAddressNode stateAddress = b.add(new ComputeObjectAddressNode(state, ConstantNode.forInt(longArrayBaseOffset)));
608                                     ComputeObjectAddressNode hashSubkeyAddress = b.add(new ComputeObjectAddressNode(hashSubkey, ConstantNode.forInt(longArrayBaseOffset)));
609                                     b.add(new ForeignCallNode(GHASH_PROCESS_BLOCKS, stateAddress, hashSubkeyAddress, dataAddress, blocks));
610                                     return true;
611                                 }
612                             });
613         }
614     }
615 
616     private static void registerCounterModePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
617         if (isIntrinsicName(config, &quot;com/sun/crypto/provider/CounterMode&quot;, &quot;implCrypt&quot;)) {
618             assert !config.useAESCTRIntrinsics || config.counterModeAESCrypt != 0L;
619             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CounterMode&quot;, replacements);
620             r.registerConditionalMethodSubstitution(config.useAESCTRIntrinsics, CounterModeSubstitutions.class, &quot;implCrypt&quot;, Receiver.class, byte[].class, int.class, int.class, byte[].class,
621                             int.class);
622         }
623     }
624 
625     private static void registerBase64Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess) {
626         if (config.useBase64Intrinsics()) {
627             Registration r = new Registration(plugins, &quot;java.util.Base64$Encoder&quot;);
628             r.register7(&quot;encodeBlock&quot;,
629                             Receiver.class,
630                             byte[].class,
631                             int.class,
632                             int.class,
633                             byte[].class,
634                             int.class,
635                             boolean.class,
636                             new InvocationPlugin() {
637                                 @Override
638                                 public boolean apply(GraphBuilderContext b,
639                                                 ResolvedJavaMethod targetMethod,
640                                                 Receiver receiver,
641                                                 ValueNode src,
642                                                 ValueNode sp,
643                                                 ValueNode sl,
644                                                 ValueNode dst,
645                                                 ValueNode dp,
646                                                 ValueNode isURL) {
647                                     int byteArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Byte);
648                                     ComputeObjectAddressNode srcAddress = b.add(new ComputeObjectAddressNode(src, ConstantNode.forInt(byteArrayBaseOffset)));
649                                     ComputeObjectAddressNode dstAddress = b.add(new ComputeObjectAddressNode(dst, ConstantNode.forInt(byteArrayBaseOffset)));
650                                     b.add(new ForeignCallNode(BASE64_ENCODE_BLOCK, srcAddress, sp, sl, dstAddress, dp, isURL));
651                                     return true;
652                                 }
653                             });
654         }
655     }
656 
657     private static void registerCRC32Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
658         Registration r = new Registration(plugins, CRC32.class, replacements);
659         r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;update&quot;, int.class, int.class);
660         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
661             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);
662             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateByteBuffer&quot;, int.class, long.class, int.class, int.class);
663         } else {
664             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateBytes0&quot;, int.class, byte[].class, int.class, int.class);
665             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateByteBuffer0&quot;, int.class, long.class, int.class, int.class);
666         }
667     }
668 
669     private static void registerCRC32CPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
670         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
671             Registration r = new Registration(plugins, &quot;java.util.zip.CRC32C&quot;, replacements);
672             r.registerConditionalMethodSubstitution(config.useCRC32CIntrinsics, CRC32CSubstitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);
673             r.registerConditionalMethodSubstitution(config.useCRC32CIntrinsics, CRC32CSubstitutions.class, &quot;updateDirectByteBuffer&quot;, int.class, long.class, int.class, int.class);
674         }
675     }
676 
677     private static void registerArraysSupportPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
678         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
679             Registration r = new Registration(plugins, &quot;jdk.internal.util.ArraysSupport&quot;, replacements);
680             r.registerConditionalMethodSubstitution(config.useVectorizedMismatchIntrinsic, ArraysSupportSubstitutions.class, &quot;vectorizedMismatch&quot;, Object.class, long.class, Object.class, long.class,
681                             int.class, int.class);
682         }
683     }
684 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
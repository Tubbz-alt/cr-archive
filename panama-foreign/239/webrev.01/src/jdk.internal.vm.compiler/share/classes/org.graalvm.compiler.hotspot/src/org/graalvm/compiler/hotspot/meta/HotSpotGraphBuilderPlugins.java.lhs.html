<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotGraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.meta;
 26 
 27 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
 28 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 29 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigAccess.JDK;
 30 import static org.graalvm.compiler.hotspot.HotSpotBackend.BASE64_ENCODE_BLOCK;
 31 import static org.graalvm.compiler.hotspot.HotSpotBackend.GHASH_PROCESS_BLOCKS;
 32 import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;
 33 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.JAVA_THREAD_THREAD_OBJECT_LOCATION;
 34 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
 35 
 36 import java.lang.invoke.ConstantCallSite;
 37 import java.lang.invoke.MutableCallSite;
 38 import java.lang.invoke.VolatileCallSite;
 39 import java.lang.reflect.Array;
 40 import java.lang.reflect.Type;
 41 import java.math.BigInteger;
 42 import java.util.zip.CRC32;
 43 
 44 import jdk.internal.vm.compiler.collections.Pair;
 45 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 46 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 47 import org.graalvm.compiler.core.common.type.ObjectStamp;
 48 import org.graalvm.compiler.core.common.type.StampFactory;
 49 import org.graalvm.compiler.core.common.type.TypeReference;
 50 import org.graalvm.compiler.debug.GraalError;
 51 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 52 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
 53 import org.graalvm.compiler.hotspot.nodes.CurrentJavaThreadNode;
 54 import org.graalvm.compiler.hotspot.replacements.AESCryptSubstitutions;
 55 import org.graalvm.compiler.hotspot.replacements.ArraysSupportSubstitutions;
 56 import org.graalvm.compiler.hotspot.replacements.BigIntegerSubstitutions;
 57 import org.graalvm.compiler.hotspot.replacements.CRC32CSubstitutions;
 58 import org.graalvm.compiler.hotspot.replacements.CRC32Substitutions;
 59 import org.graalvm.compiler.hotspot.replacements.CallSiteTargetNode;
 60 import org.graalvm.compiler.hotspot.replacements.CipherBlockChainingSubstitutions;
<a name="1" id="anc1"></a><span class="line-removed"> 61 import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;</span>
 62 import org.graalvm.compiler.hotspot.replacements.CounterModeSubstitutions;
 63 import org.graalvm.compiler.hotspot.replacements.DigestBaseSubstitutions;
 64 import org.graalvm.compiler.hotspot.replacements.FastNotifyNode;
 65 import org.graalvm.compiler.hotspot.replacements.HotSpotArraySubstitutions;
 66 import org.graalvm.compiler.hotspot.replacements.HotSpotClassSubstitutions;
 67 import org.graalvm.compiler.hotspot.replacements.HotSpotReflectionGetCallerClassNode;
 68 import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
 69 import org.graalvm.compiler.hotspot.replacements.ObjectCloneNode;
 70 import org.graalvm.compiler.hotspot.replacements.ReflectionSubstitutions;
 71 import org.graalvm.compiler.hotspot.replacements.SHA2Substitutions;
 72 import org.graalvm.compiler.hotspot.replacements.SHA5Substitutions;
 73 import org.graalvm.compiler.hotspot.replacements.SHASubstitutions;
 74 import org.graalvm.compiler.hotspot.replacements.StringUTF16Substitutions;
 75 import org.graalvm.compiler.hotspot.replacements.ThreadSubstitutions;
 76 import org.graalvm.compiler.hotspot.word.HotSpotWordTypes;
 77 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
 78 import org.graalvm.compiler.nodes.ConstantNode;
<a name="2" id="anc2"></a><span class="line-removed"> 79 import org.graalvm.compiler.nodes.NamedLocationIdentity;</span>
 80 import org.graalvm.compiler.nodes.NodeView;
 81 import org.graalvm.compiler.nodes.ValueNode;
 82 import org.graalvm.compiler.nodes.calc.AddNode;
<a name="3" id="anc3"></a><span class="line-removed"> 83 import org.graalvm.compiler.nodes.calc.IntegerConvertNode;</span>
<span class="line-removed"> 84 import org.graalvm.compiler.nodes.calc.LeftShiftNode;</span>
 85 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 86 import org.graalvm.compiler.nodes.graphbuilderconf.ForeignCallPlugin;
 87 import org.graalvm.compiler.nodes.graphbuilderconf.GeneratedPluginFactory;
 88 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 89 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 90 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 91 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 92 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 93 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 94 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
 95 import org.graalvm.compiler.nodes.memory.OnHeapMemoryAccess.BarrierType;
 96 import org.graalvm.compiler.nodes.memory.ReadNode;
 97 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 98 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 99 import org.graalvm.compiler.nodes.spi.Replacements;
100 import org.graalvm.compiler.nodes.util.GraphUtil;
101 import org.graalvm.compiler.options.OptionValues;
102 import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
103 import org.graalvm.compiler.replacements.InlineDuringParsingPlugin;
104 import org.graalvm.compiler.replacements.MethodHandlePlugin;
105 import org.graalvm.compiler.replacements.NodeIntrinsificationProvider;
106 import org.graalvm.compiler.replacements.ReplacementsImpl;
107 import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins;
108 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
109 import org.graalvm.compiler.replacements.nodes.MacroNode.MacroParams;
110 import org.graalvm.compiler.serviceprovider.GraalServices;
111 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
<a name="4" id="anc4"></a><span class="line-removed">112 import org.graalvm.compiler.word.WordOperationPlugin;</span>
113 import org.graalvm.compiler.word.WordTypes;
<a name="5" id="anc5"></a><span class="line-removed">114 import jdk.internal.vm.compiler.word.LocationIdentity;</span>
115 
<a name="6" id="anc6"></a><span class="line-removed">116 import jdk.vm.ci.code.CodeUtil;</span>
117 import jdk.vm.ci.code.TargetDescription;
118 import jdk.vm.ci.hotspot.VMIntrinsicMethod;
119 import jdk.vm.ci.meta.ConstantReflectionProvider;
120 import jdk.vm.ci.meta.DeoptimizationAction;
121 import jdk.vm.ci.meta.JavaKind;
122 import jdk.vm.ci.meta.MetaAccessProvider;
123 import jdk.vm.ci.meta.ResolvedJavaMethod;
124 import jdk.vm.ci.services.Services;
125 import sun.misc.Unsafe;
126 
127 /**
128  * Defines the {@link Plugins} used when running on HotSpot.
129  */
130 public class HotSpotGraphBuilderPlugins {
131 
132     /**
133      * Creates a {@link Plugins} object that should be used when running on HotSpot.
134      *
135      * @param constantReflection
136      * @param snippetReflection
137      * @param foreignCalls
138      * @param options
139      * @param target
140      */
141     public static Plugins create(HotSpotGraalRuntimeProvider graalRuntime,
142                     CompilerConfiguration compilerConfiguration,
143                     GraalHotSpotVMConfig config,
144                     HotSpotWordTypes wordTypes,
145                     MetaAccessProvider metaAccess,
146                     ConstantReflectionProvider constantReflection,
147                     SnippetReflectionProvider snippetReflection,
148                     ForeignCallsProvider foreignCalls,
149                     ReplacementsImpl replacements,
150                     OptionValues options,
151                     TargetDescription target) {
152         InvocationPlugins invocationPlugins = new HotSpotInvocationPlugins(graalRuntime, config, compilerConfiguration);
153 
154         Plugins plugins = new Plugins(invocationPlugins);
155         if (!IS_IN_NATIVE_IMAGE) {
156             // In libgraal all word related operations have been fully processed so this is unneeded
157             HotSpotWordOperationPlugin wordOperationPlugin = new HotSpotWordOperationPlugin(snippetReflection, wordTypes);
158             HotSpotNodePlugin nodePlugin = new HotSpotNodePlugin(wordOperationPlugin, config, wordTypes);
159 
160             plugins.appendTypePlugin(nodePlugin);
161             plugins.appendNodePlugin(nodePlugin);
162         }
163         if (!GeneratePIC.getValue(options)) {
164             plugins.appendNodePlugin(new MethodHandlePlugin(constantReflection.getMethodHandleAccess(), !config.supportsMethodHandleDeoptimizationEntry()));
165         }
166         plugins.appendInlineInvokePlugin(replacements);
167         if (InlineDuringParsing.getValue(options)) {
168             plugins.appendInlineInvokePlugin(new InlineDuringParsingPlugin());
169         }
170 
171         if (GeneratePIC.getValue(options)) {
172             plugins.setClassInitializationPlugin(new HotSpotAOTClassInitializationPlugin());
173             if (TieredAOT.getValue(options)) {
174                 plugins.setProfilingPlugin(new HotSpotAOTProfilingPlugin());
175             }
176         } else {
177             if (config.instanceKlassInitThreadOffset != -1) {
178                 plugins.setClassInitializationPlugin(new HotSpotJITClassInitializationPlugin());
179             }
180         }
181 
182         invocationPlugins.defer(new Runnable() {
183 
184             @Override
185             public void run() {
186                 registerObjectPlugins(invocationPlugins, options, config, replacements);
187                 registerClassPlugins(plugins, config, replacements);
188                 registerSystemPlugins(invocationPlugins);
189                 registerThreadPlugins(invocationPlugins, metaAccess, wordTypes, config, replacements);
190                 if (!GeneratePIC.getValue(options)) {
191                     registerCallSitePlugins(invocationPlugins);
192                 }
193                 registerReflectionPlugins(invocationPlugins, replacements);
<a name="7" id="anc7"></a><span class="line-removed">194                 registerConstantPoolPlugins(invocationPlugins, wordTypes, config, replacements);</span>
195                 registerAESPlugins(invocationPlugins, config, replacements);
196                 registerCRC32Plugins(invocationPlugins, config, replacements);
197                 registerCRC32CPlugins(invocationPlugins, config, replacements);
198                 registerBigIntegerPlugins(invocationPlugins, config, replacements);
199                 registerSHAPlugins(invocationPlugins, config, replacements);
200                 registerGHASHPlugins(invocationPlugins, config, metaAccess);
201                 registerCounterModePlugins(invocationPlugins, config, replacements);
202                 registerBase64Plugins(invocationPlugins, config, metaAccess);
203                 registerUnsafePlugins(invocationPlugins, config, replacements);
204                 StandardGraphBuilderPlugins.registerInvocationPlugins(metaAccess, snippetReflection, invocationPlugins, replacements, true, false, true);
205                 registerArrayPlugins(invocationPlugins, replacements);
206                 registerStringPlugins(invocationPlugins, replacements);
207                 registerArraysSupportPlugins(invocationPlugins, config, replacements);
208             }
209         });
210         if (!IS_IN_NATIVE_IMAGE) {
211             // In libgraal all NodeIntrinsics been converted into special nodes so the plugins
212             // aren&#39;t needed.
213             NodeIntrinsificationProvider nodeIntrinsificationProvider = new NodeIntrinsificationProvider(metaAccess, snippetReflection, foreignCalls, wordTypes, target);
214             invocationPlugins.defer(new Runnable() {
215 
216                 @Override
217                 public void run() {
218 
219                     for (GeneratedPluginFactory factory : GraalServices.load(GeneratedPluginFactory.class)) {
220                         factory.registerPlugins(invocationPlugins, nodeIntrinsificationProvider);
221                     }
222 
223                 }
224             });
225         }
226         return plugins;
227     }
228 
229     private static void registerObjectPlugins(InvocationPlugins plugins, OptionValues options, GraalHotSpotVMConfig config, Replacements replacements) {
230         Registration r = new Registration(plugins, Object.class, replacements);
231         if (!GeneratePIC.getValue(options)) {
232             // FIXME: clone() requires speculation and requires a fix in here (to check that
233             // b.getAssumptions() != null), and in ReplacementImpl.getSubstitution() where there is
234             // an instantiation of IntrinsicGraphBuilder using a constructor that sets
235             // AllowAssumptions to YES automatically. The former has to inherit the assumptions
236             // settings from the root compile instead. So, for now, I&#39;m disabling it for
237             // GeneratePIC.
238             r.register1(&quot;clone&quot;, Receiver.class, new InvocationPlugin() {
239                 @Override
240                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
241                     ValueNode object = receiver.get();
242                     b.addPush(JavaKind.Object, new ObjectCloneNode(MacroParams.of(b, targetMethod, object)));
243                     return true;
244                 }
245 
246                 @Override
247                 public boolean inlineOnly() {
248                     return true;
249                 }
250             });
251         }
252         r.register1(&quot;hashCode&quot;, Receiver.class, new InvocationPlugin() {
253             @Override
254             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
255                 ValueNode object = receiver.get();
256                 b.addPush(JavaKind.Int, new IdentityHashCodeNode(object, b.bci()));
257                 return true;
258             }
259 
260             @Override
261             public boolean inlineOnly() {
262                 return true;
263             }
264         });
265         if (config.inlineNotify()) {
266             r.register1(&quot;notify&quot;, Receiver.class, new InvocationPlugin() {
267                 @Override
268                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
269                     ValueNode object = receiver.get();
270                     b.add(new FastNotifyNode(object, false, b.bci()));
271                     return true;
272                 }
273 
274                 @Override
275                 public boolean inlineOnly() {
276                     return true;
277                 }
278             });
279         }
280         if (config.inlineNotifyAll()) {
281             r.register1(&quot;notifyAll&quot;, Receiver.class, new InvocationPlugin() {
282                 @Override
283                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
284                     ValueNode object = receiver.get();
285                     b.add(new FastNotifyNode(object, true, b.bci()));
286                     return true;
287                 }
288 
289                 @Override
290                 public boolean inlineOnly() {
291                     return true;
292                 }
293             });
294         }
295     }
296 
297     private static void registerClassPlugins(Plugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
298         Registration r = new Registration(plugins.getInvocationPlugins(), Class.class, replacements);
299 
300         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getModifiers&quot;, Receiver.class);
301         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isInterface&quot;, Receiver.class);
302         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isArray&quot;, Receiver.class);
303         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isPrimitive&quot;, Receiver.class);
304         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getSuperclass&quot;, Receiver.class);
305 
306         if (config.jvmAccIsHiddenClass != 0) {
307             r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isHidden&quot;, Receiver.class);
308         }
309 
310         if (config.getFieldOffset(&quot;ArrayKlass::_component_mirror&quot;, Integer.class, &quot;oop&quot;, Integer.MAX_VALUE, JDK &lt;= 8) != Integer.MAX_VALUE) {
311             r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getComponentType&quot;, Receiver.class);
312         }
313     }
314 
315     private static void registerCallSitePlugins(InvocationPlugins plugins) {
316         InvocationPlugin plugin = new InvocationPlugin() {
317             @Override
318             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
319                 ValueNode callSite = receiver.get();
320                 ValueNode folded = CallSiteTargetNode.tryFold(GraphUtil.originalValue(callSite, true), b.getMetaAccess(), b.getAssumptions());
321                 if (folded != null) {
322                     b.addPush(JavaKind.Object, folded);
323                 } else {
324                     b.addPush(JavaKind.Object, new CallSiteTargetNode(MacroParams.of(b, targetMethod, callSite)));
325                 }
326                 return true;
327             }
328 
329             @Override
330             public boolean inlineOnly() {
331                 return true;
332             }
333         };
334         plugins.register(plugin, ConstantCallSite.class, &quot;getTarget&quot;, Receiver.class);
335         plugins.register(plugin, MutableCallSite.class, &quot;getTarget&quot;, Receiver.class);
336         plugins.register(plugin, VolatileCallSite.class, &quot;getTarget&quot;, Receiver.class);
337     }
338 
339     private static void registerReflectionPlugins(InvocationPlugins plugins, Replacements replacements) {
340         Registration r = new Registration(plugins, reflectionClass, replacements);
341         r.register0(&quot;getCallerClass&quot;, new InvocationPlugin() {
342             @Override
343             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
344                 b.addPush(JavaKind.Object, new HotSpotReflectionGetCallerClassNode(MacroParams.of(b, targetMethod)));
345                 return true;
346             }
347 
348             @Override
349             public boolean inlineOnly() {
350                 return true;
351             }
352         });
353         r.registerMethodSubstitution(ReflectionSubstitutions.class, &quot;getClassAccessFlags&quot;, Class.class);
354     }
355 
356     private static void registerUnsafePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
357         Registration r;
358         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
359             r = new Registration(plugins, Unsafe.class, replacements);
360         } else {
361             r = new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements);
362         }
363         String substituteMethodName = config.doingUnsafeAccessOffset != Integer.MAX_VALUE ? &quot;copyMemoryGuarded&quot; : &quot;copyMemory&quot;;
364         r.registerMethodSubstitution(HotSpotUnsafeSubstitutions.class, HotSpotUnsafeSubstitutions.copyMemoryName, substituteMethodName, Receiver.class, Object.class, long.class, Object.class,
365                         long.class, long.class);
366 
367         r.register2(&quot;allocateInstance&quot;, Receiver.class, Class.class, new InvocationPlugin() {
368             @Override
369             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode clazz) {
370                 /* Emits a null-check for the otherwise unused receiver. */
371                 unsafe.get();
372                 /*
373                  * Note that the provided clazz might not be initialized. The HotSpot lowering
374                  * snippet for DynamicNewInstanceNode performs the necessary class initialization
375                  * check. Such a DynamicNewInstanceNode is also never constant folded to a
376                  * NewInstanceNode.
377                  */
378                 b.addPush(JavaKind.Object, new DynamicNewInstanceNode(b.nullCheckedValue(clazz, DeoptimizationAction.None), true));
379                 return true;
380             }
381         });
382     }
383 
<a name="8" id="anc8"></a><span class="line-removed">384     private static final LocationIdentity INSTANCE_KLASS_CONSTANTS = NamedLocationIdentity.immutable(&quot;InstanceKlass::_constants&quot;);</span>
<span class="line-removed">385     private static final LocationIdentity CONSTANT_POOL_LENGTH = NamedLocationIdentity.immutable(&quot;ConstantPool::_length&quot;);</span>
<span class="line-removed">386 </span>
<span class="line-removed">387     /**</span>
<span class="line-removed">388      * Emits a node to get the metaspace {@code ConstantPool} pointer given the value of the</span>
<span class="line-removed">389      * {@code constantPoolOop} field in a ConstantPool value.</span>
<span class="line-removed">390      *</span>
<span class="line-removed">391      * @param constantPoolOop value of the {@code constantPoolOop} field in a ConstantPool value</span>
<span class="line-removed">392      * @return a node representing the metaspace {@code ConstantPool} pointer associated with</span>
<span class="line-removed">393      *         {@code constantPoolOop}</span>
<span class="line-removed">394      */</span>
<span class="line-removed">395     private static ValueNode getMetaspaceConstantPool(GraphBuilderContext b, ValueNode constantPoolOop, WordTypes wordTypes, GraalHotSpotVMConfig config) {</span>
<span class="line-removed">396         // ConstantPool.constantPoolOop is in fact the holder class.</span>
<span class="line-removed">397         ValueNode value = b.nullCheckedValue(constantPoolOop, DeoptimizationAction.None);</span>
<span class="line-removed">398         ValueNode klass = b.add(ClassGetHubNode.create(value, b.getMetaAccess(), b.getConstantReflection(), false));</span>
<span class="line-removed">399 </span>
<span class="line-removed">400         boolean notCompressible = false;</span>
<span class="line-removed">401         AddressNode constantsAddress = b.add(new OffsetAddressNode(klass, b.add(ConstantNode.forLong(config.instanceKlassConstantsOffset))));</span>
<span class="line-removed">402         return WordOperationPlugin.readOp(b, wordTypes.getWordKind(), constantsAddress, INSTANCE_KLASS_CONSTANTS, BarrierType.NONE, notCompressible);</span>
<span class="line-removed">403     }</span>
<span class="line-removed">404 </span>
<span class="line-removed">405     /**</span>
<span class="line-removed">406      * Emits a node representing an element in a metaspace {@code ConstantPool}.</span>
<span class="line-removed">407      *</span>
<span class="line-removed">408      * @param constantPoolOop value of the {@code constantPoolOop} field in a ConstantPool value</span>
<span class="line-removed">409      */</span>
<span class="line-removed">410     private static boolean readMetaspaceConstantPoolElement(GraphBuilderContext b, ValueNode constantPoolOop, ValueNode index, JavaKind elementKind, WordTypes wordTypes, GraalHotSpotVMConfig config) {</span>
<span class="line-removed">411         ValueNode constants = getMetaspaceConstantPool(b, constantPoolOop, wordTypes, config);</span>
<span class="line-removed">412         int shift = CodeUtil.log2(wordTypes.getWordKind().getByteCount());</span>
<span class="line-removed">413         ValueNode scaledIndex = b.add(new LeftShiftNode(IntegerConvertNode.convert(index, StampFactory.forKind(JavaKind.Long), NodeView.DEFAULT), b.add(ConstantNode.forInt(shift))));</span>
<span class="line-removed">414         ValueNode offset = b.add(new AddNode(scaledIndex, b.add(ConstantNode.forLong(config.constantPoolSize))));</span>
<span class="line-removed">415         AddressNode elementAddress = b.add(new OffsetAddressNode(constants, offset));</span>
<span class="line-removed">416         boolean notCompressible = false;</span>
<span class="line-removed">417         ValueNode elementValue = WordOperationPlugin.readOp(b, elementKind, elementAddress, NamedLocationIdentity.getArrayLocation(elementKind), BarrierType.NONE, notCompressible);</span>
<span class="line-removed">418         b.addPush(elementKind, elementValue);</span>
<span class="line-removed">419         return true;</span>
<span class="line-removed">420     }</span>
<span class="line-removed">421 </span>
<span class="line-removed">422     private static void registerConstantPoolPlugins(InvocationPlugins plugins, WordTypes wordTypes, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-removed">423         Registration r = new Registration(plugins, constantPoolClass, replacements);</span>
<span class="line-removed">424 </span>
<span class="line-removed">425         r.register2(&quot;getSize0&quot;, Receiver.class, Object.class, new InvocationPlugin() {</span>
<span class="line-removed">426             @Override</span>
<span class="line-removed">427             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop) {</span>
<span class="line-removed">428                 boolean notCompressible = false;</span>
<span class="line-removed">429                 ValueNode constants = getMetaspaceConstantPool(b, constantPoolOop, wordTypes, config);</span>
<span class="line-removed">430                 AddressNode lengthAddress = b.add(new OffsetAddressNode(constants, b.add(ConstantNode.forLong(config.constantPoolLengthOffset))));</span>
<span class="line-removed">431                 ValueNode length = WordOperationPlugin.readOp(b, JavaKind.Int, lengthAddress, CONSTANT_POOL_LENGTH, BarrierType.NONE, notCompressible);</span>
<span class="line-removed">432                 b.addPush(JavaKind.Int, length);</span>
<span class="line-removed">433                 return true;</span>
<span class="line-removed">434             }</span>
<span class="line-removed">435         });</span>
<span class="line-removed">436 </span>
<span class="line-removed">437         r.register3(&quot;getIntAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {</span>
<span class="line-removed">438             @Override</span>
<span class="line-removed">439             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {</span>
<span class="line-removed">440                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Int, wordTypes, config);</span>
<span class="line-removed">441             }</span>
<span class="line-removed">442         });</span>
<span class="line-removed">443         r.register3(&quot;getLongAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {</span>
<span class="line-removed">444             @Override</span>
<span class="line-removed">445             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {</span>
<span class="line-removed">446                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Long, wordTypes, config);</span>
<span class="line-removed">447             }</span>
<span class="line-removed">448         });</span>
<span class="line-removed">449         r.register3(&quot;getFloatAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {</span>
<span class="line-removed">450             @Override</span>
<span class="line-removed">451             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {</span>
<span class="line-removed">452                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Float, wordTypes, config);</span>
<span class="line-removed">453             }</span>
<span class="line-removed">454         });</span>
<span class="line-removed">455         r.register3(&quot;getDoubleAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {</span>
<span class="line-removed">456             @Override</span>
<span class="line-removed">457             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {</span>
<span class="line-removed">458                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Double, wordTypes, config);</span>
<span class="line-removed">459             }</span>
<span class="line-removed">460         });</span>
<span class="line-removed">461     }</span>
<span class="line-removed">462 </span>
463     private static void registerSystemPlugins(InvocationPlugins plugins) {
464         Registration r = new Registration(plugins, System.class);
465         r.register0(&quot;currentTimeMillis&quot;, new ForeignCallPlugin(HotSpotHostForeignCallsProvider.JAVA_TIME_MILLIS));
466         r.register0(&quot;nanoTime&quot;, new ForeignCallPlugin(HotSpotHostForeignCallsProvider.JAVA_TIME_NANOS));
467         r.register1(&quot;identityHashCode&quot;, Object.class, new InvocationPlugin() {
468             @Override
469             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
470                 b.addPush(JavaKind.Int, new IdentityHashCodeNode(object, b.bci()));
471                 return true;
472             }
473 
474             @Override
475             public boolean inlineOnly() {
476                 return true;
477             }
478         });
479         r.register5(&quot;arraycopy&quot;, Object.class, int.class, Object.class, int.class, int.class, new InvocationPlugin() {
480             @Override
481             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode src, ValueNode srcPos, ValueNode dst, ValueNode dstPos, ValueNode length) {
482                 b.add(new ArrayCopyNode(b.bci(), src, srcPos, dst, dstPos, length));
483                 return true;
484             }
485 
486             @Override
487             public boolean inlineOnly() {
488                 return true;
489             }
490         });
491     }
492 
493     private static void registerArrayPlugins(InvocationPlugins plugins, Replacements replacements) {
494         Registration r = new Registration(plugins, Array.class, replacements);
495         r.setAllowOverwrite(true);
496         r.registerMethodSubstitution(HotSpotArraySubstitutions.class, &quot;newInstance&quot;, Class.class, int.class);
497     }
498 
499     private static void registerStringPlugins(InvocationPlugins plugins, Replacements replacements) {
500         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
501             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacements);
502             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;toBytes&quot;, char[].class, int.class, int.class);
503             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChars&quot;, byte[].class, int.class, int.class, char[].class, int.class);
504         }
505     }
506 
507     private static void registerThreadPlugins(InvocationPlugins plugins, MetaAccessProvider metaAccess, WordTypes wordTypes, GraalHotSpotVMConfig config, Replacements replacements) {
508         Registration r = new Registration(plugins, Thread.class, replacements);
509         r.register0(&quot;currentThread&quot;, new InvocationPlugin() {
510             @Override
511             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
512                 CurrentJavaThreadNode thread = b.add(new CurrentJavaThreadNode(wordTypes.getWordKind()));
513                 ValueNode offset = b.add(ConstantNode.forLong(config.threadObjectOffset));
514                 AddressNode address = b.add(new OffsetAddressNode(thread, offset));
515                 // JavaThread::_threadObj is never compressed
516                 ObjectStamp stamp = StampFactory.objectNonNull(TypeReference.create(b.getAssumptions(), metaAccess.lookupJavaType(Thread.class)));
517                 b.addPush(JavaKind.Object, new ReadNode(address, JAVA_THREAD_THREAD_OBJECT_LOCATION, stamp, BarrierType.NONE));
518                 return true;
519             }
520         });
521 
522         if (config.osThreadInterruptedOffset != Integer.MAX_VALUE) {
523             r.registerMethodSubstitution(ThreadSubstitutions.class, &quot;isInterrupted&quot;, Receiver.class, boolean.class);
524         }
525 
526     }
527 
528     public static final String reflectionClass;
<a name="9" id="anc9"></a><span class="line-removed">529     public static final String constantPoolClass;</span>
530 
531     static {
532         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
533             reflectionClass = &quot;sun.reflect.Reflection&quot;;
<a name="10" id="anc10"></a><span class="line-removed">534             constantPoolClass = &quot;sun.reflect.ConstantPool&quot;;</span>
535         } else {
536             reflectionClass = &quot;jdk.internal.reflect.Reflection&quot;;
<a name="11" id="anc11"></a><span class="line-removed">537             constantPoolClass = &quot;jdk.internal.reflect.ConstantPool&quot;;</span>
538         }
539     }
540 
541     public static String lookupIntrinsicName(GraalHotSpotVMConfig config, String className, String name1, String name2) {
542         return selectIntrinsicName(config, className, name1, name2).getLeft();
543     }
544 
545     /**
546      * Returns a pair of Strings where the left one represents the matched intrinsic name and the
547      * right one represents the mismatched intrinsic name.
548      */
549     public static Pair&lt;String, String&gt; selectIntrinsicName(GraalHotSpotVMConfig config, String className, String name1, String name2) {
550         boolean foundName1 = false;
551         boolean foundName2 = false;
552         for (VMIntrinsicMethod intrinsic : config.getStore().getIntrinsics()) {
553             if (className.equals(intrinsic.declaringClass)) {
554                 if (name1.equals(intrinsic.name)) {
555                     foundName1 = true;
556                 } else if (name2.equals(intrinsic.name)) {
557                     foundName2 = true;
558                 }
559             }
560         }
561         if (foundName1 &amp;&amp; !foundName2) {
562             return Pair.create(name1, name2);
563         } else if (foundName2 &amp;&amp; !foundName1) {
564             return Pair.create(name2, name1);
565         }
566         throw GraalError.shouldNotReachHere();
567     }
568 
569     public static boolean isIntrinsicName(GraalHotSpotVMConfig config, String className, String name) {
570         for (VMIntrinsicMethod intrinsic : config.getStore().getIntrinsics()) {
571             if (className.equals(intrinsic.declaringClass)) {
572                 if (name.equals(intrinsic.name)) {
573                     return true;
574                 }
575             }
576         }
577         return false;
578     }
579 
580     private static void registerAESPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
581         if (config.useAESIntrinsics) {
582             assert config.aescryptEncryptBlockStub != 0L;
583             assert config.aescryptDecryptBlockStub != 0L;
584             assert config.cipherBlockChainingEncryptAESCryptStub != 0L;
585             assert config.cipherBlockChainingDecryptAESCryptStub != 0L;
586             String arch = config.osArch;
587             String decryptSuffix = arch.equals(&quot;sparc&quot;) ? &quot;WithOriginalKey&quot; : &quot;&quot;;
588 
589             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CipherBlockChaining&quot;, replacements);
590 
591             Pair&lt;String, String&gt; cbcEncryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implEncrypt&quot;, &quot;encrypt&quot;);
592             registerAndCheckMismatch(r, CipherBlockChainingSubstitutions.class, cbcEncryptName, Receiver.class, byte[].class, int.class, int.class,
593                             byte[].class, int.class);
594 
595             Pair&lt;String, String&gt; cbcDecryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implDecrypt&quot;, &quot;decrypt&quot;);
596             registerAndCheckMismatch(r, CipherBlockChainingSubstitutions.class, cbcDecryptName, cbcDecryptName.getLeft() + decryptSuffix, Receiver.class, byte[].class, int.class, int.class,
597                             byte[].class, int.class);
598 
599             r = new Registration(plugins, &quot;com.sun.crypto.provider.AESCrypt&quot;, replacements);
600 
601             Pair&lt;String, String&gt; aesEncryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implEncryptBlock&quot;, &quot;encryptBlock&quot;);
602             registerAndCheckMismatch(r, AESCryptSubstitutions.class, aesEncryptName, Receiver.class, byte[].class, int.class, byte[].class, int.class);
603 
604             Pair&lt;String, String&gt; aesDecryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implDecryptBlock&quot;, &quot;decryptBlock&quot;);
605             registerAndCheckMismatch(r, AESCryptSubstitutions.class, aesDecryptName, aesDecryptName.getLeft() + decryptSuffix, Receiver.class, byte[].class, int.class, byte[].class, int.class);
606         }
607     }
608 
609     private static void registerAndCheckMismatch(Registration r, Class&lt;?&gt; substitutionClass, Pair&lt;String, String&gt; intrinsicNames, Type... argumentTypes) {
610         try {
611             r.registerMethodSubstitution(substitutionClass, intrinsicNames.getLeft(), argumentTypes);
612         } catch (NoSuchMethodError e) {
613             throw new GraalError(e, &quot;Found method named &#39;%s&#39; instead of &#39;%s&#39; in class &#39;%s&#39;. This is most likely because the JVMCI JDK in %s was built on an incompatible base JDK.&quot;,
614                             intrinsicNames.getRight(), intrinsicNames.getLeft(), r.getDeclaringType().getTypeName(), Services.getSavedProperties().get(&quot;java.home&quot;));
615         }
616     }
617 
618     private static void registerAndCheckMismatch(Registration r, Class&lt;?&gt; substitutionClass, Pair&lt;String, String&gt; intrinsicNames, String substituteName, Type... argumentTypes) {
619         try {
620             r.registerMethodSubstitution(substitutionClass, intrinsicNames.getLeft(), substituteName, argumentTypes);
621         } catch (NoSuchMethodError e) {
622             throw new GraalError(e, &quot;Found method named &#39;%s&#39; instead of &#39;%s&#39; in class &#39;%s&#39;. This is most likely because the JVMCI JDK in %s was built on an incompatible base JDK.&quot;,
623                             intrinsicNames.getRight(), intrinsicNames.getLeft(), r.getDeclaringType().getTypeName(), Services.getSavedProperties().get(&quot;java.home&quot;));
624         }
625     }
626 
627     private static void registerBigIntegerPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
628         Registration r = new Registration(plugins, BigInteger.class, replacements);
629         assert !config.useMultiplyToLenIntrinsic() || config.multiplyToLen != 0L;
630         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
631             r.registerConditionalMethodSubstitution(config.useMultiplyToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;multiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class,
632                             int.class, int[].class);
633         } else {
634             r.registerConditionalMethodSubstitution(config.useMultiplyToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;implMultiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class,
635                             int.class, int[].class);
636         }
637         r.registerConditionalMethodSubstitution(config.useMulAddIntrinsic(), BigIntegerSubstitutions.class, &quot;implMulAdd&quot;, int[].class, int[].class, int.class, int.class, int.class);
638         r.registerConditionalMethodSubstitution(config.useMontgomeryMultiplyIntrinsic(), BigIntegerSubstitutions.class, &quot;implMontgomeryMultiply&quot;, int[].class, int[].class, int[].class, int.class,
639                         long.class, int[].class);
640         r.registerConditionalMethodSubstitution(config.useMontgomerySquareIntrinsic(), BigIntegerSubstitutions.class, &quot;implMontgomerySquare&quot;, int[].class, int[].class, int.class, long.class,
641                         int[].class);
642         r.registerConditionalMethodSubstitution(config.useSquareToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;implSquareToLen&quot;, int[].class, int.class, int[].class, int.class);
643     }
644 
645     private static void registerSHAPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
646         boolean useSha1 = config.useSHA1Intrinsics();
647         boolean useSha256 = config.useSHA256Intrinsics();
648         boolean useSha512 = config.useSHA512Intrinsics();
649 
650         if (isIntrinsicName(config, &quot;sun/security/provider/DigestBase&quot;, &quot;implCompressMultiBlock0&quot;) &amp;&amp; (useSha1 || useSha256 || useSha512)) {
651             Registration r = new Registration(plugins, &quot;sun.security.provider.DigestBase&quot;, replacements);
652             r.registerMethodSubstitution(DigestBaseSubstitutions.class, &quot;implCompressMultiBlock0&quot;, Receiver.class, byte[].class, int.class, int.class);
653         }
654 
655         Pair&lt;String, String&gt; implCompressName = selectIntrinsicName(config, &quot;sun/security/provider/SHA&quot;, &quot;implCompress&quot;, &quot;implCompress0&quot;);
656         if (useSha1) {
657             assert config.sha1ImplCompress != 0L;
658             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA&quot;, replacements);
659             registerAndCheckMismatch(r, SHASubstitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);
660         }
661         if (useSha256) {
662             assert config.sha256ImplCompress != 0L;
663             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA2&quot;, replacements);
664             registerAndCheckMismatch(r, SHA2Substitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);
665         }
666         if (useSha512) {
667             assert config.sha512ImplCompress != 0L;
668             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA5&quot;, replacements);
669             registerAndCheckMismatch(r, SHA5Substitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);
670         }
671     }
672 
673     private static void registerGHASHPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess) {
674         if (config.useGHASHIntrinsics()) {
675             assert config.ghashProcessBlocks != 0L;
676             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.GHASH&quot;);
677             r.register5(&quot;processBlocks&quot;,
678                             byte[].class,
679                             int.class,
680                             int.class,
681                             long[].class,
682                             long[].class,
683                             new InvocationPlugin() {
684                                 @Override
685                                 public boolean apply(GraphBuilderContext b,
686                                                 ResolvedJavaMethod targetMethod,
687                                                 Receiver receiver,
688                                                 ValueNode data,
689                                                 ValueNode inOffset,
690                                                 ValueNode blocks,
691                                                 ValueNode state,
692                                                 ValueNode hashSubkey) {
693                                     int longArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Long);
694                                     int byteArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Byte);
695                                     ValueNode dataOffset = AddNode.create(ConstantNode.forInt(byteArrayBaseOffset), inOffset, NodeView.DEFAULT);
696                                     ComputeObjectAddressNode dataAddress = b.add(new ComputeObjectAddressNode(data, dataOffset));
697                                     ComputeObjectAddressNode stateAddress = b.add(new ComputeObjectAddressNode(state, ConstantNode.forInt(longArrayBaseOffset)));
698                                     ComputeObjectAddressNode hashSubkeyAddress = b.add(new ComputeObjectAddressNode(hashSubkey, ConstantNode.forInt(longArrayBaseOffset)));
699                                     b.add(new ForeignCallNode(GHASH_PROCESS_BLOCKS, stateAddress, hashSubkeyAddress, dataAddress, blocks));
700                                     return true;
701                                 }
702                             });
703         }
704     }
705 
706     private static void registerCounterModePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
707         if (isIntrinsicName(config, &quot;com/sun/crypto/provider/CounterMode&quot;, &quot;implCrypt&quot;)) {
708             assert !config.useAESCTRIntrinsics || config.counterModeAESCrypt != 0L;
709             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CounterMode&quot;, replacements);
710             r.registerConditionalMethodSubstitution(config.useAESCTRIntrinsics, CounterModeSubstitutions.class, &quot;implCrypt&quot;, Receiver.class, byte[].class, int.class, int.class, byte[].class,
711                             int.class);
712         }
713     }
714 
715     private static void registerBase64Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess) {
716         if (config.useBase64Intrinsics()) {
717             Registration r = new Registration(plugins, &quot;java.util.Base64$Encoder&quot;);
718             r.register7(&quot;encodeBlock&quot;,
719                             Receiver.class,
720                             byte[].class,
721                             int.class,
722                             int.class,
723                             byte[].class,
724                             int.class,
725                             boolean.class,
726                             new InvocationPlugin() {
727                                 @Override
728                                 public boolean apply(GraphBuilderContext b,
729                                                 ResolvedJavaMethod targetMethod,
730                                                 Receiver receiver,
731                                                 ValueNode src,
732                                                 ValueNode sp,
733                                                 ValueNode sl,
734                                                 ValueNode dst,
735                                                 ValueNode dp,
736                                                 ValueNode isURL) {
737                                     int byteArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Byte);
738                                     ComputeObjectAddressNode srcAddress = b.add(new ComputeObjectAddressNode(src, ConstantNode.forInt(byteArrayBaseOffset)));
739                                     ComputeObjectAddressNode dstAddress = b.add(new ComputeObjectAddressNode(dst, ConstantNode.forInt(byteArrayBaseOffset)));
740                                     b.add(new ForeignCallNode(BASE64_ENCODE_BLOCK, srcAddress, sp, sl, dstAddress, dp, isURL));
741                                     return true;
742                                 }
743                             });
744         }
745     }
746 
747     private static void registerCRC32Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
748         Registration r = new Registration(plugins, CRC32.class, replacements);
749         r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;update&quot;, int.class, int.class);
750         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
751             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);
752             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateByteBuffer&quot;, int.class, long.class, int.class, int.class);
753         } else {
754             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateBytes0&quot;, int.class, byte[].class, int.class, int.class);
755             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateByteBuffer0&quot;, int.class, long.class, int.class, int.class);
756         }
757     }
758 
759     private static void registerCRC32CPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
760         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
761             Registration r = new Registration(plugins, &quot;java.util.zip.CRC32C&quot;, replacements);
762             r.registerConditionalMethodSubstitution(config.useCRC32CIntrinsics, CRC32CSubstitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);
763             r.registerConditionalMethodSubstitution(config.useCRC32CIntrinsics, CRC32CSubstitutions.class, &quot;updateDirectByteBuffer&quot;, int.class, long.class, int.class, int.class);
764         }
765     }
766 
767     private static void registerArraysSupportPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
768         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
769             Registration r = new Registration(plugins, &quot;jdk.internal.util.ArraysSupport&quot;, replacements);
770             r.registerConditionalMethodSubstitution(config.useVectorizedMismatchIntrinsic, ArraysSupportSubstitutions.class, &quot;vectorizedMismatch&quot;, Object.class, long.class, Object.class, long.class,
771                             int.class, int.class);
772         }
773     }
774 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/Linker.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../java.rmi/share/classes/sun/rmi/server/resources/rmid_zh_CN.properties.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/Linker.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 81                 objectFileName = objectFileName + &quot;.o&quot;;
 82                 linkerPath = (options.linkerpath != null) ? options.linkerpath : &quot;ld&quot;;
 83                 linkerCmd = linkerPath + &quot; -shared -z noexecstack -o &quot; + libraryFileName + &quot; &quot; + objectFileName;
 84                 linkerCheck = linkerPath + &quot; -v&quot;;
 85                 break;
 86             case &quot;Mac OS X&quot;:
 87                 if (name.endsWith(&quot;.dylib&quot;)) {
 88                     objectFileName = name.substring(0, name.length() - &quot;.dylib&quot;.length());
 89                 }
 90                 objectFileName = objectFileName + &quot;.o&quot;;
 91                 linkerPath = (options.linkerpath != null) ? options.linkerpath : &quot;ld&quot;;
 92                 linkerCmd = linkerPath + &quot; -dylib -o &quot; + libraryFileName + &quot; &quot; + objectFileName;
 93                 linkerCheck = linkerPath + &quot; -v&quot;;
 94                 break;
 95             default:
 96                 if (options.osName.startsWith(&quot;Windows&quot;)) {
 97                     if (name.endsWith(&quot;.dll&quot;)) {
 98                         objectFileName = name.substring(0, name.length() - &quot;.dll&quot;.length());
 99                     }
100                     objectFileName = objectFileName + &quot;.obj&quot;;
<span class="line-modified">101                     linkerPath = (options.linkerpath != null) ? options.linkerpath : getWindowsLinkPath();</span>
102                     if (linkerPath == null) {
103                         throw new InternalError(&quot;Can&#39;t locate Microsoft Visual Studio amd64 link.exe&quot;);
104                     }
105                     linkerCmd = linkerPath + &quot; /DLL /OPT:NOREF /NOLOGO /NOENTRY&quot; + &quot; /OUT:&quot; + libraryFileName + &quot; &quot; + objectFileName;
106                     linkerCheck = null; // link.exe presence is verified already
107                     break;
108                 } else {
109                     throw new InternalError(&quot;Unsupported platform: &quot; + options.osName);
110                 }
111         }
112 
113         // Check linker presence on platforms by printing its version
114         if (linkerCheck != null) {
115             Process p = Runtime.getRuntime().exec(linkerCheck);
116             final int exitCode = p.waitFor();
117             if (exitCode != 0) {
118                 throw new InternalError(getString(p.getErrorStream()));
119             }
120         }


121     }
122 
123     void link() throws Exception {
124         Process p = Runtime.getRuntime().exec(linkerCmd);
125         final int exitCode = p.waitFor();
126         if (exitCode != 0) {
127             String errorMessage = getString(p.getErrorStream());
128             if (errorMessage.isEmpty()) {
129                 errorMessage = getString(p.getInputStream());
130             }
131             throw new InternalError(errorMessage);
132         }
133         File objFile = new File(objectFileName);
134         boolean keepObjFile = Boolean.parseBoolean(System.getProperty(&quot;aot.keep.objFile&quot;, &quot;false&quot;));
135         if (objFile.exists() &amp;&amp; !keepObjFile) {
136             if (!objFile.delete()) {
137                 throw new InternalError(&quot;Failed to delete &quot; + objectFileName + &quot; file&quot;);
138             }
139         }
140         // Make non-executable for all.
141         File libFile = new File(libraryFileName);
142         if (libFile.exists() &amp;&amp; !options.osName.startsWith(&quot;Windows&quot;)) {
143             if (!libFile.setExecutable(false, false)) {
144                 throw new InternalError(&quot;Failed to change attribute for &quot; + libraryFileName + &quot; file&quot;);
145             }
146         }
147 
148     }
149 
150     /**
151      * Search for Visual Studio link.exe Search Order is: VS2017+, VS2013, VS2015, VS2012.
152      */
<span class="line-modified">153     private static String getWindowsLinkPath() throws Exception {</span>
154         try {
155             Path vc141NewerLinker = getVC141AndNewerLinker();
156             if (vc141NewerLinker != null) {
157                 return vc141NewerLinker.toString();
158             }
159         } catch (Exception e) {
<span class="line-modified">160             e.printStackTrace();</span>



161         }
162 
163         String link = &quot;\\VC\\bin\\amd64\\link.exe&quot;;
164 
165         /**
166          * First try searching the paths pointed to by the VS environment variables.
167          */
168         for (VSVERSIONS vs : VSVERSIONS.values()) {
169             String vspath = System.getenv(vs.getEnvVariable());
170             if (vspath != null) {
171                 File commonTools = new File(vspath);
172                 File vsRoot = commonTools.getParentFile().getParentFile();
173                 File linkPath = new File(vsRoot, link);
174                 if (linkPath.exists()) {
175                     return linkPath.getPath();
176                 }
177             }
178         }
179 
180         /**
181          * If we didn&#39;t find via the VS environment variables, try the well known paths
182          */
183         for (VSVERSIONS vs : VSVERSIONS.values()) {
184             String wkp = vs.getWellKnownPath();
185             if (new File(wkp).exists()) {
186                 return wkp;
187             }
188         }
189 
190         return null;
191     }
192 
193     private static Path getVC141AndNewerLinker() throws Exception {
194         String programFilesX86 = System.getenv(&quot;ProgramFiles(x86)&quot;);
195         if (programFilesX86 == null) {
<span class="line-modified">196             throw new InternalError(&quot;Could not read the ProgramFiles(x86) environment variable&quot;);</span>
197         }
<span class="line-modified">198         Path vswhere = Paths.get(programFilesX86 + &quot;\\Microsoft Visual Studio\\Installer\\vswhere.exe&quot;);</span>

199         if (!Files.exists(vswhere)) {
<span class="line-modified">200             return null;</span>
201         }
202 
203         ProcessBuilder processBuilder = new ProcessBuilder(vswhere.toString(), &quot;-requires&quot;,
204                         &quot;Microsoft.VisualStudio.Component.VC.Tools.x86.x64&quot;, &quot;-property&quot;, &quot;installationPath&quot;, &quot;-latest&quot;);
205         processBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE);
206         processBuilder.redirectError(ProcessBuilder.Redirect.PIPE);
207         Process process = processBuilder.start();
208         final int exitCode = process.waitFor();
209         if (exitCode != 0) {
210             String errorMessage = getString(process.getErrorStream());
211             if (errorMessage.isEmpty()) {
212                 errorMessage = getString(process.getInputStream());
213             }
<span class="line-modified">214             throw new InternalError(errorMessage);</span>
215         }
216 
<span class="line-modified">217         String installationPath = getLines(process.getInputStream()).findFirst().orElseThrow(() -&gt; new InternalError(&quot;Unexpected empty output from vswhere&quot;));</span>
218         Path vcToolsVersionFilePath = Paths.get(installationPath, &quot;VC\\Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt&quot;);
219         List&lt;String&gt; vcToolsVersionFileLines = Files.readAllLines(vcToolsVersionFilePath);
220         if (vcToolsVersionFileLines.isEmpty()) {
<span class="line-modified">221             throw new InternalError(vcToolsVersionFilePath.toString() + &quot; is empty&quot;);</span>
222         }
223         String vcToolsVersion = vcToolsVersionFileLines.get(0);
224         Path linkPath = Paths.get(installationPath, &quot;VC\\Tools\\MSVC&quot;, vcToolsVersion, &quot;bin\\Hostx64\\x64\\link.exe&quot;);
225         if (!Files.exists(linkPath)) {
<span class="line-modified">226             throw new InternalError(&quot;Linker at path &quot; + linkPath.toString() + &quot; does not exist&quot;);</span>
227         }
228 
229         return linkPath;
230     }
231 
232     // @formatter:off (workaround for Eclipse formatting bug)
233     enum VSVERSIONS {
234         VS2013(&quot;VS120COMNTOOLS&quot;, &quot;C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\bin\\amd64\\link.exe&quot;),
235         VS2015(&quot;VS140COMNTOOLS&quot;, &quot;C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\link.exe&quot;),
236         VS2012(&quot;VS110COMNTOOLS&quot;, &quot;C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\bin\\amd64\\link.exe&quot;);
237 
238         private final String envvariable;
239         private final String wkp;
240 
241         VSVERSIONS(String envvariable, String wellknownpath) {
242             this.envvariable = envvariable;
243             this.wkp = wellknownpath;
244         }
245 
246         String getEnvVariable() {
</pre>
</td>
<td>
<hr />
<pre>
 81                 objectFileName = objectFileName + &quot;.o&quot;;
 82                 linkerPath = (options.linkerpath != null) ? options.linkerpath : &quot;ld&quot;;
 83                 linkerCmd = linkerPath + &quot; -shared -z noexecstack -o &quot; + libraryFileName + &quot; &quot; + objectFileName;
 84                 linkerCheck = linkerPath + &quot; -v&quot;;
 85                 break;
 86             case &quot;Mac OS X&quot;:
 87                 if (name.endsWith(&quot;.dylib&quot;)) {
 88                     objectFileName = name.substring(0, name.length() - &quot;.dylib&quot;.length());
 89                 }
 90                 objectFileName = objectFileName + &quot;.o&quot;;
 91                 linkerPath = (options.linkerpath != null) ? options.linkerpath : &quot;ld&quot;;
 92                 linkerCmd = linkerPath + &quot; -dylib -o &quot; + libraryFileName + &quot; &quot; + objectFileName;
 93                 linkerCheck = linkerPath + &quot; -v&quot;;
 94                 break;
 95             default:
 96                 if (options.osName.startsWith(&quot;Windows&quot;)) {
 97                     if (name.endsWith(&quot;.dll&quot;)) {
 98                         objectFileName = name.substring(0, name.length() - &quot;.dll&quot;.length());
 99                     }
100                     objectFileName = objectFileName + &quot;.obj&quot;;
<span class="line-modified">101                     linkerPath = (options.linkerpath != null) ? options.linkerpath : getWindowsLinkPath(main);</span>
102                     if (linkerPath == null) {
103                         throw new InternalError(&quot;Can&#39;t locate Microsoft Visual Studio amd64 link.exe&quot;);
104                     }
105                     linkerCmd = linkerPath + &quot; /DLL /OPT:NOREF /NOLOGO /NOENTRY&quot; + &quot; /OUT:&quot; + libraryFileName + &quot; &quot; + objectFileName;
106                     linkerCheck = null; // link.exe presence is verified already
107                     break;
108                 } else {
109                     throw new InternalError(&quot;Unsupported platform: &quot; + options.osName);
110                 }
111         }
112 
113         // Check linker presence on platforms by printing its version
114         if (linkerCheck != null) {
115             Process p = Runtime.getRuntime().exec(linkerCheck);
116             final int exitCode = p.waitFor();
117             if (exitCode != 0) {
118                 throw new InternalError(getString(p.getErrorStream()));
119             }
120         }
<span class="line-added">121 </span>
<span class="line-added">122         main.printer.printlnVerbose(&quot;Found linker: &quot; + linkerPath);</span>
123     }
124 
125     void link() throws Exception {
126         Process p = Runtime.getRuntime().exec(linkerCmd);
127         final int exitCode = p.waitFor();
128         if (exitCode != 0) {
129             String errorMessage = getString(p.getErrorStream());
130             if (errorMessage.isEmpty()) {
131                 errorMessage = getString(p.getInputStream());
132             }
133             throw new InternalError(errorMessage);
134         }
135         File objFile = new File(objectFileName);
136         boolean keepObjFile = Boolean.parseBoolean(System.getProperty(&quot;aot.keep.objFile&quot;, &quot;false&quot;));
137         if (objFile.exists() &amp;&amp; !keepObjFile) {
138             if (!objFile.delete()) {
139                 throw new InternalError(&quot;Failed to delete &quot; + objectFileName + &quot; file&quot;);
140             }
141         }
142         // Make non-executable for all.
143         File libFile = new File(libraryFileName);
144         if (libFile.exists() &amp;&amp; !options.osName.startsWith(&quot;Windows&quot;)) {
145             if (!libFile.setExecutable(false, false)) {
146                 throw new InternalError(&quot;Failed to change attribute for &quot; + libraryFileName + &quot; file&quot;);
147             }
148         }
149 
150     }
151 
152     /**
153      * Search for Visual Studio link.exe Search Order is: VS2017+, VS2013, VS2015, VS2012.
154      */
<span class="line-modified">155     private static String getWindowsLinkPath(Main main) throws Exception {</span>
156         try {
157             Path vc141NewerLinker = getVC141AndNewerLinker();
158             if (vc141NewerLinker != null) {
159                 return vc141NewerLinker.toString();
160             }
161         } catch (Exception e) {
<span class="line-modified">162             main.printer.printlnVerbose(&quot;Could not find VC14 or newer version of linker: &quot; + e.getMessage());</span>
<span class="line-added">163             if (main.options.debug) {</span>
<span class="line-added">164                 e.printStackTrace();</span>
<span class="line-added">165             }</span>
166         }
167 
168         String link = &quot;\\VC\\bin\\amd64\\link.exe&quot;;
169 
170         /**
171          * First try searching the paths pointed to by the VS environment variables.
172          */
173         for (VSVERSIONS vs : VSVERSIONS.values()) {
174             String vspath = System.getenv(vs.getEnvVariable());
175             if (vspath != null) {
176                 File commonTools = new File(vspath);
177                 File vsRoot = commonTools.getParentFile().getParentFile();
178                 File linkPath = new File(vsRoot, link);
179                 if (linkPath.exists()) {
180                     return linkPath.getPath();
181                 }
182             }
183         }
184 
185         /**
186          * If we didn&#39;t find via the VS environment variables, try the well known paths
187          */
188         for (VSVERSIONS vs : VSVERSIONS.values()) {
189             String wkp = vs.getWellKnownPath();
190             if (new File(wkp).exists()) {
191                 return wkp;
192             }
193         }
194 
195         return null;
196     }
197 
198     private static Path getVC141AndNewerLinker() throws Exception {
199         String programFilesX86 = System.getenv(&quot;ProgramFiles(x86)&quot;);
200         if (programFilesX86 == null) {
<span class="line-modified">201             throw new IllegalStateException(&quot;Could not read the ProgramFiles(x86) environment variable&quot;);</span>
202         }
<span class="line-modified">203         String vswherePath = programFilesX86 + &quot;\\Microsoft Visual Studio\\Installer\\vswhere.exe&quot;;</span>
<span class="line-added">204         Path vswhere = Paths.get(vswherePath);</span>
205         if (!Files.exists(vswhere)) {
<span class="line-modified">206             throw new IllegalStateException(&quot;Could not find &quot; + vswherePath);</span>
207         }
208 
209         ProcessBuilder processBuilder = new ProcessBuilder(vswhere.toString(), &quot;-requires&quot;,
210                         &quot;Microsoft.VisualStudio.Component.VC.Tools.x86.x64&quot;, &quot;-property&quot;, &quot;installationPath&quot;, &quot;-latest&quot;);
211         processBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE);
212         processBuilder.redirectError(ProcessBuilder.Redirect.PIPE);
213         Process process = processBuilder.start();
214         final int exitCode = process.waitFor();
215         if (exitCode != 0) {
216             String errorMessage = getString(process.getErrorStream());
217             if (errorMessage.isEmpty()) {
218                 errorMessage = getString(process.getInputStream());
219             }
<span class="line-modified">220             throw new IllegalStateException(&quot;vswhere error: &quot; + errorMessage);</span>
221         }
222 
<span class="line-modified">223         String installationPath = getLines(process.getInputStream()).findFirst().orElseThrow(() -&gt; new IllegalStateException(&quot;Unexpected empty output from vswhere&quot;));</span>
224         Path vcToolsVersionFilePath = Paths.get(installationPath, &quot;VC\\Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt&quot;);
225         List&lt;String&gt; vcToolsVersionFileLines = Files.readAllLines(vcToolsVersionFilePath);
226         if (vcToolsVersionFileLines.isEmpty()) {
<span class="line-modified">227             throw new IllegalStateException(vcToolsVersionFilePath.toString() + &quot; is empty&quot;);</span>
228         }
229         String vcToolsVersion = vcToolsVersionFileLines.get(0);
230         Path linkPath = Paths.get(installationPath, &quot;VC\\Tools\\MSVC&quot;, vcToolsVersion, &quot;bin\\Hostx64\\x64\\link.exe&quot;);
231         if (!Files.exists(linkPath)) {
<span class="line-modified">232             throw new IllegalStateException(&quot;Linker at path &quot; + linkPath.toString() + &quot; does not exist&quot;);</span>
233         }
234 
235         return linkPath;
236     }
237 
238     // @formatter:off (workaround for Eclipse formatting bug)
239     enum VSVERSIONS {
240         VS2013(&quot;VS120COMNTOOLS&quot;, &quot;C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\bin\\amd64\\link.exe&quot;),
241         VS2015(&quot;VS140COMNTOOLS&quot;, &quot;C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\link.exe&quot;),
242         VS2012(&quot;VS110COMNTOOLS&quot;, &quot;C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\bin\\amd64\\link.exe&quot;);
243 
244         private final String envvariable;
245         private final String wkp;
246 
247         VSVERSIONS(String envvariable, String wellknownpath) {
248             this.envvariable = envvariable;
249             this.wkp = wellknownpath;
250         }
251 
252         String getEnvVariable() {
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../java.rmi/share/classes/sun/rmi/server/resources/rmid_zh_CN.properties.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/javax/swing/PopupFactory.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javax.swing;
  27 
<a name="2" id="anc2"></a>



  28 import java.applet.Applet;
<a name="3" id="anc3"></a><span class="line-modified">  29 import java.awt.BorderLayout;</span>
<span class="line-added">  30 import java.awt.Component;</span>
<span class="line-added">  31 import java.awt.Container;</span>
<span class="line-added">  32 import java.awt.GraphicsConfiguration;</span>
<span class="line-added">  33 import java.awt.GraphicsEnvironment;</span>
<span class="line-added">  34 import java.awt.Insets;</span>
<span class="line-added">  35 import java.awt.Panel;</span>
<span class="line-added">  36 import java.awt.Point;</span>
<span class="line-added">  37 import java.awt.Rectangle;</span>
<span class="line-added">  38 import java.awt.Toolkit;</span>
<span class="line-added">  39 import java.awt.Window;</span>
  40 import java.awt.event.WindowAdapter;
  41 import java.awt.event.WindowEvent;
  42 import java.security.AccessController;
  43 import java.util.ArrayList;
  44 import java.util.HashMap;
  45 import java.util.List;
  46 import java.util.Map;
<a name="4" id="anc4"></a><span class="line-added">  47 </span>
<span class="line-added">  48 import sun.awt.EmbeddedFrame;</span>
<span class="line-added">  49 import sun.awt.OSInfo;</span>
<span class="line-added">  50 import sun.swing.SwingAccessor;</span>
<span class="line-added">  51 </span>
  52 import static javax.swing.ClientPropertyKey.PopupFactory_FORCE_HEAVYWEIGHT_POPUP;
  53 
  54 /**
  55  * &lt;code&gt;PopupFactory&lt;/code&gt;, as the name implies, is used to obtain
  56  * instances of &lt;code&gt;Popup&lt;/code&gt;s. &lt;code&gt;Popup&lt;/code&gt;s are used to
  57  * display a &lt;code&gt;Component&lt;/code&gt; above all other &lt;code&gt;Component&lt;/code&gt;s
  58  * in a particular containment hierarchy. The general contract is that
  59  * once you have obtained a &lt;code&gt;Popup&lt;/code&gt; from a
  60  * &lt;code&gt;PopupFactory&lt;/code&gt;, you must invoke &lt;code&gt;hide&lt;/code&gt; on the
  61  * &lt;code&gt;Popup&lt;/code&gt;. The typical usage is:
  62  * &lt;pre&gt;
  63  *   PopupFactory factory = PopupFactory.getSharedInstance();
  64  *   Popup popup = factory.getPopup(owner, contents, x, y);
  65  *   popup.show();
  66  *   ...
  67  *   popup.hide();
  68  * &lt;/pre&gt;
  69  *
  70  * @see Popup
  71  *
  72  * @since 1.4
  73  */
  74 public class PopupFactory {
  75 
  76     static {
  77         SwingAccessor.setPopupFactoryAccessor(new SwingAccessor.PopupFactoryAccessor() {
  78             @Override
  79             public Popup getHeavyWeightPopup(PopupFactory factory, Component owner,
  80                                              Component contents, int ownerX, int ownerY) {
  81                 return factory.getPopup(owner, contents, ownerX, ownerY, HEAVY_WEIGHT_POPUP);
  82             }
  83         });
  84     }
  85     /**
  86      * The shared instanceof &lt;code&gt;PopupFactory&lt;/code&gt; is per
  87      * &lt;code&gt;AppContext&lt;/code&gt;. This is the key used in the
  88      * &lt;code&gt;AppContext&lt;/code&gt; to locate the &lt;code&gt;PopupFactory&lt;/code&gt;.
  89      */
  90     private static final Object SharedInstanceKey =
  91         new StringBuffer(&quot;PopupFactory.SharedInstanceKey&quot;);
  92 
  93     /**
  94      * Max number of items to store in any one particular cache.
  95      */
  96     private static final int MAX_CACHE_SIZE = 5;
  97 
  98     /**
  99      * Key used to indicate a light weight popup should be used.
 100      */
 101     static final int LIGHT_WEIGHT_POPUP   = 0;
 102 
 103     /**
 104      * Key used to indicate a medium weight Popup should be used.
 105      */
 106     static final int MEDIUM_WEIGHT_POPUP  = 1;
 107 
 108     /*
 109      * Key used to indicate a heavy weight Popup should be used.
 110      */
 111     static final int HEAVY_WEIGHT_POPUP   = 2;
 112 
 113     /**
 114      * Default type of Popup to create.
 115      */
 116     private int popupType = LIGHT_WEIGHT_POPUP;
 117 
 118 
 119     /**
 120      * Sets the &lt;code&gt;PopupFactory&lt;/code&gt; that will be used to obtain
 121      * &lt;code&gt;Popup&lt;/code&gt;s.
 122      * This will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; if
 123      * &lt;code&gt;factory&lt;/code&gt; is null.
 124      *
 125      * @param factory Shared PopupFactory
 126      * @exception IllegalArgumentException if &lt;code&gt;factory&lt;/code&gt; is null
 127      * @see #getPopup
 128      */
 129     public static void setSharedInstance(PopupFactory factory) {
 130         if (factory == null) {
 131             throw new IllegalArgumentException(&quot;PopupFactory can not be null&quot;);
 132         }
 133         SwingUtilities.appContextPut(SharedInstanceKey, factory);
 134     }
 135 
 136     /**
 137      * Returns the shared &lt;code&gt;PopupFactory&lt;/code&gt; which can be used
 138      * to obtain &lt;code&gt;Popup&lt;/code&gt;s.
 139      *
 140      * @return Shared PopupFactory
 141      */
 142     public static PopupFactory getSharedInstance() {
 143         PopupFactory factory = (PopupFactory)SwingUtilities.appContextGet(
 144                          SharedInstanceKey);
 145 
 146         if (factory == null) {
 147             factory = new PopupFactory();
 148             setSharedInstance(factory);
 149         }
 150         return factory;
 151     }
 152 
 153 
 154     /**
 155      * Provides a hint as to the type of &lt;code&gt;Popup&lt;/code&gt; that should
 156      * be created.
 157      */
 158     void setPopupType(int type) {
 159         popupType = type;
 160     }
 161 
 162     /**
 163      * Returns the preferred type of Popup to create.
 164      */
 165     int getPopupType() {
 166         return popupType;
 167     }
 168 
 169     /**
 170      * Creates a &lt;code&gt;Popup&lt;/code&gt; for the Component &lt;code&gt;owner&lt;/code&gt;
 171      * containing the Component &lt;code&gt;contents&lt;/code&gt;. &lt;code&gt;owner&lt;/code&gt;
 172      * is used to determine which &lt;code&gt;Window&lt;/code&gt; the new
 173      * &lt;code&gt;Popup&lt;/code&gt; will parent the &lt;code&gt;Component&lt;/code&gt; the
 174      * &lt;code&gt;Popup&lt;/code&gt; creates to. A null &lt;code&gt;owner&lt;/code&gt; implies there
 175      * is no valid parent. &lt;code&gt;x&lt;/code&gt; and
 176      * &lt;code&gt;y&lt;/code&gt; specify the preferred initial location to place
 177      * the &lt;code&gt;Popup&lt;/code&gt; at. Based on screen size, or other paramaters,
 178      * the &lt;code&gt;Popup&lt;/code&gt; may not display at &lt;code&gt;x&lt;/code&gt; and
 179      * &lt;code&gt;y&lt;/code&gt;.
 180      *
 181      * @param owner    Component mouse coordinates are relative to, may be null
 182      * @param contents Contents of the Popup
 183      * @param x        Initial x screen coordinate
 184      * @param y        Initial y screen coordinate
 185      * @exception IllegalArgumentException if contents is null
 186      * @return Popup containing Contents
 187      */
 188     public Popup getPopup(Component owner, Component contents,
 189             int x, int y) throws IllegalArgumentException {
 190         return getPopup(owner, contents, x, y, false);
 191     }
 192 
 193     /**
 194      * Creates a {@code Popup} for the Component {@code owner}
 195      * containing the Component {@code contents}.
 196      * The window containing the component {@code owner}
 197      * will be used as the parent window. A null {@code owner} implies there
 198      * is no valid parent. {@code x} and {@code y} specify the preferred
 199      * initial location to place the {@code Popup} at. Based on screen size,
 200      * or other parameters, the {@code Popup} may not display at {@code x} and
 201      * {@code y}. {@code isHeavyWeightPopup} specifies if the {@code Popup}
 202      * will be heavyweight. Passing {@code true} will force the {@code Popup}
 203      * type to be heavyweight, otherwise {@code Popup} type will be selected by
 204      * {@code Popup} factory. Lightweight {@code Popup} windows are more
 205      * efficient than heavyweight (native peer) windows, but lightweight
 206      * and heavyweight components do not mix well in a GUI.
 207      * This method is intended to be used only by PopupFactory sub-classes.
 208      * @param owner Component mouse coordinates are relative to, may be null
 209      * @param contents Contents of the Popup
 210      * @param x Initial x screen coordinate
 211      * @param y Initial y screen coordinate
 212      * @param isHeavyWeightPopup true if Popup should be heavy weight,
 213      * otherwise popup type will be selected by popup factory.
 214      * @throws IllegalArgumentException if contents is null
 215      * @return Popup containing Contents
 216      */
 217     protected Popup getPopup(Component owner, Component contents, int x, int y,
 218             boolean isHeavyWeightPopup) throws IllegalArgumentException {
 219         if (contents == null) {
 220             throw new IllegalArgumentException(
 221                     &quot;Popup.getPopup must be passed non-null contents&quot;);
 222         }
 223         if (isHeavyWeightPopup) {
 224             return getPopup(owner, contents, x, y, HEAVY_WEIGHT_POPUP);
 225         }
 226         int popupType = getPopupType(owner, contents, x, y);
 227         Popup popup = getPopup(owner, contents, x, y, popupType);
 228 
 229         if (popup == null) {
 230             // Didn&#39;t fit, force to heavy.
 231             popup = getPopup(owner, contents, x, y, HEAVY_WEIGHT_POPUP);
 232         }
 233         return popup;
 234     }
 235 
 236     /**
 237      * Returns the popup type to use for the specified parameters.
 238      */
 239     private int getPopupType(Component owner, Component contents,
 240                              int ownerX, int ownerY) {
 241         int popupType = getPopupType();
 242 
 243         if (owner == null || invokerInHeavyWeightPopup(owner)) {
 244             popupType = HEAVY_WEIGHT_POPUP;
 245         }
 246         else if (popupType == LIGHT_WEIGHT_POPUP &amp;&amp;
 247                  !(contents instanceof JToolTip) &amp;&amp;
 248                  !(contents instanceof JPopupMenu)) {
 249             popupType = MEDIUM_WEIGHT_POPUP;
 250         }
 251 
 252         // Check if the parent component is an option pane.  If so we need to
 253         // force a heavy weight popup in order to have event dispatching work
 254         // correctly.
 255         Component c = owner;
 256         while (c != null) {
 257             if (c instanceof JComponent) {
 258                 if (((JComponent)c).getClientProperty(
 259                             PopupFactory_FORCE_HEAVYWEIGHT_POPUP) == Boolean.TRUE) {
 260                     popupType = HEAVY_WEIGHT_POPUP;
 261                     break;
 262                 }
 263             }
 264             c = c.getParent();
 265         }
 266 
 267         return popupType;
 268     }
 269 
 270     /**
 271      * Obtains the appropriate &lt;code&gt;Popup&lt;/code&gt; based on
 272      * &lt;code&gt;popupType&lt;/code&gt;.
 273      */
 274     @SuppressWarnings(&quot;deprecation&quot;)
 275     private Popup getPopup(Component owner, Component contents,
 276                            int ownerX, int ownerY, int popupType) {
 277         if (GraphicsEnvironment.isHeadless()) {
 278             return getHeadlessPopup(owner, contents, ownerX, ownerY);
 279         }
 280 
 281         switch(popupType) {
 282         case LIGHT_WEIGHT_POPUP:
 283             return getLightWeightPopup(owner, contents, ownerX, ownerY);
 284         case MEDIUM_WEIGHT_POPUP:
 285             return getMediumWeightPopup(owner, contents, ownerX, ownerY);
 286         case HEAVY_WEIGHT_POPUP:
 287             Popup popup = getHeavyWeightPopup(owner, contents, ownerX, ownerY);
 288             if ((AccessController.doPrivileged(OSInfo.getOSTypeAction()) ==
 289                 OSInfo.OSType.MACOSX) &amp;&amp; (owner != null) &amp;&amp;
 290                 (EmbeddedFrame.getAppletIfAncestorOf(owner) != null)) {
 291                 ((HeavyWeightPopup)popup).setCacheEnabled(false);
 292             }
 293             return popup;
 294         }
 295         return null;
 296     }
 297 
 298     /**
 299      * Creates a headless popup
 300      */
 301     private Popup getHeadlessPopup(Component owner, Component contents,
 302                                    int ownerX, int ownerY) {
 303         return HeadlessPopup.getHeadlessPopup(owner, contents, ownerX, ownerY);
 304     }
 305 
 306     /**
 307      * Creates a light weight popup.
 308      */
 309     private Popup getLightWeightPopup(Component owner, Component contents,
 310                                          int ownerX, int ownerY) {
 311         return LightWeightPopup.getLightWeightPopup(owner, contents, ownerX,
 312                                                     ownerY);
 313     }
 314 
 315     /**
 316      * Creates a medium weight popup.
 317      */
 318     private Popup getMediumWeightPopup(Component owner, Component contents,
 319                                           int ownerX, int ownerY) {
 320         return MediumWeightPopup.getMediumWeightPopup(owner, contents,
 321                                                       ownerX, ownerY);
 322     }
 323 
 324     /**
 325      * Creates a heavy weight popup.
 326      */
 327     private Popup getHeavyWeightPopup(Component owner, Component contents,
 328                                          int ownerX, int ownerY) {
 329         if (GraphicsEnvironment.isHeadless()) {
 330             return getMediumWeightPopup(owner, contents, ownerX, ownerY);
 331         }
 332         return HeavyWeightPopup.getHeavyWeightPopup(owner, contents, ownerX,
 333                                                     ownerY);
 334     }
 335 
 336     /**
 337      * Returns true if the Component &lt;code&gt;i&lt;/code&gt; inside a heavy weight
 338      * &lt;code&gt;Popup&lt;/code&gt;.
 339      */
 340     private boolean invokerInHeavyWeightPopup(Component i) {
 341         if (i != null) {
 342             Container parent;
 343             for(parent = i.getParent() ; parent != null ; parent =
 344                     parent.getParent()) {
 345                 if (parent instanceof Popup.HeavyWeightWindow) {
 346                     return true;
 347                 }
 348             }
 349         }
 350         return false;
 351     }
 352 
 353 
 354     /**
 355      * Popup implementation that uses a Window as the popup.
 356      */
 357     private static class HeavyWeightPopup extends Popup {
 358         private static final Object heavyWeightPopupCacheKey =
 359                  new StringBuffer(&quot;PopupFactory.heavyWeightPopupCache&quot;);
 360 
 361         private volatile boolean isCacheEnabled = true;
 362 
 363         /**
 364          * Returns either a new or recycled &lt;code&gt;Popup&lt;/code&gt; containing
 365          * the specified children.
 366          */
 367         static Popup getHeavyWeightPopup(Component owner, Component contents,
 368                                          int ownerX, int ownerY) {
 369             Window window = (owner != null) ? SwingUtilities.
 370                               getWindowAncestor(owner) : null;
 371             HeavyWeightPopup popup = null;
 372 
 373             if (window != null) {
 374                 popup = getRecycledHeavyWeightPopup(window);
 375             }
 376 
 377             boolean focusPopup = false;
 378             if(contents != null &amp;&amp; contents.isFocusable()) {
 379                 if(contents instanceof JPopupMenu) {
 380                     JPopupMenu jpm = (JPopupMenu) contents;
 381                     Component[] popComps = jpm.getComponents();
 382                     for (Component popComp : popComps) {
 383                         if (!(popComp instanceof MenuElement) &amp;&amp;
 384                                 !(popComp instanceof JSeparator)) {
 385                             focusPopup = true;
 386                             break;
 387                         }
 388                     }
 389                 }
 390             }
 391 
 392             if (popup == null ||
 393                 ((JWindow) popup.getComponent())
 394                  .getFocusableWindowState() != focusPopup) {
 395 
 396                 if(popup != null) {
 397                     // The recycled popup can&#39;t serve us well
 398                     // dispose it and create new one
 399                     popup._dispose();
 400                 }
 401 
 402                 popup = new HeavyWeightPopup();
 403             }
 404 
 405             popup.reset(owner, contents, ownerX, ownerY);
 406 
 407             if(focusPopup) {
 408                 JWindow wnd = (JWindow) popup.getComponent();
 409                 wnd.setFocusableWindowState(true);
 410                 // Set window name. We need this in BasicPopupMenuUI
 411                 // to identify focusable popup window.
 412                 wnd.setName(&quot;###focusableSwingPopup###&quot;);
 413             }
 414 
 415             return popup;
 416         }
 417 
 418         /**
 419          * Returns a previously disposed heavy weight &lt;code&gt;Popup&lt;/code&gt;
 420          * associated with &lt;code&gt;window&lt;/code&gt;. This will return null if
 421          * there is no &lt;code&gt;HeavyWeightPopup&lt;/code&gt; associated with
 422          * &lt;code&gt;window&lt;/code&gt;.
 423          */
 424         private static HeavyWeightPopup getRecycledHeavyWeightPopup(Window w) {
 425             synchronized (HeavyWeightPopup.class) {
 426                 List&lt;HeavyWeightPopup&gt; cache;
 427                 Map&lt;Window, List&lt;HeavyWeightPopup&gt;&gt; heavyPopupCache = getHeavyWeightPopupCache();
 428 
 429                 if (heavyPopupCache.containsKey(w)) {
 430                     cache = heavyPopupCache.get(w);
 431                 } else {
 432                     return null;
 433                 }
 434                 if (cache.size() &gt; 0) {
 435                     HeavyWeightPopup r = cache.get(0);
 436                     cache.remove(0);
 437                     return r;
 438                 }
 439                 return null;
 440             }
 441         }
 442 
 443         /**
 444          * Returns the cache to use for heavy weight popups. Maps from
 445          * &lt;code&gt;Window&lt;/code&gt; to a &lt;code&gt;List&lt;/code&gt; of
 446          * &lt;code&gt;HeavyWeightPopup&lt;/code&gt;s.
 447          */
 448         @SuppressWarnings(&quot;unchecked&quot;)
 449         private static Map&lt;Window, List&lt;HeavyWeightPopup&gt;&gt; getHeavyWeightPopupCache() {
 450             synchronized (HeavyWeightPopup.class) {
 451                 Map&lt;Window, List&lt;HeavyWeightPopup&gt;&gt; cache = (Map&lt;Window, List&lt;HeavyWeightPopup&gt;&gt;)SwingUtilities.appContextGet(
 452                                   heavyWeightPopupCacheKey);
 453 
 454                 if (cache == null) {
 455                     cache = new HashMap&lt;&gt;(2);
 456                     SwingUtilities.appContextPut(heavyWeightPopupCacheKey,
 457                                                  cache);
 458                 }
 459                 return cache;
 460             }
 461         }
 462 
 463         /**
 464          * Recycles the passed in &lt;code&gt;HeavyWeightPopup&lt;/code&gt;.
 465          */
 466         private static void recycleHeavyWeightPopup(HeavyWeightPopup popup) {
 467             synchronized (HeavyWeightPopup.class) {
 468                 List&lt;HeavyWeightPopup&gt; cache;
 469                 Window window = SwingUtilities.getWindowAncestor(
 470                                      popup.getComponent());
 471                 Map&lt;Window, List&lt;HeavyWeightPopup&gt;&gt; heavyPopupCache = getHeavyWeightPopupCache();
 472 
 473                 if (window instanceof Popup.DefaultFrame ||
 474                                       !window.isVisible()) {
 475                     // If the Window isn&#39;t visible, we don&#39;t cache it as we
 476                     // likely won&#39;t ever get a windowClosed event to clean up.
 477                     // We also don&#39;t cache DefaultFrames as this indicates
 478                     // there wasn&#39;t a valid Window parent, and thus we don&#39;t
 479                     // know when to clean up.
 480                     popup._dispose();
 481                     return;
 482                 } else if (heavyPopupCache.containsKey(window)) {
 483                     cache = heavyPopupCache.get(window);
 484                 } else {
 485                     cache = new ArrayList&lt;HeavyWeightPopup&gt;();
 486                     heavyPopupCache.put(window, cache);
 487                     // Clean up if the Window is closed
 488                     final Window w = window;
 489 
 490                     w.addWindowListener(new WindowAdapter() {
 491                         public void windowClosed(WindowEvent e) {
 492                             List&lt;HeavyWeightPopup&gt; popups;
 493 
 494                             synchronized(HeavyWeightPopup.class) {
 495                                 Map&lt;Window, List&lt;HeavyWeightPopup&gt;&gt; heavyPopupCache2 =
 496                                               getHeavyWeightPopupCache();
 497 
 498                                 popups = heavyPopupCache2.remove(w);
 499                             }
 500                             if (popups != null) {
 501                                 for (int counter = popups.size() - 1;
 502                                                    counter &gt;= 0; counter--) {
 503                                     popups.get(counter)._dispose();
 504                                 }
 505                             }
 506                         }
 507                     });
 508                 }
 509 
 510                 if(cache.size() &lt; MAX_CACHE_SIZE) {
 511                     cache.add(popup);
 512                 } else {
 513                     popup._dispose();
 514                 }
 515             }
 516         }
 517 
 518         /**
 519          * Enables or disables cache for current object.
 520          */
 521         void setCacheEnabled(boolean enable) {
 522             isCacheEnabled = enable;
 523         }
 524 
 525         //
 526         // Popup methods
 527         //
 528         public void hide() {
 529             super.hide();
 530             if (isCacheEnabled) {
 531                 recycleHeavyWeightPopup(this);
 532             } else {
 533                 this._dispose();
 534             }
 535         }
 536 
 537         /**
 538          * As we recycle the &lt;code&gt;Window&lt;/code&gt;, we don&#39;t want to dispose it,
 539          * thus this method does nothing, instead use &lt;code&gt;_dipose&lt;/code&gt;
 540          * which will handle the disposing.
 541          */
 542         void dispose() {
 543         }
 544 
 545         void _dispose() {
 546             super.dispose();
 547         }
 548     }
 549 
 550 
 551 
 552     /**
 553      * ContainerPopup consolidates the common code used in the light/medium
 554      * weight implementations of &lt;code&gt;Popup&lt;/code&gt;.
 555      */
 556     private static class ContainerPopup extends Popup {
 557         /** Component we are to be added to. */
 558         Component owner;
 559         /** Desired x location. */
 560         int x;
 561         /** Desired y location. */
 562         int y;
 563 
 564         public void hide() {
 565             Component component = getComponent();
 566 
 567             if (component != null) {
 568                 Container parent = component.getParent();
 569 
 570                 if (parent != null) {
 571                     Rectangle bounds = component.getBounds();
 572 
 573                     parent.remove(component);
 574                     parent.repaint(bounds.x, bounds.y, bounds.width,
 575                                    bounds.height);
 576                 }
 577             }
 578             owner = null;
 579         }
 580         public void pack() {
 581             Component component = getComponent();
 582 
 583             if (component != null) {
 584                 component.setSize(component.getPreferredSize());
 585             }
 586         }
 587 
 588         void reset(Component owner, Component contents, int ownerX,
 589                    int ownerY) {
 590             if ((owner instanceof JFrame) || (owner instanceof JDialog) ||
 591                                                  (owner instanceof JWindow)) {
 592                 // Force the content to be added to the layered pane, otherwise
 593                 // we&#39;ll get an exception when adding to the RootPaneContainer.
 594                 owner = ((RootPaneContainer)owner).getLayeredPane();
 595             }
 596             super.reset(owner, contents, ownerX, ownerY);
 597 
 598             x = ownerX;
 599             y = ownerY;
 600             this.owner = owner;
 601         }
 602 
 603         boolean overlappedByOwnedWindow() {
 604             Component component = getComponent();
 605             if(owner != null &amp;&amp; component != null) {
 606                 Window w = SwingUtilities.getWindowAncestor(owner);
 607                 if (w == null) {
 608                     return false;
 609                 }
 610                 Window[] ownedWindows = w.getOwnedWindows();
 611                 if(ownedWindows != null) {
 612                     Rectangle bnd = component.getBounds();
 613                     for (Window window : ownedWindows) {
 614                         if (window.isVisible() &amp;&amp;
 615                                 bnd.intersects(window.getBounds())) {
 616 
 617                             return true;
 618                         }
 619                     }
 620                 }
 621             }
 622             return false;
 623         }
 624 
 625         /**
 626          * Returns true if popup can fit the screen and the owner&#39;s top parent.
 627          * It determines can popup be lightweight or mediumweight.
 628          */
 629         @SuppressWarnings(&quot;deprecation&quot;)
 630         boolean fitsOnScreen() {
 631             boolean result = false;
 632             Component component = getComponent();
 633             if (owner != null &amp;&amp; component != null) {
 634                 int popupWidth = component.getWidth();
 635                 int popupHeight = component.getHeight();
 636 
 637                 Container parent = (Container) SwingUtilities.getRoot(owner);
 638                 if (parent instanceof JFrame ||
 639                     parent instanceof JDialog ||
 640                     parent instanceof JWindow) {
 641 
 642                     Rectangle parentBounds = parent.getBounds();
 643                     Insets i = parent.getInsets();
 644                     parentBounds.x += i.left;
 645                     parentBounds.y += i.top;
 646                     parentBounds.width -= i.left + i.right;
 647                     parentBounds.height -= i.top + i.bottom;
 648 
 649                     if (JPopupMenu.canPopupOverlapTaskBar()) {
 650                         GraphicsConfiguration gc =
 651                                 parent.getGraphicsConfiguration();
 652                         Rectangle popupArea = getContainerPopupArea(gc);
 653                         result = parentBounds.intersection(popupArea)
 654                                 .contains(x, y, popupWidth, popupHeight);
 655                     } else {
 656                         result = parentBounds
 657                                 .contains(x, y, popupWidth, popupHeight);
 658                     }
 659                 } else if (parent instanceof JApplet) {
 660                     Rectangle parentBounds = parent.getBounds();
 661                     Point p = parent.getLocationOnScreen();
 662                     parentBounds.x = p.x;
 663                     parentBounds.y = p.y;
 664                     result = parentBounds.contains(x, y, popupWidth, popupHeight);
 665                 }
 666             }
 667             return result;
 668         }
 669 
 670         Rectangle getContainerPopupArea(GraphicsConfiguration gc) {
 671             Rectangle screenBounds;
 672             Toolkit toolkit = Toolkit.getDefaultToolkit();
 673             Insets insets;
 674             if(gc != null) {
 675                 // If we have GraphicsConfiguration use it
 676                 // to get screen bounds
 677                 screenBounds = gc.getBounds();
 678                 insets = toolkit.getScreenInsets(gc);
 679             } else {
 680                 // If we don&#39;t have GraphicsConfiguration use primary screen
 681                 screenBounds = new Rectangle(toolkit.getScreenSize());
 682                 insets = new Insets(0, 0, 0, 0);
 683             }
 684             // Take insets into account
 685             screenBounds.x += insets.left;
 686             screenBounds.y += insets.top;
 687             screenBounds.width -= (insets.left + insets.right);
 688             screenBounds.height -= (insets.top + insets.bottom);
 689             return screenBounds;
 690         }
 691     }
 692 
 693 
 694     /**
 695      * Popup implementation that is used in headless environment.
 696      */
 697     private static class HeadlessPopup extends ContainerPopup {
 698         static Popup getHeadlessPopup(Component owner, Component contents,
 699                                       int ownerX, int ownerY) {
 700             HeadlessPopup popup = new HeadlessPopup();
 701             popup.reset(owner, contents, ownerX, ownerY);
 702             return popup;
 703         }
 704 
 705         Component createComponent(Component owner) {
 706             return new Panel(new BorderLayout());
 707         }
 708 
 709         public void show() {
 710         }
 711         public void hide() {
 712         }
 713     }
 714 
 715 
 716     /**
 717      * Popup implementation that uses a JPanel as the popup.
 718      */
 719     private static class LightWeightPopup extends ContainerPopup {
 720         private static final Object lightWeightPopupCacheKey =
 721                          new StringBuffer(&quot;PopupFactory.lightPopupCache&quot;);
 722 
 723         /**
 724          * Returns a light weight &lt;code&gt;Popup&lt;/code&gt; implementation. If
 725          * the &lt;code&gt;Popup&lt;/code&gt; needs more space that in available in
 726          * &lt;code&gt;owner&lt;/code&gt;, this will return null.
 727          */
 728         static Popup getLightWeightPopup(Component owner, Component contents,
 729                                          int ownerX, int ownerY) {
 730             LightWeightPopup popup = getRecycledLightWeightPopup();
 731 
 732             if (popup == null) {
 733                 popup = new LightWeightPopup();
 734             }
 735             popup.reset(owner, contents, ownerX, ownerY);
 736             if (!popup.fitsOnScreen() ||
 737                  popup.overlappedByOwnedWindow()) {
 738                 popup.hide();
 739                 return null;
 740             }
 741             return popup;
 742         }
 743 
 744         /**
 745          * Returns the cache to use for heavy weight popups.
 746          */
 747         @SuppressWarnings(&quot;unchecked&quot;)
 748         private static List&lt;LightWeightPopup&gt; getLightWeightPopupCache() {
 749             List&lt;LightWeightPopup&gt; cache = (List&lt;LightWeightPopup&gt;)SwingUtilities.appContextGet(
 750                                    lightWeightPopupCacheKey);
 751             if (cache == null) {
 752                 cache = new ArrayList&lt;&gt;();
 753                 SwingUtilities.appContextPut(lightWeightPopupCacheKey, cache);
 754             }
 755             return cache;
 756         }
 757 
 758         /**
 759          * Recycles the LightWeightPopup &lt;code&gt;popup&lt;/code&gt;.
 760          */
 761         private static void recycleLightWeightPopup(LightWeightPopup popup) {
 762             synchronized (LightWeightPopup.class) {
 763                 List&lt;LightWeightPopup&gt; lightPopupCache = getLightWeightPopupCache();
 764                 if (lightPopupCache.size() &lt; MAX_CACHE_SIZE) {
 765                     lightPopupCache.add(popup);
 766                 }
 767             }
 768         }
 769 
 770         /**
 771          * Returns a previously used &lt;code&gt;LightWeightPopup&lt;/code&gt;, or null
 772          * if none of the popups have been recycled.
 773          */
 774         private static LightWeightPopup getRecycledLightWeightPopup() {
 775             synchronized (LightWeightPopup.class) {
 776                 List&lt;LightWeightPopup&gt; lightPopupCache = getLightWeightPopupCache();
 777                 if (lightPopupCache.size() &gt; 0) {
 778                     LightWeightPopup r = lightPopupCache.get(0);
 779                     lightPopupCache.remove(0);
 780                     return r;
 781                 }
 782                 return null;
 783             }
 784         }
 785 
 786 
 787 
 788         //
 789         // Popup methods
 790         //
 791         public void hide() {
 792             super.hide();
 793 
 794             Container component = (Container)getComponent();
 795 
 796             component.removeAll();
 797             recycleLightWeightPopup(this);
 798         }
 799 
 800         @SuppressWarnings(&quot;deprecation&quot;)
 801         public void show() {
 802             Container parent = null;
 803 
 804             if (owner != null) {
 805                 parent = (owner instanceof Container? (Container)owner : owner.getParent());
 806             }
 807 
 808             // Try to find a JLayeredPane and Window to add
 809             for (Container p = parent; p != null; p = p.getParent()) {
 810                 if (p instanceof JRootPane) {
 811                     if (p.getParent() instanceof JInternalFrame) {
 812                         continue;
 813                     }
 814                     parent = ((JRootPane)p).getLayeredPane();
 815                     // Continue, so that if there is a higher JRootPane, we&#39;ll
 816                     // pick it up.
 817                 } else if(p instanceof Window) {
 818                     if (parent == null) {
 819                         parent = p;
 820                     }
 821                     break;
 822                 } else if (p instanceof JApplet) {
 823                     // Painting code stops at Applets, we don&#39;t want
 824                     // to add to a Component above an Applet otherwise
 825                     // you&#39;ll never see it painted.
 826                     break;
 827                 }
 828             }
 829 
 830             Point p = SwingUtilities.convertScreenLocationToParent(parent, x,
 831                                                                    y);
 832             Component component = getComponent();
 833 
 834             component.setLocation(p.x, p.y);
 835             if (parent instanceof JLayeredPane) {
 836                 parent.add(component, JLayeredPane.POPUP_LAYER, 0);
 837             } else {
 838                 parent.add(component);
 839             }
<a name="5" id="anc5"></a><span class="line-added"> 840             pack();</span>
<span class="line-added"> 841             component.setVisible(true);</span>
 842         }
 843 
 844         Component createComponent(Component owner) {
<a name="6" id="anc6"></a><span class="line-modified"> 845             return new JPanel(new BorderLayout(), true);</span>



 846         }
 847 
 848         //
 849         // Local methods
 850         //
 851 
 852         /**
 853          * Resets the &lt;code&gt;Popup&lt;/code&gt; to an initial state.
 854          */
 855         void reset(Component owner, Component contents, int ownerX,
 856                    int ownerY) {
 857             super.reset(owner, contents, ownerX, ownerY);
 858 
 859             JComponent component = (JComponent)getComponent();
<a name="7" id="anc7"></a><span class="line-modified"> 860             component.setVisible(false);</span>

 861             component.setLocation(ownerX, ownerY);
<a name="8" id="anc8"></a><span class="line-added"> 862             component.setOpaque(contents.isOpaque());</span>
 863             component.add(contents, BorderLayout.CENTER);
<a name="9" id="anc9"></a>
 864             pack();
 865         }
 866     }
 867 
 868 
 869     /**
 870      * Popup implementation that uses a Panel as the popup.
 871      */
 872     private static class MediumWeightPopup extends ContainerPopup {
 873         private static final Object mediumWeightPopupCacheKey =
 874                              new StringBuffer(&quot;PopupFactory.mediumPopupCache&quot;);
 875 
 876         /** Child of the panel. The contents are added to this. */
 877         private JRootPane rootPane;
 878 
 879 
 880         /**
 881          * Returns a medium weight &lt;code&gt;Popup&lt;/code&gt; implementation. If
 882          * the &lt;code&gt;Popup&lt;/code&gt; needs more space that in available in
 883          * &lt;code&gt;owner&lt;/code&gt;, this will return null.
 884          */
 885         static Popup getMediumWeightPopup(Component owner, Component contents,
 886                                           int ownerX, int ownerY) {
 887             MediumWeightPopup popup = getRecycledMediumWeightPopup();
 888 
 889             if (popup == null) {
 890                 popup = new MediumWeightPopup();
 891             }
 892             popup.reset(owner, contents, ownerX, ownerY);
 893             if (!popup.fitsOnScreen() ||
 894                  popup.overlappedByOwnedWindow()) {
 895                 popup.hide();
 896                 return null;
 897             }
 898             return popup;
 899         }
 900 
 901         /**
 902          * Returns the cache to use for medium weight popups.
 903          */
 904         @SuppressWarnings(&quot;unchecked&quot;)
 905         private static List&lt;MediumWeightPopup&gt; getMediumWeightPopupCache() {
 906             List&lt;MediumWeightPopup&gt; cache = (List&lt;MediumWeightPopup&gt;)SwingUtilities.appContextGet(
 907                                     mediumWeightPopupCacheKey);
 908 
 909             if (cache == null) {
 910                 cache = new ArrayList&lt;&gt;();
 911                 SwingUtilities.appContextPut(mediumWeightPopupCacheKey, cache);
 912             }
 913             return cache;
 914         }
 915 
 916         /**
 917          * Recycles the MediumWeightPopup &lt;code&gt;popup&lt;/code&gt;.
 918          */
 919         private static void recycleMediumWeightPopup(MediumWeightPopup popup) {
 920             synchronized (MediumWeightPopup.class) {
 921                 List&lt;MediumWeightPopup&gt; mediumPopupCache = getMediumWeightPopupCache();
 922                 if (mediumPopupCache.size() &lt; MAX_CACHE_SIZE) {
 923                     mediumPopupCache.add(popup);
 924                 }
 925             }
 926         }
 927 
 928         /**
 929          * Returns a previously used &lt;code&gt;MediumWeightPopup&lt;/code&gt;, or null
 930          * if none of the popups have been recycled.
 931          */
 932         private static MediumWeightPopup getRecycledMediumWeightPopup() {
 933             synchronized (MediumWeightPopup.class) {
 934                 List&lt;MediumWeightPopup&gt; mediumPopupCache = getMediumWeightPopupCache();
 935                 if (mediumPopupCache.size() &gt; 0) {
 936                     MediumWeightPopup r = mediumPopupCache.get(0);
 937                     mediumPopupCache.remove(0);
 938                     return r;
 939                 }
 940                 return null;
 941             }
 942         }
 943 
 944 
 945         //
 946         // Popup
 947         //
 948 
 949         public void hide() {
 950             super.hide();
 951             rootPane.getContentPane().removeAll();
 952             recycleMediumWeightPopup(this);
 953         }
 954 
 955         @SuppressWarnings(&quot;deprecation&quot;)
 956         public void show() {
 957             Component component = getComponent();
 958             Container parent = null;
 959 
 960             if (owner != null) {
 961                 parent = owner.getParent();
 962             }
 963             /*
 964               Find the top level window,
 965               if it has a layered pane,
 966               add to that, otherwise
 967               add to the window. */
 968             while (!(parent instanceof Window || parent instanceof Applet) &amp;&amp;
 969                    (parent!=null)) {
 970                 parent = parent.getParent();
 971             }
<a name="10" id="anc10"></a><span class="line-modified"> 972 </span>



 973             if (parent instanceof RootPaneContainer) {
<a name="11" id="anc11"></a><span class="line-modified"> 974                 parent = ((RootPaneContainer) parent).getLayeredPane();</span>
<span class="line-modified"> 975             }</span>








 976 
<a name="12" id="anc12"></a><span class="line-modified"> 977             Point p = SwingUtilities.convertScreenLocationToParent(parent,</span>
<span class="line-modified"> 978                                                                    x, y);</span>
<span class="line-added"> 979             component.setLocation(p.x, p.y);</span>
<span class="line-added"> 980             if (parent instanceof JLayeredPane) {</span>
<span class="line-added"> 981                 parent.add(component, JLayeredPane.POPUP_LAYER, 0);</span>
<span class="line-added"> 982             } else {</span>
 983                 parent.add(component);
 984             }
<a name="13" id="anc13"></a><span class="line-added"> 985             pack();</span>
 986             component.setVisible(true);
<a name="14" id="anc14"></a><span class="line-added"> 987             component.revalidate();</span>
 988         }
 989 
 990         Component createComponent(Component owner) {
 991             Panel component = new MediumWeightComponent();
 992 
 993             rootPane = new JRootPane();
 994             // NOTE: this uses setOpaque vs LookAndFeel.installProperty as
 995             // there is NO reason for the RootPane not to be opaque. For
 996             // painting to work the contentPane must be opaque, therefor the
 997             // RootPane can also be opaque.
 998             rootPane.setOpaque(true);
 999             component.add(rootPane, BorderLayout.CENTER);
1000             return component;
1001         }
1002 
1003         /**
1004          * Resets the &lt;code&gt;Popup&lt;/code&gt; to an initial state.
1005          */
1006         void reset(Component owner, Component contents, int ownerX,
1007                    int ownerY) {
1008             super.reset(owner, contents, ownerX, ownerY);
1009 
1010             Component component = getComponent();
<a name="15" id="anc15"></a><span class="line-modified">1011             component.setVisible(false);</span>
1012             component.setLocation(ownerX, ownerY);
1013             rootPane.getContentPane().add(contents, BorderLayout.CENTER);
<a name="16" id="anc16"></a>

1014             pack();
1015         }
1016 
1017 
1018         // This implements SwingHeavyWeight so that repaints on it
1019         // are processed by the RepaintManager and SwingPaintEventDispatcher.
1020         @SuppressWarnings(&quot;serial&quot;) // JDK-implementation class
1021         private static class MediumWeightComponent extends Panel implements
1022                                                            SwingHeavyWeight {
1023             MediumWeightComponent() {
1024                 super(new BorderLayout());
1025             }
1026         }
1027     }
1028 }
1029 
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
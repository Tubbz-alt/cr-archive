<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/classes/javax/swing/text/rtf/RTFReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javax.swing.text.rtf;
  26 
  27 import java.lang.*;
  28 import java.util.*;
  29 import java.io.*;
  30 import java.awt.Color;
  31 import java.security.AccessController;
  32 import java.security.PrivilegedAction;
  33 import javax.swing.text.*;
  34 
  35 /**
  36  * Takes a sequence of RTF tokens and text and appends the text
  37  * described by the RTF to a &lt;code&gt;StyledDocument&lt;/code&gt; (the &lt;em&gt;target&lt;/em&gt;).
  38  * The RTF is lexed
  39  * from the character stream by the &lt;code&gt;RTFParser&lt;/code&gt; which is this class&#39;s
  40  * superclass.
  41  *
  42  * This class is an indirect subclass of OutputStream. It must be closed
  43  * in order to guarantee that all of the text has been sent to
  44  * the text acceptor.
  45  *
  46  *   @see RTFParser
  47  *   @see java.io.OutputStream
  48  */
  49 class RTFReader extends RTFParser
  50 {
  51   /** The object to which the parsed text is sent. */
  52   StyledDocument target;
  53 
  54   /** Miscellaneous information about the parser&#39;s state. This
  55    *  dictionary is saved and restored when an RTF group begins
  56    *  or ends. */
  57   Dictionary&lt;Object, Object&gt; parserState;   /* Current parser state */
  58   /** This is the &quot;dst&quot; item from parserState. rtfDestination
  59    *  is the current rtf destination. It is cached in an instance
  60    *  variable for speed. */
  61   Destination rtfDestination;
  62   /** This holds the current document attributes. */
  63   MutableAttributeSet documentAttributes;
  64 
  65   /** This Dictionary maps Integer font numbers to String font names. */
  66   Dictionary&lt;Integer, String&gt; fontTable;
  67   /** This array maps color indices to Color objects. */
  68   Color[] colorTable;
  69   /** This array maps character style numbers to Style objects. */
  70   Style[] characterStyles;
  71   /** This array maps paragraph style numbers to Style objects. */
  72   Style[] paragraphStyles;
  73   /** This array maps section style numbers to Style objects. */
  74   Style[] sectionStyles;
  75 
  76   /** This is the RTF version number, extracted from the \rtf keyword.
  77    *  The version information is currently not used. */
  78   int rtfversion;
  79 
  80   /** &lt;code&gt;true&lt;/code&gt; to indicate that if the next keyword is unknown,
  81    *  the containing group should be ignored. */
  82   boolean ignoreGroupIfUnknownKeyword;
  83 
  84   /** The parameter of the most recently parsed \\ucN keyword,
  85    *  used for skipping alternative representations after a
  86    *  Unicode character. */
  87   int skippingCharacters;
  88 
  89   private static Dictionary&lt;String, RTFAttribute&gt; straightforwardAttributes;
  90   static {
  91       straightforwardAttributes = RTFAttributes.attributesByKeyword();
  92   }
  93 
  94   private MockAttributeSet mockery;
  95 
  96   /* this should be final, but there&#39;s a bug in javac... */
  97   /** textKeywords maps RTF keywords to single-character strings,
  98    *  for those keywords which simply insert some text. */
  99   static Dictionary&lt;String, String&gt; textKeywords = null;
 100   static {
 101       textKeywords = new Hashtable&lt;String, String&gt;();
 102       textKeywords.put(&quot;\\&quot;,         &quot;\\&quot;);
 103       textKeywords.put(&quot;{&quot;,          &quot;{&quot;);
 104       textKeywords.put(&quot;}&quot;,          &quot;}&quot;);
 105       textKeywords.put(&quot; &quot;,          &quot;\u00A0&quot;);  /* not in the spec... */
 106       textKeywords.put(&quot;~&quot;,          &quot;\u00A0&quot;);  /* nonbreaking space */
 107       textKeywords.put(&quot;_&quot;,          &quot;\u2011&quot;);  /* nonbreaking hyphen */
 108       textKeywords.put(&quot;bullet&quot;,     &quot;\u2022&quot;);
 109       textKeywords.put(&quot;emdash&quot;,     &quot;\u2014&quot;);
 110       textKeywords.put(&quot;emspace&quot;,    &quot;\u2003&quot;);
 111       textKeywords.put(&quot;endash&quot;,     &quot;\u2013&quot;);
 112       textKeywords.put(&quot;enspace&quot;,    &quot;\u2002&quot;);
 113       textKeywords.put(&quot;ldblquote&quot;,  &quot;\u201C&quot;);
 114       textKeywords.put(&quot;lquote&quot;,     &quot;\u2018&quot;);
 115       textKeywords.put(&quot;ltrmark&quot;,    &quot;\u200E&quot;);
 116       textKeywords.put(&quot;rdblquote&quot;,  &quot;\u201D&quot;);
 117       textKeywords.put(&quot;rquote&quot;,     &quot;\u2019&quot;);
 118       textKeywords.put(&quot;rtlmark&quot;,    &quot;\u200F&quot;);
 119       textKeywords.put(&quot;tab&quot;,        &quot;\u0009&quot;);
 120       textKeywords.put(&quot;zwj&quot;,        &quot;\u200D&quot;);
 121       textKeywords.put(&quot;zwnj&quot;,       &quot;\u200C&quot;);
 122 
 123       /* There is no Unicode equivalent to an optional hyphen, as far as
 124          I can tell. */
 125       textKeywords.put(&quot;-&quot;,          &quot;\u2027&quot;);  /* TODO: optional hyphen */
 126   }
 127 
 128   /* some entries in parserState */
 129   static final String TabAlignmentKey = &quot;tab_alignment&quot;;
 130   static final String TabLeaderKey = &quot;tab_leader&quot;;
 131 
 132   static Dictionary&lt;String, char[]&gt; characterSets;
 133   static boolean useNeXTForAnsi = false;
 134   static {
 135       characterSets = new Hashtable&lt;String, char[]&gt;();
 136       defineCharacterSet(&quot;ansicpg&quot;, latin1TranslationTable);
 137   }
 138 
 139 /* TODO: per-font font encodings ( \fcharset control word ) ? */
 140 
 141 /**
 142  * Creates a new RTFReader instance. Text will be sent to
 143  * the specified TextAcceptor.
 144  *
 145  * @param destination The TextAcceptor which is to receive the text.
 146  */
 147 public RTFReader(StyledDocument destination)
 148 {
 149     int i;
 150 
 151     target = destination;
 152     parserState = new Hashtable&lt;Object, Object&gt;();
 153     fontTable = new Hashtable&lt;Integer, String&gt;();
 154 
 155     rtfversion = -1;
 156 
 157     mockery = new MockAttributeSet();
 158     documentAttributes = new SimpleAttributeSet();
 159 }
 160 
 161 /** Called when the RTFParser encounters a bin keyword in the
 162  *  RTF stream.
 163  *
 164  *  @see RTFParser
 165  */
 166 public void handleBinaryBlob(byte[] data)
 167 {
 168     if (skippingCharacters &gt; 0) {
 169         /* a blob only counts as one character for skipping purposes */
 170         skippingCharacters --;
 171         return;
 172     }
 173 
 174     /* someday, someone will want to do something with blobs */
 175 }
 176 
 177 
 178 /**
 179  * Handles any pure text (containing no control characters) in the input
 180  * stream. Called by the superclass. */
 181 public void handleText(String text)
 182 {
 183     if (skippingCharacters &gt; 0) {
 184         if (skippingCharacters &gt;= text.length()) {
 185             skippingCharacters -= text.length();
 186             return;
 187         } else {
 188             text = text.substring(skippingCharacters);
 189             skippingCharacters = 0;
 190         }
 191     }
 192 
 193     if (rtfDestination != null) {
 194         rtfDestination.handleText(text);
 195         return;
 196     }
 197 
 198     warning(&quot;Text with no destination. oops.&quot;);
 199 }
 200 
 201 /** The default color for text which has no specified color. */
 202 Color defaultColor()
 203 {
 204     return Color.black;
 205 }
 206 
 207 /** Called by the superclass when a new RTF group is begun.
 208  *  This implementation saves the current &lt;code&gt;parserState&lt;/code&gt;, and gives
 209  *  the current destination a chance to save its own state.
 210  * @see RTFParser#begingroup
 211  */
 212 public void begingroup()
 213 {
 214     if (skippingCharacters &gt; 0) {
 215         /* TODO this indicates an error in the RTF. Log it? */
 216         skippingCharacters = 0;
 217     }
 218 
 219     /* we do this little dance to avoid cloning the entire state stack and
 220        immediately throwing it away. */
 221     Object oldSaveState = parserState.get(&quot;_savedState&quot;);
 222     if (oldSaveState != null)
 223         parserState.remove(&quot;_savedState&quot;);
 224     @SuppressWarnings(&quot;unchecked&quot;)
 225     Dictionary&lt;String, Object&gt; saveState = (Dictionary&lt;String, Object&gt;)((Hashtable)parserState).clone();
 226     if (oldSaveState != null)
 227         saveState.put(&quot;_savedState&quot;, oldSaveState);
 228     parserState.put(&quot;_savedState&quot;, saveState);
 229 
 230     if (rtfDestination != null)
 231         rtfDestination.begingroup();
 232 }
 233 
 234 /** Called by the superclass when the current RTF group is closed.
 235  *  This restores the parserState saved by &lt;code&gt;begingroup()&lt;/code&gt;
 236  *  as well as invoking the endgroup method of the current
 237  *  destination.
 238  * @see RTFParser#endgroup
 239  */
 240 public void endgroup()
 241 {
 242     if (skippingCharacters &gt; 0) {
 243         /* NB this indicates an error in the RTF. Log it? */
 244         skippingCharacters = 0;
 245     }
 246 
 247     @SuppressWarnings(&quot;unchecked&quot;)
 248     Dictionary&lt;Object, Object&gt; restoredState = (Dictionary&lt;Object, Object&gt;)parserState.get(&quot;_savedState&quot;);
 249     Destination restoredDestination = (Destination)restoredState.get(&quot;dst&quot;);
 250     if (restoredDestination != rtfDestination) {
 251         rtfDestination.close(); /* allow the destination to clean up */
 252         rtfDestination = restoredDestination;
 253     }
 254     Dictionary&lt;Object, Object&gt; oldParserState = parserState;
 255     parserState = restoredState;
 256     if (rtfDestination != null)
 257         rtfDestination.endgroup(oldParserState);
 258 }
 259 
 260 protected void setRTFDestination(Destination newDestination)
 261 {
 262     /* Check that setting the destination won&#39;t close the
 263        current destination (should never happen) */
 264     @SuppressWarnings(&quot;unchecked&quot;)
 265     Dictionary&lt;Object, Object&gt; previousState = (Dictionary)parserState.get(&quot;_savedState&quot;);
 266     if (previousState != null) {
 267         if (rtfDestination != previousState.get(&quot;dst&quot;)) {
 268             warning(&quot;Warning, RTF destination overridden, invalid RTF.&quot;);
 269             rtfDestination.close();
 270         }
 271     }
 272     rtfDestination = newDestination;
 273     parserState.put(&quot;dst&quot;, rtfDestination);
 274 }
 275 
 276 /** Called by the user when there is no more input (&lt;i&gt;i.e.&lt;/i&gt;,
 277  * at the end of the RTF file.)
 278  *
 279  * @see OutputStream#close
 280  */
 281 public void close()
 282     throws IOException
 283 {
 284     Enumeration&lt;?&gt; docProps = documentAttributes.getAttributeNames();
 285     while(docProps.hasMoreElements()) {
 286         Object propName = docProps.nextElement();
 287         target.putProperty(propName,
 288                            documentAttributes.getAttribute(propName));
 289     }
 290 
 291     /* RTFParser should have ensured that all our groups are closed */
 292 
 293     warning(&quot;RTF filter done.&quot;);
 294 
 295     super.close();
 296 }
 297 
 298 /**
 299  * Handles a parameterless RTF keyword. This is called by the superclass
 300  * (RTFParser) when a keyword is found in the input stream.
 301  *
 302  * @return true if the keyword is recognized and handled;
 303  *         false otherwise
 304  * @see RTFParser#handleKeyword
 305  */
 306 public boolean handleKeyword(String keyword)
 307 {
 308     String item;
 309     boolean ignoreGroupIfUnknownKeywordSave = ignoreGroupIfUnknownKeyword;
 310 
 311     if (skippingCharacters &gt; 0) {
 312         skippingCharacters --;
 313         return true;
 314     }
 315 
 316     ignoreGroupIfUnknownKeyword = false;
 317 
 318     if ((item = textKeywords.get(keyword)) != null) {
 319         handleText(item);
 320         return true;
 321     }
 322 
 323     if (keyword.equals(&quot;fonttbl&quot;)) {
 324         setRTFDestination(new FonttblDestination());
 325         return true;
 326     }
 327 
 328     if (keyword.equals(&quot;colortbl&quot;)) {
 329         setRTFDestination(new ColortblDestination());
 330         return true;
 331     }
 332 
 333     if (keyword.equals(&quot;stylesheet&quot;)) {
 334         setRTFDestination(new StylesheetDestination());
 335         return true;
 336     }
 337 
 338     if (keyword.equals(&quot;info&quot;)) {
 339         setRTFDestination(new InfoDestination());
 340         return false;
 341     }
 342 
 343     if (keyword.equals(&quot;mac&quot;)) {
 344         setCharacterSet(&quot;mac&quot;);
 345         return true;
 346     }
 347 
 348     if (keyword.equals(&quot;ansi&quot;)) {
 349         if (useNeXTForAnsi)
 350             setCharacterSet(&quot;NeXT&quot;);
 351         else
 352             setCharacterSet(&quot;ansi&quot;);
 353         return true;
 354     }
 355 
 356     if (keyword.equals(&quot;next&quot;)) {
 357         setCharacterSet(&quot;NeXT&quot;);
 358         return true;
 359     }
 360 
 361     if (keyword.equals(&quot;pc&quot;)) {
 362         setCharacterSet(&quot;cpg437&quot;); /* IBM Code Page 437 */
 363         return true;
 364     }
 365 
 366     if (keyword.equals(&quot;pca&quot;)) {
 367         setCharacterSet(&quot;cpg850&quot;); /* IBM Code Page 850 */
 368         return true;
 369     }
 370 
 371     if (keyword.equals(&quot;*&quot;)) {
 372         ignoreGroupIfUnknownKeyword = true;
 373         return true;
 374     }
 375 
 376     if (rtfDestination != null) {
 377         if(rtfDestination.handleKeyword(keyword))
 378             return true;
 379     }
 380 
 381     /* this point is reached only if the keyword is unrecognized */
 382 
 383     /* other destinations we don&#39;t understand and therefore ignore */
 384     if (keyword.equals(&quot;aftncn&quot;) ||
 385         keyword.equals(&quot;aftnsep&quot;) ||
 386         keyword.equals(&quot;aftnsepc&quot;) ||
 387         keyword.equals(&quot;annotation&quot;) ||
 388         keyword.equals(&quot;atnauthor&quot;) ||
 389         keyword.equals(&quot;atnicn&quot;) ||
 390         keyword.equals(&quot;atnid&quot;) ||
 391         keyword.equals(&quot;atnref&quot;) ||
 392         keyword.equals(&quot;atntime&quot;) ||
 393         keyword.equals(&quot;atrfend&quot;) ||
 394         keyword.equals(&quot;atrfstart&quot;) ||
 395         keyword.equals(&quot;bkmkend&quot;) ||
 396         keyword.equals(&quot;bkmkstart&quot;) ||
 397         keyword.equals(&quot;datafield&quot;) ||
 398         keyword.equals(&quot;do&quot;) ||
 399         keyword.equals(&quot;dptxbxtext&quot;) ||
 400         keyword.equals(&quot;falt&quot;) ||
 401         keyword.equals(&quot;field&quot;) ||
 402         keyword.equals(&quot;file&quot;) ||
 403         keyword.equals(&quot;filetbl&quot;) ||
 404         keyword.equals(&quot;fname&quot;) ||
 405         keyword.equals(&quot;fontemb&quot;) ||
 406         keyword.equals(&quot;fontfile&quot;) ||
 407         keyword.equals(&quot;footer&quot;) ||
 408         keyword.equals(&quot;footerf&quot;) ||
 409         keyword.equals(&quot;footerl&quot;) ||
 410         keyword.equals(&quot;footerr&quot;) ||
 411         keyword.equals(&quot;footnote&quot;) ||
 412         keyword.equals(&quot;ftncn&quot;) ||
 413         keyword.equals(&quot;ftnsep&quot;) ||
 414         keyword.equals(&quot;ftnsepc&quot;) ||
 415         keyword.equals(&quot;header&quot;) ||
 416         keyword.equals(&quot;headerf&quot;) ||
 417         keyword.equals(&quot;headerl&quot;) ||
 418         keyword.equals(&quot;headerr&quot;) ||
 419         keyword.equals(&quot;keycode&quot;) ||
 420         keyword.equals(&quot;nextfile&quot;) ||
 421         keyword.equals(&quot;object&quot;) ||
 422         keyword.equals(&quot;pict&quot;) ||
 423         keyword.equals(&quot;pn&quot;) ||
 424         keyword.equals(&quot;pnseclvl&quot;) ||
 425         keyword.equals(&quot;pntxtb&quot;) ||
 426         keyword.equals(&quot;pntxta&quot;) ||
 427         keyword.equals(&quot;revtbl&quot;) ||
 428         keyword.equals(&quot;rxe&quot;) ||
 429         keyword.equals(&quot;tc&quot;) ||
 430         keyword.equals(&quot;template&quot;) ||
 431         keyword.equals(&quot;txe&quot;) ||
 432         keyword.equals(&quot;xe&quot;)) {
 433         ignoreGroupIfUnknownKeywordSave = true;
 434     }
 435 
 436     if (ignoreGroupIfUnknownKeywordSave) {
 437         setRTFDestination(new DiscardingDestination());
 438     }
 439 
 440     return false;
 441 }
 442 
 443 /**
 444  * Handles an RTF keyword and its integer parameter.
 445  * This is called by the superclass
 446  * (RTFParser) when a keyword is found in the input stream.
 447  *
 448  * @return true if the keyword is recognized and handled;
 449  *         false otherwise
 450  * @see RTFParser#handleKeyword
 451  */
 452 public boolean handleKeyword(String keyword, int parameter)
 453 {
 454     boolean ignoreGroupIfUnknownKeywordSave = ignoreGroupIfUnknownKeyword;
 455 
 456     if (skippingCharacters &gt; 0) {
 457         skippingCharacters --;
 458         return true;
 459     }
 460 
 461     ignoreGroupIfUnknownKeyword = false;
 462 
 463     if (keyword.equals(&quot;uc&quot;)) {
 464         /* count of characters to skip after a unicode character */
 465         parserState.put(&quot;UnicodeSkip&quot;, Integer.valueOf(parameter));
 466         return true;
 467     }
 468     if (keyword.equals(&quot;u&quot;)) {
 469         if (parameter &lt; 0)
 470             parameter = parameter + 65536;
 471         handleText((char)parameter);
 472         Number skip = (Number)(parserState.get(&quot;UnicodeSkip&quot;));
 473         if (skip != null) {
 474             skippingCharacters = skip.intValue();
 475         } else {
 476             skippingCharacters = 1;
 477         }
 478         return true;
 479     }
 480 
 481     if (keyword.equals(&quot;rtf&quot;)) {
 482         rtfversion = parameter;
 483         setRTFDestination(new DocumentDestination());
 484         return true;
 485     }
 486 
 487     if (keyword.startsWith(&quot;NeXT&quot;) ||
 488         keyword.equals(&quot;private&quot;))
 489         ignoreGroupIfUnknownKeywordSave = true;
 490 
 491      if (keyword.contains(&quot;ansicpg&quot;)) {
 492          setCharacterSet(&quot;ansicpg&quot;);
 493          return true;
 494      }
 495 
 496     if (rtfDestination != null) {
 497         if(rtfDestination.handleKeyword(keyword, parameter))
 498             return true;
 499     }
 500 
 501     /* this point is reached only if the keyword is unrecognized */
 502 
 503     if (ignoreGroupIfUnknownKeywordSave) {
 504         setRTFDestination(new DiscardingDestination());
 505     }
 506 
 507     return false;
 508 }
 509 
 510 private void setTargetAttribute(String name, Object value)
 511 {
 512 //    target.changeAttributes(new LFDictionary(LFArray.arrayWithObject(value), LFArray.arrayWithObject(name)));
 513 }
 514 
 515 /**
 516  * setCharacterSet sets the current translation table to correspond with
 517  * the named character set. The character set is loaded if necessary.
 518  *
 519  * @see AbstractFilter
 520  */
 521 public void setCharacterSet(String name)
 522 {
 523     Object set;
 524 
 525     try {
 526         set = getCharacterSet(name);
 527     } catch (Exception e) {
 528         warning(&quot;Exception loading RTF character set \&quot;&quot; + name + &quot;\&quot;: &quot; + e);
 529         set = null;
 530     }
 531 
 532     if (set != null) {
 533         translationTable = (char[])set;
 534     } else {
 535         warning(&quot;Unknown RTF character set \&quot;&quot; + name + &quot;\&quot;&quot;);
 536         if (!name.equals(&quot;ansi&quot;)) {
 537             try {
 538                 translationTable = (char[])getCharacterSet(&quot;ansi&quot;);
 539             } catch (IOException e) {
 540                 throw new InternalError(&quot;RTFReader: Unable to find character set resources (&quot; + e + &quot;)&quot;, e);
 541             }
 542         }
 543     }
 544 
 545     setTargetAttribute(Constants.RTFCharacterSet, name);
 546 }
 547 
 548 /** Adds a character set to the RTFReader&#39;s list
 549  *  of known character sets */
 550 public static void
 551 defineCharacterSet(String name, char[] table)
 552 {
 553     if (table.length &lt; 256)
 554         throw new IllegalArgumentException(&quot;Translation table must have 256 entries.&quot;);
 555     characterSets.put(name, table);
 556 }
 557 
 558 /** Looks up a named character set. A character set is a 256-entry
 559  *  array of characters, mapping unsigned byte values to their Unicode
 560  *  equivalents. The character set is loaded if necessary.
 561  *
 562  *  @return the character set
 563  */
 564 public static Object
 565 getCharacterSet(final String name)
 566     throws IOException
 567 {
 568     char[] set = characterSets.get(name);
 569     if (set == null) {
 570         InputStream charsetStream = AccessController.doPrivileged(
 571                 new PrivilegedAction&lt;InputStream&gt;() {
 572                     public InputStream run() {
 573                         return RTFReader.class.getResourceAsStream(&quot;charsets/&quot; + name + &quot;.txt&quot;);
 574                     }
 575                 });
 576         set = readCharset(charsetStream);
 577         defineCharacterSet(name, set);
 578     }
 579     return set;
 580 }
 581 
 582 /** Parses a character set from an InputStream. The character set
 583  * must contain 256 decimal integers, separated by whitespace, with
 584  * no punctuation. B- and C- style comments are allowed.
 585  *
 586  * @return the newly read character set
 587  */
 588 static char[] readCharset(InputStream strm)
 589      throws IOException
 590 {
 591     char[] values = new char[256];
 592     int i;
 593     StreamTokenizer in = new StreamTokenizer(new BufferedReader(
 594             new InputStreamReader(strm, &quot;ISO-8859-1&quot;)));
 595 
 596     in.eolIsSignificant(false);
 597     in.commentChar(&#39;#&#39;);
 598     in.slashSlashComments(true);
 599     in.slashStarComments(true);
 600 
 601     i = 0;
 602     while (i &lt; 256) {
 603         int ttype;
 604         try {
 605             ttype = in.nextToken();
 606         } catch (Exception e) {
 607             throw new IOException(&quot;Unable to read from character set file (&quot; + e + &quot;)&quot;);
 608         }
 609         if (ttype != StreamTokenizer.TT_NUMBER) {
 610 //          System.out.println(&quot;Bad token: type=&quot; + ttype + &quot; tok=&quot; + in.sval);
 611             throw new IOException(&quot;Unexpected token in character set file&quot;);
 612 //          continue;
 613         }
 614         values[i] = (char)(in.nval);
 615         i++;
 616     }
 617 
 618     return values;
 619 }
 620 
 621 static char[] readCharset(java.net.URL href)
 622      throws IOException
 623 {
 624     return readCharset(href.openStream());
 625 }
 626 
 627 /** An interface (could be an entirely abstract class) describing
 628  *  a destination. The RTF reader always has a current destination
 629  *  which is where text is sent.
 630  *
 631  *  @see RTFReader
 632  */
 633 interface Destination {
 634     void handleBinaryBlob(byte[] data);
 635     void handleText(String text);
 636     boolean handleKeyword(String keyword);
 637     boolean handleKeyword(String keyword, int parameter);
 638 
 639     void begingroup();
 640     void endgroup(Dictionary&lt;Object, Object&gt; oldState);
 641 
 642     void close();
 643 }
 644 
 645 /** This data-sink class is used to implement ignored destinations
 646  *  (e.g. {\*\blegga blah blah blah} )
 647  *  It accepts all keywords and text but does nothing with them. */
 648 class DiscardingDestination implements Destination
 649 {
 650     public void handleBinaryBlob(byte[] data)
 651     {
 652         /* Discard binary blobs. */
 653     }
 654 
 655     public void handleText(String text)
 656     {
 657         /* Discard text. */
 658     }
 659 
 660     public boolean handleKeyword(String text)
 661     {
 662         /* Accept and discard keywords. */
 663         return true;
 664     }
 665 
 666     public boolean handleKeyword(String text, int parameter)
 667     {
 668         /* Accept and discard parameterized keywords. */
 669         return true;
 670     }
 671 
 672     public void begingroup()
 673     {
 674         /* Ignore groups --- the RTFReader will keep track of the
 675            current group level as necessary */
 676     }
 677 
 678     public void endgroup(Dictionary&lt;Object, Object&gt; oldState)
 679     {
 680         /* Ignore groups */
 681     }
 682 
 683     public void close()
 684     {
 685         /* No end-of-destination cleanup needed */
 686     }
 687 }
 688 
 689 /** Reads the fonttbl group, inserting fonts into the RTFReader&#39;s
 690  *  fontTable dictionary. */
 691 class FonttblDestination implements Destination
 692 {
 693     int nextFontNumber;
 694     Integer fontNumberKey = null;
 695     String nextFontFamily;
 696 
 697     public void handleBinaryBlob(byte[] data)
 698     { /* Discard binary blobs. */ }
 699 
 700     public void handleText(String text)
 701     {
 702         int semicolon = text.indexOf(&#39;;&#39;);
 703         String fontName;
 704 
 705         if (semicolon &gt; -1)
 706             fontName = text.substring(0, semicolon);
 707         else
 708             fontName = text;
 709 
 710 
 711         /* TODO: do something with the font family. */
 712 
 713         if (nextFontNumber == -1
 714             &amp;&amp; fontNumberKey != null) {
 715             //font name might be broken across multiple calls
 716             fontName = fontTable.get(fontNumberKey) + fontName;
 717         } else {
 718             fontNumberKey = Integer.valueOf(nextFontNumber);
 719         }
 720         fontTable.put(fontNumberKey, fontName);
 721 
 722         nextFontNumber = -1;
 723         nextFontFamily = null;
 724     }
 725 
 726     public boolean handleKeyword(String keyword)
 727     {
 728         if (keyword.charAt(0) == &#39;f&#39;) {
 729             nextFontFamily = keyword.substring(1);
 730             return true;
 731         }
 732 
 733         return false;
 734     }
 735 
 736     public boolean handleKeyword(String keyword, int parameter)
 737     {
 738         if (keyword.equals(&quot;f&quot;)) {
 739             nextFontNumber = parameter;
 740             return true;
 741         }
 742 
 743         return false;
 744     }
 745 
 746     /* Groups are irrelevant. */
 747     public void begingroup() {}
 748     public void endgroup(Dictionary&lt;Object, Object&gt; oldState) {}
 749 
 750     /* currently, the only thing we do when the font table ends is
 751        dump its contents to the debugging log. */
 752     public void close()
 753     {
 754         Enumeration&lt;Integer&gt; nums = fontTable.keys();
 755         warning(&quot;Done reading font table.&quot;);
 756         while(nums.hasMoreElements()) {
 757             Integer num = nums.nextElement();
 758             warning(&quot;Number &quot; + num + &quot;: &quot; + fontTable.get(num));
 759         }
 760     }
 761 }
 762 
 763 /** Reads the colortbl group. Upon end-of-group, the RTFReader&#39;s
 764  *  color table is set to an array containing the read colors. */
 765 class ColortblDestination implements Destination
 766 {
 767     int red, green, blue;
 768     Vector&lt;Color&gt; proTemTable;
 769 
 770     public ColortblDestination()
 771     {
 772         red = 0;
 773         green = 0;
 774         blue = 0;
 775         proTemTable = new Vector&lt;Color&gt;();
 776     }
 777 
 778     public void handleText(String text)
 779     {
 780         int index;
 781 
 782         for (index = 0; index &lt; text.length(); index ++) {
 783             if (text.charAt(index) == &#39;;&#39;) {
 784                 Color newColor;
 785                 newColor = new Color(red, green, blue);
 786                 proTemTable.addElement(newColor);
 787             }
 788         }
 789     }
 790 
 791     public void close()
 792     {
 793         int count = proTemTable.size();
 794         warning(&quot;Done reading color table, &quot; + count + &quot; entries.&quot;);
 795         colorTable = new Color[count];
 796         proTemTable.copyInto(colorTable);
 797     }
 798 
 799     public boolean handleKeyword(String keyword, int parameter)
 800     {
 801         if (keyword.equals(&quot;red&quot;))
 802             red = parameter;
 803         else if (keyword.equals(&quot;green&quot;))
 804             green = parameter;
 805         else if (keyword.equals(&quot;blue&quot;))
 806             blue = parameter;
 807         else
 808             return false;
 809 
 810         return true;
 811     }
 812 
 813     /* Colortbls don&#39;t understand any parameterless keywords */
 814     public boolean handleKeyword(String keyword) { return false; }
 815 
 816     /* Groups are irrelevant. */
 817     public void begingroup() {}
 818     public void endgroup(Dictionary&lt;Object, Object&gt; oldState) {}
 819 
 820     /* Shouldn&#39;t see any binary blobs ... */
 821     public void handleBinaryBlob(byte[] data) {}
 822 }
 823 
 824 /** Handles the stylesheet keyword. Styles are read and sorted
 825  *  into the three style arrays in the RTFReader. */
 826 class StylesheetDestination
 827     extends DiscardingDestination
 828     implements Destination
 829 {
 830     Dictionary&lt;Integer, StyleDefiningDestination&gt; definedStyles;
 831 
 832     public StylesheetDestination()
 833     {
 834         definedStyles = new Hashtable&lt;Integer, StyleDefiningDestination&gt;();
 835     }
 836 
 837     public void begingroup()
 838     {
 839         setRTFDestination(new StyleDefiningDestination());
 840     }
 841 
 842     public void close()
 843     {
 844         Vector&lt;Style&gt; chrStyles = new Vector&lt;Style&gt;();
 845         Vector&lt;Style&gt; pgfStyles = new Vector&lt;Style&gt;();
 846         Vector&lt;Style&gt; secStyles = new Vector&lt;Style&gt;();
 847         Enumeration&lt;StyleDefiningDestination&gt; styles = definedStyles.elements();
 848         while(styles.hasMoreElements()) {
 849             StyleDefiningDestination style;
 850             Style defined;
 851             style = styles.nextElement();
 852             defined = style.realize();
 853             warning(&quot;Style &quot;+style.number+&quot; (&quot;+style.styleName+&quot;): &quot;+defined);
 854             String stype = (String)defined.getAttribute(Constants.StyleType);
 855             Vector&lt;Style&gt; toSet;
 856             if (stype.equals(Constants.STSection)) {
 857                 toSet = secStyles;
 858             } else if (stype.equals(Constants.STCharacter)) {
 859                 toSet = chrStyles;
 860             } else {
 861                 toSet = pgfStyles;
 862             }
 863             if (toSet.size() &lt;= style.number)
 864                 toSet.setSize(style.number + 1);
 865             toSet.setElementAt(defined, style.number);
 866         }
 867         if (!(chrStyles.isEmpty())) {
 868             Style[] styleArray = new Style[chrStyles.size()];
 869             chrStyles.copyInto(styleArray);
 870             characterStyles = styleArray;
 871         }
 872         if (!(pgfStyles.isEmpty())) {
 873             Style[] styleArray = new Style[pgfStyles.size()];
 874             pgfStyles.copyInto(styleArray);
 875             paragraphStyles = styleArray;
 876         }
 877         if (!(secStyles.isEmpty())) {
 878             Style[] styleArray = new Style[secStyles.size()];
 879             secStyles.copyInto(styleArray);
 880             sectionStyles = styleArray;
 881         }
 882 
 883 /* (old debugging code)
 884         int i, m;
 885         if (characterStyles != null) {
 886           m = characterStyles.length;
 887           for(i=0;i&lt;m;i++)
 888             warnings.println(&quot;chrStyle[&quot;+i+&quot;]=&quot;+characterStyles[i]);
 889         } else warnings.println(&quot;No character styles.&quot;);
 890         if (paragraphStyles != null) {
 891           m = paragraphStyles.length;
 892           for(i=0;i&lt;m;i++)
 893             warnings.println(&quot;pgfStyle[&quot;+i+&quot;]=&quot;+paragraphStyles[i]);
 894         } else warnings.println(&quot;No paragraph styles.&quot;);
 895         if (sectionStyles != null) {
 896           m = characterStyles.length;
 897           for(i=0;i&lt;m;i++)
 898             warnings.println(&quot;secStyle[&quot;+i+&quot;]=&quot;+sectionStyles[i]);
 899         } else warnings.println(&quot;No section styles.&quot;);
 900 */
 901     }
 902 
 903     /** This subclass handles an individual style */
 904     class StyleDefiningDestination
 905         extends AttributeTrackingDestination
 906         implements Destination
 907     {
 908         final int STYLENUMBER_NONE = 222;
 909         boolean additive;
 910         boolean characterStyle;
 911         boolean sectionStyle;
 912         public String styleName;
 913         public int number;
 914         int basedOn;
 915         int nextStyle;
 916         boolean hidden;
 917 
 918         Style realizedStyle;
 919 
 920         public StyleDefiningDestination()
 921         {
 922             additive = false;
 923             characterStyle = false;
 924             sectionStyle = false;
 925             styleName = null;
 926             number = 0;
 927             basedOn = STYLENUMBER_NONE;
 928             nextStyle = STYLENUMBER_NONE;
 929             hidden = false;
 930         }
 931 
 932         public void handleText(String text)
 933         {
 934             if (styleName != null)
 935                 styleName = styleName + text;
 936             else
 937                 styleName = text;
 938         }
 939 
 940         public void close() {
 941             int semicolon = (styleName == null) ? 0 : styleName.indexOf(&#39;;&#39;);
 942             if (semicolon &gt; 0)
 943                 styleName = styleName.substring(0, semicolon);
 944             definedStyles.put(Integer.valueOf(number), this);
 945             super.close();
 946         }
 947 
 948         public boolean handleKeyword(String keyword)
 949         {
 950             if (keyword.equals(&quot;additive&quot;)) {
 951                 additive = true;
 952                 return true;
 953             }
 954             if (keyword.equals(&quot;shidden&quot;)) {
 955                 hidden = true;
 956                 return true;
 957             }
 958             return super.handleKeyword(keyword);
 959         }
 960 
 961         public boolean handleKeyword(String keyword, int parameter)
 962         {
 963             if (keyword.equals(&quot;s&quot;)) {
 964                 characterStyle = false;
 965                 sectionStyle = false;
 966                 number = parameter;
 967             } else if (keyword.equals(&quot;cs&quot;)) {
 968                 characterStyle = true;
 969                 sectionStyle = false;
 970                 number = parameter;
 971             } else if (keyword.equals(&quot;ds&quot;)) {
 972                 characterStyle = false;
 973                 sectionStyle = true;
 974                 number = parameter;
 975             } else if (keyword.equals(&quot;sbasedon&quot;)) {
 976                 basedOn = parameter;
 977             } else if (keyword.equals(&quot;snext&quot;)) {
 978                 nextStyle = parameter;
 979             } else {
 980                 return super.handleKeyword(keyword, parameter);
 981             }
 982             return true;
 983         }
 984 
 985         public Style realize()
 986         {
 987             Style basis = null;
 988             Style next = null;
 989 
 990             if (realizedStyle != null)
 991                 return realizedStyle;
 992 
 993             if (basedOn != STYLENUMBER_NONE) {
 994                 StyleDefiningDestination styleDest;
 995                 styleDest = definedStyles.get(Integer.valueOf(basedOn));
 996                 if (styleDest != null &amp;&amp; styleDest != this) {
 997                     basis = styleDest.realize();
 998                 }
 999             }
1000 
1001             /* NB: Swing StyleContext doesn&#39;t allow distinct styles with
1002                the same name; RTF apparently does. This may confuse the
1003                user. */
1004             realizedStyle = target.addStyle(styleName, basis);
1005 
1006             if (characterStyle) {
1007                 realizedStyle.addAttributes(currentTextAttributes());
1008                 realizedStyle.addAttribute(Constants.StyleType,
1009                                            Constants.STCharacter);
1010             } else if (sectionStyle) {
1011                 realizedStyle.addAttributes(currentSectionAttributes());
1012                 realizedStyle.addAttribute(Constants.StyleType,
1013                                            Constants.STSection);
1014             } else { /* must be a paragraph style */
1015                 realizedStyle.addAttributes(currentParagraphAttributes());
1016                 realizedStyle.addAttribute(Constants.StyleType,
1017                                            Constants.STParagraph);
1018             }
1019 
1020             if (nextStyle != STYLENUMBER_NONE) {
1021                 StyleDefiningDestination styleDest;
1022                 styleDest = definedStyles.get(Integer.valueOf(nextStyle));
1023                 if (styleDest != null) {
1024                     next = styleDest.realize();
1025                 }
1026             }
1027 
1028             if (next != null)
1029                 realizedStyle.addAttribute(Constants.StyleNext, next);
1030             realizedStyle.addAttribute(Constants.StyleAdditive,
1031                                        Boolean.valueOf(additive));
1032             realizedStyle.addAttribute(Constants.StyleHidden,
1033                                        Boolean.valueOf(hidden));
1034 
1035             return realizedStyle;
1036         }
1037     }
1038 }
1039 
1040 /** Handles the info group. Currently no info keywords are recognized
1041  *  so this is a subclass of DiscardingDestination. */
1042 class InfoDestination
1043     extends DiscardingDestination
1044     implements Destination
1045 {
1046 }
1047 
1048 /** RTFReader.TextHandlingDestination is an abstract RTF destination
1049  *  which simply tracks the attributes specified by the RTF control words
1050  *  in internal form and can produce acceptable AttributeSets for the
1051  *  current character, paragraph, and section attributes. It is up
1052  *  to the subclasses to determine what is done with the actual text. */
1053 abstract class AttributeTrackingDestination implements Destination
1054 {
1055     /** This is the &quot;chr&quot; element of parserState, cached for
1056      *  more efficient use */
1057     MutableAttributeSet characterAttributes;
1058     /** This is the &quot;pgf&quot; element of parserState, cached for
1059      *  more efficient use */
1060     MutableAttributeSet paragraphAttributes;
1061     /** This is the &quot;sec&quot; element of parserState, cached for
1062      *  more efficient use */
1063     MutableAttributeSet sectionAttributes;
1064 
1065     public AttributeTrackingDestination()
1066     {
1067         characterAttributes = rootCharacterAttributes();
1068         parserState.put(&quot;chr&quot;, characterAttributes);
1069         paragraphAttributes = rootParagraphAttributes();
1070         parserState.put(&quot;pgf&quot;, paragraphAttributes);
1071         sectionAttributes = rootSectionAttributes();
1072         parserState.put(&quot;sec&quot;, sectionAttributes);
1073     }
1074 
1075     public abstract void handleText(String text);
1076 
1077     public void handleBinaryBlob(byte[] data)
1078     {
1079         /* This should really be in TextHandlingDestination, but
1080          * since *nobody* does anything with binary blobs, this
1081          * is more convenient. */
1082         warning(&quot;Unexpected binary data in RTF file.&quot;);
1083     }
1084 
1085     public void begingroup()
1086     {
1087         AttributeSet characterParent = currentTextAttributes();
1088         AttributeSet paragraphParent = currentParagraphAttributes();
1089         AttributeSet sectionParent = currentSectionAttributes();
1090 
1091         /* It would probably be more efficient to use the
1092          * resolver property of the attributes set for
1093          * implementing rtf groups,
1094          * but that&#39;s needed for styles. */
1095 
1096         /* update the cached attribute dictionaries */
1097         characterAttributes = new SimpleAttributeSet();
1098         characterAttributes.addAttributes(characterParent);
1099         parserState.put(&quot;chr&quot;, characterAttributes);
1100 
1101         paragraphAttributes = new SimpleAttributeSet();
1102         paragraphAttributes.addAttributes(paragraphParent);
1103         parserState.put(&quot;pgf&quot;, paragraphAttributes);
1104 
1105         sectionAttributes = new SimpleAttributeSet();
1106         sectionAttributes.addAttributes(sectionParent);
1107         parserState.put(&quot;sec&quot;, sectionAttributes);
1108     }
1109 
1110     public void endgroup(Dictionary&lt;Object, Object&gt; oldState)
1111     {
1112         characterAttributes = (MutableAttributeSet)parserState.get(&quot;chr&quot;);
1113         paragraphAttributes = (MutableAttributeSet)parserState.get(&quot;pgf&quot;);
1114         sectionAttributes   = (MutableAttributeSet)parserState.get(&quot;sec&quot;);
1115     }
1116 
1117     public void close()
1118     {
1119     }
1120 
1121     public boolean handleKeyword(String keyword)
1122     {
1123         if (keyword.equals(&quot;ulnone&quot;)) {
1124             return handleKeyword(&quot;ul&quot;, 0);
1125         }
1126 
1127         {
1128             RTFAttribute attr = straightforwardAttributes.get(keyword);
1129             if (attr != null) {
1130                 boolean ok;
1131 
1132                 switch(attr.domain()) {
1133                   case RTFAttribute.D_CHARACTER:
1134                     ok = attr.set(characterAttributes);
1135                     break;
1136                   case RTFAttribute.D_PARAGRAPH:
1137                     ok = attr.set(paragraphAttributes);
1138                     break;
1139                   case RTFAttribute.D_SECTION:
1140                     ok = attr.set(sectionAttributes);
1141                     break;
1142                   case RTFAttribute.D_META:
1143                     mockery.backing = parserState;
1144                     ok = attr.set(mockery);
1145                     mockery.backing = null;
1146                     break;
1147                   case RTFAttribute.D_DOCUMENT:
1148                     ok = attr.set(documentAttributes);
1149                     break;
1150                   default:
1151                     /* should never happen */
1152                     ok = false;
1153                     break;
1154                 }
1155                 if (ok)
1156                     return true;
1157             }
1158         }
1159 
1160 
1161         if (keyword.equals(&quot;plain&quot;)) {
1162             resetCharacterAttributes();
1163             return true;
1164         }
1165 
1166         if (keyword.equals(&quot;pard&quot;)) {
1167             resetParagraphAttributes();
1168             return true;
1169         }
1170 
1171         if (keyword.equals(&quot;sectd&quot;)) {
1172             resetSectionAttributes();
1173             return true;
1174         }
1175 
1176         return false;
1177     }
1178 
1179     public boolean handleKeyword(String keyword, int parameter)
1180     {
1181         boolean booleanParameter = (parameter != 0);
1182 
1183         if (keyword.equals(&quot;fc&quot;))
1184             keyword = &quot;cf&quot;; /* whatEVER, dude. */
1185 
1186         if (keyword.equals(&quot;f&quot;)) {
1187             parserState.put(keyword, Integer.valueOf(parameter));
1188             return true;
1189         }
1190         if (keyword.equals(&quot;cf&quot;)) {
1191             parserState.put(keyword, Integer.valueOf(parameter));
1192             return true;
1193         }
1194         if (keyword.equals(&quot;cb&quot;)) {
1195             parserState.put(keyword, Integer.valueOf(parameter));
1196             return true;
1197         }
1198 
1199         {
1200             RTFAttribute attr = straightforwardAttributes.get(keyword);
1201             if (attr != null) {
1202                 boolean ok;
1203 
1204                 switch(attr.domain()) {
1205                   case RTFAttribute.D_CHARACTER:
1206                     ok = attr.set(characterAttributes, parameter);
1207                     break;
1208                   case RTFAttribute.D_PARAGRAPH:
1209                     ok = attr.set(paragraphAttributes, parameter);
1210                     break;
1211                   case RTFAttribute.D_SECTION:
1212                     ok = attr.set(sectionAttributes, parameter);
1213                     break;
1214                   case RTFAttribute.D_META:
1215                     mockery.backing = parserState;
1216                     ok = attr.set(mockery, parameter);
1217                     mockery.backing = null;
1218                     break;
1219                   case RTFAttribute.D_DOCUMENT:
1220                     ok = attr.set(documentAttributes, parameter);
1221                     break;
1222                   default:
1223                     /* should never happen */
1224                     ok = false;
1225                     break;
1226                 }
1227                 if (ok)
1228                     return true;
1229             }
1230         }
1231 
1232         if (keyword.equals(&quot;fs&quot;)) {
1233             StyleConstants.setFontSize(characterAttributes, (parameter / 2));
1234             return true;
1235         }
1236 
1237         /* TODO: superscript/subscript */
1238 
1239         if (keyword.equals(&quot;sl&quot;)) {
1240             if (parameter == 1000) {  /* magic value! */
1241                 characterAttributes.removeAttribute(StyleConstants.LineSpacing);
1242             } else {
1243                 /* TODO: The RTF sl attribute has special meaning if it&#39;s
1244                    negative. Make sure that SwingText has the same special
1245                    meaning, or find a way to imitate that. When SwingText
1246                    handles this, also recognize the slmult keyword. */
1247                 StyleConstants.setLineSpacing(characterAttributes,
1248                                               parameter / 20f);
1249             }
1250             return true;
1251         }
1252 
1253         /* TODO: Other kinds of underlining */
1254 
1255         if (keyword.equals(&quot;tx&quot;) || keyword.equals(&quot;tb&quot;)) {
1256             float tabPosition = parameter / 20f;
1257             int tabAlignment, tabLeader;
1258             Number item;
1259 
1260             tabAlignment = TabStop.ALIGN_LEFT;
1261             item = (Number)(parserState.get(&quot;tab_alignment&quot;));
1262             if (item != null)
1263                 tabAlignment = item.intValue();
1264             tabLeader = TabStop.LEAD_NONE;
1265             item = (Number)(parserState.get(&quot;tab_leader&quot;));
1266             if (item != null)
1267                 tabLeader = item.intValue();
1268             if (keyword.equals(&quot;tb&quot;))
1269                 tabAlignment = TabStop.ALIGN_BAR;
1270 
1271             parserState.remove(&quot;tab_alignment&quot;);
1272             parserState.remove(&quot;tab_leader&quot;);
1273 
1274             TabStop newStop = new TabStop(tabPosition, tabAlignment, tabLeader);
1275             Dictionary&lt;Object, Object&gt; tabs;
1276             Integer stopCount;
1277 
1278             @SuppressWarnings(&quot;unchecked&quot;)
1279             Dictionary&lt;Object, Object&gt;tmp = (Dictionary)parserState.get(&quot;_tabs&quot;);
1280             tabs = tmp;
1281             if (tabs == null) {
1282                 tabs = new Hashtable&lt;Object, Object&gt;();
1283                 parserState.put(&quot;_tabs&quot;, tabs);
1284                 stopCount = Integer.valueOf(1);
1285             } else {
1286                 stopCount = (Integer)tabs.get(&quot;stop count&quot;);
1287                 stopCount = Integer.valueOf(1 + stopCount.intValue());
1288             }
1289             tabs.put(stopCount, newStop);
1290             tabs.put(&quot;stop count&quot;, stopCount);
1291             parserState.remove(&quot;_tabs_immutable&quot;);
1292 
1293             return true;
1294         }
1295 
1296         if (keyword.equals(&quot;s&quot;) &amp;&amp;
1297             paragraphStyles != null) {
1298             parserState.put(&quot;paragraphStyle&quot;, paragraphStyles[parameter]);
1299             return true;
1300         }
1301 
1302         if (keyword.equals(&quot;cs&quot;) &amp;&amp;
1303             characterStyles != null) {
1304             parserState.put(&quot;characterStyle&quot;, characterStyles[parameter]);
1305             return true;
1306         }
1307 
1308         if (keyword.equals(&quot;ds&quot;) &amp;&amp;
1309             sectionStyles != null) {
1310             parserState.put(&quot;sectionStyle&quot;, sectionStyles[parameter]);
1311             return true;
1312         }
1313 
1314         return false;
1315     }
1316 
1317     /** Returns a new MutableAttributeSet containing the
1318      *  default character attributes */
1319     protected MutableAttributeSet rootCharacterAttributes()
1320     {
1321         MutableAttributeSet set = new SimpleAttributeSet();
1322 
1323         /* TODO: default font */
1324 
1325         StyleConstants.setItalic(set, false);
1326         StyleConstants.setBold(set, false);
1327         StyleConstants.setUnderline(set, false);
1328         StyleConstants.setForeground(set, defaultColor());
1329 
1330         return set;
1331     }
1332 
1333     /** Returns a new MutableAttributeSet containing the
1334      *  default paragraph attributes */
1335     protected MutableAttributeSet rootParagraphAttributes()
1336     {
1337         MutableAttributeSet set = new SimpleAttributeSet();
1338 
1339         StyleConstants.setLeftIndent(set, 0f);
1340         StyleConstants.setRightIndent(set, 0f);
1341         StyleConstants.setFirstLineIndent(set, 0f);
1342 
1343         /* TODO: what should this be, really? */
1344         set.setResolveParent(target.getStyle(StyleContext.DEFAULT_STYLE));
1345 
1346         return set;
1347     }
1348 
1349     /** Returns a new MutableAttributeSet containing the
1350      *  default section attributes */
1351     protected MutableAttributeSet rootSectionAttributes()
1352     {
1353         MutableAttributeSet set = new SimpleAttributeSet();
1354 
1355         return set;
1356     }
1357 
1358     /**
1359      * Calculates the current text (character) attributes in a form suitable
1360      * for SwingText from the current parser state.
1361      *
1362      * @return a new MutableAttributeSet containing the text attributes.
1363      */
1364     MutableAttributeSet currentTextAttributes()
1365     {
1366         MutableAttributeSet attributes =
1367             new SimpleAttributeSet(characterAttributes);
1368         Integer fontnum;
1369         Integer stateItem;
1370 
1371         /* figure out the font name */
1372         /* TODO: catch exceptions for undefined attributes,
1373            bad font indices, etc.? (as it stands, it is the caller&#39;s
1374            job to clean up after corrupt RTF) */
1375         fontnum = (Integer)parserState.get(&quot;f&quot;);
1376         /* note setFontFamily() can not handle a null font */
1377         String fontFamily;
1378         if (fontnum != null)
1379             fontFamily = fontTable.get(fontnum);
1380         else
1381             fontFamily = null;
1382         if (fontFamily != null)
1383             StyleConstants.setFontFamily(attributes, fontFamily);
1384         else
1385             attributes.removeAttribute(StyleConstants.FontFamily);
1386 
1387         if (colorTable != null) {
1388             stateItem = (Integer)parserState.get(&quot;cf&quot;);
1389             if (stateItem != null) {
1390                 Color fg = colorTable[stateItem.intValue()];
1391                 StyleConstants.setForeground(attributes, fg);
1392             } else {
1393                 /* AttributeSet dies if you set a value to null */
1394                 attributes.removeAttribute(StyleConstants.Foreground);
1395             }
1396         }
1397 
1398         if (colorTable != null) {
1399             stateItem = (Integer)parserState.get(&quot;cb&quot;);
1400             if (stateItem != null) {
1401                 Color bg = colorTable[stateItem.intValue()];
1402                 attributes.addAttribute(StyleConstants.Background,
1403                                         bg);
1404             } else {
1405                 /* AttributeSet dies if you set a value to null */
1406                 attributes.removeAttribute(StyleConstants.Background);
1407             }
1408         }
1409 
1410         Style characterStyle = (Style)parserState.get(&quot;characterStyle&quot;);
1411         if (characterStyle != null)
1412             attributes.setResolveParent(characterStyle);
1413 
1414         /* Other attributes are maintained directly in &quot;attributes&quot; */
1415 
1416         return attributes;
1417     }
1418 
1419     /**
1420      * Calculates the current paragraph attributes (with keys
1421      * as given in StyleConstants) from the current parser state.
1422      *
1423      * @return a newly created MutableAttributeSet.
1424      * @see StyleConstants
1425      */
1426     MutableAttributeSet currentParagraphAttributes()
1427     {
1428         /* NB if there were a mutableCopy() method we should use it */
1429         MutableAttributeSet bld = new SimpleAttributeSet(paragraphAttributes);
1430 
1431         Integer stateItem;
1432 
1433         /*** Tab stops ***/
1434         TabStop[] tabs;
1435 
1436         tabs = (TabStop[])parserState.get(&quot;_tabs_immutable&quot;);
1437         if (tabs == null) {
1438             @SuppressWarnings(&quot;unchecked&quot;)
1439             Dictionary&lt;Object, Object&gt; workingTabs = (Dictionary)parserState.get(&quot;_tabs&quot;);
1440             if (workingTabs != null) {
1441                 int count = ((Integer)workingTabs.get(&quot;stop count&quot;)).intValue();
1442                 tabs = new TabStop[count];
1443                 for (int ix = 1; ix &lt;= count; ix ++)
1444                     tabs[ix-1] = (TabStop)workingTabs.get(Integer.valueOf(ix));
1445                 parserState.put(&quot;_tabs_immutable&quot;, tabs);
1446             }
1447         }
1448         if (tabs != null)
1449             bld.addAttribute(Constants.Tabs, tabs);
1450 
1451         Style paragraphStyle = (Style)parserState.get(&quot;paragraphStyle&quot;);
1452         if (paragraphStyle != null)
1453             bld.setResolveParent(paragraphStyle);
1454 
1455         return bld;
1456     }
1457 
1458     /**
1459      * Calculates the current section attributes
1460      * from the current parser state.
1461      *
1462      * @return a newly created MutableAttributeSet.
1463      */
1464     public AttributeSet currentSectionAttributes()
1465     {
1466         MutableAttributeSet attributes = new SimpleAttributeSet(sectionAttributes);
1467 
1468         Style sectionStyle = (Style)parserState.get(&quot;sectionStyle&quot;);
1469         if (sectionStyle != null)
1470             attributes.setResolveParent(sectionStyle);
1471 
1472         return attributes;
1473     }
1474 
1475     /** Resets the filter&#39;s internal notion of the current character
1476      *  attributes to their default values. Invoked to handle the
1477      *  \plain keyword. */
1478     protected void resetCharacterAttributes()
1479     {
1480         handleKeyword(&quot;f&quot;, 0);
1481         handleKeyword(&quot;cf&quot;, 0);
1482 
1483         handleKeyword(&quot;fs&quot;, 24);  /* 12 pt. */
1484 
1485         Enumeration&lt;RTFAttribute&gt; attributes = straightforwardAttributes.elements();
1486         while(attributes.hasMoreElements()) {
1487             RTFAttribute attr = attributes.nextElement();
1488             if (attr.domain() == RTFAttribute.D_CHARACTER)
1489                 attr.setDefault(characterAttributes);
1490         }
1491 
1492         handleKeyword(&quot;sl&quot;, 1000);
1493 
1494         parserState.remove(&quot;characterStyle&quot;);
1495     }
1496 
1497     /** Resets the filter&#39;s internal notion of the current paragraph&#39;s
1498      *  attributes to their default values. Invoked to handle the
1499      *  \pard keyword. */
1500     protected void resetParagraphAttributes()
1501     {
1502         parserState.remove(&quot;_tabs&quot;);
1503         parserState.remove(&quot;_tabs_immutable&quot;);
1504         parserState.remove(&quot;paragraphStyle&quot;);
1505 
1506         StyleConstants.setAlignment(paragraphAttributes,
1507                                     StyleConstants.ALIGN_LEFT);
1508 
1509         Enumeration&lt;RTFAttribute&gt; attributes = straightforwardAttributes.elements();
1510         while(attributes.hasMoreElements()) {
1511             RTFAttribute attr = attributes.nextElement();
1512             if (attr.domain() == RTFAttribute.D_PARAGRAPH)
1513                 attr.setDefault(characterAttributes);
1514         }
1515     }
1516 
1517     /** Resets the filter&#39;s internal notion of the current section&#39;s
1518      *  attributes to their default values. Invoked to handle the
1519      *  \sectd keyword. */
1520     protected void resetSectionAttributes()
1521     {
1522         Enumeration&lt;RTFAttribute&gt; attributes = straightforwardAttributes.elements();
1523         while(attributes.hasMoreElements()) {
1524             RTFAttribute attr = attributes.nextElement();
1525             if (attr.domain() == RTFAttribute.D_SECTION)
1526                 attr.setDefault(characterAttributes);
1527         }
1528 
1529         parserState.remove(&quot;sectionStyle&quot;);
1530     }
1531 }
1532 
1533 /** RTFReader.TextHandlingDestination provides basic text handling
1534  *  functionality. Subclasses must implement: &lt;dl&gt;
1535  *  &lt;dt&gt;deliverText()&lt;dd&gt;to handle a run of text with the same
1536  *                       attributes
1537  *  &lt;dt&gt;finishParagraph()&lt;dd&gt;to end the current paragraph and
1538  *                           set the paragraph&#39;s attributes
1539  *  &lt;dt&gt;endSection()&lt;dd&gt;to end the current section
1540  *  &lt;/dl&gt;
1541  */
1542 abstract class TextHandlingDestination
1543     extends AttributeTrackingDestination
1544     implements Destination
1545 {
1546     /** &lt;code&gt;true&lt;/code&gt; if the reader has not just finished
1547      *  a paragraph; false upon startup */
1548     boolean inParagraph;
1549 
1550     public TextHandlingDestination()
1551     {
1552         super();
1553         inParagraph = false;
1554     }
1555 
1556     public void handleText(String text)
1557     {
1558         if (! inParagraph)
1559             beginParagraph();
1560 
1561         deliverText(text, currentTextAttributes());
1562     }
1563 
1564     abstract void deliverText(String text, AttributeSet characterAttributes);
1565 
1566     public void close()
1567     {
1568         if (inParagraph)
1569             endParagraph();
1570 
1571         super.close();
1572     }
1573 
1574     public boolean handleKeyword(String keyword)
1575     {
1576         if (keyword.equals(&quot;\r&quot;) || keyword.equals(&quot;\n&quot;)) {
1577             keyword = &quot;par&quot;;
1578         }
1579 
1580         if (keyword.equals(&quot;par&quot;)) {
1581 //          warnings.println(&quot;Ending paragraph.&quot;);
1582             endParagraph();
1583             return true;
1584         }
1585 
1586         if (keyword.equals(&quot;sect&quot;)) {
1587 //          warnings.println(&quot;Ending section.&quot;);
1588             endSection();
1589             return true;
1590         }
1591 
1592         return super.handleKeyword(keyword);
1593     }
1594 
1595     protected void beginParagraph()
1596     {
1597         inParagraph = true;
1598     }
1599 
1600     protected void endParagraph()
1601     {
1602         AttributeSet pgfAttributes = currentParagraphAttributes();
1603         AttributeSet chrAttributes = currentTextAttributes();
1604         finishParagraph(pgfAttributes, chrAttributes);
1605         inParagraph = false;
1606     }
1607 
1608     abstract void finishParagraph(AttributeSet pgfA, AttributeSet chrA);
1609 
1610     abstract void endSection();
1611 }
1612 
1613 /** RTFReader.DocumentDestination is a concrete subclass of
1614  *  TextHandlingDestination which appends the text to the
1615  *  StyledDocument given by the &lt;code&gt;target&lt;/code&gt; ivar of the
1616  *  containing RTFReader.
1617  */
1618 class DocumentDestination
1619     extends TextHandlingDestination
1620     implements Destination
1621 {
1622     public void deliverText(String text, AttributeSet characterAttributes)
1623     {
1624         try {
1625             target.insertString(target.getLength(),
1626                                 text,
1627                                 currentTextAttributes());
1628         } catch (BadLocationException ble) {
1629             /* This shouldn&#39;t be able to happen, of course */
1630             /* TODO is InternalError the correct error to throw? */
1631             throw new InternalError(ble.getMessage(), ble);
1632         }
1633     }
1634 
1635     public void finishParagraph(AttributeSet pgfAttributes,
1636                                 AttributeSet chrAttributes)
1637     {
1638         int pgfEndPosition = target.getLength();
1639         try {
1640             target.insertString(pgfEndPosition, &quot;\n&quot;, chrAttributes);
1641             target.setParagraphAttributes(pgfEndPosition, 1, pgfAttributes, true);
1642         } catch (BadLocationException ble) {
1643             /* This shouldn&#39;t be able to happen, of course */
1644             /* TODO is InternalError the correct error to throw? */
1645             throw new InternalError(ble.getMessage(), ble);
1646         }
1647     }
1648 
1649     public void endSection()
1650     {
1651         /* If we implemented sections, we&#39;d end &#39;em here */
1652     }
1653 }
1654 
1655 }
    </pre>
  </body>
</html>
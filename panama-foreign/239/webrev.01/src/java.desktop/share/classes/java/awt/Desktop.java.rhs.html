<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/java/awt/Desktop.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.awt;
  27 
  28 import java.awt.desktop.AboutEvent;
  29 import java.awt.desktop.AboutHandler;
  30 import java.awt.desktop.OpenFilesHandler;
  31 import java.awt.desktop.OpenURIEvent;
  32 import java.awt.desktop.OpenURIHandler;
  33 import java.awt.desktop.PreferencesEvent;
  34 import java.awt.desktop.PreferencesHandler;
  35 import java.awt.desktop.PrintFilesHandler;
  36 import java.awt.desktop.QuitHandler;
  37 import java.awt.desktop.QuitStrategy;
  38 import java.awt.desktop.SystemEventListener;
  39 import java.awt.peer.DesktopPeer;
  40 import java.io.File;
  41 import java.io.FilePermission;
  42 import java.io.IOException;
  43 import java.net.URI;
  44 import java.net.URISyntaxException;
  45 import java.security.AccessController;
  46 import java.security.PrivilegedAction;
  47 import java.util.Objects;
  48 
  49 import javax.swing.JMenuBar;
  50 
  51 import sun.awt.SunToolkit;
  52 import sun.security.util.SecurityConstants;
  53 
  54 /**
  55  * The {@code Desktop} class allows interact with various desktop capabilities.
  56  *
  57  * &lt;p&gt; Supported operations include:
  58  * &lt;ul&gt;
  59  *   &lt;li&gt;launching the user-default browser to show a specified
  60  *       URI;&lt;/li&gt;
  61  *   &lt;li&gt;launching the user-default mail client with an optional
  62  *       {@code mailto} URI;&lt;/li&gt;
  63  *   &lt;li&gt;launching a registered application to open, edit or print a
  64  *       specified file.&lt;/li&gt;
  65  * &lt;/ul&gt;
  66  *
  67  * &lt;p&gt; This class provides methods corresponding to these
  68  * operations. The methods look for the associated application
  69  * registered on the current platform, and launch it to handle a URI
  70  * or file. If there is no associated application or the associated
  71  * application fails to be launched, an exception is thrown.
  72  *
  73  * Please see {@link Desktop.Action} for the full list of supported operations
  74  * and capabilities.
  75  *
  76  * &lt;p&gt; An application is registered to a URI or file type.
  77  * The mechanism of registering, accessing, and
  78  * launching the associated application is platform-dependent.
  79  *
  80  * &lt;p&gt; Each operation is an action type represented by the {@link
  81  * Desktop.Action} class.
  82  *
  83  * &lt;p&gt; Note: when some action is invoked and the associated
  84  * application is executed, it will be executed on the same system as
  85  * the one on which the Java application was launched.
  86  *
  87  * @see Action
  88  *
  89  * @since 1.6
  90  * @author Armin Chen
  91  * @author George Zhang
  92  */
  93 public class Desktop {
  94 
  95     /**
  96      * Represents an action type.  Each platform supports a different
  97      * set of actions.  You may use the {@link Desktop#isSupported}
  98      * method to determine if the given action is supported by the
  99      * current platform.
 100      * @see java.awt.Desktop#isSupported(java.awt.Desktop.Action)
 101      * @since 1.6
 102      */
 103     public static enum Action {
 104         /**
 105          * Represents an &quot;open&quot; action.
 106          * @see Desktop#open(java.io.File)
 107          */
 108         OPEN,
 109         /**
 110          * Represents an &quot;edit&quot; action.
 111          * @see Desktop#edit(java.io.File)
 112          */
 113         EDIT,
 114         /**
 115          * Represents a &quot;print&quot; action.
 116          * @see Desktop#print(java.io.File)
 117          */
 118         PRINT,
 119         /**
 120          * Represents a &quot;mail&quot; action.
 121          * @see Desktop#mail()
 122          * @see Desktop#mail(java.net.URI)
 123          */
 124         MAIL,
 125 
 126         /**
 127          * Represents a &quot;browse&quot; action.
 128          * @see Desktop#browse(java.net.URI)
 129          */
 130         BROWSE,
 131 
 132         /**
 133          * Represents an AppForegroundListener
 134          * @see java.awt.desktop.AppForegroundListener
 135          * @since 9
 136          */
 137         APP_EVENT_FOREGROUND,
 138 
 139         /**
 140          * Represents an AppHiddenListener
 141          * @see java.awt.desktop.AppHiddenListener
 142          * @since 9
 143          */
 144         APP_EVENT_HIDDEN,
 145 
 146         /**
 147          * Represents an AppReopenedListener
 148          * @see java.awt.desktop.AppReopenedListener
 149          * @since 9
 150          */
 151         APP_EVENT_REOPENED,
 152 
 153         /**
 154          * Represents a ScreenSleepListener
 155          * @see java.awt.desktop.ScreenSleepListener
 156          * @since 9
 157          */
 158         APP_EVENT_SCREEN_SLEEP,
 159 
 160         /**
 161          * Represents a SystemSleepListener
 162          * @see java.awt.desktop.SystemSleepListener
 163          * @since 9
 164          */
 165         APP_EVENT_SYSTEM_SLEEP,
 166 
 167         /**
 168          * Represents a UserSessionListener
 169          * @see java.awt.desktop.UserSessionListener
 170          * @since 9
 171          */
 172         APP_EVENT_USER_SESSION,
 173 
 174         /**
 175          * Represents an AboutHandler
 176          * @see #setAboutHandler(java.awt.desktop.AboutHandler)
 177          * @since 9
 178          */
 179         APP_ABOUT,
 180 
 181         /**
 182          * Represents a PreferencesHandler
 183          * @see #setPreferencesHandler(java.awt.desktop.PreferencesHandler)
 184          * @since 9
 185          */
 186         APP_PREFERENCES,
 187 
 188         /**
 189          * Represents an OpenFilesHandler
 190          * @see #setOpenFileHandler(java.awt.desktop.OpenFilesHandler)
 191          * @since 9
 192          */
 193         APP_OPEN_FILE,
 194 
 195         /**
 196          * Represents a PrintFilesHandler
 197          * @see #setPrintFileHandler(java.awt.desktop.PrintFilesHandler)
 198          * @since 9
 199          */
 200         APP_PRINT_FILE,
 201 
 202         /**
 203          * Represents an OpenURIHandler
 204          * @see #setOpenURIHandler(java.awt.desktop.OpenURIHandler)
 205          * @since 9
 206          */
 207         APP_OPEN_URI,
 208 
 209         /**
 210          * Represents a QuitHandler
 211          * @see #setQuitHandler(java.awt.desktop.QuitHandler)
 212          * @since 9
 213          */
 214         APP_QUIT_HANDLER,
 215 
 216         /**
 217          * Represents a QuitStrategy
 218          * @see #setQuitStrategy(java.awt.desktop.QuitStrategy)
 219          * @since 9
 220          */
 221         APP_QUIT_STRATEGY,
 222 
 223         /**
 224          * Represents a SuddenTermination
 225          * @see #enableSuddenTermination()
 226          * @since 9
 227          */
 228         APP_SUDDEN_TERMINATION,
 229 
 230         /**
 231          * Represents a requestForeground
 232          * @see #requestForeground(boolean)
 233          * @since 9
 234          */
 235         APP_REQUEST_FOREGROUND,
 236 
 237         /**
 238          * Represents a HelpViewer
 239          * @see #openHelpViewer()
 240          * @since 9
 241          */
 242         APP_HELP_VIEWER,
 243 
 244         /**
 245          * Represents a menu bar
 246          * @see #setDefaultMenuBar(javax.swing.JMenuBar)
 247          * @since 9
 248          */
 249         APP_MENU_BAR,
 250 
 251         /**
 252          * Represents a browse file directory
 253          * @see #browseFileDirectory(java.io.File)
 254          * @since 9
 255          */
 256         BROWSE_FILE_DIR,
 257 
 258         /**
 259          * Represents a move to trash
 260          * @see #moveToTrash(java.io.File)
 261          * @since 9
 262          */
 263         MOVE_TO_TRASH
 264     };
 265 
 266     private DesktopPeer peer;
 267 
 268     /**
 269      * Suppresses default constructor for noninstantiability.
 270      */
 271     private Desktop() {
 272         Toolkit defaultToolkit = Toolkit.getDefaultToolkit();
 273         // same cast as in isDesktopSupported()
 274         if (defaultToolkit instanceof SunToolkit) {
 275             peer = ((SunToolkit) defaultToolkit).createDesktopPeer(this);
 276         }
 277     }
 278 
 279     private void checkEventsProcessingPermission() {
 280         SecurityManager sm = System.getSecurityManager();
 281         if (sm != null) {
 282             sm.checkPermission(new RuntimePermission(
 283                     &quot;canProcessApplicationEvents&quot;));
 284         }
 285     }
 286 
 287     /**
 288      * Returns the {@code Desktop} instance of the current
 289      * desktop context. On some platforms the Desktop API may not be
 290      * supported; use the {@link #isDesktopSupported} method to
 291      * determine if the current desktop is supported.
 292      * @return the Desktop instance
 293      * @throws HeadlessException if {@link
 294      * GraphicsEnvironment#isHeadless()} returns {@code true}
 295      * @throws UnsupportedOperationException if this class is not
 296      * supported on the current platform
 297      * @see #isDesktopSupported()
 298      * @see java.awt.GraphicsEnvironment#isHeadless
 299      */
 300     public static synchronized Desktop getDesktop(){
 301         if (GraphicsEnvironment.isHeadless()) throw new HeadlessException();
 302         if (!Desktop.isDesktopSupported()) {
 303             throw new UnsupportedOperationException(&quot;Desktop API is not &quot; +
 304                                                     &quot;supported on the current platform&quot;);
 305         }
 306 
 307         sun.awt.AppContext context = sun.awt.AppContext.getAppContext();
 308         Desktop desktop = (Desktop)context.get(Desktop.class);
 309 
 310         if (desktop == null) {
 311             desktop = new Desktop();
 312             context.put(Desktop.class, desktop);
 313         }
 314 
 315         return desktop;
 316     }
 317 
 318     /**
 319      * Tests whether this class is supported on the current platform.
 320      * If it&#39;s supported, use {@link #getDesktop()} to retrieve an
 321      * instance.
 322      *
 323      * @return {@code true} if this class is supported on the
 324      *         current platform; {@code false} otherwise
 325      * @see #getDesktop()
 326      */
 327     public static boolean isDesktopSupported(){
 328         Toolkit defaultToolkit = Toolkit.getDefaultToolkit();
 329         if (defaultToolkit instanceof SunToolkit) {
 330             return ((SunToolkit)defaultToolkit).isDesktopSupported();
 331         }
 332         return false;
 333     }
 334 
 335     /**
 336      * Tests whether an action is supported on the current platform.
 337      *
 338      * &lt;p&gt;Even when the platform supports an action, a file or URI may
 339      * not have a registered application for the action.  For example,
 340      * most of the platforms support the {@link Desktop.Action#OPEN}
 341      * action.  But for a specific file, there may not be an
 342      * application registered to open it.  In this case, {@link
 343      * #isSupported(Action)} may return {@code true}, but the corresponding
 344      * action method will throw an {@link IOException}.
 345      *
 346      * @param action the specified {@link Action}
 347      * @return {@code true} if the specified action is supported on
 348      *         the current platform; {@code false} otherwise
 349      * @see Desktop.Action
 350      */
 351     public boolean isSupported(Action action) {
 352         return peer.isSupported(action);
 353     }
 354 
 355     /**
 356      * Checks if the file is a valid file and readable.
 357      *
 358      * @throws SecurityException If a security manager exists and its
 359      *         {@link SecurityManager#checkRead(java.lang.String)} method
 360      *         denies read access to the file
 361      * @throws NullPointerException if file is null
 362      * @throws IllegalArgumentException if file doesn&#39;t exist
 363      */
 364     private static void checkFileValidation(File file) {
 365         if (!file.exists()) {
 366             throw new IllegalArgumentException(&quot;The file: &quot;
 367                     + file.getPath() + &quot; doesn&#39;t exist.&quot;);
 368         }
 369     }
 370 
 371     /**
 372      * Checks if the action type is supported.
 373      *
 374      * @param actionType the action type in question
 375      * @throws UnsupportedOperationException if the specified action type is not
 376      *         supported on the current platform
 377      */
 378     private void checkActionSupport(Action actionType){
 379         if (!isSupported(actionType)) {
 380             throw new UnsupportedOperationException(&quot;The &quot; + actionType.name()
 381                     + &quot; action is not supported on the current platform!&quot;);
 382         }
 383     }
 384 
 385 
 386     /**
 387      * Calls to the security manager&#39;s {@code checkPermission} method with an
 388      * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)} permission. This
 389      * permission is needed, because we cannot add a security warning icon to
 390      * the windows of the external native application.
 391      */
 392     private void checkAWTPermission() {
 393         SecurityManager sm = System.getSecurityManager();
 394         if (sm != null) {
 395             sm.checkPermission(new AWTPermission(
 396                     &quot;showWindowWithoutWarningBanner&quot;));
 397         }
 398     }
 399 
 400     /**
 401      * Launches the associated application to open the file.
 402      *
 403      * &lt;p&gt; If the specified file is a directory, the file manager of
 404      * the current platform is launched to open it.
 405      *
 406      * @param file the file to be opened with the associated application
 407      * @throws NullPointerException if {@code file} is {@code null}
 408      * @throws IllegalArgumentException if the specified file doesn&#39;t
 409      * exist
 410      * @throws UnsupportedOperationException if the current platform
 411      * does not support the {@link Desktop.Action#OPEN} action
 412      * @throws IOException if the specified file has no associated
 413      * application or the associated application fails to be launched
 414      * @throws SecurityException if a security manager exists and its
 415      * {@link java.lang.SecurityManager#checkRead(java.lang.String)}
 416      * method denies read access to the file, or it denies the
 417      * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}
 418      * permission, or the calling thread is not allowed to create a
 419      * subprocess
 420      * @see java.awt.AWTPermission
 421      */
 422     public void open(File file) throws IOException {
 423         file = new File(file.getPath());
 424         checkAWTPermission();
 425         checkExec();
 426         checkActionSupport(Action.OPEN);
 427         checkFileValidation(file);
 428 
 429         peer.open(file);
 430     }
 431 
 432     /**
 433      * Launches the associated editor application and opens a file for
 434      * editing.
 435      *
 436      * @param file the file to be opened for editing
 437      * @throws NullPointerException if the specified file is {@code null}
 438      * @throws IllegalArgumentException if the specified file doesn&#39;t
 439      * exist
 440      * @throws UnsupportedOperationException if the current platform
 441      * does not support the {@link Desktop.Action#EDIT} action
 442      * @throws IOException if the specified file has no associated
 443      * editor, or the associated application fails to be launched
 444      * @throws SecurityException if a security manager exists and its
 445      * {@link java.lang.SecurityManager#checkRead(java.lang.String)}
 446      * method denies read access to the file, or {@link
 447      * java.lang.SecurityManager#checkWrite(java.lang.String)} method
 448      * denies write access to the file, or it denies the
 449      * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}
 450      * permission, or the calling thread is not allowed to create a
 451      * subprocess
 452      * @see java.awt.AWTPermission
 453      */
 454     public void edit(File file) throws IOException {
 455         file = new File(file.getPath());
 456         checkAWTPermission();
 457         checkExec();
 458         checkActionSupport(Action.EDIT);
 459         file.canWrite();
 460         checkFileValidation(file);
<a name="2" id="anc2"></a><span class="line-modified"> 461         if (file.isDirectory()) {</span>
<span class="line-added"> 462             throw new IOException(file.getPath() + &quot; is a directory&quot;);</span>
<span class="line-added"> 463         }</span>
 464         peer.edit(file);
 465     }
 466 
 467     /**
 468      * Prints a file with the native desktop printing facility, using
 469      * the associated application&#39;s print command.
 470      *
 471      * @param file the file to be printed
 472      * @throws NullPointerException if the specified file is {@code
 473      * null}
 474      * @throws IllegalArgumentException if the specified file doesn&#39;t
 475      * exist
 476      * @throws UnsupportedOperationException if the current platform
 477      *         does not support the {@link Desktop.Action#PRINT} action
 478      * @throws IOException if the specified file has no associated
 479      * application that can be used to print it
 480      * @throws SecurityException if a security manager exists and its
 481      * {@link java.lang.SecurityManager#checkRead(java.lang.String)}
 482      * method denies read access to the file, or its {@link
 483      * java.lang.SecurityManager#checkPrintJobAccess()} method denies
 484      * the permission to print the file, or the calling thread is not
 485      * allowed to create a subprocess
 486      */
 487     public void print(File file) throws IOException {
 488         file = new File(file.getPath());
 489         checkExec();
 490         SecurityManager sm = System.getSecurityManager();
 491         if (sm != null) {
 492             sm.checkPrintJobAccess();
 493         }
 494         checkActionSupport(Action.PRINT);
 495         checkFileValidation(file);
<a name="3" id="anc3"></a><span class="line-modified"> 496         if (file.isDirectory()) {</span>
<span class="line-added"> 497             throw new IOException(file.getPath() + &quot; is a directory&quot;);</span>
<span class="line-added"> 498         }</span>
 499         peer.print(file);
 500     }
 501 
 502     /**
 503      * Launches the default browser to display a {@code URI}.
 504      * If the default browser is not able to handle the specified
 505      * {@code URI}, the application registered for handling
 506      * {@code URIs} of the specified type is invoked. The application
 507      * is determined from the protocol and path of the {@code URI}, as
 508      * defined by the {@code URI} class.
 509      *
 510      * @param uri the URI to be displayed in the user default browser
 511      * @throws NullPointerException if {@code uri} is {@code null}
 512      * @throws UnsupportedOperationException if the current platform
 513      * does not support the {@link Desktop.Action#BROWSE} action
 514      * @throws IOException if the user default browser is not found,
 515      * or it fails to be launched, or the default handler application
 516      * failed to be launched
 517      * @throws SecurityException if a security manager exists and it
 518      * denies the
 519      * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}
 520      * permission, or the calling thread is not allowed to create a
 521      * subprocess
 522      * @see java.net.URI
 523      * @see java.awt.AWTPermission
 524      */
 525     public void browse(URI uri) throws IOException {
 526         checkAWTPermission();
 527         checkExec();
 528         checkActionSupport(Action.BROWSE);
 529         Objects.requireNonNull(uri);
 530         peer.browse(uri);
 531     }
 532 
 533     /**
 534      * Launches the mail composing window of the user default mail
 535      * client.
 536      *
 537      * @throws UnsupportedOperationException if the current platform
 538      * does not support the {@link Desktop.Action#MAIL} action
 539      * @throws IOException if the user default mail client is not
 540      * found, or it fails to be launched
 541      * @throws SecurityException if a security manager exists and it
 542      * denies the
 543      * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}
 544      * permission, or the calling thread is not allowed to create a
 545      * subprocess
 546      * @see java.awt.AWTPermission
 547      */
 548     public void mail() throws IOException {
 549         checkAWTPermission();
 550         checkExec();
 551         checkActionSupport(Action.MAIL);
 552         URI mailtoURI = null;
 553         try{
 554             mailtoURI = new URI(&quot;mailto:?&quot;);
 555             peer.mail(mailtoURI);
 556         } catch (URISyntaxException e){
 557             // won&#39;t reach here.
 558         }
 559     }
 560 
 561     /**
 562      * Launches the mail composing window of the user default mail
 563      * client, filling the message fields specified by a {@code
 564      * mailto:} URI.
 565      *
 566      * &lt;p&gt; A {@code mailto:} URI can specify message fields
 567      * including &lt;i&gt;&quot;to&quot;&lt;/i&gt;, &lt;i&gt;&quot;cc&quot;&lt;/i&gt;, &lt;i&gt;&quot;subject&quot;&lt;/i&gt;,
 568      * &lt;i&gt;&quot;body&quot;&lt;/i&gt;, etc.  See &lt;a
 569      * href=&quot;http://www.ietf.org/rfc/rfc2368.txt&quot;&gt;The mailto URL
 570      * scheme (RFC 2368)&lt;/a&gt; for the {@code mailto:} URI specification
 571      * details.
 572      *
 573      * @param mailtoURI the specified {@code mailto:} URI
 574      * @throws NullPointerException if the specified URI is {@code
 575      * null}
 576      * @throws IllegalArgumentException if the URI scheme is not
 577      *         {@code &quot;mailto&quot;}
 578      * @throws UnsupportedOperationException if the current platform
 579      * does not support the {@link Desktop.Action#MAIL} action
 580      * @throws IOException if the user default mail client is not
 581      * found or fails to be launched
 582      * @throws SecurityException if a security manager exists and it
 583      * denies the
 584      * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}
 585      * permission, or the calling thread is not allowed to create a
 586      * subprocess
 587      * @see java.net.URI
 588      * @see java.awt.AWTPermission
 589      */
 590     public  void mail(URI mailtoURI) throws IOException {
 591         checkAWTPermission();
 592         checkExec();
 593         checkActionSupport(Action.MAIL);
 594         if (mailtoURI == null) throw new NullPointerException();
 595 
 596         if (!&quot;mailto&quot;.equalsIgnoreCase(mailtoURI.getScheme())) {
 597             throw new IllegalArgumentException(&quot;URI scheme is not \&quot;mailto\&quot;&quot;);
 598         }
 599 
 600         peer.mail(mailtoURI);
 601     }
 602 
 603     private void checkExec() throws SecurityException {
 604         SecurityManager sm = System.getSecurityManager();
 605         if (sm != null) {
 606             sm.checkPermission(new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;,
 607                     SecurityConstants.FILE_EXECUTE_ACTION));
 608         }
 609     }
 610 
 611     private void checkRead() throws SecurityException {
 612         SecurityManager sm = System.getSecurityManager();
 613         if (sm != null) {
 614             sm.checkPermission(new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;,
 615                     SecurityConstants.FILE_READ_ACTION));
 616         }
 617     }
 618 
 619     private void checkQuitPermission() {
 620         SecurityManager sm = System.getSecurityManager();
 621         if (sm != null) {
 622             sm.checkExit(0);
 623         }
 624     }
 625 
 626     /**
 627      * Adds sub-types of {@link SystemEventListener} to listen for notifications
 628      * from the native system.
 629      *
 630      * Has no effect if SystemEventListener&#39;s sub-type is unsupported on the current
 631      * platform.
 632      *
 633      * @param listener listener
 634      *
 635      * @throws SecurityException if a security manager exists and it
 636      * denies the
 637      * {@code RuntimePermission(&quot;canProcessApplicationEvents&quot;)}
 638      * permission
 639      *
 640      * @see java.awt.desktop.AppForegroundListener
 641      * @see java.awt.desktop.AppHiddenListener
 642      * @see java.awt.desktop.AppReopenedListener
 643      * @see java.awt.desktop.ScreenSleepListener
 644      * @see java.awt.desktop.SystemSleepListener
 645      * @see java.awt.desktop.UserSessionListener
 646      * @since 9
 647      */
 648     public void addAppEventListener(final SystemEventListener listener) {
 649         checkEventsProcessingPermission();
 650         peer.addAppEventListener(listener);
 651     }
 652 
 653     /**
 654      * Removes sub-types of {@link SystemEventListener} to listen for notifications
 655      * from the native system.
 656      *
 657      * Has no effect if SystemEventListener&#39;s sub-type is unsupported on  the current
 658      * platform.
 659      *
 660      * @param listener listener
 661      *
 662      * @throws SecurityException if a security manager exists and it
 663      * denies the
 664      * {@code RuntimePermission(&quot;canProcessApplicationEvents&quot;)}
 665      * permission
 666      *
 667      * @see java.awt.desktop.AppForegroundListener
 668      * @see java.awt.desktop.AppHiddenListener
 669      * @see java.awt.desktop.AppReopenedListener
 670      * @see java.awt.desktop.ScreenSleepListener
 671      * @see java.awt.desktop.SystemSleepListener
 672      * @see java.awt.desktop.UserSessionListener
 673      * @since 9
 674      */
 675     public void removeAppEventListener(final SystemEventListener listener) {
 676         checkEventsProcessingPermission();
 677         peer.removeAppEventListener(listener);
 678     }
 679 
 680     /**
 681      * Installs a handler to show a custom About window for your application.
 682      * &lt;p&gt;
 683      * Setting the {@link java.awt.desktop.AboutHandler} to {@code null} reverts it to the
 684      * default behavior.
 685      *
 686      * @param aboutHandler the handler to respond to the
 687      * {@link java.awt.desktop.AboutHandler#handleAbout(AboutEvent)} message
 688      *
 689      * @throws SecurityException if a security manager exists and it
 690      * denies the
 691      * {@code RuntimePermission(&quot;canProcessApplicationEvents&quot;)}
 692      * permission
 693      * @throws UnsupportedOperationException if the current platform
 694      * does not support the {@link Desktop.Action#APP_ABOUT} action
 695      *
 696      * @since 9
 697      */
 698     public void setAboutHandler(final AboutHandler aboutHandler) {
 699         checkEventsProcessingPermission();
 700         checkActionSupport(Action.APP_ABOUT);
 701         peer.setAboutHandler(aboutHandler);
 702     }
 703 
 704     /**
 705      * Installs a handler to show a custom Preferences window for your
 706      * application.
 707      * &lt;p&gt;
 708      * Setting the {@link PreferencesHandler} to {@code null} reverts it to
 709      * the default behavior
 710      *
 711      * @param preferencesHandler the handler to respond to the
 712      * {@link PreferencesHandler#handlePreferences(PreferencesEvent)}
 713      *
 714      * @throws SecurityException if a security manager exists and it
 715      * denies the
 716      * {@code RuntimePermission(&quot;canProcessApplicationEvents&quot;)} permission
 717      * @throws UnsupportedOperationException if the current platform
 718      * does not support the {@link Desktop.Action#APP_PREFERENCES} action
 719      * @since 9
 720      */
 721     public void setPreferencesHandler(final PreferencesHandler preferencesHandler) {
 722         checkEventsProcessingPermission();
 723         checkActionSupport(Action.APP_PREFERENCES);
 724         peer.setPreferencesHandler(preferencesHandler);
 725     }
 726 
 727     /**
 728      * Installs the handler which is notified when the application is asked to
 729      * open a list of files.
 730      *
 731      * @implNote Please note that for macOS, notifications
 732      * are only sent if the Java app is a bundled application,
 733      * with a {@code CFBundleDocumentTypes} array present in its
 734      * {@code Info.plist}. Check the
 735      * &lt;a href=&quot;https://developer.apple.com/documentation&quot;&gt;
 736      * Apple Developer Documentation&lt;/a&gt; for more information about
 737      * {@code Info.plist}.
 738      *
 739      * @param openFileHandler handler
 740      *
 741      * @throws SecurityException if a security manager exists and its
 742      * {@link java.lang.SecurityManager#checkRead(java.lang.String)}
 743      * method denies read access to the files, or it denies the
 744      * {@code RuntimePermission(&quot;canProcessApplicationEvents&quot;)}
 745      * permission, or the calling thread is not allowed to create a
 746      * subprocess
 747      * @throws UnsupportedOperationException if the current platform
 748      * does not support the {@link Desktop.Action#APP_OPEN_FILE} action
 749      * @since 9
 750      */
 751     public void setOpenFileHandler(final OpenFilesHandler openFileHandler) {
 752         checkEventsProcessingPermission();
 753         checkExec();
 754         checkRead();
 755         checkActionSupport(Action.APP_OPEN_FILE);
 756         peer.setOpenFileHandler(openFileHandler);
 757     }
 758 
 759     /**
 760      * Installs the handler which is notified when the application is asked to
 761      * print a list of files.
 762      *
 763      * @implNote Please note that for macOS, notifications
 764      * are only sent if the Java app is a bundled application,
 765      * with a {@code CFBundleDocumentTypes} array present in its
 766      * {@code Info.plist}. Check the
 767      * &lt;a href=&quot;https://developer.apple.com/documentation&quot;&gt;
 768      * Apple Developer Documentation&lt;/a&gt; for more information about
 769      * {@code Info.plist}.
 770      *
 771      * @param printFileHandler handler
 772      * @throws SecurityException if a security manager exists and its
 773      * {@link java.lang.SecurityManager#checkPrintJobAccess()} method denies
 774      * the permission to print or it denies the
 775      * {@code RuntimePermission(&quot;canProcessApplicationEvents&quot;)} permission
 776      * @throws UnsupportedOperationException if the current platform
 777      * does not support the {@link Desktop.Action#APP_PRINT_FILE} action
 778      * @since 9
 779      */
 780     public void setPrintFileHandler(final PrintFilesHandler printFileHandler) {
 781         checkEventsProcessingPermission();
 782         SecurityManager sm = System.getSecurityManager();
 783         if (sm != null) {
 784             sm.checkPrintJobAccess();
 785         }
 786         checkActionSupport(Action.APP_PRINT_FILE);
 787         peer.setPrintFileHandler(printFileHandler);
 788     }
 789 
 790     /**
 791      * Installs the handler which is notified when the application is asked to
 792      * open a URL.
 793      *
 794      * Setting the handler to {@code null} causes all
 795      * {@link OpenURIHandler#openURI(OpenURIEvent)} requests to be
 796      * enqueued until another handler is set.
 797      *
 798      * @implNote Please note that for macOS, notifications
 799      * are only sent if the Java app is a bundled application,
 800      * with a {@code CFBundleDocumentTypes} array present in its
 801      * {@code Info.plist}. Check the
 802      * &lt;a href=&quot;https://developer.apple.com/documentation&quot;&gt;
 803      * Apple Developer Documentation&lt;/a&gt; for more information about
 804      * {@code Info.plist}.
 805      *
 806      * @param openURIHandler handler
 807      *
 808      * {@code RuntimePermission(&quot;canProcessApplicationEvents&quot;)}
 809      * permission, or the calling thread is not allowed to create a
 810      * subprocess
 811      * @throws UnsupportedOperationException if the current platform
 812      * does not support the {@link Desktop.Action#APP_OPEN_URI} action
 813      * @since 9
 814      */
 815     public void setOpenURIHandler(final OpenURIHandler openURIHandler) {
 816         checkEventsProcessingPermission();
 817         checkExec();
 818         checkActionSupport(Action.APP_OPEN_URI);
 819         peer.setOpenURIHandler(openURIHandler);
 820     }
 821 
 822     /**
 823      * Installs the handler which determines if the application should quit. The
 824      * handler is passed a one-shot {@link java.awt.desktop.QuitResponse} which can cancel or
 825      * proceed with the quit. Setting the handler to {@code null} causes
 826      * all quit requests to directly perform the default {@link QuitStrategy}.
 827      *
 828      * @param quitHandler the handler that is called when the application is
 829      * asked to quit
 830      *
 831      * @throws SecurityException if a security manager exists and it
 832      * will not allow the caller to invoke {@code System.exit} or it denies the
 833      * {@code RuntimePermission(&quot;canProcessApplicationEvents&quot;)} permission
 834      * @throws UnsupportedOperationException if the current platform
 835      * does not support the {@link Desktop.Action#APP_QUIT_HANDLER} action
 836      * @since 9
 837      */
 838     public void setQuitHandler(final QuitHandler quitHandler) {
 839         checkEventsProcessingPermission();
 840         checkQuitPermission();
 841         checkActionSupport(Action.APP_QUIT_HANDLER);
 842         peer.setQuitHandler(quitHandler);
 843     }
 844 
 845     /**
 846      * Sets the default strategy used to quit this application. The default is
 847      * calling SYSTEM_EXIT_0.
 848      *
 849      * @param strategy the way this application should be shutdown
 850      *
 851      * @throws SecurityException if a security manager exists and it
 852      * will not allow the caller to invoke {@code System.exit} or it denies the
 853      * {@code RuntimePermission(&quot;canProcessApplicationEvents&quot;)} permission
 854      * @throws UnsupportedOperationException if the current platform
 855      * does not support the {@link Desktop.Action#APP_QUIT_STRATEGY} action
 856      * @see QuitStrategy
 857      * @since 9
 858      */
 859     public void setQuitStrategy(final QuitStrategy strategy) {
 860         checkEventsProcessingPermission();
 861         checkQuitPermission();
 862         checkActionSupport(Action.APP_QUIT_STRATEGY);
 863         peer.setQuitStrategy(strategy);
 864     }
 865 
 866     /**
 867      * Enables this application to be suddenly terminated.
 868      *
 869      * Call this method to indicate your application&#39;s state is saved, and
 870      * requires no notification to be terminated. Letting your application
 871      * remain terminatable improves the user experience by avoiding re-paging in
 872      * your application when it&#39;s asked to quit.
 873      *
 874      * &lt;b&gt;Note: enabling sudden termination will allow your application to be
 875      * quit without notifying your QuitHandler, or running any shutdown
 876      * hooks.&lt;/b&gt;
 877      * E.g. user-initiated Cmd-Q, logout, restart, or shutdown requests will
 878      * effectively &quot;kill -KILL&quot; your application.
 879      *
 880      * @throws SecurityException if a security manager exists and it
 881      * will not allow the caller to invoke {@code System.exit} or it denies the
 882      * {@code RuntimePermission(&quot;canProcessApplicationEvents&quot;)} permission
 883      * @throws UnsupportedOperationException if the current platform
 884      * does not support the {@link Desktop.Action#APP_SUDDEN_TERMINATION} action
 885      * @see #disableSuddenTermination()
 886      * @since 9
 887      */
 888     public void enableSuddenTermination() {
 889         checkEventsProcessingPermission();
 890         checkQuitPermission();
 891         checkActionSupport(Action.APP_SUDDEN_TERMINATION);
 892         peer.enableSuddenTermination();
 893     }
 894 
 895     /**
 896      * Prevents this application from being suddenly terminated.
 897      *
 898      * Call this method to indicate that your application has unsaved state, and
 899      * may not be terminated without notification.
 900      *
 901      * @throws SecurityException if a security manager exists and it
 902      * will not allow the caller to invoke {@code System.exit} or it denies the
 903      * {@code RuntimePermission(&quot;canProcessApplicationEvents&quot;)} permission
 904      * @throws UnsupportedOperationException if the current platform
 905      * does not support the {@link Desktop.Action#APP_SUDDEN_TERMINATION} action
 906      * @see #enableSuddenTermination()
 907      * @since 9
 908      */
 909     public void disableSuddenTermination() {
 910         checkEventsProcessingPermission();
 911         checkQuitPermission();
 912         checkActionSupport(Action.APP_SUDDEN_TERMINATION);
 913         peer.disableSuddenTermination();
 914     }
 915 
 916     /**
 917      * Requests this application to move to the foreground.
 918      *
 919      * @param allWindows if all windows of this application should be moved to
 920      * the foreground, or only the foremost one
 921      * @throws SecurityException if a security manager exists and it denies the
 922      * {@code RuntimePermission(&quot;canProcessApplicationEvents&quot;)} permission.
 923      * @throws UnsupportedOperationException if the current platform
 924      * does not support the {@link Desktop.Action#APP_REQUEST_FOREGROUND} action
 925      * @since 9
 926      */
 927     public void requestForeground(final boolean allWindows) {
 928         checkEventsProcessingPermission();
 929         checkActionSupport(Action.APP_REQUEST_FOREGROUND);
 930         peer.requestForeground(allWindows);
 931     }
 932 
 933     /**
 934      * Opens the native help viewer application.
 935      *
 936      * @implNote Please note that for Mac OS, it opens the native help viewer
 937      * application if a Help Book has been added to the application bundler
 938      * and registered in the Info.plist with CFBundleHelpBookFolder
 939      *
 940      * @throws SecurityException if a security manager exists and it denies the
 941      *         {@code RuntimePermission(&quot;canProcessApplicationEvents&quot;)}
 942      *         permission, or it denies the
 943      *         {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}
 944      *         permission, or the calling thread is not allowed to create a
 945      *         subprocess
 946      * @throws UnsupportedOperationException if the current platform
 947      * does not support the {@link Desktop.Action#APP_HELP_VIEWER} action
 948      * @since 9
 949      */
 950     public void openHelpViewer() {
 951         checkAWTPermission();
 952         checkExec();
 953         checkEventsProcessingPermission();
 954         checkActionSupport(Action.APP_HELP_VIEWER);
 955         peer.openHelpViewer();
 956     }
 957 
 958     /**
 959      * Sets the default menu bar to use when there are no active frames.
 960      *
 961      * @param menuBar to use when no other frames are active
 962      * @throws SecurityException if a security manager exists and it denies the
 963      * {@code RuntimePermission(&quot;canProcessApplicationEvents&quot;)} permission.
 964      * @throws UnsupportedOperationException if the current platform
 965      * does not support the {@link Desktop.Action#APP_MENU_BAR} action
 966      * @since 9
 967      */
 968     public void setDefaultMenuBar(final JMenuBar menuBar) {
 969         checkEventsProcessingPermission();
 970         checkActionSupport(Action.APP_MENU_BAR);
 971 
 972         if (menuBar != null) {
 973             Container parent = menuBar.getParent();
 974             if (parent != null) {
 975                 parent.remove(menuBar);
 976                 menuBar.updateUI();
 977             }
 978         }
 979 
 980         peer.setDefaultMenuBar(menuBar);
 981     }
 982 
 983     /**
 984      * Opens a folder containing the {@code file} and selects it
 985      * in a default system file manager.
 986      * @param file the file
 987      * @throws SecurityException If a security manager exists and its
 988      *         {@link SecurityManager#checkRead(java.lang.String)} method
 989      *         denies read access to the file or to its parent, or it denies the
 990      *         {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}
 991      *         permission, or the calling thread is not allowed to create a
 992      *         subprocess
 993      * @throws UnsupportedOperationException if the current platform
 994      *         does not support the {@link Desktop.Action#BROWSE_FILE_DIR} action
 995      * @throws NullPointerException if {@code file} is {@code null}
 996      * @throws IllegalArgumentException if the specified file or its parent
 997      *         doesn&#39;t exist
 998      * @since 9
 999      */
1000     public void browseFileDirectory(File file) {
1001         file = new File(file.getPath());
1002         checkAWTPermission();
1003         checkExec();
1004         checkActionSupport(Action.BROWSE_FILE_DIR);
1005         checkFileValidation(file);
1006         File parentFile = file.getParentFile();
1007         if (parentFile == null || !parentFile.exists()) {
1008             throw new IllegalArgumentException(&quot;Parent folder doesn&#39;t exist&quot;);
1009         }
1010         peer.browseFileDirectory(file);
1011     }
1012 
1013     /**
1014      * Moves the specified file to the trash.
1015      *
1016      * @param file the file
1017      * @return returns true if successfully moved the file to the trash.
1018      * @throws SecurityException If a security manager exists and its
1019      *         {@link SecurityManager#checkDelete(java.lang.String)} method
1020      *         denies deletion of the file
1021      * @throws UnsupportedOperationException if the current platform
1022      *         does not support the {@link Desktop.Action#MOVE_TO_TRASH} action
1023      * @throws NullPointerException if {@code file} is {@code null}
1024      * @throws IllegalArgumentException if the specified file doesn&#39;t exist
1025      *
1026      * @since 9
1027      */
1028     public boolean moveToTrash(File file) {
1029         file = new File(file.getPath());
1030         SecurityManager sm = System.getSecurityManager();
1031         if (sm != null) {
1032             sm.checkDelete(file.getPath());
1033         }
1034         checkActionSupport(Action.MOVE_TO_TRASH);
1035         final File finalFile = file;
1036         AccessController.doPrivileged((PrivilegedAction&lt;?&gt;) () -&gt; {
1037             checkFileValidation(finalFile);
1038             return null;
1039         });
1040         return peer.moveToTrash(file);
1041     }
1042 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
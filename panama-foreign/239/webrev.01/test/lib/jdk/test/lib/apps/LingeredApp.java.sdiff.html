<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/lib/jdk/test/lib/apps/LingeredApp.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../SA/SATestUtils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="libLingeredApp.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/lib/jdk/test/lib/apps/LingeredApp.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 import java.io.IOException;
 28 import java.nio.file.Files;
 29 import java.nio.file.NoSuchFileException;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.nio.file.attribute.BasicFileAttributes;
 33 import java.nio.file.attribute.FileTime;
 34 import java.util.ArrayList;
 35 import java.util.Collections;
 36 import java.util.Date;
 37 import java.util.List;
 38 import java.util.Map;
 39 import java.util.concurrent.TimeUnit;
 40 import java.util.stream.Collectors;
 41 import java.util.UUID;
 42 
 43 import jdk.test.lib.JDKToolFinder;
 44 import jdk.test.lib.Utils;
 45 import jdk.test.lib.process.OutputBuffer;
 46 import jdk.test.lib.process.StreamPumper;

 47 
 48 /**
 49  * This is a framework to launch an app that could be synchronized with caller
 50  * to make further attach actions reliable across supported platforms
 51 
 52  * Caller example:
 53  *
 54  *   LingeredApp a = LingeredApp.startApp(cmd);
 55  *     // do something.
 56  *     // a.getPid(). a.getProcess(), a.getProcessStdout() are available.
 57  *   LingeredApp.stopApp(a);
 58  *
 59  *   for use custom LingeredApp (class SmartTestApp extends LingeredApp):
 60  *
 61  *   SmartTestApp = new SmartTestApp();
 62  *   LingeredApp.startApp(a, cmd);
 63  *     // do something
 64  *   a.stopApp();   // LingeredApp.stopApp(a) can be used as well
 65  *
 66  *   or fine grained control
</pre>
<hr />
<pre>
 76  *  After app termination (stopApp/waitAppTermination) its output is available
 77  *
 78  *   output = a.getAppOutput();
 79  *
 80  */
 81 public class LingeredApp {
 82 
 83     private static final long spinDelay = 1000;
 84 
 85     private long lockCreationTime;
 86     private ByteArrayOutputStream stderrBuffer;
 87     private ByteArrayOutputStream stdoutBuffer;
 88     private Thread outPumperThread;
 89     private Thread errPumperThread;
 90 
 91     protected Process appProcess;
 92     protected OutputBuffer output;
 93     protected static final int appWaitTime = 100;
 94     protected final String lockFileName;
 95 


 96     /**
 97      * Create LingeredApp object on caller side. Lock file have be a valid filename
 98      * at writable location
 99      *
100      * @param lockFileName - the name of lock file
101      */
102     public LingeredApp(String lockFileName) {
103         this.lockFileName = lockFileName;
104     }
105 
106     public LingeredApp() {
107         final String lockName = UUID.randomUUID().toString() + &quot;.lck&quot;;
108         this.lockFileName = lockName;
109     }
110 






111     /**
112      *
113      * @return name of lock file
114      */
115     public String getLockFileName() {
116         return this.lockFileName;
117     }
118 
119     /**
120      *
121      *  @return pid of java process running testapp
122      */
123     public long getPid() {
124         if (appProcess == null) {
125             throw new RuntimeException(&quot;Process is not alive&quot;);
126         }
127         return appProcess.pid();
128     }
129 
130     /**
</pre>
<hr />
<pre>
246      * @throws java.io.IOException
247      */
248     public void waitAppReady(long timeout) throws IOException {
249         // adjust timeout for timeout_factor and convert to ms
250         timeout = Utils.adjustTimeout(timeout) * 1000;
251         long here = epoch();
252         while (true) {
253             long epoch = epoch();
254             if (epoch - here &gt; timeout) {
255                 throw new IOException(&quot;App waiting timeout&quot;);
256             }
257 
258             // Live process should touch lock file every second
259             long lm = lastModified(lockFileName);
260             if (lm &gt; lockCreationTime) {
261                 break;
262             }
263 
264             // Make sure process didn&#39;t already exit
265             if (!appProcess.isAlive()) {
<span class="line-modified">266                 throw new IOException(&quot;App exited unexpectedly with &quot; + appProcess.exitValue());</span>




267             }
268 
269             try {
270                 Thread.sleep(spinDelay);
271             } catch (InterruptedException ex) {
272                 // pass
273             }
274         }
275     }
276 
277     /**
278      * Waits for the application to start with the default timeout.
279      */
280     public void waitAppReady() throws IOException {
281         waitAppReady(appWaitTime);
282     }
283 
284     /**
285      * Analyze an environment and prepare a command line to
286      * run the app, app name should be added explicitly
287      */
288     private List&lt;String&gt; runAppPrepare(String[] vmArguments) {
289         List&lt;String&gt; cmd = new ArrayList&lt;&gt;();
290         cmd.add(JDKToolFinder.getTestJDKTool(&quot;java&quot;));
291         Collections.addAll(cmd, vmArguments);





292 
293         // Make sure we set correct classpath to run the app
294         cmd.add(&quot;-cp&quot;);
295         String classpath = System.getProperty(&quot;test.class.path&quot;);
296         cmd.add((classpath == null) ? &quot;.&quot; : classpath);
297 
298         return cmd;
299     }
300 
301     /**
302      * Adds application name to the command line.
303      * By default adds name of this class.
304      */
305     protected void runAddAppName(List&lt;String&gt; cmd) {
306         cmd.add(getClass().getName());
307     }
308 
309     /**
310      * Assemble command line to a printable string
311      */
312     public void printCommandLine(List&lt;String&gt; cmd) {
313         // A bit of verbosity
314         System.out.println(cmd.stream()
315                 .map(s -&gt; &quot;&#39;&quot; + s + &quot;&#39;&quot;)
316                 .collect(Collectors.joining(&quot; &quot;, &quot;Command line: [&quot;, &quot;]&quot;)));
317     }
318 
319     /**
320      * Run the app.
321      * User should provide exact options to run app. Might use #Utils.getTestJavaOpts() to set default test options.
322      * @param vmOpts
323      * @throws IOException
324      */
325     public void runAppExactJvmOpts(String[] vmOpts)
326             throws IOException {
327 
328         List&lt;String&gt; cmd = runAppPrepare(vmOpts);
329 
330         runAddAppName(cmd);
331         cmd.add(lockFileName);



332 
333         printCommandLine(cmd);
334 
335         ProcessBuilder pb = new ProcessBuilder(cmd);




336         // ProcessBuilder.start can throw IOException
337         appProcess = pb.start();
338 
339         startOutputPumpers();
340     }
341 
342     private void finishApp() {
343         if (appProcess != null) {
344             OutputBuffer output = getOutput();
345             String msg =
346                     &quot; LingeredApp stdout: [&quot; + output.getStdout() + &quot;];\n&quot; +
347                     &quot; LingeredApp stderr: [&quot; + output.getStderr() + &quot;]\n&quot; +
348                     &quot; LingeredApp exitValue = &quot; + appProcess.exitValue();
349 
350             System.out.println(msg);
351         }
352     }
353 
354     /**
355      * Delete lock file that signals app to terminate, then
</pre>
<hr />
<pre>
453                 System.err.println(&quot;SANITY Warning! The Clock is wrong on this system lastModifiedTime() &gt; getTime()&quot;);
454                 sane = false;
455             }
456 
457             setLastModified(&quot;.&quot;, epoch());
458             long lm1 = lastModified(&quot;.&quot;);
459             if (lm1 &lt;= lm) {
460                 System.err.println(&quot;SANITY Warning! The setLastModified doesn&#39;t work on this system&quot;);
461                 sane = false;
462             }
463         }
464         catch(IOException e) {
465             System.err.println(&quot;SANITY Warning! IOException during sanity check &quot; + e);
466             sane = false;
467         }
468 
469         return sane;
470     }
471 
472     /**
<span class="line-modified">473      * This part is the application it self</span>

474      */
475     public static void main(String args[]) {

476 
<span class="line-modified">477         if (args.length != 1) {</span>
478             System.err.println(&quot;Lock file name is not specified&quot;);
479             System.exit(7);












480         }
481 
482         String theLockFileName = args[0];
483         Path path = Paths.get(theLockFileName);
484 
485         try {




486             while (Files.exists(path)) {
487                 // Touch the lock to indicate our readiness
488                 setLastModified(theLockFileName, epoch());
489                 Thread.sleep(spinDelay);
490             }
491         } catch (IOException ex) {
492             // Lock deleted while we are setting last modified time.
493             // Ignore the error and let the app exit.
494             if (Files.exists(path)) {
495                 // If the lock file was not removed, return an error.
496                 System.err.println(&quot;LingeredApp IOException: lock file still exists&quot;);
497                 System.exit(4);
498             }
499         } catch (Exception ex) {
500             System.err.println(&quot;LingeredApp ERROR: &quot; + ex);
501             // Leave exit_code = 1 to Java launcher
502             System.exit(3);
503         }
504 
505         System.exit(0);
</pre>
</td>
<td>
<hr />
<pre>
 27 import java.io.IOException;
 28 import java.nio.file.Files;
 29 import java.nio.file.NoSuchFileException;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.nio.file.attribute.BasicFileAttributes;
 33 import java.nio.file.attribute.FileTime;
 34 import java.util.ArrayList;
 35 import java.util.Collections;
 36 import java.util.Date;
 37 import java.util.List;
 38 import java.util.Map;
 39 import java.util.concurrent.TimeUnit;
 40 import java.util.stream.Collectors;
 41 import java.util.UUID;
 42 
 43 import jdk.test.lib.JDKToolFinder;
 44 import jdk.test.lib.Utils;
 45 import jdk.test.lib.process.OutputBuffer;
 46 import jdk.test.lib.process.StreamPumper;
<span class="line-added"> 47 import jdk.test.lib.util.CoreUtils;</span>
 48 
 49 /**
 50  * This is a framework to launch an app that could be synchronized with caller
 51  * to make further attach actions reliable across supported platforms
 52 
 53  * Caller example:
 54  *
 55  *   LingeredApp a = LingeredApp.startApp(cmd);
 56  *     // do something.
 57  *     // a.getPid(). a.getProcess(), a.getProcessStdout() are available.
 58  *   LingeredApp.stopApp(a);
 59  *
 60  *   for use custom LingeredApp (class SmartTestApp extends LingeredApp):
 61  *
 62  *   SmartTestApp = new SmartTestApp();
 63  *   LingeredApp.startApp(a, cmd);
 64  *     // do something
 65  *   a.stopApp();   // LingeredApp.stopApp(a) can be used as well
 66  *
 67  *   or fine grained control
</pre>
<hr />
<pre>
 77  *  After app termination (stopApp/waitAppTermination) its output is available
 78  *
 79  *   output = a.getAppOutput();
 80  *
 81  */
 82 public class LingeredApp {
 83 
 84     private static final long spinDelay = 1000;
 85 
 86     private long lockCreationTime;
 87     private ByteArrayOutputStream stderrBuffer;
 88     private ByteArrayOutputStream stdoutBuffer;
 89     private Thread outPumperThread;
 90     private Thread errPumperThread;
 91 
 92     protected Process appProcess;
 93     protected OutputBuffer output;
 94     protected static final int appWaitTime = 100;
 95     protected final String lockFileName;
 96 
<span class="line-added"> 97     protected boolean forceCrash = false; // set true to force a crash and core file</span>
<span class="line-added"> 98 </span>
 99     /**
100      * Create LingeredApp object on caller side. Lock file have be a valid filename
101      * at writable location
102      *
103      * @param lockFileName - the name of lock file
104      */
105     public LingeredApp(String lockFileName) {
106         this.lockFileName = lockFileName;
107     }
108 
109     public LingeredApp() {
110         final String lockName = UUID.randomUUID().toString() + &quot;.lck&quot;;
111         this.lockFileName = lockName;
112     }
113 
<span class="line-added">114     public void setForceCrash(boolean forceCrash) {</span>
<span class="line-added">115         this.forceCrash = forceCrash;</span>
<span class="line-added">116     }</span>
<span class="line-added">117 </span>
<span class="line-added">118     native private static int crash();</span>
<span class="line-added">119 </span>
120     /**
121      *
122      * @return name of lock file
123      */
124     public String getLockFileName() {
125         return this.lockFileName;
126     }
127 
128     /**
129      *
130      *  @return pid of java process running testapp
131      */
132     public long getPid() {
133         if (appProcess == null) {
134             throw new RuntimeException(&quot;Process is not alive&quot;);
135         }
136         return appProcess.pid();
137     }
138 
139     /**
</pre>
<hr />
<pre>
255      * @throws java.io.IOException
256      */
257     public void waitAppReady(long timeout) throws IOException {
258         // adjust timeout for timeout_factor and convert to ms
259         timeout = Utils.adjustTimeout(timeout) * 1000;
260         long here = epoch();
261         while (true) {
262             long epoch = epoch();
263             if (epoch - here &gt; timeout) {
264                 throw new IOException(&quot;App waiting timeout&quot;);
265             }
266 
267             // Live process should touch lock file every second
268             long lm = lastModified(lockFileName);
269             if (lm &gt; lockCreationTime) {
270                 break;
271             }
272 
273             // Make sure process didn&#39;t already exit
274             if (!appProcess.isAlive()) {
<span class="line-modified">275                 if (forceCrash) {</span>
<span class="line-added">276                     return; // This is expected. Just return.</span>
<span class="line-added">277                 } else {</span>
<span class="line-added">278                     throw new IOException(&quot;App exited unexpectedly with &quot; + appProcess.exitValue());</span>
<span class="line-added">279                 }</span>
280             }
281 
282             try {
283                 Thread.sleep(spinDelay);
284             } catch (InterruptedException ex) {
285                 // pass
286             }
287         }
288     }
289 
290     /**
291      * Waits for the application to start with the default timeout.
292      */
293     public void waitAppReady() throws IOException {
294         waitAppReady(appWaitTime);
295     }
296 
297     /**
298      * Analyze an environment and prepare a command line to
299      * run the app, app name should be added explicitly
300      */
301     private List&lt;String&gt; runAppPrepare(String[] vmArguments) {
302         List&lt;String&gt; cmd = new ArrayList&lt;&gt;();
303         cmd.add(JDKToolFinder.getTestJDKTool(&quot;java&quot;));
304         Collections.addAll(cmd, vmArguments);
<span class="line-added">305         if (forceCrash) {</span>
<span class="line-added">306             cmd.add(&quot;-XX:+CreateCoredumpOnCrash&quot;);</span>
<span class="line-added">307             // We need to find libLingeredApp.so for the crash() native method</span>
<span class="line-added">308             cmd.add(&quot;-Djava.library.path=&quot; + System.getProperty(&quot;java.library.path&quot;));</span>
<span class="line-added">309         }</span>
310 
311         // Make sure we set correct classpath to run the app
312         cmd.add(&quot;-cp&quot;);
313         String classpath = System.getProperty(&quot;test.class.path&quot;);
314         cmd.add((classpath == null) ? &quot;.&quot; : classpath);
315 
316         return cmd;
317     }
318 
319     /**
320      * Adds application name to the command line.
321      * By default adds name of this class.
322      */
323     protected void runAddAppName(List&lt;String&gt; cmd) {
324         cmd.add(getClass().getName());
325     }
326 
327     /**
328      * Assemble command line to a printable string
329      */
330     public void printCommandLine(List&lt;String&gt; cmd) {
331         // A bit of verbosity
332         System.out.println(cmd.stream()
333                 .map(s -&gt; &quot;&#39;&quot; + s + &quot;&#39;&quot;)
334                 .collect(Collectors.joining(&quot; &quot;, &quot;Command line: [&quot;, &quot;]&quot;)));
335     }
336 
337     /**
338      * Run the app.
339      * User should provide exact options to run app. Might use #Utils.getTestJavaOpts() to set default test options.
340      * @param vmOpts
341      * @throws IOException
342      */
343     public void runAppExactJvmOpts(String[] vmOpts)
344             throws IOException {
345 
346         List&lt;String&gt; cmd = runAppPrepare(vmOpts);
347 
348         runAddAppName(cmd);
349         cmd.add(lockFileName);
<span class="line-added">350         if (forceCrash) {</span>
<span class="line-added">351             cmd.add(&quot;forceCrash&quot;); // Let the subprocess know to force a crash</span>
<span class="line-added">352         }</span>
353 
354         printCommandLine(cmd);
355 
356         ProcessBuilder pb = new ProcessBuilder(cmd);
<span class="line-added">357         if (forceCrash) {</span>
<span class="line-added">358             // If we are going to force a core dump, apply &quot;ulimit -c unlimited&quot; if we can.</span>
<span class="line-added">359             pb = CoreUtils.addCoreUlimitCommand(pb);</span>
<span class="line-added">360         }</span>
361         // ProcessBuilder.start can throw IOException
362         appProcess = pb.start();
363 
364         startOutputPumpers();
365     }
366 
367     private void finishApp() {
368         if (appProcess != null) {
369             OutputBuffer output = getOutput();
370             String msg =
371                     &quot; LingeredApp stdout: [&quot; + output.getStdout() + &quot;];\n&quot; +
372                     &quot; LingeredApp stderr: [&quot; + output.getStderr() + &quot;]\n&quot; +
373                     &quot; LingeredApp exitValue = &quot; + appProcess.exitValue();
374 
375             System.out.println(msg);
376         }
377     }
378 
379     /**
380      * Delete lock file that signals app to terminate, then
</pre>
<hr />
<pre>
478                 System.err.println(&quot;SANITY Warning! The Clock is wrong on this system lastModifiedTime() &gt; getTime()&quot;);
479                 sane = false;
480             }
481 
482             setLastModified(&quot;.&quot;, epoch());
483             long lm1 = lastModified(&quot;.&quot;);
484             if (lm1 &lt;= lm) {
485                 System.err.println(&quot;SANITY Warning! The setLastModified doesn&#39;t work on this system&quot;);
486                 sane = false;
487             }
488         }
489         catch(IOException e) {
490             System.err.println(&quot;SANITY Warning! IOException during sanity check &quot; + e);
491             sane = false;
492         }
493 
494         return sane;
495     }
496 
497     /**
<span class="line-modified">498      * This part is the application itself. First arg is optional &quot;forceCrash&quot;.</span>
<span class="line-added">499      * Following arg is the lock file name.</span>
500      */
501     public static void main(String args[]) {
<span class="line-added">502         boolean forceCrash = false;</span>
503 
<span class="line-modified">504         if (args.length == 0) {</span>
505             System.err.println(&quot;Lock file name is not specified&quot;);
506             System.exit(7);
<span class="line-added">507         } else if (args.length &gt; 2) {</span>
<span class="line-added">508             System.err.println(&quot;Too many arguments specified: &quot;  + args.length);</span>
<span class="line-added">509             System.exit(7);</span>
<span class="line-added">510         }</span>
<span class="line-added">511 </span>
<span class="line-added">512         if (args.length == 2) {</span>
<span class="line-added">513             if (args[1].equals(&quot;forceCrash&quot;)) {</span>
<span class="line-added">514                 forceCrash = true;</span>
<span class="line-added">515             } else {</span>
<span class="line-added">516                 System.err.println(&quot;Invalid 1st argment: &quot; + args[1]);</span>
<span class="line-added">517                 System.exit(7);</span>
<span class="line-added">518             }</span>
519         }
520 
521         String theLockFileName = args[0];
522         Path path = Paths.get(theLockFileName);
523 
524         try {
<span class="line-added">525             if (forceCrash) {</span>
<span class="line-added">526                 System.loadLibrary(&quot;LingeredApp&quot;); // location of native crash() method</span>
<span class="line-added">527                 crash();</span>
<span class="line-added">528             }</span>
529             while (Files.exists(path)) {
530                 // Touch the lock to indicate our readiness
531                 setLastModified(theLockFileName, epoch());
532                 Thread.sleep(spinDelay);
533             }
534         } catch (IOException ex) {
535             // Lock deleted while we are setting last modified time.
536             // Ignore the error and let the app exit.
537             if (Files.exists(path)) {
538                 // If the lock file was not removed, return an error.
539                 System.err.println(&quot;LingeredApp IOException: lock file still exists&quot;);
540                 System.exit(4);
541             }
542         } catch (Exception ex) {
543             System.err.println(&quot;LingeredApp ERROR: &quot; + ex);
544             // Leave exit_code = 1 to Java launcher
545             System.exit(3);
546         }
547 
548         System.exit(0);
</pre>
</td>
</tr>
</table>
<center><a href="../SA/SATestUtils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="libLingeredApp.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
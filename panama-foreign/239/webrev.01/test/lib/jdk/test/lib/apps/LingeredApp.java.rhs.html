<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/lib/jdk/test/lib/apps/LingeredApp.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.apps;
 25 
 26 import java.io.ByteArrayOutputStream;
 27 import java.io.IOException;
 28 import java.nio.file.Files;
 29 import java.nio.file.NoSuchFileException;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.nio.file.attribute.BasicFileAttributes;
 33 import java.nio.file.attribute.FileTime;
 34 import java.util.ArrayList;
 35 import java.util.Collections;
 36 import java.util.Date;
 37 import java.util.List;
 38 import java.util.Map;
 39 import java.util.concurrent.TimeUnit;
 40 import java.util.stream.Collectors;
 41 import java.util.UUID;
 42 
 43 import jdk.test.lib.JDKToolFinder;
 44 import jdk.test.lib.Utils;
 45 import jdk.test.lib.process.OutputBuffer;
 46 import jdk.test.lib.process.StreamPumper;
<a name="1" id="anc1"></a><span class="line-added"> 47 import jdk.test.lib.util.CoreUtils;</span>
 48 
 49 /**
 50  * This is a framework to launch an app that could be synchronized with caller
 51  * to make further attach actions reliable across supported platforms
 52 
 53  * Caller example:
 54  *
 55  *   LingeredApp a = LingeredApp.startApp(cmd);
 56  *     // do something.
 57  *     // a.getPid(). a.getProcess(), a.getProcessStdout() are available.
 58  *   LingeredApp.stopApp(a);
 59  *
 60  *   for use custom LingeredApp (class SmartTestApp extends LingeredApp):
 61  *
 62  *   SmartTestApp = new SmartTestApp();
 63  *   LingeredApp.startApp(a, cmd);
 64  *     // do something
 65  *   a.stopApp();   // LingeredApp.stopApp(a) can be used as well
 66  *
 67  *   or fine grained control
 68  *
 69  *   a = new SmartTestApp(&quot;MyLock.lck&quot;);
 70  *   a.createLock();
 71  *   a.runAppExactJvmOpts(Utils.getTestJavaOpts());
 72  *   a.waitAppReady();
 73  *     // do something
 74  *   a.deleteLock();
 75  *   a.waitAppTerminate();
 76  *
 77  *  After app termination (stopApp/waitAppTermination) its output is available
 78  *
 79  *   output = a.getAppOutput();
 80  *
 81  */
 82 public class LingeredApp {
 83 
 84     private static final long spinDelay = 1000;
 85 
 86     private long lockCreationTime;
 87     private ByteArrayOutputStream stderrBuffer;
 88     private ByteArrayOutputStream stdoutBuffer;
 89     private Thread outPumperThread;
 90     private Thread errPumperThread;
 91 
 92     protected Process appProcess;
 93     protected OutputBuffer output;
 94     protected static final int appWaitTime = 100;
 95     protected final String lockFileName;
 96 
<a name="2" id="anc2"></a><span class="line-added"> 97     protected boolean forceCrash = false; // set true to force a crash and core file</span>
<span class="line-added"> 98 </span>
 99     /**
100      * Create LingeredApp object on caller side. Lock file have be a valid filename
101      * at writable location
102      *
103      * @param lockFileName - the name of lock file
104      */
105     public LingeredApp(String lockFileName) {
106         this.lockFileName = lockFileName;
107     }
108 
109     public LingeredApp() {
110         final String lockName = UUID.randomUUID().toString() + &quot;.lck&quot;;
111         this.lockFileName = lockName;
112     }
113 
<a name="3" id="anc3"></a><span class="line-added">114     public void setForceCrash(boolean forceCrash) {</span>
<span class="line-added">115         this.forceCrash = forceCrash;</span>
<span class="line-added">116     }</span>
<span class="line-added">117 </span>
<span class="line-added">118     native private static int crash();</span>
<span class="line-added">119 </span>
120     /**
121      *
122      * @return name of lock file
123      */
124     public String getLockFileName() {
125         return this.lockFileName;
126     }
127 
128     /**
129      *
130      *  @return pid of java process running testapp
131      */
132     public long getPid() {
133         if (appProcess == null) {
134             throw new RuntimeException(&quot;Process is not alive&quot;);
135         }
136         return appProcess.pid();
137     }
138 
139     /**
140      *
141      * @return process object
142      */
143     public Process getProcess() {
144         return appProcess;
145     }
146 
147     /**
148      * @return the LingeredApp&#39;s output.
149      * Can be called after the app is run.
150      */
151     public String getProcessStdout() {
152         return stdoutBuffer.toString();
153     }
154 
155     /**
156      *
157      * @return OutputBuffer object for the LingeredApp&#39;s output. Can only be called
158      * after LingeredApp has exited.
159      */
160     public OutputBuffer getOutput() {
161         if (appProcess.isAlive()) {
162             throw new RuntimeException(&quot;Process is still alive. Can&#39;t get its output.&quot;);
163         }
164         if (output == null) {
165             output = OutputBuffer.of(stdoutBuffer.toString(), stderrBuffer.toString(), appProcess.exitValue());
166         }
167         return output;
168     }
169 
170     /*
171      * Capture all stdout and stderr output from the LingeredApp so it can be returned
172      * to the driver app later. This code is modeled after ProcessTools.getOutput().
173      */
174     private void startOutputPumpers() {
175         stderrBuffer = new ByteArrayOutputStream();
176         stdoutBuffer = new ByteArrayOutputStream();
177         StreamPumper outPumper = new StreamPumper(appProcess.getInputStream(), stdoutBuffer);
178         StreamPumper errPumper = new StreamPumper(appProcess.getErrorStream(), stderrBuffer);
179         outPumperThread = new Thread(outPumper);
180         errPumperThread = new Thread(errPumper);
181 
182         outPumperThread.setDaemon(true);
183         errPumperThread.setDaemon(true);
184 
185         outPumperThread.start();
186         errPumperThread.start();
187     }
188 
189     /* Make sure all part of the app use the same method to get dates,
190      as different methods could produce different results
191      */
192     private static long epoch() {
193         return new Date().getTime();
194     }
195 
196     private static long lastModified(String fileName) throws IOException {
197         Path path = Paths.get(fileName);
198         BasicFileAttributes attr = Files.readAttributes(path, BasicFileAttributes.class);
199         return attr.lastModifiedTime().toMillis();
200     }
201 
202     private static void setLastModified(String fileName, long newTime) throws IOException {
203         Path path = Paths.get(fileName);
204         FileTime fileTime = FileTime.fromMillis(newTime);
205         Files.setLastModifiedTime(path, fileTime);
206     }
207 
208     /**
209      * create lock
210      *
211      * @throws IOException
212      */
213     public void createLock() throws IOException {
214         Path path = Paths.get(lockFileName);
215         // Files.deleteIfExists(path);
216         Files.createFile(path);
217         lockCreationTime = lastModified(lockFileName);
218     }
219 
220     /**
221      * Delete lock
222      *
223      * @throws IOException
224      */
225     public void deleteLock() throws IOException {
226         try {
227             Path path = Paths.get(lockFileName);
228             Files.delete(path);
229         } catch (NoSuchFileException ex) {
230             // Lock already deleted. Ignore error
231         }
232     }
233 
234     public void waitAppTerminate() {
235         // This code is modeled after tail end of ProcessTools.getOutput().
236         try {
237             // If the app hangs, we don&#39;t want to wait for the to test timeout.
238             if (!appProcess.waitFor(Utils.adjustTimeout(appWaitTime), TimeUnit.SECONDS)) {
239                 appProcess.destroy();
240                 appProcess.waitFor();
241             }
242             outPumperThread.join();
243             errPumperThread.join();
244         } catch (InterruptedException e) {
245             Thread.currentThread().interrupt();
246             // pass
247         }
248     }
249 
250     /**
251      * The app touches the lock file when it&#39;s started
252      * wait while it happens. Caller have to delete lock on wait error.
253      *
254      * @param timeout timeout in seconds
255      * @throws java.io.IOException
256      */
257     public void waitAppReady(long timeout) throws IOException {
258         // adjust timeout for timeout_factor and convert to ms
259         timeout = Utils.adjustTimeout(timeout) * 1000;
260         long here = epoch();
261         while (true) {
262             long epoch = epoch();
263             if (epoch - here &gt; timeout) {
264                 throw new IOException(&quot;App waiting timeout&quot;);
265             }
266 
267             // Live process should touch lock file every second
268             long lm = lastModified(lockFileName);
269             if (lm &gt; lockCreationTime) {
270                 break;
271             }
272 
273             // Make sure process didn&#39;t already exit
274             if (!appProcess.isAlive()) {
<a name="4" id="anc4"></a><span class="line-modified">275                 if (forceCrash) {</span>
<span class="line-added">276                     return; // This is expected. Just return.</span>
<span class="line-added">277                 } else {</span>
<span class="line-added">278                     throw new IOException(&quot;App exited unexpectedly with &quot; + appProcess.exitValue());</span>
<span class="line-added">279                 }</span>
280             }
281 
282             try {
283                 Thread.sleep(spinDelay);
284             } catch (InterruptedException ex) {
285                 // pass
286             }
287         }
288     }
289 
290     /**
291      * Waits for the application to start with the default timeout.
292      */
293     public void waitAppReady() throws IOException {
294         waitAppReady(appWaitTime);
295     }
296 
297     /**
298      * Analyze an environment and prepare a command line to
299      * run the app, app name should be added explicitly
300      */
301     private List&lt;String&gt; runAppPrepare(String[] vmArguments) {
302         List&lt;String&gt; cmd = new ArrayList&lt;&gt;();
303         cmd.add(JDKToolFinder.getTestJDKTool(&quot;java&quot;));
304         Collections.addAll(cmd, vmArguments);
<a name="5" id="anc5"></a><span class="line-added">305         if (forceCrash) {</span>
<span class="line-added">306             cmd.add(&quot;-XX:+CreateCoredumpOnCrash&quot;);</span>
<span class="line-added">307             // We need to find libLingeredApp.so for the crash() native method</span>
<span class="line-added">308             cmd.add(&quot;-Djava.library.path=&quot; + System.getProperty(&quot;java.library.path&quot;));</span>
<span class="line-added">309         }</span>
310 
311         // Make sure we set correct classpath to run the app
312         cmd.add(&quot;-cp&quot;);
313         String classpath = System.getProperty(&quot;test.class.path&quot;);
314         cmd.add((classpath == null) ? &quot;.&quot; : classpath);
315 
316         return cmd;
317     }
318 
319     /**
320      * Adds application name to the command line.
321      * By default adds name of this class.
322      */
323     protected void runAddAppName(List&lt;String&gt; cmd) {
324         cmd.add(getClass().getName());
325     }
326 
327     /**
328      * Assemble command line to a printable string
329      */
330     public void printCommandLine(List&lt;String&gt; cmd) {
331         // A bit of verbosity
332         System.out.println(cmd.stream()
333                 .map(s -&gt; &quot;&#39;&quot; + s + &quot;&#39;&quot;)
334                 .collect(Collectors.joining(&quot; &quot;, &quot;Command line: [&quot;, &quot;]&quot;)));
335     }
336 
337     /**
338      * Run the app.
339      * User should provide exact options to run app. Might use #Utils.getTestJavaOpts() to set default test options.
340      * @param vmOpts
341      * @throws IOException
342      */
343     public void runAppExactJvmOpts(String[] vmOpts)
344             throws IOException {
345 
346         List&lt;String&gt; cmd = runAppPrepare(vmOpts);
347 
348         runAddAppName(cmd);
349         cmd.add(lockFileName);
<a name="6" id="anc6"></a><span class="line-added">350         if (forceCrash) {</span>
<span class="line-added">351             cmd.add(&quot;forceCrash&quot;); // Let the subprocess know to force a crash</span>
<span class="line-added">352         }</span>
353 
354         printCommandLine(cmd);
355 
356         ProcessBuilder pb = new ProcessBuilder(cmd);
<a name="7" id="anc7"></a><span class="line-added">357         if (forceCrash) {</span>
<span class="line-added">358             // If we are going to force a core dump, apply &quot;ulimit -c unlimited&quot; if we can.</span>
<span class="line-added">359             pb = CoreUtils.addCoreUlimitCommand(pb);</span>
<span class="line-added">360         }</span>
361         // ProcessBuilder.start can throw IOException
362         appProcess = pb.start();
363 
364         startOutputPumpers();
365     }
366 
367     private void finishApp() {
368         if (appProcess != null) {
369             OutputBuffer output = getOutput();
370             String msg =
371                     &quot; LingeredApp stdout: [&quot; + output.getStdout() + &quot;];\n&quot; +
372                     &quot; LingeredApp stderr: [&quot; + output.getStderr() + &quot;]\n&quot; +
373                     &quot; LingeredApp exitValue = &quot; + appProcess.exitValue();
374 
375             System.out.println(msg);
376         }
377     }
378 
379     /**
380      * Delete lock file that signals app to terminate, then
381      * wait until app is actually terminated.
382      * @throws IOException
383      */
384     public void stopApp() throws IOException {
385         deleteLock();
386         // The startApp() of the derived app can throw
387         // an exception before the LA actually starts
388         if (appProcess != null) {
389             waitAppTerminate();
390 
391             finishApp();
392 
393             int exitcode = appProcess.exitValue();
394             if (exitcode != 0) {
395                 throw new IOException(&quot;LingeredApp terminated with non-zero exit code &quot; + exitcode);
396             }
397         }
398     }
399 
400     /**
401      *  High level interface for test writers
402      */
403 
404     /**
405      * Factory method that starts pre-created LingeredApp
406      * lock name is autogenerated
407      * User should provide exact options to run app. Might use #Utils.getTestJavaOpts() to set default test options.
408      * @param jvmOpts - the exact vm options used to start LingeredApp
409      * @param theApp - app to start
410      * @throws IOException
411      */
412     public static void startAppExactJvmOpts(LingeredApp theApp, String... jvmOpts) throws IOException {
413         theApp.createLock();
414         try {
415             theApp.runAppExactJvmOpts(jvmOpts);
416             theApp.waitAppReady();
417         } catch (Exception ex) {
418             theApp.deleteLock();
419             throw ex;
420         }
421     }
422 
423     /**
424      * Factory method that starts pre-created LingeredApp
425      * lock name is autogenerated, additionalJvmOpts are appended to default test options
426      * @param additionalJvmOpts - additional Jvm options, appended to #Utils.getTestJavaOpts();
427      * @param theApp - app to start
428      * @throws IOException
429      */
430     public static void startApp(LingeredApp theApp, String... additionalJvmOpts) throws IOException {
431         startAppExactJvmOpts(theApp, Utils.prependTestJavaOpts(additionalJvmOpts));
432     }
433 
434     /**
435      * Factory method that creates LingeredApp object with ready to use application
436      * lock name is autogenerated, additionalJvmOpts are appended to default test options
437      * @param additionalJvmOpts - additional Jvm options, appended to #Utils.getTestJavaOpts();
438      * @return LingeredApp object
439      * @throws IOException
440      */
441     public static LingeredApp startApp(String... additionalJvmOpts) throws IOException {
442         LingeredApp a = new LingeredApp();
443         try {
444             startApp(a, additionalJvmOpts);
445         } catch (Exception ex) {
446             System.out.println(&quot;LingeredApp failed to start: &quot; + ex);
447             a.finishApp();
448             throw ex;
449         }
450 
451         return a;
452     }
453 
454     public static void stopApp(LingeredApp app) throws IOException {
455         if (app != null) {
456             // LingeredApp can throw an exception during the intialization,
457             // make sure we don&#39;t have cascade NPE
458             app.stopApp();
459         }
460     }
461 
462     /**
463      * LastModified time might not work correctly in some cases it might
464      * cause later failures
465      */
466 
467     public static boolean isLastModifiedWorking() {
468         boolean sane = true;
469         try {
470             long lm = lastModified(&quot;.&quot;);
471             if (lm == 0) {
472                 System.err.println(&quot;SANITY Warning! The lastModifiedTime() doesn&#39;t work on this system, it returns 0&quot;);
473                 sane = false;
474             }
475 
476             long now = epoch();
477             if (lm &gt; now) {
478                 System.err.println(&quot;SANITY Warning! The Clock is wrong on this system lastModifiedTime() &gt; getTime()&quot;);
479                 sane = false;
480             }
481 
482             setLastModified(&quot;.&quot;, epoch());
483             long lm1 = lastModified(&quot;.&quot;);
484             if (lm1 &lt;= lm) {
485                 System.err.println(&quot;SANITY Warning! The setLastModified doesn&#39;t work on this system&quot;);
486                 sane = false;
487             }
488         }
489         catch(IOException e) {
490             System.err.println(&quot;SANITY Warning! IOException during sanity check &quot; + e);
491             sane = false;
492         }
493 
494         return sane;
495     }
496 
497     /**
<a name="8" id="anc8"></a><span class="line-modified">498      * This part is the application itself. First arg is optional &quot;forceCrash&quot;.</span>
<span class="line-added">499      * Following arg is the lock file name.</span>
500      */
501     public static void main(String args[]) {
<a name="9" id="anc9"></a><span class="line-added">502         boolean forceCrash = false;</span>
503 
<a name="10" id="anc10"></a><span class="line-modified">504         if (args.length == 0) {</span>
505             System.err.println(&quot;Lock file name is not specified&quot;);
506             System.exit(7);
<a name="11" id="anc11"></a><span class="line-added">507         } else if (args.length &gt; 2) {</span>
<span class="line-added">508             System.err.println(&quot;Too many arguments specified: &quot;  + args.length);</span>
<span class="line-added">509             System.exit(7);</span>
<span class="line-added">510         }</span>
<span class="line-added">511 </span>
<span class="line-added">512         if (args.length == 2) {</span>
<span class="line-added">513             if (args[1].equals(&quot;forceCrash&quot;)) {</span>
<span class="line-added">514                 forceCrash = true;</span>
<span class="line-added">515             } else {</span>
<span class="line-added">516                 System.err.println(&quot;Invalid 1st argment: &quot; + args[1]);</span>
<span class="line-added">517                 System.exit(7);</span>
<span class="line-added">518             }</span>
519         }
520 
521         String theLockFileName = args[0];
522         Path path = Paths.get(theLockFileName);
523 
524         try {
<a name="12" id="anc12"></a><span class="line-added">525             if (forceCrash) {</span>
<span class="line-added">526                 System.loadLibrary(&quot;LingeredApp&quot;); // location of native crash() method</span>
<span class="line-added">527                 crash();</span>
<span class="line-added">528             }</span>
529             while (Files.exists(path)) {
530                 // Touch the lock to indicate our readiness
531                 setLastModified(theLockFileName, epoch());
532                 Thread.sleep(spinDelay);
533             }
534         } catch (IOException ex) {
535             // Lock deleted while we are setting last modified time.
536             // Ignore the error and let the app exit.
537             if (Files.exists(path)) {
538                 // If the lock file was not removed, return an error.
539                 System.err.println(&quot;LingeredApp IOException: lock file still exists&quot;);
540                 System.exit(4);
541             }
542         } catch (Exception ex) {
543             System.err.println(&quot;LingeredApp ERROR: &quot; + ex);
544             // Leave exit_code = 1 to Java launcher
545             System.exit(3);
546         }
547 
548         System.exit(0);
549     }
550 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
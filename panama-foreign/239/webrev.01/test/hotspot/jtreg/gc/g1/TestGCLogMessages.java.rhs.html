<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/gc/g1/TestGCLogMessages.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package gc.g1;
 25 
 26 /*
 27  * @test TestGCLogMessages
 28  * @bug 8035406 8027295 8035398 8019342 8027959 8048179 8027962 8069330 8076463 8150630 8160055 8177059 8166191
 29  * @summary Ensure the output for a minor GC with G1
 30  * includes the expected necessary messages.
 31  * @requires vm.gc.G1
 32  * @library /test/lib
 33  * @modules java.base/jdk.internal.misc
 34  *          java.management
 35  * @build sun.hotspot.WhiteBox
 36  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 37  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
 38  *                   gc.g1.TestGCLogMessages
 39  */
 40 
 41 import jdk.test.lib.process.OutputAnalyzer;
 42 import jdk.test.lib.process.ProcessTools;
 43 import sun.hotspot.code.Compiler;
 44 
 45 public class TestGCLogMessages {
 46 
 47     private enum Level {
 48         OFF(&quot;&quot;),
 49         INFO(&quot;info&quot;),
 50         DEBUG(&quot;debug&quot;),
 51         TRACE(&quot;trace&quot;);
 52 
 53         private String logName;
 54 
 55         Level(String logName) {
 56             this.logName = logName;
 57         }
 58 
 59         public boolean lessThan(Level other) {
 60             return this.compareTo(other) &lt; 0;
 61         }
 62 
 63         public String toString() {
 64             return logName;
 65         }
 66     }
 67 
 68     private class LogMessageWithLevel {
 69         String message;
 70         Level level;
 71 
 72         public LogMessageWithLevel(String message, Level level) {
 73             this.message = message;
 74             this.level = level;
 75         }
 76 
 77         public boolean isAvailable() {
 78             return true;
 79         }
 80     };
 81 
 82     private class LogMessageWithLevelC2OrJVMCIOnly extends LogMessageWithLevel {
 83         public LogMessageWithLevelC2OrJVMCIOnly(String message, Level level) {
 84             super(message, level);
 85         }
 86 
 87         public boolean isAvailable() {
 88             return Compiler.isC2OrJVMCIIncludedInVmBuild();
 89         }
 90     }
 91 
 92     private LogMessageWithLevel allLogMessages[] = new LogMessageWithLevel[] {
 93         new LogMessageWithLevel(&quot;Pre Evacuate Collection Set&quot;, Level.INFO),
 94         new LogMessageWithLevel(&quot;Evacuate Collection Set&quot;, Level.INFO),
 95         new LogMessageWithLevel(&quot;Post Evacuate Collection Set&quot;, Level.INFO),
 96         new LogMessageWithLevel(&quot;Other&quot;, Level.INFO),
 97 
 98         // Merge Heap Roots
 99         new LogMessageWithLevel(&quot;Merge Heap Roots&quot;, Level.INFO),
100         new LogMessageWithLevel(&quot;Prepare Merge Heap Roots&quot;, Level.DEBUG),
101         new LogMessageWithLevel(&quot;Eager Reclaim&quot;, Level.DEBUG),
102         new LogMessageWithLevel(&quot;Remembered Sets&quot;, Level.DEBUG),
103         new LogMessageWithLevel(&quot;Merged Sparse&quot;, Level.DEBUG),
104         new LogMessageWithLevel(&quot;Merged Fine&quot;, Level.DEBUG),
105         new LogMessageWithLevel(&quot;Merged Coarse&quot;, Level.DEBUG),
106         new LogMessageWithLevel(&quot;Hot Card Cache&quot;, Level.DEBUG),
107         new LogMessageWithLevel(&quot;Log Buffers&quot;, Level.DEBUG),
108         new LogMessageWithLevel(&quot;Dirty Cards&quot;, Level.DEBUG),
109         new LogMessageWithLevel(&quot;Skipped Cards&quot;, Level.DEBUG),
110         // Scan Heap Roots
111         new LogMessageWithLevel(&quot;Scan Heap Roots&quot;, Level.DEBUG),
112         new LogMessageWithLevel(&quot;Scanned Cards&quot;, Level.DEBUG),
113         new LogMessageWithLevel(&quot;Scanned Blocks&quot;, Level.DEBUG),
114         new LogMessageWithLevel(&quot;Claimed Chunks&quot;, Level.DEBUG),
115         // Code Roots Scan
116         new LogMessageWithLevel(&quot;Code Root Scan&quot;, Level.DEBUG),
117         // Object Copy
118         new LogMessageWithLevel(&quot;Object Copy&quot;, Level.DEBUG),
119         new LogMessageWithLevel(&quot;Copied Bytes&quot;, Level.DEBUG),
120         new LogMessageWithLevel(&quot;LAB Waste&quot;, Level.DEBUG),
121         new LogMessageWithLevel(&quot;LAB Undo Waste&quot;, Level.DEBUG),
122         // Ext Root Scan
123         new LogMessageWithLevel(&quot;Thread Roots&quot;, Level.TRACE),
124         new LogMessageWithLevel(&quot;Universe Roots&quot;, Level.TRACE),
125         new LogMessageWithLevel(&quot;ObjectSynchronizer Roots&quot;, Level.TRACE),
126         new LogMessageWithLevel(&quot;Management Roots&quot;, Level.TRACE),
127         new LogMessageWithLevel(&quot;CLDG Roots&quot;, Level.TRACE),
128         new LogMessageWithLevel(&quot;JVMTI Roots&quot;, Level.TRACE),
129         new LogMessageWithLevel(&quot;CM RefProcessor Roots&quot;, Level.TRACE),
130         new LogMessageWithLevel(&quot;JNI Global Roots&quot;, Level.TRACE),
131         new LogMessageWithLevel(&quot;VM Global Roots&quot;, Level.TRACE),
132         // Redirty Cards
133         new LogMessageWithLevel(&quot;Redirty Cards&quot;, Level.DEBUG),
134         new LogMessageWithLevel(&quot;Parallel Redirty&quot;, Level.TRACE),
135         new LogMessageWithLevel(&quot;Redirtied Cards&quot;, Level.TRACE),
136         // Misc Top-level
137         new LogMessageWithLevel(&quot;Code Roots Purge&quot;, Level.DEBUG),
138         new LogMessageWithLevel(&quot;String Deduplication&quot;, Level.DEBUG),
139         new LogMessageWithLevel(&quot;Queue Fixup&quot;, Level.DEBUG),
140         new LogMessageWithLevel(&quot;Table Fixup&quot;, Level.DEBUG),
141         new LogMessageWithLevel(&quot;Expand Heap After Collection&quot;, Level.DEBUG),
142         new LogMessageWithLevel(&quot;Region Register&quot;, Level.DEBUG),
143         new LogMessageWithLevel(&quot;Prepare Heap Roots&quot;, Level.DEBUG),
144         new LogMessageWithLevel(&quot;Concatenate Dirty Card Logs&quot;, Level.DEBUG),
145         // Free CSet
146         new LogMessageWithLevel(&quot;Free Collection Set&quot;, Level.DEBUG),
147         new LogMessageWithLevel(&quot;Serial Free Collection Set&quot;, Level.TRACE),
148         new LogMessageWithLevel(&quot;Parallel Free Collection Set&quot;, Level.TRACE),
149         new LogMessageWithLevel(&quot;Young Free Collection Set&quot;, Level.TRACE),
150         new LogMessageWithLevel(&quot;Non-Young Free Collection Set&quot;, Level.TRACE),
151         // Rebuild Free List
152         new LogMessageWithLevel(&quot;Rebuild Free List&quot;, Level.DEBUG),
153         new LogMessageWithLevel(&quot;Serial Rebuild Free List&quot;, Level.TRACE),
154         new LogMessageWithLevel(&quot;Parallel Rebuild Free List&quot;, Level.TRACE),
155 
156         // Humongous Eager Reclaim
157         new LogMessageWithLevel(&quot;Humongous Reclaim&quot;, Level.DEBUG),
158         // Merge PSS
159         new LogMessageWithLevel(&quot;Merge Per-Thread State&quot;, Level.DEBUG),
160         // TLAB handling
161         new LogMessageWithLevel(&quot;Prepare TLABs&quot;, Level.DEBUG),
162         new LogMessageWithLevel(&quot;Resize TLABs&quot;, Level.DEBUG),
163         // Reference Processing
164         new LogMessageWithLevel(&quot;Reference Processing&quot;, Level.DEBUG),
165         // VM internal reference processing
166         new LogMessageWithLevel(&quot;Weak Processing&quot;, Level.DEBUG),
167         new LogMessageWithLevel(&quot;JNI Weak&quot;, Level.DEBUG),
168         new LogMessageWithLevel(&quot;StringTable Weak&quot;, Level.DEBUG),
169         new LogMessageWithLevel(&quot;ResolvedMethodTable Weak&quot;, Level.DEBUG),
170         new LogMessageWithLevel(&quot;VM Weak&quot;, Level.DEBUG),
171 
172         new LogMessageWithLevelC2OrJVMCIOnly(&quot;DerivedPointerTable Update&quot;, Level.DEBUG),
173         new LogMessageWithLevel(&quot;Start New Collection Set&quot;, Level.DEBUG),
174     };
175 
176     void checkMessagesAtLevel(OutputAnalyzer output, LogMessageWithLevel messages[], Level level) throws Exception {
177         for (LogMessageWithLevel l : messages) {
178             if (level.lessThan(l.level) || !l.isAvailable()) {
179                 output.shouldNotContain(l.message);
180             } else {
181                 output.shouldMatch(&quot;\\[&quot; + l.level + &quot;.*&quot; + l.message);
182             }
183         }
184     }
185 
186     public static void main(String[] args) throws Exception {
187         new TestGCLogMessages().testNormalLogs();
188         new TestGCLogMessages().testConcurrentRefinementLogs();
189         new TestGCLogMessages().testWithToSpaceExhaustionLogs();
<a name="1" id="anc1"></a><span class="line-modified">190         new TestGCLogMessages().testWithConcurrentStart();</span>
191         new TestGCLogMessages().testExpandHeap();
192     }
193 
194     private void testNormalLogs() throws Exception {
195 
196         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(&quot;-XX:+UseG1GC&quot;,
197                                                                   &quot;-Xmx10M&quot;,
198                                                                   GCTest.class.getName());
199 
200         OutputAnalyzer output = new OutputAnalyzer(pb.start());
201         checkMessagesAtLevel(output, allLogMessages, Level.OFF);
202         output.shouldHaveExitValue(0);
203 
204         pb = ProcessTools.createJavaProcessBuilder(&quot;-XX:+UseG1GC&quot;,
205                                                    &quot;-XX:+UseStringDeduplication&quot;,
206                                                    &quot;-Xmx10M&quot;,
207                                                    &quot;-Xlog:gc+phases=debug&quot;,
208                                                    GCTest.class.getName());
209 
210         output = new OutputAnalyzer(pb.start());
211         checkMessagesAtLevel(output, allLogMessages, Level.DEBUG);
212 
213         pb = ProcessTools.createJavaProcessBuilder(&quot;-XX:+UseG1GC&quot;,
214                                                    &quot;-XX:+UseStringDeduplication&quot;,
215                                                    &quot;-Xmx10M&quot;,
216                                                    &quot;-Xlog:gc+phases=trace&quot;,
217                                                    GCTest.class.getName());
218 
219         output = new OutputAnalyzer(pb.start());
220         checkMessagesAtLevel(output, allLogMessages, Level.TRACE);
221         output.shouldHaveExitValue(0);
222     }
223 
224     LogMessageWithLevel concRefineMessages[] = new LogMessageWithLevel[] {
225         new LogMessageWithLevel(&quot;Mutator refinement: &quot;, Level.DEBUG),
226         new LogMessageWithLevel(&quot;Concurrent refinement: &quot;, Level.DEBUG),
227         new LogMessageWithLevel(&quot;Total refinement: &quot;, Level.DEBUG),
228         // &quot;Concurrent refinement rate&quot; optionally printed if any.
229         // &quot;Generate dirty cards rate&quot; optionally printed if any.
230     };
231 
232     private void testConcurrentRefinementLogs() throws Exception {
233         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(&quot;-XX:+UseG1GC&quot;,
234                                                                   &quot;-Xmx10M&quot;,
235                                                                   &quot;-Xlog:gc+refine+stats=debug&quot;,
236                                                                   GCTest.class.getName());
237         OutputAnalyzer output = new OutputAnalyzer(pb.start());
238         checkMessagesAtLevel(output, concRefineMessages, Level.DEBUG);
239     }
240 
241     LogMessageWithLevel exhFailureMessages[] = new LogMessageWithLevel[] {
242         new LogMessageWithLevel(&quot;Evacuation Failure&quot;, Level.DEBUG),
243         new LogMessageWithLevel(&quot;Recalculate Used&quot;, Level.TRACE),
244         new LogMessageWithLevel(&quot;Remove Self Forwards&quot;, Level.TRACE),
245     };
246 
247     private void testWithToSpaceExhaustionLogs() throws Exception {
248         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(&quot;-XX:+UseG1GC&quot;,
249                                                                   &quot;-Xmx32M&quot;,
250                                                                   &quot;-Xmn16M&quot;,
251                                                                   &quot;-Xlog:gc+phases=debug&quot;,
252                                                                   GCTestWithToSpaceExhaustion.class.getName());
253 
254         OutputAnalyzer output = new OutputAnalyzer(pb.start());
255         checkMessagesAtLevel(output, exhFailureMessages, Level.DEBUG);
256         output.shouldHaveExitValue(0);
257 
258         pb = ProcessTools.createJavaProcessBuilder(&quot;-XX:+UseG1GC&quot;,
259                                                    &quot;-Xmx32M&quot;,
260                                                    &quot;-Xmn16M&quot;,
261                                                    &quot;-Xlog:gc+phases=trace&quot;,
262                                                    GCTestWithToSpaceExhaustion.class.getName());
263 
264         output = new OutputAnalyzer(pb.start());
265         checkMessagesAtLevel(output, exhFailureMessages, Level.TRACE);
266         output.shouldHaveExitValue(0);
267     }
268 
<a name="2" id="anc2"></a><span class="line-modified">269     private void testWithConcurrentStart() throws Exception {</span>
270         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(&quot;-XX:+UseG1GC&quot;,
271                                                                   &quot;-Xmx10M&quot;,
272                                                                   &quot;-Xbootclasspath/a:.&quot;,
273                                                                   &quot;-Xlog:gc*=debug&quot;,
274                                                                   &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
275                                                                   &quot;-XX:+WhiteBoxAPI&quot;,
<a name="3" id="anc3"></a><span class="line-modified">276                                                                   GCTestWithConcurrentStart.class.getName());</span>
277 
278         OutputAnalyzer output = new OutputAnalyzer(pb.start());
279         output.shouldContain(&quot;Clear Claimed Marks&quot;);
280         output.shouldHaveExitValue(0);
281     }
282 
283     private void testExpandHeap() throws Exception {
284         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(&quot;-XX:+UseG1GC&quot;,
285                                                                   &quot;-Xmx10M&quot;,
286                                                                   &quot;-Xbootclasspath/a:.&quot;,
287                                                                   &quot;-Xlog:gc+ergo+heap=debug&quot;,
288                                                                   &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
289                                                                   &quot;-XX:+WhiteBoxAPI&quot;,
290                                                                   GCTest.class.getName());
291 
292         OutputAnalyzer output = new OutputAnalyzer(pb.start());
293         output.shouldContain(&quot;Expand the heap. requested expansion amount: &quot;);
294         output.shouldContain(&quot;B expansion amount: &quot;);
295         output.shouldHaveExitValue(0);
296     }
297 
298 
299     static class GCTest {
300         private static byte[] garbage;
301         public static void main(String [] args) {
302             System.out.println(&quot;Creating garbage&quot;);
303             // create 128MB of garbage. This should result in at least one GC
304             for (int i = 0; i &lt; 1024; i++) {
305                 garbage = new byte[128 * 1024];
306             }
307             System.out.println(&quot;Done&quot;);
308         }
309     }
310 
311     static class GCTestWithToSpaceExhaustion {
312         private static byte[] garbage;
313         private static byte[] largeObject;
314         public static void main(String [] args) {
315             largeObject = new byte[16*1024*1024];
316             System.out.println(&quot;Creating garbage&quot;);
317             // create 128MB of garbage. This should result in at least one GC,
318             // some of them with to-space exhaustion.
319             for (int i = 0; i &lt; 1024; i++) {
320                 garbage = new byte[128 * 1024];
321             }
322             System.out.println(&quot;Done&quot;);
323         }
324     }
325 
<a name="4" id="anc4"></a><span class="line-modified">326     static class GCTestWithConcurrentStart {</span>
327         public static void main(String [] args) {
328             sun.hotspot.WhiteBox WB = sun.hotspot.WhiteBox.getWhiteBox();
329             WB.g1StartConcMarkCycle();
330         }
331     }
332 
333 }
334 
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
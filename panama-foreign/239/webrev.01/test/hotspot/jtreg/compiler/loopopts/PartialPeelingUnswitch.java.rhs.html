<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/compiler/loopopts/PartialPeelingUnswitch.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * @test
<a name="1" id="anc1"></a><span class="line-added">  26  * @requires vm.compiler2.enabled</span>
  27  * @bug 8233033 8235984 8240227
  28  * @summary Tests if partially peeled statements are not executed before the loop predicates by bailing out of loop unswitching.
  29  *
  30  * @run main/othervm -Xbatch -XX:LoopStripMiningIter=0
  31  *      -XX:CompileCommand=compileonly,compiler.loopopts.PartialPeelingUnswitch::test*
  32  *      -XX:CompileCommand=dontinline,compiler.loopopts.PartialPeelingUnswitch::dontInline*
  33  *      compiler.loopopts.PartialPeelingUnswitch
  34  * @run main/othervm -Xbatch -Xcomp -XX:LoopStripMiningIter=0
  35  *      -XX:CompileCommand=compileonly,compiler.loopopts.PartialPeelingUnswitch::test*
  36  *      -XX:CompileCommand=dontinline,compiler.loopopts.PartialPeelingUnswitch::dontInline*
  37  *      compiler.loopopts.PartialPeelingUnswitch
  38  * @run main/othervm -Xbatch
  39  *      -XX:CompileCommand=compileonly,compiler.loopopts.PartialPeelingUnswitch::test*
  40  *      -XX:CompileCommand=dontinline,compiler.loopopts.PartialPeelingUnswitch::dontInline*
  41  *      compiler.loopopts.PartialPeelingUnswitch
  42  * @run main/othervm -Xbatch -Xcomp
  43  *      -XX:CompileCommand=compileonly,compiler.loopopts.PartialPeelingUnswitch::test*
  44  *      -XX:CompileCommand=dontinline,compiler.loopopts.PartialPeelingUnswitch::dontInline*
  45  *      compiler.loopopts.PartialPeelingUnswitch
  46  * @run main/othervm -Xbatch
  47  *      -XX:CompileCommand=compileonly,compiler.loopopts.PartialPeelingUnswitch::*
  48  *      -XX:CompileCommand=dontinline,compiler.loopopts.PartialPeelingUnswitch::dontInline*
  49  *      compiler.loopopts.PartialPeelingUnswitch
  50  * @run main/othervm -Xbatch -Xcomp
  51  *      -XX:CompileCommand=compileonly,compiler.loopopts.PartialPeelingUnswitch::*
  52  *      -XX:CompileCommand=dontinline,compiler.loopopts.PartialPeelingUnswitch::dontInline*
  53  *      compiler.loopopts.PartialPeelingUnswitch
  54  */
  55 
  56 package compiler.loopopts;
  57 
  58 public class PartialPeelingUnswitch {
  59 
  60     public static int iFld;
  61     public static int w = 88;
  62     public static int x = 42;
  63     public static int y = 31;
  64     public static int z = 22;
  65     public static int val = 34;
  66     public static final int iCon = 20;
  67 
  68     public static int[] iArr = new int[10];
  69 
  70     public int test() {
  71         /*
  72          * The inner loop of this test is first partially peeled and then unswitched. An uncommon trap is hit in one
  73          * of the cloned loop predicates for the fast loop (set up at unswitching stage). The only partially peeled
  74          * statement &quot;iFld += 7&quot; was wrongly executed before the predicates (and before the loop itself).
  75          * When hitting the uncommon trap, &quot;iFld &gt;&gt;= 1&quot; was not yet executed. As a result, the interpreter directly
  76          * reexecuted &quot;iFld += 7&quot; again. This resulted in a wrong result for &quot;iFld&quot;. The fix in 8233033 makes peeled
  77          * statements control dependant on the cloned loop predicates such that they are executed after them. However,
  78          * some cases are not handled properly. For now, the new fix in 8235984 just bails out of loop unswitching.
  79          */
  80         iFld = 13;
  81         for (int i = 0; i &lt; 8; i++) {
  82             int j = 10;
  83             while (--j &gt; 0) {
  84                 iFld += -7;
  85                 switch ((i * 5) + 102) {
  86                 case 120:
  87                     break;
  88                 case 103:
  89                     break;
  90                 case 116:
  91                     break;
  92                 default:
  93                     iFld &gt;&gt;= 1;
  94                 }
  95             }
  96         }
  97         return iFld;
  98     }
  99 
 100     public int test2() {
 101         /*
 102          * Same nested loop structure as in test() but with more statements that are partially peeled from the inner loop.
 103          * Afterwards the inner loop is unswitched.
 104          */
 105         iFld = 13;
 106         int k = 0;
 107         for (int i = 0; i &lt; 8; i++) {
 108             int j = 10;
 109             while (--j &gt; 0) {
 110                 // All statements before the switch expression are partially peeled
 111                 iFld += -7;
 112                 x = y + iFld;
 113                 y = iArr[5];
 114                 k = 6;
 115                 iArr[5] = 5;
 116                 iArr[6] += 23;
 117                 iArr[7] = iArr[8] + iArr[6];
 118                 iArr[j] = 34;
 119                 switch ((i * 5) + 102) {
 120                 case 120:
 121                     break;
 122                 case 103:
 123                     break;
 124                 case 116:
 125                     break;
 126                 default:
 127                     iFld &gt;&gt;= 1;
 128                 }
 129             }
 130         }
 131         return iFld + k;
 132     }
 133 
 134     public int test3() {
 135         iFld = 13;
 136         if (z &lt; 34) {
 137             z = 34;
 138         }
 139 
 140         for (int i = 0; i &lt; 8; i++) {
 141             int j = 10;
 142             while (--j &gt; 0) {
 143                 iFld += -7;
 144                 iArr[5] = 8;
 145                 x = iArr[6];
 146                 y = x;
 147                 for (int k = 50; k &lt; 51; k++) {
 148                     x = iArr[7];
 149                 }
 150                 switch ((i * 5) + 102) {
 151                 case 120:
 152                     return iFld;
 153                 case 103:
 154                     break;
 155                 case 116:
 156                     break;
 157                 default:
 158                     if (iFld == -7) {
 159                         return iFld;
 160                     }
 161                     z = iArr[5];
 162                     iFld &gt;&gt;= 1;
 163                 }
 164             }
 165             iArr[5] = 34;
 166             dontInline(iArr[5]);
 167         }
 168         return iFld;
 169     }
 170 
 171     public int test4() {
 172         iFld = 13;
 173         if (z &lt; 34) {
 174             z = 34;
 175         }
 176 
 177         for (int i = 0; i &lt; 8; i++) {
 178             int j = 10;
 179             while (--j &gt; 0) {
 180                 iFld += -7;
 181                 iArr[5] = 8;
 182                 x = iArr[6];
 183                 y = x;
 184                 for (int k = 50; k &lt; 51; k++) {
 185                     x = iArr[7];
 186                 }
 187                 switch ((i * 5) + 102) {
 188                 case 120:
 189                     return iFld;
 190                 case 103:
 191                     break;
 192                 case 116:
 193                     break;
 194                 default:
 195                     if (iFld == -7) {
 196                         return iFld;
 197                     }
 198                     z = iArr[5];
 199                     iFld &gt;&gt;= 1;
 200                 }
 201             }
 202             iArr[5] = 34;
 203         }
 204         return iFld;
 205     }
 206 
 207     public int test5() {
 208         iFld = 13;
 209         for (int i = 0; i &lt; 8; i++) {
 210             int j = 10;
 211             while (--j &gt; 0) {
 212                 iFld += -7;
 213                 iArr[5] = 8;
 214                 x = iArr[6];
 215                 y = x;
 216                 for (int k = 50; k &lt; 51; k++) {
 217                     x = iArr[7];
 218                 }
 219                 switch ((i * 5) + 102) {
 220                 case 120:
 221                     return iFld;
 222                 case 103:
 223                     break;
 224                 case 116:
 225                     break;
 226                 default:
 227                     iFld &gt;&gt;= 1;
 228                 }
 229             }
 230         }
 231         return iFld;
 232     }
 233 
 234     public int test6() {
 235         iFld = 13;
 236         for (int i = 0; i &lt; 8; i++) {
 237             int j = 10;
 238             while (--j &gt; 0) {
 239                 iFld += -7;
 240                 iArr[5] = 8;
 241                 x = iArr[6];
 242                 y = x;
 243                 switch ((i * 5) + 102) {
 244                 case 120:
 245                     return iFld;
 246                 case 103:
 247                     break;
 248                 case 116:
 249                     break;
 250                 default:
 251                     iFld &gt;&gt;= 1;
 252                 }
 253             }
 254         }
 255         return iFld;
 256     }
 257 
 258     public int test7() {
 259         iFld = 13;
 260         for (int i = 0; i &lt; 8; i++) {
 261             int j = 10;
 262             while (--j &gt; 0) {
 263                 iFld += -7;
 264                 iArr[5] = 8;
 265                 switch ((i * 5) + 102) {
 266                 case 120:
 267                     return iFld;
 268                 case 103:
 269                     break;
 270                 case 116:
 271                     break;
 272                 default:
 273                     iFld &gt;&gt;= 1;
 274                 }
 275             }
 276         }
 277         return iFld;
 278     }
 279 
 280     public int test8() {
 281 
 282         iFld = 13;
 283         for (int i = 0; i &lt; 8; i++) {
 284             int j = 50;
 285             while (--j &gt; 0) {
 286                 // All statements before the switch expression are partially peeled
 287                 iFld += -7;
 288                 x = y + iFld;
 289                 y = iArr[5];
 290                 iArr[5] = 5;
 291                 iArr[6] += 23;
 292                 iArr[7] = iArr[8] + iArr[6];
 293                 switch ((val * 5) + 102) {
 294                 case 120:
 295                     break;
 296                 case 103:
 297                     break;
 298                 case 116:
 299                     break;
 300                 default:
 301                     iFld &gt;&gt;= 1;
 302                 }
 303             }
 304         }
 305         return iFld;
 306     }
 307 
 308 
 309     public int test9() {
 310         iFld = 13;
 311         for (int i = 0; i &lt; 8; i++) {
 312             int j = 10;
 313             while (--j &gt; 0) {
 314                 iFld += -7;
 315                 iArr[4] = 8;
 316                 x = iArr[5];
 317                 switch ((i * 5) + 102) {
 318                 case 120:
 319                     return iFld + 1;
 320                 case 103:
 321                     break;
 322                 case 116:
 323                     break;
 324                 default:
 325                     iFld &gt;&gt;= 1;
 326                 }
 327             }
 328         }
 329 
 330         return iFld;
 331     }
 332 
 333    public int test10() {
 334         if (z &lt; 34) {
 335             z = 34;
 336         }
 337 
 338         iFld = 13;
 339         for (int i = 0; i &lt; 80; i++) {
 340             int j = 50;
 341             while (--j &gt; 0) {
 342                 iFld += -7;
 343                 iArr[4] = 8;
 344                 x = iArr[5];
 345                 switch ((i * 5) + 102) {
 346                 case 120:
 347                     break;
 348                 case 103:
 349                     break;
 350                 case 116:
 351                     break;
 352                 default:
 353                     iFld &gt;&gt;= 1;
 354                 }
 355             }
 356         }
 357         if (z == 34) {
 358             x = iArr[6];
 359         }
 360         return iFld;
 361     }
 362 
 363 
 364     public int test11Xcomp() {
 365         if (z &lt; 34) {
 366             z = 34;
 367         }
 368 
 369         iFld = 13;
 370         for (int i = 0; i &lt; 80; i++) {
 371             int j = 50;
 372             while (--j &gt; 0) {
 373                 iFld += -7;
 374                 iArr[4] = 8;
 375                 x = iArr[5];
 376                 switch ((i * 5) + 102) {
 377                 case 120:
 378                     break;
 379                 case 103:
 380                     break;
 381                 case 116:
 382                     break;
 383                 default:
 384                     iFld &gt;&gt;= 1;
 385                 }
 386                 if (z == 34) {
 387                     break;
 388                 }
 389             }
 390         }
 391         if (z == 34) {
 392             x = iArr[6];
 393         }
 394         return iFld;
 395     }
 396 
 397     // Phi with multiple inputs from same peeled node
 398     public int test12Xcomp() {
 399         if (z &lt; 34) {
 400             z = 34;
 401         }
 402 
 403         iFld = 13;
 404         for (int i = 0; i &lt; 80; i++) {
 405             int j = 50;
 406             while (--j &gt; 0) {
 407                 iFld += -7;
 408                 iArr[4] = 8;
 409                 x = iArr[5];
 410                 switch ((i * 5) + 102) {
 411                 case 120:
 412                     break;
 413                 case 103:
 414                     break;
 415                 case 116:
 416                     return z;
 417                 case 106:
 418                     return y;
 419                 case 111:
 420                     return x;
 421                 default:
 422                     iFld &gt;&gt;= 1;
 423                 }
 424                 w = 45;
 425             }
 426 
 427         }
 428         if (z == 34) {
 429             x = iArr[6];
 430         }
 431         return iFld;
 432     }
 433 
 434     public int test13Xcomp() {
 435         if (z &lt; 34) {
 436             z = 34;
 437         }
 438 
 439         iFld = 13;
 440         for (int i = 0; i &lt; 80; i++) {
 441             int j = 50;
 442             while (--j &gt; 0) {
 443                 iFld += -7;
 444                 iArr[4] = 8;
 445                 x = iArr[5];
 446                 switch ((i * 5) + 102) {
 447                 case 120:
 448                     break;
 449                 case 103:
 450                     break;
 451                 case 116:
 452                     break;
 453                 default:
 454                     iFld &gt;&gt;= 1;
 455                 }
 456                 w = 45;
 457             }
 458 
 459         }
 460         if (z == 34) {
 461             x = iArr[6];
 462         }
 463         return iFld;
 464     }
 465 
 466     // Triggers after peeling with Xcomp
 467     public int test14Peel() {
 468         iFld = 13;
 469         for (int i = 0; i &lt; 8; i++) {
 470             int j = 10;
 471             while (--j &gt; 0) {
 472                 iFld += -7;
 473                 iArr[4] = 8;
 474                 x = iArr[5];
 475                 switch ((i * 5) + 102) {
 476                 case 120:
 477                     return iFld;
 478                 case 103:
 479                     break;
 480                 case 116:
 481                     break;
 482                 default:
 483                     iFld &gt;&gt;= 1;
 484                 }
 485                 iFld = 3;
 486             }
 487         }
 488         y = iArr[4];
 489         x = iArr[6];
 490 
 491         return iFld;
 492     }
 493 
 494 
 495     public int test15earlyCtrl() {
 496         iFld = 13;
 497         if (z &lt; 34) {
 498             z = 34;
 499         }
 500 
 501         for (int i = 0; i &lt; 8; i++) {
 502             int j = 10;
 503             while (--j &gt; 0) {
 504                 iFld += -7;
 505                 iArr[5] = 8;
 506                 x = iArr[6];
 507                 y = x;
 508                 x = iArr[7];
 509                 switch ((i * 5) + 102) {
 510                 case 120:
 511                     return iFld;
 512                 case 103:
 513                     break;
 514                 case 116:
 515                     break;
 516                 default:
 517                     if (iFld == -7) {
 518                         return iFld;
 519                     }
 520                     z = iArr[5];
 521                     iFld &gt;&gt;= 1;
 522                 }
 523             }
 524             if (iFld == 7) {
 525                 iArr[3] = 3;
 526             }
 527             dontInline(7);
 528             iArr[5] = 34;
 529         }
 530         return iFld;
 531     }
 532 
 533     // Load after loop -&gt; LoadI after loop from peeled StoreI
 534     public int test16() {
 535         iFld = 13;
 536         if (z &lt; 34) {
 537             z = 34;
 538         }
 539 
 540         for (int i = 0; i &lt; 8; i++) {
 541             int j = 60;
 542             while (--j &gt; 0) {
 543                 iFld += -7;
 544                 y += iFld + 1;
 545 
 546                 iArr[5] = 8;
 547                 x = iArr[6];
 548                 x = iArr[7];
 549                 switch ((i * 5) + 102) {
 550                 case 120:
 551                     return iFld;
 552                 case 103:
 553                     break;
 554                 case 116:
 555                     break;
 556                 default:
 557                     if (iFld == -7) {
 558                         return iFld;
 559                     }
 560                     z = iArr[5];
 561                     iFld &gt;&gt;= 1;
 562                 }
 563             }
 564             w = iArr[9];
 565             if (iFld == 7) {
 566                 iArr[3] = 3;
 567             }
 568             dontInline(7);
 569             iArr[5] = 34;
 570         }
 571         return iFld;
 572     }
 573 
 574     // Region 13 before return, which region to choose for MergeMem?
 575     public int test17Xcomp() {
 576         A p = dontInlineGetA();
 577         if (z &lt; 34) {
 578             z = 34;
 579         }
 580 
 581         iFld = 13;
 582         for (int i = 0; i &lt; 80; i++) {
 583             int j = 50;
 584             while (--j &gt; 0) {
 585                 iFld += -7;
 586                 iArr[4] = 8;
 587                 x = iArr[5];
 588                 y = p.i;
 589                 switch ((i * 5) + 102) {
 590                 case 120:
 591                     break;
 592                 case 103:
 593                     break;
 594                 case 116:
 595                     return z;
 596                 case 106:
 597                     return y;
 598                 case 111:
 599                     return x;
 600                 default:
 601                     iFld &gt;&gt;= 1;
 602                 }
 603                 w = 45;
 604             }
 605 
 606         }
 607         if (z == 34) {
 608             x = iArr[6];
 609         }
 610         return iFld;
 611     }
 612 
 613     // Region 13 before return, which region to choose for MergeMem?
 614     public int test18Xcomp() {
 615         if (z &lt; 34) {
 616             z = 34;
 617         }
 618 
 619         iFld = 13;
 620         for (int i = 0; i &lt; 80; i++) {
 621             int j = 50;
 622             while (--j &gt; 0) {
 623                 iFld += -7;
 624                 iArr[4] = 8;
 625                 x = iArr[5];
 626                 y = 85;
 627                 switch ((i * 5) + 102) {
 628                 case 120:
 629                     break;
 630                 case 103:
 631                     break;
 632                 case 116:
 633                     return z;
 634                 case 106:
 635                     if (z == 34) {
 636                         x = iArr[7];
 637                     }
 638                     return y;
 639                 case 111:
 640                     return x;
 641                 default:
 642                     iFld &gt;&gt;= 1;
 643                 }
 644                 w = 45;
 645             }
 646 
 647         }
 648 
 649         if (z == 34) {
 650             x = iArr[6];
 651         }
 652         return iFld;
 653     }
 654 
 655     public int test19Xcomp() {
 656         if (z &lt; 34) {
 657             z = 34;
 658         }
 659 
 660         iFld = 13;
 661         for (int i = 0; i &lt; 80; i++) {
 662             int j = 50;
 663             while (--j &gt; 0) {
 664                 iFld += -7;
 665                 iArr[4] = 8;
 666                 x = iArr[5]+ iArr[6];
 667                 y = 85;
 668                 switch ((i * 5) + 102) {
 669                 case 120:
 670                     break;
 671                 case 103:
 672                     break;
 673                 case 116:
 674                     break;
 675                 case 106:
 676                     if (z == 34) {
 677                         x = iArr[7];
 678                     }
 679                     return y;
 680                 case 111:
 681                     return x;
 682                 default:
 683                     iFld &gt;&gt;= 1;
 684                 }
 685                 w = 45;
 686             }
 687         }
 688 
 689         if (z == 34) {
 690             iArr[7] = 34;
 691         }
 692         return iFld;
 693     }
 694 
 695     public int test20() {
 696         if (z &lt; 34) {
 697             z = 34;
 698         }
 699 
 700         iFld = 13;
 701         for (int i = 0; i &lt; 80; i++) {
 702             int j = 50;
 703             while (--j &gt; 0) {
 704                 iFld += -7;
 705                 iArr[4] = 8;
 706                 x = iArr[5];
 707                 switch ((i * 5) + 102) {
 708                 case 120:
 709                     break;
 710                 case 103:
 711                     break;
 712                 case 116:
 713                     break;
 714                 default:
 715                     iFld &gt;&gt;= 1;
 716                 }
 717             }
 718             x = iArr[6];
 719         }
 720         if (z == 34) {
 721             x = iArr[7];
 722         }
 723         return iFld;
 724     }
 725 
 726 
 727     public int test21() {
 728         if (z &lt; 34) {
 729             z = 34;
 730         }
 731 
 732         iFld = 13;
 733         for (int i = 0; i &lt; 80; i++) {
 734             int j = 50;
 735             while (--j &gt; 0) {
 736                 iFld += -7;
 737                 iArr[4] = 8;
 738                 x = iArr[5];
 739                 switch ((i * 5) + 102) {
 740                 case 120:
 741                     break;
 742                 case 103:
 743                     break;
 744                 case 116:
 745                     break;
 746                 default:
 747                     iFld &gt;&gt;= 1;
 748                 }
 749             }
 750             x = iArr[6];
 751         }
 752         if (z == 34) {
 753             y = iArr[7];
 754         }
 755         return iFld;
 756     }
 757 
 758     public int testNoOuter() {
 759         iFld = 13;
 760         int j = 10;
 761         while (--j &gt; 0) {
 762             iFld += -7;
 763             switch ((iCon * 5) + 102) {
 764             case 120:
 765                 break;
 766             case 103:
 767                 break;
 768             case 116:
 769                 break;
 770             default:
 771                 iFld &gt;&gt;= 1;
 772             }
 773         }
 774         return iFld;
 775     }
 776 
 777     public int test2NoOuter() {
 778         /*
 779          * Same nested loop structure as in test() but with more statements that are partially peeled from the inner loop.
 780          * Afterwards the inner loop is unswitched.
 781          */
 782         iFld = 13;
 783         int k = 0;
 784         int j = 10;
 785         while (--j &gt; 0) {
 786             // All statements before the switch expression are partially peeled
 787             iFld += -7;
 788             x = y + iFld;
 789             y = iArr[5];
 790             k = 6;
 791             iArr[5] = 5;
 792             iArr[6] += 23;
 793             iArr[7] = iArr[8] + iArr[6];
 794             iArr[j] = 34;
 795             switch ((iCon * 5) + 102) {
 796             case 120:
 797                 break;
 798             case 103:
 799                 break;
 800             case 116:
 801                 break;
 802             default:
 803                 iFld &gt;&gt;= 1;
 804             }
 805         }
 806         return iFld + k;
 807     }
 808 
 809     public int test3NoOuter() {
 810         iFld = 13;
 811         if (z &lt; 34) {
 812             z = 34;
 813         }
 814 
 815         int j = 10;
 816         while (--j &gt; 0) {
 817             iFld += -7;
 818             iArr[5] = 8;
 819             x = iArr[6];
 820             y = x;
 821             for (int k = 50; k &lt; 51; k++) {
 822                 x = iArr[7];
 823             }
 824             switch ((iCon * 5) + 102) {
 825             case 120:
 826                 return iFld;
 827             case 103:
 828                 break;
 829             case 116:
 830                 break;
 831             default:
 832                 if (iFld == -7) {
 833                     return iFld;
 834                 }
 835                 z = iArr[5];
 836                 iFld &gt;&gt;= 1;
 837             }
 838         }
 839         iArr[5] = 34;
 840         dontInline(iArr[5]);
 841         return iFld;
 842     }
 843 
 844     public int test4NoOuter() {
 845         iFld = 13;
 846         if (z &lt; 34) {
 847             z = 34;
 848         }
 849 
 850         int j = 10;
 851         while (--j &gt; 0) {
 852             iFld += -7;
 853             iArr[5] = 8;
 854             x = iArr[6];
 855             y = x;
 856             for (int k = 50; k &lt; 51; k++) {
 857                 x = iArr[7];
 858             }
 859             switch ((iCon * 5) + 102) {
 860             case 120:
 861                 return iFld;
 862             case 103:
 863                 break;
 864             case 116:
 865                 break;
 866             default:
 867                 if (iFld == -7) {
 868                     return iFld;
 869                 }
 870                 z = iArr[5];
 871                 iFld &gt;&gt;= 1;
 872             }
 873         }
 874         iArr[5] = 34;
 875         return iFld;
 876     }
 877 
 878     public int test5NoOuter() {
 879         iFld = 13;
 880         int j = 10;
 881         while (--j &gt; 0) {
 882             iFld += -7;
 883             iArr[5] = 8;
 884             x = iArr[6];
 885             y = x;
 886             for (int k = 50; k &lt; 51; k++) {
 887                 x = iArr[7];
 888             }
 889             switch ((iCon * 5) + 102) {
 890             case 120:
 891                 return iFld;
 892             case 103:
 893                 break;
 894             case 116:
 895                 break;
 896             default:
 897                 iFld &gt;&gt;= 1;
 898             }
 899         }
 900         return iFld;
 901     }
 902 
 903     public int test6NoOuter() {
 904         iFld = 13;
 905         int j = 10;
 906         while (--j &gt; 0) {
 907             iFld += -7;
 908             iArr[5] = 8;
 909             x = iArr[6];
 910             y = x;
 911             switch ((iCon * 5) + 102) {
 912             case 120:
 913                 return iFld;
 914             case 103:
 915                 break;
 916             case 116:
 917                 break;
 918             default:
 919                 iFld &gt;&gt;= 1;
 920             }
 921         }
 922         return iFld;
 923     }
 924 
 925     public int test7NoOuter() {
 926         iFld = 13;
 927         int j = 10;
 928         while (--j &gt; 0) {
 929             iFld += -7;
 930             iArr[5] = 8;
 931             switch ((iCon * 5) + 102) {
 932             case 120:
 933                 return iFld;
 934             case 103:
 935                 break;
 936             case 116:
 937                 break;
 938             default:
 939                 iFld &gt;&gt;= 1;
 940             }
 941         }
 942         return iFld;
 943     }
 944 
 945     public int test8NoOuter() {
 946 
 947         iFld = 13;
 948         int j = 50;
 949         while (--j &gt; 0) {
 950             // All statements before the switch expression are partially peeled
 951             iFld += -7;
 952             x = y + iFld;
 953             y = iArr[5];
 954             iArr[5] = 5;
 955             iArr[6] += 23;
 956             iArr[7] = iArr[8] + iArr[6];
 957             switch ((val * 5) + 102) {
 958             case 120:
 959                 break;
 960             case 103:
 961                 break;
 962             case 116:
 963                 break;
 964             default:
 965                 iFld &gt;&gt;= 1;
 966             }
 967         }
 968         return iFld;
 969     }
 970 
 971 
 972     public int test9NoOuter() {
 973         iFld = 13;
 974         int j = 10;
 975         while (--j &gt; 0) {
 976             iFld += -7;
 977             iArr[4] = 8;
 978             x = iArr[5];
 979             switch ((iCon * 5) + 102) {
 980             case 120:
 981                 return iFld + 1;
 982             case 103:
 983                 break;
 984             case 116:
 985                 break;
 986             default:
 987                 iFld &gt;&gt;= 1;
 988             }
 989         }
 990         return iFld;
 991     }
 992 
 993    public int test10NoOuter() {
 994         if (z &lt; 34) {
 995             z = 34;
 996         }
 997 
 998         iFld = 13;
 999         int j = 50;
1000         while (--j &gt; 0) {
1001             iFld += -7;
1002             iArr[4] = 8;
1003             x = iArr[5];
1004             switch ((iCon * 5) + 102) {
1005             case 120:
1006                 break;
1007             case 103:
1008                 break;
1009             case 116:
1010                 break;
1011             default:
1012                 iFld &gt;&gt;= 1;
1013             }
1014         }
1015         if (z == 34) {
1016             x = iArr[6];
1017         }
1018         return iFld;
1019     }
1020 
1021 
1022     public int test11XcompNoOuter() {
1023         if (z &lt; 34) {
1024             z = 34;
1025         }
1026 
1027         iFld = 13;
1028         int j = 50;
1029         while (--j &gt; 0) {
1030             iFld += -7;
1031             iArr[4] = 8;
1032             x = iArr[5];
1033             switch ((iCon * 5) + 102) {
1034             case 120:
1035                 break;
1036             case 103:
1037                 break;
1038             case 116:
1039                 break;
1040             default:
1041                 iFld &gt;&gt;= 1;
1042             }
1043             if (z == 34) {
1044                 break;
1045             }
1046         }
1047         if (z == 34) {
1048             x = iArr[6];
1049         }
1050         return iFld;
1051     }
1052 
1053     // Phi with multiple inputs from same peeled node
1054     public int test12XcompNoOuter() {
1055         if (z &lt; 34) {
1056             z = 34;
1057         }
1058 
1059         iFld = 13;
1060         int j = 50;
1061         while (--j &gt; 0) {
1062             iFld += -7;
1063             iArr[4] = 8;
1064             x = iArr[5];
1065             switch ((iCon * 5) + 102) {
1066             case 120:
1067                 break;
1068             case 103:
1069                 break;
1070             case 116:
1071                 return z;
1072             case 106:
1073                 return y;
1074             case 111:
1075                 return x;
1076             default:
1077                 iFld &gt;&gt;= 1;
1078             }
1079             w = 45;
1080         }
1081 
1082         if (z == 34) {
1083             x = iArr[6];
1084         }
1085         return iFld;
1086     }
1087 
1088     public int test13XcompNoOuter() {
1089         if (z &lt; 34) {
1090             z = 34;
1091         }
1092 
1093         iFld = 13;
1094         int j = 50;
1095         while (--j &gt; 0) {
1096             iFld += -7;
1097             iArr[4] = 8;
1098             x = iArr[5];
1099             switch ((iCon * 5) + 102) {
1100             case 120:
1101                 break;
1102             case 103:
1103                 break;
1104             case 116:
1105                 break;
1106             default:
1107                 iFld &gt;&gt;= 1;
1108             }
1109             w = 45;
1110         }
1111 
1112         if (z == 34) {
1113             x = iArr[6];
1114         }
1115         return iFld;
1116     }
1117 
1118     // Triggers after peeling with Xcomp
1119     public int test14PeelNoOuter() {
1120         iFld = 13;
1121         int j = 10;
1122         while (--j &gt; 0) {
1123             iFld += -7;
1124             iArr[4] = 8;
1125             x = iArr[5];
1126             switch ((iCon * 5) + 102) {
1127             case 120:
1128                 return iFld;
1129             case 103:
1130                 break;
1131             case 116:
1132                 break;
1133             default:
1134                 iFld &gt;&gt;= 1;
1135             }
1136             iFld = 3;
1137         }
1138         y = iArr[4];
1139         x = iArr[6];
1140 
1141         return iFld;
1142     }
1143 
1144 
1145     public int test15earlyCtrlNoOuter() {
1146         iFld = 13;
1147         if (z &lt; 34) {
1148             z = 34;
1149         }
1150 
1151         int j = 10;
1152         while (--j &gt; 0) {
1153             iFld += -7;
1154             iArr[5] = 8;
1155             x = iArr[6];
1156             y = x;
1157             x = iArr[7];
1158             switch ((iCon * 5) + 102) {
1159             case 120:
1160                 return iFld;
1161             case 103:
1162                 break;
1163             case 116:
1164                 break;
1165             default:
1166                 if (iFld == -7) {
1167                     return iFld;
1168                 }
1169                 z = iArr[5];
1170                 iFld &gt;&gt;= 1;
1171             }
1172         }
1173         if (iFld == 7) {
1174             iArr[3] = 3;
1175         }
1176         dontInline(7);
1177         iArr[5] = 34;
1178         return iFld;
1179     }
1180 
1181     // Load after loop -&gt; LoadI after loop from peeled StoreI
1182     public int test16NoOuter() {
1183         iFld = 13;
1184         if (z &lt; 34) {
1185             z = 34;
1186         }
1187 
1188         int j = 60;
1189         while (--j &gt; 0) {
1190             iFld += -7;
1191             y += iFld + 1;
1192 
1193             iArr[5] = 8;
1194             x = iArr[6];
1195             x = iArr[7];
1196             switch ((iCon * 5) + 102) {
1197             case 120:
1198                 return iFld;
1199             case 103:
1200                 break;
1201             case 116:
1202                 break;
1203             default:
1204                 if (iFld == -7) {
1205                     return iFld;
1206                 }
1207                 z = iArr[5];
1208                 iFld &gt;&gt;= 1;
1209             }
1210         }
1211         w = iArr[9];
1212         if (iFld == 7) {
1213             iArr[3] = 3;
1214         }
1215         dontInline(7);
1216         iArr[5] = 34;
1217         return iFld;
1218     }
1219 
1220     // Region 13 before return, which region to choose for MergeMem?
1221     public int test17XcompNoOuter() {
1222         A p = dontInlineGetA();
1223         if (z &lt; 34) {
1224             z = 34;
1225         }
1226 
1227         iFld = 13;
1228         int j = 50;
1229         while (--j &gt; 0) {
1230             iFld += -7;
1231             iArr[4] = 8;
1232             x = iArr[5];
1233             y = p.i;
1234             switch ((iCon * 5) + 102) {
1235             case 120:
1236                 break;
1237             case 103:
1238                 break;
1239             case 116:
1240                 return z;
1241             case 106:
1242                 return y;
1243             case 111:
1244                 return x;
1245             default:
1246                 iFld &gt;&gt;= 1;
1247             }
1248             w = 45;
1249         }
1250         if (z == 34) {
1251             x = iArr[6];
1252         }
1253         return iFld;
1254     }
1255 
1256     // Region 13 before return, which region to choose for MergeMem?
1257     public int test18XcompNoOuter() {
1258         if (z &lt; 34) {
1259             z = 34;
1260         }
1261 
1262         iFld = 13;
1263         int j = 50;
1264         while (--j &gt; 0) {
1265             iFld += -7;
1266             iArr[4] = 8;
1267             x = iArr[5];
1268             y = 85;
1269             switch ((iCon * 5) + 102) {
1270             case 120:
1271                 break;
1272             case 103:
1273                 break;
1274             case 116:
1275                 return z;
1276             case 106:
1277                 if (z == 34) {
1278                     x = iArr[7];
1279                 }
1280                 return y;
1281             case 111:
1282                 return x;
1283             default:
1284                 iFld &gt;&gt;= 1;
1285             }
1286             w = 45;
1287         }
1288 
1289         if (z == 34) {
1290             x = iArr[6];
1291         }
1292         return iFld;
1293     }
1294 
1295     public int test19XcompNoOuter() {
1296         if (z &lt; 34) {
1297             z = 34;
1298         }
1299 
1300         iFld = 13;
1301         int j = 50;
1302         while (--j &gt; 0) {
1303             iFld += -7;
1304             iArr[4] = 8;
1305             x = iArr[5]+ iArr[6];
1306             y = 85;
1307             switch ((iCon * 5) + 102) {
1308             case 120:
1309                 break;
1310             case 103:
1311                 break;
1312             case 116:
1313                 break;
1314             case 106:
1315                 if (z == 34) {
1316                     x = iArr[7];
1317                 }
1318                 return y;
1319             case 111:
1320                 return x;
1321             default:
1322                 iFld &gt;&gt;= 1;
1323             }
1324             w = 45;
1325         }
1326 
1327         if (z == 34) {
1328             iArr[7] = 34;
1329         }
1330         return iFld;
1331     }
1332 
1333 
1334     public int test20NoOuter() {
1335         if (z &lt; 34) {
1336             z = 34;
1337         }
1338 
1339         iFld = 13;
1340         int j = 50;
1341         while (--j &gt; 0) {
1342             iFld += -7;
1343             iArr[4] = 8;
1344             x = iArr[5];
1345             switch ((iCon * 5) + 102) {
1346             case 120:
1347                 break;
1348             case 103:
1349                 break;
1350             case 116:
1351                 break;
1352             default:
1353                 iFld &gt;&gt;= 1;
1354             }
1355         }
1356         x = iArr[6];
1357         if (z == 34) {
1358             x = iArr[7];
1359         }
1360         return iFld;
1361     }
1362 
1363     public int test21NoOuter() {
1364         if (z &lt; 34) {
1365             z = 34;
1366         }
1367 
1368         iFld = 13;
1369         int j = 50;
1370         while (--j &gt; 0) {
1371             iFld += -7;
1372             iArr[4] = 8;
1373             x = iArr[5];
1374             switch ((iCon * 5) + 102) {
1375             case 120:
1376                 break;
1377             case 103:
1378                 break;
1379             case 116:
1380                 break;
1381             default:
1382                 iFld &gt;&gt;= 1;
1383             }
1384         }
1385         x = iArr[6];
1386         if (z == 34) {
1387             y = iArr[7];
1388         }
1389         return iFld;
1390     }
1391     public static void main(String[] strArr) {
1392         BookKeeper[] bookKeeper = new BookKeeper[22];
1393         for (int i = 0; i &lt; 22; i++) {
1394             bookKeeper[i] = new BookKeeper();
1395         }
1396 
1397         PartialPeelingUnswitch _instance = new PartialPeelingUnswitch();
1398         for (int i = 0; i &lt; 2000; i++) {
1399             int result = _instance.test();
1400             if (result != -7) {
1401                 throw new RuntimeException(&quot;Result should always be -7 but was &quot; + result);
1402             }
1403         }
1404 
1405         for (int i = 0; i &lt; 2000; i++) {
1406             int result = _instance.test2();
1407             check(-1, result);
1408             check(-7, iFld);
1409             check(-9, x);
1410             check(5, y);
1411             check(5, iArr[5]);
1412             check(149, iArr[6]);
1413             check(183, iArr[7]);
1414 
1415             // Reset fields
1416             for (int j = 0; j &lt; 10; j++) {
1417                 iArr[j] = 0;
1418             }
1419             x = 42;
1420             y = 31;
1421         }
1422 
1423         for (int i = 0; i &lt; 2000; i++) {
1424             BookKeeper.setup();
1425             _instance.test3();
1426             bookKeeper[3].compare();
1427             BookKeeper.setup();
1428             _instance.test4();
1429             bookKeeper[4].compare();
1430             BookKeeper.setup();
1431             _instance.test5();
1432             bookKeeper[5].compare();
1433             BookKeeper.setup();
1434             _instance.test6();
1435             bookKeeper[6].compare();
1436             BookKeeper.setup();
1437             _instance.test7();
1438             bookKeeper[7].compare();
1439             BookKeeper.setup();
1440             _instance.test8();
1441             bookKeeper[8].compare();
1442             BookKeeper.setup();
1443             _instance.test9();
1444             bookKeeper[9].compare();
1445             BookKeeper.setup();
1446             _instance.test10();
1447             bookKeeper[10].compare();
1448             BookKeeper.setup();
1449             _instance.test11Xcomp();
1450             bookKeeper[11].compare();
1451             BookKeeper.setup();
1452             _instance.test12Xcomp();
1453             bookKeeper[12].compare();
1454             BookKeeper.setup();
1455             _instance.test13Xcomp();
1456             bookKeeper[13].compare();
1457             BookKeeper.setup();
1458             _instance.test14Peel();
1459             bookKeeper[14].compare();
1460             BookKeeper.setup();
1461             _instance.test15earlyCtrl();
1462             bookKeeper[15].compare();
1463             BookKeeper.setup();
1464             _instance.test16();
1465             bookKeeper[16].compare();
1466             BookKeeper.setup();
1467             _instance.test17Xcomp();
1468             bookKeeper[17].compare();
1469             BookKeeper.setup();
1470             _instance.test18Xcomp();
1471             bookKeeper[18].compare();
1472             BookKeeper.setup();
1473             _instance.test19Xcomp();
1474             bookKeeper[19].compare();
1475             BookKeeper.setup();
1476             _instance.test20();
1477             bookKeeper[20].compare();
1478             BookKeeper.setup();
1479             _instance.test21();
1480             bookKeeper[21].compare();
1481         }
1482 
1483         for (int i = 0; i &lt; 22; i++) {
1484             bookKeeper[i] = new BookKeeper();
1485         }
1486 
1487         for (int i = 0; i &lt; 2000; i++) {
1488             BookKeeper.setup();
1489             _instance.testNoOuter();
1490             bookKeeper[1].compare();
1491             BookKeeper.setup();
1492             _instance.test2NoOuter();
1493             bookKeeper[2].compare();
1494             BookKeeper.setup();
1495             _instance.test3NoOuter();
1496             bookKeeper[3].compare();
1497             BookKeeper.setup();
1498             _instance.test4NoOuter();
1499             bookKeeper[4].compare();
1500             BookKeeper.setup();
1501             _instance.test5NoOuter();
1502             bookKeeper[5].compare();
1503             BookKeeper.setup();
1504             _instance.test6NoOuter();
1505             bookKeeper[6].compare();
1506             BookKeeper.setup();
1507             _instance.test7NoOuter();
1508             bookKeeper[7].compare();
1509             BookKeeper.setup();
1510             _instance.test8NoOuter();
1511             bookKeeper[8].compare();
1512             BookKeeper.setup();
1513             _instance.test9NoOuter();
1514             bookKeeper[9].compare();
1515             BookKeeper.setup();
1516             _instance.test10NoOuter();
1517             bookKeeper[10].compare();
1518             BookKeeper.setup();
1519             _instance.test11XcompNoOuter();
1520             bookKeeper[11].compare();
1521             BookKeeper.setup();
1522             _instance.test12XcompNoOuter();
1523             bookKeeper[12].compare();
1524             BookKeeper.setup();
1525             _instance.test13XcompNoOuter();
1526             bookKeeper[13].compare();
1527             BookKeeper.setup();
1528             _instance.test14PeelNoOuter();
1529             bookKeeper[14].compare();
1530             BookKeeper.setup();
1531             _instance.test15earlyCtrlNoOuter();
1532             bookKeeper[15].compare();
1533             BookKeeper.setup();
1534             _instance.test16NoOuter();
1535             bookKeeper[16].compare();
1536             BookKeeper.setup();
1537             _instance.test17XcompNoOuter();
1538             bookKeeper[17].compare();
1539             BookKeeper.setup();
1540             _instance.test18XcompNoOuter();
1541             bookKeeper[18].compare();
1542             BookKeeper.setup();
1543             _instance.test19XcompNoOuter();
1544             bookKeeper[19].compare();
1545             BookKeeper.setup();
1546             _instance.test20NoOuter();
1547             bookKeeper[20].compare();
1548             BookKeeper.setup();
1549             _instance.test21NoOuter();
1550             bookKeeper[21].compare();
1551         }
1552 
1553         for (int i = 0; i &lt; 22; i++) {
1554             bookKeeper[i] = new BookKeeper();
1555         }
1556 
1557         for (int i = 0; i &lt; 2000; i++) {
1558             BookKeeper.setup();
1559             setZ(i);
1560             _instance.test3();
1561             bookKeeper[3].compare(i);
1562             BookKeeper.setup();
1563             setZ(i);
1564             _instance.test4();
1565             bookKeeper[4].compare(i);
1566             BookKeeper.setup();
1567             setZ(i);
1568             _instance.test5();
1569             bookKeeper[5].compare(i);
1570             BookKeeper.setup();
1571             setZ(i);
1572             _instance.test6();
1573             bookKeeper[6].compare(i);
1574             BookKeeper.setup();
1575             setZ(i);
1576             _instance.test7();
1577             bookKeeper[7].compare(i);
1578             BookKeeper.setup();
1579             setZ(i);
1580             _instance.test8();
1581             bookKeeper[8].compare(i);
1582             BookKeeper.setup();
1583             setZ(i);
1584             _instance.test9();
1585             bookKeeper[9].compare(i);
1586             BookKeeper.setup();
1587             setZ(i);
1588             _instance.test10();
1589             bookKeeper[10].compare(i);
1590             setZ(i);
1591             BookKeeper.setup();
1592             _instance.test11Xcomp();
1593             bookKeeper[11].compare(i);
1594             setZ(i);
1595             BookKeeper.setup();
1596             _instance.test12Xcomp();
1597             bookKeeper[12].compare(i);
1598             setZ(i);
1599             BookKeeper.setup();
1600             _instance.test13Xcomp();
1601             bookKeeper[13].compare(i);
1602             setZ(i);
1603             BookKeeper.setup();
1604             _instance.test14Peel();
1605             bookKeeper[14].compare(i);
1606             setZ(i);
1607             BookKeeper.setup();
1608             _instance.test15earlyCtrl();
1609             bookKeeper[15].compare(i);
1610             setZ(i);
1611             BookKeeper.setup();
1612             _instance.test16();
1613             bookKeeper[16].compare(i);
1614             setZ(i);
1615             BookKeeper.setup();
1616             _instance.test17Xcomp();
1617             bookKeeper[17].compare(i);
1618             setZ(i);
1619             BookKeeper.setup();
1620             _instance.test18Xcomp();
1621             bookKeeper[18].compare(i);
1622             setZ(i);
1623             BookKeeper.setup();
1624             _instance.test19Xcomp();
1625             bookKeeper[19].compare(i);
1626             setZ(i);
1627             BookKeeper.setup();
1628             _instance.test20();
1629             bookKeeper[20].compare(i);
1630             setZ(i);
1631             BookKeeper.setup();
1632             _instance.test21();
1633             bookKeeper[21].compare(i);
1634         }
1635 
1636         for (int i = 0; i &lt; 22; i++) {
1637             bookKeeper[i] = new BookKeeper();
1638         }
1639 
1640         for (int i = 0; i &lt; 2000; i++) {
1641             BookKeeper.setup();
1642             setZ(i);
1643             _instance.testNoOuter();
1644             bookKeeper[1].compare(i);
1645             BookKeeper.setup();
1646             setZ(i);
1647             _instance.test2NoOuter();
1648             bookKeeper[2].compare(i);
1649             BookKeeper.setup();
1650             setZ(i);
1651             _instance.test3NoOuter();
1652             bookKeeper[3].compare(i);
1653             BookKeeper.setup();
1654             setZ(i);
1655             _instance.test4NoOuter();
1656             bookKeeper[4].compare(i);
1657             BookKeeper.setup();
1658             setZ(i);
1659             _instance.test5NoOuter();
1660             bookKeeper[5].compare(i);
1661             BookKeeper.setup();
1662             setZ(i);
1663             _instance.test6NoOuter();
1664             bookKeeper[6].compare(i);
1665             BookKeeper.setup();
1666             setZ(i);
1667             _instance.test7NoOuter();
1668             bookKeeper[7].compare(i);
1669             BookKeeper.setup();
1670             setZ(i);
1671             _instance.test8NoOuter();
1672             bookKeeper[8].compare(i);
1673             BookKeeper.setup();
1674             setZ(i);
1675             _instance.test9NoOuter();
1676             bookKeeper[9].compare(i);
1677             BookKeeper.setup();
1678             setZ(i);
1679             _instance.test10NoOuter();
1680             bookKeeper[10].compare(i);
1681             BookKeeper.setup();
1682             setZ(i);
1683             _instance.test11XcompNoOuter();
1684             bookKeeper[11].compare(i);
1685             BookKeeper.setup();
1686             setZ(i);
1687             _instance.test12XcompNoOuter();
1688             bookKeeper[12].compare(i);
1689             BookKeeper.setup();
1690             setZ(i);
1691             _instance.test13XcompNoOuter();
1692             bookKeeper[13].compare(i);
1693             BookKeeper.setup();
1694             setZ(i);
1695             _instance.test14PeelNoOuter();
1696             bookKeeper[14].compare(i);
1697             BookKeeper.setup();
1698             setZ(i);
1699             _instance.test15earlyCtrlNoOuter();
1700             bookKeeper[15].compare(i);
1701             BookKeeper.setup();
1702             setZ(i);
1703             _instance.test16NoOuter();
1704             bookKeeper[16].compare(i);
1705             BookKeeper.setup();
1706             setZ(i);
1707             _instance.test17XcompNoOuter();
1708             bookKeeper[17].compare(i);
1709             BookKeeper.setup();
1710             setZ(i);
1711             _instance.test18XcompNoOuter();
1712             bookKeeper[18].compare(i);
1713             BookKeeper.setup();
1714             setZ(i);
1715             _instance.test19XcompNoOuter();
1716             bookKeeper[19].compare(i);
1717             BookKeeper.setup();
1718             setZ(i);
1719             _instance.test20NoOuter();
1720             bookKeeper[20].compare(i);
1721             BookKeeper.setup();
1722             setZ(i);
1723             _instance.test21NoOuter();
1724             bookKeeper[21].compare(i);
1725         }
1726     }
1727 
1728     public static void setZ(int i) {
1729         if (i % 2 == 0) {
1730             z = 23;
1731         } else {
1732             z = 35;
1733         }
1734     }
1735 
1736     public static void check(int expected, int actual) {
1737         if (expected != actual) {
1738             throw new RuntimeException(&quot;Wrong result, expected: &quot; + expected + &quot;, actual: &quot; + actual);
1739         }
1740     }
1741 
1742     public void dontInline(int i) { }
1743 
1744     class A {
1745         int i = 3;
1746     }
1747 
1748     A dontInlineGetA() {
1749         return new A();
1750     }
1751 
1752     static class BookKeeper {
1753         public int iFld;
1754         public int w;
1755         public int x;
1756         public int y;
1757         public int z;
1758         public int val;
1759         public int[] iArr;
1760 
1761         public int iFld2;
1762         public int w2;
1763         public int x2;
1764         public int y2;
1765         public int z2;
1766         public int val2;
1767         public int[] iArr2;
1768 
1769         public void compare() {
1770             if (iArr == null) {
1771                 // First compare, initialize values
1772                 this.iFld = PartialPeelingUnswitch.iFld;
1773                 this.w = PartialPeelingUnswitch.w;
1774                 this.x = PartialPeelingUnswitch.x;
1775                 this.y = PartialPeelingUnswitch.y;
1776                 this.z = PartialPeelingUnswitch.z;
1777                 this.val = PartialPeelingUnswitch.val;
1778                 this.iArr = new int[10];
1779                 System.arraycopy(PartialPeelingUnswitch.iArr, 0, this.iArr, 0, 10);
1780             } else {
1781 
1782                 // Do comparison
1783                 boolean check = PartialPeelingUnswitch.iFld == this.iFld
1784                                 &amp;&amp; this.w == PartialPeelingUnswitch.w
1785                                 &amp;&amp; this.x == PartialPeelingUnswitch.x
1786                                 &amp;&amp; this.y == PartialPeelingUnswitch.y
1787                                 &amp;&amp; this.z == PartialPeelingUnswitch.z
1788                                 &amp;&amp; this.val == PartialPeelingUnswitch.val;
1789                 for (int i = 0; i &lt; 10; i++) {
1790                     check = check &amp;&amp; this.iArr[i] == PartialPeelingUnswitch.iArr[i];
1791                 }
1792 
1793                 if (!check) {
1794                     throw new RuntimeException(&quot;Failed comparison&quot;);
1795                 }
1796             }
1797         }
1798 
1799         public void compare(int i) {
1800             if (i % 2 == 0 &amp;&amp; iArr == null) {
1801                 // First compare, initialize values
1802                 this.iFld = PartialPeelingUnswitch.iFld;
1803                 this.w = PartialPeelingUnswitch.w;
1804                 this.x = PartialPeelingUnswitch.x;
1805                 this.y = PartialPeelingUnswitch.y;
1806                 this.z = PartialPeelingUnswitch.z;
1807                 this.val = PartialPeelingUnswitch.val;
1808                 this.iArr = new int[10];
1809                 System.arraycopy(PartialPeelingUnswitch.iArr, 0, this.iArr, 0, 10);
1810             } else if (i % 2 != 0 &amp;&amp; iArr2 == null) {
1811                 // First compare, initialize values
1812                 this.iFld2 = PartialPeelingUnswitch.iFld;
1813                 this.w2 = PartialPeelingUnswitch.w;
1814                 this.x2 = PartialPeelingUnswitch.x;
1815                 this.y2 = PartialPeelingUnswitch.y;
1816                 this.z2 = PartialPeelingUnswitch.z;
1817                 this.val2 = PartialPeelingUnswitch.val;
1818                 this.iArr2 = new int[10];
1819                 System.arraycopy(PartialPeelingUnswitch.iArr, 0, this.iArr2, 0, 10);
1820             } else if (i % 2 == 0) {
1821                 // Do comparison
1822                 boolean check = PartialPeelingUnswitch.iFld == this.iFld
1823                                 &amp;&amp; this.w == PartialPeelingUnswitch.w
1824                                 &amp;&amp; this.x == PartialPeelingUnswitch.x
1825                                 &amp;&amp; this.y == PartialPeelingUnswitch.y
1826                                 &amp;&amp; this.z == PartialPeelingUnswitch.z
1827                                 &amp;&amp; this.val == PartialPeelingUnswitch.val;
1828                 for (int j = 0; j &lt; 10; j++) {
1829                     check = check &amp;&amp; this.iArr[j] == PartialPeelingUnswitch.iArr[j];
1830                 }
1831 
1832                 if (!check) {
1833                     throw new RuntimeException(&quot;Failed comparison&quot;);
1834                 }
1835             } else {
1836                 // Do comparison
1837                 boolean check = PartialPeelingUnswitch.iFld == this.iFld2
1838                                 &amp;&amp; this.w2 == PartialPeelingUnswitch.w
1839                                 &amp;&amp; this.x2 == PartialPeelingUnswitch.x
1840                                 &amp;&amp; this.y2 == PartialPeelingUnswitch.y
1841                                 &amp;&amp; this.z2 == PartialPeelingUnswitch.z
1842                                 &amp;&amp; this.val2 == PartialPeelingUnswitch.val;
1843                 for (int j = 0; j &lt; 10; j++) {
1844                     check = check &amp;&amp; this.iArr2[j] == PartialPeelingUnswitch.iArr[j];
1845                 }
1846 
1847                 if (!check) {
1848                     throw new RuntimeException(&quot;Failed comparison&quot;);
1849                 }
1850             }
1851         }
1852 
1853         public static void setup() {
1854             PartialPeelingUnswitch.iFld = 0;
1855             PartialPeelingUnswitch.w = 88;
1856             PartialPeelingUnswitch.x = 42;
1857             PartialPeelingUnswitch.y = 31;
1858             PartialPeelingUnswitch.z = 22;
1859             PartialPeelingUnswitch.val = 34;
1860             PartialPeelingUnswitch.iArr = new int[10];
1861         }
1862     }
1863 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
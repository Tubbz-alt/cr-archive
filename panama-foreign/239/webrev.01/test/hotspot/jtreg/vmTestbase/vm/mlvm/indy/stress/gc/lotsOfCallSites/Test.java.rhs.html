<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/vm/mlvm/indy/stress/gc/lotsOfCallSites/Test.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 /*
 26  * @test
 27  *
 28  * @summary converted from VM Testbase vm/mlvm/indy/stress/gc/lotsOfCallSites.
 29  * VM Testbase keywords: [feature_mlvm, nonconcurrent]
 30  *
 31  * @library /vmTestbase
 32  *          /test/lib
<a name="1" id="anc1"></a>
 33  * @build sun.hotspot.WhiteBox
 34  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 35  *
 36  * @comment build test class and indify classes
 37  * @build vm.mlvm.indy.stress.gc.lotsOfCallSites.Test
 38  *        vm.mlvm.indy.stress.gc.lotsOfCallSites.INDIFY_Testee
 39  * @run driver vm.mlvm.share.IndifiedClassesBuilder
 40  *
 41  * @run main/othervm -Xbootclasspath/a:.
 42  *                   -XX:+UnlockDiagnosticVMOptions
 43  *                   -XX:+WhiteBoxAPI
 44  *                   vm.mlvm.indy.stress.gc.lotsOfCallSites.Test
 45  */
 46 
 47 package vm.mlvm.indy.stress.gc.lotsOfCallSites;
 48 
 49 import java.lang.invoke.CallSite;
 50 import java.lang.invoke.MethodHandles;
 51 import java.lang.invoke.MethodHandle;
 52 import java.lang.invoke.MethodType;
 53 import java.lang.ref.PhantomReference;
 54 import java.lang.ref.Reference;
 55 import java.lang.ref.ReferenceQueue;
 56 import java.lang.reflect.Field;
 57 import java.lang.reflect.Method;
 58 import java.lang.reflect.InvocationTargetException;
 59 import java.lang.management.MemoryMXBean;
 60 import java.lang.management.MemoryPoolMXBean;
 61 import java.lang.management.ManagementFactory;
 62 import java.lang.management.MemoryUsage;
 63 import java.util.HashSet;
 64 
 65 import nsk.share.test.Stresser;
 66 import vm.mlvm.share.CustomClassLoaders;
 67 import vm.mlvm.share.Env;
 68 import vm.mlvm.share.MlvmTest;
 69 import vm.mlvm.share.WhiteBoxHelper;
 70 import vm.share.FileUtils;
 71 import vm.share.options.Option;
 72 
 73 /**
 74  * The test creates a lot of CallSites by loading a class with a bootstrap method and invokedynamic
 75  * via a custom classloader in a loop.
 76  *
 77  * The test verifies that all CallSites are &quot;delivered to heaven&quot; by creating a PhantomReference per
 78  *  a CallSite and checking the number of references put into a queue.
 79  *
 80  */
 81 public class Test extends MlvmTest {
 82 
 83     // TODO (separate bug should be filed): move this option to MlvmTest level
 84     @Option(name = &quot;heapdump&quot;, default_value = &quot;false&quot;, description = &quot;Dump heap after test has finished&quot;)
 85     private boolean heapDumpOpt = false;
 86 
 87     @Option(name = &quot;iterations&quot;, default_value = &quot;100000&quot;, description = &quot;Iterations: each iteration loads one new class&quot;)
 88     private int iterations = 100_000;
 89 
 90     private static final int GC_COUNT = 6;
 91     private static final boolean TERMINATE_ON_FULL_METASPACE = false;
 92 
 93     private static final ReferenceQueue&lt;CallSite&gt; objQueue = new ReferenceQueue&lt;CallSite&gt;();
 94     private static final HashSet&lt;PhantomReference&lt;CallSite&gt;&gt; references = new HashSet&lt;PhantomReference&lt;CallSite&gt;&gt;();
 95     private static long loadedClassCount = 0;
 96 
 97     // We avoid direct references to the testee class to avoid loading it by application class loader
 98     // Otherwise the testee class is loaded both by the custom and the application class loaders,
 99     // and when java.lang.invoke.MH.COMPILE_THRESHOLD={0,1} is defined, the test fails with
100     // &quot;java.lang.IncompatibleClassChangeError: disagree on InnerClasses attribute&quot;
101     private static final String TESTEE_CLASS_NAME = Test.class.getPackage().getName() + &quot;.&quot; + &quot;INDIFY_Testee&quot;;
102     private static final String TESTEE_REFERENCES_FIELD = &quot;references&quot;;
103     private static final String TESTEE_OBJQUEUE_FIELD = &quot;objQueue&quot;;
104     private static final String TESTEE_BOOTSTRAP_CALLED_FIELD = &quot;bootstrapCalled&quot;;
105     private static final String TESTEE_TARGET_CALLED_FIELD = &quot;targetCalled&quot;;
106     private static final String TESTEE_INDY_METHOD = &quot;indyWrapper&quot;;
107 
108     private static int removeQueuedReferences() {
109         int count = 0;
110         Reference&lt;? extends CallSite&gt; r;
111         while ((r = objQueue.poll()) != null) {
112             if (!references.remove(r)) {
113                 Env.traceNormal(&quot;Reference &quot; + r + &quot; was not registered!&quot;);
114             }
115             ++count;
116         }
117         if (count &gt; 0) {
118             Env.traceVerbose(&quot;Removed &quot; + count + &quot; phantom references&quot;);
119         } else {
120             Env.traceDebug(&quot;Removed &quot; + count + &quot; phantom references&quot;);
121         }
122         return count;
123     }
124 
125     private MemoryPoolMXBean getClassMetadataMemoryPoolMXBean() {
126     MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();
127     for (MemoryPoolMXBean memPool : ManagementFactory.getMemoryPoolMXBeans()) {
128             String name = memPool.getName();
129         if ((name.contains(&quot;Compressed class space&quot;) || name.contains(&quot;Metaspace&quot;)) &amp;&amp; memPool.getUsage() != null) {
130                 return memPool;
131             }
132         }
133         return null;
134     }
135 
136     private MethodHandle getFullGCMethod() throws NoSuchMethodException, IllegalAccessException {
137         try {
138             return WhiteBoxHelper.getMethod(&quot;fullGC&quot;, MethodType.methodType(void.class));
139         } catch (NoSuchMethodException | ClassNotFoundException | InvocationTargetException e) {
140             Env.traceDebug(e, &quot;No WhiteBox API. Will use System.gc() instead of WhiteBox.fullGC()&quot;);
141             return MethodHandles.lookup().findStatic(System.class, &quot;gc&quot;, MethodType.methodType(void.class));
142         }
143     }
144 
145     @Override
146     public boolean run() throws Throwable {
147         setHeapDumpAfter(heapDumpOpt);
148 
149         final byte[] classBytes = FileUtils.readClass(TESTEE_CLASS_NAME);
150         final MemoryPoolMXBean classMetadataPoolMXB = getClassMetadataMemoryPoolMXBean();
151         final String memPoolName = classMetadataPoolMXB == null ? &quot;&quot; : classMetadataPoolMXB.getName();
152 
153         MethodHandle mhCollectHeap = getFullGCMethod();
154 
155         int removedEntries = 0;
156 
157         Stresser stresser = createStresser();
158         stresser.start(iterations);
159         try {
160             while (stresser.continueExecution()) {
161                 stresser.iteration();
162 
163                 iteration(classBytes, TESTEE_CLASS_NAME);
164                 removedEntries += removeQueuedReferences();
165 
166                 if (stresser.getIteration() % 1000 == 0) {
167                     Env.traceNormal(&quot;Iterations: &quot; + stresser.getIteration() + &quot; removed entries: &quot; + removedEntries);
168                     if (TERMINATE_ON_FULL_METASPACE &amp;&amp; classMetadataPoolMXB != null) {
169                         MemoryUsage mu = classMetadataPoolMXB.getUsage();
170                         Env.traceNormal(memPoolName + &quot; usage: &quot; + mu);
171                         if  (mu.getUsed() &gt;= mu.getMax() * 9 / 10) {
172                             Env.traceNormal(memPoolName + &quot; is nearly out of space: &quot; + mu + &quot;. Terminating.&quot;);
173                             break;
174                         }
175                     }
176                 }
177             }
178 
179         } catch (OutOfMemoryError e) {
180             Env.traceNormal(e, &quot;Out of memory. This is OK&quot;);
181         } finally {
182             stresser.finish();
183         }
184 
185         for (int i = 0; i &lt; GC_COUNT; ++i) {
186             mhCollectHeap.invoke();
187             Thread.sleep(500);
188             removedEntries += removeQueuedReferences();
189         }
190 
191         removedEntries += removeQueuedReferences();
192 
193         Env.traceNormal(&quot;Loaded classes: &quot; + loadedClassCount
194                       + &quot;; References left in set: &quot; + references.size()
195                       + &quot;; References removed from queue: &quot; + removedEntries);
196 
197         if (references.size() != 0 || removedEntries != loadedClassCount) {
198             Env.complain(&quot;Not all of the created CallSites were GC-ed&quot;);
199             return false;
200         }
201 
202         return true;
203     }
204 
205     private void iteration(byte[] classBytes, String indyClassName) throws Throwable {
206         ClassLoader cl = CustomClassLoaders.makeClassBytesLoader(classBytes, indyClassName);
207         Class&lt;?&gt; c = cl.loadClass(indyClassName);
208         ++loadedClassCount;
209 
210         if (c.getClassLoader() != cl) {
211             throw new RuntimeException(&quot;Invalid class loader: &quot; + c.getClassLoader() + &quot;; required=&quot; + cl);
212         }
213 
214         Field vr = c.getDeclaredField(TESTEE_REFERENCES_FIELD);
215         vr.set(null, references);
216 
217         Field voq = c.getDeclaredField(TESTEE_OBJQUEUE_FIELD);
218         voq.set(null, objQueue);
219 
220         Field vbc = c.getDeclaredField(TESTEE_BOOTSTRAP_CALLED_FIELD);
221         if (vbc.getBoolean(null)) {
222             throw new RuntimeException(TESTEE_BOOTSTRAP_CALLED_FIELD + &quot; flag should not be set. Not a fresh copy of the testee class?&quot;);
223         }
224 
225         Field vt = c.getDeclaredField(TESTEE_TARGET_CALLED_FIELD);
226         if (vt.getBoolean(null)) {
227             throw new RuntimeException(TESTEE_TARGET_CALLED_FIELD + &quot; flag should not be set. Not a fresh copy of the testee class?&quot;);
228         }
229 
230         Method m = c.getDeclaredMethod(TESTEE_INDY_METHOD);
231         m.invoke(null);
232 
233         if (!vbc.getBoolean(null) ) {
234             throw new RuntimeException(&quot;Bootstrap method of the testee class was not called&quot;);
235         }
236 
237         if (!vt.getBoolean(null) ) {
238             throw new RuntimeException(&quot;Target method of the testee class was not called&quot;);
239         }
240     }
241 
242     public static void main(String[] args) {
243         MlvmTest.launch(args);
244     }
245 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
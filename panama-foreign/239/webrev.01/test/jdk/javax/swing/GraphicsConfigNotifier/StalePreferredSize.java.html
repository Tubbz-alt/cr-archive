<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/javax/swing/GraphicsConfigNotifier/StalePreferredSize.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.awt.Dimension;
 25 import java.awt.EventQueue;
 26 import java.awt.FlowLayout;
 27 import java.awt.Font;
 28 import java.util.List;
 29 import java.util.Objects;
 30 import java.util.concurrent.Callable;
 31 
 32 import javax.swing.JButton;
 33 import javax.swing.JCheckBox;
 34 import javax.swing.JComboBox;
 35 import javax.swing.JComponent;
 36 import javax.swing.JEditorPane;
 37 import javax.swing.JFormattedTextField;
 38 import javax.swing.JFrame;
 39 import javax.swing.JLabel;
 40 import javax.swing.JList;
 41 import javax.swing.JMenu;
 42 import javax.swing.JMenuItem;
 43 import javax.swing.JRadioButton;
 44 import javax.swing.JScrollPane;
 45 import javax.swing.JSpinner;
 46 import javax.swing.JTable;
 47 import javax.swing.JTextArea;
 48 import javax.swing.JTextField;
 49 import javax.swing.JToolTip;
 50 import javax.swing.JTree;
 51 import javax.swing.Popup;
 52 import javax.swing.PopupFactory;
 53 import javax.swing.SpinnerListModel;
 54 import javax.swing.SwingUtilities;
 55 import javax.swing.UIManager;
 56 import javax.swing.UnsupportedLookAndFeelException;
 57 import javax.swing.tree.DefaultMutableTreeNode;
 58 
 59 import sun.swing.MenuItemLayoutHelper;
 60 
 61 import static javax.swing.UIManager.getInstalledLookAndFeels;
 62 
 63 /**
 64  * @test
 65  * @key headful
 66  * @bug 8201552 8213843 8213535
 67  * @summary Initial layout of the component should use correct graphics config.
 68  *          It is checked by SwingUtilities.updateComponentTreeUI(), if layout
 69  *          was correct the call to updateComponentTreeUI() will be no-op.
 70  * @modules java.desktop/sun.swing
 71  * @compile -encoding utf-8 StalePreferredSize.java
 72  * @run main/othervm/timeout=400 StalePreferredSize
 73  * @run main/othervm/timeout=400 -Dsun.java2d.uiScale=1 StalePreferredSize
 74  * @run main/othervm/timeout=400 -Dsun.java2d.uiScale=2.25 StalePreferredSize
 75  */
 76 public final class StalePreferredSize {
 77 
 78     // Some text to be tested
 79     static final String TEXT[] = new String[]{
 80             &quot;&lt;span&gt;A few words to get started before the &quot;
 81                     + &quot;bug&lt;/span&gt;&lt;span&gt;overlapping text&lt;/span&gt;&quot;,
 82             &quot;A quick brown fox jumps over the lazy dog&quot;,
 83             &quot;El veloz murciélago hindú comía feliz cardillo y kiwi. La cigüeña &quot;
 84                     + &quot;tocaba el saxofón detrás del palenque de paja&quot;,
 85             &quot;Voix ambiguë d’un cœur qui au zéphyr préfère les jattes de kiwis&quot;,
 86             &quot;다람쥐 헌 쳇바퀴에 타고파&quot;,
 87             &quot;Съешь ещё этих мягких французских булок да выпей же чаю&quot;};
 88 
 89     static JFrame frame;
 90     static Popup popup;
 91     static JComponent component;
 92     static int typeFont = 0; // 0 - default, 1 - bold, 2 - italic
 93     static boolean addViaPopup;
 94 
 95     public static void main(final String[] args) throws Exception {
 96         for (final UIManager.LookAndFeelInfo laf : getInstalledLookAndFeels()) {
 97             EventQueue.invokeAndWait(() -&gt; setLookAndFeel(laf));
 98             for (typeFont = 0; typeFont &lt; 3; typeFont++) {
 99                 System.err.println(&quot;typeFont = &quot; + typeFont);
100                 for (boolean usePopup : new boolean[]{true, false}) {
101                     addViaPopup = usePopup;
102                     System.err.println(&quot;Use popup: &quot; + usePopup);
103                     for (final boolean html : new boolean[]{true, false}) {
104                         for (String text : TEXT) {
105                             if (html) {
106                                 text = &quot;&lt;html&gt;&quot; + text + &quot;&lt;/html&gt;&quot;;
107                             }
108                             test(text);
109                         }
110                     }
111                 }
112             }
113         }
114     }
115 
116     private static void test(String text) throws Exception {
117         System.err.println(&quot;text = &quot; + text);
118         // Each Callable create a component to be tested
119         final List&lt;Callable&lt;JComponent&gt;&gt; comps = List.of(
120                 () -&gt; new JLabel(text),
121                 () -&gt; new JButton(text),
122                 () -&gt; new JMenuItem(text),
123                 () -&gt; new JMenu(text),
124                 () -&gt; new JList&lt;&gt;(new String[]{text}),
125                 () -&gt; new JComboBox&lt;&gt;(new String[]{text}),
126                 () -&gt; new JTextField(text),
127                 () -&gt; new JTextArea(text),
128                 () -&gt; new JCheckBox(text),
129                 () -&gt; new JFormattedTextField(text),
130                 () -&gt; new JRadioButton(text),
131                 () -&gt; new JTree(new DefaultMutableTreeNode(text)),
132                 () -&gt; new JSpinner(new SpinnerListModel(new String[]{text})),
133                 () -&gt; {
134                     JToolTip tip = new JToolTip();
135                     tip.setTipText(text);
136                     return tip;
137                     },
138                 () -&gt; {
139                     JEditorPane pane = new JEditorPane();
140                     pane.setText(text);
141                     return pane;
142                     },
143                 () -&gt; {
144                     JTable table = new JTable(1, 1);
145                     table.getModel().setValueAt(text, 0, 0);
146                     return table;
147                     }
148         );
149 
150         for (final Callable&lt;JComponent&gt; creator : comps) {
151             checkComponent(creator);
152         }
153     }
154 
155     static void checkComponent(Callable&lt;JComponent&gt; creator) throws Exception {
156         EventQueue.invokeAndWait(() -&gt; {
157 
158             try {
159                 component = creator.call();
160             } catch (Exception e) {
161                 throw new RuntimeException(e);
162             }
163 
164             component.setEnabled(false); // minimize paint/focus events amount
165             Font font = component.getFont();
166             if (typeFont == 1) {
167                 component.setFont(new Font(font.deriveFont(Font.BOLD).getAttributes()));
168             }
169             if (typeFont == 2) {
170                 component.setFont(new Font(font.deriveFont(Font.ITALIC).getAttributes()));
171             }
172 
173             frame = new JFrame();
174             // incorrect initial insets may ruin our size calculation
175             frame.setUndecorated(true); // TODO JDK-8244388
176             frame.setLayout(new FlowLayout());
177             frame.setSize(700, 400);
178             frame.setLocationRelativeTo(null);
179             if (addViaPopup) {
180                 // doing our best to show lightweight or mediumweight popup
181                 int x = frame.getX() + 50;
182                 int y = frame.getY() + 200;
183                 PopupFactory factory = PopupFactory.getSharedInstance();
184                 popup = factory.getPopup(frame, component, x, y);
185                 if (component instanceof JMenuItem) {
186                     // TODO JDK-8244400
187                     MenuItemLayoutHelper.clearUsedParentClientProperties((JMenuItem)component);
188                 }
189             } else {
190                 frame.add(new JScrollPane(component));
191             }
192             frame.setVisible(true);
193             if (popup != null) {
194                 popup.show();
195             }
196         });
197 
198         EventQueue.invokeAndWait(() -&gt; {
199             if (!component.isValid()) {
200                 dispose();
201                 throw new RuntimeException(&quot;Component must be valid&quot;);
202             }
203 
204             // After the frame was shown we change nothing, so current layout
205             // should be optimal and updateComponentTreeUI() should be no-op
206             Dimension before = component.getPreferredSize();
207             SwingUtilities.updateComponentTreeUI(frame);
208             Dimension after = component.getPreferredSize();
209 
210             // We change the font size to some big value, as a result the
211             // layout and preferredSize of the component should be changed
212             component.setFont(component.getFont().deriveFont(35f));
213             Dimension last = component.getPreferredSize();
214 
215             dispose();
216 
217             if (!Objects.equals(before, after)) {
218                 System.err.println(&quot;Component: &quot; + component);
219                 System.err.println(&quot;Before: &quot; + before);
220                 System.err.println(&quot;After: &quot; + after);
221                 throw new RuntimeException(&quot;Wrong PreferredSize&quot;);
222             }
223             // TODO JDK-8206024
224 //            if (Objects.equals(after, last)) {
225 //                System.err.println(&quot;Component: &quot; + component);
226 //                System.err.println(&quot;After: &quot; + after);
227 //                System.err.println(&quot;Last: &quot; + last);
228 //                throw new RuntimeException(&quot;Wrong PreferredSize&quot;);
229 //            }
230         });
231     }
232 
233     private static void dispose() {
234         if (popup != null) {
235             popup.hide();
236             popup = null;
237         }
238         frame.dispose();
239     }
240 
241     private static void setLookAndFeel(final UIManager.LookAndFeelInfo laf) {
242         try {
243             UIManager.setLookAndFeel(laf.getClassName());
244             System.err.println(&quot;LookAndFeel: &quot; + laf.getClassName());
245         } catch (final UnsupportedLookAndFeelException ignored) {
246             System.err.println(
247                     &quot;Unsupported LookAndFeel: &quot; + laf.getClassName());
248         } catch (ClassNotFoundException | InstantiationException |
249                 IllegalAccessException e) {
250             throw new RuntimeException(e);
251         }
252     }
253 }
    </pre>
  </body>
</html>
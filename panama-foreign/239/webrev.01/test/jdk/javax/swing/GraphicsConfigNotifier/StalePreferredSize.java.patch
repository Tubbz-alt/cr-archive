diff a/test/jdk/javax/swing/GraphicsConfigNotifier/StalePreferredSize.java b/test/jdk/javax/swing/GraphicsConfigNotifier/StalePreferredSize.java
--- a/test/jdk/javax/swing/GraphicsConfigNotifier/StalePreferredSize.java
+++ b/test/jdk/javax/swing/GraphicsConfigNotifier/StalePreferredSize.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -19,11 +19,10 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
-import java.awt.Component;
 import java.awt.Dimension;
 import java.awt.EventQueue;
 import java.awt.FlowLayout;
 import java.awt.Font;
 import java.util.List;
@@ -31,10 +30,11 @@
 import java.util.concurrent.Callable;
 
 import javax.swing.JButton;
 import javax.swing.JCheckBox;
 import javax.swing.JComboBox;
+import javax.swing.JComponent;
 import javax.swing.JEditorPane;
 import javax.swing.JFormattedTextField;
 import javax.swing.JFrame;
 import javax.swing.JLabel;
 import javax.swing.JList;
@@ -46,29 +46,34 @@
 import javax.swing.JTable;
 import javax.swing.JTextArea;
 import javax.swing.JTextField;
 import javax.swing.JToolTip;
 import javax.swing.JTree;
+import javax.swing.Popup;
+import javax.swing.PopupFactory;
 import javax.swing.SpinnerListModel;
 import javax.swing.SwingUtilities;
 import javax.swing.UIManager;
 import javax.swing.UnsupportedLookAndFeelException;
 import javax.swing.tree.DefaultMutableTreeNode;
 
+import sun.swing.MenuItemLayoutHelper;
+
 import static javax.swing.UIManager.getInstalledLookAndFeels;
 
 /**
  * @test
  * @key headful
- * @bug 8201552 8213843
+ * @bug 8201552 8213843 8213535
  * @summary Initial layout of the component should use correct graphics config.
  *          It is checked by SwingUtilities.updateComponentTreeUI(), if layout
  *          was correct the call to updateComponentTreeUI() will be no-op.
+ * @modules java.desktop/sun.swing
  * @compile -encoding utf-8 StalePreferredSize.java
- * @run main/othervm/timeout=200 StalePreferredSize
- * @run main/othervm/timeout=200 -Dsun.java2d.uiScale=1 StalePreferredSize
- * @run main/othervm/timeout=200 -Dsun.java2d.uiScale=2.25 StalePreferredSize
+ * @run main/othervm/timeout=400 StalePreferredSize
+ * @run main/othervm/timeout=400 -Dsun.java2d.uiScale=1 StalePreferredSize
+ * @run main/othervm/timeout=400 -Dsun.java2d.uiScale=2.25 StalePreferredSize
  */
 public final class StalePreferredSize {
 
     // Some text to be tested
     static final String TEXT[] = new String[]{
@@ -80,34 +85,40 @@
             "Voix ambiguë d’un cœur qui au zéphyr préfère les jattes de kiwis",
             "다람쥐 헌 쳇바퀴에 타고파",
             "Съешь ещё этих мягких французских булок да выпей же чаю"};
 
     static JFrame frame;
-    static Component component;
+    static Popup popup;
+    static JComponent component;
     static int typeFont = 0; // 0 - default, 1 - bold, 2 - italic
+    static boolean addViaPopup;
 
     public static void main(final String[] args) throws Exception {
         for (final UIManager.LookAndFeelInfo laf : getInstalledLookAndFeels()) {
             EventQueue.invokeAndWait(() -> setLookAndFeel(laf));
             for (typeFont = 0; typeFont < 3; typeFont++) {
                 System.err.println("typeFont = " + typeFont);
-                for (final boolean html : new boolean[]{true, false}) {
-                    for (String text : TEXT) {
-                        if (html) {
-                            text = "<html>" + text + "</html>";
+                for (boolean usePopup : new boolean[]{true, false}) {
+                    addViaPopup = usePopup;
+                    System.err.println("Use popup: " + usePopup);
+                    for (final boolean html : new boolean[]{true, false}) {
+                        for (String text : TEXT) {
+                            if (html) {
+                                text = "<html>" + text + "</html>";
+                            }
+                            test(text);
                         }
-                        test(text);
                     }
                 }
             }
         }
     }
 
     private static void test(String text) throws Exception {
         System.err.println("text = " + text);
         // Each Callable create a component to be tested
-        final List<Callable<Component>> comps = List.of(
+        final List<Callable<JComponent>> comps = List.of(
                 () -> new JLabel(text),
                 () -> new JButton(text),
                 () -> new JMenuItem(text),
                 () -> new JMenu(text),
                 () -> new JList<>(new String[]{text}),
@@ -134,41 +145,63 @@
                     table.getModel().setValueAt(text, 0, 0);
                     return table;
                     }
         );
 
-        for (final Callable<Component> creator : comps) {
+        for (final Callable<JComponent> creator : comps) {
             checkComponent(creator);
         }
     }
 
-    static void checkComponent(Callable<Component> creator) throws Exception {
+    static void checkComponent(Callable<JComponent> creator) throws Exception {
         EventQueue.invokeAndWait(() -> {
 
             try {
                 component = creator.call();
             } catch (Exception e) {
                 throw new RuntimeException(e);
             }
 
+            component.setEnabled(false); // minimize paint/focus events amount
             Font font = component.getFont();
             if (typeFont == 1) {
                 component.setFont(new Font(font.deriveFont(Font.BOLD).getAttributes()));
             }
             if (typeFont == 2) {
                 component.setFont(new Font(font.deriveFont(Font.ITALIC).getAttributes()));
             }
 
             frame = new JFrame();
+            // incorrect initial insets may ruin our size calculation
+            frame.setUndecorated(true); // TODO JDK-8244388
             frame.setLayout(new FlowLayout());
-            frame.add(new JScrollPane(component));
-            frame.setSize(300, 100);
+            frame.setSize(700, 400);
             frame.setLocationRelativeTo(null);
+            if (addViaPopup) {
+                // doing our best to show lightweight or mediumweight popup
+                int x = frame.getX() + 50;
+                int y = frame.getY() + 200;
+                PopupFactory factory = PopupFactory.getSharedInstance();
+                popup = factory.getPopup(frame, component, x, y);
+                if (component instanceof JMenuItem) {
+                    // TODO JDK-8244400
+                    MenuItemLayoutHelper.clearUsedParentClientProperties((JMenuItem)component);
+                }
+            } else {
+                frame.add(new JScrollPane(component));
+            }
             frame.setVisible(true);
+            if (popup != null) {
+                popup.show();
+            }
         });
 
         EventQueue.invokeAndWait(() -> {
+            if (!component.isValid()) {
+                dispose();
+                throw new RuntimeException("Component must be valid");
+            }
 
             // After the frame was shown we change nothing, so current layout
             // should be optimal and updateComponentTreeUI() should be no-op
             Dimension before = component.getPreferredSize();
             SwingUtilities.updateComponentTreeUI(frame);
@@ -177,11 +210,11 @@
             // We change the font size to some big value, as a result the
             // layout and preferredSize of the component should be changed
             component.setFont(component.getFont().deriveFont(35f));
             Dimension last = component.getPreferredSize();
 
-            frame.dispose();
+            dispose();
 
             if (!Objects.equals(before, after)) {
                 System.err.println("Component: " + component);
                 System.err.println("Before: " + before);
                 System.err.println("After: " + after);
@@ -195,10 +228,18 @@
 //                throw new RuntimeException("Wrong PreferredSize");
 //            }
         });
     }
 
+    private static void dispose() {
+        if (popup != null) {
+            popup.hide();
+            popup = null;
+        }
+        frame.dispose();
+    }
+
     private static void setLookAndFeel(final UIManager.LookAndFeelInfo laf) {
         try {
             UIManager.setLookAndFeel(laf.getClassName());
             System.err.println("LookAndFeel: " + laf.getClassName());
         } catch (final UnsupportedLookAndFeelException ignored) {

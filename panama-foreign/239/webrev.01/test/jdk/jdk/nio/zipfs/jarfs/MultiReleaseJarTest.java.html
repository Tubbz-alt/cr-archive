<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/nio/zipfs/jarfs/MultiReleaseJarTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8144355 8144062 8176709 8194070 8193802 8231093
 27  * @summary Test aliasing additions to ZipFileSystem for multi-release jar files
 28  * @library /lib/testlibrary/java/util/jar /test/lib/
 29  * @modules jdk.compiler
 30  *          jdk.jartool
 31  *          jdk.zipfs
 32  * @build CreateMultiReleaseTestJars
 33  *        jdk.test.lib.util.JarBuilder
 34  *        jdk.test.lib.compiler.Compiler
 35  * @run testng MultiReleaseJarTest
 36  */
 37 
 38 import java.io.IOException;
 39 import java.lang.invoke.MethodHandle;
 40 import java.lang.invoke.MethodHandles;
 41 import java.lang.invoke.MethodType;
 42 import java.lang.Runtime.Version;
 43 import java.net.URI;
 44 import java.nio.file.*;
 45 import java.util.ArrayList;
 46 import java.util.HashMap;
 47 import java.util.Map;
 48 import java.util.concurrent.atomic.AtomicInteger;
 49 
 50 import org.testng.Assert;
 51 import org.testng.annotations.*;
 52 import jdk.test.lib.util.JarBuilder;
 53 
 54 public class MultiReleaseJarTest {
 55     final private int MAJOR_VERSION = Runtime.version().feature();
 56     private static final String PROPERTY_RELEASE_VERSION = &quot;releaseVersion&quot;;
 57     private static final String PROPERTY_MULTI_RELEASE = &quot;multi-release&quot;;
 58 
 59     final private String userdir = System.getProperty(&quot;user.dir&quot;,&quot;.&quot;);
 60     final private CreateMultiReleaseTestJars creator =  new CreateMultiReleaseTestJars();
 61     final private Map&lt;String,String&gt; stringEnv = new HashMap&lt;&gt;();
 62     final private Map&lt;String,Integer&gt; integerEnv = new HashMap&lt;&gt;();
 63     final private Map&lt;String,Version&gt; versionEnv = new HashMap&lt;&gt;();
 64     final private String className = &quot;version.Version&quot;;
 65     final private MethodType mt = MethodType.methodType(int.class);
 66 
 67     private String entryName;
 68     private URI uvuri;
 69     private URI mruri;
 70     private URI smruri;
 71 
 72     @BeforeClass
 73     public void initialize() throws Exception {
 74         creator.compileEntries();
 75         creator.buildUnversionedJar();
 76         creator.buildMultiReleaseJar();
 77         creator.buildShortMultiReleaseJar();
 78         String ssp = Paths.get(userdir, &quot;unversioned.jar&quot;).toUri().toString();
 79         uvuri = new URI(&quot;jar&quot;, ssp , null);
 80         ssp = Paths.get(userdir, &quot;multi-release.jar&quot;).toUri().toString();
 81         mruri = new URI(&quot;jar&quot;, ssp, null);
 82         ssp = Paths.get(userdir, &quot;short-multi-release.jar&quot;).toUri().toString();
 83         smruri = new URI(&quot;jar&quot;, ssp, null);
 84         entryName = className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;;
 85     }
 86 
 87     public void close() throws IOException {
 88         Files.delete(Paths.get(userdir, &quot;unversioned.jar&quot;));
 89         Files.delete(Paths.get(userdir, &quot;multi-release.jar&quot;));
 90         Files.delete(Paths.get(userdir, &quot;short-multi-release.jar&quot;));
 91     }
 92 
 93     @DataProvider(name=&quot;strings&quot;)
 94     public Object[][] createStrings() {
 95         return new Object[][]{
 96                 {&quot;runtime&quot;, MAJOR_VERSION, &quot;8&quot;},
 97                 {null, 8, Integer.toString(MAJOR_VERSION)},
 98                 {&quot;8&quot;, 8, &quot;9&quot;},
 99                 {&quot;9&quot;, 9, null},
100                 {Integer.toString(MAJOR_VERSION), MAJOR_VERSION, &quot;8&quot;},
101                 {Integer.toString(MAJOR_VERSION+1), MAJOR_VERSION, &quot;8&quot;},
102                 {&quot;50&quot;, MAJOR_VERSION, &quot;9&quot;}
103         };
104     }
105 
106     @DataProvider(name=&quot;integers&quot;)
107     public Object[][] createIntegers() {
108         return new Object[][] {
109                 {null, 8, Integer.valueOf(9)},
110                 {Integer.valueOf(8), 8, Integer.valueOf(9)},
111                 {Integer.valueOf(9), 9, Integer.valueOf(MAJOR_VERSION)},
112                 {Integer.valueOf(MAJOR_VERSION), MAJOR_VERSION, Integer.valueOf(8)},
113                 {Integer.valueOf(MAJOR_VERSION + 1), MAJOR_VERSION, null},
114                 {Integer.valueOf(100), MAJOR_VERSION, Integer.valueOf(8)}
115         };
116     }
117 
118     @DataProvider(name=&quot;versions&quot;)
119     public Object[][] createVersions() {
120         return new Object[][] {
121                 {null, 8, Version.parse(&quot;14&quot;)},
122                 {Version.parse(&quot;8&quot;), 8, Version.parse(&quot;7&quot;)},
123                 {Version.parse(&quot;9&quot;), 9, null},
124                 {Version.parse(Integer.toString(MAJOR_VERSION)), MAJOR_VERSION, Version.parse(&quot;8&quot;)},
125                 {Version.parse(Integer.toString(MAJOR_VERSION) + 1), MAJOR_VERSION, Version.parse(&quot;9&quot;)},
126                 {Version.parse(&quot;100&quot;), MAJOR_VERSION, Version.parse(&quot;14&quot;)}
127         };
128     }
129 
130     @DataProvider(name=&quot;invalidVersions&quot;)
131     public Object[][] invalidVersions() {
132         return new Object[][] {
133                 {Map.of(PROPERTY_RELEASE_VERSION, &quot;&quot;)},
134                 {Map.of(PROPERTY_RELEASE_VERSION, &quot;invalid&quot;)},
135                 {Map.of(PROPERTY_RELEASE_VERSION, &quot;0&quot;)},
136                 {Map.of(PROPERTY_RELEASE_VERSION, &quot;-1&quot;)},
137                 {Map.of(PROPERTY_RELEASE_VERSION, &quot;11.0.1&quot;)},
138                 {Map.of(PROPERTY_RELEASE_VERSION, new ArrayList&lt;Long&gt;())},
139                 {Map.of(PROPERTY_RELEASE_VERSION, Integer.valueOf(0))},
140                 {Map.of(PROPERTY_RELEASE_VERSION, Integer.valueOf(-1))}
141         };
142     }
143 
144     // Not the best test but all I can do since ZipFileSystem
145     // is not public, so I can&#39;t use (fs instanceof ...)
146     @Test
147     public void testNewFileSystem() throws Exception {
148         Map&lt;String,String&gt; env = new HashMap&lt;&gt;();
149         // no configuration, treat multi-release jar as unversioned
150         try (FileSystem fs = FileSystems.newFileSystem(mruri, env)) {
151             Assert.assertTrue(readAndCompare(fs, 8));
152         }
153         env.put(PROPERTY_RELEASE_VERSION, &quot;runtime&quot;);
154         // a configuration and jar file is multi-release
155         try (FileSystem fs = FileSystems.newFileSystem(mruri, env)) {
156             Assert.assertTrue(readAndCompare(fs, MAJOR_VERSION));
157         }
158         // a configuration but jar file is unversioned
159         try (FileSystem fs = FileSystems.newFileSystem(uvuri, env)) {
160             Assert.assertTrue(readAndCompare(fs, 8));
161         }
162     }
163 
164     private boolean readAndCompare(FileSystem fs, int expected) throws IOException {
165         Path path = fs.getPath(&quot;version/Version.java&quot;);
166         String src = new String(Files.readAllBytes(path));
167         return src.contains(&quot;return &quot; + expected);
168     }
169 
170     @Test(dataProvider=&quot;strings&quot;)
171     public void testStrings(String value, int expected, String ignorable) throws Throwable {
172         stringEnv.clear();
173         stringEnv.put(PROPERTY_RELEASE_VERSION, value);
174         // we check, that values for &quot;multi-release&quot; are ignored
175         stringEnv.put(PROPERTY_MULTI_RELEASE, ignorable);
176         runTest(stringEnv, expected);
177     }
178 
179     @Test(dataProvider=&quot;integers&quot;)
180     public void testIntegers(Integer value, int expected, Integer ignorable) throws Throwable {
181         integerEnv.clear();
182         integerEnv.put(PROPERTY_RELEASE_VERSION, value);
183         // we check, that values for &quot;multi-release&quot; are ignored
184         integerEnv.put(PROPERTY_MULTI_RELEASE, value);
185         runTest(integerEnv, expected);
186     }
187 
188     @Test(dataProvider=&quot;versions&quot;)
189     public void testVersions(Version value, int expected, Version ignorable) throws Throwable {
190         versionEnv.clear();
191         versionEnv.put(PROPERTY_RELEASE_VERSION, value);
192         // we check, that values for &quot;multi-release&quot; are ignored
193         versionEnv.put(PROPERTY_MULTI_RELEASE, ignorable);
194         runTest(versionEnv, expected);
195     }
196 
197     @Test
198     public void testShortJar() throws Throwable {
199         integerEnv.clear();
200         integerEnv.put(PROPERTY_RELEASE_VERSION, Integer.valueOf(MAJOR_VERSION));
201         runTest(smruri, integerEnv, MAJOR_VERSION);
202         integerEnv.put(PROPERTY_RELEASE_VERSION, Integer.valueOf(9));
203         runTest(smruri, integerEnv, 8);
204     }
205 
206     /**
207      * Validate that an invalid value for the &quot;releaseVersion&quot; property throws
208      * an {@code IllegalArgumentException}
209      * @param env Zip FS map
210      * @throws Throwable  Exception thrown for anything other than the expected
211      * IllegalArgumentException
212      */
213     @Test(dataProvider=&quot;invalidVersions&quot;)
214     public void testInvalidVersions(Map&lt;String,?&gt; env) throws Throwable {
215         Assert.assertThrows(IllegalArgumentException.class, () -&gt;
216                 FileSystems.newFileSystem(Path.of(userdir,
217                         &quot;multi-release.jar&quot;), env));
218     }
219 
220     // The following tests are for backwards compatibility to validate that
221     // the original property still works
222     @Test(dataProvider=&quot;strings&quot;)
223     public void testMRStrings(String value, int expected, String ignorable) throws Throwable {
224         stringEnv.clear();
225         stringEnv.put(PROPERTY_MULTI_RELEASE, value);
226         runTest(stringEnv, expected);
227     }
228 
229     @Test(dataProvider=&quot;integers&quot;)
230     public void testMRIntegers(Integer value, int expected, Integer ignorable) throws Throwable {
231         integerEnv.clear();
232         integerEnv.put(PROPERTY_MULTI_RELEASE, value);
233         runTest(integerEnv, expected);
234     }
235 
236     @Test(dataProvider=&quot;versions&quot;)
237     public void testMRVersions(Version value, int expected, Version ignorable) throws Throwable {
238         versionEnv.clear();
239         versionEnv.put(PROPERTY_MULTI_RELEASE, value);
240         runTest(versionEnv, expected);
241     }
242 
243     private void runTest(Map&lt;String,?&gt; env, int expected) throws Throwable {
244         runTest(mruri, env, expected);
245     }
246 
247     private void runTest(URI uri, Map&lt;String,?&gt; env, int expected) throws Throwable {
248         try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {
249             Path version = fs.getPath(entryName);
250             byte [] bytes = Files.readAllBytes(version);
251             Class&lt;?&gt; vcls = (new ByteArrayClassLoader(fs)).defineClass(className, bytes);
252             MethodHandle mh = MethodHandles.lookup().findVirtual(vcls, &quot;getVersion&quot;, mt);
253             Assert.assertEquals((int)mh.invoke(vcls.getDeclaredConstructor().newInstance()), expected);
254         }
255     }
256 
257     @Test
258     public void testIsMultiReleaseJar() throws Exception {
259         // Re-examine commented out tests as part of JDK-8176843
260         testCustomMultiReleaseValue(&quot;true&quot;, true);
261         testCustomMultiReleaseValue(&quot;true\r\nOther: value&quot;, true);
262         testCustomMultiReleaseValue(&quot;true\nOther: value&quot;, true);
263         //testCustomMultiReleaseValue(&quot;true\rOther: value&quot;, true);
264 
265         testCustomMultiReleaseValue(&quot;false&quot;, false);
266         testCustomMultiReleaseValue(&quot; true&quot;, false);
267         testCustomMultiReleaseValue(&quot;true &quot;, false);
268         //testCustomMultiReleaseValue(&quot;true\n &quot;, false);
269         //testCustomMultiReleaseValue(&quot;true\r &quot;, false);
270         //testCustomMultiReleaseValue(&quot;true\n true&quot;, false);
271         //testCustomMultiReleaseValue(&quot;true\r\n true&quot;, false);
272     }
273 
274     @Test
275     public void testMultiReleaseJarWithNonVersionDir() throws Exception {
276         String jfname = &quot;multi-release-non-ver.jar&quot;;
277         Path jfpath = Paths.get(jfname);
278         URI uri = new URI(&quot;jar&quot;, jfpath.toUri().toString() , null);
279         JarBuilder jb = new JarBuilder(jfname);
280         jb.addAttribute(&quot;Multi-Release&quot;, &quot;true&quot;);
281         jb.build();
282         Map&lt;String,String&gt; env = Map.of(PROPERTY_RELEASE_VERSION, &quot;runtime&quot;);
283         try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {
284             Assert.assertTrue(true);
285         }
286         Files.delete(jfpath);
287     }
288 
289     private static final AtomicInteger JAR_COUNT = new AtomicInteger(0);
290 
291     private void testCustomMultiReleaseValue(String value, boolean expected)
292             throws Exception {
293         String fileName = &quot;custom-mr&quot; + JAR_COUNT.incrementAndGet() + &quot;.jar&quot;;
294         creator.buildCustomMultiReleaseJar(fileName, value, Map.of(),
295                 /*addEntries*/true);
296 
297         Map&lt;String,String&gt; env = Map.of(PROPERTY_RELEASE_VERSION, &quot;runtime&quot;);
298         Path filePath = Paths.get(userdir, fileName);
299         String ssp = filePath.toUri().toString();
300         URI customJar = new URI(&quot;jar&quot;, ssp , null);
301         try (FileSystem fs = FileSystems.newFileSystem(customJar, env)) {
302             if (expected) {
303                 Assert.assertTrue(readAndCompare(fs, MAJOR_VERSION));
304             } else {
305                 Assert.assertTrue(readAndCompare(fs, 8));
306             }
307         }
308         Files.delete(filePath);
309     }
310 
311     private static class ByteArrayClassLoader extends ClassLoader {
312         final private FileSystem fs;
313 
314         ByteArrayClassLoader(FileSystem fs) {
315             super(null);
316             this.fs = fs;
317         }
318 
319         @Override
320         public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
321             try {
322                 return super.loadClass(name);
323             } catch (ClassNotFoundException x) {}
324             Path cls = fs.getPath(name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;);
325             try {
326                 byte[] bytes = Files.readAllBytes(cls);
327                 return defineClass(name, bytes);
328             } catch (IOException x) {
329                 throw new ClassNotFoundException(x.getMessage());
330             }
331         }
332 
333         public Class&lt;?&gt; defineClass(String name, byte[] bytes) throws ClassNotFoundException {
334             if (bytes == null) throw new ClassNotFoundException(&quot;No bytes for &quot; + name);
335             return defineClass(name, bytes, 0, bytes.length);
336         }
337     }
338 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/jdk/nio/zipfs/jarfs/MultiReleaseJarTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8144355 8144062 8176709 8194070 8193802 8231093
 27  * @summary Test aliasing additions to ZipFileSystem for multi-release jar files
 28  * @library /lib/testlibrary/java/util/jar
 29  * @modules jdk.compiler
 30  *          jdk.jartool
 31  *          jdk.zipfs
 32  * @build Compiler JarBuilder CreateMultiReleaseTestJars
 33  * @run testng MultiReleaseJarTest
 34  */
 35 
 36 import java.io.IOException;
 37 import java.lang.invoke.MethodHandle;
 38 import java.lang.invoke.MethodHandles;
 39 import java.lang.invoke.MethodType;
 40 import java.lang.Runtime.Version;
 41 import java.net.URI;
 42 import java.nio.file.*;
 43 import java.util.ArrayList;
 44 import java.util.HashMap;
 45 import java.util.Map;
 46 import java.util.concurrent.atomic.AtomicInteger;
 47 
 48 import org.testng.Assert;
 49 import org.testng.annotations.*;
 50 
 51 public class MultiReleaseJarTest {
 52     final private int MAJOR_VERSION = Runtime.version().feature();
 53     private static final String PROPERTY_RELEASE_VERSION = &quot;releaseVersion&quot;;
 54     private static final String PROPERTY_MULTI_RELEASE = &quot;multi-release&quot;;
 55 
 56     final private String userdir = System.getProperty(&quot;user.dir&quot;,&quot;.&quot;);
 57     final private CreateMultiReleaseTestJars creator =  new CreateMultiReleaseTestJars();
 58     final private Map&lt;String,String&gt; stringEnv = new HashMap&lt;&gt;();
 59     final private Map&lt;String,Integer&gt; integerEnv = new HashMap&lt;&gt;();
 60     final private Map&lt;String,Version&gt; versionEnv = new HashMap&lt;&gt;();
 61     final private String className = &quot;version.Version&quot;;
 62     final private MethodType mt = MethodType.methodType(int.class);
 63 
 64     private String entryName;
 65     private URI uvuri;
 66     private URI mruri;
 67     private URI smruri;
 68 
 69     @BeforeClass
 70     public void initialize() throws Exception {
 71         creator.compileEntries();
 72         creator.buildUnversionedJar();
 73         creator.buildMultiReleaseJar();
 74         creator.buildShortMultiReleaseJar();
 75         String ssp = Paths.get(userdir, &quot;unversioned.jar&quot;).toUri().toString();
 76         uvuri = new URI(&quot;jar&quot;, ssp , null);
 77         ssp = Paths.get(userdir, &quot;multi-release.jar&quot;).toUri().toString();
 78         mruri = new URI(&quot;jar&quot;, ssp, null);
 79         ssp = Paths.get(userdir, &quot;short-multi-release.jar&quot;).toUri().toString();
 80         smruri = new URI(&quot;jar&quot;, ssp, null);
 81         entryName = className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;;
 82     }
 83 
 84     public void close() throws IOException {
 85         Files.delete(Paths.get(userdir, &quot;unversioned.jar&quot;));
 86         Files.delete(Paths.get(userdir, &quot;multi-release.jar&quot;));
 87         Files.delete(Paths.get(userdir, &quot;short-multi-release.jar&quot;));
 88     }
 89 
 90     @DataProvider(name=&quot;strings&quot;)
 91     public Object[][] createStrings() {
 92         return new Object[][]{
 93                 {&quot;runtime&quot;, MAJOR_VERSION, &quot;8&quot;},
 94                 {null, 8, Integer.toString(MAJOR_VERSION)},
 95                 {&quot;8&quot;, 8, &quot;9&quot;},
 96                 {&quot;9&quot;, 9, null},
 97                 {Integer.toString(MAJOR_VERSION), MAJOR_VERSION, &quot;8&quot;},
 98                 {Integer.toString(MAJOR_VERSION+1), MAJOR_VERSION, &quot;8&quot;},
 99                 {&quot;50&quot;, MAJOR_VERSION, &quot;9&quot;}
100         };
101     }
102 
103     @DataProvider(name=&quot;integers&quot;)
104     public Object[][] createIntegers() {
105         return new Object[][] {
106                 {null, 8, Integer.valueOf(9)},
107                 {Integer.valueOf(8), 8, Integer.valueOf(9)},
108                 {Integer.valueOf(9), 9, Integer.valueOf(MAJOR_VERSION)},
109                 {Integer.valueOf(MAJOR_VERSION), MAJOR_VERSION, Integer.valueOf(8)},
110                 {Integer.valueOf(MAJOR_VERSION + 1), MAJOR_VERSION, null},
111                 {Integer.valueOf(100), MAJOR_VERSION, Integer.valueOf(8)}
112         };
113     }
114 
115     @DataProvider(name=&quot;versions&quot;)
116     public Object[][] createVersions() {
117         return new Object[][] {
118                 {null, 8, Version.parse(&quot;14&quot;)},
119                 {Version.parse(&quot;8&quot;), 8, Version.parse(&quot;7&quot;)},
120                 {Version.parse(&quot;9&quot;), 9, null},
121                 {Version.parse(Integer.toString(MAJOR_VERSION)), MAJOR_VERSION, Version.parse(&quot;8&quot;)},
122                 {Version.parse(Integer.toString(MAJOR_VERSION) + 1), MAJOR_VERSION, Version.parse(&quot;9&quot;)},
123                 {Version.parse(&quot;100&quot;), MAJOR_VERSION, Version.parse(&quot;14&quot;)}
124         };
125     }
126 
127     @DataProvider(name=&quot;invalidVersions&quot;)
128     public Object[][] invalidVersions() {
129         return new Object[][] {
130                 {Map.of(PROPERTY_RELEASE_VERSION, &quot;&quot;)},
131                 {Map.of(PROPERTY_RELEASE_VERSION, &quot;invalid&quot;)},
132                 {Map.of(PROPERTY_RELEASE_VERSION, &quot;0&quot;)},
133                 {Map.of(PROPERTY_RELEASE_VERSION, &quot;-1&quot;)},
134                 {Map.of(PROPERTY_RELEASE_VERSION, &quot;11.0.1&quot;)},
135                 {Map.of(PROPERTY_RELEASE_VERSION, new ArrayList&lt;Long&gt;())},
136                 {Map.of(PROPERTY_RELEASE_VERSION, Integer.valueOf(0))},
137                 {Map.of(PROPERTY_RELEASE_VERSION, Integer.valueOf(-1))}
138         };
139     }
140 
141     // Not the best test but all I can do since ZipFileSystem
142     // is not public, so I can&#39;t use (fs instanceof ...)
143     @Test
144     public void testNewFileSystem() throws Exception {
145         Map&lt;String,String&gt; env = new HashMap&lt;&gt;();
146         // no configuration, treat multi-release jar as unversioned
147         try (FileSystem fs = FileSystems.newFileSystem(mruri, env)) {
148             Assert.assertTrue(readAndCompare(fs, 8));
149         }
150         env.put(PROPERTY_RELEASE_VERSION, &quot;runtime&quot;);
151         // a configuration and jar file is multi-release
152         try (FileSystem fs = FileSystems.newFileSystem(mruri, env)) {
153             Assert.assertTrue(readAndCompare(fs, MAJOR_VERSION));
154         }
155         // a configuration but jar file is unversioned
156         try (FileSystem fs = FileSystems.newFileSystem(uvuri, env)) {
157             Assert.assertTrue(readAndCompare(fs, 8));
158         }
159     }
160 
161     private boolean readAndCompare(FileSystem fs, int expected) throws IOException {
162         Path path = fs.getPath(&quot;version/Version.java&quot;);
163         String src = new String(Files.readAllBytes(path));
164         return src.contains(&quot;return &quot; + expected);
165     }
166 
167     @Test(dataProvider=&quot;strings&quot;)
168     public void testStrings(String value, int expected, String ignorable) throws Throwable {
169         stringEnv.clear();
170         stringEnv.put(PROPERTY_RELEASE_VERSION, value);
171         // we check, that values for &quot;multi-release&quot; are ignored
172         stringEnv.put(PROPERTY_MULTI_RELEASE, ignorable);
173         runTest(stringEnv, expected);
174     }
175 
176     @Test(dataProvider=&quot;integers&quot;)
177     public void testIntegers(Integer value, int expected, Integer ignorable) throws Throwable {
178         integerEnv.clear();
179         integerEnv.put(PROPERTY_RELEASE_VERSION, value);
180         // we check, that values for &quot;multi-release&quot; are ignored
181         integerEnv.put(PROPERTY_MULTI_RELEASE, value);
182         runTest(integerEnv, expected);
183     }
184 
185     @Test(dataProvider=&quot;versions&quot;)
186     public void testVersions(Version value, int expected, Version ignorable) throws Throwable {
187         versionEnv.clear();
188         versionEnv.put(PROPERTY_RELEASE_VERSION, value);
189         // we check, that values for &quot;multi-release&quot; are ignored
190         versionEnv.put(PROPERTY_MULTI_RELEASE, ignorable);
191         runTest(versionEnv, expected);
192     }
193 
194     @Test
195     public void testShortJar() throws Throwable {
196         integerEnv.clear();
197         integerEnv.put(PROPERTY_RELEASE_VERSION, Integer.valueOf(MAJOR_VERSION));
198         runTest(smruri, integerEnv, MAJOR_VERSION);
199         integerEnv.put(PROPERTY_RELEASE_VERSION, Integer.valueOf(9));
200         runTest(smruri, integerEnv, 8);
201     }
202 
203     /**
204      * Validate that an invalid value for the &quot;releaseVersion&quot; property throws
205      * an {@code IllegalArgumentException}
206      * @param env Zip FS map
207      * @throws Throwable  Exception thrown for anything other than the expected
208      * IllegalArgumentException
209      */
210     @Test(dataProvider=&quot;invalidVersions&quot;)
211     public void testInvalidVersions(Map&lt;String,?&gt; env) throws Throwable {
212         Assert.assertThrows(IllegalArgumentException.class, () -&gt;
213                 FileSystems.newFileSystem(Path.of(userdir,
214                         &quot;multi-release.jar&quot;), env));
215     }
216 
217     // The following tests are for backwards compatibility to validate that
218     // the original property still works
219     @Test(dataProvider=&quot;strings&quot;)
220     public void testMRStrings(String value, int expected, String ignorable) throws Throwable {
221         stringEnv.clear();
222         stringEnv.put(PROPERTY_MULTI_RELEASE, value);
223         runTest(stringEnv, expected);
224     }
225 
226     @Test(dataProvider=&quot;integers&quot;)
227     public void testMRIntegers(Integer value, int expected, Integer ignorable) throws Throwable {
228         integerEnv.clear();
229         integerEnv.put(PROPERTY_MULTI_RELEASE, value);
230         runTest(integerEnv, expected);
231     }
232 
233     @Test(dataProvider=&quot;versions&quot;)
234     public void testMRVersions(Version value, int expected, Version ignorable) throws Throwable {
235         versionEnv.clear();
236         versionEnv.put(PROPERTY_MULTI_RELEASE, value);
237         runTest(versionEnv, expected);
238     }
239 
240     private void runTest(Map&lt;String,?&gt; env, int expected) throws Throwable {
241         runTest(mruri, env, expected);
242     }
243 
244     private void runTest(URI uri, Map&lt;String,?&gt; env, int expected) throws Throwable {
245         try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {
246             Path version = fs.getPath(entryName);
247             byte [] bytes = Files.readAllBytes(version);
248             Class&lt;?&gt; vcls = (new ByteArrayClassLoader(fs)).defineClass(className, bytes);
249             MethodHandle mh = MethodHandles.lookup().findVirtual(vcls, &quot;getVersion&quot;, mt);
250             Assert.assertEquals((int)mh.invoke(vcls.getDeclaredConstructor().newInstance()), expected);
251         }
252     }
253 
254     @Test
255     public void testIsMultiReleaseJar() throws Exception {
256         // Re-examine commented out tests as part of JDK-8176843
257         testCustomMultiReleaseValue(&quot;true&quot;, true);
258         testCustomMultiReleaseValue(&quot;true\r\nOther: value&quot;, true);
259         testCustomMultiReleaseValue(&quot;true\nOther: value&quot;, true);
260         //testCustomMultiReleaseValue(&quot;true\rOther: value&quot;, true);
261 
262         testCustomMultiReleaseValue(&quot;false&quot;, false);
263         testCustomMultiReleaseValue(&quot; true&quot;, false);
264         testCustomMultiReleaseValue(&quot;true &quot;, false);
265         //testCustomMultiReleaseValue(&quot;true\n &quot;, false);
266         //testCustomMultiReleaseValue(&quot;true\r &quot;, false);
267         //testCustomMultiReleaseValue(&quot;true\n true&quot;, false);
268         //testCustomMultiReleaseValue(&quot;true\r\n true&quot;, false);
269     }
270 
271     @Test
272     public void testMultiReleaseJarWithNonVersionDir() throws Exception {
273         String jfname = &quot;multi-release-non-ver.jar&quot;;
274         Path jfpath = Paths.get(jfname);
275         URI uri = new URI(&quot;jar&quot;, jfpath.toUri().toString() , null);
276         JarBuilder jb = new JarBuilder(jfname);
277         jb.addAttribute(&quot;Multi-Release&quot;, &quot;true&quot;);
278         jb.build();
279         Map&lt;String,String&gt; env = Map.of(PROPERTY_RELEASE_VERSION, &quot;runtime&quot;);
280         try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {
281             Assert.assertTrue(true);
282         }
283         Files.delete(jfpath);
284     }
285 
286     private static final AtomicInteger JAR_COUNT = new AtomicInteger(0);
287 
288     private void testCustomMultiReleaseValue(String value, boolean expected)
289             throws Exception {
290         String fileName = &quot;custom-mr&quot; + JAR_COUNT.incrementAndGet() + &quot;.jar&quot;;
291         creator.buildCustomMultiReleaseJar(fileName, value, Map.of(),
292                 /*addEntries*/true);
293 
294         Map&lt;String,String&gt; env = Map.of(PROPERTY_RELEASE_VERSION, &quot;runtime&quot;);
295         Path filePath = Paths.get(userdir, fileName);
296         String ssp = filePath.toUri().toString();
297         URI customJar = new URI(&quot;jar&quot;, ssp , null);
298         try (FileSystem fs = FileSystems.newFileSystem(customJar, env)) {
299             if (expected) {
300                 Assert.assertTrue(readAndCompare(fs, MAJOR_VERSION));
301             } else {
302                 Assert.assertTrue(readAndCompare(fs, 8));
303             }
304         }
305         Files.delete(filePath);
306     }
307 
308     private static class ByteArrayClassLoader extends ClassLoader {
309         final private FileSystem fs;
310 
311         ByteArrayClassLoader(FileSystem fs) {
312             super(null);
313             this.fs = fs;
314         }
315 
316         @Override
317         public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
318             try {
319                 return super.loadClass(name);
320             } catch (ClassNotFoundException x) {}
321             Path cls = fs.getPath(name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;);
322             try {
323                 byte[] bytes = Files.readAllBytes(cls);
324                 return defineClass(name, bytes);
325             } catch (IOException x) {
326                 throw new ClassNotFoundException(x.getMessage());
327             }
328         }
329 
330         public Class&lt;?&gt; defineClass(String name, byte[] bytes) throws ClassNotFoundException {
331             if (bytes == null) throw new ClassNotFoundException(&quot;No bytes for &quot; + name);
332             return defineClass(name, bytes, 0, bytes.length);
333         }
334     }
335 }
    </pre>
  </body>
</html>
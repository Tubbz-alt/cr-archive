<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/awt/KeyboardFocusmanager/TypeAhead/EnqueueWithDialogButtonTest/EnqueueWithDialogButtonTest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @key headful
 27  * @bug 4799136
 28  * @summary Tests that type-ahead for dialog works and doesn&#39;t block program
 29  * @author Dmitry.Cherepanov@SUN.COM area=awt.focus
 30  * @run main EnqueueWithDialogButtonTest
 31  */
 32 
 33 import java.awt.*;
 34 import java.lang.reflect.InvocationTargetException;
 35 import java.awt.event.*;
 36 import java.util.concurrent.CountDownLatch;
 37 import java.util.concurrent.TimeUnit;
 38 
 39 /*
 40  * Tests that type-ahead works correctly. That means
 41  * that the key events are not delivered until a focus
 42  * transfer is completed.
 43  * There is another pretty similar test EnqueueWithDialogTest
 44  * written in time before 6347235 resolution. We&#39;ll keep it
 45  * to track quite unrelated suspicious waitForIdle behavior.
 46  */
 47 
 48 public class EnqueueWithDialogButtonTest
 49 {
 50     static Frame f;
 51     static Button b;
 52     static Dialog d;
 53     static Button ok;
 54     static CountDownLatch pressLatch = new CountDownLatch(1);
 55     static CountDownLatch robotLatch = new CountDownLatch(1);
 56     static volatile boolean gotFocus = false;
 57     static Robot robot;
 58     public static void main(String args[]) throws Exception {
 59         EnqueueWithDialogButtonTest test = new EnqueueWithDialogButtonTest();
 60         test.init();
 61         test.start();
 62     }
 63     public void init()
 64     {
 65         Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() {
 66                 public void eventDispatched(AWTEvent e) {
 67                     if (e instanceof InputEvent){
 68                         System.err.println(e.toString()+&quot;,&quot;+((InputEvent)e).getWhen());
 69                     }else{
 70                         System.err.println(e.toString());
 71                     }
 72                  }
 73             }, AWTEvent.KEY_EVENT_MASK | AWTEvent.FOCUS_EVENT_MASK);
 74 
 75 
 76         f = new Frame(&quot;frame&quot;);
 77         f.setPreferredSize(new Dimension(100,100));
 78         f.setLocation(100,50);
 79         b = new Button(&quot;press&quot;);
 80         d = new Dialog(f, &quot;dialog&quot;, true);
 81         d.setPreferredSize(new Dimension(70,70));
 82         ok = new Button(&quot;ok&quot;);
 83         d.add(ok);
 84         d.pack();
 85         ok.addKeyListener(new KeyAdapter() {
 86                 public void keyPressed(KeyEvent e) {
 87                     System.err.println(&quot;OK pressed: should arrive after got focus&quot;);
 88                     d.dispose();
 89                     f.dispose();
 90                     // Typed-ahead key events should only be accepted if
 91                     // they arrive after FOCUS_GAINED
 92                     if (gotFocus) {
 93                         pressLatch.countDown();
 94                     }
 95                 }
 96             });
 97         ok.addFocusListener(new FocusAdapter() {
 98                 public void focusGained(FocusEvent e) {
 99                     gotFocus = true;
100                     System.err.println(&quot;OK got focus&quot;);
101                 }
102             });
103         f.add(b);
104         f.pack();
105         b.addActionListener(new ActionListener() {
106                 public void actionPerformed(ActionEvent e) {
107                     System.err.println(e.toString()+&quot;,&quot;+e.getWhen());
108                     System.err.println(&quot;B pressed&quot;);
109                     robotLatch.countDown();
110 
111                     EventQueue.invokeLater(new Runnable() {
112                             public void run() {
113                                 waitTillShown(d);
114                                 EnqueueWithDialogButtonTest.this.d.toFront();
115                                 EnqueueWithDialogButtonTest.this.moveMouseOver(d);
116                             }
117                         });
118 
119                     // This will cause enqueue the following key events
120                     d.setVisible(true);
121                 }
122             });
123 
124     }//End  init()
125 
126     public void start () throws Exception
127     {
128 
129         robot = new Robot();
130         robot.setAutoDelay(50);
131 
132         f.setVisible(true);
133         waitTillShown(b);
134         System.err.println(&quot;b is shown&quot;);
135         f.toFront();
136         moveMouseOver(f);
137         robot.waitForIdle();
138         robot.delay(100);
139         makeFocused(b);
140         robot.waitForIdle();
141         robot.delay(100);
142         System.err.println(&quot;b is focused&quot;);
143 
144         robot.keyPress(KeyEvent.VK_SPACE);
145         robot.keyRelease(KeyEvent.VK_SPACE);
146         boolean ok = robotLatch.await(1, TimeUnit.SECONDS);
147         if(!ok) {
148             throw new RuntimeException(&quot;Was B button pressed?&quot;);
149         }
150 
151         robot.keyPress(KeyEvent.VK_SPACE);
152         robot.keyRelease(KeyEvent.VK_SPACE);
153         robot.delay(500);
154         ok = pressLatch.await(3, TimeUnit.SECONDS);
155         if(!ok) {
156             throw new RuntimeException(&quot;Type-ahead doesn&#39;t work&quot;);
157         }
158 
159     }// start()
160 
161     private void moveMouseOver(Container c) {
162         Point p = c.getLocationOnScreen();
163         Dimension d = c.getSize();
164         robot.mouseMove(p.x + (int)(d.getWidth()/2), p.y + (int)(d.getHeight()/2));
165     }
166 
167     private void waitTillShown(Component c) {
168         while (true) {
169             try {
170                 Thread.sleep(100);
171                 c.getLocationOnScreen();
172                 break;
173             } catch (InterruptedException ie) {
174                 ie.printStackTrace();
175                 break;
176             } catch (Exception e) {
177             }
178         }
179     }
180     private void makeFocused(Component comp) {
181         if (comp.isFocusOwner()) {
182             return;
183         }
184         final Semaphore sema = new Semaphore();
185         final FocusAdapter fa = new FocusAdapter() {
186                 public void focusGained(FocusEvent fe) {
187                     sema.raise();
188                 }
189             };
190         comp.addFocusListener(fa);
191         comp.requestFocusInWindow();
192         if (comp.isFocusOwner()) {
193             return;
194         }
195         try {
196             sema.doWait(3000);
197         } catch (InterruptedException ie) {
198             ie.printStackTrace();
199         }
200         comp.removeFocusListener(fa);
201         if (!comp.isFocusOwner()) {
202             throw new RuntimeException(&quot;Can&#39;t make &quot; + comp + &quot; focused, current owner is &quot; + KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner());
203         }
204     }
205 
206 static class Semaphore {
207     boolean state = false;
208     int waiting = 0;
209     public Semaphore() {
210     }
211     public synchronized void doWait() throws InterruptedException {
212         if (state) {
213             return;
214         }
215         waiting++;
216         wait();
217         waiting--;
218     }
219     public synchronized void doWait(int timeout) throws InterruptedException {
220         if (state) {
221             return;
222         }
223         waiting++;
224         wait(timeout);
225         waiting--;
226     }
227     public synchronized void raise() {
228         state = true;
229         if (waiting &gt; 0) {
230             notifyAll();
231         }
232     }
233     public synchronized boolean getState() {
234         return state;
235     }
236 }
237 }// class TestDialogTypeAhead
    </pre>
  </body>
</html>
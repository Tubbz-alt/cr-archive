<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/awt/KeyboardFocusmanager/TypeAhead/FreezeTest/FreezeTest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 /*
 24  * @test
 25  * @key headful
 26  * @bug 4799136
 27  * @summary Tests that type-ahead for dialog works and doesn&#39;t block program
 28  * @author Dmitry.Cherepanov@SUN.COM area=awt.focus
 29  * @run main FreezeTest
 30  */
 31 
 32 /*
 33  * Tests that type-ahead doesn&#39;t block program.
 34  */
 35 
 36 import java.awt.AWTEvent;
 37 import java.awt.Button;
 38 import java.awt.Component;
 39 import java.awt.Container;
 40 import java.awt.Dialog;
 41 import java.awt.Dimension;
 42 import java.awt.EventQueue;
 43 import java.awt.Frame;
 44 import java.awt.KeyboardFocusManager;
 45 import java.awt.Point;
 46 import java.awt.Robot;
 47 import java.awt.TextField;
 48 import java.awt.Toolkit;
 49 import java.awt.event.AWTEventListener;
 50 import java.awt.event.ActionEvent;
 51 import java.awt.event.ActionListener;
 52 import java.awt.event.FocusAdapter;
 53 import java.awt.event.FocusEvent;
 54 import java.awt.event.InputEvent;
 55 import java.awt.event.KeyEvent;
 56 import java.util.concurrent.CountDownLatch;
 57 import java.util.concurrent.TimeUnit;
 58 
 59 public class FreezeTest
 60 {
 61     static Frame f;
 62     static Button b;
 63     static Dialog d;
 64     static TextField tf;
 65     static CountDownLatch robotLatch = new CountDownLatch(1);
 66     static Robot robot;
 67     static int click_count = 100;
 68     static int deliver_count = 0;
 69 
 70     public static void main(String args[]) throws Exception {
 71         FreezeTest test = new FreezeTest();
 72         try {
 73             test.init();
 74             test.start();
 75         } finally {
 76             if (d != null) {
 77                 d.dispose();
 78             }
 79             if (f != null) {
 80                 f.dispose();
 81             }
 82         }
 83     }
 84 
 85     public void init()
 86     {
 87         Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() {
 88                 public void eventDispatched(AWTEvent e) {
 89                     if (e instanceof KeyEvent){
 90                         deliver_count++;
 91                         System.err.println(&quot;key_event# &quot;+deliver_count);
 92                     }
 93 
 94                     if (e instanceof InputEvent){
 95                         System.err.println(e.toString()+&quot;,&quot;+((InputEvent)e).getWhen());
 96                     }else{
 97                         System.err.println(e.toString());
 98                     }
 99                  }
100             }, AWTEvent.KEY_EVENT_MASK | AWTEvent.FOCUS_EVENT_MASK);
101 
102 
103         f = new Frame(&quot;frame&quot;);
104         b = new Button(&quot;press&quot;);
105         d = new Dialog(f, &quot;dialog&quot;, true);
106         tf = new TextField(&quot;&quot;);
107         d.add(tf);
108         d.pack();
109 
110         f.add(b);
111         f.pack();
112         b.addActionListener(new ActionListener() {
113                 public void actionPerformed(ActionEvent e) {
114                     System.err.println(e.toString()+&quot;,&quot;+e.getWhen());
115                     System.err.println(&quot;B pressed&quot;);
116                     robotLatch.countDown();
117 
118                     EventQueue.invokeLater(new Runnable() {
119                             public void run() {
120                                 waitTillShown(d);
121                                 FreezeTest.this.d.toFront();
122                                 FreezeTest.this.moveMouseOver(d);
123                             }
124                         });
125                     d.setVisible(true);
126                 }
127             });
128 
129     }//End  init()
130 
131     public void start () throws Exception
132     {
133         robot = new Robot();
134 
135         f.setVisible(true);
136         waitTillShown(b);
137         System.err.println(&quot;b is shown&quot;);
138         f.toFront();
139         moveMouseOver(f);
140         robot.waitForIdle();
141         makeFocused(b);
142         robot.waitForIdle();
143         System.err.println(&quot;b is focused&quot;);
144 
145         robot.keyPress(KeyEvent.VK_SPACE);
146         robot.keyRelease(KeyEvent.VK_SPACE);
147         boolean ok = robotLatch.await(1, TimeUnit.SECONDS);
148         if(!ok) {
149             throw new RuntimeException(&quot;Was B button pressed?&quot;);
150         }
151 
152         for (int i = 0; i &lt; click_count; i++){
153             System.err.println(&quot;click# &quot;+(i+1));
154             robot.keyPress(KeyEvent.VK_SPACE);
155             robot.delay(10);
156             robot.keyRelease(KeyEvent.VK_SPACE);
157             robot.delay(50);
158         }
159 
160         robot.waitForIdle();
161 
162         int deliver_count = this.deliver_count;
163         int expected_count = (click_count + 1) * 3;
164 
165         if (deliver_count != expected_count){
166             System.err.println(&quot;deliver_count = &quot;+deliver_count+&quot; (!=&quot;+expected_count+&quot;)&quot;);
167             throw new RuntimeException(&quot;incorrect behaviour&quot;);
168         }
169     }// start()
170 
171     private void moveMouseOver(Container c) {
172         Point p = c.getLocationOnScreen();
173         Dimension d = c.getSize();
174         robot.mouseMove(p.x + (int)(d.getWidth()/2), p.y + (int)(d.getHeight()/2));
175     }
176 
177     private void waitTillShown(Component c) {
178         while (true) {
179             try {
180                 Thread.sleep(100);
181                 c.getLocationOnScreen();
182                 break;
183             } catch (InterruptedException ie) {
184                 ie.printStackTrace();
185                 break;
186             } catch (Exception e) {
187             }
188         }
189     }
190     private void makeFocused(Component comp) {
191         if (comp.isFocusOwner()) {
192             return;
193         }
194         final Semaphore sema = new Semaphore();
195         final FocusAdapter fa = new FocusAdapter() {
196                 public void focusGained(FocusEvent fe) {
197                     sema.raise();
198                 }
199             };
200         comp.addFocusListener(fa);
201         comp.requestFocusInWindow();
202         if (comp.isFocusOwner()) {
203             return;
204         }
205         try {
206             sema.doWait(3000);
207         } catch (InterruptedException ie) {
208             ie.printStackTrace();
209         }
210         comp.removeFocusListener(fa);
211         if (!comp.isFocusOwner()) {
212             throw new RuntimeException(&quot;Can&#39;t make &quot; + comp + &quot; focused, current owner is &quot; + KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner());
213         }
214     }
215 
216 static class Semaphore {
217     boolean state = false;
218     int waiting = 0;
219     public Semaphore() {
220     }
221     public synchronized void doWait() throws InterruptedException {
222         if (state) {
223             return;
224         }
225         waiting++;
226         wait();
227         waiting--;
228     }
229     public synchronized void doWait(int timeout) throws InterruptedException {
230         if (state) {
231             return;
232         }
233         waiting++;
234         wait(timeout);
235         waiting--;
236     }
237     public synchronized void raise() {
238         state = true;
239         if (waiting &gt; 0) {
240             notifyAll();
241         }
242     }
243     public synchronized boolean getState() {
244         return state;
245     }
246 }
247 }
    </pre>
  </body>
</html>
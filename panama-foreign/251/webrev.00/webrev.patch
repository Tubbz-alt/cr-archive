diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/ConstantHelper.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/ConstantHelper.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/ConstantHelper.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/ConstantHelper.java
@@ -20,11 +20,11 @@
  *
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
-package jdk.incubator.jextract.tool;
+package jdk.incubator.jextract;
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
@@ -61,11 +61,11 @@
 import static java.lang.constant.ConstantDescs.*;
 import static java.lang.invoke.MethodHandleInfo.*;
 import static java.lang.invoke.MethodType.methodType;
 import static jdk.internal.org.objectweb.asm.Opcodes.*;
 
-class ConstantHelper {
+public class ConstantHelper {
 
     private static final String INTR_OBJECT = Type.getInternalName(Object.class);
 
     private static final ClassDesc CD_LIBRARIES = desc(LibraryLookup[].class);
 
@@ -140,11 +140,11 @@
             Map.entry(Float.TYPE,               desc(Float.TYPE)),
             Map.entry(Double.TYPE,              desc(Double.TYPE)),
             Map.entry(MemoryAddress.class,      desc(Long.TYPE))
     );
 
-    ConstantHelper(String parentClassName, ClassDesc runtimeHelper, ClassDesc cString, String[] libraryNames) {
+    public ConstantHelper(String parentClassName, ClassDesc runtimeHelper, ClassDesc cString, String[] libraryNames) {
         this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
         String className = parentClassName + "$constants";
         this.CD_constantsHelper = ClassDesc.of(className);
         this.internalClassName = className.replace('.', '/');
 
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Filter.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Filter.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Filter.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.incubator.jextract;
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Position;
+
+public class Filter {
+    private Filter() {}
+
+    public static Declaration.Scoped filter(Declaration.Scoped decl, String... validNames) {
+        Declaration[] newMembers = decl.members().stream()
+                .filter(d -> filterDecl(d, validNames))
+                .toArray(Declaration[]::new);
+        return Declaration.toplevel(decl.pos(), newMembers);
+    }
+
+    private static boolean filterDecl(Declaration d, String... validNames) {
+        if (d.pos() == Position.NO_POSITION) {
+            return false;
+        } else {
+            for (String s : validNames) {
+                String pathName = d.pos().path().toString();
+                if (pathName.contains(s)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/FunctionalInterfaceScanner.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/FunctionalInterfaceScanner.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/FunctionalInterfaceScanner.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/FunctionalInterfaceScanner.java
@@ -21,11 +21,11 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
-package jdk.incubator.jextract.tool;
+package jdk.incubator.jextract;
 
 import jdk.incubator.jextract.Declaration;
 import jdk.incubator.jextract.Type;
 import jdk.incubator.foreign.FunctionDescriptor;
 
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.incubator.jextract;
+
+import jdk.incubator.foreign.FunctionDescriptor;
+import java.lang.invoke.MethodType;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A helper class to generate header interface class in source form.
+ * After aggregating various constituents of a .java source, build
+ * method is called to get overall generated source string.
+ */
+public class HeaderBuilder extends JavaSourceBuilder {
+    public HeaderBuilder(String className, String pkgName, ConstantHelper constantHelper) {
+        super(className, pkgName, constantHelper);
+    }
+
+    public void addFunctionalInterface(String name, MethodType mtype,  FunctionDescriptor fDesc) {
+        incrAlign();
+        indent();
+        sb.append("public interface " + name + " {\n");
+        incrAlign();
+        indent();
+        sb.append(mtype.returnType().getName() + " apply(");
+        String delim = "";
+        for (int i = 0 ; i < mtype.parameterCount(); i++) {
+            sb.append(delim + mtype.parameterType(i).getName() + " x" + i);
+            delim = ", ";
+        }
+        sb.append(");\n");
+        addFunctionalFactory(name, mtype, fDesc);
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+        indent();
+    }
+
+    public void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + mtype.returnType().getName() + " " + javaName + " (");
+        String delim = "";
+        List<String> pNames = new ArrayList<>();
+        final int numParams = paramNames.size();
+        for (int i = 0 ; i < numParams; i++) {
+            String pName = paramNames.get(i);
+            if (pName.isEmpty()) {
+                pName = "x" + i;
+            }
+            pNames.add(pName);
+            sb.append(delim + mtype.parameterType(i).getName() + " " + pName);
+            delim = ", ";
+        }
+        if (varargs) {
+            String lastArg = "x" + numParams;
+            if (numParams > 0) {
+                sb.append(", ");
+            }
+            sb.append("Object... " + lastArg);
+            pNames.add(lastArg);
+        }
+        sb.append(") {\n");
+        incrAlign();
+        indent();
+        sb.append("try {\n");
+        incrAlign();
+        indent();
+        if (!mtype.returnType().equals(void.class)) {
+            sb.append("return (" + mtype.returnType().getName() + ")");
+        }
+        sb.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + ".invokeExact(" + String.join(", ", pNames) + ");\n");
+        decrAlign();
+        indent();
+        sb.append("} catch (Throwable ex) {\n");
+        incrAlign();
+        indent();
+        sb.append("throw new AssertionError(ex);\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    public void emitPrimitiveTypedef(Type.Primitive primType, String name) {
+        Type.Primitive.Kind kind = primType.kind();
+        if (primitiveKindSupported(kind) && !kind.layout().isEmpty()) {
+            incrAlign();
+            indent();
+            sb.append(PUB_MODS);
+            sb.append("ValueLayout ");
+            sb.append(name);
+            sb.append(" = ");
+            sb.append(TypeTranslator.typeToLayoutName(kind));
+            sb.append(";\n");
+            decrAlign();
+        }
+    }
+
+    private boolean primitiveKindSupported(Type.Primitive.Kind kind) {
+        return switch(kind) {
+            case Short, Int, Long, LongLong, Float, Double, LongDouble, Char -> true;
+            default -> false;
+        };
+    }
+
+    public void emitTypedef(String className, String superClassName) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS);
+        sb.append("class ");
+        sb.append(className);
+        sb.append(" extends ");
+        sb.append(superClassName);
+        sb.append(" {\n");
+        incrAlign();
+        indent();
+        // private constructor
+        sb.append("private ");
+        sb.append(className);
+        sb.append("() {}\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    private void addFunctionalFactory(String className, MethodType mtype, FunctionDescriptor fDesc) {
+        indent();
+        sb.append(PUB_MODS + "MemorySegment allocate(" + className + " fi) {\n");
+        incrAlign();
+        indent();
+        sb.append("return RuntimeHelper.upcallStub(" + className + ".class, fi, " + functionGetCallString(className, fDesc) + ", " +
+                "\"" + mtype.toMethodDescriptorString() + "\");\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+
+        indent();
+        sb.append(PUB_MODS + "MemoryAddress allocate(" + className + " fi, NativeScope scope) {\n");
+        incrAlign();
+        indent();
+        sb.append("return scope.register(allocate(fi)).baseAddress();\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JavaSourceBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JavaSourceBuilder.java
@@ -20,11 +20,11 @@
  *
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
-package jdk.incubator.jextract.tool;
+package jdk.incubator.jextract;
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryLayout;
 
 import javax.tools.JavaFileObject;
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/OutputFactory.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/OutputFactory.java
@@ -0,0 +1,416 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.incubator.jextract;
+
+import jdk.incubator.foreign.*;
+import jdk.incubator.jextract.Type.Primitive;
+import javax.tools.JavaFileObject;
+import javax.tools.SimpleJavaFileObject;
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.lang.constant.ClassDesc;
+import java.lang.invoke.MethodType;
+import java.net.URI;
+import java.net.URL;
+import java.net.URISyntaxException;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/*
+ * Scan a header file and generate Java source items for entities defined in that header
+ * file. Tree visitor visit methods return true/false depending on whether a
+ * particular Tree is processed or skipped.
+ */
+public class OutputFactory implements Declaration.Visitor<Void, Declaration> {
+    private final Set<String> constants = new HashSet<>();
+    // To detect duplicate Variable and Function declarations.
+    private final Set<Declaration.Variable> variables = new HashSet<>();
+    private final Set<Declaration.Function> functions = new HashSet<>();
+
+    protected final HeaderBuilder builder;
+    protected final ConstantHelper constantHelper;
+    protected final TypeTranslator typeTranslator = new TypeTranslator();
+    private final String clsName;
+    private final String pkgName;
+    private StructBuilder structBuilder;
+    private Map<Declaration, String> structClassNames = new HashMap<>();
+    private List<String> structSources = new ArrayList<>();
+    private Set<String> nestedClassNames = new HashSet<>();
+    private Set<Declaration.Typedef> unresolvedStructTypedefs = new HashSet<>();
+    private int nestedClassNameCount = 0;
+    /*
+     * We may have case-insensitive name collision! A C program may have
+     * defined structs/unions/typedefs with the names FooS, fooS, FoOs, fOOs.
+     * Because we map structs/unions/typedefs to nested classes of header classes,
+     * such a case-insensitive name collision is problematic. This is because in
+     * a case-insensitive file system javac will overwrite classes for
+     * Header$CFooS, Header$CfooS, Header$CFoOs and so on! We solve this by
+     * generating unique case-insensitive names for nested classes.
+     */
+    private String uniqueNestedClassName(String name) {
+        name = Utils.javaSafeIdentifier(name);
+        return nestedClassNames.add(name.toLowerCase())? name : (name + "$" + nestedClassNameCount++);
+    }
+
+    private String structClassName(Declaration decl) {
+        return structClassNames.computeIfAbsent(decl, d -> uniqueNestedClassName(d.name()));
+    }
+
+    private boolean structDefinitionSeen(Declaration decl) {
+        return structClassNames.containsKey(decl);
+    }
+
+    // have we seen this Variable earlier?
+    protected boolean variableSeen(Declaration.Variable tree) {
+        return !variables.add(tree);
+    }
+
+    // have we seen this Function earlier?
+    protected boolean functionSeen(Declaration.Function tree) {
+        return !functions.add(tree);
+    }
+
+    public static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String headerName, String pkgName, List<String> libraryNames) {
+        String clsName = Utils.javaSafeIdentifier(headerName.replace(".h", "_h"), true);
+        String qualName = pkgName.isEmpty() ? clsName : pkgName + "." + clsName;
+        ConstantHelper constantHelper = new ConstantHelper(qualName,
+                ClassDesc.of(pkgName, "RuntimeHelper"), ClassDesc.of("jdk.incubator.foreign", "CSupport"),
+                libraryNames.toArray(String[]::new));
+        return new OutputFactory(clsName, pkgName,
+                new HeaderBuilder(clsName, pkgName, constantHelper), constantHelper).generate(decl);
+    }
+
+    public OutputFactory(String clsName, String pkgName, HeaderBuilder builder, ConstantHelper constantHelper) {
+        this.clsName = clsName;
+        this.pkgName = pkgName;
+        this.builder = builder;
+        this.constantHelper = constantHelper;
+    }
+
+    private static String getCLangConstantsHolder() {
+        String prefix = "jdk.incubator.foreign.CSupport.";
+        String abi = CSupport.getSystemLinker().name();
+        switch (abi) {
+            case CSupport.SysV.NAME:
+                return prefix + "SysV";
+            case CSupport.Win64.NAME:
+                return prefix + "Win64";
+            case CSupport.AArch64.NAME:
+                return prefix + "AArch64";
+            default:
+                throw new UnsupportedOperationException("Unsupported ABI: " + abi);
+        }
+    }
+
+    static final String C_LANG_CONSTANTS_HOLDER = getCLangConstantsHolder();
+
+    public JavaFileObject[] generate(Declaration.Scoped decl) {
+        builder.classBegin();
+        //generate all decls
+        decl.members().forEach(this::generateDecl);
+        for (String src : structSources) {
+            builder.addContent(src);
+        }
+        // check if unresolved typedefs can be resolved now!
+        for (Declaration.Typedef td : unresolvedStructTypedefs) {
+            Declaration.Scoped structDef = ((Type.Declared)td.type()).tree();
+            if (structDefinitionSeen(structDef)) {
+                builder.emitTypedef(uniqueNestedClassName(td.name()), structClassName(structDef));
+            }
+        }
+        builder.classEnd();
+        try {
+            List<JavaFileObject> files = new ArrayList<>();
+            files.add(builder.build());
+            files.addAll(constantHelper.getClasses());
+            files.add(fileFromString(pkgName,"RuntimeHelper", getRuntimeHelperSource()));
+            return files.toArray(new JavaFileObject[0]);
+        } catch (IOException ex) {
+            throw new UncheckedIOException(ex);
+        } catch (URISyntaxException ex2) {
+            throw new RuntimeException(ex2);
+        }
+    }
+
+    private String getRuntimeHelperSource() throws URISyntaxException, IOException {
+        URL runtimeHelper = OutputFactory.class.getResource("resources/RuntimeHelper.java.template");
+        return (pkgName.isEmpty()? "" : "package " + pkgName + ";\n") +
+                        String.join("\n", Files.readAllLines(Paths.get(runtimeHelper.toURI())))
+                                .replace("${C_LANG}", C_LANG_CONSTANTS_HOLDER);
+    }
+
+    private void generateDecl(Declaration tree) {
+        try {
+            tree.accept(this, null);
+        } catch (Exception ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    private static Class<?> classForType(Primitive.Kind type, MemoryLayout layout) {
+        boolean isFloat = switch(type) {
+            case Float, Double, LongDouble -> true;
+            default-> false;
+        };
+        return TypeTranslator.layoutToClass(isFloat, layout);
+    }
+
+    private JavaFileObject fileFromString(String pkgName, String clsName, String contents) {
+        String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
+        return new SimpleJavaFileObject(URI.create(pkgPrefix + clsName + ".java"), JavaFileObject.Kind.SOURCE) {
+            @Override
+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
+                return contents;
+            }
+        };
+    }
+
+    @Override
+    public Void visitConstant(Declaration.Constant constant, Declaration parent) {
+        if (!constants.add(constant.name())) {
+            //skip
+            return null;
+        }
+
+        builder.addConstantGetter(Utils.javaSafeIdentifier(constant.name()), typeTranslator.getJavaType(constant.type()), constant.value());
+        return null;
+    }
+
+    @Override
+    public Void visitScoped(Declaration.Scoped d, Declaration parent) {
+        if (d.layout().isEmpty()) {
+            //skip decl-only
+            return null;
+        }
+        boolean structClass = false;
+        StructBuilder oldStructBuilder = this.structBuilder;
+        if (!d.name().isEmpty() || !isRecord(parent)) {
+            //only add explicit struct layout if the struct is not to be flattened inside another struct
+            switch (d.kind()) {
+                case STRUCT:
+                case UNION: {
+                    structClass = true;
+                    String className = structClassName(d.name().isEmpty() ? parent : d);
+                    this.structBuilder = new StructBuilder(className, pkgName, constantHelper);
+                    structBuilder.incrAlign();
+                    structBuilder.classBegin();
+                    structBuilder.addLayoutGetter(className, d.layout().get());
+                    break;
+                }
+            }
+        }
+        d.members().forEach(fieldTree -> fieldTree.accept(this, d.name().isEmpty() ? parent : d));
+        if (structClass) {
+            this.structBuilder.classEnd();
+            structSources.add(structBuilder.getSource());
+            this.structBuilder = oldStructBuilder;
+        }
+        return null;
+    }
+
+    @Override
+    public Void visitFunction(Declaration.Function funcTree, Declaration parent) {
+        if (functionSeen(funcTree)) {
+            return null;
+        }
+
+        MethodType mtype = typeTranslator.getMethodType(funcTree.type());
+        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);
+        if (descriptor == null) {
+            //abort
+            return null;
+        }
+        String mhName = Utils.javaSafeIdentifier(funcTree.name());
+        builder.addMethodHandleGetter(mhName, funcTree.name(), mtype, descriptor, funcTree.type().varargs());
+        //generate static wrapper for function
+        List<String> paramNames = funcTree.parameters()
+                                          .stream()
+                                          .map(Declaration.Variable::name)
+                                          .map(p -> !p.isEmpty() ? Utils.javaSafeIdentifier(p) : p)
+                                          .collect(Collectors.toList());
+        builder.addStaticFunctionWrapper(Utils.javaSafeIdentifier(funcTree.name()), funcTree.name(), mtype,
+                Type.descriptorFor(funcTree.type()).orElseThrow(), funcTree.type().varargs(), paramNames);
+        int i = 0;
+        for (Declaration.Variable param : funcTree.parameters()) {
+            Type.Function f = getAsFunctionPointer(param.type());
+            if (f != null) {
+                String name = funcTree.name() + "$" + (param.name().isEmpty() ? "x" + i : param.name());
+                name = Utils.javaSafeIdentifier(name);
+                //generate functional interface
+                if (f.varargs()) {
+                    System.err.println("WARNING: varargs in callbacks is not supported");
+                }
+                MethodType fitype = typeTranslator.getMethodType(f, false);
+                builder.addFunctionalInterface(name, fitype, Type.descriptorFor(f).orElseThrow());
+                i++;
+            }
+        }
+        return null;
+    }
+
+    Type.Function getAsFunctionPointer(Type type) {
+        if (type instanceof Type.Delegated) {
+            switch (((Type.Delegated) type).kind()) {
+                case POINTER: {
+                    Type pointee = ((Type.Delegated) type).type();
+                    return (pointee instanceof Type.Function) ?
+                        (Type.Function)pointee : null;
+                }
+                default:
+                    return getAsFunctionPointer(((Type.Delegated) type).type());
+            }
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public Void visitTypedef(Declaration.Typedef tree, Declaration parent) {
+        Type type = tree.type();
+        if (type instanceof Type.Declared) {
+            Declaration.Scoped s = ((Type.Declared) type).tree();
+            if (!s.name().equals(tree.name())) {
+                switch (s.kind()) {
+                    case STRUCT:
+                    case UNION: {
+                        if (s.name().isEmpty()) {
+                            visitScoped(s, tree);
+                        } else {
+                            /*
+                             * If typedef is seen after the struct/union definition, we can generate subclass
+                             * right away. If not, we've to save it and revisit after all the declarations are
+                             * seen. This is to support forward declaration of typedefs.
+                             *
+                             * typedef struct Foo Bar;
+                             *
+                             * struct Foo {
+                             *     int x, y;
+                             * };
+                             */
+                            if (structDefinitionSeen(s)) {
+                                builder.emitTypedef(uniqueNestedClassName(tree.name()), structClassName(s));
+                            } else {
+                                /*
+                                 * Definition of typedef'ed struct/union not seen yet. May be the definition comes later.
+                                 * Save it to visit at the end of all declarations.
+                                 */
+                                unresolvedStructTypedefs.add(tree);
+                            }
+                        }
+                    }
+                    break;
+                    default:
+                        visitScoped(s, tree);
+                }
+            }
+        } else if (type instanceof Type.Primitive) {
+             builder.emitPrimitiveTypedef((Type.Primitive)type, uniqueNestedClassName(tree.name()));
+        }
+        return null;
+    }
+
+    @Override
+    public Void visitVariable(Declaration.Variable tree, Declaration parent) {
+        if (parent == null && variableSeen(tree)) {
+            return null;
+        }
+
+        String fieldName = tree.name();
+        String symbol = tree.name();
+        assert !symbol.isEmpty();
+        assert !fieldName.isEmpty();
+        fieldName = Utils.javaSafeIdentifier(fieldName);
+
+        Type type = tree.type();
+        MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));
+        if (layout == null) {
+            //no layout - abort
+            return null;
+        }
+        Class<?> clazz = typeTranslator.getJavaType(type);
+        if (tree.kind() == Declaration.Variable.Kind.BITFIELD ||
+                (layout instanceof ValueLayout && layout.byteSize() > 8)) {
+            //skip
+            return null;
+        }
+
+        boolean isSegment = clazz == MemorySegment.class;
+        MemoryLayout treeLayout = tree.layout().orElseThrow();
+        if (parent != null) { //struct field
+            MemoryLayout parentLayout = parentLayout(parent);
+            if (isSegment) {
+                structBuilder.addAddressGetter(fieldName, tree.name(), treeLayout, parentLayout);
+            } else {
+                structBuilder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+                structBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+                structBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+            }
+        } else {
+            if (isSegment) {
+                builder.addAddressGetter(fieldName, tree.name(), treeLayout, null);
+            } else {
+                builder.addLayoutGetter(fieldName, layout);
+                builder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz,null);
+                builder.addAddressGetter(fieldName, tree.name(), treeLayout, null);
+                builder.addGetter(fieldName, tree.name(), treeLayout, clazz, null);
+                builder.addSetter(fieldName, tree.name(), treeLayout, clazz, null);
+            }
+        }
+
+        return null;
+    }
+
+    private boolean isRecord(Declaration declaration) {
+        if (declaration == null) {
+            return false;
+        } else if (!(declaration instanceof Declaration.Scoped)) {
+            return false;
+        } else {
+            Declaration.Scoped scope = (Declaration.Scoped)declaration;
+            return scope.kind() == Declaration.Scoped.Kind.CLASS ||
+                    scope.kind() == Declaration.Scoped.Kind.STRUCT ||
+                    scope.kind() == Declaration.Scoped.Kind.UNION;
+        }
+    }
+
+    protected static MemoryLayout parentLayout(Declaration parent) {
+        if (parent instanceof Declaration.Typedef) {
+            Declaration.Typedef alias = (Declaration.Typedef) parent;
+            return Type.layoutFor(alias.type()).orElseThrow();
+        } else if (parent instanceof Declaration.Scoped) {
+            return ((Declaration.Scoped) parent).layout().orElseThrow();
+        } else {
+            throw new IllegalArgumentException("Unexpected parent declaration");
+        }
+        // case like `typedef struct { ... } Foo`
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/StructBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/StructBuilder.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/StructBuilder.java
@@ -0,0 +1,208 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.incubator.jextract;
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+
+/**
+ * This class generates static utilities class for C structs, unions.
+ */
+public class StructBuilder extends JavaSourceBuilder {
+    public StructBuilder(String className, String pkgName, ConstantHelper constantHelper) {
+        super(className, pkgName, constantHelper);
+    }
+
+    @Override
+    protected String getClassModifiers() {
+        return PUB_MODS;
+    }
+
+    @Override
+    protected void addPackagePrefix() {
+        // nested class. containing class has necessary package declaration
+    }
+
+    @Override
+    protected void addImportSection() {
+        // nested class. containing class has necessary imports
+    }
+
+    @Override
+    public void classEnd() {
+        emitSizeof();
+        emitAllocate();
+        emitScopeAllocate();
+        emitAllocateArray();
+        emitScopeAllocateArray();
+        super.classEnd();
+    }
+
+    @Override
+    public void addLayoutGetter(String javaName, MemoryLayout layout) {
+        var desc = constantHelper.addLayout(javaName + "$struct", layout);
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + displayName(desc.invocationType().returnType()) + " $LAYOUT() {\n");
+        incrAlign();
+        indent();
+        sb.append("return " + getCallString(desc) + ";\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    @Override
+    public void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(MemoryAddress addr) {\n");
+        incrAlign();
+        indent();
+        sb.append("return (" + type.getName() + ")"
+                + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(addr);\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+
+        addIndexGetter(javaName, nativeName, layout, type, parentLayout);
+    }
+
+    @Override
+    public void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        incrAlign();
+        indent();
+        String param = MemoryAddress.class.getName() + " addr";
+        sb.append(PUB_MODS + "void " + javaName + "$set(" + param + ", " + type.getName() + " x) {\n");
+        incrAlign();
+        indent();
+        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, null) + ".set(addr, x);\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+
+        addIndexSetter(javaName, nativeName, layout, type, parentLayout);
+    }
+
+    @Override
+    public void addAddressGetter(String javaName, String nativeName, MemoryLayout layout, MemoryLayout parentLayout) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + "MemoryAddress " + javaName + "$addr(MemoryAddress addr) {\n");
+        incrAlign();
+        indent();
+        sb.append("return addr.segment().asSlice(");
+        sb.append(parentLayout.byteOffset(MemoryLayout.PathElement.groupElement(nativeName)));
+        sb.append(", ");
+        sb.append(layout.byteSize());
+        sb.append(").baseAddress();\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    private void emitSizeof() {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS);
+        sb.append("long sizeof() { return $LAYOUT().byteSize(); }\n");
+        decrAlign();
+    }
+
+    private void emitAllocate() {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS);
+        sb.append("MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n");
+        decrAlign();
+    }
+
+    private void emitScopeAllocate() {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS);
+        sb.append("MemoryAddress allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n");
+        decrAlign();
+    }
+
+    private void emitAllocateArray() {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS);
+        sb.append("MemorySegment allocateArray(int len) {\n");
+        incrAlign();
+        indent();
+        sb.append("return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));");
+        decrAlign();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    private void emitScopeAllocateArray() {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS);
+        sb.append("MemoryAddress allocateArray(int len, NativeScope scope) {\n");
+        incrAlign();
+        indent();
+        sb.append("return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));");
+        decrAlign();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    private void addIndexGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        incrAlign();
+        indent();
+        String params = MemoryAddress.class.getName() + " addr, long index";
+        sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(" + params + ") {\n");
+        incrAlign();
+        indent();
+        sb.append("return (" + type.getName() + ")"
+                + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(addr.addOffset(index*sizeof()));\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    private void addIndexSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        incrAlign();
+        indent();
+        String params = MemoryAddress.class.getName() + " addr, long index, " + type.getName() + " x";
+        sb.append(PUB_MODS + "void " + javaName + "$set(" + params + ") {\n");
+        incrAlign();
+        indent();
+        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".set(addr.addOffset(index*sizeof()), x);\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/TypeTranslator.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/TypeTranslator.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/TypeTranslator.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/TypeTranslator.java
@@ -21,11 +21,11 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
-package jdk.incubator.jextract.tool;
+package jdk.incubator.jextract;
 
 import jdk.incubator.jextract.Type.Primitive;
 import jdk.incubator.jextract.Type;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Utils.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Utils.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Utils.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.incubator.jextract;
+
+import javax.lang.model.SourceVersion;
+import javax.tools.JavaFileObject;
+import javax.tools.SimpleJavaFileObject;
+import java.io.IOException;
+import java.net.URI;
+
+final class Utils {
+
+    private Utils() {}
+
+    private static URI fileName(String pkgName, String clsName, String extension) {
+        String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
+        return URI.create(pkgPrefix + clsName + extension);
+    }
+
+    static JavaFileObject fileFromString(String pkgName, String clsName, String contents) {
+        return new SimpleJavaFileObject(fileName(pkgName, clsName, ".java"), JavaFileObject.Kind.SOURCE) {
+            @Override
+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
+                return contents;
+            }
+        };
+    }
+
+    static String javaSafeIdentifier(String name) {
+        return javaSafeIdentifier(name, false);
+    }
+
+    static String javaSafeIdentifier(String name, boolean checkAllChars) {
+        if (checkAllChars) {
+            StringBuilder buf = new StringBuilder();
+            char[] chars = name.toCharArray();
+            if (Character.isJavaIdentifierStart(chars[0])) {
+                buf.append(chars[0]);
+            } else {
+                buf.append('_');
+            }
+            if (chars.length > 1) {
+                for (int i = 1; i < chars.length; i++) {
+                    char ch = chars[i];
+                    if (Character.isJavaIdentifierPart(ch)) {
+                        buf.append(ch);
+                    } else {
+                        buf.append('_');
+                    }
+                }
+            }
+            return buf.toString();
+        } else {
+            // We never get the problem of Java non-identifiers (like 123, ab-xy) as
+            // C identifiers. But we may have a java keyword used as a C identifier.
+            assert SourceVersion.isIdentifier(name);
+
+            return SourceVersion.isKeyword(name) ? (name + "_") : name;
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/resources/RuntimeHelper.java.template
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/resources/RuntimeHelper.java.template
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Filter.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Filter.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Filter.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package jdk.incubator.jextract.tool;
-
-import jdk.incubator.jextract.Declaration;
-import jdk.incubator.jextract.Position;
-
-public class Filter {
-
-    public static Declaration.Scoped filter(Declaration.Scoped decl, String... validNames) {
-        Declaration[] newMembers = decl.members().stream()
-                .filter(d -> filterDecl(d, validNames))
-                .toArray(Declaration[]::new);
-        return Declaration.toplevel(decl.pos(), newMembers);
-    }
-
-    static boolean filterDecl(Declaration d, String... validNames) {
-        if (d.pos() == Position.NO_POSITION) {
-            return false;
-        } else {
-            for (String s : validNames) {
-                String pathName = d.pos().path().toString();
-                if (pathName.contains(s)) {
-                    return true;
-                }
-            }
-            return false;
-        }
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.jextract.tool;
-
-import jdk.incubator.foreign.FunctionDescriptor;
-import java.lang.invoke.MethodType;
-import java.util.ArrayList;
-import java.util.List;
-import jdk.incubator.jextract.Type;
-
-/**
- * A helper class to generate header interface class in source form.
- * After aggregating various constituents of a .java source, build
- * method is called to get overall generated source string.
- */
-class HeaderBuilder extends JavaSourceBuilder {
-    HeaderBuilder(String className, String pkgName, ConstantHelper constantHelper) {
-        super(className, pkgName, constantHelper);
-    }
-
-    public void addFunctionalInterface(String name, MethodType mtype,  FunctionDescriptor fDesc) {
-        incrAlign();
-        indent();
-        sb.append("public interface " + name + " {\n");
-        incrAlign();
-        indent();
-        sb.append(mtype.returnType().getName() + " apply(");
-        String delim = "";
-        for (int i = 0 ; i < mtype.parameterCount(); i++) {
-            sb.append(delim + mtype.parameterType(i).getName() + " x" + i);
-            delim = ", ";
-        }
-        sb.append(");\n");
-        addFunctionalFactory(name, mtype, fDesc);
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-        indent();
-    }
-
-    public void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + mtype.returnType().getName() + " " + javaName + " (");
-        String delim = "";
-        List<String> pNames = new ArrayList<>();
-        final int numParams = paramNames.size();
-        for (int i = 0 ; i < numParams; i++) {
-            String pName = paramNames.get(i);
-            if (pName.isEmpty()) {
-                pName = "x" + i;
-            }
-            pNames.add(pName);
-            sb.append(delim + mtype.parameterType(i).getName() + " " + pName);
-            delim = ", ";
-        }
-        if (varargs) {
-            String lastArg = "x" + numParams;
-            if (numParams > 0) {
-                sb.append(", ");
-            }
-            sb.append("Object... " + lastArg);
-            pNames.add(lastArg);
-        }
-        sb.append(") {\n");
-        incrAlign();
-        indent();
-        sb.append("try {\n");
-        incrAlign();
-        indent();
-        if (!mtype.returnType().equals(void.class)) {
-            sb.append("return (" + mtype.returnType().getName() + ")");
-        }
-        sb.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + ".invokeExact(" + String.join(", ", pNames) + ");\n");
-        decrAlign();
-        indent();
-        sb.append("} catch (Throwable ex) {\n");
-        incrAlign();
-        indent();
-        sb.append("throw new AssertionError(ex);\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    public void emitPrimitiveTypedef(Type.Primitive primType, String name) {
-        Type.Primitive.Kind kind = primType.kind();
-        if (primitiveKindSupported(kind) && !kind.layout().isEmpty()) {
-            incrAlign();
-            indent();
-            sb.append(PUB_MODS);
-            sb.append("ValueLayout ");
-            sb.append(name);
-            sb.append(" = ");
-            sb.append(TypeTranslator.typeToLayoutName(kind));
-            sb.append(";\n");
-            decrAlign();
-        }
-    }
-
-    private boolean primitiveKindSupported(Type.Primitive.Kind kind) {
-        return switch(kind) {
-            case Short, Int, Long, LongLong, Float, Double, LongDouble, Char -> true;
-            default -> false;
-        };
-    }
-
-    public void emitTypedef(String className, String superClassName) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS);
-        sb.append("class ");
-        sb.append(className);
-        sb.append(" extends ");
-        sb.append(superClassName);
-        sb.append(" {\n");
-        incrAlign();
-        indent();
-        // private constructor
-        sb.append("private ");
-        sb.append(className);
-        sb.append("() {}\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    private void addFunctionalFactory(String className, MethodType mtype, FunctionDescriptor fDesc) {
-        indent();
-        sb.append(PUB_MODS + "MemorySegment allocate(" + className + " fi) {\n");
-        incrAlign();
-        indent();
-        sb.append("return RuntimeHelper.upcallStub(" + className + ".class, fi, " + functionGetCallString(className, fDesc) + ", " +
-                "\"" + mtype.toMethodDescriptorString() + "\");\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-
-        indent();
-        sb.append(PUB_MODS + "MemoryAddress allocate(" + className + " fi, NativeScope scope) {\n");
-        incrAlign();
-        indent();
-        sb.append("return scope.register(allocate(fi)).baseAddress();\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Main.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Main.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Main.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Main.java
@@ -23,12 +23,11 @@
  * questions.
  */
 
 package jdk.incubator.jextract.tool;
 
-import jdk.incubator.jextract.Declaration;
-import jdk.incubator.jextract.JextractTask;
+import jdk.incubator.jextract.*;
 import jdk.internal.joptsimple.OptionException;
 import jdk.internal.joptsimple.OptionParser;
 import jdk.internal.joptsimple.OptionSet;
 
 import javax.tools.JavaFileObject;
@@ -191,11 +190,11 @@
 
             Path output = Path.of(options.outputDir);
 
             JavaFileObject[] files = OutputFactory.generateWrapped(
                 toplevel,
-                Utils.javaSafeIdentifier(header.getFileName().toString().replace(".h", "_h"), true),
+                header.getFileName().toString(),
                 options.targetPackage,
                 options.libraryNames);
             jextractTask.write(output, files);
         } catch (RuntimeException re) {
             err.println(re);
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
+++ /dev/null
@@ -1,417 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.jextract.tool;
-
-import jdk.incubator.foreign.*;
-import jdk.incubator.jextract.Declaration;
-import jdk.incubator.jextract.Type;
-import jdk.incubator.jextract.Type.Primitive;
-import javax.tools.JavaFileObject;
-import javax.tools.SimpleJavaFileObject;
-import java.io.IOException;
-import java.io.UncheckedIOException;
-import java.lang.constant.ClassDesc;
-import java.lang.invoke.MethodType;
-import java.net.URI;
-import java.net.URL;
-import java.net.URISyntaxException;
-import java.nio.file.Files;
-import java.nio.file.Paths;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.stream.Collectors;
-
-/*
- * Scan a header file and generate Java source items for entities defined in that header
- * file. Tree visitor visit methods return true/false depending on whether a
- * particular Tree is processed or skipped.
- */
-public class OutputFactory implements Declaration.Visitor<Void, Declaration> {
-    private final Set<String> constants = new HashSet<>();
-    // To detect duplicate Variable and Function declarations.
-    private final Set<Declaration.Variable> variables = new HashSet<>();
-    private final Set<Declaration.Function> functions = new HashSet<>();
-
-    protected final HeaderBuilder builder;
-    protected final ConstantHelper constantHelper;
-    protected final TypeTranslator typeTranslator = new TypeTranslator();
-    private final String clsName;
-    private final String pkgName;
-    private StructBuilder structBuilder;
-    private Map<Declaration, String> structClassNames = new HashMap<>();
-    private List<String> structSources = new ArrayList<>();
-    private Set<String> nestedClassNames = new HashSet<>();
-    private Set<Declaration.Typedef> unresolvedStructTypedefs = new HashSet<>();
-    private int nestedClassNameCount = 0;
-    /*
-     * We may have case-insensitive name collision! A C program may have
-     * defined structs/unions/typedefs with the names FooS, fooS, FoOs, fOOs.
-     * Because we map structs/unions/typedefs to nested classes of header classes,
-     * such a case-insensitive name collision is problematic. This is because in
-     * a case-insensitive file system javac will overwrite classes for
-     * Header$CFooS, Header$CfooS, Header$CFoOs and so on! We solve this by
-     * generating unique case-insensitive names for nested classes.
-     */
-    private String uniqueNestedClassName(String name) {
-        name = Utils.javaSafeIdentifier(name);
-        return nestedClassNames.add(name.toLowerCase())? name : (name + "$" + nestedClassNameCount++);
-    }
-
-    private String structClassName(Declaration decl) {
-        return structClassNames.computeIfAbsent(decl, d -> uniqueNestedClassName(d.name()));
-    }
-
-    private boolean structDefinitionSeen(Declaration decl) {
-        return structClassNames.containsKey(decl);
-    }
-
-    // have we seen this Variable earlier?
-    protected boolean variableSeen(Declaration.Variable tree) {
-        return !variables.add(tree);
-    }
-
-    // have we seen this Function earlier?
-    protected boolean functionSeen(Declaration.Function tree) {
-        return !functions.add(tree);
-    }
-
-    static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String clsName, String pkgName, List<String> libraryNames) {
-        String qualName = pkgName.isEmpty() ? clsName : pkgName + "." + clsName;
-        ConstantHelper constantHelper = new ConstantHelper(qualName,
-                ClassDesc.of(pkgName, "RuntimeHelper"), ClassDesc.of("jdk.incubator.foreign", "CSupport"),
-                libraryNames.toArray(String[]::new));
-        return new OutputFactory(clsName, pkgName,
-                new HeaderBuilder(clsName, pkgName, constantHelper), constantHelper).generate(decl);
-    }
-
-    public OutputFactory(String clsName, String pkgName, HeaderBuilder builder, ConstantHelper constantHelper) {
-        this.clsName = clsName;
-        this.pkgName = pkgName;
-        this.builder = builder;
-        this.constantHelper = constantHelper;
-    }
-
-    private static String getCLangConstantsHolder() {
-        String prefix = "jdk.incubator.foreign.CSupport.";
-        String abi = CSupport.getSystemLinker().name();
-        switch (abi) {
-            case CSupport.SysV.NAME:
-                return prefix + "SysV";
-            case CSupport.Win64.NAME:
-                return prefix + "Win64";
-            case CSupport.AArch64.NAME:
-                return prefix + "AArch64";
-            default:
-                throw new UnsupportedOperationException("Unsupported ABI: " + abi);
-        }
-    }
-
-    static final String C_LANG_CONSTANTS_HOLDER = getCLangConstantsHolder();
-
-    public JavaFileObject[] generate(Declaration.Scoped decl) {
-        builder.classBegin();
-        //generate all decls
-        decl.members().forEach(this::generateDecl);
-        for (String src : structSources) {
-            builder.addContent(src);
-        }
-        // check if unresolved typedefs can be resolved now!
-        for (Declaration.Typedef td : unresolvedStructTypedefs) {
-            Declaration.Scoped structDef = ((Type.Declared)td.type()).tree();
-            if (structDefinitionSeen(structDef)) {
-                builder.emitTypedef(uniqueNestedClassName(td.name()), structClassName(structDef));
-            }
-        }
-        builder.classEnd();
-        try {
-            List<JavaFileObject> files = new ArrayList<>();
-            files.add(builder.build());
-            files.addAll(constantHelper.getClasses());
-            files.add(fileFromString(pkgName,"RuntimeHelper", getRuntimeHelperSource()));
-            return files.toArray(new JavaFileObject[0]);
-        } catch (IOException ex) {
-            throw new UncheckedIOException(ex);
-        } catch (URISyntaxException ex2) {
-            throw new RuntimeException(ex2);
-        }
-    }
-
-    private String getRuntimeHelperSource() throws URISyntaxException, IOException {
-        URL runtimeHelper = OutputFactory.class.getResource("resources/RuntimeHelper.java.template");
-        return (pkgName.isEmpty()? "" : "package " + pkgName + ";\n") +
-                        String.join("\n", Files.readAllLines(Paths.get(runtimeHelper.toURI())))
-                                .replace("${C_LANG}", C_LANG_CONSTANTS_HOLDER);
-    }
-
-    private void generateDecl(Declaration tree) {
-        try {
-            tree.accept(this, null);
-        } catch (Exception ex) {
-            ex.printStackTrace();
-        }
-    }
-
-    private static Class<?> classForType(Primitive.Kind type, MemoryLayout layout) {
-        boolean isFloat = switch(type) {
-            case Float, Double, LongDouble -> true;
-            default-> false;
-        };
-        return TypeTranslator.layoutToClass(isFloat, layout);
-    }
-
-    private JavaFileObject fileFromString(String pkgName, String clsName, String contents) {
-        String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
-        return new SimpleJavaFileObject(URI.create(pkgPrefix + clsName + ".java"), JavaFileObject.Kind.SOURCE) {
-            @Override
-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
-                return contents;
-            }
-        };
-    }
-
-    @Override
-    public Void visitConstant(Declaration.Constant constant, Declaration parent) {
-        if (!constants.add(constant.name())) {
-            //skip
-            return null;
-        }
-
-        builder.addConstantGetter(Utils.javaSafeIdentifier(constant.name()), typeTranslator.getJavaType(constant.type()), constant.value());
-        return null;
-    }
-
-    @Override
-    public Void visitScoped(Declaration.Scoped d, Declaration parent) {
-        if (d.layout().isEmpty()) {
-            //skip decl-only
-            return null;
-        }
-        boolean structClass = false;
-        StructBuilder oldStructBuilder = this.structBuilder;
-        if (!d.name().isEmpty() || !isRecord(parent)) {
-            //only add explicit struct layout if the struct is not to be flattened inside another struct
-            switch (d.kind()) {
-                case STRUCT:
-                case UNION: {
-                    structClass = true;
-                    String className = structClassName(d.name().isEmpty() ? parent : d);
-                    this.structBuilder = new StructBuilder(className, pkgName, constantHelper);
-                    structBuilder.incrAlign();
-                    structBuilder.classBegin();
-                    structBuilder.addLayoutGetter(className, d.layout().get());
-                    break;
-                }
-            }
-        }
-        d.members().forEach(fieldTree -> fieldTree.accept(this, d.name().isEmpty() ? parent : d));
-        if (structClass) {
-            this.structBuilder.classEnd();
-            structSources.add(structBuilder.getSource());
-            this.structBuilder = oldStructBuilder;
-        }
-        return null;
-    }
-
-    @Override
-    public Void visitFunction(Declaration.Function funcTree, Declaration parent) {
-        if (functionSeen(funcTree)) {
-            return null;
-        }
-
-        MethodType mtype = typeTranslator.getMethodType(funcTree.type());
-        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);
-        if (descriptor == null) {
-            //abort
-            return null;
-        }
-        String mhName = Utils.javaSafeIdentifier(funcTree.name());
-        builder.addMethodHandleGetter(mhName, funcTree.name(), mtype, descriptor, funcTree.type().varargs());
-        //generate static wrapper for function
-        List<String> paramNames = funcTree.parameters()
-                                          .stream()
-                                          .map(Declaration.Variable::name)
-                                          .map(p -> !p.isEmpty() ? Utils.javaSafeIdentifier(p) : p)
-                                          .collect(Collectors.toList());
-        builder.addStaticFunctionWrapper(Utils.javaSafeIdentifier(funcTree.name()), funcTree.name(), mtype,
-                Type.descriptorFor(funcTree.type()).orElseThrow(), funcTree.type().varargs(), paramNames);
-        int i = 0;
-        for (Declaration.Variable param : funcTree.parameters()) {
-            Type.Function f = getAsFunctionPointer(param.type());
-            if (f != null) {
-                String name = funcTree.name() + "$" + (param.name().isEmpty() ? "x" + i : param.name());
-                name = Utils.javaSafeIdentifier(name);
-                //generate functional interface
-                if (f.varargs()) {
-                    System.err.println("WARNING: varargs in callbacks is not supported");
-                }
-                MethodType fitype = typeTranslator.getMethodType(f, false);
-                builder.addFunctionalInterface(name, fitype, Type.descriptorFor(f).orElseThrow());
-                i++;
-            }
-        }
-        return null;
-    }
-
-    Type.Function getAsFunctionPointer(Type type) {
-        if (type instanceof Type.Delegated) {
-            switch (((Type.Delegated) type).kind()) {
-                case POINTER: {
-                    Type pointee = ((Type.Delegated) type).type();
-                    return (pointee instanceof Type.Function) ?
-                        (Type.Function)pointee : null;
-                }
-                default:
-                    return getAsFunctionPointer(((Type.Delegated) type).type());
-            }
-        } else {
-            return null;
-        }
-    }
-
-    @Override
-    public Void visitTypedef(Declaration.Typedef tree, Declaration parent) {
-        Type type = tree.type();
-        if (type instanceof Type.Declared) {
-            Declaration.Scoped s = ((Type.Declared) type).tree();
-            if (!s.name().equals(tree.name())) {
-                switch (s.kind()) {
-                    case STRUCT:
-                    case UNION: {
-                        if (s.name().isEmpty()) {
-                            visitScoped(s, tree);
-                        } else {
-                            /*
-                             * If typedef is seen after the struct/union definition, we can generate subclass
-                             * right away. If not, we've to save it and revisit after all the declarations are
-                             * seen. This is to support forward declaration of typedefs.
-                             *
-                             * typedef struct Foo Bar;
-                             *
-                             * struct Foo {
-                             *     int x, y;
-                             * };
-                             */
-                            if (structDefinitionSeen(s)) {
-                                builder.emitTypedef(uniqueNestedClassName(tree.name()), structClassName(s));
-                            } else {
-                                /*
-                                 * Definition of typedef'ed struct/union not seen yet. May be the definition comes later.
-                                 * Save it to visit at the end of all declarations.
-                                 */
-                                unresolvedStructTypedefs.add(tree);
-                            }
-                        }
-                    }
-                    break;
-                    default:
-                        visitScoped(s, tree);
-                }
-            }
-        } else if (type instanceof Type.Primitive) {
-             builder.emitPrimitiveTypedef((Type.Primitive)type, uniqueNestedClassName(tree.name()));
-        }
-        return null;
-    }
-
-    @Override
-    public Void visitVariable(Declaration.Variable tree, Declaration parent) {
-        if (parent == null && variableSeen(tree)) {
-            return null;
-        }
-
-        String fieldName = tree.name();
-        String symbol = tree.name();
-        assert !symbol.isEmpty();
-        assert !fieldName.isEmpty();
-        fieldName = Utils.javaSafeIdentifier(fieldName);
-
-        Type type = tree.type();
-        MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));
-        if (layout == null) {
-            //no layout - abort
-            return null;
-        }
-        Class<?> clazz = typeTranslator.getJavaType(type);
-        if (tree.kind() == Declaration.Variable.Kind.BITFIELD ||
-                (layout instanceof ValueLayout && layout.byteSize() > 8)) {
-            //skip
-            return null;
-        }
-
-        boolean isSegment = clazz == MemorySegment.class;
-        MemoryLayout treeLayout = tree.layout().orElseThrow();
-        if (parent != null) { //struct field
-            MemoryLayout parentLayout = parentLayout(parent);
-            if (isSegment) {
-                structBuilder.addAddressGetter(fieldName, tree.name(), treeLayout, parentLayout);
-            } else {
-                structBuilder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
-                structBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
-                structBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
-            }
-        } else {
-            if (isSegment) {
-                builder.addAddressGetter(fieldName, tree.name(), treeLayout, null);
-            } else {
-                builder.addLayoutGetter(fieldName, layout);
-                builder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz,null);
-                builder.addAddressGetter(fieldName, tree.name(), treeLayout, null);
-                builder.addGetter(fieldName, tree.name(), treeLayout, clazz, null);
-                builder.addSetter(fieldName, tree.name(), treeLayout, clazz, null);
-            }
-        }
-
-        return null;
-    }
-
-    private boolean isRecord(Declaration declaration) {
-        if (declaration == null) {
-            return false;
-        } else if (!(declaration instanceof Declaration.Scoped)) {
-            return false;
-        } else {
-            Declaration.Scoped scope = (Declaration.Scoped)declaration;
-            return scope.kind() == Declaration.Scoped.Kind.CLASS ||
-                    scope.kind() == Declaration.Scoped.Kind.STRUCT ||
-                    scope.kind() == Declaration.Scoped.Kind.UNION;
-        }
-    }
-
-    protected static MemoryLayout parentLayout(Declaration parent) {
-        if (parent instanceof Declaration.Typedef) {
-            Declaration.Typedef alias = (Declaration.Typedef) parent;
-            return Type.layoutFor(alias.type()).orElseThrow();
-        } else if (parent instanceof Declaration.Scoped) {
-            return ((Declaration.Scoped) parent).layout().orElseThrow();
-        } else {
-            throw new IllegalArgumentException("Unexpected parent declaration");
-        }
-        // case like `typedef struct { ... } Foo`
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StructBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StructBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StructBuilder.java
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.jextract.tool;
-
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryLayout;
-
-import java.lang.constant.DirectMethodHandleDesc;
-
-/**
- * This class generates static utilities class for C structs, unions.
- */
-class StructBuilder extends JavaSourceBuilder {
-    StructBuilder(String className, String pkgName, ConstantHelper constantHelper) {
-        super(className, pkgName, constantHelper);
-    }
-
-    @Override
-    protected String getClassModifiers() {
-        return PUB_MODS;
-    }
-
-    @Override
-    protected void addPackagePrefix() {
-        // nested class. containing class has necessary package declaration
-    }
-
-    @Override
-    protected void addImportSection() {
-        // nested class. containing class has necessary imports
-    }
-
-    @Override
-    public void classEnd() {
-        emitSizeof();
-        emitAllocate();
-        emitScopeAllocate();
-        emitAllocateArray();
-        emitScopeAllocateArray();
-        super.classEnd();
-    }
-
-    @Override
-    public void addLayoutGetter(String javaName, MemoryLayout layout) {
-        var desc = constantHelper.addLayout(javaName + "$struct", layout);
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + displayName(desc.invocationType().returnType()) + " $LAYOUT() {\n");
-        incrAlign();
-        indent();
-        sb.append("return " + getCallString(desc) + ";\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    @Override
-    public void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(MemoryAddress addr) {\n");
-        incrAlign();
-        indent();
-        sb.append("return (" + type.getName() + ")"
-                + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(addr);\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-
-        addIndexGetter(javaName, nativeName, layout, type, parentLayout);
-    }
-
-    @Override
-    public void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        incrAlign();
-        indent();
-        String param = MemoryAddress.class.getName() + " addr";
-        sb.append(PUB_MODS + "void " + javaName + "$set(" + param + ", " + type.getName() + " x) {\n");
-        incrAlign();
-        indent();
-        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, null) + ".set(addr, x);\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-
-        addIndexSetter(javaName, nativeName, layout, type, parentLayout);
-    }
-
-    @Override
-    public void addAddressGetter(String javaName, String nativeName, MemoryLayout layout, MemoryLayout parentLayout) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + "MemoryAddress " + javaName + "$addr(MemoryAddress addr) {\n");
-        incrAlign();
-        indent();
-        sb.append("return addr.segment().asSlice(");
-        sb.append(parentLayout.byteOffset(MemoryLayout.PathElement.groupElement(nativeName)));
-        sb.append(", ");
-        sb.append(layout.byteSize());
-        sb.append(").baseAddress();\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    private void emitSizeof() {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS);
-        sb.append("long sizeof() { return $LAYOUT().byteSize(); }\n");
-        decrAlign();
-    }
-
-    private void emitAllocate() {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS);
-        sb.append("MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n");
-        decrAlign();
-    }
-
-    private void emitScopeAllocate() {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS);
-        sb.append("MemoryAddress allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n");
-        decrAlign();
-    }
-
-    private void emitAllocateArray() {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS);
-        sb.append("MemorySegment allocateArray(int len) {\n");
-        incrAlign();
-        indent();
-        sb.append("return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));");
-        decrAlign();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    private void emitScopeAllocateArray() {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS);
-        sb.append("MemoryAddress allocateArray(int len, NativeScope scope) {\n");
-        incrAlign();
-        indent();
-        sb.append("return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));");
-        decrAlign();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    private void addIndexGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        incrAlign();
-        indent();
-        String params = MemoryAddress.class.getName() + " addr, long index";
-        sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(" + params + ") {\n");
-        incrAlign();
-        indent();
-        sb.append("return (" + type.getName() + ")"
-                + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(addr.addOffset(index*sizeof()));\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    private void addIndexSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        incrAlign();
-        indent();
-        String params = MemoryAddress.class.getName() + " addr, long index, " + type.getName() + " x";
-        sb.append(PUB_MODS + "void " + javaName + "$set(" + params + ") {\n");
-        incrAlign();
-        indent();
-        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".set(addr.addOffset(index*sizeof()), x);\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Utils.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Utils.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Utils.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.incubator.jextract.tool;
-
-import javax.lang.model.SourceVersion;
-import javax.tools.JavaFileObject;
-import javax.tools.SimpleJavaFileObject;
-import java.io.IOException;
-import java.net.URI;
-
-final class Utils {
-
-    private Utils() {}
-
-    private static URI fileName(String pkgName, String clsName, String extension) {
-        String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
-        return URI.create(pkgPrefix + clsName + extension);
-    }
-
-    static JavaFileObject fileFromString(String pkgName, String clsName, String contents) {
-        return new SimpleJavaFileObject(fileName(pkgName, clsName, ".java"), JavaFileObject.Kind.SOURCE) {
-            @Override
-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
-                return contents;
-            }
-        };
-    }
-
-    static String javaSafeIdentifier(String name) {
-        return javaSafeIdentifier(name, false);
-    }
-
-    static String javaSafeIdentifier(String name, boolean checkAllChars) {
-        if (checkAllChars) {
-            StringBuilder buf = new StringBuilder();
-            char[] chars = name.toCharArray();
-            if (Character.isJavaIdentifierStart(chars[0])) {
-                buf.append(chars[0]);
-            } else {
-                buf.append('_');
-            }
-            if (chars.length > 1) {
-                for (int i = 1; i < chars.length; i++) {
-                    char ch = chars[i];
-                    if (Character.isJavaIdentifierPart(ch)) {
-                        buf.append(ch);
-                    } else {
-                        buf.append('_');
-                    }
-                }
-            }
-            return buf.toString();
-        } else {
-            // We never get the problem of Java non-identifiers (like 123, ab-xy) as
-            // C identifiers. But we may have a java keyword used as a C identifier.
-            assert SourceVersion.isIdentifier(name);
-
-            return SourceVersion.isKeyword(name) ? (name + "_") : name;
-        }
-    }
-}

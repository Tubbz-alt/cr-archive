<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TranslationUnit.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="LibClang.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TranslationUnit.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 47 
 48     public Cursor getCursor() {
 49         return new Cursor(Index_h.clang_getTranslationUnitCursor(tu));
 50     }
 51 
 52     public Diagnostic[] getDiagnostics() {
 53         int cntDiags = Index_h.clang_getNumDiagnostics(tu);
 54         Diagnostic[] rv = new Diagnostic[cntDiags];
 55         for (int i = 0; i &lt; cntDiags; i++) {
 56             MemoryAddress diag = Index_h.clang_getDiagnostic(tu, i);
 57             rv[i] = new Diagnostic(diag);
 58         }
 59 
 60         return rv;
 61     }
 62 
 63     public final void save(Path path) throws TranslationUnitSaveException {
 64         try (MemorySegment pathStr = Utils.toNativeString(path.toAbsolutePath().toString())) {
 65             SaveError res = SaveError.valueOf(Index_h.clang_saveTranslationUnit(tu, pathStr.baseAddress(), 0));
 66             if (res != SaveError.None) {
<span class="line-modified"> 67                 throw new TranslationUnitSaveException(path);</span>
 68             }
 69         }
 70     }
 71 
 72     void processDiagnostics(Consumer&lt;Diagnostic&gt; dh) {
 73         Objects.requireNonNull(dh);
 74         for (Diagnostic diag : getDiagnostics()) {
 75             dh.accept(diag);
 76         }
 77     }
 78 
 79     static long FILENAME_OFFSET = Index_h.CXUnsavedFile$LAYOUT.offset(MemoryLayout.PathElement.groupElement(&quot;Filename&quot;)) / 8;
 80     static long CONTENTS_OFFSET = Index_h.CXUnsavedFile$LAYOUT.offset(MemoryLayout.PathElement.groupElement(&quot;Contents&quot;)) / 8;
 81     static long LENGTH_OFFSET = Index_h.CXUnsavedFile$LAYOUT.offset(MemoryLayout.PathElement.groupElement(&quot;Length&quot;)) / 8;
 82 
 83     public void reparse(Index.UnsavedFile... inMemoryFiles) {
 84         try (AllocationScope scope = new AllocationScope()) {
 85             MemorySegment files = inMemoryFiles.length == 0 ?
 86                     null :
 87                     scope.track(MemorySegment.allocateNative(MemoryLayout.ofSequence(inMemoryFiles.length, Index_h.CXUnsavedFile$LAYOUT)));
</pre>
<hr />
<pre>
193             MemorySegment s = Index_h.clang_getTokenSpelling(
194                     tu, token);
195             return LibClang.CXStrToString(s);
196         }
197 
198         public SourceLocation getLocation() {
199             return new SourceLocation(Index_h.clang_getTokenLocation(
200                     tu, token));
201         }
202 
203         public SourceRange getExtent() {
204             return new SourceRange(Index_h.clang_getTokenExtent(
205                     tu, token));
206         }
207     }
208 
209     public static class TranslationUnitSaveException extends IOException {
210 
211         static final long serialVersionUID = 1L;
212 
<span class="line-modified">213         TranslationUnitSaveException(Path path) {</span>
<span class="line-modified">214             super(&quot;Cannot save translation unit to: &quot; + path.toAbsolutePath());</span>



215         }
216     }
217 }
</pre>
</td>
<td>
<hr />
<pre>
 47 
 48     public Cursor getCursor() {
 49         return new Cursor(Index_h.clang_getTranslationUnitCursor(tu));
 50     }
 51 
 52     public Diagnostic[] getDiagnostics() {
 53         int cntDiags = Index_h.clang_getNumDiagnostics(tu);
 54         Diagnostic[] rv = new Diagnostic[cntDiags];
 55         for (int i = 0; i &lt; cntDiags; i++) {
 56             MemoryAddress diag = Index_h.clang_getDiagnostic(tu, i);
 57             rv[i] = new Diagnostic(diag);
 58         }
 59 
 60         return rv;
 61     }
 62 
 63     public final void save(Path path) throws TranslationUnitSaveException {
 64         try (MemorySegment pathStr = Utils.toNativeString(path.toAbsolutePath().toString())) {
 65             SaveError res = SaveError.valueOf(Index_h.clang_saveTranslationUnit(tu, pathStr.baseAddress(), 0));
 66             if (res != SaveError.None) {
<span class="line-modified"> 67                 throw new TranslationUnitSaveException(path, res);</span>
 68             }
 69         }
 70     }
 71 
 72     void processDiagnostics(Consumer&lt;Diagnostic&gt; dh) {
 73         Objects.requireNonNull(dh);
 74         for (Diagnostic diag : getDiagnostics()) {
 75             dh.accept(diag);
 76         }
 77     }
 78 
 79     static long FILENAME_OFFSET = Index_h.CXUnsavedFile$LAYOUT.offset(MemoryLayout.PathElement.groupElement(&quot;Filename&quot;)) / 8;
 80     static long CONTENTS_OFFSET = Index_h.CXUnsavedFile$LAYOUT.offset(MemoryLayout.PathElement.groupElement(&quot;Contents&quot;)) / 8;
 81     static long LENGTH_OFFSET = Index_h.CXUnsavedFile$LAYOUT.offset(MemoryLayout.PathElement.groupElement(&quot;Length&quot;)) / 8;
 82 
 83     public void reparse(Index.UnsavedFile... inMemoryFiles) {
 84         try (AllocationScope scope = new AllocationScope()) {
 85             MemorySegment files = inMemoryFiles.length == 0 ?
 86                     null :
 87                     scope.track(MemorySegment.allocateNative(MemoryLayout.ofSequence(inMemoryFiles.length, Index_h.CXUnsavedFile$LAYOUT)));
</pre>
<hr />
<pre>
193             MemorySegment s = Index_h.clang_getTokenSpelling(
194                     tu, token);
195             return LibClang.CXStrToString(s);
196         }
197 
198         public SourceLocation getLocation() {
199             return new SourceLocation(Index_h.clang_getTokenLocation(
200                     tu, token));
201         }
202 
203         public SourceRange getExtent() {
204             return new SourceRange(Index_h.clang_getTokenExtent(
205                     tu, token));
206         }
207     }
208 
209     public static class TranslationUnitSaveException extends IOException {
210 
211         static final long serialVersionUID = 1L;
212 
<span class="line-modified">213         private final SaveError error;</span>
<span class="line-modified">214 </span>
<span class="line-added">215         TranslationUnitSaveException(Path path, SaveError error) {</span>
<span class="line-added">216             super(&quot;Cannot save translation unit to: &quot; + path.toAbsolutePath() + &quot;. Error: &quot; + error);</span>
<span class="line-added">217             this.error = error;</span>
218         }
219     }
220 }
</pre>
</td>
</tr>
</table>
<center><a href="LibClang.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
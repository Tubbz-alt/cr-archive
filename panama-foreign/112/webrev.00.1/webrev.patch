diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
@@ -51,19 +51,27 @@
         return INSTANCE;
     }
 
     @Override
     public MemoryAddress withSize(MemoryAddress base, long byteSize) throws IllegalAccessError {
+        checkRawNativeAddress(base);
         return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(base.toRawLongValue(), byteSize, null, false)
                 .baseAddress();
     }
 
     @Override
     public MemorySegment asMallocSegment(MemoryAddress base, long byteSize) throws IllegalAccessError {
+        checkRawNativeAddress(base);
         return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(base.toRawLongValue(), byteSize, Thread.currentThread(), true);
     }
 
+    private void checkRawNativeAddress(MemoryAddress base) {
+        if (base.segment() != AbstractMemorySegmentImpl.NOTHING) {
+            throw new IllegalArgumentException("Not an unchecked memory address");
+        }
+    }
+
     @Override
     public MemorySegment asUnconfined(MemorySegment segment) {
         return ((NativeMemorySegmentImpl)segment).asUnconfined();
     }
 
diff a/test/jdk/java/foreign/TestByteBuffer.java b/test/jdk/java/foreign/TestByteBuffer.java
--- a/test/jdk/java/foreign/TestByteBuffer.java
+++ b/test/jdk/java/foreign/TestByteBuffer.java
@@ -443,22 +443,33 @@
     }
 
     @Test(dataProvider="bufferSources")
     public void testBufferToSegment(ByteBuffer bb, Predicate<MemorySegment> segmentChecker) {
         MemorySegment segment = MemorySegment.ofByteBuffer(bb);
+        assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
         assertTrue(segmentChecker.test(segment));
         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
         assertEquals(bb.capacity(), segment.byteSize());
         //another round trip
         segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());
+        assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
         assertTrue(segmentChecker.test(segment));
         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
         assertEquals(bb.capacity(), segment.byteSize());
     }
 
+    @Test
+    public void testRoundTripAccess() {
+        try(MemorySegment ms = MemorySegment.allocateNative(4)) {
+            MemorySegment msNoAccess = ms.withAccessModes(MemorySegment.READ); // READ is required to make BB
+            MemorySegment msRoundTrip = MemorySegment.ofByteBuffer(msNoAccess.asByteBuffer());
+            assertEquals(msNoAccess.accessModes(), msRoundTrip.accessModes());
+        }
+    }
+
     @DataProvider(name = "bufferOps")
     public static Object[][] bufferOps() throws Throwable {
         return new Object[][]{
                 { (Function<ByteBuffer, Buffer>) bb -> bb, bufferMembers(ByteBuffer.class)},
                 { (Function<ByteBuffer, Buffer>) ByteBuffer::asCharBuffer, bufferMembers(CharBuffer.class)},
@@ -604,16 +615,22 @@
     @DataProvider(name = "bufferSources")
     public static Object[][] bufferSources() {
         Predicate<MemorySegment> heapTest = segment -> segment instanceof HeapMemorySegmentImpl;
         Predicate<MemorySegment> nativeTest = segment -> segment instanceof NativeMemorySegmentImpl;
         Predicate<MemorySegment> mappedTest = segment -> segment instanceof MappedMemorySegmentImpl;
-        try (FileChannel channel = FileChannel.open(tempPath)) {
+        try (FileChannel channel = FileChannel.open(tempPath, StandardOpenOption.READ, StandardOpenOption.WRITE)) {
             return new Object[][]{
                     { ByteBuffer.wrap(new byte[256]), heapTest },
                     { ByteBuffer.allocate(256), heapTest },
                     { ByteBuffer.allocateDirect(256), nativeTest },
-                    { channel.map(FileChannel.MapMode.READ_ONLY, 0L, 256), mappedTest }
+                    { channel.map(FileChannel.MapMode.READ_WRITE, 0L, 256), mappedTest },
+
+                    { ByteBuffer.wrap(new byte[256]).asReadOnlyBuffer(), heapTest },
+                    { ByteBuffer.allocate(256).asReadOnlyBuffer(), heapTest },
+                    { ByteBuffer.allocateDirect(256).asReadOnlyBuffer(), nativeTest },
+                    { channel.map(FileChannel.MapMode.READ_WRITE, 0L, 256).asReadOnlyBuffer(),
+                            nativeTest /* this seems to be an existing bug in the BB implementation */ }
             };
         } catch (IOException ex) {
             throw new ExceptionInInitializerError(ex);
         }
     }
diff a/test/jdk/java/foreign/TestSharedAccess.java b/test/jdk/java/foreign/TestSharedAccess.java
--- a/test/jdk/java/foreign/TestSharedAccess.java
+++ b/test/jdk/java/foreign/TestSharedAccess.java
@@ -34,13 +34,17 @@
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.SequenceLayout;
 import org.testng.annotations.*;
 
 import java.lang.invoke.VarHandle;
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Spliterator;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import static org.testng.Assert.*;
 
 public class TestSharedAccess {
@@ -130,10 +134,45 @@
             new Thread(r).start();
             Thread.sleep(5000);
         } //should fail here!
     }
 
+    @Test
+    public void testOutsideConfinementThread() throws Throwable {
+        CountDownLatch a = new CountDownLatch(1);
+        CountDownLatch b = new CountDownLatch(1);
+        CompletableFuture<?> r;
+        try (MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.ofSequence(2, MemoryLayouts.JAVA_INT))) {
+            r = CompletableFuture.runAsync(() -> {
+                try {
+                    ByteBuffer bb = s1.asByteBuffer();
+
+                    MemorySegment s2 = MemorySegment.ofByteBuffer(bb);
+                    a.countDown();
+
+                    try {
+                        b.await();
+                    } catch (InterruptedException e) {
+                    }
+
+                    MemoryAddress base = s2.baseAddress();
+                    setInt(base.addOffset(4), -42);
+                    fail();
+                } catch (IllegalStateException ex) {
+                    assertTrue(ex.getMessage().contains("owning thread"));
+                }
+            });
+
+            a.await();
+            MemoryAddress base = s1.baseAddress();
+            setInt(base.addOffset(4), 42);
+        }
+
+        b.countDown();
+        r.get();
+    }
+
     static int getInt(MemoryAddress address) {
         return (int)intHandle.getVolatile(address);
     }
 
     static void setInt(MemoryAddress address, int value) {

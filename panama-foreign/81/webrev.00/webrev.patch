diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Foreign.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Foreign.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Foreign.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Foreign.java
@@ -76,30 +76,46 @@
      * @throws IllegalStateException if the given address is not an off-heap address
      */
     long asLong(MemoryAddress address) throws IllegalAccessError;
 
     /**
-     * Returns a new native memory segment with given base address and size. The returned segment has its own temporal
-     * bounds, and can therefore be closed; closing such a segment does <em>not</em> result in any resource being
-     * deallocated.
+     * Returns a new memory address attached to a native memory segment with given base address and size. The segment
+     * attached to the returned address has <em>no temporal bounds</em> and cannot be closed; as such,
+     * the returned address is assumed to always be <em>alive</em>. Also, the segment attached to the returned address
+     * has <em>no confinement thread</em>; this means that the returned address can be used by multiple threads.
      * <p>
      * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
      * restricted methods, and use safe and supported functionalities, where possible.
+     *
+     * @param base the desired base address
+     * @param byteSize the desired size (in bytes).
+     * @return a new memory address attached to a native memory segment with given base address and size.
+     * @throws IllegalArgumentException if {@code base} does not encapsulate a native memory address,
+     * or if the segment associated with {@code base} is not the <em>primordial</em> segment.
+     * @throws IllegalAccessError if the permission jkd.incubator.foreign.restrictedMethods is set to 'deny'
+     */
+    MemoryAddress withSize(MemoryAddress base, long byteSize);
+
+    /**
+     * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
+     * bounds, and can therefore be closed; closing such a segment results in releasing the native memory by calling
+     * <em>free</em> on the base address of the returned memory segment. As for other ordinary memory segments,
+     * the returned segment will also be confined on the current thread (see {@link Thread#currentThread()}).
      * <p>
-     * This method allows for making an otherwise in-accessible memory region accessible. However, there
-     * is no guarantee that this memory is safe to access, or that the given size for the new segment is not too large,
-     * potentially resulting in out-of-bounds accesses. The developer is trusted to make the judgement that the use of the
-     * returned memory segment is safe.
+     * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
+     * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
+     * restricted methods, and use safe and supported functionalities, where possible.
      *
      * @param base the desired base address
      * @param byteSize the desired size.
      * @return a new native memory segment with given base address and size.
-     * @throws IllegalArgumentException if {@code base} does not encapsulate a native memory address.
+     * @throws IllegalArgumentException if {@code base} does not encapsulate a native memory address,
+     * or if the segment associated with {@code base} is not the <em>primordial</em> segment.
      * @throws IllegalAccessError if the permission jkd.incubator.foreign.restrictedMethods is set to 'deny'
      */
-    MemorySegment ofNativeUnchecked(MemoryAddress base, long byteSize) throws IllegalAccessError;
+    MemorySegment asMallocSegment(MemoryAddress base, long byteSize);
 
     /**
      * Returns a non-confined memory segment that has the same spatial and temporal bounds as the provided segment.
      * Since the returned segment can be effectively accessed by multiple threads in an unconstrained fashion,
      * this method should be used with care, as it might lead to JVM crashes - e.g. in the case where a thread {@code A}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
@@ -61,12 +61,19 @@
     public long asLong(MemoryAddress address) throws IllegalAccessError {
         return MemoryAddressImpl.addressof(address);
     }
 
     @Override
-    public MemorySegment ofNativeUnchecked(MemoryAddress base, long byteSize) throws IllegalAccessError {
-        return Utils.makeNativeSegmentUnchecked(base, byteSize);
+    public MemoryAddress withSize(MemoryAddress base, long byteSize) throws IllegalAccessError {
+        return Utils.makeNativeSegmentUnchecked(asLong(base), byteSize, null, false)
+                .baseAddress();
+    }
+
+    @Override
+    public MemorySegment asMallocSegment(MemoryAddress base, long byteSize) throws IllegalAccessError {
+        long addr = asLong(base);
+        return Utils.makeNativeSegmentUnchecked(addr, byteSize, Thread.currentThread(), true);
     }
 
     @Override
     public MemorySegment asUnconfined(MemorySegment segment) {
         return ((MemorySegmentImpl)segment).asUnconfined();
@@ -139,18 +146,16 @@
     }
 
     @Override
     public String toJavaString(MemoryAddress addr) {
         StringBuilder buf = new StringBuilder();
-        try (MemorySegment seg = ofNativeUnchecked(addr, Long.MAX_VALUE)) {
-            MemoryAddress baseAddr = seg.baseAddress();
-            byte curr = (byte) Lazy.byteArrHandle.get(baseAddr, 0);
-            long offset = 0;
-            while (curr != 0) {
-                buf.append((char) curr);
-                curr = (byte) Lazy.byteArrHandle.get(baseAddr, ++offset);
-            }
+        MemoryAddress baseAddr = withSize(addr, Long.MAX_VALUE);
+        byte curr = (byte) Lazy.byteArrHandle.get(baseAddr, 0);
+        long offset = 0;
+        while (curr != 0) {
+            buf.append((char) curr);
+            curr = (byte) Lazy.byteArrHandle.get(baseAddr, ++offset);
         }
         return buf.toString();
     }
 
     // need to lazily initialize this to prevent circular init
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
@@ -23,10 +23,11 @@
  *  questions.
  *
  */
 package jdk.internal.foreign;
 
+import jdk.incubator.foreign.Foreign;
 import jdk.internal.access.foreign.MemoryAddressProxy;
 import jdk.internal.misc.Unsafe;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
@@ -38,10 +39,11 @@
  * about the segment this address is associated with, as well as an offset into such segment.
  */
 public final class MemoryAddressImpl implements MemoryAddress, MemoryAddressProxy {
 
     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+    private static final InternalForeign foreign = InternalForeign.getInstancePrivileged();
 
     private final MemorySegmentImpl segment;
     private final long offset;
 
     public MemoryAddressImpl(MemorySegmentImpl segment) {
@@ -146,8 +148,8 @@
     public static MemoryAddress ofLongUnchecked(long value) {
         return ofLongUnchecked(value, Long.MAX_VALUE);
     }
 
     public static MemoryAddress ofLongUnchecked(long value, long byteSize) {
-        return new MemoryAddressImpl((MemorySegmentImpl)Utils.makeNativeSegmentUnchecked(value, byteSize), 0);
+        return foreign.withSize(MemoryAddress.ofLong(value), byteSize);
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
@@ -84,11 +84,11 @@
     public MemorySegmentImpl(long min, Object base, long length, Thread owner, MemoryScope scope) {
         this(min, base, length, DEFAULT_MASK, owner, scope);
     }
 
     @ForceInline
-    private MemorySegmentImpl(long min, Object base, long length, int mask, Thread owner, MemoryScope scope) {
+    MemorySegmentImpl(long min, Object base, long length, int mask, Thread owner, MemoryScope scope) {
         this.length = length;
         this.mask = length > Integer.MAX_VALUE ? mask : (mask | SMALL);
         this.min = min;
         this.base = base;
         this.owner = owner;
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -115,14 +115,10 @@
 
     public static boolean isPadding(MemoryLayout layout) {
         return layout.getClass() == PADDING_CLASS;
     }
 
-    public static MemoryAddress resizeNativeAddress(MemoryAddress base, long byteSize) {
-        return new MemoryAddressImpl((MemorySegmentImpl)Utils.makeNativeSegmentUnchecked(base, byteSize), 0);
-    }
-
     public static void checkCarrier(Class<?> carrier) {
         if (carrier == void.class || carrier == boolean.class ||
                 (!carrier.isPrimitive() && !isAddress(carrier))) {
             throw new IllegalArgumentException("Illegal carrier: " + carrier.getSimpleName());
         }
@@ -167,20 +163,17 @@
             segment = segment.asSlice(delta, bytesSize);
         }
         return segment;
     }
 
-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress base, long bytesSize) {
-        if (((MemorySegmentImpl)base.segment()).base != null) {
-            throw new IllegalArgumentException("Not a native address: " + base);
+    public static MemorySegment makeNativeSegmentUnchecked(long min, long bytesSize, Thread owner, boolean allowClose) {
+        MemoryScope scope = new MemoryScope(null, allowClose ? () -> unsafe.freeMemory(min) : null);
+        int mask = MemorySegmentImpl.DEFAULT_MASK;
+        if (!allowClose) {
+            mask &= ~MemorySegment.CLOSE;
         }
-        return makeNativeSegmentUnchecked(((MemoryAddressImpl)base).unsafeGetOffset(), bytesSize);
-    }
-
-    public static MemorySegment makeNativeSegmentUnchecked(long min, long bytesSize) {
-        MemoryScope scope = new MemoryScope(null, null);
-        return new MemorySegmentImpl(min, null, bytesSize, Thread.currentThread(), scope);
+        return new MemorySegmentImpl(min, null, bytesSize, mask, owner, scope);
     }
 
     public static MemorySegment makeArraySegment(byte[] arr) {
         return makeArraySegment(arr, arr.length, Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE);
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BindingInterpreter.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BindingInterpreter.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BindingInterpreter.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BindingInterpreter.java
@@ -23,10 +23,11 @@
 package jdk.internal.foreign.abi;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.foreign.InternalForeign;
 import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.Utils;
 
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
@@ -42,10 +43,12 @@
     private static final VarHandle VH_INT = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
     private static final VarHandle VH_LONG = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
     private static final VarHandle VH_FLOAT = MemoryHandles.varHandle(float.class, ByteOrder.nativeOrder());
     private static final VarHandle VH_DOUBLE = MemoryHandles.varHandle(double.class, ByteOrder.nativeOrder());
 
+    private static InternalForeign foreign = InternalForeign.getInstancePrivileged();
+
     static void unbox(Object arg, List<Binding> bindings, Function<VMStorage,
             MemoryAddress> ptrFunction, List<? super MemorySegment> buffers) {
         Deque<Object> stack = new ArrayDeque<>();
         stack.push(arg);
         for (Binding b : bindings) {
@@ -102,11 +105,11 @@
                     write(writeAddress, binding.type(), value);
                 }
                 case COPY_BUFFER -> {
                     Binding.Copy binding = (Binding.Copy) b;
                     MemoryAddress operand = (MemoryAddress) stack.pop();
-                    operand = Utils.resizeNativeAddress(operand, binding.size());
+                    operand = foreign.withSize(operand, binding.size());
                     MemorySegment copy = MemorySegment.allocateNative(binding.size(), binding.alignment());
                     MemoryAddress.copy(operand, copy.baseAddress(), binding.size());
                     stack.push(copy); // leaked
                 }
                 case ALLOC_BUFFER -> {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableUpcallHandler.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableUpcallHandler.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableUpcallHandler.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableUpcallHandler.java
@@ -23,10 +23,11 @@
 
 package jdk.internal.foreign.abi;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
+import jdk.internal.foreign.InternalForeign;
 import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.Utils;
 import jdk.internal.vm.annotation.Stable;
 
 import java.lang.invoke.MethodHandle;
@@ -49,10 +50,12 @@
     private static final boolean DEBUG =
         privilegedGetProperty("jdk.internal.foreign.ProgrammableUpcallHandler.DEBUG");
 
     private static final VarHandle VH_LONG = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
 
+    private static InternalForeign foreign = InternalForeign.getInstancePrivileged();
+
     @Stable
     private final MethodHandle mh;
     private final MethodType type;
     private final CallingSequence callingSequence;
     private final long entryPoint;
@@ -83,11 +86,11 @@
             if (DEBUG) {
                 System.err.println("Buffer state before:");
                 layout.dump(abi.arch, buffer, System.err);
             }
 
-            MemoryAddress bufferBase = Utils.resizeNativeAddress(buffer, layout.size);
+            MemoryAddress bufferBase = foreign.withSize(buffer, layout.size);
             MemoryAddress stackArgsBase = MemoryAddressImpl.ofLongUnchecked((long)VH_LONG.get(buffer.rebase(bufferBase.segment()).addOffset(layout.stack_args)));
             Object[] args = new Object[type.parameterCount()];
             for (int i = 0 ; i < type.parameterCount() ; i++) {
                 args[i] = jdk.internal.foreign.abi.BindingInterpreter.box(callingSequence.argumentBindings(i),
                         s -> abi.arch.isStackType(s.type())
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
@@ -25,10 +25,11 @@
 package jdk.internal.foreign.abi;
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.foreign.InternalForeign;
 import jdk.internal.foreign.Utils;
 
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.SequenceLayout;
@@ -49,10 +50,12 @@
 
     private static final MethodHandle MH_ALLOC_BUFFER;
     private static final MethodHandle MH_BASEADDRESS;
     private static final MethodHandle MH_BUFFER_COPY;
 
+    private static InternalForeign foreign = InternalForeign.getInstancePrivileged();
+
     static {
         try {
             var lookup = MethodHandles.lookup();
             MH_ALLOC_BUFFER = lookup.findStatic(MemorySegment.class, "allocateNative",
                     methodType(MemorySegment.class, MemoryLayout.class));
@@ -168,11 +171,11 @@
 
         return target;
     }
 
     private static MemoryAddress bufferCopy(MemoryAddress dest, MemorySegment buffer) {
-        MemoryAddress.copy(buffer.baseAddress(), Utils.resizeNativeAddress(dest, buffer.byteSize()), buffer.byteSize());
+        MemoryAddress.copy(buffer.baseAddress(), foreign.withSize(dest, buffer.byteSize()), buffer.byteSize());
         return dest;
     }
 
     public static void checkFunctionTypes(MethodType mt, FunctionDescriptor cDesc) {
         if (mt.parameterCount() != cDesc.argumentLayouts().size())
diff a/test/jdk/java/foreign/StdLibTest.java b/test/jdk/java/foreign/StdLibTest.java
--- a/test/jdk/java/foreign/StdLibTest.java
+++ b/test/jdk/java/foreign/StdLibTest.java
@@ -106,25 +106,24 @@
         assertEquals(stdLibHelper.strlen(s), s.length());
     }
 
     @Test(dataProvider = "instants")
     void test_time(Instant instant) throws Throwable {
-        try (StdLibHelper.Tm tm = stdLibHelper.gmtime(instant.getEpochSecond())) {
-            LocalDateTime localTime = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);
-            assertEquals(tm.sec(), localTime.getSecond());
-            assertEquals(tm.min(), localTime.getMinute());
-            assertEquals(tm.hour(), localTime.getHour());
-            //day pf year in Java has 1-offset
-            assertEquals(tm.yday(), localTime.getDayOfYear() - 1);
-            assertEquals(tm.mday(), localTime.getDayOfMonth());
-            //days of week starts from Sunday in C, but on Monday in Java, also account for 1-offset
-            assertEquals((tm.wday() + 6) % 7, localTime.getDayOfWeek().getValue() - 1);
-            //month in Java has 1-offset
-            assertEquals(tm.mon(), localTime.getMonth().getValue() - 1);
-            assertEquals(tm.isdst(), ZoneOffset.UTC.getRules()
-                    .isDaylightSavings(Instant.ofEpochMilli(instant.getEpochSecond() * 1000)));
-        }
+        StdLibHelper.Tm tm = stdLibHelper.gmtime(instant.getEpochSecond());
+        LocalDateTime localTime = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);
+        assertEquals(tm.sec(), localTime.getSecond());
+        assertEquals(tm.min(), localTime.getMinute());
+        assertEquals(tm.hour(), localTime.getHour());
+        //day pf year in Java has 1-offset
+        assertEquals(tm.yday(), localTime.getDayOfYear() - 1);
+        assertEquals(tm.mday(), localTime.getDayOfMonth());
+        //days of week starts from Sunday in C, but on Monday in Java, also account for 1-offset
+        assertEquals((tm.wday() + 6) % 7, localTime.getDayOfWeek().getValue() - 1);
+        //month in Java has 1-offset
+        assertEquals(tm.mon(), localTime.getMonth().getValue() - 1);
+        assertEquals(tm.isdst(), ZoneOffset.UTC.getRules()
+                .isDaylightSavings(Instant.ofEpochMilli(instant.getEpochSecond() * 1000)));
     }
 
     @Test(dataProvider = "ints")
     void test_qsort(List<Integer> ints) throws Throwable {
         if (ints.size() > 0) {
@@ -259,19 +258,19 @@
                 longHandle.set(time.baseAddress(), arg);
                 return new Tm((MemoryAddress)gmtime.invokeExact(time.baseAddress()));
             }
         }
 
-        static class Tm implements AutoCloseable {
+        static class Tm {
 
             //Tm pointer should never be freed directly, as it points to shared memory
             private MemoryAddress base;
 
             static final long SIZE = 56;
 
             Tm(MemoryAddress base) {
-                this.base = base.rebase(FOREIGN.ofNativeUnchecked(base, SIZE));
+                this.base = FOREIGN.withSize(base, SIZE);
             }
 
             int sec() {
                 return (int)intHandle.get(base);
             }
@@ -298,15 +297,10 @@
             }
             boolean isdst() {
                 byte b = (byte)byteHandle.get(base.addOffset(32));
                 return b == 0 ? false : true;
             }
-
-            @Override
-            public void close() throws Exception {
-                base.segment().close();
-            }
         }
 
         int[] qsort(int[] arr) throws Throwable {
             //init native array
             SequenceLayout seq = MemoryLayout.ofSequence(arr.length, C_INT);

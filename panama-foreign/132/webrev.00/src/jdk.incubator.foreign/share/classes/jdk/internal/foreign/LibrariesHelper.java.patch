diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java
@@ -26,57 +26,55 @@
 package jdk.internal.foreign;
 
 import jdk.incubator.foreign.MemoryAddress;
 
 import java.io.File;
-import java.lang.invoke.MethodHandles.Lookup;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.internal.loader.NativeLibraries;
 import jdk.internal.loader.NativeLibrary;
+import jdk.internal.ref.CleanerFactory;
 
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.Arrays;
+import java.util.IdentityHashMap;
+import java.util.Map;
 import java.util.Optional;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Supplier;
 
 public final class LibrariesHelper {
     private LibrariesHelper() {}
 
-    // FIXME - revisit this (refcount for unload)
-    private final static ClassValue<NativeLibraries> nativeLibrary = new ClassValue<>() {
-        @Override
-        protected NativeLibraries computeValue(Class<?> type) {
-            return NativeLibraries.jniNativeLibraries(type.getClassLoader());
-        }
-    };
+    private final static NativeLibraries nativeLibraries =
+            NativeLibraries.rawNativeLibraries(LibrariesHelper.class, true);
 
+    private final static Map<NativeLibrary, AtomicInteger> loadedLibraries = new IdentityHashMap<>();
 
     /**
      * Load the specified shared library.
      *
-     * @param lookup Lookup object of the caller.
      * @param name Name of the shared library to load.
      */
-    public static LibraryLookup loadLibrary(Lookup lookup, String name) {
-        return new LibraryLookupImpl(nativeLibrary.get(lookup.lookupClass())
-                .loadLibrary(lookup.lookupClass(), name));
+    public static LibraryLookup loadLibrary(String name) {
+        return lookup(() -> nativeLibraries.loadLibrary(LibrariesHelper.class, name),
+                "Library not found: " + name);
     }
 
     /**
      * Load the specified shared library.
      *
-     * @param lookup Lookup object of the caller.
      * @param path Path of the shared library to load.
      */
-    public static LibraryLookup load(Lookup lookup, String path) {
+    public static LibraryLookup load(String path) {
         File file = new File(path);
         if (!file.isAbsolute()) {
             throw new UnsatisfiedLinkError(
                     "Expecting an absolute path of the library: " + path);
         }
-        return new LibraryLookupImpl(nativeLibrary.get(lookup.lookupClass())
-                .loadLibrary(lookup.lookupClass(), file));
+        return lookup(() -> nativeLibraries.loadLibrary(LibrariesHelper.class, file),
+                "Library not found: " + path);
     }
 
     // return the absolute path of the library of given name by searching
     // in the given array of paths.
     private static Optional<Path> findLibraryPath(Path[] paths, String libName) {
@@ -84,11 +82,31 @@
               map(p -> p.resolve(System.mapLibraryName(libName))).
               filter(Files::isRegularFile).map(Path::toAbsolutePath).findFirst();
     }
 
     public static LibraryLookup getDefaultLibrary() {
-        return new LibraryLookupImpl(NativeLibraries.defaultLibrary);
+        return LibraryLookupImpl.DEFAULT_LOOKUP;
+    }
+
+    synchronized static LibraryLookupImpl lookup(Supplier<NativeLibrary> librarySupplier, String notFoundMsg) {
+        NativeLibrary library = librarySupplier.get();
+        if (library == null) {
+            throw new IllegalArgumentException("Library not found: " + notFoundMsg);
+        }
+        AtomicInteger refCount = loadedLibraries.computeIfAbsent(library, lib -> new AtomicInteger());
+        refCount.incrementAndGet();
+        LibraryLookupImpl lookup = new LibraryLookupImpl(library);
+        CleanerFactory.cleaner().register(lookup, () -> tryUnload(library));
+        return lookup;
+    }
+
+    synchronized static void tryUnload(NativeLibrary library) {
+        AtomicInteger refCount = loadedLibraries.get(library);
+        if (refCount.decrementAndGet() == 0) {
+            loadedLibraries.remove(library);
+            nativeLibraries.unload(library);
+        }
     }
 
     static class LibraryLookupImpl implements LibraryLookup {
         final NativeLibrary library;
 
@@ -97,9 +115,18 @@
         }
 
         @Override
         public MemoryAddress lookup(String name) throws NoSuchMethodException {
             long addr = library.lookup(name);
-            return MemoryAddress.ofLong(addr);
+            return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(addr),
+                    0, null, null, this)
+                    .baseAddress();
         }
+
+        static LibraryLookup DEFAULT_LOOKUP = new LibraryLookupImpl(NativeLibraries.defaultLibrary);
+    }
+
+    /* used for testing */
+    public static int numLoadedLibraries() {
+        return loadedLibraries.size();
     }
 }

diff a/src/java.base/share/classes/module-info.java b/src/java.base/share/classes/module-info.java
--- a/src/java.base/share/classes/module-info.java
+++ b/src/java.base/share/classes/module-info.java
@@ -215,11 +215,12 @@
         jdk.management.agent,
         jdk.internal.jvmstat;
     exports jdk.internal.platform to
         jdk.management;
     exports jdk.internal.ref to
-        java.desktop;
+        java.desktop,
+        jdk.incubator.foreign;
     exports jdk.internal.reflect to
         java.logging,
         java.sql,
         java.sql.rowset,
         jdk.dynalink,
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/LibraryLookup.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/LibraryLookup.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/LibraryLookup.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/LibraryLookup.java
@@ -26,20 +26,33 @@
 package jdk.incubator.foreign;
 
 import jdk.internal.foreign.LibrariesHelper;
 
 import java.io.File;
-import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
 import java.util.Objects;
 
 /**
  * A native library lookup. Exposes lookup operation for searching symbols, see {@link LibraryLookup#lookup(String)}.
+ * A given native library remains loaded as long as there is at least one <em>live</em> library lookup instance referring
+ * to it.
+ * <p>
+ * Memory address instances generated by a library lookup will contain a strong reference to the originating lookup object,
+ * therefore preventing library unloading; in turn method handle instances obtained from
+ * {@link SystemABI#downcallHandle(MemoryAddress, MethodType, FunctionDescriptor)}) also maintain a strong reference
+ * to the memory address parameter used for their construction. This means that there is always a strong reachability chain
+ * from a native method handle to a lookup object (the one that was used to lookup the native library symbol the method handle
+ * refers to); this is useful to prevent situations where a native library is unloaded in the middle of a native call.
+ * <p>
+ * To allow for a library to be unloaded, a client will have to discard any strong references it
+ * maintains, directly, or indirectly to a lookup object associated with given library.
  */
 public interface LibraryLookup {
 
     /**
-     * Lookups a symbol with given name in this library.
+     * Lookups a symbol with given name in this library. The returned address has the same temporal bounds
+     * as this lookup object.
      * @param name the symbol name.
      * @return the library symbol (if any)
      * @throws NoSuchMethodException if no symbol with given name could be found.
      */
     MemoryAddress lookup(String name) throws NoSuchMethodException;
@@ -56,41 +69,39 @@
         return LibrariesHelper.getDefaultLibrary();
     }
 
     /**
      * Obtain a library lookup object corresponding to a library identified by given path.
-     * @param lookup the contextual lookup object.
      * @param path the library path.
      * @return a library lookup object for given path.
      */
-    static LibraryLookup ofPath(MethodHandles.Lookup lookup, String path) {
+    static LibraryLookup ofPath(String path) {
         Objects.requireNonNull(path);
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
             security.checkLink(path);
         }
         if (!(new File(path).isAbsolute())) {
             throw new UnsatisfiedLinkError(
                     "Expecting an absolute path of the library: " + path);
         }
-        return LibrariesHelper.load(lookup, path);
+        return LibrariesHelper.load(path);
     }
 
     /**
      * Obtain a library lookup object corresponding to a library identified by given library name.
-     * @param lookup the contextual lookup object.
      * @param libName the library name.
      * @return a library lookup object for given library name.
      */
-    static LibraryLookup ofLibrary(MethodHandles.Lookup lookup, String libName) {
+    static LibraryLookup ofLibrary(String libName) {
         Objects.requireNonNull(libName);
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
             security.checkLink(libName);
         }
         if (libName.indexOf(File.separatorChar) != -1) {
             throw new UnsatisfiedLinkError(
                     "Directory separator should not appear in library name: " + libName);
         }
-        return LibrariesHelper.loadLibrary(lookup, libName);
+        return LibrariesHelper.loadLibrary(libName);
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java
@@ -26,57 +26,55 @@
 package jdk.internal.foreign;
 
 import jdk.incubator.foreign.MemoryAddress;
 
 import java.io.File;
-import java.lang.invoke.MethodHandles.Lookup;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.internal.loader.NativeLibraries;
 import jdk.internal.loader.NativeLibrary;
+import jdk.internal.ref.CleanerFactory;
 
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.Arrays;
+import java.util.IdentityHashMap;
+import java.util.Map;
 import java.util.Optional;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Supplier;
 
 public final class LibrariesHelper {
     private LibrariesHelper() {}
 
-    // FIXME - revisit this (refcount for unload)
-    private final static ClassValue<NativeLibraries> nativeLibrary = new ClassValue<>() {
-        @Override
-        protected NativeLibraries computeValue(Class<?> type) {
-            return NativeLibraries.jniNativeLibraries(type.getClassLoader());
-        }
-    };
+    private final static NativeLibraries nativeLibraries =
+            NativeLibraries.rawNativeLibraries(LibrariesHelper.class, true);
 
+    private final static Map<NativeLibrary, AtomicInteger> loadedLibraries = new IdentityHashMap<>();
 
     /**
      * Load the specified shared library.
      *
-     * @param lookup Lookup object of the caller.
      * @param name Name of the shared library to load.
      */
-    public static LibraryLookup loadLibrary(Lookup lookup, String name) {
-        return new LibraryLookupImpl(nativeLibrary.get(lookup.lookupClass())
-                .loadLibrary(lookup.lookupClass(), name));
+    public static LibraryLookup loadLibrary(String name) {
+        return lookup(() -> nativeLibraries.loadLibrary(LibrariesHelper.class, name),
+                "Library not found: " + name);
     }
 
     /**
      * Load the specified shared library.
      *
-     * @param lookup Lookup object of the caller.
      * @param path Path of the shared library to load.
      */
-    public static LibraryLookup load(Lookup lookup, String path) {
+    public static LibraryLookup load(String path) {
         File file = new File(path);
         if (!file.isAbsolute()) {
             throw new UnsatisfiedLinkError(
                     "Expecting an absolute path of the library: " + path);
         }
-        return new LibraryLookupImpl(nativeLibrary.get(lookup.lookupClass())
-                .loadLibrary(lookup.lookupClass(), file));
+        return lookup(() -> nativeLibraries.loadLibrary(LibrariesHelper.class, file),
+                "Library not found: " + path);
     }
 
     // return the absolute path of the library of given name by searching
     // in the given array of paths.
     private static Optional<Path> findLibraryPath(Path[] paths, String libName) {
@@ -84,11 +82,31 @@
               map(p -> p.resolve(System.mapLibraryName(libName))).
               filter(Files::isRegularFile).map(Path::toAbsolutePath).findFirst();
     }
 
     public static LibraryLookup getDefaultLibrary() {
-        return new LibraryLookupImpl(NativeLibraries.defaultLibrary);
+        return LibraryLookupImpl.DEFAULT_LOOKUP;
+    }
+
+    synchronized static LibraryLookupImpl lookup(Supplier<NativeLibrary> librarySupplier, String notFoundMsg) {
+        NativeLibrary library = librarySupplier.get();
+        if (library == null) {
+            throw new IllegalArgumentException(notFoundMsg);
+        }
+        AtomicInteger refCount = loadedLibraries.computeIfAbsent(library, lib -> new AtomicInteger());
+        refCount.incrementAndGet();
+        LibraryLookupImpl lookup = new LibraryLookupImpl(library);
+        CleanerFactory.cleaner().register(lookup, () -> tryUnload(library));
+        return lookup;
+    }
+
+    synchronized static void tryUnload(NativeLibrary library) {
+        AtomicInteger refCount = loadedLibraries.get(library);
+        if (refCount.decrementAndGet() == 0) {
+            loadedLibraries.remove(library);
+            nativeLibraries.unload(library);
+        }
     }
 
     static class LibraryLookupImpl implements LibraryLookup {
         final NativeLibrary library;
 
@@ -97,9 +115,18 @@
         }
 
         @Override
         public MemoryAddress lookup(String name) throws NoSuchMethodException {
             long addr = library.lookup(name);
-            return MemoryAddress.ofLong(addr);
+            return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(addr),
+                    0, null, null, this)
+                    .baseAddress();
         }
+
+        static LibraryLookup DEFAULT_LOOKUP = new LibraryLookupImpl(NativeLibraries.defaultLibrary);
+    }
+
+    /* used for testing */
+    public static int numLoadedLibraries() {
+        return loadedLibraries.size();
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
@@ -70,14 +70,14 @@
 
     private final MethodType type;
     private final FunctionDescriptor function;
     private final CallingSequence callingSequence;
 
-    private final long addr;
+    private final MemoryAddress addr;
     private final long stubAddress;
 
-    public ProgrammableInvoker(ABIDescriptor abi, long addr, CallingSequence callingSequence) {
+    public ProgrammableInvoker(ABIDescriptor abi, MemoryAddress addr, CallingSequence callingSequence) {
         this.abi = abi;
         this.layout = BufferLayout.of(abi);
         this.stubAddress = adapterStubs.computeIfAbsent(abi, key -> generateAdapter(key, layout));
 
         this.addr = addr;
@@ -107,11 +107,11 @@
                 stackArgs = stackArgsSeg.baseAddress();
             } else {
                 stackArgs = MemoryAddressImpl.NULL;
             }
 
-            VH_LONG.set(argsPtr.addOffset(layout.arguments_next_pc), addr);
+            VH_LONG.set(argsPtr.addOffset(layout.arguments_next_pc), addr.toRawLongValue());
             VH_LONG.set(argsPtr.addOffset(layout.stack_args_bytes), stackArgsBytes);
             VH_LONG.set(argsPtr.addOffset(layout.stack_args), stackArgs.toRawLongValue());
 
             for (int i = 0; i < args.length; i++) {
                 Object arg = args[i];
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
@@ -53,11 +53,11 @@
         return instance;
     }
 
     @Override
     public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
-        return CallArranger.arrangeDowncall(symbol.toRawLongValue(), type, function);
+        return CallArranger.arrangeDowncall(symbol, type, function);
     }
 
     @Override
     public MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function) {
         return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
@@ -122,11 +122,11 @@
         }
 
         return new Bindings(csb.build(), returnInMemory);
     }
 
-    public static MethodHandle arrangeDowncall(long addr, MethodType mt, FunctionDescriptor cDesc) {
+    public static MethodHandle arrangeDowncall(MemoryAddress addr, MethodType mt, FunctionDescriptor cDesc) {
         Bindings bindings = getBindings(mt, cDesc, false);
 
         MethodHandle handle = new ProgrammableInvoker(C, addr, bindings.callingSequence).getBoundMethodHandle();
 
         if (bindings.isInMemoryReturn) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
@@ -125,11 +125,11 @@
         }
 
         return new Bindings(csb.build(), returnInMemory, argCalc.storageCalculator.nVectorReg);
     }
 
-    public static MethodHandle arrangeDowncall(long addr, MethodType mt, FunctionDescriptor cDesc) {
+    public static MethodHandle arrangeDowncall(MemoryAddress addr, MethodType mt, FunctionDescriptor cDesc) {
         Bindings bindings = getBindings(mt, cDesc, false);
 
         MethodHandle handle = new ProgrammableInvoker(CSysV, addr, bindings.callingSequence).getBoundMethodHandle();
         handle = MethodHandles.insertArguments(handle, handle.type().parameterCount() - 1, bindings.nVectorArgs);
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
@@ -57,11 +57,11 @@
         return instance;
     }
 
     @Override
     public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
-        return CallArranger.arrangeDowncall(symbol.toRawLongValue(), type, function);
+        return CallArranger.arrangeDowncall(symbol, type, function);
     }
 
     @Override
     public MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function) {
         return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
@@ -122,11 +122,11 @@
         }
 
         return new Bindings(csb.csb.build(), returnInMemory);
     }
 
-    public static MethodHandle arrangeDowncall(long addr, MethodType mt, FunctionDescriptor cDesc) {
+    public static MethodHandle arrangeDowncall(MemoryAddress addr, MethodType mt, FunctionDescriptor cDesc) {
         Bindings bindings = getBindings(mt, cDesc, false);
 
         MethodHandle handle = new ProgrammableInvoker(CWindows, addr, bindings.callingSequence).getBoundMethodHandle();
 
         if (bindings.isInMemoryReturn) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
@@ -62,11 +62,11 @@
         return instance;
     }
 
     @Override
     public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
-        return CallArranger.arrangeDowncall(symbol.toRawLongValue(), type, function);
+        return CallArranger.arrangeDowncall(symbol, type, function);
     }
 
     @Override
     public MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function) {
         return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
diff a/test/jdk/java/foreign/TestDowncall.java b/test/jdk/java/foreign/TestDowncall.java
--- a/test/jdk/java/foreign/TestDowncall.java
+++ b/test/jdk/java/foreign/TestDowncall.java
@@ -49,11 +49,11 @@
 import org.testng.annotations.*;
 import static org.testng.Assert.*;
 
 public class TestDowncall extends CallGeneratorHelper {
 
-    static LibraryLookup lib = LibraryLookup.ofLibrary(MethodHandles.lookup(), "TestDowncall");
+    static LibraryLookup lib = LibraryLookup.ofLibrary("TestDowncall");
     static SystemABI abi = SystemABI.getSystemABI();
 
 
     @Test(dataProvider="functions", dataProviderClass=CallGeneratorHelper.class)
     public void testDowncall(String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {
diff a/test/jdk/java/foreign/TestLibraryLookup.java b/test/jdk/java/foreign/TestLibraryLookup.java
--- /dev/null
+++ b/test/jdk/java/foreign/TestLibraryLookup.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @modules jdk.incubator.foreign/jdk.internal.foreign
+ * @run testng/othervm -Dforeign.restricted=permit TestLibraryLookup
+ */
+
+import jdk.incubator.foreign.LibraryLookup;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.internal.foreign.LibrariesHelper;
+import org.testng.annotations.Test;
+
+import java.lang.reflect.Field;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.testng.Assert.*;
+
+public class TestLibraryLookup {
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testInvalidLookupName() {
+        LibraryLookup.ofLibrary("NonExistent");
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testInvalidLookupPath() {
+        LibraryLookup.ofPath(Path.of("NonExistent").toAbsolutePath().toString());
+    }
+
+    @Test
+    public void testSimpleLookup() throws Throwable {
+        MemoryAddress symbol = null;
+        LibraryLookup lookup = LibraryLookup.ofLibrary("LookupTest");
+        symbol = lookup.lookup("f");
+        assertTrue(symbol.segment().isAlive());
+        assertEquals(LibrariesHelper.numLoadedLibraries(), 1);
+        lookup = null;
+        symbol = null;
+        waitUnload();
+    }
+
+    @Test
+    public void testMultiLookupSameLoader() throws Throwable {
+        List<MemoryAddress> symbols = new ArrayList<>();
+        List<LibraryLookup> lookups = new ArrayList<>();
+        for (int i = 0 ; i < 5 ; i++) {
+            LibraryLookup lookup = LibraryLookup.ofLibrary("LookupTest");
+            MemoryAddress symbol = lookup.lookup("f");
+            assertTrue(symbol.segment().isAlive());
+            lookups.add(lookup);
+            symbols.add(symbol);
+            assertEquals(LibrariesHelper.numLoadedLibraries(), 1);
+        }
+        lookups = null;
+        symbols = null;
+        waitUnload();
+    }
+
+    @Test
+    public void testMultiLookupDifferentLoaders() throws Throwable {
+        List<URLClassLoader> loaders = new ArrayList<>();
+        for (int i = 0 ; i < 5 ; i++) {
+            URLClassLoader loader = new LocalLoader();
+            Class<?> clazz = loader.loadClass("TestLibraryLookup$Holder");
+            Field field = clazz.getField("lookup");
+            field.setAccessible(true);
+            field.get(null); //make sure <clinit> is run
+            loaders.add(loader);
+        }
+        loaders.forEach(loader -> {
+            try {
+                loader.close();
+            } catch (Throwable ex) {
+                throw new AssertionError(ex);
+            }
+        });
+        loaders = null;
+        waitUnload();
+    }
+
+    static class LocalLoader extends URLClassLoader {
+        public LocalLoader() throws Exception {
+            super(new URL[] { Path.of(System.getProperty("test.classes")).toUri().toURL() });
+        }
+
+        @Override
+        public Class<?> loadClass(String name) throws ClassNotFoundException {
+            Class clazz = findLoadedClass(name);
+            if (clazz == null) {
+                //try local first
+                try {
+                    clazz = findClass(name);
+                } catch (ClassNotFoundException e) {
+                    // Swallow exception - does not exist locally
+                }
+                //then try parent loader
+                if (clazz == null) {
+                    clazz = super.loadClass(name);
+                }
+            }
+            return clazz;
+        }
+    }
+
+    static class Holder {
+        public static LibraryLookup lookup;
+        public static MemoryAddress symbol;
+
+        static {
+            try {
+                lookup = LibraryLookup.ofLibrary("LookupTest");
+                symbol = lookup.lookup("f");
+            } catch (Throwable ex) {
+                throw new ExceptionInInitializerError();
+            }
+        }
+    }
+
+    private static void waitUnload() throws InterruptedException {
+        while (LibrariesHelper.numLoadedLibraries() != 0) {
+            System.gc();
+            Object o = new Object[1000];
+            Thread.sleep(1);
+        }
+    }
+}
diff a/test/jdk/java/foreign/TestUpcall.java b/test/jdk/java/foreign/TestUpcall.java
--- a/test/jdk/java/foreign/TestUpcall.java
+++ b/test/jdk/java/foreign/TestUpcall.java
@@ -59,11 +59,11 @@
 import static org.testng.Assert.assertEquals;
 
 
 public class TestUpcall extends CallGeneratorHelper {
 
-    static LibraryLookup lib = LibraryLookup.ofLibrary(MethodHandles.lookup(), "TestUpcall");
+    static LibraryLookup lib = LibraryLookup.ofLibrary("TestUpcall");
     static SystemABI abi = SystemABI.getSystemABI();
     static final MemoryAddress dummyAddress;
     static final Cleaner cleaner = Cleaner.create();
 
     static MethodHandle DUMMY;
diff a/test/jdk/java/foreign/TestVarArgs.java b/test/jdk/java/foreign/TestVarArgs.java
--- a/test/jdk/java/foreign/TestVarArgs.java
+++ b/test/jdk/java/foreign/TestVarArgs.java
@@ -68,11 +68,11 @@
     static final SystemABI abi = SystemABI.getSystemABI();
     static final MemoryAddress varargsAddr;
 
     static {
         try {
-            varargsAddr = LibraryLookup.ofLibrary(MethodHandles.lookup(), "VarArgs").lookup("varargs");
+            varargsAddr = LibraryLookup.ofLibrary("VarArgs").lookup("varargs");
         } catch (NoSuchMethodException e) {
             throw new BootstrapMethodError(e);
         }
     }
 
diff a/test/jdk/java/foreign/libLookupTest.c b/test/jdk/java/foreign/libLookupTest.c
--- /dev/null
+++ b/test/jdk/java/foreign/libLookupTest.c
@@ -0,0 +1,32 @@
+/*
+ *  Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+ #ifdef _WIN64
+ #define EXPORT __declspec(dllexport)
+ #else
+ #define EXPORT
+ #endif
+
+ EXPORT void f() { }
+

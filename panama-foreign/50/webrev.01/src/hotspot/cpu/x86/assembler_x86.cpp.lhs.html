<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/assembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.hpp&quot;
  27 #include &quot;asm/assembler.inline.hpp&quot;
  28 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  29 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  30 #include &quot;interpreter/interpreter.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;prims/methodHandles.hpp&quot;
  33 #include &quot;runtime/biasedLocking.hpp&quot;
  34 #include &quot;runtime/objectMonitor.hpp&quot;
  35 #include &quot;runtime/os.hpp&quot;
  36 #include &quot;runtime/sharedRuntime.hpp&quot;
  37 #include &quot;runtime/stubRoutines.hpp&quot;
  38 #include &quot;utilities/macros.hpp&quot;
  39 
  40 #ifdef PRODUCT
  41 #define BLOCK_COMMENT(str) /* nothing */
  42 #define STOP(error) stop(error)
  43 #else
  44 #define BLOCK_COMMENT(str) block_comment(str)
  45 #define STOP(error) block_comment(error); stop(error)
  46 #endif
  47 
  48 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  49 // Implementation of AddressLiteral
  50 
  51 // A 2-D table for managing compressed displacement(disp8) on EVEX enabled platforms.
  52 unsigned char tuple_table[Assembler::EVEX_ETUP + 1][Assembler::AVX_512bit + 1] = {
  53   // -----------------Table 4.5 -------------------- //
  54   16, 32, 64,  // EVEX_FV(0)
  55   4,  4,  4,   // EVEX_FV(1) - with Evex.b
  56   16, 32, 64,  // EVEX_FV(2) - with Evex.w
  57   8,  8,  8,   // EVEX_FV(3) - with Evex.w and Evex.b
  58   8,  16, 32,  // EVEX_HV(0)
  59   4,  4,  4,   // EVEX_HV(1) - with Evex.b
  60   // -----------------Table 4.6 -------------------- //
  61   16, 32, 64,  // EVEX_FVM(0)
  62   1,  1,  1,   // EVEX_T1S(0)
  63   2,  2,  2,   // EVEX_T1S(1)
  64   4,  4,  4,   // EVEX_T1S(2)
  65   8,  8,  8,   // EVEX_T1S(3)
  66   4,  4,  4,   // EVEX_T1F(0)
  67   8,  8,  8,   // EVEX_T1F(1)
  68   8,  8,  8,   // EVEX_T2(0)
  69   0,  16, 16,  // EVEX_T2(1)
  70   0,  16, 16,  // EVEX_T4(0)
  71   0,  0,  32,  // EVEX_T4(1)
  72   0,  0,  32,  // EVEX_T8(0)
  73   8,  16, 32,  // EVEX_HVM(0)
  74   4,  8,  16,  // EVEX_QVM(0)
  75   2,  4,  8,   // EVEX_OVM(0)
  76   16, 16, 16,  // EVEX_M128(0)
  77   8,  32, 64,  // EVEX_DUP(0)
  78   0,  0,  0    // EVEX_NTUP
  79 };
  80 
  81 AddressLiteral::AddressLiteral(address target, relocInfo::relocType rtype) {
  82   _is_lval = false;
  83   _target = target;
  84   switch (rtype) {
  85   case relocInfo::oop_type:
  86   case relocInfo::metadata_type:
  87     // Oops are a special case. Normally they would be their own section
  88     // but in cases like icBuffer they are literals in the code stream that
  89     // we don&#39;t have a section for. We use none so that we get a literal address
  90     // which is always patchable.
  91     break;
  92   case relocInfo::external_word_type:
  93     _rspec = external_word_Relocation::spec(target);
  94     break;
  95   case relocInfo::internal_word_type:
  96     _rspec = internal_word_Relocation::spec(target);
  97     break;
  98   case relocInfo::opt_virtual_call_type:
  99     _rspec = opt_virtual_call_Relocation::spec();
 100     break;
 101   case relocInfo::static_call_type:
 102     _rspec = static_call_Relocation::spec();
 103     break;
 104   case relocInfo::runtime_call_type:
 105     _rspec = runtime_call_Relocation::spec();
 106     break;
 107   case relocInfo::poll_type:
 108   case relocInfo::poll_return_type:
 109     _rspec = Relocation::spec_simple(rtype);
 110     break;
 111   case relocInfo::none:
 112     break;
 113   default:
 114     ShouldNotReachHere();
 115     break;
 116   }
 117 }
 118 
 119 // Implementation of Address
 120 
 121 #ifdef _LP64
 122 
 123 Address Address::make_array(ArrayAddress adr) {
 124   // Not implementable on 64bit machines
 125   // Should have been handled higher up the call chain.
 126   ShouldNotReachHere();
 127   return Address();
 128 }
 129 
 130 // exceedingly dangerous constructor
 131 Address::Address(int disp, address loc, relocInfo::relocType rtype) {
 132   _base  = noreg;
 133   _index = noreg;
 134   _scale = no_scale;
 135   _disp  = disp;
 136   _xmmindex = xnoreg;
 137   _isxmmindex = false;
 138   switch (rtype) {
 139     case relocInfo::external_word_type:
 140       _rspec = external_word_Relocation::spec(loc);
 141       break;
 142     case relocInfo::internal_word_type:
 143       _rspec = internal_word_Relocation::spec(loc);
 144       break;
 145     case relocInfo::runtime_call_type:
 146       // HMM
 147       _rspec = runtime_call_Relocation::spec();
 148       break;
 149     case relocInfo::poll_type:
 150     case relocInfo::poll_return_type:
 151       _rspec = Relocation::spec_simple(rtype);
 152       break;
 153     case relocInfo::none:
 154       break;
 155     default:
 156       ShouldNotReachHere();
 157   }
 158 }
 159 #else // LP64
 160 
 161 Address Address::make_array(ArrayAddress adr) {
 162   AddressLiteral base = adr.base();
 163   Address index = adr.index();
 164   assert(index._disp == 0, &quot;must not have disp&quot;); // maybe it can?
 165   Address array(index._base, index._index, index._scale, (intptr_t) base.target());
 166   array._rspec = base._rspec;
 167   return array;
 168 }
 169 
 170 // exceedingly dangerous constructor
 171 Address::Address(address loc, RelocationHolder spec) {
 172   _base  = noreg;
 173   _index = noreg;
 174   _scale = no_scale;
 175   _disp  = (intptr_t) loc;
 176   _rspec = spec;
 177   _xmmindex = xnoreg;
 178   _isxmmindex = false;
 179 }
 180 
 181 #endif // _LP64
 182 
 183 
 184 
 185 // Convert the raw encoding form into the form expected by the constructor for
 186 // Address.  An index of 4 (rsp) corresponds to having no index, so convert
 187 // that to noreg for the Address constructor.
 188 Address Address::make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc) {
 189   RelocationHolder rspec;
 190   if (disp_reloc != relocInfo::none) {
 191     rspec = Relocation::spec_simple(disp_reloc);
 192   }
 193   bool valid_index = index != rsp-&gt;encoding();
 194   if (valid_index) {
 195     Address madr(as_Register(base), as_Register(index), (Address::ScaleFactor)scale, in_ByteSize(disp));
 196     madr._rspec = rspec;
 197     return madr;
 198   } else {
 199     Address madr(as_Register(base), noreg, Address::no_scale, in_ByteSize(disp));
 200     madr._rspec = rspec;
 201     return madr;
 202   }
 203 }
 204 
 205 // Implementation of Assembler
 206 
 207 int AbstractAssembler::code_fill_byte() {
 208   return (u_char)&#39;\xF4&#39;; // hlt
 209 }
 210 
 211 // make this go away someday
 212 void Assembler::emit_data(jint data, relocInfo::relocType rtype, int format) {
 213   if (rtype == relocInfo::none)
 214     emit_int32(data);
 215   else
 216     emit_data(data, Relocation::spec_simple(rtype), format);
 217 }
 218 
 219 void Assembler::emit_data(jint data, RelocationHolder const&amp; rspec, int format) {
 220   assert(imm_operand == 0, &quot;default format must be immediate in this file&quot;);
 221   assert(inst_mark() != NULL, &quot;must be inside InstructionMark&quot;);
 222   if (rspec.type() !=  relocInfo::none) {
 223     #ifdef ASSERT
 224       check_relocation(rspec, format);
 225     #endif
 226     // Do not use AbstractAssembler::relocate, which is not intended for
 227     // embedded words.  Instead, relocate to the enclosing instruction.
 228 
 229     // hack. call32 is too wide for mask so use disp32
 230     if (format == call32_operand)
 231       code_section()-&gt;relocate(inst_mark(), rspec, disp32_operand);
 232     else
 233       code_section()-&gt;relocate(inst_mark(), rspec, format);
 234   }
 235   emit_int32(data);
 236 }
 237 
 238 static int encode(Register r) {
 239   int enc = r-&gt;encoding();
 240   if (enc &gt;= 8) {
 241     enc -= 8;
 242   }
 243   return enc;
 244 }
 245 
 246 void Assembler::emit_arith_b(int op1, int op2, Register dst, int imm8) {
 247   assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;);
 248   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
 249   assert(isByte(imm8), &quot;not a byte&quot;);
 250   assert((op1 &amp; 0x01) == 0, &quot;should be 8bit operation&quot;);
 251   emit_int8(op1);
 252   emit_int8(op2 | encode(dst));
 253   emit_int8(imm8);
 254 }
 255 
 256 
 257 void Assembler::emit_arith(int op1, int op2, Register dst, int32_t imm32) {
 258   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
 259   assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
 260   assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
 261   if (is8bit(imm32)) {
 262     emit_int8(op1 | 0x02); // set sign bit
 263     emit_int8(op2 | encode(dst));
 264     emit_int8(imm32 &amp; 0xFF);
 265   } else {
 266     emit_int8(op1);
 267     emit_int8(op2 | encode(dst));
 268     emit_int32(imm32);
 269   }
 270 }
 271 
 272 // Force generation of a 4 byte immediate value even if it fits into 8bit
 273 void Assembler::emit_arith_imm32(int op1, int op2, Register dst, int32_t imm32) {
 274   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
 275   assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
 276   assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
 277   emit_int8(op1);
 278   emit_int8(op2 | encode(dst));
 279   emit_int32(imm32);
 280 }
 281 
 282 // immediate-to-memory forms
 283 void Assembler::emit_arith_operand(int op1, Register rm, Address adr, int32_t imm32) {
 284   assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
 285   assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
 286   if (is8bit(imm32)) {
 287     emit_int8(op1 | 0x02); // set sign bit
 288     emit_operand(rm, adr, 1);
 289     emit_int8(imm32 &amp; 0xFF);
 290   } else {
 291     emit_int8(op1);
 292     emit_operand(rm, adr, 4);
 293     emit_int32(imm32);
 294   }
 295 }
 296 
 297 
 298 void Assembler::emit_arith(int op1, int op2, Register dst, Register src) {
 299   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
 300   emit_int8(op1);
 301   emit_int8(op2 | encode(dst) &lt;&lt; 3 | encode(src));
 302 }
 303 
 304 
 305 bool Assembler::query_compressed_disp_byte(int disp, bool is_evex_inst, int vector_len,
 306                                            int cur_tuple_type, int in_size_in_bits, int cur_encoding) {
 307   int mod_idx = 0;
 308   // We will test if the displacement fits the compressed format and if so
 309   // apply the compression to the displacment iff the result is8bit.
 310   if (VM_Version::supports_evex() &amp;&amp; is_evex_inst) {
 311     switch (cur_tuple_type) {
 312     case EVEX_FV:
 313       if ((cur_encoding &amp; VEX_W) == VEX_W) {
 314         mod_idx = ((cur_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 3 : 2;
 315       } else {
 316         mod_idx = ((cur_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 1 : 0;
 317       }
 318       break;
 319 
 320     case EVEX_HV:
 321       mod_idx = ((cur_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 1 : 0;
 322       break;
 323 
 324     case EVEX_FVM:
 325       break;
 326 
 327     case EVEX_T1S:
 328       switch (in_size_in_bits) {
 329       case EVEX_8bit:
 330         break;
 331 
 332       case EVEX_16bit:
 333         mod_idx = 1;
 334         break;
 335 
 336       case EVEX_32bit:
 337         mod_idx = 2;
 338         break;
 339 
 340       case EVEX_64bit:
 341         mod_idx = 3;
 342         break;
 343       }
 344       break;
 345 
 346     case EVEX_T1F:
 347     case EVEX_T2:
 348     case EVEX_T4:
 349       mod_idx = (in_size_in_bits == EVEX_64bit) ? 1 : 0;
 350       break;
 351 
 352     case EVEX_T8:
 353       break;
 354 
 355     case EVEX_HVM:
 356       break;
 357 
 358     case EVEX_QVM:
 359       break;
 360 
 361     case EVEX_OVM:
 362       break;
 363 
 364     case EVEX_M128:
 365       break;
 366 
 367     case EVEX_DUP:
 368       break;
 369 
 370     default:
 371       assert(0, &quot;no valid evex tuple_table entry&quot;);
 372       break;
 373     }
 374 
 375     if (vector_len &gt;= AVX_128bit &amp;&amp; vector_len &lt;= AVX_512bit) {
 376       int disp_factor = tuple_table[cur_tuple_type + mod_idx][vector_len];
 377       if ((disp % disp_factor) == 0) {
 378         int new_disp = disp / disp_factor;
 379         if ((-0x80 &lt;= new_disp &amp;&amp; new_disp &lt; 0x80)) {
 380           disp = new_disp;
 381         }
 382       } else {
 383         return false;
 384       }
 385     }
 386   }
 387   return (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80);
 388 }
 389 
 390 
 391 bool Assembler::emit_compressed_disp_byte(int &amp;disp) {
 392   int mod_idx = 0;
 393   // We will test if the displacement fits the compressed format and if so
 394   // apply the compression to the displacment iff the result is8bit.
 395   if (VM_Version::supports_evex() &amp;&amp; _attributes &amp;&amp; _attributes-&gt;is_evex_instruction()) {
 396     int evex_encoding = _attributes-&gt;get_evex_encoding();
 397     int tuple_type = _attributes-&gt;get_tuple_type();
 398     switch (tuple_type) {
 399     case EVEX_FV:
 400       if ((evex_encoding &amp; VEX_W) == VEX_W) {
 401         mod_idx = ((evex_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 3 : 2;
 402       } else {
 403         mod_idx = ((evex_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 1 : 0;
 404       }
 405       break;
 406 
 407     case EVEX_HV:
 408       mod_idx = ((evex_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 1 : 0;
 409       break;
 410 
 411     case EVEX_FVM:
 412       break;
 413 
 414     case EVEX_T1S:
 415       switch (_attributes-&gt;get_input_size()) {
 416       case EVEX_8bit:
 417         break;
 418 
 419       case EVEX_16bit:
 420         mod_idx = 1;
 421         break;
 422 
 423       case EVEX_32bit:
 424         mod_idx = 2;
 425         break;
 426 
 427       case EVEX_64bit:
 428         mod_idx = 3;
 429         break;
 430       }
 431       break;
 432 
 433     case EVEX_T1F:
 434     case EVEX_T2:
 435     case EVEX_T4:
 436       mod_idx = (_attributes-&gt;get_input_size() == EVEX_64bit) ? 1 : 0;
 437       break;
 438 
 439     case EVEX_T8:
 440       break;
 441 
 442     case EVEX_HVM:
 443       break;
 444 
 445     case EVEX_QVM:
 446       break;
 447 
 448     case EVEX_OVM:
 449       break;
 450 
 451     case EVEX_M128:
 452       break;
 453 
 454     case EVEX_DUP:
 455       break;
 456 
 457     default:
 458       assert(0, &quot;no valid evex tuple_table entry&quot;);
 459       break;
 460     }
 461 
 462     int vector_len = _attributes-&gt;get_vector_len();
 463     if (vector_len &gt;= AVX_128bit &amp;&amp; vector_len &lt;= AVX_512bit) {
 464       int disp_factor = tuple_table[tuple_type + mod_idx][vector_len];
 465       if ((disp % disp_factor) == 0) {
 466         int new_disp = disp / disp_factor;
 467         if (is8bit(new_disp)) {
 468           disp = new_disp;
 469         }
 470       } else {
 471         return false;
 472       }
 473     }
 474   }
 475   return is8bit(disp);
 476 }
 477 
 478 
 479 void Assembler::emit_operand(Register reg, Register base, Register index,
 480                              Address::ScaleFactor scale, int disp,
 481                              RelocationHolder const&amp; rspec,
 482                              int rip_relative_correction) {
 483   relocInfo::relocType rtype = rspec.type();
 484 
 485   // Encode the registers as needed in the fields they are used in
 486 
 487   int regenc = encode(reg) &lt;&lt; 3;
 488   int indexenc = index-&gt;is_valid() ? encode(index) &lt;&lt; 3 : 0;
 489   int baseenc = base-&gt;is_valid() ? encode(base) : 0;
 490 
 491   if (base-&gt;is_valid()) {
 492     if (index-&gt;is_valid()) {
 493       assert(scale != Address::no_scale, &quot;inconsistent address&quot;);
 494       // [base + index*scale + disp]
 495       if (disp == 0 &amp;&amp; rtype == relocInfo::none  &amp;&amp;
 496           base != rbp LP64_ONLY(&amp;&amp; base != r13)) {
 497         // [base + index*scale]
 498         // [00 reg 100][ss index base]
 499         assert(index != rsp, &quot;illegal addressing mode&quot;);
 500         emit_int8(0x04 | regenc);
 501         emit_int8(scale &lt;&lt; 6 | indexenc | baseenc);
 502       } else if (emit_compressed_disp_byte(disp) &amp;&amp; rtype == relocInfo::none) {
 503         // [base + index*scale + imm8]
 504         // [01 reg 100][ss index base] imm8
 505         assert(index != rsp, &quot;illegal addressing mode&quot;);
 506         emit_int8(0x44 | regenc);
 507         emit_int8(scale &lt;&lt; 6 | indexenc | baseenc);
 508         emit_int8(disp &amp; 0xFF);
 509       } else {
 510         // [base + index*scale + disp32]
 511         // [10 reg 100][ss index base] disp32
 512         assert(index != rsp, &quot;illegal addressing mode&quot;);
 513         emit_int8(0x84 | regenc);
 514         emit_int8(scale &lt;&lt; 6 | indexenc | baseenc);
 515         emit_data(disp, rspec, disp32_operand);
 516       }
 517     } else if (base == rsp LP64_ONLY(|| base == r12)) {
 518       // [rsp + disp]
 519       if (disp == 0 &amp;&amp; rtype == relocInfo::none) {
 520         // [rsp]
 521         // [00 reg 100][00 100 100]
 522         emit_int8(0x04 | regenc);
 523         emit_int8(0x24);
 524       } else if (emit_compressed_disp_byte(disp) &amp;&amp; rtype == relocInfo::none) {
 525         // [rsp + imm8]
 526         // [01 reg 100][00 100 100] disp8
 527         emit_int8(0x44 | regenc);
 528         emit_int8(0x24);
 529         emit_int8(disp &amp; 0xFF);
 530       } else {
 531         // [rsp + imm32]
 532         // [10 reg 100][00 100 100] disp32
 533         emit_int8(0x84 | regenc);
 534         emit_int8(0x24);
 535         emit_data(disp, rspec, disp32_operand);
 536       }
 537     } else {
 538       // [base + disp]
 539       assert(base != rsp LP64_ONLY(&amp;&amp; base != r12), &quot;illegal addressing mode&quot;);
 540       if (disp == 0 &amp;&amp; rtype == relocInfo::none &amp;&amp;
 541           base != rbp LP64_ONLY(&amp;&amp; base != r13)) {
 542         // [base]
 543         // [00 reg base]
 544         emit_int8(0x00 | regenc | baseenc);
 545       } else if (emit_compressed_disp_byte(disp) &amp;&amp; rtype == relocInfo::none) {
 546         // [base + disp8]
 547         // [01 reg base] disp8
 548         emit_int8(0x40 | regenc | baseenc);
 549         emit_int8(disp &amp; 0xFF);
 550       } else {
 551         // [base + disp32]
 552         // [10 reg base] disp32
 553         emit_int8(0x80 | regenc | baseenc);
 554         emit_data(disp, rspec, disp32_operand);
 555       }
 556     }
 557   } else {
 558     if (index-&gt;is_valid()) {
 559       assert(scale != Address::no_scale, &quot;inconsistent address&quot;);
 560       // [index*scale + disp]
 561       // [00 reg 100][ss index 101] disp32
 562       assert(index != rsp, &quot;illegal addressing mode&quot;);
 563       emit_int8(0x04 | regenc);
 564       emit_int8(scale &lt;&lt; 6 | indexenc | 0x05);
 565       emit_data(disp, rspec, disp32_operand);
 566     } else if (rtype != relocInfo::none ) {
 567       // [disp] (64bit) RIP-RELATIVE (32bit) abs
 568       // [00 000 101] disp32
 569 
 570       emit_int8(0x05 | regenc);
 571       // Note that the RIP-rel. correction applies to the generated
 572       // disp field, but _not_ to the target address in the rspec.
 573 
 574       // disp was created by converting the target address minus the pc
 575       // at the start of the instruction. That needs more correction here.
 576       // intptr_t disp = target - next_ip;
 577       assert(inst_mark() != NULL, &quot;must be inside InstructionMark&quot;);
 578       address next_ip = pc() + sizeof(int32_t) + rip_relative_correction;
 579       int64_t adjusted = disp;
 580       // Do rip-rel adjustment for 64bit
 581       LP64_ONLY(adjusted -=  (next_ip - inst_mark()));
 582       assert(is_simm32(adjusted),
 583              &quot;must be 32bit offset (RIP relative address)&quot;);
 584       emit_data((int32_t) adjusted, rspec, disp32_operand);
 585 
 586     } else {
 587       // 32bit never did this, did everything as the rip-rel/disp code above
 588       // [disp] ABSOLUTE
 589       // [00 reg 100][00 100 101] disp32
 590       emit_int8(0x04 | regenc);
 591       emit_int8(0x25);
 592       emit_data(disp, rspec, disp32_operand);
 593     }
 594   }
 595 }
 596 
 597 void Assembler::emit_operand(XMMRegister reg, Register base, Register index,
 598                              Address::ScaleFactor scale, int disp,
 599                              RelocationHolder const&amp; rspec) {
 600   if (UseAVX &gt; 2) {
 601     int xreg_enc = reg-&gt;encoding();
 602     if (xreg_enc &gt; 15) {
 603       XMMRegister new_reg = as_XMMRegister(xreg_enc &amp; 0xf);
 604       emit_operand((Register)new_reg, base, index, scale, disp, rspec);
 605       return;
 606     }
 607   }
 608   emit_operand((Register)reg, base, index, scale, disp, rspec);
 609 }
 610 
 611 void Assembler::emit_operand(XMMRegister reg, Register base, XMMRegister index,
 612                              Address::ScaleFactor scale, int disp,
 613                              RelocationHolder const&amp; rspec) {
 614   if (UseAVX &gt; 2) {
 615     int xreg_enc = reg-&gt;encoding();
 616     int xmmindex_enc = index-&gt;encoding();
 617     XMMRegister new_reg = as_XMMRegister(xreg_enc &amp; 0xf);
 618     XMMRegister new_index = as_XMMRegister(xmmindex_enc &amp; 0xf);
 619     emit_operand((Register)new_reg, base, (Register)new_index, scale, disp, rspec);
 620   } else {
 621     emit_operand((Register)reg, base, (Register)index, scale, disp, rspec);
 622   }
 623 }
 624 
 625 
 626 // Secret local extension to Assembler::WhichOperand:
 627 #define end_pc_operand (_WhichOperand_limit)
 628 
 629 address Assembler::locate_operand(address inst, WhichOperand which) {
 630   // Decode the given instruction, and return the address of
 631   // an embedded 32-bit operand word.
 632 
 633   // If &quot;which&quot; is disp32_operand, selects the displacement portion
 634   // of an effective address specifier.
 635   // If &quot;which&quot; is imm64_operand, selects the trailing immediate constant.
 636   // If &quot;which&quot; is call32_operand, selects the displacement of a call or jump.
 637   // Caller is responsible for ensuring that there is such an operand,
 638   // and that it is 32/64 bits wide.
 639 
 640   // If &quot;which&quot; is end_pc_operand, find the end of the instruction.
 641 
 642   address ip = inst;
 643   bool is_64bit = false;
 644 
 645   debug_only(bool has_disp32 = false);
 646   int tail_size = 0; // other random bytes (#32, #16, etc.) at end of insn
 647 
 648   again_after_prefix:
 649   switch (0xFF &amp; *ip++) {
 650 
 651   // These convenience macros generate groups of &quot;case&quot; labels for the switch.
 652 #define REP4(x) (x)+0: case (x)+1: case (x)+2: case (x)+3
 653 #define REP8(x) (x)+0: case (x)+1: case (x)+2: case (x)+3: \
 654              case (x)+4: case (x)+5: case (x)+6: case (x)+7
 655 #define REP16(x) REP8((x)+0): \
 656               case REP8((x)+8)
 657 
 658   case CS_segment:
 659   case SS_segment:
 660   case DS_segment:
 661   case ES_segment:
 662   case FS_segment:
 663   case GS_segment:
 664     // Seems dubious
 665     LP64_ONLY(assert(false, &quot;shouldn&#39;t have that prefix&quot;));
 666     assert(ip == inst+1, &quot;only one prefix allowed&quot;);
 667     goto again_after_prefix;
 668 
 669   case 0x67:
 670   case REX:
 671   case REX_B:
 672   case REX_X:
 673   case REX_XB:
 674   case REX_R:
 675   case REX_RB:
 676   case REX_RX:
 677   case REX_RXB:
 678     NOT_LP64(assert(false, &quot;64bit prefixes&quot;));
 679     goto again_after_prefix;
 680 
 681   case REX_W:
 682   case REX_WB:
 683   case REX_WX:
 684   case REX_WXB:
 685   case REX_WR:
 686   case REX_WRB:
 687   case REX_WRX:
 688   case REX_WRXB:
 689     NOT_LP64(assert(false, &quot;64bit prefixes&quot;));
 690     is_64bit = true;
 691     goto again_after_prefix;
 692 
 693   case 0xFF: // pushq a; decl a; incl a; call a; jmp a
 694   case 0x88: // movb a, r
 695   case 0x89: // movl a, r
 696   case 0x8A: // movb r, a
 697   case 0x8B: // movl r, a
 698   case 0x8F: // popl a
 699     debug_only(has_disp32 = true);
 700     break;
 701 
 702   case 0x68: // pushq #32
 703     if (which == end_pc_operand) {
 704       return ip + 4;
 705     }
 706     assert(which == imm_operand &amp;&amp; !is_64bit, &quot;pushl has no disp32 or 64bit immediate&quot;);
 707     return ip;                  // not produced by emit_operand
 708 
 709   case 0x66: // movw ... (size prefix)
 710     again_after_size_prefix2:
 711     switch (0xFF &amp; *ip++) {
 712     case REX:
 713     case REX_B:
 714     case REX_X:
 715     case REX_XB:
 716     case REX_R:
 717     case REX_RB:
 718     case REX_RX:
 719     case REX_RXB:
 720     case REX_W:
 721     case REX_WB:
 722     case REX_WX:
 723     case REX_WXB:
 724     case REX_WR:
 725     case REX_WRB:
 726     case REX_WRX:
 727     case REX_WRXB:
 728       NOT_LP64(assert(false, &quot;64bit prefix found&quot;));
 729       goto again_after_size_prefix2;
 730     case 0x8B: // movw r, a
 731     case 0x89: // movw a, r
 732       debug_only(has_disp32 = true);
 733       break;
 734     case 0xC7: // movw a, #16
 735       debug_only(has_disp32 = true);
 736       tail_size = 2;  // the imm16
 737       break;
 738     case 0x0F: // several SSE/SSE2 variants
 739       ip--;    // reparse the 0x0F
 740       goto again_after_prefix;
 741     default:
 742       ShouldNotReachHere();
 743     }
 744     break;
 745 
 746   case REP8(0xB8): // movl/q r, #32/#64(oop?)
 747     if (which == end_pc_operand)  return ip + (is_64bit ? 8 : 4);
 748     // these asserts are somewhat nonsensical
 749 #ifndef _LP64
 750     assert(which == imm_operand || which == disp32_operand,
 751            &quot;which %d is_64_bit %d ip &quot; INTPTR_FORMAT, which, is_64bit, p2i(ip));
 752 #else
 753     assert((which == call32_operand || which == imm_operand) &amp;&amp; is_64bit ||
 754            which == narrow_oop_operand &amp;&amp; !is_64bit,
 755            &quot;which %d is_64_bit %d ip &quot; INTPTR_FORMAT, which, is_64bit, p2i(ip));
 756 #endif // _LP64
 757     return ip;
 758 
 759   case 0x69: // imul r, a, #32
 760   case 0xC7: // movl a, #32(oop?)
 761     tail_size = 4;
 762     debug_only(has_disp32 = true); // has both kinds of operands!
 763     break;
 764 
 765   case 0x0F: // movx..., etc.
 766     switch (0xFF &amp; *ip++) {
 767     case 0x3A: // pcmpestri
 768       tail_size = 1;
 769     case 0x38: // ptest, pmovzxbw
 770       ip++; // skip opcode
 771       debug_only(has_disp32 = true); // has both kinds of operands!
 772       break;
 773 
 774     case 0x70: // pshufd r, r/a, #8
 775       debug_only(has_disp32 = true); // has both kinds of operands!
 776     case 0x73: // psrldq r, #8
 777       tail_size = 1;
 778       break;
 779 
 780     case 0x12: // movlps
 781     case 0x28: // movaps
 782     case 0x2E: // ucomiss
 783     case 0x2F: // comiss
 784     case 0x54: // andps
 785     case 0x55: // andnps
 786     case 0x56: // orps
 787     case 0x57: // xorps
 788     case 0x58: // addpd
 789     case 0x59: // mulpd
 790     case 0x6E: // movd
 791     case 0x7E: // movd
 792     case 0x6F: // movdq
 793     case 0x7F: // movdq
 794     case 0xAE: // ldmxcsr, stmxcsr, fxrstor, fxsave, clflush
 795     case 0xFE: // paddd
 796       debug_only(has_disp32 = true);
 797       break;
 798 
 799     case 0xAD: // shrd r, a, %cl
 800     case 0xAF: // imul r, a
 801     case 0xBE: // movsbl r, a (movsxb)
 802     case 0xBF: // movswl r, a (movsxw)
 803     case 0xB6: // movzbl r, a (movzxb)
 804     case 0xB7: // movzwl r, a (movzxw)
 805     case REP16(0x40): // cmovl cc, r, a
 806     case 0xB0: // cmpxchgb
 807     case 0xB1: // cmpxchg
 808     case 0xC1: // xaddl
 809     case 0xC7: // cmpxchg8
 810     case REP16(0x90): // setcc a
 811       debug_only(has_disp32 = true);
 812       // fall out of the switch to decode the address
 813       break;
 814 
 815     case 0xC4: // pinsrw r, a, #8
 816       debug_only(has_disp32 = true);
 817     case 0xC5: // pextrw r, r, #8
 818       tail_size = 1;  // the imm8
 819       break;
 820 
 821     case 0xAC: // shrd r, a, #8
 822       debug_only(has_disp32 = true);
 823       tail_size = 1;  // the imm8
 824       break;
 825 
 826     case REP16(0x80): // jcc rdisp32
 827       if (which == end_pc_operand)  return ip + 4;
 828       assert(which == call32_operand, &quot;jcc has no disp32 or imm&quot;);
 829       return ip;
 830     default:
 831       ShouldNotReachHere();
 832     }
 833     break;
 834 
 835   case 0x81: // addl a, #32; addl r, #32
 836     // also: orl, adcl, sbbl, andl, subl, xorl, cmpl
 837     // on 32bit in the case of cmpl, the imm might be an oop
 838     tail_size = 4;
 839     debug_only(has_disp32 = true); // has both kinds of operands!
 840     break;
 841 
 842   case 0x83: // addl a, #8; addl r, #8
 843     // also: orl, adcl, sbbl, andl, subl, xorl, cmpl
 844     debug_only(has_disp32 = true); // has both kinds of operands!
 845     tail_size = 1;
 846     break;
 847 
 848   case 0x9B:
 849     switch (0xFF &amp; *ip++) {
 850     case 0xD9: // fnstcw a
 851       debug_only(has_disp32 = true);
 852       break;
 853     default:
 854       ShouldNotReachHere();
 855     }
 856     break;
 857 
 858   case REP4(0x00): // addb a, r; addl a, r; addb r, a; addl r, a
 859   case REP4(0x10): // adc...
 860   case REP4(0x20): // and...
 861   case REP4(0x30): // xor...
 862   case REP4(0x08): // or...
 863   case REP4(0x18): // sbb...
 864   case REP4(0x28): // sub...
 865   case 0xF7: // mull a
 866   case 0x8D: // lea r, a
 867   case 0x87: // xchg r, a
 868   case REP4(0x38): // cmp...
 869   case 0x85: // test r, a
 870     debug_only(has_disp32 = true); // has both kinds of operands!
 871     break;
 872 
 873   case 0xC1: // sal a, #8; sar a, #8; shl a, #8; shr a, #8
 874   case 0xC6: // movb a, #8
 875   case 0x80: // cmpb a, #8
 876   case 0x6B: // imul r, a, #8
 877     debug_only(has_disp32 = true); // has both kinds of operands!
 878     tail_size = 1; // the imm8
 879     break;
 880 
 881   case 0xC4: // VEX_3bytes
 882   case 0xC5: // VEX_2bytes
 883     assert((UseAVX &gt; 0), &quot;shouldn&#39;t have VEX prefix&quot;);
 884     assert(ip == inst+1, &quot;no prefixes allowed&quot;);
 885     // C4 and C5 are also used as opcodes for PINSRW and PEXTRW instructions
 886     // but they have prefix 0x0F and processed when 0x0F processed above.
 887     //
 888     // In 32-bit mode the VEX first byte C4 and C5 alias onto LDS and LES
 889     // instructions (these instructions are not supported in 64-bit mode).
 890     // To distinguish them bits [7:6] are set in the VEX second byte since
 891     // ModRM byte can not be of the form 11xxxxxx in 32-bit mode. To set
 892     // those VEX bits REX and vvvv bits are inverted.
 893     //
 894     // Fortunately C2 doesn&#39;t generate these instructions so we don&#39;t need
 895     // to check for them in product version.
 896 
 897     // Check second byte
 898     NOT_LP64(assert((0xC0 &amp; *ip) == 0xC0, &quot;shouldn&#39;t have LDS and LES instructions&quot;));
 899 
 900     int vex_opcode;
 901     // First byte
 902     if ((0xFF &amp; *inst) == VEX_3bytes) {
 903       vex_opcode = VEX_OPCODE_MASK &amp; *ip;
 904       ip++; // third byte
 905       is_64bit = ((VEX_W &amp; *ip) == VEX_W);
 906     } else {
 907       vex_opcode = VEX_OPCODE_0F;
 908     }
 909     ip++; // opcode
 910     // To find the end of instruction (which == end_pc_operand).
 911     switch (vex_opcode) {
 912       case VEX_OPCODE_0F:
 913         switch (0xFF &amp; *ip) {
 914         case 0x70: // pshufd r, r/a, #8
 915         case 0x71: // ps[rl|ra|ll]w r, #8
 916         case 0x72: // ps[rl|ra|ll]d r, #8
 917         case 0x73: // ps[rl|ra|ll]q r, #8
 918         case 0xC2: // cmp[ps|pd|ss|sd] r, r, r/a, #8
 919         case 0xC4: // pinsrw r, r, r/a, #8
 920         case 0xC5: // pextrw r/a, r, #8
 921         case 0xC6: // shufp[s|d] r, r, r/a, #8
 922           tail_size = 1;  // the imm8
 923           break;
 924         }
 925         break;
 926       case VEX_OPCODE_0F_3A:
 927         tail_size = 1;
 928         break;
 929     }
 930     ip++; // skip opcode
 931     debug_only(has_disp32 = true); // has both kinds of operands!
 932     break;
 933 
 934   case 0x62: // EVEX_4bytes
 935     assert(VM_Version::supports_evex(), &quot;shouldn&#39;t have EVEX prefix&quot;);
 936     assert(ip == inst+1, &quot;no prefixes allowed&quot;);
 937     // no EVEX collisions, all instructions that have 0x62 opcodes
 938     // have EVEX versions and are subopcodes of 0x66
 939     ip++; // skip P0 and exmaine W in P1
 940     is_64bit = ((VEX_W &amp; *ip) == VEX_W);
 941     ip++; // move to P2
 942     ip++; // skip P2, move to opcode
 943     // To find the end of instruction (which == end_pc_operand).
 944     switch (0xFF &amp; *ip) {
 945     case 0x22: // pinsrd r, r/a, #8
 946     case 0x61: // pcmpestri r, r/a, #8
 947     case 0x70: // pshufd r, r/a, #8
 948     case 0x73: // psrldq r, #8
 949       tail_size = 1;  // the imm8
 950       break;
 951     default:
 952       break;
 953     }
 954     ip++; // skip opcode
 955     debug_only(has_disp32 = true); // has both kinds of operands!
 956     break;
 957 
 958   case 0xD1: // sal a, 1; sar a, 1; shl a, 1; shr a, 1
 959   case 0xD3: // sal a, %cl; sar a, %cl; shl a, %cl; shr a, %cl
 960   case 0xD9: // fld_s a; fst_s a; fstp_s a; fldcw a
 961   case 0xDD: // fld_d a; fst_d a; fstp_d a
 962   case 0xDB: // fild_s a; fistp_s a; fld_x a; fstp_x a
 963   case 0xDF: // fild_d a; fistp_d a
 964   case 0xD8: // fadd_s a; fsubr_s a; fmul_s a; fdivr_s a; fcomp_s a
 965   case 0xDC: // fadd_d a; fsubr_d a; fmul_d a; fdivr_d a; fcomp_d a
 966   case 0xDE: // faddp_d a; fsubrp_d a; fmulp_d a; fdivrp_d a; fcompp_d a
 967     debug_only(has_disp32 = true);
 968     break;
 969 
 970   case 0xE8: // call rdisp32
 971   case 0xE9: // jmp  rdisp32
 972     if (which == end_pc_operand)  return ip + 4;
 973     assert(which == call32_operand, &quot;call has no disp32 or imm&quot;);
 974     return ip;
 975 
 976   case 0xF0:                    // Lock
 977     goto again_after_prefix;
 978 
 979   case 0xF3:                    // For SSE
 980   case 0xF2:                    // For SSE2
 981     switch (0xFF &amp; *ip++) {
 982     case REX:
 983     case REX_B:
 984     case REX_X:
 985     case REX_XB:
 986     case REX_R:
 987     case REX_RB:
 988     case REX_RX:
 989     case REX_RXB:
 990     case REX_W:
 991     case REX_WB:
 992     case REX_WX:
 993     case REX_WXB:
 994     case REX_WR:
 995     case REX_WRB:
 996     case REX_WRX:
 997     case REX_WRXB:
 998       NOT_LP64(assert(false, &quot;found 64bit prefix&quot;));
 999       ip++;
1000     default:
1001       ip++;
1002     }
1003     debug_only(has_disp32 = true); // has both kinds of operands!
1004     break;
1005 
1006   default:
1007     ShouldNotReachHere();
1008 
1009 #undef REP8
1010 #undef REP16
1011   }
1012 
1013   assert(which != call32_operand, &quot;instruction is not a call, jmp, or jcc&quot;);
1014 #ifdef _LP64
1015   assert(which != imm_operand, &quot;instruction is not a movq reg, imm64&quot;);
1016 #else
1017   // assert(which != imm_operand || has_imm32, &quot;instruction has no imm32 field&quot;);
1018   assert(which != imm_operand || has_disp32, &quot;instruction has no imm32 field&quot;);
1019 #endif // LP64
1020   assert(which != disp32_operand || has_disp32, &quot;instruction has no disp32 field&quot;);
1021 
1022   // parse the output of emit_operand
1023   int op2 = 0xFF &amp; *ip++;
1024   int base = op2 &amp; 0x07;
1025   int op3 = -1;
1026   const int b100 = 4;
1027   const int b101 = 5;
1028   if (base == b100 &amp;&amp; (op2 &gt;&gt; 6) != 3) {
1029     op3 = 0xFF &amp; *ip++;
1030     base = op3 &amp; 0x07;   // refetch the base
1031   }
1032   // now ip points at the disp (if any)
1033 
1034   switch (op2 &gt;&gt; 6) {
1035   case 0:
1036     // [00 reg  100][ss index base]
1037     // [00 reg  100][00   100  esp]
1038     // [00 reg base]
1039     // [00 reg  100][ss index  101][disp32]
1040     // [00 reg  101]               [disp32]
1041 
1042     if (base == b101) {
1043       if (which == disp32_operand)
1044         return ip;              // caller wants the disp32
1045       ip += 4;                  // skip the disp32
1046     }
1047     break;
1048 
1049   case 1:
1050     // [01 reg  100][ss index base][disp8]
1051     // [01 reg  100][00   100  esp][disp8]
1052     // [01 reg base]               [disp8]
1053     ip += 1;                    // skip the disp8
1054     break;
1055 
1056   case 2:
1057     // [10 reg  100][ss index base][disp32]
1058     // [10 reg  100][00   100  esp][disp32]
1059     // [10 reg base]               [disp32]
1060     if (which == disp32_operand)
1061       return ip;                // caller wants the disp32
1062     ip += 4;                    // skip the disp32
1063     break;
1064 
1065   case 3:
1066     // [11 reg base]  (not a memory addressing mode)
1067     break;
1068   }
1069 
1070   if (which == end_pc_operand) {
1071     return ip + tail_size;
1072   }
1073 
1074 #ifdef _LP64
1075   assert(which == narrow_oop_operand &amp;&amp; !is_64bit, &quot;instruction is not a movl adr, imm32&quot;);
1076 #else
1077   assert(which == imm_operand, &quot;instruction has only an imm field&quot;);
1078 #endif // LP64
1079   return ip;
1080 }
1081 
1082 address Assembler::locate_next_instruction(address inst) {
1083   // Secretly share code with locate_operand:
1084   return locate_operand(inst, end_pc_operand);
1085 }
1086 
1087 
1088 #ifdef ASSERT
1089 void Assembler::check_relocation(RelocationHolder const&amp; rspec, int format) {
1090   address inst = inst_mark();
1091   assert(inst != NULL &amp;&amp; inst &lt; pc(), &quot;must point to beginning of instruction&quot;);
1092   address opnd;
1093 
1094   Relocation* r = rspec.reloc();
1095   if (r-&gt;type() == relocInfo::none) {
1096     return;
1097   } else if (r-&gt;is_call() || format == call32_operand) {
1098     // assert(format == imm32_operand, &quot;cannot specify a nonzero format&quot;);
1099     opnd = locate_operand(inst, call32_operand);
1100   } else if (r-&gt;is_data()) {
1101     assert(format == imm_operand || format == disp32_operand
1102            LP64_ONLY(|| format == narrow_oop_operand), &quot;format ok&quot;);
1103     opnd = locate_operand(inst, (WhichOperand)format);
1104   } else {
1105     assert(format == imm_operand, &quot;cannot specify a format&quot;);
1106     return;
1107   }
1108   assert(opnd == pc(), &quot;must put operand where relocs can find it&quot;);
1109 }
1110 #endif // ASSERT
1111 
1112 void Assembler::emit_operand32(Register reg, Address adr) {
1113   assert(reg-&gt;encoding() &lt; 8, &quot;no extended registers&quot;);
1114   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);
1115   emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,
1116                adr._rspec);
1117 }
1118 
1119 void Assembler::emit_operand(Register reg, Address adr,
1120                              int rip_relative_correction) {
1121   emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,
1122                adr._rspec,
1123                rip_relative_correction);
1124 }
1125 
1126 void Assembler::emit_operand(XMMRegister reg, Address adr) {
1127     if (adr.isxmmindex()) {
1128        emit_operand(reg, adr._base, adr._xmmindex, adr._scale, adr._disp, adr._rspec);
1129     } else {
1130        emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,
1131        adr._rspec);
1132     }
1133 }
1134 
1135 // MMX operations
1136 void Assembler::emit_operand(MMXRegister reg, Address adr) {
1137   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);
1138   emit_operand((Register)reg, adr._base, adr._index, adr._scale, adr._disp, adr._rspec);
1139 }
1140 
1141 // work around gcc (3.2.1-7a) bug
1142 void Assembler::emit_operand(Address adr, MMXRegister reg) {
1143   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);
1144   emit_operand((Register)reg, adr._base, adr._index, adr._scale, adr._disp, adr._rspec);
1145 }
1146 
1147 
1148 void Assembler::emit_farith(int b1, int b2, int i) {
1149   assert(isByte(b1) &amp;&amp; isByte(b2), &quot;wrong opcode&quot;);
1150   assert(0 &lt;= i &amp;&amp;  i &lt; 8, &quot;illegal stack offset&quot;);
1151   emit_int8(b1);
1152   emit_int8(b2 + i);
1153 }
1154 
1155 
1156 // Now the Assembler instructions (identical for 32/64 bits)
1157 
1158 void Assembler::adcl(Address dst, int32_t imm32) {
1159   InstructionMark im(this);
1160   prefix(dst);
1161   emit_arith_operand(0x81, rdx, dst, imm32);
1162 }
1163 
1164 void Assembler::adcl(Address dst, Register src) {
1165   InstructionMark im(this);
1166   prefix(dst, src);
1167   emit_int8(0x11);
1168   emit_operand(src, dst);
1169 }
1170 
1171 void Assembler::adcl(Register dst, int32_t imm32) {
1172   prefix(dst);
1173   emit_arith(0x81, 0xD0, dst, imm32);
1174 }
1175 
1176 void Assembler::adcl(Register dst, Address src) {
1177   InstructionMark im(this);
1178   prefix(src, dst);
1179   emit_int8(0x13);
1180   emit_operand(dst, src);
1181 }
1182 
1183 void Assembler::adcl(Register dst, Register src) {
1184   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1185   emit_arith(0x13, 0xC0, dst, src);
1186 }
1187 
1188 void Assembler::addl(Address dst, int32_t imm32) {
1189   InstructionMark im(this);
1190   prefix(dst);
1191   emit_arith_operand(0x81, rax, dst, imm32);
1192 }
1193 
1194 void Assembler::addb(Address dst, int imm8) {
1195   InstructionMark im(this);
1196   prefix(dst);
1197   emit_int8((unsigned char)0x80);
1198   emit_operand(rax, dst, 1);
1199   emit_int8(imm8);
1200 }
1201 
1202 void Assembler::addw(Address dst, int imm16) {
1203   InstructionMark im(this);
1204   emit_int8(0x66);
1205   prefix(dst);
1206   emit_int8((unsigned char)0x81);
1207   emit_operand(rax, dst, 2);
1208   emit_int16(imm16);
1209 }
1210 
1211 void Assembler::addl(Address dst, Register src) {
1212   InstructionMark im(this);
1213   prefix(dst, src);
1214   emit_int8(0x01);
1215   emit_operand(src, dst);
1216 }
1217 
1218 void Assembler::addl(Register dst, int32_t imm32) {
1219   prefix(dst);
1220   emit_arith(0x81, 0xC0, dst, imm32);
1221 }
1222 
1223 void Assembler::addl(Register dst, Address src) {
1224   InstructionMark im(this);
1225   prefix(src, dst);
1226   emit_int8(0x03);
1227   emit_operand(dst, src);
1228 }
1229 
1230 void Assembler::addl(Register dst, Register src) {
1231   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1232   emit_arith(0x03, 0xC0, dst, src);
1233 }
1234 
1235 void Assembler::addr_nop_4() {
1236   assert(UseAddressNop, &quot;no CPU support&quot;);
1237   // 4 bytes: NOP DWORD PTR [EAX+0]
1238   emit_int8(0x0F);
1239   emit_int8(0x1F);
1240   emit_int8(0x40); // emit_rm(cbuf, 0x1, EAX_enc, EAX_enc);
1241   emit_int8(0);    // 8-bits offset (1 byte)
1242 }
1243 
1244 void Assembler::addr_nop_5() {
1245   assert(UseAddressNop, &quot;no CPU support&quot;);
1246   // 5 bytes: NOP DWORD PTR [EAX+EAX*0+0] 8-bits offset
1247   emit_int8(0x0F);
1248   emit_int8(0x1F);
1249   emit_int8(0x44); // emit_rm(cbuf, 0x1, EAX_enc, 0x4);
1250   emit_int8(0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);
1251   emit_int8(0);    // 8-bits offset (1 byte)
1252 }
1253 
1254 void Assembler::addr_nop_7() {
1255   assert(UseAddressNop, &quot;no CPU support&quot;);
1256   // 7 bytes: NOP DWORD PTR [EAX+0] 32-bits offset
1257   emit_int8(0x0F);
1258   emit_int8(0x1F);
1259   emit_int8((unsigned char)0x80);
1260                    // emit_rm(cbuf, 0x2, EAX_enc, EAX_enc);
1261   emit_int32(0);   // 32-bits offset (4 bytes)
1262 }
1263 
1264 void Assembler::addr_nop_8() {
1265   assert(UseAddressNop, &quot;no CPU support&quot;);
1266   // 8 bytes: NOP DWORD PTR [EAX+EAX*0+0] 32-bits offset
1267   emit_int8(0x0F);
1268   emit_int8(0x1F);
1269   emit_int8((unsigned char)0x84);
1270                    // emit_rm(cbuf, 0x2, EAX_enc, 0x4);
1271   emit_int8(0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);
1272   emit_int32(0);   // 32-bits offset (4 bytes)
1273 }
1274 
1275 void Assembler::addsd(XMMRegister dst, XMMRegister src) {
1276   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1277   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1278   attributes.set_rex_vex_w_reverted();
1279   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1280   emit_int8(0x58);
1281   emit_int8((unsigned char)(0xC0 | encode));
1282 }
1283 
1284 void Assembler::addsd(XMMRegister dst, Address src) {
1285   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1286   InstructionMark im(this);
1287   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1288   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1289   attributes.set_rex_vex_w_reverted();
1290   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1291   emit_int8(0x58);
1292   emit_operand(dst, src);
1293 }
1294 
1295 void Assembler::addss(XMMRegister dst, XMMRegister src) {
1296   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1297   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1298   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1299   emit_int8(0x58);
1300   emit_int8((unsigned char)(0xC0 | encode));
1301 }
1302 
1303 void Assembler::addss(XMMRegister dst, Address src) {
1304   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1305   InstructionMark im(this);
1306   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1307   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1308   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1309   emit_int8(0x58);
1310   emit_operand(dst, src);
1311 }
1312 
1313 void Assembler::aesdec(XMMRegister dst, Address src) {
1314   assert(VM_Version::supports_aes(), &quot;&quot;);
1315   InstructionMark im(this);
1316   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1317   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1318   emit_int8((unsigned char)0xDE);
1319   emit_operand(dst, src);
1320 }
1321 
1322 void Assembler::aesdec(XMMRegister dst, XMMRegister src) {
1323   assert(VM_Version::supports_aes(), &quot;&quot;);
1324   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1325   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1326   emit_int8((unsigned char)0xDE);
1327   emit_int8(0xC0 | encode);
1328 }
1329 
1330 void Assembler::vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1331   assert(VM_Version::supports_avx512_vaes(), &quot;&quot;);
1332   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1333   attributes.set_is_evex_instruction();
1334   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1335   emit_int8((unsigned char)0xDE);
1336   emit_int8((unsigned char)(0xC0 | encode));
1337 }
1338 
1339 
1340 void Assembler::aesdeclast(XMMRegister dst, Address src) {
1341   assert(VM_Version::supports_aes(), &quot;&quot;);
1342   InstructionMark im(this);
1343   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1344   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1345   emit_int8((unsigned char)0xDF);
1346   emit_operand(dst, src);
1347 }
1348 
1349 void Assembler::aesdeclast(XMMRegister dst, XMMRegister src) {
1350   assert(VM_Version::supports_aes(), &quot;&quot;);
1351   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1352   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1353   emit_int8((unsigned char)0xDF);
1354   emit_int8((unsigned char)(0xC0 | encode));
1355 }
1356 
1357 void Assembler::vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1358   assert(VM_Version::supports_avx512_vaes(), &quot;&quot;);
1359   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1360   attributes.set_is_evex_instruction();
1361   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1362   emit_int8((unsigned char)0xDF);
1363   emit_int8((unsigned char)(0xC0 | encode));
1364 }
1365 
1366 void Assembler::aesenc(XMMRegister dst, Address src) {
1367   assert(VM_Version::supports_aes(), &quot;&quot;);
1368   InstructionMark im(this);
1369   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1370   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1371   emit_int8((unsigned char)0xDC);
1372   emit_operand(dst, src);
1373 }
1374 
1375 void Assembler::aesenc(XMMRegister dst, XMMRegister src) {
1376   assert(VM_Version::supports_aes(), &quot;&quot;);
1377   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1378   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1379   emit_int8((unsigned char)0xDC);
1380   emit_int8(0xC0 | encode);
1381 }
1382 
1383 void Assembler::vaesenc(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1384   assert(VM_Version::supports_avx512_vaes(), &quot;requires vaes support/enabling&quot;);
1385   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1386   attributes.set_is_evex_instruction();
1387   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1388   emit_int8((unsigned char)0xDC);
1389   emit_int8((unsigned char)(0xC0 | encode));
1390 }
1391 
1392 void Assembler::aesenclast(XMMRegister dst, Address src) {
1393   assert(VM_Version::supports_aes(), &quot;&quot;);
1394   InstructionMark im(this);
1395   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1396   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1397   emit_int8((unsigned char)0xDD);
1398   emit_operand(dst, src);
1399 }
1400 
1401 void Assembler::aesenclast(XMMRegister dst, XMMRegister src) {
1402   assert(VM_Version::supports_aes(), &quot;&quot;);
1403   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1404   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1405   emit_int8((unsigned char)0xDD);
1406   emit_int8((unsigned char)(0xC0 | encode));
1407 }
1408 
1409 void Assembler::vaesenclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1410   assert(VM_Version::supports_avx512_vaes(), &quot;requires vaes support/enabling&quot;);
1411   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1412   attributes.set_is_evex_instruction();
1413   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1414   emit_int8((unsigned char)0xDD);
1415   emit_int8((unsigned char)(0xC0 | encode));
1416 }
1417 
1418 void Assembler::andl(Address dst, int32_t imm32) {
1419   InstructionMark im(this);
1420   prefix(dst);
1421   emit_int8((unsigned char)0x81);
1422   emit_operand(rsp, dst, 4);
1423   emit_int32(imm32);
1424 }
1425 
1426 void Assembler::andl(Register dst, int32_t imm32) {
1427   prefix(dst);
1428   emit_arith(0x81, 0xE0, dst, imm32);
1429 }
1430 
1431 void Assembler::andl(Register dst, Address src) {
1432   InstructionMark im(this);
1433   prefix(src, dst);
1434   emit_int8(0x23);
1435   emit_operand(dst, src);
1436 }
1437 
1438 void Assembler::andl(Register dst, Register src) {
1439   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1440   emit_arith(0x23, 0xC0, dst, src);
1441 }
1442 
1443 void Assembler::andnl(Register dst, Register src1, Register src2) {
1444   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1445   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1446   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1447   emit_int8((unsigned char)0xF2);
1448   emit_int8((unsigned char)(0xC0 | encode));
1449 }
1450 
1451 void Assembler::andnl(Register dst, Register src1, Address src2) {
1452   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1453   InstructionMark im(this);
1454   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1455   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1456   emit_int8((unsigned char)0xF2);
1457   emit_operand(dst, src2);
1458 }
1459 
1460 void Assembler::bsfl(Register dst, Register src) {
1461   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1462   emit_int8(0x0F);
1463   emit_int8((unsigned char)0xBC);
1464   emit_int8((unsigned char)(0xC0 | encode));
1465 }
1466 
1467 void Assembler::bsrl(Register dst, Register src) {
1468   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1469   emit_int8(0x0F);
1470   emit_int8((unsigned char)0xBD);
1471   emit_int8((unsigned char)(0xC0 | encode));
1472 }
1473 
1474 void Assembler::bswapl(Register reg) { // bswap
1475   int encode = prefix_and_encode(reg-&gt;encoding());
1476   emit_int8(0x0F);
1477   emit_int8((unsigned char)(0xC8 | encode));
1478 }
1479 
1480 void Assembler::blsil(Register dst, Register src) {
1481   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1482   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1483   int encode = vex_prefix_and_encode(rbx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1484   emit_int8((unsigned char)0xF3);
1485   emit_int8((unsigned char)(0xC0 | encode));
1486 }
1487 
1488 void Assembler::blsil(Register dst, Address src) {
1489   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1490   InstructionMark im(this);
1491   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1492   vex_prefix(src, dst-&gt;encoding(), rbx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1493   emit_int8((unsigned char)0xF3);
1494   emit_operand(rbx, src);
1495 }
1496 
1497 void Assembler::blsmskl(Register dst, Register src) {
1498   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1499   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1500   int encode = vex_prefix_and_encode(rdx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1501   emit_int8((unsigned char)0xF3);
1502   emit_int8((unsigned char)(0xC0 | encode));
1503 }
1504 
1505 void Assembler::blsmskl(Register dst, Address src) {
1506   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1507   InstructionMark im(this);
1508   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1509   vex_prefix(src, dst-&gt;encoding(), rdx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1510   emit_int8((unsigned char)0xF3);
1511   emit_operand(rdx, src);
1512 }
1513 
1514 void Assembler::blsrl(Register dst, Register src) {
1515   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1516   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1517   int encode = vex_prefix_and_encode(rcx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1518   emit_int8((unsigned char)0xF3);
1519   emit_int8((unsigned char)(0xC0 | encode));
1520 }
1521 
1522 void Assembler::blsrl(Register dst, Address src) {
1523   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1524   InstructionMark im(this);
1525   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1526   vex_prefix(src, dst-&gt;encoding(), rcx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1527   emit_int8((unsigned char)0xF3);
1528   emit_operand(rcx, src);
1529 }
1530 
1531 void Assembler::call(Label&amp; L, relocInfo::relocType rtype) {
1532   // suspect disp32 is always good
1533   int operand = LP64_ONLY(disp32_operand) NOT_LP64(imm_operand);
1534 
1535   if (L.is_bound()) {
1536     const int long_size = 5;
1537     int offs = (int)( target(L) - pc() );
1538     assert(offs &lt;= 0, &quot;assembler error&quot;);
1539     InstructionMark im(this);
1540     // 1110 1000 #32-bit disp
1541     emit_int8((unsigned char)0xE8);
1542     emit_data(offs - long_size, rtype, operand);
1543   } else {
1544     InstructionMark im(this);
1545     // 1110 1000 #32-bit disp
1546     L.add_patch_at(code(), locator());
1547 
1548     emit_int8((unsigned char)0xE8);
1549     emit_data(int(0), rtype, operand);
1550   }
1551 }
1552 
1553 void Assembler::call(Register dst) {
1554   int encode = prefix_and_encode(dst-&gt;encoding());
1555   emit_int8((unsigned char)0xFF);
1556   emit_int8((unsigned char)(0xD0 | encode));
1557 }
1558 
1559 
1560 void Assembler::call(Address adr) {
1561   InstructionMark im(this);
1562   prefix(adr);
1563   emit_int8((unsigned char)0xFF);
1564   emit_operand(rdx, adr);
1565 }
1566 
1567 void Assembler::call_literal(address entry, RelocationHolder const&amp; rspec) {
1568   InstructionMark im(this);
1569   emit_int8((unsigned char)0xE8);
1570   intptr_t disp = entry - (pc() + sizeof(int32_t));
1571   // Entry is NULL in case of a scratch emit.
1572   assert(entry == NULL || is_simm32(disp), &quot;disp=&quot; INTPTR_FORMAT &quot; must be 32bit offset (call2)&quot;, disp);
1573   // Technically, should use call32_operand, but this format is
1574   // implied by the fact that we&#39;re emitting a call instruction.
1575 
1576   int operand = LP64_ONLY(disp32_operand) NOT_LP64(call32_operand);
1577   emit_data((int) disp, rspec, operand);
1578 }
1579 
1580 void Assembler::cdql() {
1581   emit_int8((unsigned char)0x99);
1582 }
1583 
1584 void Assembler::cld() {
1585   emit_int8((unsigned char)0xFC);
1586 }
1587 
1588 void Assembler::cmovl(Condition cc, Register dst, Register src) {
1589   NOT_LP64(guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;));
1590   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1591   emit_int8(0x0F);
1592   emit_int8(0x40 | cc);
1593   emit_int8((unsigned char)(0xC0 | encode));
1594 }
1595 
1596 
1597 void Assembler::cmovl(Condition cc, Register dst, Address src) {
1598   NOT_LP64(guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;));
1599   prefix(src, dst);
1600   emit_int8(0x0F);
1601   emit_int8(0x40 | cc);
1602   emit_operand(dst, src);
1603 }
1604 
1605 void Assembler::cmpb(Address dst, int imm8) {
1606   InstructionMark im(this);
1607   prefix(dst);
1608   emit_int8((unsigned char)0x80);
1609   emit_operand(rdi, dst, 1);
1610   emit_int8(imm8);
1611 }
1612 
1613 void Assembler::cmpl(Address dst, int32_t imm32) {
1614   InstructionMark im(this);
1615   prefix(dst);
1616   emit_int8((unsigned char)0x81);
1617   emit_operand(rdi, dst, 4);
1618   emit_int32(imm32);
1619 }
1620 
1621 void Assembler::cmpl(Register dst, int32_t imm32) {
1622   prefix(dst);
1623   emit_arith(0x81, 0xF8, dst, imm32);
1624 }
1625 
1626 void Assembler::cmpl(Register dst, Register src) {
1627   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1628   emit_arith(0x3B, 0xC0, dst, src);
1629 }
1630 
1631 void Assembler::cmpl(Register dst, Address  src) {
1632   InstructionMark im(this);
1633   prefix(src, dst);
1634   emit_int8((unsigned char)0x3B);
1635   emit_operand(dst, src);
1636 }
1637 
1638 void Assembler::cmpw(Address dst, int imm16) {
1639   InstructionMark im(this);
1640   assert(!dst.base_needs_rex() &amp;&amp; !dst.index_needs_rex(), &quot;no extended registers&quot;);
1641   emit_int8(0x66);
1642   emit_int8((unsigned char)0x81);
1643   emit_operand(rdi, dst, 2);
1644   emit_int16(imm16);
1645 }
1646 
1647 // The 32-bit cmpxchg compares the value at adr with the contents of rax,
1648 // and stores reg into adr if so; otherwise, the value at adr is loaded into rax,.
1649 // The ZF is set if the compared values were equal, and cleared otherwise.
1650 void Assembler::cmpxchgl(Register reg, Address adr) { // cmpxchg
1651   InstructionMark im(this);
1652   prefix(adr, reg);
1653   emit_int8(0x0F);
1654   emit_int8((unsigned char)0xB1);
1655   emit_operand(reg, adr);
1656 }
1657 
1658 // The 8-bit cmpxchg compares the value at adr with the contents of rax,
1659 // and stores reg into adr if so; otherwise, the value at adr is loaded into rax,.
1660 // The ZF is set if the compared values were equal, and cleared otherwise.
1661 void Assembler::cmpxchgb(Register reg, Address adr) { // cmpxchg
1662   InstructionMark im(this);
1663   prefix(adr, reg, true);
1664   emit_int8(0x0F);
1665   emit_int8((unsigned char)0xB0);
1666   emit_operand(reg, adr);
1667 }
1668 
1669 void Assembler::comisd(XMMRegister dst, Address src) {
1670   // NOTE: dbx seems to decode this as comiss even though the
1671   // 0x66 is there. Strangly ucomisd comes out correct
1672   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1673   InstructionMark im(this);
1674   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);;
1675   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1676   attributes.set_rex_vex_w_reverted();
1677   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
1678   emit_int8(0x2F);
1679   emit_operand(dst, src);
1680 }
1681 
1682 void Assembler::comisd(XMMRegister dst, XMMRegister src) {
1683   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1684   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1685   attributes.set_rex_vex_w_reverted();
1686   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
1687   emit_int8(0x2F);
1688   emit_int8((unsigned char)(0xC0 | encode));
1689 }
1690 
1691 void Assembler::comiss(XMMRegister dst, Address src) {
1692   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1693   InstructionMark im(this);
1694   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1695   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1696   simd_prefix(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
1697   emit_int8(0x2F);
1698   emit_operand(dst, src);
1699 }
1700 
1701 void Assembler::comiss(XMMRegister dst, XMMRegister src) {
1702   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1703   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1704   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
1705   emit_int8(0x2F);
1706   emit_int8((unsigned char)(0xC0 | encode));
1707 }
1708 
1709 void Assembler::cpuid() {
1710   emit_int8(0x0F);
1711   emit_int8((unsigned char)0xA2);
1712 }
1713 
1714 // Opcode / Instruction                      Op /  En  64 - Bit Mode     Compat / Leg Mode Description                  Implemented
1715 // F2 0F 38 F0 / r       CRC32 r32, r / m8   RM        Valid             Valid             Accumulate CRC32 on r / m8.  v
1716 // F2 REX 0F 38 F0 / r   CRC32 r32, r / m8*  RM        Valid             N.E.              Accumulate CRC32 on r / m8.  -
1717 // F2 REX.W 0F 38 F0 / r CRC32 r64, r / m8   RM        Valid             N.E.              Accumulate CRC32 on r / m8.  -
1718 //
1719 // F2 0F 38 F1 / r       CRC32 r32, r / m16  RM        Valid             Valid             Accumulate CRC32 on r / m16. v
1720 //
1721 // F2 0F 38 F1 / r       CRC32 r32, r / m32  RM        Valid             Valid             Accumulate CRC32 on r / m32. v
1722 //
1723 // F2 REX.W 0F 38 F1 / r CRC32 r64, r / m64  RM        Valid             N.E.              Accumulate CRC32 on r / m64. v
1724 void Assembler::crc32(Register crc, Register v, int8_t sizeInBytes) {
1725   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
1726   int8_t w = 0x01;
1727   Prefix p = Prefix_EMPTY;
1728 
1729   emit_int8((int8_t)0xF2);
1730   switch (sizeInBytes) {
1731   case 1:
1732     w = 0;
1733     break;
1734   case 2:
1735   case 4:
1736     break;
1737   LP64_ONLY(case 8:)
1738     // This instruction is not valid in 32 bits
1739     // Note:
1740     // http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf
1741     //
1742     // Page B - 72   Vol. 2C says
1743     // qwreg2 to qwreg            1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : 11 qwreg1 qwreg2
1744     // mem64 to qwreg             1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : mod qwreg r / m
1745     //                                                                            F0!!!
1746     // while 3 - 208 Vol. 2A
1747     // F2 REX.W 0F 38 F1 / r       CRC32 r64, r / m64             RM         Valid      N.E.Accumulate CRC32 on r / m64.
1748     //
1749     // the 0 on a last bit is reserved for a different flavor of this instruction :
1750     // F2 REX.W 0F 38 F0 / r       CRC32 r64, r / m8              RM         Valid      N.E.Accumulate CRC32 on r / m8.
1751     p = REX_W;
1752     break;
1753   default:
1754     assert(0, &quot;Unsupported value for a sizeInBytes argument&quot;);
1755     break;
1756   }
1757   LP64_ONLY(prefix(crc, v, p);)
1758   emit_int8((int8_t)0x0F);
1759   emit_int8(0x38);
1760   emit_int8((int8_t)(0xF0 | w));
1761   emit_int8(0xC0 | ((crc-&gt;encoding() &amp; 0x7) &lt;&lt; 3) | (v-&gt;encoding() &amp; 7));
1762 }
1763 
1764 void Assembler::crc32(Register crc, Address adr, int8_t sizeInBytes) {
1765   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
1766   InstructionMark im(this);
1767   int8_t w = 0x01;
1768   Prefix p = Prefix_EMPTY;
1769 
1770   emit_int8((int8_t)0xF2);
1771   switch (sizeInBytes) {
1772   case 1:
1773     w = 0;
1774     break;
1775   case 2:
1776   case 4:
1777     break;
1778   LP64_ONLY(case 8:)
1779     // This instruction is not valid in 32 bits
1780     p = REX_W;
1781     break;
1782   default:
1783     assert(0, &quot;Unsupported value for a sizeInBytes argument&quot;);
1784     break;
1785   }
1786   LP64_ONLY(prefix(crc, adr, p);)
1787   emit_int8((int8_t)0x0F);
1788   emit_int8(0x38);
1789   emit_int8((int8_t)(0xF0 | w));
1790   emit_operand(crc, adr);
1791 }
1792 
1793 void Assembler::cvtdq2pd(XMMRegister dst, XMMRegister src) {
1794   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1795   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1796   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1797   emit_int8((unsigned char)0xE6);
1798   emit_int8((unsigned char)(0xC0 | encode));
1799 }
1800 
1801 void Assembler::cvtdq2ps(XMMRegister dst, XMMRegister src) {
1802   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1803   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1804   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
1805   emit_int8(0x5B);
1806   emit_int8((unsigned char)(0xC0 | encode));
1807 }
1808 
1809 void Assembler::cvtsd2ss(XMMRegister dst, XMMRegister src) {
1810   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1811   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1812   attributes.set_rex_vex_w_reverted();
1813   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1814   emit_int8(0x5A);
1815   emit_int8((unsigned char)(0xC0 | encode));
1816 }
1817 
1818 void Assembler::cvtsd2ss(XMMRegister dst, Address src) {
1819   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1820   InstructionMark im(this);
1821   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1822   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1823   attributes.set_rex_vex_w_reverted();
1824   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1825   emit_int8(0x5A);
1826   emit_operand(dst, src);
1827 }
1828 
1829 void Assembler::cvtsi2sdl(XMMRegister dst, Register src) {
1830   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1831   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1832   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1833   emit_int8(0x2A);
1834   emit_int8((unsigned char)(0xC0 | encode));
1835 }
1836 
1837 void Assembler::cvtsi2sdl(XMMRegister dst, Address src) {
1838   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1839   InstructionMark im(this);
1840   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1841   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1842   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1843   emit_int8(0x2A);
1844   emit_operand(dst, src);
1845 }
1846 
1847 void Assembler::cvtsi2ssl(XMMRegister dst, Register src) {
1848   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1849   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1850   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1851   emit_int8(0x2A);
1852   emit_int8((unsigned char)(0xC0 | encode));
1853 }
1854 
1855 void Assembler::cvtsi2ssl(XMMRegister dst, Address src) {
1856   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1857   InstructionMark im(this);
1858   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1859   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1860   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1861   emit_int8(0x2A);
1862   emit_operand(dst, src);
1863 }
1864 
1865 void Assembler::cvtsi2ssq(XMMRegister dst, Register src) {
1866   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1867   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1868   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1869   emit_int8(0x2A);
1870   emit_int8((unsigned char)(0xC0 | encode));
1871 }
1872 
1873 void Assembler::cvtss2sd(XMMRegister dst, XMMRegister src) {
1874   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1875   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1876   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1877   emit_int8(0x5A);
1878   emit_int8((unsigned char)(0xC0 | encode));
1879 }
1880 
1881 void Assembler::cvtss2sd(XMMRegister dst, Address src) {
1882   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1883   InstructionMark im(this);
1884   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1885   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1886   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1887   emit_int8(0x5A);
1888   emit_operand(dst, src);
1889 }
1890 
1891 
1892 void Assembler::cvttsd2sil(Register dst, XMMRegister src) {
1893   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1894   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1895   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1896   emit_int8(0x2C);
1897   emit_int8((unsigned char)(0xC0 | encode));
1898 }
1899 
1900 void Assembler::cvttss2sil(Register dst, XMMRegister src) {
1901   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1902   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1903   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1904   emit_int8(0x2C);
1905   emit_int8((unsigned char)(0xC0 | encode));
1906 }
1907 
1908 void Assembler::cvttpd2dq(XMMRegister dst, XMMRegister src) {
1909   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1910   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
1911   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1912   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
1913   emit_int8((unsigned char)0xE6);
1914   emit_int8((unsigned char)(0xC0 | encode));
1915 }
1916 
1917 void Assembler::pabsb(XMMRegister dst, XMMRegister src) {
1918   assert(VM_Version::supports_ssse3(), &quot;&quot;);
1919   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1920   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1921   emit_int8(0x1C);
1922   emit_int8((unsigned char)(0xC0 | encode));
1923 }
1924 
1925 void Assembler::pabsw(XMMRegister dst, XMMRegister src) {
1926   assert(VM_Version::supports_ssse3(), &quot;&quot;);
1927   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1928   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1929   emit_int8(0x1D);
1930   emit_int8((unsigned char)(0xC0 | encode));
1931 }
1932 
1933 void Assembler::pabsd(XMMRegister dst, XMMRegister src) {
1934   assert(VM_Version::supports_ssse3(), &quot;&quot;);
1935   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1936   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1937   emit_int8(0x1E);
1938   emit_int8((unsigned char)(0xC0 | encode));
1939 }
1940 
1941 void Assembler::vpabsb(XMMRegister dst, XMMRegister src, int vector_len) {
1942   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
1943   vector_len == AVX_256bit? VM_Version::supports_avx2() :
1944   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
1945   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1946   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1947   emit_int8((unsigned char)0x1C);
1948   emit_int8((unsigned char)(0xC0 | encode));
1949 }
1950 
1951 void Assembler::vpabsw(XMMRegister dst, XMMRegister src, int vector_len) {
1952   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
1953   vector_len == AVX_256bit? VM_Version::supports_avx2() :
1954   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
1955   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1956   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1957   emit_int8((unsigned char)0x1D);
1958   emit_int8((unsigned char)(0xC0 | encode));
1959 }
1960 
1961 void Assembler::vpabsd(XMMRegister dst, XMMRegister src, int vector_len) {
1962   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
1963   vector_len == AVX_256bit? VM_Version::supports_avx2() :
1964   vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot;&quot;);
1965   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1966   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1967   emit_int8((unsigned char)0x1E);
1968   emit_int8((unsigned char)(0xC0 | encode));
1969 }
1970 
1971 void Assembler::evpabsq(XMMRegister dst, XMMRegister src, int vector_len) {
1972   assert(UseAVX &gt; 2, &quot;&quot;);
1973   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1974   attributes.set_is_evex_instruction();
1975   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1976   emit_int8((unsigned char)0x1F);
1977   emit_int8((unsigned char)(0xC0 | encode));
1978 }
1979 
1980 void Assembler::decl(Address dst) {
1981   // Don&#39;t use it directly. Use MacroAssembler::decrement() instead.
1982   InstructionMark im(this);
1983   prefix(dst);
1984   emit_int8((unsigned char)0xFF);
1985   emit_operand(rcx, dst);
1986 }
1987 
1988 void Assembler::divsd(XMMRegister dst, Address src) {
1989   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1990   InstructionMark im(this);
1991   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1992   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1993   attributes.set_rex_vex_w_reverted();
1994   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1995   emit_int8(0x5E);
1996   emit_operand(dst, src);
1997 }
1998 
1999 void Assembler::divsd(XMMRegister dst, XMMRegister src) {
2000   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2001   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2002   attributes.set_rex_vex_w_reverted();
2003   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2004   emit_int8(0x5E);
2005   emit_int8((unsigned char)(0xC0 | encode));
2006 }
2007 
2008 void Assembler::divss(XMMRegister dst, Address src) {
2009   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2010   InstructionMark im(this);
2011   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2012   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2013   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2014   emit_int8(0x5E);
2015   emit_operand(dst, src);
2016 }
2017 
2018 void Assembler::divss(XMMRegister dst, XMMRegister src) {
2019   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2020   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2021   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2022   emit_int8(0x5E);
2023   emit_int8((unsigned char)(0xC0 | encode));
2024 }
2025 
2026 void Assembler::emms() {
2027   NOT_LP64(assert(VM_Version::supports_mmx(), &quot;&quot;));
2028   emit_int8(0x0F);
2029   emit_int8(0x77);
2030 }
2031 
2032 void Assembler::hlt() {
2033   emit_int8((unsigned char)0xF4);
2034 }
2035 
2036 void Assembler::idivl(Register src) {
2037   int encode = prefix_and_encode(src-&gt;encoding());
2038   emit_int8((unsigned char)0xF7);
2039   emit_int8((unsigned char)(0xF8 | encode));
2040 }
2041 
2042 void Assembler::divl(Register src) { // Unsigned
2043   int encode = prefix_and_encode(src-&gt;encoding());
2044   emit_int8((unsigned char)0xF7);
2045   emit_int8((unsigned char)(0xF0 | encode));
2046 }
2047 
2048 void Assembler::imull(Register src) {
2049   int encode = prefix_and_encode(src-&gt;encoding());
2050   emit_int8((unsigned char)0xF7);
2051   emit_int8((unsigned char)(0xE8 | encode));
2052 }
2053 
2054 void Assembler::imull(Register dst, Register src) {
2055   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
2056   emit_int8(0x0F);
2057   emit_int8((unsigned char)0xAF);
2058   emit_int8((unsigned char)(0xC0 | encode));
2059 }
2060 
2061 
2062 void Assembler::imull(Register dst, Register src, int value) {
2063   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
2064   if (is8bit(value)) {
2065     emit_int8(0x6B);
2066     emit_int8((unsigned char)(0xC0 | encode));
2067     emit_int8(value &amp; 0xFF);
2068   } else {
2069     emit_int8(0x69);
2070     emit_int8((unsigned char)(0xC0 | encode));
2071     emit_int32(value);
2072   }
2073 }
2074 
2075 void Assembler::imull(Register dst, Address src) {
2076   InstructionMark im(this);
2077   prefix(src, dst);
2078   emit_int8(0x0F);
2079   emit_int8((unsigned char) 0xAF);
2080   emit_operand(dst, src);
2081 }
2082 
2083 
2084 void Assembler::incl(Address dst) {
2085   // Don&#39;t use it directly. Use MacroAssembler::increment() instead.
2086   InstructionMark im(this);
2087   prefix(dst);
2088   emit_int8((unsigned char)0xFF);
2089   emit_operand(rax, dst);
2090 }
2091 
2092 void Assembler::jcc(Condition cc, Label&amp; L, bool maybe_short) {
2093   InstructionMark im(this);
2094   assert((0 &lt;= cc) &amp;&amp; (cc &lt; 16), &quot;illegal cc&quot;);
2095   if (L.is_bound()) {
2096     address dst = target(L);
2097     assert(dst != NULL, &quot;jcc most probably wrong&quot;);
2098 
2099     const int short_size = 2;
2100     const int long_size = 6;
2101     intptr_t offs = (intptr_t)dst - (intptr_t)pc();
2102     if (maybe_short &amp;&amp; is8bit(offs - short_size)) {
2103       // 0111 tttn #8-bit disp
2104       emit_int8(0x70 | cc);
2105       emit_int8((offs - short_size) &amp; 0xFF);
2106     } else {
2107       // 0000 1111 1000 tttn #32-bit disp
2108       assert(is_simm32(offs - long_size),
2109              &quot;must be 32bit offset (call4)&quot;);
2110       emit_int8(0x0F);
2111       emit_int8((unsigned char)(0x80 | cc));
2112       emit_int32(offs - long_size);
2113     }
2114   } else {
2115     // Note: could eliminate cond. jumps to this jump if condition
2116     //       is the same however, seems to be rather unlikely case.
2117     // Note: use jccb() if label to be bound is very close to get
2118     //       an 8-bit displacement
2119     L.add_patch_at(code(), locator());
2120     emit_int8(0x0F);
2121     emit_int8((unsigned char)(0x80 | cc));
2122     emit_int32(0);
2123   }
2124 }
2125 
2126 void Assembler::jccb_0(Condition cc, Label&amp; L, const char* file, int line) {
2127   if (L.is_bound()) {
2128     const int short_size = 2;
2129     address entry = target(L);
2130 #ifdef ASSERT
2131     intptr_t dist = (intptr_t)entry - ((intptr_t)pc() + short_size);
2132     intptr_t delta = short_branch_delta();
2133     if (delta != 0) {
2134       dist += (dist &lt; 0 ? (-delta) :delta);
2135     }
2136     assert(is8bit(dist), &quot;Dispacement too large for a short jmp at %s:%d&quot;, file, line);
2137 #endif
2138     intptr_t offs = (intptr_t)entry - (intptr_t)pc();
2139     // 0111 tttn #8-bit disp
2140     emit_int8(0x70 | cc);
2141     emit_int8((offs - short_size) &amp; 0xFF);
2142   } else {
2143     InstructionMark im(this);
2144     L.add_patch_at(code(), locator(), file, line);
2145     emit_int8(0x70 | cc);
2146     emit_int8(0);
2147   }
2148 }
2149 
2150 void Assembler::jmp(Address adr) {
2151   InstructionMark im(this);
2152   prefix(adr);
2153   emit_int8((unsigned char)0xFF);
2154   emit_operand(rsp, adr);
2155 }
2156 
2157 void Assembler::jmp(Label&amp; L, bool maybe_short) {
2158   if (L.is_bound()) {
2159     address entry = target(L);
2160     assert(entry != NULL, &quot;jmp most probably wrong&quot;);
2161     InstructionMark im(this);
2162     const int short_size = 2;
2163     const int long_size = 5;
2164     intptr_t offs = entry - pc();
2165     if (maybe_short &amp;&amp; is8bit(offs - short_size)) {
2166       emit_int8((unsigned char)0xEB);
2167       emit_int8((offs - short_size) &amp; 0xFF);
2168     } else {
2169       emit_int8((unsigned char)0xE9);
2170       emit_int32(offs - long_size);
2171     }
2172   } else {
2173     // By default, forward jumps are always 32-bit displacements, since
2174     // we can&#39;t yet know where the label will be bound.  If you&#39;re sure that
2175     // the forward jump will not run beyond 256 bytes, use jmpb to
2176     // force an 8-bit displacement.
2177     InstructionMark im(this);
2178     L.add_patch_at(code(), locator());
2179     emit_int8((unsigned char)0xE9);
2180     emit_int32(0);
2181   }
2182 }
2183 
2184 void Assembler::jmp(Register entry) {
2185   int encode = prefix_and_encode(entry-&gt;encoding());
2186   emit_int8((unsigned char)0xFF);
2187   emit_int8((unsigned char)(0xE0 | encode));
2188 }
2189 
2190 void Assembler::jmp_literal(address dest, RelocationHolder const&amp; rspec) {
2191   InstructionMark im(this);
2192   emit_int8((unsigned char)0xE9);
2193   assert(dest != NULL, &quot;must have a target&quot;);
2194   intptr_t disp = dest - (pc() + sizeof(int32_t));
2195   assert(is_simm32(disp), &quot;must be 32bit offset (jmp)&quot;);
2196   emit_data(disp, rspec.reloc(), call32_operand);
2197 }
2198 
2199 void Assembler::jmpb_0(Label&amp; L, const char* file, int line) {
2200   if (L.is_bound()) {
2201     const int short_size = 2;
2202     address entry = target(L);
2203     assert(entry != NULL, &quot;jmp most probably wrong&quot;);
2204 #ifdef ASSERT
2205     intptr_t dist = (intptr_t)entry - ((intptr_t)pc() + short_size);
2206     intptr_t delta = short_branch_delta();
2207     if (delta != 0) {
2208       dist += (dist &lt; 0 ? (-delta) :delta);
2209     }
2210     assert(is8bit(dist), &quot;Dispacement too large for a short jmp at %s:%d&quot;, file, line);
2211 #endif
2212     intptr_t offs = entry - pc();
2213     emit_int8((unsigned char)0xEB);
2214     emit_int8((offs - short_size) &amp; 0xFF);
2215   } else {
2216     InstructionMark im(this);
2217     L.add_patch_at(code(), locator(), file, line);
2218     emit_int8((unsigned char)0xEB);
2219     emit_int8(0);
2220   }
2221 }
2222 
2223 void Assembler::ldmxcsr( Address src) {
2224   if (UseAVX &gt; 0 ) {
2225     InstructionMark im(this);
2226     InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2227     vex_prefix(src, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2228     emit_int8((unsigned char)0xAE);
2229     emit_operand(as_Register(2), src);
2230   } else {
2231     NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2232     InstructionMark im(this);
2233     prefix(src);
2234     emit_int8(0x0F);
2235     emit_int8((unsigned char)0xAE);
2236     emit_operand(as_Register(2), src);
2237   }
2238 }
2239 
2240 void Assembler::leal(Register dst, Address src) {
2241   InstructionMark im(this);
2242 #ifdef _LP64
2243   emit_int8(0x67); // addr32
2244   prefix(src, dst);
2245 #endif // LP64
2246   emit_int8((unsigned char)0x8D);
2247   emit_operand(dst, src);
2248 }
2249 
2250 void Assembler::lfence() {
2251   emit_int8(0x0F);
2252   emit_int8((unsigned char)0xAE);
2253   emit_int8((unsigned char)0xE8);
2254 }
2255 
2256 void Assembler::lock() {
2257   emit_int8((unsigned char)0xF0);
2258 }
2259 
2260 void Assembler::lzcntl(Register dst, Register src) {
2261   assert(VM_Version::supports_lzcnt(), &quot;encoding is treated as BSR&quot;);
2262   emit_int8((unsigned char)0xF3);
2263   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
2264   emit_int8(0x0F);
2265   emit_int8((unsigned char)0xBD);
2266   emit_int8((unsigned char)(0xC0 | encode));
2267 }
2268 
2269 // Emit mfence instruction
2270 void Assembler::mfence() {
2271   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)
2272   emit_int8(0x0F);
2273   emit_int8((unsigned char)0xAE);
2274   emit_int8((unsigned char)0xF0);
2275 }
2276 
2277 // Emit sfence instruction
2278 void Assembler::sfence() {
2279   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)
2280   emit_int8(0x0F);
2281   emit_int8((unsigned char)0xAE);
2282   emit_int8((unsigned char)0xF8);
2283 }
2284 
2285 void Assembler::mov(Register dst, Register src) {
2286   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2287 }
2288 
2289 void Assembler::movapd(XMMRegister dst, XMMRegister src) {
2290   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2291   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
2292   InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2293   attributes.set_rex_vex_w_reverted();
2294   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2295   emit_int8(0x28);
2296   emit_int8((unsigned char)(0xC0 | encode));
2297 }
2298 
2299 void Assembler::movaps(XMMRegister dst, XMMRegister src) {
2300   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2301   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
2302   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2303   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2304   emit_int8(0x28);
2305   emit_int8((unsigned char)(0xC0 | encode));
2306 }
2307 
2308 void Assembler::movlhps(XMMRegister dst, XMMRegister src) {
2309   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2310   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2311   int encode = simd_prefix_and_encode(dst, src, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2312   emit_int8(0x16);
2313   emit_int8((unsigned char)(0xC0 | encode));
2314 }
2315 
2316 void Assembler::movb(Register dst, Address src) {
2317   NOT_LP64(assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;));
2318   InstructionMark im(this);
2319   prefix(src, dst, true);
2320   emit_int8((unsigned char)0x8A);
2321   emit_operand(dst, src);
2322 }
2323 
2324 void Assembler::movddup(XMMRegister dst, XMMRegister src) {
2325   NOT_LP64(assert(VM_Version::supports_sse3(), &quot;&quot;));
2326   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
2327   InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2328   attributes.set_rex_vex_w_reverted();
2329   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2330   emit_int8(0x12);
2331   emit_int8(0xC0 | encode);
2332 }
2333 
2334 void Assembler::kmovbl(KRegister dst, Register src) {
2335   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
2336   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2337   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2338   emit_int8((unsigned char)0x92);
2339   emit_int8((unsigned char)(0xC0 | encode));
2340 }
2341 
2342 void Assembler::kmovbl(Register dst, KRegister src) {
2343   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
2344   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2345   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2346   emit_int8((unsigned char)0x93);
2347   emit_int8((unsigned char)(0xC0 | encode));
2348 }
2349 
2350 void Assembler::kmovwl(KRegister dst, Register src) {
2351   assert(VM_Version::supports_evex(), &quot;&quot;);
2352   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2353   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2354   emit_int8((unsigned char)0x92);
2355   emit_int8((unsigned char)(0xC0 | encode));
2356 }
2357 
2358 void Assembler::kmovwl(Register dst, KRegister src) {
2359   assert(VM_Version::supports_evex(), &quot;&quot;);
2360   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2361   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2362   emit_int8((unsigned char)0x93);
2363   emit_int8((unsigned char)(0xC0 | encode));
2364 }
2365 
2366 void Assembler::kmovwl(KRegister dst, Address src) {
2367   assert(VM_Version::supports_evex(), &quot;&quot;);
2368   InstructionMark im(this);
2369   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2370   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2371   emit_int8((unsigned char)0x90);
2372   emit_operand((Register)dst, src);
2373 }
2374 
2375 void Assembler::kmovdl(KRegister dst, Register src) {
2376   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2377   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2378   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2379   emit_int8((unsigned char)0x92);
2380   emit_int8((unsigned char)(0xC0 | encode));
2381 }
2382 
2383 void Assembler::kmovdl(Register dst, KRegister src) {
2384   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2385   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2386   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2387   emit_int8((unsigned char)0x93);
2388   emit_int8((unsigned char)(0xC0 | encode));
2389 }
2390 
2391 void Assembler::kmovql(KRegister dst, KRegister src) {
2392   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2393   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2394   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2395   emit_int8((unsigned char)0x90);
2396   emit_int8((unsigned char)(0xC0 | encode));
2397 }
2398 
2399 void Assembler::kmovql(KRegister dst, Address src) {
2400   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2401   InstructionMark im(this);
2402   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2403   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2404   emit_int8((unsigned char)0x90);
2405   emit_operand((Register)dst, src);
2406 }
2407 
2408 void Assembler::kmovql(Address dst, KRegister src) {
2409   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2410   InstructionMark im(this);
2411   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2412   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2413   emit_int8((unsigned char)0x90);
2414   emit_operand((Register)src, dst);
2415 }
2416 
2417 void Assembler::kmovql(KRegister dst, Register src) {
2418   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2419   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2420   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2421   emit_int8((unsigned char)0x92);
2422   emit_int8((unsigned char)(0xC0 | encode));
2423 }
2424 
2425 void Assembler::kmovql(Register dst, KRegister src) {
2426   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2427   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2428   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2429   emit_int8((unsigned char)0x93);
2430   emit_int8((unsigned char)(0xC0 | encode));
2431 }
2432 
2433 void Assembler::knotwl(KRegister dst, KRegister src) {
2434   assert(VM_Version::supports_evex(), &quot;&quot;);
2435   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2436   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2437   emit_int8((unsigned char)0x44);
2438   emit_int8((unsigned char)(0xC0 | encode));
2439 }
2440 
2441 // This instruction produces ZF or CF flags
2442 void Assembler::kortestbl(KRegister src1, KRegister src2) {
2443   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
2444   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2445   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2446   emit_int8((unsigned char)0x98);
2447   emit_int8((unsigned char)(0xC0 | encode));
2448 }
2449 
2450 // This instruction produces ZF or CF flags
2451 void Assembler::kortestwl(KRegister src1, KRegister src2) {
2452   assert(VM_Version::supports_evex(), &quot;&quot;);
2453   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2454   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2455   emit_int8((unsigned char)0x98);
2456   emit_int8((unsigned char)(0xC0 | encode));
2457 }
2458 
2459 // This instruction produces ZF or CF flags
2460 void Assembler::kortestdl(KRegister src1, KRegister src2) {
2461   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2462   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2463   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2464   emit_int8((unsigned char)0x98);
2465   emit_int8((unsigned char)(0xC0 | encode));
2466 }
2467 
2468 // This instruction produces ZF or CF flags
2469 void Assembler::kortestql(KRegister src1, KRegister src2) {
2470   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2471   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2472   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2473   emit_int8((unsigned char)0x98);
2474   emit_int8((unsigned char)(0xC0 | encode));
2475 }
2476 
2477 // This instruction produces ZF or CF flags
2478 void Assembler::ktestql(KRegister src1, KRegister src2) {
2479   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2480   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2481   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2482   emit_int8((unsigned char)0x99);
2483   emit_int8((unsigned char)(0xC0 | encode));
2484 }
2485 
2486 void Assembler::ktestq(KRegister src1, KRegister src2) {
2487   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2488   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2489   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2490   emit_int8((unsigned char)0x99);
2491   emit_int8((unsigned char)(0xC0 | encode));
2492 }
2493 
2494 void Assembler::ktestd(KRegister src1, KRegister src2) {
2495   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2496   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2497   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2498   emit_int8((unsigned char)0x99);
2499   emit_int8((unsigned char)(0xC0 | encode));
2500 }
2501 
2502 void Assembler::movb(Address dst, int imm8) {
2503   InstructionMark im(this);
2504    prefix(dst);
2505   emit_int8((unsigned char)0xC6);
2506   emit_operand(rax, dst, 1);
2507   emit_int8(imm8);
2508 }
2509 
2510 
2511 void Assembler::movb(Address dst, Register src) {
2512   assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;);
2513   InstructionMark im(this);
2514   prefix(dst, src, true);
2515   emit_int8((unsigned char)0x88);
2516   emit_operand(src, dst);
2517 }
2518 
2519 void Assembler::movdl(XMMRegister dst, Register src) {
2520   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2521   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2522   int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2523   emit_int8(0x6E);
2524   emit_int8((unsigned char)(0xC0 | encode));
2525 }
2526 
2527 void Assembler::movdl(Register dst, XMMRegister src) {
2528   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2529   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2530   // swap src/dst to get correct prefix
2531   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2532   emit_int8(0x7E);
2533   emit_int8((unsigned char)(0xC0 | encode));
2534 }
2535 
2536 void Assembler::movdl(XMMRegister dst, Address src) {
2537   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2538   InstructionMark im(this);
2539   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2540   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2541   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2542   emit_int8(0x6E);
2543   emit_operand(dst, src);
2544 }
2545 
2546 void Assembler::movdl(Address dst, XMMRegister src) {
2547   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2548   InstructionMark im(this);
2549   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2550   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2551   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2552   emit_int8(0x7E);
2553   emit_operand(src, dst);
2554 }
2555 
2556 void Assembler::movdqa(XMMRegister dst, XMMRegister src) {
2557   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2558   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2559   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2560   emit_int8(0x6F);
2561   emit_int8((unsigned char)(0xC0 | encode));
2562 }
2563 
2564 void Assembler::movdqa(XMMRegister dst, Address src) {
2565   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2566   InstructionMark im(this);
2567   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2568   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2569   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2570   emit_int8(0x6F);
2571   emit_operand(dst, src);
2572 }
2573 
2574 void Assembler::movdqu(XMMRegister dst, Address src) {
2575   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2576   InstructionMark im(this);
2577   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2578   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2579   simd_prefix(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2580   emit_int8(0x6F);
2581   emit_operand(dst, src);
2582 }
2583 
2584 void Assembler::movdqu(XMMRegister dst, XMMRegister src) {
2585   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2586   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2587   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2588   emit_int8(0x6F);
2589   emit_int8((unsigned char)(0xC0 | encode));
2590 }
2591 
2592 void Assembler::movdqu(Address dst, XMMRegister src) {
2593   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2594   InstructionMark im(this);
2595   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2596   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2597   attributes.reset_is_clear_context();
2598   simd_prefix(src, xnoreg, dst, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2599   emit_int8(0x7F);
2600   emit_operand(src, dst);
2601 }
2602 
2603 // Move Unaligned 256bit Vector
2604 void Assembler::vmovdqu(XMMRegister dst, XMMRegister src) {
2605   assert(UseAVX &gt; 0, &quot;&quot;);
2606   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2607   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2608   emit_int8(0x6F);
2609   emit_int8((unsigned char)(0xC0 | encode));
2610 }
2611 
2612 void Assembler::vmovdqu(XMMRegister dst, Address src) {
2613   assert(UseAVX &gt; 0, &quot;&quot;);
2614   InstructionMark im(this);
2615   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2616   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2617   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2618   emit_int8(0x6F);
2619   emit_operand(dst, src);
2620 }
2621 
2622 void Assembler::vmovdqu(Address dst, XMMRegister src) {
2623   assert(UseAVX &gt; 0, &quot;&quot;);
2624   InstructionMark im(this);
2625   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2626   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2627   attributes.reset_is_clear_context();
2628   // swap src&lt;-&gt;dst for encoding
2629   assert(src != xnoreg, &quot;sanity&quot;);
2630   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2631   emit_int8(0x7F);
2632   emit_operand(src, dst);
2633 }
2634 
2635 // Move Unaligned EVEX enabled Vector (programmable : 8,16,32,64)
2636 void Assembler::evmovdqub(XMMRegister dst, XMMRegister src, int vector_len) {
2637   assert(VM_Version::supports_evex(), &quot;&quot;);
2638   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2639   attributes.set_is_evex_instruction();
2640   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
2641   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
2642   emit_int8(0x6F);
2643   emit_int8((unsigned char)(0xC0 | encode));
2644 }
2645 
2646 void Assembler::evmovdqub(XMMRegister dst, Address src, int vector_len) {
2647   assert(VM_Version::supports_evex(), &quot;&quot;);
2648   InstructionMark im(this);
2649   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2650   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
2651   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2652   attributes.set_is_evex_instruction();
2653   vex_prefix(src, 0, dst-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
2654   emit_int8(0x6F);
2655   emit_operand(dst, src);
2656 }
2657 
2658 void Assembler::evmovdqub(Address dst, XMMRegister src, int vector_len) {
2659   assert(VM_Version::supports_evex(), &quot;&quot;);
2660   assert(src != xnoreg, &quot;sanity&quot;);
2661   InstructionMark im(this);
2662   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2663   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
2664   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2665   attributes.set_is_evex_instruction();
2666   vex_prefix(dst, 0, src-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
2667   emit_int8(0x7F);
2668   emit_operand(src, dst);
2669 }
2670 
2671 void Assembler::evmovdqub(XMMRegister dst, KRegister mask, Address src, int vector_len) {
2672   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
2673   InstructionMark im(this);
2674   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
2675   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2676   attributes.set_embedded_opmask_register_specifier(mask);
2677   attributes.set_is_evex_instruction();
2678   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2679   emit_int8(0x6F);
2680   emit_operand(dst, src);
2681 }
2682 
2683 void Assembler::evmovdquw(XMMRegister dst, Address src, int vector_len) {
2684   assert(VM_Version::supports_evex(), &quot;&quot;);
2685   InstructionMark im(this);
2686   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2687   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2688   attributes.set_is_evex_instruction();
2689   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
2690   vex_prefix(src, 0, dst-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
2691   emit_int8(0x6F);
2692   emit_operand(dst, src);
2693 }
2694 
2695 void Assembler::evmovdquw(XMMRegister dst, KRegister mask, Address src, int vector_len) {
2696   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
2697   InstructionMark im(this);
2698   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
2699   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2700   attributes.set_embedded_opmask_register_specifier(mask);
2701   attributes.set_is_evex_instruction();
2702   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2703   emit_int8(0x6F);
2704   emit_operand(dst, src);
2705 }
2706 
2707 void Assembler::evmovdquw(Address dst, XMMRegister src, int vector_len) {
2708   assert(VM_Version::supports_evex(), &quot;&quot;);
2709   assert(src != xnoreg, &quot;sanity&quot;);
2710   InstructionMark im(this);
2711   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2712   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2713   attributes.set_is_evex_instruction();
2714   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
2715   vex_prefix(dst, 0, src-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
2716   emit_int8(0x7F);
2717   emit_operand(src, dst);
2718 }
2719 
2720 void Assembler::evmovdquw(Address dst, KRegister mask, XMMRegister src, int vector_len) {
2721   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
2722   assert(src != xnoreg, &quot;sanity&quot;);
2723   InstructionMark im(this);
2724   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
2725   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2726   attributes.reset_is_clear_context();
2727   attributes.set_embedded_opmask_register_specifier(mask);
2728   attributes.set_is_evex_instruction();
2729   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2730   emit_int8(0x7F);
2731   emit_operand(src, dst);
2732 }
2733 
2734 void Assembler::evmovdqul(XMMRegister dst, XMMRegister src, int vector_len) {
2735   assert(VM_Version::supports_evex(), &quot;&quot;);
2736   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2737   attributes.set_is_evex_instruction();
2738   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2739   emit_int8(0x6F);
2740   emit_int8((unsigned char)(0xC0 | encode));
2741 }
2742 
2743 void Assembler::evmovdqul(XMMRegister dst, Address src, int vector_len) {
2744   assert(VM_Version::supports_evex(), &quot;&quot;);
2745   InstructionMark im(this);
2746   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true , /* uses_vl */ true);
2747   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2748   attributes.set_is_evex_instruction();
2749   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2750   emit_int8(0x6F);
2751   emit_operand(dst, src);
2752 }
2753 
2754 void Assembler::evmovdqul(Address dst, XMMRegister src, int vector_len) {
2755   assert(VM_Version::supports_evex(), &quot;&quot;);
2756   assert(src != xnoreg, &quot;sanity&quot;);
2757   InstructionMark im(this);
2758   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2759   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2760   attributes.reset_is_clear_context();
2761   attributes.set_is_evex_instruction();
2762   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2763   emit_int8(0x7F);
2764   emit_operand(src, dst);
2765 }
2766 
2767 void Assembler::evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) {
2768   assert(VM_Version::supports_evex(), &quot;&quot;);
2769   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2770   attributes.set_is_evex_instruction();
2771   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2772   emit_int8(0x6F);
2773   emit_int8((unsigned char)(0xC0 | encode));
2774 }
2775 
2776 void Assembler::evmovdquq(XMMRegister dst, Address src, int vector_len) {
2777   assert(VM_Version::supports_evex(), &quot;&quot;);
2778   InstructionMark im(this);
2779   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2780   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2781   attributes.set_is_evex_instruction();
2782   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2783   emit_int8(0x6F);
2784   emit_operand(dst, src);
2785 }
2786 
2787 void Assembler::evmovdquq(Address dst, XMMRegister src, int vector_len) {
2788   assert(VM_Version::supports_evex(), &quot;&quot;);
2789   assert(src != xnoreg, &quot;sanity&quot;);
2790   InstructionMark im(this);
2791   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2792   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2793   attributes.reset_is_clear_context();
2794   attributes.set_is_evex_instruction();
2795   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2796   emit_int8(0x7F);
2797   emit_operand(src, dst);
2798 }
2799 
2800 // Uses zero extension on 64bit
2801 
2802 void Assembler::movl(Register dst, int32_t imm32) {
2803   int encode = prefix_and_encode(dst-&gt;encoding());
2804   emit_int8((unsigned char)(0xB8 | encode));
2805   emit_int32(imm32);
2806 }
2807 
2808 void Assembler::movl(Register dst, Register src) {
2809   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
2810   emit_int8((unsigned char)0x8B);
2811   emit_int8((unsigned char)(0xC0 | encode));
2812 }
2813 
2814 void Assembler::movl(Register dst, Address src) {
2815   InstructionMark im(this);
2816   prefix(src, dst);
2817   emit_int8((unsigned char)0x8B);
2818   emit_operand(dst, src);
2819 }
2820 
2821 void Assembler::movl(Address dst, int32_t imm32) {
2822   InstructionMark im(this);
2823   prefix(dst);
2824   emit_int8((unsigned char)0xC7);
2825   emit_operand(rax, dst, 4);
2826   emit_int32(imm32);
2827 }
2828 
2829 void Assembler::movl(Address dst, Register src) {
2830   InstructionMark im(this);
2831   prefix(dst, src);
2832   emit_int8((unsigned char)0x89);
2833   emit_operand(src, dst);
2834 }
2835 
2836 // New cpus require to use movsd and movss to avoid partial register stall
2837 // when loading from memory. But for old Opteron use movlpd instead of movsd.
2838 // The selection is done in MacroAssembler::movdbl() and movflt().
2839 void Assembler::movlpd(XMMRegister dst, Address src) {
2840   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2841   InstructionMark im(this);
2842   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2843   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2844   attributes.set_rex_vex_w_reverted();
2845   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2846   emit_int8(0x12);
2847   emit_operand(dst, src);
2848 }
2849 
2850 void Assembler::movq( MMXRegister dst, Address src ) {
2851   assert( VM_Version::supports_mmx(), &quot;&quot; );
2852   emit_int8(0x0F);
2853   emit_int8(0x6F);
2854   emit_operand(dst, src);
2855 }
2856 
2857 void Assembler::movq( Address dst, MMXRegister src ) {
2858   assert( VM_Version::supports_mmx(), &quot;&quot; );
2859   emit_int8(0x0F);
2860   emit_int8(0x7F);
2861   // workaround gcc (3.2.1-7a) bug
2862   // In that version of gcc with only an emit_operand(MMX, Address)
2863   // gcc will tail jump and try and reverse the parameters completely
2864   // obliterating dst in the process. By having a version available
2865   // that doesn&#39;t need to swap the args at the tail jump the bug is
2866   // avoided.
2867   emit_operand(dst, src);
2868 }
2869 
2870 void Assembler::movq(XMMRegister dst, Address src) {
2871   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2872   InstructionMark im(this);
2873   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2874   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2875   attributes.set_rex_vex_w_reverted();
2876   simd_prefix(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2877   emit_int8(0x7E);
2878   emit_operand(dst, src);
2879 }
2880 
2881 void Assembler::movq(Address dst, XMMRegister src) {
2882   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2883   InstructionMark im(this);
2884   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2885   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2886   attributes.set_rex_vex_w_reverted();
2887   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2888   emit_int8((unsigned char)0xD6);
2889   emit_operand(src, dst);
2890 }
2891 
2892 void Assembler::movsbl(Register dst, Address src) { // movsxb
2893   InstructionMark im(this);
2894   prefix(src, dst);
2895   emit_int8(0x0F);
2896   emit_int8((unsigned char)0xBE);
2897   emit_operand(dst, src);
2898 }
2899 
2900 void Assembler::movsbl(Register dst, Register src) { // movsxb
2901   NOT_LP64(assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;));
2902   int encode = prefix_and_encode(dst-&gt;encoding(), false, src-&gt;encoding(), true);
2903   emit_int8(0x0F);
2904   emit_int8((unsigned char)0xBE);
2905   emit_int8((unsigned char)(0xC0 | encode));
2906 }
2907 
2908 void Assembler::movsd(XMMRegister dst, XMMRegister src) {
2909   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2910   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2911   attributes.set_rex_vex_w_reverted();
2912   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2913   emit_int8(0x10);
2914   emit_int8((unsigned char)(0xC0 | encode));
2915 }
2916 
2917 void Assembler::movsd(XMMRegister dst, Address src) {
2918   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2919   InstructionMark im(this);
2920   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2921   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2922   attributes.set_rex_vex_w_reverted();
2923   simd_prefix(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2924   emit_int8(0x10);
2925   emit_operand(dst, src);
2926 }
2927 
2928 void Assembler::movsd(Address dst, XMMRegister src) {
2929   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2930   InstructionMark im(this);
2931   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2932   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2933   attributes.reset_is_clear_context();
2934   attributes.set_rex_vex_w_reverted();
2935   simd_prefix(src, xnoreg, dst, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2936   emit_int8(0x11);
2937   emit_operand(src, dst);
2938 }
2939 
2940 void Assembler::movss(XMMRegister dst, XMMRegister src) {
2941   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2942   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2943   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2944   emit_int8(0x10);
2945   emit_int8((unsigned char)(0xC0 | encode));
2946 }
2947 
2948 void Assembler::movss(XMMRegister dst, Address src) {
2949   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2950   InstructionMark im(this);
2951   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2952   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2953   simd_prefix(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2954   emit_int8(0x10);
2955   emit_operand(dst, src);
2956 }
2957 
2958 void Assembler::movss(Address dst, XMMRegister src) {
2959   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2960   InstructionMark im(this);
2961   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2962   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2963   attributes.reset_is_clear_context();
2964   simd_prefix(src, xnoreg, dst, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2965   emit_int8(0x11);
2966   emit_operand(src, dst);
2967 }
2968 
2969 void Assembler::movswl(Register dst, Address src) { // movsxw
2970   InstructionMark im(this);
2971   prefix(src, dst);
2972   emit_int8(0x0F);
2973   emit_int8((unsigned char)0xBF);
2974   emit_operand(dst, src);
2975 }
2976 
2977 void Assembler::movswl(Register dst, Register src) { // movsxw
2978   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
2979   emit_int8(0x0F);
2980   emit_int8((unsigned char)0xBF);
2981   emit_int8((unsigned char)(0xC0 | encode));
2982 }
2983 
2984 void Assembler::movw(Address dst, int imm16) {
2985   InstructionMark im(this);
2986 
2987   emit_int8(0x66); // switch to 16-bit mode
2988   prefix(dst);
2989   emit_int8((unsigned char)0xC7);
2990   emit_operand(rax, dst, 2);
2991   emit_int16(imm16);
2992 }
2993 
2994 void Assembler::movw(Register dst, Address src) {
2995   InstructionMark im(this);
2996   emit_int8(0x66);
2997   prefix(src, dst);
2998   emit_int8((unsigned char)0x8B);
2999   emit_operand(dst, src);
3000 }
3001 
3002 void Assembler::movw(Address dst, Register src) {
3003   InstructionMark im(this);
3004   emit_int8(0x66);
3005   prefix(dst, src);
3006   emit_int8((unsigned char)0x89);
3007   emit_operand(src, dst);
3008 }
3009 
3010 void Assembler::movzbl(Register dst, Address src) { // movzxb
3011   InstructionMark im(this);
3012   prefix(src, dst);
3013   emit_int8(0x0F);
3014   emit_int8((unsigned char)0xB6);
3015   emit_operand(dst, src);
3016 }
3017 
3018 void Assembler::movzbl(Register dst, Register src) { // movzxb
3019   NOT_LP64(assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;));
3020   int encode = prefix_and_encode(dst-&gt;encoding(), false, src-&gt;encoding(), true);
3021   emit_int8(0x0F);
3022   emit_int8((unsigned char)0xB6);
3023   emit_int8(0xC0 | encode);
3024 }
3025 
3026 void Assembler::movzwl(Register dst, Address src) { // movzxw
3027   InstructionMark im(this);
3028   prefix(src, dst);
3029   emit_int8(0x0F);
3030   emit_int8((unsigned char)0xB7);
3031   emit_operand(dst, src);
3032 }
3033 
3034 void Assembler::movzwl(Register dst, Register src) { // movzxw
3035   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
3036   emit_int8(0x0F);
3037   emit_int8((unsigned char)0xB7);
3038   emit_int8(0xC0 | encode);
3039 }
3040 
3041 void Assembler::mull(Address src) {
3042   InstructionMark im(this);
3043   prefix(src);
3044   emit_int8((unsigned char)0xF7);
3045   emit_operand(rsp, src);
3046 }
3047 
3048 void Assembler::mull(Register src) {
3049   int encode = prefix_and_encode(src-&gt;encoding());
3050   emit_int8((unsigned char)0xF7);
3051   emit_int8((unsigned char)(0xE0 | encode));
3052 }
3053 
3054 void Assembler::mulsd(XMMRegister dst, Address src) {
3055   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
3056   InstructionMark im(this);
3057   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
3058   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
3059   attributes.set_rex_vex_w_reverted();
3060   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
3061   emit_int8(0x59);
3062   emit_operand(dst, src);
3063 }
3064 
3065 void Assembler::mulsd(XMMRegister dst, XMMRegister src) {
3066   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
3067   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
3068   attributes.set_rex_vex_w_reverted();
3069   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
3070   emit_int8(0x59);
3071   emit_int8((unsigned char)(0xC0 | encode));
3072 }
3073 
3074 void Assembler::mulss(XMMRegister dst, Address src) {
3075   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
3076   InstructionMark im(this);
3077   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
3078   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
3079   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
3080   emit_int8(0x59);
3081   emit_operand(dst, src);
3082 }
3083 
3084 void Assembler::mulss(XMMRegister dst, XMMRegister src) {
3085   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
3086   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
3087   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
3088   emit_int8(0x59);
3089   emit_int8((unsigned char)(0xC0 | encode));
3090 }
3091 
3092 void Assembler::negl(Register dst) {
3093   int encode = prefix_and_encode(dst-&gt;encoding());
3094   emit_int8((unsigned char)0xF7);
3095   emit_int8((unsigned char)(0xD8 | encode));
3096 }
3097 
3098 void Assembler::nop(int i) {
3099 #ifdef ASSERT
3100   assert(i &gt; 0, &quot; &quot;);
3101   // The fancy nops aren&#39;t currently recognized by debuggers making it a
3102   // pain to disassemble code while debugging. If asserts are on clearly
3103   // speed is not an issue so simply use the single byte traditional nop
3104   // to do alignment.
3105 
3106   for (; i &gt; 0 ; i--) emit_int8((unsigned char)0x90);
3107   return;
3108 
3109 #endif // ASSERT
3110 
3111   if (UseAddressNop &amp;&amp; VM_Version::is_intel()) {
3112     //
3113     // Using multi-bytes nops &quot;0x0F 0x1F [address]&quot; for Intel
3114     //  1: 0x90
3115     //  2: 0x66 0x90
3116     //  3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)
3117     //  4: 0x0F 0x1F 0x40 0x00
3118     //  5: 0x0F 0x1F 0x44 0x00 0x00
3119     //  6: 0x66 0x0F 0x1F 0x44 0x00 0x00
3120     //  7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3121     //  8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3122     //  9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3123     // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3124     // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3125 
3126     // The rest coding is Intel specific - don&#39;t use consecutive address nops
3127 
3128     // 12: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3129     // 13: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3130     // 14: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3131     // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3132 
3133     while(i &gt;= 15) {
3134       // For Intel don&#39;t generate consecutive addess nops (mix with regular nops)
3135       i -= 15;
3136       emit_int8(0x66);   // size prefix
3137       emit_int8(0x66);   // size prefix
3138       emit_int8(0x66);   // size prefix
3139       addr_nop_8();
3140       emit_int8(0x66);   // size prefix
3141       emit_int8(0x66);   // size prefix
3142       emit_int8(0x66);   // size prefix
3143       emit_int8((unsigned char)0x90);
3144                          // nop
3145     }
3146     switch (i) {
3147       case 14:
3148         emit_int8(0x66); // size prefix
3149       case 13:
3150         emit_int8(0x66); // size prefix
3151       case 12:
3152         addr_nop_8();
3153         emit_int8(0x66); // size prefix
3154         emit_int8(0x66); // size prefix
3155         emit_int8(0x66); // size prefix
3156         emit_int8((unsigned char)0x90);
3157                          // nop
3158         break;
3159       case 11:
3160         emit_int8(0x66); // size prefix
3161       case 10:
3162         emit_int8(0x66); // size prefix
3163       case 9:
3164         emit_int8(0x66); // size prefix
3165       case 8:
3166         addr_nop_8();
3167         break;
3168       case 7:
3169         addr_nop_7();
3170         break;
3171       case 6:
3172         emit_int8(0x66); // size prefix
3173       case 5:
3174         addr_nop_5();
3175         break;
3176       case 4:
3177         addr_nop_4();
3178         break;
3179       case 3:
3180         // Don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding
3181         emit_int8(0x66); // size prefix
3182       case 2:
3183         emit_int8(0x66); // size prefix
3184       case 1:
3185         emit_int8((unsigned char)0x90);
3186                          // nop
3187         break;
3188       default:
3189         assert(i == 0, &quot; &quot;);
3190     }
3191     return;
3192   }
3193   if (UseAddressNop &amp;&amp; VM_Version::is_amd_family()) {
3194     //
3195     // Using multi-bytes nops &quot;0x0F 0x1F [address]&quot; for AMD.
3196     //  1: 0x90
3197     //  2: 0x66 0x90
3198     //  3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)
3199     //  4: 0x0F 0x1F 0x40 0x00
3200     //  5: 0x0F 0x1F 0x44 0x00 0x00
3201     //  6: 0x66 0x0F 0x1F 0x44 0x00 0x00
3202     //  7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3203     //  8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3204     //  9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3205     // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3206     // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3207 
3208     // The rest coding is AMD specific - use consecutive address nops
3209 
3210     // 12: 0x66 0x0F 0x1F 0x44 0x00 0x00 0x66 0x0F 0x1F 0x44 0x00 0x00
3211     // 13: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00 0x66 0x0F 0x1F 0x44 0x00 0x00
3212     // 14: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3213     // 15: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3214     // 16: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3215     //     Size prefixes (0x66) are added for larger sizes
3216 
3217     while(i &gt;= 22) {
3218       i -= 11;
3219       emit_int8(0x66); // size prefix
3220       emit_int8(0x66); // size prefix
3221       emit_int8(0x66); // size prefix
3222       addr_nop_8();
3223     }
3224     // Generate first nop for size between 21-12
3225     switch (i) {
3226       case 21:
3227         i -= 1;
3228         emit_int8(0x66); // size prefix
3229       case 20:
3230       case 19:
3231         i -= 1;
3232         emit_int8(0x66); // size prefix
3233       case 18:
3234       case 17:
3235         i -= 1;
3236         emit_int8(0x66); // size prefix
3237       case 16:
3238       case 15:
3239         i -= 8;
3240         addr_nop_8();
3241         break;
3242       case 14:
3243       case 13:
3244         i -= 7;
3245         addr_nop_7();
3246         break;
3247       case 12:
3248         i -= 6;
3249         emit_int8(0x66); // size prefix
3250         addr_nop_5();
3251         break;
3252       default:
3253         assert(i &lt; 12, &quot; &quot;);
3254     }
3255 
3256     // Generate second nop for size between 11-1
3257     switch (i) {
3258       case 11:
3259         emit_int8(0x66); // size prefix
3260       case 10:
3261         emit_int8(0x66); // size prefix
3262       case 9:
3263         emit_int8(0x66); // size prefix
3264       case 8:
3265         addr_nop_8();
3266         break;
3267       case 7:
3268         addr_nop_7();
3269         break;
3270       case 6:
3271         emit_int8(0x66); // size prefix
3272       case 5:
3273         addr_nop_5();
3274         break;
3275       case 4:
3276         addr_nop_4();
3277         break;
3278       case 3:
3279         // Don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding
3280         emit_int8(0x66); // size prefix
3281       case 2:
3282         emit_int8(0x66); // size prefix
3283       case 1:
3284         emit_int8((unsigned char)0x90);
3285                          // nop
3286         break;
3287       default:
3288         assert(i == 0, &quot; &quot;);
3289     }
3290     return;
3291   }
3292 
3293   if (UseAddressNop &amp;&amp; VM_Version::is_zx()) {
3294     //
3295     // Using multi-bytes nops &quot;0x0F 0x1F [address]&quot; for ZX
3296     //  1: 0x90
3297     //  2: 0x66 0x90
3298     //  3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)
3299     //  4: 0x0F 0x1F 0x40 0x00
3300     //  5: 0x0F 0x1F 0x44 0x00 0x00
3301     //  6: 0x66 0x0F 0x1F 0x44 0x00 0x00
3302     //  7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3303     //  8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3304     //  9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3305     // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3306     // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3307 
3308     // The rest coding is ZX specific - don&#39;t use consecutive address nops
3309 
3310     // 12: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3311     // 13: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3312     // 14: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3313     // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3314 
3315     while (i &gt;= 15) {
3316       // For ZX don&#39;t generate consecutive addess nops (mix with regular nops)
3317       i -= 15;
3318       emit_int8(0x66);   // size prefix
3319       emit_int8(0x66);   // size prefix
3320       emit_int8(0x66);   // size prefix
3321       addr_nop_8();
3322       emit_int8(0x66);   // size prefix
3323       emit_int8(0x66);   // size prefix
3324       emit_int8(0x66);   // size prefix
3325       emit_int8((unsigned char)0x90);
3326                          // nop
3327     }
3328     switch (i) {
3329       case 14:
3330         emit_int8(0x66); // size prefix
3331       case 13:
3332         emit_int8(0x66); // size prefix
3333       case 12:
3334         addr_nop_8();
3335         emit_int8(0x66); // size prefix
3336         emit_int8(0x66); // size prefix
3337         emit_int8(0x66); // size prefix
3338         emit_int8((unsigned char)0x90);
3339                          // nop
3340         break;
3341       case 11:
3342         emit_int8(0x66); // size prefix
3343       case 10:
3344         emit_int8(0x66); // size prefix
3345       case 9:
3346         emit_int8(0x66); // size prefix
3347       case 8:
3348         addr_nop_8();
3349         break;
3350       case 7:
3351         addr_nop_7();
3352         break;
3353       case 6:
3354         emit_int8(0x66); // size prefix
3355       case 5:
3356         addr_nop_5();
3357         break;
3358       case 4:
3359         addr_nop_4();
3360         break;
3361       case 3:
3362         // Don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding
3363         emit_int8(0x66); // size prefix
3364       case 2:
3365         emit_int8(0x66); // size prefix
3366       case 1:
3367         emit_int8((unsigned char)0x90);
3368                          // nop
3369         break;
3370       default:
3371         assert(i == 0, &quot; &quot;);
3372     }
3373     return;
3374   }
3375 
3376   // Using nops with size prefixes &quot;0x66 0x90&quot;.
3377   // From AMD Optimization Guide:
3378   //  1: 0x90
3379   //  2: 0x66 0x90
3380   //  3: 0x66 0x66 0x90
3381   //  4: 0x66 0x66 0x66 0x90
3382   //  5: 0x66 0x66 0x90 0x66 0x90
3383   //  6: 0x66 0x66 0x90 0x66 0x66 0x90
3384   //  7: 0x66 0x66 0x66 0x90 0x66 0x66 0x90
3385   //  8: 0x66 0x66 0x66 0x90 0x66 0x66 0x66 0x90
3386   //  9: 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
3387   // 10: 0x66 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
3388   //
3389   while(i &gt; 12) {
3390     i -= 4;
3391     emit_int8(0x66); // size prefix
3392     emit_int8(0x66);
3393     emit_int8(0x66);
3394     emit_int8((unsigned char)0x90);
3395                      // nop
3396   }
3397   // 1 - 12 nops
3398   if(i &gt; 8) {
3399     if(i &gt; 9) {
3400       i -= 1;
3401       emit_int8(0x66);
3402     }
3403     i -= 3;
3404     emit_int8(0x66);
3405     emit_int8(0x66);
3406     emit_int8((unsigned char)0x90);
3407   }
3408   // 1 - 8 nops
3409   if(i &gt; 4) {
3410     if(i &gt; 6) {
3411       i -= 1;
3412       emit_int8(0x66);
3413     }
3414     i -= 3;
3415     emit_int8(0x66);
3416     emit_int8(0x66);
3417     emit_int8((unsigned char)0x90);
3418   }
3419   switch (i) {
3420     case 4:
3421       emit_int8(0x66);
3422     case 3:
3423       emit_int8(0x66);
3424     case 2:
3425       emit_int8(0x66);
3426     case 1:
3427       emit_int8((unsigned char)0x90);
3428       break;
3429     default:
3430       assert(i == 0, &quot; &quot;);
3431   }
3432 }
3433 
3434 void Assembler::notl(Register dst) {
3435   int encode = prefix_and_encode(dst-&gt;encoding());
3436   emit_int8((unsigned char)0xF7);
3437   emit_int8((unsigned char)(0xD0 | encode));
3438 }
3439 
3440 void Assembler::orl(Address dst, int32_t imm32) {
3441   InstructionMark im(this);
3442   prefix(dst);
3443   emit_arith_operand(0x81, rcx, dst, imm32);
3444 }
3445 
3446 void Assembler::orl(Register dst, int32_t imm32) {
3447   prefix(dst);
3448   emit_arith(0x81, 0xC8, dst, imm32);
3449 }
3450 
3451 void Assembler::orl(Register dst, Address src) {
3452   InstructionMark im(this);
3453   prefix(src, dst);
3454   emit_int8(0x0B);
3455   emit_operand(dst, src);
3456 }
3457 
3458 void Assembler::orl(Register dst, Register src) {
3459   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
3460   emit_arith(0x0B, 0xC0, dst, src);
3461 }
3462 
3463 void Assembler::orl(Address dst, Register src) {
3464   InstructionMark im(this);
3465   prefix(dst, src);
3466   emit_int8(0x09);
3467   emit_operand(src, dst);
3468 }
3469 
3470 void Assembler::orb(Address dst, int imm8) {
3471   InstructionMark im(this);
3472   prefix(dst);
3473   emit_int8((unsigned char)0x80);
3474   emit_operand(rcx, dst, 1);
3475   emit_int8(imm8);
3476 }
3477 
3478 void Assembler::packuswb(XMMRegister dst, Address src) {
3479   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
3480   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
3481   InstructionMark im(this);
3482   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3483   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
3484   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3485   emit_int8(0x67);
3486   emit_operand(dst, src);
3487 }
3488 
3489 void Assembler::packuswb(XMMRegister dst, XMMRegister src) {
3490   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
3491   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3492   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3493   emit_int8(0x67);
3494   emit_int8((unsigned char)(0xC0 | encode));
3495 }
3496 
3497 void Assembler::vpackuswb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3498   assert(UseAVX &gt; 0, &quot;some form of AVX must be enabled&quot;);
3499   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3500   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3501   emit_int8(0x67);
3502   emit_int8((unsigned char)(0xC0 | encode));
3503 }
3504 
3505 void Assembler::vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {
3506   assert(VM_Version::supports_avx2(), &quot;&quot;);
3507   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3508   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3509   emit_int8(0x00);
3510   emit_int8((unsigned char)(0xC0 | encode));
3511   emit_int8(imm8);
3512 }
3513 
3514 void Assembler::vpermq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3515   assert(UseAVX &gt; 2, &quot;requires AVX512F&quot;);
3516   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3517   attributes.set_is_evex_instruction();
3518   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3519   emit_int8((unsigned char)0x36);
3520   emit_int8((unsigned char)(0xC0 | encode));
3521 }
3522 
3523 void Assembler::vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8) {
3524   assert(VM_Version::supports_avx2(), &quot;&quot;);
3525   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3526   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3527   emit_int8(0x46);
3528   emit_int8(0xC0 | encode);
3529   emit_int8(imm8);
3530 }
3531 
3532 void Assembler::vperm2f128(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8) {
3533   assert(VM_Version::supports_avx(), &quot;&quot;);
3534   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3535   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3536   emit_int8(0x06);
3537   emit_int8(0xC0 | encode);
3538   emit_int8(imm8);
3539 }
3540 
3541 void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3542   assert(VM_Version::supports_evex(), &quot;&quot;);
3543   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3544   attributes.set_is_evex_instruction();
3545   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3546   emit_int8(0x76);
3547   emit_int8((unsigned char)(0xC0 | encode));
3548 }
3549 
3550 
3551 void Assembler::pause() {
3552   emit_int8((unsigned char)0xF3);
3553   emit_int8((unsigned char)0x90);
3554 }
3555 
3556 void Assembler::ud2() {
3557   emit_int8(0x0F);
3558   emit_int8(0x0B);
3559 }
3560 
3561 void Assembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
3562   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
3563   InstructionMark im(this);
3564   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3565   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3566   emit_int8(0x61);
3567   emit_operand(dst, src);
3568   emit_int8(imm8);
3569 }
3570 
3571 void Assembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
3572   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
3573   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3574   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3575   emit_int8(0x61);
3576   emit_int8((unsigned char)(0xC0 | encode));
3577   emit_int8(imm8);
3578 }
3579 
3580 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3581 void Assembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
3582   assert(VM_Version::supports_sse2(), &quot;&quot;);
3583   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3584   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3585   emit_int8(0x74);
3586   emit_int8((unsigned char)(0xC0 | encode));
3587 }
3588 
3589 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3590 void Assembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3591   assert(VM_Version::supports_avx(), &quot;&quot;);
3592   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3593   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3594   emit_int8(0x74);
3595   emit_int8((unsigned char)(0xC0 | encode));
3596 }
3597 
3598 // In this context, kdst is written the mask used to process the equal components
3599 void Assembler::evpcmpeqb(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3600   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3601   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3602   attributes.set_is_evex_instruction();
3603   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3604   emit_int8(0x74);
3605   emit_int8((unsigned char)(0xC0 | encode));
3606 }
3607 
3608 void Assembler::evpcmpgtb(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3609   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3610   InstructionMark im(this);
3611   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3612   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3613   attributes.set_is_evex_instruction();
3614   int dst_enc = kdst-&gt;encoding();
3615   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3616   emit_int8(0x64);
3617   emit_operand(as_Register(dst_enc), src);
3618 }
3619 
3620 void Assembler::evpcmpgtb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len) {
3621   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3622   InstructionMark im(this);
3623   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
3624   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3625   attributes.reset_is_clear_context();
3626   attributes.set_embedded_opmask_register_specifier(mask);
3627   attributes.set_is_evex_instruction();
3628   int dst_enc = kdst-&gt;encoding();
3629   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3630   emit_int8(0x64);
3631   emit_operand(as_Register(dst_enc), src);
3632 }
3633 
3634 void Assembler::evpcmpuw(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {
3635   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3636   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3637   attributes.set_is_evex_instruction();
3638   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3639   emit_int8(0x3E);
3640   emit_int8((unsigned char)(0xC0 | encode));
3641   emit_int8(vcc);
3642 }
3643 
3644 void Assembler::evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {
3645   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3646   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
3647   attributes.reset_is_clear_context();
3648   attributes.set_embedded_opmask_register_specifier(mask);
3649   attributes.set_is_evex_instruction();
3650   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3651   emit_int8(0x3E);
3652   emit_int8((unsigned char)(0xC0 | encode));
3653   emit_int8(vcc);
3654 }
3655 
3656 void Assembler::evpcmpuw(KRegister kdst, XMMRegister nds, Address src, ComparisonPredicate vcc, int vector_len) {
3657   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3658   InstructionMark im(this);
3659   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3660   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3661   attributes.set_is_evex_instruction();
3662   int dst_enc = kdst-&gt;encoding();
3663   vex_prefix(src, nds-&gt;encoding(), kdst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3664   emit_int8(0x3E);
3665   emit_operand(as_Register(dst_enc), src);
3666   emit_int8(vcc);
3667 }
3668 
3669 void Assembler::evpcmpeqb(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3670   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3671   InstructionMark im(this);
3672   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3673   attributes.set_is_evex_instruction();
3674   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3675   int dst_enc = kdst-&gt;encoding();
3676   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3677   emit_int8(0x74);
3678   emit_operand(as_Register(dst_enc), src);
3679 }
3680 
3681 void Assembler::evpcmpeqb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len) {
3682   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3683   InstructionMark im(this);
3684   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_reg_mask */ false, /* uses_vl */ true);
3685   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3686   attributes.reset_is_clear_context();
3687   attributes.set_embedded_opmask_register_specifier(mask);
3688   attributes.set_is_evex_instruction();
3689   vex_prefix(src, nds-&gt;encoding(), kdst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3690   emit_int8(0x74);
3691   emit_operand(as_Register(kdst-&gt;encoding()), src);
3692 }
3693 
3694 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3695 void Assembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
3696   assert(VM_Version::supports_sse2(), &quot;&quot;);
3697   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3698   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3699   emit_int8(0x75);
3700   emit_int8((unsigned char)(0xC0 | encode));
3701 }
3702 
3703 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3704 void Assembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3705   assert(VM_Version::supports_avx(), &quot;&quot;);
3706   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3707   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3708   emit_int8(0x75);
3709   emit_int8((unsigned char)(0xC0 | encode));
3710 }
3711 
3712 // In this context, kdst is written the mask used to process the equal components
3713 void Assembler::evpcmpeqw(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3714   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3715   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3716   attributes.set_is_evex_instruction();
3717   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3718   emit_int8(0x75);
3719   emit_int8((unsigned char)(0xC0 | encode));
3720 }
3721 
3722 void Assembler::evpcmpeqw(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3723   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3724   InstructionMark im(this);
3725   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3726   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3727   attributes.set_is_evex_instruction();
3728   int dst_enc = kdst-&gt;encoding();
3729   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3730   emit_int8(0x75);
3731   emit_operand(as_Register(dst_enc), src);
3732 }
3733 
3734 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3735 void Assembler::pcmpeqd(XMMRegister dst, XMMRegister src) {
3736   assert(VM_Version::supports_sse2(), &quot;&quot;);
3737   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3738   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3739   emit_int8(0x76);
3740   emit_int8((unsigned char)(0xC0 | encode));
3741 }
3742 
3743 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3744 void Assembler::vpcmpeqd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3745   assert(VM_Version::supports_avx(), &quot;&quot;);
3746   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3747   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3748   emit_int8(0x76);
3749   emit_int8((unsigned char)(0xC0 | encode));
3750 }
3751 
3752 // In this context, kdst is written the mask used to process the equal components
3753 void Assembler::evpcmpeqd(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3754   assert(VM_Version::supports_evex(), &quot;&quot;);
3755   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3756   attributes.set_is_evex_instruction();
3757   attributes.reset_is_clear_context();
3758   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3759   emit_int8(0x76);
3760   emit_int8((unsigned char)(0xC0 | encode));
3761 }
3762 
3763 void Assembler::evpcmpeqd(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3764   assert(VM_Version::supports_evex(), &quot;&quot;);
3765   InstructionMark im(this);
3766   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3767   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
3768   attributes.reset_is_clear_context();
3769   attributes.set_is_evex_instruction();
3770   int dst_enc = kdst-&gt;encoding();
3771   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3772   emit_int8(0x76);
3773   emit_operand(as_Register(dst_enc), src);
3774 }
3775 
3776 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3777 void Assembler::pcmpeqq(XMMRegister dst, XMMRegister src) {
3778   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3779   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3780   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3781   emit_int8(0x29);
3782   emit_int8((unsigned char)(0xC0 | encode));
3783 }
3784 
3785 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3786 void Assembler::vpcmpeqq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3787   assert(VM_Version::supports_avx(), &quot;&quot;);
3788   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3789   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3790   emit_int8(0x29);
3791   emit_int8((unsigned char)(0xC0 | encode));
3792 }
3793 
3794 // In this context, kdst is written the mask used to process the equal components
3795 void Assembler::evpcmpeqq(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3796   assert(VM_Version::supports_evex(), &quot;&quot;);
3797   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3798   attributes.reset_is_clear_context();
3799   attributes.set_is_evex_instruction();
3800   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3801   emit_int8(0x29);
3802   emit_int8((unsigned char)(0xC0 | encode));
3803 }
3804 
3805 // In this context, kdst is written the mask used to process the equal components
3806 void Assembler::evpcmpeqq(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3807   assert(VM_Version::supports_evex(), &quot;&quot;);
3808   InstructionMark im(this);
3809   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3810   attributes.reset_is_clear_context();
3811   attributes.set_is_evex_instruction();
3812   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
3813   int dst_enc = kdst-&gt;encoding();
3814   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3815   emit_int8(0x29);
3816   emit_operand(as_Register(dst_enc), src);
3817 }
3818 
3819 void Assembler::pmovmskb(Register dst, XMMRegister src) {
3820   assert(VM_Version::supports_sse2(), &quot;&quot;);
3821   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3822   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3823   emit_int8((unsigned char)0xD7);
3824   emit_int8((unsigned char)(0xC0 | encode));
3825 }
3826 
3827 void Assembler::vpmovmskb(Register dst, XMMRegister src) {
3828   assert(VM_Version::supports_avx2(), &quot;&quot;);
3829   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3830   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3831   emit_int8((unsigned char)0xD7);
3832   emit_int8((unsigned char)(0xC0 | encode));
3833 }
3834 
3835 void Assembler::pextrd(Register dst, XMMRegister src, int imm8) {
3836   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3837   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3838   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3839   emit_int8(0x16);
3840   emit_int8((unsigned char)(0xC0 | encode));
3841   emit_int8(imm8);
3842 }
3843 
3844 void Assembler::pextrd(Address dst, XMMRegister src, int imm8) {
3845   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3846   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3847   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
3848   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3849   emit_int8(0x16);
3850   emit_operand(src, dst);
3851   emit_int8(imm8);
3852 }
3853 
3854 void Assembler::pextrq(Register dst, XMMRegister src, int imm8) {
3855   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3856   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3857   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3858   emit_int8(0x16);
3859   emit_int8((unsigned char)(0xC0 | encode));
3860   emit_int8(imm8);
3861 }
3862 
3863 void Assembler::pextrq(Address dst, XMMRegister src, int imm8) {
3864   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3865   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3866   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
3867   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3868   emit_int8(0x16);
3869   emit_operand(src, dst);
3870   emit_int8(imm8);
3871 }
3872 
3873 void Assembler::pextrw(Register dst, XMMRegister src, int imm8) {
3874   assert(VM_Version::supports_sse2(), &quot;&quot;);
3875   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3876   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3877   emit_int8((unsigned char)0xC5);
3878   emit_int8((unsigned char)(0xC0 | encode));
3879   emit_int8(imm8);
3880 }
3881 
3882 void Assembler::pextrw(Address dst, XMMRegister src, int imm8) {
3883   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3884   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3885   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
3886   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3887   emit_int8((unsigned char)0x15);
3888   emit_operand(src, dst);
3889   emit_int8(imm8);
3890 }
3891 
3892 void Assembler::pextrb(Address dst, XMMRegister src, int imm8) {
3893   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3894   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3895   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_8bit);
3896   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3897   emit_int8(0x14);
3898   emit_operand(src, dst);
3899   emit_int8(imm8);
3900 }
3901 
3902 void Assembler::pinsrd(XMMRegister dst, Register src, int imm8) {
3903   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3904   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3905   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3906   emit_int8(0x22);
3907   emit_int8((unsigned char)(0xC0 | encode));
3908   emit_int8(imm8);
3909 }
3910 
3911 void Assembler::pinsrd(XMMRegister dst, Address src, int imm8) {
3912   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3913   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3914   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
3915   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3916   emit_int8(0x22);
3917   emit_operand(dst,src);
3918   emit_int8(imm8);
3919 }
3920 
3921 void Assembler::pinsrq(XMMRegister dst, Register src, int imm8) {
3922   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3923   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3924   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3925   emit_int8(0x22);
3926   emit_int8((unsigned char)(0xC0 | encode));
3927   emit_int8(imm8);
3928 }
3929 
3930 void Assembler::pinsrq(XMMRegister dst, Address src, int imm8) {
3931   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3932   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3933   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
3934   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3935   emit_int8(0x22);
3936   emit_operand(dst, src);
3937   emit_int8(imm8);
3938 }
3939 
3940 void Assembler::pinsrw(XMMRegister dst, Register src, int imm8) {
3941   assert(VM_Version::supports_sse2(), &quot;&quot;);
3942   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3943   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3944   emit_int8((unsigned char)0xC4);
3945   emit_int8((unsigned char)(0xC0 | encode));
3946   emit_int8(imm8);
3947 }
3948 
3949 void Assembler::pinsrw(XMMRegister dst, Address src, int imm8) {
3950   assert(VM_Version::supports_sse2(), &quot;&quot;);
3951   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3952   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
3953   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3954   emit_int8((unsigned char)0xC4);
3955   emit_operand(dst, src);
3956   emit_int8(imm8);
3957 }
3958 
3959 void Assembler::pinsrb(XMMRegister dst, Address src, int imm8) {
3960   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3961   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3962   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_8bit);
3963   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3964   emit_int8(0x20);
3965   emit_operand(dst, src);
3966   emit_int8(imm8);
3967 }
3968 
3969 void Assembler::pmovzxbw(XMMRegister dst, Address src) {
3970   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3971   InstructionMark im(this);
3972   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3973   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
3974   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3975   emit_int8(0x30);
3976   emit_operand(dst, src);
3977 }
3978 
3979 void Assembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
3980   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3981   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3982   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3983   emit_int8(0x30);
3984   emit_int8((unsigned char)(0xC0 | encode));
3985 }
3986 
3987 void Assembler::pmovsxbw(XMMRegister dst, XMMRegister src) {
3988   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3989   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3990   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3991   emit_int8(0x20);
3992   emit_int8((unsigned char)(0xC0 | encode));
3993 }
3994 
3995 void Assembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
3996   assert(VM_Version::supports_avx(), &quot;&quot;);
3997   InstructionMark im(this);
3998   assert(dst != xnoreg, &quot;sanity&quot;);
3999   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4000   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
4001   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4002   emit_int8(0x30);
4003   emit_operand(dst, src);
4004 }
4005 
4006 void Assembler::vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len) {
4007   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4008   vector_len == AVX_256bit? VM_Version::supports_avx2() :
4009   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4010   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4011   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4012   emit_int8(0x30);
4013   emit_int8((unsigned char) (0xC0 | encode));
4014 }
4015 
4016 void Assembler::vpmovsxbw(XMMRegister dst, XMMRegister src, int vector_len) {
4017   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4018   vector_len == AVX_256bit? VM_Version::supports_avx2() :
4019   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4020   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4021   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4022   emit_int8(0x20);
4023   emit_int8((unsigned char)(0xC0 | encode));
4024 }
4025 
4026 void Assembler::evpmovzxbw(XMMRegister dst, KRegister mask, Address src, int vector_len) {
4027   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
4028   assert(dst != xnoreg, &quot;sanity&quot;);
4029   InstructionMark im(this);
4030   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
4031   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
4032   attributes.set_embedded_opmask_register_specifier(mask);
4033   attributes.set_is_evex_instruction();
4034   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4035   emit_int8(0x30);
4036   emit_operand(dst, src);
4037 }
4038 void Assembler::evpmovwb(Address dst, XMMRegister src, int vector_len) {
4039   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
4040   assert(src != xnoreg, &quot;sanity&quot;);
4041   InstructionMark im(this);
4042   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4043   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
4044   attributes.set_is_evex_instruction();
4045   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &amp;attributes);
4046   emit_int8(0x30);
4047   emit_operand(src, dst);
4048 }
4049 
4050 void Assembler::evpmovwb(Address dst, KRegister mask, XMMRegister src, int vector_len) {
4051   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
4052   assert(src != xnoreg, &quot;sanity&quot;);
4053   InstructionMark im(this);
4054   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
4055   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
4056   attributes.reset_is_clear_context();
4057   attributes.set_embedded_opmask_register_specifier(mask);
4058   attributes.set_is_evex_instruction();
4059   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &amp;attributes);
4060   emit_int8(0x30);
4061   emit_operand(src, dst);
4062 }
4063 
4064 void Assembler::evpmovdb(Address dst, XMMRegister src, int vector_len) {
4065   assert(VM_Version::supports_evex(), &quot;&quot;);
4066   assert(src != xnoreg, &quot;sanity&quot;);
4067   InstructionMark im(this);
4068   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4069   attributes.set_address_attributes(/* tuple_type */ EVEX_QVM, /* input_size_in_bits */ EVEX_NObit);
4070   attributes.set_is_evex_instruction();
4071   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &amp;attributes);
4072   emit_int8(0x31);
4073   emit_operand(src, dst);
4074 }
4075 
4076 void Assembler::vpmovzxwd(XMMRegister dst, XMMRegister src, int vector_len) {
4077   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4078   vector_len == AVX_256bit? VM_Version::supports_avx2() :
4079   vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot; &quot;);
4080   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4081   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4082   emit_int8(0x33);
4083   emit_int8((unsigned char)(0xC0 | encode));
4084 }
4085 
4086 void Assembler::pmaddwd(XMMRegister dst, XMMRegister src) {
4087   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4088   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4089   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4090   emit_int8((unsigned char)0xF5);
4091   emit_int8((unsigned char)(0xC0 | encode));
4092 }
4093 
4094 void Assembler::vpmaddwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
4095   assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
4096     (vector_len == AVX_256bit ? VM_Version::supports_avx2() :
4097     (vector_len == AVX_512bit ? VM_Version::supports_evex() : 0)), &quot;&quot;);
4098   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4099   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4100   emit_int8((unsigned char)0xF5);
4101   emit_int8((unsigned char)(0xC0 | encode));
4102 }
4103 
4104 void Assembler::evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
4105   assert(VM_Version::supports_evex(), &quot;&quot;);
4106   assert(VM_Version::supports_avx512_vnni(), &quot;must support vnni&quot;);
4107   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4108   attributes.set_is_evex_instruction();
4109   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4110   emit_int8(0x52);
4111   emit_int8((unsigned char)(0xC0 | encode));
4112 }
4113 
4114 // generic
4115 void Assembler::pop(Register dst) {
4116   int encode = prefix_and_encode(dst-&gt;encoding());
4117   emit_int8(0x58 | encode);
4118 }
4119 
4120 void Assembler::popcntl(Register dst, Address src) {
4121   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
4122   InstructionMark im(this);
4123   emit_int8((unsigned char)0xF3);
4124   prefix(src, dst);
4125   emit_int8(0x0F);
4126   emit_int8((unsigned char)0xB8);
4127   emit_operand(dst, src);
4128 }
4129 
4130 void Assembler::popcntl(Register dst, Register src) {
4131   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
4132   emit_int8((unsigned char)0xF3);
4133   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4134   emit_int8(0x0F);
4135   emit_int8((unsigned char)0xB8);
4136   emit_int8((unsigned char)(0xC0 | encode));
4137 }
4138 
4139 void Assembler::vpopcntd(XMMRegister dst, XMMRegister src, int vector_len) {
4140   assert(VM_Version::supports_avx512_vpopcntdq(), &quot;must support vpopcntdq feature&quot;);
4141   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4142   attributes.set_is_evex_instruction();
4143   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4144   emit_int8(0x55);
4145   emit_int8((unsigned char)(0xC0 | encode));
4146 }
4147 
4148 void Assembler::popf() {
4149   emit_int8((unsigned char)0x9D);
4150 }
4151 
4152 #ifndef _LP64 // no 32bit push/pop on amd64
4153 void Assembler::popl(Address dst) {
4154   // NOTE: this will adjust stack by 8byte on 64bits
4155   InstructionMark im(this);
4156   prefix(dst);
4157   emit_int8((unsigned char)0x8F);
4158   emit_operand(rax, dst);
4159 }
4160 #endif
4161 
4162 void Assembler::prefetch_prefix(Address src) {
4163   prefix(src);
4164   emit_int8(0x0F);
4165 }
4166 
4167 void Assembler::prefetchnta(Address src) {
4168   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
4169   InstructionMark im(this);
4170   prefetch_prefix(src);
4171   emit_int8(0x18);
4172   emit_operand(rax, src); // 0, src
4173 }
4174 
4175 void Assembler::prefetchr(Address src) {
4176   assert(VM_Version::supports_3dnow_prefetch(), &quot;must support&quot;);
4177   InstructionMark im(this);
4178   prefetch_prefix(src);
4179   emit_int8(0x0D);
4180   emit_operand(rax, src); // 0, src
4181 }
4182 
4183 void Assembler::prefetcht0(Address src) {
4184   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
4185   InstructionMark im(this);
4186   prefetch_prefix(src);
4187   emit_int8(0x18);
4188   emit_operand(rcx, src); // 1, src
4189 }
4190 
4191 void Assembler::prefetcht1(Address src) {
4192   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
4193   InstructionMark im(this);
4194   prefetch_prefix(src);
4195   emit_int8(0x18);
4196   emit_operand(rdx, src); // 2, src
4197 }
4198 
4199 void Assembler::prefetcht2(Address src) {
4200   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
4201   InstructionMark im(this);
4202   prefetch_prefix(src);
4203   emit_int8(0x18);
4204   emit_operand(rbx, src); // 3, src
4205 }
4206 
4207 void Assembler::prefetchw(Address src) {
4208   assert(VM_Version::supports_3dnow_prefetch(), &quot;must support&quot;);
4209   InstructionMark im(this);
4210   prefetch_prefix(src);
4211   emit_int8(0x0D);
4212   emit_operand(rcx, src); // 1, src
4213 }
4214 
4215 void Assembler::prefix(Prefix p) {
4216   emit_int8(p);
4217 }
4218 
4219 void Assembler::pshufb(XMMRegister dst, XMMRegister src) {
4220   assert(VM_Version::supports_ssse3(), &quot;&quot;);
4221   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4222   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4223   emit_int8(0x00);
4224   emit_int8((unsigned char)(0xC0 | encode));
4225 }
4226 
4227 void Assembler::vpshufb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
4228   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4229          vector_len == AVX_256bit? VM_Version::supports_avx2() :
4230          vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4231   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4232   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4233   emit_int8(0x00);
4234   emit_int8((unsigned char)(0xC0 | encode));
4235 }
4236 
4237 void Assembler::pshufb(XMMRegister dst, Address src) {
4238   assert(VM_Version::supports_ssse3(), &quot;&quot;);
4239   InstructionMark im(this);
4240   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4241   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
4242   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4243   emit_int8(0x00);
4244   emit_operand(dst, src);
4245 }
4246 
4247 void Assembler::pshufd(XMMRegister dst, XMMRegister src, int mode) {
4248   assert(isByte(mode), &quot;invalid value&quot;);
4249   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4250   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
4251   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4252   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4253   emit_int8(0x70);
4254   emit_int8((unsigned char)(0xC0 | encode));
4255   emit_int8(mode &amp; 0xFF);
4256 }
4257 
4258 void Assembler::vpshufd(XMMRegister dst, XMMRegister src, int mode, int vector_len) {
4259   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4260          (vector_len == AVX_256bit? VM_Version::supports_avx2() :
4261          (vector_len == AVX_512bit? VM_Version::supports_evex() : 0)), &quot;&quot;);
4262   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4263   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4264   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4265   emit_int8(0x70);
4266   emit_int8((unsigned char)(0xC0 | encode));
4267   emit_int8(mode &amp; 0xFF);
4268 }
4269 
4270 void Assembler::pshufd(XMMRegister dst, Address src, int mode) {
4271   assert(isByte(mode), &quot;invalid value&quot;);
4272   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4273   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4274   InstructionMark im(this);
4275   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4276   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
4277   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4278   emit_int8(0x70);
4279   emit_operand(dst, src);
4280   emit_int8(mode &amp; 0xFF);
4281 }
4282 
4283 void Assembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
4284   assert(isByte(mode), &quot;invalid value&quot;);
4285   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4286   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4287   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4288   emit_int8(0x70);
4289   emit_int8((unsigned char)(0xC0 | encode));
4290   emit_int8(mode &amp; 0xFF);
4291 }
4292 
4293 void Assembler::pshuflw(XMMRegister dst, Address src, int mode) {
4294   assert(isByte(mode), &quot;invalid value&quot;);
4295   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4296   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4297   InstructionMark im(this);
4298   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4299   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
4300   simd_prefix(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4301   emit_int8(0x70);
4302   emit_operand(dst, src);
4303   emit_int8(mode &amp; 0xFF);
4304 }
4305 
4306 void Assembler::evshufi64x2(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
4307   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
4308   assert(vector_len == Assembler::AVX_256bit || vector_len == Assembler::AVX_512bit, &quot;&quot;);
4309   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4310   attributes.set_is_evex_instruction();
4311   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
4312   emit_int8(0x43);
4313   emit_int8((unsigned char)(0xC0 | encode));
4314   emit_int8(imm8 &amp; 0xFF);
4315 }
4316 
4317 void Assembler::psrldq(XMMRegister dst, int shift) {
4318   // Shift left 128 bit value in dst XMMRegister by shift number of bytes.
4319   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4320   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4321   int encode = simd_prefix_and_encode(xmm3, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4322   emit_int8(0x73);
4323   emit_int8((unsigned char)(0xC0 | encode));
4324   emit_int8(shift);
4325 }
4326 
4327 void Assembler::vpsrldq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
4328   assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
4329          vector_len == AVX_256bit ? VM_Version::supports_avx2() :
4330          vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4331   InstructionAttr attributes(vector_len, /*vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4332   int encode = vex_prefix_and_encode(xmm3-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4333   emit_int8(0x73);
4334   emit_int8((unsigned char)(0xC0 | encode));
4335   emit_int8(shift &amp; 0xFF);
4336 }
4337 
4338 void Assembler::pslldq(XMMRegister dst, int shift) {
4339   // Shift left 128 bit value in dst XMMRegister by shift number of bytes.
4340   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4341   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4342   // XMM7 is for /7 encoding: 66 0F 73 /7 ib
4343   int encode = simd_prefix_and_encode(xmm7, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4344   emit_int8(0x73);
4345   emit_int8((unsigned char)(0xC0 | encode));
4346   emit_int8(shift);
4347 }
4348 
4349 void Assembler::vpslldq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
4350   assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
4351          vector_len == AVX_256bit ? VM_Version::supports_avx2() :
4352          vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4353   InstructionAttr attributes(vector_len, /*vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4354   int encode = vex_prefix_and_encode(xmm7-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4355   emit_int8(0x73);
4356   emit_int8((unsigned char)(0xC0 | encode));
4357   emit_int8(shift &amp; 0xFF);
4358 }
4359 
4360 void Assembler::ptest(XMMRegister dst, Address src) {
4361   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4362   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4363   InstructionMark im(this);
4364   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4365   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4366   emit_int8(0x17);
4367   emit_operand(dst, src);
4368 }
4369 
4370 void Assembler::ptest(XMMRegister dst, XMMRegister src) {
4371   assert(VM_Version::supports_sse4_1() || VM_Version::supports_avx(), &quot;&quot;);
4372   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4373   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4374   emit_int8(0x17);
4375   emit_int8((unsigned char)(0xC0 | encode));
4376 }
4377 
4378 void Assembler::vptest(XMMRegister dst, Address src) {
4379   assert(VM_Version::supports_avx(), &quot;&quot;);
4380   InstructionMark im(this);
4381   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4382   assert(dst != xnoreg, &quot;sanity&quot;);
4383   // swap src&lt;-&gt;dst for encoding
4384   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4385   emit_int8(0x17);
4386   emit_operand(dst, src);
4387 }
4388 
4389 void Assembler::vptest(XMMRegister dst, XMMRegister src) {
4390   assert(VM_Version::supports_avx(), &quot;&quot;);
4391   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4392   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4393   emit_int8(0x17);
4394   emit_int8((unsigned char)(0xC0 | encode));
4395 }
4396 
4397 void Assembler::punpcklbw(XMMRegister dst, Address src) {
4398   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4399   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4400   InstructionMark im(this);
4401   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_vlbw, /* no_mask_reg */ true, /* uses_vl */ true);
4402   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
4403   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4404   emit_int8(0x60);
4405   emit_operand(dst, src);
4406 }
4407 
4408 void Assembler::punpcklbw(XMMRegister dst, XMMRegister src) {
4409   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4410   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_vlbw, /* no_mask_reg */ true, /* uses_vl */ true);
4411   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4412   emit_int8(0x60);
4413   emit_int8((unsigned char)(0xC0 | encode));
4414 }
4415 
4416 void Assembler::punpckldq(XMMRegister dst, Address src) {
4417   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4418   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4419   InstructionMark im(this);
4420   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4421   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
4422   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4423   emit_int8(0x62);
4424   emit_operand(dst, src);
4425 }
4426 
4427 void Assembler::punpckldq(XMMRegister dst, XMMRegister src) {
4428   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4429   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4430   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4431   emit_int8(0x62);
4432   emit_int8((unsigned char)(0xC0 | encode));
4433 }
4434 
4435 void Assembler::punpcklqdq(XMMRegister dst, XMMRegister src) {
4436   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4437   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4438   attributes.set_rex_vex_w_reverted();
4439   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4440   emit_int8(0x6C);
4441   emit_int8((unsigned char)(0xC0 | encode));
4442 }
4443 
4444 void Assembler::push(int32_t imm32) {
4445   // in 64bits we push 64bits onto the stack but only
4446   // take a 32bit immediate
4447   emit_int8(0x68);
4448   emit_int32(imm32);
4449 }
4450 
4451 void Assembler::push(Register src) {
4452   int encode = prefix_and_encode(src-&gt;encoding());
4453 
4454   emit_int8(0x50 | encode);
4455 }
4456 
4457 void Assembler::pushf() {
4458   emit_int8((unsigned char)0x9C);
4459 }
4460 
4461 #ifndef _LP64 // no 32bit push/pop on amd64
4462 void Assembler::pushl(Address src) {
4463   // Note this will push 64bit on 64bit
4464   InstructionMark im(this);
4465   prefix(src);
4466   emit_int8((unsigned char)0xFF);
4467   emit_operand(rsi, src);
4468 }
4469 #endif
4470 
4471 void Assembler::rcll(Register dst, int imm8) {
4472   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4473   int encode = prefix_and_encode(dst-&gt;encoding());
4474   if (imm8 == 1) {
4475     emit_int8((unsigned char)0xD1);
4476     emit_int8((unsigned char)(0xD0 | encode));
4477   } else {
4478     emit_int8((unsigned char)0xC1);
4479     emit_int8((unsigned char)0xD0 | encode);
4480     emit_int8(imm8);
4481   }
4482 }
4483 
4484 void Assembler::rcpps(XMMRegister dst, XMMRegister src) {
4485   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4486   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4487   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
4488   emit_int8(0x53);
4489   emit_int8((unsigned char)(0xC0 | encode));
4490 }
4491 
4492 void Assembler::rcpss(XMMRegister dst, XMMRegister src) {
4493   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4494   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4495   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4496   emit_int8(0x53);
4497   emit_int8((unsigned char)(0xC0 | encode));
4498 }
4499 
4500 void Assembler::rdtsc() {
4501   emit_int8((unsigned char)0x0F);
4502   emit_int8((unsigned char)0x31);
4503 }
4504 
4505 // copies data from [esi] to [edi] using rcx pointer sized words
4506 // generic
4507 void Assembler::rep_mov() {
4508   emit_int8((unsigned char)0xF3);
4509   // MOVSQ
4510   LP64_ONLY(prefix(REX_W));
4511   emit_int8((unsigned char)0xA5);
4512 }
4513 
4514 // sets rcx bytes with rax, value at [edi]
4515 void Assembler::rep_stosb() {
4516   emit_int8((unsigned char)0xF3); // REP
4517   LP64_ONLY(prefix(REX_W));
4518   emit_int8((unsigned char)0xAA); // STOSB
4519 }
4520 
4521 // sets rcx pointer sized words with rax, value at [edi]
4522 // generic
4523 void Assembler::rep_stos() {
4524   emit_int8((unsigned char)0xF3); // REP
4525   LP64_ONLY(prefix(REX_W));       // LP64:STOSQ, LP32:STOSD
4526   emit_int8((unsigned char)0xAB);
4527 }
4528 
4529 // scans rcx pointer sized words at [edi] for occurance of rax,
4530 // generic
4531 void Assembler::repne_scan() { // repne_scan
4532   emit_int8((unsigned char)0xF2);
4533   // SCASQ
4534   LP64_ONLY(prefix(REX_W));
4535   emit_int8((unsigned char)0xAF);
4536 }
4537 
4538 #ifdef _LP64
4539 // scans rcx 4 byte words at [edi] for occurance of rax,
4540 // generic
4541 void Assembler::repne_scanl() { // repne_scan
4542   emit_int8((unsigned char)0xF2);
4543   // SCASL
4544   emit_int8((unsigned char)0xAF);
4545 }
4546 #endif
4547 
4548 void Assembler::ret(int imm16) {
4549   if (imm16 == 0) {
4550     emit_int8((unsigned char)0xC3);
4551   } else {
4552     emit_int8((unsigned char)0xC2);
4553     emit_int16(imm16);
4554   }
4555 }
4556 
4557 void Assembler::sahf() {
4558 #ifdef _LP64
4559   // Not supported in 64bit mode
4560   ShouldNotReachHere();
4561 #endif
4562   emit_int8((unsigned char)0x9E);
4563 }
4564 
4565 void Assembler::sarl(Register dst, int imm8) {
4566   int encode = prefix_and_encode(dst-&gt;encoding());
4567   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4568   if (imm8 == 1) {
4569     emit_int8((unsigned char)0xD1);
4570     emit_int8((unsigned char)(0xF8 | encode));
4571   } else {
4572     emit_int8((unsigned char)0xC1);
4573     emit_int8((unsigned char)(0xF8 | encode));
4574     emit_int8(imm8);
4575   }
4576 }
4577 
4578 void Assembler::sarl(Register dst) {
4579   int encode = prefix_and_encode(dst-&gt;encoding());
4580   emit_int8((unsigned char)0xD3);
4581   emit_int8((unsigned char)(0xF8 | encode));
4582 }
4583 
4584 void Assembler::sbbl(Address dst, int32_t imm32) {
4585   InstructionMark im(this);
4586   prefix(dst);
4587   emit_arith_operand(0x81, rbx, dst, imm32);
4588 }
4589 
4590 void Assembler::sbbl(Register dst, int32_t imm32) {
4591   prefix(dst);
4592   emit_arith(0x81, 0xD8, dst, imm32);
4593 }
4594 
4595 
4596 void Assembler::sbbl(Register dst, Address src) {
4597   InstructionMark im(this);
4598   prefix(src, dst);
4599   emit_int8(0x1B);
4600   emit_operand(dst, src);
4601 }
4602 
4603 void Assembler::sbbl(Register dst, Register src) {
4604   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4605   emit_arith(0x1B, 0xC0, dst, src);
4606 }
4607 
4608 void Assembler::setb(Condition cc, Register dst) {
4609   assert(0 &lt;= cc &amp;&amp; cc &lt; 16, &quot;illegal cc&quot;);
4610   int encode = prefix_and_encode(dst-&gt;encoding(), true);
4611   emit_int8(0x0F);
4612   emit_int8((unsigned char)0x90 | cc);
4613   emit_int8((unsigned char)(0xC0 | encode));
4614 }
4615 
4616 void Assembler::palignr(XMMRegister dst, XMMRegister src, int imm8) {
4617   assert(VM_Version::supports_ssse3(), &quot;&quot;);
4618   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4619   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
4620   emit_int8((unsigned char)0x0F);
4621   emit_int8((unsigned char)(0xC0 | encode));
4622   emit_int8(imm8);
4623 }
4624 
4625 void Assembler::vpalignr(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
4626   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4627          vector_len == AVX_256bit? VM_Version::supports_avx2() :
4628          0, &quot;&quot;);
4629   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4630   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
4631   emit_int8((unsigned char)0x0F);
4632   emit_int8((unsigned char)(0xC0 | encode));
4633   emit_int8(imm8);
4634 }
4635 
4636 void Assembler::evalignq(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
4637   assert(VM_Version::supports_evex(), &quot;&quot;);
4638   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4639   attributes.set_is_evex_instruction();
4640   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
4641   emit_int8(0x3);
4642   emit_int8((unsigned char)(0xC0 | encode));
4643   emit_int8(imm8);
4644 }
4645 
4646 void Assembler::pblendw(XMMRegister dst, XMMRegister src, int imm8) {
4647   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4648   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4649   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
4650   emit_int8((unsigned char)0x0E);
4651   emit_int8((unsigned char)(0xC0 | encode));
4652   emit_int8(imm8);
4653 }
4654 
4655 void Assembler::sha1rnds4(XMMRegister dst, XMMRegister src, int imm8) {
4656   assert(VM_Version::supports_sha(), &quot;&quot;);
4657   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, /* rex_w */ false);
4658   emit_int8((unsigned char)0xCC);
4659   emit_int8((unsigned char)(0xC0 | encode));
4660   emit_int8((unsigned char)imm8);
4661 }
4662 
4663 void Assembler::sha1nexte(XMMRegister dst, XMMRegister src) {
4664   assert(VM_Version::supports_sha(), &quot;&quot;);
4665   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
4666   emit_int8((unsigned char)0xC8);
4667   emit_int8((unsigned char)(0xC0 | encode));
4668 }
4669 
4670 void Assembler::sha1msg1(XMMRegister dst, XMMRegister src) {
4671   assert(VM_Version::supports_sha(), &quot;&quot;);
4672   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
4673   emit_int8((unsigned char)0xC9);
4674   emit_int8((unsigned char)(0xC0 | encode));
4675 }
4676 
4677 void Assembler::sha1msg2(XMMRegister dst, XMMRegister src) {
4678   assert(VM_Version::supports_sha(), &quot;&quot;);
4679   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
4680   emit_int8((unsigned char)0xCA);
4681   emit_int8((unsigned char)(0xC0 | encode));
4682 }
4683 
4684 // xmm0 is implicit additional source to this instruction.
4685 void Assembler::sha256rnds2(XMMRegister dst, XMMRegister src) {
4686   assert(VM_Version::supports_sha(), &quot;&quot;);
4687   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
4688   emit_int8((unsigned char)0xCB);
4689   emit_int8((unsigned char)(0xC0 | encode));
4690 }
4691 
4692 void Assembler::sha256msg1(XMMRegister dst, XMMRegister src) {
4693   assert(VM_Version::supports_sha(), &quot;&quot;);
4694   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
4695   emit_int8((unsigned char)0xCC);
4696   emit_int8((unsigned char)(0xC0 | encode));
4697 }
4698 
4699 void Assembler::sha256msg2(XMMRegister dst, XMMRegister src) {
4700   assert(VM_Version::supports_sha(), &quot;&quot;);
4701   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
4702   emit_int8((unsigned char)0xCD);
4703   emit_int8((unsigned char)(0xC0 | encode));
4704 }
4705 
4706 
4707 void Assembler::shll(Register dst, int imm8) {
4708   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4709   int encode = prefix_and_encode(dst-&gt;encoding());
4710   if (imm8 == 1 ) {
4711     emit_int8((unsigned char)0xD1);
4712     emit_int8((unsigned char)(0xE0 | encode));
4713   } else {
4714     emit_int8((unsigned char)0xC1);
4715     emit_int8((unsigned char)(0xE0 | encode));
4716     emit_int8(imm8);
4717   }
4718 }
4719 
4720 void Assembler::shll(Register dst) {
4721   int encode = prefix_and_encode(dst-&gt;encoding());
4722   emit_int8((unsigned char)0xD3);
4723   emit_int8((unsigned char)(0xE0 | encode));
4724 }
4725 
4726 void Assembler::shrl(Register dst, int imm8) {
4727   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4728   int encode = prefix_and_encode(dst-&gt;encoding());
4729   emit_int8((unsigned char)0xC1);
4730   emit_int8((unsigned char)(0xE8 | encode));
4731   emit_int8(imm8);
4732 }
4733 
4734 void Assembler::shrl(Register dst) {
4735   int encode = prefix_and_encode(dst-&gt;encoding());
4736   emit_int8((unsigned char)0xD3);
4737   emit_int8((unsigned char)(0xE8 | encode));
4738 }
4739 
4740 void Assembler::shldl(Register dst, Register src) {
4741   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
4742   emit_int8(0x0F);
4743   emit_int8((unsigned char)0xA5);
4744   emit_int8((unsigned char)(0xC0 | encode));
4745 }
4746 
4747 void Assembler::shldl(Register dst, Register src, int8_t imm8) {
4748   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
4749   emit_int8(0x0F);
4750   emit_int8((unsigned char)0xA4);
4751   emit_int8((unsigned char)(0xC0 | encode));
4752   emit_int8(imm8);
4753 }
4754 
4755 void Assembler::shrdl(Register dst, Register src) {
4756   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
4757   emit_int8(0x0F);
4758   emit_int8((unsigned char)0xAD);
4759   emit_int8((unsigned char)(0xC0 | encode));
4760 }
4761 
4762 void Assembler::shrdl(Register dst, Register src, int8_t imm8) {
4763   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
4764   emit_int8(0x0F);
4765   emit_int8((unsigned char)0xAC);
4766   emit_int8((unsigned char)(0xC0 | encode));
4767   emit_int8(imm8);
4768 }
4769 
4770 // copies a single word from [esi] to [edi]
4771 void Assembler::smovl() {
4772   emit_int8((unsigned char)0xA5);
4773 }
4774 
4775 void Assembler::roundsd(XMMRegister dst, XMMRegister src, int32_t rmode) {
4776   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4777   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4778   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
4779   emit_int8(0x0B);
4780   emit_int8((unsigned char)(0xC0 | encode));
4781   emit_int8((unsigned char)rmode);
4782 }
4783 
4784 void Assembler::roundsd(XMMRegister dst, Address src, int32_t rmode) {
4785   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4786   InstructionMark im(this);
4787   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4788   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
4789   emit_int8(0x0B);
4790   emit_operand(dst, src);
4791   emit_int8((unsigned char)rmode);
4792 }
4793 
4794 void Assembler::sqrtsd(XMMRegister dst, XMMRegister src) {
4795   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4796   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4797   attributes.set_rex_vex_w_reverted();
4798   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4799   emit_int8(0x51);
4800   emit_int8((unsigned char)(0xC0 | encode));
4801 }
4802 
4803 void Assembler::sqrtsd(XMMRegister dst, Address src) {
4804   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4805   InstructionMark im(this);
4806   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4807   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4808   attributes.set_rex_vex_w_reverted();
4809   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4810   emit_int8(0x51);
4811   emit_operand(dst, src);
4812 }
4813 
4814 void Assembler::sqrtss(XMMRegister dst, XMMRegister src) {
4815   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4816   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4817   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4818   emit_int8(0x51);
4819   emit_int8((unsigned char)(0xC0 | encode));
4820 }
4821 
4822 void Assembler::std() {
4823   emit_int8((unsigned char)0xFD);
4824 }
4825 
4826 void Assembler::sqrtss(XMMRegister dst, Address src) {
4827   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4828   InstructionMark im(this);
4829   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4830   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4831   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4832   emit_int8(0x51);
4833   emit_operand(dst, src);
4834 }
4835 
4836 void Assembler::stmxcsr( Address dst) {
4837   if (UseAVX &gt; 0 ) {
4838     assert(VM_Version::supports_avx(), &quot;&quot;);
4839     InstructionMark im(this);
4840     InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4841     vex_prefix(dst, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
4842     emit_int8((unsigned char)0xAE);
4843     emit_operand(as_Register(3), dst);
4844   } else {
4845     NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4846     InstructionMark im(this);
4847     prefix(dst);
4848     emit_int8(0x0F);
4849     emit_int8((unsigned char)0xAE);
4850     emit_operand(as_Register(3), dst);
4851   }
4852 }
4853 
4854 void Assembler::subl(Address dst, int32_t imm32) {
4855   InstructionMark im(this);
4856   prefix(dst);
4857   emit_arith_operand(0x81, rbp, dst, imm32);
4858 }
4859 
4860 void Assembler::subl(Address dst, Register src) {
4861   InstructionMark im(this);
4862   prefix(dst, src);
4863   emit_int8(0x29);
4864   emit_operand(src, dst);
4865 }
4866 
4867 void Assembler::subl(Register dst, int32_t imm32) {
4868   prefix(dst);
4869   emit_arith(0x81, 0xE8, dst, imm32);
4870 }
4871 
4872 // Force generation of a 4 byte immediate value even if it fits into 8bit
4873 void Assembler::subl_imm32(Register dst, int32_t imm32) {
4874   prefix(dst);
4875   emit_arith_imm32(0x81, 0xE8, dst, imm32);
4876 }
4877 
4878 void Assembler::subl(Register dst, Address src) {
4879   InstructionMark im(this);
4880   prefix(src, dst);
4881   emit_int8(0x2B);
4882   emit_operand(dst, src);
4883 }
4884 
4885 void Assembler::subl(Register dst, Register src) {
4886   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4887   emit_arith(0x2B, 0xC0, dst, src);
4888 }
4889 
4890 void Assembler::subsd(XMMRegister dst, XMMRegister src) {
4891   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4892   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4893   attributes.set_rex_vex_w_reverted();
4894   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4895   emit_int8(0x5C);
4896   emit_int8((unsigned char)(0xC0 | encode));
4897 }
4898 
4899 void Assembler::subsd(XMMRegister dst, Address src) {
4900   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4901   InstructionMark im(this);
4902   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4903   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4904   attributes.set_rex_vex_w_reverted();
4905   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4906   emit_int8(0x5C);
4907   emit_operand(dst, src);
4908 }
4909 
4910 void Assembler::subss(XMMRegister dst, XMMRegister src) {
4911   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4912   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true , /* uses_vl */ false);
4913   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4914   emit_int8(0x5C);
4915   emit_int8((unsigned char)(0xC0 | encode));
4916 }
4917 
4918 void Assembler::subss(XMMRegister dst, Address src) {
4919   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4920   InstructionMark im(this);
4921   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4922   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4923   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4924   emit_int8(0x5C);
4925   emit_operand(dst, src);
4926 }
4927 
4928 void Assembler::testb(Register dst, int imm8) {
4929   NOT_LP64(assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;));
4930   (void) prefix_and_encode(dst-&gt;encoding(), true);
4931   emit_arith_b(0xF6, 0xC0, dst, imm8);
4932 }
4933 
4934 void Assembler::testb(Address dst, int imm8) {
4935   InstructionMark im(this);
4936   prefix(dst);
4937   emit_int8((unsigned char)0xF6);
4938   emit_operand(rax, dst, 1);
4939   emit_int8(imm8);
4940 }
4941 
4942 void Assembler::testl(Register dst, int32_t imm32) {
4943   // not using emit_arith because test
4944   // doesn&#39;t support sign-extension of
4945   // 8bit operands
4946   int encode = dst-&gt;encoding();
4947   if (encode == 0) {
4948     emit_int8((unsigned char)0xA9);
4949   } else {
4950     encode = prefix_and_encode(encode);
4951     emit_int8((unsigned char)0xF7);
4952     emit_int8((unsigned char)(0xC0 | encode));
4953   }
4954   emit_int32(imm32);
4955 }
4956 
4957 void Assembler::testl(Register dst, Register src) {
4958   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4959   emit_arith(0x85, 0xC0, dst, src);
4960 }
4961 
4962 void Assembler::testl(Register dst, Address src) {
4963   InstructionMark im(this);
4964   prefix(src, dst);
4965   emit_int8((unsigned char)0x85);
4966   emit_operand(dst, src);
4967 }
4968 
4969 void Assembler::tzcntl(Register dst, Register src) {
4970   assert(VM_Version::supports_bmi1(), &quot;tzcnt instruction not supported&quot;);
4971   emit_int8((unsigned char)0xF3);
4972   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4973   emit_int8(0x0F);
4974   emit_int8((unsigned char)0xBC);
4975   emit_int8((unsigned char)0xC0 | encode);
4976 }
4977 
4978 void Assembler::tzcntq(Register dst, Register src) {
4979   assert(VM_Version::supports_bmi1(), &quot;tzcnt instruction not supported&quot;);
4980   emit_int8((unsigned char)0xF3);
4981   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4982   emit_int8(0x0F);
4983   emit_int8((unsigned char)0xBC);
4984   emit_int8((unsigned char)(0xC0 | encode));
4985 }
4986 
4987 void Assembler::ucomisd(XMMRegister dst, Address src) {
4988   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4989   InstructionMark im(this);
4990   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4991   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4992   attributes.set_rex_vex_w_reverted();
4993   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4994   emit_int8(0x2E);
4995   emit_operand(dst, src);
4996 }
4997 
4998 void Assembler::ucomisd(XMMRegister dst, XMMRegister src) {
4999   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5000   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5001   attributes.set_rex_vex_w_reverted();
5002   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5003   emit_int8(0x2E);
5004   emit_int8((unsigned char)(0xC0 | encode));
5005 }
5006 
5007 void Assembler::ucomiss(XMMRegister dst, Address src) {
5008   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5009   InstructionMark im(this);
5010   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5011   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
5012   simd_prefix(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5013   emit_int8(0x2E);
5014   emit_operand(dst, src);
5015 }
5016 
5017 void Assembler::ucomiss(XMMRegister dst, XMMRegister src) {
5018   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5019   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5020   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5021   emit_int8(0x2E);
5022   emit_int8((unsigned char)(0xC0 | encode));
5023 }
5024 
5025 void Assembler::xabort(int8_t imm8) {
5026   emit_int8((unsigned char)0xC6);
5027   emit_int8((unsigned char)0xF8);
5028   emit_int8((unsigned char)(imm8 &amp; 0xFF));
5029 }
5030 
5031 void Assembler::xaddb(Address dst, Register src) {
5032   InstructionMark im(this);
5033   prefix(dst, src, true);
5034   emit_int8(0x0F);
5035   emit_int8((unsigned char)0xC0);
5036   emit_operand(src, dst);
5037 }
5038 
5039 void Assembler::xaddw(Address dst, Register src) {
5040   InstructionMark im(this);
5041   emit_int8(0x66);
5042   prefix(dst, src);
5043   emit_int8(0x0F);
5044   emit_int8((unsigned char)0xC1);
5045   emit_operand(src, dst);
5046 }
5047 
5048 void Assembler::xaddl(Address dst, Register src) {
5049   InstructionMark im(this);
5050   prefix(dst, src);
5051   emit_int8(0x0F);
5052   emit_int8((unsigned char)0xC1);
5053   emit_operand(src, dst);
5054 }
5055 
5056 void Assembler::xbegin(Label&amp; abort, relocInfo::relocType rtype) {
5057   InstructionMark im(this);
5058   relocate(rtype);
5059   if (abort.is_bound()) {
5060     address entry = target(abort);
5061     assert(entry != NULL, &quot;abort entry NULL&quot;);
5062     intptr_t offset = entry - pc();
5063     emit_int8((unsigned char)0xC7);
5064     emit_int8((unsigned char)0xF8);
5065     emit_int32(offset - 6); // 2 opcode + 4 address
5066   } else {
5067     abort.add_patch_at(code(), locator());
5068     emit_int8((unsigned char)0xC7);
5069     emit_int8((unsigned char)0xF8);
5070     emit_int32(0);
5071   }
5072 }
5073 
5074 void Assembler::xchgb(Register dst, Address src) { // xchg
5075   InstructionMark im(this);
5076   prefix(src, dst, true);
5077   emit_int8((unsigned char)0x86);
5078   emit_operand(dst, src);
5079 }
5080 
5081 void Assembler::xchgw(Register dst, Address src) { // xchg
5082   InstructionMark im(this);
5083   emit_int8(0x66);
5084   prefix(src, dst);
5085   emit_int8((unsigned char)0x87);
5086   emit_operand(dst, src);
5087 }
5088 
5089 void Assembler::xchgl(Register dst, Address src) { // xchg
5090   InstructionMark im(this);
5091   prefix(src, dst);
5092   emit_int8((unsigned char)0x87);
5093   emit_operand(dst, src);
5094 }
5095 
5096 void Assembler::xchgl(Register dst, Register src) {
5097   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
5098   emit_int8((unsigned char)0x87);
5099   emit_int8((unsigned char)(0xC0 | encode));
5100 }
5101 
5102 void Assembler::xend() {
5103   emit_int8((unsigned char)0x0F);
5104   emit_int8((unsigned char)0x01);
5105   emit_int8((unsigned char)0xD5);
5106 }
5107 
5108 void Assembler::xgetbv() {
5109   emit_int8(0x0F);
5110   emit_int8(0x01);
5111   emit_int8((unsigned char)0xD0);
5112 }
5113 
5114 void Assembler::xorl(Register dst, int32_t imm32) {
5115   prefix(dst);
5116   emit_arith(0x81, 0xF0, dst, imm32);
5117 }
5118 
5119 void Assembler::xorl(Register dst, Address src) {
5120   InstructionMark im(this);
5121   prefix(src, dst);
5122   emit_int8(0x33);
5123   emit_operand(dst, src);
5124 }
5125 
5126 void Assembler::xorl(Register dst, Register src) {
5127   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
5128   emit_arith(0x33, 0xC0, dst, src);
5129 }
5130 
5131 void Assembler::xorb(Register dst, Address src) {
5132   InstructionMark im(this);
5133   prefix(src, dst);
5134   emit_int8(0x32);
5135   emit_operand(dst, src);
5136 }
5137 
5138 // AVX 3-operands scalar float-point arithmetic instructions
5139 
5140 void Assembler::vaddsd(XMMRegister dst, XMMRegister nds, Address src) {
5141   assert(VM_Version::supports_avx(), &quot;&quot;);
5142   InstructionMark im(this);
5143   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5144   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
5145   attributes.set_rex_vex_w_reverted();
5146   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
5147   emit_int8(0x58);
5148   emit_operand(dst, src);
5149 }
5150 
5151 void Assembler::vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5152   assert(VM_Version::supports_avx(), &quot;&quot;);
5153   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5154   attributes.set_rex_vex_w_reverted();
5155   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
5156   emit_int8(0x58);
5157   emit_int8((unsigned char)(0xC0 | encode));
5158 }
5159 
5160 void Assembler::vaddss(XMMRegister dst, XMMRegister nds, Address src) {
5161   assert(VM_Version::supports_avx(), &quot;&quot;);
5162   InstructionMark im(this);
5163   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5164   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
5165   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
5166   emit_int8(0x58);
5167   emit_operand(dst, src);
5168 }
5169 
5170 void Assembler::vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5171   assert(VM_Version::supports_avx(), &quot;&quot;);
5172   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5173   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
5174   emit_int8(0x58);
5175   emit_int8((unsigned char)(0xC0 | encode));
5176 }
5177 
5178 void Assembler::vdivsd(XMMRegister dst, XMMRegister nds, Address src) {
5179   assert(VM_Version::supports_avx(), &quot;&quot;);
5180   InstructionMark im(this);
5181   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5182   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
5183   attributes.set_rex_vex_w_reverted();
5184   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
5185   emit_int8(0x5E);
5186   emit_operand(dst, src);
5187 }
5188 
5189 void Assembler::vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5190   assert(VM_Version::supports_avx(), &quot;&quot;);
5191   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5192   attributes.set_rex_vex_w_reverted();
5193   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
5194   emit_int8(0x5E);
5195   emit_int8((unsigned char)(0xC0 | encode));
5196 }
5197 
5198 void Assembler::vdivss(XMMRegister dst, XMMRegister nds, Address src) {
5199   assert(VM_Version::supports_avx(), &quot;&quot;);
5200   InstructionMark im(this);
5201   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5202   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
5203   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
5204   emit_int8(0x5E);
5205   emit_operand(dst, src);
5206 }
5207 
5208 void Assembler::vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5209   assert(VM_Version::supports_avx(), &quot;&quot;);
5210   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5211   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
5212   emit_int8(0x5E);
5213   emit_int8((unsigned char)(0xC0 | encode));
5214 }
5215 
5216 void Assembler::vfmadd231sd(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
5217   assert(VM_Version::supports_fma(), &quot;&quot;);
5218   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5219   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5220   emit_int8((unsigned char)0xB9);
5221   emit_int8((unsigned char)(0xC0 | encode));
5222 }
5223 
5224 void Assembler::vfmadd231ss(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
5225   assert(VM_Version::supports_fma(), &quot;&quot;);
5226   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5227   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5228   emit_int8((unsigned char)0xB9);
5229   emit_int8((unsigned char)(0xC0 | encode));
5230 }
5231 
5232 void Assembler::vmulsd(XMMRegister dst, XMMRegister nds, Address src) {
5233   assert(VM_Version::supports_avx(), &quot;&quot;);
5234   InstructionMark im(this);
5235   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5236   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
5237   attributes.set_rex_vex_w_reverted();
5238   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
5239   emit_int8(0x59);
5240   emit_operand(dst, src);
5241 }
5242 
5243 void Assembler::vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5244   assert(VM_Version::supports_avx(), &quot;&quot;);
5245   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5246   attributes.set_rex_vex_w_reverted();
5247   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
5248   emit_int8(0x59);
5249   emit_int8((unsigned char)(0xC0 | encode));
5250 }
5251 
5252 void Assembler::vmulss(XMMRegister dst, XMMRegister nds, Address src) {
5253   assert(VM_Version::supports_avx(), &quot;&quot;);
5254   InstructionMark im(this);
5255   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5256   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
5257   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
5258   emit_int8(0x59);
5259   emit_operand(dst, src);
5260 }
5261 
5262 void Assembler::vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5263   assert(VM_Version::supports_avx(), &quot;&quot;);
5264   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5265   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
5266   emit_int8(0x59);
5267   emit_int8((unsigned char)(0xC0 | encode));
5268 }
5269 
5270 void Assembler::vsubsd(XMMRegister dst, XMMRegister nds, Address src) {
5271   assert(VM_Version::supports_avx(), &quot;&quot;);
5272   InstructionMark im(this);
5273   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5274   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
5275   attributes.set_rex_vex_w_reverted();
5276   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
5277   emit_int8(0x5C);
5278   emit_operand(dst, src);
5279 }
5280 
5281 void Assembler::vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5282   assert(VM_Version::supports_avx(), &quot;&quot;);
5283   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5284   attributes.set_rex_vex_w_reverted();
5285   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
5286   emit_int8(0x5C);
5287   emit_int8((unsigned char)(0xC0 | encode));
5288 }
5289 
5290 void Assembler::vsubss(XMMRegister dst, XMMRegister nds, Address src) {
5291   assert(VM_Version::supports_avx(), &quot;&quot;);
5292   InstructionMark im(this);
5293   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5294   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
5295   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
5296   emit_int8(0x5C);
5297   emit_operand(dst, src);
5298 }
5299 
5300 void Assembler::vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5301   assert(VM_Version::supports_avx(), &quot;&quot;);
5302   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5303   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
5304   emit_int8(0x5C);
5305   emit_int8((unsigned char)(0xC0 | encode));
5306 }
5307 
5308 //====================VECTOR ARITHMETIC=====================================
5309 
5310 // Float-point vector arithmetic
5311 
5312 void Assembler::addpd(XMMRegister dst, XMMRegister src) {
5313   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5314   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5315   attributes.set_rex_vex_w_reverted();
5316   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5317   emit_int8(0x58);
5318   emit_int8((unsigned char)(0xC0 | encode));
5319 }
5320 
5321 void Assembler::addpd(XMMRegister dst, Address src) {
5322   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5323   InstructionMark im(this);
5324   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5325   attributes.set_rex_vex_w_reverted();
5326   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5327   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5328   emit_int8(0x58);
5329   emit_operand(dst, src);
5330 }
5331 
5332 
5333 void Assembler::addps(XMMRegister dst, XMMRegister src) {
5334   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5335   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5336   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5337   emit_int8(0x58);
5338   emit_int8((unsigned char)(0xC0 | encode));
5339 }
5340 
5341 void Assembler::vaddpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5342   assert(VM_Version::supports_avx(), &quot;&quot;);
5343   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5344   attributes.set_rex_vex_w_reverted();
5345   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5346   emit_int8(0x58);
5347   emit_int8((unsigned char)(0xC0 | encode));
5348 }
5349 
5350 void Assembler::vaddps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5351   assert(VM_Version::supports_avx(), &quot;&quot;);
5352   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5353   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5354   emit_int8(0x58);
5355   emit_int8((unsigned char)(0xC0 | encode));
5356 }
5357 
5358 void Assembler::vaddpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5359   assert(VM_Version::supports_avx(), &quot;&quot;);
5360   InstructionMark im(this);
5361   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5362   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5363   attributes.set_rex_vex_w_reverted();
5364   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5365   emit_int8(0x58);
5366   emit_operand(dst, src);
5367 }
5368 
5369 void Assembler::vaddps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5370   assert(VM_Version::supports_avx(), &quot;&quot;);
5371   InstructionMark im(this);
5372   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5373   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5374   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5375   emit_int8(0x58);
5376   emit_operand(dst, src);
5377 }
5378 
5379 void Assembler::subpd(XMMRegister dst, XMMRegister src) {
5380   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5381   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5382   attributes.set_rex_vex_w_reverted();
5383   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5384   emit_int8(0x5C);
5385   emit_int8((unsigned char)(0xC0 | encode));
5386 }
5387 
5388 void Assembler::subps(XMMRegister dst, XMMRegister src) {
5389   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5390   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5391   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5392   emit_int8(0x5C);
5393   emit_int8((unsigned char)(0xC0 | encode));
5394 }
5395 
5396 void Assembler::vsubpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5397   assert(VM_Version::supports_avx(), &quot;&quot;);
5398   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5399   attributes.set_rex_vex_w_reverted();
5400   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5401   emit_int8(0x5C);
5402   emit_int8((unsigned char)(0xC0 | encode));
5403 }
5404 
5405 void Assembler::vsubps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5406   assert(VM_Version::supports_avx(), &quot;&quot;);
5407   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5408   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5409   emit_int8(0x5C);
5410   emit_int8((unsigned char)(0xC0 | encode));
5411 }
5412 
5413 void Assembler::vsubpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5414   assert(VM_Version::supports_avx(), &quot;&quot;);
5415   InstructionMark im(this);
5416   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5417   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5418   attributes.set_rex_vex_w_reverted();
5419   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5420   emit_int8(0x5C);
5421   emit_operand(dst, src);
5422 }
5423 
5424 void Assembler::vsubps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5425   assert(VM_Version::supports_avx(), &quot;&quot;);
5426   InstructionMark im(this);
5427   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5428   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5429   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5430   emit_int8(0x5C);
5431   emit_operand(dst, src);
5432 }
5433 
5434 void Assembler::mulpd(XMMRegister dst, XMMRegister src) {
5435   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5436   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5437   attributes.set_rex_vex_w_reverted();
5438   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5439   emit_int8(0x59);
5440   emit_int8((unsigned char)(0xC0 | encode));
5441 }
5442 
5443 void Assembler::mulpd(XMMRegister dst, Address src) {
5444   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5445   InstructionMark im(this);
5446   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5447   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5448   attributes.set_rex_vex_w_reverted();
5449   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5450   emit_int8(0x59);
5451   emit_operand(dst, src);
5452 }
5453 
5454 void Assembler::mulps(XMMRegister dst, XMMRegister src) {
5455   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5456   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5457   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5458   emit_int8(0x59);
5459   emit_int8((unsigned char)(0xC0 | encode));
5460 }
5461 
5462 void Assembler::vmulpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5463   assert(VM_Version::supports_avx(), &quot;&quot;);
5464   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5465   attributes.set_rex_vex_w_reverted();
5466   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5467   emit_int8(0x59);
5468   emit_int8((unsigned char)(0xC0 | encode));
5469 }
5470 
5471 void Assembler::vmulps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5472   assert(VM_Version::supports_avx(), &quot;&quot;);
5473   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5474   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5475   emit_int8(0x59);
5476   emit_int8((unsigned char)(0xC0 | encode));
5477 }
5478 
5479 void Assembler::vmulpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5480   assert(VM_Version::supports_avx(), &quot;&quot;);
5481   InstructionMark im(this);
5482   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5483   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5484   attributes.set_rex_vex_w_reverted();
5485   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5486   emit_int8(0x59);
5487   emit_operand(dst, src);
5488 }
5489 
5490 void Assembler::vmulps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5491   assert(VM_Version::supports_avx(), &quot;&quot;);
5492   InstructionMark im(this);
5493   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5494   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5495   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5496   emit_int8(0x59);
5497   emit_operand(dst, src);
5498 }
5499 
5500 void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
5501   assert(VM_Version::supports_fma(), &quot;&quot;);
5502   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5503   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5504   emit_int8((unsigned char)0xB8);
5505   emit_int8((unsigned char)(0xC0 | encode));
5506 }
5507 
5508 void Assembler::vfmadd231ps(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
5509   assert(VM_Version::supports_fma(), &quot;&quot;);
5510   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5511   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5512   emit_int8((unsigned char)0xB8);
5513   emit_int8((unsigned char)(0xC0 | encode));
5514 }
5515 
5516 void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {
5517   assert(VM_Version::supports_fma(), &quot;&quot;);
5518   InstructionMark im(this);
5519   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5520   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5521   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5522   emit_int8((unsigned char)0xB8);
5523   emit_operand(dst, src2);
5524 }
5525 
5526 void Assembler::vfmadd231ps(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {
5527   assert(VM_Version::supports_fma(), &quot;&quot;);
5528   InstructionMark im(this);
5529   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5530   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5531   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5532   emit_int8((unsigned char)0xB8);
5533   emit_operand(dst, src2);
5534 }
5535 
5536 void Assembler::divpd(XMMRegister dst, XMMRegister src) {
5537   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5538   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5539   attributes.set_rex_vex_w_reverted();
5540   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5541   emit_int8(0x5E);
5542   emit_int8((unsigned char)(0xC0 | encode));
5543 }
5544 
5545 void Assembler::divps(XMMRegister dst, XMMRegister src) {
5546   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5547   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5548   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5549   emit_int8(0x5E);
5550   emit_int8((unsigned char)(0xC0 | encode));
5551 }
5552 
5553 void Assembler::vdivpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5554   assert(VM_Version::supports_avx(), &quot;&quot;);
5555   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5556   attributes.set_rex_vex_w_reverted();
5557   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5558   emit_int8(0x5E);
5559   emit_int8((unsigned char)(0xC0 | encode));
5560 }
5561 
5562 void Assembler::vdivps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5563   assert(VM_Version::supports_avx(), &quot;&quot;);
5564   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5565   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5566   emit_int8(0x5E);
5567   emit_int8((unsigned char)(0xC0 | encode));
5568 }
5569 
5570 void Assembler::vdivpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5571   assert(VM_Version::supports_avx(), &quot;&quot;);
5572   InstructionMark im(this);
5573   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5574   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5575   attributes.set_rex_vex_w_reverted();
5576   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5577   emit_int8(0x5E);
5578   emit_operand(dst, src);
5579 }
5580 
5581 void Assembler::vdivps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5582   assert(VM_Version::supports_avx(), &quot;&quot;);
5583   InstructionMark im(this);
5584   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5585   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5586   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5587   emit_int8(0x5E);
5588   emit_operand(dst, src);
5589 }
5590 
5591 void Assembler::vroundpd(XMMRegister dst, XMMRegister src, int32_t rmode, int vector_len) {
5592   assert(VM_Version::supports_avx(), &quot;&quot;);
5593   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
5594   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
5595   emit_int8(0x09);
5596   emit_int8((unsigned char)(0xC0 | encode));
5597   emit_int8((unsigned char)(rmode));
5598 }
5599 
5600 void Assembler::vroundpd(XMMRegister dst, Address src, int32_t rmode,  int vector_len) {
5601   assert(VM_Version::supports_avx(), &quot;&quot;);
5602   InstructionMark im(this);
5603   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
5604   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
5605   emit_int8(0x09);
5606   emit_operand(dst, src);
5607   emit_int8((unsigned char)(rmode));
5608 }
5609 
5610 void Assembler::vrndscalepd(XMMRegister dst,  XMMRegister src,  int32_t rmode, int vector_len) {
5611   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
5612   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5613   attributes.set_is_evex_instruction();
5614   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
5615   emit_int8((unsigned char)0x09);
5616   emit_int8((unsigned char)(0xC0 | encode));
5617   emit_int8((unsigned char)(rmode));
5618 }
5619 
5620 void Assembler::vrndscalepd(XMMRegister dst, Address src, int32_t rmode, int vector_len) {
5621   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
5622   assert(dst != xnoreg, &quot;sanity&quot;);
5623   InstructionMark im(this);
5624   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5625   attributes.set_is_evex_instruction();
5626   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5627   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
5628   emit_int8((unsigned char)0x09);
5629   emit_operand(dst, src);
5630   emit_int8((unsigned char)(rmode));
5631 }
5632 
5633 
5634 void Assembler::vsqrtpd(XMMRegister dst, XMMRegister src, int vector_len) {
5635   assert(VM_Version::supports_avx(), &quot;&quot;);
5636   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5637   attributes.set_rex_vex_w_reverted();
5638   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5639   emit_int8(0x51);
5640   emit_int8((unsigned char)(0xC0 | encode));
5641 }
5642 
5643 void Assembler::vsqrtpd(XMMRegister dst, Address src, int vector_len) {
5644   assert(VM_Version::supports_avx(), &quot;&quot;);
5645   InstructionMark im(this);
5646   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5647   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5648   attributes.set_rex_vex_w_reverted();
5649   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5650   emit_int8(0x51);
5651   emit_operand(dst, src);
5652 }
5653 
5654 void Assembler::vsqrtps(XMMRegister dst, XMMRegister src, int vector_len) {
5655   assert(VM_Version::supports_avx(), &quot;&quot;);
5656   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5657   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5658   emit_int8(0x51);
5659   emit_int8((unsigned char)(0xC0 | encode));
5660 }
5661 
5662 void Assembler::vsqrtps(XMMRegister dst, Address src, int vector_len) {
5663   assert(VM_Version::supports_avx(), &quot;&quot;);
5664   InstructionMark im(this);
5665   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5666   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5667   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5668   emit_int8(0x51);
5669   emit_operand(dst, src);
5670 }
5671 
5672 void Assembler::andpd(XMMRegister dst, XMMRegister src) {
5673   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5674   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5675   attributes.set_rex_vex_w_reverted();
5676   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5677   emit_int8(0x54);
5678   emit_int8((unsigned char)(0xC0 | encode));
5679 }
5680 
5681 void Assembler::andps(XMMRegister dst, XMMRegister src) {
5682   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5683   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5684   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5685   emit_int8(0x54);
5686   emit_int8((unsigned char)(0xC0 | encode));
5687 }
5688 
5689 void Assembler::andps(XMMRegister dst, Address src) {
5690   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5691   InstructionMark im(this);
5692   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5693   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5694   simd_prefix(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5695   emit_int8(0x54);
5696   emit_operand(dst, src);
5697 }
5698 
5699 void Assembler::andpd(XMMRegister dst, Address src) {
5700   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5701   InstructionMark im(this);
5702   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5703   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5704   attributes.set_rex_vex_w_reverted();
5705   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5706   emit_int8(0x54);
5707   emit_operand(dst, src);
5708 }
5709 
5710 void Assembler::vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5711   assert(VM_Version::supports_avx(), &quot;&quot;);
5712   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5713   attributes.set_rex_vex_w_reverted();
5714   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5715   emit_int8(0x54);
5716   emit_int8((unsigned char)(0xC0 | encode));
5717 }
5718 
5719 void Assembler::vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5720   assert(VM_Version::supports_avx(), &quot;&quot;);
5721   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5722   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5723   emit_int8(0x54);
5724   emit_int8((unsigned char)(0xC0 | encode));
5725 }
5726 
5727 void Assembler::vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5728   assert(VM_Version::supports_avx(), &quot;&quot;);
5729   InstructionMark im(this);
5730   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5731   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5732   attributes.set_rex_vex_w_reverted();
5733   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5734   emit_int8(0x54);
5735   emit_operand(dst, src);
5736 }
5737 
5738 void Assembler::vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5739   assert(VM_Version::supports_avx(), &quot;&quot;);
5740   InstructionMark im(this);
5741   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5742   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5743   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5744   emit_int8(0x54);
5745   emit_operand(dst, src);
5746 }
5747 
5748 void Assembler::unpckhpd(XMMRegister dst, XMMRegister src) {
5749   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5750   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5751   attributes.set_rex_vex_w_reverted();
5752   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5753   emit_int8(0x15);
5754   emit_int8((unsigned char)(0xC0 | encode));
5755 }
5756 
5757 void Assembler::unpcklpd(XMMRegister dst, XMMRegister src) {
5758   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5759   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5760   attributes.set_rex_vex_w_reverted();
5761   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5762   emit_int8(0x14);
5763   emit_int8((unsigned char)(0xC0 | encode));
5764 }
5765 
5766 void Assembler::xorpd(XMMRegister dst, XMMRegister src) {
5767   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5768   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5769   attributes.set_rex_vex_w_reverted();
5770   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5771   emit_int8(0x57);
5772   emit_int8((unsigned char)(0xC0 | encode));
5773 }
5774 
5775 void Assembler::xorps(XMMRegister dst, XMMRegister src) {
5776   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5777   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5778   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5779   emit_int8(0x57);
5780   emit_int8((unsigned char)(0xC0 | encode));
5781 }
5782 
5783 void Assembler::xorpd(XMMRegister dst, Address src) {
5784   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5785   InstructionMark im(this);
5786   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5787   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5788   attributes.set_rex_vex_w_reverted();
5789   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5790   emit_int8(0x57);
5791   emit_operand(dst, src);
5792 }
5793 
5794 void Assembler::xorps(XMMRegister dst, Address src) {
5795   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5796   InstructionMark im(this);
5797   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5798   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5799   simd_prefix(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5800   emit_int8(0x57);
5801   emit_operand(dst, src);
5802 }
5803 
5804 void Assembler::vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5805   assert(VM_Version::supports_avx(), &quot;&quot;);
5806   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5807   attributes.set_rex_vex_w_reverted();
5808   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5809   emit_int8(0x57);
5810   emit_int8((unsigned char)(0xC0 | encode));
5811 }
5812 
5813 void Assembler::vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5814   assert(VM_Version::supports_avx(), &quot;&quot;);
5815   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5816   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5817   emit_int8(0x57);
5818   emit_int8((unsigned char)(0xC0 | encode));
5819 }
5820 
5821 void Assembler::vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5822   assert(VM_Version::supports_avx(), &quot;&quot;);
5823   InstructionMark im(this);
5824   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5825   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5826   attributes.set_rex_vex_w_reverted();
5827   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5828   emit_int8(0x57);
5829   emit_operand(dst, src);
5830 }
5831 
5832 void Assembler::vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5833   assert(VM_Version::supports_avx(), &quot;&quot;);
5834   InstructionMark im(this);
5835   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5836   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5837   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5838   emit_int8(0x57);
5839   emit_operand(dst, src);
5840 }
5841 
5842 // Integer vector arithmetic
5843 void Assembler::vphaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5844   assert(VM_Version::supports_avx() &amp;&amp; (vector_len == 0) ||
5845          VM_Version::supports_avx2(), &quot;256 bit integer vectors requires AVX2&quot;);
5846   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5847   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5848   emit_int8(0x01);
5849   emit_int8((unsigned char)(0xC0 | encode));
5850 }
5851 
5852 void Assembler::vphaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5853   assert(VM_Version::supports_avx() &amp;&amp; (vector_len == 0) ||
5854          VM_Version::supports_avx2(), &quot;256 bit integer vectors requires AVX2&quot;);
5855   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5856   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5857   emit_int8(0x02);
5858   emit_int8((unsigned char)(0xC0 | encode));
5859 }
5860 
5861 void Assembler::paddb(XMMRegister dst, XMMRegister src) {
5862   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5863   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5864   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5865   emit_int8((unsigned char)0xFC);
5866   emit_int8((unsigned char)(0xC0 | encode));
5867 }
5868 
5869 void Assembler::paddw(XMMRegister dst, XMMRegister src) {
5870   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5871   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5872   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5873   emit_int8((unsigned char)0xFD);
5874   emit_int8((unsigned char)(0xC0 | encode));
5875 }
5876 
5877 void Assembler::paddd(XMMRegister dst, XMMRegister src) {
5878   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5879   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5880   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5881   emit_int8((unsigned char)0xFE);
5882   emit_int8((unsigned char)(0xC0 | encode));
5883 }
5884 
5885 void Assembler::paddd(XMMRegister dst, Address src) {
5886   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5887   InstructionMark im(this);
5888   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5889   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5890   emit_int8((unsigned char)0xFE);
5891   emit_operand(dst, src);
5892 }
5893 
5894 void Assembler::paddq(XMMRegister dst, XMMRegister src) {
5895   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5896   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5897   attributes.set_rex_vex_w_reverted();
5898   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5899   emit_int8((unsigned char)0xD4);
5900   emit_int8((unsigned char)(0xC0 | encode));
5901 }
5902 
5903 void Assembler::phaddw(XMMRegister dst, XMMRegister src) {
5904   assert(VM_Version::supports_sse3(), &quot;&quot;);
5905   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5906   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5907   emit_int8(0x01);
5908   emit_int8((unsigned char)(0xC0 | encode));
5909 }
5910 
5911 void Assembler::phaddd(XMMRegister dst, XMMRegister src) {
5912   assert(VM_Version::supports_sse3(), &quot;&quot;);
5913   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5914   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5915   emit_int8(0x02);
5916   emit_int8((unsigned char)(0xC0 | encode));
5917 }
5918 
5919 void Assembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5920   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5921   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5922   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5923   emit_int8((unsigned char)0xFC);
5924   emit_int8((unsigned char)(0xC0 | encode));
5925 }
5926 
5927 void Assembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5928   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5929   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5930   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5931   emit_int8((unsigned char)0xFD);
5932   emit_int8((unsigned char)(0xC0 | encode));
5933 }
5934 
5935 void Assembler::vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5936   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5937   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5938   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5939   emit_int8((unsigned char)0xFE);
5940   emit_int8((unsigned char)(0xC0 | encode));
5941 }
5942 
5943 void Assembler::vpaddq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5944   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5945   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5946   attributes.set_rex_vex_w_reverted();
5947   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5948   emit_int8((unsigned char)0xD4);
5949   emit_int8((unsigned char)(0xC0 | encode));
5950 }
5951 
5952 void Assembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5953   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5954   InstructionMark im(this);
5955   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5956   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
5957   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5958   emit_int8((unsigned char)0xFC);
5959   emit_operand(dst, src);
5960 }
5961 
5962 void Assembler::vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5963   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5964   InstructionMark im(this);
5965   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5966   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
5967   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5968   emit_int8((unsigned char)0xFD);
5969   emit_operand(dst, src);
5970 }
5971 
5972 void Assembler::vpaddd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5973   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5974   InstructionMark im(this);
5975   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5976   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5977   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5978   emit_int8((unsigned char)0xFE);
5979   emit_operand(dst, src);
5980 }
5981 
5982 void Assembler::vpaddq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5983   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5984   InstructionMark im(this);
5985   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5986   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5987   attributes.set_rex_vex_w_reverted();
5988   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5989   emit_int8((unsigned char)0xD4);
5990   emit_operand(dst, src);
5991 }
5992 
5993 void Assembler::psubb(XMMRegister dst, XMMRegister src) {
5994   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5995   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5996   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5997   emit_int8((unsigned char)0xF8);
5998   emit_int8((unsigned char)(0xC0 | encode));
5999 }
6000 
6001 void Assembler::psubw(XMMRegister dst, XMMRegister src) {
6002   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6003   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6004   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6005   emit_int8((unsigned char)0xF9);
6006   emit_int8((unsigned char)(0xC0 | encode));
6007 }
6008 
6009 void Assembler::psubd(XMMRegister dst, XMMRegister src) {
6010   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6011   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6012   emit_int8((unsigned char)0xFA);
6013   emit_int8((unsigned char)(0xC0 | encode));
6014 }
6015 
6016 void Assembler::psubq(XMMRegister dst, XMMRegister src) {
6017   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6018   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6019   attributes.set_rex_vex_w_reverted();
6020   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6021   emit_int8((unsigned char)0xFB);
6022   emit_int8((unsigned char)(0xC0 | encode));
6023 }
6024 
6025 void Assembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6026   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6027   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6028   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6029   emit_int8((unsigned char)0xF8);
6030   emit_int8((unsigned char)(0xC0 | encode));
6031 }
6032 
6033 void Assembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6034   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6035   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6036   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6037   emit_int8((unsigned char)0xF9);
6038   emit_int8((unsigned char)(0xC0 | encode));
6039 }
6040 
6041 void Assembler::vpsubd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6042   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6043   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6044   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6045   emit_int8((unsigned char)0xFA);
6046   emit_int8((unsigned char)(0xC0 | encode));
6047 }
6048 
6049 void Assembler::vpsubq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6050   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6051   InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6052   attributes.set_rex_vex_w_reverted();
6053   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6054   emit_int8((unsigned char)0xFB);
6055   emit_int8((unsigned char)(0xC0 | encode));
6056 }
6057 
6058 void Assembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6059   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6060   InstructionMark im(this);
6061   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6062   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
6063   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6064   emit_int8((unsigned char)0xF8);
6065   emit_operand(dst, src);
6066 }
6067 
6068 void Assembler::vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6069   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6070   InstructionMark im(this);
6071   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6072   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
6073   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6074   emit_int8((unsigned char)0xF9);
6075   emit_operand(dst, src);
6076 }
6077 
6078 void Assembler::vpsubd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6079   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6080   InstructionMark im(this);
6081   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6082   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6083   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6084   emit_int8((unsigned char)0xFA);
6085   emit_operand(dst, src);
6086 }
6087 
6088 void Assembler::vpsubq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6089   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6090   InstructionMark im(this);
6091   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6092   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
6093   attributes.set_rex_vex_w_reverted();
6094   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6095   emit_int8((unsigned char)0xFB);
6096   emit_operand(dst, src);
6097 }
6098 
6099 void Assembler::pmullw(XMMRegister dst, XMMRegister src) {
6100   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6101   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6102   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6103   emit_int8((unsigned char)0xD5);
6104   emit_int8((unsigned char)(0xC0 | encode));
6105 }
6106 
6107 void Assembler::pmulld(XMMRegister dst, XMMRegister src) {
6108   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
6109   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6110   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6111   emit_int8(0x40);
6112   emit_int8((unsigned char)(0xC0 | encode));
6113 }
6114 
6115 void Assembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6116   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6117   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6118   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6119   emit_int8((unsigned char)0xD5);
6120   emit_int8((unsigned char)(0xC0 | encode));
6121 }
6122 
6123 void Assembler::vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6124   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6125   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6126   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6127   emit_int8(0x40);
6128   emit_int8((unsigned char)(0xC0 | encode));
6129 }
6130 
6131 void Assembler::vpmullq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6132   assert(UseAVX &gt; 2, &quot;requires some form of EVEX&quot;);
6133   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
6134   attributes.set_is_evex_instruction();
6135   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6136   emit_int8(0x40);
6137   emit_int8((unsigned char)(0xC0 | encode));
6138 }
6139 
6140 void Assembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6141   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6142   InstructionMark im(this);
6143   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6144   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
6145   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6146   emit_int8((unsigned char)0xD5);
6147   emit_operand(dst, src);
6148 }
6149 
6150 void Assembler::vpmulld(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6151   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6152   InstructionMark im(this);
6153   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6154   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6155   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6156   emit_int8(0x40);
6157   emit_operand(dst, src);
6158 }
6159 
6160 void Assembler::vpmullq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6161   assert(UseAVX &gt; 2, &quot;requires some form of EVEX&quot;);
6162   InstructionMark im(this);
6163   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
6164   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
6165   attributes.set_is_evex_instruction();
6166   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6167   emit_int8(0x40);
6168   emit_operand(dst, src);
6169 }
6170 
6171 // Shift packed integers left by specified number of bits.
6172 void Assembler::psllw(XMMRegister dst, int shift) {
6173   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6174   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6175   // XMM6 is for /6 encoding: 66 0F 71 /6 ib
6176   int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6177   emit_int8(0x71);
6178   emit_int8((unsigned char)(0xC0 | encode));
6179   emit_int8(shift &amp; 0xFF);
6180 }
6181 
6182 void Assembler::pslld(XMMRegister dst, int shift) {
6183   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6184   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6185   // XMM6 is for /6 encoding: 66 0F 72 /6 ib
6186   int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6187   emit_int8(0x72);
6188   emit_int8((unsigned char)(0xC0 | encode));
6189   emit_int8(shift &amp; 0xFF);
6190 }
6191 
6192 void Assembler::psllq(XMMRegister dst, int shift) {
6193   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6194   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6195   // XMM6 is for /6 encoding: 66 0F 73 /6 ib
6196   int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6197   emit_int8(0x73);
6198   emit_int8((unsigned char)(0xC0 | encode));
6199   emit_int8(shift &amp; 0xFF);
6200 }
6201 
6202 void Assembler::psllw(XMMRegister dst, XMMRegister shift) {
6203   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6204   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6205   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6206   emit_int8((unsigned char)0xF1);
6207   emit_int8((unsigned char)(0xC0 | encode));
6208 }
6209 
6210 void Assembler::pslld(XMMRegister dst, XMMRegister shift) {
6211   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6212   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6213   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6214   emit_int8((unsigned char)0xF2);
6215   emit_int8((unsigned char)(0xC0 | encode));
6216 }
6217 
6218 void Assembler::psllq(XMMRegister dst, XMMRegister shift) {
6219   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6220   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6221   attributes.set_rex_vex_w_reverted();
6222   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6223   emit_int8((unsigned char)0xF3);
6224   emit_int8((unsigned char)(0xC0 | encode));
6225 }
6226 
6227 void Assembler::vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6228   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6229   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6230   // XMM6 is for /6 encoding: 66 0F 71 /6 ib
6231   int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6232   emit_int8(0x71);
6233   emit_int8((unsigned char)(0xC0 | encode));
6234   emit_int8(shift &amp; 0xFF);
6235 }
6236 
6237 void Assembler::vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6238   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6239   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6240   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6241   // XMM6 is for /6 encoding: 66 0F 72 /6 ib
6242   int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6243   emit_int8(0x72);
6244   emit_int8((unsigned char)(0xC0 | encode));
6245   emit_int8(shift &amp; 0xFF);
6246 }
6247 
6248 void Assembler::vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6249   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6250   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6251   attributes.set_rex_vex_w_reverted();
6252   // XMM6 is for /6 encoding: 66 0F 73 /6 ib
6253   int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6254   emit_int8(0x73);
6255   emit_int8((unsigned char)(0xC0 | encode));
6256   emit_int8(shift &amp; 0xFF);
6257 }
6258 
6259 void Assembler::vpsllw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6260   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6261   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6262   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6263   emit_int8((unsigned char)0xF1);
6264   emit_int8((unsigned char)(0xC0 | encode));
6265 }
6266 
6267 void Assembler::vpslld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6268   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6269   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6270   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6271   emit_int8((unsigned char)0xF2);
6272   emit_int8((unsigned char)(0xC0 | encode));
6273 }
6274 
6275 void Assembler::vpsllq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6276   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6277   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6278   attributes.set_rex_vex_w_reverted();
6279   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6280   emit_int8((unsigned char)0xF3);
6281   emit_int8((unsigned char)(0xC0 | encode));
6282 }
6283 
6284 // Shift packed integers logically right by specified number of bits.
6285 void Assembler::psrlw(XMMRegister dst, int shift) {
6286   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6287   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6288   // XMM2 is for /2 encoding: 66 0F 71 /2 ib
6289   int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6290   emit_int8(0x71);
6291   emit_int8((unsigned char)(0xC0 | encode));
6292   emit_int8(shift &amp; 0xFF);
6293 }
6294 
6295 void Assembler::psrld(XMMRegister dst, int shift) {
6296   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6297   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6298   // XMM2 is for /2 encoding: 66 0F 72 /2 ib
6299   int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6300   emit_int8(0x72);
6301   emit_int8((unsigned char)(0xC0 | encode));
6302   emit_int8(shift &amp; 0xFF);
6303 }
6304 
6305 void Assembler::psrlq(XMMRegister dst, int shift) {
6306   // Do not confuse it with psrldq SSE2 instruction which
6307   // shifts 128 bit value in xmm register by number of bytes.
6308   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6309   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6310   attributes.set_rex_vex_w_reverted();
6311   // XMM2 is for /2 encoding: 66 0F 73 /2 ib
6312   int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6313   emit_int8(0x73);
6314   emit_int8((unsigned char)(0xC0 | encode));
6315   emit_int8(shift &amp; 0xFF);
6316 }
6317 
6318 void Assembler::psrlw(XMMRegister dst, XMMRegister shift) {
6319   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6320   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6321   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6322   emit_int8((unsigned char)0xD1);
6323   emit_int8((unsigned char)(0xC0 | encode));
6324 }
6325 
6326 void Assembler::psrld(XMMRegister dst, XMMRegister shift) {
6327   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6328   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6329   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6330   emit_int8((unsigned char)0xD2);
6331   emit_int8((unsigned char)(0xC0 | encode));
6332 }
6333 
6334 void Assembler::psrlq(XMMRegister dst, XMMRegister shift) {
6335   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6336   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6337   attributes.set_rex_vex_w_reverted();
6338   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6339   emit_int8((unsigned char)0xD3);
6340   emit_int8((unsigned char)(0xC0 | encode));
6341 }
6342 
6343 void Assembler::vpsrlw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6344   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6345   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6346   // XMM2 is for /2 encoding: 66 0F 71 /2 ib
6347   int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6348   emit_int8(0x71);
6349   emit_int8((unsigned char)(0xC0 | encode));
6350   emit_int8(shift &amp; 0xFF);
6351 }
6352 
6353 void Assembler::vpsrld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6354   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6355   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6356   // XMM2 is for /2 encoding: 66 0F 72 /2 ib
6357   int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6358   emit_int8(0x72);
6359   emit_int8((unsigned char)(0xC0 | encode));
6360   emit_int8(shift &amp; 0xFF);
6361 }
6362 
6363 void Assembler::vpsrlq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6364   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6365   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6366   attributes.set_rex_vex_w_reverted();
6367   // XMM2 is for /2 encoding: 66 0F 73 /2 ib
6368   int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6369   emit_int8(0x73);
6370   emit_int8((unsigned char)(0xC0 | encode));
6371   emit_int8(shift &amp; 0xFF);
6372 }
6373 
6374 void Assembler::vpsrlw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6375   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6376   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6377   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6378   emit_int8((unsigned char)0xD1);
6379   emit_int8((unsigned char)(0xC0 | encode));
6380 }
6381 
6382 void Assembler::vpsrld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6383   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6384   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6385   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6386   emit_int8((unsigned char)0xD2);
6387   emit_int8((unsigned char)(0xC0 | encode));
6388 }
6389 
6390 void Assembler::vpsrlq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6391   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6392   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6393   attributes.set_rex_vex_w_reverted();
6394   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6395   emit_int8((unsigned char)0xD3);
6396   emit_int8((unsigned char)(0xC0 | encode));
6397 }
6398 
6399 void Assembler::evpsrlvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6400   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
6401   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6402   attributes.set_is_evex_instruction();
6403   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6404   emit_int8(0x10);
6405   emit_int8((unsigned char)(0xC0 | encode));
6406 }
6407 
6408 void Assembler::evpsllvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6409   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
6410   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6411   attributes.set_is_evex_instruction();
6412   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6413   emit_int8(0x12);
6414   emit_int8((unsigned char)(0xC0 | encode));
6415 }
6416 
6417 // Shift packed integers arithmetically right by specified number of bits.
6418 void Assembler::psraw(XMMRegister dst, int shift) {
6419   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6420   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6421   // XMM4 is for /4 encoding: 66 0F 71 /4 ib
6422   int encode = simd_prefix_and_encode(xmm4, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6423   emit_int8(0x71);
6424   emit_int8((unsigned char)(0xC0 | encode));
6425   emit_int8(shift &amp; 0xFF);
6426 }
6427 
6428 void Assembler::psrad(XMMRegister dst, int shift) {
6429   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6430   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6431   // XMM4 is for /4 encoding: 66 0F 72 /4 ib
6432   int encode = simd_prefix_and_encode(xmm4, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6433   emit_int8(0x72);
6434   emit_int8((unsigned char)(0xC0 | encode));
6435   emit_int8(shift &amp; 0xFF);
6436 }
6437 
6438 void Assembler::psraw(XMMRegister dst, XMMRegister shift) {
6439   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6440   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6441   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6442   emit_int8((unsigned char)0xE1);
6443   emit_int8((unsigned char)(0xC0 | encode));
6444 }
6445 
6446 void Assembler::psrad(XMMRegister dst, XMMRegister shift) {
6447   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6448   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6449   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6450   emit_int8((unsigned char)0xE2);
6451   emit_int8((unsigned char)(0xC0 | encode));
6452 }
6453 
6454 void Assembler::vpsraw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6455   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6456   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6457   // XMM4 is for /4 encoding: 66 0F 71 /4 ib
6458   int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6459   emit_int8(0x71);
6460   emit_int8((unsigned char)(0xC0 | encode));
6461   emit_int8(shift &amp; 0xFF);
6462 }
6463 
6464 void Assembler::vpsrad(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6465   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6466   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6467   // XMM4 is for /4 encoding: 66 0F 71 /4 ib
6468   int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6469   emit_int8(0x72);
6470   emit_int8((unsigned char)(0xC0 | encode));
6471   emit_int8(shift &amp; 0xFF);
6472 }
6473 
6474 void Assembler::vpsraw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6475   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6476   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6477   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6478   emit_int8((unsigned char)0xE1);
6479   emit_int8((unsigned char)(0xC0 | encode));
6480 }
6481 
6482 void Assembler::vpsrad(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6483   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6484   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6485   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6486   emit_int8((unsigned char)0xE2);
6487   emit_int8((unsigned char)(0xC0 | encode));
6488 }
6489 
6490 void Assembler::evpsraq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6491   assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);
6492   assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);
6493   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6494   attributes.set_is_evex_instruction();
6495   int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6496   emit_int8((unsigned char)0x72);
6497   emit_int8((unsigned char)(0xC0 | encode));
6498   emit_int8(shift &amp; 0xFF);
6499 }
6500 
6501 void Assembler::evpsraq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6502   assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);
6503   assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);
6504   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6505   attributes.set_is_evex_instruction();
6506   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6507   emit_int8((unsigned char)0xE2);
6508   emit_int8((unsigned char)(0xC0 | encode));
6509 }
6510 
6511 // logical operations packed integers
6512 void Assembler::pand(XMMRegister dst, XMMRegister src) {
6513   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6514   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6515   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6516   emit_int8((unsigned char)0xDB);
6517   emit_int8((unsigned char)(0xC0 | encode));
6518 }
6519 
6520 void Assembler::vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6521   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6522   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6523   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6524   emit_int8((unsigned char)0xDB);
6525   emit_int8((unsigned char)(0xC0 | encode));
6526 }
6527 
6528 void Assembler::vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6529   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6530   InstructionMark im(this);
6531   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6532   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6533   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6534   emit_int8((unsigned char)0xDB);
6535   emit_operand(dst, src);
6536 }
6537 
6538 void Assembler::vpandq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6539   assert(VM_Version::supports_evex(), &quot;&quot;);
6540   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6541   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6542   emit_int8((unsigned char)0xDB);
6543   emit_int8((unsigned char)(0xC0 | encode));
6544 }
6545 
6546 void Assembler::vpshldvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6547   assert(VM_Version::supports_avx512_vbmi2(), &quot;requires vbmi2&quot;);
6548   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6549   attributes.set_is_evex_instruction();
6550   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6551   emit_int8(0x71);
6552   emit_int8((unsigned char)(0xC0 | encode));
6553 }
6554 
6555 void Assembler::vpshrdvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6556   assert(VM_Version::supports_avx512_vbmi2(), &quot;requires vbmi2&quot;);
6557   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6558   attributes.set_is_evex_instruction();
6559   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6560   emit_int8(0x73);
6561   emit_int8((unsigned char)(0xC0 | encode));
6562 }
6563 
6564 void Assembler::pandn(XMMRegister dst, XMMRegister src) {
6565   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6566   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6567   attributes.set_rex_vex_w_reverted();
6568   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6569   emit_int8((unsigned char)0xDF);
6570   emit_int8((unsigned char)(0xC0 | encode));
6571 }
6572 
6573 void Assembler::vpandn(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6574   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6575   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6576   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6577   emit_int8((unsigned char)0xDF);
6578   emit_int8((unsigned char)(0xC0 | encode));
6579 }
6580 
6581 
6582 void Assembler::por(XMMRegister dst, XMMRegister src) {
6583   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6584   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6585   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6586   emit_int8((unsigned char)0xEB);
6587   emit_int8((unsigned char)(0xC0 | encode));
6588 }
6589 
6590 void Assembler::vpor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6591   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6592   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6593   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6594   emit_int8((unsigned char)0xEB);
6595   emit_int8((unsigned char)(0xC0 | encode));
6596 }
6597 
6598 void Assembler::vpor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6599   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6600   InstructionMark im(this);
6601   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6602   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6603   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6604   emit_int8((unsigned char)0xEB);
6605   emit_operand(dst, src);
6606 }
6607 
6608 void Assembler::vporq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6609   assert(VM_Version::supports_evex(), &quot;&quot;);
6610   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6611   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6612   emit_int8((unsigned char)0xEB);
6613   emit_int8((unsigned char)(0xC0 | encode));
6614 }
6615 
6616 
6617 void Assembler::pxor(XMMRegister dst, XMMRegister src) {
6618   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6619   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6620   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6621   emit_int8((unsigned char)0xEF);
6622   emit_int8((unsigned char)(0xC0 | encode));
6623 }
6624 
6625 void Assembler::vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6626   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6627   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6628   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6629   emit_int8((unsigned char)0xEF);
6630   emit_int8((unsigned char)(0xC0 | encode));
6631 }
6632 
6633 void Assembler::vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6634   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6635   InstructionMark im(this);
6636   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6637   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6638   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6639   emit_int8((unsigned char)0xEF);
6640   emit_operand(dst, src);
6641 }
6642 
6643 void Assembler::evpxorq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6644   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
6645   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6646   attributes.set_is_evex_instruction();
6647   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6648   emit_int8((unsigned char)0xEF);
6649   emit_int8((unsigned char)(0xC0 | encode));
6650 }
6651 
6652 void Assembler::evpxorq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6653   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
6654   assert(dst != xnoreg, &quot;sanity&quot;);
6655   InstructionMark im(this);
6656   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6657   attributes.set_is_evex_instruction();
6658   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
6659   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6660   emit_int8((unsigned char)0xEF);
6661   emit_operand(dst, src);
6662 }
6663 
6664 
6665 // vinserti forms
6666 
6667 void Assembler::vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6668   assert(VM_Version::supports_avx2(), &quot;&quot;);
6669   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6670   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6671   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6672   emit_int8(0x38);
6673   emit_int8((unsigned char)(0xC0 | encode));
6674   // 0x00 - insert into lower 128 bits
6675   // 0x01 - insert into upper 128 bits
6676   emit_int8(imm8 &amp; 0x01);
6677 }
6678 
6679 void Assembler::vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6680   assert(VM_Version::supports_avx2(), &quot;&quot;);
6681   assert(dst != xnoreg, &quot;sanity&quot;);
6682   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6683   InstructionMark im(this);
6684   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6685   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6686   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6687   emit_int8(0x38);
6688   emit_operand(dst, src);
6689   // 0x00 - insert into lower 128 bits
6690   // 0x01 - insert into upper 128 bits
6691   emit_int8(imm8 &amp; 0x01);
6692 }
6693 
6694 void Assembler::vinserti32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6695   assert(VM_Version::supports_evex(), &quot;&quot;);
6696   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6697   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6698   attributes.set_is_evex_instruction();
6699   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6700   emit_int8(0x38);
6701   emit_int8((unsigned char)(0xC0 | encode));
6702   // 0x00 - insert into q0 128 bits (0..127)
6703   // 0x01 - insert into q1 128 bits (128..255)
6704   // 0x02 - insert into q2 128 bits (256..383)
6705   // 0x03 - insert into q3 128 bits (384..511)
6706   emit_int8(imm8 &amp; 0x03);
6707 }
6708 
6709 void Assembler::vinserti32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6710   assert(VM_Version::supports_avx(), &quot;&quot;);
6711   assert(dst != xnoreg, &quot;sanity&quot;);
6712   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6713   InstructionMark im(this);
6714   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6715   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6716   attributes.set_is_evex_instruction();
6717   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6718   emit_int8(0x18);
6719   emit_operand(dst, src);
6720   // 0x00 - insert into q0 128 bits (0..127)
6721   // 0x01 - insert into q1 128 bits (128..255)
6722   // 0x02 - insert into q2 128 bits (256..383)
6723   // 0x03 - insert into q3 128 bits (384..511)
6724   emit_int8(imm8 &amp; 0x03);
6725 }
6726 
6727 void Assembler::vinserti64x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6728   assert(VM_Version::supports_evex(), &quot;&quot;);
6729   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6730   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6731   attributes.set_is_evex_instruction();
6732   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6733   emit_int8(0x3A);
6734   emit_int8((unsigned char)(0xC0 | encode));
6735   // 0x00 - insert into lower 256 bits
6736   // 0x01 - insert into upper 256 bits
6737   emit_int8(imm8 &amp; 0x01);
6738 }
6739 
6740 
6741 // vinsertf forms
6742 
6743 void Assembler::vinsertf128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6744   assert(VM_Version::supports_avx(), &quot;&quot;);
6745   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6746   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6747   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6748   emit_int8(0x18);
6749   emit_int8((unsigned char)(0xC0 | encode));
6750   // 0x00 - insert into lower 128 bits
6751   // 0x01 - insert into upper 128 bits
6752   emit_int8(imm8 &amp; 0x01);
6753 }
6754 
6755 void Assembler::vinsertf128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6756   assert(VM_Version::supports_avx(), &quot;&quot;);
6757   assert(dst != xnoreg, &quot;sanity&quot;);
6758   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6759   InstructionMark im(this);
6760   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6761   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6762   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6763   emit_int8(0x18);
6764   emit_operand(dst, src);
6765   // 0x00 - insert into lower 128 bits
6766   // 0x01 - insert into upper 128 bits
6767   emit_int8(imm8 &amp; 0x01);
6768 }
6769 
6770 void Assembler::vinsertf32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6771   assert(VM_Version::supports_avx2(), &quot;&quot;);
6772   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6773   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6774   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6775   emit_int8(0x18);
6776   emit_int8((unsigned char)(0xC0 | encode));
6777   // 0x00 - insert into q0 128 bits (0..127)
6778   // 0x01 - insert into q1 128 bits (128..255)
6779   // 0x02 - insert into q0 128 bits (256..383)
6780   // 0x03 - insert into q1 128 bits (384..512)
6781   emit_int8(imm8 &amp; 0x03);
6782 }
6783 
6784 void Assembler::vinsertf32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6785   assert(VM_Version::supports_avx(), &quot;&quot;);
6786   assert(dst != xnoreg, &quot;sanity&quot;);
6787   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6788   InstructionMark im(this);
6789   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6790   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6791   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6792   emit_int8(0x18);
6793   emit_operand(dst, src);
6794   // 0x00 - insert into q0 128 bits (0..127)
6795   // 0x01 - insert into q1 128 bits (128..255)
6796   // 0x02 - insert into q0 128 bits (256..383)
6797   // 0x03 - insert into q1 128 bits (384..512)
6798   emit_int8(imm8 &amp; 0x03);
6799 }
6800 
6801 void Assembler::vinsertf64x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6802   assert(VM_Version::supports_evex(), &quot;&quot;);
6803   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6804   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6805   attributes.set_is_evex_instruction();
6806   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6807   emit_int8(0x1A);
6808   emit_int8((unsigned char)(0xC0 | encode));
6809   // 0x00 - insert into lower 256 bits
6810   // 0x01 - insert into upper 256 bits
6811   emit_int8(imm8 &amp; 0x01);
6812 }
6813 
6814 void Assembler::vinsertf64x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6815   assert(VM_Version::supports_evex(), &quot;&quot;);
6816   assert(dst != xnoreg, &quot;sanity&quot;);
6817   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6818   InstructionMark im(this);
6819   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6820   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_64bit);
6821   attributes.set_is_evex_instruction();
6822   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6823   emit_int8(0x1A);
6824   emit_operand(dst, src);
6825   // 0x00 - insert into lower 256 bits
6826   // 0x01 - insert into upper 256 bits
6827   emit_int8(imm8 &amp; 0x01);
6828 }
6829 
6830 
6831 // vextracti forms
6832 
6833 void Assembler::vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6834   assert(VM_Version::supports_avx2(), &quot;&quot;);
6835   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6836   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6837   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6838   emit_int8(0x39);
6839   emit_int8((unsigned char)(0xC0 | encode));
6840   // 0x00 - extract from lower 128 bits
6841   // 0x01 - extract from upper 128 bits
6842   emit_int8(imm8 &amp; 0x01);
6843 }
6844 
6845 void Assembler::vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
6846   assert(VM_Version::supports_avx2(), &quot;&quot;);
6847   assert(src != xnoreg, &quot;sanity&quot;);
6848   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6849   InstructionMark im(this);
6850   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6851   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6852   attributes.reset_is_clear_context();
6853   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6854   emit_int8(0x39);
6855   emit_operand(src, dst);
6856   // 0x00 - extract from lower 128 bits
6857   // 0x01 - extract from upper 128 bits
6858   emit_int8(imm8 &amp; 0x01);
6859 }
6860 
6861 void Assembler::vextracti32x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6862   assert(VM_Version::supports_evex(), &quot;&quot;);
6863   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6864   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6865   attributes.set_is_evex_instruction();
6866   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6867   emit_int8(0x39);
6868   emit_int8((unsigned char)(0xC0 | encode));
6869   // 0x00 - extract from bits 127:0
6870   // 0x01 - extract from bits 255:128
6871   // 0x02 - extract from bits 383:256
6872   // 0x03 - extract from bits 511:384
6873   emit_int8(imm8 &amp; 0x03);
6874 }
6875 
6876 void Assembler::vextracti32x4(Address dst, XMMRegister src, uint8_t imm8) {
6877   assert(VM_Version::supports_evex(), &quot;&quot;);
6878   assert(src != xnoreg, &quot;sanity&quot;);
6879   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6880   InstructionMark im(this);
6881   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6882   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6883   attributes.reset_is_clear_context();
6884   attributes.set_is_evex_instruction();
6885   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6886   emit_int8(0x39);
6887   emit_operand(src, dst);
6888   // 0x00 - extract from bits 127:0
6889   // 0x01 - extract from bits 255:128
6890   // 0x02 - extract from bits 383:256
6891   // 0x03 - extract from bits 511:384
6892   emit_int8(imm8 &amp; 0x03);
6893 }
6894 
6895 void Assembler::vextracti64x2(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6896   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
6897   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6898   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6899   attributes.set_is_evex_instruction();
6900   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6901   emit_int8(0x39);
6902   emit_int8((unsigned char)(0xC0 | encode));
6903   // 0x00 - extract from bits 127:0
6904   // 0x01 - extract from bits 255:128
6905   // 0x02 - extract from bits 383:256
6906   // 0x03 - extract from bits 511:384
6907   emit_int8(imm8 &amp; 0x03);
6908 }
6909 
6910 void Assembler::vextracti64x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6911   assert(VM_Version::supports_evex(), &quot;&quot;);
6912   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6913   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6914   attributes.set_is_evex_instruction();
6915   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6916   emit_int8(0x3B);
6917   emit_int8((unsigned char)(0xC0 | encode));
6918   // 0x00 - extract from lower 256 bits
6919   // 0x01 - extract from upper 256 bits
6920   emit_int8(imm8 &amp; 0x01);
6921 }
6922 
6923 void Assembler::vextracti64x4(Address dst, XMMRegister src, uint8_t imm8) {
6924   assert(VM_Version::supports_evex(), &quot;&quot;);
6925   assert(src != xnoreg, &quot;sanity&quot;);
6926   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6927   InstructionMark im(this);
6928   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6929   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_64bit);
6930   attributes.reset_is_clear_context();
6931   attributes.set_is_evex_instruction();
6932   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6933   emit_int8(0x38);
6934   emit_operand(src, dst);
6935   // 0x00 - extract from lower 256 bits
6936   // 0x01 - extract from upper 256 bits
6937   emit_int8(imm8 &amp; 0x01);
6938 }
6939 // vextractf forms
6940 
6941 void Assembler::vextractf128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6942   assert(VM_Version::supports_avx(), &quot;&quot;);
6943   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6944   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6945   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6946   emit_int8(0x19);
6947   emit_int8((unsigned char)(0xC0 | encode));
6948   // 0x00 - extract from lower 128 bits
6949   // 0x01 - extract from upper 128 bits
6950   emit_int8(imm8 &amp; 0x01);
6951 }
6952 
6953 void Assembler::vextractf128(Address dst, XMMRegister src, uint8_t imm8) {
6954   assert(VM_Version::supports_avx(), &quot;&quot;);
6955   assert(src != xnoreg, &quot;sanity&quot;);
6956   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6957   InstructionMark im(this);
6958   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6959   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6960   attributes.reset_is_clear_context();
6961   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6962   emit_int8(0x19);
6963   emit_operand(src, dst);
6964   // 0x00 - extract from lower 128 bits
6965   // 0x01 - extract from upper 128 bits
6966   emit_int8(imm8 &amp; 0x01);
6967 }
6968 
6969 void Assembler::vextractf32x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6970   assert(VM_Version::supports_evex(), &quot;&quot;);
6971   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6972   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6973   attributes.set_is_evex_instruction();
6974   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6975   emit_int8(0x19);
6976   emit_int8((unsigned char)(0xC0 | encode));
6977   // 0x00 - extract from bits 127:0
6978   // 0x01 - extract from bits 255:128
6979   // 0x02 - extract from bits 383:256
6980   // 0x03 - extract from bits 511:384
6981   emit_int8(imm8 &amp; 0x03);
6982 }
6983 
6984 void Assembler::vextractf32x4(Address dst, XMMRegister src, uint8_t imm8) {
6985   assert(VM_Version::supports_evex(), &quot;&quot;);
6986   assert(src != xnoreg, &quot;sanity&quot;);
6987   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6988   InstructionMark im(this);
6989   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6990   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6991   attributes.reset_is_clear_context();
6992   attributes.set_is_evex_instruction();
6993   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6994   emit_int8(0x19);
6995   emit_operand(src, dst);
6996   // 0x00 - extract from bits 127:0
6997   // 0x01 - extract from bits 255:128
6998   // 0x02 - extract from bits 383:256
6999   // 0x03 - extract from bits 511:384
7000   emit_int8(imm8 &amp; 0x03);
7001 }
7002 
7003 void Assembler::vextractf64x2(XMMRegister dst, XMMRegister src, uint8_t imm8) {
7004   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
7005   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
7006   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7007   attributes.set_is_evex_instruction();
7008   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
7009   emit_int8(0x19);
7010   emit_int8((unsigned char)(0xC0 | encode));
7011   // 0x00 - extract from bits 127:0
7012   // 0x01 - extract from bits 255:128
7013   // 0x02 - extract from bits 383:256
7014   // 0x03 - extract from bits 511:384
7015   emit_int8(imm8 &amp; 0x03);
7016 }
7017 
7018 void Assembler::vextractf64x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
7019   assert(VM_Version::supports_evex(), &quot;&quot;);
7020   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
7021   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7022   attributes.set_is_evex_instruction();
7023   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
7024   emit_int8(0x1B);
7025   emit_int8((unsigned char)(0xC0 | encode));
7026   // 0x00 - extract from lower 256 bits
7027   // 0x01 - extract from upper 256 bits
7028   emit_int8(imm8 &amp; 0x01);
7029 }
7030 
7031 void Assembler::vextractf64x4(Address dst, XMMRegister src, uint8_t imm8) {
7032   assert(VM_Version::supports_evex(), &quot;&quot;);
7033   assert(src != xnoreg, &quot;sanity&quot;);
7034   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
7035   InstructionMark im(this);
7036   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7037   attributes.set_address_attributes(/* tuple_type */ EVEX_T4,/* input_size_in_bits */  EVEX_64bit);
7038   attributes.reset_is_clear_context();
7039   attributes.set_is_evex_instruction();
7040   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
7041   emit_int8(0x1B);
7042   emit_operand(src, dst);
7043   // 0x00 - extract from lower 256 bits
7044   // 0x01 - extract from upper 256 bits
7045   emit_int8(imm8 &amp; 0x01);
7046 }
7047 
7048 // duplicate 1-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
7049 void Assembler::vpbroadcastb(XMMRegister dst, XMMRegister src, int vector_len) {
7050   assert(VM_Version::supports_avx2(), &quot;&quot;);
7051   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
7052   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7053   emit_int8(0x78);
7054   emit_int8((unsigned char)(0xC0 | encode));
7055 }
7056 
7057 void Assembler::vpbroadcastb(XMMRegister dst, Address src, int vector_len) {
7058   assert(VM_Version::supports_avx2(), &quot;&quot;);
7059   assert(dst != xnoreg, &quot;sanity&quot;);
7060   InstructionMark im(this);
7061   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
7062   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_8bit);
7063   // swap src&lt;-&gt;dst for encoding
7064   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7065   emit_int8(0x78);
7066   emit_operand(dst, src);
7067 }
7068 
7069 // duplicate 2-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
7070 void Assembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
7071   assert(VM_Version::supports_avx2(), &quot;&quot;);
7072   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
7073   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7074   emit_int8(0x79);
7075   emit_int8((unsigned char)(0xC0 | encode));
7076 }
7077 
7078 void Assembler::vpbroadcastw(XMMRegister dst, Address src, int vector_len) {
7079   assert(VM_Version::supports_avx2(), &quot;&quot;);
7080   assert(dst != xnoreg, &quot;sanity&quot;);
7081   InstructionMark im(this);
7082   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
7083   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
7084   // swap src&lt;-&gt;dst for encoding
7085   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7086   emit_int8(0x79);
7087   emit_operand(dst, src);
7088 }
7089 
7090 // xmm/mem sourced byte/word/dword/qword replicate
7091 
7092 // duplicate 4-byte integer data from src into programmed locations in dest : requires AVX512VL
7093 void Assembler::vpbroadcastd(XMMRegister dst, XMMRegister src, int vector_len) {
7094   assert(UseAVX &gt;= 2, &quot;&quot;);
7095   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7096   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7097   emit_int8(0x58);
7098   emit_int8((unsigned char)(0xC0 | encode));
7099 }
7100 
7101 void Assembler::vpbroadcastd(XMMRegister dst, Address src, int vector_len) {
7102   assert(VM_Version::supports_avx2(), &quot;&quot;);
7103   assert(dst != xnoreg, &quot;sanity&quot;);
7104   InstructionMark im(this);
7105   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7106   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
7107   // swap src&lt;-&gt;dst for encoding
7108   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7109   emit_int8(0x58);
7110   emit_operand(dst, src);
7111 }
7112 
7113 // duplicate 8-byte integer data from src into programmed locations in dest : requires AVX512VL
7114 void Assembler::vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len) {
7115   assert(VM_Version::supports_avx2(), &quot;&quot;);
7116   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7117   attributes.set_rex_vex_w_reverted();
7118   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7119   emit_int8(0x59);
7120   emit_int8((unsigned char)(0xC0 | encode));
7121 }
7122 
7123 void Assembler::vpbroadcastq(XMMRegister dst, Address src, int vector_len) {
7124   assert(VM_Version::supports_avx2(), &quot;&quot;);
7125   assert(dst != xnoreg, &quot;sanity&quot;);
7126   InstructionMark im(this);
7127   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7128   attributes.set_rex_vex_w_reverted();
7129   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
7130   // swap src&lt;-&gt;dst for encoding
7131   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7132   emit_int8(0x59);
7133   emit_operand(dst, src);
7134 }
7135 void Assembler::evbroadcasti64x2(XMMRegister dst, XMMRegister src, int vector_len) {
7136   assert(vector_len != Assembler::AVX_128bit, &quot;&quot;);
7137   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
7138   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7139   attributes.set_rex_vex_w_reverted();
7140   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7141   emit_int8(0x5A);
7142   emit_int8((unsigned char)(0xC0 | encode));
7143 }
7144 
7145 void Assembler::evbroadcasti64x2(XMMRegister dst, Address src, int vector_len) {
7146   assert(vector_len != Assembler::AVX_128bit, &quot;&quot;);
7147   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
7148   assert(dst != xnoreg, &quot;sanity&quot;);
7149   InstructionMark im(this);
7150   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7151   attributes.set_rex_vex_w_reverted();
7152   attributes.set_address_attributes(/* tuple_type */ EVEX_T2, /* input_size_in_bits */ EVEX_64bit);
7153   // swap src&lt;-&gt;dst for encoding
7154   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7155   emit_int8(0x5A);
7156   emit_operand(dst, src);
7157 }
7158 
7159 // scalar single/double precision replicate
7160 
7161 // duplicate single precision data from src into programmed locations in dest : requires AVX512VL
7162 void Assembler::vbroadcastss(XMMRegister dst, XMMRegister src, int vector_len) {
7163   assert(VM_Version::supports_avx2(), &quot;&quot;);
7164   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7165   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7166   emit_int8(0x18);
7167   emit_int8((unsigned char)(0xC0 | encode));
7168 }
7169 
7170 void Assembler::vbroadcastss(XMMRegister dst, Address src, int vector_len) {
7171   assert(VM_Version::supports_avx(), &quot;&quot;);
7172   assert(dst != xnoreg, &quot;sanity&quot;);
7173   InstructionMark im(this);
7174   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7175   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
7176   // swap src&lt;-&gt;dst for encoding
7177   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7178   emit_int8(0x18);
7179   emit_operand(dst, src);
7180 }
7181 
7182 // duplicate double precision data from src into programmed locations in dest : requires AVX512VL
7183 void Assembler::vbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len) {
7184   assert(VM_Version::supports_avx2(), &quot;&quot;);
7185   assert(vector_len == AVX_256bit || vector_len == AVX_512bit, &quot;&quot;);
7186   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7187   attributes.set_rex_vex_w_reverted();
7188   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7189   emit_int8(0x19);
7190   emit_int8((unsigned char)(0xC0 | encode));
7191 }
7192 
7193 void Assembler::vbroadcastsd(XMMRegister dst, Address src, int vector_len) {
7194   assert(VM_Version::supports_avx(), &quot;&quot;);
7195   assert(vector_len == AVX_256bit || vector_len == AVX_512bit, &quot;&quot;);
7196   assert(dst != xnoreg, &quot;sanity&quot;);
7197   InstructionMark im(this);
7198   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7199   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
7200   attributes.set_rex_vex_w_reverted();
7201   // swap src&lt;-&gt;dst for encoding
7202   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7203   emit_int8(0x19);
7204   emit_operand(dst, src);
7205 }
7206 
7207 
7208 // gpr source broadcast forms
7209 
7210 // duplicate 1-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
7211 void Assembler::evpbroadcastb(XMMRegister dst, Register src, int vector_len) {
7212   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
7213   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
7214   attributes.set_is_evex_instruction();
7215   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7216   emit_int8(0x7A);
7217   emit_int8((unsigned char)(0xC0 | encode));
7218 }
7219 
7220 // duplicate 2-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
7221 void Assembler::evpbroadcastw(XMMRegister dst, Register src, int vector_len) {
7222   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
7223   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
7224   attributes.set_is_evex_instruction();
7225   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7226   emit_int8(0x7B);
7227   emit_int8((unsigned char)(0xC0 | encode));
7228 }
7229 
7230 // duplicate 4-byte integer data from src into programmed locations in dest : requires AVX512VL
7231 void Assembler::evpbroadcastd(XMMRegister dst, Register src, int vector_len) {
7232   assert(VM_Version::supports_evex(), &quot;&quot;);
7233   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7234   attributes.set_is_evex_instruction();
7235   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7236   emit_int8(0x7C);
7237   emit_int8((unsigned char)(0xC0 | encode));
7238 }
7239 
7240 // duplicate 8-byte integer data from src into programmed locations in dest : requires AVX512VL
7241 void Assembler::evpbroadcastq(XMMRegister dst, Register src, int vector_len) {
7242   assert(VM_Version::supports_evex(), &quot;&quot;);
7243   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7244   attributes.set_is_evex_instruction();
7245   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7246   emit_int8(0x7C);
7247   emit_int8((unsigned char)(0xC0 | encode));
7248 }
7249 void Assembler::evpgatherdd(XMMRegister dst, KRegister mask, Address src, int vector_len) {
7250   assert(VM_Version::supports_evex(), &quot;&quot;);
7251   assert(dst != xnoreg, &quot;sanity&quot;);
7252   InstructionMark im(this);
7253   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
7254   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
7255   attributes.reset_is_clear_context();
7256   attributes.set_embedded_opmask_register_specifier(mask);
7257   attributes.set_is_evex_instruction();
7258   // swap src&lt;-&gt;dst for encoding
7259   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7260   emit_int8((unsigned char)0x90);
7261   emit_operand(dst, src);
7262 }
7263 // Carry-Less Multiplication Quadword
7264 void Assembler::pclmulqdq(XMMRegister dst, XMMRegister src, int mask) {
7265   assert(VM_Version::supports_clmul(), &quot;&quot;);
7266   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7267   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
7268   emit_int8(0x44);
7269   emit_int8((unsigned char)(0xC0 | encode));
7270   emit_int8((unsigned char)mask);
7271 }
7272 
7273 // Carry-Less Multiplication Quadword
7274 void Assembler::vpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask) {
7275   assert(VM_Version::supports_avx() &amp;&amp; VM_Version::supports_clmul(), &quot;&quot;);
7276   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7277   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
7278   emit_int8(0x44);
7279   emit_int8((unsigned char)(0xC0 | encode));
7280   emit_int8((unsigned char)mask);
7281 }
7282 
7283 void Assembler::evpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask, int vector_len) {
7284   assert(VM_Version::supports_avx512_vpclmulqdq(), &quot;Requires vector carryless multiplication support&quot;);
7285   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7286   attributes.set_is_evex_instruction();
7287   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
7288   emit_int8(0x44);
7289   emit_int8((unsigned char)(0xC0 | encode));
7290   emit_int8((unsigned char)mask);
7291 }
7292 
7293 void Assembler::vzeroupper_uncached() {
7294   if (VM_Version::supports_vzeroupper()) {
7295     InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
7296     (void)vex_prefix_and_encode(0, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
7297     emit_int8(0x77);
7298   }
7299 }
7300 
7301 #ifndef _LP64
7302 // 32bit only pieces of the assembler
7303 
7304 void Assembler::vzeroupper() {
7305   vzeroupper_uncached();
7306 }
7307 
7308 void Assembler::cmp_literal32(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
7309   // NO PREFIX AS NEVER 64BIT
7310   InstructionMark im(this);
7311   emit_int8((unsigned char)0x81);
7312   emit_int8((unsigned char)(0xF8 | src1-&gt;encoding()));
7313   emit_data(imm32, rspec, 0);
7314 }
7315 
7316 void Assembler::cmp_literal32(Address src1, int32_t imm32, RelocationHolder const&amp; rspec) {
7317   // NO PREFIX AS NEVER 64BIT (not even 32bit versions of 64bit regs
7318   InstructionMark im(this);
7319   emit_int8((unsigned char)0x81);
7320   emit_operand(rdi, src1);
7321   emit_data(imm32, rspec, 0);
7322 }
7323 
7324 // The 64-bit (32bit platform) cmpxchg compares the value at adr with the contents of rdx:rax,
7325 // and stores rcx:rbx into adr if so; otherwise, the value at adr is loaded
7326 // into rdx:rax.  The ZF is set if the compared values were equal, and cleared otherwise.
7327 void Assembler::cmpxchg8(Address adr) {
7328   InstructionMark im(this);
7329   emit_int8(0x0F);
7330   emit_int8((unsigned char)0xC7);
7331   emit_operand(rcx, adr);
7332 }
7333 
7334 void Assembler::decl(Register dst) {
7335   // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
7336  emit_int8(0x48 | dst-&gt;encoding());
7337 }
7338 
7339 // 64bit doesn&#39;t use the x87
7340 
7341 void Assembler::fabs() {
7342   emit_int8((unsigned char)0xD9);
7343   emit_int8((unsigned char)0xE1);
7344 }
7345 
7346 void Assembler::fadd(int i) {
7347   emit_farith(0xD8, 0xC0, i);
7348 }
7349 
7350 void Assembler::fadd_d(Address src) {
7351   InstructionMark im(this);
7352   emit_int8((unsigned char)0xDC);
7353   emit_operand32(rax, src);
7354 }
7355 
7356 void Assembler::fadd_s(Address src) {
7357   InstructionMark im(this);
7358   emit_int8((unsigned char)0xD8);
7359   emit_operand32(rax, src);
7360 }
7361 
7362 void Assembler::fadda(int i) {
7363   emit_farith(0xDC, 0xC0, i);
7364 }
7365 
7366 void Assembler::faddp(int i) {
7367   emit_farith(0xDE, 0xC0, i);
7368 }
7369 
7370 void Assembler::fchs() {
7371   emit_int8((unsigned char)0xD9);
7372   emit_int8((unsigned char)0xE0);
7373 }
7374 
7375 void Assembler::fcom(int i) {
7376   emit_farith(0xD8, 0xD0, i);
7377 }
7378 
7379 void Assembler::fcomp(int i) {
7380   emit_farith(0xD8, 0xD8, i);
7381 }
7382 
7383 void Assembler::fcomp_d(Address src) {
7384   InstructionMark im(this);
7385   emit_int8((unsigned char)0xDC);
7386   emit_operand32(rbx, src);
7387 }
7388 
7389 void Assembler::fcomp_s(Address src) {
7390   InstructionMark im(this);
7391   emit_int8((unsigned char)0xD8);
7392   emit_operand32(rbx, src);
7393 }
7394 
7395 void Assembler::fcompp() {
7396   emit_int8((unsigned char)0xDE);
7397   emit_int8((unsigned char)0xD9);
7398 }
7399 
7400 void Assembler::fcos() {
7401   emit_int8((unsigned char)0xD9);
7402   emit_int8((unsigned char)0xFF);
7403 }
7404 
7405 void Assembler::fdecstp() {
7406   emit_int8((unsigned char)0xD9);
7407   emit_int8((unsigned char)0xF6);
7408 }
7409 
7410 void Assembler::fdiv(int i) {
7411   emit_farith(0xD8, 0xF0, i);
7412 }
7413 
7414 void Assembler::fdiv_d(Address src) {
7415   InstructionMark im(this);
7416   emit_int8((unsigned char)0xDC);
7417   emit_operand32(rsi, src);
7418 }
7419 
7420 void Assembler::fdiv_s(Address src) {
7421   InstructionMark im(this);
7422   emit_int8((unsigned char)0xD8);
7423   emit_operand32(rsi, src);
7424 }
7425 
7426 void Assembler::fdiva(int i) {
7427   emit_farith(0xDC, 0xF8, i);
7428 }
7429 
7430 // Note: The Intel manual (Pentium Processor User&#39;s Manual, Vol.3, 1994)
7431 //       is erroneous for some of the floating-point instructions below.
7432 
7433 void Assembler::fdivp(int i) {
7434   emit_farith(0xDE, 0xF8, i);                    // ST(0) &lt;- ST(0) / ST(1) and pop (Intel manual wrong)
7435 }
7436 
7437 void Assembler::fdivr(int i) {
7438   emit_farith(0xD8, 0xF8, i);
7439 }
7440 
7441 void Assembler::fdivr_d(Address src) {
7442   InstructionMark im(this);
7443   emit_int8((unsigned char)0xDC);
7444   emit_operand32(rdi, src);
7445 }
7446 
7447 void Assembler::fdivr_s(Address src) {
7448   InstructionMark im(this);
7449   emit_int8((unsigned char)0xD8);
7450   emit_operand32(rdi, src);
7451 }
7452 
7453 void Assembler::fdivra(int i) {
7454   emit_farith(0xDC, 0xF0, i);
7455 }
7456 
7457 void Assembler::fdivrp(int i) {
7458   emit_farith(0xDE, 0xF0, i);                    // ST(0) &lt;- ST(1) / ST(0) and pop (Intel manual wrong)
7459 }
7460 
7461 void Assembler::ffree(int i) {
7462   emit_farith(0xDD, 0xC0, i);
7463 }
7464 
7465 void Assembler::fild_d(Address adr) {
7466   InstructionMark im(this);
7467   emit_int8((unsigned char)0xDF);
7468   emit_operand32(rbp, adr);
7469 }
7470 
7471 void Assembler::fild_s(Address adr) {
7472   InstructionMark im(this);
7473   emit_int8((unsigned char)0xDB);
7474   emit_operand32(rax, adr);
7475 }
7476 
7477 void Assembler::fincstp() {
7478   emit_int8((unsigned char)0xD9);
7479   emit_int8((unsigned char)0xF7);
7480 }
7481 
7482 void Assembler::finit() {
7483   emit_int8((unsigned char)0x9B);
7484   emit_int8((unsigned char)0xDB);
7485   emit_int8((unsigned char)0xE3);
7486 }
7487 
7488 void Assembler::fist_s(Address adr) {
7489   InstructionMark im(this);
7490   emit_int8((unsigned char)0xDB);
7491   emit_operand32(rdx, adr);
7492 }
7493 
7494 void Assembler::fistp_d(Address adr) {
7495   InstructionMark im(this);
7496   emit_int8((unsigned char)0xDF);
7497   emit_operand32(rdi, adr);
7498 }
7499 
7500 void Assembler::fistp_s(Address adr) {
7501   InstructionMark im(this);
7502   emit_int8((unsigned char)0xDB);
7503   emit_operand32(rbx, adr);
7504 }
7505 
7506 void Assembler::fld1() {
7507   emit_int8((unsigned char)0xD9);
7508   emit_int8((unsigned char)0xE8);
7509 }
7510 
7511 void Assembler::fld_d(Address adr) {
7512   InstructionMark im(this);
7513   emit_int8((unsigned char)0xDD);
7514   emit_operand32(rax, adr);
7515 }
7516 
7517 void Assembler::fld_s(Address adr) {
7518   InstructionMark im(this);
7519   emit_int8((unsigned char)0xD9);
7520   emit_operand32(rax, adr);
7521 }
7522 
7523 
7524 void Assembler::fld_s(int index) {
7525   emit_farith(0xD9, 0xC0, index);
7526 }
7527 
<a name="1" id="anc1"></a><span class="line-removed">7528 void Assembler::fld_x(Address adr) {</span>
<span class="line-removed">7529   InstructionMark im(this);</span>
<span class="line-removed">7530   emit_int8((unsigned char)0xDB);</span>
<span class="line-removed">7531   emit_operand32(rbp, adr);</span>
<span class="line-removed">7532 }</span>
<span class="line-removed">7533 </span>
7534 void Assembler::fldcw(Address src) {
7535   InstructionMark im(this);
7536   emit_int8((unsigned char)0xD9);
7537   emit_operand32(rbp, src);
7538 }
7539 
7540 void Assembler::fldenv(Address src) {
7541   InstructionMark im(this);
7542   emit_int8((unsigned char)0xD9);
7543   emit_operand32(rsp, src);
7544 }
7545 
7546 void Assembler::fldlg2() {
7547   emit_int8((unsigned char)0xD9);
7548   emit_int8((unsigned char)0xEC);
7549 }
7550 
7551 void Assembler::fldln2() {
7552   emit_int8((unsigned char)0xD9);
7553   emit_int8((unsigned char)0xED);
7554 }
7555 
7556 void Assembler::fldz() {
7557   emit_int8((unsigned char)0xD9);
7558   emit_int8((unsigned char)0xEE);
7559 }
7560 
7561 void Assembler::flog() {
7562   fldln2();
7563   fxch();
7564   fyl2x();
7565 }
7566 
7567 void Assembler::flog10() {
7568   fldlg2();
7569   fxch();
7570   fyl2x();
7571 }
7572 
7573 void Assembler::fmul(int i) {
7574   emit_farith(0xD8, 0xC8, i);
7575 }
7576 
7577 void Assembler::fmul_d(Address src) {
7578   InstructionMark im(this);
7579   emit_int8((unsigned char)0xDC);
7580   emit_operand32(rcx, src);
7581 }
7582 
7583 void Assembler::fmul_s(Address src) {
7584   InstructionMark im(this);
7585   emit_int8((unsigned char)0xD8);
7586   emit_operand32(rcx, src);
7587 }
7588 
7589 void Assembler::fmula(int i) {
7590   emit_farith(0xDC, 0xC8, i);
7591 }
7592 
7593 void Assembler::fmulp(int i) {
7594   emit_farith(0xDE, 0xC8, i);
7595 }
7596 
7597 void Assembler::fnsave(Address dst) {
7598   InstructionMark im(this);
7599   emit_int8((unsigned char)0xDD);
7600   emit_operand32(rsi, dst);
7601 }
7602 
7603 void Assembler::fnstcw(Address src) {
7604   InstructionMark im(this);
7605   emit_int8((unsigned char)0x9B);
7606   emit_int8((unsigned char)0xD9);
7607   emit_operand32(rdi, src);
7608 }
7609 
7610 void Assembler::fnstsw_ax() {
7611   emit_int8((unsigned char)0xDF);
7612   emit_int8((unsigned char)0xE0);
7613 }
7614 
7615 void Assembler::fprem() {
7616   emit_int8((unsigned char)0xD9);
7617   emit_int8((unsigned char)0xF8);
7618 }
7619 
7620 void Assembler::fprem1() {
7621   emit_int8((unsigned char)0xD9);
7622   emit_int8((unsigned char)0xF5);
7623 }
7624 
7625 void Assembler::frstor(Address src) {
7626   InstructionMark im(this);
7627   emit_int8((unsigned char)0xDD);
7628   emit_operand32(rsp, src);
7629 }
7630 
7631 void Assembler::fsin() {
7632   emit_int8((unsigned char)0xD9);
7633   emit_int8((unsigned char)0xFE);
7634 }
7635 
7636 void Assembler::fsqrt() {
7637   emit_int8((unsigned char)0xD9);
7638   emit_int8((unsigned char)0xFA);
7639 }
7640 
7641 void Assembler::fst_d(Address adr) {
7642   InstructionMark im(this);
7643   emit_int8((unsigned char)0xDD);
7644   emit_operand32(rdx, adr);
7645 }
7646 
7647 void Assembler::fst_s(Address adr) {
7648   InstructionMark im(this);
7649   emit_int8((unsigned char)0xD9);
7650   emit_operand32(rdx, adr);
7651 }
7652 
7653 void Assembler::fstp_d(Address adr) {
7654   InstructionMark im(this);
7655   emit_int8((unsigned char)0xDD);
7656   emit_operand32(rbx, adr);
7657 }
7658 
7659 void Assembler::fstp_d(int index) {
7660   emit_farith(0xDD, 0xD8, index);
7661 }
7662 
7663 void Assembler::fstp_s(Address adr) {
7664   InstructionMark im(this);
7665   emit_int8((unsigned char)0xD9);
7666   emit_operand32(rbx, adr);
7667 }
7668 
<a name="2" id="anc2"></a><span class="line-removed">7669 void Assembler::fstp_x(Address adr) {</span>
<span class="line-removed">7670   InstructionMark im(this);</span>
<span class="line-removed">7671   emit_int8((unsigned char)0xDB);</span>
<span class="line-removed">7672   emit_operand32(rdi, adr);</span>
<span class="line-removed">7673 }</span>
<span class="line-removed">7674 </span>
7675 void Assembler::fsub(int i) {
7676   emit_farith(0xD8, 0xE0, i);
7677 }
7678 
7679 void Assembler::fsub_d(Address src) {
7680   InstructionMark im(this);
7681   emit_int8((unsigned char)0xDC);
7682   emit_operand32(rsp, src);
7683 }
7684 
7685 void Assembler::fsub_s(Address src) {
7686   InstructionMark im(this);
7687   emit_int8((unsigned char)0xD8);
7688   emit_operand32(rsp, src);
7689 }
7690 
7691 void Assembler::fsuba(int i) {
7692   emit_farith(0xDC, 0xE8, i);
7693 }
7694 
7695 void Assembler::fsubp(int i) {
7696   emit_farith(0xDE, 0xE8, i);                    // ST(0) &lt;- ST(0) - ST(1) and pop (Intel manual wrong)
7697 }
7698 
7699 void Assembler::fsubr(int i) {
7700   emit_farith(0xD8, 0xE8, i);
7701 }
7702 
7703 void Assembler::fsubr_d(Address src) {
7704   InstructionMark im(this);
7705   emit_int8((unsigned char)0xDC);
7706   emit_operand32(rbp, src);
7707 }
7708 
7709 void Assembler::fsubr_s(Address src) {
7710   InstructionMark im(this);
7711   emit_int8((unsigned char)0xD8);
7712   emit_operand32(rbp, src);
7713 }
7714 
7715 void Assembler::fsubra(int i) {
7716   emit_farith(0xDC, 0xE0, i);
7717 }
7718 
7719 void Assembler::fsubrp(int i) {
7720   emit_farith(0xDE, 0xE0, i);                    // ST(0) &lt;- ST(1) - ST(0) and pop (Intel manual wrong)
7721 }
7722 
7723 void Assembler::ftan() {
7724   emit_int8((unsigned char)0xD9);
7725   emit_int8((unsigned char)0xF2);
7726   emit_int8((unsigned char)0xDD);
7727   emit_int8((unsigned char)0xD8);
7728 }
7729 
7730 void Assembler::ftst() {
7731   emit_int8((unsigned char)0xD9);
7732   emit_int8((unsigned char)0xE4);
7733 }
7734 
7735 void Assembler::fucomi(int i) {
7736   // make sure the instruction is supported (introduced for P6, together with cmov)
7737   guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;);
7738   emit_farith(0xDB, 0xE8, i);
7739 }
7740 
7741 void Assembler::fucomip(int i) {
7742   // make sure the instruction is supported (introduced for P6, together with cmov)
7743   guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;);
7744   emit_farith(0xDF, 0xE8, i);
7745 }
7746 
7747 void Assembler::fwait() {
7748   emit_int8((unsigned char)0x9B);
7749 }
7750 
7751 void Assembler::fxch(int i) {
7752   emit_farith(0xD9, 0xC8, i);
7753 }
7754 
7755 void Assembler::fyl2x() {
7756   emit_int8((unsigned char)0xD9);
7757   emit_int8((unsigned char)0xF1);
7758 }
7759 
7760 void Assembler::frndint() {
7761   emit_int8((unsigned char)0xD9);
7762   emit_int8((unsigned char)0xFC);
7763 }
7764 
7765 void Assembler::f2xm1() {
7766   emit_int8((unsigned char)0xD9);
7767   emit_int8((unsigned char)0xF0);
7768 }
7769 
7770 void Assembler::fldl2e() {
7771   emit_int8((unsigned char)0xD9);
7772   emit_int8((unsigned char)0xEA);
7773 }
7774 #endif // !_LP64
7775 
7776 // SSE SIMD prefix byte values corresponding to VexSimdPrefix encoding.
7777 static int simd_pre[4] = { 0, 0x66, 0xF3, 0xF2 };
7778 // SSE opcode second byte values (first is 0x0F) corresponding to VexOpcode encoding.
7779 static int simd_opc[4] = { 0,    0, 0x38, 0x3A };
7780 
7781 // Generate SSE legacy REX prefix and SIMD opcode based on VEX encoding.
7782 void Assembler::rex_prefix(Address adr, XMMRegister xreg, VexSimdPrefix pre, VexOpcode opc, bool rex_w) {
7783   if (pre &gt; 0) {
7784     emit_int8(simd_pre[pre]);
7785   }
7786   if (rex_w) {
7787     prefixq(adr, xreg);
7788   } else {
7789     prefix(adr, xreg);
7790   }
7791   if (opc &gt; 0) {
7792     emit_int8(0x0F);
7793     int opc2 = simd_opc[opc];
7794     if (opc2 &gt; 0) {
7795       emit_int8(opc2);
7796     }
7797   }
7798 }
7799 
7800 int Assembler::rex_prefix_and_encode(int dst_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, bool rex_w) {
7801   if (pre &gt; 0) {
7802     emit_int8(simd_pre[pre]);
7803   }
7804   int encode = (rex_w) ? prefixq_and_encode(dst_enc, src_enc) : prefix_and_encode(dst_enc, src_enc);
7805   if (opc &gt; 0) {
7806     emit_int8(0x0F);
7807     int opc2 = simd_opc[opc];
7808     if (opc2 &gt; 0) {
7809       emit_int8(opc2);
7810     }
7811   }
7812   return encode;
7813 }
7814 
7815 
7816 void Assembler::vex_prefix(bool vex_r, bool vex_b, bool vex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc) {
7817   int vector_len = _attributes-&gt;get_vector_len();
7818   bool vex_w = _attributes-&gt;is_rex_vex_w();
7819   if (vex_b || vex_x || vex_w || (opc == VEX_OPCODE_0F_38) || (opc == VEX_OPCODE_0F_3A)) {
7820     prefix(VEX_3bytes);
7821 
7822     int byte1 = (vex_r ? VEX_R : 0) | (vex_x ? VEX_X : 0) | (vex_b ? VEX_B : 0);
7823     byte1 = (~byte1) &amp; 0xE0;
7824     byte1 |= opc;
7825     emit_int8(byte1);
7826 
7827     int byte2 = ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
7828     byte2 |= (vex_w ? VEX_W : 0) | ((vector_len &gt; 0) ? 4 : 0) | pre;
7829     emit_int8(byte2);
7830   } else {
7831     prefix(VEX_2bytes);
7832 
7833     int byte1 = vex_r ? VEX_R : 0;
7834     byte1 = (~byte1) &amp; 0x80;
7835     byte1 |= ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
7836     byte1 |= ((vector_len &gt; 0 ) ? 4 : 0) | pre;
7837     emit_int8(byte1);
7838   }
7839 }
7840 
7841 // This is a 4 byte encoding
7842 void Assembler::evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v, int nds_enc, VexSimdPrefix pre, VexOpcode opc){
7843   // EVEX 0x62 prefix
7844   prefix(EVEX_4bytes);
7845   bool vex_w = _attributes-&gt;is_rex_vex_w();
7846   int evex_encoding = (vex_w ? VEX_W : 0);
7847   // EVEX.b is not currently used for broadcast of single element or data rounding modes
7848   _attributes-&gt;set_evex_encoding(evex_encoding);
7849 
7850   // P0: byte 2, initialized to RXBR`00mm
7851   // instead of not&#39;d
7852   int byte2 = (vex_r ? VEX_R : 0) | (vex_x ? VEX_X : 0) | (vex_b ? VEX_B : 0) | (evex_r ? EVEX_Rb : 0);
7853   byte2 = (~byte2) &amp; 0xF0;
7854   // confine opc opcode extensions in mm bits to lower two bits
7855   // of form {0F, 0F_38, 0F_3A}
7856   byte2 |= opc;
7857   emit_int8(byte2);
7858 
7859   // P1: byte 3 as Wvvvv1pp
7860   int byte3 = ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
7861   // p[10] is always 1
7862   byte3 |= EVEX_F;
7863   byte3 |= (vex_w &amp; 1) &lt;&lt; 7;
7864   // confine pre opcode extensions in pp bits to lower two bits
7865   // of form {66, F3, F2}
7866   byte3 |= pre;
7867   emit_int8(byte3);
7868 
7869   // P2: byte 4 as zL&#39;Lbv&#39;aaa
7870   // kregs are implemented in the low 3 bits as aaa
7871   int byte4 = (_attributes-&gt;is_no_reg_mask()) ?
7872               0 :
7873               _attributes-&gt;get_embedded_opmask_register_specifier();
7874   // EVEX.v` for extending EVEX.vvvv or VIDX
7875   byte4 |= (evex_v ? 0: EVEX_V);
7876   // third EXEC.b for broadcast actions
7877   byte4 |= (_attributes-&gt;is_extended_context() ? EVEX_Rb : 0);
7878   // fourth EVEX.L&#39;L for vector length : 0 is 128, 1 is 256, 2 is 512, currently we do not support 1024
7879   byte4 |= ((_attributes-&gt;get_vector_len())&amp; 0x3) &lt;&lt; 5;
7880   // last is EVEX.z for zero/merge actions
7881   if (_attributes-&gt;is_no_reg_mask() == false) {
7882     byte4 |= (_attributes-&gt;is_clear_context() ? EVEX_Z : 0);
7883   }
7884   emit_int8(byte4);
7885 }
7886 
7887 void Assembler::vex_prefix(Address adr, int nds_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {
7888   bool vex_r = ((xreg_enc &amp; 8) == 8) ? 1 : 0;
7889   bool vex_b = adr.base_needs_rex();
7890   bool vex_x;
7891   if (adr.isxmmindex()) {
7892     vex_x = adr.xmmindex_needs_rex();
7893   } else {
7894     vex_x = adr.index_needs_rex();
7895   }
7896   set_attributes(attributes);
7897   attributes-&gt;set_current_assembler(this);
7898 
7899   // For EVEX instruction (which is not marked as pure EVEX instruction) check and see if this instruction
7900   // is allowed in legacy mode and has resources which will fit in it.
7901   // Pure EVEX instructions will have is_evex_instruction set in their definition.
7902   if (!attributes-&gt;is_legacy_mode()) {
7903     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !_is_managed) {
7904       if ((attributes-&gt;get_vector_len() != AVX_512bit) &amp;&amp; (nds_enc &lt; 16) &amp;&amp; (xreg_enc &lt; 16)) {
7905           attributes-&gt;set_is_legacy_mode();
7906       }
7907     }
7908   }
7909 
7910   if (UseAVX &gt; 2) {
7911     assert(((!attributes-&gt;uses_vl()) ||
7912             (attributes-&gt;get_vector_len() == AVX_512bit) ||
7913             (!_legacy_mode_vl) ||
7914             (attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7915     assert(((nds_enc &lt; 16 &amp;&amp; xreg_enc &lt; 16) || (!attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7916   }
7917 
7918   _is_managed = false;
7919   if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_legacy_mode())
7920   {
7921     bool evex_r = (xreg_enc &gt;= 16);
7922     bool evex_v;
7923     // EVEX.V&#39; is set to true when VSIB is used as we may need to use higher order XMM registers (16-31)
7924     if (adr.isxmmindex())  {
7925       evex_v = ((adr._xmmindex-&gt;encoding() &gt; 15) ? true : false);
7926     } else {
7927       evex_v = (nds_enc &gt;= 16);
7928     }
7929     attributes-&gt;set_is_evex_instruction();
7930     evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_v, nds_enc, pre, opc);
7931   } else {
7932     if (UseAVX &gt; 2 &amp;&amp; attributes-&gt;is_rex_vex_w_reverted()) {
7933       attributes-&gt;set_rex_vex_w(false);
7934     }
7935     vex_prefix(vex_r, vex_b, vex_x, nds_enc, pre, opc);
7936   }
7937 }
7938 
7939 int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {
7940   bool vex_r = ((dst_enc &amp; 8) == 8) ? 1 : 0;
7941   bool vex_b = ((src_enc &amp; 8) == 8) ? 1 : 0;
7942   bool vex_x = false;
7943   set_attributes(attributes);
7944   attributes-&gt;set_current_assembler(this);
7945 
7946   // For EVEX instruction (which is not marked as pure EVEX instruction) check and see if this instruction
7947   // is allowed in legacy mode and has resources which will fit in it.
7948   // Pure EVEX instructions will have is_evex_instruction set in their definition.
7949   if (!attributes-&gt;is_legacy_mode()) {
7950     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !_is_managed) {
7951       if ((!attributes-&gt;uses_vl() || (attributes-&gt;get_vector_len() != AVX_512bit)) &amp;&amp;
7952           (dst_enc &lt; 16) &amp;&amp; (nds_enc &lt; 16) &amp;&amp; (src_enc &lt; 16)) {
7953           attributes-&gt;set_is_legacy_mode();
7954       }
7955     }
7956   }
7957 
7958   if (UseAVX &gt; 2) {
7959     // All the scalar fp instructions (with uses_vl as false) can have legacy_mode as false
7960     // Instruction with uses_vl true are vector instructions
7961     // All the vector instructions with AVX_512bit length can have legacy_mode as false
7962     // All the vector instructions with &lt; AVX_512bit length can have legacy_mode as false if AVX512vl() is supported
7963     // Rest all should have legacy_mode set as true
7964     assert(((!attributes-&gt;uses_vl()) ||
7965             (attributes-&gt;get_vector_len() == AVX_512bit) ||
7966             (!_legacy_mode_vl) ||
7967             (attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7968     // Instruction with legacy_mode true should have dst, nds and src &lt; 15
7969     assert(((dst_enc &lt; 16 &amp;&amp; nds_enc &lt; 16 &amp;&amp; src_enc &lt; 16) || (!attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7970   }
7971 
7972   _is_managed = false;
7973   if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_legacy_mode())
7974   {
7975     bool evex_r = (dst_enc &gt;= 16);
7976     bool evex_v = (nds_enc &gt;= 16);
7977     // can use vex_x as bank extender on rm encoding
7978     vex_x = (src_enc &gt;= 16);
7979     attributes-&gt;set_is_evex_instruction();
7980     evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_v, nds_enc, pre, opc);
7981   } else {
7982     if (UseAVX &gt; 2 &amp;&amp; attributes-&gt;is_rex_vex_w_reverted()) {
7983       attributes-&gt;set_rex_vex_w(false);
7984     }
7985     vex_prefix(vex_r, vex_b, vex_x, nds_enc, pre, opc);
7986   }
7987 
7988   // return modrm byte components for operands
7989   return (((dst_enc &amp; 7) &lt;&lt; 3) | (src_enc &amp; 7));
7990 }
7991 
7992 
7993 void Assembler::simd_prefix(XMMRegister xreg, XMMRegister nds, Address adr, VexSimdPrefix pre,
7994                             VexOpcode opc, InstructionAttr *attributes) {
7995   if (UseAVX &gt; 0) {
7996     int xreg_enc = xreg-&gt;encoding();
7997     int nds_enc = nds-&gt;is_valid() ? nds-&gt;encoding() : 0;
7998     vex_prefix(adr, nds_enc, xreg_enc, pre, opc, attributes);
7999   } else {
8000     assert((nds == xreg) || (nds == xnoreg), &quot;wrong sse encoding&quot;);
8001     rex_prefix(adr, xreg, pre, opc, attributes-&gt;is_rex_vex_w());
8002   }
8003 }
8004 
8005 int Assembler::simd_prefix_and_encode(XMMRegister dst, XMMRegister nds, XMMRegister src, VexSimdPrefix pre,
8006                                       VexOpcode opc, InstructionAttr *attributes) {
8007   int dst_enc = dst-&gt;encoding();
8008   int src_enc = src-&gt;encoding();
8009   if (UseAVX &gt; 0) {
8010     int nds_enc = nds-&gt;is_valid() ? nds-&gt;encoding() : 0;
8011     return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes);
8012   } else {
8013     assert((nds == dst) || (nds == src) || (nds == xnoreg), &quot;wrong sse encoding&quot;);
8014     return rex_prefix_and_encode(dst_enc, src_enc, pre, opc, attributes-&gt;is_rex_vex_w());
8015   }
8016 }
8017 
8018 void Assembler::vmaxss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
8019   assert(VM_Version::supports_avx(), &quot;&quot;);
8020   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8021   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
8022   emit_int8(0x5F);
8023   emit_int8((unsigned char)(0xC0 | encode));
8024 }
8025 
8026 void Assembler::vmaxsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
8027   assert(VM_Version::supports_avx(), &quot;&quot;);
8028   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8029   attributes.set_rex_vex_w_reverted();
8030   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
8031   emit_int8(0x5F);
8032   emit_int8((unsigned char)(0xC0 | encode));
8033 }
8034 
8035 void Assembler::vminss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
8036   assert(VM_Version::supports_avx(), &quot;&quot;);
8037   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8038   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
8039   emit_int8(0x5D);
8040   emit_int8((unsigned char)(0xC0 | encode));
8041 }
8042 
8043 void Assembler::vminsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
8044   assert(VM_Version::supports_avx(), &quot;&quot;);
8045   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8046   attributes.set_rex_vex_w_reverted();
8047   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
8048   emit_int8(0x5D);
8049   emit_int8((unsigned char)(0xC0 | encode));
8050 }
8051 
8052 void Assembler::cmppd(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len) {
8053   assert(VM_Version::supports_avx(), &quot;&quot;);
8054   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
8055   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
8056   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
8057   emit_int8((unsigned char)0xC2);
8058   emit_int8((unsigned char)(0xC0 | encode));
8059   emit_int8((unsigned char)(0xF &amp; cop));
8060 }
8061 
8062 void Assembler::blendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len) {
8063   assert(VM_Version::supports_avx(), &quot;&quot;);
8064   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
8065   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
8066   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
8067   emit_int8((unsigned char)0x4B);
8068   emit_int8((unsigned char)(0xC0 | encode));
8069   int src2_enc = src2-&gt;encoding();
8070   emit_int8((unsigned char)(0xF0 &amp; src2_enc&lt;&lt;4));
8071 }
8072 
8073 void Assembler::cmpps(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len) {
8074   assert(VM_Version::supports_avx(), &quot;&quot;);
8075   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
8076   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
8077   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
8078   emit_int8((unsigned char)0xC2);
8079   emit_int8((unsigned char)(0xC0 | encode));
8080   emit_int8((unsigned char)(0xF &amp; cop));
8081 }
8082 
8083 void Assembler::blendvps(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len) {
8084   assert(VM_Version::supports_avx(), &quot;&quot;);
8085   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
8086   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
8087   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
8088   emit_int8((unsigned char)0x4A);
8089   emit_int8((unsigned char)(0xC0 | encode));
8090   int src2_enc = src2-&gt;encoding();
8091   emit_int8((unsigned char)(0xF0 &amp; src2_enc&lt;&lt;4));
8092 }
8093 
8094 void Assembler::vpblendd(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
8095   assert(VM_Version::supports_avx2(), &quot;&quot;);
8096   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
8097   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
8098   emit_int8((unsigned char)0x02);
8099   emit_int8((unsigned char)(0xC0 | encode));
8100   emit_int8((unsigned char)imm8);
8101 }
8102 
8103 void Assembler::shlxl(Register dst, Register src1, Register src2) {
8104   assert(VM_Version::supports_bmi2(), &quot;&quot;);
8105   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
8106   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
8107   emit_int8((unsigned char)0xF7);
8108   emit_int8((unsigned char)(0xC0 | encode));
8109 }
8110 
8111 void Assembler::shlxq(Register dst, Register src1, Register src2) {
8112   assert(VM_Version::supports_bmi2(), &quot;&quot;);
8113   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
8114   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
8115   emit_int8((unsigned char)0xF7);
8116   emit_int8((unsigned char)(0xC0 | encode));
8117 }
8118 
8119 #ifndef _LP64
8120 
8121 void Assembler::incl(Register dst) {
8122   // Don&#39;t use it directly. Use MacroAssembler::incrementl() instead.
8123   emit_int8(0x40 | dst-&gt;encoding());
8124 }
8125 
8126 void Assembler::lea(Register dst, Address src) {
8127   leal(dst, src);
8128 }
8129 
8130 void Assembler::mov_literal32(Address dst, int32_t imm32, RelocationHolder const&amp; rspec) {
8131   InstructionMark im(this);
8132   emit_int8((unsigned char)0xC7);
8133   emit_operand(rax, dst);
8134   emit_data((int)imm32, rspec, 0);
8135 }
8136 
8137 void Assembler::mov_literal32(Register dst, int32_t imm32, RelocationHolder const&amp; rspec) {
8138   InstructionMark im(this);
8139   int encode = prefix_and_encode(dst-&gt;encoding());
8140   emit_int8((unsigned char)(0xB8 | encode));
8141   emit_data((int)imm32, rspec, 0);
8142 }
8143 
8144 void Assembler::popa() { // 32bit
8145   emit_int8(0x61);
8146 }
8147 
8148 void Assembler::push_literal32(int32_t imm32, RelocationHolder const&amp; rspec) {
8149   InstructionMark im(this);
8150   emit_int8(0x68);
8151   emit_data(imm32, rspec, 0);
8152 }
8153 
8154 void Assembler::pusha() { // 32bit
8155   emit_int8(0x60);
8156 }
8157 
8158 void Assembler::set_byte_if_not_zero(Register dst) {
8159   emit_int8(0x0F);
8160   emit_int8((unsigned char)0x95);
8161   emit_int8((unsigned char)(0xE0 | dst-&gt;encoding()));
8162 }
8163 
8164 #else // LP64
8165 
8166 void Assembler::set_byte_if_not_zero(Register dst) {
8167   int enc = prefix_and_encode(dst-&gt;encoding(), true);
8168   emit_int8(0x0F);
8169   emit_int8((unsigned char)0x95);
8170   emit_int8((unsigned char)(0xE0 | enc));
8171 }
8172 
8173 // 64bit only pieces of the assembler
8174 // This should only be used by 64bit instructions that can use rip-relative
8175 // it cannot be used by instructions that want an immediate value.
8176 
8177 bool Assembler::reachable(AddressLiteral adr) {
8178   int64_t disp;
8179   relocInfo::relocType relocType = adr.reloc();
8180 
8181   // None will force a 64bit literal to the code stream. Likely a placeholder
8182   // for something that will be patched later and we need to certain it will
8183   // always be reachable.
8184   if (relocType == relocInfo::none) {
8185     return false;
8186   }
8187   if (relocType == relocInfo::internal_word_type) {
8188     // This should be rip relative and easily reachable.
8189     return true;
8190   }
8191   if (relocType == relocInfo::virtual_call_type ||
8192       relocType == relocInfo::opt_virtual_call_type ||
8193       relocType == relocInfo::static_call_type ||
8194       relocType == relocInfo::static_stub_type ) {
8195     // This should be rip relative within the code cache and easily
8196     // reachable until we get huge code caches. (At which point
8197     // ic code is going to have issues).
8198     return true;
8199   }
8200   if (relocType != relocInfo::external_word_type &amp;&amp;
8201       relocType != relocInfo::poll_return_type &amp;&amp;  // these are really external_word but need special
8202       relocType != relocInfo::poll_type &amp;&amp;         // relocs to identify them
8203       relocType != relocInfo::runtime_call_type ) {
8204     return false;
8205   }
8206 
8207   // Stress the correction code
8208   if (ForceUnreachable) {
8209     // Must be runtimecall reloc, see if it is in the codecache
8210     // Flipping stuff in the codecache to be unreachable causes issues
8211     // with things like inline caches where the additional instructions
8212     // are not handled.
8213     if (CodeCache::find_blob(adr._target) == NULL) {
8214       return false;
8215     }
8216   }
8217   // For external_word_type/runtime_call_type if it is reachable from where we
8218   // are now (possibly a temp buffer) and where we might end up
8219   // anywhere in the codeCache then we are always reachable.
8220   // This would have to change if we ever save/restore shared code
8221   // to be more pessimistic.
8222   disp = (int64_t)adr._target - ((int64_t)CodeCache::low_bound() + sizeof(int));
8223   if (!is_simm32(disp)) return false;
8224   disp = (int64_t)adr._target - ((int64_t)CodeCache::high_bound() + sizeof(int));
8225   if (!is_simm32(disp)) return false;
8226 
8227   disp = (int64_t)adr._target - ((int64_t)pc() + sizeof(int));
8228 
8229   // Because rip relative is a disp + address_of_next_instruction and we
8230   // don&#39;t know the value of address_of_next_instruction we apply a fudge factor
8231   // to make sure we will be ok no matter the size of the instruction we get placed into.
8232   // We don&#39;t have to fudge the checks above here because they are already worst case.
8233 
8234   // 12 == override/rex byte, opcode byte, rm byte, sib byte, a 4-byte disp , 4-byte literal
8235   // + 4 because better safe than sorry.
8236   const int fudge = 12 + 4;
8237   if (disp &lt; 0) {
8238     disp -= fudge;
8239   } else {
8240     disp += fudge;
8241   }
8242   return is_simm32(disp);
8243 }
8244 
8245 // Check if the polling page is not reachable from the code cache using rip-relative
8246 // addressing.
8247 bool Assembler::is_polling_page_far() {
8248   intptr_t addr = (intptr_t)os::get_polling_page();
8249   return ForceUnreachable ||
8250          !is_simm32(addr - (intptr_t)CodeCache::low_bound()) ||
8251          !is_simm32(addr - (intptr_t)CodeCache::high_bound());
8252 }
8253 
8254 void Assembler::emit_data64(jlong data,
8255                             relocInfo::relocType rtype,
8256                             int format) {
8257   if (rtype == relocInfo::none) {
8258     emit_int64(data);
8259   } else {
8260     emit_data64(data, Relocation::spec_simple(rtype), format);
8261   }
8262 }
8263 
8264 void Assembler::emit_data64(jlong data,
8265                             RelocationHolder const&amp; rspec,
8266                             int format) {
8267   assert(imm_operand == 0, &quot;default format must be immediate in this file&quot;);
8268   assert(imm_operand == format, &quot;must be immediate&quot;);
8269   assert(inst_mark() != NULL, &quot;must be inside InstructionMark&quot;);
8270   // Do not use AbstractAssembler::relocate, which is not intended for
8271   // embedded words.  Instead, relocate to the enclosing instruction.
8272   code_section()-&gt;relocate(inst_mark(), rspec, format);
8273 #ifdef ASSERT
8274   check_relocation(rspec, format);
8275 #endif
8276   emit_int64(data);
8277 }
8278 
8279 int Assembler::prefix_and_encode(int reg_enc, bool byteinst) {
8280   if (reg_enc &gt;= 8) {
8281     prefix(REX_B);
8282     reg_enc -= 8;
8283   } else if (byteinst &amp;&amp; reg_enc &gt;= 4) {
8284     prefix(REX);
8285   }
8286   return reg_enc;
8287 }
8288 
8289 int Assembler::prefixq_and_encode(int reg_enc) {
8290   if (reg_enc &lt; 8) {
8291     prefix(REX_W);
8292   } else {
8293     prefix(REX_WB);
8294     reg_enc -= 8;
8295   }
8296   return reg_enc;
8297 }
8298 
8299 int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte) {
8300   if (dst_enc &lt; 8) {
8301     if (src_enc &gt;= 8) {
8302       prefix(REX_B);
8303       src_enc -= 8;
8304     } else if ((src_is_byte &amp;&amp; src_enc &gt;= 4) || (dst_is_byte &amp;&amp; dst_enc &gt;= 4)) {
8305       prefix(REX);
8306     }
8307   } else {
8308     if (src_enc &lt; 8) {
8309       prefix(REX_R);
8310     } else {
8311       prefix(REX_RB);
8312       src_enc -= 8;
8313     }
8314     dst_enc -= 8;
8315   }
8316   return dst_enc &lt;&lt; 3 | src_enc;
8317 }
8318 
8319 int Assembler::prefixq_and_encode(int dst_enc, int src_enc) {
8320   if (dst_enc &lt; 8) {
8321     if (src_enc &lt; 8) {
8322       prefix(REX_W);
8323     } else {
8324       prefix(REX_WB);
8325       src_enc -= 8;
8326     }
8327   } else {
8328     if (src_enc &lt; 8) {
8329       prefix(REX_WR);
8330     } else {
8331       prefix(REX_WRB);
8332       src_enc -= 8;
8333     }
8334     dst_enc -= 8;
8335   }
8336   return dst_enc &lt;&lt; 3 | src_enc;
8337 }
8338 
8339 void Assembler::prefix(Register reg) {
8340   if (reg-&gt;encoding() &gt;= 8) {
8341     prefix(REX_B);
8342   }
8343 }
8344 
8345 void Assembler::prefix(Register dst, Register src, Prefix p) {
8346   if (src-&gt;encoding() &gt;= 8) {
8347     p = (Prefix)(p | REX_B);
8348   }
8349   if (dst-&gt;encoding() &gt;= 8) {
8350     p = (Prefix)( p | REX_R);
8351   }
8352   if (p != Prefix_EMPTY) {
8353     // do not generate an empty prefix
8354     prefix(p);
8355   }
8356 }
8357 
8358 void Assembler::prefix(Register dst, Address adr, Prefix p) {
8359   if (adr.base_needs_rex()) {
8360     if (adr.index_needs_rex()) {
8361       assert(false, &quot;prefix(Register dst, Address adr, Prefix p) does not support handling of an X&quot;);
8362     } else {
8363       prefix(REX_B);
8364     }
8365   } else {
8366     if (adr.index_needs_rex()) {
8367       assert(false, &quot;prefix(Register dst, Address adr, Prefix p) does not support handling of an X&quot;);
8368     }
8369   }
8370   if (dst-&gt;encoding() &gt;= 8) {
8371     p = (Prefix)(p | REX_R);
8372   }
8373   if (p != Prefix_EMPTY) {
8374     // do not generate an empty prefix
8375     prefix(p);
8376   }
8377 }
8378 
8379 void Assembler::prefix(Address adr) {
8380   if (adr.base_needs_rex()) {
8381     if (adr.index_needs_rex()) {
8382       prefix(REX_XB);
8383     } else {
8384       prefix(REX_B);
8385     }
8386   } else {
8387     if (adr.index_needs_rex()) {
8388       prefix(REX_X);
8389     }
8390   }
8391 }
8392 
8393 void Assembler::prefixq(Address adr) {
8394   if (adr.base_needs_rex()) {
8395     if (adr.index_needs_rex()) {
8396       prefix(REX_WXB);
8397     } else {
8398       prefix(REX_WB);
8399     }
8400   } else {
8401     if (adr.index_needs_rex()) {
8402       prefix(REX_WX);
8403     } else {
8404       prefix(REX_W);
8405     }
8406   }
8407 }
8408 
8409 
8410 void Assembler::prefix(Address adr, Register reg, bool byteinst) {
8411   if (reg-&gt;encoding() &lt; 8) {
8412     if (adr.base_needs_rex()) {
8413       if (adr.index_needs_rex()) {
8414         prefix(REX_XB);
8415       } else {
8416         prefix(REX_B);
8417       }
8418     } else {
8419       if (adr.index_needs_rex()) {
8420         prefix(REX_X);
8421       } else if (byteinst &amp;&amp; reg-&gt;encoding() &gt;= 4 ) {
8422         prefix(REX);
8423       }
8424     }
8425   } else {
8426     if (adr.base_needs_rex()) {
8427       if (adr.index_needs_rex()) {
8428         prefix(REX_RXB);
8429       } else {
8430         prefix(REX_RB);
8431       }
8432     } else {
8433       if (adr.index_needs_rex()) {
8434         prefix(REX_RX);
8435       } else {
8436         prefix(REX_R);
8437       }
8438     }
8439   }
8440 }
8441 
8442 void Assembler::prefixq(Address adr, Register src) {
8443   if (src-&gt;encoding() &lt; 8) {
8444     if (adr.base_needs_rex()) {
8445       if (adr.index_needs_rex()) {
8446         prefix(REX_WXB);
8447       } else {
8448         prefix(REX_WB);
8449       }
8450     } else {
8451       if (adr.index_needs_rex()) {
8452         prefix(REX_WX);
8453       } else {
8454         prefix(REX_W);
8455       }
8456     }
8457   } else {
8458     if (adr.base_needs_rex()) {
8459       if (adr.index_needs_rex()) {
8460         prefix(REX_WRXB);
8461       } else {
8462         prefix(REX_WRB);
8463       }
8464     } else {
8465       if (adr.index_needs_rex()) {
8466         prefix(REX_WRX);
8467       } else {
8468         prefix(REX_WR);
8469       }
8470     }
8471   }
8472 }
8473 
8474 void Assembler::prefix(Address adr, XMMRegister reg) {
8475   if (reg-&gt;encoding() &lt; 8) {
8476     if (adr.base_needs_rex()) {
8477       if (adr.index_needs_rex()) {
8478         prefix(REX_XB);
8479       } else {
8480         prefix(REX_B);
8481       }
8482     } else {
8483       if (adr.index_needs_rex()) {
8484         prefix(REX_X);
8485       }
8486     }
8487   } else {
8488     if (adr.base_needs_rex()) {
8489       if (adr.index_needs_rex()) {
8490         prefix(REX_RXB);
8491       } else {
8492         prefix(REX_RB);
8493       }
8494     } else {
8495       if (adr.index_needs_rex()) {
8496         prefix(REX_RX);
8497       } else {
8498         prefix(REX_R);
8499       }
8500     }
8501   }
8502 }
8503 
8504 void Assembler::prefixq(Address adr, XMMRegister src) {
8505   if (src-&gt;encoding() &lt; 8) {
8506     if (adr.base_needs_rex()) {
8507       if (adr.index_needs_rex()) {
8508         prefix(REX_WXB);
8509       } else {
8510         prefix(REX_WB);
8511       }
8512     } else {
8513       if (adr.index_needs_rex()) {
8514         prefix(REX_WX);
8515       } else {
8516         prefix(REX_W);
8517       }
8518     }
8519   } else {
8520     if (adr.base_needs_rex()) {
8521       if (adr.index_needs_rex()) {
8522         prefix(REX_WRXB);
8523       } else {
8524         prefix(REX_WRB);
8525       }
8526     } else {
8527       if (adr.index_needs_rex()) {
8528         prefix(REX_WRX);
8529       } else {
8530         prefix(REX_WR);
8531       }
8532     }
8533   }
8534 }
8535 
8536 void Assembler::adcq(Register dst, int32_t imm32) {
8537   (void) prefixq_and_encode(dst-&gt;encoding());
8538   emit_arith(0x81, 0xD0, dst, imm32);
8539 }
8540 
8541 void Assembler::adcq(Register dst, Address src) {
8542   InstructionMark im(this);
8543   prefixq(src, dst);
8544   emit_int8(0x13);
8545   emit_operand(dst, src);
8546 }
8547 
8548 void Assembler::adcq(Register dst, Register src) {
8549   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8550   emit_arith(0x13, 0xC0, dst, src);
8551 }
8552 
8553 void Assembler::addq(Address dst, int32_t imm32) {
8554   InstructionMark im(this);
8555   prefixq(dst);
8556   emit_arith_operand(0x81, rax, dst,imm32);
8557 }
8558 
8559 void Assembler::addq(Address dst, Register src) {
8560   InstructionMark im(this);
8561   prefixq(dst, src);
8562   emit_int8(0x01);
8563   emit_operand(src, dst);
8564 }
8565 
8566 void Assembler::addq(Register dst, int32_t imm32) {
8567   (void) prefixq_and_encode(dst-&gt;encoding());
8568   emit_arith(0x81, 0xC0, dst, imm32);
8569 }
8570 
8571 void Assembler::addq(Register dst, Address src) {
8572   InstructionMark im(this);
8573   prefixq(src, dst);
8574   emit_int8(0x03);
8575   emit_operand(dst, src);
8576 }
8577 
8578 void Assembler::addq(Register dst, Register src) {
8579   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8580   emit_arith(0x03, 0xC0, dst, src);
8581 }
8582 
8583 void Assembler::adcxq(Register dst, Register src) {
8584   //assert(VM_Version::supports_adx(), &quot;adx instructions not supported&quot;);
8585   emit_int8((unsigned char)0x66);
8586   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8587   emit_int8(0x0F);
8588   emit_int8(0x38);
8589   emit_int8((unsigned char)0xF6);
8590   emit_int8((unsigned char)(0xC0 | encode));
8591 }
8592 
8593 void Assembler::adoxq(Register dst, Register src) {
8594   //assert(VM_Version::supports_adx(), &quot;adx instructions not supported&quot;);
8595   emit_int8((unsigned char)0xF3);
8596   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8597   emit_int8(0x0F);
8598   emit_int8(0x38);
8599   emit_int8((unsigned char)0xF6);
8600   emit_int8((unsigned char)(0xC0 | encode));
8601 }
8602 
8603 void Assembler::andq(Address dst, int32_t imm32) {
8604   InstructionMark im(this);
8605   prefixq(dst);
8606   emit_int8((unsigned char)0x81);
8607   emit_operand(rsp, dst, 4);
8608   emit_int32(imm32);
8609 }
8610 
8611 void Assembler::andq(Register dst, int32_t imm32) {
8612   (void) prefixq_and_encode(dst-&gt;encoding());
8613   emit_arith(0x81, 0xE0, dst, imm32);
8614 }
8615 
8616 void Assembler::andq(Register dst, Address src) {
8617   InstructionMark im(this);
8618   prefixq(src, dst);
8619   emit_int8(0x23);
8620   emit_operand(dst, src);
8621 }
8622 
8623 void Assembler::andq(Register dst, Register src) {
8624   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8625   emit_arith(0x23, 0xC0, dst, src);
8626 }
8627 
8628 void Assembler::andnq(Register dst, Register src1, Register src2) {
8629   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8630   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8631   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8632   emit_int8((unsigned char)0xF2);
8633   emit_int8((unsigned char)(0xC0 | encode));
8634 }
8635 
8636 void Assembler::andnq(Register dst, Register src1, Address src2) {
8637   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8638   InstructionMark im(this);
8639   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8640   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8641   emit_int8((unsigned char)0xF2);
8642   emit_operand(dst, src2);
8643 }
8644 
8645 void Assembler::bsfq(Register dst, Register src) {
8646   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8647   emit_int8(0x0F);
8648   emit_int8((unsigned char)0xBC);
8649   emit_int8((unsigned char)(0xC0 | encode));
8650 }
8651 
8652 void Assembler::bsrq(Register dst, Register src) {
8653   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8654   emit_int8(0x0F);
8655   emit_int8((unsigned char)0xBD);
8656   emit_int8((unsigned char)(0xC0 | encode));
8657 }
8658 
8659 void Assembler::bswapq(Register reg) {
8660   int encode = prefixq_and_encode(reg-&gt;encoding());
8661   emit_int8(0x0F);
8662   emit_int8((unsigned char)(0xC8 | encode));
8663 }
8664 
8665 void Assembler::blsiq(Register dst, Register src) {
8666   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8667   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8668   int encode = vex_prefix_and_encode(rbx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8669   emit_int8((unsigned char)0xF3);
8670   emit_int8((unsigned char)(0xC0 | encode));
8671 }
8672 
8673 void Assembler::blsiq(Register dst, Address src) {
8674   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8675   InstructionMark im(this);
8676   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8677   vex_prefix(src, dst-&gt;encoding(), rbx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8678   emit_int8((unsigned char)0xF3);
8679   emit_operand(rbx, src);
8680 }
8681 
8682 void Assembler::blsmskq(Register dst, Register src) {
8683   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8684   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8685   int encode = vex_prefix_and_encode(rdx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8686   emit_int8((unsigned char)0xF3);
8687   emit_int8((unsigned char)(0xC0 | encode));
8688 }
8689 
8690 void Assembler::blsmskq(Register dst, Address src) {
8691   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8692   InstructionMark im(this);
8693   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8694   vex_prefix(src, dst-&gt;encoding(), rdx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8695   emit_int8((unsigned char)0xF3);
8696   emit_operand(rdx, src);
8697 }
8698 
8699 void Assembler::blsrq(Register dst, Register src) {
8700   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8701   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8702   int encode = vex_prefix_and_encode(rcx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8703   emit_int8((unsigned char)0xF3);
8704   emit_int8((unsigned char)(0xC0 | encode));
8705 }
8706 
8707 void Assembler::blsrq(Register dst, Address src) {
8708   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8709   InstructionMark im(this);
8710   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8711   vex_prefix(src, dst-&gt;encoding(), rcx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8712   emit_int8((unsigned char)0xF3);
8713   emit_operand(rcx, src);
8714 }
8715 
8716 void Assembler::cdqq() {
8717   prefix(REX_W);
8718   emit_int8((unsigned char)0x99);
8719 }
8720 
8721 void Assembler::clflush(Address adr) {
8722   assert(VM_Version::supports_clflush(), &quot;should do&quot;);
8723   prefix(adr);
8724   emit_int8(0x0F);
8725   emit_int8((unsigned char)0xAE);
8726   emit_operand(rdi, adr);
8727 }
8728 
8729 void Assembler::clflushopt(Address adr) {
8730   assert(VM_Version::supports_clflushopt(), &quot;should do!&quot;);
8731   // adr should be base reg only with no index or offset
8732   assert(adr.index() == noreg, &quot;index should be noreg&quot;);
8733   assert(adr.scale() == Address::no_scale, &quot;scale should be no_scale&quot;);
8734   assert(adr.disp() == 0, &quot;displacement should be 0&quot;);
8735   // instruction prefix is 0x66
8736   emit_int8(0x66);
8737   prefix(adr);
8738   // opcode family is 0x0f 0xAE
8739   emit_int8(0x0F);
8740   emit_int8((unsigned char)0xAE);
8741   // extended opcode byte is 7 == rdi
8742   emit_operand(rdi, adr);
8743 }
8744 
8745 void Assembler::clwb(Address adr) {
8746   assert(VM_Version::supports_clwb(), &quot;should do!&quot;);
8747   // adr should be base reg only with no index or offset
8748   assert(adr.index() == noreg, &quot;index should be noreg&quot;);
8749   assert(adr.scale() == Address::no_scale, &quot;scale should be no_scale&quot;);
8750   assert(adr.disp() == 0, &quot;displacement should be 0&quot;);
8751   // instruction prefix is 0x66
8752   emit_int8(0x66);
8753   prefix(adr);
8754   // opcode family is 0x0f 0xAE
8755   emit_int8(0x0F);
8756   emit_int8((unsigned char)0xAE);
8757   // extended opcode byte is 6 == rsi
8758   emit_operand(rsi, adr);
8759 }
8760 
8761 void Assembler::cmovq(Condition cc, Register dst, Register src) {
8762   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8763   emit_int8(0x0F);
8764   emit_int8(0x40 | cc);
8765   emit_int8((unsigned char)(0xC0 | encode));
8766 }
8767 
8768 void Assembler::cmovq(Condition cc, Register dst, Address src) {
8769   InstructionMark im(this);
8770   prefixq(src, dst);
8771   emit_int8(0x0F);
8772   emit_int8(0x40 | cc);
8773   emit_operand(dst, src);
8774 }
8775 
8776 void Assembler::cmpq(Address dst, int32_t imm32) {
8777   InstructionMark im(this);
8778   prefixq(dst);
8779   emit_int8((unsigned char)0x81);
8780   emit_operand(rdi, dst, 4);
8781   emit_int32(imm32);
8782 }
8783 
8784 void Assembler::cmpq(Register dst, int32_t imm32) {
8785   (void) prefixq_and_encode(dst-&gt;encoding());
8786   emit_arith(0x81, 0xF8, dst, imm32);
8787 }
8788 
8789 void Assembler::cmpq(Address dst, Register src) {
8790   InstructionMark im(this);
8791   prefixq(dst, src);
8792   emit_int8(0x3B);
8793   emit_operand(src, dst);
8794 }
8795 
8796 void Assembler::cmpq(Register dst, Register src) {
8797   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8798   emit_arith(0x3B, 0xC0, dst, src);
8799 }
8800 
8801 void Assembler::cmpq(Register dst, Address  src) {
8802   InstructionMark im(this);
8803   prefixq(src, dst);
8804   emit_int8(0x3B);
8805   emit_operand(dst, src);
8806 }
8807 
8808 void Assembler::cmpxchgq(Register reg, Address adr) {
8809   InstructionMark im(this);
8810   prefixq(adr, reg);
8811   emit_int8(0x0F);
8812   emit_int8((unsigned char)0xB1);
8813   emit_operand(reg, adr);
8814 }
8815 
8816 void Assembler::cvtsi2sdq(XMMRegister dst, Register src) {
8817   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8818   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8819   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
8820   emit_int8(0x2A);
8821   emit_int8((unsigned char)(0xC0 | encode));
8822 }
8823 
8824 void Assembler::cvtsi2sdq(XMMRegister dst, Address src) {
8825   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8826   InstructionMark im(this);
8827   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8828   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
8829   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
8830   emit_int8(0x2A);
8831   emit_operand(dst, src);
8832 }
8833 
8834 void Assembler::cvtsi2ssq(XMMRegister dst, Address src) {
8835   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
8836   InstructionMark im(this);
8837   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8838   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
8839   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
8840   emit_int8(0x2A);
8841   emit_operand(dst, src);
8842 }
8843 
8844 void Assembler::cvttsd2siq(Register dst, Address src) {
8845   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8846   // F2 REX.W 0F 2C /r
8847   // CVTTSD2SI r64, xmm1/m64
8848   InstructionMark im(this);
8849   emit_int8((unsigned char)0xF2);
8850   prefix(REX_W);
8851   emit_int8(0x0F);
8852   emit_int8(0x2C);
8853   emit_operand(dst, src);
8854 }
8855 
8856 void Assembler::cvttsd2siq(Register dst, XMMRegister src) {
8857   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8858   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8859   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
8860   emit_int8(0x2C);
8861   emit_int8((unsigned char)(0xC0 | encode));
8862 }
8863 
8864 void Assembler::cvttss2siq(Register dst, XMMRegister src) {
8865   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
8866   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8867   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
8868   emit_int8(0x2C);
8869   emit_int8((unsigned char)(0xC0 | encode));
8870 }
8871 
8872 void Assembler::decl(Register dst) {
8873   // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
8874   // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
8875   int encode = prefix_and_encode(dst-&gt;encoding());
8876   emit_int8((unsigned char)0xFF);
8877   emit_int8((unsigned char)(0xC8 | encode));
8878 }
8879 
8880 void Assembler::decq(Register dst) {
8881   // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
8882   // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
8883   int encode = prefixq_and_encode(dst-&gt;encoding());
8884   emit_int8((unsigned char)0xFF);
8885   emit_int8(0xC8 | encode);
8886 }
8887 
8888 void Assembler::decq(Address dst) {
8889   // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
8890   InstructionMark im(this);
8891   prefixq(dst);
8892   emit_int8((unsigned char)0xFF);
8893   emit_operand(rcx, dst);
8894 }
8895 
<a name="3" id="anc3"></a>











8896 void Assembler::fxrstor(Address src) {
8897   prefixq(src);
8898   emit_int8(0x0F);
8899   emit_int8((unsigned char)0xAE);
8900   emit_operand(as_Register(1), src);
8901 }
8902 
8903 void Assembler::xrstor(Address src) {
8904   prefixq(src);
8905   emit_int8(0x0F);
8906   emit_int8((unsigned char)0xAE);
8907   emit_operand(as_Register(5), src);
8908 }
8909 
8910 void Assembler::fxsave(Address dst) {
8911   prefixq(dst);
8912   emit_int8(0x0F);
8913   emit_int8((unsigned char)0xAE);
8914   emit_operand(as_Register(0), dst);
8915 }
8916 
8917 void Assembler::xsave(Address dst) {
8918   prefixq(dst);
8919   emit_int8(0x0F);
8920   emit_int8((unsigned char)0xAE);
8921   emit_operand(as_Register(4), dst);
8922 }
8923 
8924 void Assembler::idivq(Register src) {
8925   int encode = prefixq_and_encode(src-&gt;encoding());
8926   emit_int8((unsigned char)0xF7);
8927   emit_int8((unsigned char)(0xF8 | encode));
8928 }
8929 
8930 void Assembler::imulq(Register dst, Register src) {
8931   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8932   emit_int8(0x0F);
8933   emit_int8((unsigned char)0xAF);
8934   emit_int8((unsigned char)(0xC0 | encode));
8935 }
8936 
8937 void Assembler::imulq(Register dst, Register src, int value) {
8938   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8939   if (is8bit(value)) {
8940     emit_int8(0x6B);
8941     emit_int8((unsigned char)(0xC0 | encode));
8942     emit_int8(value &amp; 0xFF);
8943   } else {
8944     emit_int8(0x69);
8945     emit_int8((unsigned char)(0xC0 | encode));
8946     emit_int32(value);
8947   }
8948 }
8949 
8950 void Assembler::imulq(Register dst, Address src) {
8951   InstructionMark im(this);
8952   prefixq(src, dst);
8953   emit_int8(0x0F);
8954   emit_int8((unsigned char) 0xAF);
8955   emit_operand(dst, src);
8956 }
8957 
8958 void Assembler::incl(Register dst) {
8959   // Don&#39;t use it directly. Use MacroAssembler::incrementl() instead.
8960   // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
8961   int encode = prefix_and_encode(dst-&gt;encoding());
8962   emit_int8((unsigned char)0xFF);
8963   emit_int8((unsigned char)(0xC0 | encode));
8964 }
8965 
8966 void Assembler::incq(Register dst) {
8967   // Don&#39;t use it directly. Use MacroAssembler::incrementq() instead.
8968   // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
8969   int encode = prefixq_and_encode(dst-&gt;encoding());
8970   emit_int8((unsigned char)0xFF);
8971   emit_int8((unsigned char)(0xC0 | encode));
8972 }
8973 
8974 void Assembler::incq(Address dst) {
8975   // Don&#39;t use it directly. Use MacroAssembler::incrementq() instead.
8976   InstructionMark im(this);
8977   prefixq(dst);
8978   emit_int8((unsigned char)0xFF);
8979   emit_operand(rax, dst);
8980 }
8981 
8982 void Assembler::lea(Register dst, Address src) {
8983   leaq(dst, src);
8984 }
8985 
8986 void Assembler::leaq(Register dst, Address src) {
8987   InstructionMark im(this);
8988   prefixq(src, dst);
8989   emit_int8((unsigned char)0x8D);
8990   emit_operand(dst, src);
8991 }
8992 
8993 void Assembler::mov64(Register dst, int64_t imm64) {
8994   InstructionMark im(this);
8995   int encode = prefixq_and_encode(dst-&gt;encoding());
8996   emit_int8((unsigned char)(0xB8 | encode));
8997   emit_int64(imm64);
8998 }
8999 
9000 void Assembler::mov_literal64(Register dst, intptr_t imm64, RelocationHolder const&amp; rspec) {
9001   InstructionMark im(this);
9002   int encode = prefixq_and_encode(dst-&gt;encoding());
9003   emit_int8(0xB8 | encode);
9004   emit_data64(imm64, rspec);
9005 }
9006 
9007 void Assembler::mov_narrow_oop(Register dst, int32_t imm32, RelocationHolder const&amp; rspec) {
9008   InstructionMark im(this);
9009   int encode = prefix_and_encode(dst-&gt;encoding());
9010   emit_int8((unsigned char)(0xB8 | encode));
9011   emit_data((int)imm32, rspec, narrow_oop_operand);
9012 }
9013 
9014 void Assembler::mov_narrow_oop(Address dst, int32_t imm32,  RelocationHolder const&amp; rspec) {
9015   InstructionMark im(this);
9016   prefix(dst);
9017   emit_int8((unsigned char)0xC7);
9018   emit_operand(rax, dst, 4);
9019   emit_data((int)imm32, rspec, narrow_oop_operand);
9020 }
9021 
9022 void Assembler::cmp_narrow_oop(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
9023   InstructionMark im(this);
9024   int encode = prefix_and_encode(src1-&gt;encoding());
9025   emit_int8((unsigned char)0x81);
9026   emit_int8((unsigned char)(0xF8 | encode));
9027   emit_data((int)imm32, rspec, narrow_oop_operand);
9028 }
9029 
9030 void Assembler::cmp_narrow_oop(Address src1, int32_t imm32, RelocationHolder const&amp; rspec) {
9031   InstructionMark im(this);
9032   prefix(src1);
9033   emit_int8((unsigned char)0x81);
9034   emit_operand(rax, src1, 4);
9035   emit_data((int)imm32, rspec, narrow_oop_operand);
9036 }
9037 
9038 void Assembler::lzcntq(Register dst, Register src) {
9039   assert(VM_Version::supports_lzcnt(), &quot;encoding is treated as BSR&quot;);
9040   emit_int8((unsigned char)0xF3);
9041   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9042   emit_int8(0x0F);
9043   emit_int8((unsigned char)0xBD);
9044   emit_int8((unsigned char)(0xC0 | encode));
9045 }
9046 
9047 void Assembler::movdq(XMMRegister dst, Register src) {
9048   // table D-1 says MMX/SSE2
9049   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
9050   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
9051   int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
9052   emit_int8(0x6E);
9053   emit_int8((unsigned char)(0xC0 | encode));
9054 }
9055 
9056 void Assembler::movdq(Register dst, XMMRegister src) {
9057   // table D-1 says MMX/SSE2
9058   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
9059   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
9060   // swap src/dst to get correct prefix
9061   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
9062   emit_int8(0x7E);
9063   emit_int8((unsigned char)(0xC0 | encode));
9064 }
9065 
9066 void Assembler::movq(Register dst, Register src) {
9067   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9068   emit_int8((unsigned char)0x8B);
9069   emit_int8((unsigned char)(0xC0 | encode));
9070 }
9071 
9072 void Assembler::movq(Register dst, Address src) {
9073   InstructionMark im(this);
9074   prefixq(src, dst);
9075   emit_int8((unsigned char)0x8B);
9076   emit_operand(dst, src);
9077 }
9078 
9079 void Assembler::movq(Address dst, Register src) {
9080   InstructionMark im(this);
9081   prefixq(dst, src);
9082   emit_int8((unsigned char)0x89);
9083   emit_operand(src, dst);
9084 }
9085 
9086 void Assembler::movsbq(Register dst, Address src) {
9087   InstructionMark im(this);
9088   prefixq(src, dst);
9089   emit_int8(0x0F);
9090   emit_int8((unsigned char)0xBE);
9091   emit_operand(dst, src);
9092 }
9093 
9094 void Assembler::movsbq(Register dst, Register src) {
9095   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9096   emit_int8(0x0F);
9097   emit_int8((unsigned char)0xBE);
9098   emit_int8((unsigned char)(0xC0 | encode));
9099 }
9100 
9101 void Assembler::movslq(Register dst, int32_t imm32) {
9102   // dbx shows movslq(rcx, 3) as movq     $0x0000000049000000,(%rbx)
9103   // and movslq(r8, 3); as movl     $0x0000000048000000,(%rbx)
9104   // as a result we shouldn&#39;t use until tested at runtime...
9105   ShouldNotReachHere();
9106   InstructionMark im(this);
9107   int encode = prefixq_and_encode(dst-&gt;encoding());
9108   emit_int8((unsigned char)(0xC7 | encode));
9109   emit_int32(imm32);
9110 }
9111 
9112 void Assembler::movslq(Address dst, int32_t imm32) {
9113   assert(is_simm32(imm32), &quot;lost bits&quot;);
9114   InstructionMark im(this);
9115   prefixq(dst);
9116   emit_int8((unsigned char)0xC7);
9117   emit_operand(rax, dst, 4);
9118   emit_int32(imm32);
9119 }
9120 
9121 void Assembler::movslq(Register dst, Address src) {
9122   InstructionMark im(this);
9123   prefixq(src, dst);
9124   emit_int8(0x63);
9125   emit_operand(dst, src);
9126 }
9127 
9128 void Assembler::movslq(Register dst, Register src) {
9129   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9130   emit_int8(0x63);
9131   emit_int8((unsigned char)(0xC0 | encode));
9132 }
9133 
9134 void Assembler::movswq(Register dst, Address src) {
9135   InstructionMark im(this);
9136   prefixq(src, dst);
9137   emit_int8(0x0F);
9138   emit_int8((unsigned char)0xBF);
9139   emit_operand(dst, src);
9140 }
9141 
9142 void Assembler::movswq(Register dst, Register src) {
9143   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9144   emit_int8((unsigned char)0x0F);
9145   emit_int8((unsigned char)0xBF);
9146   emit_int8((unsigned char)(0xC0 | encode));
9147 }
9148 
9149 void Assembler::movzbq(Register dst, Address src) {
9150   InstructionMark im(this);
9151   prefixq(src, dst);
9152   emit_int8((unsigned char)0x0F);
9153   emit_int8((unsigned char)0xB6);
9154   emit_operand(dst, src);
9155 }
9156 
9157 void Assembler::movzbq(Register dst, Register src) {
9158   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9159   emit_int8(0x0F);
9160   emit_int8((unsigned char)0xB6);
9161   emit_int8(0xC0 | encode);
9162 }
9163 
9164 void Assembler::movzwq(Register dst, Address src) {
9165   InstructionMark im(this);
9166   prefixq(src, dst);
9167   emit_int8((unsigned char)0x0F);
9168   emit_int8((unsigned char)0xB7);
9169   emit_operand(dst, src);
9170 }
9171 
9172 void Assembler::movzwq(Register dst, Register src) {
9173   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9174   emit_int8((unsigned char)0x0F);
9175   emit_int8((unsigned char)0xB7);
9176   emit_int8((unsigned char)(0xC0 | encode));
9177 }
9178 
9179 void Assembler::mulq(Address src) {
9180   InstructionMark im(this);
9181   prefixq(src);
9182   emit_int8((unsigned char)0xF7);
9183   emit_operand(rsp, src);
9184 }
9185 
9186 void Assembler::mulq(Register src) {
9187   int encode = prefixq_and_encode(src-&gt;encoding());
9188   emit_int8((unsigned char)0xF7);
9189   emit_int8((unsigned char)(0xE0 | encode));
9190 }
9191 
9192 void Assembler::mulxq(Register dst1, Register dst2, Register src) {
9193   assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
9194   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
9195   int encode = vex_prefix_and_encode(dst1-&gt;encoding(), dst2-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &amp;attributes);
9196   emit_int8((unsigned char)0xF6);
9197   emit_int8((unsigned char)(0xC0 | encode));
9198 }
9199 
9200 void Assembler::negq(Register dst) {
9201   int encode = prefixq_and_encode(dst-&gt;encoding());
9202   emit_int8((unsigned char)0xF7);
9203   emit_int8((unsigned char)(0xD8 | encode));
9204 }
9205 
9206 void Assembler::notq(Register dst) {
9207   int encode = prefixq_and_encode(dst-&gt;encoding());
9208   emit_int8((unsigned char)0xF7);
9209   emit_int8((unsigned char)(0xD0 | encode));
9210 }
9211 
9212 void Assembler::btsq(Address dst, int imm8) {
9213   assert(isByte(imm8), &quot;not a byte&quot;);
9214   InstructionMark im(this);
9215   prefixq(dst);
9216   emit_int8((unsigned char)0x0F);
9217   emit_int8((unsigned char)0xBA);
9218   emit_operand(rbp /* 5 */, dst, 1);
9219   emit_int8(imm8);
9220 }
9221 
9222 void Assembler::btrq(Address dst, int imm8) {
9223   assert(isByte(imm8), &quot;not a byte&quot;);
9224   InstructionMark im(this);
9225   prefixq(dst);
9226   emit_int8((unsigned char)0x0F);
9227   emit_int8((unsigned char)0xBA);
9228   emit_operand(rsi /* 6 */, dst, 1);
9229   emit_int8(imm8);
9230 }
9231 
9232 void Assembler::orq(Address dst, int32_t imm32) {
9233   InstructionMark im(this);
9234   prefixq(dst);
9235   emit_int8((unsigned char)0x81);
9236   emit_operand(rcx, dst, 4);
9237   emit_int32(imm32);
9238 }
9239 
9240 void Assembler::orq(Register dst, int32_t imm32) {
9241   (void) prefixq_and_encode(dst-&gt;encoding());
9242   emit_arith(0x81, 0xC8, dst, imm32);
9243 }
9244 
9245 void Assembler::orq(Register dst, Address src) {
9246   InstructionMark im(this);
9247   prefixq(src, dst);
9248   emit_int8(0x0B);
9249   emit_operand(dst, src);
9250 }
9251 
9252 void Assembler::orq(Register dst, Register src) {
9253   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9254   emit_arith(0x0B, 0xC0, dst, src);
9255 }
9256 
9257 void Assembler::popcntq(Register dst, Address src) {
9258   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
9259   InstructionMark im(this);
9260   emit_int8((unsigned char)0xF3);
9261   prefixq(src, dst);
9262   emit_int8((unsigned char)0x0F);
9263   emit_int8((unsigned char)0xB8);
9264   emit_operand(dst, src);
9265 }
9266 
9267 void Assembler::popcntq(Register dst, Register src) {
9268   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
9269   emit_int8((unsigned char)0xF3);
9270   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9271   emit_int8((unsigned char)0x0F);
9272   emit_int8((unsigned char)0xB8);
9273   emit_int8((unsigned char)(0xC0 | encode));
9274 }
9275 
9276 void Assembler::popq(Address dst) {
9277   InstructionMark im(this);
9278   prefixq(dst);
9279   emit_int8((unsigned char)0x8F);
9280   emit_operand(rax, dst);
9281 }
9282 
9283 // Precomputable: popa, pusha, vzeroupper
9284 
9285 // The result of these routines are invariant from one invocation to another
9286 // invocation for the duration of a run. Caching the result on bootstrap
9287 // and copying it out on subsequent invocations can thus be beneficial
9288 static bool     precomputed = false;
9289 
9290 static u_char* popa_code  = NULL;
9291 static int     popa_len   = 0;
9292 
9293 static u_char* pusha_code = NULL;
9294 static int     pusha_len  = 0;
9295 
9296 static u_char* vzup_code  = NULL;
9297 static int     vzup_len   = 0;
9298 
9299 void Assembler::precompute_instructions() {
9300   assert(!Universe::is_fully_initialized(), &quot;must still be single threaded&quot;);
9301   guarantee(!precomputed, &quot;only once&quot;);
9302   precomputed = true;
9303   ResourceMark rm;
9304 
9305   // Make a temporary buffer big enough for the routines we&#39;re capturing
9306   int size = 256;
9307   char* tmp_code = NEW_RESOURCE_ARRAY(char, size);
9308   CodeBuffer buffer((address)tmp_code, size);
9309   MacroAssembler masm(&amp;buffer);
9310 
9311   address begin_popa  = masm.code_section()-&gt;end();
9312   masm.popa_uncached();
9313   address end_popa    = masm.code_section()-&gt;end();
9314   masm.pusha_uncached();
9315   address end_pusha   = masm.code_section()-&gt;end();
9316   masm.vzeroupper_uncached();
9317   address end_vzup    = masm.code_section()-&gt;end();
9318 
9319   // Save the instructions to permanent buffers.
9320   popa_len = (int)(end_popa - begin_popa);
9321   popa_code = NEW_C_HEAP_ARRAY(u_char, popa_len, mtInternal);
9322   memcpy(popa_code, begin_popa, popa_len);
9323 
9324   pusha_len = (int)(end_pusha - end_popa);
9325   pusha_code = NEW_C_HEAP_ARRAY(u_char, pusha_len, mtInternal);
9326   memcpy(pusha_code, end_popa, pusha_len);
9327 
9328   vzup_len = (int)(end_vzup - end_pusha);
9329   if (vzup_len &gt; 0) {
9330     vzup_code = NEW_C_HEAP_ARRAY(u_char, vzup_len, mtInternal);
9331     memcpy(vzup_code, end_pusha, vzup_len);
9332   } else {
9333     vzup_code = pusha_code; // dummy
9334   }
9335 
9336   assert(masm.code()-&gt;total_oop_size() == 0 &amp;&amp;
9337          masm.code()-&gt;total_metadata_size() == 0 &amp;&amp;
9338          masm.code()-&gt;total_relocation_size() == 0,
9339          &quot;pre-computed code can&#39;t reference oops, metadata or contain relocations&quot;);
9340 }
9341 
9342 static void emit_copy(CodeSection* code_section, u_char* src, int src_len) {
9343   assert(src != NULL, &quot;code to copy must have been pre-computed&quot;);
9344   assert(code_section-&gt;limit() - code_section-&gt;end() &gt; src_len, &quot;code buffer not large enough&quot;);
9345   address end = code_section-&gt;end();
9346   memcpy(end, src, src_len);
9347   code_section-&gt;set_end(end + src_len);
9348 }
9349 
9350 void Assembler::popa() { // 64bit
9351   emit_copy(code_section(), popa_code, popa_len);
9352 }
9353 
9354 void Assembler::popa_uncached() { // 64bit
9355   movq(r15, Address(rsp, 0));
9356   movq(r14, Address(rsp, wordSize));
9357   movq(r13, Address(rsp, 2 * wordSize));
9358   movq(r12, Address(rsp, 3 * wordSize));
9359   movq(r11, Address(rsp, 4 * wordSize));
9360   movq(r10, Address(rsp, 5 * wordSize));
9361   movq(r9,  Address(rsp, 6 * wordSize));
9362   movq(r8,  Address(rsp, 7 * wordSize));
9363   movq(rdi, Address(rsp, 8 * wordSize));
9364   movq(rsi, Address(rsp, 9 * wordSize));
9365   movq(rbp, Address(rsp, 10 * wordSize));
9366   // skip rsp
9367   movq(rbx, Address(rsp, 12 * wordSize));
9368   movq(rdx, Address(rsp, 13 * wordSize));
9369   movq(rcx, Address(rsp, 14 * wordSize));
9370   movq(rax, Address(rsp, 15 * wordSize));
9371 
9372   addq(rsp, 16 * wordSize);
9373 }
9374 
9375 void Assembler::pusha() { // 64bit
9376   emit_copy(code_section(), pusha_code, pusha_len);
9377 }
9378 
9379 void Assembler::pusha_uncached() { // 64bit
9380   // we have to store original rsp.  ABI says that 128 bytes
9381   // below rsp are local scratch.
9382   movq(Address(rsp, -5 * wordSize), rsp);
9383 
9384   subq(rsp, 16 * wordSize);
9385 
9386   movq(Address(rsp, 15 * wordSize), rax);
9387   movq(Address(rsp, 14 * wordSize), rcx);
9388   movq(Address(rsp, 13 * wordSize), rdx);
9389   movq(Address(rsp, 12 * wordSize), rbx);
9390   // skip rsp
9391   movq(Address(rsp, 10 * wordSize), rbp);
9392   movq(Address(rsp, 9 * wordSize), rsi);
9393   movq(Address(rsp, 8 * wordSize), rdi);
9394   movq(Address(rsp, 7 * wordSize), r8);
9395   movq(Address(rsp, 6 * wordSize), r9);
9396   movq(Address(rsp, 5 * wordSize), r10);
9397   movq(Address(rsp, 4 * wordSize), r11);
9398   movq(Address(rsp, 3 * wordSize), r12);
9399   movq(Address(rsp, 2 * wordSize), r13);
9400   movq(Address(rsp, wordSize), r14);
9401   movq(Address(rsp, 0), r15);
9402 }
9403 
9404 void Assembler::vzeroupper() {
9405   emit_copy(code_section(), vzup_code, vzup_len);
9406 }
9407 
9408 void Assembler::pushq(Address src) {
9409   InstructionMark im(this);
9410   prefixq(src);
9411   emit_int8((unsigned char)0xFF);
9412   emit_operand(rsi, src);
9413 }
9414 
9415 void Assembler::rclq(Register dst, int imm8) {
9416   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
9417   int encode = prefixq_and_encode(dst-&gt;encoding());
9418   if (imm8 == 1) {
9419     emit_int8((unsigned char)0xD1);
9420     emit_int8((unsigned char)(0xD0 | encode));
9421   } else {
9422     emit_int8((unsigned char)0xC1);
9423     emit_int8((unsigned char)(0xD0 | encode));
9424     emit_int8(imm8);
9425   }
9426 }
9427 
9428 void Assembler::rcrq(Register dst, int imm8) {
9429   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
9430   int encode = prefixq_and_encode(dst-&gt;encoding());
9431   if (imm8 == 1) {
9432     emit_int8((unsigned char)0xD1);
9433     emit_int8((unsigned char)(0xD8 | encode));
9434   } else {
9435     emit_int8((unsigned char)0xC1);
9436     emit_int8((unsigned char)(0xD8 | encode));
9437     emit_int8(imm8);
9438   }
9439 }
9440 
9441 void Assembler::rorq(Register dst, int imm8) {
9442   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
9443   int encode = prefixq_and_encode(dst-&gt;encoding());
9444   if (imm8 == 1) {
9445     emit_int8((unsigned char)0xD1);
9446     emit_int8((unsigned char)(0xC8 | encode));
9447   } else {
9448     emit_int8((unsigned char)0xC1);
9449     emit_int8((unsigned char)(0xc8 | encode));
9450     emit_int8(imm8);
9451   }
9452 }
9453 
9454 void Assembler::rorxq(Register dst, Register src, int imm8) {
9455   assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
9456   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
9457   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &amp;attributes);
9458   emit_int8((unsigned char)0xF0);
9459   emit_int8((unsigned char)(0xC0 | encode));
9460   emit_int8(imm8);
9461 }
9462 
9463 void Assembler::rorxd(Register dst, Register src, int imm8) {
9464   assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
9465   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
9466   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &amp;attributes);
9467   emit_int8((unsigned char)0xF0);
9468   emit_int8((unsigned char)(0xC0 | encode));
9469   emit_int8(imm8);
9470 }
9471 
9472 void Assembler::sarq(Register dst, int imm8) {
9473   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
9474   int encode = prefixq_and_encode(dst-&gt;encoding());
9475   if (imm8 == 1) {
9476     emit_int8((unsigned char)0xD1);
9477     emit_int8((unsigned char)(0xF8 | encode));
9478   } else {
9479     emit_int8((unsigned char)0xC1);
9480     emit_int8((unsigned char)(0xF8 | encode));
9481     emit_int8(imm8);
9482   }
9483 }
9484 
9485 void Assembler::sarq(Register dst) {
9486   int encode = prefixq_and_encode(dst-&gt;encoding());
9487   emit_int8((unsigned char)0xD3);
9488   emit_int8((unsigned char)(0xF8 | encode));
9489 }
9490 
9491 void Assembler::sbbq(Address dst, int32_t imm32) {
9492   InstructionMark im(this);
9493   prefixq(dst);
9494   emit_arith_operand(0x81, rbx, dst, imm32);
9495 }
9496 
9497 void Assembler::sbbq(Register dst, int32_t imm32) {
9498   (void) prefixq_and_encode(dst-&gt;encoding());
9499   emit_arith(0x81, 0xD8, dst, imm32);
9500 }
9501 
9502 void Assembler::sbbq(Register dst, Address src) {
9503   InstructionMark im(this);
9504   prefixq(src, dst);
9505   emit_int8(0x1B);
9506   emit_operand(dst, src);
9507 }
9508 
9509 void Assembler::sbbq(Register dst, Register src) {
9510   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9511   emit_arith(0x1B, 0xC0, dst, src);
9512 }
9513 
9514 void Assembler::shlq(Register dst, int imm8) {
9515   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
9516   int encode = prefixq_and_encode(dst-&gt;encoding());
9517   if (imm8 == 1) {
9518     emit_int8((unsigned char)0xD1);
9519     emit_int8((unsigned char)(0xE0 | encode));
9520   } else {
9521     emit_int8((unsigned char)0xC1);
9522     emit_int8((unsigned char)(0xE0 | encode));
9523     emit_int8(imm8);
9524   }
9525 }
9526 
9527 void Assembler::shlq(Register dst) {
9528   int encode = prefixq_and_encode(dst-&gt;encoding());
9529   emit_int8((unsigned char)0xD3);
9530   emit_int8((unsigned char)(0xE0 | encode));
9531 }
9532 
9533 void Assembler::shrq(Register dst, int imm8) {
9534   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
9535   int encode = prefixq_and_encode(dst-&gt;encoding());
9536   emit_int8((unsigned char)0xC1);
9537   emit_int8((unsigned char)(0xE8 | encode));
9538   emit_int8(imm8);
9539 }
9540 
9541 void Assembler::shrq(Register dst) {
9542   int encode = prefixq_and_encode(dst-&gt;encoding());
9543   emit_int8((unsigned char)0xD3);
9544   emit_int8(0xE8 | encode);
9545 }
9546 
9547 void Assembler::subq(Address dst, int32_t imm32) {
9548   InstructionMark im(this);
9549   prefixq(dst);
9550   emit_arith_operand(0x81, rbp, dst, imm32);
9551 }
9552 
9553 void Assembler::subq(Address dst, Register src) {
9554   InstructionMark im(this);
9555   prefixq(dst, src);
9556   emit_int8(0x29);
9557   emit_operand(src, dst);
9558 }
9559 
9560 void Assembler::subq(Register dst, int32_t imm32) {
9561   (void) prefixq_and_encode(dst-&gt;encoding());
9562   emit_arith(0x81, 0xE8, dst, imm32);
9563 }
9564 
9565 // Force generation of a 4 byte immediate value even if it fits into 8bit
9566 void Assembler::subq_imm32(Register dst, int32_t imm32) {
9567   (void) prefixq_and_encode(dst-&gt;encoding());
9568   emit_arith_imm32(0x81, 0xE8, dst, imm32);
9569 }
9570 
9571 void Assembler::subq(Register dst, Address src) {
9572   InstructionMark im(this);
9573   prefixq(src, dst);
9574   emit_int8(0x2B);
9575   emit_operand(dst, src);
9576 }
9577 
9578 void Assembler::subq(Register dst, Register src) {
9579   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9580   emit_arith(0x2B, 0xC0, dst, src);
9581 }
9582 
9583 void Assembler::testq(Register dst, int32_t imm32) {
9584   // not using emit_arith because test
9585   // doesn&#39;t support sign-extension of
9586   // 8bit operands
9587   int encode = dst-&gt;encoding();
9588   if (encode == 0) {
9589     prefix(REX_W);
9590     emit_int8((unsigned char)0xA9);
9591   } else {
9592     encode = prefixq_and_encode(encode);
9593     emit_int8((unsigned char)0xF7);
9594     emit_int8((unsigned char)(0xC0 | encode));
9595   }
9596   emit_int32(imm32);
9597 }
9598 
9599 void Assembler::testq(Register dst, Register src) {
9600   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9601   emit_arith(0x85, 0xC0, dst, src);
9602 }
9603 
9604 void Assembler::testq(Register dst, Address src) {
9605   InstructionMark im(this);
9606   prefixq(src, dst);
9607   emit_int8((unsigned char)0x85);
9608   emit_operand(dst, src);
9609 }
9610 
9611 void Assembler::xaddq(Address dst, Register src) {
9612   InstructionMark im(this);
9613   prefixq(dst, src);
9614   emit_int8(0x0F);
9615   emit_int8((unsigned char)0xC1);
9616   emit_operand(src, dst);
9617 }
9618 
9619 void Assembler::xchgq(Register dst, Address src) {
9620   InstructionMark im(this);
9621   prefixq(src, dst);
9622   emit_int8((unsigned char)0x87);
9623   emit_operand(dst, src);
9624 }
9625 
9626 void Assembler::xchgq(Register dst, Register src) {
9627   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9628   emit_int8((unsigned char)0x87);
9629   emit_int8((unsigned char)(0xc0 | encode));
9630 }
9631 
9632 void Assembler::xorq(Register dst, Register src) {
9633   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9634   emit_arith(0x33, 0xC0, dst, src);
9635 }
9636 
9637 void Assembler::xorq(Register dst, Address src) {
9638   InstructionMark im(this);
9639   prefixq(src, dst);
9640   emit_int8(0x33);
9641   emit_operand(dst, src);
9642 }
9643 
9644 #endif // !LP64
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangInvokeAccess;
  29 import jdk.internal.access.SharedSecrets;
  30 import jdk.internal.org.objectweb.asm.AnnotationVisitor;
  31 import jdk.internal.org.objectweb.asm.ClassWriter;
  32 import jdk.internal.org.objectweb.asm.MethodVisitor;
  33 import jdk.internal.reflect.CallerSensitive;
  34 import jdk.internal.reflect.Reflection;
  35 import jdk.internal.vm.annotation.ForceInline;
  36 import jdk.internal.vm.annotation.Hidden;
  37 import jdk.internal.vm.annotation.Stable;
  38 import sun.invoke.empty.Empty;
  39 import sun.invoke.util.ValueConversions;
  40 import sun.invoke.util.VerifyType;
  41 import sun.invoke.util.Wrapper;
  42 
  43 import java.lang.reflect.Array;
  44 import java.nio.ByteOrder;
  45 import java.util.Arrays;
  46 import java.util.Collections;
  47 import java.util.HashMap;
  48 import java.util.Iterator;
  49 import java.util.List;
  50 import java.util.Map;
  51 import java.util.function.Function;
  52 import java.util.stream.Stream;
  53 
  54 import static java.lang.invoke.LambdaForm.*;
  55 import static java.lang.invoke.MethodHandleStatics.*;
  56 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
  57 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  58 
  59 /**
  60  * Trusted implementation code for MethodHandle.
  61  * @author jrose
  62  */
  63 /*non-public*/
  64 abstract class MethodHandleImpl {
  65 
  66     /// Factory methods to create method handles:
  67 
  68     static MethodHandle makeArrayElementAccessor(Class&lt;?&gt; arrayClass, ArrayAccess access) {
  69         if (arrayClass == Object[].class) {
  70             return ArrayAccess.objectAccessor(access);
  71         }
  72         if (!arrayClass.isArray())
  73             throw newIllegalArgumentException(&quot;not an array: &quot;+arrayClass);
  74         MethodHandle[] cache = ArrayAccessor.TYPED_ACCESSORS.get(arrayClass);
  75         int cacheIndex = ArrayAccess.cacheIndex(access);
  76         MethodHandle mh = cache[cacheIndex];
  77         if (mh != null)  return mh;
  78         mh = ArrayAccessor.getAccessor(arrayClass, access);
  79         MethodType correctType = ArrayAccessor.correctType(arrayClass, access);
  80         if (mh.type() != correctType) {
  81             assert(mh.type().parameterType(0) == Object[].class);
  82             /* if access == SET */ assert(access != ArrayAccess.SET || mh.type().parameterType(2) == Object.class);
  83             /* if access == GET */ assert(access != ArrayAccess.GET ||
  84                     (mh.type().returnType() == Object.class &amp;&amp;
  85                      correctType.parameterType(0).getComponentType() == correctType.returnType()));
  86             // safe to view non-strictly, because element type follows from array type
  87             mh = mh.viewAsType(correctType, false);
  88         }
  89         mh = makeIntrinsic(mh, ArrayAccess.intrinsic(access));
  90         // Atomically update accessor cache.
  91         synchronized(cache) {
  92             if (cache[cacheIndex] == null) {
  93                 cache[cacheIndex] = mh;
  94             } else {
  95                 // Throw away newly constructed accessor and use cached version.
  96                 mh = cache[cacheIndex];
  97             }
  98         }
  99         return mh;
 100     }
 101 
 102     enum ArrayAccess {
 103         GET, SET, LENGTH;
 104 
 105         // As ArrayAccess and ArrayAccessor have a circular dependency, the ArrayAccess properties cannot be stored in
 106         // final fields.
 107 
 108         static String opName(ArrayAccess a) {
 109             switch (a) {
 110                 case GET: return &quot;getElement&quot;;
 111                 case SET: return &quot;setElement&quot;;
 112                 case LENGTH: return &quot;length&quot;;
 113             }
 114             throw unmatchedArrayAccess(a);
 115         }
 116 
 117         static MethodHandle objectAccessor(ArrayAccess a) {
 118             switch (a) {
 119                 case GET: return ArrayAccessor.OBJECT_ARRAY_GETTER;
 120                 case SET: return ArrayAccessor.OBJECT_ARRAY_SETTER;
 121                 case LENGTH: return ArrayAccessor.OBJECT_ARRAY_LENGTH;
 122             }
 123             throw unmatchedArrayAccess(a);
 124         }
 125 
 126         static int cacheIndex(ArrayAccess a) {
 127             switch (a) {
 128                 case GET: return ArrayAccessor.GETTER_INDEX;
 129                 case SET: return ArrayAccessor.SETTER_INDEX;
 130                 case LENGTH: return ArrayAccessor.LENGTH_INDEX;
 131             }
 132             throw unmatchedArrayAccess(a);
 133         }
 134 
 135         static Intrinsic intrinsic(ArrayAccess a) {
 136             switch (a) {
 137                 case GET: return Intrinsic.ARRAY_LOAD;
 138                 case SET: return Intrinsic.ARRAY_STORE;
 139                 case LENGTH: return Intrinsic.ARRAY_LENGTH;
 140             }
 141             throw unmatchedArrayAccess(a);
 142         }
 143     }
 144 
 145     static InternalError unmatchedArrayAccess(ArrayAccess a) {
 146         return newInternalError(&quot;should not reach here (unmatched ArrayAccess: &quot; + a + &quot;)&quot;);
 147     }
 148 
 149     static final class ArrayAccessor {
 150         /// Support for array element and length access
 151         static final int GETTER_INDEX = 0, SETTER_INDEX = 1, LENGTH_INDEX = 2, INDEX_LIMIT = 3;
 152         static final ClassValue&lt;MethodHandle[]&gt; TYPED_ACCESSORS
 153                 = new ClassValue&lt;MethodHandle[]&gt;() {
 154                     @Override
 155                     protected MethodHandle[] computeValue(Class&lt;?&gt; type) {
 156                         return new MethodHandle[INDEX_LIMIT];
 157                     }
 158                 };
 159         static final MethodHandle OBJECT_ARRAY_GETTER, OBJECT_ARRAY_SETTER, OBJECT_ARRAY_LENGTH;
 160         static {
 161             MethodHandle[] cache = TYPED_ACCESSORS.get(Object[].class);
 162             cache[GETTER_INDEX] = OBJECT_ARRAY_GETTER = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.GET),    Intrinsic.ARRAY_LOAD);
 163             cache[SETTER_INDEX] = OBJECT_ARRAY_SETTER = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.SET),    Intrinsic.ARRAY_STORE);
 164             cache[LENGTH_INDEX] = OBJECT_ARRAY_LENGTH = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.LENGTH), Intrinsic.ARRAY_LENGTH);
 165 
 166             assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_GETTER.internalMemberName()));
 167             assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_SETTER.internalMemberName()));
 168             assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_LENGTH.internalMemberName()));
 169         }
 170 
 171         static int     getElementI(int[]     a, int i)            { return              a[i]; }
 172         static long    getElementJ(long[]    a, int i)            { return              a[i]; }
 173         static float   getElementF(float[]   a, int i)            { return              a[i]; }
 174         static double  getElementD(double[]  a, int i)            { return              a[i]; }
 175         static boolean getElementZ(boolean[] a, int i)            { return              a[i]; }
 176         static byte    getElementB(byte[]    a, int i)            { return              a[i]; }
 177         static short   getElementS(short[]   a, int i)            { return              a[i]; }
 178         static char    getElementC(char[]    a, int i)            { return              a[i]; }
 179         static Object  getElementL(Object[]  a, int i)            { return              a[i]; }
 180 
 181         static void    setElementI(int[]     a, int i, int     x) {              a[i] = x; }
 182         static void    setElementJ(long[]    a, int i, long    x) {              a[i] = x; }
 183         static void    setElementF(float[]   a, int i, float   x) {              a[i] = x; }
 184         static void    setElementD(double[]  a, int i, double  x) {              a[i] = x; }
 185         static void    setElementZ(boolean[] a, int i, boolean x) {              a[i] = x; }
 186         static void    setElementB(byte[]    a, int i, byte    x) {              a[i] = x; }
 187         static void    setElementS(short[]   a, int i, short   x) {              a[i] = x; }
 188         static void    setElementC(char[]    a, int i, char    x) {              a[i] = x; }
 189         static void    setElementL(Object[]  a, int i, Object  x) {              a[i] = x; }
 190 
 191         static int     lengthI(int[]     a)                       { return a.length; }
 192         static int     lengthJ(long[]    a)                       { return a.length; }
 193         static int     lengthF(float[]   a)                       { return a.length; }
 194         static int     lengthD(double[]  a)                       { return a.length; }
 195         static int     lengthZ(boolean[] a)                       { return a.length; }
 196         static int     lengthB(byte[]    a)                       { return a.length; }
 197         static int     lengthS(short[]   a)                       { return a.length; }
 198         static int     lengthC(char[]    a)                       { return a.length; }
 199         static int     lengthL(Object[]  a)                       { return a.length; }
 200 
 201         static String name(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 202             Class&lt;?&gt; elemClass = arrayClass.getComponentType();
 203             if (elemClass == null)  throw newIllegalArgumentException(&quot;not an array&quot;, arrayClass);
 204             return ArrayAccess.opName(access) + Wrapper.basicTypeChar(elemClass);
 205         }
 206         static MethodType type(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 207             Class&lt;?&gt; elemClass = arrayClass.getComponentType();
 208             Class&lt;?&gt; arrayArgClass = arrayClass;
 209             if (!elemClass.isPrimitive()) {
 210                 arrayArgClass = Object[].class;
 211                 elemClass = Object.class;
 212             }
 213             switch (access) {
 214                 case GET:    return MethodType.methodType(elemClass,  arrayArgClass, int.class);
 215                 case SET:    return MethodType.methodType(void.class, arrayArgClass, int.class, elemClass);
 216                 case LENGTH: return MethodType.methodType(int.class,  arrayArgClass);
 217             }
 218             throw unmatchedArrayAccess(access);
 219         }
 220         static MethodType correctType(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 221             Class&lt;?&gt; elemClass = arrayClass.getComponentType();
 222             switch (access) {
 223                 case GET:    return MethodType.methodType(elemClass,  arrayClass, int.class);
 224                 case SET:    return MethodType.methodType(void.class, arrayClass, int.class, elemClass);
 225                 case LENGTH: return MethodType.methodType(int.class,  arrayClass);
 226             }
 227             throw unmatchedArrayAccess(access);
 228         }
 229         static MethodHandle getAccessor(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 230             String     name = name(arrayClass, access);
 231             MethodType type = type(arrayClass, access);
 232             try {
 233                 return IMPL_LOOKUP.findStatic(ArrayAccessor.class, name, type);
 234             } catch (ReflectiveOperationException ex) {
 235                 throw uncaughtException(ex);
 236             }
 237         }
 238     }
 239 
 240     /**
 241      * Create a JVM-level adapter method handle to conform the given method
 242      * handle to the similar newType, using only pairwise argument conversions.
 243      * For each argument, convert incoming argument to the exact type needed.
 244      * The argument conversions allowed are casting, boxing and unboxing,
 245      * integral widening or narrowing, and floating point widening or narrowing.
 246      * @param srcType required call type
 247      * @param target original method handle
 248      * @param strict if true, only asType conversions are allowed; if false, explicitCastArguments conversions allowed
 249      * @param monobox if true, unboxing conversions are assumed to be exactly typed (Integer to int only, not long or double)
 250      * @return an adapter to the original handle with the desired new type,
 251      *          or the original target if the types are already identical
 252      *          or null if the adaptation cannot be made
 253      */
 254     static MethodHandle makePairwiseConvert(MethodHandle target, MethodType srcType,
 255                                             boolean strict, boolean monobox) {
 256         MethodType dstType = target.type();
 257         if (srcType == dstType)
 258             return target;
 259         return makePairwiseConvertByEditor(target, srcType, strict, monobox);
 260     }
 261 
 262     private static int countNonNull(Object[] array) {
 263         int count = 0;
 264         if (array != null) {
 265             for (Object x : array) {
 266                 if (x != null) ++count;
 267             }
 268         }
 269         return count;
 270     }
 271 
 272     static MethodHandle makePairwiseConvertByEditor(MethodHandle target, MethodType srcType,
 273                                                     boolean strict, boolean monobox) {
 274         // In method types arguments start at index 0, while the LF
 275         // editor have the MH receiver at position 0 - adjust appropriately.
 276         final int MH_RECEIVER_OFFSET = 1;
 277         Object[] convSpecs = computeValueConversions(srcType, target.type(), strict, monobox);
 278         int convCount = countNonNull(convSpecs);
 279         if (convCount == 0)
 280             return target.viewAsType(srcType, strict);
 281         MethodType basicSrcType = srcType.basicType();
 282         MethodType midType = target.type().basicType();
 283         BoundMethodHandle mh = target.rebind();
 284 
 285         // Match each unique conversion to the positions at which it is to be applied
 286         var convSpecMap = new HashMap&lt;Object, int[]&gt;(((4 * convCount) / 3) + 1);
 287         for (int i = 0; i &lt; convSpecs.length - MH_RECEIVER_OFFSET; i++) {
 288             Object convSpec = convSpecs[i];
 289             if (convSpec == null) continue;
 290             int[] positions = convSpecMap.get(convSpec);
 291             if (positions == null) {
 292                 positions = new int[] { i + MH_RECEIVER_OFFSET };
 293             } else {
 294                 positions = Arrays.copyOf(positions, positions.length + 1);
 295                 positions[positions.length - 1] = i + MH_RECEIVER_OFFSET;
 296             }
 297             convSpecMap.put(convSpec, positions);
 298         }
 299         for (var entry : convSpecMap.entrySet()) {
 300             Object convSpec = entry.getKey();
 301 
 302             MethodHandle fn;
 303             if (convSpec instanceof Class) {
 304                 fn = getConstantHandle(MH_cast).bindTo(convSpec);
 305             } else {
 306                 fn = (MethodHandle) convSpec;
 307             }
 308             int[] positions = entry.getValue();
 309             Class&lt;?&gt; newType = basicSrcType.parameterType(positions[0] - MH_RECEIVER_OFFSET);
 310             BasicType newBasicType = BasicType.basicType(newType);
 311             convCount -= positions.length;
 312             if (convCount == 0) {
 313                 midType = srcType;
 314             } else {
 315                 Class&lt;?&gt;[] ptypes = midType.ptypes().clone();
 316                 for (int pos : positions) {
 317                     ptypes[pos - 1] = newType;
 318                 }
 319                 midType = MethodType.makeImpl(midType.rtype(), ptypes, true);
 320             }
 321             LambdaForm form2;
 322             if (positions.length &gt; 1) {
 323                 form2 = mh.editor().filterRepeatedArgumentForm(newBasicType, positions);
 324             } else {
 325                 form2 = mh.editor().filterArgumentForm(positions[0], newBasicType);
 326             }
 327             mh = mh.copyWithExtendL(midType, form2, fn);
 328         }
 329         Object convSpec = convSpecs[convSpecs.length - 1];
 330         if (convSpec != null) {
 331             MethodHandle fn;
 332             if (convSpec instanceof Class) {
 333                 if (convSpec == void.class)
 334                     fn = null;
 335                 else
 336                     fn = getConstantHandle(MH_cast).bindTo(convSpec);
 337             } else {
 338                 fn = (MethodHandle) convSpec;
 339             }
 340             Class&lt;?&gt; newType = basicSrcType.returnType();
 341             assert(--convCount == 0);
 342             midType = srcType;
 343             if (fn != null) {
 344                 mh = mh.rebind();  // rebind if too complex
 345                 LambdaForm form2 = mh.editor().filterReturnForm(BasicType.basicType(newType), false);
 346                 mh = mh.copyWithExtendL(midType, form2, fn);
 347             } else {
 348                 LambdaForm form2 = mh.editor().filterReturnForm(BasicType.basicType(newType), true);
 349                 mh = mh.copyWith(midType, form2);
 350             }
 351         }
 352         assert(convCount == 0);
 353         assert(mh.type().equals(srcType));
 354         return mh;
 355     }
 356 
 357     static Object[] computeValueConversions(MethodType srcType, MethodType dstType,
 358                                             boolean strict, boolean monobox) {
 359         final int INARG_COUNT = srcType.parameterCount();
 360         Object[] convSpecs = null;
 361         for (int i = 0; i &lt;= INARG_COUNT; i++) {
 362             boolean isRet = (i == INARG_COUNT);
 363             Class&lt;?&gt; src = isRet ? dstType.returnType() : srcType.parameterType(i);
 364             Class&lt;?&gt; dst = isRet ? srcType.returnType() : dstType.parameterType(i);
 365             if (!VerifyType.isNullConversion(src, dst, /*keepInterfaces=*/ strict)) {
 366                 if (convSpecs == null) {
 367                     convSpecs = new Object[INARG_COUNT + 1];
 368                 }
 369                 convSpecs[i] = valueConversion(src, dst, strict, monobox);
 370             }
 371         }
 372         return convSpecs;
 373     }
 374     static MethodHandle makePairwiseConvert(MethodHandle target, MethodType srcType,
 375                                             boolean strict) {
 376         return makePairwiseConvert(target, srcType, strict, /*monobox=*/ false);
 377     }
 378 
 379     /**
 380      * Find a conversion function from the given source to the given destination.
 381      * This conversion function will be used as a LF NamedFunction.
 382      * Return a Class object if a simple cast is needed.
 383      * Return void.class if void is involved.
 384      */
 385     static Object valueConversion(Class&lt;?&gt; src, Class&lt;?&gt; dst, boolean strict, boolean monobox) {
 386         assert(!VerifyType.isNullConversion(src, dst, /*keepInterfaces=*/ strict));  // caller responsibility
 387         if (dst == void.class)
 388             return dst;
 389         MethodHandle fn;
 390         if (src.isPrimitive()) {
 391             if (src == void.class) {
 392                 return void.class;  // caller must recognize this specially
 393             } else if (dst.isPrimitive()) {
 394                 // Examples: int-&gt;byte, byte-&gt;int, boolean-&gt;int (!strict)
 395                 fn = ValueConversions.convertPrimitive(src, dst);
 396             } else {
 397                 // Examples: int-&gt;Integer, boolean-&gt;Object, float-&gt;Number
 398                 Wrapper wsrc = Wrapper.forPrimitiveType(src);
 399                 fn = ValueConversions.boxExact(wsrc);
 400                 assert(fn.type().parameterType(0) == wsrc.primitiveType());
 401                 assert(fn.type().returnType() == wsrc.wrapperType());
 402                 if (!VerifyType.isNullConversion(wsrc.wrapperType(), dst, strict)) {
 403                     // Corner case, such as int-&gt;Long, which will probably fail.
 404                     MethodType mt = MethodType.methodType(dst, src);
 405                     if (strict)
 406                         fn = fn.asType(mt);
 407                     else
 408                         fn = MethodHandleImpl.makePairwiseConvert(fn, mt, /*strict=*/ false);
 409                 }
 410             }
 411         } else if (dst.isPrimitive()) {
 412             Wrapper wdst = Wrapper.forPrimitiveType(dst);
 413             if (monobox || src == wdst.wrapperType()) {
 414                 // Use a strongly-typed unboxer, if possible.
 415                 fn = ValueConversions.unboxExact(wdst, strict);
 416             } else {
 417                 // Examples:  Object-&gt;int, Number-&gt;int, Comparable-&gt;int, Byte-&gt;int
 418                 // must include additional conversions
 419                 // src must be examined at runtime, to detect Byte, Character, etc.
 420                 fn = (strict
 421                         ? ValueConversions.unboxWiden(wdst)
 422                         : ValueConversions.unboxCast(wdst));
 423             }
 424         } else {
 425             // Simple reference conversion.
 426             // Note:  Do not check for a class hierarchy relation
 427             // between src and dst.  In all cases a &#39;null&#39; argument
 428             // will pass the cast conversion.
 429             return dst;
 430         }
 431         assert(fn.type().parameterCount() &lt;= 1) : &quot;pc&quot;+Arrays.asList(src.getSimpleName(), dst.getSimpleName(), fn);
 432         return fn;
 433     }
 434 
 435     static MethodHandle makeVarargsCollector(MethodHandle target, Class&lt;?&gt; arrayType) {
 436         MethodType type = target.type();
 437         int last = type.parameterCount() - 1;
 438         if (type.parameterType(last) != arrayType)
 439             target = target.asType(type.changeParameterType(last, arrayType));
 440         target = target.asFixedArity();  // make sure this attribute is turned off
 441         return new AsVarargsCollector(target, arrayType);
 442     }
 443 
 444     private static final class AsVarargsCollector extends DelegatingMethodHandle {
 445         private final MethodHandle target;
 446         private final Class&lt;?&gt; arrayType;
 447         private @Stable MethodHandle asCollectorCache;
 448 
 449         AsVarargsCollector(MethodHandle target, Class&lt;?&gt; arrayType) {
 450             this(target.type(), target, arrayType);
 451         }
 452         AsVarargsCollector(MethodType type, MethodHandle target, Class&lt;?&gt; arrayType) {
 453             super(type, target);
 454             this.target = target;
 455             this.arrayType = arrayType;
 456         }
 457 
 458         @Override
 459         public boolean isVarargsCollector() {
 460             return true;
 461         }
 462 
 463         @Override
 464         protected MethodHandle getTarget() {
 465             return target;
 466         }
 467 
 468         @Override
 469         public MethodHandle asFixedArity() {
 470             return target;
 471         }
 472 
 473         @Override
 474         MethodHandle setVarargs(MemberName member) {
 475             if (member.isVarargs())  return this;
 476             return asFixedArity();
 477         }
 478 
 479         @Override
 480         public MethodHandle withVarargs(boolean makeVarargs) {
 481             if (makeVarargs)  return this;
 482             return asFixedArity();
 483         }
 484 
 485         @Override
 486         public MethodHandle asTypeUncached(MethodType newType) {
 487             MethodType type = this.type();
 488             int collectArg = type.parameterCount() - 1;
 489             int newArity = newType.parameterCount();
 490             if (newArity == collectArg+1 &amp;&amp;
 491                 type.parameterType(collectArg).isAssignableFrom(newType.parameterType(collectArg))) {
 492                 // if arity and trailing parameter are compatible, do normal thing
 493                 return asTypeCache = asFixedArity().asType(newType);
 494             }
 495             // check cache
 496             MethodHandle acc = asCollectorCache;
 497             if (acc != null &amp;&amp; acc.type().parameterCount() == newArity)
 498                 return asTypeCache = acc.asType(newType);
 499             // build and cache a collector
 500             int arrayLength = newArity - collectArg;
 501             MethodHandle collector;
 502             try {
 503                 collector = asFixedArity().asCollector(arrayType, arrayLength);
 504                 assert(collector.type().parameterCount() == newArity) : &quot;newArity=&quot;+newArity+&quot; but collector=&quot;+collector;
 505             } catch (IllegalArgumentException ex) {
 506                 throw new WrongMethodTypeException(&quot;cannot build collector&quot;, ex);
 507             }
 508             asCollectorCache = collector;
 509             return asTypeCache = collector.asType(newType);
 510         }
 511 
 512         @Override
 513         boolean viewAsTypeChecks(MethodType newType, boolean strict) {
 514             super.viewAsTypeChecks(newType, true);
 515             if (strict) return true;
 516             // extra assertion for non-strict checks:
 517             assert (type().lastParameterType().getComponentType()
 518                     .isAssignableFrom(
 519                             newType.lastParameterType().getComponentType()))
 520                     : Arrays.asList(this, newType);
 521             return true;
 522         }
 523 
 524         @Override
 525         public Object invokeWithArguments(Object... arguments) throws Throwable {
 526             MethodType type = this.type();
 527             int argc;
 528             final int MAX_SAFE = 127;  // 127 longs require 254 slots, which is safe to spread
 529             if (arguments == null
 530                     || (argc = arguments.length) &lt;= MAX_SAFE
 531                     || argc &lt; type.parameterCount()) {
 532                 return super.invokeWithArguments(arguments);
 533             }
 534 
 535             // a jumbo invocation requires more explicit reboxing of the trailing arguments
 536             int uncollected = type.parameterCount() - 1;
 537             Class&lt;?&gt; elemType = arrayType.getComponentType();
 538             int collected = argc - uncollected;
 539             Object collArgs = (elemType == Object.class)
 540                 ? new Object[collected] : Array.newInstance(elemType, collected);
 541             if (!elemType.isPrimitive()) {
 542                 // simple cast:  just do some casting
 543                 try {
 544                     System.arraycopy(arguments, uncollected, collArgs, 0, collected);
 545                 } catch (ArrayStoreException ex) {
 546                     return super.invokeWithArguments(arguments);
 547                 }
 548             } else {
 549                 // corner case of flat array requires reflection (or specialized copy loop)
 550                 MethodHandle arraySetter = MethodHandles.arrayElementSetter(arrayType);
 551                 try {
 552                     for (int i = 0; i &lt; collected; i++) {
 553                         arraySetter.invoke(collArgs, i, arguments[uncollected + i]);
 554                     }
 555                 } catch (WrongMethodTypeException|ClassCastException ex) {
 556                     return super.invokeWithArguments(arguments);
 557                 }
 558             }
 559 
 560             // chop the jumbo list down to size and call in non-varargs mode
 561             Object[] newArgs = new Object[uncollected + 1];
 562             System.arraycopy(arguments, 0, newArgs, 0, uncollected);
 563             newArgs[uncollected] = collArgs;
 564             return asFixedArity().invokeWithArguments(newArgs);
 565         }
 566     }
 567 
 568     /** Factory method:  Spread selected argument. */
 569     static MethodHandle makeSpreadArguments(MethodHandle target,
 570                                             Class&lt;?&gt; spreadArgType, int spreadArgPos, int spreadArgCount) {
 571         MethodType targetType = target.type();
 572 
 573         for (int i = 0; i &lt; spreadArgCount; i++) {
 574             Class&lt;?&gt; arg = VerifyType.spreadArgElementType(spreadArgType, i);
 575             if (arg == null)  arg = Object.class;
 576             targetType = targetType.changeParameterType(spreadArgPos + i, arg);
 577         }
 578         target = target.asType(targetType);
 579 
 580         MethodType srcType = targetType
 581                 .replaceParameterTypes(spreadArgPos, spreadArgPos + spreadArgCount, spreadArgType);
 582         // Now build a LambdaForm.
 583         MethodType lambdaType = srcType.invokerType();
 584         Name[] names = arguments(spreadArgCount + 2, lambdaType);
 585         int nameCursor = lambdaType.parameterCount();
 586         int[] indexes = new int[targetType.parameterCount()];
 587 
 588         for (int i = 0, argIndex = 1; i &lt; targetType.parameterCount() + 1; i++, argIndex++) {
 589             Class&lt;?&gt; src = lambdaType.parameterType(i);
 590             if (i == spreadArgPos) {
 591                 // Spread the array.
 592                 MethodHandle aload = MethodHandles.arrayElementGetter(spreadArgType);
 593                 Name array = names[argIndex];
 594                 names[nameCursor++] = new Name(getFunction(NF_checkSpreadArgument), array, spreadArgCount);
 595                 for (int j = 0; j &lt; spreadArgCount; i++, j++) {
 596                     indexes[i] = nameCursor;
 597                     names[nameCursor++] = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), array, j);
 598                 }
 599             } else if (i &lt; indexes.length) {
 600                 indexes[i] = argIndex;
 601             }
 602         }
 603         assert(nameCursor == names.length-1);  // leave room for the final call
 604 
 605         // Build argument array for the call.
 606         Name[] targetArgs = new Name[targetType.parameterCount()];
 607         for (int i = 0; i &lt; targetType.parameterCount(); i++) {
 608             int idx = indexes[i];
 609             targetArgs[i] = names[idx];
 610         }
 611         names[names.length - 1] = new Name(target, (Object[]) targetArgs);
 612 
 613         LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.SPREAD);
 614         return SimpleMethodHandle.make(srcType, form);
 615     }
 616 
 617     static void checkSpreadArgument(Object av, int n) {
 618         if (av == null &amp;&amp; n == 0) {
 619             return;
 620         } else if (av == null) {
 621             throw new NullPointerException(&quot;null array reference&quot;);
 622         } else if (av instanceof Object[]) {
 623             int len = ((Object[])av).length;
 624             if (len == n)  return;
 625         } else {
 626             int len = java.lang.reflect.Array.getLength(av);
 627             if (len == n)  return;
 628         }
 629         // fall through to error:
 630         throw newIllegalArgumentException(&quot;array is not of length &quot;+n);
 631     }
 632 
 633     /** Factory method:  Collect or filter selected argument(s). */
 634     static MethodHandle makeCollectArguments(MethodHandle target,
 635                 MethodHandle collector, int collectArgPos, boolean retainOriginalArgs) {
 636         MethodType targetType = target.type();          // (a..., c, [b...])=&gt;r
 637         MethodType collectorType = collector.type();    // (b...)=&gt;c
 638         int collectArgCount = collectorType.parameterCount();
 639         Class&lt;?&gt; collectValType = collectorType.returnType();
 640         int collectValCount = (collectValType == void.class ? 0 : 1);
 641         MethodType srcType = targetType                 // (a..., [b...])=&gt;r
 642                 .dropParameterTypes(collectArgPos, collectArgPos+collectValCount);
 643         if (!retainOriginalArgs) {                      // (a..., b...)=&gt;r
 644             srcType = srcType.insertParameterTypes(collectArgPos, collectorType.parameterArray());
 645         }
 646         // in  arglist: [0: ...keep1 | cpos: collect...  | cpos+cacount: keep2... ]
 647         // out arglist: [0: ...keep1 | cpos: collectVal? | cpos+cvcount: keep2... ]
 648         // out(retain): [0: ...keep1 | cpos: cV? coll... | cpos+cvc+cac: keep2... ]
 649 
 650         // Now build a LambdaForm.
 651         MethodType lambdaType = srcType.invokerType();
 652         Name[] names = arguments(2, lambdaType);
 653         final int collectNamePos = names.length - 2;
 654         final int targetNamePos  = names.length - 1;
 655 
 656         Name[] collectorArgs = Arrays.copyOfRange(names, 1 + collectArgPos, 1 + collectArgPos + collectArgCount);
 657         names[collectNamePos] = new Name(collector, (Object[]) collectorArgs);
 658 
 659         // Build argument array for the target.
 660         // Incoming LF args to copy are: [ (mh) headArgs collectArgs tailArgs ].
 661         // Output argument array is [ headArgs (collectVal)? (collectArgs)? tailArgs ].
 662         Name[] targetArgs = new Name[targetType.parameterCount()];
 663         int inputArgPos  = 1;  // incoming LF args to copy to target
 664         int targetArgPos = 0;  // fill pointer for targetArgs
 665         int chunk = collectArgPos;  // |headArgs|
 666         System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 667         inputArgPos  += chunk;
 668         targetArgPos += chunk;
 669         if (collectValType != void.class) {
 670             targetArgs[targetArgPos++] = names[collectNamePos];
 671         }
 672         chunk = collectArgCount;
 673         if (retainOriginalArgs) {
 674             System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 675             targetArgPos += chunk;   // optionally pass on the collected chunk
 676         }
 677         inputArgPos += chunk;
 678         chunk = targetArgs.length - targetArgPos;  // all the rest
 679         System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 680         assert(inputArgPos + chunk == collectNamePos);  // use of rest of input args also
 681         names[targetNamePos] = new Name(target, (Object[]) targetArgs);
 682 
 683         LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.COLLECT);
 684         return SimpleMethodHandle.make(srcType, form);
 685     }
 686 
 687     @Hidden
 688     static MethodHandle selectAlternative(boolean testResult, MethodHandle target, MethodHandle fallback) {
 689         if (testResult) {
 690             return target;
 691         } else {
 692             return fallback;
 693         }
 694     }
 695 
 696     // Intrinsified by C2. Counters are used during parsing to calculate branch frequencies.
 697     @Hidden
 698     @jdk.internal.HotSpotIntrinsicCandidate
 699     static boolean profileBoolean(boolean result, int[] counters) {
 700         // Profile is int[2] where [0] and [1] correspond to false and true occurrences respectively.
 701         int idx = result ? 1 : 0;
 702         try {
 703             counters[idx] = Math.addExact(counters[idx], 1);
 704         } catch (ArithmeticException e) {
 705             // Avoid continuous overflow by halving the problematic count.
 706             counters[idx] = counters[idx] / 2;
 707         }
 708         return result;
 709     }
 710 
 711     // Intrinsified by C2. Returns true if obj is a compile-time constant.
 712     @Hidden
 713     @jdk.internal.HotSpotIntrinsicCandidate
 714     static boolean isCompileConstant(Object obj) {
 715         return false;
 716     }
 717 
 718     static MethodHandle makeGuardWithTest(MethodHandle test,
 719                                    MethodHandle target,
 720                                    MethodHandle fallback) {
 721         MethodType type = target.type();
 722         assert(test.type().equals(type.changeReturnType(boolean.class)) &amp;&amp; fallback.type().equals(type));
 723         MethodType basicType = type.basicType();
 724         LambdaForm form = makeGuardWithTestForm(basicType);
 725         BoundMethodHandle mh;
 726         try {
 727             if (PROFILE_GWT) {
 728                 int[] counts = new int[2];
 729                 mh = (BoundMethodHandle)
 730                         BoundMethodHandle.speciesData_LLLL().factory().invokeBasic(type, form,
 731                                 (Object) test, (Object) profile(target), (Object) profile(fallback), counts);
 732             } else {
 733                 mh = (BoundMethodHandle)
 734                         BoundMethodHandle.speciesData_LLL().factory().invokeBasic(type, form,
 735                                 (Object) test, (Object) profile(target), (Object) profile(fallback));
 736             }
 737         } catch (Throwable ex) {
 738             throw uncaughtException(ex);
 739         }
 740         assert(mh.type() == type);
 741         return mh;
 742     }
 743 
 744 
 745     static MethodHandle profile(MethodHandle target) {
 746         if (DONT_INLINE_THRESHOLD &gt;= 0) {
 747             return makeBlockInliningWrapper(target);
 748         } else {
 749             return target;
 750         }
 751     }
 752 
 753     /**
 754      * Block inlining during JIT-compilation of a target method handle if it hasn&#39;t been invoked enough times.
 755      * Corresponding LambdaForm has @DontInline when compiled into bytecode.
 756      */
 757     static MethodHandle makeBlockInliningWrapper(MethodHandle target) {
 758         LambdaForm lform;
 759         if (DONT_INLINE_THRESHOLD &gt; 0) {
 760             lform = Makers.PRODUCE_BLOCK_INLINING_FORM.apply(target);
 761         } else {
 762             lform = Makers.PRODUCE_REINVOKER_FORM.apply(target);
 763         }
 764         return new CountingWrapper(target, lform,
 765                 Makers.PRODUCE_BLOCK_INLINING_FORM, Makers.PRODUCE_REINVOKER_FORM,
 766                                    DONT_INLINE_THRESHOLD);
 767     }
 768 
 769     private final static class Makers {
 770         /** Constructs reinvoker lambda form which block inlining during JIT-compilation for a particular method handle */
 771         static final Function&lt;MethodHandle, LambdaForm&gt; PRODUCE_BLOCK_INLINING_FORM = new Function&lt;MethodHandle, LambdaForm&gt;() {
 772             @Override
 773             public LambdaForm apply(MethodHandle target) {
 774                 return DelegatingMethodHandle.makeReinvokerForm(target,
 775                                    MethodTypeForm.LF_DELEGATE_BLOCK_INLINING, CountingWrapper.class, false,
 776                                    DelegatingMethodHandle.NF_getTarget, CountingWrapper.NF_maybeStopCounting);
 777             }
 778         };
 779 
 780         /** Constructs simple reinvoker lambda form for a particular method handle */
 781         static final Function&lt;MethodHandle, LambdaForm&gt; PRODUCE_REINVOKER_FORM = new Function&lt;MethodHandle, LambdaForm&gt;() {
 782             @Override
 783             public LambdaForm apply(MethodHandle target) {
 784                 return DelegatingMethodHandle.makeReinvokerForm(target,
 785                         MethodTypeForm.LF_DELEGATE, DelegatingMethodHandle.class, DelegatingMethodHandle.NF_getTarget);
 786             }
 787         };
 788 
 789         /** Maker of type-polymorphic varargs */
 790         static final ClassValue&lt;MethodHandle[]&gt; TYPED_COLLECTORS = new ClassValue&lt;MethodHandle[]&gt;() {
 791             @Override
 792             protected MethodHandle[] computeValue(Class&lt;?&gt; type) {
 793                 return new MethodHandle[MAX_JVM_ARITY + 1];
 794             }
 795         };
 796     }
 797 
 798     /**
 799      * Counting method handle. It has 2 states: counting and non-counting.
 800      * It is in counting state for the first n invocations and then transitions to non-counting state.
 801      * Behavior in counting and non-counting states is determined by lambda forms produced by
 802      * countingFormProducer &amp; nonCountingFormProducer respectively.
 803      */
 804     static class CountingWrapper extends DelegatingMethodHandle {
 805         private final MethodHandle target;
 806         private int count;
 807         private Function&lt;MethodHandle, LambdaForm&gt; countingFormProducer;
 808         private Function&lt;MethodHandle, LambdaForm&gt; nonCountingFormProducer;
 809         private volatile boolean isCounting;
 810 
 811         private CountingWrapper(MethodHandle target, LambdaForm lform,
 812                                 Function&lt;MethodHandle, LambdaForm&gt; countingFromProducer,
 813                                 Function&lt;MethodHandle, LambdaForm&gt; nonCountingFormProducer,
 814                                 int count) {
 815             super(target.type(), lform);
 816             this.target = target;
 817             this.count = count;
 818             this.countingFormProducer = countingFromProducer;
 819             this.nonCountingFormProducer = nonCountingFormProducer;
 820             this.isCounting = (count &gt; 0);
 821         }
 822 
 823         @Hidden
 824         @Override
 825         protected MethodHandle getTarget() {
 826             return target;
 827         }
 828 
 829         @Override
 830         public MethodHandle asTypeUncached(MethodType newType) {
 831             MethodHandle newTarget = target.asType(newType);
 832             MethodHandle wrapper;
 833             if (isCounting) {
 834                 LambdaForm lform;
 835                 lform = countingFormProducer.apply(newTarget);
 836                 wrapper = new CountingWrapper(newTarget, lform, countingFormProducer, nonCountingFormProducer, DONT_INLINE_THRESHOLD);
 837             } else {
 838                 wrapper = newTarget; // no need for a counting wrapper anymore
 839             }
 840             return (asTypeCache = wrapper);
 841         }
 842 
 843         // Customize target if counting happens for too long.
 844         private int invocations = CUSTOMIZE_THRESHOLD;
 845         private void maybeCustomizeTarget() {
 846             int c = invocations;
 847             if (c &gt;= 0) {
 848                 if (c == 1) {
 849                     target.customize();
 850                 }
 851                 invocations = c - 1;
 852             }
 853         }
 854 
 855         boolean countDown() {
 856             int c = count;
 857             maybeCustomizeTarget();
 858             if (c &lt;= 1) {
 859                 // Try to limit number of updates. MethodHandle.updateForm() doesn&#39;t guarantee LF update visibility.
 860                 if (isCounting) {
 861                     isCounting = false;
 862                     return true;
 863                 } else {
 864                     return false;
 865                 }
 866             } else {
 867                 count = c - 1;
 868                 return false;
 869             }
 870         }
 871 
 872         @Hidden
 873         static void maybeStopCounting(Object o1) {
 874              CountingWrapper wrapper = (CountingWrapper) o1;
 875              if (wrapper.countDown()) {
 876                  // Reached invocation threshold. Replace counting behavior with a non-counting one.
 877                  LambdaForm lform = wrapper.nonCountingFormProducer.apply(wrapper.target);
 878                  lform.compileToBytecode(); // speed up warmup by avoiding LF interpretation again after transition
 879                  wrapper.updateForm(lform);
 880              }
 881         }
 882 
 883         static final NamedFunction NF_maybeStopCounting;
 884         static {
 885             Class&lt;?&gt; THIS_CLASS = CountingWrapper.class;
 886             try {
 887                 NF_maybeStopCounting = new NamedFunction(THIS_CLASS.getDeclaredMethod(&quot;maybeStopCounting&quot;, Object.class));
 888             } catch (ReflectiveOperationException ex) {
 889                 throw newInternalError(ex);
 890             }
 891         }
 892     }
 893 
 894     static LambdaForm makeGuardWithTestForm(MethodType basicType) {
 895         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_GWT);
 896         if (lform != null)  return lform;
 897         final int THIS_MH      = 0;  // the BMH_LLL
 898         final int ARG_BASE     = 1;  // start of incoming arguments
 899         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
 900         int nameCursor = ARG_LIMIT;
 901         final int GET_TEST     = nameCursor++;
 902         final int GET_TARGET   = nameCursor++;
 903         final int GET_FALLBACK = nameCursor++;
 904         final int GET_COUNTERS = PROFILE_GWT ? nameCursor++ : -1;
 905         final int CALL_TEST    = nameCursor++;
 906         final int PROFILE      = (GET_COUNTERS != -1) ? nameCursor++ : -1;
 907         final int TEST         = nameCursor-1; // previous statement: either PROFILE or CALL_TEST
 908         final int SELECT_ALT   = nameCursor++;
 909         final int CALL_TARGET  = nameCursor++;
 910         assert(CALL_TARGET == SELECT_ALT+1);  // must be true to trigger IBG.emitSelectAlternative
 911 
 912         MethodType lambdaType = basicType.invokerType();
 913         Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
 914 
 915         BoundMethodHandle.SpeciesData data =
 916                 (GET_COUNTERS != -1) ? BoundMethodHandle.speciesData_LLLL()
 917                                      : BoundMethodHandle.speciesData_LLL();
 918         names[THIS_MH] = names[THIS_MH].withConstraint(data);
 919         names[GET_TEST]     = new Name(data.getterFunction(0), names[THIS_MH]);
 920         names[GET_TARGET]   = new Name(data.getterFunction(1), names[THIS_MH]);
 921         names[GET_FALLBACK] = new Name(data.getterFunction(2), names[THIS_MH]);
 922         if (GET_COUNTERS != -1) {
 923             names[GET_COUNTERS] = new Name(data.getterFunction(3), names[THIS_MH]);
 924         }
 925         Object[] invokeArgs = Arrays.copyOfRange(names, 0, ARG_LIMIT, Object[].class);
 926 
 927         // call test
 928         MethodType testType = basicType.changeReturnType(boolean.class).basicType();
 929         invokeArgs[0] = names[GET_TEST];
 930         names[CALL_TEST] = new Name(testType, invokeArgs);
 931 
 932         // profile branch
 933         if (PROFILE != -1) {
 934             names[PROFILE] = new Name(getFunction(NF_profileBoolean), names[CALL_TEST], names[GET_COUNTERS]);
 935         }
 936         // call selectAlternative
 937         names[SELECT_ALT] = new Name(new NamedFunction(getConstantHandle(MH_selectAlternative), Intrinsic.SELECT_ALTERNATIVE), names[TEST], names[GET_TARGET], names[GET_FALLBACK]);
 938 
 939         // call target or fallback
 940         invokeArgs[0] = names[SELECT_ALT];
 941         names[CALL_TARGET] = new Name(basicType, invokeArgs);
 942 
 943         lform = new LambdaForm(lambdaType.parameterCount(), names, /*forceInline=*/true, Kind.GUARD);
 944 
 945         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_GWT, lform);
 946     }
 947 
 948     /**
 949      * The LambdaForm shape for catchException combinator is the following:
 950      * &lt;blockquote&gt;&lt;pre&gt;{@code
 951      *  guardWithCatch=Lambda(a0:L,a1:L,a2:L)=&gt;{
 952      *    t3:L=BoundMethodHandle$Species_LLLLL.argL0(a0:L);
 953      *    t4:L=BoundMethodHandle$Species_LLLLL.argL1(a0:L);
 954      *    t5:L=BoundMethodHandle$Species_LLLLL.argL2(a0:L);
 955      *    t6:L=BoundMethodHandle$Species_LLLLL.argL3(a0:L);
 956      *    t7:L=BoundMethodHandle$Species_LLLLL.argL4(a0:L);
 957      *    t8:L=MethodHandle.invokeBasic(t6:L,a1:L,a2:L);
 958      *    t9:L=MethodHandleImpl.guardWithCatch(t3:L,t4:L,t5:L,t8:L);
 959      *   t10:I=MethodHandle.invokeBasic(t7:L,t9:L);t10:I}
 960      * }&lt;/pre&gt;&lt;/blockquote&gt;
 961      *
 962      * argL0 and argL2 are target and catcher method handles. argL1 is exception class.
 963      * argL3 and argL4 are auxiliary method handles: argL3 boxes arguments and wraps them into Object[]
 964      * (ValueConversions.array()) and argL4 unboxes result if necessary (ValueConversions.unbox()).
 965      *
 966      * Having t8 and t10 passed outside and not hardcoded into a lambda form allows to share lambda forms
 967      * among catchException combinators with the same basic type.
 968      */
 969     private static LambdaForm makeGuardWithCatchForm(MethodType basicType) {
 970         MethodType lambdaType = basicType.invokerType();
 971 
 972         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_GWC);
 973         if (lform != null) {
 974             return lform;
 975         }
 976         final int THIS_MH      = 0;  // the BMH_LLLLL
 977         final int ARG_BASE     = 1;  // start of incoming arguments
 978         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
 979 
 980         int nameCursor = ARG_LIMIT;
 981         final int GET_TARGET       = nameCursor++;
 982         final int GET_CLASS        = nameCursor++;
 983         final int GET_CATCHER      = nameCursor++;
 984         final int GET_COLLECT_ARGS = nameCursor++;
 985         final int GET_UNBOX_RESULT = nameCursor++;
 986         final int BOXED_ARGS       = nameCursor++;
 987         final int TRY_CATCH        = nameCursor++;
 988         final int UNBOX_RESULT     = nameCursor++;
 989 
 990         Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
 991 
 992         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLLL();
 993         names[THIS_MH]          = names[THIS_MH].withConstraint(data);
 994         names[GET_TARGET]       = new Name(data.getterFunction(0), names[THIS_MH]);
 995         names[GET_CLASS]        = new Name(data.getterFunction(1), names[THIS_MH]);
 996         names[GET_CATCHER]      = new Name(data.getterFunction(2), names[THIS_MH]);
 997         names[GET_COLLECT_ARGS] = new Name(data.getterFunction(3), names[THIS_MH]);
 998         names[GET_UNBOX_RESULT] = new Name(data.getterFunction(4), names[THIS_MH]);
 999 
1000         // FIXME: rework argument boxing/result unboxing logic for LF interpretation
1001 
1002         // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);
1003         MethodType collectArgsType = basicType.changeReturnType(Object.class);
1004         MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
1005         Object[] args = new Object[invokeBasic.type().parameterCount()];
1006         args[0] = names[GET_COLLECT_ARGS];
1007         System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT-ARG_BASE);
1008         names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.GUARD_WITH_CATCH), args);
1009 
1010         // t_{i+1}:L=MethodHandleImpl.guardWithCatch(target:L,exType:L,catcher:L,t_{i}:L);
1011         Object[] gwcArgs = new Object[] {names[GET_TARGET], names[GET_CLASS], names[GET_CATCHER], names[BOXED_ARGS]};
1012         names[TRY_CATCH] = new Name(getFunction(NF_guardWithCatch), gwcArgs);
1013 
1014         // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
1015         MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
1016         Object[] unboxArgs  = new Object[] {names[GET_UNBOX_RESULT], names[TRY_CATCH]};
1017         names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
1018 
1019         lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.GUARD_WITH_CATCH);
1020 
1021         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_GWC, lform);
1022     }
1023 
1024     static MethodHandle makeGuardWithCatch(MethodHandle target,
1025                                     Class&lt;? extends Throwable&gt; exType,
1026                                     MethodHandle catcher) {
1027         MethodType type = target.type();
1028         LambdaForm form = makeGuardWithCatchForm(type.basicType());
1029 
1030         // Prepare auxiliary method handles used during LambdaForm interpretation.
1031         // Box arguments and wrap them into Object[]: ValueConversions.array().
1032         MethodType varargsType = type.changeReturnType(Object[].class);
1033         MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
1034         MethodHandle unboxResult = unboxResultHandle(type.returnType());
1035 
1036         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLLL();
1037         BoundMethodHandle mh;
1038         try {
1039             mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) target, (Object) exType,
1040                     (Object) catcher, (Object) collectArgs, (Object) unboxResult);
1041         } catch (Throwable ex) {
1042             throw uncaughtException(ex);
1043         }
1044         assert(mh.type() == type);
1045         return mh;
1046     }
1047 
1048     /**
1049      * Intrinsified during LambdaForm compilation
1050      * (see {@link InvokerBytecodeGenerator#emitGuardWithCatch emitGuardWithCatch}).
1051      */
1052     @Hidden
1053     static Object guardWithCatch(MethodHandle target, Class&lt;? extends Throwable&gt; exType, MethodHandle catcher,
1054                                  Object... av) throws Throwable {
1055         // Use asFixedArity() to avoid unnecessary boxing of last argument for VarargsCollector case.
1056         try {
1057             return target.asFixedArity().invokeWithArguments(av);
1058         } catch (Throwable t) {
1059             if (!exType.isInstance(t)) throw t;
1060             return catcher.asFixedArity().invokeWithArguments(prepend(av, t));
1061         }
1062     }
1063 
1064     /** Prepend elements to an array. */
1065     @Hidden
1066     private static Object[] prepend(Object[] array, Object... elems) {
1067         int nArray = array.length;
1068         int nElems = elems.length;
1069         Object[] newArray = new Object[nArray + nElems];
1070         System.arraycopy(elems, 0, newArray, 0, nElems);
1071         System.arraycopy(array, 0, newArray, nElems, nArray);
1072         return newArray;
1073     }
1074 
1075     static MethodHandle throwException(MethodType type) {
1076         assert(Throwable.class.isAssignableFrom(type.parameterType(0)));
1077         int arity = type.parameterCount();
1078         if (arity &gt; 1) {
1079             MethodHandle mh = throwException(type.dropParameterTypes(1, arity));
1080             mh = MethodHandles.dropArguments(mh, 1, Arrays.copyOfRange(type.parameterArray(), 1, arity));
1081             return mh;
1082         }
1083         return makePairwiseConvert(getFunction(NF_throwException).resolvedHandle(), type, false, true);
1084     }
1085 
1086     static &lt;T extends Throwable&gt; Empty throwException(T t) throws T { throw t; }
1087 
1088     static MethodHandle[] FAKE_METHOD_HANDLE_INVOKE = new MethodHandle[2];
1089     static MethodHandle fakeMethodHandleInvoke(MemberName method) {
1090         int idx;
1091         assert(method.isMethodHandleInvoke());
1092         switch (method.getName()) {
1093         case &quot;invoke&quot;:       idx = 0; break;
1094         case &quot;invokeExact&quot;:  idx = 1; break;
1095         default:             throw new InternalError(method.getName());
1096         }
1097         MethodHandle mh = FAKE_METHOD_HANDLE_INVOKE[idx];
1098         if (mh != null)  return mh;
1099         MethodType type = MethodType.methodType(Object.class, UnsupportedOperationException.class,
1100                                                 MethodHandle.class, Object[].class);
1101         mh = throwException(type);
1102         mh = mh.bindTo(new UnsupportedOperationException(&quot;cannot reflectively invoke MethodHandle&quot;));
1103         if (!method.getInvocationType().equals(mh.type()))
1104             throw new InternalError(method.toString());
1105         mh = mh.withInternalMemberName(method, false);
1106         mh = mh.withVarargs(true);
1107         assert(method.isVarargs());
1108         FAKE_METHOD_HANDLE_INVOKE[idx] = mh;
1109         return mh;
1110     }
1111     static MethodHandle fakeVarHandleInvoke(MemberName method) {
1112         // TODO caching, is it necessary?
1113         MethodType type = MethodType.methodType(method.getReturnType(), UnsupportedOperationException.class,
1114                                                 VarHandle.class, Object[].class);
1115         MethodHandle mh = throwException(type);
1116         mh = mh.bindTo(new UnsupportedOperationException(&quot;cannot reflectively invoke VarHandle&quot;));
1117         if (!method.getInvocationType().equals(mh.type()))
1118             throw new InternalError(method.toString());
1119         mh = mh.withInternalMemberName(method, false);
1120         mh = mh.asVarargsCollector(Object[].class);
1121         assert(method.isVarargs());
1122         return mh;
1123     }
1124 
1125     /**
1126      * Create an alias for the method handle which, when called,
1127      * appears to be called from the same class loader and protection domain
1128      * as hostClass.
1129      * This is an expensive no-op unless the method which is called
1130      * is sensitive to its caller.  A small number of system methods
1131      * are in this category, including Class.forName and Method.invoke.
1132      */
1133     static MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {
1134         return BindCaller.bindCaller(mh, hostClass);
1135     }
1136 
1137     // Put the whole mess into its own nested class.
1138     // That way we can lazily load the code and set up the constants.
1139     private static class BindCaller {
1140         private static MethodType INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);
1141 
1142         static MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {
1143             // Code in the boot layer should now be careful while creating method handles or
1144             // functional interface instances created from method references to @CallerSensitive  methods,
1145             // it needs to be ensured the handles or interface instances are kept safe and are not passed
1146             // from the boot layer to untrusted code.
1147             if (hostClass == null
1148                 ||    (hostClass.isArray() ||
1149                        hostClass.isPrimitive() ||
1150                        hostClass.getName().startsWith(&quot;java.lang.invoke.&quot;))) {
1151                 throw new InternalError();  // does not happen, and should not anyway
1152             }
1153             // For simplicity, convert mh to a varargs-like method.
1154             MethodHandle vamh = prepareForInvoker(mh);
1155             // Cache the result of makeInjectedInvoker once per argument class.
1156             MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass);
1157             return restoreToType(bccInvoker.bindTo(vamh), mh, hostClass);
1158         }
1159 
1160         private static MethodHandle makeInjectedInvoker(Class&lt;?&gt; hostClass) {
1161             try {
1162                 Class&lt;?&gt; invokerClass = UNSAFE.defineAnonymousClass(hostClass, INJECTED_INVOKER_TEMPLATE, null);
1163                 assert checkInjectedInvoker(hostClass, invokerClass);
1164                 return IMPL_LOOKUP.findStatic(invokerClass, &quot;invoke_V&quot;, INVOKER_MT);
1165             } catch (ReflectiveOperationException ex) {
1166                 throw uncaughtException(ex);
1167             }
1168         }
1169 
1170         private static ClassValue&lt;MethodHandle&gt; CV_makeInjectedInvoker = new ClassValue&lt;MethodHandle&gt;() {
1171             @Override protected MethodHandle computeValue(Class&lt;?&gt; hostClass) {
1172                 return makeInjectedInvoker(hostClass);
1173             }
1174         };
1175 
1176         // Adapt mh so that it can be called directly from an injected invoker:
1177         private static MethodHandle prepareForInvoker(MethodHandle mh) {
1178             mh = mh.asFixedArity();
1179             MethodType mt = mh.type();
1180             int arity = mt.parameterCount();
1181             MethodHandle vamh = mh.asType(mt.generic());
1182             vamh.internalForm().compileToBytecode();  // eliminate LFI stack frames
1183             vamh = vamh.asSpreader(Object[].class, arity);
1184             vamh.internalForm().compileToBytecode();  // eliminate LFI stack frames
1185             return vamh;
1186         }
1187 
1188         // Undo the adapter effect of prepareForInvoker:
1189         private static MethodHandle restoreToType(MethodHandle vamh,
1190                                                   MethodHandle original,
1191                                                   Class&lt;?&gt; hostClass) {
1192             MethodType type = original.type();
1193             MethodHandle mh = vamh.asCollector(Object[].class, type.parameterCount());
1194             MemberName member = original.internalMemberName();
1195             mh = mh.asType(type);
1196             mh = new WrappedMember(mh, type, member, original.isInvokeSpecial(), hostClass);
1197             return mh;
1198         }
1199 
1200         private static boolean checkInjectedInvoker(Class&lt;?&gt; hostClass, Class&lt;?&gt; invokerClass) {
1201             assert (hostClass.getClassLoader() == invokerClass.getClassLoader()) : hostClass.getName()+&quot; (CL)&quot;;
1202             try {
1203                 assert (hostClass.getProtectionDomain() == invokerClass.getProtectionDomain()) : hostClass.getName()+&quot; (PD)&quot;;
1204             } catch (SecurityException ex) {
1205                 // Self-check was blocked by security manager. This is OK.
1206             }
1207             try {
1208                 // Test the invoker to ensure that it really injects into the right place.
1209                 MethodHandle invoker = IMPL_LOOKUP.findStatic(invokerClass, &quot;invoke_V&quot;, INVOKER_MT);
1210                 MethodHandle vamh = prepareForInvoker(MH_checkCallerClass);
1211                 return (boolean)invoker.invoke(vamh, new Object[]{ invokerClass });
1212             } catch (Throwable ex) {
1213                 throw new InternalError(ex);
1214             }
1215         }
1216 
1217         private static final MethodHandle MH_checkCallerClass;
1218         static {
1219             final Class&lt;?&gt; THIS_CLASS = BindCaller.class;
1220             assert(checkCallerClass(THIS_CLASS));
1221             try {
1222                 MH_checkCallerClass = IMPL_LOOKUP
1223                     .findStatic(THIS_CLASS, &quot;checkCallerClass&quot;,
1224                                 MethodType.methodType(boolean.class, Class.class));
1225                 assert((boolean) MH_checkCallerClass.invokeExact(THIS_CLASS));
1226             } catch (Throwable ex) {
1227                 throw new InternalError(ex);
1228             }
1229         }
1230 
1231         @CallerSensitive
1232         @ForceInline // to ensure Reflection.getCallerClass optimization
1233         private static boolean checkCallerClass(Class&lt;?&gt; expected) {
1234             // This method is called via MH_checkCallerClass and so it&#39;s correct to ask for the immediate caller here.
1235             Class&lt;?&gt; actual = Reflection.getCallerClass();
1236             if (actual != expected)
1237                 throw new InternalError(&quot;found &quot; + actual.getName() + &quot;, expected &quot; + expected.getName());
1238             return true;
1239         }
1240 
1241         private static final byte[] INJECTED_INVOKER_TEMPLATE = generateInvokerTemplate();
1242 
1243         /** Produces byte code for a class that is used as an injected invoker. */
1244         private static byte[] generateInvokerTemplate() {
1245             ClassWriter cw = new ClassWriter(0);
1246 
1247             // private static class InjectedInvoker {
1248             //     @Hidden
1249             //     static Object invoke_V(MethodHandle vamh, Object[] args) throws Throwable {
1250             //        return vamh.invokeExact(args);
1251             //     }
1252             // }
1253             cw.visit(52, ACC_PRIVATE | ACC_SUPER, &quot;InjectedInvoker&quot;, null, &quot;java/lang/Object&quot;, null);
1254 
1255             MethodVisitor mv = cw.visitMethod(ACC_STATIC, &quot;invoke_V&quot;,
1256                           &quot;(Ljava/lang/invoke/MethodHandle;[Ljava/lang/Object;)Ljava/lang/Object;&quot;,
1257                           null, null);
1258 
1259             // Suppress invoker method in stack traces.
1260             AnnotationVisitor av0 = mv.visitAnnotation(InvokerBytecodeGenerator.HIDDEN_SIG, true);
1261             av0.visitEnd();
1262 
1263             mv.visitCode();
1264             mv.visitVarInsn(ALOAD, 0);
1265             mv.visitVarInsn(ALOAD, 1);
1266             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/invoke/MethodHandle&quot;, &quot;invokeExact&quot;,
1267                                &quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;, false);
1268             mv.visitInsn(ARETURN);
1269             mv.visitMaxs(2, 2);
1270             mv.visitEnd();
1271 
1272             cw.visitEnd();
1273             return cw.toByteArray();
1274         }
1275     }
1276 
1277     /** This subclass allows a wrapped method handle to be re-associated with an arbitrary member name. */
1278     private static final class WrappedMember extends DelegatingMethodHandle {
1279         private final MethodHandle target;
1280         private final MemberName member;
1281         private final Class&lt;?&gt; callerClass;
1282         private final boolean isInvokeSpecial;
1283 
1284         private WrappedMember(MethodHandle target, MethodType type,
1285                               MemberName member, boolean isInvokeSpecial,
1286                               Class&lt;?&gt; callerClass) {
1287             super(type, target);
1288             this.target = target;
1289             this.member = member;
1290             this.callerClass = callerClass;
1291             this.isInvokeSpecial = isInvokeSpecial;
1292         }
1293 
1294         @Override
1295         MemberName internalMemberName() {
1296             return member;
1297         }
1298         @Override
1299         Class&lt;?&gt; internalCallerClass() {
1300             return callerClass;
1301         }
1302         @Override
1303         boolean isInvokeSpecial() {
1304             return isInvokeSpecial;
1305         }
1306         @Override
1307         protected MethodHandle getTarget() {
1308             return target;
1309         }
1310         @Override
1311         public MethodHandle asTypeUncached(MethodType newType) {
1312             // This MH is an alias for target, except for the MemberName
1313             // Drop the MemberName if there is any conversion.
1314             return asTypeCache = target.asType(newType);
1315         }
1316     }
1317 
1318     static MethodHandle makeWrappedMember(MethodHandle target, MemberName member, boolean isInvokeSpecial) {
1319         if (member.equals(target.internalMemberName()) &amp;&amp; isInvokeSpecial == target.isInvokeSpecial())
1320             return target;
1321         return new WrappedMember(target, target.type(), member, isInvokeSpecial, null);
1322     }
1323 
1324     /** Intrinsic IDs */
1325     /*non-public*/
1326     enum Intrinsic {
1327         SELECT_ALTERNATIVE,
1328         GUARD_WITH_CATCH,
1329         TRY_FINALLY,
1330         LOOP,
1331         NEW_ARRAY,
1332         ARRAY_LOAD,
1333         ARRAY_STORE,
1334         ARRAY_LENGTH,
1335         IDENTITY,
1336         ZERO,
1337         NONE // no intrinsic associated
1338     }
1339 
1340     /** Mark arbitrary method handle as intrinsic.
1341      * InvokerBytecodeGenerator uses this info to produce more efficient bytecode shape. */
1342     static final class IntrinsicMethodHandle extends DelegatingMethodHandle {
1343         private final MethodHandle target;
1344         private final Intrinsic intrinsicName;
1345 
1346         IntrinsicMethodHandle(MethodHandle target, Intrinsic intrinsicName) {
1347             super(target.type(), target);
1348             this.target = target;
1349             this.intrinsicName = intrinsicName;
1350         }
1351 
1352         @Override
1353         protected MethodHandle getTarget() {
1354             return target;
1355         }
1356 
1357         @Override
1358         Intrinsic intrinsicName() {
1359             return intrinsicName;
1360         }
1361 
1362         @Override
1363         public MethodHandle asTypeUncached(MethodType newType) {
1364             // This MH is an alias for target, except for the intrinsic name
1365             // Drop the name if there is any conversion.
1366             return asTypeCache = target.asType(newType);
1367         }
1368 
1369         @Override
1370         String internalProperties() {
1371             return super.internalProperties() +
1372                     &quot;\n&amp; Intrinsic=&quot;+intrinsicName;
1373         }
1374 
1375         @Override
1376         public MethodHandle asCollector(Class&lt;?&gt; arrayType, int arrayLength) {
1377             if (intrinsicName == Intrinsic.IDENTITY) {
1378                 MethodType resultType = type().asCollectorType(arrayType, type().parameterCount() - 1, arrayLength);
1379                 MethodHandle newArray = MethodHandleImpl.varargsArray(arrayType, arrayLength);
1380                 return newArray.asType(resultType);
1381             }
1382             return super.asCollector(arrayType, arrayLength);
1383         }
1384     }
1385 
1386     static MethodHandle makeIntrinsic(MethodHandle target, Intrinsic intrinsicName) {
1387         if (intrinsicName == target.intrinsicName())
1388             return target;
1389         return new IntrinsicMethodHandle(target, intrinsicName);
1390     }
1391 
1392     static MethodHandle makeIntrinsic(MethodType type, LambdaForm form, Intrinsic intrinsicName) {
1393         return new IntrinsicMethodHandle(SimpleMethodHandle.make(type, form), intrinsicName);
1394     }
1395 
1396     /// Collection of multiple arguments.
1397 
1398     private static MethodHandle findCollector(String name, int nargs, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {
1399         MethodType type = MethodType.genericMethodType(nargs)
1400                 .changeReturnType(rtype)
1401                 .insertParameterTypes(0, ptypes);
1402         try {
1403             return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, name, type);
1404         } catch (ReflectiveOperationException ex) {
1405             return null;
1406         }
1407     }
1408 
1409     private static final Object[] NO_ARGS_ARRAY = {};
1410     private static Object[] makeArray(Object... args) { return args; }
1411     private static Object[] array() { return NO_ARGS_ARRAY; }
1412     private static Object[] array(Object a0)
1413                 { return makeArray(a0); }
1414     private static Object[] array(Object a0, Object a1)
1415                 { return makeArray(a0, a1); }
1416     private static Object[] array(Object a0, Object a1, Object a2)
1417                 { return makeArray(a0, a1, a2); }
1418     private static Object[] array(Object a0, Object a1, Object a2, Object a3)
1419                 { return makeArray(a0, a1, a2, a3); }
1420     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1421                                   Object a4)
1422                 { return makeArray(a0, a1, a2, a3, a4); }
1423     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1424                                   Object a4, Object a5)
1425                 { return makeArray(a0, a1, a2, a3, a4, a5); }
1426     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1427                                   Object a4, Object a5, Object a6)
1428                 { return makeArray(a0, a1, a2, a3, a4, a5, a6); }
1429     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1430                                   Object a4, Object a5, Object a6, Object a7)
1431                 { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7); }
1432     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1433                                   Object a4, Object a5, Object a6, Object a7,
1434                                   Object a8)
1435                 { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8); }
1436     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1437                                   Object a4, Object a5, Object a6, Object a7,
1438                                   Object a8, Object a9)
1439                 { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }
1440 
1441     private static final int ARRAYS_COUNT = 11;
1442     private static final @Stable MethodHandle[] ARRAYS = new MethodHandle[MAX_ARITY + 1];
1443 
1444     // filling versions of the above:
1445     // using Integer len instead of int len and no varargs to avoid bootstrapping problems
1446     private static Object[] fillNewArray(Integer len, Object[] /*not ...*/ args) {
1447         Object[] a = new Object[len];
1448         fillWithArguments(a, 0, args);
1449         return a;
1450     }
1451     private static Object[] fillNewTypedArray(Object[] example, Integer len, Object[] /*not ...*/ args) {
1452         Object[] a = Arrays.copyOf(example, len);
1453         assert(a.getClass() != Object[].class);
1454         fillWithArguments(a, 0, args);
1455         return a;
1456     }
1457     private static void fillWithArguments(Object[] a, int pos, Object... args) {
1458         System.arraycopy(args, 0, a, pos, args.length);
1459     }
1460     // using Integer pos instead of int pos to avoid bootstrapping problems
1461     private static Object[] fillArray(Integer pos, Object[] a, Object a0)
1462                 { fillWithArguments(a, pos, a0); return a; }
1463     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1)
1464                 { fillWithArguments(a, pos, a0, a1); return a; }
1465     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2)
1466                 { fillWithArguments(a, pos, a0, a1, a2); return a; }
1467     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3)
1468                 { fillWithArguments(a, pos, a0, a1, a2, a3); return a; }
1469     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1470                                   Object a4)
1471                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4); return a; }
1472     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1473                                   Object a4, Object a5)
1474                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5); return a; }
1475     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1476                                   Object a4, Object a5, Object a6)
1477                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6); return a; }
1478     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1479                                   Object a4, Object a5, Object a6, Object a7)
1480                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7); return a; }
1481     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1482                                   Object a4, Object a5, Object a6, Object a7,
1483                                   Object a8)
1484                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8); return a; }
1485     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1486                                   Object a4, Object a5, Object a6, Object a7,
1487                                   Object a8, Object a9)
1488                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); return a; }
1489 
1490     private static final int FILL_ARRAYS_COUNT = 11; // current number of fillArray methods
1491     private static final @Stable MethodHandle[] FILL_ARRAYS = new MethodHandle[FILL_ARRAYS_COUNT];
1492 
1493     private static MethodHandle getFillArray(int count) {
1494         assert (count &gt; 0 &amp;&amp; count &lt; FILL_ARRAYS_COUNT);
1495         MethodHandle mh = FILL_ARRAYS[count];
1496         if (mh != null) {
1497             return mh;
1498         }
1499         mh = findCollector(&quot;fillArray&quot;, count, Object[].class, Integer.class, Object[].class);
1500         FILL_ARRAYS[count] = mh;
1501         return mh;
1502     }
1503 
1504     private static Object copyAsPrimitiveArray(Wrapper w, Object... boxes) {
1505         Object a = w.makeArray(boxes.length);
1506         w.copyArrayUnboxing(boxes, 0, a, 0, boxes.length);
1507         return a;
1508     }
1509 
1510     /** Return a method handle that takes the indicated number of Object
1511      *  arguments and returns an Object array of them, as if for varargs.
1512      */
1513     static MethodHandle varargsArray(int nargs) {
1514         MethodHandle mh = ARRAYS[nargs];
1515         if (mh != null) {
1516             return mh;
1517         }
1518         if (nargs &lt; ARRAYS_COUNT) {
1519             mh = findCollector(&quot;array&quot;, nargs, Object[].class);
1520         } else {
1521             mh = buildVarargsArray(getConstantHandle(MH_fillNewArray),
1522                     getConstantHandle(MH_arrayIdentity), nargs);
1523         }
1524         assert(assertCorrectArity(mh, nargs));
1525         mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);
1526         return ARRAYS[nargs] = mh;
1527     }
1528 
1529     private static boolean assertCorrectArity(MethodHandle mh, int arity) {
1530         assert(mh.type().parameterCount() == arity) : &quot;arity != &quot;+arity+&quot;: &quot;+mh;
1531         return true;
1532     }
1533 
1534     // Array identity function (used as getConstantHandle(MH_arrayIdentity)).
1535     static &lt;T&gt; T[] identity(T[] x) {
1536         return x;
1537     }
1538 
1539     private static MethodHandle buildVarargsArray(MethodHandle newArray, MethodHandle finisher, int nargs) {
1540         // Build up the result mh as a sequence of fills like this:
1541         //   finisher(fill(fill(newArrayWA(23,x1..x10),10,x11..x20),20,x21..x23))
1542         // The various fill(_,10*I,___*[J]) are reusable.
1543         int leftLen = Math.min(nargs, LEFT_ARGS);  // absorb some arguments immediately
1544         int rightLen = nargs - leftLen;
1545         MethodHandle leftCollector = newArray.bindTo(nargs);
1546         leftCollector = leftCollector.asCollector(Object[].class, leftLen);
1547         MethodHandle mh = finisher;
1548         if (rightLen &gt; 0) {
1549             MethodHandle rightFiller = fillToRight(LEFT_ARGS + rightLen);
1550             if (mh.equals(getConstantHandle(MH_arrayIdentity)))
1551                 mh = rightFiller;
1552             else
1553                 mh = MethodHandles.collectArguments(mh, 0, rightFiller);
1554         }
1555         if (mh.equals(getConstantHandle(MH_arrayIdentity)))
1556             mh = leftCollector;
1557         else
1558             mh = MethodHandles.collectArguments(mh, 0, leftCollector);
1559         return mh;
1560     }
1561 
1562     private static final int LEFT_ARGS = FILL_ARRAYS_COUNT - 1;
1563     private static final @Stable MethodHandle[] FILL_ARRAY_TO_RIGHT = new MethodHandle[MAX_ARITY + 1];
1564     /** fill_array_to_right(N).invoke(a, argL..arg[N-1])
1565      *  fills a[L]..a[N-1] with corresponding arguments,
1566      *  and then returns a.  The value L is a global constant (LEFT_ARGS).
1567      */
1568     private static MethodHandle fillToRight(int nargs) {
1569         MethodHandle filler = FILL_ARRAY_TO_RIGHT[nargs];
1570         if (filler != null)  return filler;
1571         filler = buildFiller(nargs);
1572         assert(assertCorrectArity(filler, nargs - LEFT_ARGS + 1));
1573         return FILL_ARRAY_TO_RIGHT[nargs] = filler;
1574     }
1575     private static MethodHandle buildFiller(int nargs) {
1576         if (nargs &lt;= LEFT_ARGS)
1577             return getConstantHandle(MH_arrayIdentity);  // no args to fill; return the array unchanged
1578         // we need room for both mh and a in mh.invoke(a, arg*[nargs])
1579         final int CHUNK = LEFT_ARGS;
1580         int rightLen = nargs % CHUNK;
1581         int midLen = nargs - rightLen;
1582         if (rightLen == 0) {
1583             midLen = nargs - (rightLen = CHUNK);
1584             if (FILL_ARRAY_TO_RIGHT[midLen] == null) {
1585                 // build some precursors from left to right
1586                 for (int j = LEFT_ARGS % CHUNK; j &lt; midLen; j += CHUNK)
1587                     if (j &gt; LEFT_ARGS)  fillToRight(j);
1588             }
1589         }
1590         if (midLen &lt; LEFT_ARGS) rightLen = nargs - (midLen = LEFT_ARGS);
1591         assert(rightLen &gt; 0);
1592         MethodHandle midFill = fillToRight(midLen);  // recursive fill
1593         MethodHandle rightFill = getFillArray(rightLen).bindTo(midLen);  // [midLen..nargs-1]
1594         assert(midFill.type().parameterCount()   == 1 + midLen - LEFT_ARGS);
1595         assert(rightFill.type().parameterCount() == 1 + rightLen);
1596 
1597         // Combine the two fills:
1598         //   right(mid(a, x10..x19), x20..x23)
1599         // The final product will look like this:
1600         //   right(mid(newArrayLeft(24, x0..x9), x10..x19), x20..x23)
1601         if (midLen == LEFT_ARGS)
1602             return rightFill;
1603         else
1604             return MethodHandles.collectArguments(rightFill, 0, midFill);
1605     }
1606 
1607     static final int MAX_JVM_ARITY = 255;  // limit imposed by the JVM
1608 
1609     /** Return a method handle that takes the indicated number of
1610      *  typed arguments and returns an array of them.
1611      *  The type argument is the array type.
1612      */
1613     static MethodHandle varargsArray(Class&lt;?&gt; arrayType, int nargs) {
1614         Class&lt;?&gt; elemType = arrayType.getComponentType();
1615         if (elemType == null)  throw new IllegalArgumentException(&quot;not an array: &quot;+arrayType);
1616         // FIXME: Need more special casing and caching here.
1617         if (nargs &gt;= MAX_JVM_ARITY/2 - 1) {
1618             int slots = nargs;
1619             final int MAX_ARRAY_SLOTS = MAX_JVM_ARITY - 1;  // 1 for receiver MH
1620             if (slots &lt;= MAX_ARRAY_SLOTS &amp;&amp; elemType.isPrimitive())
1621                 slots *= Wrapper.forPrimitiveType(elemType).stackSlots();
1622             if (slots &gt; MAX_ARRAY_SLOTS)
1623                 throw new IllegalArgumentException(&quot;too many arguments: &quot;+arrayType.getSimpleName()+&quot;, length &quot;+nargs);
1624         }
1625         if (elemType == Object.class)
1626             return varargsArray(nargs);
1627         // other cases:  primitive arrays, subtypes of Object[]
1628         MethodHandle cache[] = Makers.TYPED_COLLECTORS.get(elemType);
1629         MethodHandle mh = nargs &lt; cache.length ? cache[nargs] : null;
1630         if (mh != null)  return mh;
1631         if (nargs == 0) {
1632             Object example = java.lang.reflect.Array.newInstance(arrayType.getComponentType(), 0);
1633             mh = MethodHandles.constant(arrayType, example);
1634         } else if (elemType.isPrimitive()) {
1635             MethodHandle builder = getConstantHandle(MH_fillNewArray);
1636             MethodHandle producer = buildArrayProducer(arrayType);
1637             mh = buildVarargsArray(builder, producer, nargs);
1638         } else {
1639             Class&lt;? extends Object[]&gt; objArrayType = arrayType.asSubclass(Object[].class);
1640             Object[] example = Arrays.copyOf(NO_ARGS_ARRAY, 0, objArrayType);
1641             MethodHandle builder = getConstantHandle(MH_fillNewTypedArray).bindTo(example);
1642             MethodHandle producer = getConstantHandle(MH_arrayIdentity); // must be weakly typed
1643             mh = buildVarargsArray(builder, producer, nargs);
1644         }
1645         mh = mh.asType(MethodType.methodType(arrayType, Collections.&lt;Class&lt;?&gt;&gt;nCopies(nargs, elemType)));
1646         mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);
1647         assert(assertCorrectArity(mh, nargs));
1648         if (nargs &lt; cache.length)
1649             cache[nargs] = mh;
1650         return mh;
1651     }
1652 
1653     private static MethodHandle buildArrayProducer(Class&lt;?&gt; arrayType) {
1654         Class&lt;?&gt; elemType = arrayType.getComponentType();
1655         assert(elemType.isPrimitive());
1656         return getConstantHandle(MH_copyAsPrimitiveArray).bindTo(Wrapper.forPrimitiveType(elemType));
1657     }
1658 
1659     /*non-public*/
1660     static void assertSame(Object mh1, Object mh2) {
1661         if (mh1 != mh2) {
1662             String msg = String.format(&quot;mh1 != mh2: mh1 = %s (form: %s); mh2 = %s (form: %s)&quot;,
1663                     mh1, ((MethodHandle)mh1).form,
1664                     mh2, ((MethodHandle)mh2).form);
1665             throw newInternalError(msg);
1666         }
1667     }
1668 
1669     // Local constant functions:
1670 
1671     /* non-public */
1672     static final byte NF_checkSpreadArgument = 0,
1673             NF_guardWithCatch = 1,
1674             NF_throwException = 2,
1675             NF_tryFinally = 3,
1676             NF_loop = 4,
1677             NF_profileBoolean = 5,
1678             NF_LIMIT = 6;
1679 
1680     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
1681 
1682     static NamedFunction getFunction(byte func) {
1683         NamedFunction nf = NFS[func];
1684         if (nf != null) {
1685             return nf;
1686         }
1687         return NFS[func] = createFunction(func);
1688     }
1689 
1690     private static NamedFunction createFunction(byte func) {
1691         try {
1692             switch (func) {
1693                 case NF_checkSpreadArgument:
1694                     return new NamedFunction(MethodHandleImpl.class
1695                             .getDeclaredMethod(&quot;checkSpreadArgument&quot;, Object.class, int.class));
1696                 case NF_guardWithCatch:
1697                     return new NamedFunction(MethodHandleImpl.class
1698                             .getDeclaredMethod(&quot;guardWithCatch&quot;, MethodHandle.class, Class.class,
1699                                     MethodHandle.class, Object[].class));
1700                 case NF_tryFinally:
1701                     return new NamedFunction(MethodHandleImpl.class
1702                             .getDeclaredMethod(&quot;tryFinally&quot;, MethodHandle.class, MethodHandle.class, Object[].class));
1703                 case NF_loop:
1704                     return new NamedFunction(MethodHandleImpl.class
1705                             .getDeclaredMethod(&quot;loop&quot;, BasicType[].class, LoopClauses.class, Object[].class));
1706                 case NF_throwException:
1707                     return new NamedFunction(MethodHandleImpl.class
1708                             .getDeclaredMethod(&quot;throwException&quot;, Throwable.class));
1709                 case NF_profileBoolean:
1710                     return new NamedFunction(MethodHandleImpl.class
1711                             .getDeclaredMethod(&quot;profileBoolean&quot;, boolean.class, int[].class));
1712                 default:
1713                     throw new InternalError(&quot;Undefined function: &quot; + func);
1714             }
1715         } catch (ReflectiveOperationException ex) {
1716             throw newInternalError(ex);
1717         }
1718     }
1719 
1720     static {
1721         SharedSecrets.setJavaLangInvokeAccess(new JavaLangInvokeAccess() {
1722             @Override
1723             public Object newMemberName() {
1724                 return new MemberName();
1725             }
1726 
1727             @Override
1728             public String getName(Object mname) {
1729                 MemberName memberName = (MemberName)mname;
1730                 return memberName.getName();
1731             }
1732             @Override
1733             public Class&lt;?&gt; getDeclaringClass(Object mname) {
1734                 MemberName memberName = (MemberName)mname;
1735                 return memberName.getDeclaringClass();
1736             }
1737 
1738             @Override
1739             public MethodType getMethodType(Object mname) {
1740                 MemberName memberName = (MemberName)mname;
1741                 return memberName.getMethodType();
1742             }
1743 
1744             @Override
1745             public String getMethodDescriptor(Object mname) {
1746                 MemberName memberName = (MemberName)mname;
1747                 return memberName.getMethodDescriptor();
1748             }
1749 
1750             @Override
1751             public boolean isNative(Object mname) {
1752                 MemberName memberName = (MemberName)mname;
1753                 return memberName.isNative();
1754             }
1755 
1756             @Override
1757             public byte[] generateDirectMethodHandleHolderClassBytes(
1758                     String className, MethodType[] methodTypes, int[] types) {
1759                 return GenerateJLIClassesHelper
1760                         .generateDirectMethodHandleHolderClassBytes(
1761                                 className, methodTypes, types);
1762             }
1763 
1764             @Override
1765             public byte[] generateDelegatingMethodHandleHolderClassBytes(
1766                     String className, MethodType[] methodTypes) {
1767                 return GenerateJLIClassesHelper
1768                         .generateDelegatingMethodHandleHolderClassBytes(
1769                                 className, methodTypes);
1770             }
1771 
1772             @Override
1773             public Map.Entry&lt;String, byte[]&gt; generateConcreteBMHClassBytes(
1774                     final String types) {
1775                 return GenerateJLIClassesHelper
1776                         .generateConcreteBMHClassBytes(types);
1777             }
1778 
1779             @Override
1780             public byte[] generateBasicFormsClassBytes(final String className) {
1781                 return GenerateJLIClassesHelper
1782                         .generateBasicFormsClassBytes(className);
1783             }
1784 
1785             @Override
1786             public byte[] generateInvokersHolderClassBytes(final String className,
1787                     MethodType[] invokerMethodTypes,
1788                     MethodType[] callSiteMethodTypes) {
1789                 return GenerateJLIClassesHelper
1790                         .generateInvokersHolderClassBytes(className,
1791                                 invokerMethodTypes, callSiteMethodTypes);
1792             }
1793 
1794             @Override
1795             public VarHandle memoryAddressViewVarHandle(Class&lt;?&gt; carrier, long alignmentMask,
1796                                                         ByteOrder order, long offset, long[] strides) {
1797                 return VarHandles.makeMemoryAddressViewHandle(carrier, alignmentMask, order, offset, strides);
1798             }
1799 
1800             @Override
1801             public Class&lt;?&gt; memoryAddressCarrier(VarHandle handle) {
1802                 return checkMemAccessHandle(handle).carrier();
1803             }
1804 
1805             @Override
1806             public long memoryAddressAlignmentMask(VarHandle handle) {
1807                 return checkMemAccessHandle(handle).alignmentMask;
1808             }
1809 
1810             @Override
1811             public ByteOrder memoryAddressByteOrder(VarHandle handle) {
1812                 return checkMemAccessHandle(handle).be ?
1813                         ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
1814             }
1815 
1816             @Override
1817             public long memoryAddressOffset(VarHandle handle) {
1818                 return checkMemAccessHandle(handle).offset;
1819             }
1820 
1821             @Override
1822             public long[] memoryAddressStrides(VarHandle handle) {
1823                 return checkMemAccessHandle(handle).strides();
1824             }
1825 
1826             private VarHandleMemoryAddressBase checkMemAccessHandle(VarHandle handle) {
1827                 if (!(handle.asDirect() instanceof VarHandleMemoryAddressBase)) {
1828                     throw new IllegalArgumentException(&quot;Not a memory access varhandle: &quot; + handle);
1829                 }
1830                 return (VarHandleMemoryAddressBase) handle.asDirect();
1831             }
1832         });
1833     }
1834 
1835     /** Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore(). */
1836     private static MethodHandle unboxResultHandle(Class&lt;?&gt; returnType) {
1837         if (returnType.isPrimitive()) {
1838             if (returnType == void.class) {
1839                 return ValueConversions.ignore();
1840             } else {
1841                 Wrapper w = Wrapper.forPrimitiveType(returnType);
1842                 return ValueConversions.unboxExact(w);
1843             }
1844         } else {
1845             return MethodHandles.identity(Object.class);
1846         }
1847     }
1848 
1849     /**
1850      * Assembles a loop method handle from the given handles and type information.
1851      *
1852      * @param tloop the return type of the loop.
1853      * @param targs types of the arguments to be passed to the loop.
1854      * @param init sanitized array of initializers for loop-local variables.
1855      * @param step sanitited array of loop bodies.
1856      * @param pred sanitized array of predicates.
1857      * @param fini sanitized array of loop finalizers.
1858      *
1859      * @return a handle that, when invoked, will execute the loop.
1860      */
1861     static MethodHandle makeLoop(Class&lt;?&gt; tloop, List&lt;Class&lt;?&gt;&gt; targs, List&lt;MethodHandle&gt; init, List&lt;MethodHandle&gt; step,
1862                                  List&lt;MethodHandle&gt; pred, List&lt;MethodHandle&gt; fini) {
1863         MethodType type = MethodType.methodType(tloop, targs);
1864         BasicType[] initClauseTypes =
1865                 init.stream().map(h -&gt; h.type().returnType()).map(BasicType::basicType).toArray(BasicType[]::new);
1866         LambdaForm form = makeLoopForm(type.basicType(), initClauseTypes);
1867 
1868         // Prepare auxiliary method handles used during LambdaForm interpretation.
1869         // Box arguments and wrap them into Object[]: ValueConversions.array().
1870         MethodType varargsType = type.changeReturnType(Object[].class);
1871         MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
1872         MethodHandle unboxResult = unboxResultHandle(tloop);
1873 
1874         LoopClauses clauseData =
1875                 new LoopClauses(new MethodHandle[][]{toArray(init), toArray(step), toArray(pred), toArray(fini)});
1876         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLL();
1877         BoundMethodHandle mh;
1878         try {
1879             mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) clauseData,
1880                     (Object) collectArgs, (Object) unboxResult);
1881         } catch (Throwable ex) {
1882             throw uncaughtException(ex);
1883         }
1884         assert(mh.type() == type);
1885         return mh;
1886     }
1887 
1888     private static MethodHandle[] toArray(List&lt;MethodHandle&gt; l) {
1889         return l.toArray(new MethodHandle[0]);
1890     }
1891 
1892     /**
1893      * Loops introduce some complexity as they can have additional local state. Hence, LambdaForms for loops are
1894      * generated from a template. The LambdaForm template shape for the loop combinator is as follows (assuming one
1895      * reference parameter passed in {@code a1}, and a reference return type, with the return value represented by
1896      * {@code t12}):
1897      * &lt;blockquote&gt;&lt;pre&gt;{@code
1898      *  loop=Lambda(a0:L,a1:L)=&gt;{
1899      *    t2:L=BoundMethodHandle$Species_L3.argL0(a0:L);    // LoopClauses holding init, step, pred, fini handles
1900      *    t3:L=BoundMethodHandle$Species_L3.argL1(a0:L);    // helper handle to box the arguments into an Object[]
1901      *    t4:L=BoundMethodHandle$Species_L3.argL2(a0:L);    // helper handle to unbox the result
1902      *    t5:L=MethodHandle.invokeBasic(t3:L,a1:L);         // box the arguments into an Object[]
1903      *    t6:L=MethodHandleImpl.loop(null,t2:L,t3:L);       // call the loop executor
1904      *    t7:L=MethodHandle.invokeBasic(t4:L,t6:L);t7:L}    // unbox the result; return the result
1905      * }&lt;/pre&gt;&lt;/blockquote&gt;
1906      * &lt;p&gt;
1907      * {@code argL0} is a LoopClauses instance holding, in a 2-dimensional array, the init, step, pred, and fini method
1908      * handles. {@code argL1} and {@code argL2} are auxiliary method handles: {@code argL1} boxes arguments and wraps
1909      * them into {@code Object[]} ({@code ValueConversions.array()}), and {@code argL2} unboxes the result if necessary
1910      * ({@code ValueConversions.unbox()}).
1911      * &lt;p&gt;
1912      * Having {@code t3} and {@code t4} passed in via a BMH and not hardcoded in the lambda form allows to share lambda
1913      * forms among loop combinators with the same basic type.
1914      * &lt;p&gt;
1915      * The above template is instantiated by using the {@link LambdaFormEditor} to replace the {@code null} argument to
1916      * the {@code loop} invocation with the {@code BasicType} array describing the loop clause types. This argument is
1917      * ignored in the loop invoker, but will be extracted and used in {@linkplain InvokerBytecodeGenerator#emitLoop(int)
1918      * bytecode generation}.
1919      */
1920     private static LambdaForm makeLoopForm(MethodType basicType, BasicType[] localVarTypes) {
1921         MethodType lambdaType = basicType.invokerType();
1922 
1923         final int THIS_MH = 0;  // the BMH_LLL
1924         final int ARG_BASE = 1; // start of incoming arguments
1925         final int ARG_LIMIT = ARG_BASE + basicType.parameterCount();
1926 
1927         int nameCursor = ARG_LIMIT;
1928         final int GET_CLAUSE_DATA = nameCursor++;
1929         final int GET_COLLECT_ARGS = nameCursor++;
1930         final int GET_UNBOX_RESULT = nameCursor++;
1931         final int BOXED_ARGS = nameCursor++;
1932         final int LOOP = nameCursor++;
1933         final int UNBOX_RESULT = nameCursor++;
1934 
1935         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_LOOP);
1936         if (lform == null) {
1937             Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
1938 
1939             BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLL();
1940             names[THIS_MH] = names[THIS_MH].withConstraint(data);
1941             names[GET_CLAUSE_DATA] = new Name(data.getterFunction(0), names[THIS_MH]);
1942             names[GET_COLLECT_ARGS] = new Name(data.getterFunction(1), names[THIS_MH]);
1943             names[GET_UNBOX_RESULT] = new Name(data.getterFunction(2), names[THIS_MH]);
1944 
1945             // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);
1946             MethodType collectArgsType = basicType.changeReturnType(Object.class);
1947             MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
1948             Object[] args = new Object[invokeBasic.type().parameterCount()];
1949             args[0] = names[GET_COLLECT_ARGS];
1950             System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT - ARG_BASE);
1951             names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.LOOP), args);
1952 
1953             // t_{i+1}:L=MethodHandleImpl.loop(localTypes:L,clauses:L,t_{i}:L);
1954             Object[] lArgs =
1955                     new Object[]{null, // placeholder for BasicType[] localTypes - will be added by LambdaFormEditor
1956                             names[GET_CLAUSE_DATA], names[BOXED_ARGS]};
1957             names[LOOP] = new Name(getFunction(NF_loop), lArgs);
1958 
1959             // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
1960             MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
1961             Object[] unboxArgs = new Object[]{names[GET_UNBOX_RESULT], names[LOOP]};
1962             names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
1963 
1964             lform = basicType.form().setCachedLambdaForm(MethodTypeForm.LF_LOOP,
1965                     new LambdaForm(lambdaType.parameterCount(), names, Kind.LOOP));
1966         }
1967 
1968         // BOXED_ARGS is the index into the names array where the loop idiom starts
1969         return lform.editor().noteLoopLocalTypesForm(BOXED_ARGS, localVarTypes);
1970     }
1971 
1972     static class LoopClauses {
1973         @Stable final MethodHandle[][] clauses;
1974         LoopClauses(MethodHandle[][] clauses) {
1975             assert clauses.length == 4;
1976             this.clauses = clauses;
1977         }
1978         @Override
1979         public String toString() {
1980             StringBuffer sb = new StringBuffer(&quot;LoopClauses -- &quot;);
1981             for (int i = 0; i &lt; 4; ++i) {
1982                 if (i &gt; 0) {
1983                     sb.append(&quot;       &quot;);
1984                 }
1985                 sb.append(&#39;&lt;&#39;).append(i).append(&quot;&gt;: &quot;);
1986                 MethodHandle[] hs = clauses[i];
1987                 for (int j = 0; j &lt; hs.length; ++j) {
1988                     if (j &gt; 0) {
1989                         sb.append(&quot;          &quot;);
1990                     }
1991                     sb.append(&#39;*&#39;).append(j).append(&quot;: &quot;).append(hs[j]).append(&#39;\n&#39;);
1992                 }
1993             }
1994             sb.append(&quot; --\n&quot;);
1995             return sb.toString();
1996         }
1997     }
1998 
1999     /**
2000      * Intrinsified during LambdaForm compilation
2001      * (see {@link InvokerBytecodeGenerator#emitLoop(int)}).
2002      */
2003     @Hidden
2004     static Object loop(BasicType[] localTypes, LoopClauses clauseData, Object... av) throws Throwable {
2005         final MethodHandle[] init = clauseData.clauses[0];
2006         final MethodHandle[] step = clauseData.clauses[1];
2007         final MethodHandle[] pred = clauseData.clauses[2];
2008         final MethodHandle[] fini = clauseData.clauses[3];
2009         int varSize = (int) Stream.of(init).filter(h -&gt; h.type().returnType() != void.class).count();
2010         int nArgs = init[0].type().parameterCount();
2011         Object[] varsAndArgs = new Object[varSize + nArgs];
2012         for (int i = 0, v = 0; i &lt; init.length; ++i) {
2013             MethodHandle ih = init[i];
2014             if (ih.type().returnType() == void.class) {
2015                 ih.invokeWithArguments(av);
2016             } else {
2017                 varsAndArgs[v++] = ih.invokeWithArguments(av);
2018             }
2019         }
2020         System.arraycopy(av, 0, varsAndArgs, varSize, nArgs);
2021         final int nSteps = step.length;
2022         for (; ; ) {
2023             for (int i = 0, v = 0; i &lt; nSteps; ++i) {
2024                 MethodHandle p = pred[i];
2025                 MethodHandle s = step[i];
2026                 MethodHandle f = fini[i];
2027                 if (s.type().returnType() == void.class) {
2028                     s.invokeWithArguments(varsAndArgs);
2029                 } else {
2030                     varsAndArgs[v++] = s.invokeWithArguments(varsAndArgs);
2031                 }
2032                 if (!(boolean) p.invokeWithArguments(varsAndArgs)) {
2033                     return f.invokeWithArguments(varsAndArgs);
2034                 }
2035             }
2036         }
2037     }
2038 
2039     /**
2040      * This method is bound as the predicate in {@linkplain MethodHandles#countedLoop(MethodHandle, MethodHandle,
2041      * MethodHandle) counting loops}.
2042      *
2043      * @param limit the upper bound of the parameter, statically bound at loop creation time.
2044      * @param counter the counter parameter, passed in during loop execution.
2045      *
2046      * @return whether the counter has reached the limit.
2047      */
2048     static boolean countedLoopPredicate(int limit, int counter) {
2049         return counter &lt; limit;
2050     }
2051 
2052     /**
2053      * This method is bound as the step function in {@linkplain MethodHandles#countedLoop(MethodHandle, MethodHandle,
2054      * MethodHandle) counting loops} to increment the counter.
2055      *
2056      * @param limit the upper bound of the loop counter (ignored).
2057      * @param counter the loop counter.
2058      *
2059      * @return the loop counter incremented by 1.
2060      */
2061     static int countedLoopStep(int limit, int counter) {
2062         return counter + 1;
2063     }
2064 
2065     /**
2066      * This is bound to initialize the loop-local iterator in {@linkplain MethodHandles#iteratedLoop iterating loops}.
2067      *
2068      * @param it the {@link Iterable} over which the loop iterates.
2069      *
2070      * @return an {@link Iterator} over the argument&#39;s elements.
2071      */
2072     static Iterator&lt;?&gt; initIterator(Iterable&lt;?&gt; it) {
2073         return it.iterator();
2074     }
2075 
2076     /**
2077      * This method is bound as the predicate in {@linkplain MethodHandles#iteratedLoop iterating loops}.
2078      *
2079      * @param it the iterator to be checked.
2080      *
2081      * @return {@code true} iff there are more elements to iterate over.
2082      */
2083     static boolean iteratePredicate(Iterator&lt;?&gt; it) {
2084         return it.hasNext();
2085     }
2086 
2087     /**
2088      * This method is bound as the step for retrieving the current value from the iterator in {@linkplain
2089      * MethodHandles#iteratedLoop iterating loops}.
2090      *
2091      * @param it the iterator.
2092      *
2093      * @return the next element from the iterator.
2094      */
2095     static Object iterateNext(Iterator&lt;?&gt; it) {
2096         return it.next();
2097     }
2098 
2099     /**
2100      * Makes a {@code try-finally} handle that conforms to the type constraints.
2101      *
2102      * @param target the target to execute in a {@code try-finally} block.
2103      * @param cleanup the cleanup to execute in the {@code finally} block.
2104      * @param rtype the result type of the entire construct.
2105      * @param argTypes the types of the arguments.
2106      *
2107      * @return a handle on the constructed {@code try-finally} block.
2108      */
2109     static MethodHandle makeTryFinally(MethodHandle target, MethodHandle cleanup, Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; argTypes) {
2110         MethodType type = MethodType.methodType(rtype, argTypes);
2111         LambdaForm form = makeTryFinallyForm(type.basicType());
2112 
2113         // Prepare auxiliary method handles used during LambdaForm interpretation.
2114         // Box arguments and wrap them into Object[]: ValueConversions.array().
2115         MethodType varargsType = type.changeReturnType(Object[].class);
2116         MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
2117         MethodHandle unboxResult = unboxResultHandle(rtype);
2118 
2119         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLL();
2120         BoundMethodHandle mh;
2121         try {
2122             mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) target, (Object) cleanup,
2123                     (Object) collectArgs, (Object) unboxResult);
2124         } catch (Throwable ex) {
2125             throw uncaughtException(ex);
2126         }
2127         assert(mh.type() == type);
2128         return mh;
2129     }
2130 
2131     /**
2132      * The LambdaForm shape for the tryFinally combinator is as follows (assuming one reference parameter passed in
2133      * {@code a1}, and a reference return type, with the return value represented by {@code t8}):
2134      * &lt;blockquote&gt;&lt;pre&gt;{@code
2135      *  tryFinally=Lambda(a0:L,a1:L)=&gt;{
2136      *    t2:L=BoundMethodHandle$Species_LLLL.argL0(a0:L);  // target method handle
2137      *    t3:L=BoundMethodHandle$Species_LLLL.argL1(a0:L);  // cleanup method handle
2138      *    t4:L=BoundMethodHandle$Species_LLLL.argL2(a0:L);  // helper handle to box the arguments into an Object[]
2139      *    t5:L=BoundMethodHandle$Species_LLLL.argL3(a0:L);  // helper handle to unbox the result
2140      *    t6:L=MethodHandle.invokeBasic(t4:L,a1:L);         // box the arguments into an Object[]
2141      *    t7:L=MethodHandleImpl.tryFinally(t2:L,t3:L,t6:L); // call the tryFinally executor
2142      *    t8:L=MethodHandle.invokeBasic(t5:L,t7:L);t8:L}    // unbox the result; return the result
2143      * }&lt;/pre&gt;&lt;/blockquote&gt;
2144      * &lt;p&gt;
2145      * {@code argL0} and {@code argL1} are the target and cleanup method handles.
2146      * {@code argL2} and {@code argL3} are auxiliary method handles: {@code argL2} boxes arguments and wraps them into
2147      * {@code Object[]} ({@code ValueConversions.array()}), and {@code argL3} unboxes the result if necessary
2148      * ({@code ValueConversions.unbox()}).
2149      * &lt;p&gt;
2150      * Having {@code t4} and {@code t5} passed in via a BMH and not hardcoded in the lambda form allows to share lambda
2151      * forms among tryFinally combinators with the same basic type.
2152      */
2153     private static LambdaForm makeTryFinallyForm(MethodType basicType) {
2154         MethodType lambdaType = basicType.invokerType();
2155 
2156         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_TF);
2157         if (lform != null) {
2158             return lform;
2159         }
2160         final int THIS_MH      = 0;  // the BMH_LLLL
2161         final int ARG_BASE     = 1;  // start of incoming arguments
2162         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
2163 
2164         int nameCursor = ARG_LIMIT;
2165         final int GET_TARGET       = nameCursor++;
2166         final int GET_CLEANUP      = nameCursor++;
2167         final int GET_COLLECT_ARGS = nameCursor++;
2168         final int GET_UNBOX_RESULT = nameCursor++;
2169         final int BOXED_ARGS       = nameCursor++;
2170         final int TRY_FINALLY      = nameCursor++;
2171         final int UNBOX_RESULT     = nameCursor++;
2172 
2173         Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
2174 
2175         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLL();
2176         names[THIS_MH]          = names[THIS_MH].withConstraint(data);
2177         names[GET_TARGET]       = new Name(data.getterFunction(0), names[THIS_MH]);
2178         names[GET_CLEANUP]      = new Name(data.getterFunction(1), names[THIS_MH]);
2179         names[GET_COLLECT_ARGS] = new Name(data.getterFunction(2), names[THIS_MH]);
2180         names[GET_UNBOX_RESULT] = new Name(data.getterFunction(3), names[THIS_MH]);
2181 
2182         // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);
2183         MethodType collectArgsType = basicType.changeReturnType(Object.class);
2184         MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
2185         Object[] args = new Object[invokeBasic.type().parameterCount()];
2186         args[0] = names[GET_COLLECT_ARGS];
2187         System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT-ARG_BASE);
2188         names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.TRY_FINALLY), args);
2189 
2190         // t_{i+1}:L=MethodHandleImpl.tryFinally(target:L,exType:L,catcher:L,t_{i}:L);
2191         Object[] tfArgs = new Object[] {names[GET_TARGET], names[GET_CLEANUP], names[BOXED_ARGS]};
2192         names[TRY_FINALLY] = new Name(getFunction(NF_tryFinally), tfArgs);
2193 
2194         // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
2195         MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
2196         Object[] unboxArgs  = new Object[] {names[GET_UNBOX_RESULT], names[TRY_FINALLY]};
2197         names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
2198 
2199         lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.TRY_FINALLY);
2200 
2201         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_TF, lform);
2202     }
2203 
2204     /**
2205      * Intrinsified during LambdaForm compilation
2206      * (see {@link InvokerBytecodeGenerator#emitTryFinally emitTryFinally}).
2207      */
2208     @Hidden
2209     static Object tryFinally(MethodHandle target, MethodHandle cleanup, Object... av) throws Throwable {
2210         Throwable t = null;
2211         Object r = null;
2212         try {
2213             r = target.invokeWithArguments(av);
2214         } catch (Throwable thrown) {
2215             t = thrown;
2216             throw t;
2217         } finally {
2218             Object[] args = target.type().returnType() == void.class ? prepend(av, t) : prepend(av, t, r);
2219             r = cleanup.invokeWithArguments(args);
2220         }
2221         return r;
2222     }
2223 
2224     // Indexes into constant method handles:
2225     static final int
2226             MH_cast                  =  0,
2227             MH_selectAlternative     =  1,
2228             MH_copyAsPrimitiveArray  =  2,
2229             MH_fillNewTypedArray     =  3,
2230             MH_fillNewArray          =  4,
2231             MH_arrayIdentity         =  5,
2232             MH_countedLoopPred       =  6,
2233             MH_countedLoopStep       =  7,
2234             MH_initIterator          =  8,
2235             MH_iteratePred           =  9,
2236             MH_iterateNext           = 10,
2237             MH_Array_newInstance     = 11,
2238             MH_LIMIT                 = 12;
2239 
2240     static MethodHandle getConstantHandle(int idx) {
2241         MethodHandle handle = HANDLES[idx];
2242         if (handle != null) {
2243             return handle;
2244         }
2245         return setCachedHandle(idx, makeConstantHandle(idx));
2246     }
2247 
2248     private static synchronized MethodHandle setCachedHandle(int idx, final MethodHandle method) {
2249         // Simulate a CAS, to avoid racy duplication of results.
2250         MethodHandle prev = HANDLES[idx];
2251         if (prev != null) {
2252             return prev;
2253         }
2254         HANDLES[idx] = method;
2255         return method;
2256     }
2257 
2258     // Local constant method handles:
2259     private static final @Stable MethodHandle[] HANDLES = new MethodHandle[MH_LIMIT];
2260 
2261     private static MethodHandle makeConstantHandle(int idx) {
2262         try {
2263             switch (idx) {
2264                 case MH_cast:
2265                     return IMPL_LOOKUP.findVirtual(Class.class, &quot;cast&quot;,
2266                             MethodType.methodType(Object.class, Object.class));
2267                 case MH_copyAsPrimitiveArray:
2268                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;copyAsPrimitiveArray&quot;,
2269                             MethodType.methodType(Object.class, Wrapper.class, Object[].class));
2270                 case MH_arrayIdentity:
2271                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;identity&quot;,
2272                             MethodType.methodType(Object[].class, Object[].class));
2273                 case MH_fillNewArray:
2274                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;fillNewArray&quot;,
2275                             MethodType.methodType(Object[].class, Integer.class, Object[].class));
2276                 case MH_fillNewTypedArray:
2277                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;fillNewTypedArray&quot;,
2278                             MethodType.methodType(Object[].class, Object[].class, Integer.class, Object[].class));
2279                 case MH_selectAlternative:
2280                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;selectAlternative&quot;,
2281                             MethodType.methodType(MethodHandle.class, boolean.class, MethodHandle.class, MethodHandle.class));
2282                 case MH_countedLoopPred:
2283                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;countedLoopPredicate&quot;,
2284                             MethodType.methodType(boolean.class, int.class, int.class));
2285                 case MH_countedLoopStep:
2286                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;countedLoopStep&quot;,
2287                             MethodType.methodType(int.class, int.class, int.class));
2288                 case MH_initIterator:
2289                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;initIterator&quot;,
2290                             MethodType.methodType(Iterator.class, Iterable.class));
2291                 case MH_iteratePred:
2292                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;iteratePredicate&quot;,
2293                             MethodType.methodType(boolean.class, Iterator.class));
2294                 case MH_iterateNext:
2295                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;iterateNext&quot;,
2296                             MethodType.methodType(Object.class, Iterator.class));
2297                 case MH_Array_newInstance:
2298                     return IMPL_LOOKUP.findStatic(Array.class, &quot;newInstance&quot;,
2299                             MethodType.methodType(Object.class, Class.class, int.class));
2300             }
2301         } catch (ReflectiveOperationException ex) {
2302             throw newInternalError(ex);
2303         }
2304         throw newInternalError(&quot;Unknown function index: &quot; + idx);
2305     }
2306 }
    </pre>
  </body>
</html>
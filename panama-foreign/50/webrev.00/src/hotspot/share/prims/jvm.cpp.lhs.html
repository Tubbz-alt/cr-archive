<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileStream.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  30 #include &quot;classfile/javaAssertions.hpp&quot;
  31 #include &quot;classfile/javaClasses.inline.hpp&quot;
  32 #include &quot;classfile/moduleEntry.hpp&quot;
  33 #include &quot;classfile/modules.hpp&quot;
  34 #include &quot;classfile/packageEntry.hpp&quot;
  35 #include &quot;classfile/stringTable.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/heapShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/referenceType.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/method.hpp&quot;
  54 #include &quot;oops/recordComponent.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;prims/jvm_misc.hpp&quot;
  59 #include &quot;prims/jvmtiExport.hpp&quot;
  60 #include &quot;prims/jvmtiThreadState.hpp&quot;
  61 #include &quot;prims/nativeLookup.hpp&quot;
  62 #include &quot;prims/stackwalk.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/atomic.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/init.hpp&quot;
  67 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  68 #include &quot;runtime/deoptimization.hpp&quot;
  69 #include &quot;runtime/handshake.hpp&quot;
  70 #include &quot;runtime/java.hpp&quot;
  71 #include &quot;runtime/javaCalls.hpp&quot;
  72 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  73 #include &quot;runtime/jniHandles.inline.hpp&quot;
  74 #include &quot;runtime/os.inline.hpp&quot;
  75 #include &quot;runtime/perfData.hpp&quot;
  76 #include &quot;runtime/reflection.hpp&quot;
  77 #include &quot;runtime/thread.inline.hpp&quot;
  78 #include &quot;runtime/threadSMR.hpp&quot;
  79 #include &quot;runtime/vframe.inline.hpp&quot;
  80 #include &quot;runtime/vmOperations.hpp&quot;
  81 #include &quot;runtime/vm_version.hpp&quot;
  82 #include &quot;services/attachListener.hpp&quot;
  83 #include &quot;services/management.hpp&quot;
  84 #include &quot;services/threadService.hpp&quot;
  85 #include &quot;utilities/copy.hpp&quot;
  86 #include &quot;utilities/defaultStream.hpp&quot;
  87 #include &quot;utilities/dtrace.hpp&quot;
  88 #include &quot;utilities/events.hpp&quot;
  89 #include &quot;utilities/histogram.hpp&quot;
  90 #include &quot;utilities/macros.hpp&quot;
  91 #include &quot;utilities/utf8.hpp&quot;
  92 #if INCLUDE_CDS
  93 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  94 #endif
  95 
  96 #include &lt;errno.h&gt;
  97 #include &lt;jfr/recorder/jfrRecorder.hpp&gt;
  98 
  99 /*
 100   NOTE about use of any ctor or function call that can trigger a safepoint/GC:
 101   such ctors and calls MUST NOT come between an oop declaration/init and its
 102   usage because if objects are move this may cause various memory stomps, bus
 103   errors and segfaults. Here is a cookbook for causing so called &quot;naked oop
 104   failures&quot;:
 105 
 106       JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields&lt;etc&gt; {
 107           JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
 108 
 109           // Object address to be held directly in mirror &amp; not visible to GC
 110           oop mirror = JNIHandles::resolve_non_null(ofClass);
 111 
 112           // If this ctor can hit a safepoint, moving objects around, then
 113           ComplexConstructor foo;
 114 
 115           // Boom! mirror may point to JUNK instead of the intended object
 116           (some dereference of mirror)
 117 
 118           // Here&#39;s another call that may block for GC, making mirror stale
 119           MutexLocker ml(some_lock);
 120 
 121           // And here&#39;s an initializer that can result in a stale oop
 122           // all in one step.
 123           oop o = call_that_can_throw_exception(TRAPS);
 124 
 125 
 126   The solution is to keep the oop declaration BELOW the ctor or function
 127   call that might cause a GC, do another resolve to reassign the oop, or
 128   consider use of a Handle instead of an oop so there is immunity from object
 129   motion. But note that the &quot;QUICK&quot; entries below do not have a handlemark
 130   and thus can only support use of handles passed in.
 131 */
 132 
 133 static void trace_class_resolution_impl(Klass* to_class, TRAPS) {
 134   ResourceMark rm;
 135   int line_number = -1;
 136   const char * source_file = NULL;
 137   const char * trace = &quot;explicit&quot;;
 138   InstanceKlass* caller = NULL;
 139   JavaThread* jthread = JavaThread::current();
 140   if (jthread-&gt;has_last_Java_frame()) {
 141     vframeStream vfst(jthread);
 142 
 143     // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
 144     TempNewSymbol access_controller = SymbolTable::new_symbol(&quot;java/security/AccessController&quot;);
 145     Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
 146     TempNewSymbol privileged_action = SymbolTable::new_symbol(&quot;java/security/PrivilegedAction&quot;);
 147     Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
 148 
 149     Method* last_caller = NULL;
 150 
 151     while (!vfst.at_end()) {
 152       Method* m = vfst.method();
 153       if (!vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass())&amp;&amp;
 154           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(access_controller_klass) &amp;&amp;
 155           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(privileged_action_klass)) {
 156         break;
 157       }
 158       last_caller = m;
 159       vfst.next();
 160     }
 161     // if this is called from Class.forName0 and that is called from Class.forName,
 162     // then print the caller of Class.forName.  If this is Class.loadClass, then print
 163     // that caller, otherwise keep quiet since this should be picked up elsewhere.
 164     bool found_it = false;
 165     if (!vfst.at_end() &amp;&amp;
 166         vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 167         vfst.method()-&gt;name() == vmSymbols::forName0_name()) {
 168       vfst.next();
 169       if (!vfst.at_end() &amp;&amp;
 170           vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 171           vfst.method()-&gt;name() == vmSymbols::forName_name()) {
 172         vfst.next();
 173         found_it = true;
 174       }
 175     } else if (last_caller != NULL &amp;&amp;
 176                last_caller-&gt;method_holder()-&gt;name() ==
 177                  vmSymbols::java_lang_ClassLoader() &amp;&amp;
 178                last_caller-&gt;name() == vmSymbols::loadClass_name()) {
 179       found_it = true;
 180     } else if (!vfst.at_end()) {
 181       if (vfst.method()-&gt;is_native()) {
 182         // JNI call
 183         found_it = true;
 184       }
 185     }
 186     if (found_it &amp;&amp; !vfst.at_end()) {
 187       // found the caller
 188       caller = vfst.method()-&gt;method_holder();
 189       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 190       if (line_number == -1) {
 191         // show method name if it&#39;s a native method
 192         trace = vfst.method()-&gt;name_and_sig_as_C_string();
 193       }
 194       Symbol* s = caller-&gt;source_file_name();
 195       if (s != NULL) {
 196         source_file = s-&gt;as_C_string();
 197       }
 198     }
 199   }
 200   if (caller != NULL) {
 201     if (to_class != caller) {
 202       const char * from = caller-&gt;external_name();
 203       const char * to = to_class-&gt;external_name();
 204       // print in a single call to reduce interleaving between threads
 205       if (source_file != NULL) {
 206         log_debug(class, resolve)(&quot;%s %s %s:%d (%s)&quot;, from, to, source_file, line_number, trace);
 207       } else {
 208         log_debug(class, resolve)(&quot;%s %s (%s)&quot;, from, to, trace);
 209       }
 210     }
 211   }
 212 }
 213 
 214 void trace_class_resolution(Klass* to_class) {
 215   EXCEPTION_MARK;
 216   trace_class_resolution_impl(to_class, THREAD);
 217   if (HAS_PENDING_EXCEPTION) {
 218     CLEAR_PENDING_EXCEPTION;
 219   }
 220 }
 221 
 222 // Wrapper to trace JVM functions
 223 
 224 #ifdef ASSERT
 225   Histogram* JVMHistogram;
 226   volatile int JVMHistogram_lock = 0;
 227 
 228   class JVMHistogramElement : public HistogramElement {
 229     public:
 230      JVMHistogramElement(const char* name);
 231   };
 232 
 233   JVMHistogramElement::JVMHistogramElement(const char* elementName) {
 234     _name = elementName;
 235     uintx count = 0;
 236 
 237     while (Atomic::cmpxchg(&amp;JVMHistogram_lock, 0, 1) != 0) {
 238       while (Atomic::load_acquire(&amp;JVMHistogram_lock) != 0) {
 239         count +=1;
 240         if ( (WarnOnStalledSpinLock &gt; 0)
 241           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 242           warning(&quot;JVMHistogram_lock seems to be stalled&quot;);
 243         }
 244       }
 245      }
 246 
 247     if(JVMHistogram == NULL)
 248       JVMHistogram = new Histogram(&quot;JVM Call Counts&quot;,100);
 249 
 250     JVMHistogram-&gt;add_element(this);
 251     Atomic::dec(&amp;JVMHistogram_lock);
 252   }
 253 
 254   #define JVMCountWrapper(arg) \
 255       static JVMHistogramElement* e = new JVMHistogramElement(arg); \
 256       if (e != NULL) e-&gt;increment_count();  // Due to bug in VC++, we need a NULL check here eventhough it should never happen!
 257 
 258   #define JVMWrapper(arg) JVMCountWrapper(arg);
 259 #else
 260   #define JVMWrapper(arg)
 261 #endif
 262 
 263 
 264 // Interface version /////////////////////////////////////////////////////////////////////
 265 
 266 
 267 JVM_LEAF(jint, JVM_GetInterfaceVersion())
 268   return JVM_INTERFACE_VERSION;
 269 JVM_END
 270 
 271 
 272 // java.lang.System //////////////////////////////////////////////////////////////////////
 273 
 274 
 275 JVM_LEAF(jlong, JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored))
 276   JVMWrapper(&quot;JVM_CurrentTimeMillis&quot;);
 277   return os::javaTimeMillis();
 278 JVM_END
 279 
 280 JVM_LEAF(jlong, JVM_NanoTime(JNIEnv *env, jclass ignored))
 281   JVMWrapper(&quot;JVM_NanoTime&quot;);
 282   return os::javaTimeNanos();
 283 JVM_END
 284 
 285 // The function below is actually exposed by jdk.internal.misc.VM and not
 286 // java.lang.System, but we choose to keep it here so that it stays next
 287 // to JVM_CurrentTimeMillis and JVM_NanoTime
 288 
 289 const jlong MAX_DIFF_SECS = CONST64(0x0100000000); //  2^32
 290 const jlong MIN_DIFF_SECS = -MAX_DIFF_SECS; // -2^32
 291 
 292 JVM_LEAF(jlong, JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs))
 293   JVMWrapper(&quot;JVM_GetNanoTimeAdjustment&quot;);
 294   jlong seconds;
 295   jlong nanos;
 296 
 297   os::javaTimeSystemUTC(seconds, nanos);
 298 
 299   // We&#39;re going to verify that the result can fit in a long.
 300   // For that we need the difference in seconds between &#39;seconds&#39;
 301   // and &#39;offset_secs&#39; to be such that:
 302   //     |seconds - offset_secs| &lt; (2^63/10^9)
 303   // We&#39;re going to approximate 10^9 ~&lt; 2^30 (1000^3 ~&lt; 1024^3)
 304   // which makes |seconds - offset_secs| &lt; 2^33
 305   // and we will prefer +/- 2^32 as the maximum acceptable diff
 306   // as 2^32 has a more natural feel than 2^33...
 307   //
 308   // So if |seconds - offset_secs| &gt;= 2^32 - we return a special
 309   // sentinel value (-1) which the caller should take as an
 310   // exception value indicating that the offset given to us is
 311   // too far from range of the current time - leading to too big
 312   // a nano adjustment. The caller is expected to recover by
 313   // computing a more accurate offset and calling this method
 314   // again. (For the record 2^32 secs is ~136 years, so that
 315   // should rarely happen)
 316   //
 317   jlong diff = seconds - offset_secs;
 318   if (diff &gt;= MAX_DIFF_SECS || diff &lt;= MIN_DIFF_SECS) {
 319      return -1; // sentinel value: the offset is too far off the target
 320   }
 321 
 322   // return the adjustment. If you compute a time by adding
 323   // this number of nanoseconds along with the number of seconds
 324   // in the offset you should get the current UTC time.
 325   return (diff * (jlong)1000000000) + nanos;
 326 JVM_END
 327 
 328 JVM_ENTRY(void, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 329                                jobject dst, jint dst_pos, jint length))
 330   JVMWrapper(&quot;JVM_ArrayCopy&quot;);
 331   // Check if we have null pointers
 332   if (src == NULL || dst == NULL) {
 333     THROW(vmSymbols::java_lang_NullPointerException());
 334   }
 335   arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));
 336   arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));
 337   assert(oopDesc::is_oop(s), &quot;JVM_ArrayCopy: src not an oop&quot;);
 338   assert(oopDesc::is_oop(d), &quot;JVM_ArrayCopy: dst not an oop&quot;);
 339   // Do copy
 340   s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);
 341 JVM_END
 342 
 343 
 344 static void set_property(Handle props, const char* key, const char* value, TRAPS) {
 345   JavaValue r(T_OBJECT);
 346   // public synchronized Object put(Object key, Object value);
 347   HandleMark hm(THREAD);
 348   Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK);
 349   Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK);
 350   JavaCalls::call_virtual(&amp;r,
 351                           props,
 352                           SystemDictionary::Properties_klass(),
 353                           vmSymbols::put_name(),
 354                           vmSymbols::object_object_object_signature(),
 355                           key_str,
 356                           value_str,
 357                           THREAD);
 358 }
 359 
 360 
 361 #define PUTPROP(props, name, value) set_property((props), (name), (value), CHECK_(properties));
 362 
 363 /*
 364  * Return all of the system properties in a Java String array with alternating
 365  * names and values from the jvm SystemProperty.
 366  * Which includes some internal and all commandline -D defined properties.
 367  */
 368 JVM_ENTRY(jobjectArray, JVM_GetProperties(JNIEnv *env))
 369   JVMWrapper(&quot;JVM_GetProperties&quot;);
 370   ResourceMark rm(THREAD);
 371   HandleMark hm(THREAD);
 372   int ndx = 0;
 373   int fixedCount = 2;
 374 
 375   SystemProperty* p = Arguments::system_properties();
 376   int count = Arguments::PropertyList_count(p);
 377 
 378   // Allocate result String array
 379   InstanceKlass* ik = SystemDictionary::String_klass();
 380   objArrayOop r = oopFactory::new_objArray(ik, (count + fixedCount) * 2, CHECK_NULL);
 381   objArrayHandle result_h(THREAD, r);
 382 
 383   while (p != NULL) {
 384     const char * key = p-&gt;key();
 385     if (strcmp(key, &quot;sun.nio.MaxDirectMemorySize&quot;) != 0) {
 386         const char * value = p-&gt;value();
 387         Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK_NULL);
 388         Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK_NULL);
 389         result_h-&gt;obj_at_put(ndx * 2,  key_str());
 390         result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 391         ndx++;
 392     }
 393     p = p-&gt;next();
 394   }
 395 
 396   // Convert the -XX:MaxDirectMemorySize= command line flag
 397   // to the sun.nio.MaxDirectMemorySize property.
 398   // Do this after setting user properties to prevent people
 399   // from setting the value with a -D option, as requested.
 400   // Leave empty if not supplied
 401   if (!FLAG_IS_DEFAULT(MaxDirectMemorySize)) {
 402     char as_chars[256];
 403     jio_snprintf(as_chars, sizeof(as_chars), JULONG_FORMAT, MaxDirectMemorySize);
 404     Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.nio.MaxDirectMemorySize&quot;, CHECK_NULL);
 405     Handle value_str  = java_lang_String::create_from_platform_dependent_str(as_chars, CHECK_NULL);
 406     result_h-&gt;obj_at_put(ndx * 2,  key_str());
 407     result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 408     ndx++;
 409   }
 410 
 411   // JVM monitoring and management support
 412   // Add the sun.management.compiler property for the compiler&#39;s name
 413   {
 414 #undef CSIZE
 415 #if defined(_LP64) || defined(_WIN64)
 416   #define CSIZE &quot;64-Bit &quot;
 417 #else
 418   #define CSIZE
 419 #endif // 64bit
 420 
 421 #ifdef TIERED
 422     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Tiered Compilers&quot;;
 423 #else
 424 #if defined(COMPILER1)
 425     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Client Compiler&quot;;
 426 #elif defined(COMPILER2)
 427     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Server Compiler&quot;;
 428 #elif INCLUDE_JVMCI
 429     #error &quot;INCLUDE_JVMCI should imply TIERED&quot;
 430 #else
 431     const char* compiler_name = &quot;&quot;;
 432 #endif // compilers
 433 #endif // TIERED
 434 
 435     if (*compiler_name != &#39;\0&#39; &amp;&amp;
 436         (Arguments::mode() != Arguments::_int)) {
 437       Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.management.compiler&quot;, CHECK_NULL);
 438       Handle value_str  = java_lang_String::create_from_platform_dependent_str(compiler_name, CHECK_NULL);
 439       result_h-&gt;obj_at_put(ndx * 2,  key_str());
 440       result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 441       ndx++;
 442     }
 443   }
 444 
 445   return (jobjectArray) JNIHandles::make_local(env, result_h());
 446 JVM_END
 447 
 448 
 449 /*
 450  * Return the temporary directory that the VM uses for the attach
 451  * and perf data files.
 452  *
 453  * It is important that this directory is well-known and the
 454  * same for all VM instances. It cannot be affected by configuration
 455  * variables such as java.io.tmpdir.
 456  */
 457 JVM_ENTRY(jstring, JVM_GetTemporaryDirectory(JNIEnv *env))
 458   JVMWrapper(&quot;JVM_GetTemporaryDirectory&quot;);
 459   HandleMark hm(THREAD);
 460   const char* temp_dir = os::get_temp_directory();
 461   Handle h = java_lang_String::create_from_platform_dependent_str(temp_dir, CHECK_NULL);
 462   return (jstring) JNIHandles::make_local(env, h());
 463 JVM_END
 464 
 465 
 466 // java.lang.Runtime /////////////////////////////////////////////////////////////////////////
 467 
 468 extern volatile jint vm_created;
 469 
 470 JVM_ENTRY_NO_ENV(void, JVM_BeforeHalt())
 471   JVMWrapper(&quot;JVM_BeforeHalt&quot;);
<a name="1" id="anc1"></a>



 472   EventShutdown event;
 473   if (event.should_commit()) {
 474     event.set_reason(&quot;Shutdown requested from Java&quot;);
 475     event.commit();
 476   }
 477 JVM_END
 478 
 479 
 480 JVM_ENTRY_NO_ENV(void, JVM_Halt(jint code))
 481   before_exit(thread);
 482   vm_exit(code);
 483 JVM_END
 484 
 485 
 486 JVM_ENTRY_NO_ENV(void, JVM_GC(void))
 487   JVMWrapper(&quot;JVM_GC&quot;);
 488   if (!DisableExplicitGC) {
 489     Universe::heap()-&gt;collect(GCCause::_java_lang_system_gc);
 490   }
 491 JVM_END
 492 
 493 
 494 JVM_LEAF(jlong, JVM_MaxObjectInspectionAge(void))
 495   JVMWrapper(&quot;JVM_MaxObjectInspectionAge&quot;);
 496   return Universe::heap()-&gt;millis_since_last_gc();
 497 JVM_END
 498 
 499 
 500 static inline jlong convert_size_t_to_jlong(size_t val) {
 501   // In the 64-bit vm, a size_t can overflow a jlong (which is signed).
 502   NOT_LP64 (return (jlong)val;)
 503   LP64_ONLY(return (jlong)MIN2(val, (size_t)max_jlong);)
 504 }
 505 
 506 JVM_ENTRY_NO_ENV(jlong, JVM_TotalMemory(void))
 507   JVMWrapper(&quot;JVM_TotalMemory&quot;);
 508   size_t n = Universe::heap()-&gt;capacity();
 509   return convert_size_t_to_jlong(n);
 510 JVM_END
 511 
 512 
 513 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 514   JVMWrapper(&quot;JVM_FreeMemory&quot;);
 515   size_t n = Universe::heap()-&gt;unused();
 516   return convert_size_t_to_jlong(n);
 517 JVM_END
 518 
 519 
 520 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 521   JVMWrapper(&quot;JVM_MaxMemory&quot;);
 522   size_t n = Universe::heap()-&gt;max_capacity();
 523   return convert_size_t_to_jlong(n);
 524 JVM_END
 525 
 526 
 527 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 528   JVMWrapper(&quot;JVM_ActiveProcessorCount&quot;);
 529   return os::active_processor_count();
 530 JVM_END
 531 
 532 
 533 
 534 // java.lang.Throwable //////////////////////////////////////////////////////
 535 
 536 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
 537   JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
 538   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 539   java_lang_Throwable::fill_in_stack_trace(exception);
 540 JVM_END
 541 
 542 // java.lang.NullPointerException ///////////////////////////////////////////
 543 
 544 JVM_ENTRY(jstring, JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable))
 545   if (!ShowCodeDetailsInExceptionMessages) return NULL;
 546 
 547   oop exc = JNIHandles::resolve_non_null(throwable);
 548 
 549   Method* method;
 550   int bci;
 551   if (!java_lang_Throwable::get_top_method_and_bci(exc, &amp;method, &amp;bci)) {
 552     return NULL;
 553   }
 554   if (method-&gt;is_native()) {
 555     return NULL;
 556   }
 557 
 558   stringStream ss;
 559   bool ok = BytecodeUtils::get_NPE_message_at(&amp;ss, method, bci);
 560   if (ok) {
 561     oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_NULL);
 562     return (jstring) JNIHandles::make_local(env, result);
 563   } else {
 564     return NULL;
 565   }
 566 JVM_END
 567 
 568 // java.lang.StackTraceElement //////////////////////////////////////////////
 569 
 570 
 571 JVM_ENTRY(void, JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable))
 572   JVMWrapper(&quot;JVM_InitStackTraceElementArray&quot;);
 573   Handle exception(THREAD, JNIHandles::resolve(throwable));
 574   objArrayOop st = objArrayOop(JNIHandles::resolve(elements));
 575   objArrayHandle stack_trace(THREAD, st);
 576   // Fill in the allocated stack trace
 577   java_lang_Throwable::get_stack_trace_elements(exception, stack_trace, CHECK);
 578 JVM_END
 579 
 580 
 581 JVM_ENTRY(void, JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo))
 582   JVMWrapper(&quot;JVM_InitStackTraceElement&quot;);
 583   Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(stackFrameInfo));
 584   Handle stack_trace_element(THREAD, JNIHandles::resolve_non_null(element));
 585   java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);
 586 JVM_END
 587 
 588 
 589 // java.lang.StackWalker //////////////////////////////////////////////////////
 590 
 591 
 592 JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 593                                      jint skip_frames, jint frame_count, jint start_index,
 594                                      jobjectArray frames))
 595   JVMWrapper(&quot;JVM_CallStackWalk&quot;);
 596   JavaThread* jt = (JavaThread*) THREAD;
 597   if (!jt-&gt;is_Java_thread() || !jt-&gt;has_last_Java_frame()) {
 598     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;doStackWalk: no stack trace&quot;, NULL);
 599   }
 600 
 601   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 602 
 603   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 604   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 605   // be null.
 606   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 607   objArrayHandle frames_array_h(THREAD, fa);
 608 
 609   int limit = start_index + frame_count;
 610   if (frames_array_h-&gt;length() &lt; limit) {
 611     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;, NULL);
 612   }
 613 
 614   oop result = StackWalk::walk(stackStream_h, mode, skip_frames, frame_count,
 615                                start_index, frames_array_h, CHECK_NULL);
 616   return JNIHandles::make_local(env, result);
 617 JVM_END
 618 
 619 
 620 JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 621                                   jint frame_count, jint start_index,
 622                                   jobjectArray frames))
 623   JVMWrapper(&quot;JVM_MoreStackWalk&quot;);
 624   JavaThread* jt = (JavaThread*) THREAD;
 625 
 626   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 627   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 628   // be null.
 629   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 630   objArrayHandle frames_array_h(THREAD, fa);
 631 
 632   int limit = start_index+frame_count;
 633   if (frames_array_h-&gt;length() &lt; limit) {
 634     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;);
 635   }
 636 
 637   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 638   return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,
 639                                    start_index, frames_array_h, THREAD);
 640 JVM_END
 641 
 642 // java.lang.Object ///////////////////////////////////////////////
 643 
 644 
 645 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 646   JVMWrapper(&quot;JVM_IHashCode&quot;);
 647   // as implemented in the classic virtual machine; return 0 if object is NULL
 648   return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;
 649 JVM_END
 650 
 651 
 652 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 653   JVMWrapper(&quot;JVM_MonitorWait&quot;);
 654   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 655   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 656   if (JvmtiExport::should_post_monitor_wait()) {
 657     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 658 
 659     // The current thread already owns the monitor and it has not yet
 660     // been added to the wait queue so the current thread cannot be
 661     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 662     // event handler cannot accidentally consume an unpark() meant for
 663     // the ParkEvent associated with this ObjectMonitor.
 664   }
 665   ObjectSynchronizer::wait(obj, ms, CHECK);
 666 JVM_END
 667 
 668 
 669 JVM_ENTRY(void, JVM_MonitorNotify(JNIEnv* env, jobject handle))
 670   JVMWrapper(&quot;JVM_MonitorNotify&quot;);
 671   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 672   ObjectSynchronizer::notify(obj, CHECK);
 673 JVM_END
 674 
 675 
 676 JVM_ENTRY(void, JVM_MonitorNotifyAll(JNIEnv* env, jobject handle))
 677   JVMWrapper(&quot;JVM_MonitorNotifyAll&quot;);
 678   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 679   ObjectSynchronizer::notifyall(obj, CHECK);
 680 JVM_END
 681 
 682 
 683 JVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle))
 684   JVMWrapper(&quot;JVM_Clone&quot;);
 685   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 686   Klass* klass = obj-&gt;klass();
 687   JvmtiVMObjectAllocEventCollector oam;
 688 
 689 #ifdef ASSERT
 690   // Just checking that the cloneable flag is set correct
 691   if (obj-&gt;is_array()) {
 692     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 693   } else {
 694     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 695     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 696     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 697   }
 698 #endif
 699 
 700   // Check if class of obj supports the Cloneable interface.
 701   // All arrays are considered to be cloneable (See JLS 20.1.5).
 702   // All j.l.r.Reference classes are considered non-cloneable.
 703   if (!klass-&gt;is_cloneable() ||
 704       (klass-&gt;is_instance_klass() &amp;&amp;
 705        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 706     ResourceMark rm(THREAD);
 707     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 708   }
 709 
 710   // Make shallow object copy
 711   const int size = obj-&gt;size();
 712   oop new_obj_oop = NULL;
 713   if (obj-&gt;is_array()) {
 714     const int length = ((arrayOop)obj())-&gt;length();
 715     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 716                                                    /* do_zero */ true, CHECK_NULL);
 717   } else {
 718     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 719   }
 720 
 721   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 722 
 723   Handle new_obj(THREAD, new_obj_oop);
 724   // Caution: this involves a java upcall, so the clone should be
 725   // &quot;gc-robust&quot; by this stage.
 726   if (klass-&gt;has_finalizer()) {
 727     assert(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 728     new_obj_oop = InstanceKlass::register_finalizer(instanceOop(new_obj()), CHECK_NULL);
 729     new_obj = Handle(THREAD, new_obj_oop);
 730   }
 731 
 732   return JNIHandles::make_local(env, new_obj());
 733 JVM_END
 734 
 735 // java.io.File ///////////////////////////////////////////////////////////////
 736 
 737 JVM_LEAF(char*, JVM_NativePath(char* path))
 738   JVMWrapper(&quot;JVM_NativePath&quot;);
 739   return os::native_path(path);
 740 JVM_END
 741 
 742 
 743 // Misc. class handling ///////////////////////////////////////////////////////////
 744 
 745 
 746 JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env))
 747   JVMWrapper(&quot;JVM_GetCallerClass&quot;);
 748 
 749   // Getting the class of the caller frame.
 750   //
 751   // The call stack at this point looks something like this:
 752   //
 753   // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
 754   // [1] [ @CallerSensitive API.method                                   ]
 755   // [.] [ (skipped intermediate frames)                                 ]
 756   // [n] [ caller                                                        ]
 757   vframeStream vfst(thread);
 758   // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
 759   for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
 760     Method* m = vfst.method();
 761     assert(m != NULL, &quot;sanity&quot;);
 762     switch (n) {
 763     case 0:
 764       // This must only be called from Reflection.getCallerClass
 765       if (m-&gt;intrinsic_id() != vmIntrinsics::_getCallerClass) {
 766         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetCallerClass must only be called from Reflection.getCallerClass&quot;);
 767       }
 768       // fall-through
 769     case 1:
 770       // Frame 0 and 1 must be caller sensitive.
 771       if (!m-&gt;caller_sensitive()) {
 772         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(&quot;CallerSensitive annotation expected at frame %d&quot;, n));
 773       }
 774       break;
 775     default:
 776       if (!m-&gt;is_ignored_by_security_stack_walk()) {
 777         // We have reached the desired frame; return the holder class.
 778         return (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());
 779       }
 780       break;
 781     }
 782   }
 783   return NULL;
 784 JVM_END
 785 
 786 
 787 JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
 788   JVMWrapper(&quot;JVM_FindPrimitiveClass&quot;);
 789   oop mirror = NULL;
 790   BasicType t = name2type(utf);
 791   if (t != T_ILLEGAL &amp;&amp; !is_reference_type(t)) {
 792     mirror = Universe::java_mirror(t);
 793   }
 794   if (mirror == NULL) {
 795     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
 796   } else {
 797     return (jclass) JNIHandles::make_local(env, mirror);
 798   }
 799 JVM_END
 800 
 801 
 802 // Returns a class loaded by the bootstrap class loader; or null
 803 // if not found.  ClassNotFoundException is not thrown.
 804 // FindClassFromBootLoader is exported to the launcher for windows.
 805 JVM_ENTRY(jclass, JVM_FindClassFromBootLoader(JNIEnv* env,
 806                                               const char* name))
 807   JVMWrapper(&quot;JVM_FindClassFromBootLoader&quot;);
 808 
 809   // Java libraries should ensure that name is never null...
 810   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 811     // It&#39;s impossible to create this class;  the name cannot fit
 812     // into the constant pool.
 813     return NULL;
 814   }
 815 
 816   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 817   Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
 818   if (k == NULL) {
 819     return NULL;
 820   }
 821 
 822   if (log_is_enabled(Debug, class, resolve)) {
 823     trace_class_resolution(k);
 824   }
 825   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 826 JVM_END
 827 
 828 // Find a class with this name in this loader, using the caller&#39;s protection domain.
 829 JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,
 830                                           jboolean init, jobject loader,
 831                                           jclass caller))
 832   JVMWrapper(&quot;JVM_FindClassFromCaller throws ClassNotFoundException&quot;);
 833   // Java libraries should ensure that name is never null...
 834   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 835     // It&#39;s impossible to create this class;  the name cannot fit
 836     // into the constant pool.
 837     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), name);
 838   }
 839 
 840   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 841 
 842   oop loader_oop = JNIHandles::resolve(loader);
 843   oop from_class = JNIHandles::resolve(caller);
 844   oop protection_domain = NULL;
 845   // If loader is null, shouldn&#39;t call ClassLoader.checkPackageAccess; otherwise get
 846   // NPE. Put it in another way, the bootstrap class loader has all permission and
 847   // thus no checkPackageAccess equivalence in the VM class loader.
 848   // The caller is also passed as NULL by the java code if there is no security
 849   // manager to avoid the performance cost of getting the calling class.
 850   if (from_class != NULL &amp;&amp; loader_oop != NULL) {
 851     protection_domain = java_lang_Class::as_Klass(from_class)-&gt;protection_domain();
 852   }
 853 
 854   Handle h_loader(THREAD, loader_oop);
 855   Handle h_prot(THREAD, protection_domain);
 856   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 857                                                h_prot, false, THREAD);
 858 
 859   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 860     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 861   }
 862   return result;
 863 JVM_END
 864 
 865 // Currently only called from the old verifier.
 866 JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv *env, const char *name,
 867                                          jboolean init, jclass from))
 868   JVMWrapper(&quot;JVM_FindClassFromClass&quot;);
 869   if (name == NULL) {
 870     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), &quot;No class name given&quot;);
 871   }
 872   if ((int)strlen(name) &gt; Symbol::max_length()) {
 873     // It&#39;s impossible to create this class;  the name cannot fit
 874     // into the constant pool.
 875     Exceptions::fthrow(THREAD_AND_LOCATION,
 876                        vmSymbols::java_lang_NoClassDefFoundError(),
 877                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 878                        Symbol::max_length(),
 879                        name);
 880     return 0;
 881   }
 882   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 883   oop from_class_oop = JNIHandles::resolve(from);
 884   Klass* from_class = (from_class_oop == NULL)
 885                            ? (Klass*)NULL
 886                            : java_lang_Class::as_Klass(from_class_oop);
 887   oop class_loader = NULL;
 888   oop protection_domain = NULL;
 889   if (from_class != NULL) {
 890     class_loader = from_class-&gt;class_loader();
 891     protection_domain = from_class-&gt;protection_domain();
 892   }
 893   Handle h_loader(THREAD, class_loader);
 894   Handle h_prot  (THREAD, protection_domain);
 895   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 896                                                h_prot, true, thread);
 897 
 898   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 899     // this function is generally only used for class loading during verification.
 900     ResourceMark rm;
 901     oop from_mirror = JNIHandles::resolve_non_null(from);
 902     Klass* from_class = java_lang_Class::as_Klass(from_mirror);
 903     const char * from_name = from_class-&gt;external_name();
 904 
 905     oop mirror = JNIHandles::resolve_non_null(result);
 906     Klass* to_class = java_lang_Class::as_Klass(mirror);
 907     const char * to = to_class-&gt;external_name();
 908     log_debug(class, resolve)(&quot;%s %s (verification)&quot;, from_name, to);
 909   }
 910 
 911   return result;
 912 JVM_END
 913 
 914 static void is_lock_held_by_thread(Handle loader, PerfCounter* counter, TRAPS) {
 915   if (loader.is_null()) {
 916     return;
 917   }
 918 
 919   // check whether the current caller thread holds the lock or not.
 920   // If not, increment the corresponding counter
 921   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader) !=
 922       ObjectSynchronizer::owner_self) {
 923     counter-&gt;inc();
 924   }
 925 }
 926 
 927 // common code for JVM_DefineClass() and JVM_DefineClassWithSource()
 928 static jclass jvm_define_class_common(JNIEnv *env, const char *name,
 929                                       jobject loader, const jbyte *buf,
 930                                       jsize len, jobject pd, const char *source,
 931                                       TRAPS) {
 932   if (source == NULL)  source = &quot;__JVM_DefineClass__&quot;;
 933 
 934   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
 935   JavaThread* jt = (JavaThread*) THREAD;
 936 
 937   PerfClassTraceTime vmtimer(ClassLoader::perf_define_appclass_time(),
 938                              ClassLoader::perf_define_appclass_selftime(),
 939                              ClassLoader::perf_define_appclasses(),
 940                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 941                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 942                              PerfClassTraceTime::DEFINE_CLASS);
 943 
 944   if (UsePerfData) {
 945     ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len);
 946   }
 947 
 948   // Since exceptions can be thrown, class initialization can take place
 949   // if name is NULL no check for class name in .class stream has to be made.
 950   TempNewSymbol class_name = NULL;
 951   if (name != NULL) {
 952     const int str_len = (int)strlen(name);
 953     if (str_len &gt; Symbol::max_length()) {
 954       // It&#39;s impossible to create this class;  the name cannot fit
 955       // into the constant pool.
 956       Exceptions::fthrow(THREAD_AND_LOCATION,
 957                          vmSymbols::java_lang_NoClassDefFoundError(),
 958                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 959                          Symbol::max_length(),
 960                          name);
 961       return 0;
 962     }
 963     class_name = SymbolTable::new_symbol(name, str_len);
 964   }
 965 
 966   ResourceMark rm(THREAD);
 967   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
 968   Handle class_loader (THREAD, JNIHandles::resolve(loader));
 969   if (UsePerfData) {
 970     is_lock_held_by_thread(class_loader,
 971                            ClassLoader::sync_JVMDefineClassLockFreeCounter(),
 972                            THREAD);
 973   }
 974   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
 975   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 976                                                    class_loader,
 977                                                    protection_domain,
 978                                                    &amp;st,
 979                                                    CHECK_NULL);
 980 
 981   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 982     trace_class_resolution(k);
 983   }
 984 
 985   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 986 }
 987 
 988 
 989 JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))
 990   JVMWrapper(&quot;JVM_DefineClass&quot;);
 991 
 992   return jvm_define_class_common(env, name, loader, buf, len, pd, NULL, THREAD);
 993 JVM_END
 994 
 995 
 996 JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source))
 997   JVMWrapper(&quot;JVM_DefineClassWithSource&quot;);
 998 
 999   return jvm_define_class_common(env, name, loader, buf, len, pd, source, THREAD);
1000 JVM_END
1001 
1002 JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
1003   JVMWrapper(&quot;JVM_FindLoadedClass&quot;);
1004   ResourceMark rm(THREAD);
1005 
1006   Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
1007   char* str = java_lang_String::as_utf8_string(h_name());
1008 
1009   // Sanity check, don&#39;t expect null
1010   if (str == NULL) return NULL;
1011 
1012   // Internalize the string, converting &#39;.&#39; to &#39;/&#39; in string.
1013   char* p = (char*)str;
1014   while (*p != &#39;\0&#39;) {
1015       if (*p == &#39;.&#39;) {
1016           *p = &#39;/&#39;;
1017       }
1018       p++;
1019   }
1020 
1021   const int str_len = (int)(p - str);
1022   if (str_len &gt; Symbol::max_length()) {
1023     // It&#39;s impossible to create this class;  the name cannot fit
1024     // into the constant pool.
1025     return NULL;
1026   }
1027   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len);
1028 
1029   // Security Note:
1030   //   The Java level wrapper will perform the necessary security check allowing
1031   //   us to pass the NULL as the initiating class loader.
1032   Handle h_loader(THREAD, JNIHandles::resolve(loader));
1033   if (UsePerfData) {
1034     is_lock_held_by_thread(h_loader,
1035                            ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),
1036                            THREAD);
1037   }
1038 
1039   Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,
1040                                                               h_loader,
1041                                                               Handle(),
1042                                                               CHECK_NULL);
1043 #if INCLUDE_CDS
1044   if (k == NULL) {
1045     // If the class is not already loaded, try to see if it&#39;s in the shared
1046     // archive for the current classloader (h_loader).
1047     k = SystemDictionaryShared::find_or_load_shared_class(klass_name, h_loader, CHECK_NULL);
1048   }
1049 #endif
1050   return (k == NULL) ? NULL :
1051             (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1052 JVM_END
1053 
1054 // Module support //////////////////////////////////////////////////////////////////////////////
1055 
1056 JVM_ENTRY(void, JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
1057                                  jstring location, const char* const* packages, jsize num_packages))
1058   JVMWrapper(&quot;JVM_DefineModule&quot;);
1059   Modules::define_module(module, is_open, version, location, packages, num_packages, CHECK);
1060 JVM_END
1061 
1062 JVM_ENTRY(void, JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module))
1063   JVMWrapper(&quot;JVM_SetBootLoaderUnnamedModule&quot;);
1064   Modules::set_bootloader_unnamed_module(module, CHECK);
1065 JVM_END
1066 
1067 JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, const char* package, jobject to_module))
1068   JVMWrapper(&quot;JVM_AddModuleExports&quot;);
1069   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1070 JVM_END
1071 
1072 JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, const char* package))
1073   JVMWrapper(&quot;JVM_AddModuleExportsToAllUnnamed&quot;);
1074   Modules::add_module_exports_to_all_unnamed(from_module, package, CHECK);
1075 JVM_END
1076 
1077 JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, const char* package))
1078   JVMWrapper(&quot;JVM_AddModuleExportsToAll&quot;);
1079   Modules::add_module_exports(from_module, package, NULL, CHECK);
1080 JVM_END
1081 
1082 JVM_ENTRY (void, JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module))
1083   JVMWrapper(&quot;JVM_AddReadsModule&quot;);
1084   Modules::add_reads_module(from_module, source_module, CHECK);
1085 JVM_END
1086 
1087 // Reflection support //////////////////////////////////////////////////////////////////////////////
1088 
1089 JVM_ENTRY(jstring, JVM_InitClassName(JNIEnv *env, jclass cls))
1090   assert (cls != NULL, &quot;illegal class&quot;);
1091   JVMWrapper(&quot;JVM_InitClassName&quot;);
1092   JvmtiVMObjectAllocEventCollector oam;
1093   ResourceMark rm(THREAD);
1094   HandleMark hm(THREAD);
1095   Handle java_class(THREAD, JNIHandles::resolve(cls));
1096   oop result = java_lang_Class::name(java_class, CHECK_NULL);
1097   return (jstring) JNIHandles::make_local(env, result);
1098 JVM_END
1099 
1100 
1101 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1102   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1103   JvmtiVMObjectAllocEventCollector oam;
1104   oop mirror = JNIHandles::resolve_non_null(cls);
1105 
1106   // Special handling for primitive objects
1107   if (java_lang_Class::is_primitive(mirror)) {
1108     // Primitive objects does not have any interfaces
1109     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1110     return (jobjectArray) JNIHandles::make_local(env, r);
1111   }
1112 
1113   Klass* klass = java_lang_Class::as_Klass(mirror);
1114   // Figure size of result array
1115   int size;
1116   if (klass-&gt;is_instance_klass()) {
1117     size = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;length();
1118   } else {
1119     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
1120     size = 2;
1121   }
1122 
1123   // Allocate result array
1124   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1125   objArrayHandle result (THREAD, r);
1126   // Fill in result
1127   if (klass-&gt;is_instance_klass()) {
1128     // Regular instance klass, fill in all local interfaces
1129     for (int index = 0; index &lt; size; index++) {
1130       Klass* k = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;at(index);
1131       result-&gt;obj_at_put(index, k-&gt;java_mirror());
1132     }
1133   } else {
1134     // All arrays implement java.lang.Cloneable and java.io.Serializable
1135     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1136     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
1137   }
1138   return (jobjectArray) JNIHandles::make_local(env, result());
1139 JVM_END
1140 
1141 
1142 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1143   JVMWrapper(&quot;JVM_IsInterface&quot;);
1144   oop mirror = JNIHandles::resolve_non_null(cls);
1145   if (java_lang_Class::is_primitive(mirror)) {
1146     return JNI_FALSE;
1147   }
1148   Klass* k = java_lang_Class::as_Klass(mirror);
1149   jboolean result = k-&gt;is_interface();
1150   assert(!result || k-&gt;is_instance_klass(),
1151          &quot;all interfaces are instance types&quot;);
1152   // The compiler intrinsic for isInterface tests the
1153   // Klass::_access_flags bits in the same way.
1154   return result;
1155 JVM_END
1156 
1157 
1158 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1159   JVMWrapper(&quot;JVM_GetClassSigners&quot;);
1160   JvmtiVMObjectAllocEventCollector oam;
1161   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1162     // There are no signers for primitive types
1163     return NULL;
1164   }
1165 
1166   objArrayHandle signers(THREAD, java_lang_Class::signers(JNIHandles::resolve_non_null(cls)));
1167 
1168   // If there are no signers set in the class, or if the class
1169   // is an array, return NULL.
1170   if (signers == NULL) return NULL;
1171 
1172   // copy of the signers array
1173   Klass* element = ObjArrayKlass::cast(signers-&gt;klass())-&gt;element_klass();
1174   objArrayOop signers_copy = oopFactory::new_objArray(element, signers-&gt;length(), CHECK_NULL);
1175   for (int index = 0; index &lt; signers-&gt;length(); index++) {
1176     signers_copy-&gt;obj_at_put(index, signers-&gt;obj_at(index));
1177   }
1178 
1179   // return the copy
1180   return (jobjectArray) JNIHandles::make_local(env, signers_copy);
1181 JVM_END
1182 
1183 
1184 JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))
1185   JVMWrapper(&quot;JVM_SetClassSigners&quot;);
1186   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1187     // This call is ignored for primitive types and arrays.
1188     // Signers are only set once, ClassLoader.java, and thus shouldn&#39;t
1189     // be called with an array.  Only the bootstrap loader creates arrays.
1190     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1191     if (k-&gt;is_instance_klass()) {
1192       java_lang_Class::set_signers(k-&gt;java_mirror(), objArrayOop(JNIHandles::resolve(signers)));
1193     }
1194   }
1195 JVM_END
1196 
1197 
1198 JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))
1199   JVMWrapper(&quot;JVM_GetProtectionDomain&quot;);
1200   if (JNIHandles::resolve(cls) == NULL) {
1201     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
1202   }
1203 
1204   if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1205     // Primitive types does not have a protection domain.
1206     return NULL;
1207   }
1208 
1209   oop pd = java_lang_Class::protection_domain(JNIHandles::resolve(cls));
1210   return (jobject) JNIHandles::make_local(env, pd);
1211 JVM_END
1212 
1213 
1214 // Returns the inherited_access_control_context field of the running thread.
1215 JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))
1216   JVMWrapper(&quot;JVM_GetInheritedAccessControlContext&quot;);
1217   oop result = java_lang_Thread::inherited_access_control_context(thread-&gt;threadObj());
1218   return JNIHandles::make_local(env, result);
1219 JVM_END
1220 
1221 class RegisterArrayForGC {
1222  private:
1223   JavaThread *_thread;
1224  public:
1225   RegisterArrayForGC(JavaThread *thread, GrowableArray&lt;oop&gt;* array)  {
1226     _thread = thread;
1227     _thread-&gt;register_array_for_gc(array);
1228   }
1229 
1230   ~RegisterArrayForGC() {
1231     _thread-&gt;register_array_for_gc(NULL);
1232   }
1233 };
1234 
1235 
1236 JVM_ENTRY(jobject, JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls))
1237   JVMWrapper(&quot;JVM_GetStackAccessControlContext&quot;);
1238   if (!UsePrivilegedStack) return NULL;
1239 
1240   ResourceMark rm(THREAD);
1241   GrowableArray&lt;oop&gt;* local_array = new GrowableArray&lt;oop&gt;(12);
1242   JvmtiVMObjectAllocEventCollector oam;
1243 
1244   // count the protection domains on the execution stack. We collapse
1245   // duplicate consecutive protection domains into a single one, as
1246   // well as stopping when we hit a privileged frame.
1247 
1248   oop previous_protection_domain = NULL;
1249   Handle privileged_context(thread, NULL);
1250   bool is_privileged = false;
1251   oop protection_domain = NULL;
1252 
1253   // Iterate through Java frames
1254   vframeStream vfst(thread);
1255   for(; !vfst.at_end(); vfst.next()) {
1256     // get method of frame
1257     Method* method = vfst.method();
1258 
1259     // stop at the first privileged frame
1260     if (method-&gt;method_holder() == SystemDictionary::AccessController_klass() &amp;&amp;
1261       method-&gt;name() == vmSymbols::executePrivileged_name())
1262     {
1263       // this frame is privileged
1264       is_privileged = true;
1265 
1266       javaVFrame *priv = vfst.asJavaVFrame();       // executePrivileged
1267 
1268       StackValueCollection* locals = priv-&gt;locals();
1269       StackValue* ctx_sv = locals-&gt;at(1); // AccessControlContext context
1270       StackValue* clr_sv = locals-&gt;at(2); // Class&lt;?&gt; caller
1271       assert(!ctx_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1272       assert(!clr_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1273       privileged_context    = ctx_sv-&gt;get_obj();
1274       Handle caller         = clr_sv-&gt;get_obj();
1275 
1276       Klass *caller_klass = java_lang_Class::as_Klass(caller());
1277       protection_domain  = caller_klass-&gt;protection_domain();
1278     } else {
1279       protection_domain = method-&gt;method_holder()-&gt;protection_domain();
1280     }
1281 
1282     if ((previous_protection_domain != protection_domain) &amp;&amp; (protection_domain != NULL)) {
1283       local_array-&gt;push(protection_domain);
1284       previous_protection_domain = protection_domain;
1285     }
1286 
1287     if (is_privileged) break;
1288   }
1289 
1290 
1291   // either all the domains on the stack were system domains, or
1292   // we had a privileged system domain
1293   if (local_array-&gt;is_empty()) {
1294     if (is_privileged &amp;&amp; privileged_context.is_null()) return NULL;
1295 
1296     oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);
1297     return JNIHandles::make_local(env, result);
1298   }
1299 
1300   // the resource area must be registered in case of a gc
1301   RegisterArrayForGC ragc(thread, local_array);
1302   objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),
1303                                                  local_array-&gt;length(), CHECK_NULL);
1304   objArrayHandle h_context(thread, context);
1305   for (int index = 0; index &lt; local_array-&gt;length(); index++) {
1306     h_context-&gt;obj_at_put(index, local_array-&gt;at(index));
1307   }
1308 
1309   oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);
1310 
1311   return JNIHandles::make_local(env, result);
1312 JVM_END
1313 
1314 
1315 JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))
1316   JVMWrapper(&quot;JVM_IsArrayClass&quot;);
1317   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1318   return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
1319 JVM_END
1320 
1321 
1322 JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))
1323   JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
1324   oop mirror = JNIHandles::resolve_non_null(cls);
1325   return (jboolean) java_lang_Class::is_primitive(mirror);
1326 JVM_END
1327 
1328 
1329 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1330   JVMWrapper(&quot;JVM_GetClassModifiers&quot;);
1331   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1332     // Primitive type
1333     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1334   }
1335 
1336   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1337   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1338   assert(k-&gt;modifier_flags() == computed_modifiers, &quot;modifiers cache is OK&quot;);
1339   return k-&gt;modifier_flags();
1340 JVM_END
1341 
1342 
1343 // Inner class reflection ///////////////////////////////////////////////////////////////////////////////
1344 
1345 JVM_ENTRY(jobjectArray, JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass))
1346   JvmtiVMObjectAllocEventCollector oam;
1347   // ofClass is a reference to a java_lang_Class object. The mirror object
1348   // of an InstanceKlass
1349 
1350   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1351       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1352     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1353     return (jobjectArray)JNIHandles::make_local(env, result);
1354   }
1355 
1356   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1357   InnerClassesIterator iter(k);
1358 
1359   if (iter.length() == 0) {
1360     // Neither an inner nor outer class
1361     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1362     return (jobjectArray)JNIHandles::make_local(env, result);
1363   }
1364 
1365   // find inner class info
1366   constantPoolHandle cp(thread, k-&gt;constants());
1367   int length = iter.length();
1368 
1369   // Allocate temp. result array
1370   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length/4, CHECK_NULL);
1371   objArrayHandle result (THREAD, r);
1372   int members = 0;
1373 
1374   for (; !iter.done(); iter.next()) {
1375     int ioff = iter.inner_class_info_index();
1376     int ooff = iter.outer_class_info_index();
1377 
1378     if (ioff != 0 &amp;&amp; ooff != 0) {
1379       // Check to see if the name matches the class we&#39;re looking for
1380       // before attempting to find the class.
1381       if (cp-&gt;klass_name_at_matches(k, ooff)) {
1382         Klass* outer_klass = cp-&gt;klass_at(ooff, CHECK_NULL);
1383         if (outer_klass == k) {
1384            Klass* ik = cp-&gt;klass_at(ioff, CHECK_NULL);
1385            InstanceKlass* inner_klass = InstanceKlass::cast(ik);
1386 
1387            // Throws an exception if outer klass has not declared k as
1388            // an inner klass
1389            Reflection::check_for_inner_class(k, inner_klass, true, CHECK_NULL);
1390 
1391            result-&gt;obj_at_put(members, inner_klass-&gt;java_mirror());
1392            members++;
1393         }
1394       }
1395     }
1396   }
1397 
1398   if (members != length) {
1399     // Return array of right length
1400     objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);
1401     for(int i = 0; i &lt; members; i++) {
1402       res-&gt;obj_at_put(i, result-&gt;obj_at(i));
1403     }
1404     return (jobjectArray)JNIHandles::make_local(env, res);
1405   }
1406 
1407   return (jobjectArray)JNIHandles::make_local(env, result());
1408 JVM_END
1409 
1410 
1411 JVM_ENTRY(jclass, JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass))
1412 {
1413   // ofClass is a reference to a java_lang_Class object.
1414   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1415       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1416     return NULL;
1417   }
1418 
1419   bool inner_is_member = false;
1420   Klass* outer_klass
1421     = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))
1422                           )-&gt;compute_enclosing_class(&amp;inner_is_member, CHECK_NULL);
1423   if (outer_klass == NULL)  return NULL;  // already a top-level class
1424   if (!inner_is_member)  return NULL;     // an anonymous class (inside a method)
1425   return (jclass) JNIHandles::make_local(env, outer_klass-&gt;java_mirror());
1426 }
1427 JVM_END
1428 
1429 JVM_ENTRY(jstring, JVM_GetSimpleBinaryName(JNIEnv *env, jclass cls))
1430 {
1431   oop mirror = JNIHandles::resolve_non_null(cls);
1432   if (java_lang_Class::is_primitive(mirror) ||
1433       !java_lang_Class::as_Klass(mirror)-&gt;is_instance_klass()) {
1434     return NULL;
1435   }
1436   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1437   int ooff = 0, noff = 0;
1438   if (k-&gt;find_inner_classes_attr(&amp;ooff, &amp;noff, THREAD)) {
1439     if (noff != 0) {
1440       constantPoolHandle i_cp(thread, k-&gt;constants());
1441       Symbol* name = i_cp-&gt;symbol_at(noff);
1442       Handle str = java_lang_String::create_from_symbol(name, CHECK_NULL);
1443       return (jstring) JNIHandles::make_local(env, str());
1444     }
1445   }
1446   return NULL;
1447 }
1448 JVM_END
1449 
1450 JVM_ENTRY(jstring, JVM_GetClassSignature(JNIEnv *env, jclass cls))
1451   assert (cls != NULL, &quot;illegal class&quot;);
1452   JVMWrapper(&quot;JVM_GetClassSignature&quot;);
1453   JvmtiVMObjectAllocEventCollector oam;
1454   ResourceMark rm(THREAD);
1455   // Return null for arrays and primatives
1456   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1457     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1458     if (k-&gt;is_instance_klass()) {
1459       Symbol* sym = InstanceKlass::cast(k)-&gt;generic_signature();
1460       if (sym == NULL) return NULL;
1461       Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
1462       return (jstring) JNIHandles::make_local(env, str());
1463     }
1464   }
1465   return NULL;
1466 JVM_END
1467 
1468 
1469 JVM_ENTRY(jbyteArray, JVM_GetClassAnnotations(JNIEnv *env, jclass cls))
1470   assert (cls != NULL, &quot;illegal class&quot;);
1471   JVMWrapper(&quot;JVM_GetClassAnnotations&quot;);
1472 
1473   // Return null for arrays and primitives
1474   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1475     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1476     if (k-&gt;is_instance_klass()) {
1477       typeArrayOop a = Annotations::make_java_array(InstanceKlass::cast(k)-&gt;class_annotations(), CHECK_NULL);
1478       return (jbyteArray) JNIHandles::make_local(env, a);
1479     }
1480   }
1481   return NULL;
1482 JVM_END
1483 
1484 
1485 static bool jvm_get_field_common(jobject field, fieldDescriptor&amp; fd, TRAPS) {
1486   // some of this code was adapted from from jni_FromReflectedField
1487 
1488   oop reflected = JNIHandles::resolve_non_null(field);
1489   oop mirror    = java_lang_reflect_Field::clazz(reflected);
1490   Klass* k    = java_lang_Class::as_Klass(mirror);
1491   int slot      = java_lang_reflect_Field::slot(reflected);
1492   int modifiers = java_lang_reflect_Field::modifiers(reflected);
1493 
1494   InstanceKlass* ik = InstanceKlass::cast(k);
1495   intptr_t offset = ik-&gt;field_offset(slot);
1496 
1497   if (modifiers &amp; JVM_ACC_STATIC) {
1498     // for static fields we only look in the current class
1499     if (!ik-&gt;find_local_field_from_offset(offset, true, &amp;fd)) {
1500       assert(false, &quot;cannot find static field&quot;);
1501       return false;
1502     }
1503   } else {
1504     // for instance fields we start with the current class and work
1505     // our way up through the superclass chain
1506     if (!ik-&gt;find_field_from_offset(offset, false, &amp;fd)) {
1507       assert(false, &quot;cannot find instance field&quot;);
1508       return false;
1509     }
1510   }
1511   return true;
1512 }
1513 
1514 static Method* jvm_get_method_common(jobject method) {
1515   // some of this code was adapted from from jni_FromReflectedMethod
1516 
1517   oop reflected = JNIHandles::resolve_non_null(method);
1518   oop mirror    = NULL;
1519   int slot      = 0;
1520 
1521   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
1522     mirror = java_lang_reflect_Constructor::clazz(reflected);
1523     slot   = java_lang_reflect_Constructor::slot(reflected);
1524   } else {
1525     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(),
1526            &quot;wrong type&quot;);
1527     mirror = java_lang_reflect_Method::clazz(reflected);
1528     slot   = java_lang_reflect_Method::slot(reflected);
1529   }
1530   Klass* k = java_lang_Class::as_Klass(mirror);
1531 
1532   Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
1533   assert(m != NULL, &quot;cannot find method&quot;);
1534   return m;  // caller has to deal with NULL in product mode
1535 }
1536 
1537 /* Type use annotations support (JDK 1.8) */
1538 
1539 JVM_ENTRY(jbyteArray, JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls))
1540   assert (cls != NULL, &quot;illegal class&quot;);
1541   JVMWrapper(&quot;JVM_GetClassTypeAnnotations&quot;);
1542   ResourceMark rm(THREAD);
1543   // Return null for arrays and primitives
1544   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1545     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1546     if (k-&gt;is_instance_klass()) {
1547       AnnotationArray* type_annotations = InstanceKlass::cast(k)-&gt;class_type_annotations();
1548       if (type_annotations != NULL) {
1549         typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1550         return (jbyteArray) JNIHandles::make_local(env, a);
1551       }
1552     }
1553   }
1554   return NULL;
1555 JVM_END
1556 
1557 JVM_ENTRY(jbyteArray, JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method))
1558   assert (method != NULL, &quot;illegal method&quot;);
1559   JVMWrapper(&quot;JVM_GetMethodTypeAnnotations&quot;);
1560 
1561   // method is a handle to a java.lang.reflect.Method object
1562   Method* m = jvm_get_method_common(method);
1563   if (m == NULL) {
1564     return NULL;
1565   }
1566 
1567   AnnotationArray* type_annotations = m-&gt;type_annotations();
1568   if (type_annotations != NULL) {
1569     typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1570     return (jbyteArray) JNIHandles::make_local(env, a);
1571   }
1572 
1573   return NULL;
1574 JVM_END
1575 
1576 JVM_ENTRY(jbyteArray, JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field))
1577   assert (field != NULL, &quot;illegal field&quot;);
1578   JVMWrapper(&quot;JVM_GetFieldTypeAnnotations&quot;);
1579 
1580   fieldDescriptor fd;
1581   bool gotFd = jvm_get_field_common(field, fd, CHECK_NULL);
1582   if (!gotFd) {
1583     return NULL;
1584   }
1585 
1586   return (jbyteArray) JNIHandles::make_local(env, Annotations::make_java_array(fd.type_annotations(), THREAD));
1587 JVM_END
1588 
1589 static void bounds_check(const constantPoolHandle&amp; cp, jint index, TRAPS) {
1590   if (!cp-&gt;is_within_bounds(index)) {
1591     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool index out of bounds&quot;);
1592   }
1593 }
1594 
1595 JVM_ENTRY(jobjectArray, JVM_GetMethodParameters(JNIEnv *env, jobject method))
1596 {
1597   JVMWrapper(&quot;JVM_GetMethodParameters&quot;);
1598   // method is a handle to a java.lang.reflect.Method object
1599   Method* method_ptr = jvm_get_method_common(method);
1600   methodHandle mh (THREAD, method_ptr);
1601   Handle reflected_method (THREAD, JNIHandles::resolve_non_null(method));
1602   const int num_params = mh-&gt;method_parameters_length();
1603 
1604   if (num_params &lt; 0) {
1605     // A -1 return value from method_parameters_length means there is no
1606     // parameter data.  Return null to indicate this to the reflection
1607     // API.
1608     assert(num_params == -1, &quot;num_params should be -1 if it is less than zero&quot;);
1609     return (jobjectArray)NULL;
1610   } else {
1611     // Otherwise, we return something up to reflection, even if it is
1612     // a zero-length array.  Why?  Because in some cases this can
1613     // trigger a MalformedParametersException.
1614 
1615     // make sure all the symbols are properly formatted
1616     for (int i = 0; i &lt; num_params; i++) {
1617       MethodParametersElement* params = mh-&gt;method_parameters_start();
1618       int index = params[i].name_cp_index;
1619       constantPoolHandle cp(THREAD, mh-&gt;constants());
1620       bounds_check(cp, index, CHECK_NULL);
1621 
1622       if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
1623         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1624                     &quot;Wrong type at constant pool index&quot;);
1625       }
1626 
1627     }
1628 
1629     objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);
1630     objArrayHandle result (THREAD, result_oop);
1631 
1632     for (int i = 0; i &lt; num_params; i++) {
1633       MethodParametersElement* params = mh-&gt;method_parameters_start();
1634       // For a 0 index, give a NULL symbol
1635       Symbol* sym = 0 != params[i].name_cp_index ?
1636         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1637       int flags = params[i].flags;
1638       oop param = Reflection::new_parameter(reflected_method, i, sym,
1639                                             flags, CHECK_NULL);
1640       result-&gt;obj_at_put(i, param);
1641     }
1642     return (jobjectArray)JNIHandles::make_local(env, result());
1643   }
1644 }
1645 JVM_END
1646 
1647 // New (JDK 1.4) reflection implementation /////////////////////////////////////
1648 
1649 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1650 {
1651   JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
1652   JvmtiVMObjectAllocEventCollector oam;
1653 
1654   // Exclude primitive types and array types
1655   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1656       java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1657     // Return empty array
1658     oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);
1659     return (jobjectArray) JNIHandles::make_local(env, res);
1660   }
1661 
1662   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1663   constantPoolHandle cp(THREAD, k-&gt;constants());
1664 
1665   // Ensure class is linked
1666   k-&gt;link_class(CHECK_NULL);
1667 
1668   // Allocate result
1669   int num_fields;
1670 
1671   if (publicOnly) {
1672     num_fields = 0;
1673     for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1674       if (fs.access_flags().is_public()) ++num_fields;
1675     }
1676   } else {
1677     num_fields = k-&gt;java_fields_count();
1678   }
1679 
1680   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1681   objArrayHandle result (THREAD, r);
1682 
1683   int out_idx = 0;
1684   fieldDescriptor fd;
1685   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1686     if (!publicOnly || fs.access_flags().is_public()) {
1687       fd.reinitialize(k, fs.index());
1688       oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
1689       result-&gt;obj_at_put(out_idx, field);
1690       ++out_idx;
1691     }
1692   }
1693   assert(out_idx == num_fields, &quot;just checking&quot;);
1694   return (jobjectArray) JNIHandles::make_local(env, result());
1695 }
1696 JVM_END
1697 
1698 JVM_ENTRY(jboolean, JVM_IsRecord(JNIEnv *env, jclass cls))
1699 {
1700   JVMWrapper(&quot;JVM_IsRecord&quot;);
1701   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1702   if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
1703     InstanceKlass* ik = InstanceKlass::cast(k);
1704     return ik-&gt;is_record();
1705   } else {
1706     return false;
1707   }
1708 }
1709 JVM_END
1710 
1711 JVM_ENTRY(jobjectArray, JVM_GetRecordComponents(JNIEnv* env, jclass ofClass))
1712 {
1713   JVMWrapper(&quot;JVM_GetRecordComponents&quot;);
1714   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass));
1715   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1716   InstanceKlass* ik = InstanceKlass::cast(c);
1717 
1718   if (ik-&gt;is_record()) {
1719     Array&lt;RecordComponent*&gt;* components = ik-&gt;record_components();
1720     assert(components != NULL, &quot;components should not be NULL&quot;);
1721     {
1722       JvmtiVMObjectAllocEventCollector oam;
1723       constantPoolHandle cp(THREAD, ik-&gt;constants());
1724       int length = components-&gt;length();
1725       assert(length &gt;= 0, &quot;unexpected record_components length&quot;);
1726       objArrayOop record_components =
1727         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1728       objArrayHandle components_h (THREAD, record_components);
1729 
1730       for (int x = 0; x &lt; length; x++) {
1731         RecordComponent* component = components-&gt;at(x);
1732         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1733         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1734         components_h-&gt;obj_at_put(x, component_oop);
1735       }
1736       return (jobjectArray)JNIHandles::make_local(components_h());
1737     }
1738   }
1739 
1740   // Return empty array if ofClass is not a record.
1741   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1742   return (jobjectArray)JNIHandles::make_local(env, result);
1743 }
1744 JVM_END
1745 
1746 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
1747   if (want_constructor) {
1748     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());
1749   } else {
1750     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());
1751   }
1752 }
1753 
1754 static jobjectArray get_class_declared_methods_helper(
1755                                   JNIEnv *env,
1756                                   jclass ofClass, jboolean publicOnly,
1757                                   bool want_constructor,
1758                                   Klass* klass, TRAPS) {
1759 
1760   JvmtiVMObjectAllocEventCollector oam;
1761 
1762   // Exclude primitive types and array types
1763   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1764       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1765     // Return empty array
1766     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1767     return (jobjectArray) JNIHandles::make_local(env, res);
1768   }
1769 
1770   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1771 
1772   // Ensure class is linked
1773   k-&gt;link_class(CHECK_NULL);
1774 
1775   Array&lt;Method*&gt;* methods = k-&gt;methods();
1776   int methods_length = methods-&gt;length();
1777 
1778   // Save original method_idnum in case of redefinition, which can change
1779   // the idnum of obsolete methods.  The new method will have the same idnum
1780   // but if we refresh the methods array, the counts will be wrong.
1781   ResourceMark rm(THREAD);
1782   GrowableArray&lt;int&gt;* idnums = new GrowableArray&lt;int&gt;(methods_length);
1783   int num_methods = 0;
1784 
1785   for (int i = 0; i &lt; methods_length; i++) {
1786     methodHandle method(THREAD, methods-&gt;at(i));
1787     if (select_method(method, want_constructor)) {
1788       if (!publicOnly || method-&gt;is_public()) {
1789         idnums-&gt;push(method-&gt;method_idnum());
1790         ++num_methods;
1791       }
1792     }
1793   }
1794 
1795   // Allocate result
1796   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1797   objArrayHandle result (THREAD, r);
1798 
1799   // Now just put the methods that we selected above, but go by their idnum
1800   // in case of redefinition.  The methods can be redefined at any safepoint,
1801   // so above when allocating the oop array and below when creating reflect
1802   // objects.
1803   for (int i = 0; i &lt; num_methods; i++) {
1804     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1805     if (method.is_null()) {
1806       // Method may have been deleted and seems this API can handle null
1807       // Otherwise should probably put a method that throws NSME
1808       result-&gt;obj_at_put(i, NULL);
1809     } else {
1810       oop m;
1811       if (want_constructor) {
1812         m = Reflection::new_constructor(method, CHECK_NULL);
1813       } else {
1814         m = Reflection::new_method(method, false, CHECK_NULL);
1815       }
1816       result-&gt;obj_at_put(i, m);
1817     }
1818   }
1819 
1820   return (jobjectArray) JNIHandles::make_local(env, result());
1821 }
1822 
1823 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1824 {
1825   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1826   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1827                                            /*want_constructor*/ false,
1828                                            SystemDictionary::reflect_Method_klass(), THREAD);
1829 }
1830 JVM_END
1831 
1832 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1833 {
1834   JVMWrapper(&quot;JVM_GetClassDeclaredConstructors&quot;);
1835   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1836                                            /*want_constructor*/ true,
1837                                            SystemDictionary::reflect_Constructor_klass(), THREAD);
1838 }
1839 JVM_END
1840 
1841 JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))
1842 {
1843   JVMWrapper(&quot;JVM_GetClassAccessFlags&quot;);
1844   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1845     // Primitive type
1846     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1847   }
1848 
1849   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1850   return k-&gt;access_flags().as_int() &amp; JVM_ACC_WRITTEN_FLAGS;
1851 }
1852 JVM_END
1853 
1854 JVM_ENTRY(jboolean, JVM_AreNestMates(JNIEnv *env, jclass current, jclass member))
1855 {
1856   JVMWrapper(&quot;JVM_AreNestMates&quot;);
1857   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
1858   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1859   InstanceKlass* ck = InstanceKlass::cast(c);
1860   Klass* m = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(member));
1861   assert(m-&gt;is_instance_klass(), &quot;must be&quot;);
1862   InstanceKlass* mk = InstanceKlass::cast(m);
1863   return ck-&gt;has_nestmate_access_to(mk, THREAD);
1864 }
1865 JVM_END
1866 
1867 JVM_ENTRY(jclass, JVM_GetNestHost(JNIEnv* env, jclass current))
1868 {
1869   // current is not a primitive or array class
1870   JVMWrapper(&quot;JVM_GetNestHost&quot;);
1871   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
1872   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1873   InstanceKlass* ck = InstanceKlass::cast(c);
1874   // Don&#39;t post exceptions if validation fails
1875   InstanceKlass* host = ck-&gt;nest_host(NULL, THREAD);
1876   return (jclass) (host == NULL ? NULL :
1877                    JNIHandles::make_local(THREAD, host-&gt;java_mirror()));
1878 }
1879 JVM_END
1880 
1881 JVM_ENTRY(jobjectArray, JVM_GetNestMembers(JNIEnv* env, jclass current))
1882 {
1883   // current is not a primitive or array class
1884   JVMWrapper(&quot;JVM_GetNestMembers&quot;);
1885   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
1886   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1887   InstanceKlass* ck = InstanceKlass::cast(c);
1888   // Get the nest host for this nest - throw ICCE if validation fails
1889   Symbol* icce = vmSymbols::java_lang_IncompatibleClassChangeError();
1890   InstanceKlass* host = ck-&gt;nest_host(icce, CHECK_NULL);
1891 
1892   {
1893     JvmtiVMObjectAllocEventCollector oam;
1894     Array&lt;u2&gt;* members = host-&gt;nest_members();
1895     int length = members == NULL ? 0 : members-&gt;length();
1896     // nest host is first in the array so make it one bigger
1897     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),
1898                                              length + 1, CHECK_NULL);
1899     objArrayHandle result (THREAD, r);
1900     result-&gt;obj_at_put(0, host-&gt;java_mirror());
1901     if (length != 0) {
1902       int i;
1903       for (i = 0; i &lt; length; i++) {
1904          int cp_index = members-&gt;at(i);
1905          Klass* k = host-&gt;constants()-&gt;klass_at(cp_index, CHECK_NULL);
1906          if (k-&gt;is_instance_klass()) {
1907            InstanceKlass* nest_host_k =
1908              InstanceKlass::cast(k)-&gt;nest_host(icce, CHECK_NULL);
1909            if (nest_host_k == host) {
1910              result-&gt;obj_at_put(i+1, k-&gt;java_mirror());
1911            }
1912            else {
1913              // k&#39;s nest host is legal but it isn&#39;t our host so
1914              // throw ICCE
1915              ResourceMark rm(THREAD);
1916              Exceptions::fthrow(THREAD_AND_LOCATION,
1917                                 icce,
1918                                 &quot;Nest member %s in %s declares a different nest host of %s&quot;,
1919                                 k-&gt;external_name(),
1920                                 host-&gt;external_name(),
1921                                 nest_host_k-&gt;external_name()
1922                            );
1923              return NULL;
1924            }
1925          }
1926          else {
1927            // we have a bad nest member entry - throw ICCE
1928            ResourceMark rm(THREAD);
1929            Exceptions::fthrow(THREAD_AND_LOCATION,
1930                               icce,
1931                               &quot;Class %s can not be a nest member of %s&quot;,
1932                               k-&gt;external_name(),
1933                               host-&gt;external_name()
1934                               );
1935            return NULL;
1936          }
1937       }
1938     }
1939     else {
1940       assert(host == ck, &quot;must be singleton nest&quot;);
1941     }
1942     return (jobjectArray)JNIHandles::make_local(THREAD, result());
1943   }
1944 }
1945 JVM_END
1946 
1947 // Constant pool access //////////////////////////////////////////////////////////
1948 
1949 JVM_ENTRY(jobject, JVM_GetClassConstantPool(JNIEnv *env, jclass cls))
1950 {
1951   JVMWrapper(&quot;JVM_GetClassConstantPool&quot;);
1952   JvmtiVMObjectAllocEventCollector oam;
1953 
1954   // Return null for primitives and arrays
1955   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1956     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1957     if (k-&gt;is_instance_klass()) {
1958       InstanceKlass* k_h = InstanceKlass::cast(k);
1959       Handle jcp = reflect_ConstantPool::create(CHECK_NULL);
1960       reflect_ConstantPool::set_cp(jcp(), k_h-&gt;constants());
1961       return JNIHandles::make_local(jcp());
1962     }
1963   }
1964   return NULL;
1965 }
1966 JVM_END
1967 
1968 
1969 JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))
1970 {
1971   JVMWrapper(&quot;JVM_ConstantPoolGetSize&quot;);
1972   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
1973   return cp-&gt;length();
1974 }
1975 JVM_END
1976 
1977 
1978 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jobject unused, jint index))
1979 {
1980   JVMWrapper(&quot;JVM_ConstantPoolGetClassAt&quot;);
1981   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
1982   bounds_check(cp, index, CHECK_NULL);
1983   constantTag tag = cp-&gt;tag_at(index);
1984   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
1985     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
1986   }
1987   Klass* k = cp-&gt;klass_at(index, CHECK_NULL);
1988   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
1989 }
1990 JVM_END
1991 
1992 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
1993 {
1994   JVMWrapper(&quot;JVM_ConstantPoolGetClassAtIfLoaded&quot;);
1995   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
1996   bounds_check(cp, index, CHECK_NULL);
1997   constantTag tag = cp-&gt;tag_at(index);
1998   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
1999     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2000   }
2001   Klass* k = ConstantPool::klass_at_if_loaded(cp, index);
2002   if (k == NULL) return NULL;
2003   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2004 }
2005 JVM_END
2006 
2007 static jobject get_method_at_helper(const constantPoolHandle&amp; cp, jint index, bool force_resolution, TRAPS) {
2008   constantTag tag = cp-&gt;tag_at(index);
2009   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2010     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2011   }
2012   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2013   Klass* k_o;
2014   if (force_resolution) {
2015     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2016   } else {
2017     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2018     if (k_o == NULL) return NULL;
2019   }
2020   InstanceKlass* k = InstanceKlass::cast(k_o);
2021   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2022   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2023   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2024   if (m.is_null()) {
2025     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2026   }
2027   oop method;
2028   if (!m-&gt;is_initializer() || m-&gt;is_static()) {
2029     method = Reflection::new_method(m, true, CHECK_NULL);
2030   } else {
2031     method = Reflection::new_constructor(m, CHECK_NULL);
2032   }
2033   return JNIHandles::make_local(method);
2034 }
2035 
2036 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2037 {
2038   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2039   JvmtiVMObjectAllocEventCollector oam;
2040   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2041   bounds_check(cp, index, CHECK_NULL);
2042   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2043   return res;
2044 }
2045 JVM_END
2046 
2047 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2048 {
2049   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2050   JvmtiVMObjectAllocEventCollector oam;
2051   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2052   bounds_check(cp, index, CHECK_NULL);
2053   jobject res = get_method_at_helper(cp, index, false, CHECK_NULL);
2054   return res;
2055 }
2056 JVM_END
2057 
2058 static jobject get_field_at_helper(constantPoolHandle cp, jint index, bool force_resolution, TRAPS) {
2059   constantTag tag = cp-&gt;tag_at(index);
2060   if (!tag.is_field()) {
2061     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2062   }
2063   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2064   Klass* k_o;
2065   if (force_resolution) {
2066     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2067   } else {
2068     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2069     if (k_o == NULL) return NULL;
2070   }
2071   InstanceKlass* k = InstanceKlass::cast(k_o);
2072   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2073   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2074   fieldDescriptor fd;
2075   Klass* target_klass = k-&gt;find_field(name, sig, &amp;fd);
2076   if (target_klass == NULL) {
2077     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up field in target class&quot;);
2078   }
2079   oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
2080   return JNIHandles::make_local(field);
2081 }
2082 
2083 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jobject unusedl, jint index))
2084 {
2085   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAt&quot;);
2086   JvmtiVMObjectAllocEventCollector oam;
2087   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2088   bounds_check(cp, index, CHECK_NULL);
2089   jobject res = get_field_at_helper(cp, index, true, CHECK_NULL);
2090   return res;
2091 }
2092 JVM_END
2093 
2094 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2095 {
2096   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAtIfLoaded&quot;);
2097   JvmtiVMObjectAllocEventCollector oam;
2098   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2099   bounds_check(cp, index, CHECK_NULL);
2100   jobject res = get_field_at_helper(cp, index, false, CHECK_NULL);
2101   return res;
2102 }
2103 JVM_END
2104 
2105 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2106 {
2107   JVMWrapper(&quot;JVM_ConstantPoolGetMemberRefInfoAt&quot;);
2108   JvmtiVMObjectAllocEventCollector oam;
2109   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2110   bounds_check(cp, index, CHECK_NULL);
2111   constantTag tag = cp-&gt;tag_at(index);
2112   if (!tag.is_field_or_method()) {
2113     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2114   }
2115   int klass_ref = cp-&gt;uncached_klass_ref_index_at(index);
2116   Symbol*  klass_name  = cp-&gt;klass_name_at(klass_ref);
2117   Symbol*  member_name = cp-&gt;uncached_name_ref_at(index);
2118   Symbol*  member_sig  = cp-&gt;uncached_signature_ref_at(index);
2119   objArrayOop  dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 3, CHECK_NULL);
2120   objArrayHandle dest(THREAD, dest_o);
2121   Handle str = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2122   dest-&gt;obj_at_put(0, str());
2123   str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2124   dest-&gt;obj_at_put(1, str());
2125   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2126   dest-&gt;obj_at_put(2, str());
2127   return (jobjectArray) JNIHandles::make_local(dest());
2128 }
2129 JVM_END
2130 
2131 JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2132 {
2133   JVMWrapper(&quot;JVM_ConstantPoolGetClassRefIndexAt&quot;);
2134   JvmtiVMObjectAllocEventCollector oam;
2135   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2136   bounds_check(cp, index, CHECK_0);
2137   constantTag tag = cp-&gt;tag_at(index);
2138   if (!tag.is_field_or_method()) {
2139     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2140   }
2141   return (jint) cp-&gt;uncached_klass_ref_index_at(index);
2142 }
2143 JVM_END
2144 
2145 JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2146 {
2147   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefIndexAt&quot;);
2148   JvmtiVMObjectAllocEventCollector oam;
2149   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2150   bounds_check(cp, index, CHECK_0);
2151   constantTag tag = cp-&gt;tag_at(index);
2152   if (!tag.is_invoke_dynamic() &amp;&amp; !tag.is_field_or_method()) {
2153     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2154   }
2155   return (jint) cp-&gt;uncached_name_and_type_ref_index_at(index);
2156 }
2157 JVM_END
2158 
2159 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2160 {
2161   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefInfoAt&quot;);
2162   JvmtiVMObjectAllocEventCollector oam;
2163   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2164   bounds_check(cp, index, CHECK_NULL);
2165   constantTag tag = cp-&gt;tag_at(index);
2166   if (!tag.is_name_and_type()) {
2167     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2168   }
2169   Symbol* member_name = cp-&gt;symbol_at(cp-&gt;name_ref_index_at(index));
2170   Symbol* member_sig = cp-&gt;symbol_at(cp-&gt;signature_ref_index_at(index));
2171   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);
2172   objArrayHandle dest(THREAD, dest_o);
2173   Handle str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2174   dest-&gt;obj_at_put(0, str());
2175   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2176   dest-&gt;obj_at_put(1, str());
2177   return (jobjectArray) JNIHandles::make_local(dest());
2178 }
2179 JVM_END
2180 
2181 JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2182 {
2183   JVMWrapper(&quot;JVM_ConstantPoolGetIntAt&quot;);
2184   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2185   bounds_check(cp, index, CHECK_0);
2186   constantTag tag = cp-&gt;tag_at(index);
2187   if (!tag.is_int()) {
2188     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2189   }
2190   return cp-&gt;int_at(index);
2191 }
2192 JVM_END
2193 
2194 JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2195 {
2196   JVMWrapper(&quot;JVM_ConstantPoolGetLongAt&quot;);
2197   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2198   bounds_check(cp, index, CHECK_(0L));
2199   constantTag tag = cp-&gt;tag_at(index);
2200   if (!tag.is_long()) {
2201     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2202   }
2203   return cp-&gt;long_at(index);
2204 }
2205 JVM_END
2206 
2207 JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2208 {
2209   JVMWrapper(&quot;JVM_ConstantPoolGetFloatAt&quot;);
2210   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2211   bounds_check(cp, index, CHECK_(0.0f));
2212   constantTag tag = cp-&gt;tag_at(index);
2213   if (!tag.is_float()) {
2214     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2215   }
2216   return cp-&gt;float_at(index);
2217 }
2218 JVM_END
2219 
2220 JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2221 {
2222   JVMWrapper(&quot;JVM_ConstantPoolGetDoubleAt&quot;);
2223   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2224   bounds_check(cp, index, CHECK_(0.0));
2225   constantTag tag = cp-&gt;tag_at(index);
2226   if (!tag.is_double()) {
2227     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2228   }
2229   return cp-&gt;double_at(index);
2230 }
2231 JVM_END
2232 
2233 JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2234 {
2235   JVMWrapper(&quot;JVM_ConstantPoolGetStringAt&quot;);
2236   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2237   bounds_check(cp, index, CHECK_NULL);
2238   constantTag tag = cp-&gt;tag_at(index);
2239   if (!tag.is_string()) {
2240     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2241   }
2242   oop str = cp-&gt;string_at(index, CHECK_NULL);
2243   return (jstring) JNIHandles::make_local(str);
2244 }
2245 JVM_END
2246 
2247 JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jobject unused, jint index))
2248 {
2249   JVMWrapper(&quot;JVM_ConstantPoolGetUTF8At&quot;);
2250   JvmtiVMObjectAllocEventCollector oam;
2251   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2252   bounds_check(cp, index, CHECK_NULL);
2253   constantTag tag = cp-&gt;tag_at(index);
2254   if (!tag.is_symbol()) {
2255     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2256   }
2257   Symbol* sym = cp-&gt;symbol_at(index);
2258   Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
2259   return (jstring) JNIHandles::make_local(str());
2260 }
2261 JVM_END
2262 
2263 JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2264 {
2265   JVMWrapper(&quot;JVM_ConstantPoolGetTagAt&quot;);
2266   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2267   bounds_check(cp, index, CHECK_0);
2268   constantTag tag = cp-&gt;tag_at(index);
2269   jbyte result = tag.value();
2270   // If returned tag values are not from the JVM spec, e.g. tags from 100 to 105,
2271   // they are changed to the corresponding tags from the JVM spec, so that java code in
2272   // sun.reflect.ConstantPool will return only tags from the JVM spec, not internal ones.
2273   if (tag.is_klass_or_reference()) {
2274       result = JVM_CONSTANT_Class;
2275   } else if (tag.is_string_index()) {
2276       result = JVM_CONSTANT_String;
2277   } else if (tag.is_method_type_in_error()) {
2278       result = JVM_CONSTANT_MethodType;
2279   } else if (tag.is_method_handle_in_error()) {
2280       result = JVM_CONSTANT_MethodHandle;
2281   } else if (tag.is_dynamic_constant_in_error()) {
2282       result = JVM_CONSTANT_Dynamic;
2283   }
2284   return result;
2285 }
2286 JVM_END
2287 
2288 // Assertion support. //////////////////////////////////////////////////////////
2289 
2290 JVM_ENTRY(jboolean, JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls))
2291   JVMWrapper(&quot;JVM_DesiredAssertionStatus&quot;);
2292   assert(cls != NULL, &quot;bad class&quot;);
2293 
2294   oop r = JNIHandles::resolve(cls);
2295   assert(! java_lang_Class::is_primitive(r), &quot;primitive classes not allowed&quot;);
2296   if (java_lang_Class::is_primitive(r)) return false;
2297 
2298   Klass* k = java_lang_Class::as_Klass(r);
2299   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2300   if (!k-&gt;is_instance_klass()) return false;
2301 
2302   ResourceMark rm(THREAD);
2303   const char* name = k-&gt;name()-&gt;as_C_string();
2304   bool system_class = k-&gt;class_loader() == NULL;
2305   return JavaAssertions::enabled(name, system_class);
2306 
2307 JVM_END
2308 
2309 
2310 // Return a new AssertionStatusDirectives object with the fields filled in with
2311 // command-line assertion arguments (i.e., -ea, -da).
2312 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2313   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2314   JvmtiVMObjectAllocEventCollector oam;
2315   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2316   return JNIHandles::make_local(env, asd);
2317 JVM_END
2318 
2319 // Verification ////////////////////////////////////////////////////////////////////////////////
2320 
2321 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2322 
2323 // RedefineClasses support: bug 6214132 caused verification to fail.
2324 // All functions from this section should call the jvmtiThreadSate function:
2325 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2326 // The function returns a Klass* of the _scratch_class if the verifier
2327 // was invoked in the middle of the class redefinition.
2328 // Otherwise it returns its argument value which is the _the_class Klass*.
2329 // Please, refer to the description in the jvmtiThreadSate.hpp.
2330 
2331 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2332   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2333   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2334   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2335   return k-&gt;name()-&gt;as_utf8();
2336 JVM_END
2337 
2338 
2339 JVM_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))
2340   JVMWrapper(&quot;JVM_GetClassCPTypes&quot;);
2341   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2342   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2343   // types will have length zero if this is not an InstanceKlass
2344   // (length is determined by call to JVM_GetClassCPEntriesCount)
2345   if (k-&gt;is_instance_klass()) {
2346     ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2347     for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
2348       constantTag tag = cp-&gt;tag_at(index);
2349       types[index] = (tag.is_unresolved_klass()) ? (unsigned char) JVM_CONSTANT_Class : tag.value();
2350     }
2351   }
2352 JVM_END
2353 
2354 
2355 JVM_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))
2356   JVMWrapper(&quot;JVM_GetClassCPEntriesCount&quot;);
2357   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2358   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2359   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;constants()-&gt;length();
2360 JVM_END
2361 
2362 
2363 JVM_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))
2364   JVMWrapper(&quot;JVM_GetClassFieldsCount&quot;);
2365   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2366   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2367   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;java_fields_count();
2368 JVM_END
2369 
2370 
2371 JVM_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))
2372   JVMWrapper(&quot;JVM_GetClassMethodsCount&quot;);
2373   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2374   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2375   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;methods()-&gt;length();
2376 JVM_END
2377 
2378 
2379 // The following methods, used for the verifier, are never called with
2380 // array klasses, so a direct cast to InstanceKlass is safe.
2381 // Typically, these methods are called in a loop with bounds determined
2382 // by the results of JVM_GetClass{Fields,Methods}Count, which return
2383 // zero for arrays.
2384 JVM_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))
2385   JVMWrapper(&quot;JVM_GetMethodIxExceptionIndexes&quot;);
2386   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2387   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2388   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2389   int length = method-&gt;checked_exceptions_length();
2390   if (length &gt; 0) {
2391     CheckedExceptionElement* table= method-&gt;checked_exceptions_start();
2392     for (int i = 0; i &lt; length; i++) {
2393       exceptions[i] = table[i].class_cp_index;
2394     }
2395   }
2396 JVM_END
2397 
2398 
2399 JVM_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))
2400   JVMWrapper(&quot;JVM_GetMethodIxExceptionsCount&quot;);
2401   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2402   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2403   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2404   return method-&gt;checked_exceptions_length();
2405 JVM_END
2406 
2407 
2408 JVM_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))
2409   JVMWrapper(&quot;JVM_GetMethodIxByteCode&quot;);
2410   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2411   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2412   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2413   memcpy(code, method-&gt;code_base(), method-&gt;code_size());
2414 JVM_END
2415 
2416 
2417 JVM_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))
2418   JVMWrapper(&quot;JVM_GetMethodIxByteCodeLength&quot;);
2419   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2420   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2421   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2422   return method-&gt;code_size();
2423 JVM_END
2424 
2425 
2426 JVM_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))
2427   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableEntry&quot;);
2428   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2429   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2430   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2431   ExceptionTable extable(method);
2432   entry-&gt;start_pc   = extable.start_pc(entry_index);
2433   entry-&gt;end_pc     = extable.end_pc(entry_index);
2434   entry-&gt;handler_pc = extable.handler_pc(entry_index);
2435   entry-&gt;catchType  = extable.catch_type_index(entry_index);
2436 JVM_END
2437 
2438 
2439 JVM_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))
2440   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableLength&quot;);
2441   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2442   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2443   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2444   return method-&gt;exception_table_length();
2445 JVM_END
2446 
2447 
2448 JVM_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))
2449   JVMWrapper(&quot;JVM_GetMethodIxModifiers&quot;);
2450   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2451   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2452   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2453   return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2454 JVM_END
2455 
2456 
2457 JVM_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))
2458   JVMWrapper(&quot;JVM_GetFieldIxModifiers&quot;);
2459   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2460   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2461   return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2462 JVM_END
2463 
2464 
2465 JVM_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))
2466   JVMWrapper(&quot;JVM_GetMethodIxLocalsCount&quot;);
2467   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2468   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2469   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2470   return method-&gt;max_locals();
2471 JVM_END
2472 
2473 
2474 JVM_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))
2475   JVMWrapper(&quot;JVM_GetMethodIxArgsSize&quot;);
2476   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2477   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2478   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2479   return method-&gt;size_of_parameters();
2480 JVM_END
2481 
2482 
2483 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2484   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2485   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2486   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2487   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2488   return method-&gt;verifier_max_stack();
2489 JVM_END
2490 
2491 
2492 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2493   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2494   ResourceMark rm(THREAD);
2495   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2496   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2497   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2498   return method-&gt;name() == vmSymbols::object_initializer_name();
2499 JVM_END
2500 
2501 
2502 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2503   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2504   ResourceMark rm(THREAD);
2505   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2506   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2507   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2508   return method-&gt;is_overpass();
2509 JVM_END
2510 
2511 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2512   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2513   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2514   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2515   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2516   return method-&gt;name()-&gt;as_utf8();
2517 JVM_END
2518 
2519 
2520 JVM_ENTRY(const char*, JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cls, jint method_index))
2521   JVMWrapper(&quot;JVM_GetMethodIxSignatureUTF&quot;);
2522   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2523   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2524   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2525   return method-&gt;signature()-&gt;as_utf8();
2526 JVM_END
2527 
2528 /**
2529  * All of these JVM_GetCP-xxx methods are used by the old verifier to
2530  * read entries in the constant pool.  Since the old verifier always
2531  * works on a copy of the code, it will not see any rewriting that
2532  * may possibly occur in the middle of verification.  So it is important
2533  * that nothing it calls tries to use the cpCache instead of the raw
2534  * constant pool, so we must use cp-&gt;uncached_x methods when appropriate.
2535  */
2536 JVM_ENTRY(const char*, JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2537   JVMWrapper(&quot;JVM_GetCPFieldNameUTF&quot;);
2538   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2539   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2540   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2541   switch (cp-&gt;tag_at(cp_index).value()) {
2542     case JVM_CONSTANT_Fieldref:
2543       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2544     default:
2545       fatal(&quot;JVM_GetCPFieldNameUTF: illegal constant&quot;);
2546   }
2547   ShouldNotReachHere();
2548   return NULL;
2549 JVM_END
2550 
2551 
2552 JVM_ENTRY(const char*, JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2553   JVMWrapper(&quot;JVM_GetCPMethodNameUTF&quot;);
2554   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2555   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2556   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2557   switch (cp-&gt;tag_at(cp_index).value()) {
2558     case JVM_CONSTANT_InterfaceMethodref:
2559     case JVM_CONSTANT_Methodref:
2560       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2561     default:
2562       fatal(&quot;JVM_GetCPMethodNameUTF: illegal constant&quot;);
2563   }
2564   ShouldNotReachHere();
2565   return NULL;
2566 JVM_END
2567 
2568 
2569 JVM_ENTRY(const char*, JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2570   JVMWrapper(&quot;JVM_GetCPMethodSignatureUTF&quot;);
2571   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2572   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2573   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2574   switch (cp-&gt;tag_at(cp_index).value()) {
2575     case JVM_CONSTANT_InterfaceMethodref:
2576     case JVM_CONSTANT_Methodref:
2577       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2578     default:
2579       fatal(&quot;JVM_GetCPMethodSignatureUTF: illegal constant&quot;);
2580   }
2581   ShouldNotReachHere();
2582   return NULL;
2583 JVM_END
2584 
2585 
2586 JVM_ENTRY(const char*, JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2587   JVMWrapper(&quot;JVM_GetCPFieldSignatureUTF&quot;);
2588   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2589   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2590   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2591   switch (cp-&gt;tag_at(cp_index).value()) {
2592     case JVM_CONSTANT_Fieldref:
2593       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2594     default:
2595       fatal(&quot;JVM_GetCPFieldSignatureUTF: illegal constant&quot;);
2596   }
2597   ShouldNotReachHere();
2598   return NULL;
2599 JVM_END
2600 
2601 
2602 JVM_ENTRY(const char*, JVM_GetCPClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2603   JVMWrapper(&quot;JVM_GetCPClassNameUTF&quot;);
2604   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2605   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2606   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2607   Symbol* classname = cp-&gt;klass_name_at(cp_index);
2608   return classname-&gt;as_utf8();
2609 JVM_END
2610 
2611 
2612 JVM_ENTRY(const char*, JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2613   JVMWrapper(&quot;JVM_GetCPFieldClassNameUTF&quot;);
2614   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2615   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2616   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2617   switch (cp-&gt;tag_at(cp_index).value()) {
2618     case JVM_CONSTANT_Fieldref: {
2619       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2620       Symbol* classname = cp-&gt;klass_name_at(class_index);
2621       return classname-&gt;as_utf8();
2622     }
2623     default:
2624       fatal(&quot;JVM_GetCPFieldClassNameUTF: illegal constant&quot;);
2625   }
2626   ShouldNotReachHere();
2627   return NULL;
2628 JVM_END
2629 
2630 
2631 JVM_ENTRY(const char*, JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2632   JVMWrapper(&quot;JVM_GetCPMethodClassNameUTF&quot;);
2633   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2634   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2635   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2636   switch (cp-&gt;tag_at(cp_index).value()) {
2637     case JVM_CONSTANT_Methodref:
2638     case JVM_CONSTANT_InterfaceMethodref: {
2639       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2640       Symbol* classname = cp-&gt;klass_name_at(class_index);
2641       return classname-&gt;as_utf8();
2642     }
2643     default:
2644       fatal(&quot;JVM_GetCPMethodClassNameUTF: illegal constant&quot;);
2645   }
2646   ShouldNotReachHere();
2647   return NULL;
2648 JVM_END
2649 
2650 
2651 JVM_ENTRY(jint, JVM_GetCPFieldModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2652   JVMWrapper(&quot;JVM_GetCPFieldModifiers&quot;);
2653   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2654   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2655   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2656   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2657   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2658   ConstantPool* cp_called = InstanceKlass::cast(k_called)-&gt;constants();
2659   switch (cp-&gt;tag_at(cp_index).value()) {
2660     case JVM_CONSTANT_Fieldref: {
2661       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2662       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2663       InstanceKlass* ik = InstanceKlass::cast(k_called);
2664       for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {
2665         if (fs.name() == name &amp;&amp; fs.signature() == signature) {
2666           return fs.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2667         }
2668       }
2669       return -1;
2670     }
2671     default:
2672       fatal(&quot;JVM_GetCPFieldModifiers: illegal constant&quot;);
2673   }
2674   ShouldNotReachHere();
2675   return 0;
2676 JVM_END
2677 
2678 
2679 JVM_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2680   JVMWrapper(&quot;JVM_GetCPMethodModifiers&quot;);
2681   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2682   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2683   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2684   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2685   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2686   switch (cp-&gt;tag_at(cp_index).value()) {
2687     case JVM_CONSTANT_Methodref:
2688     case JVM_CONSTANT_InterfaceMethodref: {
2689       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2690       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2691       Array&lt;Method*&gt;* methods = InstanceKlass::cast(k_called)-&gt;methods();
2692       int methods_count = methods-&gt;length();
2693       for (int i = 0; i &lt; methods_count; i++) {
2694         Method* method = methods-&gt;at(i);
2695         if (method-&gt;name() == name &amp;&amp; method-&gt;signature() == signature) {
2696             return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2697         }
2698       }
2699       return -1;
2700     }
2701     default:
2702       fatal(&quot;JVM_GetCPMethodModifiers: illegal constant&quot;);
2703   }
2704   ShouldNotReachHere();
2705   return 0;
2706 JVM_END
2707 
2708 
2709 // Misc //////////////////////////////////////////////////////////////////////////////////////////////
2710 
2711 JVM_LEAF(void, JVM_ReleaseUTF(const char *utf))
2712   // So long as UTF8::convert_to_utf8 returns resource strings, we don&#39;t have to do anything
2713 JVM_END
2714 
2715 
2716 JVM_ENTRY(jboolean, JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2))
2717   JVMWrapper(&quot;JVM_IsSameClassPackage&quot;);
2718   oop class1_mirror = JNIHandles::resolve_non_null(class1);
2719   oop class2_mirror = JNIHandles::resolve_non_null(class2);
2720   Klass* klass1 = java_lang_Class::as_Klass(class1_mirror);
2721   Klass* klass2 = java_lang_Class::as_Klass(class2_mirror);
2722   return (jboolean) Reflection::is_same_class_package(klass1, klass2);
2723 JVM_END
2724 
2725 // Printing support //////////////////////////////////////////////////
2726 extern &quot;C&quot; {
2727 
2728 ATTRIBUTE_PRINTF(3, 0)
2729 int jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args) {
2730   // Reject count values that are negative signed values converted to
2731   // unsigned; see bug 4399518, 4417214
2732   if ((intptr_t)count &lt;= 0) return -1;
2733 
2734   int result = os::vsnprintf(str, count, fmt, args);
2735   if (result &gt; 0 &amp;&amp; (size_t)result &gt;= count) {
2736     result = -1;
2737   }
2738 
2739   return result;
2740 }
2741 
2742 ATTRIBUTE_PRINTF(3, 4)
2743 int jio_snprintf(char *str, size_t count, const char *fmt, ...) {
2744   va_list args;
2745   int len;
2746   va_start(args, fmt);
2747   len = jio_vsnprintf(str, count, fmt, args);
2748   va_end(args);
2749   return len;
2750 }
2751 
2752 ATTRIBUTE_PRINTF(2, 3)
2753 int jio_fprintf(FILE* f, const char *fmt, ...) {
2754   int len;
2755   va_list args;
2756   va_start(args, fmt);
2757   len = jio_vfprintf(f, fmt, args);
2758   va_end(args);
2759   return len;
2760 }
2761 
2762 ATTRIBUTE_PRINTF(2, 0)
2763 int jio_vfprintf(FILE* f, const char *fmt, va_list args) {
2764   if (Arguments::vfprintf_hook() != NULL) {
2765      return Arguments::vfprintf_hook()(f, fmt, args);
2766   } else {
2767     return vfprintf(f, fmt, args);
2768   }
2769 }
2770 
2771 ATTRIBUTE_PRINTF(1, 2)
2772 JNIEXPORT int jio_printf(const char *fmt, ...) {
2773   int len;
2774   va_list args;
2775   va_start(args, fmt);
2776   len = jio_vfprintf(defaultStream::output_stream(), fmt, args);
2777   va_end(args);
2778   return len;
2779 }
2780 
2781 // HotSpot specific jio method
2782 void jio_print(const char* s, size_t len) {
2783   // Try to make this function as atomic as possible.
2784   if (Arguments::vfprintf_hook() != NULL) {
2785     jio_fprintf(defaultStream::output_stream(), &quot;%.*s&quot;, (int)len, s);
2786   } else {
2787     // Make an unused local variable to avoid warning from gcc compiler.
2788     size_t count = ::write(defaultStream::output_fd(), s, (int)len);
2789   }
2790 }
2791 
2792 } // Extern C
2793 
2794 // java.lang.Thread //////////////////////////////////////////////////////////////////////////////
2795 
2796 // In most of the JVM thread support functions we need to access the
2797 // thread through a ThreadsListHandle to prevent it from exiting and
2798 // being reclaimed while we try to operate on it. The exceptions to this
2799 // rule are when operating on the current thread, or if the monitor of
2800 // the target java.lang.Thread is locked at the Java level - in both
2801 // cases the target cannot exit.
2802 
2803 static void thread_entry(JavaThread* thread, TRAPS) {
2804   HandleMark hm(THREAD);
2805   Handle obj(THREAD, thread-&gt;threadObj());
2806   JavaValue result(T_VOID);
2807   JavaCalls::call_virtual(&amp;result,
2808                           obj,
2809                           SystemDictionary::Thread_klass(),
2810                           vmSymbols::run_method_name(),
2811                           vmSymbols::void_method_signature(),
2812                           THREAD);
2813 }
2814 
2815 
2816 JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
2817   JVMWrapper(&quot;JVM_StartThread&quot;);
2818   JavaThread *native_thread = NULL;
2819 
2820   // We cannot hold the Threads_lock when we throw an exception,
2821   // due to rank ordering issues. Example:  we might need to grab the
2822   // Heap_lock while we construct the exception.
2823   bool throw_illegal_thread_state = false;
2824 
2825   // We must release the Threads_lock before we can post a jvmti event
2826   // in Thread::start.
2827   {
2828     // Ensure that the C++ Thread and OSThread structures aren&#39;t freed before
2829     // we operate.
2830     MutexLocker mu(Threads_lock);
2831 
2832     // Since JDK 5 the java.lang.Thread threadStatus is used to prevent
2833     // re-starting an already started thread, so we should usually find
2834     // that the JavaThread is null. However for a JNI attached thread
2835     // there is a small window between the Thread object being created
2836     // (with its JavaThread set) and the update to its threadStatus, so we
2837     // have to check for this
2838     if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {
2839       throw_illegal_thread_state = true;
2840     } else {
2841       // We could also check the stillborn flag to see if this thread was already stopped, but
2842       // for historical reasons we let the thread detect that itself when it starts running
2843 
2844       jlong size =
2845              java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));
2846       // Allocate the C++ Thread structure and create the native thread.  The
2847       // stack size retrieved from java is 64-bit signed, but the constructor takes
2848       // size_t (an unsigned type), which may be 32 or 64-bit depending on the platform.
2849       //  - Avoid truncating on 32-bit platforms if size is greater than UINT_MAX.
2850       //  - Avoid passing negative values which would result in really large stacks.
2851       NOT_LP64(if (size &gt; SIZE_MAX) size = SIZE_MAX;)
2852       size_t sz = size &gt; 0 ? (size_t) size : 0;
2853       native_thread = new JavaThread(&amp;thread_entry, sz);
2854 
2855       // At this point it may be possible that no osthread was created for the
2856       // JavaThread due to lack of memory. Check for this situation and throw
2857       // an exception if necessary. Eventually we may want to change this so
2858       // that we only grab the lock if the thread was created successfully -
2859       // then we can also do this check and throw the exception in the
2860       // JavaThread constructor.
2861       if (native_thread-&gt;osthread() != NULL) {
2862         // Note: the current thread is not being used within &quot;prepare&quot;.
2863         native_thread-&gt;prepare(jthread);
2864       }
2865     }
2866   }
2867 
2868   if (throw_illegal_thread_state) {
2869     THROW(vmSymbols::java_lang_IllegalThreadStateException());
2870   }
2871 
2872   assert(native_thread != NULL, &quot;Starting null thread?&quot;);
2873 
2874   if (native_thread-&gt;osthread() == NULL) {
2875     // No one should hold a reference to the &#39;native_thread&#39;.
2876     native_thread-&gt;smr_delete();
2877     if (JvmtiExport::should_post_resource_exhausted()) {
2878       JvmtiExport::post_resource_exhausted(
2879         JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,
2880         os::native_thread_creation_failed_msg());
2881     }
2882     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),
2883               os::native_thread_creation_failed_msg());
2884   }
2885 
2886 #if INCLUDE_JFR
2887   if (JfrRecorder::is_recording() &amp;&amp; EventThreadStart::is_enabled() &amp;&amp;
2888       EventThreadStart::is_stacktrace_enabled()) {
2889     JfrThreadLocal* tl = native_thread-&gt;jfr_thread_local();
2890     // skip Thread.start() and Thread.start0()
2891     tl-&gt;set_cached_stack_trace_id(JfrStackTraceRepository::record(thread, 2));
2892   }
2893 #endif
2894 
2895   Thread::start(native_thread);
2896 
2897 JVM_END
2898 
2899 
2900 // JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints
2901 // before the quasi-asynchronous exception is delivered.  This is a little obtrusive,
2902 // but is thought to be reliable and simple. In the case, where the receiver is the
2903 // same thread as the sender, no VM_Operation is needed.
2904 JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))
2905   JVMWrapper(&quot;JVM_StopThread&quot;);
2906 
2907   // A nested ThreadsListHandle will grab the Threads_lock so create
2908   // tlh before we resolve throwable.
2909   ThreadsListHandle tlh(thread);
2910   oop java_throwable = JNIHandles::resolve(throwable);
2911   if (java_throwable == NULL) {
2912     THROW(vmSymbols::java_lang_NullPointerException());
2913   }
2914   oop java_thread = NULL;
2915   JavaThread* receiver = NULL;
2916   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
2917   Events::log_exception(thread,
2918                         &quot;JVM_StopThread thread JavaThread &quot; INTPTR_FORMAT &quot; as oop &quot; INTPTR_FORMAT &quot; [exception &quot; INTPTR_FORMAT &quot;]&quot;,
2919                         p2i(receiver), p2i(java_thread), p2i(throwable));
2920 
2921   if (is_alive) {
2922     // jthread refers to a live JavaThread.
2923     if (thread == receiver) {
2924       // Exception is getting thrown at self so no VM_Operation needed.
2925       THROW_OOP(java_throwable);
2926     } else {
2927       // Use a VM_Operation to throw the exception.
2928       Thread::send_async_exception(java_thread, java_throwable);
2929     }
2930   } else {
2931     // Either:
2932     // - target thread has not been started before being stopped, or
2933     // - target thread already terminated
2934     // We could read the threadStatus to determine which case it is
2935     // but that is overkill as it doesn&#39;t matter. We must set the
2936     // stillborn flag for the first case, and if the thread has already
2937     // exited setting this flag has no effect.
2938     java_lang_Thread::set_stillborn(java_thread);
2939   }
2940 JVM_END
2941 
2942 
2943 JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))
2944   JVMWrapper(&quot;JVM_IsThreadAlive&quot;);
2945 
2946   oop thread_oop = JNIHandles::resolve_non_null(jthread);
2947   return java_lang_Thread::is_alive(thread_oop);
2948 JVM_END
2949 
2950 
2951 JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))
2952   JVMWrapper(&quot;JVM_SuspendThread&quot;);
2953 
2954   ThreadsListHandle tlh(thread);
2955   JavaThread* receiver = NULL;
2956   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
2957   if (is_alive) {
2958     // jthread refers to a live JavaThread.
2959     {
2960       MutexLocker ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);
2961       if (receiver-&gt;is_external_suspend()) {
2962         // Don&#39;t allow nested external suspend requests. We can&#39;t return
2963         // an error from this interface so just ignore the problem.
2964         return;
2965       }
2966       if (receiver-&gt;is_exiting()) { // thread is in the process of exiting
2967         return;
2968       }
2969       receiver-&gt;set_external_suspend();
2970     }
2971 
2972     // java_suspend() will catch threads in the process of exiting
2973     // and will ignore them.
2974     receiver-&gt;java_suspend();
2975 
2976     // It would be nice to have the following assertion in all the
2977     // time, but it is possible for a racing resume request to have
2978     // resumed this thread right after we suspended it. Temporarily
2979     // enable this assertion if you are chasing a different kind of
2980     // bug.
2981     //
2982     // assert(java_lang_Thread::thread(receiver-&gt;threadObj()) == NULL ||
2983     //   receiver-&gt;is_being_ext_suspended(), &quot;thread is not suspended&quot;);
2984   }
2985 JVM_END
2986 
2987 
2988 JVM_ENTRY(void, JVM_ResumeThread(JNIEnv* env, jobject jthread))
2989   JVMWrapper(&quot;JVM_ResumeThread&quot;);
2990 
2991   ThreadsListHandle tlh(thread);
2992   JavaThread* receiver = NULL;
2993   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
2994   if (is_alive) {
2995     // jthread refers to a live JavaThread.
2996 
2997     // This is the original comment for this Threads_lock grab:
2998     //   We need to *always* get the threads lock here, since this operation cannot be allowed during
2999     //   a safepoint. The safepoint code relies on suspending a thread to examine its state. If other
3000     //   threads randomly resumes threads, then a thread might not be suspended when the safepoint code
3001     //   looks at it.
3002     //
3003     // The above comment dates back to when we had both internal and
3004     // external suspend APIs that shared a common underlying mechanism.
3005     // External suspend is now entirely cooperative and doesn&#39;t share
3006     // anything with internal suspend. That said, there are some
3007     // assumptions in the VM that an external resume grabs the
3008     // Threads_lock. We can&#39;t drop the Threads_lock grab here until we
3009     // resolve the assumptions that exist elsewhere.
3010     //
3011     MutexLocker ml(Threads_lock);
3012     receiver-&gt;java_resume();
3013   }
3014 JVM_END
3015 
3016 
3017 JVM_ENTRY(void, JVM_SetThreadPriority(JNIEnv* env, jobject jthread, jint prio))
3018   JVMWrapper(&quot;JVM_SetThreadPriority&quot;);
3019 
3020   ThreadsListHandle tlh(thread);
3021   oop java_thread = NULL;
3022   JavaThread* receiver = NULL;
3023   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3024   java_lang_Thread::set_priority(java_thread, (ThreadPriority)prio);
3025 
3026   if (is_alive) {
3027     // jthread refers to a live JavaThread.
3028     Thread::set_priority(receiver, (ThreadPriority)prio);
3029   }
3030   // Implied else: If the JavaThread hasn&#39;t started yet, then the
3031   // priority set in the java.lang.Thread object above will be pushed
3032   // down when it does start.
3033 JVM_END
3034 
3035 
3036 JVM_ENTRY(void, JVM_Yield(JNIEnv *env, jclass threadClass))
3037   JVMWrapper(&quot;JVM_Yield&quot;);
3038   if (os::dont_yield()) return;
3039   HOTSPOT_THREAD_YIELD();
3040   os::naked_yield();
3041 JVM_END
3042 
3043 static void post_thread_sleep_event(EventThreadSleep* event, jlong millis) {
3044   assert(event != NULL, &quot;invariant&quot;);
3045   assert(event-&gt;should_commit(), &quot;invariant&quot;);
3046   event-&gt;set_time(millis);
3047   event-&gt;commit();
3048 }
3049 
3050 JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))
3051   JVMWrapper(&quot;JVM_Sleep&quot;);
3052 
3053   if (millis &lt; 0) {
3054     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
3055   }
3056 
3057   if (thread-&gt;is_interrupted(true) &amp;&amp; !HAS_PENDING_EXCEPTION) {
3058     THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3059   }
3060 
3061   // Save current thread state and restore it at the end of this block.
3062   // And set new thread state to SLEEPING.
3063   JavaThreadSleepState jtss(thread);
3064 
3065   HOTSPOT_THREAD_SLEEP_BEGIN(millis);
3066   EventThreadSleep event;
3067 
3068   if (millis == 0) {
3069     os::naked_yield();
3070   } else {
3071     ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
3072     thread-&gt;osthread()-&gt;set_state(SLEEPING);
3073     if (!thread-&gt;sleep(millis)) { // interrupted
3074       // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
3075       // us while we were sleeping. We do not overwrite those.
3076       if (!HAS_PENDING_EXCEPTION) {
3077         if (event.should_commit()) {
3078           post_thread_sleep_event(&amp;event, millis);
3079         }
3080         HOTSPOT_THREAD_SLEEP_END(1);
3081 
3082         // TODO-FIXME: THROW_MSG returns which means we will not call set_state()
3083         // to properly restore the thread state.  That&#39;s likely wrong.
3084         THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3085       }
3086     }
3087     thread-&gt;osthread()-&gt;set_state(old_state);
3088   }
3089   if (event.should_commit()) {
3090     post_thread_sleep_event(&amp;event, millis);
3091   }
3092   HOTSPOT_THREAD_SLEEP_END(0);
3093 JVM_END
3094 
3095 JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
3096   JVMWrapper(&quot;JVM_CurrentThread&quot;);
3097   oop jthread = thread-&gt;threadObj();
3098   assert (thread != NULL, &quot;no current thread!&quot;);
3099   return JNIHandles::make_local(env, jthread);
3100 JVM_END
3101 
3102 JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
3103   JVMWrapper(&quot;JVM_Interrupt&quot;);
3104 
3105   ThreadsListHandle tlh(thread);
3106   JavaThread* receiver = NULL;
3107   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3108   if (is_alive) {
3109     // jthread refers to a live JavaThread.
3110     receiver-&gt;interrupt();
3111   }
3112 JVM_END
3113 
3114 
3115 // Return true iff the current thread has locked the object passed in
3116 
3117 JVM_ENTRY(jboolean, JVM_HoldsLock(JNIEnv* env, jclass threadClass, jobject obj))
3118   JVMWrapper(&quot;JVM_HoldsLock&quot;);
3119   assert(THREAD-&gt;is_Java_thread(), &quot;sanity check&quot;);
3120   if (obj == NULL) {
3121     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
3122   }
3123   Handle h_obj(THREAD, JNIHandles::resolve(obj));
3124   return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);
3125 JVM_END
3126 
3127 
3128 JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))
3129   JVMWrapper(&quot;JVM_DumpAllStacks&quot;);
3130   VM_PrintThreads op;
3131   VMThread::execute(&amp;op);
3132   if (JvmtiExport::should_post_data_dump()) {
3133     JvmtiExport::post_data_dump();
3134   }
3135 JVM_END
3136 
3137 JVM_ENTRY(void, JVM_SetNativeThreadName(JNIEnv* env, jobject jthread, jstring name))
3138   JVMWrapper(&quot;JVM_SetNativeThreadName&quot;);
3139 
3140   // We don&#39;t use a ThreadsListHandle here because the current thread
3141   // must be alive.
3142   oop java_thread = JNIHandles::resolve_non_null(jthread);
3143   JavaThread* thr = java_lang_Thread::thread(java_thread);
3144   if (thread == thr &amp;&amp; !thr-&gt;has_attached_via_jni()) {
3145     // Thread naming is only supported for the current thread and
3146     // we don&#39;t set the name of an attached thread to avoid stepping
3147     // on other programs.
3148     ResourceMark rm(thread);
3149     const char *thread_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3150     os::set_native_thread_name(thread_name);
3151   }
3152 JVM_END
3153 
3154 // java.lang.SecurityManager ///////////////////////////////////////////////////////////////////////
3155 
3156 JVM_ENTRY(jobjectArray, JVM_GetClassContext(JNIEnv *env))
3157   JVMWrapper(&quot;JVM_GetClassContext&quot;);
3158   ResourceMark rm(THREAD);
3159   JvmtiVMObjectAllocEventCollector oam;
3160   vframeStream vfst(thread);
3161 
3162   if (SystemDictionary::reflect_CallerSensitive_klass() != NULL) {
3163     // This must only be called from SecurityManager.getClassContext
3164     Method* m = vfst.method();
3165     if (!(m-&gt;method_holder() == SystemDictionary::SecurityManager_klass() &amp;&amp;
3166           m-&gt;name()          == vmSymbols::getClassContext_name() &amp;&amp;
3167           m-&gt;signature()     == vmSymbols::void_class_array_signature())) {
3168       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetClassContext must only be called from SecurityManager.getClassContext&quot;);
3169     }
3170   }
3171 
3172   // Collect method holders
3173   GrowableArray&lt;Klass*&gt;* klass_array = new GrowableArray&lt;Klass*&gt;();
3174   for (; !vfst.at_end(); vfst.security_next()) {
3175     Method* m = vfst.method();
3176     // Native frames are not returned
3177     if (!m-&gt;is_ignored_by_security_stack_walk() &amp;&amp; !m-&gt;is_native()) {
3178       Klass* holder = m-&gt;method_holder();
3179       assert(holder-&gt;is_klass(), &quot;just checking&quot;);
3180       klass_array-&gt;append(holder);
3181     }
3182   }
3183 
3184   // Create result array of type [Ljava/lang/Class;
3185   objArrayOop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), klass_array-&gt;length(), CHECK_NULL);
3186   // Fill in mirrors corresponding to method holders
3187   for (int i = 0; i &lt; klass_array-&gt;length(); i++) {
3188     result-&gt;obj_at_put(i, klass_array-&gt;at(i)-&gt;java_mirror());
3189   }
3190 
3191   return (jobjectArray) JNIHandles::make_local(env, result);
3192 JVM_END
3193 
3194 
3195 // java.lang.Package ////////////////////////////////////////////////////////////////
3196 
3197 
3198 JVM_ENTRY(jstring, JVM_GetSystemPackage(JNIEnv *env, jstring name))
3199   JVMWrapper(&quot;JVM_GetSystemPackage&quot;);
3200   ResourceMark rm(THREAD);
3201   JvmtiVMObjectAllocEventCollector oam;
3202   char* str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3203   oop result = ClassLoader::get_system_package(str, CHECK_NULL);
3204   return (jstring) JNIHandles::make_local(result);
3205 JVM_END
3206 
3207 
3208 JVM_ENTRY(jobjectArray, JVM_GetSystemPackages(JNIEnv *env))
3209   JVMWrapper(&quot;JVM_GetSystemPackages&quot;);
3210   JvmtiVMObjectAllocEventCollector oam;
3211   objArrayOop result = ClassLoader::get_system_packages(CHECK_NULL);
3212   return (jobjectArray) JNIHandles::make_local(result);
3213 JVM_END
3214 
3215 
3216 // java.lang.ref.Reference ///////////////////////////////////////////////////////////////
3217 
3218 
3219 JVM_ENTRY(jobject, JVM_GetAndClearReferencePendingList(JNIEnv* env))
3220   JVMWrapper(&quot;JVM_GetAndClearReferencePendingList&quot;);
3221 
3222   MonitorLocker ml(Heap_lock);
3223   oop ref = Universe::reference_pending_list();
3224   if (ref != NULL) {
3225     Universe::set_reference_pending_list(NULL);
3226   }
3227   return JNIHandles::make_local(env, ref);
3228 JVM_END
3229 
3230 JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))
3231   JVMWrapper(&quot;JVM_HasReferencePendingList&quot;);
3232   MonitorLocker ml(Heap_lock);
3233   return Universe::has_reference_pending_list();
3234 JVM_END
3235 
3236 JVM_ENTRY(void, JVM_WaitForReferencePendingList(JNIEnv* env))
3237   JVMWrapper(&quot;JVM_WaitForReferencePendingList&quot;);
3238   MonitorLocker ml(Heap_lock);
3239   while (!Universe::has_reference_pending_list()) {
3240     ml.wait();
3241   }
3242 JVM_END
3243 
3244 
3245 // ObjectInputStream ///////////////////////////////////////////////////////////////
3246 
3247 // Return the first user-defined class loader up the execution stack, or null
3248 // if only code from the bootstrap or platform class loader is on the stack.
3249 
3250 JVM_ENTRY(jobject, JVM_LatestUserDefinedLoader(JNIEnv *env))
3251   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3252     vfst.skip_reflection_related_frames(); // Only needed for 1.4 reflection
3253     oop loader = vfst.method()-&gt;method_holder()-&gt;class_loader();
3254     if (loader != NULL &amp;&amp; !SystemDictionary::is_platform_class_loader(loader)) {
3255       return JNIHandles::make_local(env, loader);
3256     }
3257   }
3258   return NULL;
3259 JVM_END
3260 
3261 
3262 // Array ///////////////////////////////////////////////////////////////////////////////////////////
3263 
3264 
3265 // resolve array handle and check arguments
3266 static inline arrayOop check_array(JNIEnv *env, jobject arr, bool type_array_only, TRAPS) {
3267   if (arr == NULL) {
3268     THROW_0(vmSymbols::java_lang_NullPointerException());
3269   }
3270   oop a = JNIHandles::resolve_non_null(arr);
3271   if (!a-&gt;is_array()) {
3272     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array&quot;);
3273   } else if (type_array_only &amp;&amp; !a-&gt;is_typeArray()) {
3274     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array of primitive type&quot;);
3275   }
3276   return arrayOop(a);
3277 }
3278 
3279 
3280 JVM_ENTRY(jint, JVM_GetArrayLength(JNIEnv *env, jobject arr))
3281   JVMWrapper(&quot;JVM_GetArrayLength&quot;);
3282   arrayOop a = check_array(env, arr, false, CHECK_0);
3283   return a-&gt;length();
3284 JVM_END
3285 
3286 
3287 JVM_ENTRY(jobject, JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index))
3288   JVMWrapper(&quot;JVM_Array_Get&quot;);
3289   JvmtiVMObjectAllocEventCollector oam;
3290   arrayOop a = check_array(env, arr, false, CHECK_NULL);
3291   jvalue value;
3292   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_NULL);
3293   oop box = Reflection::box(&amp;value, type, CHECK_NULL);
3294   return JNIHandles::make_local(env, box);
3295 JVM_END
3296 
3297 
3298 JVM_ENTRY(jvalue, JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode))
3299   JVMWrapper(&quot;JVM_GetPrimitiveArrayElement&quot;);
3300   jvalue value;
3301   value.i = 0; // to initialize value before getting used in CHECK
3302   arrayOop a = check_array(env, arr, true, CHECK_(value));
3303   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3304   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_(value));
3305   BasicType wide_type = (BasicType) wCode;
3306   if (type != wide_type) {
3307     Reflection::widen(&amp;value, type, wide_type, CHECK_(value));
3308   }
3309   return value;
3310 JVM_END
3311 
3312 
3313 JVM_ENTRY(void, JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val))
3314   JVMWrapper(&quot;JVM_SetArrayElement&quot;);
3315   arrayOop a = check_array(env, arr, false, CHECK);
3316   oop box = JNIHandles::resolve(val);
3317   jvalue value;
3318   value.i = 0; // to initialize value before getting used in CHECK
3319   BasicType value_type;
3320   if (a-&gt;is_objArray()) {
3321     // Make sure we do no unbox e.g. java/lang/Integer instances when storing into an object array
3322     value_type = Reflection::unbox_for_regular_object(box, &amp;value);
3323   } else {
3324     value_type = Reflection::unbox_for_primitive(box, &amp;value, CHECK);
3325   }
3326   Reflection::array_set(&amp;value, a, index, value_type, CHECK);
3327 JVM_END
3328 
3329 
3330 JVM_ENTRY(void, JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v, unsigned char vCode))
3331   JVMWrapper(&quot;JVM_SetPrimitiveArrayElement&quot;);
3332   arrayOop a = check_array(env, arr, true, CHECK);
3333   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3334   BasicType value_type = (BasicType) vCode;
3335   Reflection::array_set(&amp;v, a, index, value_type, CHECK);
3336 JVM_END
3337 
3338 
3339 JVM_ENTRY(jobject, JVM_NewArray(JNIEnv *env, jclass eltClass, jint length))
3340   JVMWrapper(&quot;JVM_NewArray&quot;);
3341   JvmtiVMObjectAllocEventCollector oam;
3342   oop element_mirror = JNIHandles::resolve(eltClass);
3343   oop result = Reflection::reflect_new_array(element_mirror, length, CHECK_NULL);
3344   return JNIHandles::make_local(env, result);
3345 JVM_END
3346 
3347 
3348 JVM_ENTRY(jobject, JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim))
3349   JVMWrapper(&quot;JVM_NewMultiArray&quot;);
3350   JvmtiVMObjectAllocEventCollector oam;
3351   arrayOop dim_array = check_array(env, dim, true, CHECK_NULL);
3352   oop element_mirror = JNIHandles::resolve(eltClass);
3353   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
3354   oop result = Reflection::reflect_new_multi_array(element_mirror, typeArrayOop(dim_array), CHECK_NULL);
3355   return JNIHandles::make_local(env, result);
3356 JVM_END
3357 
3358 
3359 // Library support ///////////////////////////////////////////////////////////////////////////
3360 
3361 JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))
3362   //%note jvm_ct
3363   JVMWrapper(&quot;JVM_LoadLibrary&quot;);
3364   char ebuf[1024];
3365   void *load_result;
3366   {
3367     ThreadToNativeFromVM ttnfvm(thread);
3368     load_result = os::dll_load(name, ebuf, sizeof ebuf);
3369   }
3370   if (load_result == NULL) {
3371     char msg[1024];
3372     jio_snprintf(msg, sizeof msg, &quot;%s: %s&quot;, name, ebuf);
3373     // Since &#39;ebuf&#39; may contain a string encoded using
3374     // platform encoding scheme, we need to pass
3375     // Exceptions::unsafe_to_utf8 to the new_exception method
3376     // as the last argument. See bug 6367357.
3377     Handle h_exception =
3378       Exceptions::new_exception(thread,
3379                                 vmSymbols::java_lang_UnsatisfiedLinkError(),
3380                                 msg, Exceptions::unsafe_to_utf8);
3381 
3382     THROW_HANDLE_0(h_exception);
3383   }
3384   log_info(library)(&quot;Loaded library %s, handle &quot; INTPTR_FORMAT, name, p2i(load_result));
3385   return load_result;
3386 JVM_END
3387 
3388 
3389 JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
3390   JVMWrapper(&quot;JVM_UnloadLibrary&quot;);
3391   os::dll_unload(handle);
3392   log_info(library)(&quot;Unloaded library with handle &quot; INTPTR_FORMAT, p2i(handle));
3393 JVM_END
3394 
3395 
3396 JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
3397   JVMWrapper(&quot;JVM_FindLibraryEntry&quot;);
3398   void* find_result = os::dll_lookup(handle, name);
3399   log_info(library)(&quot;%s %s in library with handle &quot; INTPTR_FORMAT,
3400                     find_result != NULL ? &quot;Found&quot; : &quot;Failed to find&quot;,
3401                     name, p2i(handle));
3402   return find_result;
3403 JVM_END
3404 
3405 
3406 // JNI version ///////////////////////////////////////////////////////////////////////////////
3407 
3408 JVM_LEAF(jboolean, JVM_IsSupportedJNIVersion(jint version))
3409   JVMWrapper(&quot;JVM_IsSupportedJNIVersion&quot;);
3410   return Threads::is_supported_jni_version_including_1_1(version);
3411 JVM_END
3412 
3413 
3414 // String support ///////////////////////////////////////////////////////////////////////////
3415 
3416 JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
3417   JVMWrapper(&quot;JVM_InternString&quot;);
3418   JvmtiVMObjectAllocEventCollector oam;
3419   if (str == NULL) return NULL;
3420   oop string = JNIHandles::resolve_non_null(str);
3421   oop result = StringTable::intern(string, CHECK_NULL);
3422   return (jstring) JNIHandles::make_local(env, result);
3423 JVM_END
3424 
3425 
3426 // VM Raw monitor support //////////////////////////////////////////////////////////////////////
3427 
3428 // VM Raw monitors (not to be confused with JvmtiRawMonitors) are a simple mutual exclusion
3429 // lock (not actually monitors: no wait/notify) that is exported by the VM for use by JDK
3430 // library code. They may be used by JavaThreads and non-JavaThreads and do not participate
3431 // in the safepoint protocol, thread suspension, thread interruption, or anything of that
3432 // nature. JavaThreads will be &quot;in native&quot; when using this API from JDK code.
3433 
3434 
3435 JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
3436   VM_Exit::block_if_vm_exited();
3437   JVMWrapper(&quot;JVM_RawMonitorCreate&quot;);
3438   return new os::PlatformMutex();
3439 }
3440 
3441 
3442 JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
3443   VM_Exit::block_if_vm_exited();
3444   JVMWrapper(&quot;JVM_RawMonitorDestroy&quot;);
3445   delete ((os::PlatformMutex*) mon);
3446 }
3447 
3448 
3449 JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
3450   VM_Exit::block_if_vm_exited();
3451   JVMWrapper(&quot;JVM_RawMonitorEnter&quot;);
3452   ((os::PlatformMutex*) mon)-&gt;lock();
3453   return 0;
3454 }
3455 
3456 
3457 JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
3458   VM_Exit::block_if_vm_exited();
3459   JVMWrapper(&quot;JVM_RawMonitorExit&quot;);
3460   ((os::PlatformMutex*) mon)-&gt;unlock();
3461 }
3462 
3463 
3464 // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
3465 
3466 jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,
3467                                     Handle loader, Handle protection_domain,
3468                                     jboolean throwError, TRAPS) {
3469   // Security Note:
3470   //   The Java level wrapper will perform the necessary security check allowing
3471   //   us to pass the NULL as the initiating class loader.  The VM is responsible for
3472   //   the checkPackageAccess relative to the initiating class loader via the
3473   //   protection_domain. The protection_domain is passed as NULL by the java code
3474   //   if there is no security manager in 3-arg Class.forName().
3475   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3476 
3477   // Check if we should initialize the class
3478   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3479     klass-&gt;initialize(CHECK_NULL);
3480   }
3481   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3482 }
3483 
3484 
3485 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3486 
3487 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3488   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3489   Handle method_handle;
3490   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3491     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3492     Handle receiver(THREAD, JNIHandles::resolve(obj));
3493     objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
3494     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3495     jobject res = JNIHandles::make_local(env, result);
3496     if (JvmtiExport::should_post_vm_object_alloc()) {
3497       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3498       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3499       if (java_lang_Class::is_primitive(ret_type)) {
3500         // Only for primitive type vm allocates memory for java object.
3501         // See box() method.
3502         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3503       }
3504     }
3505     return res;
3506   } else {
3507     THROW_0(vmSymbols::java_lang_StackOverflowError());
3508   }
3509 JVM_END
3510 
3511 
3512 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3513   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
3514   oop constructor_mirror = JNIHandles::resolve(c);
3515   objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
3516   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3517   jobject res = JNIHandles::make_local(env, result);
3518   if (JvmtiExport::should_post_vm_object_alloc()) {
3519     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3520   }
3521   return res;
3522 JVM_END
3523 
3524 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3525 
3526 JVM_LEAF(jboolean, JVM_SupportsCX8())
3527   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3528   return VM_Version::supports_cx8();
3529 JVM_END
3530 
3531 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3532   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3533   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3534   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3535   HeapShared::initialize_from_archived_subgraph(k);
3536 JVM_END
3537 
3538 // Returns an array of all live Thread objects (VM internal JavaThreads,
3539 // jvmti agent threads, and JNI attaching threads  are skipped)
3540 // See CR 6404306 regarding JNI attaching threads
3541 JVM_ENTRY(jobjectArray, JVM_GetAllThreads(JNIEnv *env, jclass dummy))
3542   ResourceMark rm(THREAD);
3543   ThreadsListEnumerator tle(THREAD, false, false);
3544   JvmtiVMObjectAllocEventCollector oam;
3545 
3546   int num_threads = tle.num_threads();
3547   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NULL);
3548   objArrayHandle threads_ah(THREAD, r);
3549 
3550   for (int i = 0; i &lt; num_threads; i++) {
3551     Handle h = tle.get_threadObj(i);
3552     threads_ah-&gt;obj_at_put(i, h());
3553   }
3554 
3555   return (jobjectArray) JNIHandles::make_local(env, threads_ah());
3556 JVM_END
3557 
3558 
3559 // Support for java.lang.Thread.getStackTrace() and getAllStackTraces() methods
3560 // Return StackTraceElement[][], each element is the stack trace of a thread in
3561 // the corresponding entry in the given threads array
3562 JVM_ENTRY(jobjectArray, JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads))
3563   JVMWrapper(&quot;JVM_DumpThreads&quot;);
3564   JvmtiVMObjectAllocEventCollector oam;
3565 
3566   // Check if threads is null
3567   if (threads == NULL) {
3568     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
3569   }
3570 
3571   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(threads));
3572   objArrayHandle ah(THREAD, a);
3573   int num_threads = ah-&gt;length();
3574   // check if threads is non-empty array
3575   if (num_threads == 0) {
3576     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3577   }
3578 
3579   // check if threads is not an array of objects of Thread class
3580   Klass* k = ObjArrayKlass::cast(ah-&gt;klass())-&gt;element_klass();
3581   if (k != SystemDictionary::Thread_klass()) {
3582     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3583   }
3584 
3585   ResourceMark rm(THREAD);
3586 
3587   GrowableArray&lt;instanceHandle&gt;* thread_handle_array = new GrowableArray&lt;instanceHandle&gt;(num_threads);
3588   for (int i = 0; i &lt; num_threads; i++) {
3589     oop thread_obj = ah-&gt;obj_at(i);
3590     instanceHandle h(THREAD, (instanceOop) thread_obj);
3591     thread_handle_array-&gt;append(h);
3592   }
3593 
3594   // The JavaThread references in thread_handle_array are validated
3595   // in VM_ThreadDump::doit().
3596   Handle stacktraces = ThreadService::dump_stack_traces(thread_handle_array, num_threads, CHECK_NULL);
3597   return (jobjectArray)JNIHandles::make_local(env, stacktraces());
3598 
3599 JVM_END
3600 
3601 // JVM monitoring and management support
3602 JVM_ENTRY_NO_ENV(void*, JVM_GetManagement(jint version))
3603   return Management::get_jmm_interface(version);
3604 JVM_END
3605 
3606 // com.sun.tools.attach.VirtualMachine agent properties support
3607 //
3608 // Initialize the agent properties with the properties maintained in the VM
3609 JVM_ENTRY(jobject, JVM_InitAgentProperties(JNIEnv *env, jobject properties))
3610   JVMWrapper(&quot;JVM_InitAgentProperties&quot;);
3611   ResourceMark rm;
3612 
3613   Handle props(THREAD, JNIHandles::resolve_non_null(properties));
3614 
3615   PUTPROP(props, &quot;sun.java.command&quot;, Arguments::java_command());
3616   PUTPROP(props, &quot;sun.jvm.flags&quot;, Arguments::jvm_flags());
3617   PUTPROP(props, &quot;sun.jvm.args&quot;, Arguments::jvm_args());
3618   return properties;
3619 JVM_END
3620 
3621 JVM_ENTRY(jobjectArray, JVM_GetEnclosingMethodInfo(JNIEnv *env, jclass ofClass))
3622 {
3623   JVMWrapper(&quot;JVM_GetEnclosingMethodInfo&quot;);
3624   JvmtiVMObjectAllocEventCollector oam;
3625 
3626   if (ofClass == NULL) {
3627     return NULL;
3628   }
3629   Handle mirror(THREAD, JNIHandles::resolve_non_null(ofClass));
3630   // Special handling for primitive objects
3631   if (java_lang_Class::is_primitive(mirror())) {
3632     return NULL;
3633   }
3634   Klass* k = java_lang_Class::as_Klass(mirror());
3635   if (!k-&gt;is_instance_klass()) {
3636     return NULL;
3637   }
3638   InstanceKlass* ik = InstanceKlass::cast(k);
3639   int encl_method_class_idx = ik-&gt;enclosing_method_class_index();
3640   if (encl_method_class_idx == 0) {
3641     return NULL;
3642   }
3643   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::Object_klass(), 3, CHECK_NULL);
3644   objArrayHandle dest(THREAD, dest_o);
3645   Klass* enc_k = ik-&gt;constants()-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
3646   dest-&gt;obj_at_put(0, enc_k-&gt;java_mirror());
3647   int encl_method_method_idx = ik-&gt;enclosing_method_method_index();
3648   if (encl_method_method_idx != 0) {
3649     Symbol* sym = ik-&gt;constants()-&gt;symbol_at(
3650                         extract_low_short_from_int(
3651                           ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3652     Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3653     dest-&gt;obj_at_put(1, str());
3654     sym = ik-&gt;constants()-&gt;symbol_at(
3655               extract_high_short_from_int(
3656                 ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3657     str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3658     dest-&gt;obj_at_put(2, str());
3659   }
3660   return (jobjectArray) JNIHandles::make_local(dest());
3661 }
3662 JVM_END
3663 
3664 // Returns an array of java.lang.String objects containing the input arguments to the VM.
3665 JVM_ENTRY(jobjectArray, JVM_GetVmArguments(JNIEnv *env))
3666   ResourceMark rm(THREAD);
3667 
3668   if (Arguments::num_jvm_args() == 0 &amp;&amp; Arguments::num_jvm_flags() == 0) {
3669     return NULL;
3670   }
3671 
3672   char** vm_flags = Arguments::jvm_flags_array();
3673   char** vm_args = Arguments::jvm_args_array();
3674   int num_flags = Arguments::num_jvm_flags();
3675   int num_args = Arguments::num_jvm_args();
3676 
3677   InstanceKlass* ik = SystemDictionary::String_klass();
3678   objArrayOop r = oopFactory::new_objArray(ik, num_args + num_flags, CHECK_NULL);
3679   objArrayHandle result_h(THREAD, r);
3680 
3681   int index = 0;
3682   for (int j = 0; j &lt; num_flags; j++, index++) {
3683     Handle h = java_lang_String::create_from_platform_dependent_str(vm_flags[j], CHECK_NULL);
3684     result_h-&gt;obj_at_put(index, h());
3685   }
3686   for (int i = 0; i &lt; num_args; i++, index++) {
3687     Handle h = java_lang_String::create_from_platform_dependent_str(vm_args[i], CHECK_NULL);
3688     result_h-&gt;obj_at_put(index, h());
3689   }
3690   return (jobjectArray) JNIHandles::make_local(env, result_h());
3691 JVM_END
3692 
3693 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
3694   return os::get_signal_number(name);
3695 JVM_END
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
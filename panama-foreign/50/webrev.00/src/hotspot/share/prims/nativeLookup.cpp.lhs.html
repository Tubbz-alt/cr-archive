<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/nativeLookup.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;classfile/symbolTable.hpp&quot;
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;classfile/vmSymbols.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;logging/logTag.hpp&quot;
 32 #include &quot;memory/oopFactory.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;oops/instanceKlass.hpp&quot;
 35 #include &quot;oops/method.hpp&quot;
 36 #include &quot;oops/oop.inline.hpp&quot;
 37 #include &quot;oops/symbol.hpp&quot;
 38 #include &quot;prims/jvm_misc.hpp&quot;
 39 #include &quot;prims/nativeLookup.hpp&quot;
 40 #include &quot;prims/unsafe.hpp&quot;
 41 #include &quot;runtime/arguments.hpp&quot;
 42 #include &quot;runtime/handles.inline.hpp&quot;
 43 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 44 #include &quot;runtime/javaCalls.hpp&quot;
 45 #include &quot;runtime/os.inline.hpp&quot;
 46 #include &quot;runtime/sharedRuntime.hpp&quot;
 47 #include &quot;runtime/signature.hpp&quot;
 48 #include &quot;utilities/macros.hpp&quot;
 49 #include &quot;utilities/utf8.hpp&quot;
 50 #if INCLUDE_JFR
 51 #include &quot;jfr/jfr.hpp&quot;
 52 #endif
 53 
 54 static void mangle_name_on(outputStream* st, Symbol* name, int begin, int end) {
 55   char* bytes = (char*)name-&gt;bytes() + begin;
 56   char* end_bytes = (char*)name-&gt;bytes() + end;
 57   while (bytes &lt; end_bytes) {
 58     jchar c;
 59     bytes = UTF8::next(bytes, &amp;c);
 60     if (c &lt;= 0x7f &amp;&amp; isalnum(c)) {
 61       st-&gt;put((char) c);
 62     } else {
 63            if (c == &#39;_&#39;) st-&gt;print(&quot;_1&quot;);
 64       else if (c == &#39;/&#39;) st-&gt;print(&quot;_&quot;);
 65       else if (c == &#39;;&#39;) st-&gt;print(&quot;_2&quot;);
 66       else if (c == &#39;[&#39;) st-&gt;print(&quot;_3&quot;);
 67       else               st-&gt;print(&quot;_%.5x&quot;, c);
 68     }
 69   }
 70 }
 71 
 72 
 73 static void mangle_name_on(outputStream* st, Symbol* name) {
 74   mangle_name_on(st, name, 0, name-&gt;utf8_length());
 75 }
 76 
 77 
 78 char* NativeLookup::pure_jni_name(const methodHandle&amp; method) {
 79   stringStream st;
 80   // Prefix
 81   st.print(&quot;Java_&quot;);
 82   // Klass name
 83   mangle_name_on(&amp;st, method-&gt;klass_name());
 84   st.print(&quot;_&quot;);
 85   // Method name
 86   mangle_name_on(&amp;st, method-&gt;name());
 87   return st.as_string();
 88 }
 89 
 90 
 91 char* NativeLookup::critical_jni_name(const methodHandle&amp; method) {
 92   stringStream st;
 93   // Prefix
 94   st.print(&quot;JavaCritical_&quot;);
 95   // Klass name
 96   mangle_name_on(&amp;st, method-&gt;klass_name());
 97   st.print(&quot;_&quot;);
 98   // Method name
 99   mangle_name_on(&amp;st, method-&gt;name());
100   return st.as_string();
101 }
102 
103 
104 char* NativeLookup::long_jni_name(const methodHandle&amp; method) {
105   // Signature ignore the wrapping parenteses and the trailing return type
106   stringStream st;
107   Symbol* signature = method-&gt;signature();
108   st.print(&quot;__&quot;);
109   // find &#39;)&#39;
110   int end;
111   for (end = 0; end &lt; signature-&gt;utf8_length() &amp;&amp; signature-&gt;char_at(end) != JVM_SIGNATURE_ENDFUNC; end++);
112   // skip first &#39;(&#39;
113   mangle_name_on(&amp;st, signature, 1, end);
114   return st.as_string();
115 }
116 
117 extern &quot;C&quot; {
118   void JNICALL JVM_RegisterMethodHandleMethods(JNIEnv *env, jclass unsafecls);
119   void JNICALL JVM_RegisterReferencesMethods(JNIEnv *env, jclass unsafecls);
120   void JNICALL JVM_RegisterUpcallHandlerMethods(JNIEnv *env, jclass unsafecls);
121   void JNICALL JVM_RegisterProgrammableUpcallHandlerMethods(JNIEnv *env, jclass unsafecls);
122   void JNICALL JVM_RegisterProgrammableInvokerMethods(JNIEnv *env, jclass unsafecls);
123   void JNICALL JVM_RegisterPerfMethods(JNIEnv *env, jclass perfclass);
124   void JNICALL JVM_RegisterWhiteBoxMethods(JNIEnv *env, jclass wbclass);
125 #if INCLUDE_JVMCI
126   jobject  JNICALL JVM_GetJVMCIRuntime(JNIEnv *env, jclass c);
127   void     JNICALL JVM_RegisterJVMCINatives(JNIEnv *env, jclass compilerToVMClass);
128 #endif
129 }
130 
131 #define CC (char*)  /* cast a literal from (const char*) */
132 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
133 
134 static JNINativeMethod lookup_special_native_methods[] = {
135   { CC&quot;Java_jdk_internal_misc_Unsafe_registerNatives&quot;,             NULL, FN_PTR(JVM_RegisterJDKInternalMiscUnsafeMethods) },
136   { CC&quot;Java_java_lang_invoke_MethodHandleNatives_registerNatives&quot;, NULL, FN_PTR(JVM_RegisterMethodHandleMethods) },
137   { CC&quot;Java_jdk_internal_foreign_abi_UpcallStubs_registerNatives&quot;,      NULL, FN_PTR(JVM_RegisterUpcallHandlerMethods) },
138   { CC&quot;Java_jdk_internal_foreign_abi_ProgrammableUpcallHandler_registerNatives&quot;,      NULL, FN_PTR(JVM_RegisterProgrammableUpcallHandlerMethods) },
139   { CC&quot;Java_jdk_internal_foreign_abi_ProgrammableInvoker_registerNatives&quot;,      NULL, FN_PTR(JVM_RegisterProgrammableInvokerMethods) },
140   { CC&quot;Java_jdk_internal_perf_Perf_registerNatives&quot;,               NULL, FN_PTR(JVM_RegisterPerfMethods)         },
141   { CC&quot;Java_sun_hotspot_WhiteBox_registerNatives&quot;,                 NULL, FN_PTR(JVM_RegisterWhiteBoxMethods)     },
142 #if INCLUDE_JVMCI
143   { CC&quot;Java_jdk_vm_ci_runtime_JVMCI_initializeRuntime&quot;,            NULL, FN_PTR(JVM_GetJVMCIRuntime)             },
144   { CC&quot;Java_jdk_vm_ci_hotspot_CompilerToVM_registerNatives&quot;,       NULL, FN_PTR(JVM_RegisterJVMCINatives)        },
145 #endif
146 #if INCLUDE_JFR
147   { CC&quot;Java_jdk_jfr_internal_JVM_registerNatives&quot;,                 NULL, FN_PTR(jfr_register_natives)            },
148 #endif
149 };
150 
151 static address lookup_special_native(const char* jni_name) {
152   int count = sizeof(lookup_special_native_methods) / sizeof(JNINativeMethod);
153   for (int i = 0; i &lt; count; i++) {
154     // NB: To ignore the jni prefix and jni postfix strstr is used matching.
155     if (strstr(jni_name, lookup_special_native_methods[i].name) != NULL) {
156       return CAST_FROM_FN_PTR(address, lookup_special_native_methods[i].fnPtr);
157     }
158   }
159   return NULL;
160 }
161 
162 address NativeLookup::lookup_style(const methodHandle&amp; method, char* pure_name, const char* long_name, int args_size, bool os_style, bool&amp; in_base_library, TRAPS) {
163   address entry;
164   const char* jni_name = compute_complete_jni_name(pure_name, long_name, args_size, os_style);
165 
166 
167   // If the loader is null we have a system class, so we attempt a lookup in
168   // the native Java library. This takes care of any bootstrapping problems.
<a name="2" id="anc2"></a><span class="line-modified">169   // Note: It is critical for bootstrapping that Java_java_lang_ClassLoader_00024NativeLibrary_find</span>
170   // gets found the first time around - otherwise an infinite loop can occure. This is
171   // another VM/library dependency
172   Handle loader(THREAD, method-&gt;method_holder()-&gt;class_loader());
173   if (loader.is_null()) {
174     entry = lookup_special_native(jni_name);
175     if (entry == NULL) {
176        entry = (address) os::dll_lookup(os::native_java_library(), jni_name);
177     }
178     if (entry != NULL) {
179       in_base_library = true;
180       return entry;
181     }
182   }
183 
184   // Otherwise call static method findNative in ClassLoader
185   Klass*   klass = SystemDictionary::ClassLoader_klass();
186   Handle name_arg = java_lang_String::create_from_str(jni_name, CHECK_NULL);
187 
188   JavaValue result(T_LONG);
189   JavaCalls::call_static(&amp;result,
190                          klass,
191                          vmSymbols::findNative_name(),
192                          vmSymbols::classloader_string_long_signature(),
193                          // Arguments
194                          loader,
195                          name_arg,
196                          CHECK_NULL);
197   entry = (address) (intptr_t) result.get_jlong();
198 
199   if (entry == NULL) {
200     // findNative didn&#39;t find it, if there are any agent libraries look in them
201     AgentLibrary* agent;
202     for (agent = Arguments::agents(); agent != NULL; agent = agent-&gt;next()) {
203       entry = (address) os::dll_lookup(agent-&gt;os_lib(), jni_name);
204       if (entry != NULL) {
205         return entry;
206       }
207     }
208   }
209 
210   return entry;
211 }
212 
213 const char* NativeLookup::compute_complete_jni_name(const char* pure_name, const char* long_name, int args_size, bool os_style) {
214   stringStream st;
215   if (os_style) {
216     os::print_jni_name_prefix_on(&amp;st, args_size);
217   }
218 
219   st.print_raw(pure_name);
220   st.print_raw(long_name);
221   if (os_style) {
222     os::print_jni_name_suffix_on(&amp;st, args_size);
223   }
224 
225   return st.as_string();
226 }
227 
228 address NativeLookup::lookup_critical_style(void* dll, const char* pure_name, const char* long_name, int args_size, bool os_style) {
229   const char* jni_name = compute_complete_jni_name(pure_name, long_name, args_size, os_style);
230   assert(dll != NULL, &quot;dll must be loaded&quot;);
231   return (address)os::dll_lookup(dll, jni_name);
232 }
233 
234 // Check all the formats of native implementation name to see if there is one
235 // for the specified method.
236 address NativeLookup::lookup_entry(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
237   address entry = NULL;
238   in_base_library = false;
239   // Compute pure name
240   char* pure_name = pure_jni_name(method);
241 
242   // Compute argument size
243   int args_size = 1                             // JNIEnv
244                 + (method-&gt;is_static() ? 1 : 0) // class for static methods
245                 + method-&gt;size_of_parameters(); // actual parameters
246 
247   // 1) Try JNI short style
248   entry = lookup_style(method, pure_name, &quot;&quot;,        args_size, true,  in_base_library, CHECK_NULL);
249   if (entry != NULL) return entry;
250 
251   // Compute long name
252   char* long_name = long_jni_name(method);
253 
254   // 2) Try JNI long style
255   entry = lookup_style(method, pure_name, long_name, args_size, true,  in_base_library, CHECK_NULL);
256   if (entry != NULL) return entry;
257 
258   // 3) Try JNI short style without os prefix/suffix
259   entry = lookup_style(method, pure_name, &quot;&quot;,        args_size, false, in_base_library, CHECK_NULL);
260   if (entry != NULL) return entry;
261 
262   // 4) Try JNI long style without os prefix/suffix
263   entry = lookup_style(method, pure_name, long_name, args_size, false, in_base_library, CHECK_NULL);
264 
265   return entry; // NULL indicates not found
266 }
267 
268 // Check all the formats of native implementation name to see if there is one
269 // for the specified method.
270 address NativeLookup::lookup_critical_entry(const methodHandle&amp; method) {
271   assert(CriticalJNINatives, &quot;or should not be here&quot;);
272 
273   if (method-&gt;is_synchronized() ||
274       !method-&gt;is_static()) {
275     // Only static non-synchronized methods are allowed
276     return NULL;
277   }
278 
279   ResourceMark rm;
280 
281   Symbol* signature = method-&gt;signature();
282   for (int end = 0; end &lt; signature-&gt;utf8_length(); end++) {
283     if (signature-&gt;char_at(end) == &#39;L&#39;) {
284       // Don&#39;t allow object types
285       return NULL;
286     }
287   }
288 
289   // Compute argument size
290   int args_size = method-&gt;size_of_parameters();
291   for (SignatureStream ss(signature); !ss.at_return_type(); ss.next()) {
292     if (ss.is_array()) {
293       args_size += T_INT_size; // array length parameter
294     }
295   }
296 
297   // dll handling requires I/O. Don&#39;t do that while in _thread_in_vm (safepoint may get requested).
298   ThreadToNativeFromVM thread_in_native(JavaThread::current());
299 
300   void* dll = dll_load(method);
301   address entry = NULL;
302 
303   if (dll != NULL) {
304     entry = lookup_critical_style(dll, method, args_size);
305     // Close the handle to avoid keeping the library alive if the native method holder is unloaded.
306     // This is fine because the library is still kept alive by JNI (see JVM_LoadLibrary). As soon
307     // as the holder class and the library are unloaded (see JVM_UnloadLibrary), the native wrapper
308     // that calls &#39;critical_entry&#39; becomes unreachable and is unloaded as well.
309     os::dll_unload(dll);
310   }
311 
312   return entry; // NULL indicates not found
313 }
314 
315 void* NativeLookup::dll_load(const methodHandle&amp; method) {
316   if (method-&gt;has_native_function()) {
317 
318     address current_entry = method-&gt;native_function();
319 
320     char dll_name[JVM_MAXPATHLEN];
321     int offset;
322     if (os::dll_address_to_library_name(current_entry, dll_name, sizeof(dll_name), &amp;offset)) {
323       char ebuf[32];
324       return os::dll_load(dll_name, ebuf, sizeof(ebuf));
325     }
326   }
327 
328   return NULL;
329 }
330 
331 address NativeLookup::lookup_critical_style(void* dll, const methodHandle&amp; method, int args_size) {
332   address entry = NULL;
333   const char* critical_name = critical_jni_name(method);
334 
335   // 1) Try JNI short style
336   entry = lookup_critical_style(dll, critical_name, &quot;&quot;,        args_size, true);
337   if (entry != NULL) {
338     return entry;
339   }
340 
341   const char* long_name = long_jni_name(method);
342 
343   // 2) Try JNI long style
344   entry = lookup_critical_style(dll, critical_name, long_name, args_size, true);
345   if (entry != NULL) {
346     return entry;
347   }
348 
349   // 3) Try JNI short style without os prefix/suffix
350   entry = lookup_critical_style(dll, critical_name, &quot;&quot;,        args_size, false);
351   if (entry != NULL) {
352     return entry;
353   }
354 
355   // 4) Try JNI long style without os prefix/suffix
356   return lookup_critical_style(dll, critical_name, long_name, args_size, false);
357 }
358 
359 // Check if there are any JVM TI prefixes which have been applied to the native method name.
360 // If any are found, remove them before attemping the look up of the
361 // native implementation again.
362 // See SetNativeMethodPrefix in the JVM TI Spec for more details.
363 address NativeLookup::lookup_entry_prefixed(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
364 #if INCLUDE_JVMTI
365   ResourceMark rm(THREAD);
366 
367   int prefix_count;
368   char** prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);
369   char* in_name = method-&gt;name()-&gt;as_C_string();
370   char* wrapper_name = in_name;
371   // last applied prefix will be first -- go backwards
372   for (int i = prefix_count-1; i &gt;= 0; i--) {
373     char* prefix = prefixes[i];
374     size_t prefix_len = strlen(prefix);
375     if (strncmp(prefix, wrapper_name, prefix_len) == 0) {
376       // has this prefix remove it
377       wrapper_name += prefix_len;
378     }
379   }
380   if (wrapper_name != in_name) {
381     // we have a name for a wrapping method
382     int wrapper_name_len = (int)strlen(wrapper_name);
383     TempNewSymbol wrapper_symbol = SymbolTable::probe(wrapper_name, wrapper_name_len);
384     if (wrapper_symbol != NULL) {
385       Klass* k = method-&gt;method_holder();
386       Method* wrapper_method = k-&gt;lookup_method(wrapper_symbol, method-&gt;signature());
387       if (wrapper_method != NULL &amp;&amp; !wrapper_method-&gt;is_native()) {
388         // we found a wrapper method, use its native entry
389         method-&gt;set_is_prefixed_native();
390         return lookup_entry(methodHandle(THREAD, wrapper_method), in_base_library, THREAD);
391       }
392     }
393   }
394 #endif // INCLUDE_JVMTI
395   return NULL;
396 }
397 
398 address NativeLookup::lookup_base(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
399   address entry = NULL;
400   ResourceMark rm(THREAD);
401 
402   entry = lookup_entry(method, in_base_library, THREAD);
403   if (entry != NULL) return entry;
404 
405   // standard native method resolution has failed.  Check if there are any
406   // JVM TI prefixes which have been applied to the native method name.
407   entry = lookup_entry_prefixed(method, in_base_library, THREAD);
408   if (entry != NULL) return entry;
409 
410   // Native function not found, throw UnsatisfiedLinkError
411   stringStream ss;
412   ss.print(&quot;&#39;&quot;);
413   method-&gt;print_external_name(&amp;ss);
414   ss.print(&quot;&#39;&quot;);
415   THROW_MSG_0(vmSymbols::java_lang_UnsatisfiedLinkError(), ss.as_string());
416 }
417 
418 
419 address NativeLookup::lookup(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
420   if (!method-&gt;has_native_function()) {
421     address entry = lookup_base(method, in_base_library, CHECK_NULL);
422     method-&gt;set_native_function(entry,
423       Method::native_bind_event_is_interesting);
424     // -verbose:jni printing
425     if (log_is_enabled(Debug, jni, resolve)) {
426       ResourceMark rm(THREAD);
427       log_debug(jni, resolve)(&quot;[Dynamic-linking native method %s.%s ... JNI]&quot;,
428                               method-&gt;method_holder()-&gt;external_name(),
429                               method-&gt;name()-&gt;as_C_string());
430     }
431   }
432   return method-&gt;native_function();
433 }
434 
435 address NativeLookup::base_library_lookup(const char* class_name, const char* method_name, const char* signature) {
436   EXCEPTION_MARK;
437   bool in_base_library = true;  // SharedRuntime inits some math methods.
438   TempNewSymbol c_name = SymbolTable::new_symbol(class_name);
439   TempNewSymbol m_name = SymbolTable::new_symbol(method_name);
440   TempNewSymbol s_name = SymbolTable::new_symbol(signature);
441 
442   // Find the class
443   Klass* k = SystemDictionary::resolve_or_fail(c_name, true, CATCH);
444   InstanceKlass* klass  = InstanceKlass::cast(k);
445 
446   // Find method and invoke standard lookup
447   methodHandle method (THREAD,
448                        klass-&gt;uncached_lookup_method(m_name, s_name, Klass::find_overpass));
449   address result = lookup(method, in_base_library, CATCH);
450   assert(in_base_library, &quot;must be in basic library&quot;);
451   guarantee(result != NULL, &quot;must be non NULL&quot;);
452   return result;
453 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoah_globals.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahVerifier.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../z/zCollectedHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoah_globals.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 61           range(1, 100)                                                     \
 62                                                                             \
 63   experimental(ccstr, ShenandoahGCHeuristics, &quot;adaptive&quot;,                   \
 64           &quot;The heuristics to use in Shenandoah GC. Possible values:&quot;        \
 65           &quot; *) adaptive - adapt to maintain the given amount of free heap;&quot; \
 66           &quot; *) static  -  start concurrent GC when static free heap &quot;       \
 67           &quot;               threshold and static allocation threshold are &quot;   \
 68           &quot;               tripped;&quot;                                         \
 69           &quot; *) aggressive - run concurrent GC continuously, evacuate &quot;      \
 70           &quot;               everything;&quot;                                      \
 71           &quot; *) compact - run GC with lower footprint target, may end up &quot;   \
 72           &quot;               doing continuous GC, evacuate lots of live &quot;      \
 73           &quot;               objects, uncommit heap aggressively;&quot;)            \
 74                                                                             \
 75   experimental(ccstr, ShenandoahGCMode, &quot;normal&quot;,                           \
 76           &quot;The GC mode to use in Shenandoah GC. Possible values&quot;            \
 77           &quot; *) normal    - normal GC (mark-evac-update)&quot;                    \
 78           &quot; *) traversal - traversal GC (single-pass)&quot;                      \
 79           &quot; *) passive   - disable concurrent GC, do stop-the-world GC&quot;)    \
 80                                                                             \
<span class="line-removed"> 81   experimental(ccstr, ShenandoahUpdateRefsEarly, &quot;adaptive&quot;,                \</span>
<span class="line-removed"> 82           &quot;Run a separate concurrent reference updating phase after&quot;        \</span>
<span class="line-removed"> 83           &quot;concurrent evacuation. Possible values: &#39;on&#39;, &#39;off&#39;, &#39;adaptive&#39;&quot;)\</span>
<span class="line-removed"> 84                                                                             \</span>
 85   experimental(uintx, ShenandoahRefProcFrequency, 5,                        \
 86           &quot;How often should (weak, soft, etc) references be processed. &quot;    \
 87           &quot;References get processed at every Nth GC cycle. Set to zero &quot;    \
 88           &quot;to disable reference processing.&quot;)                               \
 89                                                                             \
 90   experimental(uintx, ShenandoahUnloadClassesFrequency, 1,                  \
 91           &quot;How often should classes get unloaded. &quot;                         \
 92           &quot;Class unloading is performed at every Nth GC cycle. &quot;            \
 93           &quot;Set to zero to disable class unloading during concurrent GC.&quot;)   \
 94                                                                             \
 95   experimental(uintx, ShenandoahGarbageThreshold, 60,                       \
 96           &quot;Sets the percentage of garbage a region need to contain before &quot; \
 97           &quot;it can be marked for collection. Does not apply to all &quot;         \
 98           &quot;heuristics.&quot;)                                                    \
 99           range(0,100)                                                      \
100                                                                             \
101   experimental(uintx, ShenandoahInitFreeThreshold, 70,                      \
102           &quot;Initial remaining free heap threshold for learning steps in &quot;    \
103           &quot;heuristics. In percents of total heap size. Does not apply to &quot;  \
104           &quot;all heuristics.&quot;)                                                \
</pre>
<hr />
<pre>
111                                                                             \
112   experimental(uintx, ShenandoahAllocationThreshold, 0,                     \
113           &quot;Set percentage of memory allocated since last GC cycle before &quot;  \
114           &quot;a new GC cycle can be started. Set to zero to effectively &quot;      \
115           &quot;disable.&quot;)                                                       \
116           range(0,100)                                                      \
117                                                                             \
118   experimental(uintx, ShenandoahLearningSteps, 5,                           \
119           &quot;Number of GC cycles to run in order to learn application &quot;       \
120           &quot;and GC performance for adaptive heuristics.&quot;)                    \
121           range(0,100)                                                      \
122                                                                             \
123   experimental(uintx, ShenandoahImmediateThreshold, 90,                     \
124           &quot;If mark identifies more than this much immediate garbage &quot;       \
125           &quot;regions, it shall recycle them, and shall not continue the &quot;     \
126           &quot;rest of the GC cycle. The value is in percents of total &quot;        \
127           &quot;number of candidate regions for collection set. Setting this &quot;   \
128           &quot;threshold to 100% effectively disables this shortcut.&quot;)          \
129           range(0,100)                                                      \
130                                                                             \
<span class="line-removed">131   experimental(uintx, ShenandoahMergeUpdateRefsMinGap, 100,                 \</span>
<span class="line-removed">132           &quot;If GC is currently running in separate update-refs mode &quot;        \</span>
<span class="line-removed">133           &quot;this numbers gives the threshold when to switch to &quot;             \</span>
<span class="line-removed">134           &quot;merged update-refs mode. Number is percentage relative to&quot;       \</span>
<span class="line-removed">135           &quot;duration(marking)+duration(update-refs).&quot;)                       \</span>
<span class="line-removed">136                                                                             \</span>
<span class="line-removed">137   experimental(uintx, ShenandoahMergeUpdateRefsMaxGap, 200,                 \</span>
<span class="line-removed">138           &quot;If GC is currently running in merged update-refs mode &quot;          \</span>
<span class="line-removed">139           &quot;this numbers gives the threshold when to switch to &quot;             \</span>
<span class="line-removed">140           &quot;separate update-refs mode. Number is percentage relative &quot;       \</span>
<span class="line-removed">141           &quot;to duration(marking)+duration(update-refs).&quot;)                    \</span>
<span class="line-removed">142                                                                             \</span>
143   experimental(uintx, ShenandoahGuaranteedGCInterval, 5*60*1000,            \
144           &quot;Most heuristics would guarantee a concurrent GC cycle at &quot;       \
145           &quot;least with this interval. This is useful when large idle &quot;       \
146           &quot;intervals are present, where GC can run without stealing &quot;       \
147           &quot;time from active application. Time is in milliseconds. &quot;         \
148           &quot;(Setting this interval to 0 disables this feature).&quot;)            \
149                                                                             \
150   experimental(bool, ShenandoahAlwaysClearSoftRefs, false,                  \
151           &quot;Clear soft references always, instead of using any smart &quot;       \
152           &quot;cleanup policy. This minimizes footprint at expense of more &quot;    \
153           &quot;softref churn in applications.&quot;)                                 \
154                                                                             \
155   experimental(bool, ShenandoahUncommit, true,                              \
156           &quot;Allow Shenandoah to uncommit unused memory.&quot;)                    \
157                                                                             \
158   experimental(uintx, ShenandoahUncommitDelay, 5*60*1000,                   \
159           &quot;Shenandoah would start to uncommit memory for regions that were&quot; \
160           &quot; not used for more than this time. First use after that would &quot;  \
161           &quot;incur allocation stalls. Actively used regions would never be &quot;  \
162           &quot;uncommitted, because they never decay. Time is in milliseconds.&quot; \
</pre>
</td>
<td>
<hr />
<pre>
 61           range(1, 100)                                                     \
 62                                                                             \
 63   experimental(ccstr, ShenandoahGCHeuristics, &quot;adaptive&quot;,                   \
 64           &quot;The heuristics to use in Shenandoah GC. Possible values:&quot;        \
 65           &quot; *) adaptive - adapt to maintain the given amount of free heap;&quot; \
 66           &quot; *) static  -  start concurrent GC when static free heap &quot;       \
 67           &quot;               threshold and static allocation threshold are &quot;   \
 68           &quot;               tripped;&quot;                                         \
 69           &quot; *) aggressive - run concurrent GC continuously, evacuate &quot;      \
 70           &quot;               everything;&quot;                                      \
 71           &quot; *) compact - run GC with lower footprint target, may end up &quot;   \
 72           &quot;               doing continuous GC, evacuate lots of live &quot;      \
 73           &quot;               objects, uncommit heap aggressively;&quot;)            \
 74                                                                             \
 75   experimental(ccstr, ShenandoahGCMode, &quot;normal&quot;,                           \
 76           &quot;The GC mode to use in Shenandoah GC. Possible values&quot;            \
 77           &quot; *) normal    - normal GC (mark-evac-update)&quot;                    \
 78           &quot; *) traversal - traversal GC (single-pass)&quot;                      \
 79           &quot; *) passive   - disable concurrent GC, do stop-the-world GC&quot;)    \
 80                                                                             \




 81   experimental(uintx, ShenandoahRefProcFrequency, 5,                        \
 82           &quot;How often should (weak, soft, etc) references be processed. &quot;    \
 83           &quot;References get processed at every Nth GC cycle. Set to zero &quot;    \
 84           &quot;to disable reference processing.&quot;)                               \
 85                                                                             \
 86   experimental(uintx, ShenandoahUnloadClassesFrequency, 1,                  \
 87           &quot;How often should classes get unloaded. &quot;                         \
 88           &quot;Class unloading is performed at every Nth GC cycle. &quot;            \
 89           &quot;Set to zero to disable class unloading during concurrent GC.&quot;)   \
 90                                                                             \
 91   experimental(uintx, ShenandoahGarbageThreshold, 60,                       \
 92           &quot;Sets the percentage of garbage a region need to contain before &quot; \
 93           &quot;it can be marked for collection. Does not apply to all &quot;         \
 94           &quot;heuristics.&quot;)                                                    \
 95           range(0,100)                                                      \
 96                                                                             \
 97   experimental(uintx, ShenandoahInitFreeThreshold, 70,                      \
 98           &quot;Initial remaining free heap threshold for learning steps in &quot;    \
 99           &quot;heuristics. In percents of total heap size. Does not apply to &quot;  \
100           &quot;all heuristics.&quot;)                                                \
</pre>
<hr />
<pre>
107                                                                             \
108   experimental(uintx, ShenandoahAllocationThreshold, 0,                     \
109           &quot;Set percentage of memory allocated since last GC cycle before &quot;  \
110           &quot;a new GC cycle can be started. Set to zero to effectively &quot;      \
111           &quot;disable.&quot;)                                                       \
112           range(0,100)                                                      \
113                                                                             \
114   experimental(uintx, ShenandoahLearningSteps, 5,                           \
115           &quot;Number of GC cycles to run in order to learn application &quot;       \
116           &quot;and GC performance for adaptive heuristics.&quot;)                    \
117           range(0,100)                                                      \
118                                                                             \
119   experimental(uintx, ShenandoahImmediateThreshold, 90,                     \
120           &quot;If mark identifies more than this much immediate garbage &quot;       \
121           &quot;regions, it shall recycle them, and shall not continue the &quot;     \
122           &quot;rest of the GC cycle. The value is in percents of total &quot;        \
123           &quot;number of candidate regions for collection set. Setting this &quot;   \
124           &quot;threshold to 100% effectively disables this shortcut.&quot;)          \
125           range(0,100)                                                      \
126                                                                             \












127   experimental(uintx, ShenandoahGuaranteedGCInterval, 5*60*1000,            \
128           &quot;Most heuristics would guarantee a concurrent GC cycle at &quot;       \
129           &quot;least with this interval. This is useful when large idle &quot;       \
130           &quot;intervals are present, where GC can run without stealing &quot;       \
131           &quot;time from active application. Time is in milliseconds. &quot;         \
132           &quot;(Setting this interval to 0 disables this feature).&quot;)            \
133                                                                             \
134   experimental(bool, ShenandoahAlwaysClearSoftRefs, false,                  \
135           &quot;Clear soft references always, instead of using any smart &quot;       \
136           &quot;cleanup policy. This minimizes footprint at expense of more &quot;    \
137           &quot;softref churn in applications.&quot;)                                 \
138                                                                             \
139   experimental(bool, ShenandoahUncommit, true,                              \
140           &quot;Allow Shenandoah to uncommit unused memory.&quot;)                    \
141                                                                             \
142   experimental(uintx, ShenandoahUncommitDelay, 5*60*1000,                   \
143           &quot;Shenandoah would start to uncommit memory for regions that were&quot; \
144           &quot; not used for more than this time. First use after that would &quot;  \
145           &quot;incur allocation stalls. Actively used regions would never be &quot;  \
146           &quot;uncommitted, because they never decay. Time is in milliseconds.&quot; \
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahVerifier.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../z/zCollectedHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahFreeSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.hpp&quot;
  27 #include &quot;memory/universe.hpp&quot;
  28 
  29 #include &quot;gc/shared/gcArguments.hpp&quot;
  30 #include &quot;gc/shared/gcTimer.hpp&quot;
  31 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  32 #include &quot;gc/shared/locationPrinter.inline.hpp&quot;
  33 #include &quot;gc/shared/memAllocator.hpp&quot;
  34 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  35 #include &quot;gc/shared/plab.hpp&quot;
  36 
<span class="line-removed">  37 #include &quot;gc/shenandoah/shenandoahAllocTracker.hpp&quot;</span>
  38 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
  39 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
  40 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  41 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  42 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
  43 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
  44 #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
  45 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  46 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  47 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  48 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  49 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
  50 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  51 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  52 #include &quot;gc/shenandoah/shenandoahMemoryPool.hpp&quot;
  53 #include &quot;gc/shenandoah/shenandoahMetrics.hpp&quot;
  54 #include &quot;gc/shenandoah/shenandoahMonitoringSupport.hpp&quot;
  55 #include &quot;gc/shenandoah/shenandoahNormalMode.hpp&quot;
  56 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
  57 #include &quot;gc/shenandoah/shenandoahPacer.inline.hpp&quot;
</pre>
<hr />
<pre>
1368   void heap_region_do(ShenandoahHeapRegion* r) {
1369     if (r-&gt;is_active()) {
1370       r-&gt;clear_live_data();
1371       _ctx-&gt;capture_top_at_mark_start(r);
1372     } else {
1373       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;region_number());
1374       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
1375              &quot;Region &quot; SIZE_FORMAT &quot; should already have correct TAMS&quot;, r-&gt;region_number());
1376     }
1377   }
1378 
1379   bool is_thread_safe() { return true; }
1380 };
1381 
1382 void ShenandoahHeap::op_init_mark() {
1383   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1384   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
1385 
1386   assert(marking_context()-&gt;is_bitmap_clear(), &quot;need clear marking bitmap&quot;);
1387   assert(!marking_context()-&gt;is_complete(), &quot;should not be complete&quot;);

1388 
1389   if (ShenandoahVerify) {
1390     verifier()-&gt;verify_before_concmark();
1391   }
1392 
1393   if (VerifyBeforeGC) {
1394     Universe::verify();
1395   }
1396 
1397   set_concurrent_mark_in_progress(true);
1398   // We need to reset all TLABs because we&#39;d lose marks on all objects allocated in them.
1399   {
1400     ShenandoahGCPhase phase(ShenandoahPhaseTimings::make_parsable);
1401     make_parsable(true);
1402   }
1403 
1404   {
1405     ShenandoahGCPhase phase(ShenandoahPhaseTimings::clear_liveness);
1406     ShenandoahClearLivenessClosure clc;
1407     parallel_heap_region_iterate(&amp;clc);
</pre>
<hr />
<pre>
1434 
1435   void heap_region_do(ShenandoahHeapRegion* r) {
1436     if (r-&gt;is_active()) {
1437       HeapWord *tams = _ctx-&gt;top_at_mark_start(r);
1438       HeapWord *top = r-&gt;top();
1439       if (top &gt; tams) {
1440         r-&gt;increase_live_data_alloc_words(pointer_delta(top, tams));
1441       }
1442     } else {
1443       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;region_number());
1444       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
1445              &quot;Region &quot; SIZE_FORMAT &quot; should have correct TAMS&quot;, r-&gt;region_number());
1446     }
1447   }
1448 
1449   bool is_thread_safe() { return true; }
1450 };
1451 
1452 void ShenandoahHeap::op_final_mark() {
1453   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);

1454 
1455   // It is critical that we
1456   // evacuate roots right after finishing marking, so that we don&#39;t
1457   // get unmarked objects in the roots.
1458 
1459   if (!cancelled_gc()) {
1460     concurrent_mark()-&gt;finish_mark_from_roots(/* full_gc = */ false);
1461 
1462     // Marking is completed, deactivate SATB barrier
1463     set_concurrent_mark_in_progress(false);
1464     mark_complete_marking_context();
1465 
1466     parallel_cleaning(false /* full gc*/);
1467 
<span class="line-removed">1468     if (has_forwarded_objects()) {</span>
<span class="line-removed">1469       // Degen may be caused by failed evacuation of roots</span>
<span class="line-removed">1470       if (is_degenerated_gc_in_progress()) {</span>
<span class="line-removed">1471         concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::degen_gc_update_roots);</span>
<span class="line-removed">1472       } else {</span>
<span class="line-removed">1473         concurrent_mark()-&gt;update_thread_roots(ShenandoahPhaseTimings::update_roots);</span>
<span class="line-removed">1474       }</span>
<span class="line-removed">1475       set_has_forwarded_objects(false);</span>
<span class="line-removed">1476    }</span>
<span class="line-removed">1477 </span>
1478     if (ShenandoahVerify) {
1479       verifier()-&gt;verify_roots_no_forwarded();
1480     }
1481     // All allocations past TAMS are implicitly live, adjust the region data.
1482     // Bitmaps/TAMS are swapped at this point, so we need to poll complete bitmap.
1483     {
1484       ShenandoahGCPhase phase(ShenandoahPhaseTimings::complete_liveness);
1485       ShenandoahCompleteLivenessClosure cl;
1486       parallel_heap_region_iterate(&amp;cl);
1487     }
1488 
1489     // Force the threads to reacquire their TLABs outside the collection set.
1490     {
1491       ShenandoahGCPhase phase(ShenandoahPhaseTimings::retire_tlabs);
1492       make_parsable(true);
1493     }
1494 
1495     // We are about to select the collection set, make sure it knows about
1496     // current pinning status. Also, this allows trashing more regions that
1497     // now have their pinning status dropped.
</pre>
<hr />
<pre>
1515 
1516       heuristics()-&gt;choose_collection_set(_collection_set);
1517 
1518       _free_set-&gt;rebuild();
1519     }
1520 
1521     if (!is_degenerated_gc_in_progress()) {
1522       prepare_concurrent_roots();
1523       prepare_concurrent_unloading();
1524     }
1525 
1526     // If collection set has candidates, start evacuation.
1527     // Otherwise, bypass the rest of the cycle.
1528     if (!collection_set()-&gt;is_empty()) {
1529       ShenandoahGCPhase init_evac(ShenandoahPhaseTimings::init_evac);
1530 
1531       if (ShenandoahVerify) {
1532         verifier()-&gt;verify_before_evacuation();
1533       }
1534 







1535       set_evacuation_in_progress(true);
1536       // From here on, we need to update references.
1537       set_has_forwarded_objects(true);
1538 
1539       if (!is_degenerated_gc_in_progress()) {
1540         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1541           ShenandoahCodeRoots::arm_nmethods();
1542         }
1543         evacuate_and_update_roots();
1544       }
1545 
1546       if (ShenandoahPacing) {
1547         pacer()-&gt;setup_for_evac();
1548       }
1549 
1550       if (ShenandoahVerify) {
1551         ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::None;
1552         if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {
1553           types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::JNIHandleRoots, ShenandoahRootVerifier::WeakRoots);
1554           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CLDGRoots);
</pre>
<hr />
<pre>
1570         Universe::verify();
1571       }
1572     }
1573 
1574   } else {
1575     // If this cycle was updating references, we need to keep the has_forwarded_objects
1576     // flag on, for subsequent phases to deal with it.
1577     concurrent_mark()-&gt;cancel();
1578     set_concurrent_mark_in_progress(false);
1579 
1580     if (process_references()) {
1581       // Abandon reference processing right away: pre-cleaning must have failed.
1582       ReferenceProcessor *rp = ref_processor();
1583       rp-&gt;disable_discovery();
1584       rp-&gt;abandon_partial_discovery();
1585       rp-&gt;verify_no_references_recorded();
1586     }
1587   }
1588 }
1589 
<span class="line-removed">1590 void ShenandoahHeap::op_final_evac() {</span>
<span class="line-removed">1591   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);</span>
<span class="line-removed">1592 </span>
<span class="line-removed">1593   set_evacuation_in_progress(false);</span>
<span class="line-removed">1594 </span>
<span class="line-removed">1595   {</span>
<span class="line-removed">1596     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_evac_retire_gclabs);</span>
<span class="line-removed">1597     retire_and_reset_gclabs();</span>
<span class="line-removed">1598   }</span>
<span class="line-removed">1599 </span>
<span class="line-removed">1600   if (ShenandoahVerify) {</span>
<span class="line-removed">1601     verifier()-&gt;verify_after_evacuation();</span>
<span class="line-removed">1602   }</span>
<span class="line-removed">1603 </span>
<span class="line-removed">1604   if (VerifyAfterGC) {</span>
<span class="line-removed">1605     Universe::verify();</span>
<span class="line-removed">1606   }</span>
<span class="line-removed">1607 }</span>
<span class="line-removed">1608 </span>
1609 void ShenandoahHeap::op_conc_evac() {
1610   ShenandoahEvacuationTask task(this, _collection_set, true);
1611   workers()-&gt;run_task(&amp;task);
1612 }
1613 
1614 void ShenandoahHeap::op_stw_evac() {
1615   ShenandoahEvacuationTask task(this, _collection_set, false);
1616   workers()-&gt;run_task(&amp;task);
1617 }
1618 
1619 void ShenandoahHeap::op_updaterefs() {
1620   update_heap_references(true);
1621 }
1622 
1623 void ShenandoahHeap::op_cleanup() {
1624   free_set()-&gt;recycle_trash();
1625 }
1626 
1627 class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {
1628 private:
</pre>
<hr />
<pre>
2159                             ShenandoahPhaseTimings::purge_cldg);
2160     ClassLoaderDataGraph::purge();
2161   }
2162   // Resize and verify metaspace
2163   MetaspaceGC::compute_new_size();
2164   MetaspaceUtils::verify_metrics();
2165 }
2166 
2167 // Weak roots are either pre-evacuated (final mark) or updated (final updaterefs),
2168 // so they should not have forwarded oops.
2169 // However, we do need to &quot;null&quot; dead oops in the roots, if can not be done
2170 // in concurrent cycles.
2171 void ShenandoahHeap::stw_process_weak_roots(bool full_gc) {
2172   ShenandoahGCPhase root_phase(full_gc ?
2173                                ShenandoahPhaseTimings::full_gc_purge :
2174                                ShenandoahPhaseTimings::purge);
2175   uint num_workers = _workers-&gt;active_workers();
2176   ShenandoahPhaseTimings::Phase timing_phase = full_gc ?
2177                                                ShenandoahPhaseTimings::full_gc_purge_par :
2178                                                ShenandoahPhaseTimings::purge_par;
<span class="line-removed">2179   // Cleanup weak roots</span>
2180   ShenandoahGCPhase phase(timing_phase);
<span class="line-modified">2181   phase_timings()-&gt;record_workers_start(timing_phase);</span>


2182   if (has_forwarded_objects()) {
<span class="line-modified">2183     if (is_traversal_mode()) {</span>
<span class="line-modified">2184       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-modified">2185       ShenandoahTraversalUpdateRefsClosure keep_alive;</span>
<span class="line-modified">2186       ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahTraversalUpdateRefsClosure&gt;</span>
<span class="line-modified">2187         cleaning_task(&amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-removed">2188       _workers-&gt;run_task(&amp;cleaning_task);</span>
<span class="line-removed">2189     } else {</span>
<span class="line-removed">2190       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-removed">2191       ShenandoahUpdateRefsClosure keep_alive;</span>
<span class="line-removed">2192       ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahUpdateRefsClosure&gt;</span>
<span class="line-removed">2193         cleaning_task(&amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-removed">2194       _workers-&gt;run_task(&amp;cleaning_task);</span>
<span class="line-removed">2195     }</span>
2196   } else {
2197     ShenandoahIsAliveClosure is_alive;
2198 #ifdef ASSERT
2199     ShenandoahAssertNotForwardedClosure verify_cl;
2200     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, ShenandoahAssertNotForwardedClosure&gt;
2201       cleaning_task(&amp;is_alive, &amp;verify_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
2202 #else
2203     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, DoNothingClosure&gt;
2204       cleaning_task(&amp;is_alive, &amp;do_nothing_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
2205 #endif
2206     _workers-&gt;run_task(&amp;cleaning_task);
2207   }
<span class="line-removed">2208   phase_timings()-&gt;record_workers_end(timing_phase);</span>
2209 }
2210 
2211 void ShenandoahHeap::parallel_cleaning(bool full_gc) {
2212   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2213   stw_process_weak_roots(full_gc);
2214   if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2215     stw_unload_classes(full_gc);
2216   }
2217 }
2218 
2219 void ShenandoahHeap::set_has_forwarded_objects(bool cond) {
2220   if (is_traversal_mode()) {
2221     set_gc_state_mask(HAS_FORWARDED | UPDATEREFS, cond);
2222   } else {
2223     set_gc_state_mask(HAS_FORWARDED, cond);
2224   }
2225 
2226 }
2227 
2228 void ShenandoahHeap::set_process_references(bool pr) {
</pre>
<hr />
<pre>
2402     _regions(regions),
2403     _concurrent(concurrent) {
2404   }
2405 
2406   void work(uint worker_id) {
2407     if (_concurrent) {
2408       ShenandoahConcurrentWorkerSession worker_session(worker_id);
2409       ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
2410       do_work();
2411     } else {
2412       ShenandoahParallelWorkerSession worker_session(worker_id);
2413       do_work();
2414     }
2415   }
2416 
2417 private:
2418   void do_work() {
2419     ShenandoahHeapRegion* r = _regions-&gt;next();
2420     ShenandoahMarkingContext* const ctx = _heap-&gt;complete_marking_context();
2421     while (r != NULL) {
<span class="line-modified">2422       HeapWord* top_at_start_ur = r-&gt;concurrent_iteration_safe_limit();</span>
<span class="line-modified">2423       assert (top_at_start_ur &gt;= r-&gt;bottom(), &quot;sanity&quot;);</span>
2424       if (r-&gt;is_active() &amp;&amp; !r-&gt;is_cset()) {
<span class="line-modified">2425         _heap-&gt;marked_object_oop_iterate(r, &amp;cl, top_at_start_ur);</span>
2426       }

2427       if (ShenandoahPacing) {
<span class="line-modified">2428         _heap-&gt;pacer()-&gt;report_updaterefs(pointer_delta(top_at_start_ur, r-&gt;bottom()));</span>
2429       }
2430       if (_heap-&gt;check_cancelled_gc_and_yield(_concurrent)) {
2431         return;
2432       }
2433       r = _regions-&gt;next();
2434     }
2435   }
2436 };
2437 
2438 void ShenandoahHeap::update_heap_references(bool concurrent) {
2439   ShenandoahUpdateHeapRefsTask&lt;ShenandoahUpdateHeapRefsClosure&gt; task(&amp;_update_refs_iterator, concurrent);
2440   workers()-&gt;run_task(&amp;task);
2441 }
2442 
2443 void ShenandoahHeap::op_init_updaterefs() {
2444   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2445 
2446   set_evacuation_in_progress(false);
2447 
2448   {
2449     ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_retire_gclabs);
2450     retire_and_reset_gclabs();
2451   }
2452 
2453   if (ShenandoahVerify) {
2454     if (!is_degenerated_gc_in_progress()) {
2455       verifier()-&gt;verify_roots_in_to_space_except(ShenandoahRootVerifier::ThreadRoots);
2456     }
2457     verifier()-&gt;verify_before_updaterefs();
2458   }
2459 
2460   set_update_refs_in_progress(true);
2461 
2462   {
2463     ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_prepare);
2464 
2465     make_parsable(true);
<span class="line-removed">2466     for (uint i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-removed">2467       ShenandoahHeapRegion* r = get_region(i);</span>
<span class="line-removed">2468       r-&gt;set_concurrent_iteration_safe_limit(r-&gt;top());</span>
<span class="line-removed">2469     }</span>
2470 
2471     // Reset iterator.
2472     _update_refs_iterator.reset();
2473   }
2474 
2475   if (ShenandoahPacing) {
2476     pacer()-&gt;setup_for_updaterefs();
2477   }
2478 }
2479 
2480 void ShenandoahHeap::op_final_updaterefs() {
2481   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2482 
2483   finish_concurrent_unloading();
2484 
2485   // Check if there is left-over work, and finish it
2486   if (_update_refs_iterator.has_next()) {
2487     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_finish_work);
2488 
2489     // Finish updating references where we left off.
</pre>
<hr />
<pre>
2639 void ShenandoahHeap::vmop_entry_init_mark() {
2640   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2641   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2642   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_mark_gross);
2643 
2644   try_inject_alloc_failure();
2645   VM_ShenandoahInitMark op;
2646   VMThread::execute(&amp;op); // jump to entry_init_mark() under safepoint
2647 }
2648 
2649 void ShenandoahHeap::vmop_entry_final_mark() {
2650   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2651   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2652   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_mark_gross);
2653 
2654   try_inject_alloc_failure();
2655   VM_ShenandoahFinalMarkStartEvac op;
2656   VMThread::execute(&amp;op); // jump to entry_final_mark under safepoint
2657 }
2658 
<span class="line-removed">2659 void ShenandoahHeap::vmop_entry_final_evac() {</span>
<span class="line-removed">2660   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());</span>
<span class="line-removed">2661   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);</span>
<span class="line-removed">2662   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_evac_gross);</span>
<span class="line-removed">2663 </span>
<span class="line-removed">2664   VM_ShenandoahFinalEvac op;</span>
<span class="line-removed">2665   VMThread::execute(&amp;op); // jump to entry_final_evac under safepoint</span>
<span class="line-removed">2666 }</span>
<span class="line-removed">2667 </span>
2668 void ShenandoahHeap::vmop_entry_init_updaterefs() {
2669   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2670   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2671   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_gross);
2672 
2673   try_inject_alloc_failure();
2674   VM_ShenandoahInitUpdateRefs op;
2675   VMThread::execute(&amp;op);
2676 }
2677 
2678 void ShenandoahHeap::vmop_entry_final_updaterefs() {
2679   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2680   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2681   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_gross);
2682 
2683   try_inject_alloc_failure();
2684   VM_ShenandoahFinalUpdateRefs op;
2685   VMThread::execute(&amp;op);
2686 }
2687 
</pre>
<hr />
<pre>
2735                               ShenandoahWorkerPolicy::calc_workers_for_init_marking(),
2736                               &quot;init marking&quot;);
2737 
2738   op_init_mark();
2739 }
2740 
2741 void ShenandoahHeap::entry_final_mark() {
2742   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2743   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_mark);
2744   const char* msg = final_mark_event_message();
2745   GCTraceTime(Info, gc) time(msg, gc_timer());
2746   EventMark em(&quot;%s&quot;, msg);
2747 
2748   ShenandoahWorkerScope scope(workers(),
2749                               ShenandoahWorkerPolicy::calc_workers_for_final_marking(),
2750                               &quot;final marking&quot;);
2751 
2752   op_final_mark();
2753 }
2754 
<span class="line-removed">2755 void ShenandoahHeap::entry_final_evac() {</span>
<span class="line-removed">2756   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);</span>
<span class="line-removed">2757   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_evac);</span>
<span class="line-removed">2758   static const char* msg = &quot;Pause Final Evac&quot;;</span>
<span class="line-removed">2759   GCTraceTime(Info, gc) time(msg, gc_timer());</span>
<span class="line-removed">2760   EventMark em(&quot;%s&quot;, msg);</span>
<span class="line-removed">2761 </span>
<span class="line-removed">2762   op_final_evac();</span>
<span class="line-removed">2763 }</span>
<span class="line-removed">2764 </span>
2765 void ShenandoahHeap::entry_init_updaterefs() {
2766   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2767   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs);
2768 
2769   static const char* msg = &quot;Pause Init Update Refs&quot;;
2770   GCTraceTime(Info, gc) time(msg, gc_timer());
2771   EventMark em(&quot;%s&quot;, msg);
2772 
2773   // No workers used in this phase, no setup required
2774 
2775   op_init_updaterefs();
2776 }
2777 
2778 void ShenandoahHeap::entry_final_updaterefs() {
2779   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2780   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs);
2781 
2782   static const char* msg = &quot;Pause Final Update Refs&quot;;
2783   GCTraceTime(Info, gc) time(msg, gc_timer());
2784   EventMark em(&quot;%s&quot;, msg);
</pre>
<hr />
<pre>
3042   _index = 0;
3043 }
3044 
3045 bool ShenandoahRegionIterator::has_next() const {
3046   return _index &lt; _heap-&gt;num_regions();
3047 }
3048 
3049 char ShenandoahHeap::gc_state() const {
3050   return _gc_state.raw_value();
3051 }
3052 
3053 void ShenandoahHeap::deduplicate_string(oop str) {
3054   assert(java_lang_String::is_instance(str), &quot;invariant&quot;);
3055 
3056   if (ShenandoahStringDedup::is_enabled()) {
3057     ShenandoahStringDedup::deduplicate(str);
3058   }
3059 }
3060 
3061 const char* ShenandoahHeap::init_mark_event_message() const {
<span class="line-modified">3062   bool update_refs = has_forwarded_objects();</span>

3063   bool proc_refs = process_references();
3064   bool unload_cls = unload_classes();
3065 
<span class="line-modified">3066   if (update_refs &amp;&amp; proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3067     return &quot;Pause Init Mark (update refs) (process weakrefs) (unload classes)&quot;;</span>
<span class="line-removed">3068   } else if (update_refs &amp;&amp; proc_refs) {</span>
<span class="line-removed">3069     return &quot;Pause Init Mark (update refs) (process weakrefs)&quot;;</span>
<span class="line-removed">3070   } else if (update_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3071     return &quot;Pause Init Mark (update refs) (unload classes)&quot;;</span>
<span class="line-removed">3072   } else if (proc_refs &amp;&amp; unload_cls) {</span>
3073     return &quot;Pause Init Mark (process weakrefs) (unload classes)&quot;;
<span class="line-removed">3074   } else if (update_refs) {</span>
<span class="line-removed">3075     return &quot;Pause Init Mark (update refs)&quot;;</span>
3076   } else if (proc_refs) {
3077     return &quot;Pause Init Mark (process weakrefs)&quot;;
3078   } else if (unload_cls) {
3079     return &quot;Pause Init Mark (unload classes)&quot;;
3080   } else {
3081     return &quot;Pause Init Mark&quot;;
3082   }
3083 }
3084 
3085 const char* ShenandoahHeap::final_mark_event_message() const {
<span class="line-modified">3086   bool update_refs = has_forwarded_objects();</span>

3087   bool proc_refs = process_references();
3088   bool unload_cls = unload_classes();
3089 
<span class="line-modified">3090   if (update_refs &amp;&amp; proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3091     return &quot;Pause Final Mark (update refs) (process weakrefs) (unload classes)&quot;;</span>
<span class="line-removed">3092   } else if (update_refs &amp;&amp; proc_refs) {</span>
<span class="line-removed">3093     return &quot;Pause Final Mark (update refs) (process weakrefs)&quot;;</span>
<span class="line-removed">3094   } else if (update_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3095     return &quot;Pause Final Mark (update refs) (unload classes)&quot;;</span>
<span class="line-removed">3096   } else if (proc_refs &amp;&amp; unload_cls) {</span>
3097     return &quot;Pause Final Mark (process weakrefs) (unload classes)&quot;;
<span class="line-removed">3098   } else if (update_refs) {</span>
<span class="line-removed">3099     return &quot;Pause Final Mark (update refs)&quot;;</span>
3100   } else if (proc_refs) {
3101     return &quot;Pause Final Mark (process weakrefs)&quot;;
3102   } else if (unload_cls) {
3103     return &quot;Pause Final Mark (unload classes)&quot;;
3104   } else {
3105     return &quot;Pause Final Mark&quot;;
3106   }
3107 }
3108 
3109 const char* ShenandoahHeap::conc_mark_event_message() const {
<span class="line-modified">3110   bool update_refs = has_forwarded_objects();</span>

3111   bool proc_refs = process_references();
3112   bool unload_cls = unload_classes();
3113 
<span class="line-modified">3114   if (update_refs &amp;&amp; proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3115     return &quot;Concurrent marking (update refs) (process weakrefs) (unload classes)&quot;;</span>
<span class="line-removed">3116   } else if (update_refs &amp;&amp; proc_refs) {</span>
<span class="line-removed">3117     return &quot;Concurrent marking (update refs) (process weakrefs)&quot;;</span>
<span class="line-removed">3118   } else if (update_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3119     return &quot;Concurrent marking (update refs) (unload classes)&quot;;</span>
<span class="line-removed">3120   } else if (proc_refs &amp;&amp; unload_cls) {</span>
3121     return &quot;Concurrent marking (process weakrefs) (unload classes)&quot;;
<span class="line-removed">3122   } else if (update_refs) {</span>
<span class="line-removed">3123     return &quot;Concurrent marking (update refs)&quot;;</span>
3124   } else if (proc_refs) {
3125     return &quot;Concurrent marking (process weakrefs)&quot;;
3126   } else if (unload_cls) {
3127     return &quot;Concurrent marking (unload classes)&quot;;
3128   } else {
3129     return &quot;Concurrent marking&quot;;
3130   }
3131 }
3132 
3133 const char* ShenandoahHeap::init_traversal_event_message() const {
3134   bool proc_refs = process_references();
3135   bool unload_cls = unload_classes();
3136 
3137   if (proc_refs &amp;&amp; unload_cls) {
3138     return &quot;Pause Init Traversal (process weakrefs) (unload classes)&quot;;
3139   } else if (proc_refs) {
3140     return &quot;Pause Init Traversal (process weakrefs)&quot;;
3141   } else if (unload_cls) {
3142     return &quot;Pause Init Traversal (unload classes)&quot;;
3143   } else {
</pre>
</td>
<td>
<hr />
<pre>
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.hpp&quot;
  27 #include &quot;memory/universe.hpp&quot;
  28 
  29 #include &quot;gc/shared/gcArguments.hpp&quot;
  30 #include &quot;gc/shared/gcTimer.hpp&quot;
  31 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  32 #include &quot;gc/shared/locationPrinter.inline.hpp&quot;
  33 #include &quot;gc/shared/memAllocator.hpp&quot;
  34 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  35 #include &quot;gc/shared/plab.hpp&quot;
  36 

  37 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
  38 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
  39 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  40 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  41 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
  42 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
  43 #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
  44 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  45 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  46 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  47 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  48 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
  49 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  50 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  51 #include &quot;gc/shenandoah/shenandoahMemoryPool.hpp&quot;
  52 #include &quot;gc/shenandoah/shenandoahMetrics.hpp&quot;
  53 #include &quot;gc/shenandoah/shenandoahMonitoringSupport.hpp&quot;
  54 #include &quot;gc/shenandoah/shenandoahNormalMode.hpp&quot;
  55 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
  56 #include &quot;gc/shenandoah/shenandoahPacer.inline.hpp&quot;
</pre>
<hr />
<pre>
1367   void heap_region_do(ShenandoahHeapRegion* r) {
1368     if (r-&gt;is_active()) {
1369       r-&gt;clear_live_data();
1370       _ctx-&gt;capture_top_at_mark_start(r);
1371     } else {
1372       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;region_number());
1373       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
1374              &quot;Region &quot; SIZE_FORMAT &quot; should already have correct TAMS&quot;, r-&gt;region_number());
1375     }
1376   }
1377 
1378   bool is_thread_safe() { return true; }
1379 };
1380 
1381 void ShenandoahHeap::op_init_mark() {
1382   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1383   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
1384 
1385   assert(marking_context()-&gt;is_bitmap_clear(), &quot;need clear marking bitmap&quot;);
1386   assert(!marking_context()-&gt;is_complete(), &quot;should not be complete&quot;);
<span class="line-added">1387   assert(!has_forwarded_objects(), &quot;No forwarded objects on this path&quot;);</span>
1388 
1389   if (ShenandoahVerify) {
1390     verifier()-&gt;verify_before_concmark();
1391   }
1392 
1393   if (VerifyBeforeGC) {
1394     Universe::verify();
1395   }
1396 
1397   set_concurrent_mark_in_progress(true);
1398   // We need to reset all TLABs because we&#39;d lose marks on all objects allocated in them.
1399   {
1400     ShenandoahGCPhase phase(ShenandoahPhaseTimings::make_parsable);
1401     make_parsable(true);
1402   }
1403 
1404   {
1405     ShenandoahGCPhase phase(ShenandoahPhaseTimings::clear_liveness);
1406     ShenandoahClearLivenessClosure clc;
1407     parallel_heap_region_iterate(&amp;clc);
</pre>
<hr />
<pre>
1434 
1435   void heap_region_do(ShenandoahHeapRegion* r) {
1436     if (r-&gt;is_active()) {
1437       HeapWord *tams = _ctx-&gt;top_at_mark_start(r);
1438       HeapWord *top = r-&gt;top();
1439       if (top &gt; tams) {
1440         r-&gt;increase_live_data_alloc_words(pointer_delta(top, tams));
1441       }
1442     } else {
1443       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;region_number());
1444       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
1445              &quot;Region &quot; SIZE_FORMAT &quot; should have correct TAMS&quot;, r-&gt;region_number());
1446     }
1447   }
1448 
1449   bool is_thread_safe() { return true; }
1450 };
1451 
1452 void ShenandoahHeap::op_final_mark() {
1453   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
<span class="line-added">1454   assert(!has_forwarded_objects(), &quot;No forwarded objects on this path&quot;);</span>
1455 
1456   // It is critical that we
1457   // evacuate roots right after finishing marking, so that we don&#39;t
1458   // get unmarked objects in the roots.
1459 
1460   if (!cancelled_gc()) {
1461     concurrent_mark()-&gt;finish_mark_from_roots(/* full_gc = */ false);
1462 
1463     // Marking is completed, deactivate SATB barrier
1464     set_concurrent_mark_in_progress(false);
1465     mark_complete_marking_context();
1466 
1467     parallel_cleaning(false /* full gc*/);
1468 










1469     if (ShenandoahVerify) {
1470       verifier()-&gt;verify_roots_no_forwarded();
1471     }
1472     // All allocations past TAMS are implicitly live, adjust the region data.
1473     // Bitmaps/TAMS are swapped at this point, so we need to poll complete bitmap.
1474     {
1475       ShenandoahGCPhase phase(ShenandoahPhaseTimings::complete_liveness);
1476       ShenandoahCompleteLivenessClosure cl;
1477       parallel_heap_region_iterate(&amp;cl);
1478     }
1479 
1480     // Force the threads to reacquire their TLABs outside the collection set.
1481     {
1482       ShenandoahGCPhase phase(ShenandoahPhaseTimings::retire_tlabs);
1483       make_parsable(true);
1484     }
1485 
1486     // We are about to select the collection set, make sure it knows about
1487     // current pinning status. Also, this allows trashing more regions that
1488     // now have their pinning status dropped.
</pre>
<hr />
<pre>
1506 
1507       heuristics()-&gt;choose_collection_set(_collection_set);
1508 
1509       _free_set-&gt;rebuild();
1510     }
1511 
1512     if (!is_degenerated_gc_in_progress()) {
1513       prepare_concurrent_roots();
1514       prepare_concurrent_unloading();
1515     }
1516 
1517     // If collection set has candidates, start evacuation.
1518     // Otherwise, bypass the rest of the cycle.
1519     if (!collection_set()-&gt;is_empty()) {
1520       ShenandoahGCPhase init_evac(ShenandoahPhaseTimings::init_evac);
1521 
1522       if (ShenandoahVerify) {
1523         verifier()-&gt;verify_before_evacuation();
1524       }
1525 
<span class="line-added">1526       // Remember limit for updating refs. It&#39;s guaranteed that we get no from-space-refs written</span>
<span class="line-added">1527       // from here on.</span>
<span class="line-added">1528       for (uint i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-added">1529         ShenandoahHeapRegion* r = get_region(i);</span>
<span class="line-added">1530         r-&gt;set_update_watermark(r-&gt;top());</span>
<span class="line-added">1531       }</span>
<span class="line-added">1532 </span>
1533       set_evacuation_in_progress(true);
1534       // From here on, we need to update references.
1535       set_has_forwarded_objects(true);
1536 
1537       if (!is_degenerated_gc_in_progress()) {
1538         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1539           ShenandoahCodeRoots::arm_nmethods();
1540         }
1541         evacuate_and_update_roots();
1542       }
1543 
1544       if (ShenandoahPacing) {
1545         pacer()-&gt;setup_for_evac();
1546       }
1547 
1548       if (ShenandoahVerify) {
1549         ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::None;
1550         if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {
1551           types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::JNIHandleRoots, ShenandoahRootVerifier::WeakRoots);
1552           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CLDGRoots);
</pre>
<hr />
<pre>
1568         Universe::verify();
1569       }
1570     }
1571 
1572   } else {
1573     // If this cycle was updating references, we need to keep the has_forwarded_objects
1574     // flag on, for subsequent phases to deal with it.
1575     concurrent_mark()-&gt;cancel();
1576     set_concurrent_mark_in_progress(false);
1577 
1578     if (process_references()) {
1579       // Abandon reference processing right away: pre-cleaning must have failed.
1580       ReferenceProcessor *rp = ref_processor();
1581       rp-&gt;disable_discovery();
1582       rp-&gt;abandon_partial_discovery();
1583       rp-&gt;verify_no_references_recorded();
1584     }
1585   }
1586 }
1587 



















1588 void ShenandoahHeap::op_conc_evac() {
1589   ShenandoahEvacuationTask task(this, _collection_set, true);
1590   workers()-&gt;run_task(&amp;task);
1591 }
1592 
1593 void ShenandoahHeap::op_stw_evac() {
1594   ShenandoahEvacuationTask task(this, _collection_set, false);
1595   workers()-&gt;run_task(&amp;task);
1596 }
1597 
1598 void ShenandoahHeap::op_updaterefs() {
1599   update_heap_references(true);
1600 }
1601 
1602 void ShenandoahHeap::op_cleanup() {
1603   free_set()-&gt;recycle_trash();
1604 }
1605 
1606 class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {
1607 private:
</pre>
<hr />
<pre>
2138                             ShenandoahPhaseTimings::purge_cldg);
2139     ClassLoaderDataGraph::purge();
2140   }
2141   // Resize and verify metaspace
2142   MetaspaceGC::compute_new_size();
2143   MetaspaceUtils::verify_metrics();
2144 }
2145 
2146 // Weak roots are either pre-evacuated (final mark) or updated (final updaterefs),
2147 // so they should not have forwarded oops.
2148 // However, we do need to &quot;null&quot; dead oops in the roots, if can not be done
2149 // in concurrent cycles.
2150 void ShenandoahHeap::stw_process_weak_roots(bool full_gc) {
2151   ShenandoahGCPhase root_phase(full_gc ?
2152                                ShenandoahPhaseTimings::full_gc_purge :
2153                                ShenandoahPhaseTimings::purge);
2154   uint num_workers = _workers-&gt;active_workers();
2155   ShenandoahPhaseTimings::Phase timing_phase = full_gc ?
2156                                                ShenandoahPhaseTimings::full_gc_purge_par :
2157                                                ShenandoahPhaseTimings::purge_par;

2158   ShenandoahGCPhase phase(timing_phase);
<span class="line-modified">2159   ShenandoahGCWorkerPhase worker_phase(timing_phase);</span>
<span class="line-added">2160 </span>
<span class="line-added">2161   // Cleanup weak roots</span>
2162   if (has_forwarded_objects()) {
<span class="line-modified">2163     ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-modified">2164     ShenandoahUpdateRefsClosure keep_alive;</span>
<span class="line-modified">2165     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahUpdateRefsClosure&gt;</span>
<span class="line-modified">2166       cleaning_task(&amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-modified">2167     _workers-&gt;run_task(&amp;cleaning_task);</span>








2168   } else {
2169     ShenandoahIsAliveClosure is_alive;
2170 #ifdef ASSERT
2171     ShenandoahAssertNotForwardedClosure verify_cl;
2172     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, ShenandoahAssertNotForwardedClosure&gt;
2173       cleaning_task(&amp;is_alive, &amp;verify_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
2174 #else
2175     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, DoNothingClosure&gt;
2176       cleaning_task(&amp;is_alive, &amp;do_nothing_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
2177 #endif
2178     _workers-&gt;run_task(&amp;cleaning_task);
2179   }

2180 }
2181 
2182 void ShenandoahHeap::parallel_cleaning(bool full_gc) {
2183   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2184   stw_process_weak_roots(full_gc);
2185   if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2186     stw_unload_classes(full_gc);
2187   }
2188 }
2189 
2190 void ShenandoahHeap::set_has_forwarded_objects(bool cond) {
2191   if (is_traversal_mode()) {
2192     set_gc_state_mask(HAS_FORWARDED | UPDATEREFS, cond);
2193   } else {
2194     set_gc_state_mask(HAS_FORWARDED, cond);
2195   }
2196 
2197 }
2198 
2199 void ShenandoahHeap::set_process_references(bool pr) {
</pre>
<hr />
<pre>
2373     _regions(regions),
2374     _concurrent(concurrent) {
2375   }
2376 
2377   void work(uint worker_id) {
2378     if (_concurrent) {
2379       ShenandoahConcurrentWorkerSession worker_session(worker_id);
2380       ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
2381       do_work();
2382     } else {
2383       ShenandoahParallelWorkerSession worker_session(worker_id);
2384       do_work();
2385     }
2386   }
2387 
2388 private:
2389   void do_work() {
2390     ShenandoahHeapRegion* r = _regions-&gt;next();
2391     ShenandoahMarkingContext* const ctx = _heap-&gt;complete_marking_context();
2392     while (r != NULL) {
<span class="line-modified">2393       HeapWord* update_watermark = r-&gt;get_update_watermark();</span>
<span class="line-modified">2394       assert (update_watermark &gt;= r-&gt;bottom(), &quot;sanity&quot;);</span>
2395       if (r-&gt;is_active() &amp;&amp; !r-&gt;is_cset()) {
<span class="line-modified">2396         _heap-&gt;marked_object_oop_iterate(r, &amp;cl, update_watermark);</span>
2397       }
<span class="line-added">2398       r-&gt;set_update_watermark(r-&gt;bottom());</span>
2399       if (ShenandoahPacing) {
<span class="line-modified">2400         _heap-&gt;pacer()-&gt;report_updaterefs(pointer_delta(update_watermark, r-&gt;bottom()));</span>
2401       }
2402       if (_heap-&gt;check_cancelled_gc_and_yield(_concurrent)) {
2403         return;
2404       }
2405       r = _regions-&gt;next();
2406     }
2407   }
2408 };
2409 
2410 void ShenandoahHeap::update_heap_references(bool concurrent) {
2411   ShenandoahUpdateHeapRefsTask&lt;ShenandoahUpdateHeapRefsClosure&gt; task(&amp;_update_refs_iterator, concurrent);
2412   workers()-&gt;run_task(&amp;task);
2413 }
2414 
2415 void ShenandoahHeap::op_init_updaterefs() {
2416   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2417 
2418   set_evacuation_in_progress(false);
2419 
2420   {
2421     ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_retire_gclabs);
2422     retire_and_reset_gclabs();
2423   }
2424 
2425   if (ShenandoahVerify) {
2426     if (!is_degenerated_gc_in_progress()) {
2427       verifier()-&gt;verify_roots_in_to_space_except(ShenandoahRootVerifier::ThreadRoots);
2428     }
2429     verifier()-&gt;verify_before_updaterefs();
2430   }
2431 
2432   set_update_refs_in_progress(true);
2433 
2434   {
2435     ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_prepare);
2436 
2437     make_parsable(true);




2438 
2439     // Reset iterator.
2440     _update_refs_iterator.reset();
2441   }
2442 
2443   if (ShenandoahPacing) {
2444     pacer()-&gt;setup_for_updaterefs();
2445   }
2446 }
2447 
2448 void ShenandoahHeap::op_final_updaterefs() {
2449   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2450 
2451   finish_concurrent_unloading();
2452 
2453   // Check if there is left-over work, and finish it
2454   if (_update_refs_iterator.has_next()) {
2455     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_finish_work);
2456 
2457     // Finish updating references where we left off.
</pre>
<hr />
<pre>
2607 void ShenandoahHeap::vmop_entry_init_mark() {
2608   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2609   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2610   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_mark_gross);
2611 
2612   try_inject_alloc_failure();
2613   VM_ShenandoahInitMark op;
2614   VMThread::execute(&amp;op); // jump to entry_init_mark() under safepoint
2615 }
2616 
2617 void ShenandoahHeap::vmop_entry_final_mark() {
2618   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2619   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2620   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_mark_gross);
2621 
2622   try_inject_alloc_failure();
2623   VM_ShenandoahFinalMarkStartEvac op;
2624   VMThread::execute(&amp;op); // jump to entry_final_mark under safepoint
2625 }
2626 









2627 void ShenandoahHeap::vmop_entry_init_updaterefs() {
2628   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2629   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2630   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_gross);
2631 
2632   try_inject_alloc_failure();
2633   VM_ShenandoahInitUpdateRefs op;
2634   VMThread::execute(&amp;op);
2635 }
2636 
2637 void ShenandoahHeap::vmop_entry_final_updaterefs() {
2638   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2639   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2640   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_gross);
2641 
2642   try_inject_alloc_failure();
2643   VM_ShenandoahFinalUpdateRefs op;
2644   VMThread::execute(&amp;op);
2645 }
2646 
</pre>
<hr />
<pre>
2694                               ShenandoahWorkerPolicy::calc_workers_for_init_marking(),
2695                               &quot;init marking&quot;);
2696 
2697   op_init_mark();
2698 }
2699 
2700 void ShenandoahHeap::entry_final_mark() {
2701   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2702   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_mark);
2703   const char* msg = final_mark_event_message();
2704   GCTraceTime(Info, gc) time(msg, gc_timer());
2705   EventMark em(&quot;%s&quot;, msg);
2706 
2707   ShenandoahWorkerScope scope(workers(),
2708                               ShenandoahWorkerPolicy::calc_workers_for_final_marking(),
2709                               &quot;final marking&quot;);
2710 
2711   op_final_mark();
2712 }
2713 










2714 void ShenandoahHeap::entry_init_updaterefs() {
2715   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2716   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs);
2717 
2718   static const char* msg = &quot;Pause Init Update Refs&quot;;
2719   GCTraceTime(Info, gc) time(msg, gc_timer());
2720   EventMark em(&quot;%s&quot;, msg);
2721 
2722   // No workers used in this phase, no setup required
2723 
2724   op_init_updaterefs();
2725 }
2726 
2727 void ShenandoahHeap::entry_final_updaterefs() {
2728   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2729   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs);
2730 
2731   static const char* msg = &quot;Pause Final Update Refs&quot;;
2732   GCTraceTime(Info, gc) time(msg, gc_timer());
2733   EventMark em(&quot;%s&quot;, msg);
</pre>
<hr />
<pre>
2991   _index = 0;
2992 }
2993 
2994 bool ShenandoahRegionIterator::has_next() const {
2995   return _index &lt; _heap-&gt;num_regions();
2996 }
2997 
2998 char ShenandoahHeap::gc_state() const {
2999   return _gc_state.raw_value();
3000 }
3001 
3002 void ShenandoahHeap::deduplicate_string(oop str) {
3003   assert(java_lang_String::is_instance(str), &quot;invariant&quot;);
3004 
3005   if (ShenandoahStringDedup::is_enabled()) {
3006     ShenandoahStringDedup::deduplicate(str);
3007   }
3008 }
3009 
3010 const char* ShenandoahHeap::init_mark_event_message() const {
<span class="line-modified">3011   assert(!has_forwarded_objects(), &quot;Should not have forwarded objects here&quot;);</span>
<span class="line-added">3012 </span>
3013   bool proc_refs = process_references();
3014   bool unload_cls = unload_classes();
3015 
<span class="line-modified">3016   if (proc_refs &amp;&amp; unload_cls) {</span>






3017     return &quot;Pause Init Mark (process weakrefs) (unload classes)&quot;;


3018   } else if (proc_refs) {
3019     return &quot;Pause Init Mark (process weakrefs)&quot;;
3020   } else if (unload_cls) {
3021     return &quot;Pause Init Mark (unload classes)&quot;;
3022   } else {
3023     return &quot;Pause Init Mark&quot;;
3024   }
3025 }
3026 
3027 const char* ShenandoahHeap::final_mark_event_message() const {
<span class="line-modified">3028   assert(!has_forwarded_objects(), &quot;Should not have forwarded objects here&quot;);</span>
<span class="line-added">3029 </span>
3030   bool proc_refs = process_references();
3031   bool unload_cls = unload_classes();
3032 
<span class="line-modified">3033   if (proc_refs &amp;&amp; unload_cls) {</span>






3034     return &quot;Pause Final Mark (process weakrefs) (unload classes)&quot;;


3035   } else if (proc_refs) {
3036     return &quot;Pause Final Mark (process weakrefs)&quot;;
3037   } else if (unload_cls) {
3038     return &quot;Pause Final Mark (unload classes)&quot;;
3039   } else {
3040     return &quot;Pause Final Mark&quot;;
3041   }
3042 }
3043 
3044 const char* ShenandoahHeap::conc_mark_event_message() const {
<span class="line-modified">3045   assert(!has_forwarded_objects(), &quot;Should not have forwarded objects here&quot;);</span>
<span class="line-added">3046 </span>
3047   bool proc_refs = process_references();
3048   bool unload_cls = unload_classes();
3049 
<span class="line-modified">3050   if (proc_refs &amp;&amp; unload_cls) {</span>






3051     return &quot;Concurrent marking (process weakrefs) (unload classes)&quot;;


3052   } else if (proc_refs) {
3053     return &quot;Concurrent marking (process weakrefs)&quot;;
3054   } else if (unload_cls) {
3055     return &quot;Concurrent marking (unload classes)&quot;;
3056   } else {
3057     return &quot;Concurrent marking&quot;;
3058   }
3059 }
3060 
3061 const char* ShenandoahHeap::init_traversal_event_message() const {
3062   bool proc_refs = process_references();
3063   bool unload_cls = unload_classes();
3064 
3065   if (proc_refs &amp;&amp; unload_cls) {
3066     return &quot;Pause Init Traversal (process weakrefs) (unload classes)&quot;;
3067   } else if (proc_refs) {
3068     return &quot;Pause Init Traversal (process weakrefs)&quot;;
3069   } else if (unload_cls) {
3070     return &quot;Pause Init Traversal (unload classes)&quot;;
3071   } else {
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahFreeSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
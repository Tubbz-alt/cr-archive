<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1VMOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1Policy.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1VMOperations.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1VMOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,10 ***</span>
<span class="line-new-header">--- 25,12 ---</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
  #include &quot;gc/g1/g1Policy.hpp&quot;
  #include &quot;gc/g1/g1VMOperations.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shared/gcCause.hpp&quot;</span>
  #include &quot;gc/shared/gcId.hpp&quot;
  #include &quot;gc/shared/gcTimer.hpp&quot;
  #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  #include &quot;gc/shared/isGCActiveMark.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,10 ***</span>
<span class="line-new-header">--- 47,11 ---</span>
                                                     double target_pause_time_ms) :
    VM_GC_Operation(gc_count_before, gc_cause),
    _target_pause_time_ms(target_pause_time_ms),
    _transient_failure(false),
    _cycle_already_in_progress(false),
<span class="line-added">+   _whitebox_attached(false),</span>
    _terminating(false),
    _gc_succeeded(false)
  {}
  
  bool VM_G1TryInitiateConcMark::doit_prologue() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,10 ***</span>
<span class="line-new-header">--- 83,17 ---</span>
    } else if (!g1h-&gt;policy()-&gt;force_initial_mark_if_outside_cycle(_gc_cause)) {
      // Failure to force the next GC pause to be an initial mark indicates
      // there is already a concurrent marking cycle in progress.  Set flag
      // to notify the caller and return immediately.
      _cycle_already_in_progress = true;
<span class="line-added">+   } else if ((_gc_cause != GCCause::_wb_breakpoint) &amp;&amp;</span>
<span class="line-added">+              ConcurrentGCBreakpoints::is_controlled()) {</span>
<span class="line-added">+     // WhiteBox wants to be in control of concurrent cycles, so don&#39;t try to</span>
<span class="line-added">+     // start one.  This check is after the force_initial_mark_xxx so that a</span>
<span class="line-added">+     // request will be remembered for a later partial collection, even though</span>
<span class="line-added">+     // we&#39;ve rejected this request.</span>
<span class="line-added">+     _whitebox_attached = true;</span>
    } else if (g1h-&gt;do_collection_pause_at_safepoint(_target_pause_time_ms)) {
      _gc_succeeded = true;
    } else {
      // Failure to perform the collection at all occurs because GCLocker is
      // active, and we have the bad luck to be the collection request that
</pre>
<center><a href="g1Policy.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1VMOperations.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
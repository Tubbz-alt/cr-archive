<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
    2 // Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // AMD64 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
   64 // used as byte registers)
   65 
   66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
   67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
   69 
   70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
   71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
   72 
   73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
   74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
   75 
   76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
   77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
   78 
   79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
   80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
   81 
   82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
   83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
   84 
   85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
   86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
   87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
   88 
   89 #ifdef _WIN64
   90 
   91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
   92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
   93 
   94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
   95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
   96 
   97 #else
   98 
   99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
  100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  101 
  102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
  103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  104 
  105 #endif
  106 
  107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
  108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
  109 
  110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
  111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
  112 
  113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
  114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
  115 
  116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
  117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
  118 
  119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
  120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
  121 
  122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
  123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
  124 
  125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
  126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
  127 
  128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
  129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
  130 
  131 
  132 // Floating Point Registers
  133 
  134 // Specify priority of register selection within phases of register
  135 // allocation.  Highest priority is first.  A useful heuristic is to
  136 // give registers a low priority when they are required by machine
  137 // instructions, like EAX and EDX on I486, and choose no-save registers
  138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
  139 // which participate in fixed calling sequences should come last.
  140 // Registers which are used as pairs must fall on an even boundary.
  141 
  142 alloc_class chunk0(R10,         R10_H,
  143                    R11,         R11_H,
  144                    R8,          R8_H,
  145                    R9,          R9_H,
  146                    R12,         R12_H,
  147                    RCX,         RCX_H,
  148                    RBX,         RBX_H,
  149                    RDI,         RDI_H,
  150                    RDX,         RDX_H,
  151                    RSI,         RSI_H,
  152                    RAX,         RAX_H,
  153                    RBP,         RBP_H,
  154                    R13,         R13_H,
  155                    R14,         R14_H,
  156                    R15,         R15_H,
  157                    RSP,         RSP_H);
  158 
  159 
  160 //----------Architecture Description Register Classes--------------------------
  161 // Several register classes are automatically defined based upon information in
  162 // this architecture description.
  163 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  164 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  165 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  166 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  167 //
  168 
  169 // Empty register class.
  170 reg_class no_reg();
  171 
  172 // Class for all pointer/long registers
  173 reg_class all_reg(RAX, RAX_H,
  174                   RDX, RDX_H,
  175                   RBP, RBP_H,
  176                   RDI, RDI_H,
  177                   RSI, RSI_H,
  178                   RCX, RCX_H,
  179                   RBX, RBX_H,
  180                   RSP, RSP_H,
  181                   R8,  R8_H,
  182                   R9,  R9_H,
  183                   R10, R10_H,
  184                   R11, R11_H,
  185                   R12, R12_H,
  186                   R13, R13_H,
  187                   R14, R14_H,
  188                   R15, R15_H);
  189 
  190 // Class for all int registers
  191 reg_class all_int_reg(RAX
  192                       RDX,
  193                       RBP,
  194                       RDI,
  195                       RSI,
  196                       RCX,
  197                       RBX,
  198                       R8,
  199                       R9,
  200                       R10,
  201                       R11,
  202                       R12,
  203                       R13,
  204                       R14);
  205 
  206 // Class for all pointer registers
  207 reg_class any_reg %{
  208   return _ANY_REG_mask;
  209 %}
  210 
  211 // Class for all pointer registers (excluding RSP)
  212 reg_class ptr_reg %{
  213   return _PTR_REG_mask;
  214 %}
  215 
  216 // Class for all pointer registers (excluding RSP and RBP)
  217 reg_class ptr_reg_no_rbp %{
  218   return _PTR_REG_NO_RBP_mask;
  219 %}
  220 
  221 // Class for all pointer registers (excluding RAX and RSP)
  222 reg_class ptr_no_rax_reg %{
  223   return _PTR_NO_RAX_REG_mask;
  224 %}
  225 
  226 // Class for all pointer registers (excluding RAX, RBX, and RSP)
  227 reg_class ptr_no_rax_rbx_reg %{
  228   return _PTR_NO_RAX_RBX_REG_mask;
  229 %}
  230 
  231 // Class for all long registers (excluding RSP)
  232 reg_class long_reg %{
  233   return _LONG_REG_mask;
  234 %}
  235 
  236 // Class for all long registers (excluding RAX, RDX and RSP)
  237 reg_class long_no_rax_rdx_reg %{
  238   return _LONG_NO_RAX_RDX_REG_mask;
  239 %}
  240 
  241 // Class for all long registers (excluding RCX and RSP)
  242 reg_class long_no_rcx_reg %{
  243   return _LONG_NO_RCX_REG_mask;
  244 %}
  245 
  246 // Class for all int registers (excluding RSP)
  247 reg_class int_reg %{
  248   return _INT_REG_mask;
  249 %}
  250 
  251 // Class for all int registers (excluding RAX, RDX, and RSP)
  252 reg_class int_no_rax_rdx_reg %{
  253   return _INT_NO_RAX_RDX_REG_mask;
  254 %}
  255 
  256 // Class for all int registers (excluding RCX and RSP)
  257 reg_class int_no_rcx_reg %{
  258   return _INT_NO_RCX_REG_mask;
  259 %}
  260 
  261 // Singleton class for RAX pointer register
  262 reg_class ptr_rax_reg(RAX, RAX_H);
  263 
  264 // Singleton class for RBX pointer register
  265 reg_class ptr_rbx_reg(RBX, RBX_H);
  266 
  267 // Singleton class for RSI pointer register
  268 reg_class ptr_rsi_reg(RSI, RSI_H);
  269 
  270 // Singleton class for RBP pointer register
  271 reg_class ptr_rbp_reg(RBP, RBP_H);
  272 
  273 // Singleton class for RDI pointer register
  274 reg_class ptr_rdi_reg(RDI, RDI_H);
  275 
  276 // Singleton class for stack pointer
  277 reg_class ptr_rsp_reg(RSP, RSP_H);
  278 
  279 // Singleton class for TLS pointer
  280 reg_class ptr_r15_reg(R15, R15_H);
  281 
  282 // Singleton class for RAX long register
  283 reg_class long_rax_reg(RAX, RAX_H);
  284 
  285 // Singleton class for RCX long register
  286 reg_class long_rcx_reg(RCX, RCX_H);
  287 
  288 // Singleton class for RDX long register
  289 reg_class long_rdx_reg(RDX, RDX_H);
  290 
  291 // Singleton class for RAX int register
  292 reg_class int_rax_reg(RAX);
  293 
  294 // Singleton class for RBX int register
  295 reg_class int_rbx_reg(RBX);
  296 
  297 // Singleton class for RCX int register
  298 reg_class int_rcx_reg(RCX);
  299 
  300 // Singleton class for RCX int register
  301 reg_class int_rdx_reg(RDX);
  302 
  303 // Singleton class for RCX int register
  304 reg_class int_rdi_reg(RDI);
  305 
  306 // Singleton class for instruction pointer
  307 // reg_class ip_reg(RIP);
  308 
  309 %}
  310 
  311 //----------SOURCE BLOCK-------------------------------------------------------
  312 // This is a block of C++ code which provides values, functions, and
  313 // definitions necessary in the rest of the architecture description
  314 source_hpp %{
  315 
  316 extern RegMask _ANY_REG_mask;
  317 extern RegMask _PTR_REG_mask;
  318 extern RegMask _PTR_REG_NO_RBP_mask;
  319 extern RegMask _PTR_NO_RAX_REG_mask;
  320 extern RegMask _PTR_NO_RAX_RBX_REG_mask;
  321 extern RegMask _LONG_REG_mask;
  322 extern RegMask _LONG_NO_RAX_RDX_REG_mask;
  323 extern RegMask _LONG_NO_RCX_REG_mask;
  324 extern RegMask _INT_REG_mask;
  325 extern RegMask _INT_NO_RAX_RDX_REG_mask;
  326 extern RegMask _INT_NO_RCX_REG_mask;
  327 
  328 extern RegMask _STACK_OR_PTR_REG_mask;
  329 extern RegMask _STACK_OR_LONG_REG_mask;
  330 extern RegMask _STACK_OR_INT_REG_mask;
  331 
  332 inline const RegMask&amp; STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }
  333 inline const RegMask&amp; STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }
  334 inline const RegMask&amp; STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }
  335 
  336 %}
  337 
  338 source %{
  339 #define   RELOC_IMM64    Assembler::imm_operand
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
  360   return UseCompressedOops || UseCompressedClassPointers;
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
  381   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()-&gt;next()));
  382 
  383   _STACK_OR_PTR_REG_mask = _PTR_REG_mask;
  384   _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  385 
  386   _PTR_REG_NO_RBP_mask = _PTR_REG_mask;
  387   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  388   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  389 
  390   _PTR_NO_RAX_REG_mask = _PTR_REG_mask;
  391   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  392   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  393 
  394   _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;
  395   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()));
  396   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()-&gt;next()));
  397 
  398   _LONG_REG_mask = _PTR_REG_mask;
  399   _STACK_OR_LONG_REG_mask = _LONG_REG_mask;
  400   _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  401 
  402   _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;
  403   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  404   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  405   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  406   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()-&gt;next()));
  407 
  408   _LONG_NO_RCX_REG_mask = _LONG_REG_mask;
  409   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  410   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()-&gt;next()));
  411 
  412   _INT_REG_mask = _ALL_INT_REG_mask;
  413   if (PreserveFramePointer) {
  414     _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  415   }
  416   if (need_r12_heapbase()) {
  417     _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  418   }
  419 
  420   _STACK_OR_INT_REG_mask = _INT_REG_mask;
  421   _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  422 
  423   _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;
  424   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  425   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  426 
  427   _INT_NO_RCX_REG_mask = _INT_REG_mask;
  428   _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  429 }
  430 
  431 static bool generate_vzeroupper(Compile* C) {
  432   return (VM_Version::supports_vzeroupper() &amp;&amp; (C-&gt;max_vector_size() &gt; 16 || C-&gt;clear_upper_avx() == true)) ? true: false;  // Generate vzeroupper
  433 }
  434 
  435 static int clear_avx_size() {
  436   return generate_vzeroupper(Compile::current()) ? 3: 0;  // vzeroupper
  437 }
  438 
  439 // !!!!! Special hack to get all types of calls to specify the byte offset
  440 //       from the start of the call to the point where the return address
  441 //       will point.
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
  462 // Indicate if the safepoint node needs the polling page as an input,
  463 // it does if the polling page is more than disp32 away.
  464 bool SafePointNode::needs_polling_address_input()
  465 {
  466   return SafepointMechanism::uses_thread_local_poll() || Assembler::is_polling_page_far();
  467 }
  468 
  469 //
  470 // Compute padding required for nodes which need alignment
  471 //
  472 
  473 // The address of the call instruction needs to be 4-byte aligned to
  474 // ensure that it does not span a cache line so that it can be patched.
  475 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  476 {
  477   current_offset += clear_avx_size(); // skip vzeroupper
  478   current_offset += 1; // skip call opcode byte
  479   return align_up(current_offset, alignment_required()) - current_offset;
  480 }
  481 
  482 // The address of the call instruction needs to be 4-byte aligned to
  483 // ensure that it does not span a cache line so that it can be patched.
  484 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  485 {
  486   current_offset += clear_avx_size(); // skip vzeroupper
  487   current_offset += 11; // skip movq instruction + call opcode byte
  488   return align_up(current_offset, alignment_required()) - current_offset;
  489 }
  490 
  491 // EMIT_RM()
  492 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  493   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  494   cbuf.insts()-&gt;emit_int8(c);
  495 }
  496 
  497 // EMIT_CC()
  498 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  499   unsigned char c = (unsigned char) (f1 | f2);
  500   cbuf.insts()-&gt;emit_int8(c);
  501 }
  502 
  503 // EMIT_OPCODE()
  504 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  505   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  506 }
  507 
  508 // EMIT_OPCODE() w/ relocation information
  509 void emit_opcode(CodeBuffer &amp;cbuf,
  510                  int code, relocInfo::relocType reloc, int offset, int format)
  511 {
  512   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
  513   emit_opcode(cbuf, code);
  514 }
  515 
  516 // EMIT_D8()
  517 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  518   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  519 }
  520 
  521 // EMIT_D16()
  522 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  523   cbuf.insts()-&gt;emit_int16(d16);
  524 }
  525 
  526 // EMIT_D32()
  527 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  528   cbuf.insts()-&gt;emit_int32(d32);
  529 }
  530 
  531 // EMIT_D64()
  532 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
  533   cbuf.insts()-&gt;emit_int64(d64);
  534 }
  535 
  536 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  537 void emit_d32_reloc(CodeBuffer&amp; cbuf,
  538                     int d32,
  539                     relocInfo::relocType reloc,
  540                     int format)
  541 {
  542   assert(reloc != relocInfo::external_word_type, &quot;use 2-arg emit_d32_reloc&quot;);
  543   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  544   cbuf.insts()-&gt;emit_int32(d32);
  545 }
  546 
  547 // emit 32 bit value and construct relocation entry from RelocationHolder
  548 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  549 #ifdef ASSERT
  550   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  551       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
  552     assert(Universe::heap()-&gt;is_in((address)(intptr_t)d32), &quot;should be real oop&quot;);
  553     assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
  554   }
  555 #endif
  556   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  557   cbuf.insts()-&gt;emit_int32(d32);
  558 }
  559 
  560 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
  561   address next_ip = cbuf.insts_end() + 4;
  562   emit_d32_reloc(cbuf, (int) (addr - next_ip),
  563                  external_word_Relocation::spec(addr),
  564                  RELOC_DISP32);
  565 }
  566 
  567 
  568 // emit 64 bit value and construct relocation entry from relocInfo::relocType
  569 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  570   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  571   cbuf.insts()-&gt;emit_int64(d64);
  572 }
  573 
  574 // emit 64 bit value and construct relocation entry from RelocationHolder
  575 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  576 #ifdef ASSERT
  577   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  578       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
  579     assert(Universe::heap()-&gt;is_in((address)d64), &quot;should be real oop&quot;);
  580     assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
  581   }
  582 #endif
  583   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  584   cbuf.insts()-&gt;emit_int64(d64);
  585 }
  586 
  587 // Access stack slot for load or store
  588 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
  589 {
  590   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  591   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
  592     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
  593     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  594     emit_d8(cbuf, disp);     // Displacement  // R/M byte
  595   } else {
  596     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
  597     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  598     emit_d32(cbuf, disp);     // Displacement // R/M byte
  599   }
  600 }
  601 
  602    // rRegI ereg, memory mem) %{    // emit_reg_mem
  603 void encode_RegMem(CodeBuffer &amp;cbuf,
  604                    int reg,
  605                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
  606 {
  607   assert(disp_reloc == relocInfo::none, &quot;cannot have disp&quot;);
  608   int regenc = reg &amp; 7;
  609   int baseenc = base &amp; 7;
  610   int indexenc = index &amp; 7;
  611 
  612   // There is no index &amp; no scale, use form without SIB byte
  613   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
  614     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  615     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  616       emit_rm(cbuf, 0x0, regenc, baseenc); // *
  617     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  618       // If 8-bit displacement, mode 0x1
  619       emit_rm(cbuf, 0x1, regenc, baseenc); // *
  620       emit_d8(cbuf, disp);
  621     } else {
  622       // If 32-bit displacement
  623       if (base == -1) { // Special flag for absolute address
  624         emit_rm(cbuf, 0x0, regenc, 0x5); // *
  625         if (disp_reloc != relocInfo::none) {
  626           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  627         } else {
  628           emit_d32(cbuf, disp);
  629         }
  630       } else {
  631         // Normal base + offset
  632         emit_rm(cbuf, 0x2, regenc, baseenc); // *
  633         if (disp_reloc != relocInfo::none) {
  634           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  635         } else {
  636           emit_d32(cbuf, disp);
  637         }
  638       }
  639     }
  640   } else {
  641     // Else, encode with the SIB byte
  642     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  643     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  644       // If no displacement
  645       emit_rm(cbuf, 0x0, regenc, 0x4); // *
  646       emit_rm(cbuf, scale, indexenc, baseenc);
  647     } else {
  648       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  649         // If 8-bit displacement, mode 0x1
  650         emit_rm(cbuf, 0x1, regenc, 0x4); // *
  651         emit_rm(cbuf, scale, indexenc, baseenc);
  652         emit_d8(cbuf, disp);
  653       } else {
  654         // If 32-bit displacement
  655         if (base == 0x04 ) {
  656           emit_rm(cbuf, 0x2, regenc, 0x4);
  657           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
  658         } else {
  659           emit_rm(cbuf, 0x2, regenc, 0x4);
  660           emit_rm(cbuf, scale, indexenc, baseenc); // *
  661         }
  662         if (disp_reloc != relocInfo::none) {
  663           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  664         } else {
  665           emit_d32(cbuf, disp);
  666         }
  667       }
  668     }
  669   }
  670 }
  671 
  672 // This could be in MacroAssembler but it&#39;s fairly C2 specific
  673 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  674   Label exit;
  675   __ jccb(Assembler::noParity, exit);
  676   __ pushf();
  677   //
  678   // comiss/ucomiss instructions set ZF,PF,CF flags and
  679   // zero OF,AF,SF for NaN values.
  680   // Fixup flags by zeroing ZF,PF so that compare of NaN
  681   // values returns &#39;less than&#39; result (CF is set).
  682   // Leave the rest of flags unchanged.
  683   //
  684   //    7 6 5 4 3 2 1 0
  685   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  686   //    0 0 1 0 1 0 1 1   (0x2B)
  687   //
  688   __ andq(Address(rsp, 0), 0xffffff2b);
  689   __ popf();
  690   __ bind(exit);
  691 }
  692 
  693 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  694   Label done;
  695   __ movl(dst, -1);
  696   __ jcc(Assembler::parity, done);
  697   __ jcc(Assembler::below, done);
  698   __ setb(Assembler::notEqual, dst);
  699   __ movzbl(dst, dst);
  700   __ bind(done);
  701 }
  702 
  703 // Math.min()    # Math.max()
  704 // --------------------------
  705 // ucomis[s/d]   #
  706 // ja   -&gt; b     # a
  707 // jp   -&gt; NaN   # NaN
  708 // jb   -&gt; a     # b
  709 // je            #
  710 // |-jz -&gt; a | b # a &amp; b
  711 // |    -&gt; a     #
  712 void emit_fp_min_max(MacroAssembler&amp; _masm, XMMRegister dst,
  713                      XMMRegister a, XMMRegister b,
  714                      XMMRegister xmmt, Register rt,
  715                      bool min, bool single) {
  716 
  717   Label nan, zero, below, above, done;
  718 
  719   if (single)
  720     __ ucomiss(a, b);
  721   else
  722     __ ucomisd(a, b);
  723 
  724   if (dst-&gt;encoding() != (min ? b : a)-&gt;encoding())
  725     __ jccb(Assembler::above, above); // CF=0 &amp; ZF=0
  726   else
  727     __ jccb(Assembler::above, done);
  728 
  729   __ jccb(Assembler::parity, nan);  // PF=1
  730   __ jccb(Assembler::below, below); // CF=1
  731 
  732   // equal
  733   __ vpxor(xmmt, xmmt, xmmt, Assembler::AVX_128bit);
  734   if (single) {
  735     __ ucomiss(a, xmmt);
  736     __ jccb(Assembler::equal, zero);
  737 
  738     __ movflt(dst, a);
  739     __ jmp(done);
  740   }
  741   else {
  742     __ ucomisd(a, xmmt);
  743     __ jccb(Assembler::equal, zero);
  744 
  745     __ movdbl(dst, a);
  746     __ jmp(done);
  747   }
  748 
  749   __ bind(zero);
  750   if (min)
  751     __ vpor(dst, a, b, Assembler::AVX_128bit);
  752   else
  753     __ vpand(dst, a, b, Assembler::AVX_128bit);
  754 
  755   __ jmp(done);
  756 
  757   __ bind(above);
  758   if (single)
  759     __ movflt(dst, min ? b : a);
  760   else
  761     __ movdbl(dst, min ? b : a);
  762 
  763   __ jmp(done);
  764 
  765   __ bind(nan);
  766   if (single) {
  767     __ movl(rt, 0x7fc00000); // Float.NaN
  768     __ movdl(dst, rt);
  769   }
  770   else {
  771     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  772     __ movdq(dst, rt);
  773   }
  774   __ jmp(done);
  775 
  776   __ bind(below);
  777   if (single)
  778     __ movflt(dst, min ? a : b);
  779   else
  780     __ movdbl(dst, min ? a : b);
  781 
  782   __ bind(done);
  783 }
  784 
  785 //=============================================================================
  786 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  787 
  788 int Compile::ConstantTable::calculate_table_base_offset() const {
  789   return 0;  // absolute addressing, no offset
  790 }
  791 
  792 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  793 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  794   ShouldNotReachHere();
  795 }
  796 
  797 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  798   // Empty encoding
  799 }
  800 
  801 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  802   return 0;
  803 }
  804 
  805 #ifndef PRODUCT
  806 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  807   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  808 }
  809 #endif
  810 
  811 
  812 //=============================================================================
  813 #ifndef PRODUCT
  814 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  815   Compile* C = ra_-&gt;C;
  816 
  817   int framesize = C-&gt;frame_size_in_bytes();
  818   int bangsize = C-&gt;bang_size_in_bytes();
  819   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  820   // Remove wordSize for return addr which is already pushed.
  821   framesize -= wordSize;
  822 
  823   if (C-&gt;need_stack_bang(bangsize)) {
  824     framesize -= wordSize;
  825     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  826     st-&gt;print(&quot;\n\t&quot;);
  827     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  828     if (PreserveFramePointer) {
  829         st-&gt;print(&quot;\n\t&quot;);
  830         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  831     }
  832     if (framesize) {
  833       st-&gt;print(&quot;\n\t&quot;);
  834       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  835     }
  836   } else {
  837     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  838     st-&gt;print(&quot;\n\t&quot;);
  839     framesize -= wordSize;
  840     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  841     if (PreserveFramePointer) {
  842       st-&gt;print(&quot;\n\t&quot;);
  843       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  844       if (framesize &gt; 0) {
  845         st-&gt;print(&quot;\n\t&quot;);
  846         st-&gt;print(&quot;addq    rbp, #%d&quot;, framesize);
  847       }
  848     }
  849   }
  850 
  851   if (VerifyStackAtCalls) {
  852     st-&gt;print(&quot;\n\t&quot;);
  853     framesize -= wordSize;
  854     st-&gt;print(&quot;movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check&quot;,framesize);
  855 #ifdef ASSERT
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;# stack alignment check&quot;);
  858 #endif
  859   }
  860   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  861     st-&gt;print(&quot;\n\t&quot;);
  862     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  863     st-&gt;print(&quot;\n\t&quot;);
  864     st-&gt;print(&quot;je      fast_entry\t&quot;);
  865     st-&gt;print(&quot;\n\t&quot;);
  866     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  867     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  868   }
  869   st-&gt;cr();
  870 }
  871 #endif
  872 
  873 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  874   Compile* C = ra_-&gt;C;
  875   MacroAssembler _masm(&amp;cbuf);
  876 
  877   int framesize = C-&gt;frame_size_in_bytes();
  878   int bangsize = C-&gt;bang_size_in_bytes();
  879 
  880   if (C-&gt;clinit_barrier_on_entry()) {
  881     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  882     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  883 
  884     Label L_skip_barrier;
  885     Register klass = rscratch1;
  886 
  887     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  888     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  889 
  890     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  891 
  892     __ bind(L_skip_barrier);
  893   }
  894 
  895   __ verified_entry(framesize, C-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);
  896 
  897   C-&gt;set_frame_complete(cbuf.insts_size());
  898 
  899   if (C-&gt;has_mach_constant_base_node()) {
  900     // NOTE: We set the table base offset here because users might be
  901     // emitted before MachConstantBaseNode.
  902     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
  903     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  904   }
  905 }
  906 
  907 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
  908 {
  909   return MachNode::size(ra_); // too many variables; just compute it
  910                               // the hard way
  911 }
  912 
  913 int MachPrologNode::reloc() const
  914 {
  915   return 0; // a large enough number
  916 }
  917 
  918 //=============================================================================
  919 #ifndef PRODUCT
  920 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  921 {
  922   Compile* C = ra_-&gt;C;
  923   if (generate_vzeroupper(C)) {
  924     st-&gt;print(&quot;vzeroupper&quot;);
  925     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  926   }
  927 
  928   int framesize = C-&gt;frame_size_in_bytes();
  929   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  930   // Remove word for return adr already pushed
  931   // and RBP
  932   framesize -= 2*wordSize;
  933 
  934   if (framesize) {
  935     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  936     st-&gt;print(&quot;\t&quot;);
  937   }
  938 
  939   st-&gt;print_cr(&quot;popq    rbp&quot;);
  940   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  941     st-&gt;print(&quot;\t&quot;);
  942     if (SafepointMechanism::uses_thread_local_poll()) {
  943       st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  944                    &quot;testl   rax, [rscratch1]\t&quot;
  945                    &quot;# Safepoint: poll for GC&quot;);
  946     } else if (Assembler::is_polling_page_far()) {
  947       st-&gt;print_cr(&quot;movq    rscratch1, #polling_page_address\n\t&quot;
  948                    &quot;testl   rax, [rscratch1]\t&quot;
  949                    &quot;# Safepoint: poll for GC&quot;);
  950     } else {
  951       st-&gt;print_cr(&quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;
  952                    &quot;# Safepoint: poll for GC&quot;);
  953     }
  954   }
  955 }
  956 #endif
  957 
  958 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  959 {
  960   Compile* C = ra_-&gt;C;
  961   MacroAssembler _masm(&amp;cbuf);
  962 
  963   if (generate_vzeroupper(C)) {
  964     // Clear upper bits of YMM registers when current compiled code uses
  965     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  966     __ vzeroupper();
  967   }
  968 
  969   int framesize = C-&gt;frame_size_in_bytes();
  970   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  971   // Remove word for return adr already pushed
  972   // and RBP
  973   framesize -= 2*wordSize;
  974 
  975   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  976 
  977   if (framesize) {
  978     emit_opcode(cbuf, Assembler::REX_W);
  979     if (framesize &lt; 0x80) {
  980       emit_opcode(cbuf, 0x83); // addq rsp, #framesize
  981       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  982       emit_d8(cbuf, framesize);
  983     } else {
  984       emit_opcode(cbuf, 0x81); // addq rsp, #framesize
  985       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  986       emit_d32(cbuf, framesize);
  987     }
  988   }
  989 
  990   // popq rbp
  991   emit_opcode(cbuf, 0x58 | RBP_enc);
  992 
  993   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  994     __ reserved_stack_check();
  995   }
  996 
  997   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  998     MacroAssembler _masm(&amp;cbuf);
  999     if (SafepointMechanism::uses_thread_local_poll()) {
 1000       __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
 1001       __ relocate(relocInfo::poll_return_type);
 1002       __ testl(rax, Address(rscratch1, 0));
 1003     } else {
 1004       AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
 1005       if (Assembler::is_polling_page_far()) {
 1006         __ lea(rscratch1, polling_page);
 1007         __ relocate(relocInfo::poll_return_type);
 1008         __ testl(rax, Address(rscratch1, 0));
 1009       } else {
 1010         __ testl(rax, polling_page);
 1011       }
 1012     }
 1013   }
 1014 }
 1015 
 1016 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
 1017 {
 1018   return MachNode::size(ra_); // too many variables; just compute it
 1019                               // the hard way
 1020 }
 1021 
 1022 int MachEpilogNode::reloc() const
 1023 {
 1024   return 2; // a large enough number
 1025 }
 1026 
 1027 const Pipeline* MachEpilogNode::pipeline() const
 1028 {
 1029   return MachNode::pipeline_class();
 1030 }
 1031 
 1032 int MachEpilogNode::safepoint_offset() const
 1033 {
 1034   return 0;
 1035 }
 1036 
 1037 //=============================================================================
 1038 
 1039 enum RC {
 1040   rc_bad,
 1041   rc_int,
 1042   rc_float,
 1043   rc_stack
 1044 };
 1045 
 1046 static enum RC rc_class(OptoReg::Name reg)
 1047 {
 1048   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 1049 
 1050   if (OptoReg::is_stack(reg)) return rc_stack;
 1051 
 1052   VMReg r = OptoReg::as_VMReg(reg);
 1053 
 1054   if (r-&gt;is_Register()) return rc_int;
 1055 
 1056   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
 1057   return rc_float;
 1058 }
 1059 
 1060 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 1061 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 1062                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 1063 
 1064 int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
 1065                      int stack_offset, int reg, uint ireg, outputStream* st);
 1066 
 1067 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 1068                                       int dst_offset, uint ireg, outputStream* st) {
 1069   if (cbuf) {
 1070     MacroAssembler _masm(cbuf);
 1071     switch (ireg) {
 1072     case Op_VecS:
 1073       __ movq(Address(rsp, -8), rax);
 1074       __ movl(rax, Address(rsp, src_offset));
 1075       __ movl(Address(rsp, dst_offset), rax);
 1076       __ movq(rax, Address(rsp, -8));
 1077       break;
 1078     case Op_VecD:
 1079       __ pushq(Address(rsp, src_offset));
 1080       __ popq (Address(rsp, dst_offset));
 1081       break;
 1082     case Op_VecX:
 1083       __ pushq(Address(rsp, src_offset));
 1084       __ popq (Address(rsp, dst_offset));
 1085       __ pushq(Address(rsp, src_offset+8));
 1086       __ popq (Address(rsp, dst_offset+8));
 1087       break;
 1088     case Op_VecY:
 1089       __ vmovdqu(Address(rsp, -32), xmm0);
 1090       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1091       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1092       __ vmovdqu(xmm0, Address(rsp, -32));
 1093       break;
 1094     case Op_VecZ:
 1095       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1096       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1097       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1098       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1099       break;
 1100     default:
 1101       ShouldNotReachHere();
 1102     }
 1103 #ifndef PRODUCT
 1104   } else {
 1105     switch (ireg) {
 1106     case Op_VecS:
 1107       st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1108                 &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1109                 &quot;movl    [rsp + #%d], rax\n\t&quot;
 1110                 &quot;movq    rax, [rsp - #8]&quot;,
 1111                 src_offset, dst_offset);
 1112       break;
 1113     case Op_VecD:
 1114       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1115                 &quot;popq    [rsp + #%d]&quot;,
 1116                 src_offset, dst_offset);
 1117       break;
 1118      case Op_VecX:
 1119       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t&quot;
 1120                 &quot;popq    [rsp + #%d]\n\t&quot;
 1121                 &quot;pushq   [rsp + #%d]\n\t&quot;
 1122                 &quot;popq    [rsp + #%d]&quot;,
 1123                 src_offset, dst_offset, src_offset+8, dst_offset+8);
 1124       break;
 1125     case Op_VecY:
 1126       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1127                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1128                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1129                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1130                 src_offset, dst_offset);
 1131       break;
 1132     case Op_VecZ:
 1133       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1134                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1135                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1136                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1137                 src_offset, dst_offset);
 1138       break;
 1139     default:
 1140       ShouldNotReachHere();
 1141     }
 1142 #endif
 1143   }
 1144 }
 1145 
 1146 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
 1147                                        PhaseRegAlloc* ra_,
 1148                                        bool do_size,
 1149                                        outputStream* st) const {
 1150   assert(cbuf != NULL || st  != NULL, &quot;sanity&quot;);
 1151   // Get registers to move
 1152   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1153   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1154   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
 1155   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
 1156 
 1157   enum RC src_second_rc = rc_class(src_second);
 1158   enum RC src_first_rc = rc_class(src_first);
 1159   enum RC dst_second_rc = rc_class(dst_second);
 1160   enum RC dst_first_rc = rc_class(dst_first);
 1161 
 1162   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
 1163          &quot;must move at least 1 register&quot; );
 1164 
 1165   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1166     // Self copy, no move
 1167     return 0;
 1168   }
 1169   if (bottom_type()-&gt;isa_vect() != NULL) {
 1170     uint ireg = ideal_reg();
 1171     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1172     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1173     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1174       // mem -&gt; mem
 1175       int src_offset = ra_-&gt;reg2offset(src_first);
 1176       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1177       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
 1178     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1179       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
 1180     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1181       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1182       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
 1183     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
 1184       int stack_offset = ra_-&gt;reg2offset(src_first);
 1185       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
 1186     } else {
 1187       ShouldNotReachHere();
 1188     }
 1189     return 0;
 1190   }
 1191   if (src_first_rc == rc_stack) {
 1192     // mem -&gt;
 1193     if (dst_first_rc == rc_stack) {
 1194       // mem -&gt; mem
 1195       assert(src_second != dst_first, &quot;overlap&quot;);
 1196       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1197           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1198         // 64-bit
 1199         int src_offset = ra_-&gt;reg2offset(src_first);
 1200         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1201         if (cbuf) {
 1202           MacroAssembler _masm(cbuf);
 1203           __ pushq(Address(rsp, src_offset));
 1204           __ popq (Address(rsp, dst_offset));
 1205 #ifndef PRODUCT
 1206         } else {
 1207           st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1208                     &quot;popq    [rsp + #%d]&quot;,
 1209                      src_offset, dst_offset);
 1210 #endif
 1211         }
 1212       } else {
 1213         // 32-bit
 1214         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1215         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1216         // No pushl/popl, so:
 1217         int src_offset = ra_-&gt;reg2offset(src_first);
 1218         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1219         if (cbuf) {
 1220           MacroAssembler _masm(cbuf);
 1221           __ movq(Address(rsp, -8), rax);
 1222           __ movl(rax, Address(rsp, src_offset));
 1223           __ movl(Address(rsp, dst_offset), rax);
 1224           __ movq(rax, Address(rsp, -8));
 1225 #ifndef PRODUCT
 1226         } else {
 1227           st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1228                     &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1229                     &quot;movl    [rsp + #%d], rax\n\t&quot;
 1230                     &quot;movq    rax, [rsp - #8]&quot;,
 1231                      src_offset, dst_offset);
 1232 #endif
 1233         }
 1234       }
 1235       return 0;
 1236     } else if (dst_first_rc == rc_int) {
 1237       // mem -&gt; gpr
 1238       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1239           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1240         // 64-bit
 1241         int offset = ra_-&gt;reg2offset(src_first);
 1242         if (cbuf) {
 1243           MacroAssembler _masm(cbuf);
 1244           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1245 #ifndef PRODUCT
 1246         } else {
 1247           st-&gt;print(&quot;movq    %s, [rsp + #%d]\t# spill&quot;,
 1248                      Matcher::regName[dst_first],
 1249                      offset);
 1250 #endif
 1251         }
 1252       } else {
 1253         // 32-bit
 1254         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1255         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1256         int offset = ra_-&gt;reg2offset(src_first);
 1257         if (cbuf) {
 1258           MacroAssembler _masm(cbuf);
 1259           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1260 #ifndef PRODUCT
 1261         } else {
 1262           st-&gt;print(&quot;movl    %s, [rsp + #%d]\t# spill&quot;,
 1263                      Matcher::regName[dst_first],
 1264                      offset);
 1265 #endif
 1266         }
 1267       }
 1268       return 0;
 1269     } else if (dst_first_rc == rc_float) {
 1270       // mem-&gt; xmm
 1271       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1272           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1273         // 64-bit
 1274         int offset = ra_-&gt;reg2offset(src_first);
 1275         if (cbuf) {
 1276           MacroAssembler _masm(cbuf);
 1277           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1278 #ifndef PRODUCT
 1279         } else {
 1280           st-&gt;print(&quot;%s  %s, [rsp + #%d]\t# spill&quot;,
 1281                      UseXmmLoadAndClearUpper ? &quot;movsd &quot; : &quot;movlpd&quot;,
 1282                      Matcher::regName[dst_first],
 1283                      offset);
 1284 #endif
 1285         }
 1286       } else {
 1287         // 32-bit
 1288         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1289         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1290         int offset = ra_-&gt;reg2offset(src_first);
 1291         if (cbuf) {
 1292           MacroAssembler _masm(cbuf);
 1293           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1294 #ifndef PRODUCT
 1295         } else {
 1296           st-&gt;print(&quot;movss   %s, [rsp + #%d]\t# spill&quot;,
 1297                      Matcher::regName[dst_first],
 1298                      offset);
 1299 #endif
 1300         }
 1301       }
 1302       return 0;
 1303     }
 1304   } else if (src_first_rc == rc_int) {
 1305     // gpr -&gt;
 1306     if (dst_first_rc == rc_stack) {
 1307       // gpr -&gt; mem
 1308       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1309           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1310         // 64-bit
 1311         int offset = ra_-&gt;reg2offset(dst_first);
 1312         if (cbuf) {
 1313           MacroAssembler _masm(cbuf);
 1314           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1315 #ifndef PRODUCT
 1316         } else {
 1317           st-&gt;print(&quot;movq    [rsp + #%d], %s\t# spill&quot;,
 1318                      offset,
 1319                      Matcher::regName[src_first]);
 1320 #endif
 1321         }
 1322       } else {
 1323         // 32-bit
 1324         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1325         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1326         int offset = ra_-&gt;reg2offset(dst_first);
 1327         if (cbuf) {
 1328           MacroAssembler _masm(cbuf);
 1329           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1330 #ifndef PRODUCT
 1331         } else {
 1332           st-&gt;print(&quot;movl    [rsp + #%d], %s\t# spill&quot;,
 1333                      offset,
 1334                      Matcher::regName[src_first]);
 1335 #endif
 1336         }
 1337       }
 1338       return 0;
 1339     } else if (dst_first_rc == rc_int) {
 1340       // gpr -&gt; gpr
 1341       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1342           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1343         // 64-bit
 1344         if (cbuf) {
 1345           MacroAssembler _masm(cbuf);
 1346           __ movq(as_Register(Matcher::_regEncode[dst_first]),
 1347                   as_Register(Matcher::_regEncode[src_first]));
 1348 #ifndef PRODUCT
 1349         } else {
 1350           st-&gt;print(&quot;movq    %s, %s\t# spill&quot;,
 1351                      Matcher::regName[dst_first],
 1352                      Matcher::regName[src_first]);
 1353 #endif
 1354         }
 1355         return 0;
 1356       } else {
 1357         // 32-bit
 1358         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1359         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1360         if (cbuf) {
 1361           MacroAssembler _masm(cbuf);
 1362           __ movl(as_Register(Matcher::_regEncode[dst_first]),
 1363                   as_Register(Matcher::_regEncode[src_first]));
 1364 #ifndef PRODUCT
 1365         } else {
 1366           st-&gt;print(&quot;movl    %s, %s\t# spill&quot;,
 1367                      Matcher::regName[dst_first],
 1368                      Matcher::regName[src_first]);
 1369 #endif
 1370         }
 1371         return 0;
 1372       }
 1373     } else if (dst_first_rc == rc_float) {
 1374       // gpr -&gt; xmm
 1375       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1376           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1377         // 64-bit
 1378         if (cbuf) {
 1379           MacroAssembler _masm(cbuf);
 1380           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1381 #ifndef PRODUCT
 1382         } else {
 1383           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1384                      Matcher::regName[dst_first],
 1385                      Matcher::regName[src_first]);
 1386 #endif
 1387         }
 1388       } else {
 1389         // 32-bit
 1390         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1391         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1392         if (cbuf) {
 1393           MacroAssembler _masm(cbuf);
 1394           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1395 #ifndef PRODUCT
 1396         } else {
 1397           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1398                      Matcher::regName[dst_first],
 1399                      Matcher::regName[src_first]);
 1400 #endif
 1401         }
 1402       }
 1403       return 0;
 1404     }
 1405   } else if (src_first_rc == rc_float) {
 1406     // xmm -&gt;
 1407     if (dst_first_rc == rc_stack) {
 1408       // xmm -&gt; mem
 1409       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1410           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1411         // 64-bit
 1412         int offset = ra_-&gt;reg2offset(dst_first);
 1413         if (cbuf) {
 1414           MacroAssembler _masm(cbuf);
 1415           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1416 #ifndef PRODUCT
 1417         } else {
 1418           st-&gt;print(&quot;movsd   [rsp + #%d], %s\t# spill&quot;,
 1419                      offset,
 1420                      Matcher::regName[src_first]);
 1421 #endif
 1422         }
 1423       } else {
 1424         // 32-bit
 1425         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1426         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1427         int offset = ra_-&gt;reg2offset(dst_first);
 1428         if (cbuf) {
 1429           MacroAssembler _masm(cbuf);
 1430           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1431 #ifndef PRODUCT
 1432         } else {
 1433           st-&gt;print(&quot;movss   [rsp + #%d], %s\t# spill&quot;,
 1434                      offset,
 1435                      Matcher::regName[src_first]);
 1436 #endif
 1437         }
 1438       }
 1439       return 0;
 1440     } else if (dst_first_rc == rc_int) {
 1441       // xmm -&gt; gpr
 1442       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1443           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1444         // 64-bit
 1445         if (cbuf) {
 1446           MacroAssembler _masm(cbuf);
 1447           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1448 #ifndef PRODUCT
 1449         } else {
 1450           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1451                      Matcher::regName[dst_first],
 1452                      Matcher::regName[src_first]);
 1453 #endif
 1454         }
 1455       } else {
 1456         // 32-bit
 1457         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1458         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1459         if (cbuf) {
 1460           MacroAssembler _masm(cbuf);
 1461           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1462 #ifndef PRODUCT
 1463         } else {
 1464           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1465                      Matcher::regName[dst_first],
 1466                      Matcher::regName[src_first]);
 1467 #endif
 1468         }
 1469       }
 1470       return 0;
 1471     } else if (dst_first_rc == rc_float) {
 1472       // xmm -&gt; xmm
 1473       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1474           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1475         // 64-bit
 1476         if (cbuf) {
 1477           MacroAssembler _masm(cbuf);
 1478           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1479 #ifndef PRODUCT
 1480         } else {
 1481           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1482                      UseXmmRegToRegMoveAll ? &quot;movapd&quot; : &quot;movsd &quot;,
 1483                      Matcher::regName[dst_first],
 1484                      Matcher::regName[src_first]);
 1485 #endif
 1486         }
 1487       } else {
 1488         // 32-bit
 1489         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1490         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1491         if (cbuf) {
 1492           MacroAssembler _masm(cbuf);
 1493           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1494 #ifndef PRODUCT
 1495         } else {
 1496           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1497                      UseXmmRegToRegMoveAll ? &quot;movaps&quot; : &quot;movss &quot;,
 1498                      Matcher::regName[dst_first],
 1499                      Matcher::regName[src_first]);
 1500 #endif
 1501         }
 1502       }
 1503       return 0;
 1504     }
 1505   }
 1506 
 1507   assert(0,&quot; foo &quot;);
 1508   Unimplemented();
 1509   return 0;
 1510 }
 1511 
 1512 #ifndef PRODUCT
 1513 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1514   implementation(NULL, ra_, false, st);
 1515 }
 1516 #endif
 1517 
 1518 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1519   implementation(&amp;cbuf, ra_, false, NULL);
 1520 }
 1521 
 1522 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1523   return MachNode::size(ra_);
 1524 }
 1525 
 1526 //=============================================================================
 1527 #ifndef PRODUCT
 1528 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1529 {
 1530   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1531   int reg = ra_-&gt;get_reg_first(this);
 1532   st-&gt;print(&quot;leaq    %s, [rsp + #%d]\t# box lock&quot;,
 1533             Matcher::regName[reg], offset);
 1534 }
 1535 #endif
 1536 
 1537 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1538 {
 1539   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1540   int reg = ra_-&gt;get_encode(this);
 1541   if (offset &gt;= 0x80) {
 1542     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1543     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1544     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1545     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1546     emit_d32(cbuf, offset);
 1547   } else {
 1548     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1549     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1550     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1551     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1552     emit_d8(cbuf, offset);
 1553   }
 1554 }
 1555 
 1556 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1557 {
 1558   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1559   return (offset &lt; 0x80) ? 5 : 8; // REX
 1560 }
 1561 
 1562 //=============================================================================
 1563 #ifndef PRODUCT
 1564 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1565 {
 1566   if (UseCompressedClassPointers) {
 1567     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1568     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1569     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1570   } else {
 1571     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1572                  &quot;# Inline cache check&quot;);
 1573   }
 1574   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1575   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1576 }
 1577 #endif
 1578 
 1579 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1580 {
 1581   MacroAssembler masm(&amp;cbuf);
 1582   uint insts_size = cbuf.insts_size();
 1583   if (UseCompressedClassPointers) {
 1584     masm.load_klass(rscratch1, j_rarg0);
 1585     masm.cmpptr(rax, rscratch1);
 1586   } else {
 1587     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1588   }
 1589 
 1590   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1591 
 1592   /* WARNING these NOPs are critical so that verified entry point is properly
 1593      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1594   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1595   if (OptoBreakpoint) {
 1596     // Leave space for int3
 1597     nops_cnt -= 1;
 1598   }
 1599   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1600   if (nops_cnt &gt; 0)
 1601     masm.nop(nops_cnt);
 1602 }
 1603 
 1604 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
 1605 {
 1606   return MachNode::size(ra_); // too many variables; just compute it
 1607                               // the hard way
 1608 }
 1609 
 1610 
 1611 //=============================================================================
 1612 
 1613 int Matcher::regnum_to_fpu_offset(int regnum)
 1614 {
 1615   return regnum - 32; // The FP registers are in the second chunk
 1616 }
 1617 
 1618 // This is UltraSparc specific, true just means we have fast l2f conversion
 1619 const bool Matcher::convL2FSupported(void) {
 1620   return true;
 1621 }
 1622 
 1623 // Is this branch offset short enough that a short branch can be used?
 1624 //
 1625 // NOTE: If the platform does not provide any short branch variants, then
 1626 //       this method should return false for offset 0.
 1627 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1628   // The passed offset is relative to address of the branch.
 1629   // On 86 a branch displacement is calculated relative to address
 1630   // of a next instruction.
 1631   offset -= br_size;
 1632 
 1633   // the short version of jmpConUCF2 contains multiple branches,
 1634   // making the reach slightly less
 1635   if (rule == jmpConUCF2_rule)
 1636     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1637   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1638 }
 1639 
 1640 const bool Matcher::isSimpleConstant64(jlong value) {
 1641   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1642   //return value == (int) value;  // Cf. storeImmL and immL32.
 1643 
 1644   // Probably always true, even if a temp register is required.
 1645   return true;
 1646 }
 1647 
 1648 // The ecx parameter to rep stosq for the ClearArray node is in words.
 1649 const bool Matcher::init_array_count_is_in_bytes = false;
 1650 
 1651 // No additional cost for CMOVL.
 1652 const int Matcher::long_cmove_cost() { return 0; }
 1653 
 1654 // No CMOVF/CMOVD with SSE2
 1655 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1656 
 1657 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1658 const bool Matcher::require_postalloc_expand = false;
 1659 
 1660 // Do we need to mask the count passed to shift instructions or does
 1661 // the cpu only look at the lower 5/6 bits anyway?
 1662 const bool Matcher::need_masked_shift_count = false;
 1663 
 1664 bool Matcher::narrow_oop_use_complex_address() {
 1665   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1666   return (LogMinObjAlignmentInBytes &lt;= 3);
 1667 }
 1668 
 1669 bool Matcher::narrow_klass_use_complex_address() {
 1670   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1671   return (LogKlassAlignmentInBytes &lt;= 3);
 1672 }
 1673 
 1674 bool Matcher::const_oop_prefer_decode() {
 1675   // Prefer ConN+DecodeN over ConP.
 1676   return true;
 1677 }
 1678 
 1679 bool Matcher::const_klass_prefer_decode() {
 1680   // TODO: Either support matching DecodeNKlass (heap-based) in operand
 1681   //       or condisider the following:
 1682   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1683   //return CompressedKlassPointers::base() == NULL;
 1684   return true;
 1685 }
 1686 
 1687 // Is it better to copy float constants, or load them directly from
 1688 // memory?  Intel can load a float constant from a direct address,
 1689 // requiring no extra registers.  Most RISCs will have to materialize
 1690 // an address into a register first, so they would do better to copy
 1691 // the constant from stack.
 1692 const bool Matcher::rematerialize_float_constants = true; // XXX
 1693 
 1694 // If CPU can load and store mis-aligned doubles directly then no
 1695 // fixup is needed.  Else we split the double into 2 integer pieces
 1696 // and move it piece-by-piece.  Only happens when passing doubles into
 1697 // C code as the Java calling convention forces doubles to be aligned.
 1698 const bool Matcher::misaligned_doubles_ok = true;
 1699 
 1700 // No-op on amd64
 1701 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
 1702 
 1703 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1704 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1705 
 1706 // Are floats conerted to double when stored to stack during deoptimization?
 1707 // On x64 it is stored without convertion so we can use normal access.
 1708 bool Matcher::float_in_double() { return false; }
 1709 
 1710 // Do ints take an entire long register or just half?
 1711 const bool Matcher::int_in_long = true;
 1712 
 1713 // Return whether or not this register is ever used as an argument.
 1714 // This function is used on startup to build the trampoline stubs in
 1715 // generateOptoStub.  Registers not mentioned will be killed by the VM
 1716 // call in the trampoline, and arguments in those registers not be
 1717 // available to the callee.
 1718 bool Matcher::can_be_java_arg(int reg)
 1719 {
 1720   return
 1721     reg ==  RDI_num || reg == RDI_H_num ||
 1722     reg ==  RSI_num || reg == RSI_H_num ||
 1723     reg ==  RDX_num || reg == RDX_H_num ||
 1724     reg ==  RCX_num || reg == RCX_H_num ||
 1725     reg ==   R8_num || reg ==  R8_H_num ||
 1726     reg ==   R9_num || reg ==  R9_H_num ||
 1727     reg ==  R12_num || reg == R12_H_num ||
 1728     reg == XMM0_num || reg == XMM0b_num ||
 1729     reg == XMM1_num || reg == XMM1b_num ||
 1730     reg == XMM2_num || reg == XMM2b_num ||
 1731     reg == XMM3_num || reg == XMM3b_num ||
 1732     reg == XMM4_num || reg == XMM4b_num ||
 1733     reg == XMM5_num || reg == XMM5b_num ||
 1734     reg == XMM6_num || reg == XMM6b_num ||
 1735     reg == XMM7_num || reg == XMM7b_num;
 1736 }
 1737 
 1738 bool Matcher::is_spillable_arg(int reg)
 1739 {
 1740   return can_be_java_arg(reg);
 1741 }
 1742 
 1743 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1744   // In 64 bit mode a code which use multiply when
 1745   // devisor is constant is faster than hardware
 1746   // DIV instruction (it uses MulHiL).
 1747   return false;
 1748 }
 1749 
 1750 // Register for DIVI projection of divmodI
 1751 RegMask Matcher::divI_proj_mask() {
 1752   return INT_RAX_REG_mask();
 1753 }
 1754 
 1755 // Register for MODI projection of divmodI
 1756 RegMask Matcher::modI_proj_mask() {
 1757   return INT_RDX_REG_mask();
 1758 }
 1759 
 1760 // Register for DIVL projection of divmodL
 1761 RegMask Matcher::divL_proj_mask() {
 1762   return LONG_RAX_REG_mask();
 1763 }
 1764 
 1765 // Register for MODL projection of divmodL
 1766 RegMask Matcher::modL_proj_mask() {
 1767   return LONG_RDX_REG_mask();
 1768 }
 1769 
 1770 // Register for saving SP into on method handle invokes. Not used on x86_64.
 1771 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1772     return NO_REG_mask();
 1773 }
 1774 
 1775 %}
 1776 
 1777 //----------ENCODING BLOCK-----------------------------------------------------
 1778 // This block specifies the encoding classes used by the compiler to
 1779 // output byte streams.  Encoding classes are parameterized macros
 1780 // used by Machine Instruction Nodes in order to generate the bit
 1781 // encoding of the instruction.  Operands specify their base encoding
 1782 // interface with the interface keyword.  There are currently
 1783 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
 1784 // COND_INTER.  REG_INTER causes an operand to generate a function
 1785 // which returns its register number when queried.  CONST_INTER causes
 1786 // an operand to generate a function which returns the value of the
 1787 // constant when queried.  MEMORY_INTER causes an operand to generate
 1788 // four functions which return the Base Register, the Index Register,
 1789 // the Scale Value, and the Offset Value of the operand when queried.
 1790 // COND_INTER causes an operand to generate six functions which return
 1791 // the encoding code (ie - encoding bits for the instruction)
 1792 // associated with each basic boolean condition for a conditional
 1793 // instruction.
 1794 //
 1795 // Instructions specify two basic values for encoding.  Again, a
 1796 // function is available to check if the constant displacement is an
 1797 // oop. They use the ins_encode keyword to specify their encoding
 1798 // classes (which must be a sequence of enc_class names, and their
 1799 // parameters, specified in the encoding block), and they use the
 1800 // opcode keyword to specify, in order, their primary, secondary, and
 1801 // tertiary opcode.  Only the opcode sections which a particular
 1802 // instruction needs for encoding need to be specified.
 1803 encode %{
 1804   // Build emit functions for each basic byte or larger field in the
 1805   // intel encoding scheme (opcode, rm, sib, immediate), and call them
 1806   // from C++ code in the enc_class source block.  Emit functions will
 1807   // live in the main source block for now.  In future, we can
 1808   // generalize this by adding a syntax that specifies the sizes of
 1809   // fields in an order, so that the adlc can build the emit functions
 1810   // automagically
 1811 
 1812   // Emit primary opcode
 1813   enc_class OpcP
 1814   %{
 1815     emit_opcode(cbuf, $primary);
 1816   %}
 1817 
 1818   // Emit secondary opcode
 1819   enc_class OpcS
 1820   %{
 1821     emit_opcode(cbuf, $secondary);
 1822   %}
 1823 
 1824   // Emit tertiary opcode
 1825   enc_class OpcT
 1826   %{
 1827     emit_opcode(cbuf, $tertiary);
 1828   %}
 1829 
 1830   // Emit opcode directly
 1831   enc_class Opcode(immI d8)
 1832   %{
 1833     emit_opcode(cbuf, $d8$$constant);
 1834   %}
 1835 
 1836   // Emit size prefix
 1837   enc_class SizePrefix
 1838   %{
 1839     emit_opcode(cbuf, 0x66);
 1840   %}
 1841 
 1842   enc_class reg(rRegI reg)
 1843   %{
 1844     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
 1845   %}
 1846 
 1847   enc_class reg_reg(rRegI dst, rRegI src)
 1848   %{
 1849     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1850   %}
 1851 
 1852   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
 1853   %{
 1854     emit_opcode(cbuf, $opcode$$constant);
 1855     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1856   %}
 1857 
 1858   enc_class cdql_enc(no_rax_rdx_RegI div)
 1859   %{
 1860     // Full implementation of Java idiv and irem; checks for
 1861     // special case as described in JVM spec., p.243 &amp; p.271.
 1862     //
 1863     //         normal case                           special case
 1864     //
 1865     // input : rax: dividend                         min_int
 1866     //         reg: divisor                          -1
 1867     //
 1868     // output: rax: quotient  (= rax idiv reg)       min_int
 1869     //         rdx: remainder (= rax irem reg)       0
 1870     //
 1871     //  Code sequnce:
 1872     //
 1873     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
 1874     //    5:   75 07/08                jne    e &lt;normal&gt;
 1875     //    7:   33 d2                   xor    %edx,%edx
 1876     //  [div &gt;= 8 -&gt; offset + 1]
 1877     //  [REX_B]
 1878     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
 1879     //    c:   74 03/04                je     11 &lt;done&gt;
 1880     // 000000000000000e &lt;normal&gt;:
 1881     //    e:   99                      cltd
 1882     //  [div &gt;= 8 -&gt; offset + 1]
 1883     //  [REX_B]
 1884     //    f:   f7 f9                   idiv   $div
 1885     // 0000000000000011 &lt;done&gt;:
 1886 
 1887     // cmp    $0x80000000,%eax
 1888     emit_opcode(cbuf, 0x3d);
 1889     emit_d8(cbuf, 0x00);
 1890     emit_d8(cbuf, 0x00);
 1891     emit_d8(cbuf, 0x00);
 1892     emit_d8(cbuf, 0x80);
 1893 
 1894     // jne    e &lt;normal&gt;
 1895     emit_opcode(cbuf, 0x75);
 1896     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
 1897 
 1898     // xor    %edx,%edx
 1899     emit_opcode(cbuf, 0x33);
 1900     emit_d8(cbuf, 0xD2);
 1901 
 1902     // cmp    $0xffffffffffffffff,%ecx
 1903     if ($div$$reg &gt;= 8) {
 1904       emit_opcode(cbuf, Assembler::REX_B);
 1905     }
 1906     emit_opcode(cbuf, 0x83);
 1907     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1908     emit_d8(cbuf, 0xFF);
 1909 
 1910     // je     11 &lt;done&gt;
 1911     emit_opcode(cbuf, 0x74);
 1912     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
 1913 
 1914     // &lt;normal&gt;
 1915     // cltd
 1916     emit_opcode(cbuf, 0x99);
 1917 
 1918     // idivl (note: must be emitted by the user of this rule)
 1919     // &lt;done&gt;
 1920   %}
 1921 
 1922   enc_class cdqq_enc(no_rax_rdx_RegL div)
 1923   %{
 1924     // Full implementation of Java ldiv and lrem; checks for
 1925     // special case as described in JVM spec., p.243 &amp; p.271.
 1926     //
 1927     //         normal case                           special case
 1928     //
 1929     // input : rax: dividend                         min_long
 1930     //         reg: divisor                          -1
 1931     //
 1932     // output: rax: quotient  (= rax idiv reg)       min_long
 1933     //         rdx: remainder (= rax irem reg)       0
 1934     //
 1935     //  Code sequnce:
 1936     //
 1937     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
 1938     //    7:   00 00 80
 1939     //    a:   48 39 d0                cmp    %rdx,%rax
 1940     //    d:   75 08                   jne    17 &lt;normal&gt;
 1941     //    f:   33 d2                   xor    %edx,%edx
 1942     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
 1943     //   15:   74 05                   je     1c &lt;done&gt;
 1944     // 0000000000000017 &lt;normal&gt;:
 1945     //   17:   48 99                   cqto
 1946     //   19:   48 f7 f9                idiv   $div
 1947     // 000000000000001c &lt;done&gt;:
 1948 
 1949     // mov    $0x8000000000000000,%rdx
 1950     emit_opcode(cbuf, Assembler::REX_W);
 1951     emit_opcode(cbuf, 0xBA);
 1952     emit_d8(cbuf, 0x00);
 1953     emit_d8(cbuf, 0x00);
 1954     emit_d8(cbuf, 0x00);
 1955     emit_d8(cbuf, 0x00);
 1956     emit_d8(cbuf, 0x00);
 1957     emit_d8(cbuf, 0x00);
 1958     emit_d8(cbuf, 0x00);
 1959     emit_d8(cbuf, 0x80);
 1960 
 1961     // cmp    %rdx,%rax
 1962     emit_opcode(cbuf, Assembler::REX_W);
 1963     emit_opcode(cbuf, 0x39);
 1964     emit_d8(cbuf, 0xD0);
 1965 
 1966     // jne    17 &lt;normal&gt;
 1967     emit_opcode(cbuf, 0x75);
 1968     emit_d8(cbuf, 0x08);
 1969 
 1970     // xor    %edx,%edx
 1971     emit_opcode(cbuf, 0x33);
 1972     emit_d8(cbuf, 0xD2);
 1973 
 1974     // cmp    $0xffffffffffffffff,$div
 1975     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
 1976     emit_opcode(cbuf, 0x83);
 1977     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1978     emit_d8(cbuf, 0xFF);
 1979 
 1980     // je     1e &lt;done&gt;
 1981     emit_opcode(cbuf, 0x74);
 1982     emit_d8(cbuf, 0x05);
 1983 
 1984     // &lt;normal&gt;
 1985     // cqto
 1986     emit_opcode(cbuf, Assembler::REX_W);
 1987     emit_opcode(cbuf, 0x99);
 1988 
 1989     // idivq (note: must be emitted by the user of this rule)
 1990     // &lt;done&gt;
 1991   %}
 1992 
 1993   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1994   enc_class OpcSE(immI imm)
 1995   %{
 1996     // Emit primary opcode and set sign-extend bit
 1997     // Check for 8-bit immediate, and set sign extend bit in opcode
 1998     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1999       emit_opcode(cbuf, $primary | 0x02);
 2000     } else {
 2001       // 32-bit immediate
 2002       emit_opcode(cbuf, $primary);
 2003     }
 2004   %}
 2005 
 2006   enc_class OpcSErm(rRegI dst, immI imm)
 2007   %{
 2008     // OpcSEr/m
 2009     int dstenc = $dst$$reg;
 2010     if (dstenc &gt;= 8) {
 2011       emit_opcode(cbuf, Assembler::REX_B);
 2012       dstenc -= 8;
 2013     }
 2014     // Emit primary opcode and set sign-extend bit
 2015     // Check for 8-bit immediate, and set sign extend bit in opcode
 2016     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2017       emit_opcode(cbuf, $primary | 0x02);
 2018     } else {
 2019       // 32-bit immediate
 2020       emit_opcode(cbuf, $primary);
 2021     }
 2022     // Emit r/m byte with secondary opcode, after primary opcode.
 2023     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2024   %}
 2025 
 2026   enc_class OpcSErm_wide(rRegL dst, immI imm)
 2027   %{
 2028     // OpcSEr/m
 2029     int dstenc = $dst$$reg;
 2030     if (dstenc &lt; 8) {
 2031       emit_opcode(cbuf, Assembler::REX_W);
 2032     } else {
 2033       emit_opcode(cbuf, Assembler::REX_WB);
 2034       dstenc -= 8;
 2035     }
 2036     // Emit primary opcode and set sign-extend bit
 2037     // Check for 8-bit immediate, and set sign extend bit in opcode
 2038     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2039       emit_opcode(cbuf, $primary | 0x02);
 2040     } else {
 2041       // 32-bit immediate
 2042       emit_opcode(cbuf, $primary);
 2043     }
 2044     // Emit r/m byte with secondary opcode, after primary opcode.
 2045     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2046   %}
 2047 
 2048   enc_class Con8or32(immI imm)
 2049   %{
 2050     // Check for 8-bit immediate, and set sign extend bit in opcode
 2051     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2052       $$$emit8$imm$$constant;
 2053     } else {
 2054       // 32-bit immediate
 2055       $$$emit32$imm$$constant;
 2056     }
 2057   %}
 2058 
 2059   enc_class opc2_reg(rRegI dst)
 2060   %{
 2061     // BSWAP
 2062     emit_cc(cbuf, $secondary, $dst$$reg);
 2063   %}
 2064 
 2065   enc_class opc3_reg(rRegI dst)
 2066   %{
 2067     // BSWAP
 2068     emit_cc(cbuf, $tertiary, $dst$$reg);
 2069   %}
 2070 
 2071   enc_class reg_opc(rRegI div)
 2072   %{
 2073     // INC, DEC, IDIV, IMOD, JMP indirect, ...
 2074     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
 2075   %}
 2076 
 2077   enc_class enc_cmov(cmpOp cop)
 2078   %{
 2079     // CMOV
 2080     $$$emit8$primary;
 2081     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 2082   %}
 2083 
 2084   enc_class enc_PartialSubtypeCheck()
 2085   %{
 2086     Register Rrdi = as_Register(RDI_enc); // result register
 2087     Register Rrax = as_Register(RAX_enc); // super class
 2088     Register Rrcx = as_Register(RCX_enc); // killed
 2089     Register Rrsi = as_Register(RSI_enc); // sub class
 2090     Label miss;
 2091     const bool set_cond_codes = true;
 2092 
 2093     MacroAssembler _masm(&amp;cbuf);
 2094     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
 2095                                      NULL, &amp;miss,
 2096                                      /*set_cond_codes:*/ true);
 2097     if ($primary) {
 2098       __ xorptr(Rrdi, Rrdi);
 2099     }
 2100     __ bind(miss);
 2101   %}
 2102 
 2103   enc_class clear_avx %{
 2104     debug_only(int off0 = cbuf.insts_size());
 2105     if (generate_vzeroupper(Compile::current())) {
 2106       // Clear upper bits of YMM registers to avoid AVX &lt;-&gt; SSE transition penalty
 2107       // Clear upper bits of YMM registers when current compiled code uses
 2108       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 2109       MacroAssembler _masm(&amp;cbuf);
 2110       __ vzeroupper();
 2111     }
 2112     debug_only(int off1 = cbuf.insts_size());
 2113     assert(off1 - off0 == clear_avx_size(), &quot;correct size prediction&quot;);
 2114   %}
 2115 
 2116   enc_class Java_To_Runtime(method meth) %{
 2117     // No relocation needed
 2118     MacroAssembler _masm(&amp;cbuf);
 2119     __ mov64(r10, (int64_t) $meth$$method);
 2120     __ call(r10);
 2121   %}
 2122 
 2123   enc_class Java_To_Interpreter(method meth)
 2124   %{
 2125     // CALL Java_To_Interpreter
 2126     // This is the instruction starting address for relocation info.
 2127     cbuf.set_insts_mark();
 2128     $$$emit8$primary;
 2129     // CALL directly to the runtime
 2130     emit_d32_reloc(cbuf,
 2131                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2132                    runtime_call_Relocation::spec(),
 2133                    RELOC_DISP32);
 2134   %}
 2135 
 2136   enc_class Java_Static_Call(method meth)
 2137   %{
 2138     // JAVA STATIC CALL
 2139     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
 2140     // determine who we intended to call.
 2141     cbuf.set_insts_mark();
 2142     $$$emit8$primary;
 2143 
 2144     if (!_method) {
 2145       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2146                      runtime_call_Relocation::spec(),
 2147                      RELOC_DISP32);
 2148     } else {
 2149       int method_index = resolved_method_index(cbuf);
 2150       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2151                                                   : static_call_Relocation::spec(method_index);
 2152       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2153                      rspec, RELOC_DISP32);
 2154       // Emit stubs for static call.
 2155       address mark = cbuf.insts_mark();
 2156       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);
 2157       if (stub == NULL) {
 2158         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2159         return;
 2160       }
 2161 #if INCLUDE_AOT
 2162       CompiledStaticCall::emit_to_aot_stub(cbuf, mark);
 2163 #endif
 2164     }
 2165   %}
 2166 
 2167   enc_class Java_Dynamic_Call(method meth) %{
 2168     MacroAssembler _masm(&amp;cbuf);
 2169     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 2170   %}
 2171 
 2172   enc_class Java_Compiled_Call(method meth)
 2173   %{
 2174     // JAVA COMPILED CALL
 2175     int disp = in_bytes(Method:: from_compiled_offset());
 2176 
 2177     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
 2178     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, &quot;compiled_code_offset isn&#39;t small&quot;);
 2179 
 2180     // callq *disp(%rax)
 2181     cbuf.set_insts_mark();
 2182     $$$emit8$primary;
 2183     if (disp &lt; 0x80) {
 2184       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
 2185       emit_d8(cbuf, disp); // Displacement
 2186     } else {
 2187       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
 2188       emit_d32(cbuf, disp); // Displacement
 2189     }
 2190   %}
 2191 
 2192   enc_class reg_opc_imm(rRegI dst, immI8 shift)
 2193   %{
 2194     // SAL, SAR, SHR
 2195     int dstenc = $dst$$reg;
 2196     if (dstenc &gt;= 8) {
 2197       emit_opcode(cbuf, Assembler::REX_B);
 2198       dstenc -= 8;
 2199     }
 2200     $$$emit8$primary;
 2201     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2202     $$$emit8$shift$$constant;
 2203   %}
 2204 
 2205   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
 2206   %{
 2207     // SAL, SAR, SHR
 2208     int dstenc = $dst$$reg;
 2209     if (dstenc &lt; 8) {
 2210       emit_opcode(cbuf, Assembler::REX_W);
 2211     } else {
 2212       emit_opcode(cbuf, Assembler::REX_WB);
 2213       dstenc -= 8;
 2214     }
 2215     $$$emit8$primary;
 2216     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2217     $$$emit8$shift$$constant;
 2218   %}
 2219 
 2220   enc_class load_immI(rRegI dst, immI src)
 2221   %{
 2222     int dstenc = $dst$$reg;
 2223     if (dstenc &gt;= 8) {
 2224       emit_opcode(cbuf, Assembler::REX_B);
 2225       dstenc -= 8;
 2226     }
 2227     emit_opcode(cbuf, 0xB8 | dstenc);
 2228     $$$emit32$src$$constant;
 2229   %}
 2230 
 2231   enc_class load_immL(rRegL dst, immL src)
 2232   %{
 2233     int dstenc = $dst$$reg;
 2234     if (dstenc &lt; 8) {
 2235       emit_opcode(cbuf, Assembler::REX_W);
 2236     } else {
 2237       emit_opcode(cbuf, Assembler::REX_WB);
 2238       dstenc -= 8;
 2239     }
 2240     emit_opcode(cbuf, 0xB8 | dstenc);
 2241     emit_d64(cbuf, $src$$constant);
 2242   %}
 2243 
 2244   enc_class load_immUL32(rRegL dst, immUL32 src)
 2245   %{
 2246     // same as load_immI, but this time we care about zeroes in the high word
 2247     int dstenc = $dst$$reg;
 2248     if (dstenc &gt;= 8) {
 2249       emit_opcode(cbuf, Assembler::REX_B);
 2250       dstenc -= 8;
 2251     }
 2252     emit_opcode(cbuf, 0xB8 | dstenc);
 2253     $$$emit32$src$$constant;
 2254   %}
 2255 
 2256   enc_class load_immL32(rRegL dst, immL32 src)
 2257   %{
 2258     int dstenc = $dst$$reg;
 2259     if (dstenc &lt; 8) {
 2260       emit_opcode(cbuf, Assembler::REX_W);
 2261     } else {
 2262       emit_opcode(cbuf, Assembler::REX_WB);
 2263       dstenc -= 8;
 2264     }
 2265     emit_opcode(cbuf, 0xC7);
 2266     emit_rm(cbuf, 0x03, 0x00, dstenc);
 2267     $$$emit32$src$$constant;
 2268   %}
 2269 
 2270   enc_class load_immP31(rRegP dst, immP32 src)
 2271   %{
 2272     // same as load_immI, but this time we care about zeroes in the high word
 2273     int dstenc = $dst$$reg;
 2274     if (dstenc &gt;= 8) {
 2275       emit_opcode(cbuf, Assembler::REX_B);
 2276       dstenc -= 8;
 2277     }
 2278     emit_opcode(cbuf, 0xB8 | dstenc);
 2279     $$$emit32$src$$constant;
 2280   %}
 2281 
 2282   enc_class load_immP(rRegP dst, immP src)
 2283   %{
 2284     int dstenc = $dst$$reg;
 2285     if (dstenc &lt; 8) {
 2286       emit_opcode(cbuf, Assembler::REX_W);
 2287     } else {
 2288       emit_opcode(cbuf, Assembler::REX_WB);
 2289       dstenc -= 8;
 2290     }
 2291     emit_opcode(cbuf, 0xB8 | dstenc);
 2292     // This next line should be generated from ADLC
 2293     if ($src-&gt;constant_reloc() != relocInfo::none) {
 2294       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
 2295     } else {
 2296       emit_d64(cbuf, $src$$constant);
 2297     }
 2298   %}
 2299 
 2300   enc_class Con32(immI src)
 2301   %{
 2302     // Output immediate
 2303     $$$emit32$src$$constant;
 2304   %}
 2305 
 2306   enc_class Con32F_as_bits(immF src)
 2307   %{
 2308     // Output Float immediate bits
 2309     jfloat jf = $src$$constant;
 2310     jint jf_as_bits = jint_cast(jf);
 2311     emit_d32(cbuf, jf_as_bits);
 2312   %}
 2313 
 2314   enc_class Con16(immI src)
 2315   %{
 2316     // Output immediate
 2317     $$$emit16$src$$constant;
 2318   %}
 2319 
 2320   // How is this different from Con32??? XXX
 2321   enc_class Con_d32(immI src)
 2322   %{
 2323     emit_d32(cbuf,$src$$constant);
 2324   %}
 2325 
 2326   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
 2327     // Output immediate memory reference
 2328     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2329     emit_d32(cbuf, 0x00);
 2330   %}
 2331 
 2332   enc_class lock_prefix()
 2333   %{
 2334     emit_opcode(cbuf, 0xF0); // lock
 2335   %}
 2336 
 2337   enc_class REX_mem(memory mem)
 2338   %{
 2339     if ($mem$$base &gt;= 8) {
 2340       if ($mem$$index &lt; 8) {
 2341         emit_opcode(cbuf, Assembler::REX_B);
 2342       } else {
 2343         emit_opcode(cbuf, Assembler::REX_XB);
 2344       }
 2345     } else {
 2346       if ($mem$$index &gt;= 8) {
 2347         emit_opcode(cbuf, Assembler::REX_X);
 2348       }
 2349     }
 2350   %}
 2351 
 2352   enc_class REX_mem_wide(memory mem)
 2353   %{
 2354     if ($mem$$base &gt;= 8) {
 2355       if ($mem$$index &lt; 8) {
 2356         emit_opcode(cbuf, Assembler::REX_WB);
 2357       } else {
 2358         emit_opcode(cbuf, Assembler::REX_WXB);
 2359       }
 2360     } else {
 2361       if ($mem$$index &lt; 8) {
 2362         emit_opcode(cbuf, Assembler::REX_W);
 2363       } else {
 2364         emit_opcode(cbuf, Assembler::REX_WX);
 2365       }
 2366     }
 2367   %}
 2368 
 2369   // for byte regs
 2370   enc_class REX_breg(rRegI reg)
 2371   %{
 2372     if ($reg$$reg &gt;= 4) {
 2373       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2374     }
 2375   %}
 2376 
 2377   // for byte regs
 2378   enc_class REX_reg_breg(rRegI dst, rRegI src)
 2379   %{
 2380     if ($dst$$reg &lt; 8) {
 2381       if ($src$$reg &gt;= 4) {
 2382         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2383       }
 2384     } else {
 2385       if ($src$$reg &lt; 8) {
 2386         emit_opcode(cbuf, Assembler::REX_R);
 2387       } else {
 2388         emit_opcode(cbuf, Assembler::REX_RB);
 2389       }
 2390     }
 2391   %}
 2392 
 2393   // for byte regs
 2394   enc_class REX_breg_mem(rRegI reg, memory mem)
 2395   %{
 2396     if ($reg$$reg &lt; 8) {
 2397       if ($mem$$base &lt; 8) {
 2398         if ($mem$$index &gt;= 8) {
 2399           emit_opcode(cbuf, Assembler::REX_X);
 2400         } else if ($reg$$reg &gt;= 4) {
 2401           emit_opcode(cbuf, Assembler::REX);
 2402         }
 2403       } else {
 2404         if ($mem$$index &lt; 8) {
 2405           emit_opcode(cbuf, Assembler::REX_B);
 2406         } else {
 2407           emit_opcode(cbuf, Assembler::REX_XB);
 2408         }
 2409       }
 2410     } else {
 2411       if ($mem$$base &lt; 8) {
 2412         if ($mem$$index &lt; 8) {
 2413           emit_opcode(cbuf, Assembler::REX_R);
 2414         } else {
 2415           emit_opcode(cbuf, Assembler::REX_RX);
 2416         }
 2417       } else {
 2418         if ($mem$$index &lt; 8) {
 2419           emit_opcode(cbuf, Assembler::REX_RB);
 2420         } else {
 2421           emit_opcode(cbuf, Assembler::REX_RXB);
 2422         }
 2423       }
 2424     }
 2425   %}
 2426 
 2427   enc_class REX_reg(rRegI reg)
 2428   %{
 2429     if ($reg$$reg &gt;= 8) {
 2430       emit_opcode(cbuf, Assembler::REX_B);
 2431     }
 2432   %}
 2433 
 2434   enc_class REX_reg_wide(rRegI reg)
 2435   %{
 2436     if ($reg$$reg &lt; 8) {
 2437       emit_opcode(cbuf, Assembler::REX_W);
 2438     } else {
 2439       emit_opcode(cbuf, Assembler::REX_WB);
 2440     }
 2441   %}
 2442 
 2443   enc_class REX_reg_reg(rRegI dst, rRegI src)
 2444   %{
 2445     if ($dst$$reg &lt; 8) {
 2446       if ($src$$reg &gt;= 8) {
 2447         emit_opcode(cbuf, Assembler::REX_B);
 2448       }
 2449     } else {
 2450       if ($src$$reg &lt; 8) {
 2451         emit_opcode(cbuf, Assembler::REX_R);
 2452       } else {
 2453         emit_opcode(cbuf, Assembler::REX_RB);
 2454       }
 2455     }
 2456   %}
 2457 
 2458   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
 2459   %{
 2460     if ($dst$$reg &lt; 8) {
 2461       if ($src$$reg &lt; 8) {
 2462         emit_opcode(cbuf, Assembler::REX_W);
 2463       } else {
 2464         emit_opcode(cbuf, Assembler::REX_WB);
 2465       }
 2466     } else {
 2467       if ($src$$reg &lt; 8) {
 2468         emit_opcode(cbuf, Assembler::REX_WR);
 2469       } else {
 2470         emit_opcode(cbuf, Assembler::REX_WRB);
 2471       }
 2472     }
 2473   %}
 2474 
 2475   enc_class REX_reg_mem(rRegI reg, memory mem)
 2476   %{
 2477     if ($reg$$reg &lt; 8) {
 2478       if ($mem$$base &lt; 8) {
 2479         if ($mem$$index &gt;= 8) {
 2480           emit_opcode(cbuf, Assembler::REX_X);
 2481         }
 2482       } else {
 2483         if ($mem$$index &lt; 8) {
 2484           emit_opcode(cbuf, Assembler::REX_B);
 2485         } else {
 2486           emit_opcode(cbuf, Assembler::REX_XB);
 2487         }
 2488       }
 2489     } else {
 2490       if ($mem$$base &lt; 8) {
 2491         if ($mem$$index &lt; 8) {
 2492           emit_opcode(cbuf, Assembler::REX_R);
 2493         } else {
 2494           emit_opcode(cbuf, Assembler::REX_RX);
 2495         }
 2496       } else {
 2497         if ($mem$$index &lt; 8) {
 2498           emit_opcode(cbuf, Assembler::REX_RB);
 2499         } else {
 2500           emit_opcode(cbuf, Assembler::REX_RXB);
 2501         }
 2502       }
 2503     }
 2504   %}
 2505 
 2506   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
 2507   %{
 2508     if ($reg$$reg &lt; 8) {
 2509       if ($mem$$base &lt; 8) {
 2510         if ($mem$$index &lt; 8) {
 2511           emit_opcode(cbuf, Assembler::REX_W);
 2512         } else {
 2513           emit_opcode(cbuf, Assembler::REX_WX);
 2514         }
 2515       } else {
 2516         if ($mem$$index &lt; 8) {
 2517           emit_opcode(cbuf, Assembler::REX_WB);
 2518         } else {
 2519           emit_opcode(cbuf, Assembler::REX_WXB);
 2520         }
 2521       }
 2522     } else {
 2523       if ($mem$$base &lt; 8) {
 2524         if ($mem$$index &lt; 8) {
 2525           emit_opcode(cbuf, Assembler::REX_WR);
 2526         } else {
 2527           emit_opcode(cbuf, Assembler::REX_WRX);
 2528         }
 2529       } else {
 2530         if ($mem$$index &lt; 8) {
 2531           emit_opcode(cbuf, Assembler::REX_WRB);
 2532         } else {
 2533           emit_opcode(cbuf, Assembler::REX_WRXB);
 2534         }
 2535       }
 2536     }
 2537   %}
 2538 
 2539   enc_class reg_mem(rRegI ereg, memory mem)
 2540   %{
 2541     // High registers handle in encode_RegMem
 2542     int reg = $ereg$$reg;
 2543     int base = $mem$$base;
 2544     int index = $mem$$index;
 2545     int scale = $mem$$scale;
 2546     int disp = $mem$$disp;
 2547     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2548 
 2549     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
 2550   %}
 2551 
 2552   enc_class RM_opc_mem(immI rm_opcode, memory mem)
 2553   %{
 2554     int rm_byte_opcode = $rm_opcode$$constant;
 2555 
 2556     // High registers handle in encode_RegMem
 2557     int base = $mem$$base;
 2558     int index = $mem$$index;
 2559     int scale = $mem$$scale;
 2560     int displace = $mem$$disp;
 2561 
 2562     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
 2563                                             // working with static
 2564                                             // globals
 2565     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
 2566                   disp_reloc);
 2567   %}
 2568 
 2569   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
 2570   %{
 2571     int reg_encoding = $dst$$reg;
 2572     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2573     int index        = 0x04;            // 0x04 indicates no index
 2574     int scale        = 0x00;            // 0x00 indicates no scale
 2575     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2576     relocInfo::relocType disp_reloc = relocInfo::none;
 2577     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
 2578                   disp_reloc);
 2579   %}
 2580 
 2581   enc_class neg_reg(rRegI dst)
 2582   %{
 2583     int dstenc = $dst$$reg;
 2584     if (dstenc &gt;= 8) {
 2585       emit_opcode(cbuf, Assembler::REX_B);
 2586       dstenc -= 8;
 2587     }
 2588     // NEG $dst
 2589     emit_opcode(cbuf, 0xF7);
 2590     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2591   %}
 2592 
 2593   enc_class neg_reg_wide(rRegI dst)
 2594   %{
 2595     int dstenc = $dst$$reg;
 2596     if (dstenc &lt; 8) {
 2597       emit_opcode(cbuf, Assembler::REX_W);
 2598     } else {
 2599       emit_opcode(cbuf, Assembler::REX_WB);
 2600       dstenc -= 8;
 2601     }
 2602     // NEG $dst
 2603     emit_opcode(cbuf, 0xF7);
 2604     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2605   %}
 2606 
 2607   enc_class setLT_reg(rRegI dst)
 2608   %{
 2609     int dstenc = $dst$$reg;
 2610     if (dstenc &gt;= 8) {
 2611       emit_opcode(cbuf, Assembler::REX_B);
 2612       dstenc -= 8;
 2613     } else if (dstenc &gt;= 4) {
 2614       emit_opcode(cbuf, Assembler::REX);
 2615     }
 2616     // SETLT $dst
 2617     emit_opcode(cbuf, 0x0F);
 2618     emit_opcode(cbuf, 0x9C);
 2619     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2620   %}
 2621 
 2622   enc_class setNZ_reg(rRegI dst)
 2623   %{
 2624     int dstenc = $dst$$reg;
 2625     if (dstenc &gt;= 8) {
 2626       emit_opcode(cbuf, Assembler::REX_B);
 2627       dstenc -= 8;
 2628     } else if (dstenc &gt;= 4) {
 2629       emit_opcode(cbuf, Assembler::REX);
 2630     }
 2631     // SETNZ $dst
 2632     emit_opcode(cbuf, 0x0F);
 2633     emit_opcode(cbuf, 0x95);
 2634     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2635   %}
 2636 
 2637 
 2638   // Compare the lonogs and set -1, 0, or 1 into dst
 2639   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
 2640   %{
 2641     int src1enc = $src1$$reg;
 2642     int src2enc = $src2$$reg;
 2643     int dstenc = $dst$$reg;
 2644 
 2645     // cmpq $src1, $src2
 2646     if (src1enc &lt; 8) {
 2647       if (src2enc &lt; 8) {
 2648         emit_opcode(cbuf, Assembler::REX_W);
 2649       } else {
 2650         emit_opcode(cbuf, Assembler::REX_WB);
 2651       }
 2652     } else {
 2653       if (src2enc &lt; 8) {
 2654         emit_opcode(cbuf, Assembler::REX_WR);
 2655       } else {
 2656         emit_opcode(cbuf, Assembler::REX_WRB);
 2657       }
 2658     }
 2659     emit_opcode(cbuf, 0x3B);
 2660     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
 2661 
 2662     // movl $dst, -1
 2663     if (dstenc &gt;= 8) {
 2664       emit_opcode(cbuf, Assembler::REX_B);
 2665     }
 2666     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
 2667     emit_d32(cbuf, -1);
 2668 
 2669     // jl,s done
 2670     emit_opcode(cbuf, 0x7C);
 2671     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
 2672 
 2673     // setne $dst
 2674     if (dstenc &gt;= 4) {
 2675       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2676     }
 2677     emit_opcode(cbuf, 0x0F);
 2678     emit_opcode(cbuf, 0x95);
 2679     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
 2680 
 2681     // movzbl $dst, $dst
 2682     if (dstenc &gt;= 4) {
 2683       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
 2684     }
 2685     emit_opcode(cbuf, 0x0F);
 2686     emit_opcode(cbuf, 0xB6);
 2687     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
 2688   %}
 2689 
 2690   enc_class Push_ResultXD(regD dst) %{
 2691     MacroAssembler _masm(&amp;cbuf);
 2692     __ fstp_d(Address(rsp, 0));
 2693     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2694     __ addptr(rsp, 8);
 2695   %}
 2696 
 2697   enc_class Push_SrcXD(regD src) %{
 2698     MacroAssembler _masm(&amp;cbuf);
 2699     __ subptr(rsp, 8);
 2700     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2701     __ fld_d(Address(rsp, 0));
 2702   %}
 2703 
 2704 
 2705   enc_class enc_rethrow()
 2706   %{
 2707     cbuf.set_insts_mark();
 2708     emit_opcode(cbuf, 0xE9); // jmp entry
 2709     emit_d32_reloc(cbuf,
 2710                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
 2711                    runtime_call_Relocation::spec(),
 2712                    RELOC_DISP32);
 2713   %}
 2714 
 2715 %}
 2716 
 2717 
 2718 
 2719 //----------FRAME--------------------------------------------------------------
 2720 // Definition of frame structure and management information.
 2721 //
 2722 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2723 //                             |   (to get allocators register number
 2724 //  G  Owned by    |        |  v    add OptoReg::stack0())
 2725 //  r   CALLER     |        |
 2726 //  o     |        +--------+      pad to even-align allocators stack-slot
 2727 //  w     V        |  pad0  |        numbers; owned by CALLER
 2728 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2729 //  h     ^        |   in   |  5
 2730 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2731 //  |     |        |        |  3
 2732 //  |     |        +--------+
 2733 //  V     |        | old out|      Empty on Intel, window on Sparc
 2734 //        |    old |preserve|      Must be even aligned.
 2735 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 2736 //        |        |   in   |  3   area for Intel ret address
 2737 //     Owned by    |preserve|      Empty on Sparc.
 2738 //       SELF      +--------+
 2739 //        |        |  pad2  |  2   pad to align old SP
 2740 //        |        +--------+  1
 2741 //        |        | locks  |  0
 2742 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 2743 //        |        |  pad1  | 11   pad to align new SP
 2744 //        |        +--------+
 2745 //        |        |        | 10
 2746 //        |        | spills |  9   spills
 2747 //        V        |        |  8   (pad0 slot for callee)
 2748 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2749 //        ^        |  out   |  7
 2750 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2751 //     Owned by    +--------+
 2752 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2753 //        |    new |preserve|      Must be even-aligned.
 2754 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2755 //        |        |        |
 2756 //
 2757 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2758 //         known from SELF&#39;s arguments and the Java calling convention.
 2759 //         Region 6-7 is determined per call site.
 2760 // Note 2: If the calling convention leaves holes in the incoming argument
 2761 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2762 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2763 //         incoming area, as the Java calling convention is completely under
 2764 //         the control of the AD file.  Doubles can be sorted and packed to
 2765 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 2766 //         varargs C calling conventions.
 2767 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2768 //         even aligned with pad0 as needed.
 2769 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2770 //         region 6-11 is even aligned; it may be padded out more so that
 2771 //         the region from SP to FP meets the minimum stack alignment.
 2772 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
 2773 //         alignment.  Region 11, pad1, may be dynamically extended so that
 2774 //         SP meets the minimum alignment.
 2775 
 2776 frame
 2777 %{
 2778   // What direction does stack grow in (assumed to be same for C &amp; Java)
 2779   stack_direction(TOWARDS_LOW);
 2780 
 2781   // These three registers define part of the calling convention
 2782   // between compiled code and the interpreter.
 2783   inline_cache_reg(RAX);                // Inline Cache Register
 2784   interpreter_method_oop_reg(RBX);      // Method Oop Register when
 2785                                         // calling interpreter
 2786 
 2787   // Optional: name the operand used by cisc-spilling to access
 2788   // [stack_pointer + offset]
 2789   cisc_spilling_operand_name(indOffset32);
 2790 
 2791   // Number of stack slots consumed by locking an object
 2792   sync_stack_slots(2);
 2793 
 2794   // Compiled code&#39;s Frame Pointer
 2795   frame_pointer(RSP);
 2796 
 2797   // Interpreter stores its frame pointer in a register which is
 2798   // stored to the stack by I2CAdaptors.
 2799   // I2CAdaptors convert from interpreted java to compiled java.
 2800   interpreter_frame_pointer(RBP);
 2801 
 2802   // Stack alignment requirement
 2803   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
 2804 
 2805   // Number of stack slots between incoming argument block and the start of
 2806   // a new frame.  The PROLOG must add this many slots to the stack.  The
 2807   // EPILOG must remove this many slots.  amd64 needs two slots for
 2808   // return address.
 2809   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
 2810 
 2811   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 2812   // for calls to C.  Supports the var-args backing area for register parms.
 2813   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
 2814 
 2815   // The after-PROLOG location of the return address.  Location of
 2816   // return address specifies a type (REG or STACK) and a number
 2817   // representing the register number (i.e. - use a register name) or
 2818   // stack slot.
 2819   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 2820   // Otherwise, it is above the locks and verification slot and alignment word
 2821   return_addr(STACK - 2 +
 2822               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 2823                         Compile::current()-&gt;fixed_slots()),
 2824                        stack_alignment_in_slots()));
 2825 
 2826   // Body of function which returns an integer array locating
 2827   // arguments either in registers or in stack slots.  Passed an array
 2828   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 2829   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2830   // arguments for a CALLEE.  Incoming stack arguments are
 2831   // automatically biased by the preserve_stack_slots field above.
 2832 
 2833   calling_convention
 2834   %{
 2835     // No difference between ingoing/outgoing just pass false
 2836     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2837   %}
 2838 
 2839   c_calling_convention
 2840   %{
 2841     // This is obviously always outgoing
 2842     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2843   %}
 2844 
 2845   // Location of compiled Java return values.  Same as C for now.
 2846   return_value
 2847   %{
 2848     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
 2849            &quot;only return normal values&quot;);
 2850 
 2851     static const int lo[Op_RegL + 1] = {
 2852       0,
 2853       0,
 2854       RAX_num,  // Op_RegN
 2855       RAX_num,  // Op_RegI
 2856       RAX_num,  // Op_RegP
 2857       XMM0_num, // Op_RegF
 2858       XMM0_num, // Op_RegD
 2859       RAX_num   // Op_RegL
 2860     };
 2861     static const int hi[Op_RegL + 1] = {
 2862       0,
 2863       0,
 2864       OptoReg::Bad, // Op_RegN
 2865       OptoReg::Bad, // Op_RegI
 2866       RAX_H_num,    // Op_RegP
 2867       OptoReg::Bad, // Op_RegF
 2868       XMM0b_num,    // Op_RegD
 2869       RAX_H_num     // Op_RegL
 2870     };
 2871     // Excluded flags and vector registers.
 2872     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, &quot;missing type&quot;);
 2873     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
 2874   %}
 2875 %}
 2876 
 2877 //----------ATTRIBUTES---------------------------------------------------------
 2878 //----------Operand Attributes-------------------------------------------------
 2879 op_attrib op_cost(0);        // Required cost attribute
 2880 
 2881 //----------Instruction Attributes---------------------------------------------
 2882 ins_attrib ins_cost(100);       // Required cost attribute
 2883 ins_attrib ins_size(8);         // Required size attribute (in bits)
 2884 ins_attrib ins_short_branch(0); // Required flag: is this instruction
 2885                                 // a non-matching short branch variant
 2886                                 // of some long branch?
 2887 ins_attrib ins_alignment(1);    // Required alignment attribute (must
 2888                                 // be a power of 2) specifies the
 2889                                 // alignment that some part of the
 2890                                 // instruction (not necessarily the
 2891                                 // start) requires.  If &gt; 1, a
 2892                                 // compute_padding() function must be
 2893                                 // provided for the instruction
 2894 
 2895 //----------OPERANDS-----------------------------------------------------------
 2896 // Operand definitions must precede instruction definitions for correct parsing
 2897 // in the ADLC because operands constitute user defined types which are used in
 2898 // instruction definitions.
 2899 
 2900 //----------Simple Operands----------------------------------------------------
 2901 // Immediate Operands
 2902 // Integer Immediate
 2903 operand immI()
 2904 %{
 2905   match(ConI);
 2906 
 2907   op_cost(10);
 2908   format %{ %}
 2909   interface(CONST_INTER);
 2910 %}
 2911 
 2912 // Constant for test vs zero
 2913 operand immI0()
 2914 %{
 2915   predicate(n-&gt;get_int() == 0);
 2916   match(ConI);
 2917 
 2918   op_cost(0);
 2919   format %{ %}
 2920   interface(CONST_INTER);
 2921 %}
 2922 
 2923 // Constant for increment
 2924 operand immI1()
 2925 %{
 2926   predicate(n-&gt;get_int() == 1);
 2927   match(ConI);
 2928 
 2929   op_cost(0);
 2930   format %{ %}
 2931   interface(CONST_INTER);
 2932 %}
 2933 
 2934 // Constant for decrement
 2935 operand immI_M1()
 2936 %{
 2937   predicate(n-&gt;get_int() == -1);
 2938   match(ConI);
 2939 
 2940   op_cost(0);
 2941   format %{ %}
 2942   interface(CONST_INTER);
 2943 %}
 2944 
 2945 // Valid scale values for addressing modes
 2946 operand immI2()
 2947 %{
 2948   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 2949   match(ConI);
 2950 
 2951   format %{ %}
 2952   interface(CONST_INTER);
 2953 %}
 2954 
 2955 operand immI8()
 2956 %{
 2957   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
 2958   match(ConI);
 2959 
 2960   op_cost(5);
 2961   format %{ %}
 2962   interface(CONST_INTER);
 2963 %}
 2964 
 2965 operand immU8()
 2966 %{
 2967   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 2968   match(ConI);
 2969 
 2970   op_cost(5);
 2971   format %{ %}
 2972   interface(CONST_INTER);
 2973 %}
 2974 
 2975 operand immI16()
 2976 %{
 2977   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 2978   match(ConI);
 2979 
 2980   op_cost(10);
 2981   format %{ %}
 2982   interface(CONST_INTER);
 2983 %}
 2984 
 2985 // Int Immediate non-negative
 2986 operand immU31()
 2987 %{
 2988   predicate(n-&gt;get_int() &gt;= 0);
 2989   match(ConI);
 2990 
 2991   op_cost(0);
 2992   format %{ %}
 2993   interface(CONST_INTER);
 2994 %}
 2995 
 2996 // Constant for long shifts
 2997 operand immI_32()
 2998 %{
 2999   predicate( n-&gt;get_int() == 32 );
 3000   match(ConI);
 3001 
 3002   op_cost(0);
 3003   format %{ %}
 3004   interface(CONST_INTER);
 3005 %}
 3006 
 3007 // Constant for long shifts
 3008 operand immI_64()
 3009 %{
 3010   predicate( n-&gt;get_int() == 64 );
 3011   match(ConI);
 3012 
 3013   op_cost(0);
 3014   format %{ %}
 3015   interface(CONST_INTER);
 3016 %}
 3017 
 3018 // Pointer Immediate
 3019 operand immP()
 3020 %{
 3021   match(ConP);
 3022 
 3023   op_cost(10);
 3024   format %{ %}
 3025   interface(CONST_INTER);
 3026 %}
 3027 
 3028 // NULL Pointer Immediate
 3029 operand immP0()
 3030 %{
 3031   predicate(n-&gt;get_ptr() == 0);
 3032   match(ConP);
 3033 
 3034   op_cost(5);
 3035   format %{ %}
 3036   interface(CONST_INTER);
 3037 %}
 3038 
 3039 // Pointer Immediate
 3040 operand immN() %{
 3041   match(ConN);
 3042 
 3043   op_cost(10);
 3044   format %{ %}
 3045   interface(CONST_INTER);
 3046 %}
 3047 
 3048 operand immNKlass() %{
 3049   match(ConNKlass);
 3050 
 3051   op_cost(10);
 3052   format %{ %}
 3053   interface(CONST_INTER);
 3054 %}
 3055 
 3056 // NULL Pointer Immediate
 3057 operand immN0() %{
 3058   predicate(n-&gt;get_narrowcon() == 0);
 3059   match(ConN);
 3060 
 3061   op_cost(5);
 3062   format %{ %}
 3063   interface(CONST_INTER);
 3064 %}
 3065 
 3066 operand immP31()
 3067 %{
 3068   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
 3069             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
 3070   match(ConP);
 3071 
 3072   op_cost(5);
 3073   format %{ %}
 3074   interface(CONST_INTER);
 3075 %}
 3076 
 3077 
 3078 // Long Immediate
 3079 operand immL()
 3080 %{
 3081   match(ConL);
 3082 
 3083   op_cost(20);
 3084   format %{ %}
 3085   interface(CONST_INTER);
 3086 %}
 3087 
 3088 // Long Immediate 8-bit
 3089 operand immL8()
 3090 %{
 3091   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
 3092   match(ConL);
 3093 
 3094   op_cost(5);
 3095   format %{ %}
 3096   interface(CONST_INTER);
 3097 %}
 3098 
 3099 // Long Immediate 32-bit unsigned
 3100 operand immUL32()
 3101 %{
 3102   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
 3103   match(ConL);
 3104 
 3105   op_cost(10);
 3106   format %{ %}
 3107   interface(CONST_INTER);
 3108 %}
 3109 
 3110 // Long Immediate 32-bit signed
 3111 operand immL32()
 3112 %{
 3113   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3114   match(ConL);
 3115 
 3116   op_cost(15);
 3117   format %{ %}
 3118   interface(CONST_INTER);
 3119 %}
 3120 
 3121 operand immL_Pow2()
 3122 %{
<a name="1" id="anc1"></a><span class="line-modified"> 3123   predicate(is_power_of_2(n-&gt;get_long()));</span>
 3124   match(ConL);
 3125 
 3126   op_cost(15);
 3127   format %{ %}
 3128   interface(CONST_INTER);
 3129 %}
 3130 
 3131 operand immL_NotPow2()
 3132 %{
<a name="2" id="anc2"></a><span class="line-modified"> 3133   predicate(is_power_of_2(~n-&gt;get_long()));</span>
 3134   match(ConL);
 3135 
 3136   op_cost(15);
 3137   format %{ %}
 3138   interface(CONST_INTER);
 3139 %}
 3140 
 3141 // Long Immediate zero
 3142 operand immL0()
 3143 %{
 3144   predicate(n-&gt;get_long() == 0L);
 3145   match(ConL);
 3146 
 3147   op_cost(10);
 3148   format %{ %}
 3149   interface(CONST_INTER);
 3150 %}
 3151 
 3152 // Constant for increment
 3153 operand immL1()
 3154 %{
 3155   predicate(n-&gt;get_long() == 1);
 3156   match(ConL);
 3157 
 3158   format %{ %}
 3159   interface(CONST_INTER);
 3160 %}
 3161 
 3162 // Constant for decrement
 3163 operand immL_M1()
 3164 %{
 3165   predicate(n-&gt;get_long() == -1);
 3166   match(ConL);
 3167 
 3168   format %{ %}
 3169   interface(CONST_INTER);
 3170 %}
 3171 
 3172 // Long Immediate: the value 10
 3173 operand immL10()
 3174 %{
 3175   predicate(n-&gt;get_long() == 10);
 3176   match(ConL);
 3177 
 3178   format %{ %}
 3179   interface(CONST_INTER);
 3180 %}
 3181 
 3182 // Long immediate from 0 to 127.
 3183 // Used for a shorter form of long mul by 10.
 3184 operand immL_127()
 3185 %{
 3186   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
 3187   match(ConL);
 3188 
 3189   op_cost(10);
 3190   format %{ %}
 3191   interface(CONST_INTER);
 3192 %}
 3193 
 3194 // Long Immediate: low 32-bit mask
 3195 operand immL_32bits()
 3196 %{
 3197   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3198   match(ConL);
 3199   op_cost(20);
 3200 
 3201   format %{ %}
 3202   interface(CONST_INTER);
 3203 %}
 3204 
 3205 // Float Immediate zero
 3206 operand immF0()
 3207 %{
 3208   predicate(jint_cast(n-&gt;getf()) == 0);
 3209   match(ConF);
 3210 
 3211   op_cost(5);
 3212   format %{ %}
 3213   interface(CONST_INTER);
 3214 %}
 3215 
 3216 // Float Immediate
 3217 operand immF()
 3218 %{
 3219   match(ConF);
 3220 
 3221   op_cost(15);
 3222   format %{ %}
 3223   interface(CONST_INTER);
 3224 %}
 3225 
 3226 // Double Immediate zero
 3227 operand immD0()
 3228 %{
 3229   predicate(jlong_cast(n-&gt;getd()) == 0);
 3230   match(ConD);
 3231 
 3232   op_cost(5);
 3233   format %{ %}
 3234   interface(CONST_INTER);
 3235 %}
 3236 
 3237 // Double Immediate
 3238 operand immD()
 3239 %{
 3240   match(ConD);
 3241 
 3242   op_cost(15);
 3243   format %{ %}
 3244   interface(CONST_INTER);
 3245 %}
 3246 
 3247 // Immediates for special shifts (sign extend)
 3248 
 3249 // Constants for increment
 3250 operand immI_16()
 3251 %{
 3252   predicate(n-&gt;get_int() == 16);
 3253   match(ConI);
 3254 
 3255   format %{ %}
 3256   interface(CONST_INTER);
 3257 %}
 3258 
 3259 operand immI_24()
 3260 %{
 3261   predicate(n-&gt;get_int() == 24);
 3262   match(ConI);
 3263 
 3264   format %{ %}
 3265   interface(CONST_INTER);
 3266 %}
 3267 
 3268 // Constant for byte-wide masking
 3269 operand immI_255()
 3270 %{
 3271   predicate(n-&gt;get_int() == 255);
 3272   match(ConI);
 3273 
 3274   format %{ %}
 3275   interface(CONST_INTER);
 3276 %}
 3277 
 3278 // Constant for short-wide masking
 3279 operand immI_65535()
 3280 %{
 3281   predicate(n-&gt;get_int() == 65535);
 3282   match(ConI);
 3283 
 3284   format %{ %}
 3285   interface(CONST_INTER);
 3286 %}
 3287 
 3288 // Constant for byte-wide masking
 3289 operand immL_255()
 3290 %{
 3291   predicate(n-&gt;get_long() == 255);
 3292   match(ConL);
 3293 
 3294   format %{ %}
 3295   interface(CONST_INTER);
 3296 %}
 3297 
 3298 // Constant for short-wide masking
 3299 operand immL_65535()
 3300 %{
 3301   predicate(n-&gt;get_long() == 65535);
 3302   match(ConL);
 3303 
 3304   format %{ %}
 3305   interface(CONST_INTER);
 3306 %}
 3307 
 3308 // Register Operands
 3309 // Integer Register
 3310 operand rRegI()
 3311 %{
 3312   constraint(ALLOC_IN_RC(int_reg));
 3313   match(RegI);
 3314 
 3315   match(rax_RegI);
 3316   match(rbx_RegI);
 3317   match(rcx_RegI);
 3318   match(rdx_RegI);
 3319   match(rdi_RegI);
 3320 
 3321   format %{ %}
 3322   interface(REG_INTER);
 3323 %}
 3324 
 3325 // Special Registers
 3326 operand rax_RegI()
 3327 %{
 3328   constraint(ALLOC_IN_RC(int_rax_reg));
 3329   match(RegI);
 3330   match(rRegI);
 3331 
 3332   format %{ &quot;RAX&quot; %}
 3333   interface(REG_INTER);
 3334 %}
 3335 
 3336 // Special Registers
 3337 operand rbx_RegI()
 3338 %{
 3339   constraint(ALLOC_IN_RC(int_rbx_reg));
 3340   match(RegI);
 3341   match(rRegI);
 3342 
 3343   format %{ &quot;RBX&quot; %}
 3344   interface(REG_INTER);
 3345 %}
 3346 
 3347 operand rcx_RegI()
 3348 %{
 3349   constraint(ALLOC_IN_RC(int_rcx_reg));
 3350   match(RegI);
 3351   match(rRegI);
 3352 
 3353   format %{ &quot;RCX&quot; %}
 3354   interface(REG_INTER);
 3355 %}
 3356 
 3357 operand rdx_RegI()
 3358 %{
 3359   constraint(ALLOC_IN_RC(int_rdx_reg));
 3360   match(RegI);
 3361   match(rRegI);
 3362 
 3363   format %{ &quot;RDX&quot; %}
 3364   interface(REG_INTER);
 3365 %}
 3366 
 3367 operand rdi_RegI()
 3368 %{
 3369   constraint(ALLOC_IN_RC(int_rdi_reg));
 3370   match(RegI);
 3371   match(rRegI);
 3372 
 3373   format %{ &quot;RDI&quot; %}
 3374   interface(REG_INTER);
 3375 %}
 3376 
 3377 operand no_rcx_RegI()
 3378 %{
 3379   constraint(ALLOC_IN_RC(int_no_rcx_reg));
 3380   match(RegI);
 3381   match(rax_RegI);
 3382   match(rbx_RegI);
 3383   match(rdx_RegI);
 3384   match(rdi_RegI);
 3385 
 3386   format %{ %}
 3387   interface(REG_INTER);
 3388 %}
 3389 
 3390 operand no_rax_rdx_RegI()
 3391 %{
 3392   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
 3393   match(RegI);
 3394   match(rbx_RegI);
 3395   match(rcx_RegI);
 3396   match(rdi_RegI);
 3397 
 3398   format %{ %}
 3399   interface(REG_INTER);
 3400 %}
 3401 
 3402 // Pointer Register
 3403 operand any_RegP()
 3404 %{
 3405   constraint(ALLOC_IN_RC(any_reg));
 3406   match(RegP);
 3407   match(rax_RegP);
 3408   match(rbx_RegP);
 3409   match(rdi_RegP);
 3410   match(rsi_RegP);
 3411   match(rbp_RegP);
 3412   match(r15_RegP);
 3413   match(rRegP);
 3414 
 3415   format %{ %}
 3416   interface(REG_INTER);
 3417 %}
 3418 
 3419 operand rRegP()
 3420 %{
 3421   constraint(ALLOC_IN_RC(ptr_reg));
 3422   match(RegP);
 3423   match(rax_RegP);
 3424   match(rbx_RegP);
 3425   match(rdi_RegP);
 3426   match(rsi_RegP);
 3427   match(rbp_RegP);  // See Q&amp;A below about
 3428   match(r15_RegP);  // r15_RegP and rbp_RegP.
 3429 
 3430   format %{ %}
 3431   interface(REG_INTER);
 3432 %}
 3433 
 3434 operand rRegN() %{
 3435   constraint(ALLOC_IN_RC(int_reg));
 3436   match(RegN);
 3437 
 3438   format %{ %}
 3439   interface(REG_INTER);
 3440 %}
 3441 
 3442 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
 3443 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
 3444 // It&#39;s fine for an instruction input that expects rRegP to match a r15_RegP.
 3445 // The output of an instruction is controlled by the allocator, which respects
 3446 // register class masks, not match rules.  Unless an instruction mentions
 3447 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
 3448 // by the allocator as an input.
 3449 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
 3450 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
 3451 // result, RBP is not included in the output of the instruction either.
 3452 
 3453 operand no_rax_RegP()
 3454 %{
 3455   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
 3456   match(RegP);
 3457   match(rbx_RegP);
 3458   match(rsi_RegP);
 3459   match(rdi_RegP);
 3460 
 3461   format %{ %}
 3462   interface(REG_INTER);
 3463 %}
 3464 
 3465 // This operand is not allowed to use RBP even if
 3466 // RBP is not used to hold the frame pointer.
 3467 operand no_rbp_RegP()
 3468 %{
 3469   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
 3470   match(RegP);
 3471   match(rbx_RegP);
 3472   match(rsi_RegP);
 3473   match(rdi_RegP);
 3474 
 3475   format %{ %}
 3476   interface(REG_INTER);
 3477 %}
 3478 
 3479 operand no_rax_rbx_RegP()
 3480 %{
 3481   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
 3482   match(RegP);
 3483   match(rsi_RegP);
 3484   match(rdi_RegP);
 3485 
 3486   format %{ %}
 3487   interface(REG_INTER);
 3488 %}
 3489 
 3490 // Special Registers
 3491 // Return a pointer value
 3492 operand rax_RegP()
 3493 %{
 3494   constraint(ALLOC_IN_RC(ptr_rax_reg));
 3495   match(RegP);
 3496   match(rRegP);
 3497 
 3498   format %{ %}
 3499   interface(REG_INTER);
 3500 %}
 3501 
 3502 // Special Registers
 3503 // Return a compressed pointer value
 3504 operand rax_RegN()
 3505 %{
 3506   constraint(ALLOC_IN_RC(int_rax_reg));
 3507   match(RegN);
 3508   match(rRegN);
 3509 
 3510   format %{ %}
 3511   interface(REG_INTER);
 3512 %}
 3513 
 3514 // Used in AtomicAdd
 3515 operand rbx_RegP()
 3516 %{
 3517   constraint(ALLOC_IN_RC(ptr_rbx_reg));
 3518   match(RegP);
 3519   match(rRegP);
 3520 
 3521   format %{ %}
 3522   interface(REG_INTER);
 3523 %}
 3524 
 3525 operand rsi_RegP()
 3526 %{
 3527   constraint(ALLOC_IN_RC(ptr_rsi_reg));
 3528   match(RegP);
 3529   match(rRegP);
 3530 
 3531   format %{ %}
 3532   interface(REG_INTER);
 3533 %}
 3534 
 3535 operand rbp_RegP()
 3536 %{
 3537   constraint(ALLOC_IN_RC(ptr_rbp_reg));
 3538   match(RegP);
 3539   match(rRegP);
 3540 
 3541   format %{ %}
 3542   interface(REG_INTER);
 3543 %}
 3544 
 3545 // Used in rep stosq
 3546 operand rdi_RegP()
 3547 %{
 3548   constraint(ALLOC_IN_RC(ptr_rdi_reg));
 3549   match(RegP);
 3550   match(rRegP);
 3551 
 3552   format %{ %}
 3553   interface(REG_INTER);
 3554 %}
 3555 
 3556 operand r15_RegP()
 3557 %{
 3558   constraint(ALLOC_IN_RC(ptr_r15_reg));
 3559   match(RegP);
 3560   match(rRegP);
 3561 
 3562   format %{ %}
 3563   interface(REG_INTER);
 3564 %}
 3565 
 3566 operand rRegL()
 3567 %{
 3568   constraint(ALLOC_IN_RC(long_reg));
 3569   match(RegL);
 3570   match(rax_RegL);
 3571   match(rdx_RegL);
 3572 
 3573   format %{ %}
 3574   interface(REG_INTER);
 3575 %}
 3576 
 3577 // Special Registers
 3578 operand no_rax_rdx_RegL()
 3579 %{
 3580   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3581   match(RegL);
 3582   match(rRegL);
 3583 
 3584   format %{ %}
 3585   interface(REG_INTER);
 3586 %}
 3587 
 3588 operand no_rax_RegL()
 3589 %{
 3590   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3591   match(RegL);
 3592   match(rRegL);
 3593   match(rdx_RegL);
 3594 
 3595   format %{ %}
 3596   interface(REG_INTER);
 3597 %}
 3598 
 3599 operand no_rcx_RegL()
 3600 %{
 3601   constraint(ALLOC_IN_RC(long_no_rcx_reg));
 3602   match(RegL);
 3603   match(rRegL);
 3604 
 3605   format %{ %}
 3606   interface(REG_INTER);
 3607 %}
 3608 
 3609 operand rax_RegL()
 3610 %{
 3611   constraint(ALLOC_IN_RC(long_rax_reg));
 3612   match(RegL);
 3613   match(rRegL);
 3614 
 3615   format %{ &quot;RAX&quot; %}
 3616   interface(REG_INTER);
 3617 %}
 3618 
 3619 operand rcx_RegL()
 3620 %{
 3621   constraint(ALLOC_IN_RC(long_rcx_reg));
 3622   match(RegL);
 3623   match(rRegL);
 3624 
 3625   format %{ %}
 3626   interface(REG_INTER);
 3627 %}
 3628 
 3629 operand rdx_RegL()
 3630 %{
 3631   constraint(ALLOC_IN_RC(long_rdx_reg));
 3632   match(RegL);
 3633   match(rRegL);
 3634 
 3635   format %{ %}
 3636   interface(REG_INTER);
 3637 %}
 3638 
 3639 // Flags register, used as output of compare instructions
 3640 operand rFlagsReg()
 3641 %{
 3642   constraint(ALLOC_IN_RC(int_flags));
 3643   match(RegFlags);
 3644 
 3645   format %{ &quot;RFLAGS&quot; %}
 3646   interface(REG_INTER);
 3647 %}
 3648 
 3649 // Flags register, used as output of FLOATING POINT compare instructions
 3650 operand rFlagsRegU()
 3651 %{
 3652   constraint(ALLOC_IN_RC(int_flags));
 3653   match(RegFlags);
 3654 
 3655   format %{ &quot;RFLAGS_U&quot; %}
 3656   interface(REG_INTER);
 3657 %}
 3658 
 3659 operand rFlagsRegUCF() %{
 3660   constraint(ALLOC_IN_RC(int_flags));
 3661   match(RegFlags);
 3662   predicate(false);
 3663 
 3664   format %{ &quot;RFLAGS_U_CF&quot; %}
 3665   interface(REG_INTER);
 3666 %}
 3667 
 3668 // Float register operands
 3669 operand regF() %{
 3670    constraint(ALLOC_IN_RC(float_reg));
 3671    match(RegF);
 3672 
 3673    format %{ %}
 3674    interface(REG_INTER);
 3675 %}
 3676 
 3677 // Float register operands
 3678 operand legRegF() %{
 3679    constraint(ALLOC_IN_RC(float_reg_legacy));
 3680    match(RegF);
 3681 
 3682    format %{ %}
 3683    interface(REG_INTER);
 3684 %}
 3685 
 3686 // Float register operands
 3687 operand vlRegF() %{
 3688    constraint(ALLOC_IN_RC(float_reg_vl));
 3689    match(RegF);
 3690 
 3691    format %{ %}
 3692    interface(REG_INTER);
 3693 %}
 3694 
 3695 // Double register operands
 3696 operand regD() %{
 3697    constraint(ALLOC_IN_RC(double_reg));
 3698    match(RegD);
 3699 
 3700    format %{ %}
 3701    interface(REG_INTER);
 3702 %}
 3703 
 3704 // Double register operands
 3705 operand legRegD() %{
 3706    constraint(ALLOC_IN_RC(double_reg_legacy));
 3707    match(RegD);
 3708 
 3709    format %{ %}
 3710    interface(REG_INTER);
 3711 %}
 3712 
 3713 // Double register operands
 3714 operand vlRegD() %{
 3715    constraint(ALLOC_IN_RC(double_reg_vl));
 3716    match(RegD);
 3717 
 3718    format %{ %}
 3719    interface(REG_INTER);
 3720 %}
 3721 
 3722 //----------Memory Operands----------------------------------------------------
 3723 // Direct Memory Operand
 3724 // operand direct(immP addr)
 3725 // %{
 3726 //   match(addr);
 3727 
 3728 //   format %{ &quot;[$addr]&quot; %}
 3729 //   interface(MEMORY_INTER) %{
 3730 //     base(0xFFFFFFFF);
 3731 //     index(0x4);
 3732 //     scale(0x0);
 3733 //     disp($addr);
 3734 //   %}
 3735 // %}
 3736 
 3737 // Indirect Memory Operand
 3738 operand indirect(any_RegP reg)
 3739 %{
 3740   constraint(ALLOC_IN_RC(ptr_reg));
 3741   match(reg);
 3742 
 3743   format %{ &quot;[$reg]&quot; %}
 3744   interface(MEMORY_INTER) %{
 3745     base($reg);
 3746     index(0x4);
 3747     scale(0x0);
 3748     disp(0x0);
 3749   %}
 3750 %}
 3751 
 3752 // Indirect Memory Plus Short Offset Operand
 3753 operand indOffset8(any_RegP reg, immL8 off)
 3754 %{
 3755   constraint(ALLOC_IN_RC(ptr_reg));
 3756   match(AddP reg off);
 3757 
 3758   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3759   interface(MEMORY_INTER) %{
 3760     base($reg);
 3761     index(0x4);
 3762     scale(0x0);
 3763     disp($off);
 3764   %}
 3765 %}
 3766 
 3767 // Indirect Memory Plus Long Offset Operand
 3768 operand indOffset32(any_RegP reg, immL32 off)
 3769 %{
 3770   constraint(ALLOC_IN_RC(ptr_reg));
 3771   match(AddP reg off);
 3772 
 3773   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3774   interface(MEMORY_INTER) %{
 3775     base($reg);
 3776     index(0x4);
 3777     scale(0x0);
 3778     disp($off);
 3779   %}
 3780 %}
 3781 
 3782 // Indirect Memory Plus Index Register Plus Offset Operand
 3783 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
 3784 %{
 3785   constraint(ALLOC_IN_RC(ptr_reg));
 3786   match(AddP (AddP reg lreg) off);
 3787 
 3788   op_cost(10);
 3789   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3790   interface(MEMORY_INTER) %{
 3791     base($reg);
 3792     index($lreg);
 3793     scale(0x0);
 3794     disp($off);
 3795   %}
 3796 %}
 3797 
 3798 // Indirect Memory Plus Index Register Plus Offset Operand
 3799 operand indIndex(any_RegP reg, rRegL lreg)
 3800 %{
 3801   constraint(ALLOC_IN_RC(ptr_reg));
 3802   match(AddP reg lreg);
 3803 
 3804   op_cost(10);
 3805   format %{&quot;[$reg + $lreg]&quot; %}
 3806   interface(MEMORY_INTER) %{
 3807     base($reg);
 3808     index($lreg);
 3809     scale(0x0);
 3810     disp(0x0);
 3811   %}
 3812 %}
 3813 
 3814 // Indirect Memory Times Scale Plus Index Register
 3815 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
 3816 %{
 3817   constraint(ALLOC_IN_RC(ptr_reg));
 3818   match(AddP reg (LShiftL lreg scale));
 3819 
 3820   op_cost(10);
 3821   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3822   interface(MEMORY_INTER) %{
 3823     base($reg);
 3824     index($lreg);
 3825     scale($scale);
 3826     disp(0x0);
 3827   %}
 3828 %}
 3829 
 3830 operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)
 3831 %{
 3832   constraint(ALLOC_IN_RC(ptr_reg));
 3833   predicate(n-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3834   match(AddP reg (LShiftL (ConvI2L idx) scale));
 3835 
 3836   op_cost(10);
 3837   format %{&quot;[$reg + pos $idx &lt;&lt; $scale]&quot; %}
 3838   interface(MEMORY_INTER) %{
 3839     base($reg);
 3840     index($idx);
 3841     scale($scale);
 3842     disp(0x0);
 3843   %}
 3844 %}
 3845 
 3846 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3847 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
 3848 %{
 3849   constraint(ALLOC_IN_RC(ptr_reg));
 3850   match(AddP (AddP reg (LShiftL lreg scale)) off);
 3851 
 3852   op_cost(10);
 3853   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3854   interface(MEMORY_INTER) %{
 3855     base($reg);
 3856     index($lreg);
 3857     scale($scale);
 3858     disp($off);
 3859   %}
 3860 %}
 3861 
 3862 // Indirect Memory Plus Positive Index Register Plus Offset Operand
 3863 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
 3864 %{
 3865   constraint(ALLOC_IN_RC(ptr_reg));
 3866   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3867   match(AddP (AddP reg (ConvI2L idx)) off);
 3868 
 3869   op_cost(10);
 3870   format %{&quot;[$reg + $off + $idx]&quot; %}
 3871   interface(MEMORY_INTER) %{
 3872     base($reg);
 3873     index($idx);
 3874     scale(0x0);
 3875     disp($off);
 3876   %}
 3877 %}
 3878 
 3879 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3880 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3881 %{
 3882   constraint(ALLOC_IN_RC(ptr_reg));
 3883   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3884   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3885 
 3886   op_cost(10);
 3887   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3888   interface(MEMORY_INTER) %{
 3889     base($reg);
 3890     index($idx);
 3891     scale($scale);
 3892     disp($off);
 3893   %}
 3894 %}
 3895 
 3896 // Indirect Narrow Oop Plus Offset Operand
 3897 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3898 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3899 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3900   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3901   constraint(ALLOC_IN_RC(ptr_reg));
 3902   match(AddP (DecodeN reg) off);
 3903 
 3904   op_cost(10);
 3905   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3906   interface(MEMORY_INTER) %{
 3907     base(0xc); // R12
 3908     index($reg);
 3909     scale(0x3);
 3910     disp($off);
 3911   %}
 3912 %}
 3913 
 3914 // Indirect Memory Operand
 3915 operand indirectNarrow(rRegN reg)
 3916 %{
 3917   predicate(CompressedOops::shift() == 0);
 3918   constraint(ALLOC_IN_RC(ptr_reg));
 3919   match(DecodeN reg);
 3920 
 3921   format %{ &quot;[$reg]&quot; %}
 3922   interface(MEMORY_INTER) %{
 3923     base($reg);
 3924     index(0x4);
 3925     scale(0x0);
 3926     disp(0x0);
 3927   %}
 3928 %}
 3929 
 3930 // Indirect Memory Plus Short Offset Operand
 3931 operand indOffset8Narrow(rRegN reg, immL8 off)
 3932 %{
 3933   predicate(CompressedOops::shift() == 0);
 3934   constraint(ALLOC_IN_RC(ptr_reg));
 3935   match(AddP (DecodeN reg) off);
 3936 
 3937   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3938   interface(MEMORY_INTER) %{
 3939     base($reg);
 3940     index(0x4);
 3941     scale(0x0);
 3942     disp($off);
 3943   %}
 3944 %}
 3945 
 3946 // Indirect Memory Plus Long Offset Operand
 3947 operand indOffset32Narrow(rRegN reg, immL32 off)
 3948 %{
 3949   predicate(CompressedOops::shift() == 0);
 3950   constraint(ALLOC_IN_RC(ptr_reg));
 3951   match(AddP (DecodeN reg) off);
 3952 
 3953   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3954   interface(MEMORY_INTER) %{
 3955     base($reg);
 3956     index(0x4);
 3957     scale(0x0);
 3958     disp($off);
 3959   %}
 3960 %}
 3961 
 3962 // Indirect Memory Plus Index Register Plus Offset Operand
 3963 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
 3964 %{
 3965   predicate(CompressedOops::shift() == 0);
 3966   constraint(ALLOC_IN_RC(ptr_reg));
 3967   match(AddP (AddP (DecodeN reg) lreg) off);
 3968 
 3969   op_cost(10);
 3970   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3971   interface(MEMORY_INTER) %{
 3972     base($reg);
 3973     index($lreg);
 3974     scale(0x0);
 3975     disp($off);
 3976   %}
 3977 %}
 3978 
 3979 // Indirect Memory Plus Index Register Plus Offset Operand
 3980 operand indIndexNarrow(rRegN reg, rRegL lreg)
 3981 %{
 3982   predicate(CompressedOops::shift() == 0);
 3983   constraint(ALLOC_IN_RC(ptr_reg));
 3984   match(AddP (DecodeN reg) lreg);
 3985 
 3986   op_cost(10);
 3987   format %{&quot;[$reg + $lreg]&quot; %}
 3988   interface(MEMORY_INTER) %{
 3989     base($reg);
 3990     index($lreg);
 3991     scale(0x0);
 3992     disp(0x0);
 3993   %}
 3994 %}
 3995 
 3996 // Indirect Memory Times Scale Plus Index Register
 3997 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
 3998 %{
 3999   predicate(CompressedOops::shift() == 0);
 4000   constraint(ALLOC_IN_RC(ptr_reg));
 4001   match(AddP (DecodeN reg) (LShiftL lreg scale));
 4002 
 4003   op_cost(10);
 4004   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 4005   interface(MEMORY_INTER) %{
 4006     base($reg);
 4007     index($lreg);
 4008     scale($scale);
 4009     disp(0x0);
 4010   %}
 4011 %}
 4012 
 4013 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4014 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
 4015 %{
 4016   predicate(CompressedOops::shift() == 0);
 4017   constraint(ALLOC_IN_RC(ptr_reg));
 4018   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
 4019 
 4020   op_cost(10);
 4021   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 4022   interface(MEMORY_INTER) %{
 4023     base($reg);
 4024     index($lreg);
 4025     scale($scale);
 4026     disp($off);
 4027   %}
 4028 %}
 4029 
 4030 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
 4031 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
 4032 %{
 4033   constraint(ALLOC_IN_RC(ptr_reg));
 4034   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4035   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
 4036 
 4037   op_cost(10);
 4038   format %{&quot;[$reg + $off + $idx]&quot; %}
 4039   interface(MEMORY_INTER) %{
 4040     base($reg);
 4041     index($idx);
 4042     scale(0x0);
 4043     disp($off);
 4044   %}
 4045 %}
 4046 
 4047 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 4048 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
 4049 %{
 4050   constraint(ALLOC_IN_RC(ptr_reg));
 4051   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4052   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
 4053 
 4054   op_cost(10);
 4055   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 4056   interface(MEMORY_INTER) %{
 4057     base($reg);
 4058     index($idx);
 4059     scale($scale);
 4060     disp($off);
 4061   %}
 4062 %}
 4063 
 4064 //----------Special Memory Operands--------------------------------------------
 4065 // Stack Slot Operand - This operand is used for loading and storing temporary
 4066 //                      values on the stack where a match requires a value to
 4067 //                      flow through memory.
 4068 operand stackSlotP(sRegP reg)
 4069 %{
 4070   constraint(ALLOC_IN_RC(stack_slots));
 4071   // No match rule because this operand is only generated in matching
 4072 
 4073   format %{ &quot;[$reg]&quot; %}
 4074   interface(MEMORY_INTER) %{
 4075     base(0x4);   // RSP
 4076     index(0x4);  // No Index
 4077     scale(0x0);  // No Scale
 4078     disp($reg);  // Stack Offset
 4079   %}
 4080 %}
 4081 
 4082 operand stackSlotI(sRegI reg)
 4083 %{
 4084   constraint(ALLOC_IN_RC(stack_slots));
 4085   // No match rule because this operand is only generated in matching
 4086 
 4087   format %{ &quot;[$reg]&quot; %}
 4088   interface(MEMORY_INTER) %{
 4089     base(0x4);   // RSP
 4090     index(0x4);  // No Index
 4091     scale(0x0);  // No Scale
 4092     disp($reg);  // Stack Offset
 4093   %}
 4094 %}
 4095 
 4096 operand stackSlotF(sRegF reg)
 4097 %{
 4098   constraint(ALLOC_IN_RC(stack_slots));
 4099   // No match rule because this operand is only generated in matching
 4100 
 4101   format %{ &quot;[$reg]&quot; %}
 4102   interface(MEMORY_INTER) %{
 4103     base(0x4);   // RSP
 4104     index(0x4);  // No Index
 4105     scale(0x0);  // No Scale
 4106     disp($reg);  // Stack Offset
 4107   %}
 4108 %}
 4109 
 4110 operand stackSlotD(sRegD reg)
 4111 %{
 4112   constraint(ALLOC_IN_RC(stack_slots));
 4113   // No match rule because this operand is only generated in matching
 4114 
 4115   format %{ &quot;[$reg]&quot; %}
 4116   interface(MEMORY_INTER) %{
 4117     base(0x4);   // RSP
 4118     index(0x4);  // No Index
 4119     scale(0x0);  // No Scale
 4120     disp($reg);  // Stack Offset
 4121   %}
 4122 %}
 4123 operand stackSlotL(sRegL reg)
 4124 %{
 4125   constraint(ALLOC_IN_RC(stack_slots));
 4126   // No match rule because this operand is only generated in matching
 4127 
 4128   format %{ &quot;[$reg]&quot; %}
 4129   interface(MEMORY_INTER) %{
 4130     base(0x4);   // RSP
 4131     index(0x4);  // No Index
 4132     scale(0x0);  // No Scale
 4133     disp($reg);  // Stack Offset
 4134   %}
 4135 %}
 4136 
 4137 //----------Conditional Branch Operands----------------------------------------
 4138 // Comparison Op  - This is the operation of the comparison, and is limited to
 4139 //                  the following set of codes:
 4140 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4141 //
 4142 // Other attributes of the comparison, such as unsignedness, are specified
 4143 // by the comparison instruction that sets a condition code flags register.
 4144 // That result is represented by a flags operand whose subtype is appropriate
 4145 // to the unsignedness (etc.) of the comparison.
 4146 //
 4147 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4148 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4149 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4150 
 4151 // Comparision Code
 4152 operand cmpOp()
 4153 %{
 4154   match(Bool);
 4155 
 4156   format %{ &quot;&quot; %}
 4157   interface(COND_INTER) %{
 4158     equal(0x4, &quot;e&quot;);
 4159     not_equal(0x5, &quot;ne&quot;);
 4160     less(0xC, &quot;l&quot;);
 4161     greater_equal(0xD, &quot;ge&quot;);
 4162     less_equal(0xE, &quot;le&quot;);
 4163     greater(0xF, &quot;g&quot;);
 4164     overflow(0x0, &quot;o&quot;);
 4165     no_overflow(0x1, &quot;no&quot;);
 4166   %}
 4167 %}
 4168 
 4169 // Comparison Code, unsigned compare.  Used by FP also, with
 4170 // C2 (unordered) turned into GT or LT already.  The other bits
 4171 // C0 and C3 are turned into Carry &amp; Zero flags.
 4172 operand cmpOpU()
 4173 %{
 4174   match(Bool);
 4175 
 4176   format %{ &quot;&quot; %}
 4177   interface(COND_INTER) %{
 4178     equal(0x4, &quot;e&quot;);
 4179     not_equal(0x5, &quot;ne&quot;);
 4180     less(0x2, &quot;b&quot;);
 4181     greater_equal(0x3, &quot;nb&quot;);
 4182     less_equal(0x6, &quot;be&quot;);
 4183     greater(0x7, &quot;nbe&quot;);
 4184     overflow(0x0, &quot;o&quot;);
 4185     no_overflow(0x1, &quot;no&quot;);
 4186   %}
 4187 %}
 4188 
 4189 
 4190 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4191 operand cmpOpUCF() %{
 4192   match(Bool);
 4193   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4194             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4195             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4196             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4197   format %{ &quot;&quot; %}
 4198   interface(COND_INTER) %{
 4199     equal(0x4, &quot;e&quot;);
 4200     not_equal(0x5, &quot;ne&quot;);
 4201     less(0x2, &quot;b&quot;);
 4202     greater_equal(0x3, &quot;nb&quot;);
 4203     less_equal(0x6, &quot;be&quot;);
 4204     greater(0x7, &quot;nbe&quot;);
 4205     overflow(0x0, &quot;o&quot;);
 4206     no_overflow(0x1, &quot;no&quot;);
 4207   %}
 4208 %}
 4209 
 4210 
 4211 // Floating comparisons that can be fixed up with extra conditional jumps
 4212 operand cmpOpUCF2() %{
 4213   match(Bool);
 4214   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4215             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4216   format %{ &quot;&quot; %}
 4217   interface(COND_INTER) %{
 4218     equal(0x4, &quot;e&quot;);
 4219     not_equal(0x5, &quot;ne&quot;);
 4220     less(0x2, &quot;b&quot;);
 4221     greater_equal(0x3, &quot;nb&quot;);
 4222     less_equal(0x6, &quot;be&quot;);
 4223     greater(0x7, &quot;nbe&quot;);
 4224     overflow(0x0, &quot;o&quot;);
 4225     no_overflow(0x1, &quot;no&quot;);
 4226   %}
 4227 %}
 4228 
 4229 //----------OPERAND CLASSES----------------------------------------------------
 4230 // Operand Classes are groups of operands that are used as to simplify
 4231 // instruction definitions by not requiring the AD writer to specify separate
 4232 // instructions for every form of operand when the instruction accepts
 4233 // multiple operand types with the same basic encoding and format.  The classic
 4234 // case of this is memory operands.
 4235 
 4236 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4237                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
 4238                indCompressedOopOffset,
 4239                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4240                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4241                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4242 
 4243 //----------PIPELINE-----------------------------------------------------------
 4244 // Rules which define the behavior of the target architectures pipeline.
 4245 pipeline %{
 4246 
 4247 //----------ATTRIBUTES---------------------------------------------------------
 4248 attributes %{
 4249   variable_size_instructions;        // Fixed size instructions
 4250   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4251   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4252   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4253   instruction_fetch_units = 1;       // of 16 bytes
 4254 
 4255   // List of nop instructions
 4256   nops( MachNop );
 4257 %}
 4258 
 4259 //----------RESOURCES----------------------------------------------------------
 4260 // Resources are the functional units available to the machine
 4261 
 4262 // Generic P2/P3 pipeline
 4263 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4264 // 3 instructions decoded per cycle.
 4265 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4266 // 3 ALU op, only ALU0 handles mul instructions.
 4267 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4268            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
 4269            BR, FPU,
 4270            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
 4271 
 4272 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4273 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4274 
 4275 // Generic P2/P3 pipeline
 4276 pipe_desc(S0, S1, S2, S3, S4, S5);
 4277 
 4278 //----------PIPELINE CLASSES---------------------------------------------------
 4279 // Pipeline Classes describe the stages in which input and output are
 4280 // referenced by the hardware pipeline.
 4281 
 4282 // Naming convention: ialu or fpu
 4283 // Then: _reg
 4284 // Then: _reg if there is a 2nd register
 4285 // Then: _long if it&#39;s a pair of instructions implementing a long
 4286 // Then: _fat if it requires the big decoder
 4287 //   Or: _mem if it requires the big decoder and a memory unit.
 4288 
 4289 // Integer ALU reg operation
 4290 pipe_class ialu_reg(rRegI dst)
 4291 %{
 4292     single_instruction;
 4293     dst    : S4(write);
 4294     dst    : S3(read);
 4295     DECODE : S0;        // any decoder
 4296     ALU    : S3;        // any alu
 4297 %}
 4298 
 4299 // Long ALU reg operation
 4300 pipe_class ialu_reg_long(rRegL dst)
 4301 %{
 4302     instruction_count(2);
 4303     dst    : S4(write);
 4304     dst    : S3(read);
 4305     DECODE : S0(2);     // any 2 decoders
 4306     ALU    : S3(2);     // both alus
 4307 %}
 4308 
 4309 // Integer ALU reg operation using big decoder
 4310 pipe_class ialu_reg_fat(rRegI dst)
 4311 %{
 4312     single_instruction;
 4313     dst    : S4(write);
 4314     dst    : S3(read);
 4315     D0     : S0;        // big decoder only
 4316     ALU    : S3;        // any alu
 4317 %}
 4318 
 4319 // Long ALU reg operation using big decoder
 4320 pipe_class ialu_reg_long_fat(rRegL dst)
 4321 %{
 4322     instruction_count(2);
 4323     dst    : S4(write);
 4324     dst    : S3(read);
 4325     D0     : S0(2);     // big decoder only; twice
 4326     ALU    : S3(2);     // any 2 alus
 4327 %}
 4328 
 4329 // Integer ALU reg-reg operation
 4330 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
 4331 %{
 4332     single_instruction;
 4333     dst    : S4(write);
 4334     src    : S3(read);
 4335     DECODE : S0;        // any decoder
 4336     ALU    : S3;        // any alu
 4337 %}
 4338 
 4339 // Long ALU reg-reg operation
 4340 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
 4341 %{
 4342     instruction_count(2);
 4343     dst    : S4(write);
 4344     src    : S3(read);
 4345     DECODE : S0(2);     // any 2 decoders
 4346     ALU    : S3(2);     // both alus
 4347 %}
 4348 
 4349 // Integer ALU reg-reg operation
 4350 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
 4351 %{
 4352     single_instruction;
 4353     dst    : S4(write);
 4354     src    : S3(read);
 4355     D0     : S0;        // big decoder only
 4356     ALU    : S3;        // any alu
 4357 %}
 4358 
 4359 // Long ALU reg-reg operation
 4360 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
 4361 %{
 4362     instruction_count(2);
 4363     dst    : S4(write);
 4364     src    : S3(read);
 4365     D0     : S0(2);     // big decoder only; twice
 4366     ALU    : S3(2);     // both alus
 4367 %}
 4368 
 4369 // Integer ALU reg-mem operation
 4370 pipe_class ialu_reg_mem(rRegI dst, memory mem)
 4371 %{
 4372     single_instruction;
 4373     dst    : S5(write);
 4374     mem    : S3(read);
 4375     D0     : S0;        // big decoder only
 4376     ALU    : S4;        // any alu
 4377     MEM    : S3;        // any mem
 4378 %}
 4379 
 4380 // Integer mem operation (prefetch)
 4381 pipe_class ialu_mem(memory mem)
 4382 %{
 4383     single_instruction;
 4384     mem    : S3(read);
 4385     D0     : S0;        // big decoder only
 4386     MEM    : S3;        // any mem
 4387 %}
 4388 
 4389 // Integer Store to Memory
 4390 pipe_class ialu_mem_reg(memory mem, rRegI src)
 4391 %{
 4392     single_instruction;
 4393     mem    : S3(read);
 4394     src    : S5(read);
 4395     D0     : S0;        // big decoder only
 4396     ALU    : S4;        // any alu
 4397     MEM    : S3;
 4398 %}
 4399 
 4400 // // Long Store to Memory
 4401 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
 4402 // %{
 4403 //     instruction_count(2);
 4404 //     mem    : S3(read);
 4405 //     src    : S5(read);
 4406 //     D0     : S0(2);          // big decoder only; twice
 4407 //     ALU    : S4(2);     // any 2 alus
 4408 //     MEM    : S3(2);  // Both mems
 4409 // %}
 4410 
 4411 // Integer Store to Memory
 4412 pipe_class ialu_mem_imm(memory mem)
 4413 %{
 4414     single_instruction;
 4415     mem    : S3(read);
 4416     D0     : S0;        // big decoder only
 4417     ALU    : S4;        // any alu
 4418     MEM    : S3;
 4419 %}
 4420 
 4421 // Integer ALU0 reg-reg operation
 4422 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
 4423 %{
 4424     single_instruction;
 4425     dst    : S4(write);
 4426     src    : S3(read);
 4427     D0     : S0;        // Big decoder only
 4428     ALU0   : S3;        // only alu0
 4429 %}
 4430 
 4431 // Integer ALU0 reg-mem operation
 4432 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
 4433 %{
 4434     single_instruction;
 4435     dst    : S5(write);
 4436     mem    : S3(read);
 4437     D0     : S0;        // big decoder only
 4438     ALU0   : S4;        // ALU0 only
 4439     MEM    : S3;        // any mem
 4440 %}
 4441 
 4442 // Integer ALU reg-reg operation
 4443 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
 4444 %{
 4445     single_instruction;
 4446     cr     : S4(write);
 4447     src1   : S3(read);
 4448     src2   : S3(read);
 4449     DECODE : S0;        // any decoder
 4450     ALU    : S3;        // any alu
 4451 %}
 4452 
 4453 // Integer ALU reg-imm operation
 4454 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
 4455 %{
 4456     single_instruction;
 4457     cr     : S4(write);
 4458     src1   : S3(read);
 4459     DECODE : S0;        // any decoder
 4460     ALU    : S3;        // any alu
 4461 %}
 4462 
 4463 // Integer ALU reg-mem operation
 4464 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
 4465 %{
 4466     single_instruction;
 4467     cr     : S4(write);
 4468     src1   : S3(read);
 4469     src2   : S3(read);
 4470     D0     : S0;        // big decoder only
 4471     ALU    : S4;        // any alu
 4472     MEM    : S3;
 4473 %}
 4474 
 4475 // Conditional move reg-reg
 4476 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
 4477 %{
 4478     instruction_count(4);
 4479     y      : S4(read);
 4480     q      : S3(read);
 4481     p      : S3(read);
 4482     DECODE : S0(4);     // any decoder
 4483 %}
 4484 
 4485 // Conditional move reg-reg
 4486 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
 4487 %{
 4488     single_instruction;
 4489     dst    : S4(write);
 4490     src    : S3(read);
 4491     cr     : S3(read);
 4492     DECODE : S0;        // any decoder
 4493 %}
 4494 
 4495 // Conditional move reg-mem
 4496 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
 4497 %{
 4498     single_instruction;
 4499     dst    : S4(write);
 4500     src    : S3(read);
 4501     cr     : S3(read);
 4502     DECODE : S0;        // any decoder
 4503     MEM    : S3;
 4504 %}
 4505 
 4506 // Conditional move reg-reg long
 4507 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
 4508 %{
 4509     single_instruction;
 4510     dst    : S4(write);
 4511     src    : S3(read);
 4512     cr     : S3(read);
 4513     DECODE : S0(2);     // any 2 decoders
 4514 %}
 4515 
 4516 // XXX
 4517 // // Conditional move double reg-reg
 4518 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
 4519 // %{
 4520 //     single_instruction;
 4521 //     dst    : S4(write);
 4522 //     src    : S3(read);
 4523 //     cr     : S3(read);
 4524 //     DECODE : S0;     // any decoder
 4525 // %}
 4526 
 4527 // Float reg-reg operation
 4528 pipe_class fpu_reg(regD dst)
 4529 %{
 4530     instruction_count(2);
 4531     dst    : S3(read);
 4532     DECODE : S0(2);     // any 2 decoders
 4533     FPU    : S3;
 4534 %}
 4535 
 4536 // Float reg-reg operation
 4537 pipe_class fpu_reg_reg(regD dst, regD src)
 4538 %{
 4539     instruction_count(2);
 4540     dst    : S4(write);
 4541     src    : S3(read);
 4542     DECODE : S0(2);     // any 2 decoders
 4543     FPU    : S3;
 4544 %}
 4545 
 4546 // Float reg-reg operation
 4547 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
 4548 %{
 4549     instruction_count(3);
 4550     dst    : S4(write);
 4551     src1   : S3(read);
 4552     src2   : S3(read);
 4553     DECODE : S0(3);     // any 3 decoders
 4554     FPU    : S3(2);
 4555 %}
 4556 
 4557 // Float reg-reg operation
 4558 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
 4559 %{
 4560     instruction_count(4);
 4561     dst    : S4(write);
 4562     src1   : S3(read);
 4563     src2   : S3(read);
 4564     src3   : S3(read);
 4565     DECODE : S0(4);     // any 3 decoders
 4566     FPU    : S3(2);
 4567 %}
 4568 
 4569 // Float reg-reg operation
 4570 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
 4571 %{
 4572     instruction_count(4);
 4573     dst    : S4(write);
 4574     src1   : S3(read);
 4575     src2   : S3(read);
 4576     src3   : S3(read);
 4577     DECODE : S1(3);     // any 3 decoders
 4578     D0     : S0;        // Big decoder only
 4579     FPU    : S3(2);
 4580     MEM    : S3;
 4581 %}
 4582 
 4583 // Float reg-mem operation
 4584 pipe_class fpu_reg_mem(regD dst, memory mem)
 4585 %{
 4586     instruction_count(2);
 4587     dst    : S5(write);
 4588     mem    : S3(read);
 4589     D0     : S0;        // big decoder only
 4590     DECODE : S1;        // any decoder for FPU POP
 4591     FPU    : S4;
 4592     MEM    : S3;        // any mem
 4593 %}
 4594 
 4595 // Float reg-mem operation
 4596 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
 4597 %{
 4598     instruction_count(3);
 4599     dst    : S5(write);
 4600     src1   : S3(read);
 4601     mem    : S3(read);
 4602     D0     : S0;        // big decoder only
 4603     DECODE : S1(2);     // any decoder for FPU POP
 4604     FPU    : S4;
 4605     MEM    : S3;        // any mem
 4606 %}
 4607 
 4608 // Float mem-reg operation
 4609 pipe_class fpu_mem_reg(memory mem, regD src)
 4610 %{
 4611     instruction_count(2);
 4612     src    : S5(read);
 4613     mem    : S3(read);
 4614     DECODE : S0;        // any decoder for FPU PUSH
 4615     D0     : S1;        // big decoder only
 4616     FPU    : S4;
 4617     MEM    : S3;        // any mem
 4618 %}
 4619 
 4620 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
 4621 %{
 4622     instruction_count(3);
 4623     src1   : S3(read);
 4624     src2   : S3(read);
 4625     mem    : S3(read);
 4626     DECODE : S0(2);     // any decoder for FPU PUSH
 4627     D0     : S1;        // big decoder only
 4628     FPU    : S4;
 4629     MEM    : S3;        // any mem
 4630 %}
 4631 
 4632 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
 4633 %{
 4634     instruction_count(3);
 4635     src1   : S3(read);
 4636     src2   : S3(read);
 4637     mem    : S4(read);
 4638     DECODE : S0;        // any decoder for FPU PUSH
 4639     D0     : S0(2);     // big decoder only
 4640     FPU    : S4;
 4641     MEM    : S3(2);     // any mem
 4642 %}
 4643 
 4644 pipe_class fpu_mem_mem(memory dst, memory src1)
 4645 %{
 4646     instruction_count(2);
 4647     src1   : S3(read);
 4648     dst    : S4(read);
 4649     D0     : S0(2);     // big decoder only
 4650     MEM    : S3(2);     // any mem
 4651 %}
 4652 
 4653 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
 4654 %{
 4655     instruction_count(3);
 4656     src1   : S3(read);
 4657     src2   : S3(read);
 4658     dst    : S4(read);
 4659     D0     : S0(3);     // big decoder only
 4660     FPU    : S4;
 4661     MEM    : S3(3);     // any mem
 4662 %}
 4663 
 4664 pipe_class fpu_mem_reg_con(memory mem, regD src1)
 4665 %{
 4666     instruction_count(3);
 4667     src1   : S4(read);
 4668     mem    : S4(read);
 4669     DECODE : S0;        // any decoder for FPU PUSH
 4670     D0     : S0(2);     // big decoder only
 4671     FPU    : S4;
 4672     MEM    : S3(2);     // any mem
 4673 %}
 4674 
 4675 // Float load constant
 4676 pipe_class fpu_reg_con(regD dst)
 4677 %{
 4678     instruction_count(2);
 4679     dst    : S5(write);
 4680     D0     : S0;        // big decoder only for the load
 4681     DECODE : S1;        // any decoder for FPU POP
 4682     FPU    : S4;
 4683     MEM    : S3;        // any mem
 4684 %}
 4685 
 4686 // Float load constant
 4687 pipe_class fpu_reg_reg_con(regD dst, regD src)
 4688 %{
 4689     instruction_count(3);
 4690     dst    : S5(write);
 4691     src    : S3(read);
 4692     D0     : S0;        // big decoder only for the load
 4693     DECODE : S1(2);     // any decoder for FPU POP
 4694     FPU    : S4;
 4695     MEM    : S3;        // any mem
 4696 %}
 4697 
 4698 // UnConditional branch
 4699 pipe_class pipe_jmp(label labl)
 4700 %{
 4701     single_instruction;
 4702     BR   : S3;
 4703 %}
 4704 
 4705 // Conditional branch
 4706 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
 4707 %{
 4708     single_instruction;
 4709     cr    : S1(read);
 4710     BR    : S3;
 4711 %}
 4712 
 4713 // Allocation idiom
 4714 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
 4715 %{
 4716     instruction_count(1); force_serialization;
 4717     fixed_latency(6);
 4718     heap_ptr : S3(read);
 4719     DECODE   : S0(3);
 4720     D0       : S2;
 4721     MEM      : S3;
 4722     ALU      : S3(2);
 4723     dst      : S5(write);
 4724     BR       : S5;
 4725 %}
 4726 
 4727 // Generic big/slow expanded idiom
 4728 pipe_class pipe_slow()
 4729 %{
 4730     instruction_count(10); multiple_bundles; force_serialization;
 4731     fixed_latency(100);
 4732     D0  : S0(2);
 4733     MEM : S3(2);
 4734 %}
 4735 
 4736 // The real do-nothing guy
 4737 pipe_class empty()
 4738 %{
 4739     instruction_count(0);
 4740 %}
 4741 
 4742 // Define the class for the Nop node
 4743 define
 4744 %{
 4745    MachNop = empty;
 4746 %}
 4747 
 4748 %}
 4749 
 4750 //----------INSTRUCTIONS-------------------------------------------------------
 4751 //
 4752 // match      -- States which machine-independent subtree may be replaced
 4753 //               by this instruction.
 4754 // ins_cost   -- The estimated cost of this instruction is used by instruction
 4755 //               selection to identify a minimum cost tree of machine
 4756 //               instructions that matches a tree of machine-independent
 4757 //               instructions.
 4758 // format     -- A string providing the disassembly for this instruction.
 4759 //               The value of an instruction&#39;s operand may be inserted
 4760 //               by referring to it with a &#39;$&#39; prefix.
 4761 // opcode     -- Three instruction opcodes may be provided.  These are referred
 4762 //               to within an encode class as $primary, $secondary, and $tertiary
 4763 //               rrspectively.  The primary opcode is commonly used to
 4764 //               indicate the type of machine instruction, while secondary
 4765 //               and tertiary are often used for prefix options or addressing
 4766 //               modes.
 4767 // ins_encode -- A list of encode classes with parameters. The encode class
 4768 //               name must have been defined in an &#39;enc_class&#39; specification
 4769 //               in the encode section of the architecture description.
 4770 
 4771 
 4772 //----------Load/Store/Move Instructions---------------------------------------
 4773 //----------Load Instructions--------------------------------------------------
 4774 
 4775 // Load Byte (8 bit signed)
 4776 instruct loadB(rRegI dst, memory mem)
 4777 %{
 4778   match(Set dst (LoadB mem));
 4779 
 4780   ins_cost(125);
 4781   format %{ &quot;movsbl  $dst, $mem\t# byte&quot; %}
 4782 
 4783   ins_encode %{
 4784     __ movsbl($dst$$Register, $mem$$Address);
 4785   %}
 4786 
 4787   ins_pipe(ialu_reg_mem);
 4788 %}
 4789 
 4790 // Load Byte (8 bit signed) into Long Register
 4791 instruct loadB2L(rRegL dst, memory mem)
 4792 %{
 4793   match(Set dst (ConvI2L (LoadB mem)));
 4794 
 4795   ins_cost(125);
 4796   format %{ &quot;movsbq  $dst, $mem\t# byte -&gt; long&quot; %}
 4797 
 4798   ins_encode %{
 4799     __ movsbq($dst$$Register, $mem$$Address);
 4800   %}
 4801 
 4802   ins_pipe(ialu_reg_mem);
 4803 %}
 4804 
 4805 // Load Unsigned Byte (8 bit UNsigned)
 4806 instruct loadUB(rRegI dst, memory mem)
 4807 %{
 4808   match(Set dst (LoadUB mem));
 4809 
 4810   ins_cost(125);
 4811   format %{ &quot;movzbl  $dst, $mem\t# ubyte&quot; %}
 4812 
 4813   ins_encode %{
 4814     __ movzbl($dst$$Register, $mem$$Address);
 4815   %}
 4816 
 4817   ins_pipe(ialu_reg_mem);
 4818 %}
 4819 
 4820 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 4821 instruct loadUB2L(rRegL dst, memory mem)
 4822 %{
 4823   match(Set dst (ConvI2L (LoadUB mem)));
 4824 
 4825   ins_cost(125);
 4826   format %{ &quot;movzbq  $dst, $mem\t# ubyte -&gt; long&quot; %}
 4827 
 4828   ins_encode %{
 4829     __ movzbq($dst$$Register, $mem$$Address);
 4830   %}
 4831 
 4832   ins_pipe(ialu_reg_mem);
 4833 %}
 4834 
 4835 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 4836 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4837   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 4838   effect(KILL cr);
 4839 
 4840   format %{ &quot;movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 4841             &quot;andl    $dst, right_n_bits($mask, 8)&quot; %}
 4842   ins_encode %{
 4843     Register Rdst = $dst$$Register;
 4844     __ movzbq(Rdst, $mem$$Address);
 4845     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 4846   %}
 4847   ins_pipe(ialu_reg_mem);
 4848 %}
 4849 
 4850 // Load Short (16 bit signed)
 4851 instruct loadS(rRegI dst, memory mem)
 4852 %{
 4853   match(Set dst (LoadS mem));
 4854 
 4855   ins_cost(125);
 4856   format %{ &quot;movswl $dst, $mem\t# short&quot; %}
 4857 
 4858   ins_encode %{
 4859     __ movswl($dst$$Register, $mem$$Address);
 4860   %}
 4861 
 4862   ins_pipe(ialu_reg_mem);
 4863 %}
 4864 
 4865 // Load Short (16 bit signed) to Byte (8 bit signed)
 4866 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4867   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 4868 
 4869   ins_cost(125);
 4870   format %{ &quot;movsbl $dst, $mem\t# short -&gt; byte&quot; %}
 4871   ins_encode %{
 4872     __ movsbl($dst$$Register, $mem$$Address);
 4873   %}
 4874   ins_pipe(ialu_reg_mem);
 4875 %}
 4876 
 4877 // Load Short (16 bit signed) into Long Register
 4878 instruct loadS2L(rRegL dst, memory mem)
 4879 %{
 4880   match(Set dst (ConvI2L (LoadS mem)));
 4881 
 4882   ins_cost(125);
 4883   format %{ &quot;movswq $dst, $mem\t# short -&gt; long&quot; %}
 4884 
 4885   ins_encode %{
 4886     __ movswq($dst$$Register, $mem$$Address);
 4887   %}
 4888 
 4889   ins_pipe(ialu_reg_mem);
 4890 %}
 4891 
 4892 // Load Unsigned Short/Char (16 bit UNsigned)
 4893 instruct loadUS(rRegI dst, memory mem)
 4894 %{
 4895   match(Set dst (LoadUS mem));
 4896 
 4897   ins_cost(125);
 4898   format %{ &quot;movzwl  $dst, $mem\t# ushort/char&quot; %}
 4899 
 4900   ins_encode %{
 4901     __ movzwl($dst$$Register, $mem$$Address);
 4902   %}
 4903 
 4904   ins_pipe(ialu_reg_mem);
 4905 %}
 4906 
 4907 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 4908 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4909   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 4910 
 4911   ins_cost(125);
 4912   format %{ &quot;movsbl $dst, $mem\t# ushort -&gt; byte&quot; %}
 4913   ins_encode %{
 4914     __ movsbl($dst$$Register, $mem$$Address);
 4915   %}
 4916   ins_pipe(ialu_reg_mem);
 4917 %}
 4918 
 4919 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 4920 instruct loadUS2L(rRegL dst, memory mem)
 4921 %{
 4922   match(Set dst (ConvI2L (LoadUS mem)));
 4923 
 4924   ins_cost(125);
 4925   format %{ &quot;movzwq  $dst, $mem\t# ushort/char -&gt; long&quot; %}
 4926 
 4927   ins_encode %{
 4928     __ movzwq($dst$$Register, $mem$$Address);
 4929   %}
 4930 
 4931   ins_pipe(ialu_reg_mem);
 4932 %}
 4933 
 4934 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 4935 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 4936   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4937 
 4938   format %{ &quot;movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long&quot; %}
 4939   ins_encode %{
 4940     __ movzbq($dst$$Register, $mem$$Address);
 4941   %}
 4942   ins_pipe(ialu_reg_mem);
 4943 %}
 4944 
 4945 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
 4946 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4947   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4948   effect(KILL cr);
 4949 
 4950   format %{ &quot;movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 4951             &quot;andl    $dst, right_n_bits($mask, 16)&quot; %}
 4952   ins_encode %{
 4953     Register Rdst = $dst$$Register;
 4954     __ movzwq(Rdst, $mem$$Address);
 4955     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 4956   %}
 4957   ins_pipe(ialu_reg_mem);
 4958 %}
 4959 
 4960 // Load Integer
 4961 instruct loadI(rRegI dst, memory mem)
 4962 %{
 4963   match(Set dst (LoadI mem));
 4964 
 4965   ins_cost(125);
 4966   format %{ &quot;movl    $dst, $mem\t# int&quot; %}
 4967 
 4968   ins_encode %{
 4969     __ movl($dst$$Register, $mem$$Address);
 4970   %}
 4971 
 4972   ins_pipe(ialu_reg_mem);
 4973 %}
 4974 
 4975 // Load Integer (32 bit signed) to Byte (8 bit signed)
 4976 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4977   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 4978 
 4979   ins_cost(125);
 4980   format %{ &quot;movsbl  $dst, $mem\t# int -&gt; byte&quot; %}
 4981   ins_encode %{
 4982     __ movsbl($dst$$Register, $mem$$Address);
 4983   %}
 4984   ins_pipe(ialu_reg_mem);
 4985 %}
 4986 
 4987 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 4988 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 4989   match(Set dst (AndI (LoadI mem) mask));
 4990 
 4991   ins_cost(125);
 4992   format %{ &quot;movzbl  $dst, $mem\t# int -&gt; ubyte&quot; %}
 4993   ins_encode %{
 4994     __ movzbl($dst$$Register, $mem$$Address);
 4995   %}
 4996   ins_pipe(ialu_reg_mem);
 4997 %}
 4998 
 4999 // Load Integer (32 bit signed) to Short (16 bit signed)
 5000 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 5001   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 5002 
 5003   ins_cost(125);
 5004   format %{ &quot;movswl  $dst, $mem\t# int -&gt; short&quot; %}
 5005   ins_encode %{
 5006     __ movswl($dst$$Register, $mem$$Address);
 5007   %}
 5008   ins_pipe(ialu_reg_mem);
 5009 %}
 5010 
 5011 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 5012 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 5013   match(Set dst (AndI (LoadI mem) mask));
 5014 
 5015   ins_cost(125);
 5016   format %{ &quot;movzwl  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 5017   ins_encode %{
 5018     __ movzwl($dst$$Register, $mem$$Address);
 5019   %}
 5020   ins_pipe(ialu_reg_mem);
 5021 %}
 5022 
 5023 // Load Integer into Long Register
 5024 instruct loadI2L(rRegL dst, memory mem)
 5025 %{
 5026   match(Set dst (ConvI2L (LoadI mem)));
 5027 
 5028   ins_cost(125);
 5029   format %{ &quot;movslq  $dst, $mem\t# int -&gt; long&quot; %}
 5030 
 5031   ins_encode %{
 5032     __ movslq($dst$$Register, $mem$$Address);
 5033   %}
 5034 
 5035   ins_pipe(ialu_reg_mem);
 5036 %}
 5037 
 5038 // Load Integer with mask 0xFF into Long Register
 5039 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 5040   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5041 
 5042   format %{ &quot;movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long&quot; %}
 5043   ins_encode %{
 5044     __ movzbq($dst$$Register, $mem$$Address);
 5045   %}
 5046   ins_pipe(ialu_reg_mem);
 5047 %}
 5048 
 5049 // Load Integer with mask 0xFFFF into Long Register
 5050 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
 5051   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5052 
 5053   format %{ &quot;movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long&quot; %}
 5054   ins_encode %{
 5055     __ movzwq($dst$$Register, $mem$$Address);
 5056   %}
 5057   ins_pipe(ialu_reg_mem);
 5058 %}
 5059 
 5060 // Load Integer with a 31-bit mask into Long Register
 5061 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
 5062   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5063   effect(KILL cr);
 5064 
 5065   format %{ &quot;movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5066             &quot;andl    $dst, $mask&quot; %}
 5067   ins_encode %{
 5068     Register Rdst = $dst$$Register;
 5069     __ movl(Rdst, $mem$$Address);
 5070     __ andl(Rdst, $mask$$constant);
 5071   %}
 5072   ins_pipe(ialu_reg_mem);
 5073 %}
 5074 
 5075 // Load Unsigned Integer into Long Register
 5076 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
 5077 %{
 5078   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5079 
 5080   ins_cost(125);
 5081   format %{ &quot;movl    $dst, $mem\t# uint -&gt; long&quot; %}
 5082 
 5083   ins_encode %{
 5084     __ movl($dst$$Register, $mem$$Address);
 5085   %}
 5086 
 5087   ins_pipe(ialu_reg_mem);
 5088 %}
 5089 
 5090 // Load Long
 5091 instruct loadL(rRegL dst, memory mem)
 5092 %{
 5093   match(Set dst (LoadL mem));
 5094 
 5095   ins_cost(125);
 5096   format %{ &quot;movq    $dst, $mem\t# long&quot; %}
 5097 
 5098   ins_encode %{
 5099     __ movq($dst$$Register, $mem$$Address);
 5100   %}
 5101 
 5102   ins_pipe(ialu_reg_mem); // XXX
 5103 %}
 5104 
 5105 // Load Range
 5106 instruct loadRange(rRegI dst, memory mem)
 5107 %{
 5108   match(Set dst (LoadRange mem));
 5109 
 5110   ins_cost(125); // XXX
 5111   format %{ &quot;movl    $dst, $mem\t# range&quot; %}
 5112   opcode(0x8B);
 5113   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
 5114   ins_pipe(ialu_reg_mem);
 5115 %}
 5116 
 5117 // Load Pointer
 5118 instruct loadP(rRegP dst, memory mem)
 5119 %{
 5120   match(Set dst (LoadP mem));
 5121   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);
 5122 
 5123   ins_cost(125); // XXX
 5124   format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
 5125   opcode(0x8B);
 5126   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5127   ins_pipe(ialu_reg_mem); // XXX
 5128 %}
 5129 
 5130 // Load Compressed Pointer
 5131 instruct loadN(rRegN dst, memory mem)
 5132 %{
 5133    match(Set dst (LoadN mem));
 5134 
 5135    ins_cost(125); // XXX
 5136    format %{ &quot;movl    $dst, $mem\t# compressed ptr&quot; %}
 5137    ins_encode %{
 5138      __ movl($dst$$Register, $mem$$Address);
 5139    %}
 5140    ins_pipe(ialu_reg_mem); // XXX
 5141 %}
 5142 
 5143 
 5144 // Load Klass Pointer
 5145 instruct loadKlass(rRegP dst, memory mem)
 5146 %{
 5147   match(Set dst (LoadKlass mem));
 5148 
 5149   ins_cost(125); // XXX
 5150   format %{ &quot;movq    $dst, $mem\t# class&quot; %}
 5151   opcode(0x8B);
 5152   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5153   ins_pipe(ialu_reg_mem); // XXX
 5154 %}
 5155 
 5156 // Load narrow Klass Pointer
 5157 instruct loadNKlass(rRegN dst, memory mem)
 5158 %{
 5159   match(Set dst (LoadNKlass mem));
 5160 
 5161   ins_cost(125); // XXX
 5162   format %{ &quot;movl    $dst, $mem\t# compressed klass ptr&quot; %}
 5163   ins_encode %{
 5164     __ movl($dst$$Register, $mem$$Address);
 5165   %}
 5166   ins_pipe(ialu_reg_mem); // XXX
 5167 %}
 5168 
 5169 // Load Float
 5170 instruct loadF(regF dst, memory mem)
 5171 %{
 5172   match(Set dst (LoadF mem));
 5173 
 5174   ins_cost(145); // XXX
 5175   format %{ &quot;movss   $dst, $mem\t# float&quot; %}
 5176   ins_encode %{
 5177     __ movflt($dst$$XMMRegister, $mem$$Address);
 5178   %}
 5179   ins_pipe(pipe_slow); // XXX
 5180 %}
 5181 
 5182 // Load Float
 5183 instruct MoveF2VL(vlRegF dst, regF src) %{
 5184   match(Set dst src);
 5185   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5186   ins_encode %{
 5187     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5188   %}
 5189   ins_pipe( fpu_reg_reg );
 5190 %}
 5191 
 5192 // Load Float
 5193 instruct MoveF2LEG(legRegF dst, regF src) %{
 5194   match(Set dst src);
 5195   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5196   ins_encode %{
 5197     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5198   %}
 5199   ins_pipe( fpu_reg_reg );
 5200 %}
 5201 
 5202 // Load Float
 5203 instruct MoveVL2F(regF dst, vlRegF src) %{
 5204   match(Set dst src);
 5205   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5206   ins_encode %{
 5207     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5208   %}
 5209   ins_pipe( fpu_reg_reg );
 5210 %}
 5211 
 5212 // Load Float
 5213 instruct MoveLEG2F(regF dst, legRegF src) %{
 5214   match(Set dst src);
 5215   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5216   ins_encode %{
 5217     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5218   %}
 5219   ins_pipe( fpu_reg_reg );
 5220 %}
 5221 
 5222 // Load Double
 5223 instruct loadD_partial(regD dst, memory mem)
 5224 %{
 5225   predicate(!UseXmmLoadAndClearUpper);
 5226   match(Set dst (LoadD mem));
 5227 
 5228   ins_cost(145); // XXX
 5229   format %{ &quot;movlpd  $dst, $mem\t# double&quot; %}
 5230   ins_encode %{
 5231     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5232   %}
 5233   ins_pipe(pipe_slow); // XXX
 5234 %}
 5235 
 5236 instruct loadD(regD dst, memory mem)
 5237 %{
 5238   predicate(UseXmmLoadAndClearUpper);
 5239   match(Set dst (LoadD mem));
 5240 
 5241   ins_cost(145); // XXX
 5242   format %{ &quot;movsd   $dst, $mem\t# double&quot; %}
 5243   ins_encode %{
 5244     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5245   %}
 5246   ins_pipe(pipe_slow); // XXX
 5247 %}
 5248 
 5249 // Load Double
 5250 instruct MoveD2VL(vlRegD dst, regD src) %{
 5251   match(Set dst src);
 5252   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5253   ins_encode %{
 5254     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5255   %}
 5256   ins_pipe( fpu_reg_reg );
 5257 %}
 5258 
 5259 // Load Double
 5260 instruct MoveD2LEG(legRegD dst, regD src) %{
 5261   match(Set dst src);
 5262   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5263   ins_encode %{
 5264     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5265   %}
 5266   ins_pipe( fpu_reg_reg );
 5267 %}
 5268 
 5269 // Load Double
 5270 instruct MoveVL2D(regD dst, vlRegD src) %{
 5271   match(Set dst src);
 5272   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5273   ins_encode %{
 5274     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5275   %}
 5276   ins_pipe( fpu_reg_reg );
 5277 %}
 5278 
 5279 // Load Double
 5280 instruct MoveLEG2D(regD dst, legRegD src) %{
 5281   match(Set dst src);
 5282   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5283   ins_encode %{
 5284     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5285   %}
 5286   ins_pipe( fpu_reg_reg );
 5287 %}
 5288 
 5289 // Following pseudo code describes the algorithm for max[FD]:
 5290 // Min algorithm is on similar lines
 5291 //  btmp = (b &lt; +0.0) ? a : b
 5292 //  atmp = (b &lt; +0.0) ? b : a
 5293 //  Tmp  = Max_Float(atmp , btmp)
 5294 //  Res  = (atmp == NaN) ? atmp : Tmp
 5295 
 5296 // max = java.lang.Math.max(float a, float b)
 5297 instruct maxF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5298   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5299   match(Set dst (MaxF a b));
 5300   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5301   format %{
 5302      &quot;blendvps         $btmp,$b,$a,$b           \n\t&quot;
 5303      &quot;blendvps         $atmp,$a,$b,$b           \n\t&quot;
 5304      &quot;vmaxss           $tmp,$atmp,$btmp         \n\t&quot;
 5305      &quot;cmpps.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5306      &quot;blendvps         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5307   %}
 5308   ins_encode %{
 5309     int vector_len = Assembler::AVX_128bit;
 5310     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5311     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5312     __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5313     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5314     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5315  %}
 5316   ins_pipe( pipe_slow );
 5317 %}
 5318 
 5319 instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5320   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5321   match(Set dst (MaxF a b));
 5322   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5323 
 5324   format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
 5325   ins_encode %{
 5326     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5327                     false /*min*/, true /*single*/);
 5328   %}
 5329   ins_pipe( pipe_slow );
 5330 %}
 5331 
 5332 // max = java.lang.Math.max(double a, double b)
 5333 instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5334   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5335   match(Set dst (MaxD a b));
 5336   effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);
 5337   format %{
 5338      &quot;blendvpd         $btmp,$b,$a,$b            \n\t&quot;
 5339      &quot;blendvpd         $atmp,$a,$b,$b            \n\t&quot;
 5340      &quot;vmaxsd           $tmp,$atmp,$btmp          \n\t&quot;
 5341      &quot;cmppd.unordered  $btmp,$atmp,$atmp         \n\t&quot;
 5342      &quot;blendvpd         $dst,$tmp,$atmp,$btmp     \n\t&quot;
 5343   %}
 5344   ins_encode %{
 5345     int vector_len = Assembler::AVX_128bit;
 5346     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5347     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5348     __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5349     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5350     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5351   %}
 5352   ins_pipe( pipe_slow );
 5353 %}
 5354 
 5355 instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5356   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5357   match(Set dst (MaxD a b));
 5358   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5359 
 5360   format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
 5361   ins_encode %{
 5362     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5363                     false /*min*/, false /*single*/);
 5364   %}
 5365   ins_pipe( pipe_slow );
 5366 %}
 5367 
 5368 // min = java.lang.Math.min(float a, float b)
 5369 instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5370   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5371   match(Set dst (MinF a b));
 5372   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5373   format %{
 5374      &quot;blendvps         $atmp,$a,$b,$a             \n\t&quot;
 5375      &quot;blendvps         $btmp,$b,$a,$a             \n\t&quot;
 5376      &quot;vminss           $tmp,$atmp,$btmp           \n\t&quot;
 5377      &quot;cmpps.unordered  $btmp,$atmp,$atmp          \n\t&quot;
 5378      &quot;blendvps         $dst,$tmp,$atmp,$btmp      \n\t&quot;
 5379   %}
 5380   ins_encode %{
 5381     int vector_len = Assembler::AVX_128bit;
 5382     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5383     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5384     __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5385     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5386     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5387   %}
 5388   ins_pipe( pipe_slow );
 5389 %}
 5390 
 5391 instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5392   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5393   match(Set dst (MinF a b));
 5394   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5395 
 5396   format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
 5397   ins_encode %{
 5398     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5399                     true /*min*/, true /*single*/);
 5400   %}
 5401   ins_pipe( pipe_slow );
 5402 %}
 5403 
 5404 // min = java.lang.Math.min(double a, double b)
 5405 instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5406   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5407   match(Set dst (MinD a b));
 5408   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5409   format %{
 5410      &quot;blendvpd         $atmp,$a,$b,$a           \n\t&quot;
 5411      &quot;blendvpd         $btmp,$b,$a,$a           \n\t&quot;
 5412      &quot;vminsd           $tmp,$atmp,$btmp         \n\t&quot;
 5413      &quot;cmppd.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5414      &quot;blendvpd         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5415   %}
 5416   ins_encode %{
 5417     int vector_len = Assembler::AVX_128bit;
 5418     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5419     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5420     __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5421     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5422     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5423   %}
 5424   ins_pipe( pipe_slow );
 5425 %}
 5426 
 5427 instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5428   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5429   match(Set dst (MinD a b));
 5430   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5431 
 5432   format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
 5433   ins_encode %{
 5434     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5435                     true /*min*/, false /*single*/);
 5436   %}
 5437   ins_pipe( pipe_slow );
 5438 %}
 5439 
 5440 // Load Effective Address
 5441 instruct leaP8(rRegP dst, indOffset8 mem)
 5442 %{
 5443   match(Set dst mem);
 5444 
 5445   ins_cost(110); // XXX
 5446   format %{ &quot;leaq    $dst, $mem\t# ptr 8&quot; %}
 5447   opcode(0x8D);
 5448   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5449   ins_pipe(ialu_reg_reg_fat);
 5450 %}
 5451 
 5452 instruct leaP32(rRegP dst, indOffset32 mem)
 5453 %{
 5454   match(Set dst mem);
 5455 
 5456   ins_cost(110);
 5457   format %{ &quot;leaq    $dst, $mem\t# ptr 32&quot; %}
 5458   opcode(0x8D);
 5459   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5460   ins_pipe(ialu_reg_reg_fat);
 5461 %}
 5462 
 5463 // instruct leaPIdx(rRegP dst, indIndex mem)
 5464 // %{
 5465 //   match(Set dst mem);
 5466 
 5467 //   ins_cost(110);
 5468 //   format %{ &quot;leaq    $dst, $mem\t# ptr idx&quot; %}
 5469 //   opcode(0x8D);
 5470 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5471 //   ins_pipe(ialu_reg_reg_fat);
 5472 // %}
 5473 
 5474 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
 5475 %{
 5476   match(Set dst mem);
 5477 
 5478   ins_cost(110);
 5479   format %{ &quot;leaq    $dst, $mem\t# ptr idxoff&quot; %}
 5480   opcode(0x8D);
 5481   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5482   ins_pipe(ialu_reg_reg_fat);
 5483 %}
 5484 
 5485 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
 5486 %{
 5487   match(Set dst mem);
 5488 
 5489   ins_cost(110);
 5490   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5491   opcode(0x8D);
 5492   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5493   ins_pipe(ialu_reg_reg_fat);
 5494 %}
 5495 
 5496 instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)
 5497 %{
 5498   match(Set dst mem);
 5499 
 5500   ins_cost(110);
 5501   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5502   opcode(0x8D);
 5503   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5504   ins_pipe(ialu_reg_reg_fat);
 5505 %}
 5506 
 5507 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
 5508 %{
 5509   match(Set dst mem);
 5510 
 5511   ins_cost(110);
 5512   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoff&quot; %}
 5513   opcode(0x8D);
 5514   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5515   ins_pipe(ialu_reg_reg_fat);
 5516 %}
 5517 
 5518 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
 5519 %{
 5520   match(Set dst mem);
 5521 
 5522   ins_cost(110);
 5523   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoff&quot; %}
 5524   opcode(0x8D);
 5525   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5526   ins_pipe(ialu_reg_reg_fat);
 5527 %}
 5528 
 5529 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
 5530 %{
 5531   match(Set dst mem);
 5532 
 5533   ins_cost(110);
 5534   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoff&quot; %}
 5535   opcode(0x8D);
 5536   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5537   ins_pipe(ialu_reg_reg_fat);
 5538 %}
 5539 
 5540 // Load Effective Address which uses Narrow (32-bits) oop
 5541 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
 5542 %{
 5543   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() != 0));
 5544   match(Set dst mem);
 5545 
 5546   ins_cost(110);
 5547   format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
 5548   opcode(0x8D);
 5549   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5550   ins_pipe(ialu_reg_reg_fat);
 5551 %}
 5552 
 5553 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
 5554 %{
 5555   predicate(CompressedOops::shift() == 0);
 5556   match(Set dst mem);
 5557 
 5558   ins_cost(110); // XXX
 5559   format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
 5560   opcode(0x8D);
 5561   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5562   ins_pipe(ialu_reg_reg_fat);
 5563 %}
 5564 
 5565 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
 5566 %{
 5567   predicate(CompressedOops::shift() == 0);
 5568   match(Set dst mem);
 5569 
 5570   ins_cost(110);
 5571   format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
 5572   opcode(0x8D);
 5573   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5574   ins_pipe(ialu_reg_reg_fat);
 5575 %}
 5576 
 5577 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
 5578 %{
 5579   predicate(CompressedOops::shift() == 0);
 5580   match(Set dst mem);
 5581 
 5582   ins_cost(110);
 5583   format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
 5584   opcode(0x8D);
 5585   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5586   ins_pipe(ialu_reg_reg_fat);
 5587 %}
 5588 
 5589 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
 5590 %{
 5591   predicate(CompressedOops::shift() == 0);
 5592   match(Set dst mem);
 5593 
 5594   ins_cost(110);
 5595   format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
 5596   opcode(0x8D);
 5597   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5598   ins_pipe(ialu_reg_reg_fat);
 5599 %}
 5600 
 5601 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
 5602 %{
 5603   predicate(CompressedOops::shift() == 0);
 5604   match(Set dst mem);
 5605 
 5606   ins_cost(110);
 5607   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
 5608   opcode(0x8D);
 5609   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5610   ins_pipe(ialu_reg_reg_fat);
 5611 %}
 5612 
 5613 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
 5614 %{
 5615   predicate(CompressedOops::shift() == 0);
 5616   match(Set dst mem);
 5617 
 5618   ins_cost(110);
 5619   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
 5620   opcode(0x8D);
 5621   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5622   ins_pipe(ialu_reg_reg_fat);
 5623 %}
 5624 
 5625 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
 5626 %{
 5627   predicate(CompressedOops::shift() == 0);
 5628   match(Set dst mem);
 5629 
 5630   ins_cost(110);
 5631   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
 5632   opcode(0x8D);
 5633   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5634   ins_pipe(ialu_reg_reg_fat);
 5635 %}
 5636 
 5637 instruct loadConI(rRegI dst, immI src)
 5638 %{
 5639   match(Set dst src);
 5640 
 5641   format %{ &quot;movl    $dst, $src\t# int&quot; %}
 5642   ins_encode(load_immI(dst, src));
 5643   ins_pipe(ialu_reg_fat); // XXX
 5644 %}
 5645 
 5646 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
 5647 %{
 5648   match(Set dst src);
 5649   effect(KILL cr);
 5650 
 5651   ins_cost(50);
 5652   format %{ &quot;xorl    $dst, $dst\t# int&quot; %}
 5653   opcode(0x33); /* + rd */
 5654   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5655   ins_pipe(ialu_reg);
 5656 %}
 5657 
 5658 instruct loadConL(rRegL dst, immL src)
 5659 %{
 5660   match(Set dst src);
 5661 
 5662   ins_cost(150);
 5663   format %{ &quot;movq    $dst, $src\t# long&quot; %}
 5664   ins_encode(load_immL(dst, src));
 5665   ins_pipe(ialu_reg);
 5666 %}
 5667 
 5668 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
 5669 %{
 5670   match(Set dst src);
 5671   effect(KILL cr);
 5672 
 5673   ins_cost(50);
 5674   format %{ &quot;xorl    $dst, $dst\t# long&quot; %}
 5675   opcode(0x33); /* + rd */
 5676   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5677   ins_pipe(ialu_reg); // XXX
 5678 %}
 5679 
 5680 instruct loadConUL32(rRegL dst, immUL32 src)
 5681 %{
 5682   match(Set dst src);
 5683 
 5684   ins_cost(60);
 5685   format %{ &quot;movl    $dst, $src\t# long (unsigned 32-bit)&quot; %}
 5686   ins_encode(load_immUL32(dst, src));
 5687   ins_pipe(ialu_reg);
 5688 %}
 5689 
 5690 instruct loadConL32(rRegL dst, immL32 src)
 5691 %{
 5692   match(Set dst src);
 5693 
 5694   ins_cost(70);
 5695   format %{ &quot;movq    $dst, $src\t# long (32-bit)&quot; %}
 5696   ins_encode(load_immL32(dst, src));
 5697   ins_pipe(ialu_reg);
 5698 %}
 5699 
 5700 instruct loadConP(rRegP dst, immP con) %{
 5701   match(Set dst con);
 5702 
 5703   format %{ &quot;movq    $dst, $con\t# ptr&quot; %}
 5704   ins_encode(load_immP(dst, con));
 5705   ins_pipe(ialu_reg_fat); // XXX
 5706 %}
 5707 
 5708 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
 5709 %{
 5710   match(Set dst src);
 5711   effect(KILL cr);
 5712 
 5713   ins_cost(50);
 5714   format %{ &quot;xorl    $dst, $dst\t# ptr&quot; %}
 5715   opcode(0x33); /* + rd */
 5716   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5717   ins_pipe(ialu_reg);
 5718 %}
 5719 
 5720 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
 5721 %{
 5722   match(Set dst src);
 5723   effect(KILL cr);
 5724 
 5725   ins_cost(60);
 5726   format %{ &quot;movl    $dst, $src\t# ptr (positive 32-bit)&quot; %}
 5727   ins_encode(load_immP31(dst, src));
 5728   ins_pipe(ialu_reg);
 5729 %}
 5730 
 5731 instruct loadConF(regF dst, immF con) %{
 5732   match(Set dst con);
 5733   ins_cost(125);
 5734   format %{ &quot;movss   $dst, [$constantaddress]\t# load from constant table: float=$con&quot; %}
 5735   ins_encode %{
 5736     __ movflt($dst$$XMMRegister, $constantaddress($con));
 5737   %}
 5738   ins_pipe(pipe_slow);
 5739 %}
 5740 
 5741 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
 5742   match(Set dst src);
 5743   effect(KILL cr);
 5744   format %{ &quot;xorq    $dst, $src\t# compressed NULL ptr&quot; %}
 5745   ins_encode %{
 5746     __ xorq($dst$$Register, $dst$$Register);
 5747   %}
 5748   ins_pipe(ialu_reg);
 5749 %}
 5750 
 5751 instruct loadConN(rRegN dst, immN src) %{
 5752   match(Set dst src);
 5753 
 5754   ins_cost(125);
 5755   format %{ &quot;movl    $dst, $src\t# compressed ptr&quot; %}
 5756   ins_encode %{
 5757     address con = (address)$src$$constant;
 5758     if (con == NULL) {
 5759       ShouldNotReachHere();
 5760     } else {
 5761       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
 5762     }
 5763   %}
 5764   ins_pipe(ialu_reg_fat); // XXX
 5765 %}
 5766 
 5767 instruct loadConNKlass(rRegN dst, immNKlass src) %{
 5768   match(Set dst src);
 5769 
 5770   ins_cost(125);
 5771   format %{ &quot;movl    $dst, $src\t# compressed klass ptr&quot; %}
 5772   ins_encode %{
 5773     address con = (address)$src$$constant;
 5774     if (con == NULL) {
 5775       ShouldNotReachHere();
 5776     } else {
 5777       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
 5778     }
 5779   %}
 5780   ins_pipe(ialu_reg_fat); // XXX
 5781 %}
 5782 
 5783 instruct loadConF0(regF dst, immF0 src)
 5784 %{
 5785   match(Set dst src);
 5786   ins_cost(100);
 5787 
 5788   format %{ &quot;xorps   $dst, $dst\t# float 0.0&quot; %}
 5789   ins_encode %{
 5790     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 5791   %}
 5792   ins_pipe(pipe_slow);
 5793 %}
 5794 
 5795 // Use the same format since predicate() can not be used here.
 5796 instruct loadConD(regD dst, immD con) %{
 5797   match(Set dst con);
 5798   ins_cost(125);
 5799   format %{ &quot;movsd   $dst, [$constantaddress]\t# load from constant table: double=$con&quot; %}
 5800   ins_encode %{
 5801     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 5802   %}
 5803   ins_pipe(pipe_slow);
 5804 %}
 5805 
 5806 instruct loadConD0(regD dst, immD0 src)
 5807 %{
 5808   match(Set dst src);
 5809   ins_cost(100);
 5810 
 5811   format %{ &quot;xorpd   $dst, $dst\t# double 0.0&quot; %}
 5812   ins_encode %{
 5813     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 5814   %}
 5815   ins_pipe(pipe_slow);
 5816 %}
 5817 
 5818 instruct loadSSI(rRegI dst, stackSlotI src)
 5819 %{
 5820   match(Set dst src);
 5821 
 5822   ins_cost(125);
 5823   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 5824   opcode(0x8B);
 5825   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 5826   ins_pipe(ialu_reg_mem);
 5827 %}
 5828 
 5829 instruct loadSSL(rRegL dst, stackSlotL src)
 5830 %{
 5831   match(Set dst src);
 5832 
 5833   ins_cost(125);
 5834   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 5835   opcode(0x8B);
 5836   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5837   ins_pipe(ialu_reg_mem);
 5838 %}
 5839 
 5840 instruct loadSSP(rRegP dst, stackSlotP src)
 5841 %{
 5842   match(Set dst src);
 5843 
 5844   ins_cost(125);
 5845   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 5846   opcode(0x8B);
 5847   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5848   ins_pipe(ialu_reg_mem);
 5849 %}
 5850 
 5851 instruct loadSSF(regF dst, stackSlotF src)
 5852 %{
 5853   match(Set dst src);
 5854 
 5855   ins_cost(125);
 5856   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 5857   ins_encode %{
 5858     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
 5859   %}
 5860   ins_pipe(pipe_slow); // XXX
 5861 %}
 5862 
 5863 // Use the same format since predicate() can not be used here.
 5864 instruct loadSSD(regD dst, stackSlotD src)
 5865 %{
 5866   match(Set dst src);
 5867 
 5868   ins_cost(125);
 5869   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 5870   ins_encode  %{
 5871     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
 5872   %}
 5873   ins_pipe(pipe_slow); // XXX
 5874 %}
 5875 
 5876 // Prefetch instructions for allocation.
 5877 // Must be safe to execute with invalid address (cannot fault).
 5878 
 5879 instruct prefetchAlloc( memory mem ) %{
 5880   predicate(AllocatePrefetchInstr==3);
 5881   match(PrefetchAllocation mem);
 5882   ins_cost(125);
 5883 
 5884   format %{ &quot;PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified&quot; %}
 5885   ins_encode %{
 5886     __ prefetchw($mem$$Address);
 5887   %}
 5888   ins_pipe(ialu_mem);
 5889 %}
 5890 
 5891 instruct prefetchAllocNTA( memory mem ) %{
 5892   predicate(AllocatePrefetchInstr==0);
 5893   match(PrefetchAllocation mem);
 5894   ins_cost(125);
 5895 
 5896   format %{ &quot;PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write&quot; %}
 5897   ins_encode %{
 5898     __ prefetchnta($mem$$Address);
 5899   %}
 5900   ins_pipe(ialu_mem);
 5901 %}
 5902 
 5903 instruct prefetchAllocT0( memory mem ) %{
 5904   predicate(AllocatePrefetchInstr==1);
 5905   match(PrefetchAllocation mem);
 5906   ins_cost(125);
 5907 
 5908   format %{ &quot;PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write&quot; %}
 5909   ins_encode %{
 5910     __ prefetcht0($mem$$Address);
 5911   %}
 5912   ins_pipe(ialu_mem);
 5913 %}
 5914 
 5915 instruct prefetchAllocT2( memory mem ) %{
 5916   predicate(AllocatePrefetchInstr==2);
 5917   match(PrefetchAllocation mem);
 5918   ins_cost(125);
 5919 
 5920   format %{ &quot;PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write&quot; %}
 5921   ins_encode %{
 5922     __ prefetcht2($mem$$Address);
 5923   %}
 5924   ins_pipe(ialu_mem);
 5925 %}
 5926 
 5927 //----------Store Instructions-------------------------------------------------
 5928 
 5929 // Store Byte
 5930 instruct storeB(memory mem, rRegI src)
 5931 %{
 5932   match(Set mem (StoreB mem src));
 5933 
 5934   ins_cost(125); // XXX
 5935   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 5936   opcode(0x88);
 5937   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
 5938   ins_pipe(ialu_mem_reg);
 5939 %}
 5940 
 5941 // Store Char/Short
 5942 instruct storeC(memory mem, rRegI src)
 5943 %{
 5944   match(Set mem (StoreC mem src));
 5945 
 5946   ins_cost(125); // XXX
 5947   format %{ &quot;movw    $mem, $src\t# char/short&quot; %}
 5948   opcode(0x89);
 5949   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5950   ins_pipe(ialu_mem_reg);
 5951 %}
 5952 
 5953 // Store Integer
 5954 instruct storeI(memory mem, rRegI src)
 5955 %{
 5956   match(Set mem (StoreI mem src));
 5957 
 5958   ins_cost(125); // XXX
 5959   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 5960   opcode(0x89);
 5961   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5962   ins_pipe(ialu_mem_reg);
 5963 %}
 5964 
 5965 // Store Long
 5966 instruct storeL(memory mem, rRegL src)
 5967 %{
 5968   match(Set mem (StoreL mem src));
 5969 
 5970   ins_cost(125); // XXX
 5971   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5972   opcode(0x89);
 5973   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5974   ins_pipe(ialu_mem_reg); // XXX
 5975 %}
 5976 
 5977 // Store Pointer
 5978 instruct storeP(memory mem, any_RegP src)
 5979 %{
 5980   match(Set mem (StoreP mem src));
 5981 
 5982   ins_cost(125); // XXX
 5983   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5984   opcode(0x89);
 5985   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5986   ins_pipe(ialu_mem_reg);
 5987 %}
 5988 
 5989 instruct storeImmP0(memory mem, immP0 zero)
 5990 %{
 5991   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 5992   match(Set mem (StoreP mem zero));
 5993 
 5994   ins_cost(125); // XXX
 5995   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 5996   ins_encode %{
 5997     __ movq($mem$$Address, r12);
 5998   %}
 5999   ins_pipe(ialu_mem_reg);
 6000 %}
 6001 
 6002 // Store NULL Pointer, mark word, or other simple pointer constant.
 6003 instruct storeImmP(memory mem, immP31 src)
 6004 %{
 6005   match(Set mem (StoreP mem src));
 6006 
 6007   ins_cost(150); // XXX
 6008   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 6009   opcode(0xC7); /* C7 /0 */
 6010   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6011   ins_pipe(ialu_mem_imm);
 6012 %}
 6013 
 6014 // Store Compressed Pointer
 6015 instruct storeN(memory mem, rRegN src)
 6016 %{
 6017   match(Set mem (StoreN mem src));
 6018 
 6019   ins_cost(125); // XXX
 6020   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6021   ins_encode %{
 6022     __ movl($mem$$Address, $src$$Register);
 6023   %}
 6024   ins_pipe(ialu_mem_reg);
 6025 %}
 6026 
 6027 instruct storeNKlass(memory mem, rRegN src)
 6028 %{
 6029   match(Set mem (StoreNKlass mem src));
 6030 
 6031   ins_cost(125); // XXX
 6032   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6033   ins_encode %{
 6034     __ movl($mem$$Address, $src$$Register);
 6035   %}
 6036   ins_pipe(ialu_mem_reg);
 6037 %}
 6038 
 6039 instruct storeImmN0(memory mem, immN0 zero)
 6040 %{
 6041   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedKlassPointers::base() == NULL);
 6042   match(Set mem (StoreN mem zero));
 6043 
 6044   ins_cost(125); // XXX
 6045   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6046   ins_encode %{
 6047     __ movl($mem$$Address, r12);
 6048   %}
 6049   ins_pipe(ialu_mem_reg);
 6050 %}
 6051 
 6052 instruct storeImmN(memory mem, immN src)
 6053 %{
 6054   match(Set mem (StoreN mem src));
 6055 
 6056   ins_cost(150); // XXX
 6057   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6058   ins_encode %{
 6059     address con = (address)$src$$constant;
 6060     if (con == NULL) {
 6061       __ movl($mem$$Address, (int32_t)0);
 6062     } else {
 6063       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
 6064     }
 6065   %}
 6066   ins_pipe(ialu_mem_imm);
 6067 %}
 6068 
 6069 instruct storeImmNKlass(memory mem, immNKlass src)
 6070 %{
 6071   match(Set mem (StoreNKlass mem src));
 6072 
 6073   ins_cost(150); // XXX
 6074   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6075   ins_encode %{
 6076     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6077   %}
 6078   ins_pipe(ialu_mem_imm);
 6079 %}
 6080 
 6081 // Store Integer Immediate
 6082 instruct storeImmI0(memory mem, immI0 zero)
 6083 %{
 6084   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6085   match(Set mem (StoreI mem zero));
 6086 
 6087   ins_cost(125); // XXX
 6088   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6089   ins_encode %{
 6090     __ movl($mem$$Address, r12);
 6091   %}
 6092   ins_pipe(ialu_mem_reg);
 6093 %}
 6094 
 6095 instruct storeImmI(memory mem, immI src)
 6096 %{
 6097   match(Set mem (StoreI mem src));
 6098 
 6099   ins_cost(150);
 6100   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6101   opcode(0xC7); /* C7 /0 */
 6102   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6103   ins_pipe(ialu_mem_imm);
 6104 %}
 6105 
 6106 // Store Long Immediate
 6107 instruct storeImmL0(memory mem, immL0 zero)
 6108 %{
 6109   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6110   match(Set mem (StoreL mem zero));
 6111 
 6112   ins_cost(125); // XXX
 6113   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6114   ins_encode %{
 6115     __ movq($mem$$Address, r12);
 6116   %}
 6117   ins_pipe(ialu_mem_reg);
 6118 %}
 6119 
 6120 instruct storeImmL(memory mem, immL32 src)
 6121 %{
 6122   match(Set mem (StoreL mem src));
 6123 
 6124   ins_cost(150);
 6125   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6126   opcode(0xC7); /* C7 /0 */
 6127   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6128   ins_pipe(ialu_mem_imm);
 6129 %}
 6130 
 6131 // Store Short/Char Immediate
 6132 instruct storeImmC0(memory mem, immI0 zero)
 6133 %{
 6134   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6135   match(Set mem (StoreC mem zero));
 6136 
 6137   ins_cost(125); // XXX
 6138   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6139   ins_encode %{
 6140     __ movw($mem$$Address, r12);
 6141   %}
 6142   ins_pipe(ialu_mem_reg);
 6143 %}
 6144 
 6145 instruct storeImmI16(memory mem, immI16 src)
 6146 %{
 6147   predicate(UseStoreImmI16);
 6148   match(Set mem (StoreC mem src));
 6149 
 6150   ins_cost(150);
 6151   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6152   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6153   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6154   ins_pipe(ialu_mem_imm);
 6155 %}
 6156 
 6157 // Store Byte Immediate
 6158 instruct storeImmB0(memory mem, immI0 zero)
 6159 %{
 6160   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6161   match(Set mem (StoreB mem zero));
 6162 
 6163   ins_cost(125); // XXX
 6164   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6165   ins_encode %{
 6166     __ movb($mem$$Address, r12);
 6167   %}
 6168   ins_pipe(ialu_mem_reg);
 6169 %}
 6170 
 6171 instruct storeImmB(memory mem, immI8 src)
 6172 %{
 6173   match(Set mem (StoreB mem src));
 6174 
 6175   ins_cost(150); // XXX
 6176   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6177   opcode(0xC6); /* C6 /0 */
 6178   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6179   ins_pipe(ialu_mem_imm);
 6180 %}
 6181 
 6182 // Store CMS card-mark Immediate
 6183 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6184 %{
 6185   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6186   match(Set mem (StoreCM mem zero));
 6187 
 6188   ins_cost(125); // XXX
 6189   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6190   ins_encode %{
 6191     __ movb($mem$$Address, r12);
 6192   %}
 6193   ins_pipe(ialu_mem_reg);
 6194 %}
 6195 
 6196 instruct storeImmCM0(memory mem, immI0 src)
 6197 %{
 6198   match(Set mem (StoreCM mem src));
 6199 
 6200   ins_cost(150); // XXX
 6201   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6202   opcode(0xC6); /* C6 /0 */
 6203   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6204   ins_pipe(ialu_mem_imm);
 6205 %}
 6206 
 6207 // Store Float
 6208 instruct storeF(memory mem, regF src)
 6209 %{
 6210   match(Set mem (StoreF mem src));
 6211 
 6212   ins_cost(95); // XXX
 6213   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6214   ins_encode %{
 6215     __ movflt($mem$$Address, $src$$XMMRegister);
 6216   %}
 6217   ins_pipe(pipe_slow); // XXX
 6218 %}
 6219 
 6220 // Store immediate Float value (it is faster than store from XMM register)
 6221 instruct storeF0(memory mem, immF0 zero)
 6222 %{
 6223   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6224   match(Set mem (StoreF mem zero));
 6225 
 6226   ins_cost(25); // XXX
 6227   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6228   ins_encode %{
 6229     __ movl($mem$$Address, r12);
 6230   %}
 6231   ins_pipe(ialu_mem_reg);
 6232 %}
 6233 
 6234 instruct storeF_imm(memory mem, immF src)
 6235 %{
 6236   match(Set mem (StoreF mem src));
 6237 
 6238   ins_cost(50);
 6239   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6240   opcode(0xC7); /* C7 /0 */
 6241   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6242   ins_pipe(ialu_mem_imm);
 6243 %}
 6244 
 6245 // Store Double
 6246 instruct storeD(memory mem, regD src)
 6247 %{
 6248   match(Set mem (StoreD mem src));
 6249 
 6250   ins_cost(95); // XXX
 6251   format %{ &quot;movsd   $mem, $src\t# double&quot; %}
 6252   ins_encode %{
 6253     __ movdbl($mem$$Address, $src$$XMMRegister);
 6254   %}
 6255   ins_pipe(pipe_slow); // XXX
 6256 %}
 6257 
 6258 // Store immediate double 0.0 (it is faster than store from XMM register)
 6259 instruct storeD0_imm(memory mem, immD0 src)
 6260 %{
 6261   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6262   match(Set mem (StoreD mem src));
 6263 
 6264   ins_cost(50);
 6265   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6266   opcode(0xC7); /* C7 /0 */
 6267   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6268   ins_pipe(ialu_mem_imm);
 6269 %}
 6270 
 6271 instruct storeD0(memory mem, immD0 zero)
 6272 %{
 6273   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6274   match(Set mem (StoreD mem zero));
 6275 
 6276   ins_cost(25); // XXX
 6277   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6278   ins_encode %{
 6279     __ movq($mem$$Address, r12);
 6280   %}
 6281   ins_pipe(ialu_mem_reg);
 6282 %}
 6283 
 6284 instruct storeSSI(stackSlotI dst, rRegI src)
 6285 %{
 6286   match(Set dst src);
 6287 
 6288   ins_cost(100);
 6289   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6290   opcode(0x89);
 6291   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6292   ins_pipe( ialu_mem_reg );
 6293 %}
 6294 
 6295 instruct storeSSL(stackSlotL dst, rRegL src)
 6296 %{
 6297   match(Set dst src);
 6298 
 6299   ins_cost(100);
 6300   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 6301   opcode(0x89);
 6302   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6303   ins_pipe(ialu_mem_reg);
 6304 %}
 6305 
 6306 instruct storeSSP(stackSlotP dst, rRegP src)
 6307 %{
 6308   match(Set dst src);
 6309 
 6310   ins_cost(100);
 6311   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 6312   opcode(0x89);
 6313   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6314   ins_pipe(ialu_mem_reg);
 6315 %}
 6316 
 6317 instruct storeSSF(stackSlotF dst, regF src)
 6318 %{
 6319   match(Set dst src);
 6320 
 6321   ins_cost(95); // XXX
 6322   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6323   ins_encode %{
 6324     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6325   %}
 6326   ins_pipe(pipe_slow); // XXX
 6327 %}
 6328 
 6329 instruct storeSSD(stackSlotD dst, regD src)
 6330 %{
 6331   match(Set dst src);
 6332 
 6333   ins_cost(95); // XXX
 6334   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6335   ins_encode %{
 6336     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6337   %}
 6338   ins_pipe(pipe_slow); // XXX
 6339 %}
 6340 
 6341 instruct cacheWB(indirect addr)
 6342 %{
 6343   predicate(VM_Version::supports_data_cache_line_flush());
 6344   match(CacheWB addr);
 6345 
 6346   ins_cost(100);
 6347   format %{&quot;cache wb $addr&quot; %}
 6348   ins_encode %{
 6349     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
 6350     assert($addr$$disp == 0, &quot;should be&quot;);
 6351     __ cache_wb(Address($addr$$base$$Register, 0));
 6352   %}
 6353   ins_pipe(pipe_slow); // XXX
 6354 %}
 6355 
 6356 instruct cacheWBPreSync()
 6357 %{
 6358   predicate(VM_Version::supports_data_cache_line_flush());
 6359   match(CacheWBPreSync);
 6360 
 6361   ins_cost(100);
 6362   format %{&quot;cache wb presync&quot; %}
 6363   ins_encode %{
 6364     __ cache_wbsync(true);
 6365   %}
 6366   ins_pipe(pipe_slow); // XXX
 6367 %}
 6368 
 6369 instruct cacheWBPostSync()
 6370 %{
 6371   predicate(VM_Version::supports_data_cache_line_flush());
 6372   match(CacheWBPostSync);
 6373 
 6374   ins_cost(100);
 6375   format %{&quot;cache wb postsync&quot; %}
 6376   ins_encode %{
 6377     __ cache_wbsync(false);
 6378   %}
 6379   ins_pipe(pipe_slow); // XXX
 6380 %}
 6381 
 6382 //----------BSWAP Instructions-------------------------------------------------
 6383 instruct bytes_reverse_int(rRegI dst) %{
 6384   match(Set dst (ReverseBytesI dst));
 6385 
 6386   format %{ &quot;bswapl  $dst&quot; %}
 6387   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
 6388   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
 6389   ins_pipe( ialu_reg );
 6390 %}
 6391 
 6392 instruct bytes_reverse_long(rRegL dst) %{
 6393   match(Set dst (ReverseBytesL dst));
 6394 
 6395   format %{ &quot;bswapq  $dst&quot; %}
 6396   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
 6397   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
 6398   ins_pipe( ialu_reg);
 6399 %}
 6400 
 6401 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
 6402   match(Set dst (ReverseBytesUS dst));
 6403   effect(KILL cr);
 6404 
 6405   format %{ &quot;bswapl  $dst\n\t&quot;
 6406             &quot;shrl    $dst,16\n\t&quot; %}
 6407   ins_encode %{
 6408     __ bswapl($dst$$Register);
 6409     __ shrl($dst$$Register, 16);
 6410   %}
 6411   ins_pipe( ialu_reg );
 6412 %}
 6413 
 6414 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
 6415   match(Set dst (ReverseBytesS dst));
 6416   effect(KILL cr);
 6417 
 6418   format %{ &quot;bswapl  $dst\n\t&quot;
 6419             &quot;sar     $dst,16\n\t&quot; %}
 6420   ins_encode %{
 6421     __ bswapl($dst$$Register);
 6422     __ sarl($dst$$Register, 16);
 6423   %}
 6424   ins_pipe( ialu_reg );
 6425 %}
 6426 
 6427 //---------- Zeros Count Instructions ------------------------------------------
 6428 
 6429 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6430   predicate(UseCountLeadingZerosInstruction);
 6431   match(Set dst (CountLeadingZerosI src));
 6432   effect(KILL cr);
 6433 
 6434   format %{ &quot;lzcntl  $dst, $src\t# count leading zeros (int)&quot; %}
 6435   ins_encode %{
 6436     __ lzcntl($dst$$Register, $src$$Register);
 6437   %}
 6438   ins_pipe(ialu_reg);
 6439 %}
 6440 
 6441 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
 6442   predicate(!UseCountLeadingZerosInstruction);
 6443   match(Set dst (CountLeadingZerosI src));
 6444   effect(KILL cr);
 6445 
 6446   format %{ &quot;bsrl    $dst, $src\t# count leading zeros (int)\n\t&quot;
 6447             &quot;jnz     skip\n\t&quot;
 6448             &quot;movl    $dst, -1\n&quot;
 6449       &quot;skip:\n\t&quot;
 6450             &quot;negl    $dst\n\t&quot;
 6451             &quot;addl    $dst, 31&quot; %}
 6452   ins_encode %{
 6453     Register Rdst = $dst$$Register;
 6454     Register Rsrc = $src$$Register;
 6455     Label skip;
 6456     __ bsrl(Rdst, Rsrc);
 6457     __ jccb(Assembler::notZero, skip);
 6458     __ movl(Rdst, -1);
 6459     __ bind(skip);
 6460     __ negl(Rdst);
 6461     __ addl(Rdst, BitsPerInt - 1);
 6462   %}
 6463   ins_pipe(ialu_reg);
 6464 %}
 6465 
 6466 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6467   predicate(UseCountLeadingZerosInstruction);
 6468   match(Set dst (CountLeadingZerosL src));
 6469   effect(KILL cr);
 6470 
 6471   format %{ &quot;lzcntq  $dst, $src\t# count leading zeros (long)&quot; %}
 6472   ins_encode %{
 6473     __ lzcntq($dst$$Register, $src$$Register);
 6474   %}
 6475   ins_pipe(ialu_reg);
 6476 %}
 6477 
 6478 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
 6479   predicate(!UseCountLeadingZerosInstruction);
 6480   match(Set dst (CountLeadingZerosL src));
 6481   effect(KILL cr);
 6482 
 6483   format %{ &quot;bsrq    $dst, $src\t# count leading zeros (long)\n\t&quot;
 6484             &quot;jnz     skip\n\t&quot;
 6485             &quot;movl    $dst, -1\n&quot;
 6486       &quot;skip:\n\t&quot;
 6487             &quot;negl    $dst\n\t&quot;
 6488             &quot;addl    $dst, 63&quot; %}
 6489   ins_encode %{
 6490     Register Rdst = $dst$$Register;
 6491     Register Rsrc = $src$$Register;
 6492     Label skip;
 6493     __ bsrq(Rdst, Rsrc);
 6494     __ jccb(Assembler::notZero, skip);
 6495     __ movl(Rdst, -1);
 6496     __ bind(skip);
 6497     __ negl(Rdst);
 6498     __ addl(Rdst, BitsPerLong - 1);
 6499   %}
 6500   ins_pipe(ialu_reg);
 6501 %}
 6502 
 6503 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6504   predicate(UseCountTrailingZerosInstruction);
 6505   match(Set dst (CountTrailingZerosI src));
 6506   effect(KILL cr);
 6507 
 6508   format %{ &quot;tzcntl    $dst, $src\t# count trailing zeros (int)&quot; %}
 6509   ins_encode %{
 6510     __ tzcntl($dst$$Register, $src$$Register);
 6511   %}
 6512   ins_pipe(ialu_reg);
 6513 %}
 6514 
 6515 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
 6516   predicate(!UseCountTrailingZerosInstruction);
 6517   match(Set dst (CountTrailingZerosI src));
 6518   effect(KILL cr);
 6519 
 6520   format %{ &quot;bsfl    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 6521             &quot;jnz     done\n\t&quot;
 6522             &quot;movl    $dst, 32\n&quot;
 6523       &quot;done:&quot; %}
 6524   ins_encode %{
 6525     Register Rdst = $dst$$Register;
 6526     Label done;
 6527     __ bsfl(Rdst, $src$$Register);
 6528     __ jccb(Assembler::notZero, done);
 6529     __ movl(Rdst, BitsPerInt);
 6530     __ bind(done);
 6531   %}
 6532   ins_pipe(ialu_reg);
 6533 %}
 6534 
 6535 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6536   predicate(UseCountTrailingZerosInstruction);
 6537   match(Set dst (CountTrailingZerosL src));
 6538   effect(KILL cr);
 6539 
 6540   format %{ &quot;tzcntq    $dst, $src\t# count trailing zeros (long)&quot; %}
 6541   ins_encode %{
 6542     __ tzcntq($dst$$Register, $src$$Register);
 6543   %}
 6544   ins_pipe(ialu_reg);
 6545 %}
 6546 
 6547 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
 6548   predicate(!UseCountTrailingZerosInstruction);
 6549   match(Set dst (CountTrailingZerosL src));
 6550   effect(KILL cr);
 6551 
 6552   format %{ &quot;bsfq    $dst, $src\t# count trailing zeros (long)\n\t&quot;
 6553             &quot;jnz     done\n\t&quot;
 6554             &quot;movl    $dst, 64\n&quot;
 6555       &quot;done:&quot; %}
 6556   ins_encode %{
 6557     Register Rdst = $dst$$Register;
 6558     Label done;
 6559     __ bsfq(Rdst, $src$$Register);
 6560     __ jccb(Assembler::notZero, done);
 6561     __ movl(Rdst, BitsPerLong);
 6562     __ bind(done);
 6563   %}
 6564   ins_pipe(ialu_reg);
 6565 %}
 6566 
 6567 
 6568 //---------- Population Count Instructions -------------------------------------
 6569 
 6570 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6571   predicate(UsePopCountInstruction);
 6572   match(Set dst (PopCountI src));
 6573   effect(KILL cr);
 6574 
 6575   format %{ &quot;popcnt  $dst, $src&quot; %}
 6576   ins_encode %{
 6577     __ popcntl($dst$$Register, $src$$Register);
 6578   %}
 6579   ins_pipe(ialu_reg);
 6580 %}
 6581 
 6582 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6583   predicate(UsePopCountInstruction);
 6584   match(Set dst (PopCountI (LoadI mem)));
 6585   effect(KILL cr);
 6586 
 6587   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6588   ins_encode %{
 6589     __ popcntl($dst$$Register, $mem$$Address);
 6590   %}
 6591   ins_pipe(ialu_reg);
 6592 %}
 6593 
 6594 // Note: Long.bitCount(long) returns an int.
 6595 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6596   predicate(UsePopCountInstruction);
 6597   match(Set dst (PopCountL src));
 6598   effect(KILL cr);
 6599 
 6600   format %{ &quot;popcnt  $dst, $src&quot; %}
 6601   ins_encode %{
 6602     __ popcntq($dst$$Register, $src$$Register);
 6603   %}
 6604   ins_pipe(ialu_reg);
 6605 %}
 6606 
 6607 // Note: Long.bitCount(long) returns an int.
 6608 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6609   predicate(UsePopCountInstruction);
 6610   match(Set dst (PopCountL (LoadL mem)));
 6611   effect(KILL cr);
 6612 
 6613   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6614   ins_encode %{
 6615     __ popcntq($dst$$Register, $mem$$Address);
 6616   %}
 6617   ins_pipe(ialu_reg);
 6618 %}
 6619 
 6620 
 6621 //----------MemBar Instructions-----------------------------------------------
 6622 // Memory barrier flavors
 6623 
 6624 instruct membar_acquire()
 6625 %{
 6626   match(MemBarAcquire);
 6627   match(LoadFence);
 6628   ins_cost(0);
 6629 
 6630   size(0);
 6631   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6632   ins_encode();
 6633   ins_pipe(empty);
 6634 %}
 6635 
 6636 instruct membar_acquire_lock()
 6637 %{
 6638   match(MemBarAcquireLock);
 6639   ins_cost(0);
 6640 
 6641   size(0);
 6642   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6643   ins_encode();
 6644   ins_pipe(empty);
 6645 %}
 6646 
 6647 instruct membar_release()
 6648 %{
 6649   match(MemBarRelease);
 6650   match(StoreFence);
 6651   ins_cost(0);
 6652 
 6653   size(0);
 6654   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6655   ins_encode();
 6656   ins_pipe(empty);
 6657 %}
 6658 
 6659 instruct membar_release_lock()
 6660 %{
 6661   match(MemBarReleaseLock);
 6662   ins_cost(0);
 6663 
 6664   size(0);
 6665   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6666   ins_encode();
 6667   ins_pipe(empty);
 6668 %}
 6669 
 6670 instruct membar_volatile(rFlagsReg cr) %{
 6671   match(MemBarVolatile);
 6672   effect(KILL cr);
 6673   ins_cost(400);
 6674 
 6675   format %{
 6676     $$template
 6677     $$emit$$&quot;lock addl [rsp + #0], 0\t! membar_volatile&quot;
 6678   %}
 6679   ins_encode %{
 6680     __ membar(Assembler::StoreLoad);
 6681   %}
 6682   ins_pipe(pipe_slow);
 6683 %}
 6684 
 6685 instruct unnecessary_membar_volatile()
 6686 %{
 6687   match(MemBarVolatile);
 6688   predicate(Matcher::post_store_load_barrier(n));
 6689   ins_cost(0);
 6690 
 6691   size(0);
 6692   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6693   ins_encode();
 6694   ins_pipe(empty);
 6695 %}
 6696 
 6697 instruct membar_storestore() %{
 6698   match(MemBarStoreStore);
 6699   ins_cost(0);
 6700 
 6701   size(0);
 6702   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6703   ins_encode( );
 6704   ins_pipe(empty);
 6705 %}
 6706 
 6707 //----------Move Instructions--------------------------------------------------
 6708 
 6709 instruct castX2P(rRegP dst, rRegL src)
 6710 %{
 6711   match(Set dst (CastX2P src));
 6712 
 6713   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6714   ins_encode %{
 6715     if ($dst$$reg != $src$$reg) {
 6716       __ movptr($dst$$Register, $src$$Register);
 6717     }
 6718   %}
 6719   ins_pipe(ialu_reg_reg); // XXX
 6720 %}
 6721 
 6722 instruct castP2X(rRegL dst, rRegP src)
 6723 %{
 6724   match(Set dst (CastP2X src));
 6725 
 6726   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6727   ins_encode %{
 6728     if ($dst$$reg != $src$$reg) {
 6729       __ movptr($dst$$Register, $src$$Register);
 6730     }
 6731   %}
 6732   ins_pipe(ialu_reg_reg); // XXX
 6733 %}
 6734 
 6735 // Convert oop into int for vectors alignment masking
 6736 instruct convP2I(rRegI dst, rRegP src)
 6737 %{
 6738   match(Set dst (ConvL2I (CastP2X src)));
 6739 
 6740   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6741   ins_encode %{
 6742     __ movl($dst$$Register, $src$$Register);
 6743   %}
 6744   ins_pipe(ialu_reg_reg); // XXX
 6745 %}
 6746 
 6747 // Convert compressed oop into int for vectors alignment masking
 6748 // in case of 32bit oops (heap &lt; 4Gb).
 6749 instruct convN2I(rRegI dst, rRegN src)
 6750 %{
 6751   predicate(CompressedOops::shift() == 0);
 6752   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6753 
 6754   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6755   ins_encode %{
 6756     __ movl($dst$$Register, $src$$Register);
 6757   %}
 6758   ins_pipe(ialu_reg_reg); // XXX
 6759 %}
 6760 
 6761 // Convert oop pointer into compressed form
 6762 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
 6763   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6764   match(Set dst (EncodeP src));
 6765   effect(KILL cr);
 6766   format %{ &quot;encode_heap_oop $dst,$src&quot; %}
 6767   ins_encode %{
 6768     Register s = $src$$Register;
 6769     Register d = $dst$$Register;
 6770     if (s != d) {
 6771       __ movq(d, s);
 6772     }
 6773     __ encode_heap_oop(d);
 6774   %}
 6775   ins_pipe(ialu_reg_long);
 6776 %}
 6777 
 6778 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6779   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6780   match(Set dst (EncodeP src));
 6781   effect(KILL cr);
 6782   format %{ &quot;encode_heap_oop_not_null $dst,$src&quot; %}
 6783   ins_encode %{
 6784     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
 6785   %}
 6786   ins_pipe(ialu_reg_long);
 6787 %}
 6788 
 6789 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
 6790   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6791             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
 6792   match(Set dst (DecodeN src));
 6793   effect(KILL cr);
 6794   format %{ &quot;decode_heap_oop $dst,$src&quot; %}
 6795   ins_encode %{
 6796     Register s = $src$$Register;
 6797     Register d = $dst$$Register;
 6798     if (s != d) {
 6799       __ movq(d, s);
 6800     }
 6801     __ decode_heap_oop(d);
 6802   %}
 6803   ins_pipe(ialu_reg_long);
 6804 %}
 6805 
 6806 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6807   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6808             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6809   match(Set dst (DecodeN src));
 6810   effect(KILL cr);
 6811   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6812   ins_encode %{
 6813     Register s = $src$$Register;
 6814     Register d = $dst$$Register;
 6815     if (s != d) {
 6816       __ decode_heap_oop_not_null(d, s);
 6817     } else {
 6818       __ decode_heap_oop_not_null(d);
 6819     }
 6820   %}
 6821   ins_pipe(ialu_reg_long);
 6822 %}
 6823 
 6824 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6825   match(Set dst (EncodePKlass src));
 6826   effect(KILL cr);
 6827   format %{ &quot;encode_klass_not_null $dst,$src&quot; %}
 6828   ins_encode %{
 6829     __ encode_klass_not_null($dst$$Register, $src$$Register);
 6830   %}
 6831   ins_pipe(ialu_reg_long);
 6832 %}
 6833 
 6834 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6835   match(Set dst (DecodeNKlass src));
 6836   effect(KILL cr);
 6837   format %{ &quot;decode_klass_not_null $dst,$src&quot; %}
 6838   ins_encode %{
 6839     Register s = $src$$Register;
 6840     Register d = $dst$$Register;
 6841     if (s != d) {
 6842       __ decode_klass_not_null(d, s);
 6843     } else {
 6844       __ decode_klass_not_null(d);
 6845     }
 6846   %}
 6847   ins_pipe(ialu_reg_long);
 6848 %}
 6849 
 6850 
 6851 //----------Conditional Move---------------------------------------------------
 6852 // Jump
 6853 // dummy instruction for generating temp registers
 6854 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6855   match(Jump (LShiftL switch_val shift));
 6856   ins_cost(350);
 6857   predicate(false);
 6858   effect(TEMP dest);
 6859 
 6860   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6861             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6862   ins_encode %{
 6863     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6864     // to do that and the compiler is using that register as one it can allocate.
 6865     // So we build it all by hand.
 6866     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6867     // ArrayAddress dispatch(table, index);
 6868     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6869     __ lea($dest$$Register, $constantaddress);
 6870     __ jmp(dispatch);
 6871   %}
 6872   ins_pipe(pipe_jmp);
 6873 %}
 6874 
 6875 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
 6876   match(Jump (AddL (LShiftL switch_val shift) offset));
 6877   ins_cost(350);
 6878   effect(TEMP dest);
 6879 
 6880   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6881             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t&quot; %}
 6882   ins_encode %{
 6883     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6884     // to do that and the compiler is using that register as one it can allocate.
 6885     // So we build it all by hand.
 6886     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6887     // ArrayAddress dispatch(table, index);
 6888     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6889     __ lea($dest$$Register, $constantaddress);
 6890     __ jmp(dispatch);
 6891   %}
 6892   ins_pipe(pipe_jmp);
 6893 %}
 6894 
 6895 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
 6896   match(Jump switch_val);
 6897   ins_cost(350);
 6898   effect(TEMP dest);
 6899 
 6900   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6901             &quot;jmp     [$dest + $switch_val]\n\t&quot; %}
 6902   ins_encode %{
 6903     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6904     // to do that and the compiler is using that register as one it can allocate.
 6905     // So we build it all by hand.
 6906     // Address index(noreg, switch_reg, Address::times_1);
 6907     // ArrayAddress dispatch(table, index);
 6908     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
 6909     __ lea($dest$$Register, $constantaddress);
 6910     __ jmp(dispatch);
 6911   %}
 6912   ins_pipe(pipe_jmp);
 6913 %}
 6914 
 6915 // Conditional move
 6916 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
 6917 %{
 6918   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6919 
 6920   ins_cost(200); // XXX
 6921   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6922   opcode(0x0F, 0x40);
 6923   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6924   ins_pipe(pipe_cmov_reg);
 6925 %}
 6926 
 6927 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
 6928   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6929 
 6930   ins_cost(200); // XXX
 6931   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6932   opcode(0x0F, 0x40);
 6933   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6934   ins_pipe(pipe_cmov_reg);
 6935 %}
 6936 
 6937 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
 6938   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6939   ins_cost(200);
 6940   expand %{
 6941     cmovI_regU(cop, cr, dst, src);
 6942   %}
 6943 %}
 6944 
 6945 // Conditional move
 6946 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
 6947   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6948 
 6949   ins_cost(250); // XXX
 6950   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6951   opcode(0x0F, 0x40);
 6952   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6953   ins_pipe(pipe_cmov_mem);
 6954 %}
 6955 
 6956 // Conditional move
 6957 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
 6958 %{
 6959   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6960 
 6961   ins_cost(250); // XXX
 6962   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6963   opcode(0x0F, 0x40);
 6964   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6965   ins_pipe(pipe_cmov_mem);
 6966 %}
 6967 
 6968 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
 6969   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6970   ins_cost(250);
 6971   expand %{
 6972     cmovI_memU(cop, cr, dst, src);
 6973   %}
 6974 %}
 6975 
 6976 // Conditional move
 6977 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
 6978 %{
 6979   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6980 
 6981   ins_cost(200); // XXX
 6982   format %{ &quot;cmovl$cop $dst, $src\t# signed, compressed ptr&quot; %}
 6983   opcode(0x0F, 0x40);
 6984   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6985   ins_pipe(pipe_cmov_reg);
 6986 %}
 6987 
 6988 // Conditional move
 6989 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
 6990 %{
 6991   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6992 
 6993   ins_cost(200); // XXX
 6994   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, compressed ptr&quot; %}
 6995   opcode(0x0F, 0x40);
 6996   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6997   ins_pipe(pipe_cmov_reg);
 6998 %}
 6999 
 7000 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
 7001   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7002   ins_cost(200);
 7003   expand %{
 7004     cmovN_regU(cop, cr, dst, src);
 7005   %}
 7006 %}
 7007 
 7008 // Conditional move
 7009 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
 7010 %{
 7011   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7012 
 7013   ins_cost(200); // XXX
 7014   format %{ &quot;cmovq$cop $dst, $src\t# signed, ptr&quot; %}
 7015   opcode(0x0F, 0x40);
 7016   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7017   ins_pipe(pipe_cmov_reg);  // XXX
 7018 %}
 7019 
 7020 // Conditional move
 7021 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
 7022 %{
 7023   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7024 
 7025   ins_cost(200); // XXX
 7026   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, ptr&quot; %}
 7027   opcode(0x0F, 0x40);
 7028   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7029   ins_pipe(pipe_cmov_reg); // XXX
 7030 %}
 7031 
 7032 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
 7033   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7034   ins_cost(200);
 7035   expand %{
 7036     cmovP_regU(cop, cr, dst, src);
 7037   %}
 7038 %}
 7039 
 7040 // DISABLED: Requires the ADLC to emit a bottom_type call that
 7041 // correctly meets the two pointer arguments; one is an incoming
 7042 // register but the other is a memory operand.  ALSO appears to
 7043 // be buggy with implicit null checks.
 7044 //
 7045 //// Conditional move
 7046 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
 7047 //%{
 7048 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7049 //  ins_cost(250);
 7050 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7051 //  opcode(0x0F,0x40);
 7052 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7053 //  ins_pipe( pipe_cmov_mem );
 7054 //%}
 7055 //
 7056 //// Conditional move
 7057 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
 7058 //%{
 7059 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7060 //  ins_cost(250);
 7061 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7062 //  opcode(0x0F,0x40);
 7063 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7064 //  ins_pipe( pipe_cmov_mem );
 7065 //%}
 7066 
 7067 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
 7068 %{
 7069   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7070 
 7071   ins_cost(200); // XXX
 7072   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7073   opcode(0x0F, 0x40);
 7074   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7075   ins_pipe(pipe_cmov_reg);  // XXX
 7076 %}
 7077 
 7078 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
 7079 %{
 7080   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7081 
 7082   ins_cost(200); // XXX
 7083   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7084   opcode(0x0F, 0x40);
 7085   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7086   ins_pipe(pipe_cmov_mem);  // XXX
 7087 %}
 7088 
 7089 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
 7090 %{
 7091   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7092 
 7093   ins_cost(200); // XXX
 7094   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7095   opcode(0x0F, 0x40);
 7096   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7097   ins_pipe(pipe_cmov_reg); // XXX
 7098 %}
 7099 
 7100 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
 7101   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7102   ins_cost(200);
 7103   expand %{
 7104     cmovL_regU(cop, cr, dst, src);
 7105   %}
 7106 %}
 7107 
 7108 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
 7109 %{
 7110   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7111 
 7112   ins_cost(200); // XXX
 7113   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7114   opcode(0x0F, 0x40);
 7115   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7116   ins_pipe(pipe_cmov_mem); // XXX
 7117 %}
 7118 
 7119 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
 7120   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7121   ins_cost(200);
 7122   expand %{
 7123     cmovL_memU(cop, cr, dst, src);
 7124   %}
 7125 %}
 7126 
 7127 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
 7128 %{
 7129   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7130 
 7131   ins_cost(200); // XXX
 7132   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7133             &quot;movss     $dst, $src\n&quot;
 7134     &quot;skip:&quot; %}
 7135   ins_encode %{
 7136     Label Lskip;
 7137     // Invert sense of branch from sense of CMOV
 7138     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7139     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7140     __ bind(Lskip);
 7141   %}
 7142   ins_pipe(pipe_slow);
 7143 %}
 7144 
 7145 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
 7146 // %{
 7147 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
 7148 
 7149 //   ins_cost(200); // XXX
 7150 //   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7151 //             &quot;movss     $dst, $src\n&quot;
 7152 //     &quot;skip:&quot; %}
 7153 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
 7154 //   ins_pipe(pipe_slow);
 7155 // %}
 7156 
 7157 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
 7158 %{
 7159   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7160 
 7161   ins_cost(200); // XXX
 7162   format %{ &quot;jn$cop    skip\t# unsigned cmove float\n\t&quot;
 7163             &quot;movss     $dst, $src\n&quot;
 7164     &quot;skip:&quot; %}
 7165   ins_encode %{
 7166     Label Lskip;
 7167     // Invert sense of branch from sense of CMOV
 7168     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7169     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7170     __ bind(Lskip);
 7171   %}
 7172   ins_pipe(pipe_slow);
 7173 %}
 7174 
 7175 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
 7176   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7177   ins_cost(200);
 7178   expand %{
 7179     cmovF_regU(cop, cr, dst, src);
 7180   %}
 7181 %}
 7182 
 7183 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
 7184 %{
 7185   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7186 
 7187   ins_cost(200); // XXX
 7188   format %{ &quot;jn$cop    skip\t# signed cmove double\n\t&quot;
 7189             &quot;movsd     $dst, $src\n&quot;
 7190     &quot;skip:&quot; %}
 7191   ins_encode %{
 7192     Label Lskip;
 7193     // Invert sense of branch from sense of CMOV
 7194     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7195     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7196     __ bind(Lskip);
 7197   %}
 7198   ins_pipe(pipe_slow);
 7199 %}
 7200 
 7201 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
 7202 %{
 7203   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7204 
 7205   ins_cost(200); // XXX
 7206   format %{ &quot;jn$cop    skip\t# unsigned cmove double\n\t&quot;
 7207             &quot;movsd     $dst, $src\n&quot;
 7208     &quot;skip:&quot; %}
 7209   ins_encode %{
 7210     Label Lskip;
 7211     // Invert sense of branch from sense of CMOV
 7212     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7213     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7214     __ bind(Lskip);
 7215   %}
 7216   ins_pipe(pipe_slow);
 7217 %}
 7218 
 7219 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
 7220   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7221   ins_cost(200);
 7222   expand %{
 7223     cmovD_regU(cop, cr, dst, src);
 7224   %}
 7225 %}
 7226 
 7227 //----------Arithmetic Instructions--------------------------------------------
 7228 //----------Addition Instructions----------------------------------------------
 7229 
 7230 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 7231 %{
 7232   match(Set dst (AddI dst src));
 7233   effect(KILL cr);
 7234 
 7235   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7236   opcode(0x03);
 7237   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 7238   ins_pipe(ialu_reg_reg);
 7239 %}
 7240 
 7241 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 7242 %{
 7243   match(Set dst (AddI dst src));
 7244   effect(KILL cr);
 7245 
 7246   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7247   opcode(0x81, 0x00); /* /0 id */
 7248   ins_encode(OpcSErm(dst, src), Con8or32(src));
 7249   ins_pipe( ialu_reg );
 7250 %}
 7251 
 7252 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 7253 %{
 7254   match(Set dst (AddI dst (LoadI src)));
 7255   effect(KILL cr);
 7256 
 7257   ins_cost(125); // XXX
 7258   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7259   opcode(0x03);
 7260   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 7261   ins_pipe(ialu_reg_mem);
 7262 %}
 7263 
 7264 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 7265 %{
 7266   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7267   effect(KILL cr);
 7268 
 7269   ins_cost(150); // XXX
 7270   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7271   opcode(0x01); /* Opcode 01 /r */
 7272   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 7273   ins_pipe(ialu_mem_reg);
 7274 %}
 7275 
 7276 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
 7277 %{
 7278   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7279   effect(KILL cr);
 7280 
 7281   ins_cost(125); // XXX
 7282   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7283   opcode(0x81); /* Opcode 81 /0 id */
 7284   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7285   ins_pipe(ialu_mem_imm);
 7286 %}
 7287 
 7288 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
 7289 %{
 7290   predicate(UseIncDec);
 7291   match(Set dst (AddI dst src));
 7292   effect(KILL cr);
 7293 
 7294   format %{ &quot;incl    $dst\t# int&quot; %}
 7295   opcode(0xFF, 0x00); // FF /0
 7296   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7297   ins_pipe(ialu_reg);
 7298 %}
 7299 
 7300 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
 7301 %{
 7302   predicate(UseIncDec);
 7303   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7304   effect(KILL cr);
 7305 
 7306   ins_cost(125); // XXX
 7307   format %{ &quot;incl    $dst\t# int&quot; %}
 7308   opcode(0xFF); /* Opcode FF /0 */
 7309   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
 7310   ins_pipe(ialu_mem_imm);
 7311 %}
 7312 
 7313 // XXX why does that use AddI
 7314 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
 7315 %{
 7316   predicate(UseIncDec);
 7317   match(Set dst (AddI dst src));
 7318   effect(KILL cr);
 7319 
 7320   format %{ &quot;decl    $dst\t# int&quot; %}
 7321   opcode(0xFF, 0x01); // FF /1
 7322   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7323   ins_pipe(ialu_reg);
 7324 %}
 7325 
 7326 // XXX why does that use AddI
 7327 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
 7328 %{
 7329   predicate(UseIncDec);
 7330   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7331   effect(KILL cr);
 7332 
 7333   ins_cost(125); // XXX
 7334   format %{ &quot;decl    $dst\t# int&quot; %}
 7335   opcode(0xFF); /* Opcode FF /1 */
 7336   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
 7337   ins_pipe(ialu_mem_imm);
 7338 %}
 7339 
 7340 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
 7341 %{
 7342   match(Set dst (AddI src0 src1));
 7343 
 7344   ins_cost(110);
 7345   format %{ &quot;addr32 leal $dst, [$src0 + $src1]\t# int&quot; %}
 7346   opcode(0x8D); /* 0x8D /r */
 7347   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7348   ins_pipe(ialu_reg_reg);
 7349 %}
 7350 
 7351 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 7352 %{
 7353   match(Set dst (AddL dst src));
 7354   effect(KILL cr);
 7355 
 7356   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7357   opcode(0x03);
 7358   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7359   ins_pipe(ialu_reg_reg);
 7360 %}
 7361 
 7362 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 7363 %{
 7364   match(Set dst (AddL dst src));
 7365   effect(KILL cr);
 7366 
 7367   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7368   opcode(0x81, 0x00); /* /0 id */
 7369   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7370   ins_pipe( ialu_reg );
 7371 %}
 7372 
 7373 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 7374 %{
 7375   match(Set dst (AddL dst (LoadL src)));
 7376   effect(KILL cr);
 7377 
 7378   ins_cost(125); // XXX
 7379   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7380   opcode(0x03);
 7381   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 7382   ins_pipe(ialu_reg_mem);
 7383 %}
 7384 
 7385 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 7386 %{
 7387   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7388   effect(KILL cr);
 7389 
 7390   ins_cost(150); // XXX
 7391   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7392   opcode(0x01); /* Opcode 01 /r */
 7393   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 7394   ins_pipe(ialu_mem_reg);
 7395 %}
 7396 
 7397 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 7398 %{
 7399   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7400   effect(KILL cr);
 7401 
 7402   ins_cost(125); // XXX
 7403   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7404   opcode(0x81); /* Opcode 81 /0 id */
 7405   ins_encode(REX_mem_wide(dst),
 7406              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7407   ins_pipe(ialu_mem_imm);
 7408 %}
 7409 
 7410 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
 7411 %{
 7412   predicate(UseIncDec);
 7413   match(Set dst (AddL dst src));
 7414   effect(KILL cr);
 7415 
 7416   format %{ &quot;incq    $dst\t# long&quot; %}
 7417   opcode(0xFF, 0x00); // FF /0
 7418   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7419   ins_pipe(ialu_reg);
 7420 %}
 7421 
 7422 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
 7423 %{
 7424   predicate(UseIncDec);
 7425   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7426   effect(KILL cr);
 7427 
 7428   ins_cost(125); // XXX
 7429   format %{ &quot;incq    $dst\t# long&quot; %}
 7430   opcode(0xFF); /* Opcode FF /0 */
 7431   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
 7432   ins_pipe(ialu_mem_imm);
 7433 %}
 7434 
 7435 // XXX why does that use AddL
 7436 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
 7437 %{
 7438   predicate(UseIncDec);
 7439   match(Set dst (AddL dst src));
 7440   effect(KILL cr);
 7441 
 7442   format %{ &quot;decq    $dst\t# long&quot; %}
 7443   opcode(0xFF, 0x01); // FF /1
 7444   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7445   ins_pipe(ialu_reg);
 7446 %}
 7447 
 7448 // XXX why does that use AddL
 7449 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
 7450 %{
 7451   predicate(UseIncDec);
 7452   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7453   effect(KILL cr);
 7454 
 7455   ins_cost(125); // XXX
 7456   format %{ &quot;decq    $dst\t# long&quot; %}
 7457   opcode(0xFF); /* Opcode FF /1 */
 7458   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
 7459   ins_pipe(ialu_mem_imm);
 7460 %}
 7461 
 7462 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
 7463 %{
 7464   match(Set dst (AddL src0 src1));
 7465 
 7466   ins_cost(110);
 7467   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# long&quot; %}
 7468   opcode(0x8D); /* 0x8D /r */
 7469   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7470   ins_pipe(ialu_reg_reg);
 7471 %}
 7472 
 7473 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
 7474 %{
 7475   match(Set dst (AddP dst src));
 7476   effect(KILL cr);
 7477 
 7478   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7479   opcode(0x03);
 7480   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7481   ins_pipe(ialu_reg_reg);
 7482 %}
 7483 
 7484 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
 7485 %{
 7486   match(Set dst (AddP dst src));
 7487   effect(KILL cr);
 7488 
 7489   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7490   opcode(0x81, 0x00); /* /0 id */
 7491   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7492   ins_pipe( ialu_reg );
 7493 %}
 7494 
 7495 // XXX addP mem ops ????
 7496 
 7497 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
 7498 %{
 7499   match(Set dst (AddP src0 src1));
 7500 
 7501   ins_cost(110);
 7502   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# ptr&quot; %}
 7503   opcode(0x8D); /* 0x8D /r */
 7504   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
 7505   ins_pipe(ialu_reg_reg);
 7506 %}
 7507 
 7508 instruct checkCastPP(rRegP dst)
 7509 %{
 7510   match(Set dst (CheckCastPP dst));
 7511 
 7512   size(0);
 7513   format %{ &quot;# checkcastPP of $dst&quot; %}
 7514   ins_encode(/* empty encoding */);
 7515   ins_pipe(empty);
 7516 %}
 7517 
 7518 instruct castPP(rRegP dst)
 7519 %{
 7520   match(Set dst (CastPP dst));
 7521 
 7522   size(0);
 7523   format %{ &quot;# castPP of $dst&quot; %}
 7524   ins_encode(/* empty encoding */);
 7525   ins_pipe(empty);
 7526 %}
 7527 
 7528 instruct castII(rRegI dst)
 7529 %{
 7530   match(Set dst (CastII dst));
 7531 
 7532   size(0);
 7533   format %{ &quot;# castII of $dst&quot; %}
 7534   ins_encode(/* empty encoding */);
 7535   ins_cost(0);
 7536   ins_pipe(empty);
 7537 %}
 7538 
 7539 instruct castLL(rRegL dst)
 7540 %{
 7541   match(Set dst (CastLL dst));
 7542 
 7543   size(0);
 7544   format %{ &quot;# castLL of $dst&quot; %}
 7545   ins_encode(/* empty encoding */);
 7546   ins_cost(0);
 7547   ins_pipe(empty);
 7548 %}
 7549 
 7550 // LoadP-locked same as a regular LoadP when used with compare-swap
 7551 instruct loadPLocked(rRegP dst, memory mem)
 7552 %{
 7553   match(Set dst (LoadPLocked mem));
 7554 
 7555   ins_cost(125); // XXX
 7556   format %{ &quot;movq    $dst, $mem\t# ptr locked&quot; %}
 7557   opcode(0x8B);
 7558   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 7559   ins_pipe(ialu_reg_mem); // XXX
 7560 %}
 7561 
 7562 // Conditional-store of the updated heap-top.
 7563 // Used during allocation of the shared heap.
 7564 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7565 
 7566 instruct storePConditional(memory heap_top_ptr,
 7567                            rax_RegP oldval, rRegP newval,
 7568                            rFlagsReg cr)
 7569 %{
 7570   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7571   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7572 
 7573   format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
 7574             &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
 7575   opcode(0x0F, 0xB1);
 7576   ins_encode(lock_prefix,
 7577              REX_reg_mem_wide(newval, heap_top_ptr),
 7578              OpcP, OpcS,
 7579              reg_mem(newval, heap_top_ptr));
 7580   ins_pipe(pipe_cmpxchg);
 7581 %}
 7582 
 7583 // Conditional-store of an int value.
 7584 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7585 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
 7586 %{
 7587   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7588   effect(KILL oldval);
 7589 
 7590   format %{ &quot;cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7591   opcode(0x0F, 0xB1);
 7592   ins_encode(lock_prefix,
 7593              REX_reg_mem(newval, mem),
 7594              OpcP, OpcS,
 7595              reg_mem(newval, mem));
 7596   ins_pipe(pipe_cmpxchg);
 7597 %}
 7598 
 7599 // Conditional-store of a long value.
 7600 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7601 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
 7602 %{
 7603   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7604   effect(KILL oldval);
 7605 
 7606   format %{ &quot;cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7607   opcode(0x0F, 0xB1);
 7608   ins_encode(lock_prefix,
 7609              REX_reg_mem_wide(newval, mem),
 7610              OpcP, OpcS,
 7611              reg_mem(newval, mem));
 7612   ins_pipe(pipe_cmpxchg);
 7613 %}
 7614 
 7615 
 7616 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7617 instruct compareAndSwapP(rRegI res,
 7618                          memory mem_ptr,
 7619                          rax_RegP oldval, rRegP newval,
 7620                          rFlagsReg cr)
 7621 %{
 7622   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7623   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7624   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7625   effect(KILL cr, KILL oldval);
 7626 
 7627   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7628             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7629             &quot;sete    $res\n\t&quot;
 7630             &quot;movzbl  $res, $res&quot; %}
 7631   opcode(0x0F, 0xB1);
 7632   ins_encode(lock_prefix,
 7633              REX_reg_mem_wide(newval, mem_ptr),
 7634              OpcP, OpcS,
 7635              reg_mem(newval, mem_ptr),
 7636              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7637              REX_reg_breg(res, res), // movzbl
 7638              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7639   ins_pipe( pipe_cmpxchg );
 7640 %}
 7641 
 7642 instruct compareAndSwapL(rRegI res,
 7643                          memory mem_ptr,
 7644                          rax_RegL oldval, rRegL newval,
 7645                          rFlagsReg cr)
 7646 %{
 7647   predicate(VM_Version::supports_cx8());
 7648   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7649   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7650   effect(KILL cr, KILL oldval);
 7651 
 7652   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7653             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7654             &quot;sete    $res\n\t&quot;
 7655             &quot;movzbl  $res, $res&quot; %}
 7656   opcode(0x0F, 0xB1);
 7657   ins_encode(lock_prefix,
 7658              REX_reg_mem_wide(newval, mem_ptr),
 7659              OpcP, OpcS,
 7660              reg_mem(newval, mem_ptr),
 7661              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7662              REX_reg_breg(res, res), // movzbl
 7663              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7664   ins_pipe( pipe_cmpxchg );
 7665 %}
 7666 
 7667 instruct compareAndSwapI(rRegI res,
 7668                          memory mem_ptr,
 7669                          rax_RegI oldval, rRegI newval,
 7670                          rFlagsReg cr)
 7671 %{
 7672   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7673   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7674   effect(KILL cr, KILL oldval);
 7675 
 7676   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7677             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7678             &quot;sete    $res\n\t&quot;
 7679             &quot;movzbl  $res, $res&quot; %}
 7680   opcode(0x0F, 0xB1);
 7681   ins_encode(lock_prefix,
 7682              REX_reg_mem(newval, mem_ptr),
 7683              OpcP, OpcS,
 7684              reg_mem(newval, mem_ptr),
 7685              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7686              REX_reg_breg(res, res), // movzbl
 7687              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7688   ins_pipe( pipe_cmpxchg );
 7689 %}
 7690 
 7691 instruct compareAndSwapB(rRegI res,
 7692                          memory mem_ptr,
 7693                          rax_RegI oldval, rRegI newval,
 7694                          rFlagsReg cr)
 7695 %{
 7696   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7697   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7698   effect(KILL cr, KILL oldval);
 7699 
 7700   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7701             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7702             &quot;sete    $res\n\t&quot;
 7703             &quot;movzbl  $res, $res&quot; %}
 7704   opcode(0x0F, 0xB0);
 7705   ins_encode(lock_prefix,
 7706              REX_breg_mem(newval, mem_ptr),
 7707              OpcP, OpcS,
 7708              reg_mem(newval, mem_ptr),
 7709              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7710              REX_reg_breg(res, res), // movzbl
 7711              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7712   ins_pipe( pipe_cmpxchg );
 7713 %}
 7714 
 7715 instruct compareAndSwapS(rRegI res,
 7716                          memory mem_ptr,
 7717                          rax_RegI oldval, rRegI newval,
 7718                          rFlagsReg cr)
 7719 %{
 7720   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7721   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7722   effect(KILL cr, KILL oldval);
 7723 
 7724   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7725             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7726             &quot;sete    $res\n\t&quot;
 7727             &quot;movzbl  $res, $res&quot; %}
 7728   opcode(0x0F, 0xB1);
 7729   ins_encode(lock_prefix,
 7730              SizePrefix,
 7731              REX_reg_mem(newval, mem_ptr),
 7732              OpcP, OpcS,
 7733              reg_mem(newval, mem_ptr),
 7734              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7735              REX_reg_breg(res, res), // movzbl
 7736              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7737   ins_pipe( pipe_cmpxchg );
 7738 %}
 7739 
 7740 instruct compareAndSwapN(rRegI res,
 7741                           memory mem_ptr,
 7742                           rax_RegN oldval, rRegN newval,
 7743                           rFlagsReg cr) %{
 7744   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 7745   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 7746   effect(KILL cr, KILL oldval);
 7747 
 7748   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7749             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7750             &quot;sete    $res\n\t&quot;
 7751             &quot;movzbl  $res, $res&quot; %}
 7752   opcode(0x0F, 0xB1);
 7753   ins_encode(lock_prefix,
 7754              REX_reg_mem(newval, mem_ptr),
 7755              OpcP, OpcS,
 7756              reg_mem(newval, mem_ptr),
 7757              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7758              REX_reg_breg(res, res), // movzbl
 7759              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7760   ins_pipe( pipe_cmpxchg );
 7761 %}
 7762 
 7763 instruct compareAndExchangeB(
 7764                          memory mem_ptr,
 7765                          rax_RegI oldval, rRegI newval,
 7766                          rFlagsReg cr)
 7767 %{
 7768   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7769   effect(KILL cr);
 7770 
 7771   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7772             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7773   opcode(0x0F, 0xB0);
 7774   ins_encode(lock_prefix,
 7775              REX_breg_mem(newval, mem_ptr),
 7776              OpcP, OpcS,
 7777              reg_mem(newval, mem_ptr) // lock cmpxchg
 7778              );
 7779   ins_pipe( pipe_cmpxchg );
 7780 %}
 7781 
 7782 instruct compareAndExchangeS(
 7783                          memory mem_ptr,
 7784                          rax_RegI oldval, rRegI newval,
 7785                          rFlagsReg cr)
 7786 %{
 7787   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7788   effect(KILL cr);
 7789 
 7790   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7791             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7792   opcode(0x0F, 0xB1);
 7793   ins_encode(lock_prefix,
 7794              SizePrefix,
 7795              REX_reg_mem(newval, mem_ptr),
 7796              OpcP, OpcS,
 7797              reg_mem(newval, mem_ptr) // lock cmpxchg
 7798              );
 7799   ins_pipe( pipe_cmpxchg );
 7800 %}
 7801 
 7802 instruct compareAndExchangeI(
 7803                          memory mem_ptr,
 7804                          rax_RegI oldval, rRegI newval,
 7805                          rFlagsReg cr)
 7806 %{
 7807   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7808   effect(KILL cr);
 7809 
 7810   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7811             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7812   opcode(0x0F, 0xB1);
 7813   ins_encode(lock_prefix,
 7814              REX_reg_mem(newval, mem_ptr),
 7815              OpcP, OpcS,
 7816              reg_mem(newval, mem_ptr) // lock cmpxchg
 7817              );
 7818   ins_pipe( pipe_cmpxchg );
 7819 %}
 7820 
 7821 instruct compareAndExchangeL(
 7822                          memory mem_ptr,
 7823                          rax_RegL oldval, rRegL newval,
 7824                          rFlagsReg cr)
 7825 %{
 7826   predicate(VM_Version::supports_cx8());
 7827   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7828   effect(KILL cr);
 7829 
 7830   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7831             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7832   opcode(0x0F, 0xB1);
 7833   ins_encode(lock_prefix,
 7834              REX_reg_mem_wide(newval, mem_ptr),
 7835              OpcP, OpcS,
 7836              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7837             );
 7838   ins_pipe( pipe_cmpxchg );
 7839 %}
 7840 
 7841 instruct compareAndExchangeN(
 7842                           memory mem_ptr,
 7843                           rax_RegN oldval, rRegN newval,
 7844                           rFlagsReg cr) %{
 7845   match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7846   effect(KILL cr);
 7847 
 7848   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7849             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7850   opcode(0x0F, 0xB1);
 7851   ins_encode(lock_prefix,
 7852              REX_reg_mem(newval, mem_ptr),
 7853              OpcP, OpcS,
 7854              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7855           );
 7856   ins_pipe( pipe_cmpxchg );
 7857 %}
 7858 
 7859 instruct compareAndExchangeP(
 7860                          memory mem_ptr,
 7861                          rax_RegP oldval, rRegP newval,
 7862                          rFlagsReg cr)
 7863 %{
 7864   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7865   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7866   effect(KILL cr);
 7867 
 7868   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7869             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7870   opcode(0x0F, 0xB1);
 7871   ins_encode(lock_prefix,
 7872              REX_reg_mem_wide(newval, mem_ptr),
 7873              OpcP, OpcS,
 7874              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7875           );
 7876   ins_pipe( pipe_cmpxchg );
 7877 %}
 7878 
 7879 instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7880   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7881   match(Set dummy (GetAndAddB mem add));
 7882   effect(KILL cr);
 7883   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7884   ins_encode %{
 7885     __ lock();
 7886     __ addb($mem$$Address, $add$$constant);
 7887   %}
 7888   ins_pipe( pipe_cmpxchg );
 7889 %}
 7890 
 7891 instruct xaddB( memory mem, rRegI newval, rFlagsReg cr) %{
 7892   match(Set newval (GetAndAddB mem newval));
 7893   effect(KILL cr);
 7894   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7895   ins_encode %{
 7896     __ lock();
 7897     __ xaddb($mem$$Address, $newval$$Register);
 7898   %}
 7899   ins_pipe( pipe_cmpxchg );
 7900 %}
 7901 
 7902 instruct xaddS_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7903   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7904   match(Set dummy (GetAndAddS mem add));
 7905   effect(KILL cr);
 7906   format %{ &quot;ADDW  [$mem],$add&quot; %}
 7907   ins_encode %{
 7908     __ lock();
 7909     __ addw($mem$$Address, $add$$constant);
 7910   %}
 7911   ins_pipe( pipe_cmpxchg );
 7912 %}
 7913 
 7914 instruct xaddS( memory mem, rRegI newval, rFlagsReg cr) %{
 7915   match(Set newval (GetAndAddS mem newval));
 7916   effect(KILL cr);
 7917   format %{ &quot;XADDW  [$mem],$newval&quot; %}
 7918   ins_encode %{
 7919     __ lock();
 7920     __ xaddw($mem$$Address, $newval$$Register);
 7921   %}
 7922   ins_pipe( pipe_cmpxchg );
 7923 %}
 7924 
 7925 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7926   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7927   match(Set dummy (GetAndAddI mem add));
 7928   effect(KILL cr);
 7929   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7930   ins_encode %{
 7931     __ lock();
 7932     __ addl($mem$$Address, $add$$constant);
 7933   %}
 7934   ins_pipe( pipe_cmpxchg );
 7935 %}
 7936 
 7937 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
 7938   match(Set newval (GetAndAddI mem newval));
 7939   effect(KILL cr);
 7940   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7941   ins_encode %{
 7942     __ lock();
 7943     __ xaddl($mem$$Address, $newval$$Register);
 7944   %}
 7945   ins_pipe( pipe_cmpxchg );
 7946 %}
 7947 
 7948 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
 7949   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7950   match(Set dummy (GetAndAddL mem add));
 7951   effect(KILL cr);
 7952   format %{ &quot;ADDQ  [$mem],$add&quot; %}
 7953   ins_encode %{
 7954     __ lock();
 7955     __ addq($mem$$Address, $add$$constant);
 7956   %}
 7957   ins_pipe( pipe_cmpxchg );
 7958 %}
 7959 
 7960 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
 7961   match(Set newval (GetAndAddL mem newval));
 7962   effect(KILL cr);
 7963   format %{ &quot;XADDQ  [$mem],$newval&quot; %}
 7964   ins_encode %{
 7965     __ lock();
 7966     __ xaddq($mem$$Address, $newval$$Register);
 7967   %}
 7968   ins_pipe( pipe_cmpxchg );
 7969 %}
 7970 
 7971 instruct xchgB( memory mem, rRegI newval) %{
 7972   match(Set newval (GetAndSetB mem newval));
 7973   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7974   ins_encode %{
 7975     __ xchgb($newval$$Register, $mem$$Address);
 7976   %}
 7977   ins_pipe( pipe_cmpxchg );
 7978 %}
 7979 
 7980 instruct xchgS( memory mem, rRegI newval) %{
 7981   match(Set newval (GetAndSetS mem newval));
 7982   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7983   ins_encode %{
 7984     __ xchgw($newval$$Register, $mem$$Address);
 7985   %}
 7986   ins_pipe( pipe_cmpxchg );
 7987 %}
 7988 
 7989 instruct xchgI( memory mem, rRegI newval) %{
 7990   match(Set newval (GetAndSetI mem newval));
 7991   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7992   ins_encode %{
 7993     __ xchgl($newval$$Register, $mem$$Address);
 7994   %}
 7995   ins_pipe( pipe_cmpxchg );
 7996 %}
 7997 
 7998 instruct xchgL( memory mem, rRegL newval) %{
 7999   match(Set newval (GetAndSetL mem newval));
 8000   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 8001   ins_encode %{
 8002     __ xchgq($newval$$Register, $mem$$Address);
 8003   %}
 8004   ins_pipe( pipe_cmpxchg );
 8005 %}
 8006 
 8007 instruct xchgP( memory mem, rRegP newval) %{
 8008   match(Set newval (GetAndSetP mem newval));
 8009   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 8010   format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
 8011   ins_encode %{
 8012     __ xchgq($newval$$Register, $mem$$Address);
 8013   %}
 8014   ins_pipe( pipe_cmpxchg );
 8015 %}
 8016 
 8017 instruct xchgN( memory mem, rRegN newval) %{
 8018   match(Set newval (GetAndSetN mem newval));
 8019   format %{ &quot;XCHGL  $newval,$mem]&quot; %}
 8020   ins_encode %{
 8021     __ xchgl($newval$$Register, $mem$$Address);
 8022   %}
 8023   ins_pipe( pipe_cmpxchg );
 8024 %}
 8025 
 8026 //----------Abs Instructions-------------------------------------------
 8027 
 8028 // Integer Absolute Instructions
 8029 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, rFlagsReg cr)
 8030 %{
 8031   match(Set dst (AbsI src));
 8032   effect(TEMP dst, TEMP tmp, KILL cr);
 8033   format %{ &quot;movl $tmp, $src\n\t&quot;
 8034             &quot;sarl $tmp, 31\n\t&quot;
 8035             &quot;movl $dst, $src\n\t&quot;
 8036             &quot;xorl $dst, $tmp\n\t&quot;
 8037             &quot;subl $dst, $tmp\n&quot;
 8038           %}
 8039   ins_encode %{
 8040     __ movl($tmp$$Register, $src$$Register);
 8041     __ sarl($tmp$$Register, 31);
 8042     __ movl($dst$$Register, $src$$Register);
 8043     __ xorl($dst$$Register, $tmp$$Register);
 8044     __ subl($dst$$Register, $tmp$$Register);
 8045   %}
 8046 
 8047   ins_pipe(ialu_reg_reg);
 8048 %}
 8049 
 8050 // Long Absolute Instructions
 8051 instruct absL_rReg(rRegL dst, rRegL src, rRegL tmp, rFlagsReg cr)
 8052 %{
 8053   match(Set dst (AbsL src));
 8054   effect(TEMP dst, TEMP tmp, KILL cr);
 8055   format %{ &quot;movq $tmp, $src\n\t&quot;
 8056             &quot;sarq $tmp, 63\n\t&quot;
 8057             &quot;movq $dst, $src\n\t&quot;
 8058             &quot;xorq $dst, $tmp\n\t&quot;
 8059             &quot;subq $dst, $tmp\n&quot;
 8060           %}
 8061   ins_encode %{
 8062     __ movq($tmp$$Register, $src$$Register);
 8063     __ sarq($tmp$$Register, 63);
 8064     __ movq($dst$$Register, $src$$Register);
 8065     __ xorq($dst$$Register, $tmp$$Register);
 8066     __ subq($dst$$Register, $tmp$$Register);
 8067   %}
 8068 
 8069   ins_pipe(ialu_reg_reg);
 8070 %}
 8071 
 8072 //----------Subtraction Instructions-------------------------------------------
 8073 
 8074 // Integer Subtraction Instructions
 8075 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8076 %{
 8077   match(Set dst (SubI dst src));
 8078   effect(KILL cr);
 8079 
 8080   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8081   opcode(0x2B);
 8082   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 8083   ins_pipe(ialu_reg_reg);
 8084 %}
 8085 
 8086 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 8087 %{
 8088   match(Set dst (SubI dst src));
 8089   effect(KILL cr);
 8090 
 8091   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8092   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8093   ins_encode(OpcSErm(dst, src), Con8or32(src));
 8094   ins_pipe(ialu_reg);
 8095 %}
 8096 
 8097 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 8098 %{
 8099   match(Set dst (SubI dst (LoadI src)));
 8100   effect(KILL cr);
 8101 
 8102   ins_cost(125);
 8103   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8104   opcode(0x2B);
 8105   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 8106   ins_pipe(ialu_reg_mem);
 8107 %}
 8108 
 8109 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 8110 %{
 8111   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8112   effect(KILL cr);
 8113 
 8114   ins_cost(150);
 8115   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8116   opcode(0x29); /* Opcode 29 /r */
 8117   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 8118   ins_pipe(ialu_mem_reg);
 8119 %}
 8120 
 8121 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
 8122 %{
 8123   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8124   effect(KILL cr);
 8125 
 8126   ins_cost(125); // XXX
 8127   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8128   opcode(0x81); /* Opcode 81 /5 id */
 8129   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8130   ins_pipe(ialu_mem_imm);
 8131 %}
 8132 
 8133 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8134 %{
 8135   match(Set dst (SubL dst src));
 8136   effect(KILL cr);
 8137 
 8138   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8139   opcode(0x2B);
 8140   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8141   ins_pipe(ialu_reg_reg);
 8142 %}
 8143 
 8144 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
 8145 %{
 8146   match(Set dst (SubL dst src));
 8147   effect(KILL cr);
 8148 
 8149   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8150   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8151   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 8152   ins_pipe(ialu_reg);
 8153 %}
 8154 
 8155 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 8156 %{
 8157   match(Set dst (SubL dst (LoadL src)));
 8158   effect(KILL cr);
 8159 
 8160   ins_cost(125);
 8161   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8162   opcode(0x2B);
 8163   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 8164   ins_pipe(ialu_reg_mem);
 8165 %}
 8166 
 8167 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 8168 %{
 8169   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8170   effect(KILL cr);
 8171 
 8172   ins_cost(150);
 8173   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8174   opcode(0x29); /* Opcode 29 /r */
 8175   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 8176   ins_pipe(ialu_mem_reg);
 8177 %}
 8178 
 8179 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 8180 %{
 8181   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8182   effect(KILL cr);
 8183 
 8184   ins_cost(125); // XXX
 8185   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8186   opcode(0x81); /* Opcode 81 /5 id */
 8187   ins_encode(REX_mem_wide(dst),
 8188              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8189   ins_pipe(ialu_mem_imm);
 8190 %}
 8191 
 8192 // Subtract from a pointer
 8193 // XXX hmpf???
 8194 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
 8195 %{
 8196   match(Set dst (AddP dst (SubI zero src)));
 8197   effect(KILL cr);
 8198 
 8199   format %{ &quot;subq    $dst, $src\t# ptr - int&quot; %}
 8200   opcode(0x2B);
 8201   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8202   ins_pipe(ialu_reg_reg);
 8203 %}
 8204 
 8205 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
 8206 %{
 8207   match(Set dst (SubI zero dst));
 8208   effect(KILL cr);
 8209 
 8210   format %{ &quot;negl    $dst\t# int&quot; %}
 8211   opcode(0xF7, 0x03);  // Opcode F7 /3
 8212   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8213   ins_pipe(ialu_reg);
 8214 %}
 8215 
 8216 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
 8217 %{
 8218   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
 8219   effect(KILL cr);
 8220 
 8221   format %{ &quot;negl    $dst\t# int&quot; %}
 8222   opcode(0xF7, 0x03);  // Opcode F7 /3
 8223   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8224   ins_pipe(ialu_reg);
 8225 %}
 8226 
 8227 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
 8228 %{
 8229   match(Set dst (SubL zero dst));
 8230   effect(KILL cr);
 8231 
 8232   format %{ &quot;negq    $dst\t# long&quot; %}
 8233   opcode(0xF7, 0x03);  // Opcode F7 /3
 8234   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8235   ins_pipe(ialu_reg);
 8236 %}
 8237 
 8238 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
 8239 %{
 8240   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
 8241   effect(KILL cr);
 8242 
 8243   format %{ &quot;negq    $dst\t# long&quot; %}
 8244   opcode(0xF7, 0x03);  // Opcode F7 /3
 8245   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8246   ins_pipe(ialu_reg);
 8247 %}
 8248 
 8249 //----------Multiplication/Division Instructions-------------------------------
 8250 // Integer Multiplication Instructions
 8251 // Multiply Register
 8252 
 8253 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8254 %{
 8255   match(Set dst (MulI dst src));
 8256   effect(KILL cr);
 8257 
 8258   ins_cost(300);
 8259   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8260   opcode(0x0F, 0xAF);
 8261   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8262   ins_pipe(ialu_reg_reg_alu0);
 8263 %}
 8264 
 8265 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
 8266 %{
 8267   match(Set dst (MulI src imm));
 8268   effect(KILL cr);
 8269 
 8270   ins_cost(300);
 8271   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8272   opcode(0x69); /* 69 /r id */
 8273   ins_encode(REX_reg_reg(dst, src),
 8274              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8275   ins_pipe(ialu_reg_reg_alu0);
 8276 %}
 8277 
 8278 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
 8279 %{
 8280   match(Set dst (MulI dst (LoadI src)));
 8281   effect(KILL cr);
 8282 
 8283   ins_cost(350);
 8284   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8285   opcode(0x0F, 0xAF);
 8286   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8287   ins_pipe(ialu_reg_mem_alu0);
 8288 %}
 8289 
 8290 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
 8291 %{
 8292   match(Set dst (MulI (LoadI src) imm));
 8293   effect(KILL cr);
 8294 
 8295   ins_cost(300);
 8296   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8297   opcode(0x69); /* 69 /r id */
 8298   ins_encode(REX_reg_mem(dst, src),
 8299              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8300   ins_pipe(ialu_reg_mem_alu0);
 8301 %}
 8302 
 8303 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, rFlagsReg cr)
 8304 %{
 8305   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 8306   effect(KILL cr, KILL src2);
 8307 
 8308   expand %{ mulI_rReg(dst, src1, cr);
 8309            mulI_rReg(src2, src3, cr);
 8310            addI_rReg(dst, src2, cr); %}
 8311 %}
 8312 
 8313 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8314 %{
 8315   match(Set dst (MulL dst src));
 8316   effect(KILL cr);
 8317 
 8318   ins_cost(300);
 8319   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8320   opcode(0x0F, 0xAF);
 8321   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8322   ins_pipe(ialu_reg_reg_alu0);
 8323 %}
 8324 
 8325 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
 8326 %{
 8327   match(Set dst (MulL src imm));
 8328   effect(KILL cr);
 8329 
 8330   ins_cost(300);
 8331   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8332   opcode(0x69); /* 69 /r id */
 8333   ins_encode(REX_reg_reg_wide(dst, src),
 8334              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8335   ins_pipe(ialu_reg_reg_alu0);
 8336 %}
 8337 
 8338 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
 8339 %{
 8340   match(Set dst (MulL dst (LoadL src)));
 8341   effect(KILL cr);
 8342 
 8343   ins_cost(350);
 8344   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8345   opcode(0x0F, 0xAF);
 8346   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8347   ins_pipe(ialu_reg_mem_alu0);
 8348 %}
 8349 
 8350 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
 8351 %{
 8352   match(Set dst (MulL (LoadL src) imm));
 8353   effect(KILL cr);
 8354 
 8355   ins_cost(300);
 8356   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8357   opcode(0x69); /* 69 /r id */
 8358   ins_encode(REX_reg_mem_wide(dst, src),
 8359              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8360   ins_pipe(ialu_reg_mem_alu0);
 8361 %}
 8362 
 8363 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8364 %{
 8365   match(Set dst (MulHiL src rax));
 8366   effect(USE_KILL rax, KILL cr);
 8367 
 8368   ins_cost(300);
 8369   format %{ &quot;imulq   RDX:RAX, RAX, $src\t# mulhi&quot; %}
 8370   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8371   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8372   ins_pipe(ialu_reg_reg_alu0);
 8373 %}
 8374 
 8375 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8376                    rFlagsReg cr)
 8377 %{
 8378   match(Set rax (DivI rax div));
 8379   effect(KILL rdx, KILL cr);
 8380 
 8381   ins_cost(30*100+10*100); // XXX
 8382   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8383             &quot;jne,s   normal\n\t&quot;
 8384             &quot;xorl    rdx, rdx\n\t&quot;
 8385             &quot;cmpl    $div, -1\n\t&quot;
 8386             &quot;je,s    done\n&quot;
 8387     &quot;normal: cdql\n\t&quot;
 8388             &quot;idivl   $div\n&quot;
 8389     &quot;done:&quot;        %}
 8390   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8391   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8392   ins_pipe(ialu_reg_reg_alu0);
 8393 %}
 8394 
 8395 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8396                    rFlagsReg cr)
 8397 %{
 8398   match(Set rax (DivL rax div));
 8399   effect(KILL rdx, KILL cr);
 8400 
 8401   ins_cost(30*100+10*100); // XXX
 8402   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8403             &quot;cmpq    rax, rdx\n\t&quot;
 8404             &quot;jne,s   normal\n\t&quot;
 8405             &quot;xorl    rdx, rdx\n\t&quot;
 8406             &quot;cmpq    $div, -1\n\t&quot;
 8407             &quot;je,s    done\n&quot;
 8408     &quot;normal: cdqq\n\t&quot;
 8409             &quot;idivq   $div\n&quot;
 8410     &quot;done:&quot;        %}
 8411   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8412   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8413   ins_pipe(ialu_reg_reg_alu0);
 8414 %}
 8415 
 8416 // Integer DIVMOD with Register, both quotient and mod results
 8417 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8418                              rFlagsReg cr)
 8419 %{
 8420   match(DivModI rax div);
 8421   effect(KILL cr);
 8422 
 8423   ins_cost(30*100+10*100); // XXX
 8424   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8425             &quot;jne,s   normal\n\t&quot;
 8426             &quot;xorl    rdx, rdx\n\t&quot;
 8427             &quot;cmpl    $div, -1\n\t&quot;
 8428             &quot;je,s    done\n&quot;
 8429     &quot;normal: cdql\n\t&quot;
 8430             &quot;idivl   $div\n&quot;
 8431     &quot;done:&quot;        %}
 8432   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8433   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8434   ins_pipe(pipe_slow);
 8435 %}
 8436 
 8437 // Long DIVMOD with Register, both quotient and mod results
 8438 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8439                              rFlagsReg cr)
 8440 %{
 8441   match(DivModL rax div);
 8442   effect(KILL cr);
 8443 
 8444   ins_cost(30*100+10*100); // XXX
 8445   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8446             &quot;cmpq    rax, rdx\n\t&quot;
 8447             &quot;jne,s   normal\n\t&quot;
 8448             &quot;xorl    rdx, rdx\n\t&quot;
 8449             &quot;cmpq    $div, -1\n\t&quot;
 8450             &quot;je,s    done\n&quot;
 8451     &quot;normal: cdqq\n\t&quot;
 8452             &quot;idivq   $div\n&quot;
 8453     &quot;done:&quot;        %}
 8454   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8455   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8456   ins_pipe(pipe_slow);
 8457 %}
 8458 
 8459 //----------- DivL-By-Constant-Expansions--------------------------------------
 8460 // DivI cases are handled by the compiler
 8461 
 8462 // Magic constant, reciprocal of 10
 8463 instruct loadConL_0x6666666666666667(rRegL dst)
 8464 %{
 8465   effect(DEF dst);
 8466 
 8467   format %{ &quot;movq    $dst, #0x666666666666667\t# Used in div-by-10&quot; %}
 8468   ins_encode(load_immL(dst, 0x6666666666666667));
 8469   ins_pipe(ialu_reg);
 8470 %}
 8471 
 8472 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8473 %{
 8474   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
 8475 
 8476   format %{ &quot;imulq   rdx:rax, rax, $src\t# Used in div-by-10&quot; %}
 8477   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8478   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8479   ins_pipe(ialu_reg_reg_alu0);
 8480 %}
 8481 
 8482 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
 8483 %{
 8484   effect(USE_DEF dst, KILL cr);
 8485 
 8486   format %{ &quot;sarq    $dst, #63\t# Used in div-by-10&quot; %}
 8487   opcode(0xC1, 0x7); /* C1 /7 ib */
 8488   ins_encode(reg_opc_imm_wide(dst, 0x3F));
 8489   ins_pipe(ialu_reg);
 8490 %}
 8491 
 8492 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
 8493 %{
 8494   effect(USE_DEF dst, KILL cr);
 8495 
 8496   format %{ &quot;sarq    $dst, #2\t# Used in div-by-10&quot; %}
 8497   opcode(0xC1, 0x7); /* C1 /7 ib */
 8498   ins_encode(reg_opc_imm_wide(dst, 0x2));
 8499   ins_pipe(ialu_reg);
 8500 %}
 8501 
 8502 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
 8503 %{
 8504   match(Set dst (DivL src div));
 8505 
 8506   ins_cost((5+8)*100);
 8507   expand %{
 8508     rax_RegL rax;                     // Killed temp
 8509     rFlagsReg cr;                     // Killed
 8510     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
 8511     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
 8512     sarL_rReg_63(src, cr);            // sarq  src, 63
 8513     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
 8514     subL_rReg(dst, src, cr);          // subl  rdx, src
 8515   %}
 8516 %}
 8517 
 8518 //-----------------------------------------------------------------------------
 8519 
 8520 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
 8521                    rFlagsReg cr)
 8522 %{
 8523   match(Set rdx (ModI rax div));
 8524   effect(KILL rax, KILL cr);
 8525 
 8526   ins_cost(300); // XXX
 8527   format %{ &quot;cmpl    rax, 0x80000000\t# irem\n\t&quot;
 8528             &quot;jne,s   normal\n\t&quot;
 8529             &quot;xorl    rdx, rdx\n\t&quot;
 8530             &quot;cmpl    $div, -1\n\t&quot;
 8531             &quot;je,s    done\n&quot;
 8532     &quot;normal: cdql\n\t&quot;
 8533             &quot;idivl   $div\n&quot;
 8534     &quot;done:&quot;        %}
 8535   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8536   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8537   ins_pipe(ialu_reg_reg_alu0);
 8538 %}
 8539 
 8540 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
 8541                    rFlagsReg cr)
 8542 %{
 8543   match(Set rdx (ModL rax div));
 8544   effect(KILL rax, KILL cr);
 8545 
 8546   ins_cost(300); // XXX
 8547   format %{ &quot;movq    rdx, 0x8000000000000000\t# lrem\n\t&quot;
 8548             &quot;cmpq    rax, rdx\n\t&quot;
 8549             &quot;jne,s   normal\n\t&quot;
 8550             &quot;xorl    rdx, rdx\n\t&quot;
 8551             &quot;cmpq    $div, -1\n\t&quot;
 8552             &quot;je,s    done\n&quot;
 8553     &quot;normal: cdqq\n\t&quot;
 8554             &quot;idivq   $div\n&quot;
 8555     &quot;done:&quot;        %}
 8556   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8557   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8558   ins_pipe(ialu_reg_reg_alu0);
 8559 %}
 8560 
 8561 // Integer Shift Instructions
 8562 // Shift Left by one
 8563 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8564 %{
 8565   match(Set dst (LShiftI dst shift));
 8566   effect(KILL cr);
 8567 
 8568   format %{ &quot;sall    $dst, $shift&quot; %}
 8569   opcode(0xD1, 0x4); /* D1 /4 */
 8570   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8571   ins_pipe(ialu_reg);
 8572 %}
 8573 
 8574 // Shift Left by one
 8575 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8576 %{
 8577   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8578   effect(KILL cr);
 8579 
 8580   format %{ &quot;sall    $dst, $shift\t&quot; %}
 8581   opcode(0xD1, 0x4); /* D1 /4 */
 8582   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8583   ins_pipe(ialu_mem_imm);
 8584 %}
 8585 
 8586 // Shift Left by 8-bit immediate
 8587 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8588 %{
 8589   match(Set dst (LShiftI dst shift));
 8590   effect(KILL cr);
 8591 
 8592   format %{ &quot;sall    $dst, $shift&quot; %}
 8593   opcode(0xC1, 0x4); /* C1 /4 ib */
 8594   ins_encode(reg_opc_imm(dst, shift));
 8595   ins_pipe(ialu_reg);
 8596 %}
 8597 
 8598 // Shift Left by 8-bit immediate
 8599 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8600 %{
 8601   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8602   effect(KILL cr);
 8603 
 8604   format %{ &quot;sall    $dst, $shift&quot; %}
 8605   opcode(0xC1, 0x4); /* C1 /4 ib */
 8606   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8607   ins_pipe(ialu_mem_imm);
 8608 %}
 8609 
 8610 // Shift Left by variable
 8611 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8612 %{
 8613   match(Set dst (LShiftI dst shift));
 8614   effect(KILL cr);
 8615 
 8616   format %{ &quot;sall    $dst, $shift&quot; %}
 8617   opcode(0xD3, 0x4); /* D3 /4 */
 8618   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8619   ins_pipe(ialu_reg_reg);
 8620 %}
 8621 
 8622 // Shift Left by variable
 8623 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8624 %{
 8625   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8626   effect(KILL cr);
 8627 
 8628   format %{ &quot;sall    $dst, $shift&quot; %}
 8629   opcode(0xD3, 0x4); /* D3 /4 */
 8630   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8631   ins_pipe(ialu_mem_reg);
 8632 %}
 8633 
 8634 // Arithmetic shift right by one
 8635 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8636 %{
 8637   match(Set dst (RShiftI dst shift));
 8638   effect(KILL cr);
 8639 
 8640   format %{ &quot;sarl    $dst, $shift&quot; %}
 8641   opcode(0xD1, 0x7); /* D1 /7 */
 8642   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8643   ins_pipe(ialu_reg);
 8644 %}
 8645 
 8646 // Arithmetic shift right by one
 8647 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8648 %{
 8649   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8650   effect(KILL cr);
 8651 
 8652   format %{ &quot;sarl    $dst, $shift&quot; %}
 8653   opcode(0xD1, 0x7); /* D1 /7 */
 8654   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8655   ins_pipe(ialu_mem_imm);
 8656 %}
 8657 
 8658 // Arithmetic Shift Right by 8-bit immediate
 8659 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8660 %{
 8661   match(Set dst (RShiftI dst shift));
 8662   effect(KILL cr);
 8663 
 8664   format %{ &quot;sarl    $dst, $shift&quot; %}
 8665   opcode(0xC1, 0x7); /* C1 /7 ib */
 8666   ins_encode(reg_opc_imm(dst, shift));
 8667   ins_pipe(ialu_mem_imm);
 8668 %}
 8669 
 8670 // Arithmetic Shift Right by 8-bit immediate
 8671 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8672 %{
 8673   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8674   effect(KILL cr);
 8675 
 8676   format %{ &quot;sarl    $dst, $shift&quot; %}
 8677   opcode(0xC1, 0x7); /* C1 /7 ib */
 8678   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8679   ins_pipe(ialu_mem_imm);
 8680 %}
 8681 
 8682 // Arithmetic Shift Right by variable
 8683 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8684 %{
 8685   match(Set dst (RShiftI dst shift));
 8686   effect(KILL cr);
 8687 
 8688   format %{ &quot;sarl    $dst, $shift&quot; %}
 8689   opcode(0xD3, 0x7); /* D3 /7 */
 8690   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8691   ins_pipe(ialu_reg_reg);
 8692 %}
 8693 
 8694 // Arithmetic Shift Right by variable
 8695 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8696 %{
 8697   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8698   effect(KILL cr);
 8699 
 8700   format %{ &quot;sarl    $dst, $shift&quot; %}
 8701   opcode(0xD3, 0x7); /* D3 /7 */
 8702   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8703   ins_pipe(ialu_mem_reg);
 8704 %}
 8705 
 8706 // Logical shift right by one
 8707 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8708 %{
 8709   match(Set dst (URShiftI dst shift));
 8710   effect(KILL cr);
 8711 
 8712   format %{ &quot;shrl    $dst, $shift&quot; %}
 8713   opcode(0xD1, 0x5); /* D1 /5 */
 8714   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8715   ins_pipe(ialu_reg);
 8716 %}
 8717 
 8718 // Logical shift right by one
 8719 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8720 %{
 8721   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8722   effect(KILL cr);
 8723 
 8724   format %{ &quot;shrl    $dst, $shift&quot; %}
 8725   opcode(0xD1, 0x5); /* D1 /5 */
 8726   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8727   ins_pipe(ialu_mem_imm);
 8728 %}
 8729 
 8730 // Logical Shift Right by 8-bit immediate
 8731 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8732 %{
 8733   match(Set dst (URShiftI dst shift));
 8734   effect(KILL cr);
 8735 
 8736   format %{ &quot;shrl    $dst, $shift&quot; %}
 8737   opcode(0xC1, 0x5); /* C1 /5 ib */
 8738   ins_encode(reg_opc_imm(dst, shift));
 8739   ins_pipe(ialu_reg);
 8740 %}
 8741 
 8742 // Logical Shift Right by 8-bit immediate
 8743 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8744 %{
 8745   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8746   effect(KILL cr);
 8747 
 8748   format %{ &quot;shrl    $dst, $shift&quot; %}
 8749   opcode(0xC1, 0x5); /* C1 /5 ib */
 8750   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8751   ins_pipe(ialu_mem_imm);
 8752 %}
 8753 
 8754 // Logical Shift Right by variable
 8755 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8756 %{
 8757   match(Set dst (URShiftI dst shift));
 8758   effect(KILL cr);
 8759 
 8760   format %{ &quot;shrl    $dst, $shift&quot; %}
 8761   opcode(0xD3, 0x5); /* D3 /5 */
 8762   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8763   ins_pipe(ialu_reg_reg);
 8764 %}
 8765 
 8766 // Logical Shift Right by variable
 8767 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8768 %{
 8769   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8770   effect(KILL cr);
 8771 
 8772   format %{ &quot;shrl    $dst, $shift&quot; %}
 8773   opcode(0xD3, 0x5); /* D3 /5 */
 8774   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8775   ins_pipe(ialu_mem_reg);
 8776 %}
 8777 
 8778 // Long Shift Instructions
 8779 // Shift Left by one
 8780 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8781 %{
 8782   match(Set dst (LShiftL dst shift));
 8783   effect(KILL cr);
 8784 
 8785   format %{ &quot;salq    $dst, $shift&quot; %}
 8786   opcode(0xD1, 0x4); /* D1 /4 */
 8787   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8788   ins_pipe(ialu_reg);
 8789 %}
 8790 
 8791 // Shift Left by one
 8792 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8793 %{
 8794   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8795   effect(KILL cr);
 8796 
 8797   format %{ &quot;salq    $dst, $shift&quot; %}
 8798   opcode(0xD1, 0x4); /* D1 /4 */
 8799   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8800   ins_pipe(ialu_mem_imm);
 8801 %}
 8802 
 8803 // Shift Left by 8-bit immediate
 8804 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8805 %{
 8806   match(Set dst (LShiftL dst shift));
 8807   effect(KILL cr);
 8808 
 8809   format %{ &quot;salq    $dst, $shift&quot; %}
 8810   opcode(0xC1, 0x4); /* C1 /4 ib */
 8811   ins_encode(reg_opc_imm_wide(dst, shift));
 8812   ins_pipe(ialu_reg);
 8813 %}
 8814 
 8815 // Shift Left by 8-bit immediate
 8816 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8817 %{
 8818   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8819   effect(KILL cr);
 8820 
 8821   format %{ &quot;salq    $dst, $shift&quot; %}
 8822   opcode(0xC1, 0x4); /* C1 /4 ib */
 8823   ins_encode(REX_mem_wide(dst), OpcP,
 8824              RM_opc_mem(secondary, dst), Con8or32(shift));
 8825   ins_pipe(ialu_mem_imm);
 8826 %}
 8827 
 8828 // Shift Left by variable
 8829 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8830 %{
 8831   match(Set dst (LShiftL dst shift));
 8832   effect(KILL cr);
 8833 
 8834   format %{ &quot;salq    $dst, $shift&quot; %}
 8835   opcode(0xD3, 0x4); /* D3 /4 */
 8836   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8837   ins_pipe(ialu_reg_reg);
 8838 %}
 8839 
 8840 // Shift Left by variable
 8841 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8842 %{
 8843   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8844   effect(KILL cr);
 8845 
 8846   format %{ &quot;salq    $dst, $shift&quot; %}
 8847   opcode(0xD3, 0x4); /* D3 /4 */
 8848   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8849   ins_pipe(ialu_mem_reg);
 8850 %}
 8851 
 8852 // Arithmetic shift right by one
 8853 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8854 %{
 8855   match(Set dst (RShiftL dst shift));
 8856   effect(KILL cr);
 8857 
 8858   format %{ &quot;sarq    $dst, $shift&quot; %}
 8859   opcode(0xD1, 0x7); /* D1 /7 */
 8860   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8861   ins_pipe(ialu_reg);
 8862 %}
 8863 
 8864 // Arithmetic shift right by one
 8865 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8866 %{
 8867   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8868   effect(KILL cr);
 8869 
 8870   format %{ &quot;sarq    $dst, $shift&quot; %}
 8871   opcode(0xD1, 0x7); /* D1 /7 */
 8872   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8873   ins_pipe(ialu_mem_imm);
 8874 %}
 8875 
 8876 // Arithmetic Shift Right by 8-bit immediate
 8877 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8878 %{
 8879   match(Set dst (RShiftL dst shift));
 8880   effect(KILL cr);
 8881 
 8882   format %{ &quot;sarq    $dst, $shift&quot; %}
 8883   opcode(0xC1, 0x7); /* C1 /7 ib */
 8884   ins_encode(reg_opc_imm_wide(dst, shift));
 8885   ins_pipe(ialu_mem_imm);
 8886 %}
 8887 
 8888 // Arithmetic Shift Right by 8-bit immediate
 8889 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8890 %{
 8891   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8892   effect(KILL cr);
 8893 
 8894   format %{ &quot;sarq    $dst, $shift&quot; %}
 8895   opcode(0xC1, 0x7); /* C1 /7 ib */
 8896   ins_encode(REX_mem_wide(dst), OpcP,
 8897              RM_opc_mem(secondary, dst), Con8or32(shift));
 8898   ins_pipe(ialu_mem_imm);
 8899 %}
 8900 
 8901 // Arithmetic Shift Right by variable
 8902 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8903 %{
 8904   match(Set dst (RShiftL dst shift));
 8905   effect(KILL cr);
 8906 
 8907   format %{ &quot;sarq    $dst, $shift&quot; %}
 8908   opcode(0xD3, 0x7); /* D3 /7 */
 8909   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8910   ins_pipe(ialu_reg_reg);
 8911 %}
 8912 
 8913 // Arithmetic Shift Right by variable
 8914 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8915 %{
 8916   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8917   effect(KILL cr);
 8918 
 8919   format %{ &quot;sarq    $dst, $shift&quot; %}
 8920   opcode(0xD3, 0x7); /* D3 /7 */
 8921   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8922   ins_pipe(ialu_mem_reg);
 8923 %}
 8924 
 8925 // Logical shift right by one
 8926 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8927 %{
 8928   match(Set dst (URShiftL dst shift));
 8929   effect(KILL cr);
 8930 
 8931   format %{ &quot;shrq    $dst, $shift&quot; %}
 8932   opcode(0xD1, 0x5); /* D1 /5 */
 8933   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
 8934   ins_pipe(ialu_reg);
 8935 %}
 8936 
 8937 // Logical shift right by one
 8938 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8939 %{
 8940   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8941   effect(KILL cr);
 8942 
 8943   format %{ &quot;shrq    $dst, $shift&quot; %}
 8944   opcode(0xD1, 0x5); /* D1 /5 */
 8945   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8946   ins_pipe(ialu_mem_imm);
 8947 %}
 8948 
 8949 // Logical Shift Right by 8-bit immediate
 8950 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8951 %{
 8952   match(Set dst (URShiftL dst shift));
 8953   effect(KILL cr);
 8954 
 8955   format %{ &quot;shrq    $dst, $shift&quot; %}
 8956   opcode(0xC1, 0x5); /* C1 /5 ib */
 8957   ins_encode(reg_opc_imm_wide(dst, shift));
 8958   ins_pipe(ialu_reg);
 8959 %}
 8960 
 8961 
 8962 // Logical Shift Right by 8-bit immediate
 8963 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8964 %{
 8965   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8966   effect(KILL cr);
 8967 
 8968   format %{ &quot;shrq    $dst, $shift&quot; %}
 8969   opcode(0xC1, 0x5); /* C1 /5 ib */
 8970   ins_encode(REX_mem_wide(dst), OpcP,
 8971              RM_opc_mem(secondary, dst), Con8or32(shift));
 8972   ins_pipe(ialu_mem_imm);
 8973 %}
 8974 
 8975 // Logical Shift Right by variable
 8976 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8977 %{
 8978   match(Set dst (URShiftL dst shift));
 8979   effect(KILL cr);
 8980 
 8981   format %{ &quot;shrq    $dst, $shift&quot; %}
 8982   opcode(0xD3, 0x5); /* D3 /5 */
 8983   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8984   ins_pipe(ialu_reg_reg);
 8985 %}
 8986 
 8987 // Logical Shift Right by variable
 8988 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8989 %{
 8990   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8991   effect(KILL cr);
 8992 
 8993   format %{ &quot;shrq    $dst, $shift&quot; %}
 8994   opcode(0xD3, 0x5); /* D3 /5 */
 8995   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8996   ins_pipe(ialu_mem_reg);
 8997 %}
 8998 
 8999 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 9000 // This idiom is used by the compiler for the i2b bytecode.
 9001 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
 9002 %{
 9003   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 9004 
 9005   format %{ &quot;movsbl  $dst, $src\t# i2b&quot; %}
 9006   opcode(0x0F, 0xBE);
 9007   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9008   ins_pipe(ialu_reg_reg);
 9009 %}
 9010 
 9011 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 9012 // This idiom is used by the compiler the i2s bytecode.
 9013 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
 9014 %{
 9015   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 9016 
 9017   format %{ &quot;movswl  $dst, $src\t# i2s&quot; %}
 9018   opcode(0x0F, 0xBF);
 9019   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9020   ins_pipe(ialu_reg_reg);
 9021 %}
 9022 
 9023 // ROL/ROR instructions
 9024 
 9025 // ROL expand
 9026 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
 9027   effect(KILL cr, USE_DEF dst);
 9028 
 9029   format %{ &quot;roll    $dst&quot; %}
 9030   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9031   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9032   ins_pipe(ialu_reg);
 9033 %}
 9034 
 9035 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
 9036   effect(USE_DEF dst, USE shift, KILL cr);
 9037 
 9038   format %{ &quot;roll    $dst, $shift&quot; %}
 9039   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9040   ins_encode( reg_opc_imm(dst, shift) );
 9041   ins_pipe(ialu_reg);
 9042 %}
 9043 
 9044 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9045 %{
 9046   effect(USE_DEF dst, USE shift, KILL cr);
 9047 
 9048   format %{ &quot;roll    $dst, $shift&quot; %}
 9049   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9050   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9051   ins_pipe(ialu_reg_reg);
 9052 %}
 9053 // end of ROL expand
 9054 
 9055 // Rotate Left by one
 9056 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9057 %{
 9058   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9059 
 9060   expand %{
 9061     rolI_rReg_imm1(dst, cr);
 9062   %}
 9063 %}
 9064 
 9065 // Rotate Left by 8-bit immediate
 9066 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9067 %{
 9068   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9069   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9070 
 9071   expand %{
 9072     rolI_rReg_imm8(dst, lshift, cr);
 9073   %}
 9074 %}
 9075 
 9076 // Rotate Left by variable
 9077 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9078 %{
 9079   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 9080 
 9081   expand %{
 9082     rolI_rReg_CL(dst, shift, cr);
 9083   %}
 9084 %}
 9085 
 9086 // Rotate Left by variable
 9087 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9088 %{
 9089   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 9090 
 9091   expand %{
 9092     rolI_rReg_CL(dst, shift, cr);
 9093   %}
 9094 %}
 9095 
 9096 // ROR expand
 9097 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
 9098 %{
 9099   effect(USE_DEF dst, KILL cr);
 9100 
 9101   format %{ &quot;rorl    $dst&quot; %}
 9102   opcode(0xD1, 0x1); /* D1 /1 */
 9103   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9104   ins_pipe(ialu_reg);
 9105 %}
 9106 
 9107 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
 9108 %{
 9109   effect(USE_DEF dst, USE shift, KILL cr);
 9110 
 9111   format %{ &quot;rorl    $dst, $shift&quot; %}
 9112   opcode(0xC1, 0x1); /* C1 /1 ib */
 9113   ins_encode(reg_opc_imm(dst, shift));
 9114   ins_pipe(ialu_reg);
 9115 %}
 9116 
 9117 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9118 %{
 9119   effect(USE_DEF dst, USE shift, KILL cr);
 9120 
 9121   format %{ &quot;rorl    $dst, $shift&quot; %}
 9122   opcode(0xD3, 0x1); /* D3 /1 */
 9123   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9124   ins_pipe(ialu_reg_reg);
 9125 %}
 9126 // end of ROR expand
 9127 
 9128 // Rotate Right by one
 9129 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9130 %{
 9131   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9132 
 9133   expand %{
 9134     rorI_rReg_imm1(dst, cr);
 9135   %}
 9136 %}
 9137 
 9138 // Rotate Right by 8-bit immediate
 9139 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9140 %{
 9141   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9142   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9143 
 9144   expand %{
 9145     rorI_rReg_imm8(dst, rshift, cr);
 9146   %}
 9147 %}
 9148 
 9149 // Rotate Right by variable
 9150 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9151 %{
 9152   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 9153 
 9154   expand %{
 9155     rorI_rReg_CL(dst, shift, cr);
 9156   %}
 9157 %}
 9158 
 9159 // Rotate Right by variable
 9160 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9161 %{
 9162   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 9163 
 9164   expand %{
 9165     rorI_rReg_CL(dst, shift, cr);
 9166   %}
 9167 %}
 9168 
 9169 // for long rotate
 9170 // ROL expand
 9171 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
 9172   effect(USE_DEF dst, KILL cr);
 9173 
 9174   format %{ &quot;rolq    $dst&quot; %}
 9175   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9176   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9177   ins_pipe(ialu_reg);
 9178 %}
 9179 
 9180 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
 9181   effect(USE_DEF dst, USE shift, KILL cr);
 9182 
 9183   format %{ &quot;rolq    $dst, $shift&quot; %}
 9184   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9185   ins_encode( reg_opc_imm_wide(dst, shift) );
 9186   ins_pipe(ialu_reg);
 9187 %}
 9188 
 9189 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9190 %{
 9191   effect(USE_DEF dst, USE shift, KILL cr);
 9192 
 9193   format %{ &quot;rolq    $dst, $shift&quot; %}
 9194   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9195   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9196   ins_pipe(ialu_reg_reg);
 9197 %}
 9198 // end of ROL expand
 9199 
 9200 // Rotate Left by one
 9201 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9202 %{
 9203   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9204 
 9205   expand %{
 9206     rolL_rReg_imm1(dst, cr);
 9207   %}
 9208 %}
 9209 
 9210 // Rotate Left by 8-bit immediate
 9211 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9212 %{
 9213   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9214   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9215 
 9216   expand %{
 9217     rolL_rReg_imm8(dst, lshift, cr);
 9218   %}
 9219 %}
 9220 
 9221 // Rotate Left by variable
 9222 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9223 %{
 9224   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
 9225 
 9226   expand %{
 9227     rolL_rReg_CL(dst, shift, cr);
 9228   %}
 9229 %}
 9230 
 9231 // Rotate Left by variable
 9232 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9233 %{
 9234   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
 9235 
 9236   expand %{
 9237     rolL_rReg_CL(dst, shift, cr);
 9238   %}
 9239 %}
 9240 
 9241 // ROR expand
 9242 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
 9243 %{
 9244   effect(USE_DEF dst, KILL cr);
 9245 
 9246   format %{ &quot;rorq    $dst&quot; %}
 9247   opcode(0xD1, 0x1); /* D1 /1 */
 9248   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9249   ins_pipe(ialu_reg);
 9250 %}
 9251 
 9252 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
 9253 %{
 9254   effect(USE_DEF dst, USE shift, KILL cr);
 9255 
 9256   format %{ &quot;rorq    $dst, $shift&quot; %}
 9257   opcode(0xC1, 0x1); /* C1 /1 ib */
 9258   ins_encode(reg_opc_imm_wide(dst, shift));
 9259   ins_pipe(ialu_reg);
 9260 %}
 9261 
 9262 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9263 %{
 9264   effect(USE_DEF dst, USE shift, KILL cr);
 9265 
 9266   format %{ &quot;rorq    $dst, $shift&quot; %}
 9267   opcode(0xD3, 0x1); /* D3 /1 */
 9268   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9269   ins_pipe(ialu_reg_reg);
 9270 %}
 9271 // end of ROR expand
 9272 
 9273 // Rotate Right by one
 9274 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9275 %{
 9276   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9277 
 9278   expand %{
 9279     rorL_rReg_imm1(dst, cr);
 9280   %}
 9281 %}
 9282 
 9283 // Rotate Right by 8-bit immediate
 9284 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9285 %{
 9286   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9287   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9288 
 9289   expand %{
 9290     rorL_rReg_imm8(dst, rshift, cr);
 9291   %}
 9292 %}
 9293 
 9294 // Rotate Right by variable
 9295 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9296 %{
 9297   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
 9298 
 9299   expand %{
 9300     rorL_rReg_CL(dst, shift, cr);
 9301   %}
 9302 %}
 9303 
 9304 // Rotate Right by variable
 9305 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9306 %{
 9307   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
 9308 
 9309   expand %{
 9310     rorL_rReg_CL(dst, shift, cr);
 9311   %}
 9312 %}
 9313 
 9314 // Logical Instructions
 9315 
 9316 // Integer Logical Instructions
 9317 
 9318 // And Instructions
 9319 // And Register with Register
 9320 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9321 %{
 9322   match(Set dst (AndI dst src));
 9323   effect(KILL cr);
 9324 
 9325   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9326   opcode(0x23);
 9327   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9328   ins_pipe(ialu_reg_reg);
 9329 %}
 9330 
 9331 // And Register with Immediate 255
 9332 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
 9333 %{
 9334   match(Set dst (AndI dst src));
 9335 
 9336   format %{ &quot;movzbl  $dst, $dst\t# int &amp; 0xFF&quot; %}
 9337   opcode(0x0F, 0xB6);
 9338   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9339   ins_pipe(ialu_reg);
 9340 %}
 9341 
 9342 // And Register with Immediate 255 and promote to long
 9343 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
 9344 %{
 9345   match(Set dst (ConvI2L (AndI src mask)));
 9346 
 9347   format %{ &quot;movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long&quot; %}
 9348   opcode(0x0F, 0xB6);
 9349   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9350   ins_pipe(ialu_reg);
 9351 %}
 9352 
 9353 // And Register with Immediate 65535
 9354 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
 9355 %{
 9356   match(Set dst (AndI dst src));
 9357 
 9358   format %{ &quot;movzwl  $dst, $dst\t# int &amp; 0xFFFF&quot; %}
 9359   opcode(0x0F, 0xB7);
 9360   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9361   ins_pipe(ialu_reg);
 9362 %}
 9363 
 9364 // And Register with Immediate 65535 and promote to long
 9365 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
 9366 %{
 9367   match(Set dst (ConvI2L (AndI src mask)));
 9368 
 9369   format %{ &quot;movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long&quot; %}
 9370   opcode(0x0F, 0xB7);
 9371   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9372   ins_pipe(ialu_reg);
 9373 %}
 9374 
 9375 // And Register with Immediate
 9376 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9377 %{
 9378   match(Set dst (AndI dst src));
 9379   effect(KILL cr);
 9380 
 9381   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9382   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9383   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9384   ins_pipe(ialu_reg);
 9385 %}
 9386 
 9387 // And Register with Memory
 9388 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9389 %{
 9390   match(Set dst (AndI dst (LoadI src)));
 9391   effect(KILL cr);
 9392 
 9393   ins_cost(125);
 9394   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9395   opcode(0x23);
 9396   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9397   ins_pipe(ialu_reg_mem);
 9398 %}
 9399 
 9400 // And Memory with Register
 9401 instruct andB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9402 %{
 9403   match(Set dst (StoreB dst (AndI (LoadB dst) src)));
 9404   effect(KILL cr);
 9405 
 9406   ins_cost(150);
 9407   format %{ &quot;andb    $dst, $src\t# byte&quot; %}
 9408   opcode(0x20);
 9409   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9410   ins_pipe(ialu_mem_reg);
 9411 %}
 9412 
 9413 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9414 %{
 9415   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9416   effect(KILL cr);
 9417 
 9418   ins_cost(150);
 9419   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9420   opcode(0x21); /* Opcode 21 /r */
 9421   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9422   ins_pipe(ialu_mem_reg);
 9423 %}
 9424 
 9425 // And Memory with Immediate
 9426 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9427 %{
 9428   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9429   effect(KILL cr);
 9430 
 9431   ins_cost(125);
 9432   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9433   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9434   ins_encode(REX_mem(dst), OpcSE(src),
 9435              RM_opc_mem(secondary, dst), Con8or32(src));
 9436   ins_pipe(ialu_mem_imm);
 9437 %}
 9438 
 9439 // BMI1 instructions
 9440 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
 9441   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
 9442   predicate(UseBMI1Instructions);
 9443   effect(KILL cr);
 9444 
 9445   ins_cost(125);
 9446   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9447 
 9448   ins_encode %{
 9449     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 9450   %}
 9451   ins_pipe(ialu_reg_mem);
 9452 %}
 9453 
 9454 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
 9455   match(Set dst (AndI (XorI src1 minus_1) src2));
 9456   predicate(UseBMI1Instructions);
 9457   effect(KILL cr);
 9458 
 9459   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9460 
 9461   ins_encode %{
 9462     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 9463   %}
 9464   ins_pipe(ialu_reg);
 9465 %}
 9466 
 9467 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
 9468   match(Set dst (AndI (SubI imm_zero src) src));
 9469   predicate(UseBMI1Instructions);
 9470   effect(KILL cr);
 9471 
 9472   format %{ &quot;blsil  $dst, $src&quot; %}
 9473 
 9474   ins_encode %{
 9475     __ blsil($dst$$Register, $src$$Register);
 9476   %}
 9477   ins_pipe(ialu_reg);
 9478 %}
 9479 
 9480 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
 9481   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 9482   predicate(UseBMI1Instructions);
 9483   effect(KILL cr);
 9484 
 9485   ins_cost(125);
 9486   format %{ &quot;blsil  $dst, $src&quot; %}
 9487 
 9488   ins_encode %{
 9489     __ blsil($dst$$Register, $src$$Address);
 9490   %}
 9491   ins_pipe(ialu_reg_mem);
 9492 %}
 9493 
 9494 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9495 %{
 9496   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9497   predicate(UseBMI1Instructions);
 9498   effect(KILL cr);
 9499 
 9500   ins_cost(125);
 9501   format %{ &quot;blsmskl $dst, $src&quot; %}
 9502 
 9503   ins_encode %{
 9504     __ blsmskl($dst$$Register, $src$$Address);
 9505   %}
 9506   ins_pipe(ialu_reg_mem);
 9507 %}
 9508 
 9509 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9510 %{
 9511   match(Set dst (XorI (AddI src minus_1) src));
 9512   predicate(UseBMI1Instructions);
 9513   effect(KILL cr);
 9514 
 9515   format %{ &quot;blsmskl $dst, $src&quot; %}
 9516 
 9517   ins_encode %{
 9518     __ blsmskl($dst$$Register, $src$$Register);
 9519   %}
 9520 
 9521   ins_pipe(ialu_reg);
 9522 %}
 9523 
 9524 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9525 %{
 9526   match(Set dst (AndI (AddI src minus_1) src) );
 9527   predicate(UseBMI1Instructions);
 9528   effect(KILL cr);
 9529 
 9530   format %{ &quot;blsrl  $dst, $src&quot; %}
 9531 
 9532   ins_encode %{
 9533     __ blsrl($dst$$Register, $src$$Register);
 9534   %}
 9535 
 9536   ins_pipe(ialu_reg_mem);
 9537 %}
 9538 
 9539 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9540 %{
 9541   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9542   predicate(UseBMI1Instructions);
 9543   effect(KILL cr);
 9544 
 9545   ins_cost(125);
 9546   format %{ &quot;blsrl  $dst, $src&quot; %}
 9547 
 9548   ins_encode %{
 9549     __ blsrl($dst$$Register, $src$$Address);
 9550   %}
 9551 
 9552   ins_pipe(ialu_reg);
 9553 %}
 9554 
 9555 // Or Instructions
 9556 // Or Register with Register
 9557 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9558 %{
 9559   match(Set dst (OrI dst src));
 9560   effect(KILL cr);
 9561 
 9562   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9563   opcode(0x0B);
 9564   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9565   ins_pipe(ialu_reg_reg);
 9566 %}
 9567 
 9568 // Or Register with Immediate
 9569 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9570 %{
 9571   match(Set dst (OrI dst src));
 9572   effect(KILL cr);
 9573 
 9574   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9575   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9576   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9577   ins_pipe(ialu_reg);
 9578 %}
 9579 
 9580 // Or Register with Memory
 9581 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9582 %{
 9583   match(Set dst (OrI dst (LoadI src)));
 9584   effect(KILL cr);
 9585 
 9586   ins_cost(125);
 9587   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9588   opcode(0x0B);
 9589   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9590   ins_pipe(ialu_reg_mem);
 9591 %}
 9592 
 9593 // Or Memory with Register
 9594 instruct orB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9595 %{
 9596   match(Set dst (StoreB dst (OrI (LoadB dst) src)));
 9597   effect(KILL cr);
 9598 
 9599   ins_cost(150);
 9600   format %{ &quot;orb    $dst, $src\t# byte&quot; %}
 9601   opcode(0x08);
 9602   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9603   ins_pipe(ialu_mem_reg);
 9604 %}
 9605 
 9606 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9607 %{
 9608   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9609   effect(KILL cr);
 9610 
 9611   ins_cost(150);
 9612   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9613   opcode(0x09); /* Opcode 09 /r */
 9614   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9615   ins_pipe(ialu_mem_reg);
 9616 %}
 9617 
 9618 // Or Memory with Immediate
 9619 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9620 %{
 9621   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9622   effect(KILL cr);
 9623 
 9624   ins_cost(125);
 9625   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9626   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9627   ins_encode(REX_mem(dst), OpcSE(src),
 9628              RM_opc_mem(secondary, dst), Con8or32(src));
 9629   ins_pipe(ialu_mem_imm);
 9630 %}
 9631 
 9632 // Xor Instructions
 9633 // Xor Register with Register
 9634 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9635 %{
 9636   match(Set dst (XorI dst src));
 9637   effect(KILL cr);
 9638 
 9639   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9640   opcode(0x33);
 9641   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9642   ins_pipe(ialu_reg_reg);
 9643 %}
 9644 
 9645 // Xor Register with Immediate -1
 9646 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
 9647   match(Set dst (XorI dst imm));
 9648 
 9649   format %{ &quot;not    $dst&quot; %}
 9650   ins_encode %{
 9651      __ notl($dst$$Register);
 9652   %}
 9653   ins_pipe(ialu_reg);
 9654 %}
 9655 
 9656 // Xor Register with Immediate
 9657 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9658 %{
 9659   match(Set dst (XorI dst src));
 9660   effect(KILL cr);
 9661 
 9662   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9663   opcode(0x81, 0x06); /* Opcode 81 /6 id */
 9664   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9665   ins_pipe(ialu_reg);
 9666 %}
 9667 
 9668 // Xor Register with Memory
 9669 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9670 %{
 9671   match(Set dst (XorI dst (LoadI src)));
 9672   effect(KILL cr);
 9673 
 9674   ins_cost(125);
 9675   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9676   opcode(0x33);
 9677   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9678   ins_pipe(ialu_reg_mem);
 9679 %}
 9680 
 9681 // Xor Memory with Register
 9682 instruct xorB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9683 %{
 9684   match(Set dst (StoreB dst (XorI (LoadB dst) src)));
 9685   effect(KILL cr);
 9686 
 9687   ins_cost(150);
 9688   format %{ &quot;xorb    $dst, $src\t# byte&quot; %}
 9689   opcode(0x30);
 9690   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9691   ins_pipe(ialu_mem_reg);
 9692 %}
 9693 
 9694 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9695 %{
 9696   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9697   effect(KILL cr);
 9698 
 9699   ins_cost(150);
 9700   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9701   opcode(0x31); /* Opcode 31 /r */
 9702   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9703   ins_pipe(ialu_mem_reg);
 9704 %}
 9705 
 9706 // Xor Memory with Immediate
 9707 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9708 %{
 9709   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9710   effect(KILL cr);
 9711 
 9712   ins_cost(125);
 9713   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9714   opcode(0x81, 0x6); /* Opcode 81 /6 id */
 9715   ins_encode(REX_mem(dst), OpcSE(src),
 9716              RM_opc_mem(secondary, dst), Con8or32(src));
 9717   ins_pipe(ialu_mem_imm);
 9718 %}
 9719 
 9720 
 9721 // Long Logical Instructions
 9722 
 9723 // And Instructions
 9724 // And Register with Register
 9725 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9726 %{
 9727   match(Set dst (AndL dst src));
 9728   effect(KILL cr);
 9729 
 9730   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9731   opcode(0x23);
 9732   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9733   ins_pipe(ialu_reg_reg);
 9734 %}
 9735 
 9736 // And Register with Immediate 255
 9737 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
 9738 %{
 9739   match(Set dst (AndL dst src));
 9740 
 9741   format %{ &quot;movzbq  $dst, $dst\t# long &amp; 0xFF&quot; %}
 9742   opcode(0x0F, 0xB6);
 9743   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9744   ins_pipe(ialu_reg);
 9745 %}
 9746 
 9747 // And Register with Immediate 65535
 9748 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
 9749 %{
 9750   match(Set dst (AndL dst src));
 9751 
 9752   format %{ &quot;movzwq  $dst, $dst\t# long &amp; 0xFFFF&quot; %}
 9753   opcode(0x0F, 0xB7);
 9754   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9755   ins_pipe(ialu_reg);
 9756 %}
 9757 
 9758 // And Register with Immediate
 9759 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9760 %{
 9761   match(Set dst (AndL dst src));
 9762   effect(KILL cr);
 9763 
 9764   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9765   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9766   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9767   ins_pipe(ialu_reg);
 9768 %}
 9769 
 9770 // And Register with Memory
 9771 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9772 %{
 9773   match(Set dst (AndL dst (LoadL src)));
 9774   effect(KILL cr);
 9775 
 9776   ins_cost(125);
 9777   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9778   opcode(0x23);
 9779   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9780   ins_pipe(ialu_reg_mem);
 9781 %}
 9782 
 9783 // And Memory with Register
 9784 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9785 %{
 9786   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9787   effect(KILL cr);
 9788 
 9789   ins_cost(150);
 9790   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9791   opcode(0x21); /* Opcode 21 /r */
 9792   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9793   ins_pipe(ialu_mem_reg);
 9794 %}
 9795 
 9796 // And Memory with Immediate
 9797 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9798 %{
 9799   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9800   effect(KILL cr);
 9801 
 9802   ins_cost(125);
 9803   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9804   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9805   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9806              RM_opc_mem(secondary, dst), Con8or32(src));
 9807   ins_pipe(ialu_mem_imm);
 9808 %}
 9809 
 9810 instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)
 9811 %{
 9812   // con should be a pure 64-bit immediate given that not(con) is a power of 2
 9813   // because AND/OR works well enough for 8/32-bit values.
 9814   predicate(log2_long(~n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 30);
 9815 
 9816   match(Set dst (StoreL dst (AndL (LoadL dst) con)));
 9817   effect(KILL cr);
 9818 
 9819   ins_cost(125);
 9820   format %{ &quot;btrq    $dst, log2(not($con))\t# long&quot; %}
 9821   ins_encode %{
 9822     __ btrq($dst$$Address, log2_long(~$con$$constant));
 9823   %}
 9824   ins_pipe(ialu_mem_imm);
 9825 %}
 9826 
 9827 // BMI1 instructions
 9828 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
 9829   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
 9830   predicate(UseBMI1Instructions);
 9831   effect(KILL cr);
 9832 
 9833   ins_cost(125);
 9834   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9835 
 9836   ins_encode %{
 9837     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
 9838   %}
 9839   ins_pipe(ialu_reg_mem);
 9840 %}
 9841 
 9842 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
 9843   match(Set dst (AndL (XorL src1 minus_1) src2));
 9844   predicate(UseBMI1Instructions);
 9845   effect(KILL cr);
 9846 
 9847   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9848 
 9849   ins_encode %{
 9850   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
 9851   %}
 9852   ins_pipe(ialu_reg_mem);
 9853 %}
 9854 
 9855 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
 9856   match(Set dst (AndL (SubL imm_zero src) src));
 9857   predicate(UseBMI1Instructions);
 9858   effect(KILL cr);
 9859 
 9860   format %{ &quot;blsiq  $dst, $src&quot; %}
 9861 
 9862   ins_encode %{
 9863     __ blsiq($dst$$Register, $src$$Register);
 9864   %}
 9865   ins_pipe(ialu_reg);
 9866 %}
 9867 
 9868 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
 9869   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9870   predicate(UseBMI1Instructions);
 9871   effect(KILL cr);
 9872 
 9873   ins_cost(125);
 9874   format %{ &quot;blsiq  $dst, $src&quot; %}
 9875 
 9876   ins_encode %{
 9877     __ blsiq($dst$$Register, $src$$Address);
 9878   %}
 9879   ins_pipe(ialu_reg_mem);
 9880 %}
 9881 
 9882 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9883 %{
 9884   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
 9885   predicate(UseBMI1Instructions);
 9886   effect(KILL cr);
 9887 
 9888   ins_cost(125);
 9889   format %{ &quot;blsmskq $dst, $src&quot; %}
 9890 
 9891   ins_encode %{
 9892     __ blsmskq($dst$$Register, $src$$Address);
 9893   %}
 9894   ins_pipe(ialu_reg_mem);
 9895 %}
 9896 
 9897 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9898 %{
 9899   match(Set dst (XorL (AddL src minus_1) src));
 9900   predicate(UseBMI1Instructions);
 9901   effect(KILL cr);
 9902 
 9903   format %{ &quot;blsmskq $dst, $src&quot; %}
 9904 
 9905   ins_encode %{
 9906     __ blsmskq($dst$$Register, $src$$Register);
 9907   %}
 9908 
 9909   ins_pipe(ialu_reg);
 9910 %}
 9911 
 9912 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9913 %{
 9914   match(Set dst (AndL (AddL src minus_1) src) );
 9915   predicate(UseBMI1Instructions);
 9916   effect(KILL cr);
 9917 
 9918   format %{ &quot;blsrq  $dst, $src&quot; %}
 9919 
 9920   ins_encode %{
 9921     __ blsrq($dst$$Register, $src$$Register);
 9922   %}
 9923 
 9924   ins_pipe(ialu_reg);
 9925 %}
 9926 
 9927 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9928 %{
 9929   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
 9930   predicate(UseBMI1Instructions);
 9931   effect(KILL cr);
 9932 
 9933   ins_cost(125);
 9934   format %{ &quot;blsrq  $dst, $src&quot; %}
 9935 
 9936   ins_encode %{
 9937     __ blsrq($dst$$Register, $src$$Address);
 9938   %}
 9939 
 9940   ins_pipe(ialu_reg);
 9941 %}
 9942 
 9943 // Or Instructions
 9944 // Or Register with Register
 9945 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9946 %{
 9947   match(Set dst (OrL dst src));
 9948   effect(KILL cr);
 9949 
 9950   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9951   opcode(0x0B);
 9952   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9953   ins_pipe(ialu_reg_reg);
 9954 %}
 9955 
 9956 // Use any_RegP to match R15 (TLS register) without spilling.
 9957 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
 9958   match(Set dst (OrL dst (CastP2X src)));
 9959   effect(KILL cr);
 9960 
 9961   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9962   opcode(0x0B);
 9963   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9964   ins_pipe(ialu_reg_reg);
 9965 %}
 9966 
 9967 
 9968 // Or Register with Immediate
 9969 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9970 %{
 9971   match(Set dst (OrL dst src));
 9972   effect(KILL cr);
 9973 
 9974   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9975   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9976   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9977   ins_pipe(ialu_reg);
 9978 %}
 9979 
 9980 // Or Register with Memory
 9981 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9982 %{
 9983   match(Set dst (OrL dst (LoadL src)));
 9984   effect(KILL cr);
 9985 
 9986   ins_cost(125);
 9987   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9988   opcode(0x0B);
 9989   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9990   ins_pipe(ialu_reg_mem);
 9991 %}
 9992 
 9993 // Or Memory with Register
 9994 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9995 %{
 9996   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
 9997   effect(KILL cr);
 9998 
 9999   ins_cost(150);
10000   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10001   opcode(0x09); /* Opcode 09 /r */
10002   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10003   ins_pipe(ialu_mem_reg);
10004 %}
10005 
10006 // Or Memory with Immediate
10007 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10008 %{
10009   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
10010   effect(KILL cr);
10011 
10012   ins_cost(125);
10013   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10014   opcode(0x81, 0x1); /* Opcode 81 /1 id */
10015   ins_encode(REX_mem_wide(dst), OpcSE(src),
10016              RM_opc_mem(secondary, dst), Con8or32(src));
10017   ins_pipe(ialu_mem_imm);
10018 %}
10019 
10020 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
10021 %{
10022   // con should be a pure 64-bit power of 2 immediate
10023   // because AND/OR works well enough for 8/32-bit values.
10024   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
10025 
10026   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
10027   effect(KILL cr);
10028 
10029   ins_cost(125);
10030   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
10031   ins_encode %{
<a name="3" id="anc3"></a><span class="line-modified">10032     __ btsq($dst$$Address, log2_long($con$$constant));</span>
10033   %}
10034   ins_pipe(ialu_mem_imm);
10035 %}
10036 
10037 // Xor Instructions
10038 // Xor Register with Register
10039 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
10040 %{
10041   match(Set dst (XorL dst src));
10042   effect(KILL cr);
10043 
10044   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10045   opcode(0x33);
10046   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10047   ins_pipe(ialu_reg_reg);
10048 %}
10049 
10050 // Xor Register with Immediate -1
10051 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10052   match(Set dst (XorL dst imm));
10053 
10054   format %{ &quot;notq   $dst&quot; %}
10055   ins_encode %{
10056      __ notq($dst$$Register);
10057   %}
10058   ins_pipe(ialu_reg);
10059 %}
10060 
10061 // Xor Register with Immediate
10062 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10063 %{
10064   match(Set dst (XorL dst src));
10065   effect(KILL cr);
10066 
10067   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10068   opcode(0x81, 0x06); /* Opcode 81 /6 id */
10069   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10070   ins_pipe(ialu_reg);
10071 %}
10072 
10073 // Xor Register with Memory
10074 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10075 %{
10076   match(Set dst (XorL dst (LoadL src)));
10077   effect(KILL cr);
10078 
10079   ins_cost(125);
10080   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10081   opcode(0x33);
10082   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10083   ins_pipe(ialu_reg_mem);
10084 %}
10085 
10086 // Xor Memory with Register
10087 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10088 %{
10089   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10090   effect(KILL cr);
10091 
10092   ins_cost(150);
10093   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10094   opcode(0x31); /* Opcode 31 /r */
10095   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10096   ins_pipe(ialu_mem_reg);
10097 %}
10098 
10099 // Xor Memory with Immediate
10100 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10101 %{
10102   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10103   effect(KILL cr);
10104 
10105   ins_cost(125);
10106   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10107   opcode(0x81, 0x6); /* Opcode 81 /6 id */
10108   ins_encode(REX_mem_wide(dst), OpcSE(src),
10109              RM_opc_mem(secondary, dst), Con8or32(src));
10110   ins_pipe(ialu_mem_imm);
10111 %}
10112 
10113 // Convert Int to Boolean
10114 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
10115 %{
10116   match(Set dst (Conv2B src));
10117   effect(KILL cr);
10118 
10119   format %{ &quot;testl   $src, $src\t# ci2b\n\t&quot;
10120             &quot;setnz   $dst\n\t&quot;
10121             &quot;movzbl  $dst, $dst&quot; %}
10122   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
10123              setNZ_reg(dst),
10124              REX_reg_breg(dst, dst), // movzbl
10125              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10126   ins_pipe(pipe_slow); // XXX
10127 %}
10128 
10129 // Convert Pointer to Boolean
10130 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
10131 %{
10132   match(Set dst (Conv2B src));
10133   effect(KILL cr);
10134 
10135   format %{ &quot;testq   $src, $src\t# cp2b\n\t&quot;
10136             &quot;setnz   $dst\n\t&quot;
10137             &quot;movzbl  $dst, $dst&quot; %}
10138   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
10139              setNZ_reg(dst),
10140              REX_reg_breg(dst, dst), // movzbl
10141              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10142   ins_pipe(pipe_slow); // XXX
10143 %}
10144 
10145 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
10146 %{
10147   match(Set dst (CmpLTMask p q));
10148   effect(KILL cr);
10149 
10150   ins_cost(400);
10151   format %{ &quot;cmpl    $p, $q\t# cmpLTMask\n\t&quot;
10152             &quot;setlt   $dst\n\t&quot;
10153             &quot;movzbl  $dst, $dst\n\t&quot;
10154             &quot;negl    $dst&quot; %}
10155   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
10156              setLT_reg(dst),
10157              REX_reg_breg(dst, dst), // movzbl
10158              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
10159              neg_reg(dst));
10160   ins_pipe(pipe_slow);
10161 %}
10162 
10163 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
10164 %{
10165   match(Set dst (CmpLTMask dst zero));
10166   effect(KILL cr);
10167 
10168   ins_cost(100);
10169   format %{ &quot;sarl    $dst, #31\t# cmpLTMask0&quot; %}
10170   ins_encode %{
10171   __ sarl($dst$$Register, 31);
10172   %}
10173   ins_pipe(ialu_reg);
10174 %}
10175 
10176 /* Better to save a register than avoid a branch */
10177 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10178 %{
10179   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
10180   effect(KILL cr);
10181   ins_cost(300);
10182   format %{ &quot;subl    $p,$q\t# cadd_cmpLTMask\n\t&quot;
10183             &quot;jge     done\n\t&quot;
10184             &quot;addl    $p,$y\n&quot;
10185             &quot;done:   &quot; %}
10186   ins_encode %{
10187     Register Rp = $p$$Register;
10188     Register Rq = $q$$Register;
10189     Register Ry = $y$$Register;
10190     Label done;
10191     __ subl(Rp, Rq);
10192     __ jccb(Assembler::greaterEqual, done);
10193     __ addl(Rp, Ry);
10194     __ bind(done);
10195   %}
10196   ins_pipe(pipe_cmplt);
10197 %}
10198 
10199 /* Better to save a register than avoid a branch */
10200 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10201 %{
10202   match(Set y (AndI (CmpLTMask p q) y));
10203   effect(KILL cr);
10204 
10205   ins_cost(300);
10206 
10207   format %{ &quot;cmpl    $p, $q\t# and_cmpLTMask\n\t&quot;
10208             &quot;jlt     done\n\t&quot;
10209             &quot;xorl    $y, $y\n&quot;
10210             &quot;done:   &quot; %}
10211   ins_encode %{
10212     Register Rp = $p$$Register;
10213     Register Rq = $q$$Register;
10214     Register Ry = $y$$Register;
10215     Label done;
10216     __ cmpl(Rp, Rq);
10217     __ jccb(Assembler::less, done);
10218     __ xorl(Ry, Ry);
10219     __ bind(done);
10220   %}
10221   ins_pipe(pipe_cmplt);
10222 %}
10223 
10224 
10225 //---------- FP Instructions------------------------------------------------
10226 
10227 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
10228 %{
10229   match(Set cr (CmpF src1 src2));
10230 
10231   ins_cost(145);
10232   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10233             &quot;jnp,s   exit\n\t&quot;
10234             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10235             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10236             &quot;popfq\n&quot;
10237     &quot;exit:&quot; %}
10238   ins_encode %{
10239     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10240     emit_cmpfp_fixup(_masm);
10241   %}
10242   ins_pipe(pipe_slow);
10243 %}
10244 
10245 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
10246   match(Set cr (CmpF src1 src2));
10247 
10248   ins_cost(100);
10249   format %{ &quot;ucomiss $src1, $src2&quot; %}
10250   ins_encode %{
10251     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10252   %}
10253   ins_pipe(pipe_slow);
10254 %}
10255 
10256 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
10257 %{
10258   match(Set cr (CmpF src1 (LoadF src2)));
10259 
10260   ins_cost(145);
10261   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10262             &quot;jnp,s   exit\n\t&quot;
10263             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10264             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10265             &quot;popfq\n&quot;
10266     &quot;exit:&quot; %}
10267   ins_encode %{
10268     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10269     emit_cmpfp_fixup(_masm);
10270   %}
10271   ins_pipe(pipe_slow);
10272 %}
10273 
10274 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
10275   match(Set cr (CmpF src1 (LoadF src2)));
10276 
10277   ins_cost(100);
10278   format %{ &quot;ucomiss $src1, $src2&quot; %}
10279   ins_encode %{
10280     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10281   %}
10282   ins_pipe(pipe_slow);
10283 %}
10284 
10285 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
10286   match(Set cr (CmpF src con));
10287 
10288   ins_cost(145);
10289   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10290             &quot;jnp,s   exit\n\t&quot;
10291             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10292             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10293             &quot;popfq\n&quot;
10294     &quot;exit:&quot; %}
10295   ins_encode %{
10296     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10297     emit_cmpfp_fixup(_masm);
10298   %}
10299   ins_pipe(pipe_slow);
10300 %}
10301 
10302 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
10303   match(Set cr (CmpF src con));
10304   ins_cost(100);
10305   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con&quot; %}
10306   ins_encode %{
10307     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10308   %}
10309   ins_pipe(pipe_slow);
10310 %}
10311 
10312 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
10313 %{
10314   match(Set cr (CmpD src1 src2));
10315 
10316   ins_cost(145);
10317   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10318             &quot;jnp,s   exit\n\t&quot;
10319             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10320             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10321             &quot;popfq\n&quot;
10322     &quot;exit:&quot; %}
10323   ins_encode %{
10324     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10325     emit_cmpfp_fixup(_masm);
10326   %}
10327   ins_pipe(pipe_slow);
10328 %}
10329 
10330 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
10331   match(Set cr (CmpD src1 src2));
10332 
10333   ins_cost(100);
10334   format %{ &quot;ucomisd $src1, $src2 test&quot; %}
10335   ins_encode %{
10336     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10337   %}
10338   ins_pipe(pipe_slow);
10339 %}
10340 
10341 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
10342 %{
10343   match(Set cr (CmpD src1 (LoadD src2)));
10344 
10345   ins_cost(145);
10346   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10347             &quot;jnp,s   exit\n\t&quot;
10348             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10349             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10350             &quot;popfq\n&quot;
10351     &quot;exit:&quot; %}
10352   ins_encode %{
10353     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10354     emit_cmpfp_fixup(_masm);
10355   %}
10356   ins_pipe(pipe_slow);
10357 %}
10358 
10359 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
10360   match(Set cr (CmpD src1 (LoadD src2)));
10361 
10362   ins_cost(100);
10363   format %{ &quot;ucomisd $src1, $src2&quot; %}
10364   ins_encode %{
10365     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10366   %}
10367   ins_pipe(pipe_slow);
10368 %}
10369 
10370 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
10371   match(Set cr (CmpD src con));
10372 
10373   ins_cost(145);
10374   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10375             &quot;jnp,s   exit\n\t&quot;
10376             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10377             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10378             &quot;popfq\n&quot;
10379     &quot;exit:&quot; %}
10380   ins_encode %{
10381     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10382     emit_cmpfp_fixup(_masm);
10383   %}
10384   ins_pipe(pipe_slow);
10385 %}
10386 
10387 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
10388   match(Set cr (CmpD src con));
10389   ins_cost(100);
10390   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con&quot; %}
10391   ins_encode %{
10392     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10393   %}
10394   ins_pipe(pipe_slow);
10395 %}
10396 
10397 // Compare into -1,0,1
10398 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
10399 %{
10400   match(Set dst (CmpF3 src1 src2));
10401   effect(KILL cr);
10402 
10403   ins_cost(275);
10404   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10405             &quot;movl    $dst, #-1\n\t&quot;
10406             &quot;jp,s    done\n\t&quot;
10407             &quot;jb,s    done\n\t&quot;
10408             &quot;setne   $dst\n\t&quot;
10409             &quot;movzbl  $dst, $dst\n&quot;
10410     &quot;done:&quot; %}
10411   ins_encode %{
10412     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10413     emit_cmpfp3(_masm, $dst$$Register);
10414   %}
10415   ins_pipe(pipe_slow);
10416 %}
10417 
10418 // Compare into -1,0,1
10419 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
10420 %{
10421   match(Set dst (CmpF3 src1 (LoadF src2)));
10422   effect(KILL cr);
10423 
10424   ins_cost(275);
10425   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10426             &quot;movl    $dst, #-1\n\t&quot;
10427             &quot;jp,s    done\n\t&quot;
10428             &quot;jb,s    done\n\t&quot;
10429             &quot;setne   $dst\n\t&quot;
10430             &quot;movzbl  $dst, $dst\n&quot;
10431     &quot;done:&quot; %}
10432   ins_encode %{
10433     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10434     emit_cmpfp3(_masm, $dst$$Register);
10435   %}
10436   ins_pipe(pipe_slow);
10437 %}
10438 
10439 // Compare into -1,0,1
10440 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
10441   match(Set dst (CmpF3 src con));
10442   effect(KILL cr);
10443 
10444   ins_cost(275);
10445   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10446             &quot;movl    $dst, #-1\n\t&quot;
10447             &quot;jp,s    done\n\t&quot;
10448             &quot;jb,s    done\n\t&quot;
10449             &quot;setne   $dst\n\t&quot;
10450             &quot;movzbl  $dst, $dst\n&quot;
10451     &quot;done:&quot; %}
10452   ins_encode %{
10453     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10454     emit_cmpfp3(_masm, $dst$$Register);
10455   %}
10456   ins_pipe(pipe_slow);
10457 %}
10458 
10459 // Compare into -1,0,1
10460 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
10461 %{
10462   match(Set dst (CmpD3 src1 src2));
10463   effect(KILL cr);
10464 
10465   ins_cost(275);
10466   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10467             &quot;movl    $dst, #-1\n\t&quot;
10468             &quot;jp,s    done\n\t&quot;
10469             &quot;jb,s    done\n\t&quot;
10470             &quot;setne   $dst\n\t&quot;
10471             &quot;movzbl  $dst, $dst\n&quot;
10472     &quot;done:&quot; %}
10473   ins_encode %{
10474     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10475     emit_cmpfp3(_masm, $dst$$Register);
10476   %}
10477   ins_pipe(pipe_slow);
10478 %}
10479 
10480 // Compare into -1,0,1
10481 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
10482 %{
10483   match(Set dst (CmpD3 src1 (LoadD src2)));
10484   effect(KILL cr);
10485 
10486   ins_cost(275);
10487   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10488             &quot;movl    $dst, #-1\n\t&quot;
10489             &quot;jp,s    done\n\t&quot;
10490             &quot;jb,s    done\n\t&quot;
10491             &quot;setne   $dst\n\t&quot;
10492             &quot;movzbl  $dst, $dst\n&quot;
10493     &quot;done:&quot; %}
10494   ins_encode %{
10495     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10496     emit_cmpfp3(_masm, $dst$$Register);
10497   %}
10498   ins_pipe(pipe_slow);
10499 %}
10500 
10501 // Compare into -1,0,1
10502 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
10503   match(Set dst (CmpD3 src con));
10504   effect(KILL cr);
10505 
10506   ins_cost(275);
10507   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10508             &quot;movl    $dst, #-1\n\t&quot;
10509             &quot;jp,s    done\n\t&quot;
10510             &quot;jb,s    done\n\t&quot;
10511             &quot;setne   $dst\n\t&quot;
10512             &quot;movzbl  $dst, $dst\n&quot;
10513     &quot;done:&quot; %}
10514   ins_encode %{
10515     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10516     emit_cmpfp3(_masm, $dst$$Register);
10517   %}
10518   ins_pipe(pipe_slow);
10519 %}
10520 
10521 //----------Arithmetic Conversion Instructions---------------------------------
10522 
10523 instruct convF2D_reg_reg(regD dst, regF src)
10524 %{
10525   match(Set dst (ConvF2D src));
10526 
10527   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10528   ins_encode %{
10529     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10530   %}
10531   ins_pipe(pipe_slow); // XXX
10532 %}
10533 
10534 instruct convF2D_reg_mem(regD dst, memory src)
10535 %{
10536   match(Set dst (ConvF2D (LoadF src)));
10537 
10538   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10539   ins_encode %{
10540     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
10541   %}
10542   ins_pipe(pipe_slow); // XXX
10543 %}
10544 
10545 instruct convD2F_reg_reg(regF dst, regD src)
10546 %{
10547   match(Set dst (ConvD2F src));
10548 
10549   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10550   ins_encode %{
10551     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10552   %}
10553   ins_pipe(pipe_slow); // XXX
10554 %}
10555 
10556 instruct convD2F_reg_mem(regF dst, memory src)
10557 %{
10558   match(Set dst (ConvD2F (LoadD src)));
10559 
10560   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10561   ins_encode %{
10562     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
10563   %}
10564   ins_pipe(pipe_slow); // XXX
10565 %}
10566 
10567 // XXX do mem variants
10568 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
10569 %{
10570   match(Set dst (ConvF2I src));
10571   effect(KILL cr);
10572   format %{ &quot;convert_f2i $dst,$src&quot; %}
10573   ins_encode %{
10574     __ convert_f2i($dst$$Register, $src$$XMMRegister);
10575   %}
10576   ins_pipe(pipe_slow);
10577 %}
10578 
10579 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10580 %{
10581   match(Set dst (ConvF2L src));
10582   effect(KILL cr);
10583   format %{ &quot;convert_f2l $dst,$src&quot;%}
10584   ins_encode %{
10585     __ convert_f2l($dst$$Register, $src$$XMMRegister);
10586   %}
10587   ins_pipe(pipe_slow);
10588 %}
10589 
10590 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10591 %{
10592   match(Set dst (ConvD2I src));
10593   effect(KILL cr);
10594   format %{ &quot;convert_d2i $dst,$src&quot;%}
10595   ins_encode %{
10596     __ convert_d2i($dst$$Register, $src$$XMMRegister);
10597   %}
10598   ins_pipe(pipe_slow);
10599 %}
10600 
10601 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10602 %{
10603   match(Set dst (ConvD2L src));
10604   effect(KILL cr);
10605   format %{ &quot;convert_d2l $dst,$src&quot;%}
10606   ins_encode %{
10607     __ convert_d2l($dst$$Register, $src$$XMMRegister);
10608   %}
10609   ins_pipe(pipe_slow);
10610 %}
10611 
10612 instruct convI2F_reg_reg(regF dst, rRegI src)
10613 %{
10614   predicate(!UseXmmI2F);
10615   match(Set dst (ConvI2F src));
10616 
10617   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10618   ins_encode %{
10619     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10620   %}
10621   ins_pipe(pipe_slow); // XXX
10622 %}
10623 
10624 instruct convI2F_reg_mem(regF dst, memory src)
10625 %{
10626   match(Set dst (ConvI2F (LoadI src)));
10627 
10628   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10629   ins_encode %{
10630     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10631   %}
10632   ins_pipe(pipe_slow); // XXX
10633 %}
10634 
10635 instruct convI2D_reg_reg(regD dst, rRegI src)
10636 %{
10637   predicate(!UseXmmI2D);
10638   match(Set dst (ConvI2D src));
10639 
10640   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10641   ins_encode %{
10642     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10643   %}
10644   ins_pipe(pipe_slow); // XXX
10645 %}
10646 
10647 instruct convI2D_reg_mem(regD dst, memory src)
10648 %{
10649   match(Set dst (ConvI2D (LoadI src)));
10650 
10651   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10652   ins_encode %{
10653     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10654   %}
10655   ins_pipe(pipe_slow); // XXX
10656 %}
10657 
10658 instruct convXI2F_reg(regF dst, rRegI src)
10659 %{
10660   predicate(UseXmmI2F);
10661   match(Set dst (ConvI2F src));
10662 
10663   format %{ &quot;movdl $dst, $src\n\t&quot;
10664             &quot;cvtdq2psl $dst, $dst\t# i2f&quot; %}
10665   ins_encode %{
10666     __ movdl($dst$$XMMRegister, $src$$Register);
10667     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10668   %}
10669   ins_pipe(pipe_slow); // XXX
10670 %}
10671 
10672 instruct convXI2D_reg(regD dst, rRegI src)
10673 %{
10674   predicate(UseXmmI2D);
10675   match(Set dst (ConvI2D src));
10676 
10677   format %{ &quot;movdl $dst, $src\n\t&quot;
10678             &quot;cvtdq2pdl $dst, $dst\t# i2d&quot; %}
10679   ins_encode %{
10680     __ movdl($dst$$XMMRegister, $src$$Register);
10681     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10682   %}
10683   ins_pipe(pipe_slow); // XXX
10684 %}
10685 
10686 instruct convL2F_reg_reg(regF dst, rRegL src)
10687 %{
10688   match(Set dst (ConvL2F src));
10689 
10690   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10691   ins_encode %{
10692     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10693   %}
10694   ins_pipe(pipe_slow); // XXX
10695 %}
10696 
10697 instruct convL2F_reg_mem(regF dst, memory src)
10698 %{
10699   match(Set dst (ConvL2F (LoadL src)));
10700 
10701   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10702   ins_encode %{
10703     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10704   %}
10705   ins_pipe(pipe_slow); // XXX
10706 %}
10707 
10708 instruct convL2D_reg_reg(regD dst, rRegL src)
10709 %{
10710   match(Set dst (ConvL2D src));
10711 
10712   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10713   ins_encode %{
10714     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10715   %}
10716   ins_pipe(pipe_slow); // XXX
10717 %}
10718 
10719 instruct convL2D_reg_mem(regD dst, memory src)
10720 %{
10721   match(Set dst (ConvL2D (LoadL src)));
10722 
10723   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10724   ins_encode %{
10725     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10726   %}
10727   ins_pipe(pipe_slow); // XXX
10728 %}
10729 
10730 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10731 %{
10732   match(Set dst (ConvI2L src));
10733 
10734   ins_cost(125);
10735   format %{ &quot;movslq  $dst, $src\t# i2l&quot; %}
10736   ins_encode %{
10737     __ movslq($dst$$Register, $src$$Register);
10738   %}
10739   ins_pipe(ialu_reg_reg);
10740 %}
10741 
10742 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10743 // %{
10744 //   match(Set dst (ConvI2L src));
10745 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10746 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10747 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10748 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10749 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10750 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10751 
10752 //   format %{ &quot;movl    $dst, $src\t# unsigned i2l&quot; %}
10753 //   ins_encode(enc_copy(dst, src));
10754 // //   opcode(0x63); // needs REX.W
10755 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10756 //   ins_pipe(ialu_reg_reg);
10757 // %}
10758 
10759 // Zero-extend convert int to long
10760 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10761 %{
10762   match(Set dst (AndL (ConvI2L src) mask));
10763 
10764   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10765   ins_encode %{
10766     if ($dst$$reg != $src$$reg) {
10767       __ movl($dst$$Register, $src$$Register);
10768     }
10769   %}
10770   ins_pipe(ialu_reg_reg);
10771 %}
10772 
10773 // Zero-extend convert int to long
10774 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10775 %{
10776   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10777 
10778   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10779   ins_encode %{
10780     __ movl($dst$$Register, $src$$Address);
10781   %}
10782   ins_pipe(ialu_reg_mem);
10783 %}
10784 
10785 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10786 %{
10787   match(Set dst (AndL src mask));
10788 
10789   format %{ &quot;movl    $dst, $src\t# zero-extend long&quot; %}
10790   ins_encode %{
10791     __ movl($dst$$Register, $src$$Register);
10792   %}
10793   ins_pipe(ialu_reg_reg);
10794 %}
10795 
10796 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10797 %{
10798   match(Set dst (ConvL2I src));
10799 
10800   format %{ &quot;movl    $dst, $src\t# l2i&quot; %}
10801   ins_encode %{
10802     __ movl($dst$$Register, $src$$Register);
10803   %}
10804   ins_pipe(ialu_reg_reg);
10805 %}
10806 
10807 
10808 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10809   match(Set dst (MoveF2I src));
10810   effect(DEF dst, USE src);
10811 
10812   ins_cost(125);
10813   format %{ &quot;movl    $dst, $src\t# MoveF2I_stack_reg&quot; %}
10814   ins_encode %{
10815     __ movl($dst$$Register, Address(rsp, $src$$disp));
10816   %}
10817   ins_pipe(ialu_reg_mem);
10818 %}
10819 
10820 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10821   match(Set dst (MoveI2F src));
10822   effect(DEF dst, USE src);
10823 
10824   ins_cost(125);
10825   format %{ &quot;movss   $dst, $src\t# MoveI2F_stack_reg&quot; %}
10826   ins_encode %{
10827     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10828   %}
10829   ins_pipe(pipe_slow);
10830 %}
10831 
10832 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10833   match(Set dst (MoveD2L src));
10834   effect(DEF dst, USE src);
10835 
10836   ins_cost(125);
10837   format %{ &quot;movq    $dst, $src\t# MoveD2L_stack_reg&quot; %}
10838   ins_encode %{
10839     __ movq($dst$$Register, Address(rsp, $src$$disp));
10840   %}
10841   ins_pipe(ialu_reg_mem);
10842 %}
10843 
10844 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10845   predicate(!UseXmmLoadAndClearUpper);
10846   match(Set dst (MoveL2D src));
10847   effect(DEF dst, USE src);
10848 
10849   ins_cost(125);
10850   format %{ &quot;movlpd  $dst, $src\t# MoveL2D_stack_reg&quot; %}
10851   ins_encode %{
10852     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10853   %}
10854   ins_pipe(pipe_slow);
10855 %}
10856 
10857 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10858   predicate(UseXmmLoadAndClearUpper);
10859   match(Set dst (MoveL2D src));
10860   effect(DEF dst, USE src);
10861 
10862   ins_cost(125);
10863   format %{ &quot;movsd   $dst, $src\t# MoveL2D_stack_reg&quot; %}
10864   ins_encode %{
10865     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10866   %}
10867   ins_pipe(pipe_slow);
10868 %}
10869 
10870 
10871 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10872   match(Set dst (MoveF2I src));
10873   effect(DEF dst, USE src);
10874 
10875   ins_cost(95); // XXX
10876   format %{ &quot;movss   $dst, $src\t# MoveF2I_reg_stack&quot; %}
10877   ins_encode %{
10878     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10879   %}
10880   ins_pipe(pipe_slow);
10881 %}
10882 
10883 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10884   match(Set dst (MoveI2F src));
10885   effect(DEF dst, USE src);
10886 
10887   ins_cost(100);
10888   format %{ &quot;movl    $dst, $src\t# MoveI2F_reg_stack&quot; %}
10889   ins_encode %{
10890     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10891   %}
10892   ins_pipe( ialu_mem_reg );
10893 %}
10894 
10895 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10896   match(Set dst (MoveD2L src));
10897   effect(DEF dst, USE src);
10898 
10899   ins_cost(95); // XXX
10900   format %{ &quot;movsd   $dst, $src\t# MoveL2D_reg_stack&quot; %}
10901   ins_encode %{
10902     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10903   %}
10904   ins_pipe(pipe_slow);
10905 %}
10906 
10907 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10908   match(Set dst (MoveL2D src));
10909   effect(DEF dst, USE src);
10910 
10911   ins_cost(100);
10912   format %{ &quot;movq    $dst, $src\t# MoveL2D_reg_stack&quot; %}
10913   ins_encode %{
10914     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10915   %}
10916   ins_pipe(ialu_mem_reg);
10917 %}
10918 
10919 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10920   match(Set dst (MoveF2I src));
10921   effect(DEF dst, USE src);
10922   ins_cost(85);
10923   format %{ &quot;movd    $dst,$src\t# MoveF2I&quot; %}
10924   ins_encode %{
10925     __ movdl($dst$$Register, $src$$XMMRegister);
10926   %}
10927   ins_pipe( pipe_slow );
10928 %}
10929 
10930 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10931   match(Set dst (MoveD2L src));
10932   effect(DEF dst, USE src);
10933   ins_cost(85);
10934   format %{ &quot;movd    $dst,$src\t# MoveD2L&quot; %}
10935   ins_encode %{
10936     __ movdq($dst$$Register, $src$$XMMRegister);
10937   %}
10938   ins_pipe( pipe_slow );
10939 %}
10940 
10941 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10942   match(Set dst (MoveI2F src));
10943   effect(DEF dst, USE src);
10944   ins_cost(100);
10945   format %{ &quot;movd    $dst,$src\t# MoveI2F&quot; %}
10946   ins_encode %{
10947     __ movdl($dst$$XMMRegister, $src$$Register);
10948   %}
10949   ins_pipe( pipe_slow );
10950 %}
10951 
10952 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10953   match(Set dst (MoveL2D src));
10954   effect(DEF dst, USE src);
10955   ins_cost(100);
10956   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10957   ins_encode %{
10958      __ movdq($dst$$XMMRegister, $src$$Register);
10959   %}
10960   ins_pipe( pipe_slow );
10961 %}
10962 
10963 
10964 // =======================================================================
10965 // fast clearing of an array
10966 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,
10967                   Universe dummy, rFlagsReg cr)
10968 %{
10969   predicate(!((ClearArrayNode*)n)-&gt;is_large());
10970   match(Set dummy (ClearArray cnt base));
10971   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
10972 
10973   format %{ $$template
10974     $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
10975     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10976     $$emit$$&quot;jg      LARGE\n\t&quot;
10977     $$emit$$&quot;dec     rcx\n\t&quot;
10978     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10979     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10980     $$emit$$&quot;dec     rcx\n\t&quot;
10981     $$emit$$&quot;jge     LOOP\n\t&quot;
10982     $$emit$$&quot;jmp     DONE\n\t&quot;
10983     $$emit$$&quot;# LARGE:\n\t&quot;
10984     if (UseFastStosb) {
10985        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10986        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10987     } else if (UseXMMForObjInit) {
10988        $$emit$$&quot;mov     rdi,rax\n\t&quot;
10989        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;
10990        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10991        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
10992        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
10993        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;
10994        $$emit$$&quot;add     0x40,rax\n\t&quot;
10995        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10996        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10997        $$emit$$&quot;jge     L_loop\n\t&quot;
10998        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10999        $$emit$$&quot;jl      L_tail\n\t&quot;
11000        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
11001        $$emit$$&quot;add     0x20,rax\n\t&quot;
11002        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11003        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11004        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11005        $$emit$$&quot;jle     L_end\n\t&quot;
11006        $$emit$$&quot;dec     rcx\n\t&quot;
11007        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11008        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11009        $$emit$$&quot;add     0x8,rax\n\t&quot;
11010        $$emit$$&quot;dec     rcx\n\t&quot;
11011        $$emit$$&quot;jge     L_sloop\n\t&quot;
11012        $$emit$$&quot;# L_end:\n\t&quot;
11013     } else {
11014        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11015     }
11016     $$emit$$&quot;# DONE&quot;
11017   %}
11018   ins_encode %{
11019     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11020                  $tmp$$XMMRegister, false);
11021   %}
11022   ins_pipe(pipe_slow);
11023 %}
11024 
11025 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,
11026                         Universe dummy, rFlagsReg cr)
11027 %{
11028   predicate(((ClearArrayNode*)n)-&gt;is_large());
11029   match(Set dummy (ClearArray cnt base));
11030   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11031 
11032   format %{ $$template
11033     if (UseFastStosb) {
11034        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
11035        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11036        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
11037     } else if (UseXMMForObjInit) {
11038        $$emit$$&quot;mov     rdi,rax\t# ClearArray:\n\t&quot;
11039        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;
11040        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11041        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11042        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
11043        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;
11044        $$emit$$&quot;add     0x40,rax\n\t&quot;
11045        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11046        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11047        $$emit$$&quot;jge     L_loop\n\t&quot;
11048        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11049        $$emit$$&quot;jl      L_tail\n\t&quot;
11050        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
11051        $$emit$$&quot;add     0x20,rax\n\t&quot;
11052        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11053        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11054        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11055        $$emit$$&quot;jle     L_end\n\t&quot;
11056        $$emit$$&quot;dec     rcx\n\t&quot;
11057        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11058        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11059        $$emit$$&quot;add     0x8,rax\n\t&quot;
11060        $$emit$$&quot;dec     rcx\n\t&quot;
11061        $$emit$$&quot;jge     L_sloop\n\t&quot;
11062        $$emit$$&quot;# L_end:\n\t&quot;
11063     } else {
11064        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
11065        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11066     }
11067   %}
11068   ins_encode %{
11069     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11070                  $tmp$$XMMRegister, true);
11071   %}
11072   ins_pipe(pipe_slow);
11073 %}
11074 
11075 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11076                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11077 %{
11078   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11079   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11080   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11081 
11082   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11083   ins_encode %{
11084     __ string_compare($str1$$Register, $str2$$Register,
11085                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11086                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11087   %}
11088   ins_pipe( pipe_slow );
11089 %}
11090 
11091 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11092                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11093 %{
11094   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11095   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11096   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11097 
11098   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11099   ins_encode %{
11100     __ string_compare($str1$$Register, $str2$$Register,
11101                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11102                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11103   %}
11104   ins_pipe( pipe_slow );
11105 %}
11106 
11107 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11108                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11109 %{
11110   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11111   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11112   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11113 
11114   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11115   ins_encode %{
11116     __ string_compare($str1$$Register, $str2$$Register,
11117                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11118                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11119   %}
11120   ins_pipe( pipe_slow );
11121 %}
11122 
11123 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
11124                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11125 %{
11126   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11127   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11128   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11129 
11130   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11131   ins_encode %{
11132     __ string_compare($str2$$Register, $str1$$Register,
11133                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11134                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11135   %}
11136   ins_pipe( pipe_slow );
11137 %}
11138 
11139 // fast search of substring with known size.
11140 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11141                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11142 %{
11143   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11144   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11145   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11146 
11147   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11148   ins_encode %{
11149     int icnt2 = (int)$int_cnt2$$constant;
11150     if (icnt2 &gt;= 16) {
11151       // IndexOf for constant substrings with size &gt;= 16 elements
11152       // which don&#39;t need to be loaded through stack.
11153       __ string_indexofC8($str1$$Register, $str2$$Register,
11154                           $cnt1$$Register, $cnt2$$Register,
11155                           icnt2, $result$$Register,
11156                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11157     } else {
11158       // Small strings are loaded through stack if they cross page boundary.
11159       __ string_indexof($str1$$Register, $str2$$Register,
11160                         $cnt1$$Register, $cnt2$$Register,
11161                         icnt2, $result$$Register,
11162                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11163     }
11164   %}
11165   ins_pipe( pipe_slow );
11166 %}
11167 
11168 // fast search of substring with known size.
11169 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11170                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11171 %{
11172   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11173   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11174   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11175 
11176   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11177   ins_encode %{
11178     int icnt2 = (int)$int_cnt2$$constant;
11179     if (icnt2 &gt;= 8) {
11180       // IndexOf for constant substrings with size &gt;= 8 elements
11181       // which don&#39;t need to be loaded through stack.
11182       __ string_indexofC8($str1$$Register, $str2$$Register,
11183                           $cnt1$$Register, $cnt2$$Register,
11184                           icnt2, $result$$Register,
11185                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11186     } else {
11187       // Small strings are loaded through stack if they cross page boundary.
11188       __ string_indexof($str1$$Register, $str2$$Register,
11189                         $cnt1$$Register, $cnt2$$Register,
11190                         icnt2, $result$$Register,
11191                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11192     }
11193   %}
11194   ins_pipe( pipe_slow );
11195 %}
11196 
11197 // fast search of substring with known size.
11198 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11199                               rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11200 %{
11201   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11202   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11203   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11204 
11205   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11206   ins_encode %{
11207     int icnt2 = (int)$int_cnt2$$constant;
11208     if (icnt2 &gt;= 8) {
11209       // IndexOf for constant substrings with size &gt;= 8 elements
11210       // which don&#39;t need to be loaded through stack.
11211       __ string_indexofC8($str1$$Register, $str2$$Register,
11212                           $cnt1$$Register, $cnt2$$Register,
11213                           icnt2, $result$$Register,
11214                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11215     } else {
11216       // Small strings are loaded through stack if they cross page boundary.
11217       __ string_indexof($str1$$Register, $str2$$Register,
11218                         $cnt1$$Register, $cnt2$$Register,
11219                         icnt2, $result$$Register,
11220                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11221     }
11222   %}
11223   ins_pipe( pipe_slow );
11224 %}
11225 
11226 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11227                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11228 %{
11229   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11230   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11231   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11232 
11233   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11234   ins_encode %{
11235     __ string_indexof($str1$$Register, $str2$$Register,
11236                       $cnt1$$Register, $cnt2$$Register,
11237                       (-1), $result$$Register,
11238                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11239   %}
11240   ins_pipe( pipe_slow );
11241 %}
11242 
11243 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11244                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11245 %{
11246   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11247   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11248   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11249 
11250   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11251   ins_encode %{
11252     __ string_indexof($str1$$Register, $str2$$Register,
11253                       $cnt1$$Register, $cnt2$$Register,
11254                       (-1), $result$$Register,
11255                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11256   %}
11257   ins_pipe( pipe_slow );
11258 %}
11259 
11260 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11261                           rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11262 %{
11263   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11264   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11265   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11266 
11267   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11268   ins_encode %{
11269     __ string_indexof($str1$$Register, $str2$$Register,
11270                       $cnt1$$Register, $cnt2$$Register,
11271                       (-1), $result$$Register,
11272                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11273   %}
11274   ins_pipe( pipe_slow );
11275 %}
11276 
11277 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
11278                               rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)
11279 %{
11280   predicate(UseSSE42Intrinsics);
11281   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11282   effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11283   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11284   ins_encode %{
11285     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11286                            $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);
11287   %}
11288   ins_pipe( pipe_slow );
11289 %}
11290 
11291 // fast string equals
11292 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
11293                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11294 %{
11295   match(Set result (StrEquals (Binary str1 str2) cnt));
11296   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11297 
11298   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11299   ins_encode %{
11300     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11301                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11302                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11303   %}
11304   ins_pipe( pipe_slow );
11305 %}
11306 
11307 // fast array equals
11308 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11309                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11310 %{
11311   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11312   match(Set result (AryEq ary1 ary2));
11313   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11314 
11315   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11316   ins_encode %{
11317     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11318                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11319                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11320   %}
11321   ins_pipe( pipe_slow );
11322 %}
11323 
11324 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11325                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11326 %{
11327   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11328   match(Set result (AryEq ary1 ary2));
11329   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11330 
11331   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11332   ins_encode %{
11333     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11334                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11335                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11336   %}
11337   ins_pipe( pipe_slow );
11338 %}
11339 
11340 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
11341                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11342 %{
11343   match(Set result (HasNegatives ary1 len));
11344   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11345 
11346   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11347   ins_encode %{
11348     __ has_negatives($ary1$$Register, $len$$Register,
11349                      $result$$Register, $tmp3$$Register,
11350                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11351   %}
11352   ins_pipe( pipe_slow );
11353 %}
11354 
11355 // fast char[] to byte[] compression
11356 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11357                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11358   match(Set result (StrCompressedCopy src (Binary dst len)));
11359   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11360 
11361   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11362   ins_encode %{
11363     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11364                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11365                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11366   %}
11367   ins_pipe( pipe_slow );
11368 %}
11369 
11370 // fast byte[] to char[] inflation
11371 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11372                         legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{
11373   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11374   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11375 
11376   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11377   ins_encode %{
11378     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11379                           $tmp1$$XMMRegister, $tmp2$$Register);
11380   %}
11381   ins_pipe( pipe_slow );
11382 %}
11383 
11384 // encode char[] to byte[] in ISO_8859_1
11385 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11386                           legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11387                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11388   match(Set result (EncodeISOArray src (Binary dst len)));
11389   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11390 
11391   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
11392   ins_encode %{
11393     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11394                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11395                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11396   %}
11397   ins_pipe( pipe_slow );
11398 %}
11399 
11400 //----------Overflow Math Instructions-----------------------------------------
11401 
11402 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11403 %{
11404   match(Set cr (OverflowAddI op1 op2));
11405   effect(DEF cr, USE_KILL op1, USE op2);
11406 
11407   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11408 
11409   ins_encode %{
11410     __ addl($op1$$Register, $op2$$Register);
11411   %}
11412   ins_pipe(ialu_reg_reg);
11413 %}
11414 
11415 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
11416 %{
11417   match(Set cr (OverflowAddI op1 op2));
11418   effect(DEF cr, USE_KILL op1, USE op2);
11419 
11420   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11421 
11422   ins_encode %{
11423     __ addl($op1$$Register, $op2$$constant);
11424   %}
11425   ins_pipe(ialu_reg_reg);
11426 %}
11427 
11428 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11429 %{
11430   match(Set cr (OverflowAddL op1 op2));
11431   effect(DEF cr, USE_KILL op1, USE op2);
11432 
11433   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11434   ins_encode %{
11435     __ addq($op1$$Register, $op2$$Register);
11436   %}
11437   ins_pipe(ialu_reg_reg);
11438 %}
11439 
11440 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
11441 %{
11442   match(Set cr (OverflowAddL op1 op2));
11443   effect(DEF cr, USE_KILL op1, USE op2);
11444 
11445   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11446   ins_encode %{
11447     __ addq($op1$$Register, $op2$$constant);
11448   %}
11449   ins_pipe(ialu_reg_reg);
11450 %}
11451 
11452 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11453 %{
11454   match(Set cr (OverflowSubI op1 op2));
11455 
11456   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11457   ins_encode %{
11458     __ cmpl($op1$$Register, $op2$$Register);
11459   %}
11460   ins_pipe(ialu_reg_reg);
11461 %}
11462 
11463 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11464 %{
11465   match(Set cr (OverflowSubI op1 op2));
11466 
11467   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11468   ins_encode %{
11469     __ cmpl($op1$$Register, $op2$$constant);
11470   %}
11471   ins_pipe(ialu_reg_reg);
11472 %}
11473 
11474 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11475 %{
11476   match(Set cr (OverflowSubL op1 op2));
11477 
11478   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11479   ins_encode %{
11480     __ cmpq($op1$$Register, $op2$$Register);
11481   %}
11482   ins_pipe(ialu_reg_reg);
11483 %}
11484 
11485 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11486 %{
11487   match(Set cr (OverflowSubL op1 op2));
11488 
11489   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11490   ins_encode %{
11491     __ cmpq($op1$$Register, $op2$$constant);
11492   %}
11493   ins_pipe(ialu_reg_reg);
11494 %}
11495 
11496 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
11497 %{
11498   match(Set cr (OverflowSubI zero op2));
11499   effect(DEF cr, USE_KILL op2);
11500 
11501   format %{ &quot;negl    $op2\t# overflow check int&quot; %}
11502   ins_encode %{
11503     __ negl($op2$$Register);
11504   %}
11505   ins_pipe(ialu_reg_reg);
11506 %}
11507 
11508 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
11509 %{
11510   match(Set cr (OverflowSubL zero op2));
11511   effect(DEF cr, USE_KILL op2);
11512 
11513   format %{ &quot;negq    $op2\t# overflow check long&quot; %}
11514   ins_encode %{
11515     __ negq($op2$$Register);
11516   %}
11517   ins_pipe(ialu_reg_reg);
11518 %}
11519 
11520 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11521 %{
11522   match(Set cr (OverflowMulI op1 op2));
11523   effect(DEF cr, USE_KILL op1, USE op2);
11524 
11525   format %{ &quot;imull    $op1, $op2\t# overflow check int&quot; %}
11526   ins_encode %{
11527     __ imull($op1$$Register, $op2$$Register);
11528   %}
11529   ins_pipe(ialu_reg_reg_alu0);
11530 %}
11531 
11532 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
11533 %{
11534   match(Set cr (OverflowMulI op1 op2));
11535   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11536 
11537   format %{ &quot;imull    $tmp, $op1, $op2\t# overflow check int&quot; %}
11538   ins_encode %{
11539     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
11540   %}
11541   ins_pipe(ialu_reg_reg_alu0);
11542 %}
11543 
11544 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11545 %{
11546   match(Set cr (OverflowMulL op1 op2));
11547   effect(DEF cr, USE_KILL op1, USE op2);
11548 
11549   format %{ &quot;imulq    $op1, $op2\t# overflow check long&quot; %}
11550   ins_encode %{
11551     __ imulq($op1$$Register, $op2$$Register);
11552   %}
11553   ins_pipe(ialu_reg_reg_alu0);
11554 %}
11555 
11556 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
11557 %{
11558   match(Set cr (OverflowMulL op1 op2));
11559   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11560 
11561   format %{ &quot;imulq    $tmp, $op1, $op2\t# overflow check long&quot; %}
11562   ins_encode %{
11563     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
11564   %}
11565   ins_pipe(ialu_reg_reg_alu0);
11566 %}
11567 
11568 
11569 //----------Control Flow Instructions------------------------------------------
11570 // Signed compare Instructions
11571 
11572 // XXX more variants!!
11573 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11574 %{
11575   match(Set cr (CmpI op1 op2));
11576   effect(DEF cr, USE op1, USE op2);
11577 
11578   format %{ &quot;cmpl    $op1, $op2&quot; %}
11579   opcode(0x3B);  /* Opcode 3B /r */
11580   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11581   ins_pipe(ialu_cr_reg_reg);
11582 %}
11583 
11584 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11585 %{
11586   match(Set cr (CmpI op1 op2));
11587 
11588   format %{ &quot;cmpl    $op1, $op2&quot; %}
11589   opcode(0x81, 0x07); /* Opcode 81 /7 */
11590   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11591   ins_pipe(ialu_cr_reg_imm);
11592 %}
11593 
11594 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
11595 %{
11596   match(Set cr (CmpI op1 (LoadI op2)));
11597 
11598   ins_cost(500); // XXX
11599   format %{ &quot;cmpl    $op1, $op2&quot; %}
11600   opcode(0x3B); /* Opcode 3B /r */
11601   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11602   ins_pipe(ialu_cr_reg_mem);
11603 %}
11604 
11605 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
11606 %{
11607   match(Set cr (CmpI src zero));
11608 
11609   format %{ &quot;testl   $src, $src&quot; %}
11610   opcode(0x85);
11611   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11612   ins_pipe(ialu_cr_reg_imm);
11613 %}
11614 
11615 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11616 %{
11617   match(Set cr (CmpI (AndI src con) zero));
11618 
11619   format %{ &quot;testl   $src, $con&quot; %}
11620   opcode(0xF7, 0x00);
11621   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11622   ins_pipe(ialu_cr_reg_imm);
11623 %}
11624 
11625 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11626 %{
11627   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11628 
11629   format %{ &quot;testl   $src, $mem&quot; %}
11630   opcode(0x85);
11631   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11632   ins_pipe(ialu_cr_reg_mem);
11633 %}
11634 
11635 // Unsigned compare Instructions; really, same as signed except they
11636 // produce an rFlagsRegU instead of rFlagsReg.
11637 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11638 %{
11639   match(Set cr (CmpU op1 op2));
11640 
11641   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11642   opcode(0x3B); /* Opcode 3B /r */
11643   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11644   ins_pipe(ialu_cr_reg_reg);
11645 %}
11646 
11647 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11648 %{
11649   match(Set cr (CmpU op1 op2));
11650 
11651   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11652   opcode(0x81,0x07); /* Opcode 81 /7 */
11653   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11654   ins_pipe(ialu_cr_reg_imm);
11655 %}
11656 
11657 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
11658 %{
11659   match(Set cr (CmpU op1 (LoadI op2)));
11660 
11661   ins_cost(500); // XXX
11662   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11663   opcode(0x3B); /* Opcode 3B /r */
11664   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11665   ins_pipe(ialu_cr_reg_mem);
11666 %}
11667 
11668 // // // Cisc-spilled version of cmpU_rReg
11669 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11670 // //%{
11671 // //  match(Set cr (CmpU (LoadI op1) op2));
11672 // //
11673 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11674 // //  ins_cost(500);
11675 // //  opcode(0x39);  /* Opcode 39 /r */
11676 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11677 // //%}
11678 
11679 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11680 %{
11681   match(Set cr (CmpU src zero));
11682 
11683   format %{ &quot;testl   $src, $src\t# unsigned&quot; %}
11684   opcode(0x85);
11685   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11686   ins_pipe(ialu_cr_reg_imm);
11687 %}
11688 
11689 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11690 %{
11691   match(Set cr (CmpP op1 op2));
11692 
11693   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11694   opcode(0x3B); /* Opcode 3B /r */
11695   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11696   ins_pipe(ialu_cr_reg_reg);
11697 %}
11698 
11699 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11700 %{
11701   match(Set cr (CmpP op1 (LoadP op2)));
11702   predicate(n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11703 
11704   ins_cost(500); // XXX
11705   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11706   opcode(0x3B); /* Opcode 3B /r */
11707   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11708   ins_pipe(ialu_cr_reg_mem);
11709 %}
11710 
11711 // // // Cisc-spilled version of cmpP_rReg
11712 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11713 // //%{
11714 // //  match(Set cr (CmpP (LoadP op1) op2));
11715 // //
11716 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11717 // //  ins_cost(500);
11718 // //  opcode(0x39);  /* Opcode 39 /r */
11719 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11720 // //%}
11721 
11722 // XXX this is generalized by compP_rReg_mem???
11723 // Compare raw pointer (used in out-of-heap check).
11724 // Only works because non-oop pointers must be raw pointers
11725 // and raw pointers have no anti-dependencies.
11726 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11727 %{
11728   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none &amp;&amp;
11729             n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11730   match(Set cr (CmpP op1 (LoadP op2)));
11731 
11732   format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
11733   opcode(0x3B); /* Opcode 3B /r */
11734   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11735   ins_pipe(ialu_cr_reg_mem);
11736 %}
11737 
11738 // This will generate a signed flags result. This should be OK since
11739 // any compare to a zero should be eq/neq.
11740 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11741 %{
11742   match(Set cr (CmpP src zero));
11743 
11744   format %{ &quot;testq   $src, $src\t# ptr&quot; %}
11745   opcode(0x85);
11746   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11747   ins_pipe(ialu_cr_reg_imm);
11748 %}
11749 
11750 // This will generate a signed flags result. This should be OK since
11751 // any compare to a zero should be eq/neq.
11752 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11753 %{
11754   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11755             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11756   match(Set cr (CmpP (LoadP op) zero));
11757 
11758   ins_cost(500); // XXX
11759   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11760   opcode(0xF7); /* Opcode F7 /0 */
11761   ins_encode(REX_mem_wide(op),
11762              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11763   ins_pipe(ialu_cr_reg_imm);
11764 %}
11765 
11766 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11767 %{
11768   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;
11769             (CompressedKlassPointers::base() == NULL) &amp;&amp;
11770             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11771   match(Set cr (CmpP (LoadP mem) zero));
11772 
11773   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11774   ins_encode %{
11775     __ cmpq(r12, $mem$$Address);
11776   %}
11777   ins_pipe(ialu_cr_reg_mem);
11778 %}
11779 
11780 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11781 %{
11782   match(Set cr (CmpN op1 op2));
11783 
11784   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11785   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11786   ins_pipe(ialu_cr_reg_reg);
11787 %}
11788 
11789 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11790 %{
11791   match(Set cr (CmpN src (LoadN mem)));
11792 
11793   format %{ &quot;cmpl    $src, $mem\t# compressed ptr&quot; %}
11794   ins_encode %{
11795     __ cmpl($src$$Register, $mem$$Address);
11796   %}
11797   ins_pipe(ialu_cr_reg_mem);
11798 %}
11799 
11800 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
11801   match(Set cr (CmpN op1 op2));
11802 
11803   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11804   ins_encode %{
11805     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
11806   %}
11807   ins_pipe(ialu_cr_reg_imm);
11808 %}
11809 
11810 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
11811 %{
11812   match(Set cr (CmpN src (LoadN mem)));
11813 
11814   format %{ &quot;cmpl    $mem, $src\t# compressed ptr&quot; %}
11815   ins_encode %{
11816     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
11817   %}
11818   ins_pipe(ialu_cr_reg_mem);
11819 %}
11820 
11821 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
11822   match(Set cr (CmpN op1 op2));
11823 
11824   format %{ &quot;cmpl    $op1, $op2\t# compressed klass ptr&quot; %}
11825   ins_encode %{
11826     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
11827   %}
11828   ins_pipe(ialu_cr_reg_imm);
11829 %}
11830 
11831 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
11832 %{
11833   match(Set cr (CmpN src (LoadNKlass mem)));
11834 
11835   format %{ &quot;cmpl    $mem, $src\t# compressed klass ptr&quot; %}
11836   ins_encode %{
11837     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11838   %}
11839   ins_pipe(ialu_cr_reg_mem);
11840 %}
11841 
11842 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
11843   match(Set cr (CmpN src zero));
11844 
11845   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
11846   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11847   ins_pipe(ialu_cr_reg_imm);
11848 %}
11849 
11850 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11851 %{
11852   predicate(CompressedOops::base() != NULL);
11853   match(Set cr (CmpN (LoadN mem) zero));
11854 
11855   ins_cost(500); // XXX
11856   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
11857   ins_encode %{
11858     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11859   %}
11860   ins_pipe(ialu_cr_reg_mem);
11861 %}
11862 
11863 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11864 %{
11865   predicate(CompressedOops::base() == NULL &amp;&amp; (CompressedKlassPointers::base() == NULL));
11866   match(Set cr (CmpN (LoadN mem) zero));
11867 
11868   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
11869   ins_encode %{
11870     __ cmpl(r12, $mem$$Address);
11871   %}
11872   ins_pipe(ialu_cr_reg_mem);
11873 %}
11874 
11875 // Yanked all unsigned pointer compare operations.
11876 // Pointer compares are done with CmpP which is already unsigned.
11877 
11878 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11879 %{
11880   match(Set cr (CmpL op1 op2));
11881 
11882   format %{ &quot;cmpq    $op1, $op2&quot; %}
11883   opcode(0x3B);  /* Opcode 3B /r */
11884   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11885   ins_pipe(ialu_cr_reg_reg);
11886 %}
11887 
11888 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11889 %{
11890   match(Set cr (CmpL op1 op2));
11891 
11892   format %{ &quot;cmpq    $op1, $op2&quot; %}
11893   opcode(0x81, 0x07); /* Opcode 81 /7 */
11894   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11895   ins_pipe(ialu_cr_reg_imm);
11896 %}
11897 
11898 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
11899 %{
11900   match(Set cr (CmpL op1 (LoadL op2)));
11901 
11902   format %{ &quot;cmpq    $op1, $op2&quot; %}
11903   opcode(0x3B); /* Opcode 3B /r */
11904   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11905   ins_pipe(ialu_cr_reg_mem);
11906 %}
11907 
11908 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
11909 %{
11910   match(Set cr (CmpL src zero));
11911 
11912   format %{ &quot;testq   $src, $src&quot; %}
11913   opcode(0x85);
11914   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11915   ins_pipe(ialu_cr_reg_imm);
11916 %}
11917 
11918 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
11919 %{
11920   match(Set cr (CmpL (AndL src con) zero));
11921 
11922   format %{ &quot;testq   $src, $con\t# long&quot; %}
11923   opcode(0xF7, 0x00);
11924   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
11925   ins_pipe(ialu_cr_reg_imm);
11926 %}
11927 
11928 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
11929 %{
11930   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
11931 
11932   format %{ &quot;testq   $src, $mem&quot; %}
11933   opcode(0x85);
11934   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11935   ins_pipe(ialu_cr_reg_mem);
11936 %}
11937 
11938 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
11939 %{
11940   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
11941 
11942   format %{ &quot;testq   $src, $mem&quot; %}
11943   opcode(0x85);
11944   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11945   ins_pipe(ialu_cr_reg_mem);
11946 %}
11947 
11948 // Manifest a CmpL result in an integer register.  Very painful.
11949 // This is the test to avoid.
11950 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
11951 %{
11952   match(Set dst (CmpL3 src1 src2));
11953   effect(KILL flags);
11954 
11955   ins_cost(275); // XXX
11956   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
11957             &quot;movl    $dst, -1\n\t&quot;
11958             &quot;jl,s    done\n\t&quot;
11959             &quot;setne   $dst\n\t&quot;
11960             &quot;movzbl  $dst, $dst\n\t&quot;
11961     &quot;done:&quot; %}
11962   ins_encode(cmpl3_flag(src1, src2, dst));
11963   ins_pipe(pipe_slow);
11964 %}
11965 
11966 // Unsigned long compare Instructions; really, same as signed long except they
11967 // produce an rFlagsRegU instead of rFlagsReg.
11968 instruct compUL_rReg(rFlagsRegU cr, rRegL op1, rRegL op2)
11969 %{
11970   match(Set cr (CmpUL op1 op2));
11971 
11972   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11973   opcode(0x3B);  /* Opcode 3B /r */
11974   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11975   ins_pipe(ialu_cr_reg_reg);
11976 %}
11977 
11978 instruct compUL_rReg_imm(rFlagsRegU cr, rRegL op1, immL32 op2)
11979 %{
11980   match(Set cr (CmpUL op1 op2));
11981 
11982   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11983   opcode(0x81, 0x07); /* Opcode 81 /7 */
11984   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11985   ins_pipe(ialu_cr_reg_imm);
11986 %}
11987 
11988 instruct compUL_rReg_mem(rFlagsRegU cr, rRegL op1, memory op2)
11989 %{
11990   match(Set cr (CmpUL op1 (LoadL op2)));
11991 
11992   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11993   opcode(0x3B); /* Opcode 3B /r */
11994   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11995   ins_pipe(ialu_cr_reg_mem);
11996 %}
11997 
11998 instruct testUL_reg(rFlagsRegU cr, rRegL src, immL0 zero)
11999 %{
12000   match(Set cr (CmpUL src zero));
12001 
12002   format %{ &quot;testq   $src, $src\t# unsigned&quot; %}
12003   opcode(0x85);
12004   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
12005   ins_pipe(ialu_cr_reg_imm);
12006 %}
12007 
12008 instruct compB_mem_imm(rFlagsReg cr, memory mem, immI8 imm)
12009 %{
12010   match(Set cr (CmpI (LoadB mem) imm));
12011 
12012   ins_cost(125);
12013   format %{ &quot;cmpb    $mem, $imm&quot; %}
12014   ins_encode %{ __ cmpb($mem$$Address, $imm$$constant); %}
12015   ins_pipe(ialu_cr_reg_mem);
12016 %}
12017 
12018 instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU8 imm, immI0 zero)
12019 %{
12020   match(Set cr (CmpI (AndI (LoadUB mem) imm) zero));
12021 
12022   ins_cost(125);
12023   format %{ &quot;testb   $mem, $imm\t# ubyte&quot; %}
12024   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
12025   ins_pipe(ialu_cr_reg_mem);
12026 %}
12027 
12028 instruct testB_mem_imm(rFlagsReg cr, memory mem, immI8 imm, immI0 zero)
12029 %{
12030   match(Set cr (CmpI (AndI (LoadB mem) imm) zero));
12031 
12032   ins_cost(125);
12033   format %{ &quot;testb   $mem, $imm\t# byte&quot; %}
12034   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
12035   ins_pipe(ialu_cr_reg_mem);
12036 %}
12037 
12038 //----------Max and Min--------------------------------------------------------
12039 // Min Instructions
12040 
12041 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
12042 %{
12043   effect(USE_DEF dst, USE src, USE cr);
12044 
12045   format %{ &quot;cmovlgt $dst, $src\t# min&quot; %}
12046   opcode(0x0F, 0x4F);
12047   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12048   ins_pipe(pipe_cmov_reg);
12049 %}
12050 
12051 
12052 instruct minI_rReg(rRegI dst, rRegI src)
12053 %{
12054   match(Set dst (MinI dst src));
12055 
12056   ins_cost(200);
12057   expand %{
12058     rFlagsReg cr;
12059     compI_rReg(cr, dst, src);
12060     cmovI_reg_g(dst, src, cr);
12061   %}
12062 %}
12063 
12064 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
12065 %{
12066   effect(USE_DEF dst, USE src, USE cr);
12067 
12068   format %{ &quot;cmovllt $dst, $src\t# max&quot; %}
12069   opcode(0x0F, 0x4C);
12070   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12071   ins_pipe(pipe_cmov_reg);
12072 %}
12073 
12074 
12075 instruct maxI_rReg(rRegI dst, rRegI src)
12076 %{
12077   match(Set dst (MaxI dst src));
12078 
12079   ins_cost(200);
12080   expand %{
12081     rFlagsReg cr;
12082     compI_rReg(cr, dst, src);
12083     cmovI_reg_l(dst, src, cr);
12084   %}
12085 %}
12086 
12087 // ============================================================================
12088 // Branch Instructions
12089 
12090 // Jump Direct - Label defines a relative address from JMP+1
12091 instruct jmpDir(label labl)
12092 %{
12093   match(Goto);
12094   effect(USE labl);
12095 
12096   ins_cost(300);
12097   format %{ &quot;jmp     $labl&quot; %}
12098   size(5);
12099   ins_encode %{
12100     Label* L = $labl$$label;
12101     __ jmp(*L, false); // Always long jump
12102   %}
12103   ins_pipe(pipe_jmp);
12104 %}
12105 
12106 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12107 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
12108 %{
12109   match(If cop cr);
12110   effect(USE labl);
12111 
12112   ins_cost(300);
12113   format %{ &quot;j$cop     $labl&quot; %}
12114   size(6);
12115   ins_encode %{
12116     Label* L = $labl$$label;
12117     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12118   %}
12119   ins_pipe(pipe_jcc);
12120 %}
12121 
12122 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12123 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
12124 %{
12125   predicate(!n-&gt;has_vector_mask_set());
12126   match(CountedLoopEnd cop cr);
12127   effect(USE labl);
12128 
12129   ins_cost(300);
12130   format %{ &quot;j$cop     $labl\t# loop end&quot; %}
12131   size(6);
12132   ins_encode %{
12133     Label* L = $labl$$label;
12134     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12135   %}
12136   ins_pipe(pipe_jcc);
12137 %}
12138 
12139 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12140 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12141   predicate(!n-&gt;has_vector_mask_set());
12142   match(CountedLoopEnd cop cmp);
12143   effect(USE labl);
12144 
12145   ins_cost(300);
12146   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12147   size(6);
12148   ins_encode %{
12149     Label* L = $labl$$label;
12150     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12151   %}
12152   ins_pipe(pipe_jcc);
12153 %}
12154 
12155 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12156   predicate(!n-&gt;has_vector_mask_set());
12157   match(CountedLoopEnd cop cmp);
12158   effect(USE labl);
12159 
12160   ins_cost(200);
12161   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12162   size(6);
12163   ins_encode %{
12164     Label* L = $labl$$label;
12165     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12166   %}
12167   ins_pipe(pipe_jcc);
12168 %}
12169 
12170 // mask version
12171 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12172 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, rFlagsReg cr, label labl)
12173 %{
12174   predicate(n-&gt;has_vector_mask_set());
12175   match(CountedLoopEnd cop cr);
12176   effect(USE labl);
12177 
12178   ins_cost(400);
12179   format %{ &quot;j$cop     $labl\t# loop end\n\t&quot;
12180             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12181   size(10);
12182   ins_encode %{
12183     Label* L = $labl$$label;
12184     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12185     __ restorevectmask();
12186   %}
12187   ins_pipe(pipe_jcc);
12188 %}
12189 
12190 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12191 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12192   predicate(n-&gt;has_vector_mask_set());
12193   match(CountedLoopEnd cop cmp);
12194   effect(USE labl);
12195 
12196   ins_cost(400);
12197   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12198             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12199   size(10);
12200   ins_encode %{
12201     Label* L = $labl$$label;
12202     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12203     __ restorevectmask();
12204   %}
12205   ins_pipe(pipe_jcc);
12206 %}
12207 
12208 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12209   predicate(n-&gt;has_vector_mask_set());
12210   match(CountedLoopEnd cop cmp);
12211   effect(USE labl);
12212 
12213   ins_cost(300);
12214   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12215             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12216   size(10);
12217   ins_encode %{
12218     Label* L = $labl$$label;
12219     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12220     __ restorevectmask();
12221   %}
12222   ins_pipe(pipe_jcc);
12223 %}
12224 
12225 // Jump Direct Conditional - using unsigned comparison
12226 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12227   match(If cop cmp);
12228   effect(USE labl);
12229 
12230   ins_cost(300);
12231   format %{ &quot;j$cop,u   $labl&quot; %}
12232   size(6);
12233   ins_encode %{
12234     Label* L = $labl$$label;
12235     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12236   %}
12237   ins_pipe(pipe_jcc);
12238 %}
12239 
12240 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12241   match(If cop cmp);
12242   effect(USE labl);
12243 
12244   ins_cost(200);
12245   format %{ &quot;j$cop,u   $labl&quot; %}
12246   size(6);
12247   ins_encode %{
12248     Label* L = $labl$$label;
12249     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12250   %}
12251   ins_pipe(pipe_jcc);
12252 %}
12253 
12254 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12255   match(If cop cmp);
12256   effect(USE labl);
12257 
12258   ins_cost(200);
12259   format %{ $$template
12260     if ($cop$$cmpcode == Assembler::notEqual) {
12261       $$emit$$&quot;jp,u    $labl\n\t&quot;
12262       $$emit$$&quot;j$cop,u   $labl&quot;
12263     } else {
12264       $$emit$$&quot;jp,u    done\n\t&quot;
12265       $$emit$$&quot;j$cop,u   $labl\n\t&quot;
12266       $$emit$$&quot;done:&quot;
12267     }
12268   %}
12269   ins_encode %{
12270     Label* l = $labl$$label;
12271     if ($cop$$cmpcode == Assembler::notEqual) {
12272       __ jcc(Assembler::parity, *l, false);
12273       __ jcc(Assembler::notEqual, *l, false);
12274     } else if ($cop$$cmpcode == Assembler::equal) {
12275       Label done;
12276       __ jccb(Assembler::parity, done);
12277       __ jcc(Assembler::equal, *l, false);
12278       __ bind(done);
12279     } else {
12280        ShouldNotReachHere();
12281     }
12282   %}
12283   ins_pipe(pipe_jcc);
12284 %}
12285 
12286 // ============================================================================
12287 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary
12288 // superklass array for an instance of the superklass.  Set a hidden
12289 // internal cache on a hit (cache is checked with exposed code in
12290 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
12291 // encoding ALSO sets flags.
12292 
12293 instruct partialSubtypeCheck(rdi_RegP result,
12294                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12295                              rFlagsReg cr)
12296 %{
12297   match(Set result (PartialSubtypeCheck sub super));
12298   effect(KILL rcx, KILL cr);
12299 
12300   ins_cost(1100);  // slightly larger than the next version
12301   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12302             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12303             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12304             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t&quot;
12305             &quot;jne,s   miss\t\t# Missed: rdi not-zero\n\t&quot;
12306             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12307             &quot;xorq    $result, $result\t\t Hit: rdi zero\n\t&quot;
12308     &quot;miss:\t&quot; %}
12309 
12310   opcode(0x1); // Force a XOR of RDI
12311   ins_encode(enc_PartialSubtypeCheck());
12312   ins_pipe(pipe_slow);
12313 %}
12314 
12315 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
12316                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12317                                      immP0 zero,
12318                                      rdi_RegP result)
12319 %{
12320   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12321   effect(KILL rcx, KILL result);
12322 
12323   ins_cost(1000);
12324   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12325             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12326             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12327             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t&quot;
12328             &quot;jne,s   miss\t\t# Missed: flags nz\n\t&quot;
12329             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12330     &quot;miss:\t&quot; %}
12331 
12332   opcode(0x0); // No need to XOR RDI
12333   ins_encode(enc_PartialSubtypeCheck());
12334   ins_pipe(pipe_slow);
12335 %}
12336 
12337 // ============================================================================
12338 // Branch Instructions -- short offset versions
12339 //
12340 // These instructions are used to replace jumps of a long offset (the default
12341 // match) with jumps of a shorter offset.  These instructions are all tagged
12342 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12343 // match rules in general matching.  Instead, the ADLC generates a conversion
12344 // method in the MachNode which can be used to do in-place replacement of the
12345 // long variant with the shorter variant.  The compiler will determine if a
12346 // branch can be taken by the is_short_branch_offset() predicate in the machine
12347 // specific code section of the file.
12348 
12349 // Jump Direct - Label defines a relative address from JMP+1
12350 instruct jmpDir_short(label labl) %{
12351   match(Goto);
12352   effect(USE labl);
12353 
12354   ins_cost(300);
12355   format %{ &quot;jmp,s   $labl&quot; %}
12356   size(2);
12357   ins_encode %{
12358     Label* L = $labl$$label;
12359     __ jmpb(*L);
12360   %}
12361   ins_pipe(pipe_jmp);
12362   ins_short_branch(1);
12363 %}
12364 
12365 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12366 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
12367   match(If cop cr);
12368   effect(USE labl);
12369 
12370   ins_cost(300);
12371   format %{ &quot;j$cop,s   $labl&quot; %}
12372   size(2);
12373   ins_encode %{
12374     Label* L = $labl$$label;
12375     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12376   %}
12377   ins_pipe(pipe_jcc);
12378   ins_short_branch(1);
12379 %}
12380 
12381 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12382 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
12383   match(CountedLoopEnd cop cr);
12384   effect(USE labl);
12385 
12386   ins_cost(300);
12387   format %{ &quot;j$cop,s   $labl\t# loop end&quot; %}
12388   size(2);
12389   ins_encode %{
12390     Label* L = $labl$$label;
12391     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12392   %}
12393   ins_pipe(pipe_jcc);
12394   ins_short_branch(1);
12395 %}
12396 
12397 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12398 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12399   match(CountedLoopEnd cop cmp);
12400   effect(USE labl);
12401 
12402   ins_cost(300);
12403   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12404   size(2);
12405   ins_encode %{
12406     Label* L = $labl$$label;
12407     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12408   %}
12409   ins_pipe(pipe_jcc);
12410   ins_short_branch(1);
12411 %}
12412 
12413 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12414   match(CountedLoopEnd cop cmp);
12415   effect(USE labl);
12416 
12417   ins_cost(300);
12418   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12419   size(2);
12420   ins_encode %{
12421     Label* L = $labl$$label;
12422     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12423   %}
12424   ins_pipe(pipe_jcc);
12425   ins_short_branch(1);
12426 %}
12427 
12428 // Jump Direct Conditional - using unsigned comparison
12429 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12430   match(If cop cmp);
12431   effect(USE labl);
12432 
12433   ins_cost(300);
12434   format %{ &quot;j$cop,us  $labl&quot; %}
12435   size(2);
12436   ins_encode %{
12437     Label* L = $labl$$label;
12438     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12439   %}
12440   ins_pipe(pipe_jcc);
12441   ins_short_branch(1);
12442 %}
12443 
12444 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12445   match(If cop cmp);
12446   effect(USE labl);
12447 
12448   ins_cost(300);
12449   format %{ &quot;j$cop,us  $labl&quot; %}
12450   size(2);
12451   ins_encode %{
12452     Label* L = $labl$$label;
12453     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12454   %}
12455   ins_pipe(pipe_jcc);
12456   ins_short_branch(1);
12457 %}
12458 
12459 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12460   match(If cop cmp);
12461   effect(USE labl);
12462 
12463   ins_cost(300);
12464   format %{ $$template
12465     if ($cop$$cmpcode == Assembler::notEqual) {
12466       $$emit$$&quot;jp,u,s  $labl\n\t&quot;
12467       $$emit$$&quot;j$cop,u,s  $labl&quot;
12468     } else {
12469       $$emit$$&quot;jp,u,s  done\n\t&quot;
12470       $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
12471       $$emit$$&quot;done:&quot;
12472     }
12473   %}
12474   size(4);
12475   ins_encode %{
12476     Label* l = $labl$$label;
12477     if ($cop$$cmpcode == Assembler::notEqual) {
12478       __ jccb(Assembler::parity, *l);
12479       __ jccb(Assembler::notEqual, *l);
12480     } else if ($cop$$cmpcode == Assembler::equal) {
12481       Label done;
12482       __ jccb(Assembler::parity, done);
12483       __ jccb(Assembler::equal, *l);
12484       __ bind(done);
12485     } else {
12486        ShouldNotReachHere();
12487     }
12488   %}
12489   ins_pipe(pipe_jcc);
12490   ins_short_branch(1);
12491 %}
12492 
12493 // ============================================================================
12494 // inlined locking and unlocking
12495 
12496 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12497   predicate(Compile::current()-&gt;use_rtm());
12498   match(Set cr (FastLock object box));
12499   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12500   ins_cost(300);
12501   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12502   ins_encode %{
12503     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12504                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12505                  _counters, _rtm_counters, _stack_rtm_counters,
12506                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12507                  true, ra_-&gt;C-&gt;profile_rtm());
12508   %}
12509   ins_pipe(pipe_slow);
12510 %}
12511 
12512 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{
12513   predicate(!Compile::current()-&gt;use_rtm());
12514   match(Set cr (FastLock object box));
12515   effect(TEMP tmp, TEMP scr, USE_KILL box);
12516   ins_cost(300);
12517   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12518   ins_encode %{
12519     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12520                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
12521   %}
12522   ins_pipe(pipe_slow);
12523 %}
12524 
12525 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12526   match(Set cr (FastUnlock object box));
12527   effect(TEMP tmp, USE_KILL box);
12528   ins_cost(300);
12529   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12530   ins_encode %{
12531     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12532   %}
12533   ins_pipe(pipe_slow);
12534 %}
12535 
12536 
12537 // ============================================================================
12538 // Safepoint Instructions
12539 instruct safePoint_poll(rFlagsReg cr)
12540 %{
12541   predicate(!Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
12542   match(SafePoint);
12543   effect(KILL cr);
12544 
12545   format %{ &quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;
12546             &quot;# Safepoint: poll for GC&quot; %}
12547   ins_cost(125);
12548   ins_encode %{
12549     AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
12550     __ testl(rax, addr);
12551   %}
12552   ins_pipe(ialu_reg_mem);
12553 %}
12554 
12555 instruct safePoint_poll_far(rFlagsReg cr, rRegP poll)
12556 %{
12557   predicate(Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
12558   match(SafePoint poll);
12559   effect(KILL cr, USE poll);
12560 
12561   format %{ &quot;testl   rax, [$poll]\t&quot;
12562             &quot;# Safepoint: poll for GC&quot; %}
12563   ins_cost(125);
12564   ins_encode %{
12565     __ relocate(relocInfo::poll_type);
12566     __ testl(rax, Address($poll$$Register, 0));
12567   %}
12568   ins_pipe(ialu_reg_mem);
12569 %}
12570 
12571 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12572 %{
12573   predicate(SafepointMechanism::uses_thread_local_poll());
12574   match(SafePoint poll);
12575   effect(KILL cr, USE poll);
12576 
12577   format %{ &quot;testl   rax, [$poll]\t&quot;
12578             &quot;# Safepoint: poll for GC&quot; %}
12579   ins_cost(125);
12580   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12581   ins_encode %{
12582     __ relocate(relocInfo::poll_type);
12583     address pre_pc = __ pc();
12584     __ testl(rax, Address($poll$$Register, 0));
12585     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12586   %}
12587   ins_pipe(ialu_reg_mem);
12588 %}
12589 
12590 // ============================================================================
12591 // Procedure Call/Return Instructions
12592 // Call Java Static Instruction
12593 // Note: If this code changes, the corresponding ret_addr_offset() and
12594 //       compute_padding() functions will have to be adjusted.
12595 instruct CallStaticJavaDirect(method meth) %{
12596   match(CallStaticJava);
12597   effect(USE meth);
12598 
12599   ins_cost(300);
12600   format %{ &quot;call,static &quot; %}
12601   opcode(0xE8); /* E8 cd */
12602   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
12603   ins_pipe(pipe_slow);
12604   ins_alignment(4);
12605 %}
12606 
12607 // Call Java Dynamic Instruction
12608 // Note: If this code changes, the corresponding ret_addr_offset() and
12609 //       compute_padding() functions will have to be adjusted.
12610 instruct CallDynamicJavaDirect(method meth)
12611 %{
12612   match(CallDynamicJava);
12613   effect(USE meth);
12614 
12615   ins_cost(300);
12616   format %{ &quot;movq    rax, #Universe::non_oop_word()\n\t&quot;
12617             &quot;call,dynamic &quot; %}
12618   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
12619   ins_pipe(pipe_slow);
12620   ins_alignment(4);
12621 %}
12622 
12623 // Call Runtime Instruction
12624 instruct CallRuntimeDirect(method meth)
12625 %{
12626   match(CallRuntime);
12627   effect(USE meth);
12628 
12629   ins_cost(300);
12630   format %{ &quot;call,runtime &quot; %}
12631   ins_encode(clear_avx, Java_To_Runtime(meth));
12632   ins_pipe(pipe_slow);
12633 %}
12634 
12635 // Call runtime without safepoint
12636 instruct CallLeafDirect(method meth)
12637 %{
12638   match(CallLeaf);
12639   effect(USE meth);
12640 
12641   ins_cost(300);
12642   format %{ &quot;call_leaf,runtime &quot; %}
12643   ins_encode(clear_avx, Java_To_Runtime(meth));
12644   ins_pipe(pipe_slow);
12645 %}
12646 
12647 // Call runtime without safepoint
12648 instruct CallLeafNoFPDirect(method meth)
12649 %{
12650   match(CallLeafNoFP);
12651   effect(USE meth);
12652 
12653   ins_cost(300);
12654   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12655   ins_encode(clear_avx, Java_To_Runtime(meth));
12656   ins_pipe(pipe_slow);
12657 %}
12658 
12659 // Return Instruction
12660 // Remove the return address &amp; jump to it.
12661 // Notice: We always emit a nop after a ret to make sure there is room
12662 // for safepoint patching
12663 instruct Ret()
12664 %{
12665   match(Return);
12666 
12667   format %{ &quot;ret&quot; %}
12668   opcode(0xC3);
12669   ins_encode(OpcP);
12670   ins_pipe(pipe_jmp);
12671 %}
12672 
12673 // Tail Call; Jump from runtime stub to Java code.
12674 // Also known as an &#39;interprocedural jump&#39;.
12675 // Target of jump will eventually return to caller.
12676 // TailJump below removes the return address.
12677 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
12678 %{
12679   match(TailCall jump_target method_oop);
12680 
12681   ins_cost(300);
12682   format %{ &quot;jmp     $jump_target\t# rbx holds method oop&quot; %}
12683   opcode(0xFF, 0x4); /* Opcode FF /4 */
12684   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
12685   ins_pipe(pipe_jmp);
12686 %}
12687 
12688 // Tail Jump; remove the return address; jump to target.
12689 // TailCall above leaves the return address around.
12690 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
12691 %{
12692   match(TailJump jump_target ex_oop);
12693 
12694   ins_cost(300);
12695   format %{ &quot;popq    rdx\t# pop return address\n\t&quot;
12696             &quot;jmp     $jump_target&quot; %}
12697   opcode(0xFF, 0x4); /* Opcode FF /4 */
12698   ins_encode(Opcode(0x5a), // popq rdx
12699              REX_reg(jump_target), OpcP, reg_opc(jump_target));
12700   ins_pipe(pipe_jmp);
12701 %}
12702 
12703 // Create exception oop: created by stack-crawling runtime code.
12704 // Created exception is now available to this handler, and is setup
12705 // just prior to jumping to this handler.  No code emitted.
12706 instruct CreateException(rax_RegP ex_oop)
12707 %{
12708   match(Set ex_oop (CreateEx));
12709 
12710   size(0);
12711   // use the following format syntax
12712   format %{ &quot;# exception oop is in rax; no code emitted&quot; %}
12713   ins_encode();
12714   ins_pipe(empty);
12715 %}
12716 
12717 // Rethrow exception:
12718 // The exception oop will come in the first argument position.
12719 // Then JUMP (not call) to the rethrow stub code.
12720 instruct RethrowException()
12721 %{
12722   match(Rethrow);
12723 
12724   // use the following format syntax
12725   format %{ &quot;jmp     rethrow_stub&quot; %}
12726   ins_encode(enc_rethrow);
12727   ins_pipe(pipe_jmp);
12728 %}
12729 
12730 // ============================================================================
12731 // This name is KNOWN by the ADLC and cannot be changed.
12732 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
12733 // for this guy.
12734 instruct tlsLoadP(r15_RegP dst) %{
12735   match(Set dst (ThreadLocal));
12736   effect(DEF dst);
12737 
12738   size(0);
12739   format %{ &quot;# TLS is in R15&quot; %}
12740   ins_encode( /*empty encoding*/ );
12741   ins_pipe(ialu_reg_reg);
12742 %}
12743 
12744 
12745 //----------PEEPHOLE RULES-----------------------------------------------------
12746 // These must follow all instruction definitions as they use the names
12747 // defined in the instructions definitions.
12748 //
12749 // peepmatch ( root_instr_name [preceding_instruction]* );
12750 //
12751 // peepconstraint %{
12752 // (instruction_number.operand_name relational_op instruction_number.operand_name
12753 //  [, ...] );
12754 // // instruction numbers are zero-based using left to right order in peepmatch
12755 //
12756 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
12757 // // provide an instruction_number.operand_name for each operand that appears
12758 // // in the replacement instruction&#39;s match rule
12759 //
12760 // ---------VM FLAGS---------------------------------------------------------
12761 //
12762 // All peephole optimizations can be turned off using -XX:-OptoPeephole
12763 //
12764 // Each peephole rule is given an identifying number starting with zero and
12765 // increasing by one in the order seen by the parser.  An individual peephole
12766 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
12767 // on the command-line.
12768 //
12769 // ---------CURRENT LIMITATIONS----------------------------------------------
12770 //
12771 // Only match adjacent instructions in same basic block
12772 // Only equality constraints
12773 // Only constraints between operands, not (0.dest_reg == RAX_enc)
12774 // Only one replacement instruction
12775 //
12776 // ---------EXAMPLE----------------------------------------------------------
12777 //
12778 // // pertinent parts of existing instructions in architecture description
12779 // instruct movI(rRegI dst, rRegI src)
12780 // %{
12781 //   match(Set dst (CopyI src));
12782 // %}
12783 //
12784 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
12785 // %{
12786 //   match(Set dst (AddI dst src));
12787 //   effect(KILL cr);
12788 // %}
12789 //
12790 // // Change (inc mov) to lea
12791 // peephole %{
12792 //   // increment preceeded by register-register move
12793 //   peepmatch ( incI_rReg movI );
12794 //   // require that the destination register of the increment
12795 //   // match the destination register of the move
12796 //   peepconstraint ( 0.dst == 1.dst );
12797 //   // construct a replacement instruction that sets
12798 //   // the destination to ( move&#39;s source register + one )
12799 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
12800 // %}
12801 //
12802 
12803 // Implementation no longer uses movX instructions since
12804 // machine-independent system no longer uses CopyX nodes.
12805 //
12806 // peephole
12807 // %{
12808 //   peepmatch (incI_rReg movI);
12809 //   peepconstraint (0.dst == 1.dst);
12810 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12811 // %}
12812 
12813 // peephole
12814 // %{
12815 //   peepmatch (decI_rReg movI);
12816 //   peepconstraint (0.dst == 1.dst);
12817 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12818 // %}
12819 
12820 // peephole
12821 // %{
12822 //   peepmatch (addI_rReg_imm movI);
12823 //   peepconstraint (0.dst == 1.dst);
12824 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12825 // %}
12826 
12827 // peephole
12828 // %{
12829 //   peepmatch (incL_rReg movL);
12830 //   peepconstraint (0.dst == 1.dst);
12831 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12832 // %}
12833 
12834 // peephole
12835 // %{
12836 //   peepmatch (decL_rReg movL);
12837 //   peepconstraint (0.dst == 1.dst);
12838 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12839 // %}
12840 
12841 // peephole
12842 // %{
12843 //   peepmatch (addL_rReg_imm movL);
12844 //   peepconstraint (0.dst == 1.dst);
12845 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12846 // %}
12847 
12848 // peephole
12849 // %{
12850 //   peepmatch (addP_rReg_imm movP);
12851 //   peepconstraint (0.dst == 1.dst);
12852 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
12853 // %}
12854 
12855 // // Change load of spilled value to only a spill
12856 // instruct storeI(memory mem, rRegI src)
12857 // %{
12858 //   match(Set mem (StoreI mem src));
12859 // %}
12860 //
12861 // instruct loadI(rRegI dst, memory mem)
12862 // %{
12863 //   match(Set dst (LoadI mem));
12864 // %}
12865 //
12866 
12867 peephole
12868 %{
12869   peepmatch (loadI storeI);
12870   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12871   peepreplace (storeI(1.mem 1.mem 1.src));
12872 %}
12873 
12874 peephole
12875 %{
12876   peepmatch (loadL storeL);
12877   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12878   peepreplace (storeL(1.mem 1.mem 1.src));
12879 %}
12880 
12881 //----------SMARTSPILL RULES---------------------------------------------------
12882 // These must follow all instruction definitions as they use the names
12883 // defined in the instructions definitions.
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.EOFException;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.InterruptedIOException;
  32 import java.io.OutputStream;
  33 import java.net.InetAddress;
  34 import java.net.InetSocketAddress;
  35 import java.net.Socket;
  36 import java.net.SocketAddress;
  37 import java.net.SocketException;
  38 import java.net.UnknownHostException;
  39 import java.nio.ByteBuffer;
  40 import java.util.List;
  41 import java.util.concurrent.TimeUnit;
  42 import java.util.concurrent.locks.ReentrantLock;
  43 import java.util.function.BiFunction;
  44 import javax.net.ssl.HandshakeCompletedListener;
  45 import javax.net.ssl.SSLException;
  46 import javax.net.ssl.SSLHandshakeException;
  47 import javax.net.ssl.SSLParameters;
  48 import javax.net.ssl.SSLProtocolException;
  49 import javax.net.ssl.SSLServerSocket;
  50 import javax.net.ssl.SSLSession;
  51 import javax.net.ssl.SSLSocket;
  52 import jdk.internal.access.JavaNetInetAddressAccess;
  53 import jdk.internal.access.SharedSecrets;
  54 
  55 /**
  56  * Implementation of an SSL socket.
  57  * &lt;P&gt;
  58  * This is a normal connection type socket, implementing SSL over some lower
  59  * level socket, such as TCP.  Because it is layered over some lower level
  60  * socket, it MUST override all default socket methods.
  61  * &lt;P&gt;
  62  * This API offers a non-traditional option for establishing SSL
  63  * connections.  You may first establish the connection directly, then pass
  64  * that connection to the SSL socket constructor with a flag saying which
  65  * role should be taken in the handshake protocol.  (The two ends of the
  66  * connection must not choose the same role!)  This allows setup of SSL
  67  * proxying or tunneling, and also allows the kind of &quot;role reversal&quot;
  68  * that is required for most FTP data transfers.
  69  *
  70  * @see javax.net.ssl.SSLSocket
  71  * @see SSLServerSocket
  72  *
  73  * @author David Brownell
  74  */
  75 public final class SSLSocketImpl
  76         extends BaseSSLSocketImpl implements SSLTransport {
  77 
  78     final SSLContextImpl            sslContext;
  79     final TransportContext          conContext;
  80 
  81     private final AppInputStream    appInput = new AppInputStream();
  82     private final AppOutputStream   appOutput = new AppOutputStream();
  83 
  84     private String                  peerHost;
  85     private boolean                 autoClose;
  86     private boolean                 isConnected = false;
  87     private volatile boolean        tlsIsClosed = false;
  88 
  89     private final ReentrantLock     socketLock = new ReentrantLock();
  90     private final ReentrantLock     handshakeLock = new ReentrantLock();
  91 
  92     /*
  93      * Is the local name service trustworthy?
  94      *
  95      * If the local name service is not trustworthy, reverse host name
  96      * resolution should not be performed for endpoint identification.
  97      */
  98     private static final boolean trustNameService =
  99             Utilities.getBooleanProperty(&quot;jdk.tls.trustNameService&quot;, false);
 100 
 101     /**
 102      * Package-private constructor used to instantiate an unconnected
 103      * socket.
 104      *
 105      * This instance is meant to set handshake state to use &quot;client mode&quot;.
 106      */
 107     SSLSocketImpl(SSLContextImpl sslContext) {
 108         super();
 109         this.sslContext = sslContext;
 110         HandshakeHash handshakeHash = new HandshakeHash();
 111         this.conContext = new TransportContext(sslContext, this,
 112                 new SSLSocketInputRecord(handshakeHash),
 113                 new SSLSocketOutputRecord(handshakeHash), true);
 114     }
 115 
 116     /**
 117      * Package-private constructor used to instantiate a server socket.
 118      *
 119      * This instance is meant to set handshake state to use &quot;server mode&quot;.
 120      */
 121     SSLSocketImpl(SSLContextImpl sslContext, SSLConfiguration sslConfig) {
 122         super();
 123         this.sslContext = sslContext;
 124         HandshakeHash handshakeHash = new HandshakeHash();
 125         this.conContext = new TransportContext(sslContext, this, sslConfig,
 126                 new SSLSocketInputRecord(handshakeHash),
 127                 new SSLSocketOutputRecord(handshakeHash));
 128     }
 129 
 130     /**
 131      * Constructs an SSL connection to a named host at a specified
 132      * port, using the authentication context provided.
 133      *
 134      * This endpoint acts as the client, and may rejoin an existing SSL session
 135      * if appropriate.
 136      */
 137     SSLSocketImpl(SSLContextImpl sslContext, String peerHost,
 138             int peerPort) throws IOException, UnknownHostException {
 139         super();
 140         this.sslContext = sslContext;
 141         HandshakeHash handshakeHash = new HandshakeHash();
 142         this.conContext = new TransportContext(sslContext, this,
 143                 new SSLSocketInputRecord(handshakeHash),
 144                 new SSLSocketOutputRecord(handshakeHash), true);
 145         this.peerHost = peerHost;
 146         SocketAddress socketAddress =
 147                peerHost != null ? new InetSocketAddress(peerHost, peerPort) :
 148                new InetSocketAddress(InetAddress.getByName(null), peerPort);
 149         connect(socketAddress, 0);
 150     }
 151 
 152     /**
 153      * Constructs an SSL connection to a server at a specified
 154      * address, and TCP port, using the authentication context
 155      * provided.
 156      *
 157      * This endpoint acts as the client, and may rejoin an existing SSL
 158      * session if appropriate.
 159      */
 160     SSLSocketImpl(SSLContextImpl sslContext,
 161             InetAddress address, int peerPort) throws IOException {
 162         super();
 163         this.sslContext = sslContext;
 164         HandshakeHash handshakeHash = new HandshakeHash();
 165         this.conContext = new TransportContext(sslContext, this,
 166                 new SSLSocketInputRecord(handshakeHash),
 167                 new SSLSocketOutputRecord(handshakeHash), true);
 168 
 169         SocketAddress socketAddress = new InetSocketAddress(address, peerPort);
 170         connect(socketAddress, 0);
 171     }
 172 
 173     /**
 174      * Constructs an SSL connection to a named host at a specified
 175      * port, using the authentication context provided.
 176      *
 177      * This endpoint acts as the client, and may rejoin an existing SSL
 178      * session if appropriate.
 179      */
 180     SSLSocketImpl(SSLContextImpl sslContext,
 181             String peerHost, int peerPort, InetAddress localAddr,
 182             int localPort) throws IOException, UnknownHostException {
 183         super();
 184         this.sslContext = sslContext;
 185         HandshakeHash handshakeHash = new HandshakeHash();
 186         this.conContext = new TransportContext(sslContext, this,
 187                 new SSLSocketInputRecord(handshakeHash),
 188                 new SSLSocketOutputRecord(handshakeHash), true);
 189         this.peerHost = peerHost;
 190 
 191         bind(new InetSocketAddress(localAddr, localPort));
 192         SocketAddress socketAddress =
 193                peerHost != null ? new InetSocketAddress(peerHost, peerPort) :
 194                new InetSocketAddress(InetAddress.getByName(null), peerPort);
 195         connect(socketAddress, 0);
 196     }
 197 
 198     /**
 199      * Constructs an SSL connection to a server at a specified
 200      * address, and TCP port, using the authentication context
 201      * provided.
 202      *
 203      * This endpoint acts as the client, and may rejoin an existing SSL
 204      * session if appropriate.
 205      */
 206     SSLSocketImpl(SSLContextImpl sslContext,
 207             InetAddress peerAddr, int peerPort,
 208             InetAddress localAddr, int localPort) throws IOException {
 209         super();
 210         this.sslContext = sslContext;
 211         HandshakeHash handshakeHash = new HandshakeHash();
 212         this.conContext = new TransportContext(sslContext, this,
 213                 new SSLSocketInputRecord(handshakeHash),
 214                 new SSLSocketOutputRecord(handshakeHash), true);
 215 
 216         bind(new InetSocketAddress(localAddr, localPort));
 217         SocketAddress socketAddress = new InetSocketAddress(peerAddr, peerPort);
 218         connect(socketAddress, 0);
 219     }
 220 
 221     /**
 222      * Creates a server mode {@link Socket} layered over an
 223      * existing connected socket, and is able to read data which has
 224      * already been consumed/removed from the {@link Socket}&#39;s
 225      * underlying {@link InputStream}.
 226      */
 227     SSLSocketImpl(SSLContextImpl sslContext, Socket sock,
 228             InputStream consumed, boolean autoClose) throws IOException {
 229         super(sock, consumed);
 230         // We always layer over a connected socket
 231         if (!sock.isConnected()) {
 232             throw new SocketException(&quot;Underlying socket is not connected&quot;);
 233         }
 234 
 235         this.sslContext = sslContext;
 236         HandshakeHash handshakeHash = new HandshakeHash();
 237         this.conContext = new TransportContext(sslContext, this,
 238                 new SSLSocketInputRecord(handshakeHash),
 239                 new SSLSocketOutputRecord(handshakeHash), false);
 240         this.autoClose = autoClose;
 241         doneConnect();
 242     }
 243 
 244     /**
 245      * Layer SSL traffic over an existing connection, rather than
 246      * creating a new connection.
 247      *
 248      * The existing connection may be used only for SSL traffic (using this
 249      * SSLSocket) until the SSLSocket.close() call returns. However, if a
 250      * protocol error is detected, that existing connection is automatically
 251      * closed.
 252      * &lt;p&gt;
 253      * This particular constructor always uses the socket in the
 254      * role of an SSL client. It may be useful in cases which start
 255      * using SSL after some initial data transfers, for example in some
 256      * SSL tunneling applications or as part of some kinds of application
 257      * protocols which negotiate use of a SSL based security.
 258      */
 259     SSLSocketImpl(SSLContextImpl sslContext, Socket sock,
 260             String peerHost, int port, boolean autoClose) throws IOException {
 261         super(sock);
 262         // We always layer over a connected socket
 263         if (!sock.isConnected()) {
 264             throw new SocketException(&quot;Underlying socket is not connected&quot;);
 265         }
 266 
 267         this.sslContext = sslContext;
 268         HandshakeHash handshakeHash = new HandshakeHash();
 269         this.conContext = new TransportContext(sslContext, this,
 270                 new SSLSocketInputRecord(handshakeHash),
 271                 new SSLSocketOutputRecord(handshakeHash), true);
 272         this.peerHost = peerHost;
 273         this.autoClose = autoClose;
 274         doneConnect();
 275     }
 276 
 277     @Override
 278     public void connect(SocketAddress endpoint,
 279             int timeout) throws IOException {
 280 
 281         if (isLayered()) {
 282             throw new SocketException(&quot;Already connected&quot;);
 283         }
 284 
 285         if (!(endpoint instanceof InetSocketAddress)) {
 286             throw new SocketException(
 287                     &quot;Cannot handle non-Inet socket addresses.&quot;);
 288         }
 289 
 290         super.connect(endpoint, timeout);
 291         doneConnect();
 292     }
 293 
 294     @Override
 295     public String[] getSupportedCipherSuites() {
 296         return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
 297     }
 298 
 299     @Override
 300     public String[] getEnabledCipherSuites() {
 301         socketLock.lock();
 302         try {
 303             return CipherSuite.namesOf(
 304                     conContext.sslConfig.enabledCipherSuites);
 305         } finally {
 306             socketLock.unlock();
 307         }
 308     }
 309 
 310     @Override
 311     public void setEnabledCipherSuites(String[] suites) {
 312         socketLock.lock();
 313         try {
 314             conContext.sslConfig.enabledCipherSuites =
 315                     CipherSuite.validValuesOf(suites);
 316         } finally {
 317             socketLock.unlock();
 318         }
 319     }
 320 
 321     @Override
 322     public String[] getSupportedProtocols() {
 323         return ProtocolVersion.toStringArray(
 324                 sslContext.getSupportedProtocolVersions());
 325     }
 326 
 327     @Override
 328     public String[] getEnabledProtocols() {
 329         socketLock.lock();
 330         try {
 331             return ProtocolVersion.toStringArray(
 332                     conContext.sslConfig.enabledProtocols);
 333         } finally {
 334             socketLock.unlock();
 335         }
 336     }
 337 
 338     @Override
 339     public void setEnabledProtocols(String[] protocols) {
 340         if (protocols == null) {
 341             throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);
 342         }
 343 
 344         socketLock.lock();
 345         try {
 346             conContext.sslConfig.enabledProtocols =
 347                     ProtocolVersion.namesOf(protocols);
 348         } finally {
 349             socketLock.unlock();
 350         }
 351     }
 352 
 353     @Override
 354     public SSLSession getSession() {
 355         try {
 356             // start handshaking, if failed, the connection will be closed.
 357             ensureNegotiated();
 358         } catch (IOException ioe) {
 359             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
 360                 SSLLogger.severe(&quot;handshake failed&quot;, ioe);
 361             }
 362 
 363             return SSLSessionImpl.nullSession;
 364         }
 365 
 366         return conContext.conSession;
 367     }
 368 
 369     @Override
 370     public SSLSession getHandshakeSession() {
 371         socketLock.lock();
 372         try {
 373             return conContext.handshakeContext == null ?
 374                     null : conContext.handshakeContext.handshakeSession;
 375         } finally {
 376             socketLock.unlock();
 377         }
 378     }
 379 
 380     @Override
 381     public void addHandshakeCompletedListener(
 382             HandshakeCompletedListener listener) {
 383         if (listener == null) {
 384             throw new IllegalArgumentException(&quot;listener is null&quot;);
 385         }
 386 
 387         socketLock.lock();
 388         try {
 389             conContext.sslConfig.addHandshakeCompletedListener(listener);
 390         } finally {
 391             socketLock.unlock();
 392         }
 393     }
 394 
 395     @Override
 396     public void removeHandshakeCompletedListener(
 397             HandshakeCompletedListener listener) {
 398         if (listener == null) {
 399             throw new IllegalArgumentException(&quot;listener is null&quot;);
 400         }
 401 
 402         socketLock.lock();
 403         try {
 404             conContext.sslConfig.removeHandshakeCompletedListener(listener);
 405         } finally {
 406             socketLock.unlock();
 407         }
 408     }
 409 
 410     @Override
 411     public void startHandshake() throws IOException {
 412         if (!isConnected) {
 413             throw new SocketException(&quot;Socket is not connected&quot;);
 414         }
 415 
 416         if (conContext.isBroken || conContext.isInboundClosed() ||
 417                 conContext.isOutboundClosed()) {
 418             throw new SocketException(&quot;Socket has been closed or broken&quot;);
 419         }
 420 
 421         handshakeLock.lock();
 422         try {
 423             // double check the context status
 424             if (conContext.isBroken || conContext.isInboundClosed() ||
 425                     conContext.isOutboundClosed()) {
 426                 throw new SocketException(&quot;Socket has been closed or broken&quot;);
 427             }
 428 
 429             try {
 430                 conContext.kickstart();
 431 
 432                 // All initial handshaking goes through this operation until we
 433                 // have a valid SSL connection.
 434                 //
 435                 // Handle handshake messages only, need no application data.
 436                 if (!conContext.isNegotiated) {
 437                     readHandshakeRecord();
 438                 }
 439             } catch (IOException ioe) {
 440                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
 441                     &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);
 442             } catch (Exception oe) {    // including RuntimeException
 443                 handleException(oe);
 444             }
 445         } finally {
 446             handshakeLock.unlock();
 447         }
 448     }
 449 
 450     @Override
 451     public void setUseClientMode(boolean mode) {
 452         socketLock.lock();
 453         try {
 454             conContext.setUseClientMode(mode);
 455         } finally {
 456             socketLock.unlock();
 457         }
 458     }
 459 
 460     @Override
 461     public boolean getUseClientMode() {
 462         socketLock.lock();
 463         try {
 464             return conContext.sslConfig.isClientMode;
 465         } finally {
 466             socketLock.unlock();
 467         }
 468     }
 469 
 470     @Override
 471     public void setNeedClientAuth(boolean need) {
 472         socketLock.lock();
 473         try {
 474             conContext.sslConfig.clientAuthType =
 475                     (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :
 476                             ClientAuthType.CLIENT_AUTH_NONE);
 477         } finally {
 478             socketLock.unlock();
 479         }
 480     }
 481 
 482     @Override
 483     public boolean getNeedClientAuth() {
 484         socketLock.lock();
 485         try {
 486             return (conContext.sslConfig.clientAuthType ==
 487                         ClientAuthType.CLIENT_AUTH_REQUIRED);
 488         } finally {
 489             socketLock.unlock();
 490         }
 491     }
 492 
 493     @Override
 494     public void setWantClientAuth(boolean want) {
 495         socketLock.lock();
 496         try {
 497             conContext.sslConfig.clientAuthType =
 498                     (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :
 499                             ClientAuthType.CLIENT_AUTH_NONE);
 500         } finally {
 501             socketLock.unlock();
 502         }
 503     }
 504 
 505     @Override
 506     public boolean getWantClientAuth() {
 507         socketLock.lock();
 508         try {
 509             return (conContext.sslConfig.clientAuthType ==
 510                         ClientAuthType.CLIENT_AUTH_REQUESTED);
 511         } finally {
 512             socketLock.unlock();
 513         }
 514     }
 515 
 516     @Override
 517     public void setEnableSessionCreation(boolean flag) {
 518         socketLock.lock();
 519         try {
 520             conContext.sslConfig.enableSessionCreation = flag;
 521         } finally {
 522             socketLock.unlock();
 523         }
 524     }
 525 
 526     @Override
 527     public boolean getEnableSessionCreation() {
 528         socketLock.lock();
 529         try {
 530             return conContext.sslConfig.enableSessionCreation;
 531         } finally {
 532             socketLock.unlock();
 533         }
 534     }
 535 
 536     @Override
 537     public boolean isClosed() {
 538         return tlsIsClosed;
 539     }
 540 
 541     // Please don&#39;t synchronized this method.  Otherwise, the read and close
 542     // locks may be deadlocked.
 543     @Override
 544     public void close() throws IOException {
 545         if (tlsIsClosed) {
 546             return;
 547         }
 548 
 549         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 550             SSLLogger.fine(&quot;duplex close of SSLSocket&quot;);
 551         }
 552 
 553         try {
 554             // shutdown output bound, which may have been closed previously.
 555             if (!isOutputShutdown()) {
 556                 duplexCloseOutput();
 557             }
 558 
 559             // shutdown input bound, which may have been closed previously.
 560             if (!isInputShutdown()) {
 561                 duplexCloseInput();
 562             }
 563 
 564             if (!isClosed()) {
 565                 // close the connection directly
 566                 closeSocket(false);
 567             }
 568         } catch (IOException ioe) {
 569             // ignore the exception
 570             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 571                 SSLLogger.warning(&quot;SSLSocket duplex close failed&quot;, ioe);
 572             }
 573         } finally {
 574             tlsIsClosed = true;
 575         }
 576     }
 577 
 578     /**
 579      * Duplex close, start from closing outbound.
 580      *
 581      * For TLS 1.2 [RFC 5246], unless some other fatal alert has been
 582      * transmitted, each party is required to send a close_notify alert
 583      * before closing the write side of the connection.  The other party
 584      * MUST respond with a close_notify alert of its own and close down
 585      * the connection immediately, discarding any pending writes.  It is
 586      * not required for the initiator of the close to wait for the responding
 587      * close_notify alert before closing the read side of the connection.
 588      *
 589      * For TLS 1.3, Each party MUST send a close_notify alert before
 590      * closing its write side of the connection, unless it has already sent
 591      * some error alert.  This does not have any effect on its read side of
 592      * the connection.  Both parties need not wait to receive a close_notify
 593      * alert before closing their read side of the connection, though doing
 594      * so would introduce the possibility of truncation.
 595      *
 596      * In order to support user initiated duplex-close for TLS 1.3 connections,
 597      * the user_canceled alert is used together with the close_notify alert.
 598      */
 599     private void duplexCloseOutput() throws IOException {
 600         boolean useUserCanceled = false;
 601         boolean hasCloseReceipt = false;
 602         if (conContext.isNegotiated) {
 603             if (!conContext.protocolVersion.useTLS13PlusSpec()) {
 604                 hasCloseReceipt = true;
 605             } else {
 606                 // Use a user_canceled alert for TLS 1.3 duplex close.
 607                 useUserCanceled = true;
 608             }
 609         } else if (conContext.handshakeContext != null) {   // initial handshake
 610             // Use user_canceled alert regardless the protocol versions.
 611             useUserCanceled = true;
 612 
 613             // The protocol version may have been negotiated.
 614             ProtocolVersion pv = conContext.handshakeContext.negotiatedProtocol;
 615             if (pv == null || (!pv.useTLS13PlusSpec())) {
 616                 hasCloseReceipt = true;
 617             }
 618         }
 619 
 620         // Need a lock here so that the user_canceled alert and the
 621         // close_notify alert can be delivered together.
 622         int linger = getSoLinger();
 623         if (linger &gt;= 0) {
 624             // don&#39;t wait more than SO_LINGER for obtaining the
 625             // the lock.
 626             //
 627             // keep and clear the current thread interruption status.
 628             boolean interrupted = Thread.interrupted();
 629             try {
 630                 if (conContext.outputRecord.recordLock.tryLock() ||
 631                         conContext.outputRecord.recordLock.tryLock(
 632                                 linger, TimeUnit.SECONDS)) {
 633                     try {
 634                         handleClosedNotifyAlert(useUserCanceled);
 635                     } finally {
 636                         conContext.outputRecord.recordLock.unlock();
 637                     }
 638                 } else {
 639                     // For layered, non-autoclose sockets, we are not
 640                     // able to bring them into a usable state, so we
 641                     // treat it as fatal error.
 642                     if (!super.isOutputShutdown()) {
 643                         if (isLayered() &amp;&amp; !autoClose) {
 644                             throw new SSLException(
 645                                     &quot;SO_LINGER timeout, &quot; +
 646                                     &quot;close_notify message cannot be sent.&quot;);
 647                         } else {
 648                             super.shutdownOutput();
 649                             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 650                                 SSLLogger.warning(
 651                                     &quot;SSLSocket output duplex close failed: &quot; +
 652                                     &quot;SO_LINGER timeout, &quot; +
 653                                     &quot;close_notify message cannot be sent.&quot;);
 654                             }
 655                         }
 656                     }
 657 
 658                     // RFC2246 requires that the session becomes
 659                     // unresumable if any connection is terminated
 660                     // without proper close_notify messages with
 661                     // level equal to warning.
 662                     //
 663                     // RFC4346 no longer requires that a session not be
 664                     // resumed if failure to properly close a connection.
 665                     //
 666                     // We choose to make the session unresumable if
 667                     // failed to send the close_notify message.
 668                     //
 669                     conContext.conSession.invalidate();
 670                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 671                         SSLLogger.warning(
 672                                 &quot;Invalidate the session: SO_LINGER timeout, &quot; +
 673                                 &quot;close_notify message cannot be sent.&quot;);
 674                     }
 675                 }
 676             } catch (InterruptedException ex) {
 677                 // keep interrupted status
 678                 interrupted = true;
 679             }
 680 
 681             // restore the interrupted status
 682             if (interrupted) {
 683                 Thread.currentThread().interrupt();
 684             }
 685         } else {
 686             conContext.outputRecord.recordLock.lock();
 687             try {
 688                 handleClosedNotifyAlert(useUserCanceled);
 689             } finally {
 690                 conContext.outputRecord.recordLock.unlock();
 691             }
 692         }
 693 
 694         if (!isInputShutdown()) {
 695             bruteForceCloseInput(hasCloseReceipt);
 696         }
 697     }
 698 
 699     private void handleClosedNotifyAlert(
 700             boolean useUserCanceled) throws IOException {
 701         try {
 702             // send a user_canceled alert if needed.
 703             if (useUserCanceled) {
 704                 conContext.warning(Alert.USER_CANCELED);
 705             }
 706 
 707             // send a close_notify alert
 708             conContext.warning(Alert.CLOSE_NOTIFY);
 709         } finally {
 710             if (!conContext.isOutboundClosed()) {
 711                 conContext.outputRecord.close();
 712             }
 713 
 714             if (!super.isOutputShutdown() &amp;&amp;
 715                     (autoClose || !isLayered())) {
 716                 super.shutdownOutput();
 717             }
 718         }
 719     }
 720 
 721     /**
 722      * Duplex close, start from closing inbound.
 723      *
 724      * This method should only be called when the outbound has been closed,
 725      * but the inbound is still open.
 726      */
 727     private void duplexCloseInput() throws IOException {
 728         boolean hasCloseReceipt = false;
 729         if (conContext.isNegotiated &amp;&amp;
 730                 !conContext.protocolVersion.useTLS13PlusSpec()) {
 731             hasCloseReceipt = true;
 732         }   // No close receipt if handshake has no completed.
 733 
 734         bruteForceCloseInput(hasCloseReceipt);
 735     }
 736 
 737     /**
 738      * Brute force close the input bound.
 739      *
 740      * This method should only be called when the outbound has been closed,
 741      * but the inbound is still open.
 742      */
 743     private void bruteForceCloseInput(
 744             boolean hasCloseReceipt) throws IOException {
 745         if (hasCloseReceipt) {
 746             // It is not required for the initiator of the close to wait for
 747             // the responding close_notify alert before closing the read side
 748             // of the connection.  However, if the application protocol using
 749             // TLS provides that any data may be carried over the underlying
 750             // transport after the TLS connection is closed, the TLS
 751             // implementation MUST receive a &quot;close_notify&quot; alert before
 752             // indicating end-of-data to the application-layer.
 753             try {
 754                 this.shutdown();
 755             } finally {
 756                 if (!isInputShutdown()) {
 757                     shutdownInput(false);
 758                 }
 759             }
 760         } else {
 761             if (!conContext.isInboundClosed()) {
 762                 try (conContext.inputRecord) {
 763                     // Try the best to use up the input records and close the
 764                     // socket gracefully, without impact the performance too
 765                     // much.
 766                     appInput.deplete();
 767                 }
 768             }
 769 
 770             if ((autoClose || !isLayered()) &amp;&amp; !super.isInputShutdown()) {
 771                 super.shutdownInput();
 772             }
 773         }
 774     }
 775 
 776     // Please don&#39;t synchronized this method.  Otherwise, the read and close
 777     // locks may be deadlocked.
 778     @Override
 779     public void shutdownInput() throws IOException {
 780         shutdownInput(true);
 781     }
 782 
 783     // It is not required to check the close_notify receipt unless an
 784     // application call shutdownInput() explicitly.
 785     private void shutdownInput(
 786             boolean checkCloseNotify) throws IOException {
 787         if (isInputShutdown()) {
 788             return;
 789         }
 790 
 791         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 792             SSLLogger.fine(&quot;close inbound of SSLSocket&quot;);
 793         }
 794 
 795         // Is it ready to close inbound?
 796         //
 797         // No need to throw exception if the initial handshake is not started.
 798         if (checkCloseNotify &amp;&amp; !conContext.isInputCloseNotified &amp;&amp;
 799             (conContext.isNegotiated || conContext.handshakeContext != null)) {
 800 
 801             throw conContext.fatal(Alert.INTERNAL_ERROR,
 802                     &quot;closing inbound before receiving peer&#39;s close_notify&quot;);
 803         }
 804 
 805         conContext.closeInbound();
 806         if ((autoClose || !isLayered()) &amp;&amp; !super.isInputShutdown()) {
 807             super.shutdownInput();
 808         }
 809     }
 810 
 811     @Override
 812     public boolean isInputShutdown() {
 813         return conContext.isInboundClosed() &amp;&amp;
 814                 ((autoClose || !isLayered()) ? super.isInputShutdown(): true);
 815     }
 816 
 817     // Please don&#39;t synchronized this method.  Otherwise, the read and close
 818     // locks may be deadlocked.
 819     @Override
 820     public void shutdownOutput() throws IOException {
 821         if (isOutputShutdown()) {
 822             return;
 823         }
 824 
 825         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 826             SSLLogger.fine(&quot;close outbound of SSLSocket&quot;);
 827         }
 828         conContext.closeOutbound();
 829 
 830         if ((autoClose || !isLayered()) &amp;&amp; !super.isOutputShutdown()) {
 831             super.shutdownOutput();
 832         }
 833     }
 834 
 835     @Override
 836     public boolean isOutputShutdown() {
 837         return conContext.isOutboundClosed() &amp;&amp;
 838                 ((autoClose || !isLayered()) ? super.isOutputShutdown(): true);
 839     }
 840 
 841     @Override
 842     public InputStream getInputStream() throws IOException {
 843         socketLock.lock();
 844         try {
 845             if (isClosed()) {
 846                 throw new SocketException(&quot;Socket is closed&quot;);
 847             }
 848 
 849             if (!isConnected) {
 850                 throw new SocketException(&quot;Socket is not connected&quot;);
 851             }
 852 
 853             if (conContext.isInboundClosed() || isInputShutdown()) {
 854                 throw new SocketException(&quot;Socket input is already shutdown&quot;);
 855             }
 856 
 857             return appInput;
 858         } finally {
 859             socketLock.unlock();
 860         }
 861     }
 862 
 863     private void ensureNegotiated() throws IOException {
 864         if (conContext.isNegotiated || conContext.isBroken ||
 865                 conContext.isInboundClosed() || conContext.isOutboundClosed()) {
 866             return;
 867         }
 868 
 869         handshakeLock.lock();
 870         try {
 871             // double check the context status
 872             if (conContext.isNegotiated || conContext.isBroken ||
 873                     conContext.isInboundClosed() ||
 874                     conContext.isOutboundClosed()) {
 875                 return;
 876             }
 877 
 878             startHandshake();
 879         } finally {
 880             handshakeLock.unlock();
 881         }
 882     }
 883 
 884     /**
 885      * InputStream for application data as returned by
 886      * SSLSocket.getInputStream().
 887      */
 888     private class AppInputStream extends InputStream {
 889         // One element array used to implement the single byte read() method
 890         private final byte[] oneByte = new byte[1];
 891 
 892         // the temporary buffer used to read network
 893         private ByteBuffer buffer;
 894 
 895         // Is application data available in the stream?
 896         private volatile boolean appDataIsAvailable;
 897 
 898         // reading lock
 899         private final ReentrantLock readLock = new ReentrantLock();
 900 
 901         // closing status
 902         private volatile boolean isClosing;
 903         private volatile boolean hasDepleted;
 904 
 905         AppInputStream() {
 906             this.appDataIsAvailable = false;
 907             this.buffer = ByteBuffer.allocate(4096);
 908         }
 909 
 910         /**
 911          * Return the minimum number of bytes that can be read
 912          * without blocking.
 913          */
 914         @Override
 915         public int available() throws IOException {
 916             // Currently not synchronized.
 917             if ((!appDataIsAvailable) || checkEOF()) {
 918                 return 0;
 919             }
 920 
 921             return buffer.remaining();
 922         }
 923 
 924         /**
 925          * Read a single byte, returning -1 on non-fault EOF status.
 926          */
 927         @Override
 928         public int read() throws IOException {
 929             int n = read(oneByte, 0, 1);
 930             if (n &lt;= 0) {   // EOF
 931                 return -1;
 932             }
 933 
 934             return oneByte[0] &amp; 0xFF;
 935         }
 936 
 937         /**
 938          * Reads up to {@code len} bytes of data from the input stream
 939          * into an array of bytes.
 940          *
 941          * An attempt is made to read as many as {@code len} bytes, but a
 942          * smaller number may be read. The number of bytes actually read
 943          * is returned as an integer.
 944          *
 945          * If the layer above needs more data, it asks for more, so we
 946          * are responsible only for blocking to fill at most one buffer,
 947          * and returning &quot;-1&quot; on non-fault EOF status.
 948          */
 949         @Override
 950         public int read(byte[] b, int off, int len) throws IOException {
 951             if (b == null) {
 952                 throw new NullPointerException(&quot;the target buffer is null&quot;);
 953             } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
 954                 throw new IndexOutOfBoundsException(
 955                         &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
 956                         &quot;, bytes to read:&quot; + len);
 957             } else if (len == 0) {
 958                 return 0;
 959             }
 960 
 961             if (checkEOF()) {
 962                 return -1;
 963             }
 964 
 965             // start handshaking if the connection has not been negotiated.
 966             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 967                     !conContext.isInboundClosed() &amp;&amp;
 968                     !conContext.isOutboundClosed()) {
 969                 ensureNegotiated();
 970             }
 971 
 972             // Check if the Socket is invalid (error or closed).
 973             if (!conContext.isNegotiated ||
 974                     conContext.isBroken || conContext.isInboundClosed()) {
 975                 throw new SocketException(&quot;Connection or inbound has closed&quot;);
 976             }
 977 
 978             // Check if the input stream has been depleted.
 979             //
 980             // Note that the &quot;hasDepleted&quot; rather than the isClosing
 981             // filed is checked here, in case the closing process is
 982             // still in progress.
 983             if (hasDepleted) {
 984                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 985                     SSLLogger.fine(&quot;The input stream has been depleted&quot;);
 986                 }
 987 
 988                 return -1;
 989             }
 990 
 991             // Read the available bytes at first.
 992             //
 993             // Note that the receiving and processing of post-handshake message
 994             // are also synchronized with the read lock.
 995             readLock.lock();
 996             try {
 997                 // Double check if the Socket is invalid (error or closed).
 998                 if (conContext.isBroken || conContext.isInboundClosed()) {
 999                     throw new SocketException(
1000                             &quot;Connection or inbound has closed&quot;);
1001                 }
1002 
1003                 // Double check if the input stream has been depleted.
1004                 if (hasDepleted) {
1005                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1006                         SSLLogger.fine(&quot;The input stream is closing&quot;);
1007                     }
1008 
1009                     return -1;
1010                 }
1011 
1012                 int remains = available();
1013                 if (remains &gt; 0) {
1014                     int howmany = Math.min(remains, len);
1015                     buffer.get(b, off, howmany);
1016 
1017                     return howmany;
1018                 }
1019 
1020                 appDataIsAvailable = false;
1021                 try {
1022                     ByteBuffer bb = readApplicationRecord(buffer);
1023                     if (bb == null) {   // EOF
1024                         return -1;
1025                     } else {
1026                         // The buffer may be reallocated for bigger capacity.
1027                         buffer = bb;
1028                     }
1029 
1030                     bb.flip();
1031                     int volume = Math.min(len, bb.remaining());
1032                     buffer.get(b, off, volume);
1033                     appDataIsAvailable = true;
1034 
1035                     return volume;
1036                 } catch (Exception e) {   // including RuntimeException
1037                     // shutdown and rethrow (wrapped) exception as appropriate
1038                     handleException(e);
1039 
1040                     // dummy for compiler
1041                     return -1;
1042                 }
1043             } finally {
1044                 // Check if the input stream is closing.
1045                 //
1046                 // If the deplete() did not hold the lock, clean up the
1047                 // input stream here.
1048                 try {
1049                     if (isClosing) {
1050                         readLockedDeplete();
1051                     }
1052                 } finally {
1053                     readLock.unlock();
1054                 }
1055             }
1056         }
1057 
1058         /**
1059          * Skip n bytes.
1060          *
1061          * This implementation is somewhat less efficient than possible, but
1062          * not badly so (redundant copy).  We reuse the read() code to keep
1063          * things simpler.
1064          */
1065         @Override
1066         public long skip(long n) throws IOException {
1067             // dummy array used to implement skip()
1068             byte[] skipArray = new byte[256];
1069             long skipped = 0;
1070 
1071             readLock.lock();
1072             try {
1073                 while (n &gt; 0) {
1074                     int len = (int)Math.min(n, skipArray.length);
1075                     int r = read(skipArray, 0, len);
1076                     if (r &lt;= 0) {
1077                         break;
1078                     }
1079                     n -= r;
1080                     skipped += r;
1081                 }
1082             } finally {
1083                 readLock.unlock();
1084             }
1085 
1086             return skipped;
1087         }
1088 
1089         @Override
1090         public void close() throws IOException {
1091             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1092                 SSLLogger.finest(&quot;Closing input stream&quot;);
1093             }
1094 
1095             try {
1096                 SSLSocketImpl.this.close();
1097             } catch (IOException ioe) {
1098                 // ignore the exception
1099                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1100                     SSLLogger.warning(&quot;input stream close failed&quot;, ioe);
1101                 }
1102             }
1103         }
1104 
1105         /**
1106          * Return whether we have reached end-of-file.
1107          *
1108          * If the socket is not connected, has been shutdown because of an error
1109          * or has been closed, throw an Exception.
1110          */
1111         private boolean checkEOF() throws IOException {
1112             if (conContext.isInboundClosed()) {
1113                 return true;
1114             } else if (conContext.isInputCloseNotified || conContext.isBroken) {
1115                 if (conContext.closeReason == null) {
1116                     return true;
1117                 } else {
1118                     throw new SSLException(
1119                         &quot;Connection has closed: &quot; + conContext.closeReason,
1120                         conContext.closeReason);
1121                 }
1122             }
1123 
1124             return false;
1125         }
1126 
1127         /**
1128          * Try the best to use up the input records so as to close the
1129          * socket gracefully, without impact the performance too much.
1130          */
1131         private void deplete() {
1132             if (conContext.isInboundClosed() || isClosing) {
1133                 return;
1134             }
1135 
1136             isClosing = true;
1137             if (readLock.tryLock()) {
1138                 try {
1139                     readLockedDeplete();
1140                 } finally {
1141                     readLock.unlock();
1142                 }
1143             }
1144         }
1145 
1146         /**
1147          * Try to use up the input records.
1148          *
1149          * Please don&#39;t call this method unless the readLock is held by
1150          * the current thread.
1151          */
1152         private void readLockedDeplete() {
1153             // double check
1154             if (hasDepleted || conContext.isInboundClosed()) {
1155                 return;
1156             }
1157 
1158             if (!(conContext.inputRecord instanceof SSLSocketInputRecord)) {
1159                 return;
1160             }
1161 
1162             SSLSocketInputRecord socketInputRecord =
1163                     (SSLSocketInputRecord)conContext.inputRecord;
1164             try {
1165                 socketInputRecord.deplete(
1166                     conContext.isNegotiated &amp;&amp; (getSoTimeout() &gt; 0));
1167             } catch (Exception ex) {
1168                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1169                     SSLLogger.warning(
1170                         &quot;input stream close depletion failed&quot;, ex);
1171                 }
1172             } finally {
1173                 hasDepleted = true;
1174             }
1175         }
1176     }
1177 
1178     @Override
1179     public OutputStream getOutputStream() throws IOException {
1180         socketLock.lock();
1181         try {
1182             if (isClosed()) {
1183                 throw new SocketException(&quot;Socket is closed&quot;);
1184             }
1185 
1186             if (!isConnected) {
1187                 throw new SocketException(&quot;Socket is not connected&quot;);
1188             }
1189 
1190             if (conContext.isOutboundDone() || isOutputShutdown()) {
1191                 throw new SocketException(&quot;Socket output is already shutdown&quot;);
1192             }
1193 
1194             return appOutput;
1195         } finally {
1196             socketLock.unlock();
1197         }
1198     }
1199 
1200 
1201     /**
1202      * OutputStream for application data as returned by
1203      * SSLSocket.getOutputStream().
1204      */
1205     private class AppOutputStream extends OutputStream {
1206         // One element array used to implement the write(byte) method
1207         private final byte[] oneByte = new byte[1];
1208 
1209         @Override
1210         public void write(int i) throws IOException {
1211             oneByte[0] = (byte)i;
1212             write(oneByte, 0, 1);
1213         }
1214 
1215         @Override
1216         public void write(byte[] b,
1217                 int off, int len) throws IOException {
1218             if (b == null) {
1219                 throw new NullPointerException(&quot;the source buffer is null&quot;);
1220             } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
1221                 throw new IndexOutOfBoundsException(
1222                         &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
1223                         &quot;, bytes to read:&quot; + len);
1224             } else if (len == 0) {
1225                 //
1226                 // Don&#39;t bother to really write empty records.  We went this
1227                 // far to drive the handshake machinery, for correctness; not
1228                 // writing empty records improves performance by cutting CPU
1229                 // time and network resource usage.  However, some protocol
1230                 // implementations are fragile and don&#39;t like to see empty
1231                 // records, so this also increases robustness.
1232                 //
1233                 return;
1234             }
1235 
1236             // Start handshaking if the connection has not been negotiated.
1237             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
1238                     !conContext.isInboundClosed() &amp;&amp;
1239                     !conContext.isOutboundClosed()) {
1240                 ensureNegotiated();
1241             }
1242 
1243             // Check if the Socket is invalid (error or closed).
1244             if (!conContext.isNegotiated ||
1245                     conContext.isBroken || conContext.isOutboundClosed()) {
1246                 throw new SocketException(&quot;Connection or outbound has closed&quot;);
1247             }
1248 
1249             //
1250 
1251             // Delegate the writing to the underlying socket.
1252             try {
1253                 conContext.outputRecord.deliver(b, off, len);
1254             } catch (SSLHandshakeException she) {
1255                 // may be record sequence number overflow
1256                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE, she);
1257             } catch (SSLException ssle) {
1258                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, ssle);
1259             }   // re-throw other IOException, which should be caused by
1260                 // the underlying plain socket and could be handled by
1261                 // applications (for example, re-try the connection).
1262 
1263             // Is the sequence number is nearly overflow, or has the key usage
1264             // limit been reached?
1265             if (conContext.outputRecord.seqNumIsHuge() ||
1266                     conContext.outputRecord.writeCipher.atKeyLimit()) {
1267                 tryKeyUpdate();
1268             }
1269             // Check if NewSessionTicket PostHandshake message needs to be sent
1270             if (conContext.conSession.updateNST) {
1271                 conContext.conSession.updateNST = false;
1272                 tryNewSessionTicket();
1273             }
1274         }
1275 
1276         @Override
1277         public void close() throws IOException {
1278             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1279                 SSLLogger.finest(&quot;Closing output stream&quot;);
1280             }
1281 
1282             try {
1283                 SSLSocketImpl.this.close();
1284             } catch (IOException ioe) {
1285                 // ignore the exception
1286                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1287                     SSLLogger.warning(&quot;output stream close failed&quot;, ioe);
1288                 }
1289             }
1290         }
1291     }
1292 
1293     @Override
1294     public SSLParameters getSSLParameters() {
1295         socketLock.lock();
1296         try {
1297             return conContext.sslConfig.getSSLParameters();
1298         } finally {
1299             socketLock.unlock();
1300         }
1301     }
1302 
1303     @Override
1304     public void setSSLParameters(SSLParameters params) {
1305         socketLock.lock();
1306         try {
1307             conContext.sslConfig.setSSLParameters(params);
1308 
1309             if (conContext.sslConfig.maximumPacketSize != 0) {
1310                 conContext.outputRecord.changePacketSize(
1311                         conContext.sslConfig.maximumPacketSize);
1312             }
1313         } finally {
1314             socketLock.unlock();
1315         }
1316     }
1317 
1318     @Override
1319     public String getApplicationProtocol() {
1320         socketLock.lock();
1321         try {
1322             return conContext.applicationProtocol;
1323         } finally {
1324             socketLock.unlock();
1325         }
1326     }
1327 
1328     @Override
1329     public String getHandshakeApplicationProtocol() {
1330         socketLock.lock();
1331         try {
1332             if (conContext.handshakeContext != null) {
1333                 return conContext.handshakeContext.applicationProtocol;
1334             }
1335         } finally {
1336             socketLock.unlock();
1337         }
1338 
1339         return null;
1340     }
1341 
1342     @Override
1343     public void setHandshakeApplicationProtocolSelector(
1344             BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt; selector) {
1345         socketLock.lock();
1346         try {
1347             conContext.sslConfig.socketAPSelector = selector;
1348         } finally {
1349             socketLock.unlock();
1350         }
1351     }
1352 
1353     @Override
1354     public BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt;
1355             getHandshakeApplicationProtocolSelector() {
1356         socketLock.lock();
1357         try {
1358             return conContext.sslConfig.socketAPSelector;
1359         } finally {
1360             socketLock.unlock();
1361         }
1362     }
1363 
1364     /**
1365      * Read the initial handshake records.
1366      */
1367     private int readHandshakeRecord() throws IOException {
1368         while (!conContext.isInboundClosed()) {
1369             try {
1370                 Plaintext plainText = decode(null);
1371                 if ((plainText.contentType == ContentType.HANDSHAKE.id) &amp;&amp;
1372                         conContext.isNegotiated) {
1373                     return 0;
1374                 }
1375             } catch (SSLException ssle) {
1376                 throw ssle;
1377             } catch (IOException ioe) {
1378                 if (!(ioe instanceof SSLException)) {
1379                     throw new SSLException(&quot;readHandshakeRecord&quot;, ioe);
1380                 } else {
1381                     throw ioe;
1382                 }
1383             }
1384         }
1385 
1386         return -1;
1387     }
1388 
1389     /**
1390      * Read application data record. Used by AppInputStream only, but defined
1391      * here so as to use the socket level synchronization.
1392      *
1393      * Note that the connection guarantees that handshake, alert, and change
1394      * cipher spec data streams are handled as they arrive, so we never see
1395      * them here.
1396      *
1397      * Note: Please be careful about the synchronization, and don&#39;t use this
1398      * method other than in the AppInputStream class!
1399      */
1400     private ByteBuffer readApplicationRecord(
1401             ByteBuffer buffer) throws IOException {
1402         while (!conContext.isInboundClosed()) {
1403             /*
1404              * clean the buffer and check if it is too small, e.g. because
1405              * the AppInputStream did not have the chance to see the
1406              * current packet length but rather something like that of the
1407              * handshake before. In that case we return 0 at this point to
1408              * give the caller the chance to adjust the buffer.
1409              */
1410             buffer.clear();
1411             int inLen = conContext.inputRecord.bytesInCompletePacket();
1412             if (inLen &lt; 0) {    // EOF
1413                 handleEOF(null);
1414 
1415                 // if no exception thrown
1416                 return null;
1417             }
1418 
1419             // Is this packet bigger than SSL/TLS normally allows?
1420             if (inLen &gt; SSLRecord.maxLargeRecordSize) {
1421                 throw new SSLProtocolException(
1422                         &quot;Illegal packet size: &quot; + inLen);
1423             }
1424 
1425             if (inLen &gt; buffer.remaining()) {
1426                 buffer = ByteBuffer.allocate(inLen);
1427             }
1428 
1429             try {
1430                 Plaintext plainText;
1431                 socketLock.lock();
1432                 try {
1433                     plainText = decode(buffer);
1434                 } finally {
1435                     socketLock.unlock();
1436                 }
1437                 if (plainText.contentType == ContentType.APPLICATION_DATA.id &amp;&amp;
1438                         buffer.position() &gt; 0) {
1439                     return buffer;
1440                 }
1441             } catch (SSLException ssle) {
1442                 throw ssle;
1443             } catch (IOException ioe) {
1444                 if (!(ioe instanceof SSLException)) {
1445                     throw new SSLException(&quot;readApplicationRecord&quot;, ioe);
1446                 } else {
1447                     throw ioe;
1448                 }
1449             }
1450         }
1451 
1452         //
1453         // couldn&#39;t read, due to some kind of error
1454         //
1455         return null;
1456     }
1457 
1458     private Plaintext decode(ByteBuffer destination) throws IOException {
1459         Plaintext plainText;
1460         try {
1461             if (destination == null) {
1462                 plainText = SSLTransport.decode(conContext,
1463                         null, 0, 0, null, 0, 0);
1464             } else {
1465                 plainText = SSLTransport.decode(conContext,
1466                         null, 0, 0, new ByteBuffer[]{destination}, 0, 1);
1467             }
1468         } catch (EOFException eofe) {
1469             // EOFException is special as it is related to close_notify.
1470             plainText = handleEOF(eofe);
1471         }
1472 
1473         // Is the sequence number is nearly overflow?
1474         if (plainText != Plaintext.PLAINTEXT_NULL &amp;&amp;
1475                 (conContext.inputRecord.seqNumIsHuge() ||
1476                 conContext.inputRecord.readCipher.atKeyLimit())) {
1477             tryKeyUpdate();
1478         }
1479 
1480         return plainText;
1481     }
1482 
1483     /**
1484      * Try key update for sequence number wrap or key usage limit.
1485      *
1486      * Note that in order to maintain the handshake status properly, we check
1487      * the sequence number and key usage limit after the last record
1488      * reading/writing process.
1489      *
1490      * As we request renegotiation or close the connection for wrapped sequence
1491      * number when there is enough sequence number space left to handle a few
1492      * more records, so the sequence number of the last record cannot be
1493      * wrapped.
1494      */
1495     private void tryKeyUpdate() throws IOException {
1496         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
1497         // connection is not duplex-open.
1498         if ((conContext.handshakeContext == null) &amp;&amp;
1499                 !conContext.isOutboundClosed() &amp;&amp;
1500                 !conContext.isInboundClosed() &amp;&amp;
1501                 !conContext.isBroken) {
1502             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1503                 SSLLogger.finest(&quot;trigger key update&quot;);
1504             }
1505             startHandshake();
1506         }
1507     }
1508 
1509     // Try to generate a PostHandshake NewSessionTicket message.  This is
1510     // TLS 1.3 only.
1511     private void tryNewSessionTicket() throws IOException {
1512         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
1513         // connection is not duplex-open.
1514         if (!conContext.sslConfig.isClientMode &amp;&amp;
1515                 conContext.protocolVersion.useTLS13PlusSpec() &amp;&amp;
1516                 conContext.handshakeContext == null &amp;&amp;
1517                 !conContext.isOutboundClosed() &amp;&amp;
1518                 !conContext.isInboundClosed() &amp;&amp;
1519                 !conContext.isBroken) {
1520             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1521                 SSLLogger.finest(&quot;trigger new session ticket&quot;);
1522             }
1523             NewSessionTicket.kickstartProducer.produce(
1524                     new PostHandshakeContext(conContext));
1525         }
1526     }
1527 
1528     /**
1529      * Initialize the handshaker and socket streams.
1530      *
1531      * Called by connect, the layered constructor, and SSLServerSocket.
1532      */
1533     void doneConnect() throws IOException {
1534         socketLock.lock();
1535         try {
1536             // In server mode, it is not necessary to set host and serverNames.
1537             // Otherwise, would require a reverse DNS lookup to get
1538             // the hostname.
1539             if (peerHost == null || peerHost.isEmpty()) {
1540                 boolean useNameService =
1541                         trustNameService &amp;&amp; conContext.sslConfig.isClientMode;
1542                 useImplicitHost(useNameService);
1543             } else {
1544                 conContext.sslConfig.serverNames =
1545                         Utilities.addToSNIServerNameList(
1546                                 conContext.sslConfig.serverNames, peerHost);
1547             }
1548 
1549             InputStream sockInput = super.getInputStream();
1550             conContext.inputRecord.setReceiverStream(sockInput);
1551 
1552             OutputStream sockOutput = super.getOutputStream();
1553             conContext.inputRecord.setDeliverStream(sockOutput);
1554             conContext.outputRecord.setDeliverStream(sockOutput);
1555 
1556             this.isConnected = true;
1557         } finally {
1558             socketLock.unlock();
1559         }
1560     }
1561 
1562     private void useImplicitHost(boolean useNameService) {
1563         // Note: If the local name service is not trustworthy, reverse
1564         // host name resolution should not be performed for endpoint
1565         // identification.  Use the application original specified
1566         // hostname or IP address instead.
1567 
1568         // Get the original hostname via jdk.internal.access.SharedSecrets
1569         InetAddress inetAddress = getInetAddress();
1570         if (inetAddress == null) {      // not connected
1571             return;
1572         }
1573 
1574         JavaNetInetAddressAccess jna =
1575                 SharedSecrets.getJavaNetInetAddressAccess();
1576         String originalHostname = jna.getOriginalHostName(inetAddress);
1577         if (originalHostname != null &amp;&amp; !originalHostname.isEmpty()) {
1578 
1579             this.peerHost = originalHostname;
1580             if (conContext.sslConfig.serverNames.isEmpty() &amp;&amp;
1581                     !conContext.sslConfig.noSniExtension) {
1582                 conContext.sslConfig.serverNames =
1583                         Utilities.addToSNIServerNameList(
1584                                 conContext.sslConfig.serverNames, peerHost);
1585             }
1586 
1587             return;
1588         }
1589 
1590         // No explicitly specified hostname, no server name indication.
1591         if (!useNameService) {
1592             // The local name service is not trustworthy, use IP address.
1593             this.peerHost = inetAddress.getHostAddress();
1594         } else {
1595             // Use the underlying reverse host name resolution service.
1596             this.peerHost = getInetAddress().getHostName();
1597         }
1598     }
1599 
1600     // ONLY used by HttpsClient to setup the URI specified hostname
1601     //
1602     // Please NOTE that this method MUST be called before calling to
1603     // SSLSocket.setSSLParameters(). Otherwise, the {@code host} parameter
1604     // may override SNIHostName in the customized server name indication.
1605     public void setHost(String host) {
1606         socketLock.lock();
1607         try {
1608             this.peerHost = host;
1609             this.conContext.sslConfig.serverNames =
1610                     Utilities.addToSNIServerNameList(
1611                             conContext.sslConfig.serverNames, host);
1612         } finally {
1613             socketLock.unlock();
1614         }
1615     }
1616 
1617     /**
1618      * Handle an exception.
1619      *
1620      * This method is called by top level exception handlers (in read(),
1621      * write()) to make sure we always shutdown the connection correctly
1622      * and do not pass runtime exception to the application.
1623      *
1624      * This method never returns normally, it always throws an IOException.
1625      */
1626     private void handleException(Exception cause) throws IOException {
1627         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1628             SSLLogger.warning(&quot;handling exception&quot;, cause);
1629         }
1630 
1631         // Don&#39;t close the Socket in case of timeouts or interrupts.
1632         if (cause instanceof InterruptedIOException) {
1633             throw (IOException)cause;
1634         }
1635 
1636         // need to perform error shutdown
1637         boolean isSSLException = (cause instanceof SSLException);
1638         Alert alert;
1639         if (isSSLException) {
1640             if (cause instanceof SSLHandshakeException) {
1641                 alert = Alert.HANDSHAKE_FAILURE;
1642             } else {
1643                 alert = Alert.UNEXPECTED_MESSAGE;
1644             }
1645         } else {
1646             if (cause instanceof IOException) {
1647                 alert = Alert.UNEXPECTED_MESSAGE;
1648             } else {
1649                 // RuntimeException
1650                 alert = Alert.INTERNAL_ERROR;
1651             }
1652         }
1653 
1654         throw conContext.fatal(alert, cause);
1655     }
1656 
1657     private Plaintext handleEOF(EOFException eofe) throws IOException {
1658         if (requireCloseNotify || conContext.handshakeContext != null) {
1659             SSLException ssle;
1660             if (conContext.handshakeContext != null) {
1661                 ssle = new SSLHandshakeException(
1662                         &quot;Remote host terminated the handshake&quot;);
1663             } else {
1664                 ssle = new SSLProtocolException(
1665                         &quot;Remote host terminated the connection&quot;);
1666             }
1667 
1668             if (eofe != null) {
1669                 ssle.initCause(eofe);
1670             }
1671             throw ssle;
1672         } else {
1673             // treat as if we had received a close_notify
1674             conContext.isInputCloseNotified = true;
1675             shutdownInput();
1676 
1677             return Plaintext.PLAINTEXT_NULL;
1678         }
1679     }
1680 
1681 
1682     @Override
1683     public String getPeerHost() {
1684         return peerHost;
1685     }
1686 
1687     @Override
1688     public int getPeerPort() {
1689         return getPort();
1690     }
1691 
1692     @Override
1693     public boolean useDelegatedTask() {
1694         return false;
1695     }
1696 
1697     @Override
1698     public void shutdown() throws IOException {
1699         if (!isClosed()) {
1700             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1701                 SSLLogger.fine(&quot;close the underlying socket&quot;);
1702             }
1703 
1704             try {
1705                 if (conContext.isInputCloseNotified) {
1706                     // Close the connection, no wait for more peer response.
1707                     closeSocket(false);
1708                 } else {
1709                     // Close the connection, may wait for peer close_notify.
1710                     closeSocket(true);
1711                 }
1712             } finally {
1713                 tlsIsClosed = true;
1714             }
1715         }
1716     }
1717 
1718     private void closeSocket(boolean selfInitiated) throws IOException {
1719         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1720             SSLLogger.fine(&quot;close the SSL connection &quot; +
1721                 (selfInitiated ? &quot;(initiative)&quot; : &quot;(passive)&quot;));
1722         }
1723 
1724         if (autoClose || !isLayered()) {
1725             super.close();
1726         } else if (selfInitiated) {
1727             if (!conContext.isInboundClosed() &amp;&amp; !isInputShutdown()) {
1728                 // wait for close_notify alert to clear input stream.
1729                 waitForClose();
1730             }
1731         }
1732     }
1733 
1734    /**
1735     * Wait for close_notify alert for a graceful closure.
1736     *
1737     * [RFC 5246] If the application protocol using TLS provides that any
1738     * data may be carried over the underlying transport after the TLS
1739     * connection is closed, the TLS implementation must receive the responding
1740     * close_notify alert before indicating to the application layer that
1741     * the TLS connection has ended.  If the application protocol will not
1742     * transfer any additional data, but will only close the underlying
1743     * transport connection, then the implementation MAY choose to close the
1744     * transport without waiting for the responding close_notify.
1745     */
1746     private void waitForClose() throws IOException {
1747         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1748             SSLLogger.fine(&quot;wait for close_notify or alert&quot;);
1749         }
1750 
1751         while (!conContext.isInboundClosed()) {
1752             try {
1753                 Plaintext plainText = decode(null);
1754                 // discard and continue
1755                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1756                     SSLLogger.finest(
1757                         &quot;discard plaintext while waiting for close&quot;, plainText);
1758                 }
1759             } catch (Exception e) {   // including RuntimeException
1760                 handleException(e);
1761             }
1762         }
1763     }
1764 }
    </pre>
  </body>
</html>
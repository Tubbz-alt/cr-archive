<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.SharedSecrets;
  29 import jdk.internal.module.IllegalAccessLogger;
  30 import jdk.internal.org.objectweb.asm.ClassReader;
  31 import jdk.internal.reflect.CallerSensitive;
  32 import jdk.internal.reflect.Reflection;
  33 import jdk.internal.vm.annotation.ForceInline;
  34 import sun.invoke.util.ValueConversions;
  35 import sun.invoke.util.VerifyAccess;
  36 import sun.invoke.util.Wrapper;
  37 import sun.reflect.misc.ReflectUtil;
  38 import sun.security.util.SecurityConstants;
  39 
  40 import java.lang.invoke.LambdaForm.BasicType;
  41 import java.lang.reflect.Constructor;
  42 import java.lang.reflect.Field;
  43 import java.lang.reflect.Member;
  44 import java.lang.reflect.Method;
  45 import java.lang.reflect.Modifier;
  46 import java.lang.reflect.ReflectPermission;
  47 import java.nio.ByteOrder;
  48 import java.security.AccessController;
  49 import java.security.PrivilegedAction;
  50 import java.security.ProtectionDomain;
  51 import java.util.ArrayList;
  52 import java.util.Arrays;
  53 import java.util.BitSet;
  54 import java.util.Iterator;
  55 import java.util.List;
  56 import java.util.Objects;
  57 import java.util.Set;
  58 import java.util.concurrent.ConcurrentHashMap;
  59 import java.util.stream.Collectors;
  60 import java.util.stream.Stream;
  61 
  62 import static java.lang.invoke.MethodHandleImpl.Intrinsic;
  63 import static java.lang.invoke.MethodHandleNatives.Constants.*;
  64 import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;
  65 import static java.lang.invoke.MethodType.methodType;
  66 
  67 /**
  68  * This class consists exclusively of static methods that operate on or return
  69  * method handles. They fall into several categories:
  70  * &lt;ul&gt;
  71  * &lt;li&gt;Lookup methods which help create method handles for methods and fields.
  72  * &lt;li&gt;Combinator methods, which combine or transform pre-existing method handles into new ones.
  73  * &lt;li&gt;Other factory methods to create method handles that emulate other common JVM operations or control flow patterns.
  74  * &lt;/ul&gt;
  75  * A lookup, combinator, or factory method will fail and throw an
  76  * {@code IllegalArgumentException} if the created method handle&#39;s type
  77  * would have &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;.
  78  *
  79  * @author John Rose, JSR 292 EG
  80  * @since 1.7
  81  */
  82 public class MethodHandles {
  83 
  84     private MethodHandles() { }  // do not instantiate
  85 
  86     static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
  87 
  88     // See IMPL_LOOKUP below.
  89 
  90     //// Method handle creation from ordinary methods.
  91 
  92     /**
  93      * Returns a {@link Lookup lookup object} with
  94      * full capabilities to emulate all supported bytecode behaviors of the caller.
  95      * These capabilities include {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access} to the caller.
  96      * Factory methods on the lookup object can create
  97      * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handles&lt;/a&gt;
  98      * for any member that the caller has access to via bytecodes,
  99      * including protected and private fields and methods.
 100      * This lookup object is a &lt;em&gt;capability&lt;/em&gt; which may be delegated to trusted agents.
 101      * Do not store it in place where untrusted code can access it.
 102      * &lt;p&gt;
 103      * This method is caller sensitive, which means that it may return different
 104      * values to different callers.
 105      * @return a lookup object for the caller of this method, with
 106      * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access}
 107      */
 108     @CallerSensitive
 109     @ForceInline // to ensure Reflection.getCallerClass optimization
 110     public static Lookup lookup() {
 111         return new Lookup(Reflection.getCallerClass());
 112     }
 113 
 114     /**
 115      * This reflected$lookup method is the alternate implementation of
 116      * the lookup method when being invoked by reflection.
 117      */
 118     @CallerSensitive
 119     private static Lookup reflected$lookup() {
 120         Class&lt;?&gt; caller = Reflection.getCallerClass();
 121         if (caller.getClassLoader() == null) {
 122             throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+caller);
 123         }
 124         return new Lookup(caller);
 125     }
 126 
 127     /**
 128      * Returns a {@link Lookup lookup object} which is trusted minimally.
 129      * The lookup has the {@code UNCONDITIONAL} mode.
 130      * It can only be used to create method handles to public members of
 131      * public classes in packages that are exported unconditionally.
 132      * &lt;p&gt;
 133      * As a matter of pure convention, the {@linkplain Lookup#lookupClass() lookup class}
 134      * of this lookup object will be {@link java.lang.Object}.
 135      *
 136      * @apiNote The use of Object is conventional, and because the lookup modes are
 137      * limited, there is no special access provided to the internals of Object, its package
 138      * or its module.  This public lookup object or other lookup object with
 139      * {@code UNCONDITIONAL} mode assumes readability. Consequently, the lookup class
 140      * is not used to determine the lookup context.
 141      *
 142      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 143      * &lt;em&gt;Discussion:&lt;/em&gt;
 144      * The lookup class can be changed to any other class {@code C} using an expression of the form
 145      * {@link Lookup#in publicLookup().in(C.class)}.
 146      * A public lookup object is always subject to
 147      * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;security manager checks&lt;/a&gt;.
 148      * Also, it cannot access
 149      * &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive methods&lt;/a&gt;.
 150      * @return a lookup object which is trusted minimally
 151      *
 152      * @revised 9
 153      * @spec JPMS
 154      */
 155     public static Lookup publicLookup() {
 156         return Lookup.PUBLIC_LOOKUP;
 157     }
 158 
 159     /**
 160      * Returns a {@link Lookup lookup} object on a target class to emulate all supported
 161      * bytecode behaviors, including &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;.
 162      * The returned lookup object can provide access to classes in modules and packages,
 163      * and members of those classes, outside the normal rules of Java access control,
 164      * instead conforming to the more permissive rules for modular &lt;em&gt;deep reflection&lt;/em&gt;.
 165      * &lt;p&gt;
 166      * A caller, specified as a {@code Lookup} object, in module {@code M1} is
 167      * allowed to do deep reflection on module {@code M2} and package of the target class
 168      * if and only if all of the following conditions are {@code true}:
 169      * &lt;ul&gt;
 170      * &lt;li&gt;If there is a security manager, its {@code checkPermission} method is
 171      * called to check {@code ReflectPermission(&quot;suppressAccessChecks&quot;)} and
 172      * that must return normally.
 173      * &lt;li&gt;The caller lookup object must have {@linkplain Lookup#hasFullPrivilegeAccess()
 174      * full privilege access}.  Specifically:
 175      *   &lt;ul&gt;
 176      *     &lt;li&gt;The caller lookup object must have the {@link Lookup#MODULE MODULE} lookup mode.
 177      *         (This is because otherwise there would be no way to ensure the original lookup
 178      *         creator was a member of any particular module, and so any subsequent checks
 179      *         for readability and qualified exports would become ineffective.)
 180      *     &lt;li&gt;The caller lookup object must have {@link Lookup#PRIVATE PRIVATE} access.
 181      *         (This is because an application intending to share intra-module access
 182      *         using {@link Lookup#MODULE MODULE} alone will inadvertently also share
 183      *         deep reflection to its own module.)
 184      *   &lt;/ul&gt;
 185      * &lt;li&gt;The target class must be a proper class, not a primitive or array class.
 186      * (Thus, {@code M2} is well-defined.)
 187      * &lt;li&gt;If the caller module {@code M1} differs from
 188      * the target module {@code M2} then both of the following must be true:
 189      *   &lt;ul&gt;
 190      *     &lt;li&gt;{@code M1} {@link Module#canRead reads} {@code M2}.&lt;/li&gt;
 191      *     &lt;li&gt;{@code M2} {@link Module#isOpen(String,Module) opens} the package
 192      *         containing the target class to at least {@code M1}.&lt;/li&gt;
 193      *   &lt;/ul&gt;
 194      * &lt;/ul&gt;
 195      * &lt;p&gt;
 196      * If any of the above checks is violated, this method fails with an
 197      * exception.
 198      * &lt;p&gt;
 199      * Otherwise, if {@code M1} and {@code M2} are the same module, this method
 200      * returns a {@code Lookup} on {@code targetClass} with
 201      * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access} and
 202      * {@code null} previous lookup class.
 203      * &lt;p&gt;
 204      * Otherwise, {@code M1} and {@code M2} are two different modules.  This method
 205      * returns a {@code Lookup} on {@code targetClass} that records
 206      * the lookup class of the caller as the new previous lookup class and
 207      * drops {@code MODULE} access from the full privilege access.
 208      *
 209      * @param targetClass the target class
 210      * @param caller the caller lookup object
 211      * @return a lookup object for the target class, with private access
 212      * @throws IllegalArgumentException if {@code targetClass} is a primitive type or void or array class
 213      * @throws NullPointerException if {@code targetClass} or {@code caller} is {@code null}
 214      * @throws SecurityException if denied by the security manager
 215      * @throws IllegalAccessException if any of the other access checks specified above fails
 216      * @since 9
 217      * @spec JPMS
 218      * @see Lookup#dropLookupMode
 219      * @see &lt;a href=&quot;MethodHandles.Lookup.html#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
 220      */
 221     public static Lookup privateLookupIn(Class&lt;?&gt; targetClass, Lookup caller) throws IllegalAccessException {
 222         SecurityManager sm = System.getSecurityManager();
 223         if (sm != null) sm.checkPermission(ACCESS_PERMISSION);
 224         if (targetClass.isPrimitive())
 225             throw new IllegalArgumentException(targetClass + &quot; is a primitive class&quot;);
 226         if (targetClass.isArray())
 227             throw new IllegalArgumentException(targetClass + &quot; is an array class&quot;);
 228         // Ensure that we can reason accurately about private and module access.
 229         if (!caller.hasFullPrivilegeAccess())
 230             throw new IllegalAccessException(&quot;caller does not have PRIVATE and MODULE lookup mode&quot;);
 231 
 232         // previous lookup class is never set if it has MODULE access
 233         assert caller.previousLookupClass() == null;
 234 
 235         Class&lt;?&gt; callerClass = caller.lookupClass();
 236         Module callerModule = callerClass.getModule();  // M1
 237         Module targetModule = targetClass.getModule();  // M2
 238         Class&lt;?&gt; newPreviousClass = null;
 239         int newModes = Lookup.FULL_POWER_MODES;
 240 
 241         if (targetModule != callerModule) {
 242             if (!callerModule.canRead(targetModule))
 243                 throw new IllegalAccessException(callerModule + &quot; does not read &quot; + targetModule);
 244             if (targetModule.isNamed()) {
 245                 String pn = targetClass.getPackageName();
 246                 assert !pn.isEmpty() : &quot;unnamed package cannot be in named module&quot;;
 247                 if (!targetModule.isOpen(pn, callerModule))
 248                     throw new IllegalAccessException(targetModule + &quot; does not open &quot; + pn + &quot; to &quot; + callerModule);
 249             }
 250 
 251             // M2 != M1, set previous lookup class to M1 and drop MODULE access
 252             newPreviousClass = callerClass;
 253             newModes &amp;= ~Lookup.MODULE;
 254         }
 255 
 256         if (!callerModule.isNamed() &amp;&amp; targetModule.isNamed()) {
 257             IllegalAccessLogger logger = IllegalAccessLogger.illegalAccessLogger();
 258             if (logger != null) {
 259                 logger.logIfOpenedForIllegalAccess(caller, targetClass);
 260             }
 261         }
 262         return Lookup.newLookup(targetClass, newPreviousClass, newModes);
 263     }
 264 
 265     /**
 266      * Performs an unchecked &quot;crack&quot; of a
 267      * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;.
 268      * The result is as if the user had obtained a lookup object capable enough
 269      * to crack the target method handle, called
 270      * {@link java.lang.invoke.MethodHandles.Lookup#revealDirect Lookup.revealDirect}
 271      * on the target to obtain its symbolic reference, and then called
 272      * {@link java.lang.invoke.MethodHandleInfo#reflectAs MethodHandleInfo.reflectAs}
 273      * to resolve the symbolic reference to a member.
 274      * &lt;p&gt;
 275      * If there is a security manager, its {@code checkPermission} method
 276      * is called with a {@code ReflectPermission(&quot;suppressAccessChecks&quot;)} permission.
 277      * @param &lt;T&gt; the desired type of the result, either {@link Member} or a subtype
 278      * @param target a direct method handle to crack into symbolic reference components
 279      * @param expected a class object representing the desired result type {@code T}
 280      * @return a reference to the method, constructor, or field object
 281      * @throws    SecurityException if the caller is not privileged to call {@code setAccessible}
 282      * @throws    NullPointerException if either argument is {@code null}
 283      * @throws    IllegalArgumentException if the target is not a direct method handle
 284      * @throws    ClassCastException if the member is not of the expected type
 285      * @since 1.8
 286      */
 287     public static &lt;T extends Member&gt; T reflectAs(Class&lt;T&gt; expected, MethodHandle target) {
 288         SecurityManager smgr = System.getSecurityManager();
 289         if (smgr != null)  smgr.checkPermission(ACCESS_PERMISSION);
 290         Lookup lookup = Lookup.IMPL_LOOKUP;  // use maximally privileged lookup
 291         return lookup.revealDirect(target).reflectAs(expected, lookup);
 292     }
 293     // Copied from AccessibleObject, as used by Method.setAccessible, etc.:
 294     private static final java.security.Permission ACCESS_PERMISSION =
 295         new ReflectPermission(&quot;suppressAccessChecks&quot;);
 296 
 297     /**
 298      * A &lt;em&gt;lookup object&lt;/em&gt; is a factory for creating method handles,
 299      * when the creation requires access checking.
 300      * Method handles do not perform
 301      * access checks when they are called, but rather when they are created.
 302      * Therefore, method handle access
 303      * restrictions must be enforced when a method handle is created.
 304      * The caller class against which those restrictions are enforced
 305      * is known as the {@linkplain #lookupClass() lookup class}.
 306      * &lt;p&gt;
 307      * A lookup class which needs to create method handles will call
 308      * {@link MethodHandles#lookup() MethodHandles.lookup} to create a factory for itself.
 309      * When the {@code Lookup} factory object is created, the identity of the lookup class is
 310      * determined, and securely stored in the {@code Lookup} object.
 311      * The lookup class (or its delegates) may then use factory methods
 312      * on the {@code Lookup} object to create method handles for access-checked members.
 313      * This includes all methods, constructors, and fields which are allowed to the lookup class,
 314      * even private ones.
 315      *
 316      * &lt;h2&gt;&lt;a id=&quot;lookups&quot;&gt;&lt;/a&gt;Lookup Factory Methods&lt;/h2&gt;
 317      * The factory methods on a {@code Lookup} object correspond to all major
 318      * use cases for methods, constructors, and fields.
 319      * Each method handle created by a factory method is the functional
 320      * equivalent of a particular &lt;em&gt;bytecode behavior&lt;/em&gt;.
 321      * (Bytecode behaviors are described in section {@jvms 5.4.3.5} of
 322      * the Java Virtual Machine Specification.)
 323      * Here is a summary of the correspondence between these factory methods and
 324      * the behavior of the resulting method handles:
 325      * &lt;table class=&quot;striped&quot;&gt;
 326      * &lt;caption style=&quot;display:none&quot;&gt;lookup method behaviors&lt;/caption&gt;
 327      * &lt;thead&gt;
 328      * &lt;tr&gt;
 329      *     &lt;th scope=&quot;col&quot;&gt;&lt;a id=&quot;equiv&quot;&gt;&lt;/a&gt;lookup expression&lt;/th&gt;
 330      *     &lt;th scope=&quot;col&quot;&gt;member&lt;/th&gt;
 331      *     &lt;th scope=&quot;col&quot;&gt;bytecode behavior&lt;/th&gt;
 332      * &lt;/tr&gt;
 333      * &lt;/thead&gt;
 334      * &lt;tbody&gt;
 335      * &lt;tr&gt;
 336      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findGetter lookup.findGetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
 337      *     &lt;td&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (T) this.f;}&lt;/td&gt;
 338      * &lt;/tr&gt;
 339      * &lt;tr&gt;
 340      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStaticGetter lookup.findStaticGetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
 341      *     &lt;td&gt;{@code static}&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (FT) C.f;}&lt;/td&gt;
 342      * &lt;/tr&gt;
 343      * &lt;tr&gt;
 344      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findSetter lookup.findSetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
 345      *     &lt;td&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code this.f = x;}&lt;/td&gt;
 346      * &lt;/tr&gt;
 347      * &lt;tr&gt;
 348      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStaticSetter lookup.findStaticSetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
 349      *     &lt;td&gt;{@code static}&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code C.f = arg;}&lt;/td&gt;
 350      * &lt;/tr&gt;
 351      * &lt;tr&gt;
 352      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findVirtual lookup.findVirtual(C.class,&quot;m&quot;,MT)}&lt;/th&gt;
 353      *     &lt;td&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) this.m(arg*);}&lt;/td&gt;
 354      * &lt;/tr&gt;
 355      * &lt;tr&gt;
 356      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStatic lookup.findStatic(C.class,&quot;m&quot;,MT)}&lt;/th&gt;
 357      *     &lt;td&gt;{@code static}&lt;br&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) C.m(arg*);}&lt;/td&gt;
 358      * &lt;/tr&gt;
 359      * &lt;tr&gt;
 360      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findSpecial lookup.findSpecial(C.class,&quot;m&quot;,MT,this.class)}&lt;/th&gt;
 361      *     &lt;td&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) super.m(arg*);}&lt;/td&gt;
 362      * &lt;/tr&gt;
 363      * &lt;tr&gt;
 364      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findConstructor lookup.findConstructor(C.class,MT)}&lt;/th&gt;
 365      *     &lt;td&gt;{@code C(A*);}&lt;/td&gt;&lt;td&gt;{@code new C(arg*);}&lt;/td&gt;
 366      * &lt;/tr&gt;
 367      * &lt;tr&gt;
 368      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectGetter lookup.unreflectGetter(aField)}&lt;/th&gt;
 369      *     &lt;td&gt;({@code static})?&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (FT) aField.get(thisOrNull);}&lt;/td&gt;
 370      * &lt;/tr&gt;
 371      * &lt;tr&gt;
 372      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectSetter lookup.unreflectSetter(aField)}&lt;/th&gt;
 373      *     &lt;td&gt;({@code static})?&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code aField.set(thisOrNull, arg);}&lt;/td&gt;
 374      * &lt;/tr&gt;
 375      * &lt;tr&gt;
 376      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflect lookup.unreflect(aMethod)}&lt;/th&gt;
 377      *     &lt;td&gt;({@code static})?&lt;br&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) aMethod.invoke(thisOrNull, arg*);}&lt;/td&gt;
 378      * &lt;/tr&gt;
 379      * &lt;tr&gt;
 380      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectConstructor lookup.unreflectConstructor(aConstructor)}&lt;/th&gt;
 381      *     &lt;td&gt;{@code C(A*);}&lt;/td&gt;&lt;td&gt;{@code (C) aConstructor.newInstance(arg*);}&lt;/td&gt;
 382      * &lt;/tr&gt;
 383      * &lt;tr&gt;
 384      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectSpecial lookup.unreflectSpecial(aMethod,this.class)}&lt;/th&gt;
 385      *     &lt;td&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) super.m(arg*);}&lt;/td&gt;
 386      * &lt;/tr&gt;
 387      * &lt;tr&gt;
 388      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findClass lookup.findClass(&quot;C&quot;)}&lt;/th&gt;
 389      *     &lt;td&gt;{@code class C { ... }}&lt;/td&gt;&lt;td&gt;{@code C.class;}&lt;/td&gt;
 390      * &lt;/tr&gt;
 391      * &lt;/tbody&gt;
 392      * &lt;/table&gt;
 393      *
 394      * Here, the type {@code C} is the class or interface being searched for a member,
 395      * documented as a parameter named {@code refc} in the lookup methods.
 396      * The method type {@code MT} is composed from the return type {@code T}
 397      * and the sequence of argument types {@code A*}.
 398      * The constructor also has a sequence of argument types {@code A*} and
 399      * is deemed to return the newly-created object of type {@code C}.
 400      * Both {@code MT} and the field type {@code FT} are documented as a parameter named {@code type}.
 401      * The formal parameter {@code this} stands for the self-reference of type {@code C};
 402      * if it is present, it is always the leading argument to the method handle invocation.
 403      * (In the case of some {@code protected} members, {@code this} may be
 404      * restricted in type to the lookup class; see below.)
 405      * The name {@code arg} stands for all the other method handle arguments.
 406      * In the code examples for the Core Reflection API, the name {@code thisOrNull}
 407      * stands for a null reference if the accessed method or field is static,
 408      * and {@code this} otherwise.
 409      * The names {@code aMethod}, {@code aField}, and {@code aConstructor} stand
 410      * for reflective objects corresponding to the given members declared in type {@code C}.
 411      * &lt;p&gt;
 412      * The bytecode behavior for a {@code findClass} operation is a load of a constant class,
 413      * as if by {@code ldc CONSTANT_Class}.
 414      * The behavior is represented, not as a method handle, but directly as a {@code Class} constant.
 415      * &lt;p&gt;
 416      * In cases where the given member is of variable arity (i.e., a method or constructor)
 417      * the returned method handle will also be of {@linkplain MethodHandle#asVarargsCollector variable arity}.
 418      * In all other cases, the returned method handle will be of fixed arity.
 419      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 420      * &lt;em&gt;Discussion:&lt;/em&gt;
 421      * The equivalence between looked-up method handles and underlying
 422      * class members and bytecode behaviors
 423      * can break down in a few ways:
 424      * &lt;ul style=&quot;font-size:smaller;&quot;&gt;
 425      * &lt;li&gt;If {@code C} is not symbolically accessible from the lookup class&#39;s loader,
 426      * the lookup can still succeed, even when there is no equivalent
 427      * Java expression or bytecoded constant.
 428      * &lt;li&gt;Likewise, if {@code T} or {@code MT}
 429      * is not symbolically accessible from the lookup class&#39;s loader,
 430      * the lookup can still succeed.
 431      * For example, lookups for {@code MethodHandle.invokeExact} and
 432      * {@code MethodHandle.invoke} will always succeed, regardless of requested type.
 433      * &lt;li&gt;If there is a security manager installed, it can forbid the lookup
 434      * on various grounds (&lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;see below&lt;/a&gt;).
 435      * By contrast, the {@code ldc} instruction on a {@code CONSTANT_MethodHandle}
 436      * constant is not subject to security manager checks.
 437      * &lt;li&gt;If the looked-up method has a
 438      * &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;very large arity&lt;/a&gt;,
 439      * the method handle creation may fail with an
 440      * {@code IllegalArgumentException}, due to the method handle type having
 441      * &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters.&lt;/a&gt;
 442      * &lt;/ul&gt;
 443      *
 444      * &lt;h2&gt;&lt;a id=&quot;access&quot;&gt;&lt;/a&gt;Access checking&lt;/h2&gt;
 445      * Access checks are applied in the factory methods of {@code Lookup},
 446      * when a method handle is created.
 447      * This is a key difference from the Core Reflection API, since
 448      * {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
 449      * performs access checking against every caller, on every call.
 450      * &lt;p&gt;
 451      * All access checks start from a {@code Lookup} object, which
 452      * compares its recorded lookup class against all requests to
 453      * create method handles.
 454      * A single {@code Lookup} object can be used to create any number
 455      * of access-checked method handles, all checked against a single
 456      * lookup class.
 457      * &lt;p&gt;
 458      * A {@code Lookup} object can be shared with other trusted code,
 459      * such as a metaobject protocol.
 460      * A shared {@code Lookup} object delegates the capability
 461      * to create method handles on private members of the lookup class.
 462      * Even if privileged code uses the {@code Lookup} object,
 463      * the access checking is confined to the privileges of the
 464      * original lookup class.
 465      * &lt;p&gt;
 466      * A lookup can fail, because
 467      * the containing class is not accessible to the lookup class, or
 468      * because the desired class member is missing, or because the
 469      * desired class member is not accessible to the lookup class, or
 470      * because the lookup object is not trusted enough to access the member.
 471      * In the case of a field setter function on a {@code final} field,
 472      * finality enforcement is treated as a kind of access control,
 473      * and the lookup will fail, except in special cases of
 474      * {@link Lookup#unreflectSetter Lookup.unreflectSetter}.
 475      * In any of these cases, a {@code ReflectiveOperationException} will be
 476      * thrown from the attempted lookup.  The exact class will be one of
 477      * the following:
 478      * &lt;ul&gt;
 479      * &lt;li&gt;NoSuchMethodException &amp;mdash; if a method is requested but does not exist
 480      * &lt;li&gt;NoSuchFieldException &amp;mdash; if a field is requested but does not exist
 481      * &lt;li&gt;IllegalAccessException &amp;mdash; if the member exists but an access check fails
 482      * &lt;/ul&gt;
 483      * &lt;p&gt;
 484      * In general, the conditions under which a method handle may be
 485      * looked up for a method {@code M} are no more restrictive than the conditions
 486      * under which the lookup class could have compiled, verified, and resolved a call to {@code M}.
 487      * Where the JVM would raise exceptions like {@code NoSuchMethodError},
 488      * a method handle lookup will generally raise a corresponding
 489      * checked exception, such as {@code NoSuchMethodException}.
 490      * And the effect of invoking the method handle resulting from the lookup
 491      * is &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;exactly equivalent&lt;/a&gt;
 492      * to executing the compiled, verified, and resolved call to {@code M}.
 493      * The same point is true of fields and constructors.
 494      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 495      * &lt;em&gt;Discussion:&lt;/em&gt;
 496      * Access checks only apply to named and reflected methods,
 497      * constructors, and fields.
 498      * Other method handle creation methods, such as
 499      * {@link MethodHandle#asType MethodHandle.asType},
 500      * do not require any access checks, and are used
 501      * independently of any {@code Lookup} object.
 502      * &lt;p&gt;
 503      * If the desired member is {@code protected}, the usual JVM rules apply,
 504      * including the requirement that the lookup class must either be in the
 505      * same package as the desired member, or must inherit that member.
 506      * (See the Java Virtual Machine Specification, sections {@jvms
 507      * 4.9.2}, {@jvms 5.4.3.5}, and {@jvms 6.4}.)
 508      * In addition, if the desired member is a non-static field or method
 509      * in a different package, the resulting method handle may only be applied
 510      * to objects of the lookup class or one of its subclasses.
 511      * This requirement is enforced by narrowing the type of the leading
 512      * {@code this} parameter from {@code C}
 513      * (which will necessarily be a superclass of the lookup class)
 514      * to the lookup class itself.
 515      * &lt;p&gt;
 516      * The JVM imposes a similar requirement on {@code invokespecial} instruction,
 517      * that the receiver argument must match both the resolved method &lt;em&gt;and&lt;/em&gt;
 518      * the current class.  Again, this requirement is enforced by narrowing the
 519      * type of the leading parameter to the resulting method handle.
 520      * (See the Java Virtual Machine Specification, section {@jmvs 4.10.1.9}.)
 521      * &lt;p&gt;
 522      * The JVM represents constructors and static initializer blocks as internal methods
 523      * with special names ({@code &quot;&lt;init&gt;&quot;} and {@code &quot;&lt;clinit&gt;&quot;}).
 524      * The internal syntax of invocation instructions allows them to refer to such internal
 525      * methods as if they were normal methods, but the JVM bytecode verifier rejects them.
 526      * A lookup of such an internal method will produce a {@code NoSuchMethodException}.
 527      * &lt;p&gt;
 528      * If the relationship between nested types is expressed directly through the
 529      * {@code NestHost} and {@code NestMembers} attributes
 530      * (see the Java Virtual Machine Specification, sections {@jvms
 531      * 4.7.28} and {@jvms 4.7.29}),
 532      * then the associated {@code Lookup} object provides direct access to
 533      * the lookup class and all of its nestmates
 534      * (see {@link java.lang.Class#getNestHost Class.getNestHost}).
 535      * Otherwise, access between nested classes is obtained by the Java compiler creating
 536      * a wrapper method to access a private method of another class in the same nest.
 537      * For example, a nested class {@code C.D}
 538      * can access private members within other related classes such as
 539      * {@code C}, {@code C.D.E}, or {@code C.B},
 540      * but the Java compiler may need to generate wrapper methods in
 541      * those related classes.  In such cases, a {@code Lookup} object on
 542      * {@code C.E} would be unable to access those private members.
 543      * A workaround for this limitation is the {@link Lookup#in Lookup.in} method,
 544      * which can transform a lookup on {@code C.E} into one on any of those other
 545      * classes, without special elevation of privilege.
 546      * &lt;p&gt;
 547      * The accesses permitted to a given lookup object may be limited,
 548      * according to its set of {@link #lookupModes lookupModes},
 549      * to a subset of members normally accessible to the lookup class.
 550      * For example, the {@link MethodHandles#publicLookup publicLookup}
 551      * method produces a lookup object which is only allowed to access
 552      * public members in public classes of exported packages.
 553      * The caller sensitive method {@link MethodHandles#lookup lookup}
 554      * produces a lookup object with full capabilities relative to
 555      * its caller class, to emulate all supported bytecode behaviors.
 556      * Also, the {@link Lookup#in Lookup.in} method may produce a lookup object
 557      * with fewer access modes than the original lookup object.
 558      *
 559      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 560      * &lt;a id=&quot;privacc&quot;&gt;&lt;/a&gt;
 561      * &lt;em&gt;Discussion of private and module access:&lt;/em&gt;
 562      * We say that a lookup has &lt;em&gt;private access&lt;/em&gt;
 563      * if its {@linkplain #lookupModes lookup modes}
 564      * include the possibility of accessing {@code private} members
 565      * (which includes the private members of nestmates).
 566      * As documented in the relevant methods elsewhere,
 567      * only lookups with private access possess the following capabilities:
 568      * &lt;ul style=&quot;font-size:smaller;&quot;&gt;
 569      * &lt;li&gt;access private fields, methods, and constructors of the lookup class and its nestmates
 570      * &lt;li&gt;create method handles which {@link Lookup#findSpecial emulate invokespecial} instructions
 571      * &lt;li&gt;avoid &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;package access checks&lt;/a&gt;
 572      *     for classes accessible to the lookup class
 573      * &lt;li&gt;create {@link Lookup#in delegated lookup objects} which have private access to other classes
 574      *     within the same package member
 575      * &lt;/ul&gt;
 576      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 577      * Similarly, a lookup with module access ensures that the original lookup creator was
 578      * a member in the same module as the lookup class.
 579      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 580      * Private and module access are independently determined modes; a lookup may have
 581      * either or both or neither.  A lookup which possesses both access modes is said to
 582      * possess {@linkplain #hasFullPrivilegeAccess() full privilege access}.  Such a lookup has
 583      * the following additional capability:
 584      * &lt;ul style=&quot;font-size:smaller;&quot;&gt;
 585      * &lt;li&gt;create method handles which invoke &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt; methods,
 586      *     such as {@code Class.forName}
 587      * &lt;/ul&gt;
 588      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 589      * Each of these permissions is a consequence of the fact that a lookup object
 590      * with private access can be securely traced back to an originating class,
 591      * whose &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; and Java language access permissions
 592      * can be reliably determined and emulated by method handles.
 593      *
 594      * &lt;h2&gt;&lt;a id=&quot;cross-module-lookup&quot;&gt;&lt;/a&gt;Cross-module lookups&lt;/h2&gt;
 595      * When a lookup class in one module {@code M1} accesses a class in another module
 596      * {@code M2}, extra access checking is performed beyond the access mode bits.
 597      * A {@code Lookup} with {@link #PUBLIC} mode and a lookup class in {@code M1}
 598      * can access public types in {@code M2} when {@code M2} is readable to {@code M1}
 599      * and when the type is in a package of {@code M2} that is exported to
 600      * at least {@code M1}.
 601      * &lt;p&gt;
 602      * A {@code Lookup} on {@code C} can also &lt;em&gt;teleport&lt;/em&gt; to a target class
 603      * via {@link #in(Class) Lookup.in} and {@link MethodHandles#privateLookupIn(Class, Lookup)
 604      * MethodHandles.privateLookupIn} methods.
 605      * Teleporting across modules will always record the original lookup class as
 606      * the &lt;em&gt;{@linkplain #previousLookupClass() previous lookup class}&lt;/em&gt;
 607      * and drops {@link Lookup#MODULE MODULE} access.
 608      * If the target class is in the same module as the lookup class {@code C},
 609      * then the target class becomes the new lookup class
 610      * and there is no change to the previous lookup class.
 611      * If the target class is in a different module from {@code M1} ({@code C}&#39;s module),
 612      * {@code C} becomes the new previous lookup class
 613      * and the target class becomes the new lookup class.
 614      * In that case, if there was already a previous lookup class in {@code M0},
 615      * and it differs from {@code M1} and {@code M2}, then the resulting lookup
 616      * drops all privileges.
 617      * For example,
 618      * &lt;blockquote&gt;&lt;pre&gt;
 619      * {@code
 620      * Lookup lookup = MethodHandles.lookup();   // in class C
 621      * Lookup lookup2 = lookup.in(D.class);
 622      * MethodHandle mh = lookup2.findStatic(E.class, &quot;m&quot;, MT);
 623      * }&lt;/pre&gt;&lt;/blockquote&gt;
 624      * &lt;p&gt;
 625      * The {@link #lookup()} factory method produces a {@code Lookup} object
 626      * with {@code null} previous lookup class.
 627      * {@link Lookup#in lookup.in(D.class)} transforms the {@code lookup} on class {@code C}
 628      * to class {@code D} without elevation of privileges.
 629      * If {@code C} and {@code D} are in the same module,
 630      * {@code lookup2} records {@code D} as the new lookup class and keeps the
 631      * same previous lookup class as the original {@code lookup}, or
 632      * {@code null} if not present.
 633      * &lt;p&gt;
 634      * When a {@code Lookup} teleports from a class
 635      * in one nest to another nest, {@code PRIVATE} access is dropped.
 636      * When a {@code Lookup} teleports from a class in one package to
 637      * another package, {@code PACKAGE} access is dropped.
 638      * When a {@code Lookup} teleports from a class in one module to another module,
 639      * {@code MODULE} access is dropped.
 640      * Teleporting across modules drops the ability to access non-exported classes
 641      * in both the module of the new lookup class and the module of the old lookup class
 642      * and the resulting {@code Lookup} remains only {@code PUBLIC} access.
 643      * A {@code Lookup} can teleport back and forth to a class in the module of
 644      * the lookup class and the module of the previous class lookup.
 645      * Teleporting across modules can only decrease access but cannot increase it.
 646      * Teleporting to some third module drops all accesses.
 647      * &lt;p&gt;
 648      * In the above example, if {@code C} and {@code D} are in different modules,
 649      * {@code lookup2} records {@code D} as its lookup class and
 650      * {@code C} as its previous lookup class and {@code lookup2} has only
 651      * {@code PUBLIC} access. {@code lookup2} can teleport to other class in
 652      * {@code C}&#39;s module and {@code D}&#39;s module.
 653      * If class {@code E} is in a third module, {@code lookup2.in(E.class)} creates
 654      * a {@code Lookup} on {@code E} with no access and {@code lookup2}&#39;s lookup
 655      * class {@code D} is recorded as its previous lookup class.
 656      * &lt;p&gt;
 657      * Teleporting across modules restricts access to the public types that
 658      * both the lookup class and the previous lookup class can equally access
 659      * (see below).
 660      * &lt;p&gt;
 661      * {@link MethodHandles#privateLookupIn(Class, Lookup) MethodHandles.privateLookupIn(T.class, lookup)}
 662      * can be used to teleport a {@code lookup} from class {@code C} to class {@code T}
 663      * and create a new {@code Lookup} with &lt;a href=&quot;#privacc&quot;&gt;private access&lt;/a&gt;
 664      * if the lookup class is allowed to do &lt;em&gt;deep reflection&lt;/em&gt; on {@code T}.
 665      * The {@code lookup} must have {@link #MODULE} and {@link #PRIVATE} access
 666      * to call {@code privateLookupIn}.
 667      * A {@code lookup} on {@code C} in module {@code M1} is allowed to do deep reflection
 668      * on all classes in {@code M1}.  If {@code T} is in {@code M1}, {@code privateLookupIn}
 669      * produces a new {@code Lookup} on {@code T} with full capabilities.
 670      * A {@code lookup} on {@code C} is also allowed
 671      * to do deep reflection on {@code T} in another module {@code M2} if
 672      * {@code M1} reads {@code M2} and {@code M2} {@link Module#isOpen(String,Module) opens}
 673      * the package containing {@code T} to at least {@code M1}.
 674      * {@code T} becomes the new lookup class and {@code C} becomes the new previous
 675      * lookup class and {@code MODULE} access is dropped from the resulting {@code Lookup}.
 676      * The resulting {@code Lookup} can be used to do member lookup or teleport
 677      * to another lookup class by calling {@link #in Lookup::in}.  But
 678      * it cannot be used to obtain another private {@code Lookup} by calling
 679      * {@link MethodHandles#privateLookupIn(Class, Lookup) privateLookupIn}
 680      * because it has no {@code MODULE} access.
 681      *
 682      * &lt;h2&gt;&lt;a id=&quot;module-access-check&quot;&gt;&lt;/a&gt;Cross-module access checks&lt;/h2&gt;
 683      *
 684      * A {@code Lookup} with {@link #PUBLIC} or with {@link #UNCONDITIONAL} mode
 685      * allows cross-module access. The access checking is performed with respect
 686      * to both the lookup class and the previous lookup class if present.
 687      * &lt;p&gt;
 688      * A {@code Lookup} with {@link #UNCONDITIONAL} mode can access public type
 689      * in all modules when the type is in a package that is {@linkplain Module#isExported(String)
 690      * exported unconditionally}.
 691      * &lt;p&gt;
 692      * If a {@code Lookup} on {@code LC} in {@code M1} has no previous lookup class,
 693      * the lookup with {@link #PUBLIC} mode can access all public types in modules
 694      * that are readable to {@code M1} and the type is in a package that is exported
 695      * at least to {@code M1}.
 696      * &lt;p&gt;
 697      * If a {@code Lookup} on {@code LC} in {@code M1} has a previous lookup class
 698      * {@code PLC} on {@code M0}, the lookup with {@link #PUBLIC} mode can access
 699      * the intersection of all public types that are accessible to {@code M1}
 700      * with all public types that are accessible to {@code M0}. {@code M0}
 701      * reads {@code M1} and hence the set of accessible types includes:
 702      *
 703      * &lt;table class=&quot;striped&quot;&gt;
 704      * &lt;caption style=&quot;display:none&quot;&gt;
 705      * Public types in the following packages are accessible to the
 706      * lookup class and the previous lookup class.
 707      * &lt;/caption&gt;
 708      * &lt;thead&gt;
 709      * &lt;tr&gt;
 710      * &lt;th scope=&quot;col&quot;&gt;Equally accessible types to {@code M0} and {@code M1}&lt;/th&gt;
 711      * &lt;/tr&gt;
 712      * &lt;/thead&gt;
 713      * &lt;tbody&gt;
 714      * &lt;tr&gt;
 715      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;unconditional-exported packages from {@code M1}&lt;/th&gt;
 716      * &lt;/tr&gt;
 717      * &lt;tr&gt;
 718      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;unconditional-exported packages from {@code M0} if {@code M1} reads {@code M0}&lt;/th&gt;
 719      * &lt;/tr&gt;
 720      * &lt;tr&gt;
 721      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;unconditional-exported packages from a third module {@code M2}
 722      * if both {@code M0} and {@code M1} read {@code M2}&lt;/th&gt;
 723      * &lt;/tr&gt;
 724      * &lt;tr&gt;
 725      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;qualified-exported packages from {@code M1} to {@code M0}&lt;/th&gt;
 726      * &lt;/tr&gt;
 727      * &lt;tr&gt;
 728      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;qualified-exported packages from {@code M0} to {@code M1}
 729      * if {@code M1} reads {@code M0}&lt;/th&gt;
 730      * &lt;/tr&gt;
 731      * &lt;tr&gt;
 732      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;qualified-exported packages from a third module {@code M2} to
 733      * both {@code M0} and {@code M1} if both {@code M0} and {@code M1} read {@code M2}&lt;/th&gt;
 734      * &lt;/tr&gt;
 735      * &lt;/tbody&gt;
 736      * &lt;/table&gt;
 737      *
 738      * &lt;h2&gt;&lt;a id=&quot;access-modes&quot;&gt;&lt;/a&gt;Access modes&lt;/h2&gt;
 739      *
 740      * The table below shows the access modes of a {@code Lookup} produced by
 741      * any of the following factory or transformation methods:
 742      * &lt;ul&gt;
<a name="1" id="anc1"></a><span class="line-modified"> 743      * &lt;li&gt;{@link #lookup() MethodHandles.lookup()}&lt;/li&gt;</span>
<span class="line-modified"> 744      * &lt;li&gt;{@link #publicLookup() MethodHandles.publicLookup()}&lt;/li&gt;</span>
<span class="line-modified"> 745      * &lt;li&gt;{@link #privateLookupIn(Class, Lookup) MethodHandles.privateLookupIn}&lt;/li&gt;</span>
<span class="line-modified"> 746      * &lt;li&gt;{@link Lookup#in}&lt;/li&gt;</span>
<span class="line-modified"> 747      * &lt;li&gt;{@link Lookup#dropLookupMode(int)}&lt;/li&gt;</span>
 748      * &lt;/ul&gt;
 749      *
 750      * &lt;table class=&quot;striped&quot;&gt;
 751      * &lt;caption style=&quot;display:none&quot;&gt;
 752      * Access mode summary
 753      * &lt;/caption&gt;
 754      * &lt;thead&gt;
 755      * &lt;tr&gt;
 756      * &lt;th scope=&quot;col&quot;&gt;Lookup object&lt;/th&gt;
 757      * &lt;th style=&quot;text-align:center&quot;&gt;protected&lt;/th&gt;
 758      * &lt;th style=&quot;text-align:center&quot;&gt;private&lt;/th&gt;
 759      * &lt;th style=&quot;text-align:center&quot;&gt;package&lt;/th&gt;
 760      * &lt;th style=&quot;text-align:center&quot;&gt;module&lt;/th&gt;
 761      * &lt;th style=&quot;text-align:center&quot;&gt;public&lt;/th&gt;
 762      * &lt;/tr&gt;
 763      * &lt;/thead&gt;
 764      * &lt;tbody&gt;
 765      * &lt;tr&gt;
 766      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL = MethodHandles.lookup()} in {@code C}&lt;/th&gt;
 767      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;
 768      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
 769      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 770      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 771      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 772      * &lt;/tr&gt;
 773      * &lt;tr&gt;
 774      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL.in(C1)} same package&lt;/th&gt;
 775      * &lt;td&gt;&lt;/td&gt;
 776      * &lt;td&gt;&lt;/td&gt;
 777      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 778      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 779      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 780      * &lt;/tr&gt;
 781      * &lt;tr&gt;
 782      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL.in(C1)} same module&lt;/th&gt;
 783      * &lt;td&gt;&lt;/td&gt;
 784      * &lt;td&gt;&lt;/td&gt;
 785      * &lt;td&gt;&lt;/td&gt;
 786      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 787      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 788      * &lt;/tr&gt;
 789      * &lt;tr&gt;
 790      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL.in(D)} different module&lt;/th&gt;
 791      * &lt;td&gt;&lt;/td&gt;
 792      * &lt;td&gt;&lt;/td&gt;
 793      * &lt;td&gt;&lt;/td&gt;
 794      * &lt;td&gt;&lt;/td&gt;
 795      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 796      * &lt;/tr&gt;
 797      * &lt;tr&gt;
 798      * &lt;td&gt;{@code CL.in(D).in(C)} hop back to module&lt;/td&gt;
 799      * &lt;td&gt;&lt;/td&gt;
 800      * &lt;td&gt;&lt;/td&gt;
 801      * &lt;td&gt;&lt;/td&gt;
 802      * &lt;td&gt;&lt;/td&gt;
 803      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 804      * &lt;/tr&gt;
 805      * &lt;tr&gt;
 806      * &lt;td&gt;{@code PRI1 = privateLookupIn(C1,CL)}&lt;/td&gt;
 807      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;
 808      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
 809      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 810      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 811      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 812      * &lt;/tr&gt;
 813      * &lt;tr&gt;
 814      * &lt;td&gt;{@code PRI1a = privateLookupIn(C,PRI1)}&lt;/td&gt;
 815      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;
 816      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
 817      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 818      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 819      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 820      * &lt;/tr&gt;
 821      * &lt;tr&gt;
 822      * &lt;td&gt;{@code PRI1.in(C1)} same package&lt;/td&gt;
 823      * &lt;td&gt;&lt;/td&gt;
 824      * &lt;td&gt;&lt;/td&gt;
 825      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 826      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 827      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 828      * &lt;/tr&gt;
 829      * &lt;tr&gt;
 830      * &lt;td&gt;{@code PRI1.in(C1)} different package&lt;/td&gt;
 831      * &lt;td&gt;&lt;/td&gt;
 832      * &lt;td&gt;&lt;/td&gt;
 833      * &lt;td&gt;&lt;/td&gt;
 834      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 835      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 836      * &lt;/tr&gt;
 837      * &lt;tr&gt;
 838      * &lt;td&gt;{@code PRI1.in(D)} different module&lt;/td&gt;
 839      * &lt;td&gt;&lt;/td&gt;
 840      * &lt;td&gt;&lt;/td&gt;
 841      * &lt;td&gt;&lt;/td&gt;
 842      * &lt;td&gt;&lt;/td&gt;
 843      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 844      * &lt;/tr&gt;
 845      * &lt;tr&gt;
 846      * &lt;td&gt;{@code PRI1.dropLookupMode(PROTECTED)}&lt;/td&gt;
 847      * &lt;td&gt;&lt;/td&gt;
 848      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
 849      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 850      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 851      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 852      * &lt;/tr&gt;
 853      * &lt;tr&gt;
 854      * &lt;td&gt;{@code PRI1.dropLookupMode(PRIVATE)}&lt;/td&gt;
 855      * &lt;td&gt;&lt;/td&gt;
 856      * &lt;td&gt;&lt;/td&gt;
 857      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 858      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 859      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 860      * &lt;/tr&gt;
 861      * &lt;tr&gt;
 862      * &lt;td&gt;{@code PRI1.dropLookupMode(PACKAGE)}&lt;/td&gt;
 863      * &lt;td&gt;&lt;/td&gt;
 864      * &lt;td&gt;&lt;/td&gt;
 865      * &lt;td&gt;&lt;/td&gt;
 866      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 867      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 868      * &lt;/tr&gt;
 869      * &lt;tr&gt;
 870      * &lt;td&gt;{@code PRI1.dropLookupMode(MODULE)}&lt;/td&gt;
 871      * &lt;td&gt;&lt;/td&gt;
 872      * &lt;td&gt;&lt;/td&gt;
 873      * &lt;td&gt;&lt;/td&gt;
 874      * &lt;td&gt;&lt;/td&gt;
 875      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 876      * &lt;/tr&gt;
 877      * &lt;tr&gt;
 878      * &lt;td&gt;{@code PRI1.dropLookupMode(PUBLIC)}&lt;/td&gt;
 879      * &lt;td&gt;&lt;/td&gt;
 880      * &lt;td&gt;&lt;/td&gt;
 881      * &lt;td&gt;&lt;/td&gt;
 882      * &lt;td&gt;&lt;/td&gt;
 883      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;
 884      * &lt;tr&gt;
 885      * &lt;td&gt;{@code PRI2 = privateLookupIn(D,CL)}&lt;/td&gt;
 886      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;
 887      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
 888      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 889      * &lt;td&gt;&lt;/td&gt;
 890      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 891      * &lt;/tr&gt;
 892      * &lt;tr&gt;
 893      * &lt;td&gt;{@code privateLookupIn(D,PRI1)}&lt;/td&gt;
 894      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;
 895      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
 896      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 897      * &lt;td&gt;&lt;/td&gt;
 898      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 899      * &lt;/tr&gt;
 900      * &lt;tr&gt;
 901      * &lt;td&gt;{@code privateLookupIn(C,PRI2)} fails&lt;/td&gt;
 902      * &lt;td&gt;&lt;/td&gt;
 903      * &lt;td&gt;&lt;/td&gt;
 904      * &lt;td&gt;&lt;/td&gt;
 905      * &lt;td&gt;&lt;/td&gt;
 906      * &lt;td style=&quot;text-align:center&quot;&gt;IAE&lt;/td&gt;
 907      * &lt;/tr&gt;
 908      * &lt;tr&gt;
 909      * &lt;td&gt;{@code PRI2.in(D2)} same package&lt;/td&gt;
 910      * &lt;td&gt;&lt;/td&gt;
 911      * &lt;td&gt;&lt;/td&gt;
 912      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 913      * &lt;td&gt;&lt;/td&gt;
 914      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 915      * &lt;/tr&gt;
 916      * &lt;tr&gt;
 917      * &lt;td&gt;{@code PRI2.in(D2)} different package&lt;/td&gt;
 918      * &lt;td&gt;&lt;/td&gt;
 919      * &lt;td&gt;&lt;/td&gt;
 920      * &lt;td&gt;&lt;/td&gt;
 921      * &lt;td&gt;&lt;/td&gt;
 922      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 923      * &lt;/tr&gt;
 924      * &lt;tr&gt;
 925      * &lt;td&gt;{@code PRI2.in(C1)} hop back to module&lt;/td&gt;
 926      * &lt;td&gt;&lt;/td&gt;
 927      * &lt;td&gt;&lt;/td&gt;
 928      * &lt;td&gt;&lt;/td&gt;
 929      * &lt;td&gt;&lt;/td&gt;
 930      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 931      * &lt;/tr&gt;
 932      * &lt;tr&gt;
 933      * &lt;td&gt;{@code PRI2.in(E)} hop to third module&lt;/td&gt;
 934      * &lt;td&gt;&lt;/td&gt;
 935      * &lt;td&gt;&lt;/td&gt;
 936      * &lt;td&gt;&lt;/td&gt;
 937      * &lt;td&gt;&lt;/td&gt;
 938      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;
 939      * &lt;/tr&gt;
 940      * &lt;tr&gt;
 941      * &lt;td&gt;{@code PRI2.dropLookupMode(PROTECTED)}&lt;/td&gt;
 942      * &lt;td&gt;&lt;/td&gt;
 943      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
 944      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 945      * &lt;td&gt;&lt;/td&gt;
 946      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 947      * &lt;/tr&gt;
 948      * &lt;tr&gt;
 949      * &lt;td&gt;{@code PRI2.dropLookupMode(PRIVATE)}&lt;/td&gt;
 950      * &lt;td&gt;&lt;/td&gt;
 951      * &lt;td&gt;&lt;/td&gt;
 952      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 953      * &lt;td&gt;&lt;/td&gt;
 954      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 955      * &lt;/tr&gt;
 956      * &lt;tr&gt;
 957      * &lt;td&gt;{@code PRI2.dropLookupMode(PACKAGE)}&lt;/td&gt;
 958      * &lt;td&gt;&lt;/td&gt;
 959      * &lt;td&gt;&lt;/td&gt;
 960      * &lt;td&gt;&lt;/td&gt;
 961      * &lt;td&gt;&lt;/td&gt;
 962      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 963      * &lt;/tr&gt;
 964      * &lt;tr&gt;
 965      * &lt;td&gt;{@code PRI2.dropLookupMode(MODULE)}&lt;/td&gt;
 966      * &lt;td&gt;&lt;/td&gt;
 967      * &lt;td&gt;&lt;/td&gt;
 968      * &lt;td&gt;&lt;/td&gt;
 969      * &lt;td&gt;&lt;/td&gt;
 970      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 971      * &lt;/tr&gt;
 972      * &lt;tr&gt;
 973      * &lt;td&gt;{@code PRI2.dropLookupMode(PUBLIC)}&lt;/td&gt;
 974      * &lt;td&gt;&lt;/td&gt;
 975      * &lt;td&gt;&lt;/td&gt;
 976      * &lt;td&gt;&lt;/td&gt;
 977      * &lt;td&gt;&lt;/td&gt;
 978      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;
 979      * &lt;/tr&gt;
 980      * &lt;tr&gt;
 981      * &lt;td&gt;{@code CL.dropLookupMode(PROTECTED)}&lt;/td&gt;
 982      * &lt;td&gt;&lt;/td&gt;
 983      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
 984      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 985      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 986      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 987      * &lt;/tr&gt;
 988      * &lt;tr&gt;
 989      * &lt;td&gt;{@code CL.dropLookupMode(PRIVATE)}&lt;/td&gt;
 990      * &lt;td&gt;&lt;/td&gt;
 991      * &lt;td&gt;&lt;/td&gt;
 992      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 993      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 994      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 995      * &lt;/tr&gt;
 996      * &lt;tr&gt;
 997      * &lt;td&gt;{@code CL.dropLookupMode(PACKAGE)}&lt;/td&gt;
 998      * &lt;td&gt;&lt;/td&gt;
 999      * &lt;td&gt;&lt;/td&gt;
1000      * &lt;td&gt;&lt;/td&gt;
1001      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
1002      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
1003      * &lt;/tr&gt;
1004      * &lt;tr&gt;
1005      * &lt;td&gt;{@code CL.dropLookupMode(MODULE)}&lt;/td&gt;
1006      * &lt;td&gt;&lt;/td&gt;
1007      * &lt;td&gt;&lt;/td&gt;
1008      * &lt;td&gt;&lt;/td&gt;
1009      * &lt;td&gt;&lt;/td&gt;
1010      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
1011      * &lt;/tr&gt;
1012      * &lt;tr&gt;
1013      * &lt;td&gt;{@code CL.dropLookupMode(PUBLIC)}&lt;/td&gt;
1014      * &lt;td&gt;&lt;/td&gt;
1015      * &lt;td&gt;&lt;/td&gt;
1016      * &lt;td&gt;&lt;/td&gt;
1017      * &lt;td&gt;&lt;/td&gt;
1018      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;
1019      * &lt;/tr&gt;
1020      * &lt;tr&gt;
1021      * &lt;td&gt;{@code PUB = publicLookup()}&lt;/td&gt;
1022      * &lt;td&gt;&lt;/td&gt;
1023      * &lt;td&gt;&lt;/td&gt;
1024      * &lt;td&gt;&lt;/td&gt;
1025      * &lt;td&gt;&lt;/td&gt;
1026      * &lt;td style=&quot;text-align:center&quot;&gt;U&lt;/td&gt;
1027      * &lt;/tr&gt;
1028      * &lt;tr&gt;
1029      * &lt;td&gt;{@code PUB.in(D)} different module&lt;/td&gt;
1030      * &lt;td&gt;&lt;/td&gt;
1031      * &lt;td&gt;&lt;/td&gt;
1032      * &lt;td&gt;&lt;/td&gt;
1033      * &lt;td&gt;&lt;/td&gt;
1034      * &lt;td style=&quot;text-align:center&quot;&gt;U&lt;/td&gt;
1035      * &lt;/tr&gt;
1036      * &lt;tr&gt;
1037      * &lt;td&gt;{@code PUB.in(D).in(E)} third module&lt;/td&gt;
1038      * &lt;td&gt;&lt;/td&gt;
1039      * &lt;td&gt;&lt;/td&gt;
1040      * &lt;td&gt;&lt;/td&gt;
1041      * &lt;td&gt;&lt;/td&gt;
1042      * &lt;td style=&quot;text-align:center&quot;&gt;U&lt;/td&gt;
1043      * &lt;/tr&gt;
1044      * &lt;tr&gt;
1045      * &lt;td&gt;{@code PUB.dropLookupMode(UNCONDITIONAL)}&lt;/td&gt;
1046      * &lt;td&gt;&lt;/td&gt;
1047      * &lt;td&gt;&lt;/td&gt;
1048      * &lt;td&gt;&lt;/td&gt;
1049      * &lt;td&gt;&lt;/td&gt;
1050      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;
1051      * &lt;/tr&gt;
1052      * &lt;tr&gt;
1053      * &lt;td&gt;{@code privateLookupIn(C1,PUB)} fails&lt;/td&gt;
1054      * &lt;td&gt;&lt;/td&gt;
1055      * &lt;td&gt;&lt;/td&gt;
1056      * &lt;td&gt;&lt;/td&gt;
1057      * &lt;td&gt;&lt;/td&gt;
1058      * &lt;td style=&quot;text-align:center&quot;&gt;IAE&lt;/td&gt;
1059      * &lt;/tr&gt;
1060      * &lt;tr&gt;
1061      * &lt;td&gt;{@code ANY.in(X)}, for inaccessible {@code X}&lt;/td&gt;
1062      * &lt;td&gt;&lt;/td&gt;
1063      * &lt;td&gt;&lt;/td&gt;
1064      * &lt;td&gt;&lt;/td&gt;
1065      * &lt;td&gt;&lt;/td&gt;
1066      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;
1067      * &lt;/tr&gt;
1068      * &lt;/tbody&gt;
1069      * &lt;/table&gt;
1070      *
1071      * &lt;p&gt;
1072      * Notes:
1073      * &lt;ul&gt;
1074      * &lt;li&gt;Class {@code C} and class {@code C1} are in module {@code M1},
1075      *     but {@code D} and {@code D2} are in module {@code M2}, and {@code E}
1076      *     is in module {@code M3}. {@code X} stands for class which is inaccessible
1077      *     to the lookup. {@code ANY} stands for any of the example lookups.&lt;/li&gt;
1078      * &lt;li&gt;{@code PRO} indicates {@link #PROTECTED} bit set,
1079      *     {@code PRI} indicates {@link #PRIVATE} bit set,
1080      *     {@code PAC} indicates {@link #PACKAGE} bit set,
1081      *     {@code MOD} indicates {@link #MODULE} bit set,
1082      *     {@code 1R} and {@code 2R} indicate {@link #PUBLIC} bit set,
1083      *     {@code U} indicates {@link #UNCONDITIONAL} bit set,
1084      *     {@code IAE} indicates {@code IllegalAccessException} thrown.&lt;/li&gt;
1085      * &lt;li&gt;Public access comes in three kinds:
1086      * &lt;ul&gt;
1087      * &lt;li&gt;unconditional ({@code U}): the lookup assumes readability.
1088      *     The lookup has {@code null} previous lookup class.
1089      * &lt;li&gt;one-module-reads ({@code 1R}): the module access checking is
1090      *     performed with respect to the lookup class.  The lookup has {@code null}
1091      *     previous lookup class.
1092      * &lt;li&gt;two-module-reads ({@code 2R}): the module access checking is
1093      *     performed with respect to the lookup class and the previous lookup class.
1094      *     The lookup has a non-null previous lookup class which is in a
1095      *     different module from the current lookup class.
1096      * &lt;/ul&gt;
1097      * &lt;li&gt;Any attempt to reach a third module loses all access.&lt;/li&gt;
1098      * &lt;li&gt;If a target class {@code X} is not accessible to {@code Lookup::in}
1099      * all access modes are dropped.&lt;/li&gt;
1100      * &lt;/ul&gt;
1101      *
1102      * &lt;h2&gt;&lt;a id=&quot;secmgr&quot;&gt;&lt;/a&gt;Security manager interactions&lt;/h2&gt;
1103      * Although bytecode instructions can only refer to classes in
1104      * a related class loader, this API can search for methods in any
1105      * class, as long as a reference to its {@code Class} object is
1106      * available.  Such cross-loader references are also possible with the
1107      * Core Reflection API, and are impossible to bytecode instructions
1108      * such as {@code invokestatic} or {@code getfield}.
1109      * There is a {@linkplain java.lang.SecurityManager security manager API}
1110      * to allow applications to check such cross-loader references.
1111      * These checks apply to both the {@code MethodHandles.Lookup} API
1112      * and the Core Reflection API
1113      * (as found on {@link java.lang.Class Class}).
1114      * &lt;p&gt;
1115      * If a security manager is present, member and class lookups are subject to
1116      * additional checks.
1117      * From one to three calls are made to the security manager.
1118      * Any of these calls can refuse access by throwing a
1119      * {@link java.lang.SecurityException SecurityException}.
1120      * Define {@code smgr} as the security manager,
1121      * {@code lookc} as the lookup class of the current lookup object,
1122      * {@code refc} as the containing class in which the member
1123      * is being sought, and {@code defc} as the class in which the
1124      * member is actually defined.
1125      * (If a class or other type is being accessed,
1126      * the {@code refc} and {@code defc} values are the class itself.)
1127      * The value {@code lookc} is defined as &lt;em&gt;not present&lt;/em&gt;
1128      * if the current lookup object does not have
1129      * {@linkplain #hasFullPrivilegeAccess() full privilege access}.
1130      * The calls are made according to the following rules:
1131      * &lt;ul&gt;
1132      * &lt;li&gt;&lt;b&gt;Step 1:&lt;/b&gt;
1133      *     If {@code lookc} is not present, or if its class loader is not
1134      *     the same as or an ancestor of the class loader of {@code refc},
1135      *     then {@link SecurityManager#checkPackageAccess
1136      *     smgr.checkPackageAccess(refcPkg)} is called,
1137      *     where {@code refcPkg} is the package of {@code refc}.
1138      * &lt;li&gt;&lt;b&gt;Step 2a:&lt;/b&gt;
1139      *     If the retrieved member is not public and
1140      *     {@code lookc} is not present, then
1141      *     {@link SecurityManager#checkPermission smgr.checkPermission}
1142      *     with {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)} is called.
1143      * &lt;li&gt;&lt;b&gt;Step 2b:&lt;/b&gt;
1144      *     If the retrieved class has a {@code null} class loader,
1145      *     and {@code lookc} is not present, then
1146      *     {@link SecurityManager#checkPermission smgr.checkPermission}
1147      *     with {@code RuntimePermission(&quot;getClassLoader&quot;)} is called.
1148      * &lt;li&gt;&lt;b&gt;Step 3:&lt;/b&gt;
1149      *     If the retrieved member is not public,
1150      *     and if {@code lookc} is not present,
1151      *     and if {@code defc} and {@code refc} are different,
1152      *     then {@link SecurityManager#checkPackageAccess
1153      *     smgr.checkPackageAccess(defcPkg)} is called,
1154      *     where {@code defcPkg} is the package of {@code defc}.
1155      * &lt;/ul&gt;
1156      * Security checks are performed after other access checks have passed.
1157      * Therefore, the above rules presuppose a member or class that is public,
1158      * or else that is being accessed from a lookup class that has
1159      * rights to access the member or class.
1160      * &lt;p&gt;
1161      * If a security manager is present and the current lookup object does not have
1162      * {@linkplain #hasFullPrivilegeAccess() full privilege access}, then
1163      * {@link #defineClass(byte[]) defineClass}
1164      * calls {@link SecurityManager#checkPermission smgr.checkPermission}
1165      * with {@code RuntimePermission(&quot;defineClass&quot;)}.
1166      *
1167      * &lt;h2&gt;&lt;a id=&quot;callsens&quot;&gt;&lt;/a&gt;Caller sensitive methods&lt;/h2&gt;
1168      * A small number of Java methods have a special property called caller sensitivity.
1169      * A &lt;em&gt;caller-sensitive&lt;/em&gt; method can behave differently depending on the
1170      * identity of its immediate caller.
1171      * &lt;p&gt;
1172      * If a method handle for a caller-sensitive method is requested,
1173      * the general rules for &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; apply,
1174      * but they take account of the lookup class in a special way.
1175      * The resulting method handle behaves as if it were called
1176      * from an instruction contained in the lookup class,
1177      * so that the caller-sensitive method detects the lookup class.
1178      * (By contrast, the invoker of the method handle is disregarded.)
1179      * Thus, in the case of caller-sensitive methods,
1180      * different lookup classes may give rise to
1181      * differently behaving method handles.
1182      * &lt;p&gt;
1183      * In cases where the lookup object is
1184      * {@link MethodHandles#publicLookup() publicLookup()},
1185      * or some other lookup object without the
1186      * {@linkplain #hasFullPrivilegeAccess() full privilege access},
1187      * the lookup class is disregarded.
1188      * In such cases, no caller-sensitive method handle can be created,
1189      * access is forbidden, and the lookup fails with an
1190      * {@code IllegalAccessException}.
1191      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
1192      * &lt;em&gt;Discussion:&lt;/em&gt;
1193      * For example, the caller-sensitive method
1194      * {@link java.lang.Class#forName(String) Class.forName(x)}
1195      * can return varying classes or throw varying exceptions,
1196      * depending on the class loader of the class that calls it.
1197      * A public lookup of {@code Class.forName} will fail, because
1198      * there is no reasonable way to determine its bytecode behavior.
1199      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
1200      * If an application caches method handles for broad sharing,
1201      * it should use {@code publicLookup()} to create them.
1202      * If there is a lookup of {@code Class.forName}, it will fail,
1203      * and the application must take appropriate action in that case.
1204      * It may be that a later lookup, perhaps during the invocation of a
1205      * bootstrap method, can incorporate the specific identity
1206      * of the caller, making the method accessible.
1207      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
1208      * The function {@code MethodHandles.lookup} is caller sensitive
1209      * so that there can be a secure foundation for lookups.
1210      * Nearly all other methods in the JSR 292 API rely on lookup
1211      * objects to check access requests.
1212      *
1213      * @revised 9
1214      */
1215     public static final
1216     class Lookup {
1217         /** The class on behalf of whom the lookup is being performed. */
1218         private final Class&lt;?&gt; lookupClass;
1219 
1220         /** previous lookup class */
1221         private final Class&lt;?&gt; prevLookupClass;
1222 
1223         /** The allowed sorts of members which may be looked up (PUBLIC, etc.). */
1224         private final int allowedModes;
1225 
1226         static {
1227             Reflection.registerFieldsToFilter(Lookup.class, Set.of(&quot;lookupClass&quot;, &quot;allowedModes&quot;));
1228         }
1229 
1230         /** A single-bit mask representing {@code public} access,
1231          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1232          *  The value, {@code 0x01}, happens to be the same as the value of the
1233          *  {@code public} {@linkplain java.lang.reflect.Modifier#PUBLIC modifier bit}.
1234          *  &lt;p&gt;
1235          *  A {@code Lookup} with this lookup mode performs cross-module access check
1236          *  with respect to the {@linkplain #lookupClass() lookup class} and
1237          *  {@linkplain #previousLookupClass() previous lookup class} if present.
1238          */
1239         public static final int PUBLIC = Modifier.PUBLIC;
1240 
1241         /** A single-bit mask representing {@code private} access,
1242          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1243          *  The value, {@code 0x02}, happens to be the same as the value of the
1244          *  {@code private} {@linkplain java.lang.reflect.Modifier#PRIVATE modifier bit}.
1245          */
1246         public static final int PRIVATE = Modifier.PRIVATE;
1247 
1248         /** A single-bit mask representing {@code protected} access,
1249          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1250          *  The value, {@code 0x04}, happens to be the same as the value of the
1251          *  {@code protected} {@linkplain java.lang.reflect.Modifier#PROTECTED modifier bit}.
1252          */
1253         public static final int PROTECTED = Modifier.PROTECTED;
1254 
1255         /** A single-bit mask representing {@code package} access (default access),
1256          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1257          *  The value is {@code 0x08}, which does not correspond meaningfully to
1258          *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
1259          */
1260         public static final int PACKAGE = Modifier.STATIC;
1261 
1262         /** A single-bit mask representing {@code module} access,
1263          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1264          *  The value is {@code 0x10}, which does not correspond meaningfully to
1265          *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
1266          *  In conjunction with the {@code PUBLIC} modifier bit, a {@code Lookup}
1267          *  with this lookup mode can access all public types in the module of the
1268          *  lookup class and public types in packages exported by other modules
1269          *  to the module of the lookup class.
1270          *  &lt;p&gt;
1271          *  If this lookup mode is set, the {@linkplain #previousLookupClass()
1272          *  previous lookup class} is always {@code null}.
1273          *
1274          *  @since 9
1275          *  @spec JPMS
1276          */
1277         public static final int MODULE = PACKAGE &lt;&lt; 1;
1278 
1279         /** A single-bit mask representing {@code unconditional} access
1280          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1281          *  The value is {@code 0x20}, which does not correspond meaningfully to
1282          *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
1283          *  A {@code Lookup} with this lookup mode assumes {@linkplain
1284          *  java.lang.Module#canRead(java.lang.Module) readability}.
1285          *  This lookup mode can access all public members of public types
1286          *  of all modules when the type is in a package that is {@link
1287          *  java.lang.Module#isExported(String) exported unconditionally}.
1288          *
1289          *  &lt;p&gt;
1290          *  If this lookup mode is set, the {@linkplain #previousLookupClass()
1291          *  previous lookup class} is always {@code null}.
1292          *
1293          *  @since 9
1294          *  @spec JPMS
1295          *  @see #publicLookup()
1296          */
1297         public static final int UNCONDITIONAL = PACKAGE &lt;&lt; 2;
1298 
1299         private static final int ALL_MODES = (PUBLIC | PRIVATE | PROTECTED | PACKAGE | MODULE | UNCONDITIONAL);
1300         private static final int FULL_POWER_MODES = (ALL_MODES &amp; ~UNCONDITIONAL);
1301         private static final int TRUSTED   = -1;
1302 
1303         /*
1304          * Adjust PUBLIC =&gt; PUBLIC|MODULE|UNCONDITIONAL
1305          * Adjust 0 =&gt; PACKAGE
1306          */
1307         private static int fixmods(int mods) {
1308             mods &amp;= (ALL_MODES - PACKAGE - MODULE - UNCONDITIONAL);
1309             if (Modifier.isPublic(mods))
1310                 mods |= UNCONDITIONAL;
1311             return (mods != 0) ? mods : PACKAGE;
1312         }
1313 
1314         /** Tells which class is performing the lookup.  It is this class against
1315          *  which checks are performed for visibility and access permissions.
1316          *  &lt;p&gt;
1317          *  If this lookup object has a {@linkplain #previousLookupClass() previous lookup class},
1318          *  access checks are performed against both the lookup class and the previous lookup class.
1319          *  &lt;p&gt;
1320          *  The class implies a maximum level of access permission,
1321          *  but the permissions may be additionally limited by the bitmask
1322          *  {@link #lookupModes lookupModes}, which controls whether non-public members
1323          *  can be accessed.
1324          *  @return the lookup class, on behalf of which this lookup object finds members
1325          *  @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
1326          */
1327         public Class&lt;?&gt; lookupClass() {
1328             return lookupClass;
1329         }
1330 
1331         /** Reports a lookup class in another module that this lookup object
1332          * was previously teleported from, or {@code null}.
1333          * &lt;p&gt;
1334          * A {@code Lookup} object produced by the factory methods, such as the
1335          * {@link #lookup() lookup()} and {@link #publicLookup() publicLookup()} method,
1336          * has {@code null} previous lookup class.
1337          * A {@code Lookup} object has a non-null previous lookup class
1338          * when this lookup was teleported from an old lookup class
1339          * in one module to a new lookup class in another module.
1340          *
1341          * @return the lookup class in another module that this lookup object was
1342          *         previously teleported from, or {@code null}
1343          * @since 14
1344          * @see #in(Class)
1345          * @see MethodHandles#privateLookupIn(Class, Lookup)
1346          * @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
1347          */
1348         public Class&lt;?&gt; previousLookupClass() {
1349             return prevLookupClass;
1350         }
1351 
1352         // This is just for calling out to MethodHandleImpl.
1353         private Class&lt;?&gt; lookupClassOrNull() {
1354             if (allowedModes == TRUSTED) {
1355                 return null;
1356             }
1357             if (allowedModes == UNCONDITIONAL) {
1358                 // use Object as the caller to pass to VM doing resolution
1359                 return Object.class;
1360             }
1361             return lookupClass;
1362         }
1363 
1364         /** Tells which access-protection classes of members this lookup object can produce.
1365          *  The result is a bit-mask of the bits
1366          *  {@linkplain #PUBLIC PUBLIC (0x01)},
1367          *  {@linkplain #PRIVATE PRIVATE (0x02)},
1368          *  {@linkplain #PROTECTED PROTECTED (0x04)},
1369          *  {@linkplain #PACKAGE PACKAGE (0x08)},
1370          *  {@linkplain #MODULE MODULE (0x10)},
1371          *  and {@linkplain #UNCONDITIONAL UNCONDITIONAL (0x20)}.
1372          *  &lt;p&gt;
1373          *  A freshly-created lookup object
1374          *  on the {@linkplain java.lang.invoke.MethodHandles#lookup() caller&#39;s class} has
1375          *  all possible bits set, except {@code UNCONDITIONAL}.
1376          *  A lookup object on a new lookup class
1377          *  {@linkplain java.lang.invoke.MethodHandles.Lookup#in created from a previous lookup object}
1378          *  may have some mode bits set to zero.
1379          *  Mode bits can also be
1380          *  {@linkplain java.lang.invoke.MethodHandles.Lookup#dropLookupMode directly cleared}.
1381          *  Once cleared, mode bits cannot be restored from the downgraded lookup object.
1382          *  The purpose of this is to restrict access via the new lookup object,
1383          *  so that it can access only names which can be reached by the original
1384          *  lookup object, and also by the new lookup class.
1385          *  @return the lookup modes, which limit the kinds of access performed by this lookup object
1386          *  @see #in
1387          *  @see #dropLookupMode
1388          *
1389          *  @revised 9
1390          *  @spec JPMS
1391          */
1392         public int lookupModes() {
1393             return allowedModes &amp; ALL_MODES;
1394         }
1395 
1396         /** Embody the current class (the lookupClass) as a lookup class
1397          * for method handle creation.
1398          * Must be called by from a method in this package,
1399          * which in turn is called by a method not in this package.
1400          */
1401         Lookup(Class&lt;?&gt; lookupClass) {
1402             this(lookupClass, null, FULL_POWER_MODES);
1403             // make sure we haven&#39;t accidentally picked up a privileged class:
1404             checkUnprivilegedlookupClass(lookupClass);
1405         }
1406 
1407         private Lookup(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int allowedModes) {
1408             assert prevLookupClass == null || ((allowedModes &amp; MODULE) == 0
1409                     &amp;&amp; prevLookupClass.getModule() != lookupClass.getModule());
1410             assert !lookupClass.isArray() &amp;&amp; !lookupClass.isPrimitive();
1411             this.lookupClass = lookupClass;
1412             this.prevLookupClass = prevLookupClass;
1413             this.allowedModes = allowedModes;
1414         }
1415 
1416         private static Lookup newLookup(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int allowedModes) {
1417             // make sure we haven&#39;t accidentally picked up a privileged class:
1418             checkUnprivilegedlookupClass(lookupClass);
1419             return new Lookup(lookupClass, prevLookupClass, allowedModes);
1420         }
1421 
1422         /**
1423          * Creates a lookup on the specified new lookup class.
1424          * The resulting object will report the specified
1425          * class as its own {@link #lookupClass() lookupClass}.
1426          *
1427          * &lt;p&gt;
1428          * However, the resulting {@code Lookup} object is guaranteed
1429          * to have no more access capabilities than the original.
1430          * In particular, access capabilities can be lost as follows:&lt;ul&gt;
1431          * &lt;li&gt;If the new lookup class is in a different module from the old one,
1432          * i.e. {@link #MODULE MODULE} access is lost.
1433          * &lt;li&gt;If the new lookup class is in a different package
1434          * than the old one, protected and default (package) members will not be accessible,
1435          * i.e. {@link #PROTECTED PROTECTED} and {@link #PACKAGE PACKAGE} access are lost.
1436          * &lt;li&gt;If the new lookup class is not within the same package member
1437          * as the old one, private members will not be accessible, and protected members
1438          * will not be accessible by virtue of inheritance,
1439          * i.e. {@link #PRIVATE PRIVATE} access is lost.
1440          * (Protected members may continue to be accessible because of package sharing.)
1441          * &lt;li&gt;If the new lookup class is not
1442          * {@linkplain #accessClass(Class) accessible} to this lookup,
1443          * then no members, not even public members, will be accessible
1444          * i.e. all access modes are lost.
1445          * &lt;li&gt;If the new lookup class, the old lookup class and the previous lookup class
1446          * are all in different modules i.e. teleporting to a third module,
1447          * all access modes are lost.
1448          * &lt;/ul&gt;
1449          * &lt;p&gt;
1450          * The new previous lookup class is chosen as follows:
1451          * &lt;ul&gt;
1452          * &lt;li&gt;If the new lookup object has {@link #UNCONDITIONAL UNCONDITIONAL} bit,
1453          * the new previous lookup class is {@code null}.
1454          * &lt;li&gt;If the new lookup class is in the same module as the old lookup class,
1455          * the new previous lookup class is the old previous lookup class.
1456          * &lt;li&gt;If the new lookup class is in a different module from the old lookup class,
1457          * the new previous lookup class is the old lookup class.
1458          *&lt;/ul&gt;
1459          * &lt;p&gt;
1460          * The resulting lookup&#39;s capabilities for loading classes
1461          * (used during {@link #findClass} invocations)
1462          * are determined by the lookup class&#39; loader,
1463          * which may change due to this operation.
1464          * &lt;p&gt;
1465          * @param requestedLookupClass the desired lookup class for the new lookup object
1466          * @return a lookup object which reports the desired lookup class, or the same object
1467          * if there is no change
1468          * @throws IllegalArgumentException if {@code requestedLookupClass} is a primitive type or void or array class
1469          * @throws NullPointerException if the argument is null
1470          *
1471          * @revised 9
1472          * @spec JPMS
1473          * @see #accessClass(Class)
1474          * @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
1475          */
1476         public Lookup in(Class&lt;?&gt; requestedLookupClass) {
1477             Objects.requireNonNull(requestedLookupClass);
1478             if (requestedLookupClass.isPrimitive())
1479                 throw new IllegalArgumentException(requestedLookupClass + &quot; is a primitive class&quot;);
1480             if (requestedLookupClass.isArray())
1481                 throw new IllegalArgumentException(requestedLookupClass + &quot; is an array class&quot;);
1482 
1483             if (allowedModes == TRUSTED)  // IMPL_LOOKUP can make any lookup at all
1484                 return new Lookup(requestedLookupClass, null, FULL_POWER_MODES);
1485             if (requestedLookupClass == this.lookupClass)
1486                 return this;  // keep same capabilities
1487             int newModes = (allowedModes &amp; FULL_POWER_MODES);
1488             Module fromModule = this.lookupClass.getModule();
1489             Module targetModule = requestedLookupClass.getModule();
1490             Class&lt;?&gt; plc = this.previousLookupClass();
1491             if ((this.allowedModes &amp; UNCONDITIONAL) != 0) {
1492                 assert plc == null;
1493                 newModes = UNCONDITIONAL;
1494             } else if (fromModule != targetModule) {
1495                 if (plc != null &amp;&amp; !VerifyAccess.isSameModule(plc, requestedLookupClass)) {
1496                     // allow hopping back and forth between fromModule and plc&#39;s module
1497                     // but not the third module
1498                     newModes = 0;
1499                 }
1500                 // drop MODULE access
1501                 newModes &amp;= ~(MODULE|PACKAGE|PRIVATE|PROTECTED);
1502                 // teleport from this lookup class
1503                 plc = this.lookupClass;
1504             }
1505             if ((newModes &amp; PACKAGE) != 0
1506                 &amp;&amp; !VerifyAccess.isSamePackage(this.lookupClass, requestedLookupClass)) {
1507                 newModes &amp;= ~(PACKAGE|PRIVATE|PROTECTED);
1508             }
1509             // Allow nestmate lookups to be created without special privilege:
1510             if ((newModes &amp; PRIVATE) != 0
1511                 &amp;&amp; !VerifyAccess.isSamePackageMember(this.lookupClass, requestedLookupClass)) {
1512                 newModes &amp;= ~(PRIVATE|PROTECTED);
1513             }
1514             if ((newModes &amp; (PUBLIC|UNCONDITIONAL)) != 0
1515                 &amp;&amp; !VerifyAccess.isClassAccessible(requestedLookupClass, this.lookupClass, this.prevLookupClass, allowedModes)) {
1516                 // The requested class it not accessible from the lookup class.
1517                 // No permissions.
1518                 newModes = 0;
1519             }
1520             return newLookup(requestedLookupClass, plc, newModes);
1521         }
1522 
1523         /**
1524          * Creates a lookup on the same lookup class which this lookup object
1525          * finds members, but with a lookup mode that has lost the given lookup mode.
1526          * The lookup mode to drop is one of {@link #PUBLIC PUBLIC}, {@link #MODULE
<a name="2" id="anc2"></a><span class="line-modified">1527          * MODULE}, {@link #PACKAGE PACKAGE}, {@link #PROTECTED PROTECTED} or {@link #PRIVATE PRIVATE}.</span>
<span class="line-modified">1528          * {@link #PROTECTED PROTECTED} is always</span>
<span class="line-modified">1529          * dropped and so the resulting lookup mode will never have this access capability.</span>
<span class="line-modified">1530          * When dropping {@code PACKAGE} then the resulting lookup will not have {@code PACKAGE}</span>
<span class="line-modified">1531          * or {@code PRIVATE} access. When dropping {@code MODULE} then the resulting lookup will</span>
<span class="line-modified">1532          * not have {@code MODULE}, {@code PACKAGE}, or {@code PRIVATE} access. If {@code PUBLIC}</span>
<span class="line-modified">1533          * is dropped then the resulting lookup has no access. If {@code UNCONDITIONAL}</span>
<span class="line-modified">1534          * is dropped then the resulting lookup has no access.</span>








1535          *
1536          * @apiNote
1537          * A lookup with {@code PACKAGE} but not {@code PRIVATE} mode can safely
1538          * delegate non-public access within the package of the lookup class without
1539          * conferring  &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;.
1540          * A lookup with {@code MODULE} but not
1541          * {@code PACKAGE} mode can safely delegate {@code PUBLIC} access within
1542          * the module of the lookup class without conferring package access.
1543          * A lookup with a {@linkplain #previousLookupClass() previous lookup class}
1544          * (and {@code PUBLIC} but not {@code MODULE} mode) can safely delegate access
1545          * to public classes accessible to both the module of the lookup class
1546          * and the module of the previous lookup class.
1547          *
1548          * @param modeToDrop the lookup mode to drop
1549          * @return a lookup object which lacks the indicated mode, or the same object if there is no change
1550          * @throws IllegalArgumentException if {@code modeToDrop} is not one of {@code PUBLIC},
1551          * {@code MODULE}, {@code PACKAGE}, {@code PROTECTED}, {@code PRIVATE} or {@code UNCONDITIONAL}
1552          * @see MethodHandles#privateLookupIn
1553          * @since 9
1554          */
1555         public Lookup dropLookupMode(int modeToDrop) {
1556             int oldModes = lookupModes();
1557             int newModes = oldModes &amp; ~(modeToDrop | PROTECTED);
1558             switch (modeToDrop) {
1559                 case PUBLIC: newModes &amp;= ~(FULL_POWER_MODES); break;
1560                 case MODULE: newModes &amp;= ~(PACKAGE | PRIVATE); break;
1561                 case PACKAGE: newModes &amp;= ~(PRIVATE); break;
1562                 case PROTECTED:
1563                 case PRIVATE:
1564                 case UNCONDITIONAL: break;
1565                 default: throw new IllegalArgumentException(modeToDrop + &quot; is not a valid mode to drop&quot;);
1566             }
1567             if (newModes == oldModes) return this;  // return self if no change
1568             return newLookup(lookupClass(), previousLookupClass(), newModes);
1569         }
1570 
1571         /**
1572          * Defines a class to the same class loader and in the same runtime package and
1573          * {@linkplain java.security.ProtectionDomain protection domain} as this lookup&#39;s
1574          * {@linkplain #lookupClass() lookup class}.
1575          *
1576          * &lt;p&gt; The {@linkplain #lookupModes() lookup modes} for this lookup must include
1577          * {@link #PACKAGE PACKAGE} access as default (package) members will be
1578          * accessible to the class. The {@code PACKAGE} lookup mode serves to authenticate
1579          * that the lookup object was created by a caller in the runtime package (or derived
1580          * from a lookup originally created by suitably privileged code to a target class in
1581          * the runtime package). &lt;/p&gt;
1582          *
1583          * &lt;p&gt; The {@code bytes} parameter is the class bytes of a valid class file (as defined
1584          * by the &lt;em&gt;The Java Virtual Machine Specification&lt;/em&gt;) with a class name in the
1585          * same package as the lookup class. &lt;/p&gt;
1586          *
1587          * &lt;p&gt; This method does not run the class initializer. The class initializer may
1588          * run at a later time, as detailed in section 12.4 of the &lt;em&gt;The Java Language
1589          * Specification&lt;/em&gt;. &lt;/p&gt;
1590          *
1591          * &lt;p&gt; If there is a security manager and this lookup does not have {@linkplain
1592          * #hasFullPrivilegeAccess() full privilege access}, its {@code checkPermission} method
1593          * is first called to check {@code RuntimePermission(&quot;defineClass&quot;)}. &lt;/p&gt;
1594          *
1595          * @param bytes the class bytes
1596          * @return the {@code Class} object for the class
1597          * @throws IllegalArgumentException the bytes are for a class in a different package
1598          * to the lookup class
1599          * @throws IllegalAccessException if this lookup does not have {@code PACKAGE} access
1600          * @throws LinkageError if the class is malformed ({@code ClassFormatError}), cannot be
1601          * verified ({@code VerifyError}), is already defined, or another linkage error occurs
1602          * @throws SecurityException if a security manager is present and it
1603          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1604          * @throws NullPointerException if {@code bytes} is {@code null}
1605          * @since 9
1606          * @spec JPMS
1607          * @see Lookup#privateLookupIn
1608          * @see Lookup#dropLookupMode
1609          * @see ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)
1610          */
1611         public Class&lt;?&gt; defineClass(byte[] bytes) throws IllegalAccessException {
1612             if (!hasFullPrivilegeAccess()) {
1613                 SecurityManager sm = System.getSecurityManager();
1614                 if (sm != null)
1615                     sm.checkPermission(new RuntimePermission(&quot;defineClass&quot;));
1616             }
1617             if ((lookupModes() &amp; PACKAGE) == 0)
1618                 throw new IllegalAccessException(&quot;Lookup does not have PACKAGE access&quot;);
1619 
1620             // parse class bytes to get class name (in internal form)
1621             bytes = bytes.clone();
1622             String name;
1623             try {
1624                 ClassReader reader = new ClassReader(bytes);
1625                 name = reader.getClassName();
1626             } catch (RuntimeException e) {
1627                 // ASM exceptions are poorly specified
1628                 ClassFormatError cfe = new ClassFormatError();
1629                 cfe.initCause(e);
1630                 throw cfe;
1631             }
1632 
1633             // get package and class name in binary form
1634             String cn, pn;
1635             int index = name.lastIndexOf(&#39;/&#39;);
1636             if (index == -1) {
1637                 cn = name;
1638                 pn = &quot;&quot;;
1639             } else {
1640                 cn = name.replace(&#39;/&#39;, &#39;.&#39;);
1641                 pn = cn.substring(0, index);
1642             }
1643             if (!pn.equals(lookupClass.getPackageName())) {
1644                 throw new IllegalArgumentException(&quot;Class not in same package as lookup class&quot;);
1645             }
1646 
1647             // invoke the class loader&#39;s defineClass method
1648             ClassLoader loader = lookupClass.getClassLoader();
1649             ProtectionDomain pd = (loader != null) ? lookupClassProtectionDomain() : null;
1650             String source = &quot;__Lookup_defineClass__&quot;;
1651             Class&lt;?&gt; clazz = SharedSecrets.getJavaLangAccess().defineClass(loader, cn, bytes, pd, source);
1652             return clazz;
1653         }
1654 
1655         private ProtectionDomain lookupClassProtectionDomain() {
1656             ProtectionDomain pd = cachedProtectionDomain;
1657             if (pd == null) {
1658                 cachedProtectionDomain = pd = protectionDomain(lookupClass);
1659             }
1660             return pd;
1661         }
1662 
1663         private ProtectionDomain protectionDomain(Class&lt;?&gt; clazz) {
1664             PrivilegedAction&lt;ProtectionDomain&gt; pa = clazz::getProtectionDomain;
1665             return AccessController.doPrivileged(pa);
1666         }
1667 
1668         // cached protection domain
1669         private volatile ProtectionDomain cachedProtectionDomain;
1670 
1671 
1672         // Make sure outer class is initialized first.
1673         static { IMPL_NAMES.getClass(); }
1674 
1675         /** Package-private version of lookup which is trusted. */
1676         static final Lookup IMPL_LOOKUP = new Lookup(Object.class, null, TRUSTED);
1677 
1678         /** Version of lookup which is trusted minimally.
1679          *  It can only be used to create method handles to publicly accessible
1680          *  members in packages that are exported unconditionally.
1681          */
1682         static final Lookup PUBLIC_LOOKUP = new Lookup(Object.class, null, UNCONDITIONAL);
1683 
1684         private static void checkUnprivilegedlookupClass(Class&lt;?&gt; lookupClass) {
1685             String name = lookupClass.getName();
1686             if (name.startsWith(&quot;java.lang.invoke.&quot;))
1687                 throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+lookupClass);
1688         }
1689 
1690         /**
1691          * Displays the name of the class from which lookups are to be made.
1692          * followed with &quot;/&quot; and the name of the {@linkplain #previousLookupClass()
1693          * previous lookup class} if present.
1694          * (The name is the one reported by {@link java.lang.Class#getName() Class.getName}.)
1695          * If there are restrictions on the access permitted to this lookup,
1696          * this is indicated by adding a suffix to the class name, consisting
1697          * of a slash and a keyword.  The keyword represents the strongest
1698          * allowed access, and is chosen as follows:
1699          * &lt;ul&gt;
1700          * &lt;li&gt;If no access is allowed, the suffix is &quot;/noaccess&quot;.
1701          * &lt;li&gt;If only unconditional access is allowed, the suffix is &quot;/publicLookup&quot;.
1702          * &lt;li&gt;If only public access to types in exported packages is allowed, the suffix is &quot;/public&quot;.
1703          * &lt;li&gt;If only public and module access are allowed, the suffix is &quot;/module&quot;.
1704          * &lt;li&gt;If public and package access are allowed, the suffix is &quot;/package&quot;.
1705          * &lt;li&gt;If public, package, and private access are allowed, the suffix is &quot;/private&quot;.
1706          * &lt;/ul&gt;
1707          * If none of the above cases apply, it is the case that full access
1708          * (public, module, package, private, and protected) is allowed.
1709          * In this case, no suffix is added.
1710          * This is true only of an object obtained originally from
1711          * {@link java.lang.invoke.MethodHandles#lookup MethodHandles.lookup}.
1712          * Objects created by {@link java.lang.invoke.MethodHandles.Lookup#in Lookup.in}
1713          * always have restricted access, and will display a suffix.
1714          * &lt;p&gt;
1715          * (It may seem strange that protected access should be
1716          * stronger than private access.  Viewed independently from
1717          * package access, protected access is the first to be lost,
1718          * because it requires a direct subclass relationship between
1719          * caller and callee.)
1720          * @see #in
1721          *
1722          * @revised 9
1723          * @spec JPMS
1724          */
1725         @Override
1726         public String toString() {
1727             String cname = lookupClass.getName();
1728             if (prevLookupClass != null)
1729                 cname += &quot;/&quot; + prevLookupClass.getName();
1730             switch (allowedModes) {
1731             case 0:  // no privileges
1732                 return cname + &quot;/noaccess&quot;;
1733             case UNCONDITIONAL:
1734                 return cname + &quot;/publicLookup&quot;;
1735             case PUBLIC:
1736                 return cname + &quot;/public&quot;;
1737             case PUBLIC|MODULE:
1738                 return cname + &quot;/module&quot;;
1739             case PUBLIC|PACKAGE:
1740             case PUBLIC|MODULE|PACKAGE:
1741                 return cname + &quot;/package&quot;;
1742             case FULL_POWER_MODES &amp; (~PROTECTED):
1743             case FULL_POWER_MODES &amp; ~(PROTECTED|MODULE):
1744                     return cname + &quot;/private&quot;;
1745             case FULL_POWER_MODES:
1746             case FULL_POWER_MODES &amp; (~MODULE):
1747                 return cname;
1748             case TRUSTED:
1749                 return &quot;/trusted&quot;;  // internal only; not exported
1750             default:  // Should not happen, but it&#39;s a bitfield...
1751                 cname = cname + &quot;/&quot; + Integer.toHexString(allowedModes);
1752                 assert(false) : cname;
1753                 return cname;
1754             }
1755         }
1756 
1757         /**
1758          * Produces a method handle for a static method.
1759          * The type of the method handle will be that of the method.
1760          * (Since static methods do not take receivers, there is no
1761          * additional receiver argument inserted into the method handle type,
1762          * as there would be with {@link #findVirtual findVirtual} or {@link #findSpecial findSpecial}.)
1763          * The method and all its argument types must be accessible to the lookup object.
1764          * &lt;p&gt;
1765          * The returned method handle will have
1766          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
1767          * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
1768          * &lt;p&gt;
1769          * If the returned method handle is invoked, the method&#39;s class will
1770          * be initialized, if it has not already been initialized.
1771          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
1772          * &lt;blockquote&gt;&lt;pre&gt;{@code
1773 import static java.lang.invoke.MethodHandles.*;
1774 import static java.lang.invoke.MethodType.*;
1775 ...
1776 MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
1777   &quot;asList&quot;, methodType(List.class, Object[].class));
1778 assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
1779          * }&lt;/pre&gt;&lt;/blockquote&gt;
1780          * @param refc the class from which the method is accessed
1781          * @param name the name of the method
1782          * @param type the type of the method
1783          * @return the desired method handle
1784          * @throws NoSuchMethodException if the method does not exist
1785          * @throws IllegalAccessException if access checking fails,
1786          *                                or if the method is not {@code static},
1787          *                                or if the method&#39;s variable arity modifier bit
1788          *                                is set and {@code asVarargsCollector} fails
1789          * @throws    SecurityException if a security manager is present and it
1790          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1791          * @throws NullPointerException if any argument is null
1792          */
1793         public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
1794             MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);
1795             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerLookup(method));
1796         }
1797 
1798         /**
1799          * Produces a method handle for a virtual method.
1800          * The type of the method handle will be that of the method,
1801          * with the receiver type (usually {@code refc}) prepended.
1802          * The method and all its argument types must be accessible to the lookup object.
1803          * &lt;p&gt;
1804          * When called, the handle will treat the first argument as a receiver
1805          * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
1806          * implementation to enter.
1807          * For private methods the named method in {@code refc} will be invoked on the receiver.
1808          * (The dispatching action is identical with that performed by an
1809          * {@code invokevirtual} or {@code invokeinterface} instruction.)
1810          * &lt;p&gt;
1811          * The first argument will be of type {@code refc} if the lookup
1812          * class has full privileges to access the member.  Otherwise
1813          * the member must be {@code protected} and the first argument
1814          * will be restricted in type to the lookup class.
1815          * &lt;p&gt;
1816          * The returned method handle will have
1817          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
1818          * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
1819          * &lt;p&gt;
1820          * Because of the general &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;equivalence&lt;/a&gt; between {@code invokevirtual}
1821          * instructions and method handles produced by {@code findVirtual},
1822          * if the class is {@code MethodHandle} and the name string is
1823          * {@code invokeExact} or {@code invoke}, the resulting
1824          * method handle is equivalent to one produced by
1825          * {@link java.lang.invoke.MethodHandles#exactInvoker MethodHandles.exactInvoker} or
1826          * {@link java.lang.invoke.MethodHandles#invoker MethodHandles.invoker}
1827          * with the same {@code type} argument.
1828          * &lt;p&gt;
1829          * If the class is {@code VarHandle} and the name string corresponds to
1830          * the name of a signature-polymorphic access mode method, the resulting
1831          * method handle is equivalent to one produced by
1832          * {@link java.lang.invoke.MethodHandles#varHandleInvoker} with
1833          * the access mode corresponding to the name string and with the same
1834          * {@code type} arguments.
1835          * &lt;p&gt;
1836          * &lt;b&gt;Example:&lt;/b&gt;
1837          * &lt;blockquote&gt;&lt;pre&gt;{@code
1838 import static java.lang.invoke.MethodHandles.*;
1839 import static java.lang.invoke.MethodType.*;
1840 ...
1841 MethodHandle MH_concat = publicLookup().findVirtual(String.class,
1842   &quot;concat&quot;, methodType(String.class, String.class));
1843 MethodHandle MH_hashCode = publicLookup().findVirtual(Object.class,
1844   &quot;hashCode&quot;, methodType(int.class));
1845 MethodHandle MH_hashCode_String = publicLookup().findVirtual(String.class,
1846   &quot;hashCode&quot;, methodType(int.class));
1847 assertEquals(&quot;xy&quot;, (String) MH_concat.invokeExact(&quot;x&quot;, &quot;y&quot;));
1848 assertEquals(&quot;xy&quot;.hashCode(), (int) MH_hashCode.invokeExact((Object)&quot;xy&quot;));
1849 assertEquals(&quot;xy&quot;.hashCode(), (int) MH_hashCode_String.invokeExact(&quot;xy&quot;));
1850 // interface method:
1851 MethodHandle MH_subSequence = publicLookup().findVirtual(CharSequence.class,
1852   &quot;subSequence&quot;, methodType(CharSequence.class, int.class, int.class));
1853 assertEquals(&quot;def&quot;, MH_subSequence.invoke(&quot;abcdefghi&quot;, 3, 6).toString());
1854 // constructor &quot;internal method&quot; must be accessed differently:
1855 MethodType MT_newString = methodType(void.class); //()V for new String()
1856 try { assertEquals(&quot;impossible&quot;, lookup()
1857         .findVirtual(String.class, &quot;&lt;init&gt;&quot;, MT_newString));
1858  } catch (NoSuchMethodException ex) { } // OK
1859 MethodHandle MH_newString = publicLookup()
1860   .findConstructor(String.class, MT_newString);
1861 assertEquals(&quot;&quot;, (String) MH_newString.invokeExact());
1862          * }&lt;/pre&gt;&lt;/blockquote&gt;
1863          *
1864          * @param refc the class or interface from which the method is accessed
1865          * @param name the name of the method
1866          * @param type the type of the method, with the receiver argument omitted
1867          * @return the desired method handle
1868          * @throws NoSuchMethodException if the method does not exist
1869          * @throws IllegalAccessException if access checking fails,
1870          *                                or if the method is {@code static},
1871          *                                or if the method&#39;s variable arity modifier bit
1872          *                                is set and {@code asVarargsCollector} fails
1873          * @throws    SecurityException if a security manager is present and it
1874          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1875          * @throws NullPointerException if any argument is null
1876          */
1877         public MethodHandle findVirtual(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
1878             if (refc == MethodHandle.class) {
1879                 MethodHandle mh = findVirtualForMH(name, type);
1880                 if (mh != null)  return mh;
1881             } else if (refc == VarHandle.class) {
1882                 MethodHandle mh = findVirtualForVH(name, type);
1883                 if (mh != null)  return mh;
1884             }
1885             byte refKind = (refc.isInterface() ? REF_invokeInterface : REF_invokeVirtual);
1886             MemberName method = resolveOrFail(refKind, refc, name, type);
1887             return getDirectMethod(refKind, refc, method, findBoundCallerLookup(method));
1888         }
1889         private MethodHandle findVirtualForMH(String name, MethodType type) {
1890             // these names require special lookups because of the implicit MethodType argument
1891             if (&quot;invoke&quot;.equals(name))
1892                 return invoker(type);
1893             if (&quot;invokeExact&quot;.equals(name))
1894                 return exactInvoker(type);
1895             assert(!MemberName.isMethodHandleInvokeName(name));
1896             return null;
1897         }
1898         private MethodHandle findVirtualForVH(String name, MethodType type) {
1899             try {
1900                 return varHandleInvoker(VarHandle.AccessMode.valueFromMethodName(name), type);
1901             } catch (IllegalArgumentException e) {
1902                 return null;
1903             }
1904         }
1905 
1906         /**
1907          * Produces a method handle which creates an object and initializes it, using
1908          * the constructor of the specified type.
1909          * The parameter types of the method handle will be those of the constructor,
1910          * while the return type will be a reference to the constructor&#39;s class.
1911          * The constructor and all its argument types must be accessible to the lookup object.
1912          * &lt;p&gt;
1913          * The requested type must have a return type of {@code void}.
1914          * (This is consistent with the JVM&#39;s treatment of constructor type descriptors.)
1915          * &lt;p&gt;
1916          * The returned method handle will have
1917          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
1918          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
1919          * &lt;p&gt;
1920          * If the returned method handle is invoked, the constructor&#39;s class will
1921          * be initialized, if it has not already been initialized.
1922          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
1923          * &lt;blockquote&gt;&lt;pre&gt;{@code
1924 import static java.lang.invoke.MethodHandles.*;
1925 import static java.lang.invoke.MethodType.*;
1926 ...
1927 MethodHandle MH_newArrayList = publicLookup().findConstructor(
1928   ArrayList.class, methodType(void.class, Collection.class));
1929 Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
1930 Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
1931 assert(orig != copy);
1932 assertEquals(orig, copy);
1933 // a variable-arity constructor:
1934 MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
1935   ProcessBuilder.class, methodType(void.class, String[].class));
1936 ProcessBuilder pb = (ProcessBuilder)
1937   MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
1938 assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
1939          * }&lt;/pre&gt;&lt;/blockquote&gt;
1940          * @param refc the class or interface from which the method is accessed
1941          * @param type the type of the method, with the receiver argument omitted, and a void return type
1942          * @return the desired method handle
1943          * @throws NoSuchMethodException if the constructor does not exist
1944          * @throws IllegalAccessException if access checking fails
1945          *                                or if the method&#39;s variable arity modifier bit
1946          *                                is set and {@code asVarargsCollector} fails
1947          * @throws    SecurityException if a security manager is present and it
1948          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1949          * @throws NullPointerException if any argument is null
1950          */
1951         public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
1952             if (refc.isArray()) {
1953                 throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
1954             }
1955             String name = &quot;&lt;init&gt;&quot;;
1956             MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
1957             return getDirectConstructor(refc, ctor);
1958         }
1959 
1960         /**
1961          * Looks up a class by name from the lookup context defined by this {@code Lookup} object,
1962          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if resolved&lt;/a&gt; by an {@code ldc} instruction.
1963          * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,
1964          * and then determines whether the class is accessible to this lookup object.
1965          * &lt;p&gt;
1966          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},
1967          * its class loader, and the {@linkplain #lookupModes() lookup modes}.
1968          *
1969          * @param targetName the fully qualified name of the class to be looked up.
1970          * @return the requested class.
1971          * @throws SecurityException if a security manager is present and it
1972          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1973          * @throws LinkageError if the linkage fails
1974          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
1975          * @throws IllegalAccessException if the class is not accessible, using the allowed access
1976          * modes.
1977          * @since 9
1978          * @jvms 5.4.3.1 Class and Interface Resolution
1979          */
1980         public Class&lt;?&gt; findClass(String targetName) throws ClassNotFoundException, IllegalAccessException {
1981             Class&lt;?&gt; targetClass = Class.forName(targetName, false, lookupClass.getClassLoader());
1982             return accessClass(targetClass);
1983         }
1984 
1985         /**
1986          * Determines if a class can be accessed from the lookup context defined by
1987          * this {@code Lookup} object. The static initializer of the class is not run.
1988          * &lt;p&gt;
1989          * If the {@code targetClass} is in the same module as the lookup class,
1990          * the lookup class is {@code LC} in module {@code M1} and
1991          * the previous lookup class is in module {@code M0} or
1992          * {@code null} if not present,
1993          * {@code targetClass} is accessible if and only if one of the following is true:
1994          * &lt;ul&gt;
1995          * &lt;li&gt;If this lookup has {@link #PRIVATE} access, {@code targetClass} is
1996          *     {@code LC} or other class in the same nest of {@code LC}.&lt;/li&gt;
1997          * &lt;li&gt;If this lookup has {@link #PACKAGE} access, {@code targetClass} is
1998          *     in the same runtime package of {@code LC}.&lt;/li&gt;
1999          * &lt;li&gt;If this lookup has {@link #MODULE} access, {@code targetClass} is
2000          *     a public type in {@code M1}.&lt;/li&gt;
2001          * &lt;li&gt;If this lookup has {@link #PUBLIC} access, {@code targetClass} is
2002          *     a public type in a package exported by {@code M1} to at least  {@code M0}
2003          *     if the previous lookup class is present; otherwise, {@code targetClass}
2004          *     is a public type in a package exported by {@code M1} unconditionally.&lt;/li&gt;
2005          * &lt;/ul&gt;
2006          *
2007          * &lt;p&gt;
2008          * Otherwise, if this lookup has {@link #UNCONDITIONAL} access, this lookup
2009          * can access public types in all modules when the type is in a package
2010          * that is exported unconditionally.
2011          * &lt;p&gt;
2012          * Otherwise, the target class is in a different module from {@code lookupClass},
2013          * and if this lookup does not have {@code PUBLIC} access, {@code lookupClass}
2014          * is inaccessible.
2015          * &lt;p&gt;
2016          * Otherwise, if this lookup has no {@linkplain #previousLookupClass() previous lookup class},
2017          * {@code M1} is the module containing {@code lookupClass} and
2018          * {@code M2} is the module containing {@code targetClass},
2019          * then {@code targetClass} is accessible if and only if
2020          * &lt;ul&gt;
2021          * &lt;li&gt;{@code M1} reads {@code M2}, and
2022          * &lt;li&gt;{@code targetClass} is public and in a package exported by
2023          *     {@code M2} at least to {@code M1}.
2024          * &lt;/ul&gt;
2025          * &lt;p&gt;
2026          * Otherwise, if this lookup has a {@linkplain #previousLookupClass() previous lookup class},
2027          * {@code M1} and {@code M2} are as before, and {@code M0} is the module
2028          * containing the previous lookup class, then {@code targetClass} is accessible
2029          * if and only if one of the following is true:
2030          * &lt;ul&gt;
2031          * &lt;li&gt;{@code targetClass} is in {@code M0} and {@code M1}
2032          *     {@linkplain Module#reads reads} {@code M0} and the type is
2033          *     in a package that is exported to at least {@code M1}.
2034          * &lt;li&gt;{@code targetClass} is in {@code M1} and {@code M0}
2035          *     {@linkplain Module#reads reads} {@code M1} and the type is
2036          *     in a package that is exported to at least {@code M0}.
2037          * &lt;li&gt;{@code targetClass} is in a third module {@code M2} and both {@code M0}
2038          *     and {@code M1} reads {@code M2} and the type is in a package
2039          *     that is exported to at least both {@code M0} and {@code M2}.
2040          * &lt;/ul&gt;
2041          * &lt;p&gt;
2042          * Otherwise, {@code targetClass} is not accessible.
2043          *
2044          * @param targetClass the class to be access-checked
2045          * @return the class that has been access-checked
2046          * @throws IllegalAccessException if the class is not accessible from the lookup class
2047          * and previous lookup class, if present, using the allowed access modes.
2048          * @throws    SecurityException if a security manager is present and it
2049          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2050          * @since 9
2051          * @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
2052          */
2053         public Class&lt;?&gt; accessClass(Class&lt;?&gt; targetClass) throws IllegalAccessException {
2054             if (!VerifyAccess.isClassAccessible(targetClass, lookupClass, prevLookupClass, allowedModes)) {
2055                 throw new MemberName(targetClass).makeAccessException(&quot;access violation&quot;, this);
2056             }
2057             checkSecurityManager(targetClass, null);
2058             return targetClass;
2059         }
2060 
2061         /**
2062          * Produces an early-bound method handle for a virtual method.
2063          * It will bypass checks for overriding methods on the receiver,
2064          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if called&lt;/a&gt; from an {@code invokespecial}
2065          * instruction from within the explicitly specified {@code specialCaller}.
2066          * The type of the method handle will be that of the method,
2067          * with a suitably restricted receiver type prepended.
2068          * (The receiver type will be {@code specialCaller} or a subtype.)
2069          * The method and all its argument types must be accessible
2070          * to the lookup object.
2071          * &lt;p&gt;
2072          * Before method resolution,
2073          * if the explicitly specified caller class is not identical with the
2074          * lookup class, or if this lookup object does not have
2075          * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;
2076          * privileges, the access fails.
2077          * &lt;p&gt;
2078          * The returned method handle will have
2079          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
2080          * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
2081          * &lt;p style=&quot;font-size:smaller;&quot;&gt;
2082          * &lt;em&gt;(Note:  JVM internal methods named {@code &quot;&lt;init&gt;&quot;} are not visible to this API,
2083          * even though the {@code invokespecial} instruction can refer to them
2084          * in special circumstances.  Use {@link #findConstructor findConstructor}
2085          * to access instance initialization methods in a safe manner.)&lt;/em&gt;
2086          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
2087          * &lt;blockquote&gt;&lt;pre&gt;{@code
2088 import static java.lang.invoke.MethodHandles.*;
2089 import static java.lang.invoke.MethodType.*;
2090 ...
2091 static class Listie extends ArrayList {
2092   public String toString() { return &quot;[wee Listie]&quot;; }
2093   static Lookup lookup() { return MethodHandles.lookup(); }
2094 }
2095 ...
2096 // no access to constructor via invokeSpecial:
2097 MethodHandle MH_newListie = Listie.lookup()
2098   .findConstructor(Listie.class, methodType(void.class));
2099 Listie l = (Listie) MH_newListie.invokeExact();
2100 try { assertEquals(&quot;impossible&quot;, Listie.lookup().findSpecial(
2101         Listie.class, &quot;&lt;init&gt;&quot;, methodType(void.class), Listie.class));
2102  } catch (NoSuchMethodException ex) { } // OK
2103 // access to super and self methods via invokeSpecial:
2104 MethodHandle MH_super = Listie.lookup().findSpecial(
2105   ArrayList.class, &quot;toString&quot; , methodType(String.class), Listie.class);
2106 MethodHandle MH_this = Listie.lookup().findSpecial(
2107   Listie.class, &quot;toString&quot; , methodType(String.class), Listie.class);
2108 MethodHandle MH_duper = Listie.lookup().findSpecial(
2109   Object.class, &quot;toString&quot; , methodType(String.class), Listie.class);
2110 assertEquals(&quot;[]&quot;, (String) MH_super.invokeExact(l));
2111 assertEquals(&quot;&quot;+l, (String) MH_this.invokeExact(l));
2112 assertEquals(&quot;[]&quot;, (String) MH_duper.invokeExact(l)); // ArrayList method
2113 try { assertEquals(&quot;inaccessible&quot;, Listie.lookup().findSpecial(
2114         String.class, &quot;toString&quot;, methodType(String.class), Listie.class));
2115  } catch (IllegalAccessException ex) { } // OK
2116 Listie subl = new Listie() { public String toString() { return &quot;[subclass]&quot;; } };
2117 assertEquals(&quot;&quot;+l, (String) MH_this.invokeExact(subl)); // Listie method
2118          * }&lt;/pre&gt;&lt;/blockquote&gt;
2119          *
2120          * @param refc the class or interface from which the method is accessed
2121          * @param name the name of the method (which must not be &quot;&amp;lt;init&amp;gt;&quot;)
2122          * @param type the type of the method, with the receiver argument omitted
2123          * @param specialCaller the proposed calling class to perform the {@code invokespecial}
2124          * @return the desired method handle
2125          * @throws NoSuchMethodException if the method does not exist
2126          * @throws IllegalAccessException if access checking fails,
2127          *                                or if the method is {@code static},
2128          *                                or if the method&#39;s variable arity modifier bit
2129          *                                is set and {@code asVarargsCollector} fails
2130          * @throws    SecurityException if a security manager is present and it
2131          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2132          * @throws NullPointerException if any argument is null
2133          */
2134         public MethodHandle findSpecial(Class&lt;?&gt; refc, String name, MethodType type,
2135                                         Class&lt;?&gt; specialCaller) throws NoSuchMethodException, IllegalAccessException {
2136             checkSpecialCaller(specialCaller, refc);
2137             Lookup specialLookup = this.in(specialCaller);
2138             MemberName method = specialLookup.resolveOrFail(REF_invokeSpecial, refc, name, type);
2139             return specialLookup.getDirectMethod(REF_invokeSpecial, refc, method, findBoundCallerLookup(method));
2140         }
2141 
2142         /**
2143          * Produces a method handle giving read access to a non-static field.
2144          * The type of the method handle will have a return type of the field&#39;s
2145          * value type.
2146          * The method handle&#39;s single argument will be the instance containing
2147          * the field.
2148          * Access checking is performed immediately on behalf of the lookup class.
2149          * @param refc the class or interface from which the method is accessed
2150          * @param name the field&#39;s name
2151          * @param type the field&#39;s type
2152          * @return a method handle which can load values from the field
2153          * @throws NoSuchFieldException if the field does not exist
2154          * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
2155          * @throws    SecurityException if a security manager is present and it
2156          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2157          * @throws NullPointerException if any argument is null
2158          * @see #findVarHandle(Class, String, Class)
2159          */
2160         public MethodHandle findGetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2161             MemberName field = resolveOrFail(REF_getField, refc, name, type);
2162             return getDirectField(REF_getField, refc, field);
2163         }
2164 
2165         /**
2166          * Produces a method handle giving write access to a non-static field.
2167          * The type of the method handle will have a void return type.
2168          * The method handle will take two arguments, the instance containing
2169          * the field, and the value to be stored.
2170          * The second argument will be of the field&#39;s value type.
2171          * Access checking is performed immediately on behalf of the lookup class.
2172          * @param refc the class or interface from which the method is accessed
2173          * @param name the field&#39;s name
2174          * @param type the field&#39;s type
2175          * @return a method handle which can store values into the field
2176          * @throws NoSuchFieldException if the field does not exist
2177          * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
2178          *                                or {@code final}
2179          * @throws    SecurityException if a security manager is present and it
2180          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2181          * @throws NullPointerException if any argument is null
2182          * @see #findVarHandle(Class, String, Class)
2183          */
2184         public MethodHandle findSetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2185             MemberName field = resolveOrFail(REF_putField, refc, name, type);
2186             return getDirectField(REF_putField, refc, field);
2187         }
2188 
2189         /**
2190          * Produces a VarHandle giving access to a non-static field {@code name}
2191          * of type {@code type} declared in a class of type {@code recv}.
2192          * The VarHandle&#39;s variable type is {@code type} and it has one
2193          * coordinate type, {@code recv}.
2194          * &lt;p&gt;
2195          * Access checking is performed immediately on behalf of the lookup
2196          * class.
2197          * &lt;p&gt;
2198          * Certain access modes of the returned VarHandle are unsupported under
2199          * the following conditions:
2200          * &lt;ul&gt;
2201          * &lt;li&gt;if the field is declared {@code final}, then the write, atomic
2202          *     update, numeric atomic update, and bitwise atomic update access
2203          *     modes are unsupported.
2204          * &lt;li&gt;if the field type is anything other than {@code byte},
2205          *     {@code short}, {@code char}, {@code int}, {@code long},
2206          *     {@code float}, or {@code double} then numeric atomic update
2207          *     access modes are unsupported.
2208          * &lt;li&gt;if the field type is anything other than {@code boolean},
2209          *     {@code byte}, {@code short}, {@code char}, {@code int} or
2210          *     {@code long} then bitwise atomic update access modes are
2211          *     unsupported.
2212          * &lt;/ul&gt;
2213          * &lt;p&gt;
2214          * If the field is declared {@code volatile} then the returned VarHandle
2215          * will override access to the field (effectively ignore the
2216          * {@code volatile} declaration) in accordance to its specified
2217          * access modes.
2218          * &lt;p&gt;
2219          * If the field type is {@code float} or {@code double} then numeric
2220          * and atomic update access modes compare values using their bitwise
2221          * representation (see {@link Float#floatToRawIntBits} and
2222          * {@link Double#doubleToRawLongBits}, respectively).
2223          * @apiNote
2224          * Bitwise comparison of {@code float} values or {@code double} values,
2225          * as performed by the numeric and atomic update access modes, differ
2226          * from the primitive {@code ==} operator and the {@link Float#equals}
2227          * and {@link Double#equals} methods, specifically with respect to
2228          * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
2229          * Care should be taken when performing a compare and set or a compare
2230          * and exchange operation with such values since the operation may
2231          * unexpectedly fail.
2232          * There are many possible NaN values that are considered to be
2233          * {@code NaN} in Java, although no IEEE 754 floating-point operation
2234          * provided by Java can distinguish between them.  Operation failure can
2235          * occur if the expected or witness value is a NaN value and it is
2236          * transformed (perhaps in a platform specific manner) into another NaN
2237          * value, and thus has a different bitwise representation (see
2238          * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
2239          * details).
2240          * The values {@code -0.0} and {@code +0.0} have different bitwise
2241          * representations but are considered equal when using the primitive
2242          * {@code ==} operator.  Operation failure can occur if, for example, a
2243          * numeric algorithm computes an expected value to be say {@code -0.0}
2244          * and previously computed the witness value to be say {@code +0.0}.
2245          * @param recv the receiver class, of type {@code R}, that declares the
2246          * non-static field
2247          * @param name the field&#39;s name
2248          * @param type the field&#39;s type, of type {@code T}
2249          * @return a VarHandle giving access to non-static fields.
2250          * @throws NoSuchFieldException if the field does not exist
2251          * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
2252          * @throws    SecurityException if a security manager is present and it
2253          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2254          * @throws NullPointerException if any argument is null
2255          * @since 9
2256          */
2257         public VarHandle findVarHandle(Class&lt;?&gt; recv, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2258             MemberName getField = resolveOrFail(REF_getField, recv, name, type);
2259             MemberName putField = resolveOrFail(REF_putField, recv, name, type);
2260             return getFieldVarHandle(REF_getField, REF_putField, recv, getField, putField);
2261         }
2262 
2263         /**
2264          * Produces a method handle giving read access to a static field.
2265          * The type of the method handle will have a return type of the field&#39;s
2266          * value type.
2267          * The method handle will take no arguments.
2268          * Access checking is performed immediately on behalf of the lookup class.
2269          * &lt;p&gt;
2270          * If the returned method handle is invoked, the field&#39;s class will
2271          * be initialized, if it has not already been initialized.
2272          * @param refc the class or interface from which the method is accessed
2273          * @param name the field&#39;s name
2274          * @param type the field&#39;s type
2275          * @return a method handle which can load values from the field
2276          * @throws NoSuchFieldException if the field does not exist
2277          * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
2278          * @throws    SecurityException if a security manager is present and it
2279          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2280          * @throws NullPointerException if any argument is null
2281          */
2282         public MethodHandle findStaticGetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2283             MemberName field = resolveOrFail(REF_getStatic, refc, name, type);
2284             return getDirectField(REF_getStatic, refc, field);
2285         }
2286 
2287         /**
2288          * Produces a method handle giving write access to a static field.
2289          * The type of the method handle will have a void return type.
2290          * The method handle will take a single
2291          * argument, of the field&#39;s value type, the value to be stored.
2292          * Access checking is performed immediately on behalf of the lookup class.
2293          * &lt;p&gt;
2294          * If the returned method handle is invoked, the field&#39;s class will
2295          * be initialized, if it has not already been initialized.
2296          * @param refc the class or interface from which the method is accessed
2297          * @param name the field&#39;s name
2298          * @param type the field&#39;s type
2299          * @return a method handle which can store values into the field
2300          * @throws NoSuchFieldException if the field does not exist
2301          * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
2302          *                                or is {@code final}
2303          * @throws    SecurityException if a security manager is present and it
2304          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2305          * @throws NullPointerException if any argument is null
2306          */
2307         public MethodHandle findStaticSetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2308             MemberName field = resolveOrFail(REF_putStatic, refc, name, type);
2309             return getDirectField(REF_putStatic, refc, field);
2310         }
2311 
2312         /**
2313          * Produces a VarHandle giving access to a static field {@code name} of
2314          * type {@code type} declared in a class of type {@code decl}.
2315          * The VarHandle&#39;s variable type is {@code type} and it has no
2316          * coordinate types.
2317          * &lt;p&gt;
2318          * Access checking is performed immediately on behalf of the lookup
2319          * class.
2320          * &lt;p&gt;
2321          * If the returned VarHandle is operated on, the declaring class will be
2322          * initialized, if it has not already been initialized.
2323          * &lt;p&gt;
2324          * Certain access modes of the returned VarHandle are unsupported under
2325          * the following conditions:
2326          * &lt;ul&gt;
2327          * &lt;li&gt;if the field is declared {@code final}, then the write, atomic
2328          *     update, numeric atomic update, and bitwise atomic update access
2329          *     modes are unsupported.
2330          * &lt;li&gt;if the field type is anything other than {@code byte},
2331          *     {@code short}, {@code char}, {@code int}, {@code long},
2332          *     {@code float}, or {@code double}, then numeric atomic update
2333          *     access modes are unsupported.
2334          * &lt;li&gt;if the field type is anything other than {@code boolean},
2335          *     {@code byte}, {@code short}, {@code char}, {@code int} or
2336          *     {@code long} then bitwise atomic update access modes are
2337          *     unsupported.
2338          * &lt;/ul&gt;
2339          * &lt;p&gt;
2340          * If the field is declared {@code volatile} then the returned VarHandle
2341          * will override access to the field (effectively ignore the
2342          * {@code volatile} declaration) in accordance to its specified
2343          * access modes.
2344          * &lt;p&gt;
2345          * If the field type is {@code float} or {@code double} then numeric
2346          * and atomic update access modes compare values using their bitwise
2347          * representation (see {@link Float#floatToRawIntBits} and
2348          * {@link Double#doubleToRawLongBits}, respectively).
2349          * @apiNote
2350          * Bitwise comparison of {@code float} values or {@code double} values,
2351          * as performed by the numeric and atomic update access modes, differ
2352          * from the primitive {@code ==} operator and the {@link Float#equals}
2353          * and {@link Double#equals} methods, specifically with respect to
2354          * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
2355          * Care should be taken when performing a compare and set or a compare
2356          * and exchange operation with such values since the operation may
2357          * unexpectedly fail.
2358          * There are many possible NaN values that are considered to be
2359          * {@code NaN} in Java, although no IEEE 754 floating-point operation
2360          * provided by Java can distinguish between them.  Operation failure can
2361          * occur if the expected or witness value is a NaN value and it is
2362          * transformed (perhaps in a platform specific manner) into another NaN
2363          * value, and thus has a different bitwise representation (see
2364          * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
2365          * details).
2366          * The values {@code -0.0} and {@code +0.0} have different bitwise
2367          * representations but are considered equal when using the primitive
2368          * {@code ==} operator.  Operation failure can occur if, for example, a
2369          * numeric algorithm computes an expected value to be say {@code -0.0}
2370          * and previously computed the witness value to be say {@code +0.0}.
2371          * @param decl the class that declares the static field
2372          * @param name the field&#39;s name
2373          * @param type the field&#39;s type, of type {@code T}
2374          * @return a VarHandle giving access to a static field
2375          * @throws NoSuchFieldException if the field does not exist
2376          * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
2377          * @throws    SecurityException if a security manager is present and it
2378          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2379          * @throws NullPointerException if any argument is null
2380          * @since 9
2381          */
2382         public VarHandle findStaticVarHandle(Class&lt;?&gt; decl, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2383             MemberName getField = resolveOrFail(REF_getStatic, decl, name, type);
2384             MemberName putField = resolveOrFail(REF_putStatic, decl, name, type);
2385             return getFieldVarHandle(REF_getStatic, REF_putStatic, decl, getField, putField);
2386         }
2387 
2388         /**
2389          * Produces an early-bound method handle for a non-static method.
2390          * The receiver must have a supertype {@code defc} in which a method
2391          * of the given name and type is accessible to the lookup class.
2392          * The method and all its argument types must be accessible to the lookup object.
2393          * The type of the method handle will be that of the method,
2394          * without any insertion of an additional receiver parameter.
2395          * The given receiver will be bound into the method handle,
2396          * so that every call to the method handle will invoke the
2397          * requested method on the given receiver.
2398          * &lt;p&gt;
2399          * The returned method handle will have
2400          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
2401          * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set
2402          * &lt;em&gt;and&lt;/em&gt; the trailing array argument is not the only argument.
2403          * (If the trailing array argument is the only argument,
2404          * the given receiver value will be bound to it.)
2405          * &lt;p&gt;
2406          * This is almost equivalent to the following code, with some differences noted below:
2407          * &lt;blockquote&gt;&lt;pre&gt;{@code
2408 import static java.lang.invoke.MethodHandles.*;
2409 import static java.lang.invoke.MethodType.*;
2410 ...
2411 MethodHandle mh0 = lookup().findVirtual(defc, name, type);
2412 MethodHandle mh1 = mh0.bindTo(receiver);
2413 mh1 = mh1.withVarargs(mh0.isVarargsCollector());
2414 return mh1;
2415          * }&lt;/pre&gt;&lt;/blockquote&gt;
2416          * where {@code defc} is either {@code receiver.getClass()} or a super
2417          * type of that class, in which the requested method is accessible
2418          * to the lookup class.
2419          * (Unlike {@code bind}, {@code bindTo} does not preserve variable arity.
2420          * Also, {@code bindTo} may throw a {@code ClassCastException} in instances where {@code bind} would
2421          * throw an {@code IllegalAccessException}, as in the case where the member is {@code protected} and
2422          * the receiver is restricted by {@code findVirtual} to the lookup class.)
2423          * @param receiver the object from which the method is accessed
2424          * @param name the name of the method
2425          * @param type the type of the method, with the receiver argument omitted
2426          * @return the desired method handle
2427          * @throws NoSuchMethodException if the method does not exist
2428          * @throws IllegalAccessException if access checking fails
2429          *                                or if the method&#39;s variable arity modifier bit
2430          *                                is set and {@code asVarargsCollector} fails
2431          * @throws    SecurityException if a security manager is present and it
2432          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2433          * @throws NullPointerException if any argument is null
2434          * @see MethodHandle#bindTo
2435          * @see #findVirtual
2436          */
2437         public MethodHandle bind(Object receiver, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2438             Class&lt;? extends Object&gt; refc = receiver.getClass(); // may get NPE
2439             MemberName method = resolveOrFail(REF_invokeSpecial, refc, name, type);
2440             MethodHandle mh = getDirectMethodNoRestrictInvokeSpecial(refc, method, findBoundCallerLookup(method));
2441             if (!mh.type().leadingReferenceParameter().isAssignableFrom(receiver.getClass())) {
2442                 throw new IllegalAccessException(&quot;The restricted defining class &quot; +
2443                                                  mh.type().leadingReferenceParameter().getName() +
2444                                                  &quot; is not assignable from receiver class &quot; +
2445                                                  receiver.getClass().getName());
2446             }
2447             return mh.bindArgumentL(0, receiver).setVarargs(method);
2448         }
2449 
2450         /**
2451          * Makes a &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;
2452          * to &lt;i&gt;m&lt;/i&gt;, if the lookup class has permission.
2453          * If &lt;i&gt;m&lt;/i&gt; is non-static, the receiver argument is treated as an initial argument.
2454          * If &lt;i&gt;m&lt;/i&gt; is virtual, overriding is respected on every call.
2455          * Unlike the Core Reflection API, exceptions are &lt;em&gt;not&lt;/em&gt; wrapped.
2456          * The type of the method handle will be that of the method,
2457          * with the receiver type prepended (but only if it is non-static).
2458          * If the method&#39;s {@code accessible} flag is not set,
2459          * access checking is performed immediately on behalf of the lookup class.
2460          * If &lt;i&gt;m&lt;/i&gt; is not public, do not share the resulting handle with untrusted parties.
2461          * &lt;p&gt;
2462          * The returned method handle will have
2463          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
2464          * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
2465          * &lt;p&gt;
2466          * If &lt;i&gt;m&lt;/i&gt; is static, and
2467          * if the returned method handle is invoked, the method&#39;s class will
2468          * be initialized, if it has not already been initialized.
2469          * @param m the reflected method
2470          * @return a method handle which can invoke the reflected method
2471          * @throws IllegalAccessException if access checking fails
2472          *                                or if the method&#39;s variable arity modifier bit
2473          *                                is set and {@code asVarargsCollector} fails
2474          * @throws NullPointerException if the argument is null
2475          */
2476         public MethodHandle unreflect(Method m) throws IllegalAccessException {
2477             if (m.getDeclaringClass() == MethodHandle.class) {
2478                 MethodHandle mh = unreflectForMH(m);
2479                 if (mh != null)  return mh;
2480             }
2481             if (m.getDeclaringClass() == VarHandle.class) {
2482                 MethodHandle mh = unreflectForVH(m);
2483                 if (mh != null)  return mh;
2484             }
2485             MemberName method = new MemberName(m);
2486             byte refKind = method.getReferenceKind();
2487             if (refKind == REF_invokeSpecial)
2488                 refKind = REF_invokeVirtual;
2489             assert(method.isMethod());
2490             @SuppressWarnings(&quot;deprecation&quot;)
2491             Lookup lookup = m.isAccessible() ? IMPL_LOOKUP : this;
2492             return lookup.getDirectMethodNoSecurityManager(refKind, method.getDeclaringClass(), method, findBoundCallerLookup(method));
2493         }
2494         private MethodHandle unreflectForMH(Method m) {
2495             // these names require special lookups because they throw UnsupportedOperationException
2496             if (MemberName.isMethodHandleInvokeName(m.getName()))
2497                 return MethodHandleImpl.fakeMethodHandleInvoke(new MemberName(m));
2498             return null;
2499         }
2500         private MethodHandle unreflectForVH(Method m) {
2501             // these names require special lookups because they throw UnsupportedOperationException
2502             if (MemberName.isVarHandleMethodInvokeName(m.getName()))
2503                 return MethodHandleImpl.fakeVarHandleInvoke(new MemberName(m));
2504             return null;
2505         }
2506 
2507         /**
2508          * Produces a method handle for a reflected method.
2509          * It will bypass checks for overriding methods on the receiver,
2510          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if called&lt;/a&gt; from an {@code invokespecial}
2511          * instruction from within the explicitly specified {@code specialCaller}.
2512          * The type of the method handle will be that of the method,
2513          * with a suitably restricted receiver type prepended.
2514          * (The receiver type will be {@code specialCaller} or a subtype.)
2515          * If the method&#39;s {@code accessible} flag is not set,
2516          * access checking is performed immediately on behalf of the lookup class,
2517          * as if {@code invokespecial} instruction were being linked.
2518          * &lt;p&gt;
2519          * Before method resolution,
2520          * if the explicitly specified caller class is not identical with the
2521          * lookup class, or if this lookup object does not have
2522          * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;
2523          * privileges, the access fails.
2524          * &lt;p&gt;
2525          * The returned method handle will have
2526          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
2527          * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
2528          * @param m the reflected method
2529          * @param specialCaller the class nominally calling the method
2530          * @return a method handle which can invoke the reflected method
2531          * @throws IllegalAccessException if access checking fails,
2532          *                                or if the method is {@code static},
2533          *                                or if the method&#39;s variable arity modifier bit
2534          *                                is set and {@code asVarargsCollector} fails
2535          * @throws NullPointerException if any argument is null
2536          */
2537         public MethodHandle unreflectSpecial(Method m, Class&lt;?&gt; specialCaller) throws IllegalAccessException {
2538             checkSpecialCaller(specialCaller, m.getDeclaringClass());
2539             Lookup specialLookup = this.in(specialCaller);
2540             MemberName method = new MemberName(m, true);
2541             assert(method.isMethod());
2542             // ignore m.isAccessible:  this is a new kind of access
2543             return specialLookup.getDirectMethodNoSecurityManager(REF_invokeSpecial, method.getDeclaringClass(), method, findBoundCallerLookup(method));
2544         }
2545 
2546         /**
2547          * Produces a method handle for a reflected constructor.
2548          * The type of the method handle will be that of the constructor,
2549          * with the return type changed to the declaring class.
2550          * The method handle will perform a {@code newInstance} operation,
2551          * creating a new instance of the constructor&#39;s class on the
2552          * arguments passed to the method handle.
2553          * &lt;p&gt;
2554          * If the constructor&#39;s {@code accessible} flag is not set,
2555          * access checking is performed immediately on behalf of the lookup class.
2556          * &lt;p&gt;
2557          * The returned method handle will have
2558          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
2559          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
2560          * &lt;p&gt;
2561          * If the returned method handle is invoked, the constructor&#39;s class will
2562          * be initialized, if it has not already been initialized.
2563          * @param c the reflected constructor
2564          * @return a method handle which can invoke the reflected constructor
2565          * @throws IllegalAccessException if access checking fails
2566          *                                or if the method&#39;s variable arity modifier bit
2567          *                                is set and {@code asVarargsCollector} fails
2568          * @throws NullPointerException if the argument is null
2569          */
2570         public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {
2571             MemberName ctor = new MemberName(c);
2572             assert(ctor.isConstructor());
2573             @SuppressWarnings(&quot;deprecation&quot;)
2574             Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
2575             return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);
2576         }
2577 
2578         /**
2579          * Produces a method handle giving read access to a reflected field.
2580          * The type of the method handle will have a return type of the field&#39;s
2581          * value type.
2582          * If the field is {@code static}, the method handle will take no arguments.
2583          * Otherwise, its single argument will be the instance containing
2584          * the field.
2585          * If the {@code Field} object&#39;s {@code accessible} flag is not set,
2586          * access checking is performed immediately on behalf of the lookup class.
2587          * &lt;p&gt;
2588          * If the field is static, and
2589          * if the returned method handle is invoked, the field&#39;s class will
2590          * be initialized, if it has not already been initialized.
2591          * @param f the reflected field
2592          * @return a method handle which can load values from the reflected field
2593          * @throws IllegalAccessException if access checking fails
2594          * @throws NullPointerException if the argument is null
2595          */
2596         public MethodHandle unreflectGetter(Field f) throws IllegalAccessException {
2597             return unreflectField(f, false);
2598         }
2599 
2600         /**
2601          * Produces a method handle giving write access to a reflected field.
2602          * The type of the method handle will have a void return type.
2603          * If the field is {@code static}, the method handle will take a single
2604          * argument, of the field&#39;s value type, the value to be stored.
2605          * Otherwise, the two arguments will be the instance containing
2606          * the field, and the value to be stored.
2607          * If the {@code Field} object&#39;s {@code accessible} flag is not set,
2608          * access checking is performed immediately on behalf of the lookup class.
2609          * &lt;p&gt;
2610          * If the field is {@code final}, write access will not be
2611          * allowed and access checking will fail, except under certain
2612          * narrow circumstances documented for {@link Field#set Field.set}.
2613          * A method handle is returned only if a corresponding call to
2614          * the {@code Field} object&#39;s {@code set} method could return
2615          * normally.  In particular, fields which are both {@code static}
2616          * and {@code final} may never be set.
2617          * &lt;p&gt;
2618          * If the field is {@code static}, and
2619          * if the returned method handle is invoked, the field&#39;s class will
2620          * be initialized, if it has not already been initialized.
2621          * @param f the reflected field
2622          * @return a method handle which can store values into the reflected field
2623          * @throws IllegalAccessException if access checking fails,
2624          *         or if the field is {@code final} and write access
2625          *         is not enabled on the {@code Field} object
2626          * @throws NullPointerException if the argument is null
2627          */
2628         public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {
2629             return unreflectField(f, true);
2630         }
2631 
2632         private MethodHandle unreflectField(Field f, boolean isSetter) throws IllegalAccessException {
2633             MemberName field = new MemberName(f, isSetter);
2634             if (isSetter &amp;&amp; field.isStatic() &amp;&amp; field.isFinal())
2635                 throw field.makeAccessException(&quot;static final field has no write access&quot;, this);
2636             assert(isSetter
2637                     ? MethodHandleNatives.refKindIsSetter(field.getReferenceKind())
2638                     : MethodHandleNatives.refKindIsGetter(field.getReferenceKind()));
2639             @SuppressWarnings(&quot;deprecation&quot;)
2640             Lookup lookup = f.isAccessible() ? IMPL_LOOKUP : this;
2641             return lookup.getDirectFieldNoSecurityManager(field.getReferenceKind(), f.getDeclaringClass(), field);
2642         }
2643 
2644         /**
2645          * Produces a VarHandle giving access to a reflected field {@code f}
2646          * of type {@code T} declared in a class of type {@code R}.
2647          * The VarHandle&#39;s variable type is {@code T}.
2648          * If the field is non-static the VarHandle has one coordinate type,
2649          * {@code R}.  Otherwise, the field is static, and the VarHandle has no
2650          * coordinate types.
2651          * &lt;p&gt;
2652          * Access checking is performed immediately on behalf of the lookup
2653          * class, regardless of the value of the field&#39;s {@code accessible}
2654          * flag.
2655          * &lt;p&gt;
2656          * If the field is static, and if the returned VarHandle is operated
2657          * on, the field&#39;s declaring class will be initialized, if it has not
2658          * already been initialized.
2659          * &lt;p&gt;
2660          * Certain access modes of the returned VarHandle are unsupported under
2661          * the following conditions:
2662          * &lt;ul&gt;
2663          * &lt;li&gt;if the field is declared {@code final}, then the write, atomic
2664          *     update, numeric atomic update, and bitwise atomic update access
2665          *     modes are unsupported.
2666          * &lt;li&gt;if the field type is anything other than {@code byte},
2667          *     {@code short}, {@code char}, {@code int}, {@code long},
2668          *     {@code float}, or {@code double} then numeric atomic update
2669          *     access modes are unsupported.
2670          * &lt;li&gt;if the field type is anything other than {@code boolean},
2671          *     {@code byte}, {@code short}, {@code char}, {@code int} or
2672          *     {@code long} then bitwise atomic update access modes are
2673          *     unsupported.
2674          * &lt;/ul&gt;
2675          * &lt;p&gt;
2676          * If the field is declared {@code volatile} then the returned VarHandle
2677          * will override access to the field (effectively ignore the
2678          * {@code volatile} declaration) in accordance to its specified
2679          * access modes.
2680          * &lt;p&gt;
2681          * If the field type is {@code float} or {@code double} then numeric
2682          * and atomic update access modes compare values using their bitwise
2683          * representation (see {@link Float#floatToRawIntBits} and
2684          * {@link Double#doubleToRawLongBits}, respectively).
2685          * @apiNote
2686          * Bitwise comparison of {@code float} values or {@code double} values,
2687          * as performed by the numeric and atomic update access modes, differ
2688          * from the primitive {@code ==} operator and the {@link Float#equals}
2689          * and {@link Double#equals} methods, specifically with respect to
2690          * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
2691          * Care should be taken when performing a compare and set or a compare
2692          * and exchange operation with such values since the operation may
2693          * unexpectedly fail.
2694          * There are many possible NaN values that are considered to be
2695          * {@code NaN} in Java, although no IEEE 754 floating-point operation
2696          * provided by Java can distinguish between them.  Operation failure can
2697          * occur if the expected or witness value is a NaN value and it is
2698          * transformed (perhaps in a platform specific manner) into another NaN
2699          * value, and thus has a different bitwise representation (see
2700          * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
2701          * details).
2702          * The values {@code -0.0} and {@code +0.0} have different bitwise
2703          * representations but are considered equal when using the primitive
2704          * {@code ==} operator.  Operation failure can occur if, for example, a
2705          * numeric algorithm computes an expected value to be say {@code -0.0}
2706          * and previously computed the witness value to be say {@code +0.0}.
2707          * @param f the reflected field, with a field of type {@code T}, and
2708          * a declaring class of type {@code R}
2709          * @return a VarHandle giving access to non-static fields or a static
2710          * field
2711          * @throws IllegalAccessException if access checking fails
2712          * @throws NullPointerException if the argument is null
2713          * @since 9
2714          */
2715         public VarHandle unreflectVarHandle(Field f) throws IllegalAccessException {
2716             MemberName getField = new MemberName(f, false);
2717             MemberName putField = new MemberName(f, true);
2718             return getFieldVarHandleNoSecurityManager(getField.getReferenceKind(), putField.getReferenceKind(),
2719                                                       f.getDeclaringClass(), getField, putField);
2720         }
2721 
2722         /**
2723          * Cracks a &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;
2724          * created by this lookup object or a similar one.
2725          * Security and access checks are performed to ensure that this lookup object
2726          * is capable of reproducing the target method handle.
2727          * This means that the cracking may fail if target is a direct method handle
2728          * but was created by an unrelated lookup object.
2729          * This can happen if the method handle is &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt;
2730          * and was created by a lookup object for a different class.
2731          * @param target a direct method handle to crack into symbolic reference components
2732          * @return a symbolic reference which can be used to reconstruct this method handle from this lookup object
2733          * @throws    SecurityException if a security manager is present and it
2734          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2735          * @throws IllegalArgumentException if the target is not a direct method handle or if access checking fails
2736          * @throws    NullPointerException if the target is {@code null}
2737          * @see MethodHandleInfo
2738          * @since 1.8
2739          */
2740         public MethodHandleInfo revealDirect(MethodHandle target) {
2741             MemberName member = target.internalMemberName();
2742             if (member == null || (!member.isResolved() &amp;&amp;
2743                                    !member.isMethodHandleInvoke() &amp;&amp;
2744                                    !member.isVarHandleMethodInvoke()))
2745                 throw newIllegalArgumentException(&quot;not a direct method handle&quot;);
2746             Class&lt;?&gt; defc = member.getDeclaringClass();
2747             byte refKind = member.getReferenceKind();
2748             assert(MethodHandleNatives.refKindIsValid(refKind));
2749             if (refKind == REF_invokeSpecial &amp;&amp; !target.isInvokeSpecial())
2750                 // Devirtualized method invocation is usually formally virtual.
2751                 // To avoid creating extra MemberName objects for this common case,
2752                 // we encode this extra degree of freedom using MH.isInvokeSpecial.
2753                 refKind = REF_invokeVirtual;
2754             if (refKind == REF_invokeVirtual &amp;&amp; defc.isInterface())
2755                 // Symbolic reference is through interface but resolves to Object method (toString, etc.)
2756                 refKind = REF_invokeInterface;
2757             // Check SM permissions and member access before cracking.
2758             try {
2759                 checkAccess(refKind, defc, member);
2760                 checkSecurityManager(defc, member);
2761             } catch (IllegalAccessException ex) {
2762                 throw new IllegalArgumentException(ex);
2763             }
2764             if (allowedModes != TRUSTED &amp;&amp; member.isCallerSensitive()) {
2765                 Class&lt;?&gt; callerClass = target.internalCallerClass();
2766                 if (!hasFullPrivilegeAccess() || callerClass != lookupClass())
2767                     throw new IllegalArgumentException(&quot;method handle is caller sensitive: &quot;+callerClass);
2768             }
2769             // Produce the handle to the results.
2770             return new InfoFromMemberName(this, member, refKind);
2771         }
2772 
2773         /// Helper methods, all package-private.
2774 
2775         MemberName resolveOrFail(byte refKind, Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2776             checkSymbolicClass(refc);  // do this before attempting to resolve
2777             Objects.requireNonNull(name);
2778             Objects.requireNonNull(type);
2779             return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(),
2780                                             NoSuchFieldException.class);
2781         }
2782 
2783         MemberName resolveOrFail(byte refKind, Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2784             checkSymbolicClass(refc);  // do this before attempting to resolve
2785             Objects.requireNonNull(name);
2786             Objects.requireNonNull(type);
2787             checkMethodName(refKind, name);  // NPE check on name
2788             return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(),
2789                                             NoSuchMethodException.class);
2790         }
2791 
2792         MemberName resolveOrFail(byte refKind, MemberName member) throws ReflectiveOperationException {
2793             checkSymbolicClass(member.getDeclaringClass());  // do this before attempting to resolve
2794             Objects.requireNonNull(member.getName());
2795             Objects.requireNonNull(member.getType());
2796             return IMPL_NAMES.resolveOrFail(refKind, member, lookupClassOrNull(),
2797                                             ReflectiveOperationException.class);
2798         }
2799 
2800         MemberName resolveOrNull(byte refKind, MemberName member) {
2801             // do this before attempting to resolve
2802             if (!isClassAccessible(member.getDeclaringClass())) {
2803                 return null;
2804             }
2805             Objects.requireNonNull(member.getName());
2806             Objects.requireNonNull(member.getType());
2807             return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
2808         }
2809 
2810         void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
2811             if (!isClassAccessible(refc)) {
2812                 throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
2813             }
2814         }
2815 
2816         boolean isClassAccessible(Class&lt;?&gt; refc) {
2817             Objects.requireNonNull(refc);
2818             Class&lt;?&gt; caller = lookupClassOrNull();
2819             return caller == null || VerifyAccess.isClassAccessible(refc, caller, prevLookupClass, allowedModes);
2820         }
2821 
2822         /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
2823         void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
2824             if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial)
2825                 throw new NoSuchMethodException(&quot;illegal method name: &quot;+name);
2826         }
2827 
2828 
2829         /**
2830          * Find my trustable caller class if m is a caller sensitive method.
2831          * If this lookup object has full privilege access, then the caller class is the lookupClass.
2832          * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
2833          */
2834         Lookup findBoundCallerLookup(MemberName m) throws IllegalAccessException {
2835             if (MethodHandleNatives.isCallerSensitive(m) &amp;&amp; !hasFullPrivilegeAccess()) {
2836                 // Only lookups with full privilege access are allowed to resolve caller-sensitive methods
2837                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
2838             }
2839             return this;
2840         }
2841 
2842         /**
2843          * Returns {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
2844          * @return {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
2845          *
2846          * @deprecated This method was originally designed to test {@code PRIVATE} access
2847          * that implies full privilege access but {@code MODULE} access has since become
2848          * independent of {@code PRIVATE} access.  It is recommended to call
2849          * {@link #hasFullPrivilegeAccess()} instead.
2850          * @since 9
2851          */
2852         @Deprecated(since=&quot;14&quot;)
2853         public boolean hasPrivateAccess() {
2854             return hasFullPrivilegeAccess();
2855         }
2856 
2857         /**
2858          * Returns {@code true} if this lookup has &lt;em&gt;full privilege access&lt;/em&gt;,
2859          * i.e. {@code PRIVATE} and {@code MODULE} access.
2860          * A {@code Lookup} object must have full privilege access in order to
2861          * access all members that are allowed to the {@linkplain #lookupClass() lookup class}.
2862          *
2863          * @return {@code true} if this lookup has full privilege access.
2864          * @since 14
2865          * @see &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private and module access&lt;/a&gt;
2866          */
2867         public boolean hasFullPrivilegeAccess() {
2868             return (allowedModes &amp; (PRIVATE|MODULE)) == (PRIVATE|MODULE);
2869         }
2870 
2871         /**
2872          * Perform necessary &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;access checks&lt;/a&gt;.
2873          * Determines a trustable caller class to compare with refc, the symbolic reference class.
2874          * If this lookup object has full privilege access, then the caller class is the lookupClass.
2875          */
2876         void checkSecurityManager(Class&lt;?&gt; refc, MemberName m) {
2877             if (allowedModes == TRUSTED)  return;
2878 
2879             SecurityManager smgr = System.getSecurityManager();
2880             if (smgr == null)  return;
2881 
2882             // Step 1:
2883             boolean fullPowerLookup = hasFullPrivilegeAccess();
2884             if (!fullPowerLookup ||
2885                 !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {
2886                 ReflectUtil.checkPackageAccess(refc);
2887             }
2888 
2889             if (m == null) {  // findClass or accessClass
2890                 // Step 2b:
2891                 if (!fullPowerLookup) {
2892                     smgr.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
2893                 }
2894                 return;
2895             }
2896 
2897             // Step 2a:
2898             if (m.isPublic()) return;
2899             if (!fullPowerLookup) {
2900                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
2901             }
2902 
2903             // Step 3:
2904             Class&lt;?&gt; defc = m.getDeclaringClass();
2905             if (!fullPowerLookup &amp;&amp; defc != refc) {
2906                 ReflectUtil.checkPackageAccess(defc);
2907             }
2908         }
2909 
2910         void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
2911             boolean wantStatic = (refKind == REF_invokeStatic);
2912             String message;
2913             if (m.isConstructor())
2914                 message = &quot;expected a method, not a constructor&quot;;
2915             else if (!m.isMethod())
2916                 message = &quot;expected a method&quot;;
2917             else if (wantStatic != m.isStatic())
2918                 message = wantStatic ? &quot;expected a static method&quot; : &quot;expected a non-static method&quot;;
2919             else
2920                 { checkAccess(refKind, refc, m); return; }
2921             throw m.makeAccessException(message, this);
2922         }
2923 
2924         void checkField(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
2925             boolean wantStatic = !MethodHandleNatives.refKindHasReceiver(refKind);
2926             String message;
2927             if (wantStatic != m.isStatic())
2928                 message = wantStatic ? &quot;expected a static field&quot; : &quot;expected a non-static field&quot;;
2929             else
2930                 { checkAccess(refKind, refc, m); return; }
2931             throw m.makeAccessException(message, this);
2932         }
2933 
2934         /** Check public/protected/private bits on the symbolic reference class and its member. */
2935         void checkAccess(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
2936             assert(m.referenceKindIsConsistentWith(refKind) &amp;&amp;
2937                    MethodHandleNatives.refKindIsValid(refKind) &amp;&amp;
2938                    (MethodHandleNatives.refKindIsField(refKind) == m.isField()));
2939             int allowedModes = this.allowedModes;
2940             if (allowedModes == TRUSTED)  return;
2941             int mods = m.getModifiers();
2942             if (Modifier.isProtected(mods) &amp;&amp;
2943                     refKind == REF_invokeVirtual &amp;&amp;
2944                     m.getDeclaringClass() == Object.class &amp;&amp;
2945                     m.getName().equals(&quot;clone&quot;) &amp;&amp;
2946                     refc.isArray()) {
2947                 // The JVM does this hack also.
2948                 // (See ClassVerifier::verify_invoke_instructions
2949                 // and LinkResolver::check_method_accessability.)
2950                 // Because the JVM does not allow separate methods on array types,
2951                 // there is no separate method for int[].clone.
2952                 // All arrays simply inherit Object.clone.
2953                 // But for access checking logic, we make Object.clone
2954                 // (normally protected) appear to be public.
2955                 // Later on, when the DirectMethodHandle is created,
2956                 // its leading argument will be restricted to the
2957                 // requested array type.
2958                 // N.B. The return type is not adjusted, because
2959                 // that is *not* the bytecode behavior.
2960                 mods ^= Modifier.PROTECTED | Modifier.PUBLIC;
2961             }
2962             if (Modifier.isProtected(mods) &amp;&amp; refKind == REF_newInvokeSpecial) {
2963                 // cannot &quot;new&quot; a protected ctor in a different package
2964                 mods ^= Modifier.PROTECTED;
2965             }
2966             if (Modifier.isFinal(mods) &amp;&amp;
2967                     MethodHandleNatives.refKindIsSetter(refKind))
2968                 throw m.makeAccessException(&quot;unexpected set of a final field&quot;, this);
2969             int requestedModes = fixmods(mods);  // adjust 0 =&gt; PACKAGE
2970             if ((requestedModes &amp; allowedModes) != 0) {
2971                 if (VerifyAccess.isMemberAccessible(refc, m.getDeclaringClass(),
2972                                                     mods, lookupClass(), previousLookupClass(), allowedModes))
2973                     return;
2974             } else {
2975                 // Protected members can also be checked as if they were package-private.
2976                 if ((requestedModes &amp; PROTECTED) != 0 &amp;&amp; (allowedModes &amp; PACKAGE) != 0
2977                         &amp;&amp; VerifyAccess.isSamePackage(m.getDeclaringClass(), lookupClass()))
2978                     return;
2979             }
2980             throw m.makeAccessException(accessFailedMessage(refc, m), this);
2981         }
2982 
2983         String accessFailedMessage(Class&lt;?&gt; refc, MemberName m) {
2984             Class&lt;?&gt; defc = m.getDeclaringClass();
2985             int mods = m.getModifiers();
2986             // check the class first:
2987             boolean classOK = (Modifier.isPublic(defc.getModifiers()) &amp;&amp;
2988                                (defc == refc ||
2989                                 Modifier.isPublic(refc.getModifiers())));
2990             if (!classOK &amp;&amp; (allowedModes &amp; PACKAGE) != 0) {
2991                 // ignore previous lookup class to check if default package access
2992                 classOK = (VerifyAccess.isClassAccessible(defc, lookupClass(), null, FULL_POWER_MODES) &amp;&amp;
2993                            (defc == refc ||
2994                             VerifyAccess.isClassAccessible(refc, lookupClass(), null, FULL_POWER_MODES)));
2995             }
2996             if (!classOK)
2997                 return &quot;class is not public&quot;;
2998             if (Modifier.isPublic(mods))
2999                 return &quot;access to public member failed&quot;;  // (how?, module not readable?)
3000             if (Modifier.isPrivate(mods))
3001                 return &quot;member is private&quot;;
3002             if (Modifier.isProtected(mods))
3003                 return &quot;member is protected&quot;;
3004             return &quot;member is private to package&quot;;
3005         }
3006 
3007         private void checkSpecialCaller(Class&lt;?&gt; specialCaller, Class&lt;?&gt; refc) throws IllegalAccessException {
3008             int allowedModes = this.allowedModes;
3009             if (allowedModes == TRUSTED)  return;
3010             if ((lookupModes() &amp; PRIVATE) == 0
3011                 || (specialCaller != lookupClass()
3012                        // ensure non-abstract methods in superinterfaces can be special-invoked
3013                     &amp;&amp; !(refc != null &amp;&amp; refc.isInterface() &amp;&amp; refc.isAssignableFrom(specialCaller))))
3014                 throw new MemberName(specialCaller).
3015                     makeAccessException(&quot;no private access for invokespecial&quot;, this);
3016         }
3017 
3018         private boolean restrictProtectedReceiver(MemberName method) {
3019             // The accessing class only has the right to use a protected member
3020             // on itself or a subclass.  Enforce that restriction, from JVMS 5.4.4, etc.
3021             if (!method.isProtected() || method.isStatic()
3022                 || allowedModes == TRUSTED
3023                 || method.getDeclaringClass() == lookupClass()
3024                 || VerifyAccess.isSamePackage(method.getDeclaringClass(), lookupClass()))
3025                 return false;
3026             return true;
3027         }
3028         private MethodHandle restrictReceiver(MemberName method, DirectMethodHandle mh, Class&lt;?&gt; caller) throws IllegalAccessException {
3029             assert(!method.isStatic());
3030             // receiver type of mh is too wide; narrow to caller
3031             if (!method.getDeclaringClass().isAssignableFrom(caller)) {
3032                 throw method.makeAccessException(&quot;caller class must be a subclass below the method&quot;, caller);
3033             }
3034             MethodType rawType = mh.type();
3035             if (caller.isAssignableFrom(rawType.parameterType(0))) return mh; // no need to restrict; already narrow
3036             MethodType narrowType = rawType.changeParameterType(0, caller);
3037             assert(!mh.isVarargsCollector());  // viewAsType will lose varargs-ness
3038             assert(mh.viewAsTypeChecks(narrowType, true));
3039             return mh.copyWith(narrowType, mh.form);
3040         }
3041 
3042         /** Check access and get the requested method. */
3043         private MethodHandle getDirectMethod(byte refKind, Class&lt;?&gt; refc, MemberName method, Lookup callerLookup) throws IllegalAccessException {
3044             final boolean doRestrict    = true;
3045             final boolean checkSecurity = true;
3046             return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, callerLookup);
3047         }
3048         /** Check access and get the requested method, for invokespecial with no restriction on the application of narrowing rules. */
3049         private MethodHandle getDirectMethodNoRestrictInvokeSpecial(Class&lt;?&gt; refc, MemberName method, Lookup callerLookup) throws IllegalAccessException {
3050             final boolean doRestrict    = false;
3051             final boolean checkSecurity = true;
3052             return getDirectMethodCommon(REF_invokeSpecial, refc, method, checkSecurity, doRestrict, callerLookup);
3053         }
3054         /** Check access and get the requested method, eliding security manager checks. */
3055         private MethodHandle getDirectMethodNoSecurityManager(byte refKind, Class&lt;?&gt; refc, MemberName method, Lookup callerLookup) throws IllegalAccessException {
3056             final boolean doRestrict    = true;
3057             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3058             return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, callerLookup);
3059         }
3060         /** Common code for all methods; do not call directly except from immediately above. */
3061         private MethodHandle getDirectMethodCommon(byte refKind, Class&lt;?&gt; refc, MemberName method,
3062                                                    boolean checkSecurity,
3063                                                    boolean doRestrict,
3064                                                    Lookup boundCaller) throws IllegalAccessException {
3065             checkMethod(refKind, refc, method);
3066             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3067             if (checkSecurity)
3068                 checkSecurityManager(refc, method);
3069             assert(!method.isMethodHandleInvoke());
3070 
3071             if (refKind == REF_invokeSpecial &amp;&amp;
3072                 refc != lookupClass() &amp;&amp;
3073                 !refc.isInterface() &amp;&amp;
3074                 refc != lookupClass().getSuperclass() &amp;&amp;
3075                 refc.isAssignableFrom(lookupClass())) {
3076                 assert(!method.getName().equals(&quot;&lt;init&gt;&quot;));  // not this code path
3077 
3078                 // Per JVMS 6.5, desc. of invokespecial instruction:
3079                 // If the method is in a superclass of the LC,
3080                 // and if our original search was above LC.super,
3081                 // repeat the search (symbolic lookup) from LC.super
3082                 // and continue with the direct superclass of that class,
3083                 // and so forth, until a match is found or no further superclasses exist.
3084                 // FIXME: MemberName.resolve should handle this instead.
3085                 Class&lt;?&gt; refcAsSuper = lookupClass();
3086                 MemberName m2;
3087                 do {
3088                     refcAsSuper = refcAsSuper.getSuperclass();
3089                     m2 = new MemberName(refcAsSuper,
3090                                         method.getName(),
3091                                         method.getMethodType(),
3092                                         REF_invokeSpecial);
3093                     m2 = IMPL_NAMES.resolveOrNull(refKind, m2, lookupClassOrNull());
3094                 } while (m2 == null &amp;&amp;         // no method is found yet
3095                          refc != refcAsSuper); // search up to refc
3096                 if (m2 == null)  throw new InternalError(method.toString());
3097                 method = m2;
3098                 refc = refcAsSuper;
3099                 // redo basic checks
3100                 checkMethod(refKind, refc, method);
3101             }
3102             DirectMethodHandle dmh = DirectMethodHandle.make(refKind, refc, method, lookupClass());
3103             MethodHandle mh = dmh;
3104             // Optionally narrow the receiver argument to lookupClass using restrictReceiver.
3105             if ((doRestrict &amp;&amp; refKind == REF_invokeSpecial) ||
3106                     (MethodHandleNatives.refKindHasReceiver(refKind) &amp;&amp; restrictProtectedReceiver(method))) {
3107                 mh = restrictReceiver(method, dmh, lookupClass());
3108             }
3109             mh = maybeBindCaller(method, mh, boundCaller);
3110             mh = mh.setVarargs(method);
3111             return mh;
3112         }
3113         private MethodHandle maybeBindCaller(MemberName method, MethodHandle mh, Lookup boundCaller)
3114                                              throws IllegalAccessException {
3115             if (boundCaller.allowedModes == TRUSTED || !MethodHandleNatives.isCallerSensitive(method))
3116                 return mh;
3117 
3118             // boundCaller must have full privilege access.
3119             // It should have been checked by findBoundCallerLookup. Safe to check this again.
3120             if (!boundCaller.hasFullPrivilegeAccess())
3121                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
3122 
3123             MethodHandle cbmh = MethodHandleImpl.bindCaller(mh, boundCaller.lookupClass);
3124             // Note: caller will apply varargs after this step happens.
3125             return cbmh;
3126         }
3127 
3128         /** Check access and get the requested field. */
3129         private MethodHandle getDirectField(byte refKind, Class&lt;?&gt; refc, MemberName field) throws IllegalAccessException {
3130             final boolean checkSecurity = true;
3131             return getDirectFieldCommon(refKind, refc, field, checkSecurity);
3132         }
3133         /** Check access and get the requested field, eliding security manager checks. */
3134         private MethodHandle getDirectFieldNoSecurityManager(byte refKind, Class&lt;?&gt; refc, MemberName field) throws IllegalAccessException {
3135             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3136             return getDirectFieldCommon(refKind, refc, field, checkSecurity);
3137         }
3138         /** Common code for all fields; do not call directly except from immediately above. */
3139         private MethodHandle getDirectFieldCommon(byte refKind, Class&lt;?&gt; refc, MemberName field,
3140                                                   boolean checkSecurity) throws IllegalAccessException {
3141             checkField(refKind, refc, field);
3142             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3143             if (checkSecurity)
3144                 checkSecurityManager(refc, field);
3145             DirectMethodHandle dmh = DirectMethodHandle.make(refc, field);
3146             boolean doRestrict = (MethodHandleNatives.refKindHasReceiver(refKind) &amp;&amp;
3147                                     restrictProtectedReceiver(field));
3148             if (doRestrict)
3149                 return restrictReceiver(field, dmh, lookupClass());
3150             return dmh;
3151         }
3152         private VarHandle getFieldVarHandle(byte getRefKind, byte putRefKind,
3153                                             Class&lt;?&gt; refc, MemberName getField, MemberName putField)
3154                 throws IllegalAccessException {
3155             final boolean checkSecurity = true;
3156             return getFieldVarHandleCommon(getRefKind, putRefKind, refc, getField, putField, checkSecurity);
3157         }
3158         private VarHandle getFieldVarHandleNoSecurityManager(byte getRefKind, byte putRefKind,
3159                                                              Class&lt;?&gt; refc, MemberName getField, MemberName putField)
3160                 throws IllegalAccessException {
3161             final boolean checkSecurity = false;
3162             return getFieldVarHandleCommon(getRefKind, putRefKind, refc, getField, putField, checkSecurity);
3163         }
3164         private VarHandle getFieldVarHandleCommon(byte getRefKind, byte putRefKind,
3165                                                   Class&lt;?&gt; refc, MemberName getField, MemberName putField,
3166                                                   boolean checkSecurity) throws IllegalAccessException {
3167             assert getField.isStatic() == putField.isStatic();
3168             assert getField.isGetter() &amp;&amp; putField.isSetter();
3169             assert MethodHandleNatives.refKindIsStatic(getRefKind) == MethodHandleNatives.refKindIsStatic(putRefKind);
3170             assert MethodHandleNatives.refKindIsGetter(getRefKind) &amp;&amp; MethodHandleNatives.refKindIsSetter(putRefKind);
3171 
3172             checkField(getRefKind, refc, getField);
3173             if (checkSecurity)
3174                 checkSecurityManager(refc, getField);
3175 
3176             if (!putField.isFinal()) {
3177                 // A VarHandle does not support updates to final fields, any
3178                 // such VarHandle to a final field will be read-only and
3179                 // therefore the following write-based accessibility checks are
3180                 // only required for non-final fields
3181                 checkField(putRefKind, refc, putField);
3182                 if (checkSecurity)
3183                     checkSecurityManager(refc, putField);
3184             }
3185 
3186             boolean doRestrict = (MethodHandleNatives.refKindHasReceiver(getRefKind) &amp;&amp;
3187                                   restrictProtectedReceiver(getField));
3188             if (doRestrict) {
3189                 assert !getField.isStatic();
3190                 // receiver type of VarHandle is too wide; narrow to caller
3191                 if (!getField.getDeclaringClass().isAssignableFrom(lookupClass())) {
3192                     throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
3193                 }
3194                 refc = lookupClass();
3195             }
3196             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(), this.allowedModes == TRUSTED);
3197         }
3198         /** Check access and get the requested constructor. */
3199         private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3200             final boolean checkSecurity = true;
3201             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3202         }
3203         /** Check access and get the requested constructor, eliding security manager checks. */
3204         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3205             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3206             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3207         }
3208         /** Common code for all constructors; do not call directly except from immediately above. */
3209         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3210                                                   boolean checkSecurity) throws IllegalAccessException {
3211             assert(ctor.isConstructor());
3212             checkAccess(REF_newInvokeSpecial, refc, ctor);
3213             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3214             if (checkSecurity)
3215                 checkSecurityManager(refc, ctor);
3216             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
3217             return DirectMethodHandle.make(ctor).setVarargs(ctor);
3218         }
3219 
3220         /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
3221          */
3222         /*non-public*/
3223         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type)
3224                 throws ReflectiveOperationException {
3225             if (!(type instanceof Class || type instanceof MethodType))
3226                 throw new InternalError(&quot;unresolved MemberName&quot;);
3227             MemberName member = new MemberName(refKind, defc, name, type);
3228             MethodHandle mh = LOOKASIDE_TABLE.get(member);
3229             if (mh != null) {
3230                 checkSymbolicClass(defc);
3231                 return mh;
3232             }
3233             if (defc == MethodHandle.class &amp;&amp; refKind == REF_invokeVirtual) {
3234                 // Treat MethodHandle.invoke and invokeExact specially.
3235                 mh = findVirtualForMH(member.getName(), member.getMethodType());
3236                 if (mh != null) {
3237                     return mh;
3238                 }
3239             } else if (defc == VarHandle.class &amp;&amp; refKind == REF_invokeVirtual) {
3240                 // Treat signature-polymorphic methods on VarHandle specially.
3241                 mh = findVirtualForVH(member.getName(), member.getMethodType());
3242                 if (mh != null) {
3243                     return mh;
3244                 }
3245             }
3246             MemberName resolved = resolveOrFail(refKind, member);
3247             mh = getDirectMethodForConstant(refKind, defc, resolved);
3248             if (mh instanceof DirectMethodHandle
3249                     &amp;&amp; canBeCached(refKind, defc, resolved)) {
3250                 MemberName key = mh.internalMemberName();
3251                 if (key != null) {
3252                     key = key.asNormalOriginal();
3253                 }
3254                 if (member.equals(key)) {  // better safe than sorry
3255                     LOOKASIDE_TABLE.put(key, (DirectMethodHandle) mh);
3256                 }
3257             }
3258             return mh;
3259         }
3260         private boolean canBeCached(byte refKind, Class&lt;?&gt; defc, MemberName member) {
3261             if (refKind == REF_invokeSpecial) {
3262                 return false;
3263             }
3264             if (!Modifier.isPublic(defc.getModifiers()) ||
3265                     !Modifier.isPublic(member.getDeclaringClass().getModifiers()) ||
3266                     !member.isPublic() ||
3267                     member.isCallerSensitive()) {
3268                 return false;
3269             }
3270             ClassLoader loader = defc.getClassLoader();
3271             if (loader != null) {
3272                 ClassLoader sysl = ClassLoader.getSystemClassLoader();
3273                 boolean found = false;
3274                 while (sysl != null) {
3275                     if (loader == sysl) { found = true; break; }
3276                     sysl = sysl.getParent();
3277                 }
3278                 if (!found) {
3279                     return false;
3280                 }
3281             }
3282             try {
3283                 MemberName resolved2 = publicLookup().resolveOrNull(refKind,
3284                     new MemberName(refKind, defc, member.getName(), member.getType()));
3285                 if (resolved2 == null) {
3286                     return false;
3287                 }
3288                 checkSecurityManager(defc, resolved2);
3289             } catch (SecurityException ex) {
3290                 return false;
3291             }
3292             return true;
3293         }
3294         private MethodHandle getDirectMethodForConstant(byte refKind, Class&lt;?&gt; defc, MemberName member)
3295                 throws ReflectiveOperationException {
3296             if (MethodHandleNatives.refKindIsField(refKind)) {
3297                 return getDirectFieldNoSecurityManager(refKind, defc, member);
3298             } else if (MethodHandleNatives.refKindIsMethod(refKind)) {
3299                 return getDirectMethodNoSecurityManager(refKind, defc, member, findBoundCallerLookup(member));
3300             } else if (refKind == REF_newInvokeSpecial) {
3301                 return getDirectConstructorNoSecurityManager(defc, member);
3302             }
3303             // oops
3304             throw newIllegalArgumentException(&quot;bad MethodHandle constant #&quot;+member);
3305         }
3306 
3307         static ConcurrentHashMap&lt;MemberName, DirectMethodHandle&gt; LOOKASIDE_TABLE = new ConcurrentHashMap&lt;&gt;();
3308     }
3309 
3310     /**
3311      * Produces a method handle constructing arrays of a desired type,
3312      * as if by the {@code anewarray} bytecode.
3313      * The return type of the method handle will be the array type.
3314      * The type of its sole argument will be {@code int}, which specifies the size of the array.
3315      *
3316      * &lt;p&gt; If the returned method handle is invoked with a negative
3317      * array size, a {@code NegativeArraySizeException} will be thrown.
3318      *
3319      * @param arrayClass an array type
3320      * @return a method handle which can create arrays of the given type
3321      * @throws NullPointerException if the argument is {@code null}
3322      * @throws IllegalArgumentException if {@code arrayClass} is not an array type
3323      * @see java.lang.reflect.Array#newInstance(Class, int)
3324      * @jvms 6.5 {@code anewarray} Instruction
3325      * @since 9
3326      */
3327     public static MethodHandle arrayConstructor(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
3328         if (!arrayClass.isArray()) {
3329             throw newIllegalArgumentException(&quot;not an array class: &quot; + arrayClass.getName());
3330         }
3331         MethodHandle ani = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_Array_newInstance).
3332                 bindTo(arrayClass.getComponentType());
3333         return ani.asType(ani.type().changeReturnType(arrayClass));
3334     }
3335 
3336     /**
3337      * Produces a method handle returning the length of an array,
3338      * as if by the {@code arraylength} bytecode.
3339      * The type of the method handle will have {@code int} as return type,
3340      * and its sole argument will be the array type.
3341      *
3342      * &lt;p&gt; If the returned method handle is invoked with a {@code null}
3343      * array reference, a {@code NullPointerException} will be thrown.
3344      *
3345      * @param arrayClass an array type
3346      * @return a method handle which can retrieve the length of an array of the given array type
3347      * @throws NullPointerException if the argument is {@code null}
3348      * @throws IllegalArgumentException if arrayClass is not an array type
3349      * @jvms 6.5 {@code arraylength} Instruction
3350      * @since 9
3351      */
3352     public static MethodHandle arrayLength(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
3353         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.LENGTH);
3354     }
3355 
3356     /**
3357      * Produces a method handle giving read access to elements of an array,
3358      * as if by the {@code aaload} bytecode.
3359      * The type of the method handle will have a return type of the array&#39;s
3360      * element type.  Its first argument will be the array type,
3361      * and the second will be {@code int}.
3362      *
3363      * &lt;p&gt; When the returned method handle is invoked,
3364      * the array reference and array index are checked.
3365      * A {@code NullPointerException} will be thrown if the array reference
3366      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
3367      * thrown if the index is negative or if it is greater than or equal to
3368      * the length of the array.
3369      *
3370      * @param arrayClass an array type
3371      * @return a method handle which can load values from the given array type
3372      * @throws NullPointerException if the argument is null
3373      * @throws  IllegalArgumentException if arrayClass is not an array type
3374      * @jvms 6.5 {@code aaload} Instruction
3375      */
3376     public static MethodHandle arrayElementGetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
3377         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.GET);
3378     }
3379 
3380     /**
3381      * Produces a method handle giving write access to elements of an array,
3382      * as if by the {@code astore} bytecode.
3383      * The type of the method handle will have a void return type.
3384      * Its last argument will be the array&#39;s element type.
3385      * The first and second arguments will be the array type and int.
3386      *
3387      * &lt;p&gt; When the returned method handle is invoked,
3388      * the array reference and array index are checked.
3389      * A {@code NullPointerException} will be thrown if the array reference
3390      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
3391      * thrown if the index is negative or if it is greater than or equal to
3392      * the length of the array.
3393      *
3394      * @param arrayClass the class of an array
3395      * @return a method handle which can store values into the array type
3396      * @throws NullPointerException if the argument is null
3397      * @throws IllegalArgumentException if arrayClass is not an array type
3398      * @jvms 6.5 {@code aastore} Instruction
3399      */
3400     public static MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
3401         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
3402     }
3403 
3404     /**
3405      * Produces a VarHandle giving access to elements of an array of type
3406      * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
3407      * of {@code arrayClass} and the list of coordinate types is
3408      * {@code (arrayClass, int)}, where the {@code int} coordinate type
3409      * corresponds to an argument that is an index into an array.
3410      * &lt;p&gt;
3411      * Certain access modes of the returned VarHandle are unsupported under
3412      * the following conditions:
3413      * &lt;ul&gt;
3414      * &lt;li&gt;if the component type is anything other than {@code byte},
3415      *     {@code short}, {@code char}, {@code int}, {@code long},
3416      *     {@code float}, or {@code double} then numeric atomic update access
3417      *     modes are unsupported.
3418      * &lt;li&gt;if the field type is anything other than {@code boolean},
3419      *     {@code byte}, {@code short}, {@code char}, {@code int} or
3420      *     {@code long} then bitwise atomic update access modes are
3421      *     unsupported.
3422      * &lt;/ul&gt;
3423      * &lt;p&gt;
3424      * If the component type is {@code float} or {@code double} then numeric
3425      * and atomic update access modes compare values using their bitwise
3426      * representation (see {@link Float#floatToRawIntBits} and
3427      * {@link Double#doubleToRawLongBits}, respectively).
3428      *
3429      * &lt;p&gt; When the returned {@code VarHandle} is invoked,
3430      * the array reference and array index are checked.
3431      * A {@code NullPointerException} will be thrown if the array reference
3432      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
3433      * thrown if the index is negative or if it is greater than or equal to
3434      * the length of the array.
3435      *
3436      * @apiNote
3437      * Bitwise comparison of {@code float} values or {@code double} values,
3438      * as performed by the numeric and atomic update access modes, differ
3439      * from the primitive {@code ==} operator and the {@link Float#equals}
3440      * and {@link Double#equals} methods, specifically with respect to
3441      * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
3442      * Care should be taken when performing a compare and set or a compare
3443      * and exchange operation with such values since the operation may
3444      * unexpectedly fail.
3445      * There are many possible NaN values that are considered to be
3446      * {@code NaN} in Java, although no IEEE 754 floating-point operation
3447      * provided by Java can distinguish between them.  Operation failure can
3448      * occur if the expected or witness value is a NaN value and it is
3449      * transformed (perhaps in a platform specific manner) into another NaN
3450      * value, and thus has a different bitwise representation (see
3451      * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
3452      * details).
3453      * The values {@code -0.0} and {@code +0.0} have different bitwise
3454      * representations but are considered equal when using the primitive
3455      * {@code ==} operator.  Operation failure can occur if, for example, a
3456      * numeric algorithm computes an expected value to be say {@code -0.0}
3457      * and previously computed the witness value to be say {@code +0.0}.
3458      * @param arrayClass the class of an array, of type {@code T[]}
3459      * @return a VarHandle giving access to elements of an array
3460      * @throws NullPointerException if the arrayClass is null
3461      * @throws IllegalArgumentException if arrayClass is not an array type
3462      * @since 9
3463      */
3464     public static VarHandle arrayElementVarHandle(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
3465         return VarHandles.makeArrayElementHandle(arrayClass);
3466     }
3467 
3468     /**
3469      * Produces a VarHandle giving access to elements of a {@code byte[]} array
3470      * viewed as if it were a different primitive array type, such as
3471      * {@code int[]} or {@code long[]}.
3472      * The VarHandle&#39;s variable type is the component type of
3473      * {@code viewArrayClass} and the list of coordinate types is
3474      * {@code (byte[], int)}, where the {@code int} coordinate type
3475      * corresponds to an argument that is an index into a {@code byte[]} array.
3476      * The returned VarHandle accesses bytes at an index in a {@code byte[]}
3477      * array, composing bytes to or from a value of the component type of
3478      * {@code viewArrayClass} according to the given endianness.
3479      * &lt;p&gt;
3480      * The supported component types (variables types) are {@code short},
3481      * {@code char}, {@code int}, {@code long}, {@code float} and
3482      * {@code double}.
3483      * &lt;p&gt;
3484      * Access of bytes at a given index will result in an
3485      * {@code IndexOutOfBoundsException} if the index is less than {@code 0}
3486      * or greater than the {@code byte[]} array length minus the size (in bytes)
3487      * of {@code T}.
3488      * &lt;p&gt;
3489      * Access of bytes at an index may be aligned or misaligned for {@code T},
3490      * with respect to the underlying memory address, {@code A} say, associated
3491      * with the array and index.
3492      * If access is misaligned then access for anything other than the
3493      * {@code get} and {@code set} access modes will result in an
3494      * {@code IllegalStateException}.  In such cases atomic access is only
3495      * guaranteed with respect to the largest power of two that divides the GCD
3496      * of {@code A} and the size (in bytes) of {@code T}.
3497      * If access is aligned then following access modes are supported and are
3498      * guaranteed to support atomic access:
3499      * &lt;ul&gt;
3500      * &lt;li&gt;read write access modes for all {@code T}, with the exception of
3501      *     access modes {@code get} and {@code set} for {@code long} and
3502      *     {@code double} on 32-bit platforms.
3503      * &lt;li&gt;atomic update access modes for {@code int}, {@code long},
3504      *     {@code float} or {@code double}.
3505      *     (Future major platform releases of the JDK may support additional
3506      *     types for certain currently unsupported access modes.)
3507      * &lt;li&gt;numeric atomic update access modes for {@code int} and {@code long}.
3508      *     (Future major platform releases of the JDK may support additional
3509      *     numeric types for certain currently unsupported access modes.)
3510      * &lt;li&gt;bitwise atomic update access modes for {@code int} and {@code long}.
3511      *     (Future major platform releases of the JDK may support additional
3512      *     numeric types for certain currently unsupported access modes.)
3513      * &lt;/ul&gt;
3514      * &lt;p&gt;
3515      * Misaligned access, and therefore atomicity guarantees, may be determined
3516      * for {@code byte[]} arrays without operating on a specific array.  Given
3517      * an {@code index}, {@code T} and it&#39;s corresponding boxed type,
3518      * {@code T_BOX}, misalignment may be determined as follows:
3519      * &lt;pre&gt;{@code
3520      * int sizeOfT = T_BOX.BYTES;  // size in bytes of T
3521      * int misalignedAtZeroIndex = ByteBuffer.wrap(new byte[0]).
3522      *     alignmentOffset(0, sizeOfT);
3523      * int misalignedAtIndex = (misalignedAtZeroIndex + index) % sizeOfT;
3524      * boolean isMisaligned = misalignedAtIndex != 0;
3525      * }&lt;/pre&gt;
3526      * &lt;p&gt;
3527      * If the variable type is {@code float} or {@code double} then atomic
3528      * update access modes compare values using their bitwise representation
3529      * (see {@link Float#floatToRawIntBits} and
3530      * {@link Double#doubleToRawLongBits}, respectively).
3531      * @param viewArrayClass the view array class, with a component type of
3532      * type {@code T}
3533      * @param byteOrder the endianness of the view array elements, as
3534      * stored in the underlying {@code byte} array
3535      * @return a VarHandle giving access to elements of a {@code byte[]} array
3536      * viewed as if elements corresponding to the components type of the view
3537      * array class
3538      * @throws NullPointerException if viewArrayClass or byteOrder is null
3539      * @throws IllegalArgumentException if viewArrayClass is not an array type
3540      * @throws UnsupportedOperationException if the component type of
3541      * viewArrayClass is not supported as a variable type
3542      * @since 9
3543      */
3544     public static VarHandle byteArrayViewVarHandle(Class&lt;?&gt; viewArrayClass,
3545                                      ByteOrder byteOrder) throws IllegalArgumentException {
3546         Objects.requireNonNull(byteOrder);
3547         return VarHandles.byteArrayViewHandle(viewArrayClass,
3548                                               byteOrder == ByteOrder.BIG_ENDIAN);
3549     }
3550 
3551     /**
3552      * Produces a VarHandle giving access to elements of a {@code ByteBuffer}
3553      * viewed as if it were an array of elements of a different primitive
3554      * component type to that of {@code byte}, such as {@code int[]} or
3555      * {@code long[]}.
3556      * The VarHandle&#39;s variable type is the component type of
3557      * {@code viewArrayClass} and the list of coordinate types is
3558      * {@code (ByteBuffer, int)}, where the {@code int} coordinate type
3559      * corresponds to an argument that is an index into a {@code byte[]} array.
3560      * The returned VarHandle accesses bytes at an index in a
3561      * {@code ByteBuffer}, composing bytes to or from a value of the component
3562      * type of {@code viewArrayClass} according to the given endianness.
3563      * &lt;p&gt;
3564      * The supported component types (variables types) are {@code short},
3565      * {@code char}, {@code int}, {@code long}, {@code float} and
3566      * {@code double}.
3567      * &lt;p&gt;
3568      * Access will result in a {@code ReadOnlyBufferException} for anything
3569      * other than the read access modes if the {@code ByteBuffer} is read-only.
3570      * &lt;p&gt;
3571      * Access of bytes at a given index will result in an
3572      * {@code IndexOutOfBoundsException} if the index is less than {@code 0}
3573      * or greater than the {@code ByteBuffer} limit minus the size (in bytes) of
3574      * {@code T}.
3575      * &lt;p&gt;
3576      * Access of bytes at an index may be aligned or misaligned for {@code T},
3577      * with respect to the underlying memory address, {@code A} say, associated
3578      * with the {@code ByteBuffer} and index.
3579      * If access is misaligned then access for anything other than the
3580      * {@code get} and {@code set} access modes will result in an
3581      * {@code IllegalStateException}.  In such cases atomic access is only
3582      * guaranteed with respect to the largest power of two that divides the GCD
3583      * of {@code A} and the size (in bytes) of {@code T}.
3584      * If access is aligned then following access modes are supported and are
3585      * guaranteed to support atomic access:
3586      * &lt;ul&gt;
3587      * &lt;li&gt;read write access modes for all {@code T}, with the exception of
3588      *     access modes {@code get} and {@code set} for {@code long} and
3589      *     {@code double} on 32-bit platforms.
3590      * &lt;li&gt;atomic update access modes for {@code int}, {@code long},
3591      *     {@code float} or {@code double}.
3592      *     (Future major platform releases of the JDK may support additional
3593      *     types for certain currently unsupported access modes.)
3594      * &lt;li&gt;numeric atomic update access modes for {@code int} and {@code long}.
3595      *     (Future major platform releases of the JDK may support additional
3596      *     numeric types for certain currently unsupported access modes.)
3597      * &lt;li&gt;bitwise atomic update access modes for {@code int} and {@code long}.
3598      *     (Future major platform releases of the JDK may support additional
3599      *     numeric types for certain currently unsupported access modes.)
3600      * &lt;/ul&gt;
3601      * &lt;p&gt;
3602      * Misaligned access, and therefore atomicity guarantees, may be determined
3603      * for a {@code ByteBuffer}, {@code bb} (direct or otherwise), an
3604      * {@code index}, {@code T} and it&#39;s corresponding boxed type,
3605      * {@code T_BOX}, as follows:
3606      * &lt;pre&gt;{@code
3607      * int sizeOfT = T_BOX.BYTES;  // size in bytes of T
3608      * ByteBuffer bb = ...
3609      * int misalignedAtIndex = bb.alignmentOffset(index, sizeOfT);
3610      * boolean isMisaligned = misalignedAtIndex != 0;
3611      * }&lt;/pre&gt;
3612      * &lt;p&gt;
3613      * If the variable type is {@code float} or {@code double} then atomic
3614      * update access modes compare values using their bitwise representation
3615      * (see {@link Float#floatToRawIntBits} and
3616      * {@link Double#doubleToRawLongBits}, respectively).
3617      * @param viewArrayClass the view array class, with a component type of
3618      * type {@code T}
3619      * @param byteOrder the endianness of the view array elements, as
3620      * stored in the underlying {@code ByteBuffer} (Note this overrides the
3621      * endianness of a {@code ByteBuffer})
3622      * @return a VarHandle giving access to elements of a {@code ByteBuffer}
3623      * viewed as if elements corresponding to the components type of the view
3624      * array class
3625      * @throws NullPointerException if viewArrayClass or byteOrder is null
3626      * @throws IllegalArgumentException if viewArrayClass is not an array type
3627      * @throws UnsupportedOperationException if the component type of
3628      * viewArrayClass is not supported as a variable type
3629      * @since 9
3630      */
3631     public static VarHandle byteBufferViewVarHandle(Class&lt;?&gt; viewArrayClass,
3632                                       ByteOrder byteOrder) throws IllegalArgumentException {
3633         Objects.requireNonNull(byteOrder);
3634         return VarHandles.makeByteBufferViewHandle(viewArrayClass,
3635                                                    byteOrder == ByteOrder.BIG_ENDIAN);
3636     }
3637 
3638 
3639     /// method handle invocation (reflective style)
3640 
3641     /**
3642      * Produces a method handle which will invoke any method handle of the
3643      * given {@code type}, with a given number of trailing arguments replaced by
3644      * a single trailing {@code Object[]} array.
3645      * The resulting invoker will be a method handle with the following
3646      * arguments:
3647      * &lt;ul&gt;
3648      * &lt;li&gt;a single {@code MethodHandle} target
3649      * &lt;li&gt;zero or more leading values (counted by {@code leadingArgCount})
3650      * &lt;li&gt;an {@code Object[]} array containing trailing arguments
3651      * &lt;/ul&gt;
3652      * &lt;p&gt;
3653      * The invoker will invoke its target like a call to {@link MethodHandle#invoke invoke} with
3654      * the indicated {@code type}.
3655      * That is, if the target is exactly of the given {@code type}, it will behave
3656      * like {@code invokeExact}; otherwise it behave as if {@link MethodHandle#asType asType}
3657      * is used to convert the target to the required {@code type}.
3658      * &lt;p&gt;
3659      * The type of the returned invoker will not be the given {@code type}, but rather
3660      * will have all parameters except the first {@code leadingArgCount}
3661      * replaced by a single array of type {@code Object[]}, which will be
3662      * the final parameter.
3663      * &lt;p&gt;
3664      * Before invoking its target, the invoker will spread the final array, apply
3665      * reference casts as necessary, and unbox and widen primitive arguments.
3666      * If, when the invoker is called, the supplied array argument does
3667      * not have the correct number of elements, the invoker will throw
3668      * an {@link IllegalArgumentException} instead of invoking the target.
3669      * &lt;p&gt;
3670      * This method is equivalent to the following code (though it may be more efficient):
3671      * &lt;blockquote&gt;&lt;pre&gt;{@code
3672 MethodHandle invoker = MethodHandles.invoker(type);
3673 int spreadArgCount = type.parameterCount() - leadingArgCount;
3674 invoker = invoker.asSpreader(Object[].class, spreadArgCount);
3675 return invoker;
3676      * }&lt;/pre&gt;&lt;/blockquote&gt;
3677      * This method throws no reflective or security exceptions.
3678      * @param type the desired target type
3679      * @param leadingArgCount number of fixed arguments, to be passed unchanged to the target
3680      * @return a method handle suitable for invoking any method handle of the given type
3681      * @throws NullPointerException if {@code type} is null
3682      * @throws IllegalArgumentException if {@code leadingArgCount} is not in
3683      *                  the range from 0 to {@code type.parameterCount()} inclusive,
3684      *                  or if the resulting method handle&#39;s type would have
3685      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
3686      */
3687     public static MethodHandle spreadInvoker(MethodType type, int leadingArgCount) {
3688         if (leadingArgCount &lt; 0 || leadingArgCount &gt; type.parameterCount())
3689             throw newIllegalArgumentException(&quot;bad argument count&quot;, leadingArgCount);
3690         type = type.asSpreaderType(Object[].class, leadingArgCount, type.parameterCount() - leadingArgCount);
3691         return type.invokers().spreadInvoker(leadingArgCount);
3692     }
3693 
3694     /**
3695      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
3696      * invoke any method handle of the given type, as if by {@link MethodHandle#invokeExact invokeExact}.
3697      * The resulting invoker will have a type which is
3698      * exactly equal to the desired type, except that it will accept
3699      * an additional leading argument of type {@code MethodHandle}.
3700      * &lt;p&gt;
3701      * This method is equivalent to the following code (though it may be more efficient):
3702      * {@code publicLookup().findVirtual(MethodHandle.class, &quot;invokeExact&quot;, type)}
3703      *
3704      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
3705      * &lt;em&gt;Discussion:&lt;/em&gt;
3706      * Invoker method handles can be useful when working with variable method handles
3707      * of unknown types.
3708      * For example, to emulate an {@code invokeExact} call to a variable method
3709      * handle {@code M}, extract its type {@code T},
3710      * look up the invoker method {@code X} for {@code T},
3711      * and call the invoker method, as {@code X.invoke(T, A...)}.
3712      * (It would not work to call {@code X.invokeExact}, since the type {@code T}
3713      * is unknown.)
3714      * If spreading, collecting, or other argument transformations are required,
3715      * they can be applied once to the invoker {@code X} and reused on many {@code M}
3716      * method handle values, as long as they are compatible with the type of {@code X}.
3717      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
3718      * &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
3719      * An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
3720      * on the declared {@code invokeExact} or {@code invoke} method will raise an
3721      * {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)&lt;/em&gt;
3722      * &lt;p&gt;
3723      * This method throws no reflective or security exceptions.
3724      * @param type the desired target type
3725      * @return a method handle suitable for invoking any method handle of the given type
3726      * @throws IllegalArgumentException if the resulting method handle&#39;s type would have
3727      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
3728      */
3729     public static MethodHandle exactInvoker(MethodType type) {
3730         return type.invokers().exactInvoker();
3731     }
3732 
3733     /**
3734      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
3735      * invoke any method handle compatible with the given type, as if by {@link MethodHandle#invoke invoke}.
3736      * The resulting invoker will have a type which is
3737      * exactly equal to the desired type, except that it will accept
3738      * an additional leading argument of type {@code MethodHandle}.
3739      * &lt;p&gt;
3740      * Before invoking its target, if the target differs from the expected type,
3741      * the invoker will apply reference casts as
3742      * necessary and box, unbox, or widen primitive values, as if by {@link MethodHandle#asType asType}.
3743      * Similarly, the return value will be converted as necessary.
3744      * If the target is a {@linkplain MethodHandle#asVarargsCollector variable arity method handle},
3745      * the required arity conversion will be made, again as if by {@link MethodHandle#asType asType}.
3746      * &lt;p&gt;
3747      * This method is equivalent to the following code (though it may be more efficient):
3748      * {@code publicLookup().findVirtual(MethodHandle.class, &quot;invoke&quot;, type)}
3749      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
3750      * &lt;em&gt;Discussion:&lt;/em&gt;
3751      * A {@linkplain MethodType#genericMethodType general method type} is one which
3752      * mentions only {@code Object} arguments and return values.
3753      * An invoker for such a type is capable of calling any method handle
3754      * of the same arity as the general type.
3755      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
3756      * &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
3757      * An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
3758      * on the declared {@code invokeExact} or {@code invoke} method will raise an
3759      * {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)&lt;/em&gt;
3760      * &lt;p&gt;
3761      * This method throws no reflective or security exceptions.
3762      * @param type the desired target type
3763      * @return a method handle suitable for invoking any method handle convertible to the given type
3764      * @throws IllegalArgumentException if the resulting method handle&#39;s type would have
3765      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
3766      */
3767     public static MethodHandle invoker(MethodType type) {
3768         return type.invokers().genericInvoker();
3769     }
3770 
3771     /**
3772      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
3773      * invoke a signature-polymorphic access mode method on any VarHandle whose
3774      * associated access mode type is compatible with the given type.
3775      * The resulting invoker will have a type which is exactly equal to the
3776      * desired given type, except that it will accept an additional leading
3777      * argument of type {@code VarHandle}.
3778      *
3779      * @param accessMode the VarHandle access mode
3780      * @param type the desired target type
3781      * @return a method handle suitable for invoking an access mode method of
3782      *         any VarHandle whose access mode type is of the given type.
3783      * @since 9
3784      */
3785     public static MethodHandle varHandleExactInvoker(VarHandle.AccessMode accessMode, MethodType type) {
3786         return type.invokers().varHandleMethodExactInvoker(accessMode);
3787     }
3788 
3789     /**
3790      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
3791      * invoke a signature-polymorphic access mode method on any VarHandle whose
3792      * associated access mode type is compatible with the given type.
3793      * The resulting invoker will have a type which is exactly equal to the
3794      * desired given type, except that it will accept an additional leading
3795      * argument of type {@code VarHandle}.
3796      * &lt;p&gt;
3797      * Before invoking its target, if the access mode type differs from the
3798      * desired given type, the invoker will apply reference casts as necessary
3799      * and box, unbox, or widen primitive values, as if by
3800      * {@link MethodHandle#asType asType}.  Similarly, the return value will be
3801      * converted as necessary.
3802      * &lt;p&gt;
3803      * This method is equivalent to the following code (though it may be more
3804      * efficient): {@code publicLookup().findVirtual(VarHandle.class, accessMode.name(), type)}
3805      *
3806      * @param accessMode the VarHandle access mode
3807      * @param type the desired target type
3808      * @return a method handle suitable for invoking an access mode method of
3809      *         any VarHandle whose access mode type is convertible to the given
3810      *         type.
3811      * @since 9
3812      */
3813     public static MethodHandle varHandleInvoker(VarHandle.AccessMode accessMode, MethodType type) {
3814         return type.invokers().varHandleMethodInvoker(accessMode);
3815     }
3816 
3817     /*non-public*/
3818     static MethodHandle basicInvoker(MethodType type) {
3819         return type.invokers().basicInvoker();
3820     }
3821 
3822      /// method handle modification (creation from other method handles)
3823 
3824     /**
3825      * Produces a method handle which adapts the type of the
3826      * given method handle to a new type by pairwise argument and return type conversion.
3827      * The original type and new type must have the same number of arguments.
3828      * The resulting method handle is guaranteed to report a type
3829      * which is equal to the desired new type.
3830      * &lt;p&gt;
3831      * If the original type and new type are equal, returns target.
3832      * &lt;p&gt;
3833      * The same conversions are allowed as for {@link MethodHandle#asType MethodHandle.asType},
3834      * and some additional conversions are also applied if those conversions fail.
3835      * Given types &lt;em&gt;T0&lt;/em&gt;, &lt;em&gt;T1&lt;/em&gt;, one of the following conversions is applied
3836      * if possible, before or instead of any conversions done by {@code asType}:
3837      * &lt;ul&gt;
3838      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, and &lt;em&gt;T1&lt;/em&gt; is an interface type,
3839      *     then the value of type &lt;em&gt;T0&lt;/em&gt; is passed as a &lt;em&gt;T1&lt;/em&gt; without a cast.
3840      *     (This treatment of interfaces follows the usage of the bytecode verifier.)
3841      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is boolean and &lt;em&gt;T1&lt;/em&gt; is another primitive,
3842      *     the boolean is converted to a byte value, 1 for true, 0 for false.
3843      *     (This treatment follows the usage of the bytecode verifier.)
3844      * &lt;li&gt;If &lt;em&gt;T1&lt;/em&gt; is boolean and &lt;em&gt;T0&lt;/em&gt; is another primitive,
3845      *     &lt;em&gt;T0&lt;/em&gt; is converted to byte via Java casting conversion (JLS 5.5),
3846      *     and the low order bit of the result is tested, as if by {@code (x &amp; 1) != 0}.
3847      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are primitives other than boolean,
3848      *     then a Java casting conversion (JLS 5.5) is applied.
3849      *     (Specifically, &lt;em&gt;T0&lt;/em&gt; will convert to &lt;em&gt;T1&lt;/em&gt; by
3850      *     widening and/or narrowing.)
3851      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing
3852      *     conversion will be applied at runtime, possibly followed
3853      *     by a Java casting conversion (JLS 5.5) on the primitive value,
3854      *     possibly followed by a conversion from byte to boolean by testing
3855      *     the low-order bit.
3856      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive,
3857      *     and if the reference is null at runtime, a zero value is introduced.
3858      * &lt;/ul&gt;
3859      * @param target the method handle to invoke after arguments are retyped
3860      * @param newType the expected type of the new method handle
3861      * @return a method handle which delegates to the target after performing
3862      *           any necessary argument conversions, and arranges for any
3863      *           necessary return value conversions
3864      * @throws NullPointerException if either argument is null
3865      * @throws WrongMethodTypeException if the conversion cannot be made
3866      * @see MethodHandle#asType
3867      */
3868     public static MethodHandle explicitCastArguments(MethodHandle target, MethodType newType) {
3869         explicitCastArgumentsChecks(target, newType);
3870         // use the asTypeCache when possible:
3871         MethodType oldType = target.type();
3872         if (oldType == newType)  return target;
3873         if (oldType.explicitCastEquivalentToAsType(newType)) {
3874             return target.asFixedArity().asType(newType);
3875         }
3876         return MethodHandleImpl.makePairwiseConvert(target, newType, false);
3877     }
3878 
3879     private static void explicitCastArgumentsChecks(MethodHandle target, MethodType newType) {
3880         if (target.type().parameterCount() != newType.parameterCount()) {
3881             throw new WrongMethodTypeException(&quot;cannot explicitly cast &quot; + target + &quot; to &quot; + newType);
3882         }
3883     }
3884 
3885     /**
3886      * Produces a method handle which adapts the calling sequence of the
3887      * given method handle to a new type, by reordering the arguments.
3888      * The resulting method handle is guaranteed to report a type
3889      * which is equal to the desired new type.
3890      * &lt;p&gt;
3891      * The given array controls the reordering.
3892      * Call {@code #I} the number of incoming parameters (the value
3893      * {@code newType.parameterCount()}, and call {@code #O} the number
3894      * of outgoing parameters (the value {@code target.type().parameterCount()}).
3895      * Then the length of the reordering array must be {@code #O},
3896      * and each element must be a non-negative number less than {@code #I}.
3897      * For every {@code N} less than {@code #O}, the {@code N}-th
3898      * outgoing argument will be taken from the {@code I}-th incoming
3899      * argument, where {@code I} is {@code reorder[N]}.
3900      * &lt;p&gt;
3901      * No argument or return value conversions are applied.
3902      * The type of each incoming argument, as determined by {@code newType},
3903      * must be identical to the type of the corresponding outgoing parameter
3904      * or parameters in the target method handle.
3905      * The return type of {@code newType} must be identical to the return
3906      * type of the original target.
3907      * &lt;p&gt;
3908      * The reordering array need not specify an actual permutation.
3909      * An incoming argument will be duplicated if its index appears
3910      * more than once in the array, and an incoming argument will be dropped
3911      * if its index does not appear in the array.
3912      * As in the case of {@link #dropArguments(MethodHandle,int,List) dropArguments},
3913      * incoming arguments which are not mentioned in the reordering array
3914      * may be of any type, as determined only by {@code newType}.
3915      * &lt;blockquote&gt;&lt;pre&gt;{@code
3916 import static java.lang.invoke.MethodHandles.*;
3917 import static java.lang.invoke.MethodType.*;
3918 ...
3919 MethodType intfn1 = methodType(int.class, int.class);
3920 MethodType intfn2 = methodType(int.class, int.class, int.class);
3921 MethodHandle sub = ... (int x, int y) -&gt; (x-y) ...;
3922 assert(sub.type().equals(intfn2));
3923 MethodHandle sub1 = permuteArguments(sub, intfn2, 0, 1);
3924 MethodHandle rsub = permuteArguments(sub, intfn2, 1, 0);
3925 assert((int)rsub.invokeExact(1, 100) == 99);
3926 MethodHandle add = ... (int x, int y) -&gt; (x+y) ...;
3927 assert(add.type().equals(intfn2));
3928 MethodHandle twice = permuteArguments(add, intfn1, 0, 0);
3929 assert(twice.type().equals(intfn1));
3930 assert((int)twice.invokeExact(21) == 42);
3931      * }&lt;/pre&gt;&lt;/blockquote&gt;
3932      * &lt;p&gt;
3933      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
3934      * variable-arity method handle}, even if the original target method handle was.
3935      * @param target the method handle to invoke after arguments are reordered
3936      * @param newType the expected type of the new method handle
3937      * @param reorder an index array which controls the reordering
3938      * @return a method handle which delegates to the target after it
3939      *           drops unused arguments and moves and/or duplicates the other arguments
3940      * @throws NullPointerException if any argument is null
3941      * @throws IllegalArgumentException if the index array length is not equal to
3942      *                  the arity of the target, or if any index array element
3943      *                  not a valid index for a parameter of {@code newType},
3944      *                  or if two corresponding parameter types in
3945      *                  {@code target.type()} and {@code newType} are not identical,
3946      */
3947     public static MethodHandle permuteArguments(MethodHandle target, MethodType newType, int... reorder) {
3948         reorder = reorder.clone();  // get a private copy
3949         MethodType oldType = target.type();
3950         permuteArgumentChecks(reorder, newType, oldType);
3951         // first detect dropped arguments and handle them separately
3952         int[] originalReorder = reorder;
3953         BoundMethodHandle result = target.rebind();
3954         LambdaForm form = result.form;
3955         int newArity = newType.parameterCount();
3956         // Normalize the reordering into a real permutation,
3957         // by removing duplicates and adding dropped elements.
3958         // This somewhat improves lambda form caching, as well
3959         // as simplifying the transform by breaking it up into steps.
3960         for (int ddIdx; (ddIdx = findFirstDupOrDrop(reorder, newArity)) != 0; ) {
3961             if (ddIdx &gt; 0) {
3962                 // We found a duplicated entry at reorder[ddIdx].
3963                 // Example:  (x,y,z)-&gt;asList(x,y,z)
3964                 // permuted by [1*,0,1] =&gt; (a0,a1)=&gt;asList(a1,a0,a1)
3965                 // permuted by [0,1,0*] =&gt; (a0,a1)=&gt;asList(a0,a1,a0)
3966                 // The starred element corresponds to the argument
3967                 // deleted by the dupArgumentForm transform.
3968                 int srcPos = ddIdx, dstPos = srcPos, dupVal = reorder[srcPos];
3969                 boolean killFirst = false;
3970                 for (int val; (val = reorder[--dstPos]) != dupVal; ) {
3971                     // Set killFirst if the dup is larger than an intervening position.
3972                     // This will remove at least one inversion from the permutation.
3973                     if (dupVal &gt; val) killFirst = true;
3974                 }
3975                 if (!killFirst) {
3976                     srcPos = dstPos;
3977                     dstPos = ddIdx;
3978                 }
3979                 form = form.editor().dupArgumentForm(1 + srcPos, 1 + dstPos);
3980                 assert (reorder[srcPos] == reorder[dstPos]);
3981                 oldType = oldType.dropParameterTypes(dstPos, dstPos + 1);
3982                 // contract the reordering by removing the element at dstPos
3983                 int tailPos = dstPos + 1;
3984                 System.arraycopy(reorder, tailPos, reorder, dstPos, reorder.length - tailPos);
3985                 reorder = Arrays.copyOf(reorder, reorder.length - 1);
3986             } else {
3987                 int dropVal = ~ddIdx, insPos = 0;
3988                 while (insPos &lt; reorder.length &amp;&amp; reorder[insPos] &lt; dropVal) {
3989                     // Find first element of reorder larger than dropVal.
3990                     // This is where we will insert the dropVal.
3991                     insPos += 1;
3992                 }
3993                 Class&lt;?&gt; ptype = newType.parameterType(dropVal);
3994                 form = form.editor().addArgumentForm(1 + insPos, BasicType.basicType(ptype));
3995                 oldType = oldType.insertParameterTypes(insPos, ptype);
3996                 // expand the reordering by inserting an element at insPos
3997                 int tailPos = insPos + 1;
3998                 reorder = Arrays.copyOf(reorder, reorder.length + 1);
3999                 System.arraycopy(reorder, insPos, reorder, tailPos, reorder.length - tailPos);
4000                 reorder[insPos] = dropVal;
4001             }
4002             assert (permuteArgumentChecks(reorder, newType, oldType));
4003         }
4004         assert (reorder.length == newArity);  // a perfect permutation
4005         // Note:  This may cache too many distinct LFs. Consider backing off to varargs code.
4006         form = form.editor().permuteArgumentsForm(1, reorder);
4007         if (newType == result.type() &amp;&amp; form == result.internalForm())
4008             return result;
4009         return result.copyWith(newType, form);
4010     }
4011 
4012     /**
4013      * Return an indication of any duplicate or omission in reorder.
4014      * If the reorder contains a duplicate entry, return the index of the second occurrence.
4015      * Otherwise, return ~(n), for the first n in [0..newArity-1] that is not present in reorder.
4016      * Otherwise, return zero.
4017      * If an element not in [0..newArity-1] is encountered, return reorder.length.
4018      */
4019     private static int findFirstDupOrDrop(int[] reorder, int newArity) {
4020         final int BIT_LIMIT = 63;  // max number of bits in bit mask
4021         if (newArity &lt; BIT_LIMIT) {
4022             long mask = 0;
4023             for (int i = 0; i &lt; reorder.length; i++) {
4024                 int arg = reorder[i];
4025                 if (arg &gt;= newArity) {
4026                     return reorder.length;
4027                 }
4028                 long bit = 1L &lt;&lt; arg;
4029                 if ((mask &amp; bit) != 0) {
4030                     return i;  // &gt;0 indicates a dup
4031                 }
4032                 mask |= bit;
4033             }
4034             if (mask == (1L &lt;&lt; newArity) - 1) {
4035                 assert(Long.numberOfTrailingZeros(Long.lowestOneBit(~mask)) == newArity);
4036                 return 0;
4037             }
4038             // find first zero
4039             long zeroBit = Long.lowestOneBit(~mask);
4040             int zeroPos = Long.numberOfTrailingZeros(zeroBit);
4041             assert(zeroPos &lt;= newArity);
4042             if (zeroPos == newArity) {
4043                 return 0;
4044             }
4045             return ~zeroPos;
4046         } else {
4047             // same algorithm, different bit set
4048             BitSet mask = new BitSet(newArity);
4049             for (int i = 0; i &lt; reorder.length; i++) {
4050                 int arg = reorder[i];
4051                 if (arg &gt;= newArity) {
4052                     return reorder.length;
4053                 }
4054                 if (mask.get(arg)) {
4055                     return i;  // &gt;0 indicates a dup
4056                 }
4057                 mask.set(arg);
4058             }
4059             int zeroPos = mask.nextClearBit(0);
4060             assert(zeroPos &lt;= newArity);
4061             if (zeroPos == newArity) {
4062                 return 0;
4063             }
4064             return ~zeroPos;
4065         }
4066     }
4067 
4068     private static boolean permuteArgumentChecks(int[] reorder, MethodType newType, MethodType oldType) {
4069         if (newType.returnType() != oldType.returnType())
4070             throw newIllegalArgumentException(&quot;return types do not match&quot;,
4071                     oldType, newType);
4072         if (reorder.length == oldType.parameterCount()) {
4073             int limit = newType.parameterCount();
4074             boolean bad = false;
4075             for (int j = 0; j &lt; reorder.length; j++) {
4076                 int i = reorder[j];
4077                 if (i &lt; 0 || i &gt;= limit) {
4078                     bad = true; break;
4079                 }
4080                 Class&lt;?&gt; src = newType.parameterType(i);
4081                 Class&lt;?&gt; dst = oldType.parameterType(j);
4082                 if (src != dst)
4083                     throw newIllegalArgumentException(&quot;parameter types do not match after reorder&quot;,
4084                             oldType, newType);
4085             }
4086             if (!bad)  return true;
4087         }
4088         throw newIllegalArgumentException(&quot;bad reorder array: &quot;+Arrays.toString(reorder));
4089     }
4090 
4091     /**
4092      * Produces a method handle of the requested return type which returns the given
4093      * constant value every time it is invoked.
4094      * &lt;p&gt;
4095      * Before the method handle is returned, the passed-in value is converted to the requested type.
4096      * If the requested type is primitive, widening primitive conversions are attempted,
4097      * else reference conversions are attempted.
4098      * &lt;p&gt;The returned method handle is equivalent to {@code identity(type).bindTo(value)}.
4099      * @param type the return type of the desired method handle
4100      * @param value the value to return
4101      * @return a method handle of the given return type and no arguments, which always returns the given value
4102      * @throws NullPointerException if the {@code type} argument is null
4103      * @throws ClassCastException if the value cannot be converted to the required return type
4104      * @throws IllegalArgumentException if the given type is {@code void.class}
4105      */
4106     public static MethodHandle constant(Class&lt;?&gt; type, Object value) {
4107         if (type.isPrimitive()) {
4108             if (type == void.class)
4109                 throw newIllegalArgumentException(&quot;void type&quot;);
4110             Wrapper w = Wrapper.forPrimitiveType(type);
4111             value = w.convert(value, type);
4112             if (w.zero().equals(value))
4113                 return zero(w, type);
4114             return insertArguments(identity(type), 0, value);
4115         } else {
4116             if (value == null)
4117                 return zero(Wrapper.OBJECT, type);
4118             return identity(type).bindTo(value);
4119         }
4120     }
4121 
4122     /**
4123      * Produces a method handle which returns its sole argument when invoked.
4124      * @param type the type of the sole parameter and return value of the desired method handle
4125      * @return a unary method handle which accepts and returns the given type
4126      * @throws NullPointerException if the argument is null
4127      * @throws IllegalArgumentException if the given type is {@code void.class}
4128      */
4129     public static MethodHandle identity(Class&lt;?&gt; type) {
4130         Wrapper btw = (type.isPrimitive() ? Wrapper.forPrimitiveType(type) : Wrapper.OBJECT);
4131         int pos = btw.ordinal();
4132         MethodHandle ident = IDENTITY_MHS[pos];
4133         if (ident == null) {
4134             ident = setCachedMethodHandle(IDENTITY_MHS, pos, makeIdentity(btw.primitiveType()));
4135         }
4136         if (ident.type().returnType() == type)
4137             return ident;
4138         // something like identity(Foo.class); do not bother to intern these
4139         assert (btw == Wrapper.OBJECT);
4140         return makeIdentity(type);
4141     }
4142 
4143     /**
4144      * Produces a constant method handle of the requested return type which
4145      * returns the default value for that type every time it is invoked.
4146      * The resulting constant method handle will have no side effects.
4147      * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
4148      * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
4149      * since {@code explicitCastArguments} converts {@code null} to default values.
4150      * @param type the expected return type of the desired method handle
4151      * @return a constant method handle that takes no arguments
4152      *         and returns the default value of the given type (or void, if the type is void)
4153      * @throws NullPointerException if the argument is null
4154      * @see MethodHandles#constant
4155      * @see MethodHandles#empty
4156      * @see MethodHandles#explicitCastArguments
4157      * @since 9
4158      */
4159     public static MethodHandle zero(Class&lt;?&gt; type) {
4160         Objects.requireNonNull(type);
4161         return type.isPrimitive() ?  zero(Wrapper.forPrimitiveType(type), type) : zero(Wrapper.OBJECT, type);
4162     }
4163 
4164     private static MethodHandle identityOrVoid(Class&lt;?&gt; type) {
4165         return type == void.class ? zero(type) : identity(type);
4166     }
4167 
4168     /**
4169      * Produces a method handle of the requested type which ignores any arguments, does nothing,
4170      * and returns a suitable default depending on the return type.
4171      * That is, it returns a zero primitive value, a {@code null}, or {@code void}.
4172      * &lt;p&gt;The returned method handle is equivalent to
4173      * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.
4174      *
4175      * @apiNote Given a predicate and target, a useful &quot;if-then&quot; construct can be produced as
4176      * {@code guardWithTest(pred, target, empty(target.type())}.
4177      * @param type the type of the desired method handle
4178      * @return a constant method handle of the given type, which returns a default value of the given return type
4179      * @throws NullPointerException if the argument is null
4180      * @see MethodHandles#zero
4181      * @see MethodHandles#constant
4182      * @since 9
4183      */
4184     public static  MethodHandle empty(MethodType type) {
4185         Objects.requireNonNull(type);
4186         return dropArguments(zero(type.returnType()), 0, type.parameterList());
4187     }
4188 
4189     private static final MethodHandle[] IDENTITY_MHS = new MethodHandle[Wrapper.COUNT];
4190     private static MethodHandle makeIdentity(Class&lt;?&gt; ptype) {
4191         MethodType mtype = methodType(ptype, ptype);
4192         LambdaForm lform = LambdaForm.identityForm(BasicType.basicType(ptype));
4193         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.IDENTITY);
4194     }
4195 
4196     private static MethodHandle zero(Wrapper btw, Class&lt;?&gt; rtype) {
4197         int pos = btw.ordinal();
4198         MethodHandle zero = ZERO_MHS[pos];
4199         if (zero == null) {
4200             zero = setCachedMethodHandle(ZERO_MHS, pos, makeZero(btw.primitiveType()));
4201         }
4202         if (zero.type().returnType() == rtype)
4203             return zero;
4204         assert(btw == Wrapper.OBJECT);
4205         return makeZero(rtype);
4206     }
4207     private static final MethodHandle[] ZERO_MHS = new MethodHandle[Wrapper.COUNT];
4208     private static MethodHandle makeZero(Class&lt;?&gt; rtype) {
4209         MethodType mtype = methodType(rtype);
4210         LambdaForm lform = LambdaForm.zeroForm(BasicType.basicType(rtype));
4211         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.ZERO);
4212     }
4213 
4214     private static synchronized MethodHandle setCachedMethodHandle(MethodHandle[] cache, int pos, MethodHandle value) {
4215         // Simulate a CAS, to avoid racy duplication of results.
4216         MethodHandle prev = cache[pos];
4217         if (prev != null) return prev;
4218         return cache[pos] = value;
4219     }
4220 
4221     /**
4222      * Provides a target method handle with one or more &lt;em&gt;bound arguments&lt;/em&gt;
4223      * in advance of the method handle&#39;s invocation.
4224      * The formal parameters to the target corresponding to the bound
4225      * arguments are called &lt;em&gt;bound parameters&lt;/em&gt;.
4226      * Returns a new method handle which saves away the bound arguments.
4227      * When it is invoked, it receives arguments for any non-bound parameters,
4228      * binds the saved arguments to their corresponding parameters,
4229      * and calls the original target.
4230      * &lt;p&gt;
4231      * The type of the new method handle will drop the types for the bound
4232      * parameters from the original target type, since the new method handle
4233      * will no longer require those arguments to be supplied by its callers.
4234      * &lt;p&gt;
4235      * Each given argument object must match the corresponding bound parameter type.
4236      * If a bound parameter type is a primitive, the argument object
4237      * must be a wrapper, and will be unboxed to produce the primitive value.
4238      * &lt;p&gt;
4239      * The {@code pos} argument selects which parameters are to be bound.
4240      * It may range between zero and &lt;i&gt;N-L&lt;/i&gt; (inclusively),
4241      * where &lt;i&gt;N&lt;/i&gt; is the arity of the target method handle
4242      * and &lt;i&gt;L&lt;/i&gt; is the length of the values array.
4243      * &lt;p&gt;
4244      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
4245      * variable-arity method handle}, even if the original target method handle was.
4246      * @param target the method handle to invoke after the argument is inserted
4247      * @param pos where to insert the argument (zero for the first)
4248      * @param values the series of arguments to insert
4249      * @return a method handle which inserts an additional argument,
4250      *         before calling the original method handle
4251      * @throws NullPointerException if the target or the {@code values} array is null
4252      * @throws IllegalArgumentException if (@code pos) is less than {@code 0} or greater than
4253      *         {@code N - L} where {@code N} is the arity of the target method handle and {@code L}
4254      *         is the length of the values array.
4255      * @throws ClassCastException if an argument does not match the corresponding bound parameter
4256      *         type.
4257      * @see MethodHandle#bindTo
4258      */
4259     public static MethodHandle insertArguments(MethodHandle target, int pos, Object... values) {
4260         int insCount = values.length;
4261         Class&lt;?&gt;[] ptypes = insertArgumentsChecks(target, insCount, pos);
4262         if (insCount == 0)  return target;
4263         BoundMethodHandle result = target.rebind();
4264         for (int i = 0; i &lt; insCount; i++) {
4265             Object value = values[i];
4266             Class&lt;?&gt; ptype = ptypes[pos+i];
4267             if (ptype.isPrimitive()) {
4268                 result = insertArgumentPrimitive(result, pos, ptype, value);
4269             } else {
4270                 value = ptype.cast(value);  // throw CCE if needed
4271                 result = result.bindArgumentL(pos, value);
4272             }
4273         }
4274         return result;
4275     }
4276 
4277     private static BoundMethodHandle insertArgumentPrimitive(BoundMethodHandle result, int pos,
4278                                                              Class&lt;?&gt; ptype, Object value) {
4279         Wrapper w = Wrapper.forPrimitiveType(ptype);
4280         // perform unboxing and/or primitive conversion
4281         value = w.convert(value, ptype);
4282         switch (w) {
4283         case INT:     return result.bindArgumentI(pos, (int)value);
4284         case LONG:    return result.bindArgumentJ(pos, (long)value);
4285         case FLOAT:   return result.bindArgumentF(pos, (float)value);
4286         case DOUBLE:  return result.bindArgumentD(pos, (double)value);
4287         default:      return result.bindArgumentI(pos, ValueConversions.widenSubword(value));
4288         }
4289     }
4290 
4291     private static Class&lt;?&gt;[] insertArgumentsChecks(MethodHandle target, int insCount, int pos) throws RuntimeException {
4292         MethodType oldType = target.type();
4293         int outargs = oldType.parameterCount();
4294         int inargs  = outargs - insCount;
4295         if (inargs &lt; 0)
4296             throw newIllegalArgumentException(&quot;too many values to insert&quot;);
4297         if (pos &lt; 0 || pos &gt; inargs)
4298             throw newIllegalArgumentException(&quot;no argument type to append&quot;);
4299         return oldType.ptypes();
4300     }
4301 
4302     /**
4303      * Produces a method handle which will discard some dummy arguments
4304      * before calling some other specified &lt;i&gt;target&lt;/i&gt; method handle.
4305      * The type of the new method handle will be the same as the target&#39;s type,
4306      * except it will also include the dummy argument types,
4307      * at some given position.
4308      * &lt;p&gt;
4309      * The {@code pos} argument may range between zero and &lt;i&gt;N&lt;/i&gt;,
4310      * where &lt;i&gt;N&lt;/i&gt; is the arity of the target.
4311      * If {@code pos} is zero, the dummy arguments will precede
4312      * the target&#39;s real arguments; if {@code pos} is &lt;i&gt;N&lt;/i&gt;
4313      * they will come after.
4314      * &lt;p&gt;
4315      * &lt;b&gt;Example:&lt;/b&gt;
4316      * &lt;blockquote&gt;&lt;pre&gt;{@code
4317 import static java.lang.invoke.MethodHandles.*;
4318 import static java.lang.invoke.MethodType.*;
4319 ...
4320 MethodHandle cat = lookup().findVirtual(String.class,
4321   &quot;concat&quot;, methodType(String.class, String.class));
4322 assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
4323 MethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);
4324 MethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));
4325 assertEquals(bigType, d0.type());
4326 assertEquals(&quot;yz&quot;, (String) d0.invokeExact(123, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
4327      * }&lt;/pre&gt;&lt;/blockquote&gt;
4328      * &lt;p&gt;
4329      * This method is also equivalent to the following code:
4330      * &lt;blockquote&gt;&lt;pre&gt;
4331      * {@link #dropArguments(MethodHandle,int,Class...) dropArguments}{@code (target, pos, valueTypes.toArray(new Class[0]))}
4332      * &lt;/pre&gt;&lt;/blockquote&gt;
4333      * @param target the method handle to invoke after the arguments are dropped
4334      * @param pos position of first argument to drop (zero for the leftmost)
4335      * @param valueTypes the type(s) of the argument(s) to drop
4336      * @return a method handle which drops arguments of the given types,
4337      *         before calling the original method handle
4338      * @throws NullPointerException if the target is null,
4339      *                              or if the {@code valueTypes} list or any of its elements is null
4340      * @throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
4341      *                  or if {@code pos} is negative or greater than the arity of the target,
4342      *                  or if the new method handle&#39;s type would have too many parameters
4343      */
4344     public static MethodHandle dropArguments(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {
4345         return dropArguments0(target, pos, copyTypes(valueTypes.toArray()));
4346     }
4347 
4348     private static List&lt;Class&lt;?&gt;&gt; copyTypes(Object[] array) {
4349         return Arrays.asList(Arrays.copyOf(array, array.length, Class[].class));
4350     }
4351 
4352     private static MethodHandle dropArguments0(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {
4353         MethodType oldType = target.type();  // get NPE
4354         int dropped = dropArgumentChecks(oldType, pos, valueTypes);
4355         MethodType newType = oldType.insertParameterTypes(pos, valueTypes);
4356         if (dropped == 0)  return target;
4357         BoundMethodHandle result = target.rebind();
4358         LambdaForm lform = result.form;
4359         int insertFormArg = 1 + pos;
4360         for (Class&lt;?&gt; ptype : valueTypes) {
4361             lform = lform.editor().addArgumentForm(insertFormArg++, BasicType.basicType(ptype));
4362         }
4363         result = result.copyWith(newType, lform);
4364         return result;
4365     }
4366 
4367     private static int dropArgumentChecks(MethodType oldType, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {
4368         int dropped = valueTypes.size();
4369         MethodType.checkSlotCount(dropped);
4370         int outargs = oldType.parameterCount();
4371         int inargs  = outargs + dropped;
4372         if (pos &lt; 0 || pos &gt; outargs)
4373             throw newIllegalArgumentException(&quot;no argument type to remove&quot;
4374                     + Arrays.asList(oldType, pos, valueTypes, inargs, outargs)
4375                     );
4376         return dropped;
4377     }
4378 
4379     /**
4380      * Produces a method handle which will discard some dummy arguments
4381      * before calling some other specified &lt;i&gt;target&lt;/i&gt; method handle.
4382      * The type of the new method handle will be the same as the target&#39;s type,
4383      * except it will also include the dummy argument types,
4384      * at some given position.
4385      * &lt;p&gt;
4386      * The {@code pos} argument may range between zero and &lt;i&gt;N&lt;/i&gt;,
4387      * where &lt;i&gt;N&lt;/i&gt; is the arity of the target.
4388      * If {@code pos} is zero, the dummy arguments will precede
4389      * the target&#39;s real arguments; if {@code pos} is &lt;i&gt;N&lt;/i&gt;
4390      * they will come after.
4391      * @apiNote
4392      * &lt;blockquote&gt;&lt;pre&gt;{@code
4393 import static java.lang.invoke.MethodHandles.*;
4394 import static java.lang.invoke.MethodType.*;
4395 ...
4396 MethodHandle cat = lookup().findVirtual(String.class,
4397   &quot;concat&quot;, methodType(String.class, String.class));
4398 assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
4399 MethodHandle d0 = dropArguments(cat, 0, String.class);
4400 assertEquals(&quot;yz&quot;, (String) d0.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
4401 MethodHandle d1 = dropArguments(cat, 1, String.class);
4402 assertEquals(&quot;xz&quot;, (String) d1.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
4403 MethodHandle d2 = dropArguments(cat, 2, String.class);
4404 assertEquals(&quot;xy&quot;, (String) d2.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
4405 MethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);
4406 assertEquals(&quot;xz&quot;, (String) d12.invokeExact(&quot;x&quot;, 12, true, &quot;z&quot;));
4407      * }&lt;/pre&gt;&lt;/blockquote&gt;
4408      * &lt;p&gt;
4409      * This method is also equivalent to the following code:
4410      * &lt;blockquote&gt;&lt;pre&gt;
4411      * {@link #dropArguments(MethodHandle,int,List) dropArguments}{@code (target, pos, Arrays.asList(valueTypes))}
4412      * &lt;/pre&gt;&lt;/blockquote&gt;
4413      * @param target the method handle to invoke after the arguments are dropped
4414      * @param pos position of first argument to drop (zero for the leftmost)
4415      * @param valueTypes the type(s) of the argument(s) to drop
4416      * @return a method handle which drops arguments of the given types,
4417      *         before calling the original method handle
4418      * @throws NullPointerException if the target is null,
4419      *                              or if the {@code valueTypes} array or any of its elements is null
4420      * @throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
4421      *                  or if {@code pos} is negative or greater than the arity of the target,
4422      *                  or if the new method handle&#39;s type would have
4423      *                  &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
4424      */
4425     public static MethodHandle dropArguments(MethodHandle target, int pos, Class&lt;?&gt;... valueTypes) {
4426         return dropArguments0(target, pos, copyTypes(valueTypes));
4427     }
4428 
4429     // private version which allows caller some freedom with error handling
4430     private static MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List&lt;Class&lt;?&gt;&gt; newTypes, int pos,
4431                                       boolean nullOnFailure) {
4432         newTypes = copyTypes(newTypes.toArray());
4433         List&lt;Class&lt;?&gt;&gt; oldTypes = target.type().parameterList();
4434         int match = oldTypes.size();
4435         if (skip != 0) {
4436             if (skip &lt; 0 || skip &gt; match) {
4437                 throw newIllegalArgumentException(&quot;illegal skip&quot;, skip, target);
4438             }
4439             oldTypes = oldTypes.subList(skip, match);
4440             match -= skip;
4441         }
4442         List&lt;Class&lt;?&gt;&gt; addTypes = newTypes;
4443         int add = addTypes.size();
4444         if (pos != 0) {
4445             if (pos &lt; 0 || pos &gt; add) {
4446                 throw newIllegalArgumentException(&quot;illegal pos&quot;, pos, newTypes);
4447             }
4448             addTypes = addTypes.subList(pos, add);
4449             add -= pos;
4450             assert(addTypes.size() == add);
4451         }
4452         // Do not add types which already match the existing arguments.
4453         if (match &gt; add || !oldTypes.equals(addTypes.subList(0, match))) {
4454             if (nullOnFailure) {
4455                 return null;
4456             }
4457             throw newIllegalArgumentException(&quot;argument lists do not match&quot;, oldTypes, newTypes);
4458         }
4459         addTypes = addTypes.subList(match, add);
4460         add -= match;
4461         assert(addTypes.size() == add);
4462         // newTypes:     (   P*[pos], M*[match], A*[add] )
4463         // target: ( S*[skip],        M*[match]  )
4464         MethodHandle adapter = target;
4465         if (add &gt; 0) {
4466             adapter = dropArguments0(adapter, skip+ match, addTypes);
4467         }
4468         // adapter: (S*[skip],        M*[match], A*[add] )
4469         if (pos &gt; 0) {
4470             adapter = dropArguments0(adapter, skip, newTypes.subList(0, pos));
4471         }
4472         // adapter: (S*[skip], P*[pos], M*[match], A*[add] )
4473         return adapter;
4474     }
4475 
4476     /**
4477      * Adapts a target method handle to match the given parameter type list. If necessary, adds dummy arguments. Some
4478      * leading parameters can be skipped before matching begins. The remaining types in the {@code target}&#39;s parameter
4479      * type list must be a sub-list of the {@code newTypes} type list at the starting position {@code pos}. The
4480      * resulting handle will have the target handle&#39;s parameter type list, with any non-matching parameter types (before
4481      * or after the matching sub-list) inserted in corresponding positions of the target&#39;s original parameters, as if by
4482      * {@link #dropArguments(MethodHandle, int, Class[])}.
4483      * &lt;p&gt;
4484      * The resulting handle will have the same return type as the target handle.
4485      * &lt;p&gt;
4486      * In more formal terms, assume these two type lists:&lt;ul&gt;
4487      * &lt;li&gt;The target handle has the parameter type list {@code S..., M...}, with as many types in {@code S} as
4488      * indicated by {@code skip}. The {@code M} types are those that are supposed to match part of the given type list,
4489      * {@code newTypes}.
4490      * &lt;li&gt;The {@code newTypes} list contains types {@code P..., M..., A...}, with as many types in {@code P} as
4491      * indicated by {@code pos}. The {@code M} types are precisely those that the {@code M} types in the target handle&#39;s
4492      * parameter type list are supposed to match. The types in {@code A} are additional types found after the matching
4493      * sub-list.
4494      * &lt;/ul&gt;
4495      * Given these assumptions, the result of an invocation of {@code dropArgumentsToMatch} will have the parameter type
4496      * list {@code S..., P..., M..., A...}, with the {@code P} and {@code A} types inserted as if by
4497      * {@link #dropArguments(MethodHandle, int, Class[])}.
4498      *
4499      * @apiNote
4500      * Two method handles whose argument lists are &quot;effectively identical&quot; (i.e., identical in a common prefix) may be
4501      * mutually converted to a common type by two calls to {@code dropArgumentsToMatch}, as follows:
4502      * &lt;blockquote&gt;&lt;pre&gt;{@code
4503 import static java.lang.invoke.MethodHandles.*;
4504 import static java.lang.invoke.MethodType.*;
4505 ...
4506 ...
4507 MethodHandle h0 = constant(boolean.class, true);
4508 MethodHandle h1 = lookup().findVirtual(String.class, &quot;concat&quot;, methodType(String.class, String.class));
4509 MethodType bigType = h1.type().insertParameterTypes(1, String.class, int.class);
4510 MethodHandle h2 = dropArguments(h1, 0, bigType.parameterList());
4511 if (h1.type().parameterCount() &lt; h2.type().parameterCount())
4512     h1 = dropArgumentsToMatch(h1, 0, h2.type().parameterList(), 0);  // lengthen h1
4513 else
4514     h2 = dropArgumentsToMatch(h2, 0, h1.type().parameterList(), 0);    // lengthen h2
4515 MethodHandle h3 = guardWithTest(h0, h1, h2);
4516 assertEquals(&quot;xy&quot;, h3.invoke(&quot;x&quot;, &quot;y&quot;, 1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;));
4517      * }&lt;/pre&gt;&lt;/blockquote&gt;
4518      * @param target the method handle to adapt
4519      * @param skip number of targets parameters to disregard (they will be unchanged)
4520      * @param newTypes the list of types to match {@code target}&#39;s parameter type list to
4521      * @param pos place in {@code newTypes} where the non-skipped target parameters must occur
4522      * @return a possibly adapted method handle
4523      * @throws NullPointerException if either argument is null
4524      * @throws IllegalArgumentException if any element of {@code newTypes} is {@code void.class},
4525      *         or if {@code skip} is negative or greater than the arity of the target,
4526      *         or if {@code pos} is negative or greater than the newTypes list size,
4527      *         or if {@code newTypes} does not contain the {@code target}&#39;s non-skipped parameter types at position
4528      *         {@code pos}.
4529      * @since 9
4530      */
4531     public static MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List&lt;Class&lt;?&gt;&gt; newTypes, int pos) {
4532         Objects.requireNonNull(target);
4533         Objects.requireNonNull(newTypes);
4534         return dropArgumentsToMatch(target, skip, newTypes, pos, false);
4535     }
4536 
4537     /**
4538      * Adapts a target method handle by pre-processing
4539      * one or more of its arguments, each with its own unary filter function,
4540      * and then calling the target with each pre-processed argument
4541      * replaced by the result of its corresponding filter function.
4542      * &lt;p&gt;
4543      * The pre-processing is performed by one or more method handles,
4544      * specified in the elements of the {@code filters} array.
4545      * The first element of the filter array corresponds to the {@code pos}
4546      * argument of the target, and so on in sequence.
4547      * The filter functions are invoked in left to right order.
4548      * &lt;p&gt;
4549      * Null arguments in the array are treated as identity functions,
4550      * and the corresponding arguments left unchanged.
4551      * (If there are no non-null elements in the array, the original target is returned.)
4552      * Each filter is applied to the corresponding argument of the adapter.
4553      * &lt;p&gt;
4554      * If a filter {@code F} applies to the {@code N}th argument of
4555      * the target, then {@code F} must be a method handle which
4556      * takes exactly one argument.  The type of {@code F}&#39;s sole argument
4557      * replaces the corresponding argument type of the target
4558      * in the resulting adapted method handle.
4559      * The return type of {@code F} must be identical to the corresponding
4560      * parameter type of the target.
4561      * &lt;p&gt;
4562      * It is an error if there are elements of {@code filters}
4563      * (null or not)
4564      * which do not correspond to argument positions in the target.
4565      * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
4566      * &lt;blockquote&gt;&lt;pre&gt;{@code
4567 import static java.lang.invoke.MethodHandles.*;
4568 import static java.lang.invoke.MethodType.*;
4569 ...
4570 MethodHandle cat = lookup().findVirtual(String.class,
4571   &quot;concat&quot;, methodType(String.class, String.class));
4572 MethodHandle upcase = lookup().findVirtual(String.class,
4573   &quot;toUpperCase&quot;, methodType(String.class));
4574 assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
4575 MethodHandle f0 = filterArguments(cat, 0, upcase);
4576 assertEquals(&quot;Xy&quot;, (String) f0.invokeExact(&quot;x&quot;, &quot;y&quot;)); // Xy
4577 MethodHandle f1 = filterArguments(cat, 1, upcase);
4578 assertEquals(&quot;xY&quot;, (String) f1.invokeExact(&quot;x&quot;, &quot;y&quot;)); // xY
4579 MethodHandle f2 = filterArguments(cat, 0, upcase, upcase);
4580 assertEquals(&quot;XY&quot;, (String) f2.invokeExact(&quot;x&quot;, &quot;y&quot;)); // XY
4581      * }&lt;/pre&gt;&lt;/blockquote&gt;
4582      * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code, {@code T}
4583      * denotes the return type of both the {@code target} and resulting adapter.
4584      * {@code P}/{@code p} and {@code B}/{@code b} represent the types and values
4585      * of the parameters and arguments that precede and follow the filter position
4586      * {@code pos}, respectively. {@code A[i]}/{@code a[i]} stand for the types and
4587      * values of the filtered parameters and arguments; they also represent the
4588      * return types of the {@code filter[i]} handles. The latter accept arguments
4589      * {@code v[i]} of type {@code V[i]}, which also appear in the signature of
4590      * the resulting adapter.
4591      * &lt;blockquote&gt;&lt;pre&gt;{@code
4592      * T target(P... p, A[i]... a[i], B... b);
4593      * A[i] filter[i](V[i]);
4594      * T adapter(P... p, V[i]... v[i], B... b) {
4595      *   return target(p..., filter[i](v[i])..., b...);
4596      * }
4597      * }&lt;/pre&gt;&lt;/blockquote&gt;
4598      * &lt;p&gt;
4599      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
4600      * variable-arity method handle}, even if the original target method handle was.
4601      *
4602      * @param target the method handle to invoke after arguments are filtered
4603      * @param pos the position of the first argument to filter
4604      * @param filters method handles to call initially on filtered arguments
4605      * @return method handle which incorporates the specified argument filtering logic
4606      * @throws NullPointerException if the target is null
4607      *                              or if the {@code filters} array is null
4608      * @throws IllegalArgumentException if a non-null element of {@code filters}
4609      *          does not match a corresponding argument type of target as described above,
4610      *          or if the {@code pos+filters.length} is greater than {@code target.type().parameterCount()},
4611      *          or if the resulting method handle&#39;s type would have
4612      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
4613      */
4614     public static MethodHandle filterArguments(MethodHandle target, int pos, MethodHandle... filters) {
4615         // In method types arguments start at index 0, while the LF
4616         // editor have the MH receiver at position 0 - adjust appropriately.
4617         final int MH_RECEIVER_OFFSET = 1;
4618         filterArgumentsCheckArity(target, pos, filters);
4619         MethodHandle adapter = target;
4620 
4621         // keep track of currently matched filters, as to optimize repeated filters
4622         int index = 0;
4623         int[] positions = new int[filters.length];
4624         MethodHandle filter = null;
4625 
4626         // process filters in reverse order so that the invocation of
4627         // the resulting adapter will invoke the filters in left-to-right order
4628         for (int i = filters.length - 1; i &gt;= 0; --i) {
4629             MethodHandle newFilter = filters[i];
4630             if (newFilter == null) continue;  // ignore null elements of filters
4631 
4632             // flush changes on update
4633             if (filter != newFilter) {
4634                 if (filter != null) {
4635                     if (index &gt; 1) {
4636                         adapter = filterRepeatedArgument(adapter, filter, Arrays.copyOf(positions, index));
4637                     } else {
4638                         adapter = filterArgument(adapter, positions[0] - 1, filter);
4639                     }
4640                 }
4641                 filter = newFilter;
4642                 index = 0;
4643             }
4644 
4645             filterArgumentChecks(target, pos + i, newFilter);
4646             positions[index++] = pos + i + MH_RECEIVER_OFFSET;
4647         }
4648         if (index &gt; 1) {
4649             adapter = filterRepeatedArgument(adapter, filter, Arrays.copyOf(positions, index));
4650         } else if (index == 1) {
4651             adapter = filterArgument(adapter, positions[0] - 1, filter);
4652         }
4653         return adapter;
4654     }
4655 
4656     private static MethodHandle filterRepeatedArgument(MethodHandle adapter, MethodHandle filter, int[] positions) {
4657         MethodType targetType = adapter.type();
4658         MethodType filterType = filter.type();
4659         BoundMethodHandle result = adapter.rebind();
4660         Class&lt;?&gt; newParamType = filterType.parameterType(0);
4661 
4662         Class&lt;?&gt;[] ptypes = targetType.ptypes().clone();
4663         for (int pos : positions) {
4664             ptypes[pos - 1] = newParamType;
4665         }
4666         MethodType newType = MethodType.makeImpl(targetType.rtype(), ptypes, true);
4667 
4668         LambdaForm lform = result.editor().filterRepeatedArgumentForm(BasicType.basicType(newParamType), positions);
4669         return result.copyWithExtendL(newType, lform, filter);
4670     }
4671 
4672     /*non-public*/
4673     static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle filter) {
4674         filterArgumentChecks(target, pos, filter);
4675         MethodType targetType = target.type();
4676         MethodType filterType = filter.type();
4677         BoundMethodHandle result = target.rebind();
4678         Class&lt;?&gt; newParamType = filterType.parameterType(0);
4679         LambdaForm lform = result.editor().filterArgumentForm(1 + pos, BasicType.basicType(newParamType));
4680         MethodType newType = targetType.changeParameterType(pos, newParamType);
4681         result = result.copyWithExtendL(newType, lform, filter);
4682         return result;
4683     }
4684 
4685     private static void filterArgumentsCheckArity(MethodHandle target, int pos, MethodHandle[] filters) {
4686         MethodType targetType = target.type();
4687         int maxPos = targetType.parameterCount();
4688         if (pos + filters.length &gt; maxPos)
4689             throw newIllegalArgumentException(&quot;too many filters&quot;);
4690     }
4691 
4692     private static void filterArgumentChecks(MethodHandle target, int pos, MethodHandle filter) throws RuntimeException {
4693         MethodType targetType = target.type();
4694         MethodType filterType = filter.type();
4695         if (filterType.parameterCount() != 1
4696             || filterType.returnType() != targetType.parameterType(pos))
4697             throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
4698     }
4699 
4700     /**
4701      * Adapts a target method handle by pre-processing
4702      * a sub-sequence of its arguments with a filter (another method handle).
4703      * The pre-processed arguments are replaced by the result (if any) of the
4704      * filter function.
4705      * The target is then called on the modified (usually shortened) argument list.
4706      * &lt;p&gt;
4707      * If the filter returns a value, the target must accept that value as
4708      * its argument in position {@code pos}, preceded and/or followed by
4709      * any arguments not passed to the filter.
4710      * If the filter returns void, the target must accept all arguments
4711      * not passed to the filter.
4712      * No arguments are reordered, and a result returned from the filter
4713      * replaces (in order) the whole subsequence of arguments originally
4714      * passed to the adapter.
4715      * &lt;p&gt;
4716      * The argument types (if any) of the filter
4717      * replace zero or one argument types of the target, at position {@code pos},
4718      * in the resulting adapted method handle.
4719      * The return type of the filter (if any) must be identical to the
4720      * argument type of the target at position {@code pos}, and that target argument
4721      * is supplied by the return value of the filter.
4722      * &lt;p&gt;
4723      * In all cases, {@code pos} must be greater than or equal to zero, and
4724      * {@code pos} must also be less than or equal to the target&#39;s arity.
4725      * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
4726      * &lt;blockquote&gt;&lt;pre&gt;{@code
4727 import static java.lang.invoke.MethodHandles.*;
4728 import static java.lang.invoke.MethodType.*;
4729 ...
4730 MethodHandle deepToString = publicLookup()
4731   .findStatic(Arrays.class, &quot;deepToString&quot;, methodType(String.class, Object[].class));
4732 
4733 MethodHandle ts1 = deepToString.asCollector(String[].class, 1);
4734 assertEquals(&quot;[strange]&quot;, (String) ts1.invokeExact(&quot;strange&quot;));
4735 
4736 MethodHandle ts2 = deepToString.asCollector(String[].class, 2);
4737 assertEquals(&quot;[up, down]&quot;, (String) ts2.invokeExact(&quot;up&quot;, &quot;down&quot;));
4738 
4739 MethodHandle ts3 = deepToString.asCollector(String[].class, 3);
4740 MethodHandle ts3_ts2 = collectArguments(ts3, 1, ts2);
4741 assertEquals(&quot;[top, [up, down], strange]&quot;,
4742              (String) ts3_ts2.invokeExact(&quot;top&quot;, &quot;up&quot;, &quot;down&quot;, &quot;strange&quot;));
4743 
4744 MethodHandle ts3_ts2_ts1 = collectArguments(ts3_ts2, 3, ts1);
4745 assertEquals(&quot;[top, [up, down], [strange]]&quot;,
4746              (String) ts3_ts2_ts1.invokeExact(&quot;top&quot;, &quot;up&quot;, &quot;down&quot;, &quot;strange&quot;));
4747 
4748 MethodHandle ts3_ts2_ts3 = collectArguments(ts3_ts2, 1, ts3);
4749 assertEquals(&quot;[top, [[up, down, strange], charm], bottom]&quot;,
4750              (String) ts3_ts2_ts3.invokeExact(&quot;top&quot;, &quot;up&quot;, &quot;down&quot;, &quot;strange&quot;, &quot;charm&quot;, &quot;bottom&quot;));
4751      * }&lt;/pre&gt;&lt;/blockquote&gt;
4752      * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code, {@code T}
4753      * represents the return type of the {@code target} and resulting adapter.
4754      * {@code V}/{@code v} stand for the return type and value of the
4755      * {@code filter}, which are also found in the signature and arguments of
4756      * the {@code target}, respectively, unless {@code V} is {@code void}.
4757      * {@code A}/{@code a} and {@code C}/{@code c} represent the parameter types
4758      * and values preceding and following the collection position, {@code pos},
4759      * in the {@code target}&#39;s signature. They also turn up in the resulting
4760      * adapter&#39;s signature and arguments, where they surround
4761      * {@code B}/{@code b}, which represent the parameter types and arguments
4762      * to the {@code filter} (if any).
4763      * &lt;blockquote&gt;&lt;pre&gt;{@code
4764      * T target(A...,V,C...);
4765      * V filter(B...);
4766      * T adapter(A... a,B... b,C... c) {
4767      *   V v = filter(b...);
4768      *   return target(a...,v,c...);
4769      * }
4770      * // and if the filter has no arguments:
4771      * T target2(A...,V,C...);
4772      * V filter2();
4773      * T adapter2(A... a,C... c) {
4774      *   V v = filter2();
4775      *   return target2(a...,v,c...);
4776      * }
4777      * // and if the filter has a void return:
4778      * T target3(A...,C...);
4779      * void filter3(B...);
4780      * T adapter3(A... a,B... b,C... c) {
4781      *   filter3(b...);
4782      *   return target3(a...,c...);
4783      * }
4784      * }&lt;/pre&gt;&lt;/blockquote&gt;
4785      * &lt;p&gt;
4786      * A collection adapter {@code collectArguments(mh, 0, coll)} is equivalent to
4787      * one which first &quot;folds&quot; the affected arguments, and then drops them, in separate
4788      * steps as follows:
4789      * &lt;blockquote&gt;&lt;pre&gt;{@code
4790      * mh = MethodHandles.dropArguments(mh, 1, coll.type().parameterList()); //step 2
4791      * mh = MethodHandles.foldArguments(mh, coll); //step 1
4792      * }&lt;/pre&gt;&lt;/blockquote&gt;
4793      * If the target method handle consumes no arguments besides than the result
4794      * (if any) of the filter {@code coll}, then {@code collectArguments(mh, 0, coll)}
4795      * is equivalent to {@code filterReturnValue(coll, mh)}.
4796      * If the filter method handle {@code coll} consumes one argument and produces
4797      * a non-void result, then {@code collectArguments(mh, N, coll)}
4798      * is equivalent to {@code filterArguments(mh, N, coll)}.
4799      * Other equivalences are possible but would require argument permutation.
4800      * &lt;p&gt;
4801      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
4802      * variable-arity method handle}, even if the original target method handle was.
4803      *
4804      * @param target the method handle to invoke after filtering the subsequence of arguments
4805      * @param pos the position of the first adapter argument to pass to the filter,
4806      *            and/or the target argument which receives the result of the filter
4807      * @param filter method handle to call on the subsequence of arguments
4808      * @return method handle which incorporates the specified argument subsequence filtering logic
4809      * @throws NullPointerException if either argument is null
4810      * @throws IllegalArgumentException if the return type of {@code filter}
4811      *          is non-void and is not the same as the {@code pos} argument of the target,
4812      *          or if {@code pos} is not between 0 and the target&#39;s arity, inclusive,
4813      *          or if the resulting method handle&#39;s type would have
4814      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
4815      * @see MethodHandles#foldArguments
4816      * @see MethodHandles#filterArguments
4817      * @see MethodHandles#filterReturnValue
4818      */
4819     public static MethodHandle collectArguments(MethodHandle target, int pos, MethodHandle filter) {
4820         MethodType newType = collectArgumentsChecks(target, pos, filter);
4821         MethodType collectorType = filter.type();
4822         BoundMethodHandle result = target.rebind();
4823         LambdaForm lform;
4824         if (collectorType.returnType().isArray() &amp;&amp; filter.intrinsicName() == Intrinsic.NEW_ARRAY) {
4825             lform = result.editor().collectArgumentArrayForm(1 + pos, filter);
4826             if (lform != null) {
4827                 return result.copyWith(newType, lform);
4828             }
4829         }
4830         lform = result.editor().collectArgumentsForm(1 + pos, collectorType.basicType());
4831         return result.copyWithExtendL(newType, lform, filter);
4832     }
4833 
4834     private static MethodType collectArgumentsChecks(MethodHandle target, int pos, MethodHandle filter) throws RuntimeException {
4835         MethodType targetType = target.type();
4836         MethodType filterType = filter.type();
4837         Class&lt;?&gt; rtype = filterType.returnType();
4838         List&lt;Class&lt;?&gt;&gt; filterArgs = filterType.parameterList();
4839         if (rtype == void.class) {
4840             return targetType.insertParameterTypes(pos, filterArgs);
4841         }
4842         if (rtype != targetType.parameterType(pos)) {
4843             throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
4844         }
4845         return targetType.dropParameterTypes(pos, pos+1).insertParameterTypes(pos, filterArgs);
4846     }
4847 
4848     /**
4849      * Adapts a target method handle by post-processing
4850      * its return value (if any) with a filter (another method handle).
4851      * The result of the filter is returned from the adapter.
4852      * &lt;p&gt;
4853      * If the target returns a value, the filter must accept that value as
4854      * its only argument.
4855      * If the target returns void, the filter must accept no arguments.
4856      * &lt;p&gt;
4857      * The return type of the filter
4858      * replaces the return type of the target
4859      * in the resulting adapted method handle.
4860      * The argument type of the filter (if any) must be identical to the
4861      * return type of the target.
4862      * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
4863      * &lt;blockquote&gt;&lt;pre&gt;{@code
4864 import static java.lang.invoke.MethodHandles.*;
4865 import static java.lang.invoke.MethodType.*;
4866 ...
4867 MethodHandle cat = lookup().findVirtual(String.class,
4868   &quot;concat&quot;, methodType(String.class, String.class));
4869 MethodHandle length = lookup().findVirtual(String.class,
4870   &quot;length&quot;, methodType(int.class));
4871 System.out.println((String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;)); // xy
4872 MethodHandle f0 = filterReturnValue(cat, length);
4873 System.out.println((int) f0.invokeExact(&quot;x&quot;, &quot;y&quot;)); // 2
4874      * }&lt;/pre&gt;&lt;/blockquote&gt;
4875      * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code,
4876      * {@code T}/{@code t} represent the result type and value of the
4877      * {@code target}; {@code V}, the result type of the {@code filter}; and
4878      * {@code A}/{@code a}, the types and values of the parameters and arguments
4879      * of the {@code target} as well as the resulting adapter.
4880      * &lt;blockquote&gt;&lt;pre&gt;{@code
4881      * T target(A...);
4882      * V filter(T);
4883      * V adapter(A... a) {
4884      *   T t = target(a...);
4885      *   return filter(t);
4886      * }
4887      * // and if the target has a void return:
4888      * void target2(A...);
4889      * V filter2();
4890      * V adapter2(A... a) {
4891      *   target2(a...);
4892      *   return filter2();
4893      * }
4894      * // and if the filter has a void return:
4895      * T target3(A...);
4896      * void filter3(V);
4897      * void adapter3(A... a) {
4898      *   T t = target3(a...);
4899      *   filter3(t);
4900      * }
4901      * }&lt;/pre&gt;&lt;/blockquote&gt;
4902      * &lt;p&gt;
4903      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
4904      * variable-arity method handle}, even if the original target method handle was.
4905      * @param target the method handle to invoke before filtering the return value
4906      * @param filter method handle to call on the return value
4907      * @return method handle which incorporates the specified return value filtering logic
4908      * @throws NullPointerException if either argument is null
4909      * @throws IllegalArgumentException if the argument list of {@code filter}
4910      *          does not match the return type of target as described above
4911      */
4912     public static MethodHandle filterReturnValue(MethodHandle target, MethodHandle filter) {
4913         MethodType targetType = target.type();
4914         MethodType filterType = filter.type();
4915         filterReturnValueChecks(targetType, filterType);
4916         BoundMethodHandle result = target.rebind();
4917         BasicType rtype = BasicType.basicType(filterType.returnType());
4918         LambdaForm lform = result.editor().filterReturnForm(rtype, false);
4919         MethodType newType = targetType.changeReturnType(filterType.returnType());
4920         result = result.copyWithExtendL(newType, lform, filter);
4921         return result;
4922     }
4923 
4924     private static void filterReturnValueChecks(MethodType targetType, MethodType filterType) throws RuntimeException {
4925         Class&lt;?&gt; rtype = targetType.returnType();
4926         int filterValues = filterType.parameterCount();
4927         if (filterValues == 0
4928                 ? (rtype != void.class)
4929                 : (rtype != filterType.parameterType(0) || filterValues != 1))
4930             throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
4931     }
4932 
4933     /**
4934      * Adapts a target var handle by pre-processing incoming and outgoing values using a pair of unary filter functions.
4935      * &lt;p&gt;
4936      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var handle, the incoming value (of type {@code T}, where
4937      * {@code T} is the parameter type of the first filter function) is processed using the first filter and then passed
4938      * to the target var handle.
4939      * Conversely, when calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the return value obtained from
4940      * the target var handle (of type {@code T}, where {@code T} is the parameter type of the second filter function)
4941      * is processed using the second filter and returned to the caller. More advanced access mode types, such as
4942      * {@link java.lang.invoke.VarHandle.AccessMode#COMPARE_AND_EXCHANGE} might apply both filters at the same time.
4943      * &lt;p&gt;
4944      * For the boxing and unboxing filters to be well formed, their types must be of the form {@code S -&gt; T} and {@code T -&gt; S},
4945      * respectively, where {@code T} is the type of the target var handle. If this is the case, the resulting var handle will
4946      * have type {@code S}.
4947      * &lt;p&gt;
4948      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
4949      * atomic access guarantees as those featured by the target var handle.
4950      *
4951      * @param target the target var handle
4952      * @param filterToTarget a filter to convert some type {@code S} into the type of {@code target}
4953      * @param filterFromTarget a filter to convert the type of {@code target} to some type {@code S}
4954      * @return an adapter var handle which accepts a new type, performing the provided boxing/unboxing conversions.
4955      * @throws NullPointerException if either {@code target}, {@code filterToTarget} or {@code filterFromTarget} are {@code == null}.
4956      * @throws IllegalArgumentException if {@code filterFromTarget} and {@code filterToTarget} are not well-formed, that is, they have types
4957      * other than {@code S -&gt; T} and {@code T -&gt; S}, respectively, where {@code T} is the type of the target var handle,
4958      * or if either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.
4959      */
4960     public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {
4961         Objects.nonNull(target);
4962         Objects.nonNull(filterToTarget);
4963         Objects.nonNull(filterFromTarget);
4964         //check that from/to filters do not throw checked exceptions
4965         noCheckedExceptions(filterToTarget);
4966         noCheckedExceptions(filterFromTarget);
4967 
4968         //check that from/to filters have right signatures
4969         if (filterFromTarget.type().parameterCount() != 1) {
4970             throw newIllegalArgumentException(&quot;filterFromTarget filter type has wrong arity&quot;, filterFromTarget.type());
4971         } else if (filterToTarget.type().parameterCount() != 1) {
4972             throw newIllegalArgumentException(&quot;filterToTarget filter type has wrong arity&quot;, filterFromTarget.type());
4973         } else if (filterFromTarget.type().parameterType(0) != filterToTarget.type().returnType() ||
4974                 filterToTarget.type().parameterType(0) != filterFromTarget.type().returnType()) {
4975             throw newIllegalArgumentException(&quot;filterFromTarget and filterToTarget filter types do not match&quot;, filterFromTarget.type(), filterToTarget.type());
4976         } else if (target.varType() != filterFromTarget.type().parameterType(0)) {
4977             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterFromTarget.type(), target.varType());
4978         } else if (target.varType() != filterToTarget.type().returnType()) {
4979             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterToTarget.type(), target.varType());
4980         }
4981 
4982         return new IndirectVarHandle(target, filterFromTarget.type().returnType(), target.coordinateTypes().toArray(new Class&lt;?&gt;[0]),
4983                 (mode, modeHandle) -&gt; {
4984                     int lastParameterPos = modeHandle.type().parameterCount() - 1;
4985                     return switch (mode.at) {
4986                         case GET -&gt; MethodHandles.filterReturnValue(modeHandle, filterFromTarget);
4987                         case SET -&gt; MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);
4988                         case GET_AND_UPDATE -&gt; {
4989                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);
4990                             yield MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);
4991                         }
4992                         case COMPARE_AND_EXCHANGE -&gt; {
4993                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);
4994                             adapter = MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);
4995                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);
4996                         }
4997                         case COMPARE_AND_SET -&gt; {
4998                             MethodHandle adapter = MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);
4999                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);
5000                         }
5001                     };
5002                 });
5003     }
5004 
5005     /**
5006      * Adapts a target var handle by pre-processing incoming coordinate values using unary filter functions.
5007      * &lt;p&gt;
5008      * When calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the incoming coordinate values
5009      * starting at position {@code pos} (of type {@code C1, C2 ... Cn}, where {@code C1, C2 ... Cn} are the return type
5010      * of the unary filter functions) are transformed into new values (of type {@code S1, S2 ... Sn}, where {@code S1, S2 ... Sn} are the
5011      * parameter types of the unary filter functions), and then passed (along with any coordinate that was left unaltered
5012      * by the adaptation) to the target var handle.
5013      * &lt;p&gt;
5014      * For the coordinate filters to be well formed, their types must be of the form {@code S1 -&gt; T1, S2 -&gt; T1 ... Sn -&gt; Tn},
5015      * where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos} of the target var handle.
5016      * &lt;p&gt;
5017      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
5018      * atomic access guarantees as those featured by the target var handle.
5019      *
5020      * @param target the target var handle
5021      * @param pos the position of the first coordinate to be transformed
5022      * @param filters the unary functions which are used to transform coordinates starting at position {@code pos}
5023      * @return an adapter var handle which accepts new coordinate types, applying the provided transformation
5024      * to the new coordinate values.
5025      * @throws NullPointerException if either {@code target}, {@code filters} are {@code == null}.
5026      * @throws IllegalArgumentException if the handles in {@code filters} are not well-formed, that is, they have types
5027      * other than {@code S1 -&gt; T1, S2 -&gt; T2, ... Sn -&gt; Tn} where {@code T1, T2 ... Tn} are the coordinate types starting
5028      * at position {@code pos} of the target var handle, if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,
5029      * or if more filters are provided than the actual number of coordinate types, or if any of the filters throws any
5030      * checked exceptions.
5031      * available starting at {@code pos}.
5032      */
5033     public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {
5034         Objects.nonNull(target);
5035         Objects.nonNull(filters);
5036         if (filters.length == 0) return target;
5037 
5038         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();
5039         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {
5040             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);
5041         } else if (pos + filters.length &gt; targetCoordinates.size()) {
5042             throw new IllegalArgumentException(&quot;Too many filters&quot;);
5043         }
5044 
5045         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);
5046         for (int i = 0 ; i &lt; filters.length ; i++) {
5047             noCheckedExceptions(filters[i]);
5048             MethodType filterType = filters[i].type();
5049             if (filterType.parameterCount() != 1) {
5050                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType);
5051             } else if (newCoordinates.get(pos + i) != filterType.returnType()) {
5052                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType + &quot; for coordinate type &quot; + newCoordinates.get(i));
5053             }
5054             newCoordinates.set(pos + i, filters[i].type().parameterType(0));
5055         }
5056 
5057         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
5058                 (mode, modeHandle) -&gt; MethodHandles.filterArguments(modeHandle, 1 + pos, filters));
5059     }
5060 
5061     /**
5062      * Provides a target var handle with one or more &lt;em&gt;bound coordinates&lt;/em&gt;
5063      * in advance of the var handle&#39;s invocation. As a consequence, the resulting var handle will feature less
5064      * coordinate types than the target var handle.
5065      * &lt;p&gt;
5066      * When calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, incoming coordinate values
5067      * are joined with bound coordinate values, and then passed to the target var handle.
5068      * &lt;p&gt;
5069      * For the bound coordinates to be well formed, their types must be {@code T1, T2 ... Tn },
5070      * where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos} of the target var handle.
5071      * &lt;p&gt;
5072      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
5073      * atomic access guarantees as those featured by the target var handle.
5074      *
5075      * @param target the var handle to invoke after the bound coordinates are inserted
5076      * @param pos the position of the first coordinate to be inserted
5077      * @param values the series of bound coordinates to insert
5078      * @return an adapter var handle which inserts an additional coordinates,
5079      *         before calling the target var handle
5080      * @throws NullPointerException if either {@code target}, {@code values} are {@code == null}.
5081      * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,
5082      * or if more values are provided than the actual number of coordinate types available starting at {@code pos}.
5083      * @throws ClassCastException if the bound coordinates in {@code values} are not well-formed, that is, they have types
5084      * other than {@code T1, T2 ... Tn }, where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos}
5085      * of the target var handle.
5086      */
5087     public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {
5088         Objects.nonNull(target);
5089         Objects.nonNull(values);
5090         if (values.length == 0) return target;
5091 
5092         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();
5093         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {
5094             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);
5095         } else if (pos + values.length &gt; targetCoordinates.size()) {
5096             throw new IllegalArgumentException(&quot;Too many values&quot;);
5097         }
5098 
5099         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);
5100         for (int i = 0 ; i &lt; values.length ; i++) {
5101             Class&lt;?&gt; pt = newCoordinates.get(pos);
5102             if (pt.isPrimitive()) {
5103                 Wrapper w = Wrapper.forPrimitiveType(pt);
5104                 w.convert(values[i], pt);
5105             } else {
5106                 pt.cast(values[i]);
5107             }
5108             newCoordinates.remove(pos);
5109         }
5110 
5111         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
5112                 (mode, modeHandle) -&gt; MethodHandles.insertArguments(modeHandle, 1 + pos, values));
5113     }
5114 
5115     /**
5116      * Provides a var handle which adapts the coordinate values of the target var handle, by re-arranging them
5117      * so that the new coordinates match the provided ones.
5118      * &lt;p&gt;
5119      * The given array controls the reordering.
5120      * Call {@code #I} the number of incoming coordinates (the value
5121      * {@code newCoordinates.size()}, and call {@code #O} the number
5122      * of outgoing coordinates (the number of coordinates associated with the target var handle).
5123      * Then the length of the reordering array must be {@code #O},
5124      * and each element must be a non-negative number less than {@code #I}.
5125      * For every {@code N} less than {@code #O}, the {@code N}-th
5126      * outgoing coordinate will be taken from the {@code I}-th incoming
5127      * coordinate, where {@code I} is {@code reorder[N]}.
5128      * &lt;p&gt;
5129      * No coordinate value conversions are applied.
5130      * The type of each incoming coordinate, as determined by {@code newCoordinates},
5131      * must be identical to the type of the corresponding outgoing coordinate
5132      * in the target var handle.
5133      * &lt;p&gt;
5134      * The reordering array need not specify an actual permutation.
5135      * An incoming coordinate will be duplicated if its index appears
5136      * more than once in the array, and an incoming coordinate will be dropped
5137      * if its index does not appear in the array.
5138      * &lt;p&gt;
5139      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
5140      * atomic access guarantees as those featured by the target var handle.
5141      * @param target the var handle to invoke after the coordinates have been reordered
5142      * @param newCoordinates the new coordinate types
5143      * @param reorder an index array which controls the reordering
5144      * @return an adapter var handle which re-arranges the incoming coordinate values,
5145      * before calling the target var handle
5146      * @throws NullPointerException if either {@code target}, {@code newCoordinates} or {@code reorder} are {@code == null}.
5147      * @throws IllegalArgumentException if the index array length is not equal to
5148      * the number of coordinates of the target var handle, or if any index array element is not a valid index for
5149      * a coordinate of {@code newCoordinates}, or if two corresponding coordinate types in
5150      * the target var handle and in {@code newCoordinates} are not identical.
5151      */
5152     public static VarHandle permuteCoordinates(VarHandle target, List&lt;Class&lt;?&gt;&gt; newCoordinates, int... reorder) {
5153         Objects.nonNull(target);
5154         Objects.nonNull(newCoordinates);
5155         Objects.nonNull(reorder);
5156 
5157         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();
5158         permuteArgumentChecks(reorder,
5159                 MethodType.methodType(void.class, newCoordinates),
5160                 MethodType.methodType(void.class, targetCoordinates));
5161 
5162         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
5163                 (mode, modeHandle) -&gt;
5164                     MethodHandles.permuteArguments(modeHandle,
5165                         methodTypeFor(mode.at, modeHandle.type(), targetCoordinates, newCoordinates),
5166                         reorderArrayFor(mode.at, newCoordinates, reorder)));
5167     }
5168 
5169     private static int numTrailingArgs(VarHandle.AccessType at) {
5170         return switch (at) {
5171             case GET -&gt; 0;
5172             case GET_AND_UPDATE, SET -&gt; 1;
5173             case COMPARE_AND_SET, COMPARE_AND_EXCHANGE -&gt; 2;
5174         };
5175     }
5176 
5177     private static int[] reorderArrayFor(VarHandle.AccessType at, List&lt;Class&lt;?&gt;&gt; newCoordinates, int[] reorder) {
5178         int numTrailingArgs = numTrailingArgs(at);
5179         int[] adjustedReorder = new int[reorder.length + 1 + numTrailingArgs];
5180         adjustedReorder[0] = 0;
5181         for (int i = 0 ; i &lt; reorder.length ; i++) {
5182             adjustedReorder[i + 1] = reorder[i] + 1;
5183         }
5184         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {
5185             adjustedReorder[i + reorder.length + 1] = i + newCoordinates.size() + 1;
5186         }
5187         return adjustedReorder;
5188     }
5189 
5190     private static MethodType methodTypeFor(VarHandle.AccessType at, MethodType oldType, List&lt;Class&lt;?&gt;&gt; oldCoordinates, List&lt;Class&lt;?&gt;&gt; newCoordinates) {
5191         int numTrailingArgs = numTrailingArgs(at);
5192         MethodType adjustedType = MethodType.methodType(oldType.returnType(), oldType.parameterType(0));
5193         adjustedType = adjustedType.appendParameterTypes(newCoordinates);
5194         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {
5195             adjustedType = adjustedType.appendParameterTypes(oldType.parameterType(1 + oldCoordinates.size() + i));
5196         }
5197         return adjustedType;
5198     }
5199 
5200     /**
5201      * Adapts a target var handle handle by pre-processing
5202      * a sub-sequence of its coordinate values with a filter (a method handle).
5203      * The pre-processed coordinates are replaced by the result (if any) of the
5204      * filter function and the target var handle is then called on the modified (usually shortened)
5205      * coordinate list.
5206      * &lt;p&gt;
5207      * If {code R} is the return type of the filter (which cannot be void), the target var handle must accept a value of
5208      * type {@code R} as its coordinate in position {@code pos}, preceded and/or followed by
5209      * any coordinate not passed to the filter.
5210      * No coordinates are reordered, and the result returned from the filter
5211      * replaces (in order) the whole subsequence of coordinates originally
5212      * passed to the adapter.
5213      * &lt;p&gt;
5214      * The argument types (if any) of the filter
5215      * replace zero or one coordinate types of the target var handle, at position {@code pos},
5216      * in the resulting adapted var handle.
5217      * The return type of the filter must be identical to the
5218      * coordinate type of the target var handle at position {@code pos}, and that target var handle
5219      * coordinate is supplied by the return value of the filter.
5220      * &lt;p&gt;
5221      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
5222      * atomic access guarantees as those featured by the target var handle.
5223      *
5224      * @param target the var handle to invoke after the coordinates have been filtered
5225      * @param pos the position of the coordinate to be filtered
5226      * @param filter the filter method handle
5227      * @return an adapter var handle which filters the incoming coordinate values,
5228      * before calling the target var handle
5229      * @throws NullPointerException if either {@code target}, {@code filter} are {@code == null}.
5230      * @throws IllegalArgumentException if the return type of {@code filter}
5231      * is void, or it is not the same as the {@code pos} coordinate of the target var handle,
5232      * if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,
5233      * if the resulting var handle&#39;s type would have &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many coordinates&lt;/a&gt;,
5234      * or if {@code filter} throws any checked exceptions.
5235      */
5236     public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {
5237         Objects.nonNull(target);
5238         Objects.nonNull(filter);
5239         noCheckedExceptions(filter);
5240 
5241         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();
5242         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {
5243             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);
5244         } else if (filter.type().returnType() == void.class) {
5245             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; ; filter cannot be void&quot;);
5246         } else if (filter.type().returnType() != targetCoordinates.get(pos)) {
5247             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; for coordinate type &quot; + targetCoordinates.get(pos));
5248         }
5249 
5250         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);
5251         for (Class&lt;?&gt; arg : filter.type().parameterList()) {
5252             newCoordinates.add(pos, arg);
5253         }
5254 
5255         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
5256                 (mode, modeHandle) -&gt; MethodHandles.collectArguments(modeHandle, 1 + pos, filter));
5257     }
5258 
5259     private static void noCheckedExceptions(MethodHandle handle) {
5260         if (handle instanceof DirectMethodHandle) {
5261             DirectMethodHandle directHandle = (DirectMethodHandle)handle;
5262             MethodHandleInfo info = Lookup.IMPL_LOOKUP.revealDirect(directHandle);
5263             Class&lt;?&gt;[] exceptionTypes = switch (info.getReferenceKind()) {
5264                 case MethodHandleInfo.REF_invokeInterface, MethodHandleInfo.REF_invokeSpecial,
5265                      MethodHandleInfo.REF_invokeStatic, MethodHandleInfo.REF_invokeVirtual -&gt;
5266                         info.reflectAs(Method.class, Lookup.IMPL_LOOKUP).getExceptionTypes();
5267                 case MethodHandleInfo.REF_newInvokeSpecial -&gt;
5268                         info.reflectAs(Constructor.class, Lookup.IMPL_LOOKUP).getExceptionTypes();
5269                 case MethodHandleInfo.REF_getField, MethodHandleInfo.REF_getStatic,
5270                      MethodHandleInfo.REF_putField, MethodHandleInfo.REF_putStatic -&gt; null;
5271                 default -&gt; throw new AssertionError(&quot;Cannot get here&quot;);
5272             };
5273             if (exceptionTypes != null) {
5274                 if (Stream.of(exceptionTypes).anyMatch(MethodHandles::isCheckedException)) {
5275                     throw newIllegalArgumentException(&quot;Cannot adapt a var handle with a method handle which throws checked exceptions&quot;);
5276                 }
5277             }
5278         } else if (handle instanceof DelegatingMethodHandle) {
5279             noCheckedExceptions(((DelegatingMethodHandle)handle).getTarget());
5280         } else {
5281             //bound
5282             BoundMethodHandle boundHandle = (BoundMethodHandle)handle;
5283             for (int i = 0 ; i &lt; boundHandle.fieldCount() ; i++) {
5284                 Object arg = boundHandle.arg(i);
5285                 if (arg instanceof MethodHandle){
5286                     noCheckedExceptions((MethodHandle) arg);
5287                 }
5288             }
5289         }
5290     }
5291 
5292     private static boolean isCheckedException(Class&lt;?&gt; clazz) {
5293         return Throwable.class.isAssignableFrom(clazz) &amp;&amp;
5294                 !RuntimeException.class.isAssignableFrom(clazz) &amp;&amp;
5295                 !Error.class.isAssignableFrom(clazz);
5296     }
5297 
5298     /**
5299      * Adapts a target method handle by pre-processing
5300      * some of its arguments, and then calling the target with
5301      * the result of the pre-processing, inserted into the original
5302      * sequence of arguments.
5303      * &lt;p&gt;
5304      * The pre-processing is performed by {@code combiner}, a second method handle.
5305      * Of the arguments passed to the adapter, the first {@code N} arguments
5306      * are copied to the combiner, which is then called.
5307      * (Here, {@code N} is defined as the parameter count of the combiner.)
5308      * After this, control passes to the target, with any result
5309      * from the combiner inserted before the original {@code N} incoming
5310      * arguments.
5311      * &lt;p&gt;
5312      * If the combiner returns a value, the first parameter type of the target
5313      * must be identical with the return type of the combiner, and the next
5314      * {@code N} parameter types of the target must exactly match the parameters
5315      * of the combiner.
5316      * &lt;p&gt;
5317      * If the combiner has a void return, no result will be inserted,
5318      * and the first {@code N} parameter types of the target
5319      * must exactly match the parameters of the combiner.
5320      * &lt;p&gt;
5321      * The resulting adapter is the same type as the target, except that the
5322      * first parameter type is dropped,
5323      * if it corresponds to the result of the combiner.
5324      * &lt;p&gt;
5325      * (Note that {@link #dropArguments(MethodHandle,int,List) dropArguments} can be used to remove any arguments
5326      * that either the combiner or the target does not wish to receive.
5327      * If some of the incoming arguments are destined only for the combiner,
5328      * consider using {@link MethodHandle#asCollector asCollector} instead, since those
5329      * arguments will not need to be live on the stack on entry to the
5330      * target.)
5331      * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
5332      * &lt;blockquote&gt;&lt;pre&gt;{@code
5333 import static java.lang.invoke.MethodHandles.*;
5334 import static java.lang.invoke.MethodType.*;
5335 ...
5336 MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
5337   &quot;println&quot;, methodType(void.class, String.class))
5338     .bindTo(System.out);
5339 MethodHandle cat = lookup().findVirtual(String.class,
5340   &quot;concat&quot;, methodType(String.class, String.class));
5341 assertEquals(&quot;boojum&quot;, (String) cat.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
5342 MethodHandle catTrace = foldArguments(cat, trace);
5343 // also prints &quot;boo&quot;:
5344 assertEquals(&quot;boojum&quot;, (String) catTrace.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
5345      * }&lt;/pre&gt;&lt;/blockquote&gt;
5346      * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code, {@code T}
5347      * represents the result type of the {@code target} and resulting adapter.
5348      * {@code V}/{@code v} represent the type and value of the parameter and argument
5349      * of {@code target} that precedes the folding position; {@code V} also is
5350      * the result type of the {@code combiner}. {@code A}/{@code a} denote the
5351      * types and values of the {@code N} parameters and arguments at the folding
5352      * position. {@code B}/{@code b} represent the types and values of the
5353      * {@code target} parameters and arguments that follow the folded parameters
5354      * and arguments.
5355      * &lt;blockquote&gt;&lt;pre&gt;{@code
5356      * // there are N arguments in A...
5357      * T target(V, A[N]..., B...);
5358      * V combiner(A...);
5359      * T adapter(A... a, B... b) {
5360      *   V v = combiner(a...);
5361      *   return target(v, a..., b...);
5362      * }
5363      * // and if the combiner has a void return:
5364      * T target2(A[N]..., B...);
5365      * void combiner2(A...);
5366      * T adapter2(A... a, B... b) {
5367      *   combiner2(a...);
5368      *   return target2(a..., b...);
5369      * }
5370      * }&lt;/pre&gt;&lt;/blockquote&gt;
5371      * &lt;p&gt;
5372      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
5373      * variable-arity method handle}, even if the original target method handle was.
5374      * @param target the method handle to invoke after arguments are combined
5375      * @param combiner method handle to call initially on the incoming arguments
5376      * @return method handle which incorporates the specified argument folding logic
5377      * @throws NullPointerException if either argument is null
5378      * @throws IllegalArgumentException if {@code combiner}&#39;s return type
5379      *          is non-void and not the same as the first argument type of
5380      *          the target, or if the initial {@code N} argument types
5381      *          of the target
5382      *          (skipping one matching the {@code combiner}&#39;s return type)
5383      *          are not identical with the argument types of {@code combiner}
5384      */
5385     public static MethodHandle foldArguments(MethodHandle target, MethodHandle combiner) {
5386         return foldArguments(target, 0, combiner);
5387     }
5388 
5389     /**
5390      * Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then
5391      * calling the target with the result of the pre-processing, inserted into the original sequence of arguments just
5392      * before the folded arguments.
5393      * &lt;p&gt;
5394      * This method is closely related to {@link #foldArguments(MethodHandle, MethodHandle)}, but allows to control the
5395      * position in the parameter list at which folding takes place. The argument controlling this, {@code pos}, is a
5396      * zero-based index. The aforementioned method {@link #foldArguments(MethodHandle, MethodHandle)} assumes position
5397      * 0.
5398      *
5399      * @apiNote Example:
5400      * &lt;blockquote&gt;&lt;pre&gt;{@code
5401     import static java.lang.invoke.MethodHandles.*;
5402     import static java.lang.invoke.MethodType.*;
5403     ...
5404     MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
5405     &quot;println&quot;, methodType(void.class, String.class))
5406     .bindTo(System.out);
5407     MethodHandle cat = lookup().findVirtual(String.class,
5408     &quot;concat&quot;, methodType(String.class, String.class));
5409     assertEquals(&quot;boojum&quot;, (String) cat.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
5410     MethodHandle catTrace = foldArguments(cat, 1, trace);
5411     // also prints &quot;jum&quot;:
5412     assertEquals(&quot;boojum&quot;, (String) catTrace.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
5413      * }&lt;/pre&gt;&lt;/blockquote&gt;
5414      * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code, {@code T}
5415      * represents the result type of the {@code target} and resulting adapter.
5416      * {@code V}/{@code v} represent the type and value of the parameter and argument
5417      * of {@code target} that precedes the folding position; {@code V} also is
5418      * the result type of the {@code combiner}. {@code A}/{@code a} denote the
5419      * types and values of the {@code N} parameters and arguments at the folding
5420      * position. {@code Z}/{@code z} and {@code B}/{@code b} represent the types
5421      * and values of the {@code target} parameters and arguments that precede and
5422      * follow the folded parameters and arguments starting at {@code pos},
5423      * respectively.
5424      * &lt;blockquote&gt;&lt;pre&gt;{@code
5425      * // there are N arguments in A...
5426      * T target(Z..., V, A[N]..., B...);
5427      * V combiner(A...);
5428      * T adapter(Z... z, A... a, B... b) {
5429      *   V v = combiner(a...);
5430      *   return target(z..., v, a..., b...);
5431      * }
5432      * // and if the combiner has a void return:
5433      * T target2(Z..., A[N]..., B...);
5434      * void combiner2(A...);
5435      * T adapter2(Z... z, A... a, B... b) {
5436      *   combiner2(a...);
5437      *   return target2(z..., a..., b...);
5438      * }
5439      * }&lt;/pre&gt;&lt;/blockquote&gt;
5440      * &lt;p&gt;
5441      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
5442      * variable-arity method handle}, even if the original target method handle was.
5443      *
5444      * @param target the method handle to invoke after arguments are combined
5445      * @param pos the position at which to start folding and at which to insert the folding result; if this is {@code
5446      *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.
5447      * @param combiner method handle to call initially on the incoming arguments
5448      * @return method handle which incorporates the specified argument folding logic
5449      * @throws NullPointerException if either argument is null
5450      * @throws IllegalArgumentException if either of the following two conditions holds:
5451      *          (1) {@code combiner}&#39;s return type is non-{@code void} and not the same as the argument type at position
5452      *              {@code pos} of the target signature;
5453      *          (2) the {@code N} argument types at position {@code pos} of the target signature (skipping one matching
5454      *              the {@code combiner}&#39;s return type) are not identical with the argument types of {@code combiner}.
5455      *
5456      * @see #foldArguments(MethodHandle, MethodHandle)
5457      * @since 9
5458      */
5459     public static MethodHandle foldArguments(MethodHandle target, int pos, MethodHandle combiner) {
5460         MethodType targetType = target.type();
5461         MethodType combinerType = combiner.type();
5462         Class&lt;?&gt; rtype = foldArgumentChecks(pos, targetType, combinerType);
5463         BoundMethodHandle result = target.rebind();
5464         boolean dropResult = rtype == void.class;
5465         LambdaForm lform = result.editor().foldArgumentsForm(1 + pos, dropResult, combinerType.basicType());
5466         MethodType newType = targetType;
5467         if (!dropResult) {
5468             newType = newType.dropParameterTypes(pos, pos + 1);
5469         }
5470         result = result.copyWithExtendL(newType, lform, combiner);
5471         return result;
5472     }
5473 
5474     private static Class&lt;?&gt; foldArgumentChecks(int foldPos, MethodType targetType, MethodType combinerType) {
5475         int foldArgs   = combinerType.parameterCount();
5476         Class&lt;?&gt; rtype = combinerType.returnType();
5477         int foldVals = rtype == void.class ? 0 : 1;
5478         int afterInsertPos = foldPos + foldVals;
5479         boolean ok = (targetType.parameterCount() &gt;= afterInsertPos + foldArgs);
5480         if (ok) {
5481             for (int i = 0; i &lt; foldArgs; i++) {
5482                 if (combinerType.parameterType(i) != targetType.parameterType(i + afterInsertPos)) {
5483                     ok = false;
5484                     break;
5485                 }
5486             }
5487         }
5488         if (ok &amp;&amp; foldVals != 0 &amp;&amp; combinerType.returnType() != targetType.parameterType(foldPos))
5489             ok = false;
5490         if (!ok)
5491             throw misMatchedTypes(&quot;target and combiner types&quot;, targetType, combinerType);
5492         return rtype;
5493     }
5494 
5495     /**
5496      * Adapts a target method handle by pre-processing some of its arguments, then calling the target with the result
5497      * of the pre-processing replacing the argument at the given position.
5498      *
5499      * @param target the method handle to invoke after arguments are combined
5500      * @param position the position at which to start folding and at which to insert the folding result; if this is {@code
5501      *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.
5502      * @param combiner method handle to call initially on the incoming arguments
5503      * @param argPositions indexes of the target to pick arguments sent to the combiner from
5504      * @return method handle which incorporates the specified argument folding logic
5505      * @throws NullPointerException if either argument is null
5506      * @throws IllegalArgumentException if either of the following two conditions holds:
5507      *          (1) {@code combiner}&#39;s return type is not the same as the argument type at position
5508      *              {@code pos} of the target signature;
5509      *          (2) the {@code N} argument types at positions {@code argPositions[1...N]} of the target signature are
5510      *              not identical with the argument types of {@code combiner}.
5511      */
5512     /*non-public*/
5513     static MethodHandle filterArgumentsWithCombiner(MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {
5514         return argumentsWithCombiner(true, target, position, combiner, argPositions);
5515     }
5516 
5517     /**
5518      * Adapts a target method handle by pre-processing some of its arguments, calling the target with the result of
5519      * the pre-processing inserted into the original sequence of arguments at the given position.
5520      *
5521      * @param target the method handle to invoke after arguments are combined
5522      * @param position the position at which to start folding and at which to insert the folding result; if this is {@code
5523      *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.
5524      * @param combiner method handle to call initially on the incoming arguments
5525      * @param argPositions indexes of the target to pick arguments sent to the combiner from
5526      * @return method handle which incorporates the specified argument folding logic
5527      * @throws NullPointerException if either argument is null
5528      * @throws IllegalArgumentException if either of the following two conditions holds:
5529      *          (1) {@code combiner}&#39;s return type is non-{@code void} and not the same as the argument type at position
5530      *              {@code pos} of the target signature;
5531      *          (2) the {@code N} argument types at positions {@code argPositions[1...N]} of the target signature
5532      *              (skipping {@code position} where the {@code combiner}&#39;s return will be folded in) are not identical
5533      *              with the argument types of {@code combiner}.
5534      */
5535     /*non-public*/
5536     static MethodHandle foldArgumentsWithCombiner(MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {
5537         return argumentsWithCombiner(false, target, position, combiner, argPositions);
5538     }
5539 
5540     private static MethodHandle argumentsWithCombiner(boolean filter, MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {
5541         MethodType targetType = target.type();
5542         MethodType combinerType = combiner.type();
5543         Class&lt;?&gt; rtype = argumentsWithCombinerChecks(position, filter, targetType, combinerType, argPositions);
5544         BoundMethodHandle result = target.rebind();
5545 
5546         MethodType newType = targetType;
5547         LambdaForm lform;
5548         if (filter) {
5549             lform = result.editor().filterArgumentsForm(1 + position, combinerType.basicType(), argPositions);
5550         } else {
5551             boolean dropResult = rtype == void.class;
5552             lform = result.editor().foldArgumentsForm(1 + position, dropResult, combinerType.basicType(), argPositions);
5553             if (!dropResult) {
5554                 newType = newType.dropParameterTypes(position, position + 1);
5555             }
5556         }
5557         result = result.copyWithExtendL(newType, lform, combiner);
5558         return result;
5559     }
5560 
5561     private static Class&lt;?&gt; argumentsWithCombinerChecks(int position, boolean filter, MethodType targetType, MethodType combinerType, int ... argPos) {
5562         int combinerArgs = combinerType.parameterCount();
5563         if (argPos.length != combinerArgs) {
5564             throw newIllegalArgumentException(&quot;combiner and argument map must be equal size&quot;, combinerType, argPos.length);
5565         }
5566         Class&lt;?&gt; rtype = combinerType.returnType();
5567 
5568         for (int i = 0; i &lt; combinerArgs; i++) {
5569             int arg = argPos[i];
5570             if (arg &lt; 0 || arg &gt; targetType.parameterCount()) {
5571                 throw newIllegalArgumentException(&quot;arg outside of target parameterRange&quot;, targetType, arg);
5572             }
5573             if (combinerType.parameterType(i) != targetType.parameterType(arg)) {
5574                 throw newIllegalArgumentException(&quot;target argument type at position &quot; + arg
5575                         + &quot; must match combiner argument type at index &quot; + i + &quot;: &quot; + targetType
5576                         + &quot; -&gt; &quot; + combinerType + &quot;, map: &quot; + Arrays.toString(argPos));
5577             }
5578         }
5579         if (filter &amp;&amp; combinerType.returnType() != targetType.parameterType(position)) {
5580             throw misMatchedTypes(&quot;target and combiner types&quot;, targetType, combinerType);
5581         }
5582         return rtype;
5583     }
5584 
5585     /**
5586      * Makes a method handle which adapts a target method handle,
5587      * by guarding it with a test, a boolean-valued method handle.
5588      * If the guard fails, a fallback handle is called instead.
5589      * All three method handles must have the same corresponding
5590      * argument and return types, except that the return type
5591      * of the test must be boolean, and the test is allowed
5592      * to have fewer arguments than the other two method handles.
5593      * &lt;p&gt;
5594      * Here is pseudocode for the resulting adapter. In the code, {@code T}
5595      * represents the uniform result type of the three involved handles;
5596      * {@code A}/{@code a}, the types and values of the {@code target}
5597      * parameters and arguments that are consumed by the {@code test}; and
5598      * {@code B}/{@code b}, those types and values of the {@code target}
5599      * parameters and arguments that are not consumed by the {@code test}.
5600      * &lt;blockquote&gt;&lt;pre&gt;{@code
5601      * boolean test(A...);
5602      * T target(A...,B...);
5603      * T fallback(A...,B...);
5604      * T adapter(A... a,B... b) {
5605      *   if (test(a...))
5606      *     return target(a..., b...);
5607      *   else
5608      *     return fallback(a..., b...);
5609      * }
5610      * }&lt;/pre&gt;&lt;/blockquote&gt;
5611      * Note that the test arguments ({@code a...} in the pseudocode) cannot
5612      * be modified by execution of the test, and so are passed unchanged
5613      * from the caller to the target or fallback as appropriate.
5614      * @param test method handle used for test, must return boolean
5615      * @param target method handle to call if test passes
5616      * @param fallback method handle to call if test fails
5617      * @return method handle which incorporates the specified if/then/else logic
5618      * @throws NullPointerException if any argument is null
5619      * @throws IllegalArgumentException if {@code test} does not return boolean,
5620      *          or if all three method types do not match (with the return
5621      *          type of {@code test} changed to match that of the target).
5622      */
5623     public static MethodHandle guardWithTest(MethodHandle test,
5624                                MethodHandle target,
5625                                MethodHandle fallback) {
5626         MethodType gtype = test.type();
5627         MethodType ttype = target.type();
5628         MethodType ftype = fallback.type();
5629         if (!ttype.equals(ftype))
5630             throw misMatchedTypes(&quot;target and fallback types&quot;, ttype, ftype);
5631         if (gtype.returnType() != boolean.class)
5632             throw newIllegalArgumentException(&quot;guard type is not a predicate &quot;+gtype);
5633         List&lt;Class&lt;?&gt;&gt; targs = ttype.parameterList();
5634         test = dropArgumentsToMatch(test, 0, targs, 0, true);
5635         if (test == null) {
5636             throw misMatchedTypes(&quot;target and test types&quot;, ttype, gtype);
5637         }
5638         return MethodHandleImpl.makeGuardWithTest(test, target, fallback);
5639     }
5640 
5641     static &lt;T&gt; RuntimeException misMatchedTypes(String what, T t1, T t2) {
5642         return newIllegalArgumentException(what + &quot; must match: &quot; + t1 + &quot; != &quot; + t2);
5643     }
5644 
5645     /**
5646      * Makes a method handle which adapts a target method handle,
5647      * by running it inside an exception handler.
5648      * If the target returns normally, the adapter returns that value.
5649      * If an exception matching the specified type is thrown, the fallback
5650      * handle is called instead on the exception, plus the original arguments.
5651      * &lt;p&gt;
5652      * The target and handler must have the same corresponding
5653      * argument and return types, except that handler may omit trailing arguments
5654      * (similarly to the predicate in {@link #guardWithTest guardWithTest}).
5655      * Also, the handler must have an extra leading parameter of {@code exType} or a supertype.
5656      * &lt;p&gt;
5657      * Here is pseudocode for the resulting adapter. In the code, {@code T}
5658      * represents the return type of the {@code target} and {@code handler},
5659      * and correspondingly that of the resulting adapter; {@code A}/{@code a},
5660      * the types and values of arguments to the resulting handle consumed by
5661      * {@code handler}; and {@code B}/{@code b}, those of arguments to the
5662      * resulting handle discarded by {@code handler}.
5663      * &lt;blockquote&gt;&lt;pre&gt;{@code
5664      * T target(A..., B...);
5665      * T handler(ExType, A...);
5666      * T adapter(A... a, B... b) {
5667      *   try {
5668      *     return target(a..., b...);
5669      *   } catch (ExType ex) {
5670      *     return handler(ex, a...);
5671      *   }
5672      * }
5673      * }&lt;/pre&gt;&lt;/blockquote&gt;
5674      * Note that the saved arguments ({@code a...} in the pseudocode) cannot
5675      * be modified by execution of the target, and so are passed unchanged
5676      * from the caller to the handler, if the handler is invoked.
5677      * &lt;p&gt;
5678      * The target and handler must return the same type, even if the handler
5679      * always throws.  (This might happen, for instance, because the handler
5680      * is simulating a {@code finally} clause).
5681      * To create such a throwing handler, compose the handler creation logic
5682      * with {@link #throwException throwException},
5683      * in order to create a method handle of the correct return type.
5684      * @param target method handle to call
5685      * @param exType the type of exception which the handler will catch
5686      * @param handler method handle to call if a matching exception is thrown
5687      * @return method handle which incorporates the specified try/catch logic
5688      * @throws NullPointerException if any argument is null
5689      * @throws IllegalArgumentException if {@code handler} does not accept
5690      *          the given exception type, or if the method handle types do
5691      *          not match in their return types and their
5692      *          corresponding parameters
5693      * @see MethodHandles#tryFinally(MethodHandle, MethodHandle)
5694      */
5695     public static MethodHandle catchException(MethodHandle target,
5696                                 Class&lt;? extends Throwable&gt; exType,
5697                                 MethodHandle handler) {
5698         MethodType ttype = target.type();
5699         MethodType htype = handler.type();
5700         if (!Throwable.class.isAssignableFrom(exType))
5701             throw new ClassCastException(exType.getName());
5702         if (htype.parameterCount() &lt; 1 ||
5703             !htype.parameterType(0).isAssignableFrom(exType))
5704             throw newIllegalArgumentException(&quot;handler does not accept exception type &quot;+exType);
5705         if (htype.returnType() != ttype.returnType())
5706             throw misMatchedTypes(&quot;target and handler return types&quot;, ttype, htype);
5707         handler = dropArgumentsToMatch(handler, 1, ttype.parameterList(), 0, true);
5708         if (handler == null) {
5709             throw misMatchedTypes(&quot;target and handler types&quot;, ttype, htype);
5710         }
5711         return MethodHandleImpl.makeGuardWithCatch(target, exType, handler);
5712     }
5713 
5714     /**
5715      * Produces a method handle which will throw exceptions of the given {@code exType}.
5716      * The method handle will accept a single argument of {@code exType},
5717      * and immediately throw it as an exception.
5718      * The method type will nominally specify a return of {@code returnType}.
5719      * The return type may be anything convenient:  It doesn&#39;t matter to the
5720      * method handle&#39;s behavior, since it will never return normally.
5721      * @param returnType the return type of the desired method handle
5722      * @param exType the parameter type of the desired method handle
5723      * @return method handle which can throw the given exceptions
5724      * @throws NullPointerException if either argument is null
5725      */
5726     public static MethodHandle throwException(Class&lt;?&gt; returnType, Class&lt;? extends Throwable&gt; exType) {
5727         if (!Throwable.class.isAssignableFrom(exType))
5728             throw new ClassCastException(exType.getName());
5729         return MethodHandleImpl.throwException(methodType(returnType, exType));
5730     }
5731 
5732     /**
5733      * Constructs a method handle representing a loop with several loop variables that are updated and checked upon each
5734      * iteration. Upon termination of the loop due to one of the predicates, a corresponding finalizer is run and
5735      * delivers the loop&#39;s result, which is the return value of the resulting handle.
5736      * &lt;p&gt;
5737      * Intuitively, every loop is formed by one or more &quot;clauses&quot;, each specifying a local &lt;em&gt;iteration variable&lt;/em&gt; and/or a loop
5738      * exit. Each iteration of the loop executes each clause in order. A clause can optionally update its iteration
5739      * variable; it can also optionally perform a test and conditional loop exit. In order to express this logic in
5740      * terms of method handles, each clause will specify up to four independent actions:&lt;ul&gt;
5741      * &lt;li&gt;&lt;em&gt;init:&lt;/em&gt; Before the loop executes, the initialization of an iteration variable {@code v} of type {@code V}.
5742      * &lt;li&gt;&lt;em&gt;step:&lt;/em&gt; When a clause executes, an update step for the iteration variable {@code v}.
5743      * &lt;li&gt;&lt;em&gt;pred:&lt;/em&gt; When a clause executes, a predicate execution to test for loop exit.
5744      * &lt;li&gt;&lt;em&gt;fini:&lt;/em&gt; If a clause causes a loop exit, a finalizer execution to compute the loop&#39;s return value.
5745      * &lt;/ul&gt;
5746      * The full sequence of all iteration variable types, in clause order, will be notated as {@code (V...)}.
5747      * The values themselves will be {@code (v...)}.  When we speak of &quot;parameter lists&quot;, we will usually
5748      * be referring to types, but in some contexts (describing execution) the lists will be of actual values.
5749      * &lt;p&gt;
5750      * Some of these clause parts may be omitted according to certain rules, and useful default behavior is provided in
5751      * this case. See below for a detailed description.
5752      * &lt;p&gt;
5753      * &lt;em&gt;Parameters optional everywhere:&lt;/em&gt;
5754      * Each clause function is allowed but not required to accept a parameter for each iteration variable {@code v}.
5755      * As an exception, the init functions cannot take any {@code v} parameters,
5756      * because those values are not yet computed when the init functions are executed.
5757      * Any clause function may neglect to take any trailing subsequence of parameters it is entitled to take.
5758      * In fact, any clause function may take no arguments at all.
5759      * &lt;p&gt;
5760      * &lt;em&gt;Loop parameters:&lt;/em&gt;
5761      * A clause function may take all the iteration variable values it is entitled to, in which case
5762      * it may also take more trailing parameters. Such extra values are called &lt;em&gt;loop parameters&lt;/em&gt;,
5763      * with their types and values notated as {@code (A...)} and {@code (a...)}.
5764      * These become the parameters of the resulting loop handle, to be supplied whenever the loop is executed.
5765      * (Since init functions do not accept iteration variables {@code v}, any parameter to an
5766      * init function is automatically a loop parameter {@code a}.)
5767      * As with iteration variables, clause functions are allowed but not required to accept loop parameters.
5768      * These loop parameters act as loop-invariant values visible across the whole loop.
5769      * &lt;p&gt;
5770      * &lt;em&gt;Parameters visible everywhere:&lt;/em&gt;
5771      * Each non-init clause function is permitted to observe the entire loop state, because it can be passed the full
5772      * list {@code (v... a...)} of current iteration variable values and incoming loop parameters.
5773      * The init functions can observe initial pre-loop state, in the form {@code (a...)}.
5774      * Most clause functions will not need all of this information, but they will be formally connected to it
5775      * as if by {@link #dropArguments}.
5776      * &lt;a id=&quot;astar&quot;&gt;&lt;/a&gt;
5777      * More specifically, we shall use the notation {@code (V*)} to express an arbitrary prefix of a full
5778      * sequence {@code (V...)} (and likewise for {@code (v*)}, {@code (A*)}, {@code (a*)}).
5779      * In that notation, the general form of an init function parameter list
5780      * is {@code (A*)}, and the general form of a non-init function parameter list is {@code (V*)} or {@code (V... A*)}.
5781      * &lt;p&gt;
5782      * &lt;em&gt;Checking clause structure:&lt;/em&gt;
5783      * Given a set of clauses, there is a number of checks and adjustments performed to connect all the parts of the
5784      * loop. They are spelled out in detail in the steps below. In these steps, every occurrence of the word &quot;must&quot;
5785      * corresponds to a place where {@link IllegalArgumentException} will be thrown if the required constraint is not
5786      * met by the inputs to the loop combinator.
5787      * &lt;p&gt;
5788      * &lt;em&gt;Effectively identical sequences:&lt;/em&gt;
5789      * &lt;a id=&quot;effid&quot;&gt;&lt;/a&gt;
5790      * A parameter list {@code A} is defined to be &lt;em&gt;effectively identical&lt;/em&gt; to another parameter list {@code B}
5791      * if {@code A} and {@code B} are identical, or if {@code A} is shorter and is identical with a proper prefix of {@code B}.
5792      * When speaking of an unordered set of parameter lists, we say they the set is &quot;effectively identical&quot;
5793      * as a whole if the set contains a longest list, and all members of the set are effectively identical to
5794      * that longest list.
5795      * For example, any set of type sequences of the form {@code (V*)} is effectively identical,
5796      * and the same is true if more sequences of the form {@code (V... A*)} are added.
5797      * &lt;p&gt;
5798      * &lt;em&gt;Step 0: Determine clause structure.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
5799      * &lt;li&gt;The clause array (of type {@code MethodHandle[][]}) must be non-{@code null} and contain at least one element.
5800      * &lt;li&gt;The clause array may not contain {@code null}s or sub-arrays longer than four elements.
5801      * &lt;li&gt;Clauses shorter than four elements are treated as if they were padded by {@code null} elements to length
5802      * four. Padding takes place by appending elements to the array.
5803      * &lt;li&gt;Clauses with all {@code null}s are disregarded.
5804      * &lt;li&gt;Each clause is treated as a four-tuple of functions, called &quot;init&quot;, &quot;step&quot;, &quot;pred&quot;, and &quot;fini&quot;.
5805      * &lt;/ol&gt;
5806      * &lt;p&gt;
5807      * &lt;em&gt;Step 1A: Determine iteration variable types {@code (V...)}.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
5808      * &lt;li&gt;The iteration variable type for each clause is determined using the clause&#39;s init and step return types.
5809      * &lt;li&gt;If both functions are omitted, there is no iteration variable for the corresponding clause ({@code void} is
5810      * used as the type to indicate that). If one of them is omitted, the other&#39;s return type defines the clause&#39;s
5811      * iteration variable type. If both are given, the common return type (they must be identical) defines the clause&#39;s
5812      * iteration variable type.
5813      * &lt;li&gt;Form the list of return types (in clause order), omitting all occurrences of {@code void}.
5814      * &lt;li&gt;This list of types is called the &quot;iteration variable types&quot; ({@code (V...)}).
5815      * &lt;/ol&gt;
5816      * &lt;p&gt;
5817      * &lt;em&gt;Step 1B: Determine loop parameters {@code (A...)}.&lt;/em&gt;&lt;ul&gt;
5818      * &lt;li&gt;Examine and collect init function parameter lists (which are of the form {@code (A*)}).
5819      * &lt;li&gt;Examine and collect the suffixes of the step, pred, and fini parameter lists, after removing the iteration variable types.
5820      * (They must have the form {@code (V... A*)}; collect the {@code (A*)} parts only.)
5821      * &lt;li&gt;Do not collect suffixes from step, pred, and fini parameter lists that do not begin with all the iteration variable types.
5822      * (These types will be checked in step 2, along with all the clause function types.)
5823      * &lt;li&gt;Omitted clause functions are ignored.  (Equivalently, they are deemed to have empty parameter lists.)
5824      * &lt;li&gt;All of the collected parameter lists must be effectively identical.
5825      * &lt;li&gt;The longest parameter list (which is necessarily unique) is called the &quot;external parameter list&quot; ({@code (A...)}).
5826      * &lt;li&gt;If there is no such parameter list, the external parameter list is taken to be the empty sequence.
5827      * &lt;li&gt;The combined list consisting of iteration variable types followed by the external parameter types is called
5828      * the &quot;internal parameter list&quot;.
5829      * &lt;/ul&gt;
5830      * &lt;p&gt;
5831      * &lt;em&gt;Step 1C: Determine loop return type.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
5832      * &lt;li&gt;Examine fini function return types, disregarding omitted fini functions.
5833      * &lt;li&gt;If there are no fini functions, the loop return type is {@code void}.
5834      * &lt;li&gt;Otherwise, the common return type {@code R} of the fini functions (their return types must be identical) defines the loop return
5835      * type.
5836      * &lt;/ol&gt;
5837      * &lt;p&gt;
5838      * &lt;em&gt;Step 1D: Check other types.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
5839      * &lt;li&gt;There must be at least one non-omitted pred function.
5840      * &lt;li&gt;Every non-omitted pred function must have a {@code boolean} return type.
5841      * &lt;/ol&gt;
5842      * &lt;p&gt;
5843      * &lt;em&gt;Step 2: Determine parameter lists.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
5844      * &lt;li&gt;The parameter list for the resulting loop handle will be the external parameter list {@code (A...)}.
5845      * &lt;li&gt;The parameter list for init functions will be adjusted to the external parameter list.
5846      * (Note that their parameter lists are already effectively identical to this list.)
5847      * &lt;li&gt;The parameter list for every non-omitted, non-init (step, pred, and fini) function must be
5848      * effectively identical to the internal parameter list {@code (V... A...)}.
5849      * &lt;/ol&gt;
5850      * &lt;p&gt;
5851      * &lt;em&gt;Step 3: Fill in omitted functions.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
5852      * &lt;li&gt;If an init function is omitted, use a {@linkplain #empty default value} for the clause&#39;s iteration variable
5853      * type.
5854      * &lt;li&gt;If a step function is omitted, use an {@linkplain #identity identity function} of the clause&#39;s iteration
5855      * variable type; insert dropped argument parameters before the identity function parameter for the non-{@code void}
5856      * iteration variables of preceding clauses. (This will turn the loop variable into a local loop invariant.)
5857      * &lt;li&gt;If a pred function is omitted, use a constant {@code true} function. (This will keep the loop going, as far
5858      * as this clause is concerned.  Note that in such cases the corresponding fini function is unreachable.)
5859      * &lt;li&gt;If a fini function is omitted, use a {@linkplain #empty default value} for the
5860      * loop return type.
5861      * &lt;/ol&gt;
5862      * &lt;p&gt;
5863      * &lt;em&gt;Step 4: Fill in missing parameter types.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
5864      * &lt;li&gt;At this point, every init function parameter list is effectively identical to the external parameter list {@code (A...)},
5865      * but some lists may be shorter. For every init function with a short parameter list, pad out the end of the list.
5866      * &lt;li&gt;At this point, every non-init function parameter list is effectively identical to the internal parameter
5867      * list {@code (V... A...)}, but some lists may be shorter. For every non-init function with a short parameter list,
5868      * pad out the end of the list.
5869      * &lt;li&gt;Argument lists are padded out by {@linkplain #dropArgumentsToMatch(MethodHandle, int, List, int) dropping unused trailing arguments}.
5870      * &lt;/ol&gt;
5871      * &lt;p&gt;
5872      * &lt;em&gt;Final observations.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
5873      * &lt;li&gt;After these steps, all clauses have been adjusted by supplying omitted functions and arguments.
5874      * &lt;li&gt;All init functions have a common parameter type list {@code (A...)}, which the final loop handle will also have.
5875      * &lt;li&gt;All fini functions have a common return type {@code R}, which the final loop handle will also have.
5876      * &lt;li&gt;All non-init functions have a common parameter type list {@code (V... A...)}, of
5877      * (non-{@code void}) iteration variables {@code V} followed by loop parameters.
5878      * &lt;li&gt;Each pair of init and step functions agrees in their return type {@code V}.
5879      * &lt;li&gt;Each non-init function will be able to observe the current values {@code (v...)} of all iteration variables.
5880      * &lt;li&gt;Every function will be able to observe the incoming values {@code (a...)} of all loop parameters.
5881      * &lt;/ol&gt;
5882      * &lt;p&gt;
5883      * &lt;em&gt;Example.&lt;/em&gt; As a consequence of step 1A above, the {@code loop} combinator has the following property:
5884      * &lt;ul&gt;
5885      * &lt;li&gt;Given {@code N} clauses {@code Cn = {null, Sn, Pn}} with {@code n = 1..N}.
5886      * &lt;li&gt;Suppose predicate handles {@code Pn} are either {@code null} or have no parameters.
5887      * (Only one {@code Pn} has to be non-{@code null}.)
5888      * &lt;li&gt;Suppose step handles {@code Sn} have signatures {@code (B1..BX)Rn}, for some constant {@code X&gt;=N}.
5889      * &lt;li&gt;Suppose {@code Q} is the count of non-void types {@code Rn}, and {@code (V1...VQ)} is the sequence of those types.
5890      * &lt;li&gt;It must be that {@code Vn == Bn} for {@code n = 1..min(X,Q)}.
5891      * &lt;li&gt;The parameter types {@code Vn} will be interpreted as loop-local state elements {@code (V...)}.
5892      * &lt;li&gt;Any remaining types {@code BQ+1..BX} (if {@code Q&lt;X}) will determine
5893      * the resulting loop handle&#39;s parameter types {@code (A...)}.
5894      * &lt;/ul&gt;
5895      * In this example, the loop handle parameters {@code (A...)} were derived from the step functions,
5896      * which is natural if most of the loop computation happens in the steps.  For some loops,
5897      * the burden of computation might be heaviest in the pred functions, and so the pred functions
5898      * might need to accept the loop parameter values.  For loops with complex exit logic, the fini
5899      * functions might need to accept loop parameters, and likewise for loops with complex entry logic,
5900      * where the init functions will need the extra parameters.  For such reasons, the rules for
5901      * determining these parameters are as symmetric as possible, across all clause parts.
5902      * In general, the loop parameters function as common invariant values across the whole
5903      * loop, while the iteration variables function as common variant values, or (if there is
5904      * no step function) as internal loop invariant temporaries.
5905      * &lt;p&gt;
5906      * &lt;em&gt;Loop execution.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
5907      * &lt;li&gt;When the loop is called, the loop input values are saved in locals, to be passed to
5908      * every clause function. These locals are loop invariant.
5909      * &lt;li&gt;Each init function is executed in clause order (passing the external arguments {@code (a...)})
5910      * and the non-{@code void} values are saved (as the iteration variables {@code (v...)}) into locals.
5911      * These locals will be loop varying (unless their steps behave as identity functions, as noted above).
5912      * &lt;li&gt;All function executions (except init functions) will be passed the internal parameter list, consisting of
5913      * the non-{@code void} iteration values {@code (v...)} (in clause order) and then the loop inputs {@code (a...)}
5914      * (in argument order).
5915      * &lt;li&gt;The step and pred functions are then executed, in clause order (step before pred), until a pred function
5916      * returns {@code false}.
5917      * &lt;li&gt;The non-{@code void} result from a step function call is used to update the corresponding value in the
5918      * sequence {@code (v...)} of loop variables.
5919      * The updated value is immediately visible to all subsequent function calls.
5920      * &lt;li&gt;If a pred function returns {@code false}, the corresponding fini function is called, and the resulting value
5921      * (of type {@code R}) is returned from the loop as a whole.
5922      * &lt;li&gt;If all the pred functions always return true, no fini function is ever invoked, and the loop cannot exit
5923      * except by throwing an exception.
5924      * &lt;/ol&gt;
5925      * &lt;p&gt;
5926      * &lt;em&gt;Usage tips.&lt;/em&gt;
5927      * &lt;ul&gt;
5928      * &lt;li&gt;Although each step function will receive the current values of &lt;em&gt;all&lt;/em&gt; the loop variables,
5929      * sometimes a step function only needs to observe the current value of its own variable.
5930      * In that case, the step function may need to explicitly {@linkplain #dropArguments drop all preceding loop variables}.
5931      * This will require mentioning their types, in an expression like {@code dropArguments(step, 0, V0.class, ...)}.
5932      * &lt;li&gt;Loop variables are not required to vary; they can be loop invariant.  A clause can create
5933      * a loop invariant by a suitable init function with no step, pred, or fini function.  This may be
5934      * useful to &quot;wire&quot; an incoming loop argument into the step or pred function of an adjacent loop variable.
5935      * &lt;li&gt;If some of the clause functions are virtual methods on an instance, the instance
5936      * itself can be conveniently placed in an initial invariant loop &quot;variable&quot;, using an initial clause
5937      * like {@code new MethodHandle[]{identity(ObjType.class)}}.  In that case, the instance reference
5938      * will be the first iteration variable value, and it will be easy to use virtual
5939      * methods as clause parts, since all of them will take a leading instance reference matching that value.
5940      * &lt;/ul&gt;
5941      * &lt;p&gt;
5942      * Here is pseudocode for the resulting loop handle. As above, {@code V} and {@code v} represent the types
5943      * and values of loop variables; {@code A} and {@code a} represent arguments passed to the whole loop;
5944      * and {@code R} is the common result type of all finalizers as well as of the resulting loop.
5945      * &lt;blockquote&gt;&lt;pre&gt;{@code
5946      * V... init...(A...);
5947      * boolean pred...(V..., A...);
5948      * V... step...(V..., A...);
5949      * R fini...(V..., A...);
5950      * R loop(A... a) {
5951      *   V... v... = init...(a...);
5952      *   for (;;) {
5953      *     for ((v, p, s, f) in (v..., pred..., step..., fini...)) {
5954      *       v = s(v..., a...);
5955      *       if (!p(v..., a...)) {
5956      *         return f(v..., a...);
5957      *       }
5958      *     }
5959      *   }
5960      * }
5961      * }&lt;/pre&gt;&lt;/blockquote&gt;
5962      * Note that the parameter type lists {@code (V...)} and {@code (A...)} have been expanded
5963      * to their full length, even though individual clause functions may neglect to take them all.
5964      * As noted above, missing parameters are filled in as if by {@link #dropArgumentsToMatch(MethodHandle, int, List, int)}.
5965      *
5966      * @apiNote Example:
5967      * &lt;blockquote&gt;&lt;pre&gt;{@code
5968      * // iterative implementation of the factorial function as a loop handle
5969      * static int one(int k) { return 1; }
5970      * static int inc(int i, int acc, int k) { return i + 1; }
5971      * static int mult(int i, int acc, int k) { return i * acc; }
5972      * static boolean pred(int i, int acc, int k) { return i &lt; k; }
5973      * static int fin(int i, int acc, int k) { return acc; }
5974      * // assume MH_one, MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods
5975      * // null initializer for counter, should initialize to 0
5976      * MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
5977      * MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
5978      * MethodHandle loop = MethodHandles.loop(counterClause, accumulatorClause);
5979      * assertEquals(120, loop.invoke(5));
5980      * }&lt;/pre&gt;&lt;/blockquote&gt;
5981      * The same example, dropping arguments and using combinators:
5982      * &lt;blockquote&gt;&lt;pre&gt;{@code
5983      * // simplified implementation of the factorial function as a loop handle
5984      * static int inc(int i) { return i + 1; } // drop acc, k
5985      * static int mult(int i, int acc) { return i * acc; } //drop k
5986      * static boolean cmp(int i, int k) { return i &lt; k; }
5987      * // assume MH_inc, MH_mult, and MH_cmp are handles to the above methods
5988      * // null initializer for counter, should initialize to 0
5989      * MethodHandle MH_one = MethodHandles.constant(int.class, 1);
5990      * MethodHandle MH_pred = MethodHandles.dropArguments(MH_cmp, 1, int.class); // drop acc
5991      * MethodHandle MH_fin = MethodHandles.dropArguments(MethodHandles.identity(int.class), 0, int.class); // drop i
5992      * MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
5993      * MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
5994      * MethodHandle loop = MethodHandles.loop(counterClause, accumulatorClause);
5995      * assertEquals(720, loop.invoke(6));
5996      * }&lt;/pre&gt;&lt;/blockquote&gt;
5997      * A similar example, using a helper object to hold a loop parameter:
5998      * &lt;blockquote&gt;&lt;pre&gt;{@code
5999      * // instance-based implementation of the factorial function as a loop handle
6000      * static class FacLoop {
6001      *   final int k;
6002      *   FacLoop(int k) { this.k = k; }
6003      *   int inc(int i) { return i + 1; }
6004      *   int mult(int i, int acc) { return i * acc; }
6005      *   boolean pred(int i) { return i &lt; k; }
6006      *   int fin(int i, int acc) { return acc; }
6007      * }
6008      * // assume MH_FacLoop is a handle to the constructor
6009      * // assume MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods
6010      * // null initializer for counter, should initialize to 0
6011      * MethodHandle MH_one = MethodHandles.constant(int.class, 1);
6012      * MethodHandle[] instanceClause = new MethodHandle[]{MH_FacLoop};
6013      * MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
6014      * MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
6015      * MethodHandle loop = MethodHandles.loop(instanceClause, counterClause, accumulatorClause);
6016      * assertEquals(5040, loop.invoke(7));
6017      * }&lt;/pre&gt;&lt;/blockquote&gt;
6018      *
6019      * @param clauses an array of arrays (4-tuples) of {@link MethodHandle}s adhering to the rules described above.
6020      *
6021      * @return a method handle embodying the looping behavior as defined by the arguments.
6022      *
6023      * @throws IllegalArgumentException in case any of the constraints described above is violated.
6024      *
6025      * @see MethodHandles#whileLoop(MethodHandle, MethodHandle, MethodHandle)
6026      * @see MethodHandles#doWhileLoop(MethodHandle, MethodHandle, MethodHandle)
6027      * @see MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle)
6028      * @see MethodHandles#iteratedLoop(MethodHandle, MethodHandle, MethodHandle)
6029      * @since 9
6030      */
6031     public static MethodHandle loop(MethodHandle[]... clauses) {
6032         // Step 0: determine clause structure.
6033         loopChecks0(clauses);
6034 
6035         List&lt;MethodHandle&gt; init = new ArrayList&lt;&gt;();
6036         List&lt;MethodHandle&gt; step = new ArrayList&lt;&gt;();
6037         List&lt;MethodHandle&gt; pred = new ArrayList&lt;&gt;();
6038         List&lt;MethodHandle&gt; fini = new ArrayList&lt;&gt;();
6039 
6040         Stream.of(clauses).filter(c -&gt; Stream.of(c).anyMatch(Objects::nonNull)).forEach(clause -&gt; {
6041             init.add(clause[0]); // all clauses have at least length 1
6042             step.add(clause.length &lt;= 1 ? null : clause[1]);
6043             pred.add(clause.length &lt;= 2 ? null : clause[2]);
6044             fini.add(clause.length &lt;= 3 ? null : clause[3]);
6045         });
6046 
6047         assert Stream.of(init, step, pred, fini).map(List::size).distinct().count() == 1;
6048         final int nclauses = init.size();
6049 
6050         // Step 1A: determine iteration variables (V...).
6051         final List&lt;Class&lt;?&gt;&gt; iterationVariableTypes = new ArrayList&lt;&gt;();
6052         for (int i = 0; i &lt; nclauses; ++i) {
6053             MethodHandle in = init.get(i);
6054             MethodHandle st = step.get(i);
6055             if (in == null &amp;&amp; st == null) {
6056                 iterationVariableTypes.add(void.class);
6057             } else if (in != null &amp;&amp; st != null) {
6058                 loopChecks1a(i, in, st);
6059                 iterationVariableTypes.add(in.type().returnType());
6060             } else {
6061                 iterationVariableTypes.add(in == null ? st.type().returnType() : in.type().returnType());
6062             }
6063         }
6064         final List&lt;Class&lt;?&gt;&gt; commonPrefix = iterationVariableTypes.stream().filter(t -&gt; t != void.class).
6065                 collect(Collectors.toList());
6066 
6067         // Step 1B: determine loop parameters (A...).
6068         final List&lt;Class&lt;?&gt;&gt; commonSuffix = buildCommonSuffix(init, step, pred, fini, commonPrefix.size());
6069         loopChecks1b(init, commonSuffix);
6070 
6071         // Step 1C: determine loop return type.
6072         // Step 1D: check other types.
6073         // local variable required here; see JDK-8223553
6074         Stream&lt;Class&lt;?&gt;&gt; cstream = fini.stream().filter(Objects::nonNull).map(MethodHandle::type)
6075                 .map(MethodType::returnType);
6076         final Class&lt;?&gt; loopReturnType = cstream.findFirst().orElse(void.class);
6077         loopChecks1cd(pred, fini, loopReturnType);
6078 
6079         // Step 2: determine parameter lists.
6080         final List&lt;Class&lt;?&gt;&gt; commonParameterSequence = new ArrayList&lt;&gt;(commonPrefix);
6081         commonParameterSequence.addAll(commonSuffix);
6082         loopChecks2(step, pred, fini, commonParameterSequence);
6083 
6084         // Step 3: fill in omitted functions.
6085         for (int i = 0; i &lt; nclauses; ++i) {
6086             Class&lt;?&gt; t = iterationVariableTypes.get(i);
6087             if (init.get(i) == null) {
6088                 init.set(i, empty(methodType(t, commonSuffix)));
6089             }
6090             if (step.get(i) == null) {
6091                 step.set(i, dropArgumentsToMatch(identityOrVoid(t), 0, commonParameterSequence, i));
6092             }
6093             if (pred.get(i) == null) {
6094                 pred.set(i, dropArguments0(constant(boolean.class, true), 0, commonParameterSequence));
6095             }
6096             if (fini.get(i) == null) {
6097                 fini.set(i, empty(methodType(t, commonParameterSequence)));
6098             }
6099         }
6100 
6101         // Step 4: fill in missing parameter types.
6102         // Also convert all handles to fixed-arity handles.
6103         List&lt;MethodHandle&gt; finit = fixArities(fillParameterTypes(init, commonSuffix));
6104         List&lt;MethodHandle&gt; fstep = fixArities(fillParameterTypes(step, commonParameterSequence));
6105         List&lt;MethodHandle&gt; fpred = fixArities(fillParameterTypes(pred, commonParameterSequence));
6106         List&lt;MethodHandle&gt; ffini = fixArities(fillParameterTypes(fini, commonParameterSequence));
6107 
6108         assert finit.stream().map(MethodHandle::type).map(MethodType::parameterList).
6109                 allMatch(pl -&gt; pl.equals(commonSuffix));
6110         assert Stream.of(fstep, fpred, ffini).flatMap(List::stream).map(MethodHandle::type).map(MethodType::parameterList).
6111                 allMatch(pl -&gt; pl.equals(commonParameterSequence));
6112 
6113         return MethodHandleImpl.makeLoop(loopReturnType, commonSuffix, finit, fstep, fpred, ffini);
6114     }
6115 
6116     private static void loopChecks0(MethodHandle[][] clauses) {
6117         if (clauses == null || clauses.length == 0) {
6118             throw newIllegalArgumentException(&quot;null or no clauses passed&quot;);
6119         }
6120         if (Stream.of(clauses).anyMatch(Objects::isNull)) {
6121             throw newIllegalArgumentException(&quot;null clauses are not allowed&quot;);
6122         }
6123         if (Stream.of(clauses).anyMatch(c -&gt; c.length &gt; 4)) {
6124             throw newIllegalArgumentException(&quot;All loop clauses must be represented as MethodHandle arrays with at most 4 elements.&quot;);
6125         }
6126     }
6127 
6128     private static void loopChecks1a(int i, MethodHandle in, MethodHandle st) {
6129         if (in.type().returnType() != st.type().returnType()) {
6130             throw misMatchedTypes(&quot;clause &quot; + i + &quot;: init and step return types&quot;, in.type().returnType(),
6131                     st.type().returnType());
6132         }
6133     }
6134 
6135     private static List&lt;Class&lt;?&gt;&gt; longestParameterList(Stream&lt;MethodHandle&gt; mhs, int skipSize) {
6136         final List&lt;Class&lt;?&gt;&gt; empty = List.of();
6137         final List&lt;Class&lt;?&gt;&gt; longest = mhs.filter(Objects::nonNull).
6138                 // take only those that can contribute to a common suffix because they are longer than the prefix
6139                         map(MethodHandle::type).
6140                         filter(t -&gt; t.parameterCount() &gt; skipSize).
6141                         map(MethodType::parameterList).
6142                         reduce((p, q) -&gt; p.size() &gt;= q.size() ? p : q).orElse(empty);
6143         return longest.size() == 0 ? empty : longest.subList(skipSize, longest.size());
6144     }
6145 
6146     private static List&lt;Class&lt;?&gt;&gt; longestParameterList(List&lt;List&lt;Class&lt;?&gt;&gt;&gt; lists) {
6147         final List&lt;Class&lt;?&gt;&gt; empty = List.of();
6148         return lists.stream().reduce((p, q) -&gt; p.size() &gt;= q.size() ? p : q).orElse(empty);
6149     }
6150 
6151     private static List&lt;Class&lt;?&gt;&gt; buildCommonSuffix(List&lt;MethodHandle&gt; init, List&lt;MethodHandle&gt; step, List&lt;MethodHandle&gt; pred, List&lt;MethodHandle&gt; fini, int cpSize) {
6152         final List&lt;Class&lt;?&gt;&gt; longest1 = longestParameterList(Stream.of(step, pred, fini).flatMap(List::stream), cpSize);
6153         final List&lt;Class&lt;?&gt;&gt; longest2 = longestParameterList(init.stream(), 0);
6154         return longestParameterList(Arrays.asList(longest1, longest2));
6155     }
6156 
6157     private static void loopChecks1b(List&lt;MethodHandle&gt; init, List&lt;Class&lt;?&gt;&gt; commonSuffix) {
6158         if (init.stream().filter(Objects::nonNull).map(MethodHandle::type).
6159                 anyMatch(t -&gt; !t.effectivelyIdenticalParameters(0, commonSuffix))) {
6160             throw newIllegalArgumentException(&quot;found non-effectively identical init parameter type lists: &quot; + init +
6161                     &quot; (common suffix: &quot; + commonSuffix + &quot;)&quot;);
6162         }
6163     }
6164 
6165     private static void loopChecks1cd(List&lt;MethodHandle&gt; pred, List&lt;MethodHandle&gt; fini, Class&lt;?&gt; loopReturnType) {
6166         if (fini.stream().filter(Objects::nonNull).map(MethodHandle::type).map(MethodType::returnType).
6167                 anyMatch(t -&gt; t != loopReturnType)) {
6168             throw newIllegalArgumentException(&quot;found non-identical finalizer return types: &quot; + fini + &quot; (return type: &quot; +
6169                     loopReturnType + &quot;)&quot;);
6170         }
6171 
6172         if (!pred.stream().filter(Objects::nonNull).findFirst().isPresent()) {
6173             throw newIllegalArgumentException(&quot;no predicate found&quot;, pred);
6174         }
6175         if (pred.stream().filter(Objects::nonNull).map(MethodHandle::type).map(MethodType::returnType).
6176                 anyMatch(t -&gt; t != boolean.class)) {
6177             throw newIllegalArgumentException(&quot;predicates must have boolean return type&quot;, pred);
6178         }
6179     }
6180 
6181     private static void loopChecks2(List&lt;MethodHandle&gt; step, List&lt;MethodHandle&gt; pred, List&lt;MethodHandle&gt; fini, List&lt;Class&lt;?&gt;&gt; commonParameterSequence) {
6182         if (Stream.of(step, pred, fini).flatMap(List::stream).filter(Objects::nonNull).map(MethodHandle::type).
6183                 anyMatch(t -&gt; !t.effectivelyIdenticalParameters(0, commonParameterSequence))) {
6184             throw newIllegalArgumentException(&quot;found non-effectively identical parameter type lists:\nstep: &quot; + step +
6185                     &quot;\npred: &quot; + pred + &quot;\nfini: &quot; + fini + &quot; (common parameter sequence: &quot; + commonParameterSequence + &quot;)&quot;);
6186         }
6187     }
6188 
6189     private static List&lt;MethodHandle&gt; fillParameterTypes(List&lt;MethodHandle&gt; hs, final List&lt;Class&lt;?&gt;&gt; targetParams) {
6190         return hs.stream().map(h -&gt; {
6191             int pc = h.type().parameterCount();
6192             int tpsize = targetParams.size();
6193             return pc &lt; tpsize ? dropArguments0(h, pc, targetParams.subList(pc, tpsize)) : h;
6194         }).collect(Collectors.toList());
6195     }
6196 
6197     private static List&lt;MethodHandle&gt; fixArities(List&lt;MethodHandle&gt; hs) {
6198         return hs.stream().map(MethodHandle::asFixedArity).collect(Collectors.toList());
6199     }
6200 
6201     /**
6202      * Constructs a {@code while} loop from an initializer, a body, and a predicate.
6203      * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
6204      * &lt;p&gt;
6205      * The {@code pred} handle describes the loop condition; and {@code body}, its body. The loop resulting from this
6206      * method will, in each iteration, first evaluate the predicate and then execute its body (if the predicate
6207      * evaluates to {@code true}).
6208      * The loop will terminate once the predicate evaluates to {@code false} (the body will not be executed in this case).
6209      * &lt;p&gt;
6210      * The {@code init} handle describes the initial value of an additional optional loop-local variable.
6211      * In each iteration, this loop-local variable, if present, will be passed to the {@code body}
6212      * and updated with the value returned from its invocation. The result of loop execution will be
6213      * the final value of the additional loop-local variable (if present).
6214      * &lt;p&gt;
6215      * The following rules hold for these argument handles:&lt;ul&gt;
6216      * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
6217      * {@code (V A...)V}, where {@code V} is non-{@code void}, or else {@code (A...)void}.
6218      * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
6219      * and we will write {@code (V A...)V} with the understanding that a {@code void} type {@code V}
6220      * is quietly dropped from the parameter list, leaving {@code (A...)V}.)
6221      * &lt;li&gt;The parameter list {@code (V A...)} of the body is called the &lt;em&gt;internal parameter list&lt;/em&gt;.
6222      * It will constrain the parameter lists of the other loop parts.
6223      * &lt;li&gt;If the iteration variable type {@code V} is dropped from the internal parameter list, the resulting shorter
6224      * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
6225      * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
6226      * additional state variable of the loop.
6227      * The body must both accept and return a value of this type {@code V}.
6228      * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
6229      * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
6230      * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
6231      * to the external parameter list {@code (A...)}.
6232      * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
6233      * {@linkplain #empty default value}.
6234      * &lt;li&gt;The {@code pred} handle must not be {@code null}.  It must have {@code boolean} as its return type.
6235      * Its parameter list (either empty or of the form {@code (V A*)}) must be
6236      * effectively identical to the internal parameter list.
6237      * &lt;/ul&gt;
6238      * &lt;p&gt;
6239      * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
6240      * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
6241      * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
6242      * from the external parameter list.
6243      * &lt;/ul&gt;
6244      * &lt;p&gt;
6245      * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
6246      * the sole loop variable as well as the result type of the loop; and {@code A}/{@code a}, that of the argument
6247      * passed to the loop.
6248      * &lt;blockquote&gt;&lt;pre&gt;{@code
6249      * V init(A...);
6250      * boolean pred(V, A...);
6251      * V body(V, A...);
6252      * V whileLoop(A... a...) {
6253      *   V v = init(a...);
6254      *   while (pred(v, a...)) {
6255      *     v = body(v, a...);
6256      *   }
6257      *   return v;
6258      * }
6259      * }&lt;/pre&gt;&lt;/blockquote&gt;
6260      *
6261      * @apiNote Example:
6262      * &lt;blockquote&gt;&lt;pre&gt;{@code
6263      * // implement the zip function for lists as a loop handle
6264      * static List&lt;String&gt; initZip(Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) { return new ArrayList&lt;&gt;(); }
6265      * static boolean zipPred(List&lt;String&gt; zip, Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) { return a.hasNext() &amp;&amp; b.hasNext(); }
6266      * static List&lt;String&gt; zipStep(List&lt;String&gt; zip, Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) {
6267      *   zip.add(a.next());
6268      *   zip.add(b.next());
6269      *   return zip;
6270      * }
6271      * // assume MH_initZip, MH_zipPred, and MH_zipStep are handles to the above methods
6272      * MethodHandle loop = MethodHandles.whileLoop(MH_initZip, MH_zipPred, MH_zipStep);
6273      * List&lt;String&gt; a = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
6274      * List&lt;String&gt; b = Arrays.asList(&quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;);
6275      * List&lt;String&gt; zipped = Arrays.asList(&quot;a&quot;, &quot;e&quot;, &quot;b&quot;, &quot;f&quot;, &quot;c&quot;, &quot;g&quot;, &quot;d&quot;, &quot;h&quot;);
6276      * assertEquals(zipped, (List&lt;String&gt;) loop.invoke(a.iterator(), b.iterator()));
6277      * }&lt;/pre&gt;&lt;/blockquote&gt;
6278      *
6279      *
6280      * @apiNote The implementation of this method can be expressed as follows:
6281      * &lt;blockquote&gt;&lt;pre&gt;{@code
6282      * MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body) {
6283      *     MethodHandle fini = (body.type().returnType() == void.class
6284      *                         ? null : identity(body.type().returnType()));
6285      *     MethodHandle[]
6286      *         checkExit = { null, null, pred, fini },
6287      *         varBody   = { init, body };
6288      *     return loop(checkExit, varBody);
6289      * }
6290      * }&lt;/pre&gt;&lt;/blockquote&gt;
6291      *
6292      * @param init optional initializer, providing the initial value of the loop variable.
6293      *             May be {@code null}, implying a default initial value.  See above for other constraints.
6294      * @param pred condition for the loop, which may not be {@code null}. Its result type must be {@code boolean}. See
6295      *             above for other constraints.
6296      * @param body body of the loop, which may not be {@code null}. It controls the loop parameters and result type.
6297      *             See above for other constraints.
6298      *
6299      * @return a method handle implementing the {@code while} loop as described by the arguments.
6300      * @throws IllegalArgumentException if the rules for the arguments are violated.
6301      * @throws NullPointerException if {@code pred} or {@code body} are {@code null}.
6302      *
6303      * @see #loop(MethodHandle[][])
6304      * @see #doWhileLoop(MethodHandle, MethodHandle, MethodHandle)
6305      * @since 9
6306      */
6307     public static MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body) {
6308         whileLoopChecks(init, pred, body);
6309         MethodHandle fini = identityOrVoid(body.type().returnType());
6310         MethodHandle[] checkExit = { null, null, pred, fini };
6311         MethodHandle[] varBody = { init, body };
6312         return loop(checkExit, varBody);
6313     }
6314 
6315     /**
6316      * Constructs a {@code do-while} loop from an initializer, a body, and a predicate.
6317      * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
6318      * &lt;p&gt;
6319      * The {@code pred} handle describes the loop condition; and {@code body}, its body. The loop resulting from this
6320      * method will, in each iteration, first execute its body and then evaluate the predicate.
6321      * The loop will terminate once the predicate evaluates to {@code false} after an execution of the body.
6322      * &lt;p&gt;
6323      * The {@code init} handle describes the initial value of an additional optional loop-local variable.
6324      * In each iteration, this loop-local variable, if present, will be passed to the {@code body}
6325      * and updated with the value returned from its invocation. The result of loop execution will be
6326      * the final value of the additional loop-local variable (if present).
6327      * &lt;p&gt;
6328      * The following rules hold for these argument handles:&lt;ul&gt;
6329      * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
6330      * {@code (V A...)V}, where {@code V} is non-{@code void}, or else {@code (A...)void}.
6331      * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
6332      * and we will write {@code (V A...)V} with the understanding that a {@code void} type {@code V}
6333      * is quietly dropped from the parameter list, leaving {@code (A...)V}.)
6334      * &lt;li&gt;The parameter list {@code (V A...)} of the body is called the &lt;em&gt;internal parameter list&lt;/em&gt;.
6335      * It will constrain the parameter lists of the other loop parts.
6336      * &lt;li&gt;If the iteration variable type {@code V} is dropped from the internal parameter list, the resulting shorter
6337      * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
6338      * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
6339      * additional state variable of the loop.
6340      * The body must both accept and return a value of this type {@code V}.
6341      * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
6342      * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
6343      * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
6344      * to the external parameter list {@code (A...)}.
6345      * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
6346      * {@linkplain #empty default value}.
6347      * &lt;li&gt;The {@code pred} handle must not be {@code null}.  It must have {@code boolean} as its return type.
6348      * Its parameter list (either empty or of the form {@code (V A*)}) must be
6349      * effectively identical to the internal parameter list.
6350      * &lt;/ul&gt;
6351      * &lt;p&gt;
6352      * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
6353      * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
6354      * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
6355      * from the external parameter list.
6356      * &lt;/ul&gt;
6357      * &lt;p&gt;
6358      * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
6359      * the sole loop variable as well as the result type of the loop; and {@code A}/{@code a}, that of the argument
6360      * passed to the loop.
6361      * &lt;blockquote&gt;&lt;pre&gt;{@code
6362      * V init(A...);
6363      * boolean pred(V, A...);
6364      * V body(V, A...);
6365      * V doWhileLoop(A... a...) {
6366      *   V v = init(a...);
6367      *   do {
6368      *     v = body(v, a...);
6369      *   } while (pred(v, a...));
6370      *   return v;
6371      * }
6372      * }&lt;/pre&gt;&lt;/blockquote&gt;
6373      *
6374      * @apiNote Example:
6375      * &lt;blockquote&gt;&lt;pre&gt;{@code
6376      * // int i = 0; while (i &lt; limit) { ++i; } return i; =&gt; limit
6377      * static int zero(int limit) { return 0; }
6378      * static int step(int i, int limit) { return i + 1; }
6379      * static boolean pred(int i, int limit) { return i &lt; limit; }
6380      * // assume MH_zero, MH_step, and MH_pred are handles to the above methods
6381      * MethodHandle loop = MethodHandles.doWhileLoop(MH_zero, MH_step, MH_pred);
6382      * assertEquals(23, loop.invoke(23));
6383      * }&lt;/pre&gt;&lt;/blockquote&gt;
6384      *
6385      *
6386      * @apiNote The implementation of this method can be expressed as follows:
6387      * &lt;blockquote&gt;&lt;pre&gt;{@code
6388      * MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred) {
6389      *     MethodHandle fini = (body.type().returnType() == void.class
6390      *                         ? null : identity(body.type().returnType()));
6391      *     MethodHandle[] clause = { init, body, pred, fini };
6392      *     return loop(clause);
6393      * }
6394      * }&lt;/pre&gt;&lt;/blockquote&gt;
6395      *
6396      * @param init optional initializer, providing the initial value of the loop variable.
6397      *             May be {@code null}, implying a default initial value.  See above for other constraints.
6398      * @param body body of the loop, which may not be {@code null}. It controls the loop parameters and result type.
6399      *             See above for other constraints.
6400      * @param pred condition for the loop, which may not be {@code null}. Its result type must be {@code boolean}. See
6401      *             above for other constraints.
6402      *
6403      * @return a method handle implementing the {@code while} loop as described by the arguments.
6404      * @throws IllegalArgumentException if the rules for the arguments are violated.
6405      * @throws NullPointerException if {@code pred} or {@code body} are {@code null}.
6406      *
6407      * @see #loop(MethodHandle[][])
6408      * @see #whileLoop(MethodHandle, MethodHandle, MethodHandle)
6409      * @since 9
6410      */
6411     public static MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred) {
6412         whileLoopChecks(init, pred, body);
6413         MethodHandle fini = identityOrVoid(body.type().returnType());
6414         MethodHandle[] clause = {init, body, pred, fini };
6415         return loop(clause);
6416     }
6417 
6418     private static void whileLoopChecks(MethodHandle init, MethodHandle pred, MethodHandle body) {
6419         Objects.requireNonNull(pred);
6420         Objects.requireNonNull(body);
6421         MethodType bodyType = body.type();
6422         Class&lt;?&gt; returnType = bodyType.returnType();
6423         List&lt;Class&lt;?&gt;&gt; innerList = bodyType.parameterList();
6424         List&lt;Class&lt;?&gt;&gt; outerList = innerList;
6425         if (returnType == void.class) {
6426             // OK
6427         } else if (innerList.size() == 0 || innerList.get(0) != returnType) {
6428             // leading V argument missing =&gt; error
6429             MethodType expected = bodyType.insertParameterTypes(0, returnType);
6430             throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
6431         } else {
6432             outerList = innerList.subList(1, innerList.size());
6433         }
6434         MethodType predType = pred.type();
6435         if (predType.returnType() != boolean.class ||
6436                 !predType.effectivelyIdenticalParameters(0, innerList)) {
6437             throw misMatchedTypes(&quot;loop predicate&quot;, predType, methodType(boolean.class, innerList));
6438         }
6439         if (init != null) {
6440             MethodType initType = init.type();
6441             if (initType.returnType() != returnType ||
6442                     !initType.effectivelyIdenticalParameters(0, outerList)) {
6443                 throw misMatchedTypes(&quot;loop initializer&quot;, initType, methodType(returnType, outerList));
6444             }
6445         }
6446     }
6447 
6448     /**
6449      * Constructs a loop that runs a given number of iterations.
6450      * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
6451      * &lt;p&gt;
6452      * The number of iterations is determined by the {@code iterations} handle evaluation result.
6453      * The loop counter {@code i} is an extra loop iteration variable of type {@code int}.
6454      * It will be initialized to 0 and incremented by 1 in each iteration.
6455      * &lt;p&gt;
6456      * If the {@code body} handle returns a non-{@code void} type {@code V}, a leading loop iteration variable
6457      * of that type is also present.  This variable is initialized using the optional {@code init} handle,
6458      * or to the {@linkplain #empty default value} of type {@code V} if that handle is {@code null}.
6459      * &lt;p&gt;
6460      * In each iteration, the iteration variables are passed to an invocation of the {@code body} handle.
6461      * A non-{@code void} value returned from the body (of type {@code V}) updates the leading
6462      * iteration variable.
6463      * The result of the loop handle execution will be the final {@code V} value of that variable
6464      * (or {@code void} if there is no {@code V} variable).
6465      * &lt;p&gt;
6466      * The following rules hold for the argument handles:&lt;ul&gt;
6467      * &lt;li&gt;The {@code iterations} handle must not be {@code null}, and must return
6468      * the type {@code int}, referred to here as {@code I} in parameter type lists.
6469      * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
6470      * {@code (V I A...)V}, where {@code V} is non-{@code void}, or else {@code (I A...)void}.
6471      * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
6472      * and we will write {@code (V I A...)V} with the understanding that a {@code void} type {@code V}
6473      * is quietly dropped from the parameter list, leaving {@code (I A...)V}.)
6474      * &lt;li&gt;The parameter list {@code (V I A...)} of the body contributes to a list
6475      * of types called the &lt;em&gt;internal parameter list&lt;/em&gt;.
6476      * It will constrain the parameter lists of the other loop parts.
6477      * &lt;li&gt;As a special case, if the body contributes only {@code V} and {@code I} types,
6478      * with no additional {@code A} types, then the internal parameter list is extended by
6479      * the argument types {@code A...} of the {@code iterations} handle.
6480      * &lt;li&gt;If the iteration variable types {@code (V I)} are dropped from the internal parameter list, the resulting shorter
6481      * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
6482      * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
6483      * additional state variable of the loop.
6484      * The body must both accept a leading parameter and return a value of this type {@code V}.
6485      * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
6486      * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
6487      * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
6488      * to the external parameter list {@code (A...)}.
6489      * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
6490      * {@linkplain #empty default value}.
6491      * &lt;li&gt;The parameter list of {@code iterations} (of some form {@code (A*)}) must be
6492      * effectively identical to the external parameter list {@code (A...)}.
6493      * &lt;/ul&gt;
6494      * &lt;p&gt;
6495      * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
6496      * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
6497      * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
6498      * from the external parameter list.
6499      * &lt;/ul&gt;
6500      * &lt;p&gt;
6501      * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
6502      * the second loop variable as well as the result type of the loop; and {@code A...}/{@code a...} represent
6503      * arguments passed to the loop.
6504      * &lt;blockquote&gt;&lt;pre&gt;{@code
6505      * int iterations(A...);
6506      * V init(A...);
6507      * V body(V, int, A...);
6508      * V countedLoop(A... a...) {
6509      *   int end = iterations(a...);
6510      *   V v = init(a...);
6511      *   for (int i = 0; i &lt; end; ++i) {
6512      *     v = body(v, i, a...);
6513      *   }
6514      *   return v;
6515      * }
6516      * }&lt;/pre&gt;&lt;/blockquote&gt;
6517      *
6518      * @apiNote Example with a fully conformant body method:
6519      * &lt;blockquote&gt;&lt;pre&gt;{@code
6520      * // String s = &quot;Lambdaman!&quot;; for (int i = 0; i &lt; 13; ++i) { s = &quot;na &quot; + s; } return s;
6521      * // =&gt; a variation on a well known theme
6522      * static String step(String v, int counter, String init) { return &quot;na &quot; + v; }
6523      * // assume MH_step is a handle to the method above
6524      * MethodHandle fit13 = MethodHandles.constant(int.class, 13);
6525      * MethodHandle start = MethodHandles.identity(String.class);
6526      * MethodHandle loop = MethodHandles.countedLoop(fit13, start, MH_step);
6527      * assertEquals(&quot;na na na na na na na na na na na na na Lambdaman!&quot;, loop.invoke(&quot;Lambdaman!&quot;));
6528      * }&lt;/pre&gt;&lt;/blockquote&gt;
6529      *
6530      * @apiNote Example with the simplest possible body method type,
6531      * and passing the number of iterations to the loop invocation:
6532      * &lt;blockquote&gt;&lt;pre&gt;{@code
6533      * // String s = &quot;Lambdaman!&quot;; for (int i = 0; i &lt; 13; ++i) { s = &quot;na &quot; + s; } return s;
6534      * // =&gt; a variation on a well known theme
6535      * static String step(String v, int counter ) { return &quot;na &quot; + v; }
6536      * // assume MH_step is a handle to the method above
6537      * MethodHandle count = MethodHandles.dropArguments(MethodHandles.identity(int.class), 1, String.class);
6538      * MethodHandle start = MethodHandles.dropArguments(MethodHandles.identity(String.class), 0, int.class);
6539      * MethodHandle loop = MethodHandles.countedLoop(count, start, MH_step);  // (v, i) -&gt; &quot;na &quot; + v
6540      * assertEquals(&quot;na na na na na na na na na na na na na Lambdaman!&quot;, loop.invoke(13, &quot;Lambdaman!&quot;));
6541      * }&lt;/pre&gt;&lt;/blockquote&gt;
6542      *
6543      * @apiNote Example that treats the number of iterations, string to append to, and string to append
6544      * as loop parameters:
6545      * &lt;blockquote&gt;&lt;pre&gt;{@code
6546      * // String s = &quot;Lambdaman!&quot;, t = &quot;na&quot;; for (int i = 0; i &lt; 13; ++i) { s = t + &quot; &quot; + s; } return s;
6547      * // =&gt; a variation on a well known theme
6548      * static String step(String v, int counter, int iterations_, String pre, String start_) { return pre + &quot; &quot; + v; }
6549      * // assume MH_step is a handle to the method above
6550      * MethodHandle count = MethodHandles.identity(int.class);
6551      * MethodHandle start = MethodHandles.dropArguments(MethodHandles.identity(String.class), 0, int.class, String.class);
6552      * MethodHandle loop = MethodHandles.countedLoop(count, start, MH_step);  // (v, i, _, pre, _) -&gt; pre + &quot; &quot; + v
6553      * assertEquals(&quot;na na na na na na na na na na na na na Lambdaman!&quot;, loop.invoke(13, &quot;na&quot;, &quot;Lambdaman!&quot;));
6554      * }&lt;/pre&gt;&lt;/blockquote&gt;
6555      *
6556      * @apiNote Example that illustrates the usage of {@link #dropArgumentsToMatch(MethodHandle, int, List, int)}
6557      * to enforce a loop type:
6558      * &lt;blockquote&gt;&lt;pre&gt;{@code
6559      * // String s = &quot;Lambdaman!&quot;, t = &quot;na&quot;; for (int i = 0; i &lt; 13; ++i) { s = t + &quot; &quot; + s; } return s;
6560      * // =&gt; a variation on a well known theme
6561      * static String step(String v, int counter, String pre) { return pre + &quot; &quot; + v; }
6562      * // assume MH_step is a handle to the method above
6563      * MethodType loopType = methodType(String.class, String.class, int.class, String.class);
6564      * MethodHandle count = MethodHandles.dropArgumentsToMatch(MethodHandles.identity(int.class),    0, loopType.parameterList(), 1);
6565      * MethodHandle start = MethodHandles.dropArgumentsToMatch(MethodHandles.identity(String.class), 0, loopType.parameterList(), 2);
6566      * MethodHandle body  = MethodHandles.dropArgumentsToMatch(MH_step,                              2, loopType.parameterList(), 0);
6567      * MethodHandle loop = MethodHandles.countedLoop(count, start, body);  // (v, i, pre, _, _) -&gt; pre + &quot; &quot; + v
6568      * assertEquals(&quot;na na na na na na na na na na na na na Lambdaman!&quot;, loop.invoke(&quot;na&quot;, 13, &quot;Lambdaman!&quot;));
6569      * }&lt;/pre&gt;&lt;/blockquote&gt;
6570      *
6571      * @apiNote The implementation of this method can be expressed as follows:
6572      * &lt;blockquote&gt;&lt;pre&gt;{@code
6573      * MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body) {
6574      *     return countedLoop(empty(iterations.type()), iterations, init, body);
6575      * }
6576      * }&lt;/pre&gt;&lt;/blockquote&gt;
6577      *
6578      * @param iterations a non-{@code null} handle to return the number of iterations this loop should run. The handle&#39;s
6579      *                   result type must be {@code int}. See above for other constraints.
6580      * @param init optional initializer, providing the initial value of the loop variable.
6581      *             May be {@code null}, implying a default initial value.  See above for other constraints.
6582      * @param body body of the loop, which may not be {@code null}.
6583      *             It controls the loop parameters and result type in the standard case (see above for details).
6584      *             It must accept its own return type (if non-void) plus an {@code int} parameter (for the counter),
6585      *             and may accept any number of additional types.
6586      *             See above for other constraints.
6587      *
6588      * @return a method handle representing the loop.
6589      * @throws NullPointerException if either of the {@code iterations} or {@code body} handles is {@code null}.
6590      * @throws IllegalArgumentException if any argument violates the rules formulated above.
6591      *
6592      * @see #countedLoop(MethodHandle, MethodHandle, MethodHandle, MethodHandle)
6593      * @since 9
6594      */
6595     public static MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body) {
6596         return countedLoop(empty(iterations.type()), iterations, init, body);
6597     }
6598 
6599     /**
6600      * Constructs a loop that counts over a range of numbers.
6601      * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
6602      * &lt;p&gt;
6603      * The loop counter {@code i} is a loop iteration variable of type {@code int}.
6604      * The {@code start} and {@code end} handles determine the start (inclusive) and end (exclusive)
6605      * values of the loop counter.
6606      * The loop counter will be initialized to the {@code int} value returned from the evaluation of the
6607      * {@code start} handle and run to the value returned from {@code end} (exclusively) with a step width of 1.
6608      * &lt;p&gt;
6609      * If the {@code body} handle returns a non-{@code void} type {@code V}, a leading loop iteration variable
6610      * of that type is also present.  This variable is initialized using the optional {@code init} handle,
6611      * or to the {@linkplain #empty default value} of type {@code V} if that handle is {@code null}.
6612      * &lt;p&gt;
6613      * In each iteration, the iteration variables are passed to an invocation of the {@code body} handle.
6614      * A non-{@code void} value returned from the body (of type {@code V}) updates the leading
6615      * iteration variable.
6616      * The result of the loop handle execution will be the final {@code V} value of that variable
6617      * (or {@code void} if there is no {@code V} variable).
6618      * &lt;p&gt;
6619      * The following rules hold for the argument handles:&lt;ul&gt;
6620      * &lt;li&gt;The {@code start} and {@code end} handles must not be {@code null}, and must both return
6621      * the common type {@code int}, referred to here as {@code I} in parameter type lists.
6622      * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
6623      * {@code (V I A...)V}, where {@code V} is non-{@code void}, or else {@code (I A...)void}.
6624      * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
6625      * and we will write {@code (V I A...)V} with the understanding that a {@code void} type {@code V}
6626      * is quietly dropped from the parameter list, leaving {@code (I A...)V}.)
6627      * &lt;li&gt;The parameter list {@code (V I A...)} of the body contributes to a list
6628      * of types called the &lt;em&gt;internal parameter list&lt;/em&gt;.
6629      * It will constrain the parameter lists of the other loop parts.
6630      * &lt;li&gt;As a special case, if the body contributes only {@code V} and {@code I} types,
6631      * with no additional {@code A} types, then the internal parameter list is extended by
6632      * the argument types {@code A...} of the {@code end} handle.
6633      * &lt;li&gt;If the iteration variable types {@code (V I)} are dropped from the internal parameter list, the resulting shorter
6634      * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
6635      * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
6636      * additional state variable of the loop.
6637      * The body must both accept a leading parameter and return a value of this type {@code V}.
6638      * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
6639      * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
6640      * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
6641      * to the external parameter list {@code (A...)}.
6642      * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
6643      * {@linkplain #empty default value}.
6644      * &lt;li&gt;The parameter list of {@code start} (of some form {@code (A*)}) must be
6645      * effectively identical to the external parameter list {@code (A...)}.
6646      * &lt;li&gt;Likewise, the parameter list of {@code end} must be effectively identical
6647      * to the external parameter list.
6648      * &lt;/ul&gt;
6649      * &lt;p&gt;
6650      * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
6651      * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
6652      * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
6653      * from the external parameter list.
6654      * &lt;/ul&gt;
6655      * &lt;p&gt;
6656      * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
6657      * the second loop variable as well as the result type of the loop; and {@code A...}/{@code a...} represent
6658      * arguments passed to the loop.
6659      * &lt;blockquote&gt;&lt;pre&gt;{@code
6660      * int start(A...);
6661      * int end(A...);
6662      * V init(A...);
6663      * V body(V, int, A...);
6664      * V countedLoop(A... a...) {
6665      *   int e = end(a...);
6666      *   int s = start(a...);
6667      *   V v = init(a...);
6668      *   for (int i = s; i &lt; e; ++i) {
6669      *     v = body(v, i, a...);
6670      *   }
6671      *   return v;
6672      * }
6673      * }&lt;/pre&gt;&lt;/blockquote&gt;
6674      *
6675      * @apiNote The implementation of this method can be expressed as follows:
6676      * &lt;blockquote&gt;&lt;pre&gt;{@code
6677      * MethodHandle countedLoop(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {
6678      *     MethodHandle returnVar = dropArguments(identity(init.type().returnType()), 0, int.class, int.class);
6679      *     // assume MH_increment and MH_predicate are handles to implementation-internal methods with
6680      *     // the following semantics:
6681      *     // MH_increment: (int limit, int counter) -&gt; counter + 1
6682      *     // MH_predicate: (int limit, int counter) -&gt; counter &lt; limit
6683      *     Class&lt;?&gt; counterType = start.type().returnType();  // int
6684      *     Class&lt;?&gt; returnType = body.type().returnType();
6685      *     MethodHandle incr = MH_increment, pred = MH_predicate, retv = null;
6686      *     if (returnType != void.class) {  // ignore the V variable
6687      *         incr = dropArguments(incr, 1, returnType);  // (limit, v, i) =&gt; (limit, i)
6688      *         pred = dropArguments(pred, 1, returnType);  // ditto
6689      *         retv = dropArguments(identity(returnType), 0, counterType); // ignore limit
6690      *     }
6691      *     body = dropArguments(body, 0, counterType);  // ignore the limit variable
6692      *     MethodHandle[]
6693      *         loopLimit  = { end, null, pred, retv }, // limit = end(); i &lt; limit || return v
6694      *         bodyClause = { init, body },            // v = init(); v = body(v, i)
6695      *         indexVar   = { start, incr };           // i = start(); i = i + 1
6696      *     return loop(loopLimit, bodyClause, indexVar);
6697      * }
6698      * }&lt;/pre&gt;&lt;/blockquote&gt;
6699      *
6700      * @param start a non-{@code null} handle to return the start value of the loop counter, which must be {@code int}.
6701      *              See above for other constraints.
6702      * @param end a non-{@code null} handle to return the end value of the loop counter (the loop will run to
6703      *            {@code end-1}). The result type must be {@code int}. See above for other constraints.
6704      * @param init optional initializer, providing the initial value of the loop variable.
6705      *             May be {@code null}, implying a default initial value.  See above for other constraints.
6706      * @param body body of the loop, which may not be {@code null}.
6707      *             It controls the loop parameters and result type in the standard case (see above for details).
6708      *             It must accept its own return type (if non-void) plus an {@code int} parameter (for the counter),
6709      *             and may accept any number of additional types.
6710      *             See above for other constraints.
6711      *
6712      * @return a method handle representing the loop.
6713      * @throws NullPointerException if any of the {@code start}, {@code end}, or {@code body} handles is {@code null}.
6714      * @throws IllegalArgumentException if any argument violates the rules formulated above.
6715      *
6716      * @see #countedLoop(MethodHandle, MethodHandle, MethodHandle)
6717      * @since 9
6718      */
6719     public static MethodHandle countedLoop(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {
6720         countedLoopChecks(start, end, init, body);
6721         Class&lt;?&gt; counterType = start.type().returnType();  // int, but who&#39;s counting?
6722         Class&lt;?&gt; limitType   = end.type().returnType();    // yes, int again
6723         Class&lt;?&gt; returnType  = body.type().returnType();
6724         MethodHandle incr = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_countedLoopStep);
6725         MethodHandle pred = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_countedLoopPred);
6726         MethodHandle retv = null;
6727         if (returnType != void.class) {
6728             incr = dropArguments(incr, 1, returnType);  // (limit, v, i) =&gt; (limit, i)
6729             pred = dropArguments(pred, 1, returnType);  // ditto
6730             retv = dropArguments(identity(returnType), 0, counterType);
6731         }
6732         body = dropArguments(body, 0, counterType);  // ignore the limit variable
6733         MethodHandle[]
6734             loopLimit  = { end, null, pred, retv }, // limit = end(); i &lt; limit || return v
6735             bodyClause = { init, body },            // v = init(); v = body(v, i)
6736             indexVar   = { start, incr };           // i = start(); i = i + 1
6737         return loop(loopLimit, bodyClause, indexVar);
6738     }
6739 
6740     private static void countedLoopChecks(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {
6741         Objects.requireNonNull(start);
6742         Objects.requireNonNull(end);
6743         Objects.requireNonNull(body);
6744         Class&lt;?&gt; counterType = start.type().returnType();
6745         if (counterType != int.class) {
6746             MethodType expected = start.type().changeReturnType(int.class);
6747             throw misMatchedTypes(&quot;start function&quot;, start.type(), expected);
6748         } else if (end.type().returnType() != counterType) {
6749             MethodType expected = end.type().changeReturnType(counterType);
6750             throw misMatchedTypes(&quot;end function&quot;, end.type(), expected);
6751         }
6752         MethodType bodyType = body.type();
6753         Class&lt;?&gt; returnType = bodyType.returnType();
6754         List&lt;Class&lt;?&gt;&gt; innerList = bodyType.parameterList();
6755         // strip leading V value if present
6756         int vsize = (returnType == void.class ? 0 : 1);
6757         if (vsize != 0 &amp;&amp; (innerList.size() == 0 || innerList.get(0) != returnType)) {
6758             // argument list has no &quot;V&quot; =&gt; error
6759             MethodType expected = bodyType.insertParameterTypes(0, returnType);
6760             throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
6761         } else if (innerList.size() &lt;= vsize || innerList.get(vsize) != counterType) {
6762             // missing I type =&gt; error
6763             MethodType expected = bodyType.insertParameterTypes(vsize, counterType);
6764             throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
6765         }
6766         List&lt;Class&lt;?&gt;&gt; outerList = innerList.subList(vsize + 1, innerList.size());
6767         if (outerList.isEmpty()) {
6768             // special case; take lists from end handle
6769             outerList = end.type().parameterList();
6770             innerList = bodyType.insertParameterTypes(vsize + 1, outerList).parameterList();
6771         }
6772         MethodType expected = methodType(counterType, outerList);
6773         if (!start.type().effectivelyIdenticalParameters(0, outerList)) {
6774             throw misMatchedTypes(&quot;start parameter types&quot;, start.type(), expected);
6775         }
6776         if (end.type() != start.type() &amp;&amp;
6777             !end.type().effectivelyIdenticalParameters(0, outerList)) {
6778             throw misMatchedTypes(&quot;end parameter types&quot;, end.type(), expected);
6779         }
6780         if (init != null) {
6781             MethodType initType = init.type();
6782             if (initType.returnType() != returnType ||
6783                 !initType.effectivelyIdenticalParameters(0, outerList)) {
6784                 throw misMatchedTypes(&quot;loop initializer&quot;, initType, methodType(returnType, outerList));
6785             }
6786         }
6787     }
6788 
6789     /**
6790      * Constructs a loop that ranges over the values produced by an {@code Iterator&lt;T&gt;}.
6791      * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
6792      * &lt;p&gt;
6793      * The iterator itself will be determined by the evaluation of the {@code iterator} handle.
6794      * Each value it produces will be stored in a loop iteration variable of type {@code T}.
6795      * &lt;p&gt;
6796      * If the {@code body} handle returns a non-{@code void} type {@code V}, a leading loop iteration variable
6797      * of that type is also present.  This variable is initialized using the optional {@code init} handle,
6798      * or to the {@linkplain #empty default value} of type {@code V} if that handle is {@code null}.
6799      * &lt;p&gt;
6800      * In each iteration, the iteration variables are passed to an invocation of the {@code body} handle.
6801      * A non-{@code void} value returned from the body (of type {@code V}) updates the leading
6802      * iteration variable.
6803      * The result of the loop handle execution will be the final {@code V} value of that variable
6804      * (or {@code void} if there is no {@code V} variable).
6805      * &lt;p&gt;
6806      * The following rules hold for the argument handles:&lt;ul&gt;
6807      * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
6808      * {@code (V T A...)V}, where {@code V} is non-{@code void}, or else {@code (T A...)void}.
6809      * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
6810      * and we will write {@code (V T A...)V} with the understanding that a {@code void} type {@code V}
6811      * is quietly dropped from the parameter list, leaving {@code (T A...)V}.)
6812      * &lt;li&gt;The parameter list {@code (V T A...)} of the body contributes to a list
6813      * of types called the &lt;em&gt;internal parameter list&lt;/em&gt;.
6814      * It will constrain the parameter lists of the other loop parts.
6815      * &lt;li&gt;As a special case, if the body contributes only {@code V} and {@code T} types,
6816      * with no additional {@code A} types, then the internal parameter list is extended by
6817      * the argument types {@code A...} of the {@code iterator} handle; if it is {@code null} the
6818      * single type {@code Iterable} is added and constitutes the {@code A...} list.
6819      * &lt;li&gt;If the iteration variable types {@code (V T)} are dropped from the internal parameter list, the resulting shorter
6820      * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
6821      * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
6822      * additional state variable of the loop.
6823      * The body must both accept a leading parameter and return a value of this type {@code V}.
6824      * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
6825      * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
6826      * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
6827      * to the external parameter list {@code (A...)}.
6828      * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
6829      * {@linkplain #empty default value}.
6830      * &lt;li&gt;If the {@code iterator} handle is non-{@code null}, it must have the return
6831      * type {@code java.util.Iterator} or a subtype thereof.
6832      * The iterator it produces when the loop is executed will be assumed
6833      * to yield values which can be converted to type {@code T}.
6834      * &lt;li&gt;The parameter list of an {@code iterator} that is non-{@code null} (of some form {@code (A*)}) must be
6835      * effectively identical to the external parameter list {@code (A...)}.
6836      * &lt;li&gt;If {@code iterator} is {@code null} it defaults to a method handle which behaves
6837      * like {@link java.lang.Iterable#iterator()}.  In that case, the internal parameter list
6838      * {@code (V T A...)} must have at least one {@code A} type, and the default iterator
6839      * handle parameter is adjusted to accept the leading {@code A} type, as if by
6840      * the {@link MethodHandle#asType asType} conversion method.
6841      * The leading {@code A} type must be {@code Iterable} or a subtype thereof.
6842      * This conversion step, done at loop construction time, must not throw a {@code WrongMethodTypeException}.
6843      * &lt;/ul&gt;
6844      * &lt;p&gt;
6845      * The type {@code T} may be either a primitive or reference.
6846      * Since type {@code Iterator&lt;T&gt;} is erased in the method handle representation to the raw type {@code Iterator},
6847      * the {@code iteratedLoop} combinator adjusts the leading argument type for {@code body} to {@code Object}
6848      * as if by the {@link MethodHandle#asType asType} conversion method.
6849      * Therefore, if an iterator of the wrong type appears as the loop is executed, runtime exceptions may occur
6850      * as the result of dynamic conversions performed by {@link MethodHandle#asType(MethodType)}.
6851      * &lt;p&gt;
6852      * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
6853      * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
6854      * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
6855      * from the external parameter list.
6856      * &lt;/ul&gt;
6857      * &lt;p&gt;
6858      * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
6859      * the loop variable as well as the result type of the loop; {@code T}/{@code t}, that of the elements of the
6860      * structure the loop iterates over, and {@code A...}/{@code a...} represent arguments passed to the loop.
6861      * &lt;blockquote&gt;&lt;pre&gt;{@code
6862      * Iterator&lt;T&gt; iterator(A...);  // defaults to Iterable::iterator
6863      * V init(A...);
6864      * V body(V,T,A...);
6865      * V iteratedLoop(A... a...) {
6866      *   Iterator&lt;T&gt; it = iterator(a...);
6867      *   V v = init(a...);
6868      *   while (it.hasNext()) {
6869      *     T t = it.next();
6870      *     v = body(v, t, a...);
6871      *   }
6872      *   return v;
6873      * }
6874      * }&lt;/pre&gt;&lt;/blockquote&gt;
6875      *
6876      * @apiNote Example:
6877      * &lt;blockquote&gt;&lt;pre&gt;{@code
6878      * // get an iterator from a list
6879      * static List&lt;String&gt; reverseStep(List&lt;String&gt; r, String e) {
6880      *   r.add(0, e);
6881      *   return r;
6882      * }
6883      * static List&lt;String&gt; newArrayList() { return new ArrayList&lt;&gt;(); }
6884      * // assume MH_reverseStep and MH_newArrayList are handles to the above methods
6885      * MethodHandle loop = MethodHandles.iteratedLoop(null, MH_newArrayList, MH_reverseStep);
6886      * List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);
6887      * List&lt;String&gt; reversedList = Arrays.asList(&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;);
6888      * assertEquals(reversedList, (List&lt;String&gt;) loop.invoke(list));
6889      * }&lt;/pre&gt;&lt;/blockquote&gt;
6890      *
6891      * @apiNote The implementation of this method can be expressed approximately as follows:
6892      * &lt;blockquote&gt;&lt;pre&gt;{@code
6893      * MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body) {
6894      *     // assume MH_next, MH_hasNext, MH_startIter are handles to methods of Iterator/Iterable
6895      *     Class&lt;?&gt; returnType = body.type().returnType();
6896      *     Class&lt;?&gt; ttype = body.type().parameterType(returnType == void.class ? 0 : 1);
6897      *     MethodHandle nextVal = MH_next.asType(MH_next.type().changeReturnType(ttype));
6898      *     MethodHandle retv = null, step = body, startIter = iterator;
6899      *     if (returnType != void.class) {
6900      *         // the simple thing first:  in (I V A...), drop the I to get V
6901      *         retv = dropArguments(identity(returnType), 0, Iterator.class);
6902      *         // body type signature (V T A...), internal loop types (I V A...)
6903      *         step = swapArguments(body, 0, 1);  // swap V &lt;-&gt; T
6904      *     }
6905      *     if (startIter == null)  startIter = MH_getIter;
6906      *     MethodHandle[]
6907      *         iterVar    = { startIter, null, MH_hasNext, retv }, // it = iterator; while (it.hasNext())
6908      *         bodyClause = { init, filterArguments(step, 0, nextVal) };  // v = body(v, t, a)
6909      *     return loop(iterVar, bodyClause);
6910      * }
6911      * }&lt;/pre&gt;&lt;/blockquote&gt;
6912      *
6913      * @param iterator an optional handle to return the iterator to start the loop.
6914      *                 If non-{@code null}, the handle must return {@link java.util.Iterator} or a subtype.
6915      *                 See above for other constraints.
6916      * @param init optional initializer, providing the initial value of the loop variable.
6917      *             May be {@code null}, implying a default initial value.  See above for other constraints.
6918      * @param body body of the loop, which may not be {@code null}.
6919      *             It controls the loop parameters and result type in the standard case (see above for details).
6920      *             It must accept its own return type (if non-void) plus a {@code T} parameter (for the iterated values),
6921      *             and may accept any number of additional types.
6922      *             See above for other constraints.
6923      *
6924      * @return a method handle embodying the iteration loop functionality.
6925      * @throws NullPointerException if the {@code body} handle is {@code null}.
6926      * @throws IllegalArgumentException if any argument violates the above requirements.
6927      *
6928      * @since 9
6929      */
6930     public static MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body) {
6931         Class&lt;?&gt; iterableType = iteratedLoopChecks(iterator, init, body);
6932         Class&lt;?&gt; returnType = body.type().returnType();
6933         MethodHandle hasNext = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_iteratePred);
6934         MethodHandle nextRaw = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_iterateNext);
6935         MethodHandle startIter;
6936         MethodHandle nextVal;
6937         {
6938             MethodType iteratorType;
6939             if (iterator == null) {
6940                 // derive argument type from body, if available, else use Iterable
6941                 startIter = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_initIterator);
6942                 iteratorType = startIter.type().changeParameterType(0, iterableType);
6943             } else {
6944                 // force return type to the internal iterator class
6945                 iteratorType = iterator.type().changeReturnType(Iterator.class);
6946                 startIter = iterator;
6947             }
6948             Class&lt;?&gt; ttype = body.type().parameterType(returnType == void.class ? 0 : 1);
6949             MethodType nextValType = nextRaw.type().changeReturnType(ttype);
6950 
6951             // perform the asType transforms under an exception transformer, as per spec.:
6952             try {
6953                 startIter = startIter.asType(iteratorType);
6954                 nextVal = nextRaw.asType(nextValType);
6955             } catch (WrongMethodTypeException ex) {
6956                 throw new IllegalArgumentException(ex);
6957             }
6958         }
6959 
6960         MethodHandle retv = null, step = body;
6961         if (returnType != void.class) {
6962             // the simple thing first:  in (I V A...), drop the I to get V
6963             retv = dropArguments(identity(returnType), 0, Iterator.class);
6964             // body type signature (V T A...), internal loop types (I V A...)
6965             step = swapArguments(body, 0, 1);  // swap V &lt;-&gt; T
6966         }
6967 
6968         MethodHandle[]
6969             iterVar    = { startIter, null, hasNext, retv },
6970             bodyClause = { init, filterArgument(step, 0, nextVal) };
6971         return loop(iterVar, bodyClause);
6972     }
6973 
6974     private static Class&lt;?&gt; iteratedLoopChecks(MethodHandle iterator, MethodHandle init, MethodHandle body) {
6975         Objects.requireNonNull(body);
6976         MethodType bodyType = body.type();
6977         Class&lt;?&gt; returnType = bodyType.returnType();
6978         List&lt;Class&lt;?&gt;&gt; internalParamList = bodyType.parameterList();
6979         // strip leading V value if present
6980         int vsize = (returnType == void.class ? 0 : 1);
6981         if (vsize != 0 &amp;&amp; (internalParamList.size() == 0 || internalParamList.get(0) != returnType)) {
6982             // argument list has no &quot;V&quot; =&gt; error
6983             MethodType expected = bodyType.insertParameterTypes(0, returnType);
6984             throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
6985         } else if (internalParamList.size() &lt;= vsize) {
6986             // missing T type =&gt; error
6987             MethodType expected = bodyType.insertParameterTypes(vsize, Object.class);
6988             throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
6989         }
6990         List&lt;Class&lt;?&gt;&gt; externalParamList = internalParamList.subList(vsize + 1, internalParamList.size());
6991         Class&lt;?&gt; iterableType = null;
6992         if (iterator != null) {
6993             // special case; if the body handle only declares V and T then
6994             // the external parameter list is obtained from iterator handle
6995             if (externalParamList.isEmpty()) {
6996                 externalParamList = iterator.type().parameterList();
6997             }
6998             MethodType itype = iterator.type();
6999             if (!Iterator.class.isAssignableFrom(itype.returnType())) {
7000                 throw newIllegalArgumentException(&quot;iteratedLoop first argument must have Iterator return type&quot;);
7001             }
7002             if (!itype.effectivelyIdenticalParameters(0, externalParamList)) {
7003                 MethodType expected = methodType(itype.returnType(), externalParamList);
7004                 throw misMatchedTypes(&quot;iterator parameters&quot;, itype, expected);
7005             }
7006         } else {
7007             if (externalParamList.isEmpty()) {
7008                 // special case; if the iterator handle is null and the body handle
7009                 // only declares V and T then the external parameter list consists
7010                 // of Iterable
7011                 externalParamList = Arrays.asList(Iterable.class);
7012                 iterableType = Iterable.class;
7013             } else {
7014                 // special case; if the iterator handle is null and the external
7015                 // parameter list is not empty then the first parameter must be
7016                 // assignable to Iterable
7017                 iterableType = externalParamList.get(0);
7018                 if (!Iterable.class.isAssignableFrom(iterableType)) {
7019                     throw newIllegalArgumentException(
7020                             &quot;inferred first loop argument must inherit from Iterable: &quot; + iterableType);
7021                 }
7022             }
7023         }
7024         if (init != null) {
7025             MethodType initType = init.type();
7026             if (initType.returnType() != returnType ||
7027                     !initType.effectivelyIdenticalParameters(0, externalParamList)) {
7028                 throw misMatchedTypes(&quot;loop initializer&quot;, initType, methodType(returnType, externalParamList));
7029             }
7030         }
7031         return iterableType;  // help the caller a bit
7032     }
7033 
7034     /*non-public*/
7035     static MethodHandle swapArguments(MethodHandle mh, int i, int j) {
7036         // there should be a better way to uncross my wires
7037         int arity = mh.type().parameterCount();
7038         int[] order = new int[arity];
7039         for (int k = 0; k &lt; arity; k++)  order[k] = k;
7040         order[i] = j; order[j] = i;
7041         Class&lt;?&gt;[] types = mh.type().parameterArray();
7042         Class&lt;?&gt; ti = types[i]; types[i] = types[j]; types[j] = ti;
7043         MethodType swapType = methodType(mh.type().returnType(), types);
7044         return permuteArguments(mh, swapType, order);
7045     }
7046 
7047     /**
7048      * Makes a method handle that adapts a {@code target} method handle by wrapping it in a {@code try-finally} block.
7049      * Another method handle, {@code cleanup}, represents the functionality of the {@code finally} block. Any exception
7050      * thrown during the execution of the {@code target} handle will be passed to the {@code cleanup} handle. The
7051      * exception will be rethrown, unless {@code cleanup} handle throws an exception first.  The
7052      * value returned from the {@code cleanup} handle&#39;s execution will be the result of the execution of the
7053      * {@code try-finally} handle.
7054      * &lt;p&gt;
7055      * The {@code cleanup} handle will be passed one or two additional leading arguments.
7056      * The first is the exception thrown during the
7057      * execution of the {@code target} handle, or {@code null} if no exception was thrown.
7058      * The second is the result of the execution of the {@code target} handle, or, if it throws an exception,
7059      * a {@code null}, zero, or {@code false} value of the required type is supplied as a placeholder.
7060      * The second argument is not present if the {@code target} handle has a {@code void} return type.
7061      * (Note that, except for argument type conversions, combinators represent {@code void} values in parameter lists
7062      * by omitting the corresponding paradoxical arguments, not by inserting {@code null} or zero values.)
7063      * &lt;p&gt;
7064      * The {@code target} and {@code cleanup} handles must have the same corresponding argument and return types, except
7065      * that the {@code cleanup} handle may omit trailing arguments. Also, the {@code cleanup} handle must have one or
7066      * two extra leading parameters:&lt;ul&gt;
7067      * &lt;li&gt;a {@code Throwable}, which will carry the exception thrown by the {@code target} handle (if any); and
7068      * &lt;li&gt;a parameter of the same type as the return type of both {@code target} and {@code cleanup}, which will carry
7069      * the result from the execution of the {@code target} handle.
7070      * This parameter is not present if the {@code target} returns {@code void}.
7071      * &lt;/ul&gt;
7072      * &lt;p&gt;
7073      * The pseudocode for the resulting adapter looks as follows. In the code, {@code V} represents the result type of
7074      * the {@code try/finally} construct; {@code A}/{@code a}, the types and values of arguments to the resulting
7075      * handle consumed by the cleanup; and {@code B}/{@code b}, those of arguments to the resulting handle discarded by
7076      * the cleanup.
7077      * &lt;blockquote&gt;&lt;pre&gt;{@code
7078      * V target(A..., B...);
7079      * V cleanup(Throwable, V, A...);
7080      * V adapter(A... a, B... b) {
7081      *   V result = (zero value for V);
7082      *   Throwable throwable = null;
7083      *   try {
7084      *     result = target(a..., b...);
7085      *   } catch (Throwable t) {
7086      *     throwable = t;
7087      *     throw t;
7088      *   } finally {
7089      *     result = cleanup(throwable, result, a...);
7090      *   }
7091      *   return result;
7092      * }
7093      * }&lt;/pre&gt;&lt;/blockquote&gt;
7094      * &lt;p&gt;
7095      * Note that the saved arguments ({@code a...} in the pseudocode) cannot
7096      * be modified by execution of the target, and so are passed unchanged
7097      * from the caller to the cleanup, if it is invoked.
7098      * &lt;p&gt;
7099      * The target and cleanup must return the same type, even if the cleanup
7100      * always throws.
7101      * To create such a throwing cleanup, compose the cleanup logic
7102      * with {@link #throwException throwException},
7103      * in order to create a method handle of the correct return type.
7104      * &lt;p&gt;
7105      * Note that {@code tryFinally} never converts exceptions into normal returns.
7106      * In rare cases where exceptions must be converted in that way, first wrap
7107      * the target with {@link #catchException(MethodHandle, Class, MethodHandle)}
7108      * to capture an outgoing exception, and then wrap with {@code tryFinally}.
7109      * &lt;p&gt;
7110      * It is recommended that the first parameter type of {@code cleanup} be
7111      * declared {@code Throwable} rather than a narrower subtype.  This ensures
7112      * {@code cleanup} will always be invoked with whatever exception that
7113      * {@code target} throws.  Declaring a narrower type may result in a
7114      * {@code ClassCastException} being thrown by the {@code try-finally}
7115      * handle if the type of the exception thrown by {@code target} is not
7116      * assignable to the first parameter type of {@code cleanup}.  Note that
7117      * various exception types of {@code VirtualMachineError},
7118      * {@code LinkageError}, and {@code RuntimeException} can in principle be
7119      * thrown by almost any kind of Java code, and a finally clause that
7120      * catches (say) only {@code IOException} would mask any of the others
7121      * behind a {@code ClassCastException}.
7122      *
7123      * @param target the handle whose execution is to be wrapped in a {@code try} block.
7124      * @param cleanup the handle that is invoked in the finally block.
7125      *
7126      * @return a method handle embodying the {@code try-finally} block composed of the two arguments.
7127      * @throws NullPointerException if any argument is null
7128      * @throws IllegalArgumentException if {@code cleanup} does not accept
7129      *          the required leading arguments, or if the method handle types do
7130      *          not match in their return types and their
7131      *          corresponding trailing parameters
7132      *
7133      * @see MethodHandles#catchException(MethodHandle, Class, MethodHandle)
7134      * @since 9
7135      */
7136     public static MethodHandle tryFinally(MethodHandle target, MethodHandle cleanup) {
7137         List&lt;Class&lt;?&gt;&gt; targetParamTypes = target.type().parameterList();
7138         Class&lt;?&gt; rtype = target.type().returnType();
7139 
7140         tryFinallyChecks(target, cleanup);
7141 
7142         // Match parameter lists: if the cleanup has a shorter parameter list than the target, add ignored arguments.
7143         // The cleanup parameter list (minus the leading Throwable and result parameters) must be a sublist of the
7144         // target parameter list.
7145         cleanup = dropArgumentsToMatch(cleanup, (rtype == void.class ? 1 : 2), targetParamTypes, 0);
7146 
7147         // Ensure that the intrinsic type checks the instance thrown by the
7148         // target against the first parameter of cleanup
7149         cleanup = cleanup.asType(cleanup.type().changeParameterType(0, Throwable.class));
7150 
7151         // Use asFixedArity() to avoid unnecessary boxing of last argument for VarargsCollector case.
7152         return MethodHandleImpl.makeTryFinally(target.asFixedArity(), cleanup.asFixedArity(), rtype, targetParamTypes);
7153     }
7154 
7155     private static void tryFinallyChecks(MethodHandle target, MethodHandle cleanup) {
7156         Class&lt;?&gt; rtype = target.type().returnType();
7157         if (rtype != cleanup.type().returnType()) {
7158             throw misMatchedTypes(&quot;target and return types&quot;, cleanup.type().returnType(), rtype);
7159         }
7160         MethodType cleanupType = cleanup.type();
7161         if (!Throwable.class.isAssignableFrom(cleanupType.parameterType(0))) {
7162             throw misMatchedTypes(&quot;cleanup first argument and Throwable&quot;, cleanup.type(), Throwable.class);
7163         }
7164         if (rtype != void.class &amp;&amp; cleanupType.parameterType(1) != rtype) {
7165             throw misMatchedTypes(&quot;cleanup second argument and target return type&quot;, cleanup.type(), rtype);
7166         }
7167         // The cleanup parameter list (minus the leading Throwable and result parameters) must be a sublist of the
7168         // target parameter list.
7169         int cleanupArgIndex = rtype == void.class ? 1 : 2;
7170         if (!cleanupType.effectivelyIdenticalParameters(cleanupArgIndex, target.type().parameterList())) {
7171             throw misMatchedTypes(&quot;cleanup parameters after (Throwable,result) and target parameter list prefix&quot;,
7172                     cleanup.type(), target.type());
7173         }
7174     }
7175 
7176 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
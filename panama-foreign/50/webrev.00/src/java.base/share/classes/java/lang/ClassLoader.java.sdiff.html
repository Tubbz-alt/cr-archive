<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/ClassLoader.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../hotspot/share/utilities/powerOfTwo.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ProcessBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/ClassLoader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  23  * or visit www.oracle.com if you need additional information or have any
  24  * questions.
  25  */
  26 
  27 package java.lang;
  28 
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.UncheckedIOException;
  32 import java.io.File;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.InvocationTargetException;
  35 import java.net.URL;
  36 import java.security.AccessController;
  37 import java.security.AccessControlContext;
  38 import java.security.CodeSource;
  39 import java.security.PrivilegedAction;
  40 import java.security.ProtectionDomain;
  41 import java.security.cert.Certificate;
<span class="line-removed">  42 import java.util.ArrayDeque;</span>
  43 import java.util.ArrayList;
<span class="line-removed">  44 import java.util.Arrays;</span>
  45 import java.util.Collections;
<span class="line-removed">  46 import java.util.Deque;</span>
  47 import java.util.Enumeration;
  48 import java.util.HashMap;
<span class="line-removed">  49 import java.util.HashSet;</span>
  50 import java.util.Map;
  51 import java.util.NoSuchElementException;
  52 import java.util.Objects;
  53 import java.util.Set;
  54 import java.util.Spliterator;
  55 import java.util.Spliterators;
  56 import java.util.WeakHashMap;
  57 import java.util.concurrent.ConcurrentHashMap;
  58 import java.util.function.Supplier;
  59 import java.util.stream.Stream;
  60 import java.util.stream.StreamSupport;
  61 
<span class="line-removed">  62 import jdk.internal.access.foreign.NativeLibraryProxy;</span>
<span class="line-removed">  63 import jdk.internal.loader.BuiltinClassLoader;</span>
<span class="line-removed">  64 import jdk.internal.perf.PerfCounter;</span>
  65 import jdk.internal.loader.BootLoader;

  66 import jdk.internal.loader.ClassLoaders;



  67 import jdk.internal.misc.Unsafe;
  68 import jdk.internal.misc.VM;
<span class="line-removed">  69 import jdk.internal.ref.CleanerFactory;</span>
  70 import jdk.internal.reflect.CallerSensitive;
  71 import jdk.internal.reflect.Reflection;
  72 import jdk.internal.util.StaticProperty;
  73 import sun.reflect.misc.ReflectUtil;
  74 import sun.security.util.SecurityConstants;
  75 
  76 /**
  77  * A class loader is an object that is responsible for loading classes. The
  78  * class {@code ClassLoader} is an abstract class.  Given the &lt;a
  79  * href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of a class, a class loader should attempt to
  80  * locate or generate data that constitutes a definition for the class.  A
  81  * typical strategy is to transform the name into a file name and then read a
  82  * &quot;class file&quot; of that name from a file system.
  83  *
  84  * &lt;p&gt; Every {@link java.lang.Class Class} object contains a {@link
  85  * Class#getClassLoader() reference} to the {@code ClassLoader} that defined
  86  * it.
  87  *
  88  * &lt;p&gt; {@code Class} objects for array classes are not created by class
  89  * loaders, but are created automatically as required by the Java runtime.
</pre>
<hr />
<pre>
2361      * Returns the absolute path name of a native library.  The VM invokes this
2362      * method to locate the native libraries that belong to classes loaded with
2363      * this class loader. If this method returns {@code null}, the VM
2364      * searches the library along the path specified as the
2365      * &quot;{@code java.library.path}&quot; property.
2366      *
2367      * @param  libname
2368      *         The library name
2369      *
2370      * @return  The absolute path of the native library
2371      *
2372      * @see  System#loadLibrary(String)
2373      * @see  System#mapLibraryName(String)
2374      *
2375      * @since  1.2
2376      */
2377     protected String findLibrary(String libname) {
2378         return null;
2379     }
2380 
<span class="line-modified">2381     /**</span>
<span class="line-removed">2382      * The inner class NativeLibrary denotes a loaded native library instance.</span>
<span class="line-removed">2383      * Every classloader contains a vector of loaded native libraries in the</span>
<span class="line-removed">2384      * private field {@code nativeLibraries}.  The native libraries loaded</span>
<span class="line-removed">2385      * into the system are entered into the {@code systemNativeLibraries}</span>
<span class="line-removed">2386      * vector.</span>
<span class="line-removed">2387      *</span>
<span class="line-removed">2388      * &lt;p&gt; Every native library requires a particular version of JNI. This is</span>
<span class="line-removed">2389      * denoted by the private {@code jniVersion} field.  This field is set by</span>
<span class="line-removed">2390      * the VM when it loads the library, and used by the VM to pass the correct</span>
<span class="line-removed">2391      * version of JNI to the native methods.  &lt;/p&gt;</span>
<span class="line-removed">2392      *</span>
<span class="line-removed">2393      * @see      ClassLoader</span>
<span class="line-removed">2394      * @since    1.2</span>
<span class="line-removed">2395      */</span>
<span class="line-removed">2396     static class NativeLibrary implements NativeLibraryProxy {</span>
<span class="line-removed">2397         // the class from which the library is loaded, also indicates</span>
<span class="line-removed">2398         // the loader this native library belongs.</span>
<span class="line-removed">2399         final Class&lt;?&gt; fromClass;</span>
<span class="line-removed">2400         // the canonicalized name of the native library.</span>
<span class="line-removed">2401         // or static library name</span>
<span class="line-removed">2402         final String name;</span>
<span class="line-removed">2403         // Indicates if the native library is linked into the VM</span>
<span class="line-removed">2404         final boolean isBuiltin;</span>
<span class="line-removed">2405 </span>
<span class="line-removed">2406         // opaque handle to native library, used in native code.</span>
<span class="line-removed">2407         long handle;</span>
<span class="line-removed">2408         // the version of JNI environment the native library requires.</span>
<span class="line-removed">2409         int jniVersion;</span>
<span class="line-removed">2410 </span>
<span class="line-removed">2411         native boolean load0(String name, boolean isBuiltin);</span>
<span class="line-removed">2412 </span>
<span class="line-removed">2413         private native long findEntry0(String name);</span>
<span class="line-removed">2414 </span>
<span class="line-removed">2415         // used by default library</span>
<span class="line-removed">2416         private static native long findEntryInProcess(String name);</span>
<span class="line-removed">2417 </span>
<span class="line-removed">2418         long findEntry(String name) {</span>
<span class="line-removed">2419             return findEntry0(name);</span>
<span class="line-removed">2420         }</span>
<span class="line-removed">2421 </span>
<span class="line-removed">2422         NativeLibrary(Class&lt;?&gt; fromClass, String name, boolean isBuiltin) {</span>
<span class="line-removed">2423             this.name = name;</span>
<span class="line-removed">2424             this.fromClass = fromClass;</span>
<span class="line-removed">2425             this.isBuiltin = isBuiltin;</span>
<span class="line-removed">2426         }</span>
<span class="line-removed">2427 </span>
<span class="line-removed">2428         @Override</span>
<span class="line-removed">2429         public long lookup(String name) throws NoSuchMethodException {</span>
<span class="line-removed">2430             long addr = findEntry(name);</span>
<span class="line-removed">2431             if (0 == addr) {</span>
<span class="line-removed">2432                 throw new NoSuchMethodException(&quot;Cannot find symbol &quot; + name + &quot; in library &quot; + this.name);</span>
<span class="line-removed">2433             }</span>
<span class="line-removed">2434             return addr;</span>
<span class="line-removed">2435         }</span>
<span class="line-removed">2436 </span>
<span class="line-removed">2437         /*</span>
<span class="line-removed">2438          * Loads the native library and registers for cleanup when its</span>
<span class="line-removed">2439          * associated class loader is unloaded</span>
<span class="line-removed">2440          */</span>
<span class="line-removed">2441         boolean load() {</span>
<span class="line-removed">2442             if (handle != 0) {</span>
<span class="line-removed">2443                 throw new InternalError(&quot;Native library &quot; + name + &quot; has been loaded&quot;);</span>
<span class="line-removed">2444             }</span>
<span class="line-removed">2445 </span>
<span class="line-removed">2446             if (!load0(name, isBuiltin)) return false;</span>
<span class="line-removed">2447 </span>
<span class="line-removed">2448             // register the class loader for cleanup when unloaded</span>
<span class="line-removed">2449             // builtin class loaders are never unloaded</span>
<span class="line-removed">2450             ClassLoader loader = fromClass.getClassLoader();</span>
<span class="line-removed">2451             if (loader != null &amp;&amp;</span>
<span class="line-removed">2452                 loader != getBuiltinPlatformClassLoader() &amp;&amp;</span>
<span class="line-removed">2453                 loader != getBuiltinAppClassLoader()) {</span>
<span class="line-removed">2454                 CleanerFactory.cleaner().register(loader,</span>
<span class="line-removed">2455                         new Unloader(name, handle, isBuiltin));</span>
<span class="line-removed">2456             }</span>
<span class="line-removed">2457             return true;</span>
<span class="line-removed">2458         }</span>
<span class="line-removed">2459 </span>
<span class="line-removed">2460         static NativeLibrary defaultLibrary = new NativeLibrary(Object.class, &quot;&lt;default&gt;&quot;, true) {</span>
<span class="line-removed">2461 </span>
<span class="line-removed">2462             @Override</span>
<span class="line-removed">2463             boolean load() {</span>
<span class="line-removed">2464                 throw new UnsupportedOperationException(&quot;Cannot load default library&quot;);</span>
<span class="line-removed">2465             }</span>
<span class="line-removed">2466 </span>
<span class="line-removed">2467             @Override</span>
<span class="line-removed">2468             long findEntry(String name) {</span>
<span class="line-removed">2469                 return NativeLibrary.findEntryInProcess(name);</span>
<span class="line-removed">2470             }</span>
<span class="line-removed">2471             </span>
<span class="line-removed">2472         };</span>
<span class="line-removed">2473 </span>
<span class="line-removed">2474         static NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, String name, boolean isBuiltin) {</span>
<span class="line-removed">2475             ClassLoader loader =</span>
<span class="line-removed">2476                 fromClass == null ? null : fromClass.getClassLoader();</span>
<span class="line-removed">2477 </span>
<span class="line-removed">2478             synchronized (loadedLibraryNames) {</span>
<span class="line-removed">2479                 Map&lt;String, NativeLibrary&gt; libs =</span>
<span class="line-removed">2480                     loader != null ? loader.nativeLibraries() : systemNativeLibraries();</span>
<span class="line-removed">2481                 NativeLibrary cached = libs.get(name);</span>
<span class="line-removed">2482                 if (cached != null) {</span>
<span class="line-removed">2483                     return cached;</span>
<span class="line-removed">2484                 }</span>
<span class="line-removed">2485 </span>
<span class="line-removed">2486                 if (loadedLibraryNames.contains(name)) {</span>
<span class="line-removed">2487                     throw new UnsatisfiedLinkError(&quot;Native Library &quot; + name +</span>
<span class="line-removed">2488                         &quot; already loaded in another classloader&quot;);</span>
<span class="line-removed">2489                 }</span>
<span class="line-removed">2490 </span>
<span class="line-removed">2491                 /*</span>
<span class="line-removed">2492                  * When a library is being loaded, JNI_OnLoad function can cause</span>
<span class="line-removed">2493                  * another loadLibrary invocation that should succeed.</span>
<span class="line-removed">2494                  *</span>
<span class="line-removed">2495                  * We use a static stack to hold the list of libraries we are</span>
<span class="line-removed">2496                  * loading because this can happen only when called by the</span>
<span class="line-removed">2497                  * same thread because this block is synchronous.</span>
<span class="line-removed">2498                  *</span>
<span class="line-removed">2499                  * If there is a pending load operation for the library, we</span>
<span class="line-removed">2500                  * immediately return success; otherwise, we raise</span>
<span class="line-removed">2501                  * UnsatisfiedLinkError.</span>
<span class="line-removed">2502                  */</span>
<span class="line-removed">2503                 for (NativeLibrary lib : nativeLibraryContext) {</span>
<span class="line-removed">2504                     if (name.equals(lib.name)) {</span>
<span class="line-removed">2505                         if (loader == lib.fromClass.getClassLoader()) {</span>
<span class="line-removed">2506                             return lib;</span>
<span class="line-removed">2507                         } else {</span>
<span class="line-removed">2508                             throw new UnsatisfiedLinkError(&quot;Native Library &quot; +</span>
<span class="line-removed">2509                                 name + &quot; is being loaded in another classloader&quot;);</span>
<span class="line-removed">2510                         }</span>
<span class="line-removed">2511                     }</span>
<span class="line-removed">2512                 }</span>
<span class="line-removed">2513                 NativeLibrary lib = new NativeLibrary(fromClass, name, isBuiltin);</span>
<span class="line-removed">2514                 // load the native library</span>
<span class="line-removed">2515                 nativeLibraryContext.push(lib);</span>
<span class="line-removed">2516                 try {</span>
<span class="line-removed">2517                     if (!lib.load()) return null;</span>
<span class="line-removed">2518                 } finally {</span>
<span class="line-removed">2519                     nativeLibraryContext.pop();</span>
<span class="line-removed">2520                 }</span>
<span class="line-removed">2521                 // register the loaded native library</span>
<span class="line-removed">2522                 loadedLibraryNames.add(name);</span>
<span class="line-removed">2523                 libs.put(name, lib);</span>
<span class="line-removed">2524                 return lib;</span>
<span class="line-removed">2525             }</span>
<span class="line-removed">2526         }</span>
<span class="line-removed">2527 </span>
<span class="line-removed">2528         // Invoked in the VM to determine the context class in JNI_OnLoad</span>
<span class="line-removed">2529         // and JNI_OnUnload</span>
<span class="line-removed">2530         static Class&lt;?&gt; getFromClass() {</span>
<span class="line-removed">2531             if(nativeLibraryContext.isEmpty()) { // only default library </span>
<span class="line-removed">2532                 return defaultLibrary.fromClass;</span>
<span class="line-removed">2533             }</span>
<span class="line-removed">2534             return nativeLibraryContext.peek().fromClass;</span>
<span class="line-removed">2535         }</span>
<span class="line-removed">2536 </span>
<span class="line-removed">2537         // native libraries being loaded</span>
<span class="line-removed">2538         static Deque&lt;NativeLibrary&gt; nativeLibraryContext = new ArrayDeque&lt;&gt;(8);</span>
<span class="line-removed">2539 </span>
<span class="line-removed">2540         /*</span>
<span class="line-removed">2541          * The run() method will be invoked when this class loader becomes</span>
<span class="line-removed">2542          * phantom reachable to unload the native library.</span>
<span class="line-removed">2543          */</span>
<span class="line-removed">2544         static class Unloader implements Runnable {</span>
<span class="line-removed">2545             // This represents the context when a native library is unloaded</span>
<span class="line-removed">2546             // and getFromClass() will return null,</span>
<span class="line-removed">2547             static final NativeLibrary UNLOADER =</span>
<span class="line-removed">2548                 new NativeLibrary(null, &quot;dummy&quot;, false);</span>
<span class="line-removed">2549             final String name;</span>
<span class="line-removed">2550             final long handle;</span>
<span class="line-removed">2551             final boolean isBuiltin;</span>
<span class="line-removed">2552 </span>
<span class="line-removed">2553             Unloader(String name, long handle, boolean isBuiltin) {</span>
<span class="line-removed">2554                 if (handle == 0) {</span>
<span class="line-removed">2555                     throw new IllegalArgumentException(</span>
<span class="line-removed">2556                         &quot;Invalid handle for native library &quot; + name);</span>
<span class="line-removed">2557                 }</span>
<span class="line-removed">2558 </span>
<span class="line-removed">2559                 this.name = name;</span>
<span class="line-removed">2560                 this.handle = handle;</span>
<span class="line-removed">2561                 this.isBuiltin = isBuiltin;</span>
<span class="line-removed">2562             }</span>
2563 
<span class="line-modified">2564             @Override</span>
<span class="line-modified">2565             public void run() {</span>
<span class="line-modified">2566                 synchronized (loadedLibraryNames) {</span>
<span class="line-modified">2567                     /* remove the native library name */</span>
<span class="line-modified">2568                     loadedLibraryNames.remove(name);</span>
<span class="line-modified">2569                     nativeLibraryContext.push(UNLOADER);</span>
<span class="line-modified">2570                     try {</span>
<span class="line-removed">2571                         unload(name, isBuiltin, handle);</span>
<span class="line-removed">2572                     } finally {</span>
<span class="line-removed">2573                         nativeLibraryContext.pop();</span>
<span class="line-removed">2574                     }</span>
<span class="line-removed">2575 </span>
<span class="line-removed">2576                 }</span>
<span class="line-removed">2577             }</span>
2578         }
<span class="line-modified">2579 </span>
<span class="line-removed">2580         // JNI FindClass expects the caller class if invoked from JNI_OnLoad</span>
<span class="line-removed">2581         // and JNI_OnUnload is NativeLibrary class</span>
<span class="line-removed">2582         static native void unload(String name, boolean isBuiltin, long handle);</span>
2583     }
<span class="line-modified">2584 </span>
<span class="line-modified">2585     /**</span>
<span class="line-modified">2586      * Holds system and user library paths derived from the</span>
<span class="line-modified">2587      * {@code java.library.path} and {@code sun.boot.library.path} system</span>
<span class="line-removed">2588      * properties. The system properties are eagerly read at bootstrap, then</span>
<span class="line-removed">2589      * lazily parsed on first use to avoid initialization ordering issues.</span>
<span class="line-removed">2590      */</span>
<span class="line-removed">2591     private static class LibraryPaths {</span>
<span class="line-removed">2592         static final String[] USER =</span>
<span class="line-removed">2593                 ClassLoaderHelper.parsePath(StaticProperty.javaLibraryPath());</span>
<span class="line-removed">2594         static final String[] SYS =</span>
<span class="line-removed">2595                 ClassLoaderHelper.parsePath(StaticProperty.sunBootLibraryPath());</span>
<span class="line-removed">2596     }</span>
<span class="line-removed">2597 </span>
<span class="line-removed">2598     // Invoked in the java.lang.Runtime class to implement load and loadLibrary.</span>
<span class="line-removed">2599     static NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, String name,</span>
<span class="line-removed">2600                                      boolean isAbsolute) {</span>
<span class="line-removed">2601         ClassLoader loader =</span>
<span class="line-removed">2602             (fromClass == null) ? null : fromClass.getClassLoader();</span>
<span class="line-removed">2603 </span>
<span class="line-removed">2604         if (isAbsolute) {</span>
<span class="line-removed">2605             NativeLibrary nl = loadLibrary0(fromClass, new File(name));</span>
2606             if (nl != null) {
2607                 return nl;
2608             }
<span class="line-modified">2609             throw new UnsatisfiedLinkError(&quot;Can&#39;t load library: &quot; + name);</span>

2610         }
<span class="line-modified">2611         if (loader != null) {</span>
<span class="line-modified">2612             String libfilename = loader.findLibrary(name);</span>
<span class="line-modified">2613             if (libfilename != null) {</span>
<span class="line-modified">2614                 File libfile = new File(libfilename);</span>
<span class="line-modified">2615                 if (!libfile.isAbsolute()) {</span>
<span class="line-modified">2616                     throw new UnsatisfiedLinkError(</span>


2617                         &quot;ClassLoader.findLibrary failed to return an absolute path: &quot; + libfilename);
<span class="line-removed">2618                 }</span>
<span class="line-removed">2619                 NativeLibrary nl = loadLibrary0(fromClass, libfile);</span>
<span class="line-removed">2620                 if (nl != null) {</span>
<span class="line-removed">2621                     return nl;</span>
<span class="line-removed">2622                 }</span>
<span class="line-removed">2623                 throw new UnsatisfiedLinkError(&quot;Can&#39;t load &quot; + libfilename);</span>
2624             }
<span class="line-modified">2625         }</span>
<span class="line-removed">2626         for (String sysPath : LibraryPaths.SYS) {</span>
<span class="line-removed">2627             File libfile = new File(sysPath, System.mapLibraryName(name));</span>
<span class="line-removed">2628             NativeLibrary nl = loadLibrary0(fromClass, libfile);</span>
2629             if (nl != null) {
2630                 return nl;
2631             }
<span class="line-modified">2632             libfile = ClassLoaderHelper.mapAlternativeName(libfile);</span>
<span class="line-removed">2633             if (libfile != null) {</span>
<span class="line-removed">2634                 nl = loadLibrary0(fromClass, libfile);</span>
<span class="line-removed">2635                 if (nl != null) {</span>
<span class="line-removed">2636                     return nl;</span>
<span class="line-removed">2637                 }</span>
<span class="line-removed">2638             }</span>
2639         }
<span class="line-modified">2640         if (loader != null) {</span>
<span class="line-modified">2641             for (String userPath : LibraryPaths.USER) {</span>
<span class="line-modified">2642                 File libfile = new File(userPath, System.mapLibraryName(name));</span>
<span class="line-modified">2643                 NativeLibrary nl = loadLibrary0(fromClass, libfile);</span>
<span class="line-removed">2644                 if (nl != null) {</span>
<span class="line-removed">2645                     return nl;</span>
<span class="line-removed">2646                 }</span>
<span class="line-removed">2647                 libfile = ClassLoaderHelper.mapAlternativeName(libfile);</span>
<span class="line-removed">2648                 if (libfile != null) {</span>
<span class="line-removed">2649                     nl = loadLibrary0(fromClass, libfile);</span>
<span class="line-removed">2650                     if (nl != null) {</span>
<span class="line-removed">2651                         return nl;</span>
<span class="line-removed">2652                     }</span>
<span class="line-removed">2653                 }</span>
<span class="line-removed">2654             }</span>
2655         }

2656         // Oops, it failed
2657         throw new UnsatisfiedLinkError(&quot;no &quot; + name +
<span class="line-modified">2658             &quot; in java.library.path: &quot; + Arrays.toString(LibraryPaths.USER));</span>
<span class="line-removed">2659     }</span>
<span class="line-removed">2660 </span>
<span class="line-removed">2661     private static native String findBuiltinLib(String name);</span>
<span class="line-removed">2662 </span>
<span class="line-removed">2663     private static NativeLibrary loadLibrary0(Class&lt;?&gt; fromClass, final File file) {</span>
<span class="line-removed">2664         // Check to see if we&#39;re attempting to access a static library</span>
<span class="line-removed">2665         String name = findBuiltinLib(file.getName());</span>
<span class="line-removed">2666         boolean isBuiltin = (name != null);</span>
<span class="line-removed">2667         if (!isBuiltin) {</span>
<span class="line-removed">2668             name = AccessController.doPrivileged(</span>
<span class="line-removed">2669                 new PrivilegedAction&lt;&gt;() {</span>
<span class="line-removed">2670                     public String run() {</span>
<span class="line-removed">2671                         try {</span>
<span class="line-removed">2672                             return file.exists() ? file.getCanonicalPath() : null;</span>
<span class="line-removed">2673                         } catch (IOException e) {</span>
<span class="line-removed">2674                             return null;</span>
<span class="line-removed">2675                         }</span>
<span class="line-removed">2676                     }</span>
<span class="line-removed">2677                 });</span>
<span class="line-removed">2678             if (name == null) {</span>
<span class="line-removed">2679                 return null;</span>
<span class="line-removed">2680             }</span>
<span class="line-removed">2681         }</span>
<span class="line-removed">2682         return NativeLibrary.loadLibrary(fromClass, name, isBuiltin);</span>
2683     }
2684 
2685     /*
2686      * Invoked in the VM class linking code.
2687      */
2688     private static long findNative(ClassLoader loader, String entryName) {
<span class="line-modified">2689         Map&lt;String, NativeLibrary&gt; libs =</span>
<span class="line-modified">2690             loader != null ? loader.nativeLibraries() : systemNativeLibraries();</span>
<span class="line-modified">2691         if (libs.isEmpty())</span>
<span class="line-modified">2692             return 0;</span>
<span class="line-removed">2693 </span>
<span class="line-removed">2694         // the native libraries map may be updated in another thread</span>
<span class="line-removed">2695         // when a native library is being loaded.  No symbol will be</span>
<span class="line-removed">2696         // searched from it yet.</span>
<span class="line-removed">2697         for (NativeLibrary lib : libs.values()) {</span>
<span class="line-removed">2698             long entry = lib.findEntry(entryName);</span>
<span class="line-removed">2699             if (entry != 0) return entry;</span>
<span class="line-removed">2700         }</span>
<span class="line-removed">2701         return 0;</span>
<span class="line-removed">2702     }</span>
<span class="line-removed">2703 </span>
<span class="line-removed">2704     // All native library names we&#39;ve loaded.</span>
<span class="line-removed">2705     // This also serves as the lock to obtain nativeLibraries</span>
<span class="line-removed">2706     // and write to nativeLibraryContext.</span>
<span class="line-removed">2707     private static final Set&lt;String&gt; loadedLibraryNames = new HashSet&lt;&gt;();</span>
<span class="line-removed">2708 </span>
<span class="line-removed">2709     // Native libraries belonging to system classes.</span>
<span class="line-removed">2710     private static volatile Map&lt;String, NativeLibrary&gt; systemNativeLibraries;</span>
<span class="line-removed">2711 </span>
<span class="line-removed">2712     // Native libraries associated with the class loader.</span>
<span class="line-removed">2713     private volatile Map&lt;String, NativeLibrary&gt; nativeLibraries;</span>
<span class="line-removed">2714 </span>
<span class="line-removed">2715     /*</span>
<span class="line-removed">2716      * Returns the native libraries map associated with bootstrap class loader</span>
<span class="line-removed">2717      * This method will create the map at the first time when called.</span>
<span class="line-removed">2718      */</span>
<span class="line-removed">2719     private static Map&lt;String, NativeLibrary&gt; systemNativeLibraries() {</span>
<span class="line-removed">2720         Map&lt;String, NativeLibrary&gt; libs = systemNativeLibraries;</span>
<span class="line-removed">2721         if (libs == null) {</span>
<span class="line-removed">2722             synchronized (loadedLibraryNames) {</span>
<span class="line-removed">2723                 libs = systemNativeLibraries;</span>
<span class="line-removed">2724                 if (libs == null) {</span>
<span class="line-removed">2725                     libs = systemNativeLibraries = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-removed">2726                 }</span>
<span class="line-removed">2727             }</span>
<span class="line-removed">2728         }</span>
<span class="line-removed">2729         return libs;</span>
<span class="line-removed">2730     }</span>
<span class="line-removed">2731 </span>
<span class="line-removed">2732     /*</span>
<span class="line-removed">2733      * Returns the native libraries map associated with this class loader</span>
<span class="line-removed">2734      * This method will create the map at the first time when called.</span>
<span class="line-removed">2735      */</span>
<span class="line-removed">2736     private Map&lt;String, NativeLibrary&gt; nativeLibraries() {</span>
<span class="line-removed">2737         Map&lt;String, NativeLibrary&gt; libs = nativeLibraries;</span>
<span class="line-removed">2738         if (libs == null) {</span>
<span class="line-removed">2739             synchronized (loadedLibraryNames) {</span>
<span class="line-removed">2740                 libs = nativeLibraries;</span>
<span class="line-removed">2741                 if (libs == null) {</span>
<span class="line-removed">2742                     libs = nativeLibraries = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-removed">2743                 }</span>
<span class="line-removed">2744             }</span>
2745         }
<span class="line-removed">2746         return libs;</span>
2747     }
2748 
2749     // -- Assertion management --
2750 
2751     final Object assertionLock;
2752 
2753     // The default toggle for assertion checking.
2754     // @GuardedBy(&quot;assertionLock&quot;)
2755     private boolean defaultAssertionStatus = false;
2756 
2757     // Maps String packageName to Boolean package default assertion status Note
2758     // that the default package is placed under a null map key.  If this field
2759     // is null then we are delegating assertion status queries to the VM, i.e.,
2760     // none of this ClassLoader&#39;s assertion status modification methods have
2761     // been invoked.
2762     // @GuardedBy(&quot;assertionLock&quot;)
2763     private Map&lt;String, Boolean&gt; packageAssertionStatus = null;
2764 
2765     // Maps String fullyQualifiedClassName to Boolean assertionStatus If this
2766     // field is null then we are delegating assertion status queries to the VM,
</pre>
</td>
<td>
<hr />
<pre>
  22  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  23  * or visit www.oracle.com if you need additional information or have any
  24  * questions.
  25  */
  26 
  27 package java.lang;
  28 
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.UncheckedIOException;
  32 import java.io.File;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.InvocationTargetException;
  35 import java.net.URL;
  36 import java.security.AccessController;
  37 import java.security.AccessControlContext;
  38 import java.security.CodeSource;
  39 import java.security.PrivilegedAction;
  40 import java.security.ProtectionDomain;
  41 import java.security.cert.Certificate;

  42 import java.util.ArrayList;

  43 import java.util.Collections;

  44 import java.util.Enumeration;
  45 import java.util.HashMap;

  46 import java.util.Map;
  47 import java.util.NoSuchElementException;
  48 import java.util.Objects;
  49 import java.util.Set;
  50 import java.util.Spliterator;
  51 import java.util.Spliterators;
  52 import java.util.WeakHashMap;
  53 import java.util.concurrent.ConcurrentHashMap;
  54 import java.util.function.Supplier;
  55 import java.util.stream.Stream;
  56 import java.util.stream.StreamSupport;
  57 



  58 import jdk.internal.loader.BootLoader;
<span class="line-added">  59 import jdk.internal.loader.BuiltinClassLoader;</span>
  60 import jdk.internal.loader.ClassLoaders;
<span class="line-added">  61 import jdk.internal.loader.NativeLibrary;</span>
<span class="line-added">  62 import jdk.internal.loader.NativeLibraries;</span>
<span class="line-added">  63 import jdk.internal.perf.PerfCounter;</span>
  64 import jdk.internal.misc.Unsafe;
  65 import jdk.internal.misc.VM;

  66 import jdk.internal.reflect.CallerSensitive;
  67 import jdk.internal.reflect.Reflection;
  68 import jdk.internal.util.StaticProperty;
  69 import sun.reflect.misc.ReflectUtil;
  70 import sun.security.util.SecurityConstants;
  71 
  72 /**
  73  * A class loader is an object that is responsible for loading classes. The
  74  * class {@code ClassLoader} is an abstract class.  Given the &lt;a
  75  * href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of a class, a class loader should attempt to
  76  * locate or generate data that constitutes a definition for the class.  A
  77  * typical strategy is to transform the name into a file name and then read a
  78  * &quot;class file&quot; of that name from a file system.
  79  *
  80  * &lt;p&gt; Every {@link java.lang.Class Class} object contains a {@link
  81  * Class#getClassLoader() reference} to the {@code ClassLoader} that defined
  82  * it.
  83  *
  84  * &lt;p&gt; {@code Class} objects for array classes are not created by class
  85  * loaders, but are created automatically as required by the Java runtime.
</pre>
<hr />
<pre>
2357      * Returns the absolute path name of a native library.  The VM invokes this
2358      * method to locate the native libraries that belong to classes loaded with
2359      * this class loader. If this method returns {@code null}, the VM
2360      * searches the library along the path specified as the
2361      * &quot;{@code java.library.path}&quot; property.
2362      *
2363      * @param  libname
2364      *         The library name
2365      *
2366      * @return  The absolute path of the native library
2367      *
2368      * @see  System#loadLibrary(String)
2369      * @see  System#mapLibraryName(String)
2370      *
2371      * @since  1.2
2372      */
2373     protected String findLibrary(String libname) {
2374         return null;
2375     }
2376 
<span class="line-modified">2377     private final NativeLibraries libraries = new NativeLibraries(this);</span>





















































































































































































2378 
<span class="line-modified">2379     // Invoked in the java.lang.Runtime class to implement load and loadLibrary.</span>
<span class="line-modified">2380     static NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, File file) {</span>
<span class="line-modified">2381         ClassLoader loader = (fromClass == null) ? null : fromClass.getClassLoader();</span>
<span class="line-modified">2382         NativeLibraries libs = loader != null ? loader.libraries : BootLoader.getNativeLibraries();</span>
<span class="line-modified">2383         NativeLibrary nl = libs.loadLibrary(fromClass, file);</span>
<span class="line-modified">2384         if (nl != null) {</span>
<span class="line-modified">2385             return nl;</span>







2386         }
<span class="line-modified">2387         throw new UnsatisfiedLinkError(&quot;Can&#39;t load library: &quot; + file);</span>



2388     }
<span class="line-modified">2389     static NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, String name) {</span>
<span class="line-modified">2390         ClassLoader loader = (fromClass == null) ? null : fromClass.getClassLoader();</span>
<span class="line-modified">2391         if (loader == null) {</span>
<span class="line-modified">2392             NativeLibrary nl = BootLoader.getNativeLibraries().loadLibrary(fromClass, name);</span>


















2393             if (nl != null) {
2394                 return nl;
2395             }
<span class="line-modified">2396             throw new UnsatisfiedLinkError(&quot;no &quot; + name +</span>
<span class="line-added">2397                     &quot; in system library path: &quot; + StaticProperty.sunBootLibraryPath());</span>
2398         }
<span class="line-modified">2399 </span>
<span class="line-modified">2400         NativeLibraries libs = loader.libraries;</span>
<span class="line-modified">2401         // First load from the file returned from ClassLoader::findLibrary, if found.</span>
<span class="line-modified">2402         String libfilename = loader.findLibrary(name);</span>
<span class="line-modified">2403         if (libfilename != null) {</span>
<span class="line-modified">2404             File libfile = new File(libfilename);</span>
<span class="line-added">2405             if (!libfile.isAbsolute()) {</span>
<span class="line-added">2406                 throw new UnsatisfiedLinkError(</span>
2407                         &quot;ClassLoader.findLibrary failed to return an absolute path: &quot; + libfilename);






2408             }
<span class="line-modified">2409             NativeLibrary nl = libs.loadLibrary(fromClass, libfile);</span>



2410             if (nl != null) {
2411                 return nl;
2412             }
<span class="line-modified">2413             throw new UnsatisfiedLinkError(&quot;Can&#39;t load &quot; + libfilename);</span>






2414         }
<span class="line-modified">2415         // Then load from system library path and java library path</span>
<span class="line-modified">2416         NativeLibrary nl = libs.loadLibrary(fromClass, name);</span>
<span class="line-modified">2417         if (nl != null) {</span>
<span class="line-modified">2418             return nl;</span>











2419         }
<span class="line-added">2420 </span>
2421         // Oops, it failed
2422         throw new UnsatisfiedLinkError(&quot;no &quot; + name +
<span class="line-modified">2423                 &quot; in java.library.path: &quot; + StaticProperty.javaLibraryPath());</span>
























2424     }
2425 
2426     /*
2427      * Invoked in the VM class linking code.
2428      */
2429     private static long findNative(ClassLoader loader, String entryName) {
<span class="line-modified">2430         if (loader == null) {</span>
<span class="line-modified">2431             return BootLoader.getNativeLibraries().find(entryName);</span>
<span class="line-modified">2432         } else {</span>
<span class="line-modified">2433             return loader.libraries.find(entryName);</span>




















































2434         }

2435     }
2436 
2437     // -- Assertion management --
2438 
2439     final Object assertionLock;
2440 
2441     // The default toggle for assertion checking.
2442     // @GuardedBy(&quot;assertionLock&quot;)
2443     private boolean defaultAssertionStatus = false;
2444 
2445     // Maps String packageName to Boolean package default assertion status Note
2446     // that the default package is placed under a null map key.  If this field
2447     // is null then we are delegating assertion status queries to the VM, i.e.,
2448     // none of this ClassLoader&#39;s assertion status modification methods have
2449     // been invoked.
2450     // @GuardedBy(&quot;assertionLock&quot;)
2451     private Map&lt;String, Boolean&gt; packageAssertionStatus = null;
2452 
2453     // Maps String fullyQualifiedClassName to Boolean assertionStatus If this
2454     // field is null then we are delegating assertion status queries to the VM,
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../hotspot/share/utilities/powerOfTwo.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ProcessBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/ClassLoader.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../hotspot/share/utilities/powerOfTwo.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ProcessBuilder.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/ClassLoader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 37,18 ***</span>
  import java.security.AccessControlContext;
  import java.security.CodeSource;
  import java.security.PrivilegedAction;
  import java.security.ProtectionDomain;
  import java.security.cert.Certificate;
<span class="line-removed">- import java.util.ArrayDeque;</span>
  import java.util.ArrayList;
<span class="line-removed">- import java.util.Arrays;</span>
  import java.util.Collections;
<span class="line-removed">- import java.util.Deque;</span>
  import java.util.Enumeration;
  import java.util.HashMap;
<span class="line-removed">- import java.util.HashSet;</span>
  import java.util.Map;
  import java.util.NoSuchElementException;
  import java.util.Objects;
  import java.util.Set;
  import java.util.Spliterator;
<span class="line-new-header">--- 37,14 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,18 ***</span>
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.function.Supplier;
  import java.util.stream.Stream;
  import java.util.stream.StreamSupport;
  
<span class="line-removed">- import jdk.internal.access.foreign.NativeLibraryProxy;</span>
<span class="line-removed">- import jdk.internal.loader.BuiltinClassLoader;</span>
<span class="line-removed">- import jdk.internal.perf.PerfCounter;</span>
  import jdk.internal.loader.BootLoader;
  import jdk.internal.loader.ClassLoaders;
  import jdk.internal.misc.Unsafe;
  import jdk.internal.misc.VM;
<span class="line-removed">- import jdk.internal.ref.CleanerFactory;</span>
  import jdk.internal.reflect.CallerSensitive;
  import jdk.internal.reflect.Reflection;
  import jdk.internal.util.StaticProperty;
  import sun.reflect.misc.ReflectUtil;
  import sun.security.util.SecurityConstants;
<span class="line-new-header">--- 53,18 ---</span>
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.function.Supplier;
  import java.util.stream.Stream;
  import java.util.stream.StreamSupport;
  
  import jdk.internal.loader.BootLoader;
<span class="line-added">+ import jdk.internal.loader.BuiltinClassLoader;</span>
  import jdk.internal.loader.ClassLoaders;
<span class="line-added">+ import jdk.internal.loader.NativeLibrary;</span>
<span class="line-added">+ import jdk.internal.loader.NativeLibraries;</span>
<span class="line-added">+ import jdk.internal.perf.PerfCounter;</span>
  import jdk.internal.misc.Unsafe;
  import jdk.internal.misc.VM;
  import jdk.internal.reflect.CallerSensitive;
  import jdk.internal.reflect.Reflection;
  import jdk.internal.util.StaticProperty;
  import sun.reflect.misc.ReflectUtil;
  import sun.security.util.SecurityConstants;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2376,376 ***</span>
       */
      protected String findLibrary(String libname) {
          return null;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-removed">-      * The inner class NativeLibrary denotes a loaded native library instance.</span>
<span class="line-removed">-      * Every classloader contains a vector of loaded native libraries in the</span>
<span class="line-removed">-      * private field {@code nativeLibraries}.  The native libraries loaded</span>
<span class="line-removed">-      * into the system are entered into the {@code systemNativeLibraries}</span>
<span class="line-removed">-      * vector.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt; Every native library requires a particular version of JNI. This is</span>
<span class="line-removed">-      * denoted by the private {@code jniVersion} field.  This field is set by</span>
<span class="line-removed">-      * the VM when it loads the library, and used by the VM to pass the correct</span>
<span class="line-removed">-      * version of JNI to the native methods.  &lt;/p&gt;</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @see      ClassLoader</span>
<span class="line-removed">-      * @since    1.2</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     static class NativeLibrary implements NativeLibraryProxy {</span>
<span class="line-removed">-         // the class from which the library is loaded, also indicates</span>
<span class="line-removed">-         // the loader this native library belongs.</span>
<span class="line-removed">-         final Class&lt;?&gt; fromClass;</span>
<span class="line-removed">-         // the canonicalized name of the native library.</span>
<span class="line-removed">-         // or static library name</span>
<span class="line-removed">-         final String name;</span>
<span class="line-removed">-         // Indicates if the native library is linked into the VM</span>
<span class="line-removed">-         final boolean isBuiltin;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // opaque handle to native library, used in native code.</span>
<span class="line-removed">-         long handle;</span>
<span class="line-removed">-         // the version of JNI environment the native library requires.</span>
<span class="line-removed">-         int jniVersion;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         native boolean load0(String name, boolean isBuiltin);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private native long findEntry0(String name);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // used by default library</span>
<span class="line-removed">-         private static native long findEntryInProcess(String name);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         long findEntry(String name) {</span>
<span class="line-removed">-             return findEntry0(name);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         NativeLibrary(Class&lt;?&gt; fromClass, String name, boolean isBuiltin) {</span>
<span class="line-removed">-             this.name = name;</span>
<span class="line-removed">-             this.fromClass = fromClass;</span>
<span class="line-removed">-             this.isBuiltin = isBuiltin;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public long lookup(String name) throws NoSuchMethodException {</span>
<span class="line-removed">-             long addr = findEntry(name);</span>
<span class="line-removed">-             if (0 == addr) {</span>
<span class="line-removed">-                 throw new NoSuchMethodException(&quot;Cannot find symbol &quot; + name + &quot; in library &quot; + this.name);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return addr;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-          * Loads the native library and registers for cleanup when its</span>
<span class="line-removed">-          * associated class loader is unloaded</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         boolean load() {</span>
<span class="line-removed">-             if (handle != 0) {</span>
<span class="line-removed">-                 throw new InternalError(&quot;Native library &quot; + name + &quot; has been loaded&quot;);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (!load0(name, isBuiltin)) return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // register the class loader for cleanup when unloaded</span>
<span class="line-removed">-             // builtin class loaders are never unloaded</span>
<span class="line-removed">-             ClassLoader loader = fromClass.getClassLoader();</span>
<span class="line-removed">-             if (loader != null &amp;&amp;</span>
<span class="line-removed">-                 loader != getBuiltinPlatformClassLoader() &amp;&amp;</span>
<span class="line-removed">-                 loader != getBuiltinAppClassLoader()) {</span>
<span class="line-removed">-                 CleanerFactory.cleaner().register(loader,</span>
<span class="line-removed">-                         new Unloader(name, handle, isBuiltin));</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static NativeLibrary defaultLibrary = new NativeLibrary(Object.class, &quot;&lt;default&gt;&quot;, true) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-             @Override</span>
<span class="line-removed">-             boolean load() {</span>
<span class="line-removed">-                 throw new UnsupportedOperationException(&quot;Cannot load default library&quot;);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             @Override</span>
<span class="line-removed">-             long findEntry(String name) {</span>
<span class="line-removed">-                 return NativeLibrary.findEntryInProcess(name);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             </span>
<span class="line-removed">-         };</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, String name, boolean isBuiltin) {</span>
<span class="line-removed">-             ClassLoader loader =</span>
<span class="line-removed">-                 fromClass == null ? null : fromClass.getClassLoader();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             synchronized (loadedLibraryNames) {</span>
<span class="line-removed">-                 Map&lt;String, NativeLibrary&gt; libs =</span>
<span class="line-removed">-                     loader != null ? loader.nativeLibraries() : systemNativeLibraries();</span>
<span class="line-removed">-                 NativeLibrary cached = libs.get(name);</span>
<span class="line-removed">-                 if (cached != null) {</span>
<span class="line-removed">-                     return cached;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 if (loadedLibraryNames.contains(name)) {</span>
<span class="line-removed">-                     throw new UnsatisfiedLinkError(&quot;Native Library &quot; + name +</span>
<span class="line-removed">-                         &quot; already loaded in another classloader&quot;);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 /*</span>
<span class="line-removed">-                  * When a library is being loaded, JNI_OnLoad function can cause</span>
<span class="line-removed">-                  * another loadLibrary invocation that should succeed.</span>
<span class="line-removed">-                  *</span>
<span class="line-removed">-                  * We use a static stack to hold the list of libraries we are</span>
<span class="line-removed">-                  * loading because this can happen only when called by the</span>
<span class="line-removed">-                  * same thread because this block is synchronous.</span>
<span class="line-removed">-                  *</span>
<span class="line-removed">-                  * If there is a pending load operation for the library, we</span>
<span class="line-removed">-                  * immediately return success; otherwise, we raise</span>
<span class="line-removed">-                  * UnsatisfiedLinkError.</span>
<span class="line-removed">-                  */</span>
<span class="line-removed">-                 for (NativeLibrary lib : nativeLibraryContext) {</span>
<span class="line-removed">-                     if (name.equals(lib.name)) {</span>
<span class="line-removed">-                         if (loader == lib.fromClass.getClassLoader()) {</span>
<span class="line-removed">-                             return lib;</span>
<span class="line-removed">-                         } else {</span>
<span class="line-removed">-                             throw new UnsatisfiedLinkError(&quot;Native Library &quot; +</span>
<span class="line-removed">-                                 name + &quot; is being loaded in another classloader&quot;);</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 NativeLibrary lib = new NativeLibrary(fromClass, name, isBuiltin);</span>
<span class="line-removed">-                 // load the native library</span>
<span class="line-removed">-                 nativeLibraryContext.push(lib);</span>
<span class="line-removed">-                 try {</span>
<span class="line-removed">-                     if (!lib.load()) return null;</span>
<span class="line-removed">-                 } finally {</span>
<span class="line-removed">-                     nativeLibraryContext.pop();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 // register the loaded native library</span>
<span class="line-removed">-                 loadedLibraryNames.add(name);</span>
<span class="line-removed">-                 libs.put(name, lib);</span>
<span class="line-removed">-                 return lib;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Invoked in the VM to determine the context class in JNI_OnLoad</span>
<span class="line-removed">-         // and JNI_OnUnload</span>
<span class="line-removed">-         static Class&lt;?&gt; getFromClass() {</span>
<span class="line-removed">-             if(nativeLibraryContext.isEmpty()) { // only default library </span>
<span class="line-removed">-                 return defaultLibrary.fromClass;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return nativeLibraryContext.peek().fromClass;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // native libraries being loaded</span>
<span class="line-removed">-         static Deque&lt;NativeLibrary&gt; nativeLibraryContext = new ArrayDeque&lt;&gt;(8);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-          * The run() method will be invoked when this class loader becomes</span>
<span class="line-removed">-          * phantom reachable to unload the native library.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         static class Unloader implements Runnable {</span>
<span class="line-removed">-             // This represents the context when a native library is unloaded</span>
<span class="line-removed">-             // and getFromClass() will return null,</span>
<span class="line-removed">-             static final NativeLibrary UNLOADER =</span>
<span class="line-removed">-                 new NativeLibrary(null, &quot;dummy&quot;, false);</span>
<span class="line-removed">-             final String name;</span>
<span class="line-removed">-             final long handle;</span>
<span class="line-removed">-             final boolean isBuiltin;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             Unloader(String name, long handle, boolean isBuiltin) {</span>
<span class="line-removed">-                 if (handle == 0) {</span>
<span class="line-removed">-                     throw new IllegalArgumentException(</span>
<span class="line-removed">-                         &quot;Invalid handle for native library &quot; + name);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 this.name = name;</span>
<span class="line-removed">-                 this.handle = handle;</span>
<span class="line-removed">-                 this.isBuiltin = isBuiltin;</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             public void run() {</span>
<span class="line-modified">!                 synchronized (loadedLibraryNames) {</span>
<span class="line-modified">!                     /* remove the native library name */</span>
<span class="line-modified">!                     loadedLibraryNames.remove(name);</span>
<span class="line-modified">!                     nativeLibraryContext.push(UNLOADER);</span>
<span class="line-modified">!                     try {</span>
<span class="line-removed">-                         unload(name, isBuiltin, handle);</span>
<span class="line-removed">-                     } finally {</span>
<span class="line-removed">-                         nativeLibraryContext.pop();</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
          }
<span class="line-modified">! </span>
<span class="line-removed">-         // JNI FindClass expects the caller class if invoked from JNI_OnLoad</span>
<span class="line-removed">-         // and JNI_OnUnload is NativeLibrary class</span>
<span class="line-removed">-         static native void unload(String name, boolean isBuiltin, long handle);</span>
      }
<span class="line-modified">! </span>
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Holds system and user library paths derived from the</span>
<span class="line-modified">!      * {@code java.library.path} and {@code sun.boot.library.path} system</span>
<span class="line-removed">-      * properties. The system properties are eagerly read at bootstrap, then</span>
<span class="line-removed">-      * lazily parsed on first use to avoid initialization ordering issues.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static class LibraryPaths {</span>
<span class="line-removed">-         static final String[] USER =</span>
<span class="line-removed">-                 ClassLoaderHelper.parsePath(StaticProperty.javaLibraryPath());</span>
<span class="line-removed">-         static final String[] SYS =</span>
<span class="line-removed">-                 ClassLoaderHelper.parsePath(StaticProperty.sunBootLibraryPath());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Invoked in the java.lang.Runtime class to implement load and loadLibrary.</span>
<span class="line-removed">-     static NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, String name,</span>
<span class="line-removed">-                                      boolean isAbsolute) {</span>
<span class="line-removed">-         ClassLoader loader =</span>
<span class="line-removed">-             (fromClass == null) ? null : fromClass.getClassLoader();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (isAbsolute) {</span>
<span class="line-removed">-             NativeLibrary nl = loadLibrary0(fromClass, new File(name));</span>
              if (nl != null) {
                  return nl;
              }
<span class="line-modified">!             throw new UnsatisfiedLinkError(&quot;Can&#39;t load library: &quot; + name);</span>
          }
<span class="line-modified">!         if (loader != null) {</span>
<span class="line-modified">!             String libfilename = loader.findLibrary(name);</span>
<span class="line-modified">!             if (libfilename != null) {</span>
<span class="line-modified">!                 File libfile = new File(libfilename);</span>
<span class="line-modified">!                 if (!libfile.isAbsolute()) {</span>
<span class="line-modified">!                     throw new UnsatisfiedLinkError(</span>
                          &quot;ClassLoader.findLibrary failed to return an absolute path: &quot; + libfilename);
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 NativeLibrary nl = loadLibrary0(fromClass, libfile);</span>
<span class="line-removed">-                 if (nl != null) {</span>
<span class="line-removed">-                     return nl;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 throw new UnsatisfiedLinkError(&quot;Can&#39;t load &quot; + libfilename);</span>
              }
<span class="line-modified">!         }</span>
<span class="line-removed">-         for (String sysPath : LibraryPaths.SYS) {</span>
<span class="line-removed">-             File libfile = new File(sysPath, System.mapLibraryName(name));</span>
<span class="line-removed">-             NativeLibrary nl = loadLibrary0(fromClass, libfile);</span>
              if (nl != null) {
                  return nl;
              }
<span class="line-modified">!             libfile = ClassLoaderHelper.mapAlternativeName(libfile);</span>
<span class="line-removed">-             if (libfile != null) {</span>
<span class="line-removed">-                 nl = loadLibrary0(fromClass, libfile);</span>
<span class="line-removed">-                 if (nl != null) {</span>
<span class="line-removed">-                     return nl;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
          }
<span class="line-modified">!         if (loader != null) {</span>
<span class="line-modified">!             for (String userPath : LibraryPaths.USER) {</span>
<span class="line-modified">!                 File libfile = new File(userPath, System.mapLibraryName(name));</span>
<span class="line-modified">!                 NativeLibrary nl = loadLibrary0(fromClass, libfile);</span>
<span class="line-removed">-                 if (nl != null) {</span>
<span class="line-removed">-                     return nl;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 libfile = ClassLoaderHelper.mapAlternativeName(libfile);</span>
<span class="line-removed">-                 if (libfile != null) {</span>
<span class="line-removed">-                     nl = loadLibrary0(fromClass, libfile);</span>
<span class="line-removed">-                     if (nl != null) {</span>
<span class="line-removed">-                         return nl;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
          }
          // Oops, it failed
          throw new UnsatisfiedLinkError(&quot;no &quot; + name +
<span class="line-modified">!             &quot; in java.library.path: &quot; + Arrays.toString(LibraryPaths.USER));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private static native String findBuiltinLib(String name);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private static NativeLibrary loadLibrary0(Class&lt;?&gt; fromClass, final File file) {</span>
<span class="line-removed">-         // Check to see if we&#39;re attempting to access a static library</span>
<span class="line-removed">-         String name = findBuiltinLib(file.getName());</span>
<span class="line-removed">-         boolean isBuiltin = (name != null);</span>
<span class="line-removed">-         if (!isBuiltin) {</span>
<span class="line-removed">-             name = AccessController.doPrivileged(</span>
<span class="line-removed">-                 new PrivilegedAction&lt;&gt;() {</span>
<span class="line-removed">-                     public String run() {</span>
<span class="line-removed">-                         try {</span>
<span class="line-removed">-                             return file.exists() ? file.getCanonicalPath() : null;</span>
<span class="line-removed">-                         } catch (IOException e) {</span>
<span class="line-removed">-                             return null;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 });</span>
<span class="line-removed">-             if (name == null) {</span>
<span class="line-removed">-                 return null;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return NativeLibrary.loadLibrary(fromClass, name, isBuiltin);</span>
      }
  
      /*
       * Invoked in the VM class linking code.
       */
      private static long findNative(ClassLoader loader, String entryName) {
<span class="line-modified">!         Map&lt;String, NativeLibrary&gt; libs =</span>
<span class="line-modified">!             loader != null ? loader.nativeLibraries() : systemNativeLibraries();</span>
<span class="line-modified">!         if (libs.isEmpty())</span>
<span class="line-modified">!             return 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // the native libraries map may be updated in another thread</span>
<span class="line-removed">-         // when a native library is being loaded.  No symbol will be</span>
<span class="line-removed">-         // searched from it yet.</span>
<span class="line-removed">-         for (NativeLibrary lib : libs.values()) {</span>
<span class="line-removed">-             long entry = lib.findEntry(entryName);</span>
<span class="line-removed">-             if (entry != 0) return entry;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // All native library names we&#39;ve loaded.</span>
<span class="line-removed">-     // This also serves as the lock to obtain nativeLibraries</span>
<span class="line-removed">-     // and write to nativeLibraryContext.</span>
<span class="line-removed">-     private static final Set&lt;String&gt; loadedLibraryNames = new HashSet&lt;&gt;();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Native libraries belonging to system classes.</span>
<span class="line-removed">-     private static volatile Map&lt;String, NativeLibrary&gt; systemNativeLibraries;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Native libraries associated with the class loader.</span>
<span class="line-removed">-     private volatile Map&lt;String, NativeLibrary&gt; nativeLibraries;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * Returns the native libraries map associated with bootstrap class loader</span>
<span class="line-removed">-      * This method will create the map at the first time when called.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static Map&lt;String, NativeLibrary&gt; systemNativeLibraries() {</span>
<span class="line-removed">-         Map&lt;String, NativeLibrary&gt; libs = systemNativeLibraries;</span>
<span class="line-removed">-         if (libs == null) {</span>
<span class="line-removed">-             synchronized (loadedLibraryNames) {</span>
<span class="line-removed">-                 libs = systemNativeLibraries;</span>
<span class="line-removed">-                 if (libs == null) {</span>
<span class="line-removed">-                     libs = systemNativeLibraries = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return libs;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * Returns the native libraries map associated with this class loader</span>
<span class="line-removed">-      * This method will create the map at the first time when called.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private Map&lt;String, NativeLibrary&gt; nativeLibraries() {</span>
<span class="line-removed">-         Map&lt;String, NativeLibrary&gt; libs = nativeLibraries;</span>
<span class="line-removed">-         if (libs == null) {</span>
<span class="line-removed">-             synchronized (loadedLibraryNames) {</span>
<span class="line-removed">-                 libs = nativeLibraries;</span>
<span class="line-removed">-                 if (libs == null) {</span>
<span class="line-removed">-                     libs = nativeLibraries = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
          }
<span class="line-removed">-         return libs;</span>
      }
  
      // -- Assertion management --
  
      final Object assertionLock;
<span class="line-new-header">--- 2372,68 ---</span>
       */
      protected String findLibrary(String libname) {
          return null;
      }
  
<span class="line-modified">!     private final NativeLibraries libraries = new NativeLibraries(this);</span>
  
<span class="line-modified">!     // Invoked in the java.lang.Runtime class to implement load and loadLibrary.</span>
<span class="line-modified">!     static NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, File file) {</span>
<span class="line-modified">!         ClassLoader loader = (fromClass == null) ? null : fromClass.getClassLoader();</span>
<span class="line-modified">!         NativeLibraries libs = loader != null ? loader.libraries : BootLoader.getNativeLibraries();</span>
<span class="line-modified">!         NativeLibrary nl = libs.loadLibrary(fromClass, file);</span>
<span class="line-modified">!         if (nl != null) {</span>
<span class="line-modified">!             return nl;</span>
          }
<span class="line-modified">!         throw new UnsatisfiedLinkError(&quot;Can&#39;t load library: &quot; + file);</span>
      }
<span class="line-modified">!     static NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, String name) {</span>
<span class="line-modified">!         ClassLoader loader = (fromClass == null) ? null : fromClass.getClassLoader();</span>
<span class="line-modified">!         if (loader == null) {</span>
<span class="line-modified">!             NativeLibrary nl = BootLoader.getNativeLibraries().loadLibrary(fromClass, name);</span>
              if (nl != null) {
                  return nl;
              }
<span class="line-modified">!             throw new UnsatisfiedLinkError(&quot;no &quot; + name +</span>
<span class="line-added">+                     &quot; in system library path: &quot; + StaticProperty.sunBootLibraryPath());</span>
          }
<span class="line-modified">! </span>
<span class="line-modified">!         NativeLibraries libs = loader.libraries;</span>
<span class="line-modified">!         // First load from the file returned from ClassLoader::findLibrary, if found.</span>
<span class="line-modified">!         String libfilename = loader.findLibrary(name);</span>
<span class="line-modified">!         if (libfilename != null) {</span>
<span class="line-modified">!             File libfile = new File(libfilename);</span>
<span class="line-added">+             if (!libfile.isAbsolute()) {</span>
<span class="line-added">+                 throw new UnsatisfiedLinkError(</span>
                          &quot;ClassLoader.findLibrary failed to return an absolute path: &quot; + libfilename);
              }
<span class="line-modified">!             NativeLibrary nl = libs.loadLibrary(fromClass, libfile);</span>
              if (nl != null) {
                  return nl;
              }
<span class="line-modified">!             throw new UnsatisfiedLinkError(&quot;Can&#39;t load &quot; + libfilename);</span>
          }
<span class="line-modified">!         // Then load from system library path and java library path</span>
<span class="line-modified">!         NativeLibrary nl = libs.loadLibrary(fromClass, name);</span>
<span class="line-modified">!         if (nl != null) {</span>
<span class="line-modified">!             return nl;</span>
          }
<span class="line-added">+ </span>
          // Oops, it failed
          throw new UnsatisfiedLinkError(&quot;no &quot; + name +
<span class="line-modified">!                 &quot; in java.library.path: &quot; + StaticProperty.javaLibraryPath());</span>
      }
  
      /*
       * Invoked in the VM class linking code.
       */
      private static long findNative(ClassLoader loader, String entryName) {
<span class="line-modified">!         if (loader == null) {</span>
<span class="line-modified">!             return BootLoader.getNativeLibraries().find(entryName);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             return loader.libraries.find(entryName);</span>
          }
      }
  
      // -- Assertion management --
  
      final Object assertionLock;
</pre>
<center><a href="../../../../../hotspot/share/utilities/powerOfTwo.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ProcessBuilder.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/util/regex/RegExTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /**
  25  * @test
  26  * @summary tests RegExp framework (use -Dseed=X to set PRNG seed)
  27  * @author Mike McCloskey
  28  * @bug 4481568 4482696 4495089 4504687 4527731 4599621 4631553 4619345
  29  * 4630911 4672616 4711773 4727935 4750573 4792284 4803197 4757029 4808962
  30  * 4872664 4803179 4892980 4900747 4945394 4938995 4979006 4994840 4997476
  31  * 5013885 5003322 4988891 5098443 5110268 6173522 4829857 5027748 6376940
  32  * 6358731 6178785 6284152 6231989 6497148 6486934 6233084 6504326 6635133
  33  * 6350801 6676425 6878475 6919132 6931676 6948903 6990617 7014645 7039066
  34  * 7067045 7014640 7189363 8007395 8013252 8013254 8012646 8023647 6559590
  35  * 8027645 8035076 8039124 8035975 8074678 6854417 8143854 8147531 7071819
  36  * 8151481 4867170 7080302 6728861 6995635 6736245 4916384 6328855 6192895
  37  * 6345469 6988218 6693451 7006761 8140212 8143282 8158482 8176029 8184706
  38  * 8194667 8197462 8184692 8221431 8224789 8228352 8230829 8236034 8235812
  39  * 8216332
  40  *
  41  * @library /test/lib
  42  * @library /lib/testlibrary/java/lang
  43  * @build jdk.test.lib.RandomFactory
  44  * @run main RegExTest
  45  * @key randomness
  46  */
  47 
  48 import java.io.BufferedReader;
  49 import java.io.ByteArrayInputStream;
  50 import java.io.ByteArrayOutputStream;
  51 import java.io.File;
  52 import java.io.FileInputStream;
  53 import java.io.InputStreamReader;
  54 import java.io.ObjectInputStream;
  55 import java.io.ObjectOutputStream;
  56 import java.math.BigInteger;
  57 import java.nio.CharBuffer;
  58 import java.nio.file.Files;
  59 import java.nio.file.Path;
  60 import java.nio.file.Paths;
  61 import java.util.ArrayList;
  62 import java.util.Arrays;
  63 import java.util.HashMap;
  64 import java.util.List;
  65 import java.util.Map;
  66 import java.util.Random;
  67 import java.util.Scanner;
  68 import java.util.function.Function;
  69 import java.util.function.Predicate;
  70 import java.util.regex.Matcher;
  71 import java.util.regex.MatchResult;
  72 import java.util.regex.Pattern;
  73 import java.util.regex.PatternSyntaxException;
  74 import java.util.stream.Stream;
  75 
  76 import jdk.test.lib.RandomFactory;
  77 
  78 /**
  79  * This is a test class created to check the operation of
  80  * the Pattern and Matcher classes.
  81  */
  82 public class RegExTest {
  83 
  84     private static Random generator = RandomFactory.getRandom();
  85     private static boolean failure = false;
  86     private static int failCount = 0;
  87     private static String firstFailure = null;
  88 
  89     /**
  90      * Main to interpret arguments and run several tests.
  91      *
  92      */
  93     public static void main(String[] args) throws Exception {
  94         // Most of the tests are in a file
  95         processFile(&quot;TestCases.txt&quot;);
  96         //processFile(&quot;PerlCases.txt&quot;);
  97         processFile(&quot;BMPTestCases.txt&quot;);
  98         processFile(&quot;SupplementaryTestCases.txt&quot;);
  99 
 100         // These test many randomly generated char patterns
 101         bm();
 102         slice();
 103 
 104         // These are hard to put into the file
 105         escapes();
 106         blankInput();
 107 
 108         // Substitition tests on randomly generated sequences
 109         globalSubstitute();
 110         stringbufferSubstitute();
 111         stringbuilderSubstitute();
 112 
 113         substitutionBasher();
 114         substitutionBasher2();
 115 
 116         // Canonical Equivalence
 117         ceTest();
 118 
 119         // Anchors
 120         anchorTest();
 121 
 122         // boolean match calls
 123         matchesTest();
 124         lookingAtTest();
 125 
 126         // Pattern API
 127         patternMatchesTest();
 128 
 129         // Misc
 130         lookbehindTest();
 131         nullArgumentTest();
 132         backRefTest();
 133         groupCaptureTest();
 134         caretTest();
 135         charClassTest();
 136         emptyPatternTest();
 137         findIntTest();
 138         group0Test();
 139         longPatternTest();
 140         octalTest();
 141         ampersandTest();
 142         negationTest();
 143         splitTest();
 144         appendTest();
 145         caseFoldingTest();
 146         commentsTest();
 147         unixLinesTest();
 148         replaceFirstTest();
 149         gTest();
 150         zTest();
 151         serializeTest();
 152         reluctantRepetitionTest();
 153         multilineDollarTest();
 154         dollarAtEndTest();
 155         caretBetweenTerminatorsTest();
 156         // This RFE rejected in Tiger numOccurrencesTest();
 157         javaCharClassTest();
 158         nonCaptureRepetitionTest();
 159         notCapturedGroupCurlyMatchTest();
 160         escapedSegmentTest();
 161         literalPatternTest();
 162         literalReplacementTest();
 163         regionTest();
 164         toStringTest();
 165         negatedCharClassTest();
 166         findFromTest();
 167         boundsTest();
 168         unicodeWordBoundsTest();
 169         caretAtEndTest();
 170         wordSearchTest();
 171         hitEndTest();
 172         toMatchResultTest();
 173         toMatchResultTest2();
 174         surrogatesInClassTest();
 175         removeQEQuotingTest();
 176         namedGroupCaptureTest();
 177         nonBmpClassComplementTest();
 178         unicodePropertiesTest();
 179         unicodeHexNotationTest();
 180         unicodeClassesTest();
 181         unicodeCharacterNameTest();
 182         horizontalAndVerticalWSTest();
 183         linebreakTest();
 184         branchTest();
 185         groupCurlyNotFoundSuppTest();
 186         groupCurlyBackoffTest();
 187         patternAsPredicate();
 188         patternAsMatchPredicate();
 189         invalidFlags();
 190         embeddedFlags();
 191         grapheme();
 192         expoBacktracking();
 193         invalidGroupName();
 194         illegalRepetitionRange();
 195         surrogatePairWithCanonEq();
 196         lineBreakWithQuantifier();
 197 
 198         if (failure) {
 199             throw new
 200                 RuntimeException(&quot;RegExTest failed, 1st failure: &quot; +
 201                                  firstFailure);
 202         } else {
 203             System.err.println(&quot;OKAY: All tests passed.&quot;);
 204         }
 205     }
 206 
 207     // Utility functions
 208 
 209     private static String getRandomAlphaString(int length) {
 210         StringBuffer buf = new StringBuffer(length);
 211         for (int i=0; i&lt;length; i++) {
 212             char randChar = (char)(97 + generator.nextInt(26));
 213             buf.append(randChar);
 214         }
 215         return buf.toString();
 216     }
 217 
 218     private static void check(Matcher m, String expected) {
 219         m.find();
 220         if (!m.group().equals(expected))
 221             failCount++;
 222     }
 223 
 224     private static void check(Matcher m, String result, boolean expected) {
 225         m.find();
 226         if (m.group().equals(result) != expected)
 227             failCount++;
 228     }
 229 
 230     private static void check(Pattern p, String s, boolean expected) {
 231         if (p.matcher(s).find() != expected)
 232             failCount++;
 233     }
 234 
 235     private static void check(String p, String s, boolean expected) {
 236         Matcher matcher = Pattern.compile(p).matcher(s);
 237         if (matcher.find() != expected)
 238             failCount++;
 239     }
 240 
 241     private static void check(String p, char c, boolean expected) {
 242         String propertyPattern = expected ? &quot;\\p&quot; + p : &quot;\\P&quot; + p;
 243         Pattern pattern = Pattern.compile(propertyPattern);
 244         char[] ca = new char[1]; ca[0] = c;
 245         Matcher matcher = pattern.matcher(new String(ca));
 246         if (!matcher.find())
 247             failCount++;
 248     }
 249 
 250     private static void check(String p, int codePoint, boolean expected) {
 251         String propertyPattern = expected ? &quot;\\p&quot; + p : &quot;\\P&quot; + p;
 252         Pattern pattern = Pattern.compile(propertyPattern);
 253         char[] ca = Character.toChars(codePoint);
 254         Matcher matcher = pattern.matcher(new String(ca));
 255         if (!matcher.find())
 256             failCount++;
 257     }
 258 
 259     private static void check(String p, int flag, String input, String s,
 260                               boolean expected)
 261     {
 262         Pattern pattern = Pattern.compile(p, flag);
 263         Matcher matcher = pattern.matcher(input);
 264         if (expected)
 265             check(matcher, s, expected);
 266         else
 267             check(pattern, input, false);
 268     }
 269 
 270     private static void report(String testName) {
 271         int spacesToAdd = 30 - testName.length();
 272         StringBuffer paddedNameBuffer = new StringBuffer(testName);
 273         for (int i=0; i&lt;spacesToAdd; i++)
 274             paddedNameBuffer.append(&quot; &quot;);
 275         String paddedName = paddedNameBuffer.toString();
 276         System.err.println(paddedName + &quot;: &quot; +
 277                            (failCount==0 ? &quot;Passed&quot;:&quot;Failed(&quot;+failCount+&quot;)&quot;));
 278         if (failCount &gt; 0) {
 279             failure = true;
 280 
 281             if (firstFailure == null) {
 282                 firstFailure = testName;
 283             }
 284         }
 285 
 286         failCount = 0;
 287     }
 288 
 289     /**
 290      * Converts ASCII alphabet characters [A-Za-z] in the given &#39;s&#39; to
 291      * supplementary characters. This method does NOT fully take care
 292      * of the regex syntax.
 293      */
 294     private static String toSupplementaries(String s) {
 295         int length = s.length();
 296         StringBuffer sb = new StringBuffer(length * 2);
 297 
 298         for (int i = 0; i &lt; length; ) {
 299             char c = s.charAt(i++);
 300             if (c == &#39;\\&#39;) {
 301                 sb.append(c);
 302                 if (i &lt; length) {
 303                     c = s.charAt(i++);
 304                     sb.append(c);
 305                     if (c == &#39;u&#39;) {
 306                         // assume no syntax error
 307                         sb.append(s.charAt(i++));
 308                         sb.append(s.charAt(i++));
 309                         sb.append(s.charAt(i++));
 310                         sb.append(s.charAt(i++));
 311                     }
 312                 }
 313             } else if ((c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) || (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;)) {
 314                 sb.append(&#39;\ud800&#39;).append((char)(&#39;\udc00&#39;+c));
 315             } else {
 316                 sb.append(c);
 317             }
 318         }
 319         return sb.toString();
 320     }
 321 
 322     // Regular expression tests
 323 
 324     // This is for bug 6178785
 325     // Test if an expected NPE gets thrown when passing in a null argument
 326     private static boolean check(Runnable test) {
 327         try {
 328             test.run();
 329             failCount++;
 330             return false;
 331         } catch (NullPointerException npe) {
 332             return true;
 333         }
 334     }
 335 
 336     private static void nullArgumentTest() {
 337         check(() -&gt; Pattern.compile(null));
 338         check(() -&gt; Pattern.matches(null, null));
 339         check(() -&gt; Pattern.matches(&quot;xyz&quot;, null));
 340         check(() -&gt; Pattern.quote(null));
 341         check(() -&gt; Pattern.compile(&quot;xyz&quot;).split(null));
 342         check(() -&gt; Pattern.compile(&quot;xyz&quot;).matcher(null));
 343 
 344         final Matcher m = Pattern.compile(&quot;xyz&quot;).matcher(&quot;xyz&quot;);
 345         m.matches();
 346         check(() -&gt; m.appendTail((StringBuffer) null));
 347         check(() -&gt; m.appendTail((StringBuilder)null));
 348         check(() -&gt; m.replaceAll((String) null));
 349         check(() -&gt; m.replaceAll((Function&lt;MatchResult, String&gt;)null));
 350         check(() -&gt; m.replaceFirst((String)null));
 351         check(() -&gt; m.replaceFirst((Function&lt;MatchResult, String&gt;) null));
 352         check(() -&gt; m.appendReplacement((StringBuffer)null, null));
 353         check(() -&gt; m.appendReplacement((StringBuilder)null, null));
 354         check(() -&gt; m.reset(null));
 355         check(() -&gt; Matcher.quoteReplacement(null));
 356         //check(() -&gt; m.usePattern(null));
 357 
 358         report(&quot;Null Argument&quot;);
 359     }
 360 
 361     // This is for bug6635133
 362     // Test if surrogate pair in Unicode escapes can be handled correctly.
 363     private static void surrogatesInClassTest() throws Exception {
 364         Pattern pattern = Pattern.compile(&quot;[\\ud834\\udd21-\\ud834\\udd24]&quot;);
 365         Matcher matcher = pattern.matcher(&quot;\ud834\udd22&quot;);
 366         if (!matcher.find())
 367             failCount++;
 368 
 369         report(&quot;Surrogate pair in Unicode escape&quot;);
 370     }
 371 
 372     // This is for bug6990617
 373     // Test if Pattern.RemoveQEQuoting works correctly if the octal unicode
 374     // char encoding is only 2 or 3 digits instead of 4 and the first quoted
 375     // char is an octal digit.
 376     private static void removeQEQuotingTest() throws Exception {
 377         Pattern pattern =
 378             Pattern.compile(&quot;\\011\\Q1sometext\\E\\011\\Q2sometext\\E&quot;);
 379         Matcher matcher = pattern.matcher(&quot;\t1sometext\t2sometext&quot;);
 380         if (!matcher.find())
 381             failCount++;
 382 
 383         report(&quot;Remove Q/E Quoting&quot;);
 384     }
 385 
 386     // This is for bug 4988891
 387     // Test toMatchResult to see that it is a copy of the Matcher
 388     // that is not affected by subsequent operations on the original
 389     private static void toMatchResultTest() throws Exception {
 390         Pattern pattern = Pattern.compile(&quot;squid&quot;);
 391         Matcher matcher = pattern.matcher(
 392             &quot;agiantsquidofdestinyasmallsquidoffate&quot;);
 393         matcher.find();
 394         int matcherStart1 = matcher.start();
 395         MatchResult mr = matcher.toMatchResult();
 396         if (mr == matcher)
 397             failCount++;
 398         int resultStart1 = mr.start();
 399         if (matcherStart1 != resultStart1)
 400             failCount++;
 401         matcher.find();
 402         int matcherStart2 = matcher.start();
 403         int resultStart2 = mr.start();
 404         if (matcherStart2 == resultStart2)
 405             failCount++;
 406         if (resultStart1 != resultStart2)
 407             failCount++;
 408         MatchResult mr2 = matcher.toMatchResult();
 409         if (mr == mr2)
 410             failCount++;
 411         if (mr2.start() != matcherStart2)
 412             failCount++;
 413         report(&quot;toMatchResult is a copy&quot;);
 414     }
 415 
 416     private static void checkExpectedISE(Runnable test) {
 417         try {
 418             test.run();
 419             failCount++;
 420         } catch (IllegalStateException x) {
 421         } catch (IndexOutOfBoundsException xx) {
 422             failCount++;
 423         }
 424     }
 425 
 426     private static void checkExpectedIOOE(Runnable test) {
 427         try {
 428             test.run();
 429             failCount++;
 430         } catch (IndexOutOfBoundsException x) {}
 431     }
 432 
 433     // This is for bug 8074678
 434     // Test the result of toMatchResult throws ISE if no match is availble
 435     private static void toMatchResultTest2() throws Exception {
 436         Matcher matcher = Pattern.compile(&quot;nomatch&quot;).matcher(&quot;hello world&quot;);
 437         matcher.find();
 438         MatchResult mr = matcher.toMatchResult();
 439 
 440         checkExpectedISE(() -&gt; mr.start());
 441         checkExpectedISE(() -&gt; mr.start(2));
 442         checkExpectedISE(() -&gt; mr.end());
 443         checkExpectedISE(() -&gt; mr.end(2));
 444         checkExpectedISE(() -&gt; mr.group());
 445         checkExpectedISE(() -&gt; mr.group(2));
 446 
 447         matcher = Pattern.compile(&quot;(match)&quot;).matcher(&quot;there is a match&quot;);
 448         matcher.find();
 449         MatchResult mr2 = matcher.toMatchResult();
 450         checkExpectedIOOE(() -&gt; mr2.start(2));
 451         checkExpectedIOOE(() -&gt; mr2.end(2));
 452         checkExpectedIOOE(() -&gt; mr2.group(2));
 453 
 454         report(&quot;toMatchResult2 appropriate exceptions&quot;);
 455     }
 456 
 457     // This is for bug 5013885
 458     // Must test a slice to see if it reports hitEnd correctly
 459     private static void hitEndTest() throws Exception {
 460         // Basic test of Slice node
 461         Pattern p = Pattern.compile(&quot;^squidattack&quot;);
 462         Matcher m = p.matcher(&quot;squack&quot;);
 463         m.find();
 464         if (m.hitEnd())
 465             failCount++;
 466         m.reset(&quot;squid&quot;);
 467         m.find();
 468         if (!m.hitEnd())
 469             failCount++;
 470 
 471         // Test Slice, SliceA and SliceU nodes
 472         for (int i=0; i&lt;3; i++) {
 473             int flags = 0;
 474             if (i==1) flags = Pattern.CASE_INSENSITIVE;
 475             if (i==2) flags = Pattern.UNICODE_CASE;
 476             p = Pattern.compile(&quot;^abc&quot;, flags);
 477             m = p.matcher(&quot;ad&quot;);
 478             m.find();
 479             if (m.hitEnd())
 480                 failCount++;
 481             m.reset(&quot;ab&quot;);
 482             m.find();
 483             if (!m.hitEnd())
 484                 failCount++;
 485         }
 486 
 487         // Test Boyer-Moore node
 488         p = Pattern.compile(&quot;catattack&quot;);
 489         m = p.matcher(&quot;attack&quot;);
 490         m.find();
 491         if (!m.hitEnd())
 492             failCount++;
 493 
 494         p = Pattern.compile(&quot;catattack&quot;);
 495         m = p.matcher(&quot;attackattackattackcatatta&quot;);
 496         m.find();
 497         if (!m.hitEnd())
 498             failCount++;
 499 
 500         // 8184706: Matching u+0d at EOL against \R should hit-end
 501         p = Pattern.compile(&quot;...\\R&quot;);
 502         m = p.matcher(&quot;cat&quot; + (char)0x0a);
 503         m.find();
 504         if (m.hitEnd())
 505             failCount++;
 506 
 507         m = p.matcher(&quot;cat&quot; + (char)0x0d);
 508         m.find();
 509         if (!m.hitEnd())
 510             failCount++;
 511 
 512         m = p.matcher(&quot;cat&quot; + (char)0x0d + (char)0x0a);
 513         m.find();
 514         if (m.hitEnd())
 515             failCount++;
 516 
 517         report(&quot;hitEnd&quot;);
 518     }
 519 
 520     // This is for bug 4997476
 521     // It is weird code submitted by customer demonstrating a regression
 522     private static void wordSearchTest() throws Exception {
 523         String testString = new String(&quot;word1 word2 word3&quot;);
 524         Pattern p = Pattern.compile(&quot;\\b&quot;);
 525         Matcher m = p.matcher(testString);
 526         int position = 0;
 527         int start = 0;
 528         while (m.find(position)) {
 529             start = m.start();
 530             if (start == testString.length())
 531                 break;
 532             if (m.find(start+1)) {
 533                 position = m.start();
 534             } else {
 535                 position = testString.length();
 536             }
 537             if (testString.substring(start, position).equals(&quot; &quot;))
 538                 continue;
 539             if (!testString.substring(start, position-1).startsWith(&quot;word&quot;))
 540                 failCount++;
 541         }
 542         report(&quot;Customer word search&quot;);
 543     }
 544 
 545     // This is for bug 4994840
 546     private static void caretAtEndTest() throws Exception {
 547         // Problem only occurs with multiline patterns
 548         // containing a beginning-of-line caret &quot;^&quot; followed
 549         // by an expression that also matches the empty string.
 550         Pattern pattern = Pattern.compile(&quot;^x?&quot;, Pattern.MULTILINE);
 551         Matcher matcher = pattern.matcher(&quot;\r&quot;);
 552         matcher.find();
 553         matcher.find();
 554         report(&quot;Caret at end&quot;);
 555     }
 556 
 557     // This test is for 4979006
 558     // Check to see if word boundary construct properly handles unicode
 559     // non spacing marks
 560     private static void unicodeWordBoundsTest() throws Exception {
 561         String spaces = &quot;  &quot;;
 562         String wordChar = &quot;a&quot;;
 563         String nsm = &quot;\u030a&quot;;
 564 
 565         assert (Character.getType(&#39;\u030a&#39;) == Character.NON_SPACING_MARK);
 566 
 567         Pattern pattern = Pattern.compile(&quot;\\b&quot;);
 568         Matcher matcher = pattern.matcher(&quot;&quot;);
 569         // S=other B=word character N=non spacing mark .=word boundary
 570         // SS.BB.SS
 571         String input = spaces + wordChar + wordChar + spaces;
 572         twoFindIndexes(input, matcher, 2, 4);
 573         // SS.BBN.SS
 574         input = spaces + wordChar +wordChar + nsm + spaces;
 575         twoFindIndexes(input, matcher, 2, 5);
 576         // SS.BN.SS
 577         input = spaces + wordChar + nsm + spaces;
 578         twoFindIndexes(input, matcher, 2, 4);
 579         // SS.BNN.SS
 580         input = spaces + wordChar + nsm + nsm + spaces;
 581         twoFindIndexes(input, matcher, 2, 5);
 582         // SSN.BB.SS
 583         input = spaces + nsm + wordChar + wordChar + spaces;
 584         twoFindIndexes(input, matcher, 3, 5);
 585         // SS.BNB.SS
 586         input = spaces + wordChar + nsm + wordChar + spaces;
 587         twoFindIndexes(input, matcher, 2, 5);
 588         // SSNNSS
 589         input = spaces + nsm + nsm + spaces;
 590         matcher.reset(input);
 591         if (matcher.find())
 592             failCount++;
 593         // SSN.BBN.SS
 594         input = spaces + nsm + wordChar + wordChar + nsm + spaces;
 595         twoFindIndexes(input, matcher, 3, 6);
 596 
 597         report(&quot;Unicode word boundary&quot;);
 598     }
 599 
 600     private static void twoFindIndexes(String input, Matcher matcher, int a,
 601                                        int b) throws Exception
 602     {
 603         matcher.reset(input);
 604         matcher.find();
 605         if (matcher.start() != a)
 606             failCount++;
 607         matcher.find();
 608         if (matcher.start() != b)
 609             failCount++;
 610     }
 611 
 612     // This test is for 6284152
 613     static void check(String regex, String input, String[] expected) {
 614         List&lt;String&gt; result = new ArrayList&lt;String&gt;();
 615         Pattern p = Pattern.compile(regex);
 616         Matcher m = p.matcher(input);
 617         while (m.find()) {
 618             result.add(m.group());
 619         }
 620         if (!Arrays.asList(expected).equals(result))
 621             failCount++;
 622     }
 623 
 624     private static void lookbehindTest() throws Exception {
 625         //Positive
 626         check(&quot;(?&lt;=%.{0,5})foo\\d&quot;,
 627               &quot;%foo1\n%bar foo2\n%bar  foo3\n%blahblah foo4\nfoo5&quot;,
 628               new String[]{&quot;foo1&quot;, &quot;foo2&quot;, &quot;foo3&quot;});
 629 
 630         //boundary at end of the lookbehind sub-regex should work consistently
 631         //with the boundary just after the lookbehind sub-regex
 632         check(&quot;(?&lt;=.*\\b)foo&quot;, &quot;abcd foo&quot;, new String[]{&quot;foo&quot;});
 633         check(&quot;(?&lt;=.*)\\bfoo&quot;, &quot;abcd foo&quot;, new String[]{&quot;foo&quot;});
 634         check(&quot;(?&lt;!abc )\\bfoo&quot;, &quot;abc foo&quot;, new String[0]);
 635         check(&quot;(?&lt;!abc \\b)foo&quot;, &quot;abc foo&quot;, new String[0]);
 636 
 637         //Negative
 638         check(&quot;(?&lt;!%.{0,5})foo\\d&quot;,
 639               &quot;%foo1\n%bar foo2\n%bar  foo3\n%blahblah foo4\nfoo5&quot;,
 640               new String[] {&quot;foo4&quot;, &quot;foo5&quot;});
 641 
 642         //Positive greedy
 643         check(&quot;(?&lt;=%b{1,4})foo&quot;, &quot;%bbbbfoo&quot;, new String[] {&quot;foo&quot;});
 644 
 645         //Positive reluctant
 646         check(&quot;(?&lt;=%b{1,4}?)foo&quot;, &quot;%bbbbfoo&quot;, new String[] {&quot;foo&quot;});
 647 
 648         //supplementary
 649         check(&quot;(?&lt;=%b{1,4})fo\ud800\udc00o&quot;, &quot;%bbbbfo\ud800\udc00o&quot;,
 650               new String[] {&quot;fo\ud800\udc00o&quot;});
 651         check(&quot;(?&lt;=%b{1,4}?)fo\ud800\udc00o&quot;, &quot;%bbbbfo\ud800\udc00o&quot;,
 652               new String[] {&quot;fo\ud800\udc00o&quot;});
 653         check(&quot;(?&lt;!%b{1,4})fo\ud800\udc00o&quot;, &quot;%afo\ud800\udc00o&quot;,
 654               new String[] {&quot;fo\ud800\udc00o&quot;});
 655         check(&quot;(?&lt;!%b{1,4}?)fo\ud800\udc00o&quot;, &quot;%afo\ud800\udc00o&quot;,
 656               new String[] {&quot;fo\ud800\udc00o&quot;});
 657         report(&quot;Lookbehind&quot;);
 658     }
 659 
 660     // This test is for 4938995
 661     // Check to see if weak region boundaries are transparent to
 662     // lookahead and lookbehind constructs
 663     private static void boundsTest() throws Exception {
 664         String fullMessage = &quot;catdogcat&quot;;
 665         Pattern pattern = Pattern.compile(&quot;(?&lt;=cat)dog(?=cat)&quot;);
 666         Matcher matcher = pattern.matcher(&quot;catdogca&quot;);
 667         matcher.useTransparentBounds(true);
 668         if (matcher.find())
 669             failCount++;
 670         matcher.reset(&quot;atdogcat&quot;);
 671         if (matcher.find())
 672             failCount++;
 673         matcher.reset(fullMessage);
 674         if (!matcher.find())
 675             failCount++;
 676         matcher.reset(fullMessage);
 677         matcher.region(0,9);
 678         if (!matcher.find())
 679             failCount++;
 680         matcher.reset(fullMessage);
 681         matcher.region(0,6);
 682         if (!matcher.find())
 683             failCount++;
 684         matcher.reset(fullMessage);
 685         matcher.region(3,6);
 686         if (!matcher.find())
 687             failCount++;
 688         matcher.useTransparentBounds(false);
 689         if (matcher.find())
 690             failCount++;
 691 
 692         // Negative lookahead/lookbehind
 693         pattern = Pattern.compile(&quot;(?&lt;!cat)dog(?!cat)&quot;);
 694         matcher = pattern.matcher(&quot;dogcat&quot;);
 695         matcher.useTransparentBounds(true);
 696         matcher.region(0,3);
 697         if (matcher.find())
 698             failCount++;
 699         matcher.reset(&quot;catdog&quot;);
 700         matcher.region(3,6);
 701         if (matcher.find())
 702             failCount++;
 703         matcher.useTransparentBounds(false);
 704         matcher.reset(&quot;dogcat&quot;);
 705         matcher.region(0,3);
 706         if (!matcher.find())
 707             failCount++;
 708         matcher.reset(&quot;catdog&quot;);
 709         matcher.region(3,6);
 710         if (!matcher.find())
 711             failCount++;
 712 
 713         report(&quot;Region bounds transparency&quot;);
 714     }
 715 
 716     // This test is for 4945394
 717     private static void findFromTest() throws Exception {
 718         String message = &quot;This is 40 $0 message.&quot;;
 719         Pattern pat = Pattern.compile(&quot;\\$0&quot;);
 720         Matcher match = pat.matcher(message);
 721         if (!match.find())
 722             failCount++;
 723         if (match.find())
 724             failCount++;
 725         if (match.find())
 726             failCount++;
 727         report(&quot;Check for alternating find&quot;);
 728     }
 729 
 730     // This test is for 4872664 and 4892980
 731     private static void negatedCharClassTest() throws Exception {
 732         Pattern pattern = Pattern.compile(&quot;[^&gt;]&quot;);
 733         Matcher matcher = pattern.matcher(&quot;\u203A&quot;);
 734         if (!matcher.matches())
 735             failCount++;
 736         pattern = Pattern.compile(&quot;[^fr]&quot;);
 737         matcher = pattern.matcher(&quot;a&quot;);
 738         if (!matcher.find())
 739             failCount++;
 740         matcher.reset(&quot;\u203A&quot;);
 741         if (!matcher.find())
 742             failCount++;
 743         String s = &quot;for&quot;;
 744         String result[] = s.split(&quot;[^fr]&quot;);
 745         if (!result[0].equals(&quot;f&quot;))
 746             failCount++;
 747         if (!result[1].equals(&quot;r&quot;))
 748             failCount++;
 749         s = &quot;f\u203Ar&quot;;
 750         result = s.split(&quot;[^fr]&quot;);
 751         if (!result[0].equals(&quot;f&quot;))
 752             failCount++;
 753         if (!result[1].equals(&quot;r&quot;))
 754             failCount++;
 755 
 756         // Test adding to bits, subtracting a node, then adding to bits again
 757         pattern = Pattern.compile(&quot;[^f\u203Ar]&quot;);
 758         matcher = pattern.matcher(&quot;a&quot;);
 759         if (!matcher.find())
 760             failCount++;
 761         matcher.reset(&quot;f&quot;);
 762         if (matcher.find())
 763             failCount++;
 764         matcher.reset(&quot;\u203A&quot;);
 765         if (matcher.find())
 766             failCount++;
 767         matcher.reset(&quot;r&quot;);
 768         if (matcher.find())
 769             failCount++;
 770         matcher.reset(&quot;\u203B&quot;);
 771         if (!matcher.find())
 772             failCount++;
 773 
 774         // Test subtracting a node, adding to bits, subtracting again
 775         pattern = Pattern.compile(&quot;[^\u203Ar\u203B]&quot;);
 776         matcher = pattern.matcher(&quot;a&quot;);
 777         if (!matcher.find())
 778             failCount++;
 779         matcher.reset(&quot;\u203A&quot;);
 780         if (matcher.find())
 781             failCount++;
 782         matcher.reset(&quot;r&quot;);
 783         if (matcher.find())
 784             failCount++;
 785         matcher.reset(&quot;\u203B&quot;);
 786         if (matcher.find())
 787             failCount++;
 788         matcher.reset(&quot;\u203C&quot;);
 789         if (!matcher.find())
 790             failCount++;
 791 
 792         report(&quot;Negated Character Class&quot;);
 793     }
 794 
 795     // This test is for 4628291
 796     private static void toStringTest() throws Exception {
 797         Pattern pattern = Pattern.compile(&quot;b+&quot;);
 798         if (pattern.toString() != &quot;b+&quot;)
 799             failCount++;
 800         Matcher matcher = pattern.matcher(&quot;aaabbbccc&quot;);
 801         String matcherString = matcher.toString(); // unspecified
 802         matcher.find();
 803         matcherString = matcher.toString(); // unspecified
 804         matcher.region(0,3);
 805         matcherString = matcher.toString(); // unspecified
 806         matcher.reset();
 807         matcherString = matcher.toString(); // unspecified
 808         report(&quot;toString&quot;);
 809     }
 810 
 811     // This test is for 4808962
 812     private static void literalPatternTest() throws Exception {
 813         int flags = Pattern.LITERAL;
 814 
 815         Pattern pattern = Pattern.compile(&quot;abc\\t$^&quot;, flags);
 816         check(pattern, &quot;abc\\t$^&quot;, true);
 817 
 818         pattern = Pattern.compile(Pattern.quote(&quot;abc\\t$^&quot;));
 819         check(pattern, &quot;abc\\t$^&quot;, true);
 820 
 821         pattern = Pattern.compile(&quot;\\Qa^$bcabc\\E&quot;, flags);
 822         check(pattern, &quot;\\Qa^$bcabc\\E&quot;, true);
 823         check(pattern, &quot;a^$bcabc&quot;, false);
 824 
 825         pattern = Pattern.compile(&quot;\\\\Q\\\\E&quot;);
 826         check(pattern, &quot;\\Q\\E&quot;, true);
 827 
 828         pattern = Pattern.compile(&quot;\\Qabc\\Eefg\\\\Q\\\\Ehij&quot;);
 829         check(pattern, &quot;abcefg\\Q\\Ehij&quot;, true);
 830 
 831         pattern = Pattern.compile(&quot;\\\\\\Q\\\\E&quot;);
 832         check(pattern, &quot;\\\\\\\\&quot;, true);
 833 
 834         pattern = Pattern.compile(Pattern.quote(&quot;\\Qa^$bcabc\\E&quot;));
 835         check(pattern, &quot;\\Qa^$bcabc\\E&quot;, true);
 836         check(pattern, &quot;a^$bcabc&quot;, false);
 837 
 838         pattern = Pattern.compile(Pattern.quote(&quot;\\Qabc\\Edef&quot;));
 839         check(pattern, &quot;\\Qabc\\Edef&quot;, true);
 840         check(pattern, &quot;abcdef&quot;, false);
 841 
 842         pattern = Pattern.compile(Pattern.quote(&quot;abc\\Edef&quot;));
 843         check(pattern, &quot;abc\\Edef&quot;, true);
 844         check(pattern, &quot;abcdef&quot;, false);
 845 
 846         pattern = Pattern.compile(Pattern.quote(&quot;\\E&quot;));
 847         check(pattern, &quot;\\E&quot;, true);
 848 
 849         pattern = Pattern.compile(&quot;((((abc.+?:)&quot;, flags);
 850         check(pattern, &quot;((((abc.+?:)&quot;, true);
 851 
 852         flags |= Pattern.MULTILINE;
 853 
 854         pattern = Pattern.compile(&quot;^cat$&quot;, flags);
 855         check(pattern, &quot;abc^cat$def&quot;, true);
 856         check(pattern, &quot;cat&quot;, false);
 857 
 858         flags |= Pattern.CASE_INSENSITIVE;
 859 
 860         pattern = Pattern.compile(&quot;abcdef&quot;, flags);
 861         check(pattern, &quot;ABCDEF&quot;, true);
 862         check(pattern, &quot;AbCdEf&quot;, true);
 863 
 864         flags |= Pattern.DOTALL;
 865 
 866         pattern = Pattern.compile(&quot;a...b&quot;, flags);
 867         check(pattern, &quot;A...b&quot;, true);
 868         check(pattern, &quot;Axxxb&quot;, false);
 869 
 870         flags |= Pattern.CANON_EQ;
 871 
 872         Pattern p = Pattern.compile(&quot;testa\u030a&quot;, flags);
 873         check(pattern, &quot;testa\u030a&quot;, false);
 874         check(pattern, &quot;test\u00e5&quot;, false);
 875 
 876         // Supplementary character test
 877         flags = Pattern.LITERAL;
 878 
 879         pattern = Pattern.compile(toSupplementaries(&quot;abc\\t$^&quot;), flags);
 880         check(pattern, toSupplementaries(&quot;abc\\t$^&quot;), true);
 881 
 882         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;abc\\t$^&quot;)));
 883         check(pattern, toSupplementaries(&quot;abc\\t$^&quot;), true);
 884 
 885         pattern = Pattern.compile(toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;), flags);
 886         check(pattern, toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;), true);
 887         check(pattern, toSupplementaries(&quot;a^$bcabc&quot;), false);
 888 
 889         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;)));
 890         check(pattern, toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;), true);
 891         check(pattern, toSupplementaries(&quot;a^$bcabc&quot;), false);
 892 
 893         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;\\Qabc\\Edef&quot;)));
 894         check(pattern, toSupplementaries(&quot;\\Qabc\\Edef&quot;), true);
 895         check(pattern, toSupplementaries(&quot;abcdef&quot;), false);
 896 
 897         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;abc\\Edef&quot;)));
 898         check(pattern, toSupplementaries(&quot;abc\\Edef&quot;), true);
 899         check(pattern, toSupplementaries(&quot;abcdef&quot;), false);
 900 
 901         pattern = Pattern.compile(toSupplementaries(&quot;((((abc.+?:)&quot;), flags);
 902         check(pattern, toSupplementaries(&quot;((((abc.+?:)&quot;), true);
 903 
 904         flags |= Pattern.MULTILINE;
 905 
 906         pattern = Pattern.compile(toSupplementaries(&quot;^cat$&quot;), flags);
 907         check(pattern, toSupplementaries(&quot;abc^cat$def&quot;), true);
 908         check(pattern, toSupplementaries(&quot;cat&quot;), false);
 909 
 910         flags |= Pattern.DOTALL;
 911 
 912         // note: this is case-sensitive.
 913         pattern = Pattern.compile(toSupplementaries(&quot;a...b&quot;), flags);
 914         check(pattern, toSupplementaries(&quot;a...b&quot;), true);
 915         check(pattern, toSupplementaries(&quot;axxxb&quot;), false);
 916 
 917         flags |= Pattern.CANON_EQ;
 918 
 919         String t = toSupplementaries(&quot;test&quot;);
 920         p = Pattern.compile(t + &quot;a\u030a&quot;, flags);
 921         check(pattern, t + &quot;a\u030a&quot;, false);
 922         check(pattern, t + &quot;\u00e5&quot;, false);
 923 
 924         report(&quot;Literal pattern&quot;);
 925     }
 926 
 927     // This test is for 4803179
 928     // This test is also for 4808962, replacement parts
 929     private static void literalReplacementTest() throws Exception {
 930         int flags = Pattern.LITERAL;
 931 
 932         Pattern pattern = Pattern.compile(&quot;abc&quot;, flags);
 933         Matcher matcher = pattern.matcher(&quot;zzzabczzz&quot;);
 934         String replaceTest = &quot;$0&quot;;
 935         String result = matcher.replaceAll(replaceTest);
 936         if (!result.equals(&quot;zzzabczzz&quot;))
 937             failCount++;
 938 
 939         matcher.reset();
 940         String literalReplacement = matcher.quoteReplacement(replaceTest);
 941         result = matcher.replaceAll(literalReplacement);
 942         if (!result.equals(&quot;zzz$0zzz&quot;))
 943             failCount++;
 944 
 945         matcher.reset();
 946         replaceTest = &quot;\\t$\\$&quot;;
 947         literalReplacement = matcher.quoteReplacement(replaceTest);
 948         result = matcher.replaceAll(literalReplacement);
 949         if (!result.equals(&quot;zzz\\t$\\$zzz&quot;))
 950             failCount++;
 951 
 952         // Supplementary character test
 953         pattern = Pattern.compile(toSupplementaries(&quot;abc&quot;), flags);
 954         matcher = pattern.matcher(toSupplementaries(&quot;zzzabczzz&quot;));
 955         replaceTest = &quot;$0&quot;;
 956         result = matcher.replaceAll(replaceTest);
 957         if (!result.equals(toSupplementaries(&quot;zzzabczzz&quot;)))
 958             failCount++;
 959 
 960         matcher.reset();
 961         literalReplacement = matcher.quoteReplacement(replaceTest);
 962         result = matcher.replaceAll(literalReplacement);
 963         if (!result.equals(toSupplementaries(&quot;zzz$0zzz&quot;)))
 964             failCount++;
 965 
 966         matcher.reset();
 967         replaceTest = &quot;\\t$\\$&quot;;
 968         literalReplacement = matcher.quoteReplacement(replaceTest);
 969         result = matcher.replaceAll(literalReplacement);
 970         if (!result.equals(toSupplementaries(&quot;zzz\\t$\\$zzz&quot;)))
 971             failCount++;
 972 
 973         // IAE should be thrown if backslash or &#39;$&#39; is the last character
 974         // in replacement string
 975         try {
 976             &quot;\uac00&quot;.replaceAll(&quot;\uac00&quot;, &quot;$&quot;);
 977             failCount++;
 978         } catch (IllegalArgumentException iie) {
 979         } catch (Exception e) {
 980             failCount++;
 981         }
 982         try {
 983             &quot;\uac00&quot;.replaceAll(&quot;\uac00&quot;, &quot;\\&quot;);
 984             failCount++;
 985         } catch (IllegalArgumentException iie) {
 986         } catch (Exception e) {
 987             failCount++;
 988         }
 989         report(&quot;Literal replacement&quot;);
 990     }
 991 
 992     // This test is for 4757029
 993     private static void regionTest() throws Exception {
 994         Pattern pattern = Pattern.compile(&quot;abc&quot;);
 995         Matcher matcher = pattern.matcher(&quot;abcdefabc&quot;);
 996 
 997         matcher.region(0,9);
 998         if (!matcher.find())
 999             failCount++;
1000         if (!matcher.find())
1001             failCount++;
1002         matcher.region(0,3);
1003         if (!matcher.find())
1004            failCount++;
1005         matcher.region(3,6);
1006         if (matcher.find())
1007            failCount++;
1008         matcher.region(0,2);
1009         if (matcher.find())
1010            failCount++;
1011 
1012         expectRegionFail(matcher, 1, -1);
1013         expectRegionFail(matcher, -1, -1);
1014         expectRegionFail(matcher, -1, 1);
1015         expectRegionFail(matcher, 5, 3);
1016         expectRegionFail(matcher, 5, 12);
1017         expectRegionFail(matcher, 12, 12);
1018 
1019         pattern = Pattern.compile(&quot;^abc$&quot;);
1020         matcher = pattern.matcher(&quot;zzzabczzz&quot;);
1021         matcher.region(0,9);
1022         if (matcher.find())
1023             failCount++;
1024         matcher.region(3,6);
1025         if (!matcher.find())
1026            failCount++;
1027         matcher.region(3,6);
1028         matcher.useAnchoringBounds(false);
1029         if (matcher.find())
1030            failCount++;
1031 
1032         // Supplementary character test
1033         pattern = Pattern.compile(toSupplementaries(&quot;abc&quot;));
1034         matcher = pattern.matcher(toSupplementaries(&quot;abcdefabc&quot;));
1035         matcher.region(0,9*2);
1036         if (!matcher.find())
1037             failCount++;
1038         if (!matcher.find())
1039             failCount++;
1040         matcher.region(0,3*2);
1041         if (!matcher.find())
1042            failCount++;
1043         matcher.region(1,3*2);
1044         if (matcher.find())
1045            failCount++;
1046         matcher.region(3*2,6*2);
1047         if (matcher.find())
1048            failCount++;
1049         matcher.region(0,2*2);
1050         if (matcher.find())
1051            failCount++;
1052         matcher.region(0,2*2+1);
1053         if (matcher.find())
1054            failCount++;
1055 
1056         expectRegionFail(matcher, 1*2, -1);
1057         expectRegionFail(matcher, -1, -1);
1058         expectRegionFail(matcher, -1, 1*2);
1059         expectRegionFail(matcher, 5*2, 3*2);
1060         expectRegionFail(matcher, 5*2, 12*2);
1061         expectRegionFail(matcher, 12*2, 12*2);
1062 
1063         pattern = Pattern.compile(toSupplementaries(&quot;^abc$&quot;));
1064         matcher = pattern.matcher(toSupplementaries(&quot;zzzabczzz&quot;));
1065         matcher.region(0,9*2);
1066         if (matcher.find())
1067             failCount++;
1068         matcher.region(3*2,6*2);
1069         if (!matcher.find())
1070            failCount++;
1071         matcher.region(3*2+1,6*2);
1072         if (matcher.find())
1073            failCount++;
1074         matcher.region(3*2,6*2-1);
1075         if (matcher.find())
1076            failCount++;
1077         matcher.region(3*2,6*2);
1078         matcher.useAnchoringBounds(false);
1079         if (matcher.find())
1080            failCount++;
1081 
1082         // JDK-8230829
1083         pattern = Pattern.compile(&quot;\\ud800\\udc61&quot;);
1084         matcher = pattern.matcher(&quot;\ud800\udc61&quot;);
1085         matcher.region(0, 1);
1086         if (matcher.find()) {
1087             failCount++;
1088             System.out.println(&quot;Matched a surrogate pair&quot; +
1089                     &quot; that crosses border of region&quot;);
1090         }
1091         if (!matcher.hitEnd()) {
1092             failCount++;
1093             System.out.println(&quot;Expected to hit the end when&quot; +
1094                     &quot; matching a surrogate pair crossing region&quot;);
1095         }
1096 
1097         report(&quot;Regions&quot;);
1098     }
1099 
1100     private static void expectRegionFail(Matcher matcher, int index1,
1101                                          int index2)
1102     {
1103         try {
1104             matcher.region(index1, index2);
1105             failCount++;
1106         } catch (IndexOutOfBoundsException ioobe) {
1107             // Correct result
1108         } catch (IllegalStateException ise) {
1109             // Correct result
1110         }
1111     }
1112 
1113     // This test is for 4803197
1114     private static void escapedSegmentTest() throws Exception {
1115 
1116         Pattern pattern = Pattern.compile(&quot;\\Qdir1\\dir2\\E&quot;);
1117         check(pattern, &quot;dir1\\dir2&quot;, true);
1118 
1119         pattern = Pattern.compile(&quot;\\Qdir1\\dir2\\\\E&quot;);
1120         check(pattern, &quot;dir1\\dir2\\&quot;, true);
1121 
1122         pattern = Pattern.compile(&quot;(\\Qdir1\\dir2\\\\E)&quot;);
1123         check(pattern, &quot;dir1\\dir2\\&quot;, true);
1124 
1125         // Supplementary character test
1126         pattern = Pattern.compile(toSupplementaries(&quot;\\Qdir1\\dir2\\E&quot;));
1127         check(pattern, toSupplementaries(&quot;dir1\\dir2&quot;), true);
1128 
1129         pattern = Pattern.compile(toSupplementaries(&quot;\\Qdir1\\dir2&quot;)+&quot;\\\\E&quot;);
1130         check(pattern, toSupplementaries(&quot;dir1\\dir2\\&quot;), true);
1131 
1132         pattern = Pattern.compile(toSupplementaries(&quot;(\\Qdir1\\dir2&quot;)+&quot;\\\\E)&quot;);
1133         check(pattern, toSupplementaries(&quot;dir1\\dir2\\&quot;), true);
1134 
1135         report(&quot;Escaped segment&quot;);
1136     }
1137 
1138     // This test is for 4792284
1139     private static void nonCaptureRepetitionTest() throws Exception {
1140         String input = &quot;abcdefgh;&quot;;
1141 
1142         String[] patterns = new String[] {
1143             &quot;(?:\\w{4})+;&quot;,
1144             &quot;(?:\\w{8})*;&quot;,
1145             &quot;(?:\\w{2}){2,4};&quot;,
1146             &quot;(?:\\w{4}){2,};&quot;,   // only matches the
1147             &quot;.*?(?:\\w{5})+;&quot;,   //     specified minimum
1148             &quot;.*?(?:\\w{9})*;&quot;,   //     number of reps - OK
1149             &quot;(?:\\w{4})+?;&quot;,     // lazy repetition - OK
1150             &quot;(?:\\w{4})++;&quot;,     // possessive repetition - OK
1151             &quot;(?:\\w{2,}?)+;&quot;,    // non-deterministic - OK
1152             &quot;(\\w{4})+;&quot;,        // capturing group - OK
1153         };
1154 
1155         for (int i = 0; i &lt; patterns.length; i++) {
1156             // Check find()
1157             check(patterns[i], 0, input, input, true);
1158             // Check matches()
1159             Pattern p = Pattern.compile(patterns[i]);
1160             Matcher m = p.matcher(input);
1161 
1162             if (m.matches()) {
1163                 if (!m.group(0).equals(input))
1164                     failCount++;
1165             } else {
1166                 failCount++;
1167             }
1168         }
1169 
1170         report(&quot;Non capturing repetition&quot;);
1171     }
1172 
1173     // This test is for 6358731
1174     private static void notCapturedGroupCurlyMatchTest() throws Exception {
1175         Pattern pattern = Pattern.compile(&quot;(abc)+|(abcd)+&quot;);
1176         Matcher matcher = pattern.matcher(&quot;abcd&quot;);
1177         if (!matcher.matches() ||
1178              matcher.group(1) != null ||
1179              !matcher.group(2).equals(&quot;abcd&quot;)) {
1180             failCount++;
1181         }
1182         report(&quot;Not captured GroupCurly&quot;);
1183     }
1184 
1185     // This test is for 4706545
1186     private static void javaCharClassTest() throws Exception {
1187         for (int i=0; i&lt;1000; i++) {
1188             char c = (char)generator.nextInt();
1189             check(&quot;{javaLowerCase}&quot;, c, Character.isLowerCase(c));
1190             check(&quot;{javaUpperCase}&quot;, c, Character.isUpperCase(c));
1191             check(&quot;{javaUpperCase}+&quot;, c, Character.isUpperCase(c));
1192             check(&quot;{javaTitleCase}&quot;, c, Character.isTitleCase(c));
1193             check(&quot;{javaDigit}&quot;, c, Character.isDigit(c));
1194             check(&quot;{javaDefined}&quot;, c, Character.isDefined(c));
1195             check(&quot;{javaLetter}&quot;, c, Character.isLetter(c));
1196             check(&quot;{javaLetterOrDigit}&quot;, c, Character.isLetterOrDigit(c));
1197             check(&quot;{javaJavaIdentifierStart}&quot;, c,
1198                   Character.isJavaIdentifierStart(c));
1199             check(&quot;{javaJavaIdentifierPart}&quot;, c,
1200                   Character.isJavaIdentifierPart(c));
1201             check(&quot;{javaUnicodeIdentifierStart}&quot;, c,
1202                   Character.isUnicodeIdentifierStart(c));
1203             check(&quot;{javaUnicodeIdentifierPart}&quot;, c,
1204                   Character.isUnicodeIdentifierPart(c));
1205             check(&quot;{javaIdentifierIgnorable}&quot;, c,
1206                   Character.isIdentifierIgnorable(c));
1207             check(&quot;{javaSpaceChar}&quot;, c, Character.isSpaceChar(c));
1208             check(&quot;{javaWhitespace}&quot;, c, Character.isWhitespace(c));
1209             check(&quot;{javaISOControl}&quot;, c, Character.isISOControl(c));
1210             check(&quot;{javaMirrored}&quot;, c, Character.isMirrored(c));
1211 
1212         }
1213 
1214         // Supplementary character test
1215         for (int i=0; i&lt;1000; i++) {
1216             int c = generator.nextInt(Character.MAX_CODE_POINT
1217                                       - Character.MIN_SUPPLEMENTARY_CODE_POINT)
1218                         + Character.MIN_SUPPLEMENTARY_CODE_POINT;
1219             check(&quot;{javaLowerCase}&quot;, c, Character.isLowerCase(c));
1220             check(&quot;{javaUpperCase}&quot;, c, Character.isUpperCase(c));
1221             check(&quot;{javaUpperCase}+&quot;, c, Character.isUpperCase(c));
1222             check(&quot;{javaTitleCase}&quot;, c, Character.isTitleCase(c));
1223             check(&quot;{javaDigit}&quot;, c, Character.isDigit(c));
1224             check(&quot;{javaDefined}&quot;, c, Character.isDefined(c));
1225             check(&quot;{javaLetter}&quot;, c, Character.isLetter(c));
1226             check(&quot;{javaLetterOrDigit}&quot;, c, Character.isLetterOrDigit(c));
1227             check(&quot;{javaJavaIdentifierStart}&quot;, c,
1228                   Character.isJavaIdentifierStart(c));
1229             check(&quot;{javaJavaIdentifierPart}&quot;, c,
1230                   Character.isJavaIdentifierPart(c));
1231             check(&quot;{javaUnicodeIdentifierStart}&quot;, c,
1232                   Character.isUnicodeIdentifierStart(c));
1233             check(&quot;{javaUnicodeIdentifierPart}&quot;, c,
1234                   Character.isUnicodeIdentifierPart(c));
1235             check(&quot;{javaIdentifierIgnorable}&quot;, c,
1236                   Character.isIdentifierIgnorable(c));
1237             check(&quot;{javaSpaceChar}&quot;, c, Character.isSpaceChar(c));
1238             check(&quot;{javaWhitespace}&quot;, c, Character.isWhitespace(c));
1239             check(&quot;{javaISOControl}&quot;, c, Character.isISOControl(c));
1240             check(&quot;{javaMirrored}&quot;, c, Character.isMirrored(c));
1241         }
1242 
1243         report(&quot;Java character classes&quot;);
1244     }
1245 
1246     // This test is for 4523620
1247     /*
1248     private static void numOccurrencesTest() throws Exception {
1249         Pattern pattern = Pattern.compile(&quot;aaa&quot;);
1250 
1251         if (pattern.numOccurrences(&quot;aaaaaa&quot;, false) != 2)
1252             failCount++;
1253         if (pattern.numOccurrences(&quot;aaaaaa&quot;, true) != 4)
1254             failCount++;
1255 
1256         pattern = Pattern.compile(&quot;^&quot;);
1257         if (pattern.numOccurrences(&quot;aaaaaa&quot;, false) != 1)
1258             failCount++;
1259         if (pattern.numOccurrences(&quot;aaaaaa&quot;, true) != 1)
1260             failCount++;
1261 
1262         report(&quot;Number of Occurrences&quot;);
1263     }
1264     */
1265 
1266     // This test is for 4776374
1267     private static void caretBetweenTerminatorsTest() throws Exception {
1268         int flags1 = Pattern.DOTALL;
1269         int flags2 = Pattern.DOTALL | Pattern.UNIX_LINES;
1270         int flags3 = Pattern.DOTALL | Pattern.UNIX_LINES | Pattern.MULTILINE;
1271         int flags4 = Pattern.DOTALL | Pattern.MULTILINE;
1272 
1273         check(&quot;^....&quot;, flags1, &quot;test\ntest&quot;, &quot;test&quot;, true);
1274         check(&quot;.....^&quot;, flags1, &quot;test\ntest&quot;, &quot;test&quot;, false);
1275         check(&quot;.....^&quot;, flags1, &quot;test\n&quot;, &quot;test&quot;, false);
1276         check(&quot;....^&quot;, flags1, &quot;test\r\n&quot;, &quot;test&quot;, false);
1277 
1278         check(&quot;^....&quot;, flags2, &quot;test\ntest&quot;, &quot;test&quot;, true);
1279         check(&quot;....^&quot;, flags2, &quot;test\ntest&quot;, &quot;test&quot;, false);
1280         check(&quot;.....^&quot;, flags2, &quot;test\n&quot;, &quot;test&quot;, false);
1281         check(&quot;....^&quot;, flags2, &quot;test\r\n&quot;, &quot;test&quot;, false);
1282 
1283         check(&quot;^....&quot;, flags3, &quot;test\ntest&quot;, &quot;test&quot;, true);
1284         check(&quot;.....^&quot;, flags3, &quot;test\ntest&quot;, &quot;test\n&quot;, true);
1285         check(&quot;.....^&quot;, flags3, &quot;test\u0085test&quot;, &quot;test\u0085&quot;, false);
1286         check(&quot;.....^&quot;, flags3, &quot;test\n&quot;, &quot;test&quot;, false);
1287         check(&quot;.....^&quot;, flags3, &quot;test\r\n&quot;, &quot;test&quot;, false);
1288         check(&quot;......^&quot;, flags3, &quot;test\r\ntest&quot;, &quot;test\r\n&quot;, true);
1289 
1290         check(&quot;^....&quot;, flags4, &quot;test\ntest&quot;, &quot;test&quot;, true);
1291         check(&quot;.....^&quot;, flags3, &quot;test\ntest&quot;, &quot;test\n&quot;, true);
1292         check(&quot;.....^&quot;, flags4, &quot;test\u0085test&quot;, &quot;test\u0085&quot;, true);
1293         check(&quot;.....^&quot;, flags4, &quot;test\n&quot;, &quot;test\n&quot;, false);
1294         check(&quot;.....^&quot;, flags4, &quot;test\r\n&quot;, &quot;test\r&quot;, false);
1295 
1296         // Supplementary character test
1297         String t = toSupplementaries(&quot;test&quot;);
1298         check(&quot;^....&quot;, flags1, t+&quot;\n&quot;+t, t, true);
1299         check(&quot;.....^&quot;, flags1, t+&quot;\n&quot;+t, t, false);
1300         check(&quot;.....^&quot;, flags1, t+&quot;\n&quot;, t, false);
1301         check(&quot;....^&quot;, flags1, t+&quot;\r\n&quot;, t, false);
1302 
1303         check(&quot;^....&quot;, flags2, t+&quot;\n&quot;+t, t, true);
1304         check(&quot;....^&quot;, flags2, t+&quot;\n&quot;+t, t, false);
1305         check(&quot;.....^&quot;, flags2, t+&quot;\n&quot;, t, false);
1306         check(&quot;....^&quot;, flags2, t+&quot;\r\n&quot;, t, false);
1307 
1308         check(&quot;^....&quot;, flags3, t+&quot;\n&quot;+t, t, true);
1309         check(&quot;.....^&quot;, flags3, t+&quot;\n&quot;+t, t+&quot;\n&quot;, true);
1310         check(&quot;.....^&quot;, flags3, t+&quot;\u0085&quot;+t, t+&quot;\u0085&quot;, false);
1311         check(&quot;.....^&quot;, flags3, t+&quot;\n&quot;, t, false);
1312         check(&quot;.....^&quot;, flags3, t+&quot;\r\n&quot;, t, false);
1313         check(&quot;......^&quot;, flags3, t+&quot;\r\n&quot;+t, t+&quot;\r\n&quot;, true);
1314 
1315         check(&quot;^....&quot;, flags4, t+&quot;\n&quot;+t, t, true);
1316         check(&quot;.....^&quot;, flags3, t+&quot;\n&quot;+t, t+&quot;\n&quot;, true);
1317         check(&quot;.....^&quot;, flags4, t+&quot;\u0085&quot;+t, t+&quot;\u0085&quot;, true);
1318         check(&quot;.....^&quot;, flags4, t+&quot;\n&quot;, t+&quot;\n&quot;, false);
1319         check(&quot;.....^&quot;, flags4, t+&quot;\r\n&quot;, t+&quot;\r&quot;, false);
1320 
1321         report(&quot;Caret between terminators&quot;);
1322     }
1323 
1324     // This test is for 4727935
1325     private static void dollarAtEndTest() throws Exception {
1326         int flags1 = Pattern.DOTALL;
1327         int flags2 = Pattern.DOTALL | Pattern.UNIX_LINES;
1328         int flags3 = Pattern.DOTALL | Pattern.MULTILINE;
1329 
1330         check(&quot;....$&quot;, flags1, &quot;test\n&quot;, &quot;test&quot;, true);
1331         check(&quot;....$&quot;, flags1, &quot;test\r\n&quot;, &quot;test&quot;, true);
1332         check(&quot;.....$&quot;, flags1, &quot;test\n&quot;, &quot;test\n&quot;, true);
1333         check(&quot;.....$&quot;, flags1, &quot;test\u0085&quot;, &quot;test\u0085&quot;, true);
1334         check(&quot;....$&quot;, flags1, &quot;test\u0085&quot;, &quot;test&quot;, true);
1335 
1336         check(&quot;....$&quot;, flags2, &quot;test\n&quot;, &quot;test&quot;, true);
1337         check(&quot;.....$&quot;, flags2, &quot;test\n&quot;, &quot;test\n&quot;, true);
1338         check(&quot;.....$&quot;, flags2, &quot;test\u0085&quot;, &quot;test\u0085&quot;, true);
1339         check(&quot;....$&quot;, flags2, &quot;test\u0085&quot;, &quot;est\u0085&quot;, true);
1340 
1341         check(&quot;....$.blah&quot;, flags3, &quot;test\nblah&quot;, &quot;test\nblah&quot;, true);
1342         check(&quot;.....$.blah&quot;, flags3, &quot;test\n\nblah&quot;, &quot;test\n\nblah&quot;, true);
1343         check(&quot;....$blah&quot;, flags3, &quot;test\nblah&quot;, &quot;!!!!&quot;, false);
1344         check(&quot;.....$blah&quot;, flags3, &quot;test\nblah&quot;, &quot;!!!!&quot;, false);
1345 
1346         // Supplementary character test
1347         String t = toSupplementaries(&quot;test&quot;);
1348         String b = toSupplementaries(&quot;blah&quot;);
1349         check(&quot;....$&quot;, flags1, t+&quot;\n&quot;, t, true);
1350         check(&quot;....$&quot;, flags1, t+&quot;\r\n&quot;, t, true);
1351         check(&quot;.....$&quot;, flags1, t+&quot;\n&quot;, t+&quot;\n&quot;, true);
1352         check(&quot;.....$&quot;, flags1, t+&quot;\u0085&quot;, t+&quot;\u0085&quot;, true);
1353         check(&quot;....$&quot;, flags1, t+&quot;\u0085&quot;, t, true);
1354 
1355         check(&quot;....$&quot;, flags2, t+&quot;\n&quot;, t, true);
1356         check(&quot;.....$&quot;, flags2, t+&quot;\n&quot;, t+&quot;\n&quot;, true);
1357         check(&quot;.....$&quot;, flags2, t+&quot;\u0085&quot;, t+&quot;\u0085&quot;, true);
1358         check(&quot;....$&quot;, flags2, t+&quot;\u0085&quot;, toSupplementaries(&quot;est\u0085&quot;), true);
1359 
1360         check(&quot;....$.&quot;+b, flags3, t+&quot;\n&quot;+b, t+&quot;\n&quot;+b, true);
1361         check(&quot;.....$.&quot;+b, flags3, t+&quot;\n\n&quot;+b, t+&quot;\n\n&quot;+b, true);
1362         check(&quot;....$&quot;+b, flags3, t+&quot;\n&quot;+b, &quot;!!!!&quot;, false);
1363         check(&quot;.....$&quot;+b, flags3, t+&quot;\n&quot;+b, &quot;!!!!&quot;, false);
1364 
1365         report(&quot;Dollar at End&quot;);
1366     }
1367 
1368     // This test is for 4711773
1369     private static void multilineDollarTest() throws Exception {
1370         Pattern findCR = Pattern.compile(&quot;$&quot;, Pattern.MULTILINE);
1371         Matcher matcher = findCR.matcher(&quot;first bit\nsecond bit&quot;);
1372         matcher.find();
1373         if (matcher.start(0) != 9)
1374             failCount++;
1375         matcher.find();
1376         if (matcher.start(0) != 20)
1377             failCount++;
1378 
1379         // Supplementary character test
1380         matcher = findCR.matcher(toSupplementaries(&quot;first  bit\n second  bit&quot;)); // double BMP chars
1381         matcher.find();
1382         if (matcher.start(0) != 9*2)
1383             failCount++;
1384         matcher.find();
1385         if (matcher.start(0) != 20*2)
1386             failCount++;
1387 
1388         report(&quot;Multiline Dollar&quot;);
1389     }
1390 
1391     private static void reluctantRepetitionTest() throws Exception {
1392         Pattern p = Pattern.compile(&quot;1(\\s\\S+?){1,3}?[\\s,]2&quot;);
1393         check(p, &quot;1 word word word 2&quot;, true);
1394         check(p, &quot;1 wor wo w 2&quot;, true);
1395         check(p, &quot;1 word word 2&quot;, true);
1396         check(p, &quot;1 word 2&quot;, true);
1397         check(p, &quot;1 wo w w 2&quot;, true);
1398         check(p, &quot;1 wo w 2&quot;, true);
1399         check(p, &quot;1 wor w 2&quot;, true);
1400 
1401         p = Pattern.compile(&quot;([a-z])+?c&quot;);
1402         Matcher m = p.matcher(&quot;ababcdefdec&quot;);
1403         check(m, &quot;ababc&quot;);
1404 
1405         // Supplementary character test
1406         p = Pattern.compile(toSupplementaries(&quot;([a-z])+?c&quot;));
1407         m = p.matcher(toSupplementaries(&quot;ababcdefdec&quot;));
1408         check(m, toSupplementaries(&quot;ababc&quot;));
1409 
1410         report(&quot;Reluctant Repetition&quot;);
1411     }
1412 
1413     private static Pattern serializedPattern(Pattern p) throws Exception {
1414         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1415         ObjectOutputStream oos = new ObjectOutputStream(baos);
1416         oos.writeObject(p);
1417         oos.close();
1418         try (ObjectInputStream ois = new ObjectInputStream(
1419                 new ByteArrayInputStream(baos.toByteArray()))) {
1420             return (Pattern)ois.readObject();
1421         }
1422     }
1423 
1424     private static void serializeTest() throws Exception {
1425         String patternStr = &quot;(b)&quot;;
1426         String matchStr = &quot;b&quot;;
1427         Pattern pattern = Pattern.compile(patternStr);
1428         Pattern serializedPattern = serializedPattern(pattern);
1429         Matcher matcher = serializedPattern.matcher(matchStr);
1430         if (!matcher.matches())
1431             failCount++;
1432         if (matcher.groupCount() != 1)
1433             failCount++;
1434 
1435         pattern = Pattern.compile(&quot;a(?-i)b&quot;, Pattern.CASE_INSENSITIVE);
1436         serializedPattern = serializedPattern(pattern);
1437         if (!serializedPattern.matcher(&quot;Ab&quot;).matches())
1438             failCount++;
1439         if (serializedPattern.matcher(&quot;AB&quot;).matches())
1440             failCount++;
1441 
1442         report(&quot;Serialization&quot;);
1443     }
1444 
1445     private static void gTest() {
1446         Pattern pattern = Pattern.compile(&quot;\\G\\w&quot;);
1447         Matcher matcher = pattern.matcher(&quot;abc#x#x&quot;);
1448         matcher.find();
1449         matcher.find();
1450         matcher.find();
1451         if (matcher.find())
1452             failCount++;
1453 
1454         pattern = Pattern.compile(&quot;\\GA*&quot;);
1455         matcher = pattern.matcher(&quot;1A2AA3&quot;);
1456         matcher.find();
1457         if (matcher.find())
1458             failCount++;
1459 
1460         pattern = Pattern.compile(&quot;\\GA*&quot;);
1461         matcher = pattern.matcher(&quot;1A2AA3&quot;);
1462         if (!matcher.find(1))
1463             failCount++;
1464         matcher.find();
1465         if (matcher.find())
1466             failCount++;
1467 
1468         report(&quot;\\G&quot;);
1469     }
1470 
1471     private static void zTest() {
1472         Pattern pattern = Pattern.compile(&quot;foo\\Z&quot;);
1473         // Positives
1474         check(pattern, &quot;foo\u0085&quot;, true);
1475         check(pattern, &quot;foo\u2028&quot;, true);
1476         check(pattern, &quot;foo\u2029&quot;, true);
1477         check(pattern, &quot;foo\n&quot;, true);
1478         check(pattern, &quot;foo\r&quot;, true);
1479         check(pattern, &quot;foo\r\n&quot;, true);
1480         // Negatives
1481         check(pattern, &quot;fooo&quot;, false);
1482         check(pattern, &quot;foo\n\r&quot;, false);
1483 
1484         pattern = Pattern.compile(&quot;foo\\Z&quot;, Pattern.UNIX_LINES);
1485         // Positives
1486         check(pattern, &quot;foo&quot;, true);
1487         check(pattern, &quot;foo\n&quot;, true);
1488         // Negatives
1489         check(pattern, &quot;foo\r&quot;, false);
1490         check(pattern, &quot;foo\u0085&quot;, false);
1491         check(pattern, &quot;foo\u2028&quot;, false);
1492         check(pattern, &quot;foo\u2029&quot;, false);
1493 
1494         report(&quot;\\Z&quot;);
1495     }
1496 
1497     private static void replaceFirstTest() {
1498         Pattern pattern = Pattern.compile(&quot;(ab)(c*)&quot;);
1499         Matcher matcher = pattern.matcher(&quot;abccczzzabcczzzabccc&quot;);
1500         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;testzzzabcczzzabccc&quot;))
1501             failCount++;
1502 
1503         matcher.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
1504         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;zzztestzzzabcczzzabccczzz&quot;))
1505             failCount++;
1506 
1507         matcher.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
1508         String result = matcher.replaceFirst(&quot;$1&quot;);
1509         if (!result.equals(&quot;zzzabzzzabcczzzabccczzz&quot;))
1510             failCount++;
1511 
1512         matcher.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
1513         result = matcher.replaceFirst(&quot;$2&quot;);
1514         if (!result.equals(&quot;zzzccczzzabcczzzabccczzz&quot;))
1515             failCount++;
1516 
1517         pattern = Pattern.compile(&quot;a*&quot;);
1518         matcher = pattern.matcher(&quot;aaaaaaaaaa&quot;);
1519         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;test&quot;))
1520             failCount++;
1521 
1522         pattern = Pattern.compile(&quot;a+&quot;);
1523         matcher = pattern.matcher(&quot;zzzaaaaaaaaaa&quot;);
1524         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;zzztest&quot;))
1525             failCount++;
1526 
1527         // Supplementary character test
1528         pattern = Pattern.compile(toSupplementaries(&quot;(ab)(c*)&quot;));
1529         matcher = pattern.matcher(toSupplementaries(&quot;abccczzzabcczzzabccc&quot;));
1530         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;))
1531                 .equals(toSupplementaries(&quot;testzzzabcczzzabccc&quot;)))
1532             failCount++;
1533 
1534         matcher.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
1535         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;)).
1536             equals(toSupplementaries(&quot;zzztestzzzabcczzzabccczzz&quot;)))
1537             failCount++;
1538 
1539         matcher.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
1540         result = matcher.replaceFirst(&quot;$1&quot;);
1541         if (!result.equals(toSupplementaries(&quot;zzzabzzzabcczzzabccczzz&quot;)))
1542             failCount++;
1543 
1544         matcher.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
1545         result = matcher.replaceFirst(&quot;$2&quot;);
1546         if (!result.equals(toSupplementaries(&quot;zzzccczzzabcczzzabccczzz&quot;)))
1547             failCount++;
1548 
1549         pattern = Pattern.compile(toSupplementaries(&quot;a*&quot;));
1550         matcher = pattern.matcher(toSupplementaries(&quot;aaaaaaaaaa&quot;));
1551         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;)).equals(toSupplementaries(&quot;test&quot;)))
1552             failCount++;
1553 
1554         pattern = Pattern.compile(toSupplementaries(&quot;a+&quot;));
1555         matcher = pattern.matcher(toSupplementaries(&quot;zzzaaaaaaaaaa&quot;));
1556         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;)).equals(toSupplementaries(&quot;zzztest&quot;)))
1557             failCount++;
1558 
1559         report(&quot;Replace First&quot;);
1560     }
1561 
1562     private static void unixLinesTest() {
1563         Pattern pattern = Pattern.compile(&quot;.*&quot;);
1564         Matcher matcher = pattern.matcher(&quot;aa\u2028blah&quot;);
1565         matcher.find();
1566         if (!matcher.group(0).equals(&quot;aa&quot;))
1567             failCount++;
1568 
1569         pattern = Pattern.compile(&quot;.*&quot;, Pattern.UNIX_LINES);
1570         matcher = pattern.matcher(&quot;aa\u2028blah&quot;);
1571         matcher.find();
1572         if (!matcher.group(0).equals(&quot;aa\u2028blah&quot;))
1573             failCount++;
1574 
1575         pattern = Pattern.compile(&quot;[az]$&quot;,
1576                                   Pattern.MULTILINE | Pattern.UNIX_LINES);
1577         matcher = pattern.matcher(&quot;aa\u2028zz&quot;);
1578         check(matcher, &quot;a\u2028&quot;, false);
1579 
1580         // Supplementary character test
1581         pattern = Pattern.compile(&quot;.*&quot;);
1582         matcher = pattern.matcher(toSupplementaries(&quot;aa\u2028blah&quot;));
1583         matcher.find();
1584         if (!matcher.group(0).equals(toSupplementaries(&quot;aa&quot;)))
1585             failCount++;
1586 
1587         pattern = Pattern.compile(&quot;.*&quot;, Pattern.UNIX_LINES);
1588         matcher = pattern.matcher(toSupplementaries(&quot;aa\u2028blah&quot;));
1589         matcher.find();
1590         if (!matcher.group(0).equals(toSupplementaries(&quot;aa\u2028blah&quot;)))
1591             failCount++;
1592 
1593         pattern = Pattern.compile(toSupplementaries(&quot;[az]$&quot;),
1594                                   Pattern.MULTILINE | Pattern.UNIX_LINES);
1595         matcher = pattern.matcher(toSupplementaries(&quot;aa\u2028zz&quot;));
1596         check(matcher, toSupplementaries(&quot;a\u2028&quot;), false);
1597 
1598         report(&quot;Unix Lines&quot;);
1599     }
1600 
1601     private static void commentsTest() {
1602         int flags = Pattern.COMMENTS;
1603 
1604         Pattern pattern = Pattern.compile(&quot;aa \\# aa&quot;, flags);
1605         Matcher matcher = pattern.matcher(&quot;aa#aa&quot;);
1606         if (!matcher.matches())
1607             failCount++;
1608 
1609         pattern = Pattern.compile(&quot;aa  # blah&quot;, flags);
1610         matcher = pattern.matcher(&quot;aa&quot;);
1611         if (!matcher.matches())
1612             failCount++;
1613 
1614         pattern = Pattern.compile(&quot;aa blah&quot;, flags);
1615         matcher = pattern.matcher(&quot;aablah&quot;);
1616         if (!matcher.matches())
1617              failCount++;
1618 
1619         pattern = Pattern.compile(&quot;aa  # blah blech  &quot;, flags);
1620         matcher = pattern.matcher(&quot;aa&quot;);
1621         if (!matcher.matches())
1622             failCount++;
1623 
1624         pattern = Pattern.compile(&quot;aa  # blah\n  &quot;, flags);
1625         matcher = pattern.matcher(&quot;aa&quot;);
1626         if (!matcher.matches())
1627             failCount++;
1628 
1629         pattern = Pattern.compile(&quot;aa  # blah\nbc # blech&quot;, flags);
1630         matcher = pattern.matcher(&quot;aabc&quot;);
1631         if (!matcher.matches())
1632              failCount++;
1633 
1634         pattern = Pattern.compile(&quot;aa  # blah\nbc# blech&quot;, flags);
1635         matcher = pattern.matcher(&quot;aabc&quot;);
1636         if (!matcher.matches())
1637              failCount++;
1638 
1639         pattern = Pattern.compile(&quot;aa  # blah\nbc\\# blech&quot;, flags);
1640         matcher = pattern.matcher(&quot;aabc#blech&quot;);
1641         if (!matcher.matches())
1642              failCount++;
1643 
1644         // Supplementary character test
1645         pattern = Pattern.compile(toSupplementaries(&quot;aa \\# aa&quot;), flags);
1646         matcher = pattern.matcher(toSupplementaries(&quot;aa#aa&quot;));
1647         if (!matcher.matches())
1648             failCount++;
1649 
1650         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah&quot;), flags);
1651         matcher = pattern.matcher(toSupplementaries(&quot;aa&quot;));
1652         if (!matcher.matches())
1653             failCount++;
1654 
1655         pattern = Pattern.compile(toSupplementaries(&quot;aa blah&quot;), flags);
1656         matcher = pattern.matcher(toSupplementaries(&quot;aablah&quot;));
1657         if (!matcher.matches())
1658              failCount++;
1659 
1660         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah blech  &quot;), flags);
1661         matcher = pattern.matcher(toSupplementaries(&quot;aa&quot;));
1662         if (!matcher.matches())
1663             failCount++;
1664 
1665         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\n  &quot;), flags);
1666         matcher = pattern.matcher(toSupplementaries(&quot;aa&quot;));
1667         if (!matcher.matches())
1668             failCount++;
1669 
1670         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\nbc # blech&quot;), flags);
1671         matcher = pattern.matcher(toSupplementaries(&quot;aabc&quot;));
1672         if (!matcher.matches())
1673              failCount++;
1674 
1675         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\nbc# blech&quot;), flags);
1676         matcher = pattern.matcher(toSupplementaries(&quot;aabc&quot;));
1677         if (!matcher.matches())
1678              failCount++;
1679 
1680         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\nbc\\# blech&quot;), flags);
1681         matcher = pattern.matcher(toSupplementaries(&quot;aabc#blech&quot;));
1682         if (!matcher.matches())
1683              failCount++;
1684 
1685         report(&quot;Comments&quot;);
1686     }
1687 
1688     private static void caseFoldingTest() { // bug 4504687
1689         int flags = Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;
1690         Pattern pattern = Pattern.compile(&quot;aa&quot;, flags);
1691         Matcher matcher = pattern.matcher(&quot;ab&quot;);
1692         if (matcher.matches())
1693             failCount++;
1694 
1695         pattern = Pattern.compile(&quot;aA&quot;, flags);
1696         matcher = pattern.matcher(&quot;ab&quot;);
1697         if (matcher.matches())
1698             failCount++;
1699 
1700         pattern = Pattern.compile(&quot;aa&quot;, flags);
1701         matcher = pattern.matcher(&quot;aB&quot;);
1702         if (matcher.matches())
1703             failCount++;
1704         matcher = pattern.matcher(&quot;Ab&quot;);
1705         if (matcher.matches())
1706             failCount++;
1707 
1708         // ASCII               &quot;a&quot;
1709         // Latin-1 Supplement  &quot;a&quot; + grave
1710         // Cyrillic            &quot;a&quot;
1711         String[] patterns = new String[] {
1712             //single
1713             &quot;a&quot;, &quot;\u00e0&quot;, &quot;\u0430&quot;,
1714             //slice
1715             &quot;ab&quot;, &quot;\u00e0\u00e1&quot;, &quot;\u0430\u0431&quot;,
1716             //class single
1717             &quot;[a]&quot;, &quot;[\u00e0]&quot;, &quot;[\u0430]&quot;,
1718             //class range
1719             &quot;[a-b]&quot;, &quot;[\u00e0-\u00e5]&quot;, &quot;[\u0430-\u0431]&quot;,
1720             //back reference
1721             &quot;(a)\\1&quot;, &quot;(\u00e0)\\1&quot;, &quot;(\u0430)\\1&quot;
1722         };
1723 
1724         String[] texts = new String[] {
1725             &quot;A&quot;, &quot;\u00c0&quot;, &quot;\u0410&quot;,
1726             &quot;AB&quot;, &quot;\u00c0\u00c1&quot;, &quot;\u0410\u0411&quot;,
1727             &quot;A&quot;, &quot;\u00c0&quot;, &quot;\u0410&quot;,
1728             &quot;B&quot;, &quot;\u00c2&quot;, &quot;\u0411&quot;,
1729             &quot;aA&quot;, &quot;\u00e0\u00c0&quot;, &quot;\u0430\u0410&quot;
1730         };
1731 
1732         boolean[] expected = new boolean[] {
1733             true, false, false,
1734             true, false, false,
1735             true, false, false,
1736             true, false, false,
1737             true, false, false
1738         };
1739 
1740         flags = Pattern.CASE_INSENSITIVE;
1741         for (int i = 0; i &lt; patterns.length; i++) {
1742             pattern = Pattern.compile(patterns[i], flags);
1743             matcher = pattern.matcher(texts[i]);
1744             if (matcher.matches() != expected[i]) {
1745                 System.out.println(&quot;&lt;1&gt; Failed at &quot; + i);
1746                 failCount++;
1747             }
1748         }
1749 
1750         flags = Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;
1751         for (int i = 0; i &lt; patterns.length; i++) {
1752             pattern = Pattern.compile(patterns[i], flags);
1753             matcher = pattern.matcher(texts[i]);
1754             if (!matcher.matches()) {
1755                 System.out.println(&quot;&lt;2&gt; Failed at &quot; + i);
1756                 failCount++;
1757             }
1758         }
1759         // flag unicode_case alone should do nothing
1760         flags = Pattern.UNICODE_CASE;
1761         for (int i = 0; i &lt; patterns.length; i++) {
1762             pattern = Pattern.compile(patterns[i], flags);
1763             matcher = pattern.matcher(texts[i]);
1764             if (matcher.matches()) {
1765                 System.out.println(&quot;&lt;3&gt; Failed at &quot; + i);
1766                 failCount++;
1767             }
1768         }
1769 
1770         // Special cases: i, I, u+0131 and u+0130
1771         flags = Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE;
1772         pattern = Pattern.compile(&quot;[h-j]+&quot;, flags);
1773         if (!pattern.matcher(&quot;\u0131\u0130&quot;).matches())
1774             failCount++;
1775         report(&quot;Case Folding&quot;);
1776     }
1777 
1778     private static void appendTest() {
1779         Pattern pattern = Pattern.compile(&quot;(ab)(cd)&quot;);
1780         Matcher matcher = pattern.matcher(&quot;abcd&quot;);
1781         String result = matcher.replaceAll(&quot;$2$1&quot;);
1782         if (!result.equals(&quot;cdab&quot;))
1783             failCount++;
1784 
1785         String  s1 = &quot;Swap all: first = 123, second = 456&quot;;
1786         String  s2 = &quot;Swap one: first = 123, second = 456&quot;;
1787         String  r  = &quot;$3$2$1&quot;;
1788         pattern = Pattern.compile(&quot;([a-z]+)( *= *)([0-9]+)&quot;);
1789         matcher = pattern.matcher(s1);
1790 
1791         result = matcher.replaceAll(r);
1792         if (!result.equals(&quot;Swap all: 123 = first, 456 = second&quot;))
1793             failCount++;
1794 
1795         matcher = pattern.matcher(s2);
1796 
1797         if (matcher.find()) {
1798             StringBuffer sb = new StringBuffer();
1799             matcher.appendReplacement(sb, r);
1800             matcher.appendTail(sb);
1801             result = sb.toString();
1802             if (!result.equals(&quot;Swap one: 123 = first, second = 456&quot;))
1803                 failCount++;
1804         }
1805 
1806         // Supplementary character test
1807         pattern = Pattern.compile(toSupplementaries(&quot;(ab)(cd)&quot;));
1808         matcher = pattern.matcher(toSupplementaries(&quot;abcd&quot;));
1809         result = matcher.replaceAll(&quot;$2$1&quot;);
1810         if (!result.equals(toSupplementaries(&quot;cdab&quot;)))
1811             failCount++;
1812 
1813         s1 = toSupplementaries(&quot;Swap all: first = 123, second = 456&quot;);
1814         s2 = toSupplementaries(&quot;Swap one: first = 123, second = 456&quot;);
1815         r  = toSupplementaries(&quot;$3$2$1&quot;);
1816         pattern = Pattern.compile(toSupplementaries(&quot;([a-z]+)( *= *)([0-9]+)&quot;));
1817         matcher = pattern.matcher(s1);
1818 
1819         result = matcher.replaceAll(r);
1820         if (!result.equals(toSupplementaries(&quot;Swap all: 123 = first, 456 = second&quot;)))
1821             failCount++;
1822 
1823         matcher = pattern.matcher(s2);
1824 
1825         if (matcher.find()) {
1826             StringBuffer sb = new StringBuffer();
1827             matcher.appendReplacement(sb, r);
1828             matcher.appendTail(sb);
1829             result = sb.toString();
1830             if (!result.equals(toSupplementaries(&quot;Swap one: 123 = first, second = 456&quot;)))
1831                 failCount++;
1832         }
1833         report(&quot;Append&quot;);
1834     }
1835 
1836     private static void splitTest() {
1837         Pattern pattern = Pattern.compile(&quot;:&quot;);
1838         String[] result = pattern.split(&quot;foo:and:boo&quot;, 2);
1839         if (!result[0].equals(&quot;foo&quot;))
1840             failCount++;
1841         if (!result[1].equals(&quot;and:boo&quot;))
1842             failCount++;
1843         // Supplementary character test
1844         Pattern patternX = Pattern.compile(toSupplementaries(&quot;X&quot;));
1845         result = patternX.split(toSupplementaries(&quot;fooXandXboo&quot;), 2);
1846         if (!result[0].equals(toSupplementaries(&quot;foo&quot;)))
1847             failCount++;
1848         if (!result[1].equals(toSupplementaries(&quot;andXboo&quot;)))
1849             failCount++;
1850 
1851         CharBuffer cb = CharBuffer.allocate(100);
1852         cb.put(&quot;foo:and:boo&quot;);
1853         cb.flip();
1854         result = pattern.split(cb);
1855         if (!result[0].equals(&quot;foo&quot;))
1856             failCount++;
1857         if (!result[1].equals(&quot;and&quot;))
1858             failCount++;
1859         if (!result[2].equals(&quot;boo&quot;))
1860             failCount++;
1861 
1862         // Supplementary character test
1863         CharBuffer cbs = CharBuffer.allocate(100);
1864         cbs.put(toSupplementaries(&quot;fooXandXboo&quot;));
1865         cbs.flip();
1866         result = patternX.split(cbs);
1867         if (!result[0].equals(toSupplementaries(&quot;foo&quot;)))
1868             failCount++;
1869         if (!result[1].equals(toSupplementaries(&quot;and&quot;)))
1870             failCount++;
1871         if (!result[2].equals(toSupplementaries(&quot;boo&quot;)))
1872             failCount++;
1873 
1874         String source = &quot;0123456789&quot;;
1875         for (int limit=-2; limit&lt;3; limit++) {
1876             for (int x=0; x&lt;10; x++) {
1877                 result = source.split(Integer.toString(x), limit);
1878                 int expectedLength = limit &lt; 1 ? 2 : limit;
1879 
1880                 if ((limit == 0) &amp;&amp; (x == 9)) {
1881                     // expected dropping of &quot;&quot;
1882                     if (result.length != 1)
1883                         failCount++;
1884                     if (!result[0].equals(&quot;012345678&quot;)) {
1885                         failCount++;
1886                     }
1887                 } else {
1888                     if (result.length != expectedLength) {
1889                         failCount++;
1890                     }
1891                     if (!result[0].equals(source.substring(0,x))) {
1892                         if (limit != 1) {
1893                             failCount++;
1894                         } else {
1895                             if (!result[0].equals(source.substring(0,10))) {
1896                                 failCount++;
1897                             }
1898                         }
1899                     }
1900                     if (expectedLength &gt; 1) { // Check segment 2
1901                         if (!result[1].equals(source.substring(x+1,10)))
1902                             failCount++;
1903                     }
1904                 }
1905             }
1906         }
1907         // Check the case for no match found
1908         for (int limit=-2; limit&lt;3; limit++) {
1909             result = source.split(&quot;e&quot;, limit);
1910             if (result.length != 1)
1911                 failCount++;
1912             if (!result[0].equals(source))
1913                 failCount++;
1914         }
1915         // Check the case for limit == 0, source = &quot;&quot;;
1916         // split() now returns 0-length for empty source &quot;&quot; see #6559590
1917         source = &quot;&quot;;
1918         result = source.split(&quot;e&quot;, 0);
1919         if (result.length != 1)
1920             failCount++;
1921         if (!result[0].equals(source))
1922             failCount++;
1923 
1924         // Check both split() and splitAsStraem(), especially for zero-lenth
1925         // input and zero-lenth match cases
1926         String[][] input = new String[][] {
1927             { &quot; &quot;,           &quot;Abc Efg Hij&quot; },   // normal non-zero-match
1928             { &quot; &quot;,           &quot; Abc Efg Hij&quot; },  // leading empty str for non-zero-match
1929             { &quot; &quot;,           &quot;Abc  Efg Hij&quot; },  // non-zero-match in the middle
1930             { &quot;(?=\\p{Lu})&quot;, &quot;AbcEfgHij&quot; },     // no leading empty str for zero-match
1931             { &quot;(?=\\p{Lu})&quot;, &quot;AbcEfg&quot; },
1932             { &quot;(?=\\p{Lu})&quot;, &quot;Abc&quot; },
1933             { &quot; &quot;,           &quot;&quot; },              // zero-length input
1934             { &quot;.*&quot;,          &quot;&quot; },
1935 
1936             // some tests from PatternStreamTest.java
1937             { &quot;4&quot;,       &quot;awgqwefg1fefw4vssv1vvv1&quot; },
1938             { &quot;\u00a3a&quot;, &quot;afbfq\u00a3abgwgb\u00a3awngnwggw\u00a3a\u00a3ahjrnhneerh&quot; },
1939             { &quot;1&quot;,       &quot;awgqwefg1fefw4vssv1vvv1&quot; },
1940             { &quot;1&quot;,       &quot;a\u4ebafg1fefw\u4eba4\u9f9cvssv\u9f9c1v\u672c\u672cvv&quot; },
1941             { &quot;\u56da&quot;,  &quot;1\u56da23\u56da456\u56da7890&quot; },
1942             { &quot;\u56da&quot;,  &quot;1\u56da23\u9f9c\u672c\u672c\u56da456\u56da\u9f9c\u672c7890&quot; },
1943             { &quot;\u56da&quot;,  &quot;&quot; },
1944             { &quot;[ \t,:.]&quot;,&quot;This is,testing: with\tdifferent separators.&quot; }, //multiple septs
1945             { &quot;o&quot;,       &quot;boo:and:foo&quot; },
1946             { &quot;o&quot;,       &quot;booooo:and:fooooo&quot; },
1947             { &quot;o&quot;,       &quot;fooooo:&quot; },
1948         };
1949 
1950         String[][] expected = new String[][] {
1951             { &quot;Abc&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1952             { &quot;&quot;, &quot;Abc&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1953             { &quot;Abc&quot;, &quot;&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1954             { &quot;Abc&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1955             { &quot;Abc&quot;, &quot;Efg&quot; },
1956             { &quot;Abc&quot; },
1957             { &quot;&quot; },
1958             { &quot;&quot; },
1959 
1960             { &quot;awgqwefg1fefw&quot;, &quot;vssv1vvv1&quot; },
1961             { &quot;afbfq&quot;, &quot;bgwgb&quot;, &quot;wngnwggw&quot;, &quot;&quot;, &quot;hjrnhneerh&quot; },
1962             { &quot;awgqwefg&quot;, &quot;fefw4vssv&quot;, &quot;vvv&quot; },
1963             { &quot;a\u4ebafg&quot;, &quot;fefw\u4eba4\u9f9cvssv\u9f9c&quot;, &quot;v\u672c\u672cvv&quot; },
1964             { &quot;1&quot;, &quot;23&quot;, &quot;456&quot;, &quot;7890&quot; },
1965             { &quot;1&quot;, &quot;23\u9f9c\u672c\u672c&quot;, &quot;456&quot;, &quot;\u9f9c\u672c7890&quot; },
1966             { &quot;&quot; },
1967             { &quot;This&quot;, &quot;is&quot;, &quot;testing&quot;, &quot;&quot;, &quot;with&quot;, &quot;different&quot;, &quot;separators&quot; },
1968             { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; },
1969             { &quot;b&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;:and:f&quot; },
1970             { &quot;f&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;:&quot; },
1971         };
1972         for (int i = 0; i &lt; input.length; i++) {
1973             pattern = Pattern.compile(input[i][0]);
1974             if (!Arrays.equals(pattern.split(input[i][1]), expected[i])) {
1975                 failCount++;
1976             }
1977             if (input[i][1].length() &gt; 0 &amp;&amp;  // splitAsStream() return empty resulting
1978                                              // array for zero-length input for now
1979                 !Arrays.equals(pattern.splitAsStream(input[i][1]).toArray(),
1980                                expected[i])) {
1981                 failCount++;
1982             }
1983         }
1984         report(&quot;Split&quot;);
1985     }
1986 
1987     private static void negationTest() {
1988         Pattern pattern = Pattern.compile(&quot;[\\[@^]+&quot;);
1989         Matcher matcher = pattern.matcher(&quot;@@@@[[[[^^^^&quot;);
1990         if (!matcher.find())
1991             failCount++;
1992         if (!matcher.group(0).equals(&quot;@@@@[[[[^^^^&quot;))
1993             failCount++;
1994         pattern = Pattern.compile(&quot;[@\\[^]+&quot;);
1995         matcher = pattern.matcher(&quot;@@@@[[[[^^^^&quot;);
1996         if (!matcher.find())
1997             failCount++;
1998         if (!matcher.group(0).equals(&quot;@@@@[[[[^^^^&quot;))
1999             failCount++;
2000         pattern = Pattern.compile(&quot;[@\\[^@]+&quot;);
2001         matcher = pattern.matcher(&quot;@@@@[[[[^^^^&quot;);
2002         if (!matcher.find())
2003             failCount++;
2004         if (!matcher.group(0).equals(&quot;@@@@[[[[^^^^&quot;))
2005             failCount++;
2006 
2007         pattern = Pattern.compile(&quot;\\)&quot;);
2008         matcher = pattern.matcher(&quot;xxx)xxx&quot;);
2009         if (!matcher.find())
2010             failCount++;
2011 
2012         report(&quot;Negation&quot;);
2013     }
2014 
2015     private static void ampersandTest() {
2016         Pattern pattern = Pattern.compile(&quot;[&amp;@]+&quot;);
2017         check(pattern, &quot;@@@@&amp;&amp;&amp;&amp;&quot;, true);
2018 
2019         pattern = Pattern.compile(&quot;[@&amp;]+&quot;);
2020         check(pattern, &quot;@@@@&amp;&amp;&amp;&amp;&quot;, true);
2021 
2022         pattern = Pattern.compile(&quot;[@\\&amp;]+&quot;);
2023         check(pattern, &quot;@@@@&amp;&amp;&amp;&amp;&quot;, true);
2024 
2025         report(&quot;Ampersand&quot;);
2026     }
2027 
2028     private static void octalTest() throws Exception {
2029         Pattern pattern = Pattern.compile(&quot;\\u0007&quot;);
2030         Matcher matcher = pattern.matcher(&quot;\u0007&quot;);
2031         if (!matcher.matches())
2032             failCount++;
2033         pattern = Pattern.compile(&quot;\\07&quot;);
2034         matcher = pattern.matcher(&quot;\u0007&quot;);
2035         if (!matcher.matches())
2036             failCount++;
2037         pattern = Pattern.compile(&quot;\\007&quot;);
2038         matcher = pattern.matcher(&quot;\u0007&quot;);
2039         if (!matcher.matches())
2040             failCount++;
2041         pattern = Pattern.compile(&quot;\\0007&quot;);
2042         matcher = pattern.matcher(&quot;\u0007&quot;);
2043         if (!matcher.matches())
2044             failCount++;
2045         pattern = Pattern.compile(&quot;\\040&quot;);
2046         matcher = pattern.matcher(&quot;\u0020&quot;);
2047         if (!matcher.matches())
2048             failCount++;
2049         pattern = Pattern.compile(&quot;\\0403&quot;);
2050         matcher = pattern.matcher(&quot;\u00203&quot;);
2051         if (!matcher.matches())
2052             failCount++;
2053         pattern = Pattern.compile(&quot;\\0103&quot;);
2054         matcher = pattern.matcher(&quot;\u0043&quot;);
2055         if (!matcher.matches())
2056             failCount++;
2057 
2058         report(&quot;Octal&quot;);
2059     }
2060 
2061     private static void longPatternTest() throws Exception {
2062         try {
2063             Pattern pattern = Pattern.compile(
2064                 &quot;a 32-character-long pattern xxxx&quot;);
2065             pattern = Pattern.compile(&quot;a 33-character-long pattern xxxxx&quot;);
2066             pattern = Pattern.compile(&quot;a thirty four character long regex&quot;);
2067             StringBuffer patternToBe = new StringBuffer(101);
2068             for (int i=0; i&lt;100; i++)
2069                 patternToBe.append((char)(97 + i%26));
2070             pattern = Pattern.compile(patternToBe.toString());
2071         } catch (PatternSyntaxException e) {
2072             failCount++;
2073         }
2074 
2075         // Supplementary character test
2076         try {
2077             Pattern pattern = Pattern.compile(
2078                 toSupplementaries(&quot;a 32-character-long pattern xxxx&quot;));
2079             pattern = Pattern.compile(toSupplementaries(&quot;a 33-character-long pattern xxxxx&quot;));
2080             pattern = Pattern.compile(toSupplementaries(&quot;a thirty four character long regex&quot;));
2081             StringBuffer patternToBe = new StringBuffer(101*2);
2082             for (int i=0; i&lt;100; i++)
2083                 patternToBe.append(Character.toChars(Character.MIN_SUPPLEMENTARY_CODE_POINT
2084                                                      + 97 + i%26));
2085             pattern = Pattern.compile(patternToBe.toString());
2086         } catch (PatternSyntaxException e) {
2087             failCount++;
2088         }
2089         report(&quot;LongPattern&quot;);
2090     }
2091 
2092     private static void group0Test() throws Exception {
2093         Pattern pattern = Pattern.compile(&quot;(tes)ting&quot;);
2094         Matcher matcher = pattern.matcher(&quot;testing&quot;);
2095         check(matcher, &quot;testing&quot;);
2096 
2097         matcher.reset(&quot;testing&quot;);
2098         if (matcher.lookingAt()) {
2099             if (!matcher.group(0).equals(&quot;testing&quot;))
2100                 failCount++;
2101         } else {
2102             failCount++;
2103         }
2104 
2105         matcher.reset(&quot;testing&quot;);
2106         if (matcher.matches()) {
2107             if (!matcher.group(0).equals(&quot;testing&quot;))
2108                 failCount++;
2109         } else {
2110             failCount++;
2111         }
2112 
2113         pattern = Pattern.compile(&quot;(tes)ting&quot;);
2114         matcher = pattern.matcher(&quot;testing&quot;);
2115         if (matcher.lookingAt()) {
2116             if (!matcher.group(0).equals(&quot;testing&quot;))
2117                 failCount++;
2118         } else {
2119             failCount++;
2120         }
2121 
2122         pattern = Pattern.compile(&quot;^(tes)ting&quot;);
2123         matcher = pattern.matcher(&quot;testing&quot;);
2124         if (matcher.matches()) {
2125             if (!matcher.group(0).equals(&quot;testing&quot;))
2126                 failCount++;
2127         } else {
2128             failCount++;
2129         }
2130 
2131         // Supplementary character test
2132         pattern = Pattern.compile(toSupplementaries(&quot;(tes)ting&quot;));
2133         matcher = pattern.matcher(toSupplementaries(&quot;testing&quot;));
2134         check(matcher, toSupplementaries(&quot;testing&quot;));
2135 
2136         matcher.reset(toSupplementaries(&quot;testing&quot;));
2137         if (matcher.lookingAt()) {
2138             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2139                 failCount++;
2140         } else {
2141             failCount++;
2142         }
2143 
2144         matcher.reset(toSupplementaries(&quot;testing&quot;));
2145         if (matcher.matches()) {
2146             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2147                 failCount++;
2148         } else {
2149             failCount++;
2150         }
2151 
2152         pattern = Pattern.compile(toSupplementaries(&quot;(tes)ting&quot;));
2153         matcher = pattern.matcher(toSupplementaries(&quot;testing&quot;));
2154         if (matcher.lookingAt()) {
2155             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2156                 failCount++;
2157         } else {
2158             failCount++;
2159         }
2160 
2161         pattern = Pattern.compile(toSupplementaries(&quot;^(tes)ting&quot;));
2162         matcher = pattern.matcher(toSupplementaries(&quot;testing&quot;));
2163         if (matcher.matches()) {
2164             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2165                 failCount++;
2166         } else {
2167             failCount++;
2168         }
2169 
2170         report(&quot;Group0&quot;);
2171     }
2172 
2173     private static void findIntTest() throws Exception {
2174         Pattern p = Pattern.compile(&quot;blah&quot;);
2175         Matcher m = p.matcher(&quot;zzzzblahzzzzzblah&quot;);
2176         boolean result = m.find(2);
2177         if (!result)
2178             failCount++;
2179 
2180         p = Pattern.compile(&quot;$&quot;);
2181         m = p.matcher(&quot;1234567890&quot;);
2182         result = m.find(10);
2183         if (!result)
2184             failCount++;
2185         try {
2186             result = m.find(11);
2187             failCount++;
2188         } catch (IndexOutOfBoundsException e) {
2189             // correct result
2190         }
2191 
2192         // Supplementary character test
2193         p = Pattern.compile(toSupplementaries(&quot;blah&quot;));
2194         m = p.matcher(toSupplementaries(&quot;zzzzblahzzzzzblah&quot;));
2195         result = m.find(2);
2196         if (!result)
2197             failCount++;
2198 
2199         report(&quot;FindInt&quot;);
2200     }
2201 
2202     private static void emptyPatternTest() throws Exception {
2203         Pattern p = Pattern.compile(&quot;&quot;);
2204         Matcher m = p.matcher(&quot;foo&quot;);
2205 
2206         // Should find empty pattern at beginning of input
2207         boolean result = m.find();
2208         if (result != true)
2209             failCount++;
2210         if (m.start() != 0)
2211             failCount++;
2212 
2213         // Should not match entire input if input is not empty
2214         m.reset();
2215         result = m.matches();
2216         if (result == true)
2217             failCount++;
2218 
2219         try {
2220             m.start(0);
2221             failCount++;
2222         } catch (IllegalStateException e) {
2223             // Correct result
2224         }
2225 
2226         // Should match entire input if input is empty
2227         m.reset(&quot;&quot;);
2228         result = m.matches();
2229         if (result != true)
2230             failCount++;
2231 
2232         result = Pattern.matches(&quot;&quot;, &quot;&quot;);
2233         if (result != true)
2234             failCount++;
2235 
2236         result = Pattern.matches(&quot;&quot;, &quot;foo&quot;);
2237         if (result == true)
2238             failCount++;
2239         report(&quot;EmptyPattern&quot;);
2240     }
2241 
2242     private static void charClassTest() throws Exception {
2243         Pattern pattern = Pattern.compile(&quot;blah[ab]]blech&quot;);
2244         check(pattern, &quot;blahb]blech&quot;, true);
2245 
2246         pattern = Pattern.compile(&quot;[abc[def]]&quot;);
2247         check(pattern, &quot;b&quot;, true);
2248 
2249         // Supplementary character tests
2250         pattern = Pattern.compile(toSupplementaries(&quot;blah[ab]]blech&quot;));
2251         check(pattern, toSupplementaries(&quot;blahb]blech&quot;), true);
2252 
2253         pattern = Pattern.compile(toSupplementaries(&quot;[abc[def]]&quot;));
2254         check(pattern, toSupplementaries(&quot;b&quot;), true);
2255 
2256         try {
2257             // u00ff when UNICODE_CASE
2258             pattern = Pattern.compile(&quot;[ab\u00ffcd]&quot;,
2259                                       Pattern.CASE_INSENSITIVE|
2260                                       Pattern.UNICODE_CASE);
2261             check(pattern, &quot;ab\u00ffcd&quot;, true);
2262             check(pattern, &quot;Ab\u0178Cd&quot;, true);
2263 
2264             // u00b5 when UNICODE_CASE
2265             pattern = Pattern.compile(&quot;[ab\u00b5cd]&quot;,
2266                                       Pattern.CASE_INSENSITIVE|
2267                                       Pattern.UNICODE_CASE);
2268             check(pattern, &quot;ab\u00b5cd&quot;, true);
2269             check(pattern, &quot;Ab\u039cCd&quot;, true);
2270         } catch (Exception e) { failCount++; }
2271 
2272         /* Special cases
2273            (1)LatinSmallLetterLongS u+017f
2274            (2)LatinSmallLetterDotlessI u+0131
2275            (3)LatineCapitalLetterIWithDotAbove u+0130
2276            (4)KelvinSign u+212a
2277            (5)AngstromSign u+212b
2278         */
2279         int flags = Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE;
2280         pattern = Pattern.compile(&quot;[sik\u00c5]+&quot;, flags);
2281         if (!pattern.matcher(&quot;\u017f\u0130\u0131\u212a\u212b&quot;).matches())
2282             failCount++;
2283 
2284         report(&quot;CharClass&quot;);
2285     }
2286 
2287     private static void caretTest() throws Exception {
2288         Pattern pattern = Pattern.compile(&quot;\\w*&quot;);
2289         Matcher matcher = pattern.matcher(&quot;a#bc#def##g&quot;);
2290         check(matcher, &quot;a&quot;);
2291         check(matcher, &quot;&quot;);
2292         check(matcher, &quot;bc&quot;);
2293         check(matcher, &quot;&quot;);
2294         check(matcher, &quot;def&quot;);
2295         check(matcher, &quot;&quot;);
2296         check(matcher, &quot;&quot;);
2297         check(matcher, &quot;g&quot;);
2298         check(matcher, &quot;&quot;);
2299         if (matcher.find())
2300             failCount++;
2301 
2302         pattern = Pattern.compile(&quot;^\\w*&quot;);
2303         matcher = pattern.matcher(&quot;a#bc#def##g&quot;);
2304         check(matcher, &quot;a&quot;);
2305         if (matcher.find())
2306             failCount++;
2307 
2308         pattern = Pattern.compile(&quot;\\w&quot;);
2309         matcher = pattern.matcher(&quot;abc##x&quot;);
2310         check(matcher, &quot;a&quot;);
2311         check(matcher, &quot;b&quot;);
2312         check(matcher, &quot;c&quot;);
2313         check(matcher, &quot;x&quot;);
2314         if (matcher.find())
2315             failCount++;
2316 
2317         pattern = Pattern.compile(&quot;^\\w&quot;);
2318         matcher = pattern.matcher(&quot;abc##x&quot;);
2319         check(matcher, &quot;a&quot;);
2320         if (matcher.find())
2321             failCount++;
2322 
2323         pattern = Pattern.compile(&quot;\\A\\p{Alpha}{3}&quot;);
2324         matcher = pattern.matcher(&quot;abcdef-ghi\njklmno&quot;);
2325         check(matcher, &quot;abc&quot;);
2326         if (matcher.find())
2327             failCount++;
2328 
2329         pattern = Pattern.compile(&quot;^\\p{Alpha}{3}&quot;, Pattern.MULTILINE);
2330         matcher = pattern.matcher(&quot;abcdef-ghi\njklmno&quot;);
2331         check(matcher, &quot;abc&quot;);
2332         check(matcher, &quot;jkl&quot;);
2333         if (matcher.find())
2334             failCount++;
2335 
2336         pattern = Pattern.compile(&quot;^&quot;, Pattern.MULTILINE);
2337         matcher = pattern.matcher(&quot;this is some text&quot;);
2338         String result = matcher.replaceAll(&quot;X&quot;);
2339         if (!result.equals(&quot;Xthis is some text&quot;))
2340             failCount++;
2341 
2342         pattern = Pattern.compile(&quot;^&quot;);
2343         matcher = pattern.matcher(&quot;this is some text&quot;);
2344         result = matcher.replaceAll(&quot;X&quot;);
2345         if (!result.equals(&quot;Xthis is some text&quot;))
2346             failCount++;
2347 
2348         pattern = Pattern.compile(&quot;^&quot;, Pattern.MULTILINE | Pattern.UNIX_LINES);
2349         matcher = pattern.matcher(&quot;this is some text\n&quot;);
2350         result = matcher.replaceAll(&quot;X&quot;);
2351         if (!result.equals(&quot;Xthis is some text\n&quot;))
2352             failCount++;
2353 
2354         report(&quot;Caret&quot;);
2355     }
2356 
2357     private static void groupCaptureTest() throws Exception {
2358         // Independent group
2359         Pattern pattern = Pattern.compile(&quot;x+(?&gt;y+)z+&quot;);
2360         Matcher matcher = pattern.matcher(&quot;xxxyyyzzz&quot;);
2361         matcher.find();
2362         try {
2363             String blah = matcher.group(1);
2364             failCount++;
2365         } catch (IndexOutOfBoundsException ioobe) {
2366             // Good result
2367         }
2368         // Pure group
2369         pattern = Pattern.compile(&quot;x+(?:y+)z+&quot;);
2370         matcher = pattern.matcher(&quot;xxxyyyzzz&quot;);
2371         matcher.find();
2372         try {
2373             String blah = matcher.group(1);
2374             failCount++;
2375         } catch (IndexOutOfBoundsException ioobe) {
2376             // Good result
2377         }
2378 
2379         // Supplementary character tests
2380         // Independent group
2381         pattern = Pattern.compile(toSupplementaries(&quot;x+(?&gt;y+)z+&quot;));
2382         matcher = pattern.matcher(toSupplementaries(&quot;xxxyyyzzz&quot;));
2383         matcher.find();
2384         try {
2385             String blah = matcher.group(1);
2386             failCount++;
2387         } catch (IndexOutOfBoundsException ioobe) {
2388             // Good result
2389         }
2390         // Pure group
2391         pattern = Pattern.compile(toSupplementaries(&quot;x+(?:y+)z+&quot;));
2392         matcher = pattern.matcher(toSupplementaries(&quot;xxxyyyzzz&quot;));
2393         matcher.find();
2394         try {
2395             String blah = matcher.group(1);
2396             failCount++;
2397         } catch (IndexOutOfBoundsException ioobe) {
2398             // Good result
2399         }
2400 
2401         report(&quot;GroupCapture&quot;);
2402     }
2403 
2404     private static void backRefTest() throws Exception {
2405         Pattern pattern = Pattern.compile(&quot;(a*)bc\\1&quot;);
2406         check(pattern, &quot;zzzaabcazzz&quot;, true);
2407 
2408         pattern = Pattern.compile(&quot;(a*)bc\\1&quot;);
2409         check(pattern, &quot;zzzaabcaazzz&quot;, true);
2410 
2411         pattern = Pattern.compile(&quot;(abc)(def)\\1&quot;);
2412         check(pattern, &quot;abcdefabc&quot;, true);
2413 
2414         pattern = Pattern.compile(&quot;(abc)(def)\\3&quot;);
2415         check(pattern, &quot;abcdefabc&quot;, false);
2416 
2417         try {
2418             for (int i = 1; i &lt; 10; i++) {
2419                 // Make sure backref 1-9 are always accepted
2420                 pattern = Pattern.compile(&quot;abcdef\\&quot; + i);
2421                 // and fail to match if the target group does not exit
2422                 check(pattern, &quot;abcdef&quot;, false);
2423             }
2424         } catch(PatternSyntaxException e) {
2425             failCount++;
2426         }
2427 
2428         pattern = Pattern.compile(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)\\11&quot;);
2429         check(pattern, &quot;abcdefghija&quot;, false);
2430         check(pattern, &quot;abcdefghija1&quot;, true);
2431 
2432         pattern = Pattern.compile(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)\\11&quot;);
2433         check(pattern, &quot;abcdefghijkk&quot;, true);
2434 
2435         pattern = Pattern.compile(&quot;(a)bcdefghij\\11&quot;);
2436         check(pattern, &quot;abcdefghija1&quot;, true);
2437 
2438         // Supplementary character tests
2439         pattern = Pattern.compile(toSupplementaries(&quot;(a*)bc\\1&quot;));
2440         check(pattern, toSupplementaries(&quot;zzzaabcazzz&quot;), true);
2441 
2442         pattern = Pattern.compile(toSupplementaries(&quot;(a*)bc\\1&quot;));
2443         check(pattern, toSupplementaries(&quot;zzzaabcaazzz&quot;), true);
2444 
2445         pattern = Pattern.compile(toSupplementaries(&quot;(abc)(def)\\1&quot;));
2446         check(pattern, toSupplementaries(&quot;abcdefabc&quot;), true);
2447 
2448         pattern = Pattern.compile(toSupplementaries(&quot;(abc)(def)\\3&quot;));
2449         check(pattern, toSupplementaries(&quot;abcdefabc&quot;), false);
2450 
2451         pattern = Pattern.compile(toSupplementaries(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)\\11&quot;));
2452         check(pattern, toSupplementaries(&quot;abcdefghija&quot;), false);
2453         check(pattern, toSupplementaries(&quot;abcdefghija1&quot;), true);
2454 
2455         pattern = Pattern.compile(toSupplementaries(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)\\11&quot;));
2456         check(pattern, toSupplementaries(&quot;abcdefghijkk&quot;), true);
2457 
2458         report(&quot;BackRef&quot;);
2459     }
2460 
2461     /**
2462      * Unicode Technical Report #18, section 2.6 End of Line
2463      * There is no empty line to be matched in the sequence \u000D\u000A
2464      * but there is an empty line in the sequence \u000A\u000D.
2465      */
2466     private static void anchorTest() throws Exception {
2467         Pattern p = Pattern.compile(&quot;^.*$&quot;, Pattern.MULTILINE);
2468         Matcher m = p.matcher(&quot;blah1\r\nblah2&quot;);
2469         m.find();
2470         m.find();
2471         if (!m.group().equals(&quot;blah2&quot;))
2472             failCount++;
2473 
2474         m.reset(&quot;blah1\n\rblah2&quot;);
2475         m.find();
2476         m.find();
2477         m.find();
2478         if (!m.group().equals(&quot;blah2&quot;))
2479             failCount++;
2480 
2481         // Test behavior of $ with \r\n at end of input
2482         p = Pattern.compile(&quot;.+$&quot;);
2483         m = p.matcher(&quot;blah1\r\n&quot;);
2484         if (!m.find())
2485             failCount++;
2486        if (!m.group().equals(&quot;blah1&quot;))
2487             failCount++;
2488         if (m.find())
2489             failCount++;
2490 
2491         // Test behavior of $ with \r\n at end of input in multiline
2492         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2493         m = p.matcher(&quot;blah1\r\n&quot;);
2494         if (!m.find())
2495             failCount++;
2496         if (m.find())
2497             failCount++;
2498 
2499         // Test for $ recognition of \u0085 for bug 4527731
2500         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2501         m = p.matcher(&quot;blah1\u0085&quot;);
2502         if (!m.find())
2503             failCount++;
2504 
2505         // Supplementary character test
2506         p = Pattern.compile(&quot;^.*$&quot;, Pattern.MULTILINE);
2507         m = p.matcher(toSupplementaries(&quot;blah1\r\nblah2&quot;));
2508         m.find();
2509         m.find();
2510         if (!m.group().equals(toSupplementaries(&quot;blah2&quot;)))
2511             failCount++;
2512 
2513         m.reset(toSupplementaries(&quot;blah1\n\rblah2&quot;));
2514         m.find();
2515         m.find();
2516         m.find();
2517         if (!m.group().equals(toSupplementaries(&quot;blah2&quot;)))
2518             failCount++;
2519 
2520         // Test behavior of $ with \r\n at end of input
2521         p = Pattern.compile(&quot;.+$&quot;);
2522         m = p.matcher(toSupplementaries(&quot;blah1\r\n&quot;));
2523         if (!m.find())
2524             failCount++;
2525         if (!m.group().equals(toSupplementaries(&quot;blah1&quot;)))
2526             failCount++;
2527         if (m.find())
2528             failCount++;
2529 
2530         // Test behavior of $ with \r\n at end of input in multiline
2531         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2532         m = p.matcher(toSupplementaries(&quot;blah1\r\n&quot;));
2533         if (!m.find())
2534             failCount++;
2535         if (m.find())
2536             failCount++;
2537 
2538         // Test for $ recognition of \u0085 for bug 4527731
2539         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2540         m = p.matcher(toSupplementaries(&quot;blah1\u0085&quot;));
2541         if (!m.find())
2542             failCount++;
2543 
2544         report(&quot;Anchors&quot;);
2545     }
2546 
2547     /**
2548      * A basic sanity test of Matcher.lookingAt().
2549      */
2550     private static void lookingAtTest() throws Exception {
2551         Pattern p = Pattern.compile(&quot;(ab)(c*)&quot;);
2552         Matcher m = p.matcher(&quot;abccczzzabcczzzabccc&quot;);
2553 
2554         if (!m.lookingAt())
2555             failCount++;
2556 
2557         if (!m.group().equals(m.group(0)))
2558             failCount++;
2559 
2560         m = p.matcher(&quot;zzzabccczzzabcczzzabccczzz&quot;);
2561         if (m.lookingAt())
2562             failCount++;
2563 
2564         // Supplementary character test
2565         p = Pattern.compile(toSupplementaries(&quot;(ab)(c*)&quot;));
2566         m = p.matcher(toSupplementaries(&quot;abccczzzabcczzzabccc&quot;));
2567 
2568         if (!m.lookingAt())
2569             failCount++;
2570 
2571         if (!m.group().equals(m.group(0)))
2572             failCount++;
2573 
2574         m = p.matcher(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
2575         if (m.lookingAt())
2576             failCount++;
2577 
2578         report(&quot;Looking At&quot;);
2579     }
2580 
2581     /**
2582      * A basic sanity test of Matcher.matches().
2583      */
2584     private static void matchesTest() throws Exception {
2585         // matches()
2586         Pattern p = Pattern.compile(&quot;ulb(c*)&quot;);
2587         Matcher m = p.matcher(&quot;ulbcccccc&quot;);
2588         if (!m.matches())
2589             failCount++;
2590 
2591         // find() but not matches()
2592         m.reset(&quot;zzzulbcccccc&quot;);
2593         if (m.matches())
2594             failCount++;
2595 
2596         // lookingAt() but not matches()
2597         m.reset(&quot;ulbccccccdef&quot;);
2598         if (m.matches())
2599             failCount++;
2600 
2601         // matches()
2602         p = Pattern.compile(&quot;a|ad&quot;);
2603         m = p.matcher(&quot;ad&quot;);
2604         if (!m.matches())
2605             failCount++;
2606 
2607         // Supplementary character test
2608         // matches()
2609         p = Pattern.compile(toSupplementaries(&quot;ulb(c*)&quot;));
2610         m = p.matcher(toSupplementaries(&quot;ulbcccccc&quot;));
2611         if (!m.matches())
2612             failCount++;
2613 
2614         // find() but not matches()
2615         m.reset(toSupplementaries(&quot;zzzulbcccccc&quot;));
2616         if (m.matches())
2617             failCount++;
2618 
2619         // lookingAt() but not matches()
2620         m.reset(toSupplementaries(&quot;ulbccccccdef&quot;));
2621         if (m.matches())
2622             failCount++;
2623 
2624         // matches()
2625         p = Pattern.compile(toSupplementaries(&quot;a|ad&quot;));
2626         m = p.matcher(toSupplementaries(&quot;ad&quot;));
2627         if (!m.matches())
2628             failCount++;
2629 
2630         report(&quot;Matches&quot;);
2631     }
2632 
2633     /**
2634      * A basic sanity test of Pattern.matches().
2635      */
2636     private static void patternMatchesTest() throws Exception {
2637         // matches()
2638         if (!Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2639                              toSupplementaries(&quot;ulbcccccc&quot;)))
2640             failCount++;
2641 
2642         // find() but not matches()
2643         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2644                             toSupplementaries(&quot;zzzulbcccccc&quot;)))
2645             failCount++;
2646 
2647         // lookingAt() but not matches()
2648         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2649                             toSupplementaries(&quot;ulbccccccdef&quot;)))
2650             failCount++;
2651 
2652         // Supplementary character test
2653         // matches()
2654         if (!Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2655                              toSupplementaries(&quot;ulbcccccc&quot;)))
2656             failCount++;
2657 
2658         // find() but not matches()
2659         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2660                             toSupplementaries(&quot;zzzulbcccccc&quot;)))
2661             failCount++;
2662 
2663         // lookingAt() but not matches()
2664         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2665                             toSupplementaries(&quot;ulbccccccdef&quot;)))
2666             failCount++;
2667 
2668         report(&quot;Pattern Matches&quot;);
2669     }
2670 
2671     /**
2672      * Canonical equivalence testing. Tests the ability of the engine
2673      * to match sequences that are not explicitly specified in the
2674      * pattern when they are considered equivalent by the Unicode Standard.
2675      */
2676     private static void ceTest() throws Exception {
2677         // Decomposed char outside char classes
2678         Pattern p = Pattern.compile(&quot;testa\u030a&quot;, Pattern.CANON_EQ);
2679         Matcher m = p.matcher(&quot;test\u00e5&quot;);
2680         if (!m.matches())
2681             failCount++;
2682 
2683         m.reset(&quot;testa\u030a&quot;);
2684         if (!m.matches())
2685             failCount++;
2686 
2687         // Composed char outside char classes
2688         p = Pattern.compile(&quot;test\u00e5&quot;, Pattern.CANON_EQ);
2689         m = p.matcher(&quot;test\u00e5&quot;);
2690         if (!m.matches())
2691             failCount++;
2692 
2693         m.reset(&quot;testa\u030a&quot;);
2694         if (!m.find())
2695             failCount++;
2696 
2697         // Decomposed char inside a char class
2698         p = Pattern.compile(&quot;test[abca\u030a]&quot;, Pattern.CANON_EQ);
2699         m = p.matcher(&quot;test\u00e5&quot;);
2700         if (!m.find())
2701             failCount++;
2702 
2703         m.reset(&quot;testa\u030a&quot;);
2704         if (!m.find())
2705             failCount++;
2706 
2707         // Composed char inside a char class
2708         p = Pattern.compile(&quot;test[abc\u00e5def\u00e0]&quot;, Pattern.CANON_EQ);
2709         m = p.matcher(&quot;test\u00e5&quot;);
2710         if (!m.find())
2711             failCount++;
2712 
2713         m.reset(&quot;testa\u0300&quot;);
2714         if (!m.find())
2715             failCount++;
2716 
2717         m.reset(&quot;testa\u030a&quot;);
2718         if (!m.find())
2719             failCount++;
2720 
2721         // Marks that cannot legally change order and be equivalent
2722         p = Pattern.compile(&quot;testa\u0308\u0300&quot;, Pattern.CANON_EQ);
2723         check(p, &quot;testa\u0308\u0300&quot;, true);
2724         check(p, &quot;testa\u0300\u0308&quot;, false);
2725 
2726         // Marks that can legally change order and be equivalent
2727         p = Pattern.compile(&quot;testa\u0308\u0323&quot;, Pattern.CANON_EQ);
2728         check(p, &quot;testa\u0308\u0323&quot;, true);
2729         check(p, &quot;testa\u0323\u0308&quot;, true);
2730 
2731         // Test all equivalences of the sequence a\u0308\u0323\u0300
2732         p = Pattern.compile(&quot;testa\u0308\u0323\u0300&quot;, Pattern.CANON_EQ);
2733         check(p, &quot;testa\u0308\u0323\u0300&quot;, true);
2734         check(p, &quot;testa\u0323\u0308\u0300&quot;, true);
2735         check(p, &quot;testa\u0308\u0300\u0323&quot;, true);
2736         check(p, &quot;test\u00e4\u0323\u0300&quot;, true);
2737         check(p, &quot;test\u00e4\u0300\u0323&quot;, true);
2738 
2739         Object[][] data = new Object[][] {
2740 
2741         // JDK-4867170
2742         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2743         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f81cd&quot;,             &quot;f&quot;, true },
2744         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f82cd&quot;,             &quot;f&quot;, true },
2745         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u03b1\u0314\u0345cd&quot;, &quot;f&quot;, true },
2746         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u03b1\u0345\u0314cd&quot;, &quot;f&quot;, true },
2747         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f01\u0345cd&quot;,       &quot;f&quot;, true },
2748         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f00\u0345cd&quot;,       &quot;f&quot;, true },
2749 
2750         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2751         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f81cd&quot;,             &quot;f&quot;, true },
2752         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f82cd&quot;,             &quot;f&quot;, true },
2753         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u03b1\u0314\u0345cd&quot;, &quot;f&quot;, true },
2754         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f01\u0345cd&quot;,       &quot;f&quot;, true },
2755 
2756         // backtracking, force to match &quot;\u1f80&quot;, instead of \u1f82&quot;
2757         { &quot;ab\\p{IsGreek}\u0300cd&quot;, &quot;ab\u03b1\u0313\u0345\u0300cd&quot;, &quot;m&quot;, true },
2758 
2759         { &quot;[\\p{IsGreek}]&quot;,  &quot;\u03b1\u0314\u0345&quot;,     &quot;m&quot;, true },
2760         { &quot;\\p{IsGreek}&quot;,    &quot;\u03b1\u0314\u0345&quot;,     &quot;m&quot;, true },
2761 
2762         { &quot;[^\u1f80-\u1f82]&quot;,&quot;\u1f81&quot;,                 &quot;m&quot;, false },
2763         { &quot;[^\u1f80-\u1f82]&quot;,&quot;\u03b1\u0314\u0345&quot;,     &quot;m&quot;, false },
2764         { &quot;[^\u1f01\u0345]&quot;, &quot;\u1f81&quot;,                 &quot;f&quot;, false },
2765 
2766         { &quot;[^\u1f81]+&quot;,      &quot;\u1f80\u1f82&quot;,           &quot;f&quot;, true },
2767         { &quot;[\u1f80]&quot;,        &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2768         { &quot;\u1f80&quot;,          &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2769         { &quot;\u1f00\u0345\u0300&quot;,  &quot;\u1f82&quot;, &quot;m&quot;, true },
2770         { &quot;\u1f80&quot;,          &quot;-\u1f00\u0345\u0300-&quot;,   &quot;f&quot;, true },
2771         { &quot;\u1f82&quot;,          &quot;\u1f00\u0345\u0300&quot;,     &quot;m&quot;, true },
2772         { &quot;\u1f82&quot;,          &quot;\u1f80\u0300&quot;,           &quot;m&quot;, true },
2773 
2774         // JDK-7080302       # compile failed
2775         { &quot;a(\u0041\u0301\u0328)&quot;, &quot;a\u0041\u0301\u0328&quot;, &quot;m&quot;, true},
2776 
2777         // JDK-6728861, same cause as above one
2778         { &quot;\u00e9\u00e9n&quot;, &quot;e\u0301e\u0301n&quot;, &quot;m&quot;, true},
2779 
2780         // JDK-6995635
2781         { &quot;(\u00e9)&quot;, &quot;e\u0301&quot;, &quot;m&quot;, true },
2782 
2783         // JDK-6736245
2784         // intereting special case, nfc(u2add+u0338) -&gt; u2add+u0338) NOT u2adc
2785         { &quot;\u2ADC&quot;, &quot;\u2ADC&quot;, &quot;m&quot;, true},          // NFC
2786         { &quot;\u2ADC&quot;, &quot;\u2ADD\u0338&quot;, &quot;m&quot;, true},    // NFD
2787 
2788         //  4916384.
2789         // Decomposed hangul (jamos) works inside clazz
2790         { &quot;[\u1100\u1161]&quot;, &quot;\u1100\u1161&quot;, &quot;m&quot;, true},
2791         { &quot;[\u1100\u1161]&quot;, &quot;\uac00&quot;, &quot;m&quot;, true},
2792 
2793         { &quot;[\uac00]&quot;, &quot;\u1100\u1161&quot;, &quot;m&quot;, true},
2794         { &quot;[\uac00]&quot;, &quot;\uac00&quot;, &quot;m&quot;, true},
2795 
2796         // Decomposed hangul (jamos)
2797         { &quot;\u1100\u1161&quot;, &quot;\u1100\u1161&quot;, &quot;m&quot;, true},
2798         { &quot;\u1100\u1161&quot;, &quot;\uac00&quot;, &quot;m&quot;, true},
2799 
2800         // Composed hangul
2801         { &quot;\uac00&quot;,  &quot;\u1100\u1161&quot;, &quot;m&quot;, true },
2802         { &quot;\uac00&quot;,  &quot;\uac00&quot;, &quot;m&quot;, true },
2803 
2804         /* Need a NFDSlice to nfd the source to solve this issue
2805            u+1d1c0 -&gt; nfd: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt;  -&gt; nfc: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt;
2806            u+1d1bc -&gt; nfd: &lt;u+1d1ba&gt;&lt;u+1d165&gt;           -&gt; nfc: &lt;u+1d1ba&gt;&lt;u+1d165&gt;
2807            &lt;u+1d1bc&gt;&lt;u+1d16f&gt; -&gt; nfd: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt; -&gt; nfc: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt;
2808 
2809         // Decomposed supplementary outside char classes
2810         // { &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;test\ud834\uddc0&quot;, &quot;m&quot;, true },
2811         // Composed supplementary outside char classes
2812         // { &quot;test\ud834\uddc0&quot;, &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;m&quot;, true },
2813         */
2814         { &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;m&quot;, true },
2815         { &quot;test\ud834\uddc0&quot;,             &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;m&quot;, true },
2816 
2817         { &quot;test\ud834\uddc0&quot;,             &quot;test\ud834\uddc0&quot;,             &quot;m&quot;, true },
2818         { &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;test\ud834\uddc0&quot;,             &quot;m&quot;, true },
2819         };
2820 
2821         int failCount = 0;
2822         for (Object[] d : data) {
2823             String pn = (String)d[0];
2824             String tt = (String)d[1];
2825             boolean isFind = &quot;f&quot;.equals(((String)d[2]));
2826             boolean expected = (boolean)d[3];
2827             boolean ret = isFind ? Pattern.compile(pn, Pattern.CANON_EQ).matcher(tt).find()
2828                                  : Pattern.compile(pn, Pattern.CANON_EQ).matcher(tt).matches();
2829             if (ret != expected) {
2830                 failCount++;
2831                 continue;
2832             }
2833         }
2834         report(&quot;Canonical Equivalence&quot;);
2835     }
2836 
2837     /**
2838      * A basic sanity test of Matcher.replaceAll().
2839      */
2840     private static void globalSubstitute() throws Exception {
2841         // Global substitution with a literal
2842         Pattern p = Pattern.compile(&quot;(ab)(c*)&quot;);
2843         Matcher m = p.matcher(&quot;abccczzzabcczzzabccc&quot;);
2844         if (!m.replaceAll(&quot;test&quot;).equals(&quot;testzzztestzzztest&quot;))
2845             failCount++;
2846 
2847         m.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
2848         if (!m.replaceAll(&quot;test&quot;).equals(&quot;zzztestzzztestzzztestzzz&quot;))
2849             failCount++;
2850 
2851         // Global substitution with groups
2852         m.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
2853         String result = m.replaceAll(&quot;$1&quot;);
2854         if (!result.equals(&quot;zzzabzzzabzzzabzzz&quot;))
2855             failCount++;
2856 
2857         // Supplementary character test
2858         // Global substitution with a literal
2859         p = Pattern.compile(toSupplementaries(&quot;(ab)(c*)&quot;));
2860         m = p.matcher(toSupplementaries(&quot;abccczzzabcczzzabccc&quot;));
2861         if (!m.replaceAll(toSupplementaries(&quot;test&quot;)).
2862             equals(toSupplementaries(&quot;testzzztestzzztest&quot;)))
2863             failCount++;
2864 
2865         m.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
2866         if (!m.replaceAll(toSupplementaries(&quot;test&quot;)).
2867             equals(toSupplementaries(&quot;zzztestzzztestzzztestzzz&quot;)))
2868             failCount++;
2869 
2870         // Global substitution with groups
2871         m.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
2872         result = m.replaceAll(&quot;$1&quot;);
2873         if (!result.equals(toSupplementaries(&quot;zzzabzzzabzzzabzzz&quot;)))
2874             failCount++;
2875 
2876         report(&quot;Global Substitution&quot;);
2877     }
2878 
2879     /**
2880      * Tests the usage of Matcher.appendReplacement() with literal
2881      * and group substitutions.
2882      */
2883     private static void stringbufferSubstitute() throws Exception {
2884         // SB substitution with literal
2885         String blah = &quot;zzzblahzzz&quot;;
2886         Pattern p = Pattern.compile(&quot;blah&quot;);
2887         Matcher m = p.matcher(blah);
2888         StringBuffer result = new StringBuffer();
2889         try {
2890             m.appendReplacement(result, &quot;blech&quot;);
2891             failCount++;
2892         } catch (IllegalStateException e) {
2893         }
2894         m.find();
2895         m.appendReplacement(result, &quot;blech&quot;);
2896         if (!result.toString().equals(&quot;zzzblech&quot;))
2897             failCount++;
2898 
2899         m.appendTail(result);
2900         if (!result.toString().equals(&quot;zzzblechzzz&quot;))
2901             failCount++;
2902 
2903         // SB substitution with groups
2904         blah = &quot;zzzabcdzzz&quot;;
2905         p = Pattern.compile(&quot;(ab)(cd)*&quot;);
2906         m = p.matcher(blah);
2907         result = new StringBuffer();
2908         try {
2909             m.appendReplacement(result, &quot;$1&quot;);
2910             failCount++;
2911         } catch (IllegalStateException e) {
2912         }
2913         m.find();
2914         m.appendReplacement(result, &quot;$1&quot;);
2915         if (!result.toString().equals(&quot;zzzab&quot;))
2916             failCount++;
2917 
2918         m.appendTail(result);
2919         if (!result.toString().equals(&quot;zzzabzzz&quot;))
2920             failCount++;
2921 
2922         // SB substitution with 3 groups
2923         blah = &quot;zzzabcdcdefzzz&quot;;
2924         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
2925         m = p.matcher(blah);
2926         result = new StringBuffer();
2927         try {
2928             m.appendReplacement(result, &quot;$1w$2w$3&quot;);
2929             failCount++;
2930         } catch (IllegalStateException e) {
2931         }
2932         m.find();
2933         m.appendReplacement(result, &quot;$1w$2w$3&quot;);
2934         if (!result.toString().equals(&quot;zzzabwcdwef&quot;))
2935             failCount++;
2936 
2937         m.appendTail(result);
2938         if (!result.toString().equals(&quot;zzzabwcdwefzzz&quot;))
2939             failCount++;
2940 
2941         // SB substitution with groups and three matches
2942         // skipping middle match
2943         blah = &quot;zzzabcdzzzabcddzzzabcdzzz&quot;;
2944         p = Pattern.compile(&quot;(ab)(cd*)&quot;);
2945         m = p.matcher(blah);
2946         result = new StringBuffer();
2947         try {
2948             m.appendReplacement(result, &quot;$1&quot;);
2949             failCount++;
2950         } catch (IllegalStateException e) {
2951         }
2952         m.find();
2953         m.appendReplacement(result, &quot;$1&quot;);
2954         if (!result.toString().equals(&quot;zzzab&quot;))
2955             failCount++;
2956 
2957         m.find();
2958         m.find();
2959         m.appendReplacement(result, &quot;$2&quot;);
2960         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcd&quot;))
2961             failCount++;
2962 
2963         m.appendTail(result);
2964         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcdzzz&quot;))
2965             failCount++;
2966 
2967         // Check to make sure escaped $ is ignored
2968         blah = &quot;zzzabcdcdefzzz&quot;;
2969         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
2970         m = p.matcher(blah);
2971         result = new StringBuffer();
2972         m.find();
2973         m.appendReplacement(result, &quot;$1w\\$2w$3&quot;);
2974         if (!result.toString().equals(&quot;zzzabw$2wef&quot;))
2975             failCount++;
2976 
2977         m.appendTail(result);
2978         if (!result.toString().equals(&quot;zzzabw$2wefzzz&quot;))
2979             failCount++;
2980 
2981         // Check to make sure a reference to nonexistent group causes error
2982         blah = &quot;zzzabcdcdefzzz&quot;;
2983         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
2984         m = p.matcher(blah);
2985         result = new StringBuffer();
2986         m.find();
2987         try {
2988             m.appendReplacement(result, &quot;$1w$5w$3&quot;);
2989             failCount++;
2990         } catch (IndexOutOfBoundsException ioobe) {
2991             // Correct result
2992         }
2993 
2994         // Check double digit group references
2995         blah = &quot;zzz123456789101112zzz&quot;;
2996         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
2997         m = p.matcher(blah);
2998         result = new StringBuffer();
2999         m.find();
3000         m.appendReplacement(result, &quot;$1w$11w$3&quot;);
3001         if (!result.toString().equals(&quot;zzz1w11w3&quot;))
3002             failCount++;
3003 
3004         // Check to make sure it backs off $15 to $1 if only three groups
3005         blah = &quot;zzzabcdcdefzzz&quot;;
3006         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3007         m = p.matcher(blah);
3008         result = new StringBuffer();
3009         m.find();
3010         m.appendReplacement(result, &quot;$1w$15w$3&quot;);
3011         if (!result.toString().equals(&quot;zzzabwab5wef&quot;))
3012             failCount++;
3013 
3014 
3015         // Supplementary character test
3016         // SB substitution with literal
3017         blah = toSupplementaries(&quot;zzzblahzzz&quot;);
3018         p = Pattern.compile(toSupplementaries(&quot;blah&quot;));
3019         m = p.matcher(blah);
3020         result = new StringBuffer();
3021         try {
3022             m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
3023             failCount++;
3024         } catch (IllegalStateException e) {
3025         }
3026         m.find();
3027         m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
3028         if (!result.toString().equals(toSupplementaries(&quot;zzzblech&quot;)))
3029             failCount++;
3030 
3031         m.appendTail(result);
3032         if (!result.toString().equals(toSupplementaries(&quot;zzzblechzzz&quot;)))
3033             failCount++;
3034 
3035         // SB substitution with groups
3036         blah = toSupplementaries(&quot;zzzabcdzzz&quot;);
3037         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*&quot;));
3038         m = p.matcher(blah);
3039         result = new StringBuffer();
3040         try {
3041             m.appendReplacement(result, &quot;$1&quot;);
3042             failCount++;
3043         } catch (IllegalStateException e) {
3044         }
3045         m.find();
3046         m.appendReplacement(result, &quot;$1&quot;);
3047         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3048             failCount++;
3049 
3050         m.appendTail(result);
3051         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzz&quot;)))
3052             failCount++;
3053 
3054         // SB substitution with 3 groups
3055         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3056         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3057         m = p.matcher(blah);
3058         result = new StringBuffer();
3059         try {
3060             m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3061             failCount++;
3062         } catch (IllegalStateException e) {
3063         }
3064         m.find();
3065         m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3066         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwef&quot;)))
3067             failCount++;
3068 
3069         m.appendTail(result);
3070         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwefzzz&quot;)))
3071             failCount++;
3072 
3073         // SB substitution with groups and three matches
3074         // skipping middle match
3075         blah = toSupplementaries(&quot;zzzabcdzzzabcddzzzabcdzzz&quot;);
3076         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd*)&quot;));
3077         m = p.matcher(blah);
3078         result = new StringBuffer();
3079         try {
3080             m.appendReplacement(result, &quot;$1&quot;);
3081             failCount++;
3082         } catch (IllegalStateException e) {
3083         }
3084         m.find();
3085         m.appendReplacement(result, &quot;$1&quot;);
3086         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3087             failCount++;
3088 
3089         m.find();
3090         m.find();
3091         m.appendReplacement(result, &quot;$2&quot;);
3092         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcd&quot;)))
3093             failCount++;
3094 
3095         m.appendTail(result);
3096         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcdzzz&quot;)))
3097             failCount++;
3098 
3099         // Check to make sure escaped $ is ignored
3100         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3101         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3102         m = p.matcher(blah);
3103         result = new StringBuffer();
3104         m.find();
3105         m.appendReplacement(result, toSupplementaries(&quot;$1w\\$2w$3&quot;));
3106         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wef&quot;)))
3107             failCount++;
3108 
3109         m.appendTail(result);
3110         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wefzzz&quot;)))
3111             failCount++;
3112 
3113         // Check to make sure a reference to nonexistent group causes error
3114         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3115         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3116         m = p.matcher(blah);
3117         result = new StringBuffer();
3118         m.find();
3119         try {
3120             m.appendReplacement(result, toSupplementaries(&quot;$1w$5w$3&quot;));
3121             failCount++;
3122         } catch (IndexOutOfBoundsException ioobe) {
3123             // Correct result
3124         }
3125 
3126         // Check double digit group references
3127         blah = toSupplementaries(&quot;zzz123456789101112zzz&quot;);
3128         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
3129         m = p.matcher(blah);
3130         result = new StringBuffer();
3131         m.find();
3132         m.appendReplacement(result, toSupplementaries(&quot;$1w$11w$3&quot;));
3133         if (!result.toString().equals(toSupplementaries(&quot;zzz1w11w3&quot;)))
3134             failCount++;
3135 
3136         // Check to make sure it backs off $15 to $1 if only three groups
3137         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3138         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3139         m = p.matcher(blah);
3140         result = new StringBuffer();
3141         m.find();
3142         m.appendReplacement(result, toSupplementaries(&quot;$1w$15w$3&quot;));
3143         if (!result.toString().equals(toSupplementaries(&quot;zzzabwab5wef&quot;)))
3144             failCount++;
3145 
3146         // Check nothing has been appended into the output buffer if
3147         // the replacement string triggers IllegalArgumentException.
3148         p = Pattern.compile(&quot;(abc)&quot;);
3149         m = p.matcher(&quot;abcd&quot;);
3150         result = new StringBuffer();
3151         m.find();
3152         try {
3153             m.appendReplacement(result, (&quot;xyz$g&quot;));
3154             failCount++;
3155         } catch (IllegalArgumentException iae) {
3156             if (result.length() != 0)
3157                 failCount++;
3158         }
3159 
3160         report(&quot;SB Substitution&quot;);
3161     }
3162 
3163     /**
3164      * Tests the usage of Matcher.appendReplacement() with literal
3165      * and group substitutions.
3166      */
3167     private static void stringbuilderSubstitute() throws Exception {
3168         // SB substitution with literal
3169         String blah = &quot;zzzblahzzz&quot;;
3170         Pattern p = Pattern.compile(&quot;blah&quot;);
3171         Matcher m = p.matcher(blah);
3172         StringBuilder result = new StringBuilder();
3173         try {
3174             m.appendReplacement(result, &quot;blech&quot;);
3175             failCount++;
3176         } catch (IllegalStateException e) {
3177         }
3178         m.find();
3179         m.appendReplacement(result, &quot;blech&quot;);
3180         if (!result.toString().equals(&quot;zzzblech&quot;))
3181             failCount++;
3182 
3183         m.appendTail(result);
3184         if (!result.toString().equals(&quot;zzzblechzzz&quot;))
3185             failCount++;
3186 
3187         // SB substitution with groups
3188         blah = &quot;zzzabcdzzz&quot;;
3189         p = Pattern.compile(&quot;(ab)(cd)*&quot;);
3190         m = p.matcher(blah);
3191         result = new StringBuilder();
3192         try {
3193             m.appendReplacement(result, &quot;$1&quot;);
3194             failCount++;
3195         } catch (IllegalStateException e) {
3196         }
3197         m.find();
3198         m.appendReplacement(result, &quot;$1&quot;);
3199         if (!result.toString().equals(&quot;zzzab&quot;))
3200             failCount++;
3201 
3202         m.appendTail(result);
3203         if (!result.toString().equals(&quot;zzzabzzz&quot;))
3204             failCount++;
3205 
3206         // SB substitution with 3 groups
3207         blah = &quot;zzzabcdcdefzzz&quot;;
3208         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3209         m = p.matcher(blah);
3210         result = new StringBuilder();
3211         try {
3212             m.appendReplacement(result, &quot;$1w$2w$3&quot;);
3213             failCount++;
3214         } catch (IllegalStateException e) {
3215         }
3216         m.find();
3217         m.appendReplacement(result, &quot;$1w$2w$3&quot;);
3218         if (!result.toString().equals(&quot;zzzabwcdwef&quot;))
3219             failCount++;
3220 
3221         m.appendTail(result);
3222         if (!result.toString().equals(&quot;zzzabwcdwefzzz&quot;))
3223             failCount++;
3224 
3225         // SB substitution with groups and three matches
3226         // skipping middle match
3227         blah = &quot;zzzabcdzzzabcddzzzabcdzzz&quot;;
3228         p = Pattern.compile(&quot;(ab)(cd*)&quot;);
3229         m = p.matcher(blah);
3230         result = new StringBuilder();
3231         try {
3232             m.appendReplacement(result, &quot;$1&quot;);
3233             failCount++;
3234         } catch (IllegalStateException e) {
3235         }
3236         m.find();
3237         m.appendReplacement(result, &quot;$1&quot;);
3238         if (!result.toString().equals(&quot;zzzab&quot;))
3239             failCount++;
3240 
3241         m.find();
3242         m.find();
3243         m.appendReplacement(result, &quot;$2&quot;);
3244         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcd&quot;))
3245             failCount++;
3246 
3247         m.appendTail(result);
3248         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcdzzz&quot;))
3249             failCount++;
3250 
3251         // Check to make sure escaped $ is ignored
3252         blah = &quot;zzzabcdcdefzzz&quot;;
3253         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3254         m = p.matcher(blah);
3255         result = new StringBuilder();
3256         m.find();
3257         m.appendReplacement(result, &quot;$1w\\$2w$3&quot;);
3258         if (!result.toString().equals(&quot;zzzabw$2wef&quot;))
3259             failCount++;
3260 
3261         m.appendTail(result);
3262         if (!result.toString().equals(&quot;zzzabw$2wefzzz&quot;))
3263             failCount++;
3264 
3265         // Check to make sure a reference to nonexistent group causes error
3266         blah = &quot;zzzabcdcdefzzz&quot;;
3267         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3268         m = p.matcher(blah);
3269         result = new StringBuilder();
3270         m.find();
3271         try {
3272             m.appendReplacement(result, &quot;$1w$5w$3&quot;);
3273             failCount++;
3274         } catch (IndexOutOfBoundsException ioobe) {
3275             // Correct result
3276         }
3277 
3278         // Check double digit group references
3279         blah = &quot;zzz123456789101112zzz&quot;;
3280         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
3281         m = p.matcher(blah);
3282         result = new StringBuilder();
3283         m.find();
3284         m.appendReplacement(result, &quot;$1w$11w$3&quot;);
3285         if (!result.toString().equals(&quot;zzz1w11w3&quot;))
3286             failCount++;
3287 
3288         // Check to make sure it backs off $15 to $1 if only three groups
3289         blah = &quot;zzzabcdcdefzzz&quot;;
3290         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3291         m = p.matcher(blah);
3292         result = new StringBuilder();
3293         m.find();
3294         m.appendReplacement(result, &quot;$1w$15w$3&quot;);
3295         if (!result.toString().equals(&quot;zzzabwab5wef&quot;))
3296             failCount++;
3297 
3298 
3299         // Supplementary character test
3300         // SB substitution with literal
3301         blah = toSupplementaries(&quot;zzzblahzzz&quot;);
3302         p = Pattern.compile(toSupplementaries(&quot;blah&quot;));
3303         m = p.matcher(blah);
3304         result = new StringBuilder();
3305         try {
3306             m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
3307             failCount++;
3308         } catch (IllegalStateException e) {
3309         }
3310         m.find();
3311         m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
3312         if (!result.toString().equals(toSupplementaries(&quot;zzzblech&quot;)))
3313             failCount++;
3314         m.appendTail(result);
3315         if (!result.toString().equals(toSupplementaries(&quot;zzzblechzzz&quot;)))
3316             failCount++;
3317 
3318         // SB substitution with groups
3319         blah = toSupplementaries(&quot;zzzabcdzzz&quot;);
3320         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*&quot;));
3321         m = p.matcher(blah);
3322         result = new StringBuilder();
3323         try {
3324             m.appendReplacement(result, &quot;$1&quot;);
3325             failCount++;
3326         } catch (IllegalStateException e) {
3327         }
3328         m.find();
3329         m.appendReplacement(result, &quot;$1&quot;);
3330         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3331             failCount++;
3332 
3333         m.appendTail(result);
3334         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzz&quot;)))
3335             failCount++;
3336 
3337         // SB substitution with 3 groups
3338         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3339         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3340         m = p.matcher(blah);
3341         result = new StringBuilder();
3342         try {
3343             m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3344             failCount++;
3345         } catch (IllegalStateException e) {
3346         }
3347         m.find();
3348         m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3349         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwef&quot;)))
3350             failCount++;
3351 
3352         m.appendTail(result);
3353         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwefzzz&quot;)))
3354             failCount++;
3355 
3356         // SB substitution with groups and three matches
3357         // skipping middle match
3358         blah = toSupplementaries(&quot;zzzabcdzzzabcddzzzabcdzzz&quot;);
3359         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd*)&quot;));
3360         m = p.matcher(blah);
3361         result = new StringBuilder();
3362         try {
3363             m.appendReplacement(result, &quot;$1&quot;);
3364             failCount++;
3365         } catch (IllegalStateException e) {
3366         }
3367         m.find();
3368         m.appendReplacement(result, &quot;$1&quot;);
3369         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3370             failCount++;
3371 
3372         m.find();
3373         m.find();
3374         m.appendReplacement(result, &quot;$2&quot;);
3375         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcd&quot;)))
3376             failCount++;
3377 
3378         m.appendTail(result);
3379         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcdzzz&quot;)))
3380             failCount++;
3381 
3382         // Check to make sure escaped $ is ignored
3383         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3384         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3385         m = p.matcher(blah);
3386         result = new StringBuilder();
3387         m.find();
3388         m.appendReplacement(result, toSupplementaries(&quot;$1w\\$2w$3&quot;));
3389         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wef&quot;)))
3390             failCount++;
3391 
3392         m.appendTail(result);
3393         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wefzzz&quot;)))
3394             failCount++;
3395 
3396         // Check to make sure a reference to nonexistent group causes error
3397         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3398         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3399         m = p.matcher(blah);
3400         result = new StringBuilder();
3401         m.find();
3402         try {
3403             m.appendReplacement(result, toSupplementaries(&quot;$1w$5w$3&quot;));
3404             failCount++;
3405         } catch (IndexOutOfBoundsException ioobe) {
3406             // Correct result
3407         }
3408         // Check double digit group references
3409         blah = toSupplementaries(&quot;zzz123456789101112zzz&quot;);
3410         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
3411         m = p.matcher(blah);
3412         result = new StringBuilder();
3413         m.find();
3414         m.appendReplacement(result, toSupplementaries(&quot;$1w$11w$3&quot;));
3415         if (!result.toString().equals(toSupplementaries(&quot;zzz1w11w3&quot;)))
3416             failCount++;
3417 
3418         // Check to make sure it backs off $15 to $1 if only three groups
3419         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3420         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3421         m = p.matcher(blah);
3422         result = new StringBuilder();
3423         m.find();
3424         m.appendReplacement(result, toSupplementaries(&quot;$1w$15w$3&quot;));
3425         if (!result.toString().equals(toSupplementaries(&quot;zzzabwab5wef&quot;)))
3426             failCount++;
3427         // Check nothing has been appended into the output buffer if
3428         // the replacement string triggers IllegalArgumentException.
3429         p = Pattern.compile(&quot;(abc)&quot;);
3430         m = p.matcher(&quot;abcd&quot;);
3431         result = new StringBuilder();
3432         m.find();
3433         try {
3434             m.appendReplacement(result, (&quot;xyz$g&quot;));
3435             failCount++;
3436         } catch (IllegalArgumentException iae) {
3437             if (result.length() != 0)
3438                 failCount++;
3439         }
3440         report(&quot;SB Substitution 2&quot;);
3441     }
3442 
3443     /*
3444      * 5 groups of characters are created to make a substitution string.
3445      * A base string will be created including random lead chars, the
3446      * substitution string, and random trailing chars.
3447      * A pattern containing the 5 groups is searched for and replaced with:
3448      * random group + random string + random group.
3449      * The results are checked for correctness.
3450      */
3451     private static void substitutionBasher() {
3452         for (int runs = 0; runs&lt;1000; runs++) {
3453             // Create a base string to work in
3454             int leadingChars = generator.nextInt(10);
3455             StringBuffer baseBuffer = new StringBuffer(100);
3456             String leadingString = getRandomAlphaString(leadingChars);
3457             baseBuffer.append(leadingString);
3458 
3459             // Create 5 groups of random number of random chars
3460             // Create the string to substitute
3461             // Create the pattern string to search for
3462             StringBuffer bufferToSub = new StringBuffer(25);
3463             StringBuffer bufferToPat = new StringBuffer(50);
3464             String[] groups = new String[5];
3465             for(int i=0; i&lt;5; i++) {
3466                 int aGroupSize = generator.nextInt(5)+1;
3467                 groups[i] = getRandomAlphaString(aGroupSize);
3468                 bufferToSub.append(groups[i]);
3469                 bufferToPat.append(&#39;(&#39;);
3470                 bufferToPat.append(groups[i]);
3471                 bufferToPat.append(&#39;)&#39;);
3472             }
3473             String stringToSub = bufferToSub.toString();
3474             String pattern = bufferToPat.toString();
3475 
3476             // Place sub string into working string at random index
3477             baseBuffer.append(stringToSub);
3478 
3479             // Append random chars to end
3480             int trailingChars = generator.nextInt(10);
3481             String trailingString = getRandomAlphaString(trailingChars);
3482             baseBuffer.append(trailingString);
3483             String baseString = baseBuffer.toString();
3484 
3485             // Create test pattern and matcher
3486             Pattern p = Pattern.compile(pattern);
3487             Matcher m = p.matcher(baseString);
3488 
3489             // Reject candidate if pattern happens to start early
3490             m.find();
3491             if (m.start() &lt; leadingChars)
3492                 continue;
3493 
3494             // Reject candidate if more than one match
3495             if (m.find())
3496                 continue;
3497 
3498             // Construct a replacement string with :
3499             // random group + random string + random group
3500             StringBuffer bufferToRep = new StringBuffer();
3501             int groupIndex1 = generator.nextInt(5);
3502             bufferToRep.append(&quot;$&quot; + (groupIndex1 + 1));
3503             String randomMidString = getRandomAlphaString(5);
3504             bufferToRep.append(randomMidString);
3505             int groupIndex2 = generator.nextInt(5);
3506             bufferToRep.append(&quot;$&quot; + (groupIndex2 + 1));
3507             String replacement = bufferToRep.toString();
3508 
3509             // Do the replacement
3510             String result = m.replaceAll(replacement);
3511 
3512             // Construct expected result
3513             StringBuffer bufferToRes = new StringBuffer();
3514             bufferToRes.append(leadingString);
3515             bufferToRes.append(groups[groupIndex1]);
3516             bufferToRes.append(randomMidString);
3517             bufferToRes.append(groups[groupIndex2]);
3518             bufferToRes.append(trailingString);
3519             String expectedResult = bufferToRes.toString();
3520 
3521             // Check results
3522             if (!result.equals(expectedResult))
3523                 failCount++;
3524         }
3525 
3526         report(&quot;Substitution Basher&quot;);
3527     }
3528 
3529     /*
3530      * 5 groups of characters are created to make a substitution string.
3531      * A base string will be created including random lead chars, the
3532      * substitution string, and random trailing chars.
3533      * A pattern containing the 5 groups is searched for and replaced with:
3534      * random group + random string + random group.
3535      * The results are checked for correctness.
3536      */
3537     private static void substitutionBasher2() {
3538         for (int runs = 0; runs&lt;1000; runs++) {
3539             // Create a base string to work in
3540             int leadingChars = generator.nextInt(10);
3541             StringBuilder baseBuffer = new StringBuilder(100);
3542             String leadingString = getRandomAlphaString(leadingChars);
3543             baseBuffer.append(leadingString);
3544 
3545             // Create 5 groups of random number of random chars
3546             // Create the string to substitute
3547             // Create the pattern string to search for
3548             StringBuilder bufferToSub = new StringBuilder(25);
3549             StringBuilder bufferToPat = new StringBuilder(50);
3550             String[] groups = new String[5];
3551             for(int i=0; i&lt;5; i++) {
3552                 int aGroupSize = generator.nextInt(5)+1;
3553                 groups[i] = getRandomAlphaString(aGroupSize);
3554                 bufferToSub.append(groups[i]);
3555                 bufferToPat.append(&#39;(&#39;);
3556                 bufferToPat.append(groups[i]);
3557                 bufferToPat.append(&#39;)&#39;);
3558             }
3559             String stringToSub = bufferToSub.toString();
3560             String pattern = bufferToPat.toString();
3561 
3562             // Place sub string into working string at random index
3563             baseBuffer.append(stringToSub);
3564 
3565             // Append random chars to end
3566             int trailingChars = generator.nextInt(10);
3567             String trailingString = getRandomAlphaString(trailingChars);
3568             baseBuffer.append(trailingString);
3569             String baseString = baseBuffer.toString();
3570 
3571             // Create test pattern and matcher
3572             Pattern p = Pattern.compile(pattern);
3573             Matcher m = p.matcher(baseString);
3574 
3575             // Reject candidate if pattern happens to start early
3576             m.find();
3577             if (m.start() &lt; leadingChars)
3578                 continue;
3579 
3580             // Reject candidate if more than one match
3581             if (m.find())
3582                 continue;
3583 
3584             // Construct a replacement string with :
3585             // random group + random string + random group
3586             StringBuilder bufferToRep = new StringBuilder();
3587             int groupIndex1 = generator.nextInt(5);
3588             bufferToRep.append(&quot;$&quot; + (groupIndex1 + 1));
3589             String randomMidString = getRandomAlphaString(5);
3590             bufferToRep.append(randomMidString);
3591             int groupIndex2 = generator.nextInt(5);
3592             bufferToRep.append(&quot;$&quot; + (groupIndex2 + 1));
3593             String replacement = bufferToRep.toString();
3594 
3595             // Do the replacement
3596             String result = m.replaceAll(replacement);
3597 
3598             // Construct expected result
3599             StringBuilder bufferToRes = new StringBuilder();
3600             bufferToRes.append(leadingString);
3601             bufferToRes.append(groups[groupIndex1]);
3602             bufferToRes.append(randomMidString);
3603             bufferToRes.append(groups[groupIndex2]);
3604             bufferToRes.append(trailingString);
3605             String expectedResult = bufferToRes.toString();
3606 
3607             // Check results
3608             if (!result.equals(expectedResult)) {
3609                 failCount++;
3610             }
3611         }
3612 
3613         report(&quot;Substitution Basher 2&quot;);
3614     }
3615 
3616     /**
3617      * Checks the handling of some escape sequences that the Pattern
3618      * class should process instead of the java compiler. These are
3619      * not in the file because the escapes should be be processed
3620      * by the Pattern class when the regex is compiled.
3621      */
3622     private static void escapes() throws Exception {
3623         Pattern p = Pattern.compile(&quot;\\043&quot;);
3624         Matcher m = p.matcher(&quot;#&quot;);
3625         if (!m.find())
3626             failCount++;
3627 
3628         p = Pattern.compile(&quot;\\x23&quot;);
3629         m = p.matcher(&quot;#&quot;);
3630         if (!m.find())
3631             failCount++;
3632 
3633         p = Pattern.compile(&quot;\\u0023&quot;);
3634         m = p.matcher(&quot;#&quot;);
3635         if (!m.find())
3636             failCount++;
3637 
3638         report(&quot;Escape sequences&quot;);
3639     }
3640 
3641     /**
3642      * Checks the handling of blank input situations. These
3643      * tests are incompatible with my test file format.
3644      */
3645     private static void blankInput() throws Exception {
3646         Pattern p = Pattern.compile(&quot;abc&quot;, Pattern.CASE_INSENSITIVE);
3647         Matcher m = p.matcher(&quot;&quot;);
3648         if (m.find())
3649             failCount++;
3650 
3651         p = Pattern.compile(&quot;a*&quot;, Pattern.CASE_INSENSITIVE);
3652         m = p.matcher(&quot;&quot;);
3653         if (!m.find())
3654             failCount++;
3655 
3656         p = Pattern.compile(&quot;abc&quot;);
3657         m = p.matcher(&quot;&quot;);
3658         if (m.find())
3659             failCount++;
3660 
3661         p = Pattern.compile(&quot;a*&quot;);
3662         m = p.matcher(&quot;&quot;);
3663         if (!m.find())
3664             failCount++;
3665 
3666         report(&quot;Blank input&quot;);
3667     }
3668 
3669     /**
3670      * Tests the Boyer-Moore pattern matching of a character sequence
3671      * on randomly generated patterns.
3672      */
3673     private static void bm() throws Exception {
3674         doBnM(&#39;a&#39;);
3675         report(&quot;Boyer Moore (ASCII)&quot;);
3676 
3677         doBnM(Character.MIN_SUPPLEMENTARY_CODE_POINT - 10);
3678         report(&quot;Boyer Moore (Supplementary)&quot;);
3679     }
3680 
3681     private static void doBnM(int baseCharacter) throws Exception {
3682         int achar=0;
3683 
3684         for (int i=0; i&lt;100; i++) {
3685             // Create a short pattern to search for
3686             int patternLength = generator.nextInt(7) + 4;
3687             StringBuffer patternBuffer = new StringBuffer(patternLength);
3688             String pattern;
3689             retry: for (;;) {
3690                 for (int x=0; x&lt;patternLength; x++) {
3691                     int ch = baseCharacter + generator.nextInt(26);
3692                     if (Character.isSupplementaryCodePoint(ch)) {
3693                         patternBuffer.append(Character.toChars(ch));
3694                     } else {
3695                         patternBuffer.append((char)ch);
3696                     }
3697                 }
3698                 pattern = patternBuffer.toString();
3699 
3700                 // Avoid patterns that start and end with the same substring
3701                 // See JDK-6854417
3702                 for (int x=1; x &lt; pattern.length(); x++) {
3703                     if (pattern.startsWith(pattern.substring(x)))
3704                         continue retry;
3705                 }
3706                 break;
3707             }
3708             Pattern p = Pattern.compile(pattern);
3709 
3710             // Create a buffer with random ASCII chars that does
3711             // not match the sample
3712             String toSearch = null;
3713             StringBuffer s = null;
3714             Matcher m = p.matcher(&quot;&quot;);
3715             do {
3716                 s = new StringBuffer(100);
3717                 for (int x=0; x&lt;100; x++) {
3718                     int ch = baseCharacter + generator.nextInt(26);
3719                     if (Character.isSupplementaryCodePoint(ch)) {
3720                         s.append(Character.toChars(ch));
3721                     } else {
3722                         s.append((char)ch);
3723                     }
3724                 }
3725                 toSearch = s.toString();
3726                 m.reset(toSearch);
3727             } while (m.find());
3728 
3729             // Insert the pattern at a random spot
3730             int insertIndex = generator.nextInt(99);
3731             if (Character.isLowSurrogate(s.charAt(insertIndex)))
3732                 insertIndex++;
3733             s = s.insert(insertIndex, pattern);
3734             toSearch = s.toString();
3735 
3736             // Make sure that the pattern is found
3737             m.reset(toSearch);
3738             if (!m.find())
3739                 failCount++;
3740 
3741             // Make sure that the match text is the pattern
3742             if (!m.group().equals(pattern))
3743                 failCount++;
3744 
3745             // Make sure match occured at insertion point
3746             if (m.start() != insertIndex)
3747                 failCount++;
3748         }
3749     }
3750 
3751     /**
3752      * Tests the matching of slices on randomly generated patterns.
3753      * The Boyer-Moore optimization is not done on these patterns
3754      * because it uses unicode case folding.
3755      */
3756     private static void slice() throws Exception {
3757         doSlice(Character.MAX_VALUE);
3758         report(&quot;Slice&quot;);
3759 
3760         doSlice(Character.MAX_CODE_POINT);
3761         report(&quot;Slice (Supplementary)&quot;);
3762     }
3763 
3764     private static void doSlice(int maxCharacter) throws Exception {
3765         Random generator = new Random();
3766         int achar=0;
3767 
3768         for (int i=0; i&lt;100; i++) {
3769             // Create a short pattern to search for
3770             int patternLength = generator.nextInt(7) + 4;
3771             StringBuffer patternBuffer = new StringBuffer(patternLength);
3772             for (int x=0; x&lt;patternLength; x++) {
3773                 int randomChar = 0;
3774                 while (!Character.isLetterOrDigit(randomChar))
3775                     randomChar = generator.nextInt(maxCharacter);
3776                 if (Character.isSupplementaryCodePoint(randomChar)) {
3777                     patternBuffer.append(Character.toChars(randomChar));
3778                 } else {
3779                     patternBuffer.append((char) randomChar);
3780                 }
3781             }
3782             String pattern =  patternBuffer.toString();
3783             Pattern p = Pattern.compile(pattern, Pattern.UNICODE_CASE);
3784 
3785             // Create a buffer with random chars that does not match the sample
3786             String toSearch = null;
3787             StringBuffer s = null;
3788             Matcher m = p.matcher(&quot;&quot;);
3789             do {
3790                 s = new StringBuffer(100);
3791                 for (int x=0; x&lt;100; x++) {
3792                     int randomChar = 0;
3793                     while (!Character.isLetterOrDigit(randomChar))
3794                         randomChar = generator.nextInt(maxCharacter);
3795                     if (Character.isSupplementaryCodePoint(randomChar)) {
3796                         s.append(Character.toChars(randomChar));
3797                     } else {
3798                         s.append((char) randomChar);
3799                     }
3800                 }
3801                 toSearch = s.toString();
3802                 m.reset(toSearch);
3803             } while (m.find());
3804 
3805             // Insert the pattern at a random spot
3806             int insertIndex = generator.nextInt(99);
3807             if (Character.isLowSurrogate(s.charAt(insertIndex)))
3808                 insertIndex++;
3809             s = s.insert(insertIndex, pattern);
3810             toSearch = s.toString();
3811 
3812             // Make sure that the pattern is found
3813             m.reset(toSearch);
3814             if (!m.find())
3815                 failCount++;
3816 
3817             // Make sure that the match text is the pattern
3818             if (!m.group().equals(pattern))
3819                 failCount++;
3820 
3821             // Make sure match occured at insertion point
3822             if (m.start() != insertIndex)
3823                 failCount++;
3824         }
3825     }
3826 
3827     private static void explainFailure(String pattern, String data,
3828                                        String expected, String actual) {
3829         System.err.println(&quot;----------------------------------------&quot;);
3830         System.err.println(&quot;Pattern = &quot;+pattern);
3831         System.err.println(&quot;Data = &quot;+data);
3832         System.err.println(&quot;Expected = &quot; + expected);
3833         System.err.println(&quot;Actual   = &quot; + actual);
3834     }
3835 
3836     private static void explainFailure(String pattern, String data,
3837                                        Throwable t) {
3838         System.err.println(&quot;----------------------------------------&quot;);
3839         System.err.println(&quot;Pattern = &quot;+pattern);
3840         System.err.println(&quot;Data = &quot;+data);
3841         t.printStackTrace(System.err);
3842     }
3843 
3844     // Testing examples from a file
3845 
3846     /**
3847      * Goes through the file &quot;TestCases.txt&quot; and creates many patterns
3848      * described in the file, matching the patterns against input lines in
3849      * the file, and comparing the results against the correct results
3850      * also found in the file. The file format is described in comments
3851      * at the head of the file.
3852      */
3853     private static void processFile(String fileName) throws Exception {
3854         File testCases = new File(System.getProperty(&quot;test.src&quot;, &quot;.&quot;),
3855                                   fileName);
3856         FileInputStream in = new FileInputStream(testCases);
3857         BufferedReader r = new BufferedReader(new InputStreamReader(in));
3858 
3859         // Process next test case.
3860         String aLine;
3861         while((aLine = r.readLine()) != null) {
3862             // Read a line for pattern
3863             String patternString = grabLine(r);
3864             Pattern p = null;
3865             try {
3866                 p = compileTestPattern(patternString);
3867             } catch (PatternSyntaxException e) {
3868                 String dataString = grabLine(r);
3869                 String expectedResult = grabLine(r);
3870                 if (expectedResult.startsWith(&quot;error&quot;))
3871                     continue;
3872                 explainFailure(patternString, dataString, e);
3873                 failCount++;
3874                 continue;
3875             }
3876 
3877             // Read a line for input string
3878             String dataString = grabLine(r);
3879             Matcher m = p.matcher(dataString);
3880             StringBuffer result = new StringBuffer();
3881 
3882             // Check for IllegalStateExceptions before a match
3883             failCount += preMatchInvariants(m);
3884 
3885             boolean found = m.find();
3886 
3887             if (found)
3888                 failCount += postTrueMatchInvariants(m);
3889             else
3890                 failCount += postFalseMatchInvariants(m);
3891 
3892             if (found) {
3893                 result.append(&quot;true &quot;);
3894                 result.append(m.group(0) + &quot; &quot;);
3895             } else {
3896                 result.append(&quot;false &quot;);
3897             }
3898 
3899             result.append(m.groupCount());
3900 
3901             if (found) {
3902                 for (int i=1; i&lt;m.groupCount()+1; i++)
3903                     if (m.group(i) != null)
3904                         result.append(&quot; &quot; +m.group(i));
3905             }
3906 
3907             // Read a line for the expected result
3908             String expectedResult = grabLine(r);
3909 
3910             if (!result.toString().equals(expectedResult)) {
3911                 explainFailure(patternString, dataString, expectedResult, result.toString());
3912                 failCount++;
3913             }
3914         }
3915 
3916         report(fileName);
3917     }
3918 
3919     private static int preMatchInvariants(Matcher m) {
3920         int failCount = 0;
3921         try {
3922             m.start();
3923             failCount++;
3924         } catch (IllegalStateException ise) {}
3925         try {
3926             m.end();
3927             failCount++;
3928         } catch (IllegalStateException ise) {}
3929         try {
3930             m.group();
3931             failCount++;
3932         } catch (IllegalStateException ise) {}
3933         return failCount;
3934     }
3935 
3936     private static int postFalseMatchInvariants(Matcher m) {
3937         int failCount = 0;
3938         try {
3939             m.group();
3940             failCount++;
3941         } catch (IllegalStateException ise) {}
3942         try {
3943             m.start();
3944             failCount++;
3945         } catch (IllegalStateException ise) {}
3946         try {
3947             m.end();
3948             failCount++;
3949         } catch (IllegalStateException ise) {}
3950         return failCount;
3951     }
3952 
3953     private static int postTrueMatchInvariants(Matcher m) {
3954         int failCount = 0;
3955         //assert(m.start() = m.start(0);
3956         if (m.start() != m.start(0))
3957             failCount++;
3958         //assert(m.end() = m.end(0);
3959         if (m.start() != m.start(0))
3960             failCount++;
3961         //assert(m.group() = m.group(0);
3962         if (!m.group().equals(m.group(0)))
3963             failCount++;
3964         try {
3965             m.group(50);
3966             failCount++;
3967         } catch (IndexOutOfBoundsException ise) {}
3968 
3969         return failCount;
3970     }
3971 
3972     private static Pattern compileTestPattern(String patternString) {
3973         if (!patternString.startsWith(&quot;&#39;&quot;)) {
3974             return Pattern.compile(patternString);
3975         }
3976         int break1 = patternString.lastIndexOf(&quot;&#39;&quot;);
3977         String flagString = patternString.substring(
3978                                           break1+1, patternString.length());
3979         patternString = patternString.substring(1, break1);
3980 
3981         if (flagString.equals(&quot;i&quot;))
3982             return Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);
3983 
3984         if (flagString.equals(&quot;m&quot;))
3985             return Pattern.compile(patternString, Pattern.MULTILINE);
3986 
3987         return Pattern.compile(patternString);
3988     }
3989 
3990     /**
3991      * Reads a line from the input file. Keeps reading lines until a non
3992      * empty non comment line is read. If the line contains a \n then
3993      * these two characters are replaced by a newline char. If a \\uxxxx
3994      * sequence is read then the sequence is replaced by the unicode char.
3995      */
3996     private static String grabLine(BufferedReader r) throws Exception {
3997         int index = 0;
3998         String line = r.readLine();
3999         while (line.startsWith(&quot;//&quot;) || line.length() &lt; 1)
4000             line = r.readLine();
4001         while ((index = line.indexOf(&quot;\\n&quot;)) != -1) {
4002             StringBuffer temp = new StringBuffer(line);
4003             temp.replace(index, index+2, &quot;\n&quot;);
4004             line = temp.toString();
4005         }
4006         while ((index = line.indexOf(&quot;\\u&quot;)) != -1) {
4007             StringBuffer temp = new StringBuffer(line);
4008             String value = temp.substring(index+2, index+6);
4009             char aChar = (char)Integer.parseInt(value, 16);
4010             String unicodeChar = &quot;&quot; + aChar;
4011             temp.replace(index, index+6, unicodeChar);
4012             line = temp.toString();
4013         }
4014 
4015         return line;
4016     }
4017 
4018     private static void check(Pattern p, String s, String g, String expected) {
4019         Matcher m = p.matcher(s);
4020         m.find();
4021         if (!m.group(g).equals(expected) ||
4022             s.charAt(m.start(g)) != expected.charAt(0) ||
4023             s.charAt(m.end(g) - 1) != expected.charAt(expected.length() - 1))
4024             failCount++;
4025     }
4026 
4027     private static void checkReplaceFirst(String p, String s, String r, String expected)
4028     {
4029         if (!expected.equals(Pattern.compile(p)
4030                                     .matcher(s)
4031                                     .replaceFirst(r)))
4032             failCount++;
4033     }
4034 
4035     private static void checkReplaceAll(String p, String s, String r, String expected)
4036     {
4037         if (!expected.equals(Pattern.compile(p)
4038                                     .matcher(s)
4039                                     .replaceAll(r)))
4040             failCount++;
4041     }
4042 
4043     private static void checkExpectedFail(String p) {
4044         try {
4045             Pattern.compile(p);
4046         } catch (PatternSyntaxException pse) {
4047             //pse.printStackTrace();
4048             return;
4049         }
4050         failCount++;
4051     }
4052 
4053     private static void checkExpectedIAE(Matcher m, String g) {
4054         m.find();
4055         try {
4056             m.group(g);
4057         } catch (IllegalArgumentException x) {
4058             //iae.printStackTrace();
4059             try {
4060                 m.start(g);
4061             } catch (IllegalArgumentException xx) {
4062                 try {
4063                     m.start(g);
4064                 } catch (IllegalArgumentException xxx) {
4065                     return;
4066                 }
4067             }
4068         }
4069         failCount++;
4070     }
4071 
4072     private static void checkExpectedNPE(Matcher m) {
4073         m.find();
4074         try {
4075             m.group(null);
4076         } catch (NullPointerException x) {
4077             try {
4078                 m.start(null);
4079             } catch (NullPointerException xx) {
4080                 try {
4081                     m.end(null);
4082                 } catch (NullPointerException xxx) {
4083                     return;
4084                 }
4085             }
4086         }
4087         failCount++;
4088     }
4089 
4090     private static void namedGroupCaptureTest() throws Exception {
4091         check(Pattern.compile(&quot;x+(?&lt;gname&gt;y+)z+&quot;),
4092               &quot;xxxyyyzzz&quot;,
4093               &quot;gname&quot;,
4094               &quot;yyy&quot;);
4095 
4096         check(Pattern.compile(&quot;x+(?&lt;gname8&gt;y+)z+&quot;),
4097               &quot;xxxyyyzzz&quot;,
4098               &quot;gname8&quot;,
4099               &quot;yyy&quot;);
4100 
4101         //backref
4102         Pattern pattern = Pattern.compile(&quot;(a*)bc\\1&quot;);
4103         check(pattern, &quot;zzzaabcazzz&quot;, true);  // found &quot;abca&quot;
4104 
4105         check(Pattern.compile(&quot;(?&lt;gname&gt;a*)bc\\k&lt;gname&gt;&quot;),
4106               &quot;zzzaabcaazzz&quot;, true);
4107 
4108         check(Pattern.compile(&quot;(?&lt;gname&gt;abc)(def)\\k&lt;gname&gt;&quot;),
4109               &quot;abcdefabc&quot;, true);
4110 
4111         check(Pattern.compile(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(?&lt;gname&gt;k)\\k&lt;gname&gt;&quot;),
4112               &quot;abcdefghijkk&quot;, true);
4113 
4114         // Supplementary character tests
4115         check(Pattern.compile(&quot;(?&lt;gname&gt;&quot; + toSupplementaries(&quot;a*)bc&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4116               toSupplementaries(&quot;zzzaabcazzz&quot;), true);
4117 
4118         check(Pattern.compile(&quot;(?&lt;gname&gt;&quot; + toSupplementaries(&quot;a*)bc&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4119               toSupplementaries(&quot;zzzaabcaazzz&quot;), true);
4120 
4121         check(Pattern.compile(&quot;(?&lt;gname&gt;&quot; + toSupplementaries(&quot;abc)(def)&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4122               toSupplementaries(&quot;abcdefabc&quot;), true);
4123 
4124         check(Pattern.compile(toSupplementaries(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)&quot;) +
4125                               &quot;(?&lt;gname&gt;&quot; +
4126                               toSupplementaries(&quot;k)&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4127               toSupplementaries(&quot;abcdefghijkk&quot;), true);
4128 
4129         check(Pattern.compile(&quot;x+(?&lt;gname&gt;y+)z+\\k&lt;gname&gt;&quot;),
4130               &quot;xxxyyyzzzyyy&quot;,
4131               &quot;gname&quot;,
4132               &quot;yyy&quot;);
4133 
4134         //replaceFirst/All
4135         checkReplaceFirst(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4136                           &quot;abccczzzabcczzzabccc&quot;,
4137                           &quot;${gn}&quot;,
4138                           &quot;abzzzabcczzzabccc&quot;);
4139 
4140         checkReplaceAll(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4141                         &quot;abccczzzabcczzzabccc&quot;,
4142                         &quot;${gn}&quot;,
4143                         &quot;abzzzabzzzab&quot;);
4144 
4145 
4146         checkReplaceFirst(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4147                           &quot;zzzabccczzzabcczzzabccczzz&quot;,
4148                           &quot;${gn}&quot;,
4149                           &quot;zzzabzzzabcczzzabccczzz&quot;);
4150 
4151         checkReplaceAll(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4152                         &quot;zzzabccczzzabcczzzabccczzz&quot;,
4153                         &quot;${gn}&quot;,
4154                         &quot;zzzabzzzabzzzabzzz&quot;);
4155 
4156         checkReplaceFirst(&quot;(?&lt;gn1&gt;ab)(?&lt;gn2&gt;c*)&quot;,
4157                           &quot;zzzabccczzzabcczzzabccczzz&quot;,
4158                           &quot;${gn2}&quot;,
4159                           &quot;zzzccczzzabcczzzabccczzz&quot;);
4160 
4161         checkReplaceAll(&quot;(?&lt;gn1&gt;ab)(?&lt;gn2&gt;c*)&quot;,
4162                         &quot;zzzabccczzzabcczzzabccczzz&quot;,
4163                         &quot;${gn2}&quot;,
4164                         &quot;zzzccczzzcczzzccczzz&quot;);
4165 
4166         //toSupplementaries(&quot;(ab)(c*)&quot;));
4167         checkReplaceFirst(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4168                            &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4169                           toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4170                           &quot;${gn1}&quot;,
4171                           toSupplementaries(&quot;abzzzabcczzzabccc&quot;));
4172 
4173 
4174         checkReplaceAll(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4175                         &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4176                         toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4177                         &quot;${gn1}&quot;,
4178                         toSupplementaries(&quot;abzzzabzzzab&quot;));
4179 
4180         checkReplaceFirst(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4181                            &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4182                           toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4183                           &quot;${gn2}&quot;,
4184                           toSupplementaries(&quot;ccczzzabcczzzabccc&quot;));
4185 
4186 
4187         checkReplaceAll(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4188                         &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4189                         toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4190                         &quot;${gn2}&quot;,
4191                         toSupplementaries(&quot;ccczzzcczzzccc&quot;));
4192 
4193         checkReplaceFirst(&quot;(?&lt;dog&gt;Dog)AndCat&quot;,
4194                           &quot;zzzDogAndCatzzzDogAndCatzzz&quot;,
4195                           &quot;${dog}&quot;,
4196                           &quot;zzzDogzzzDogAndCatzzz&quot;);
4197 
4198 
4199         checkReplaceAll(&quot;(?&lt;dog&gt;Dog)AndCat&quot;,
4200                           &quot;zzzDogAndCatzzzDogAndCatzzz&quot;,
4201                           &quot;${dog}&quot;,
4202                           &quot;zzzDogzzzDogzzz&quot;);
4203 
4204         // backref in Matcher &amp; String
4205         if (!&quot;abcdefghij&quot;.replaceFirst(&quot;cd(?&lt;gn&gt;ef)gh&quot;, &quot;${gn}&quot;).equals(&quot;abefij&quot;) ||
4206             !&quot;abbbcbdbefgh&quot;.replaceAll(&quot;(?&lt;gn&gt;[a-e])b&quot;, &quot;${gn}&quot;).equals(&quot;abcdefgh&quot;))
4207             failCount++;
4208 
4209         // negative
4210         checkExpectedFail(&quot;(?&lt;groupnamehasnoascii.in&gt;abc)(def)&quot;);
4211         checkExpectedFail(&quot;(?&lt;groupnamehasnoascii_in&gt;abc)(def)&quot;);
4212         checkExpectedFail(&quot;(?&lt;6groupnamestartswithdigit&gt;abc)(def)&quot;);
4213         checkExpectedFail(&quot;(?&lt;gname&gt;abc)(def)\\k&lt;gnameX&gt;&quot;);
4214         checkExpectedFail(&quot;(?&lt;gname&gt;abc)(?&lt;gname&gt;def)\\k&lt;gnameX&gt;&quot;);
4215         checkExpectedIAE(Pattern.compile(&quot;(?&lt;gname&gt;abc)(def)&quot;).matcher(&quot;abcdef&quot;),
4216                          &quot;gnameX&quot;);
4217         checkExpectedNPE(Pattern.compile(&quot;(?&lt;gname&gt;abc)(def)&quot;).matcher(&quot;abcdef&quot;));
4218         report(&quot;NamedGroupCapture&quot;);
4219     }
4220 
4221     // This is for bug 6919132
4222     private static void nonBmpClassComplementTest() throws Exception {
4223         Pattern p = Pattern.compile(&quot;\\P{Lu}&quot;);
4224         Matcher m = p.matcher(new String(new int[] {0x1d400}, 0, 1));
4225 
4226         if (m.find() &amp;&amp; m.start() == 1)
4227             failCount++;
4228 
4229         // from a unicode category
4230         p = Pattern.compile(&quot;\\P{Lu}&quot;);
4231         m = p.matcher(new String(new int[] {0x1d400}, 0, 1));
4232         if (m.find())
4233             failCount++;
4234         if (!m.hitEnd())
4235             failCount++;
4236 
4237         // block
4238         p = Pattern.compile(&quot;\\P{InMathematicalAlphanumericSymbols}&quot;);
4239         m = p.matcher(new String(new int[] {0x1d400}, 0, 1));
4240         if (m.find() &amp;&amp; m.start() == 1)
4241             failCount++;
4242 
4243         p = Pattern.compile(&quot;\\P{sc=GRANTHA}&quot;);
4244         m = p.matcher(new String(new int[] {0x11350}, 0, 1));
4245         if (m.find() &amp;&amp; m.start() == 1)
4246             failCount++;
4247 
4248         report(&quot;NonBmpClassComplement&quot;);
4249     }
4250 
4251     private static void unicodePropertiesTest() throws Exception {
4252         // different forms
4253         if (!Pattern.compile(&quot;\\p{IsLu}&quot;).matcher(&quot;A&quot;).matches() ||
4254             !Pattern.compile(&quot;\\p{Lu}&quot;).matcher(&quot;A&quot;).matches() ||
4255             !Pattern.compile(&quot;\\p{gc=Lu}&quot;).matcher(&quot;A&quot;).matches() ||
4256             !Pattern.compile(&quot;\\p{general_category=Lu}&quot;).matcher(&quot;A&quot;).matches() ||
4257             !Pattern.compile(&quot;\\p{IsLatin}&quot;).matcher(&quot;B&quot;).matches() ||
4258             !Pattern.compile(&quot;\\p{sc=Latin}&quot;).matcher(&quot;B&quot;).matches() ||
4259             !Pattern.compile(&quot;\\p{script=Latin}&quot;).matcher(&quot;B&quot;).matches() ||
4260             !Pattern.compile(&quot;\\p{InBasicLatin}&quot;).matcher(&quot;c&quot;).matches() ||
4261             !Pattern.compile(&quot;\\p{blk=BasicLatin}&quot;).matcher(&quot;c&quot;).matches() ||
4262             !Pattern.compile(&quot;\\p{block=BasicLatin}&quot;).matcher(&quot;c&quot;).matches())
4263             failCount++;
4264 
4265         Matcher common  = Pattern.compile(&quot;\\p{script=Common}&quot;).matcher(&quot;&quot;);
4266         Matcher unknown = Pattern.compile(&quot;\\p{IsUnknown}&quot;).matcher(&quot;&quot;);
4267         Matcher lastSM  = common;
4268         Character.UnicodeScript lastScript = Character.UnicodeScript.of(0);
4269 
4270         Matcher latin  = Pattern.compile(&quot;\\p{block=basic_latin}&quot;).matcher(&quot;&quot;);
4271         Matcher greek  = Pattern.compile(&quot;\\p{InGreek}&quot;).matcher(&quot;&quot;);
4272         Matcher lastBM = latin;
4273         Character.UnicodeBlock lastBlock = Character.UnicodeBlock.of(0);
4274 
4275         for (int cp = 1; cp &lt; Character.MAX_CODE_POINT; cp++) {
4276             if (cp &gt;= 0x30000 &amp;&amp; (cp &amp; 0x70) == 0){
4277                 continue;  // only pick couple code points, they are the same
4278             }
4279 
4280             // Unicode Script
4281             Character.UnicodeScript script = Character.UnicodeScript.of(cp);
4282             Matcher m;
4283             String str = new String(Character.toChars(cp));
4284             if (script == lastScript) {
4285                  m = lastSM;
4286                  m.reset(str);
4287             } else {
4288                  m  = Pattern.compile(&quot;\\p{Is&quot; + script.name() + &quot;}&quot;).matcher(str);
4289             }
4290             if (!m.matches()) {
4291                 failCount++;
4292             }
4293             Matcher other = (script == Character.UnicodeScript.COMMON)? unknown : common;
4294             other.reset(str);
4295             if (other.matches()) {
4296                 failCount++;
4297             }
4298             lastSM = m;
4299             lastScript = script;
4300 
4301             // Unicode Block
4302             Character.UnicodeBlock block = Character.UnicodeBlock.of(cp);
4303             if (block == null) {
4304                 //System.out.printf(&quot;Not a Block: cp=%x%n&quot;, cp);
4305                 continue;
4306             }
4307             if (block == lastBlock) {
4308                  m = lastBM;
4309                  m.reset(str);
4310             } else {
4311                  m  = Pattern.compile(&quot;\\p{block=&quot; + block.toString() + &quot;}&quot;).matcher(str);
4312             }
4313             if (!m.matches()) {
4314                 failCount++;
4315             }
4316             other = (block == Character.UnicodeBlock.BASIC_LATIN)? greek : latin;
4317             other.reset(str);
4318             if (other.matches()) {
4319                 failCount++;
4320             }
4321             lastBM = m;
4322             lastBlock = block;
4323         }
4324         report(&quot;unicodeProperties&quot;);
4325     }
4326 
4327     private static void unicodeHexNotationTest() throws Exception {
4328 
4329         // negative
4330         checkExpectedFail(&quot;\\x{-23}&quot;);
4331         checkExpectedFail(&quot;\\x{110000}&quot;);
4332         checkExpectedFail(&quot;\\x{}&quot;);
4333         checkExpectedFail(&quot;\\x{AB[ef]&quot;);
4334 
4335         // codepoint
4336         check(&quot;^\\x{1033c}$&quot;,              &quot;\uD800\uDF3C&quot;, true);
4337         check(&quot;^\\xF0\\x90\\x8C\\xBC$&quot;,    &quot;\uD800\uDF3C&quot;, false);
4338         check(&quot;^\\x{D800}\\x{DF3c}+$&quot;,     &quot;\uD800\uDF3C&quot;, false);
4339         check(&quot;^\\xF0\\x90\\x8C\\xBC$&quot;,    &quot;\uD800\uDF3C&quot;, false);
4340 
4341         // in class
4342         check(&quot;^[\\x{D800}\\x{DF3c}]+$&quot;,   &quot;\uD800\uDF3C&quot;, false);
4343         check(&quot;^[\\xF0\\x90\\x8C\\xBC]+$&quot;, &quot;\uD800\uDF3C&quot;, false);
4344         check(&quot;^[\\x{D800}\\x{DF3C}]+$&quot;,   &quot;\uD800\uDF3C&quot;, false);
4345         check(&quot;^[\\x{DF3C}\\x{D800}]+$&quot;,   &quot;\uD800\uDF3C&quot;, false);
4346         check(&quot;^[\\x{D800}\\x{DF3C}]+$&quot;,   &quot;\uDF3C\uD800&quot;, true);
4347         check(&quot;^[\\x{DF3C}\\x{D800}]+$&quot;,   &quot;\uDF3C\uD800&quot;, true);
4348 
4349         for (int cp = 0; cp &lt;= 0x10FFFF; cp++) {
4350              String s = &quot;A&quot; + new String(Character.toChars(cp)) + &quot;B&quot;;
4351              String hexUTF16 = (cp &lt;= 0xFFFF)? String.format(&quot;\\u%04x&quot;, cp)
4352                                              : String.format(&quot;\\u%04x\\u%04x&quot;,
4353                                                (int) Character.toChars(cp)[0],
4354                                                (int) Character.toChars(cp)[1]);
4355              String hexCodePoint = &quot;\\x{&quot; + Integer.toHexString(cp) + &quot;}&quot;;
4356              if (!Pattern.matches(&quot;A&quot; + hexUTF16 + &quot;B&quot;, s))
4357                  failCount++;
4358              if (!Pattern.matches(&quot;A[&quot; + hexUTF16 + &quot;]B&quot;, s))
4359                  failCount++;
4360              if (!Pattern.matches(&quot;A&quot; + hexCodePoint + &quot;B&quot;, s))
4361                  failCount++;
4362              if (!Pattern.matches(&quot;A[&quot; + hexCodePoint + &quot;]B&quot;, s))
4363                  failCount++;
4364          }
4365          report(&quot;unicodeHexNotation&quot;);
4366     }
4367 
4368     private static void unicodeClassesTest() throws Exception {
4369 
4370         Matcher lower  = Pattern.compile(&quot;\\p{Lower}&quot;).matcher(&quot;&quot;);
4371         Matcher upper  = Pattern.compile(&quot;\\p{Upper}&quot;).matcher(&quot;&quot;);
4372         Matcher ASCII  = Pattern.compile(&quot;\\p{ASCII}&quot;).matcher(&quot;&quot;);
4373         Matcher alpha  = Pattern.compile(&quot;\\p{Alpha}&quot;).matcher(&quot;&quot;);
4374         Matcher digit  = Pattern.compile(&quot;\\p{Digit}&quot;).matcher(&quot;&quot;);
4375         Matcher alnum  = Pattern.compile(&quot;\\p{Alnum}&quot;).matcher(&quot;&quot;);
4376         Matcher punct  = Pattern.compile(&quot;\\p{Punct}&quot;).matcher(&quot;&quot;);
4377         Matcher graph  = Pattern.compile(&quot;\\p{Graph}&quot;).matcher(&quot;&quot;);
4378         Matcher print  = Pattern.compile(&quot;\\p{Print}&quot;).matcher(&quot;&quot;);
4379         Matcher blank  = Pattern.compile(&quot;\\p{Blank}&quot;).matcher(&quot;&quot;);
4380         Matcher cntrl  = Pattern.compile(&quot;\\p{Cntrl}&quot;).matcher(&quot;&quot;);
4381         Matcher xdigit = Pattern.compile(&quot;\\p{XDigit}&quot;).matcher(&quot;&quot;);
4382         Matcher space  = Pattern.compile(&quot;\\p{Space}&quot;).matcher(&quot;&quot;);
4383         Matcher bound  = Pattern.compile(&quot;\\b&quot;).matcher(&quot;&quot;);
4384         Matcher word   = Pattern.compile(&quot;\\w++&quot;).matcher(&quot;&quot;);
4385         // UNICODE_CHARACTER_CLASS
4386         Matcher lowerU  = Pattern.compile(&quot;\\p{Lower}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4387         Matcher upperU  = Pattern.compile(&quot;\\p{Upper}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4388         Matcher ASCIIU  = Pattern.compile(&quot;\\p{ASCII}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4389         Matcher alphaU  = Pattern.compile(&quot;\\p{Alpha}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4390         Matcher digitU  = Pattern.compile(&quot;\\p{Digit}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4391         Matcher alnumU  = Pattern.compile(&quot;\\p{Alnum}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4392         Matcher punctU  = Pattern.compile(&quot;\\p{Punct}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4393         Matcher graphU  = Pattern.compile(&quot;\\p{Graph}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4394         Matcher printU  = Pattern.compile(&quot;\\p{Print}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4395         Matcher blankU  = Pattern.compile(&quot;\\p{Blank}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4396         Matcher cntrlU  = Pattern.compile(&quot;\\p{Cntrl}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4397         Matcher xdigitU = Pattern.compile(&quot;\\p{XDigit}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4398         Matcher spaceU  = Pattern.compile(&quot;\\p{Space}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4399         Matcher boundU  = Pattern.compile(&quot;\\b&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4400         Matcher wordU   = Pattern.compile(&quot;\\w&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4401         // embedded flag (?U)
4402         Matcher lowerEU  = Pattern.compile(&quot;(?U)\\p{Lower}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4403         Matcher graphEU  = Pattern.compile(&quot;(?U)\\p{Graph}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4404         Matcher wordEU   = Pattern.compile(&quot;(?U)\\w&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4405 
4406         Matcher bwb    = Pattern.compile(&quot;\\b\\w\\b&quot;).matcher(&quot;&quot;);
4407         Matcher bwbU   = Pattern.compile(&quot;\\b\\w++\\b&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4408         Matcher bwbEU  = Pattern.compile(&quot;(?U)\\b\\w++\\b&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4409         // properties
4410         Matcher lowerP  = Pattern.compile(&quot;\\p{IsLowerCase}&quot;).matcher(&quot;&quot;);
4411         Matcher upperP  = Pattern.compile(&quot;\\p{IsUpperCase}&quot;).matcher(&quot;&quot;);
4412         Matcher titleP  = Pattern.compile(&quot;\\p{IsTitleCase}&quot;).matcher(&quot;&quot;);
4413         Matcher letterP = Pattern.compile(&quot;\\p{IsLetter}&quot;).matcher(&quot;&quot;);
4414         Matcher alphaP  = Pattern.compile(&quot;\\p{IsAlphabetic}&quot;).matcher(&quot;&quot;);
4415         Matcher ideogP  = Pattern.compile(&quot;\\p{IsIdeographic}&quot;).matcher(&quot;&quot;);
4416         Matcher cntrlP  = Pattern.compile(&quot;\\p{IsControl}&quot;).matcher(&quot;&quot;);
4417         Matcher spaceP  = Pattern.compile(&quot;\\p{IsWhiteSpace}&quot;).matcher(&quot;&quot;);
4418         Matcher definedP = Pattern.compile(&quot;\\p{IsAssigned}&quot;).matcher(&quot;&quot;);
4419         Matcher nonCCPP = Pattern.compile(&quot;\\p{IsNoncharacterCodePoint}&quot;).matcher(&quot;&quot;);
4420         Matcher joinCrtl = Pattern.compile(&quot;\\p{IsJoinControl}&quot;).matcher(&quot;&quot;);
4421         // javaMethod
4422         Matcher lowerJ  = Pattern.compile(&quot;\\p{javaLowerCase}&quot;).matcher(&quot;&quot;);
4423         Matcher upperJ  = Pattern.compile(&quot;\\p{javaUpperCase}&quot;).matcher(&quot;&quot;);
4424         Matcher alphaJ  = Pattern.compile(&quot;\\p{javaAlphabetic}&quot;).matcher(&quot;&quot;);
4425         Matcher ideogJ  = Pattern.compile(&quot;\\p{javaIdeographic}&quot;).matcher(&quot;&quot;);
4426         // GC/C
4427         Matcher gcC  = Pattern.compile(&quot;\\p{C}&quot;).matcher(&quot;&quot;);
4428 
4429         for (int cp = 1; cp &lt; 0x30000; cp++) {
4430             String str = new String(Character.toChars(cp));
4431             int type = Character.getType(cp);
4432             if (// lower
4433                 POSIX_ASCII.isLower(cp)   != lower.reset(str).matches()  ||
4434                 Character.isLowerCase(cp) != lowerU.reset(str).matches() ||
4435                 Character.isLowerCase(cp) != lowerP.reset(str).matches() ||
4436                 Character.isLowerCase(cp) != lowerEU.reset(str).matches()||
4437                 Character.isLowerCase(cp) != lowerJ.reset(str).matches()||
4438                 // upper
4439                 POSIX_ASCII.isUpper(cp)   != upper.reset(str).matches()  ||
4440                 POSIX_Unicode.isUpper(cp) != upperU.reset(str).matches() ||
4441                 Character.isUpperCase(cp) != upperP.reset(str).matches() ||
4442                 Character.isUpperCase(cp) != upperJ.reset(str).matches() ||
4443                 // alpha
4444                 POSIX_ASCII.isAlpha(cp)   != alpha.reset(str).matches()  ||
4445                 POSIX_Unicode.isAlpha(cp) != alphaU.reset(str).matches() ||
4446                 Character.isAlphabetic(cp)!= alphaP.reset(str).matches() ||
4447                 Character.isAlphabetic(cp)!= alphaJ.reset(str).matches() ||
4448                 // digit
4449                 POSIX_ASCII.isDigit(cp)   != digit.reset(str).matches()  ||
4450                 Character.isDigit(cp)     != digitU.reset(str).matches() ||
4451                 // alnum
4452                 POSIX_ASCII.isAlnum(cp)   != alnum.reset(str).matches()  ||
4453                 POSIX_Unicode.isAlnum(cp) != alnumU.reset(str).matches() ||
4454                 // punct
4455                 POSIX_ASCII.isPunct(cp)   != punct.reset(str).matches()  ||
4456                 POSIX_Unicode.isPunct(cp) != punctU.reset(str).matches() ||
4457                 // graph
4458                 POSIX_ASCII.isGraph(cp)   != graph.reset(str).matches()  ||
4459                 POSIX_Unicode.isGraph(cp) != graphU.reset(str).matches() ||
4460                 POSIX_Unicode.isGraph(cp) != graphEU.reset(str).matches()||
4461                 // blank
4462                 POSIX_ASCII.isType(cp, POSIX_ASCII.BLANK)
4463                                           != blank.reset(str).matches()  ||
4464                 POSIX_Unicode.isBlank(cp) != blankU.reset(str).matches() ||
4465                 // print
4466                 POSIX_ASCII.isPrint(cp)   != print.reset(str).matches()  ||
4467                 POSIX_Unicode.isPrint(cp) != printU.reset(str).matches() ||
4468                 // cntrl
4469                 POSIX_ASCII.isCntrl(cp)   != cntrl.reset(str).matches()  ||
4470                 POSIX_Unicode.isCntrl(cp) != cntrlU.reset(str).matches() ||
4471                 (Character.CONTROL == type) != cntrlP.reset(str).matches() ||
4472                 // hexdigit
4473                 POSIX_ASCII.isHexDigit(cp)   != xdigit.reset(str).matches()  ||
4474                 POSIX_Unicode.isHexDigit(cp) != xdigitU.reset(str).matches() ||
4475                 // space
4476                 POSIX_ASCII.isSpace(cp)   != space.reset(str).matches()  ||
4477                 POSIX_Unicode.isSpace(cp) != spaceU.reset(str).matches() ||
4478                 POSIX_Unicode.isSpace(cp) != spaceP.reset(str).matches() ||
4479                 // word
4480                 POSIX_ASCII.isWord(cp)   != word.reset(str).matches()  ||
4481                 POSIX_Unicode.isWord(cp) != wordU.reset(str).matches() ||
4482                 POSIX_Unicode.isWord(cp) != wordEU.reset(str).matches()||
4483                 // bwordb
4484                 POSIX_ASCII.isWord(cp) != bwb.reset(str).matches() ||
4485                 POSIX_Unicode.isWord(cp) != bwbU.reset(str).matches() ||
4486                 // properties
4487                 Character.isTitleCase(cp) != titleP.reset(str).matches() ||
4488                 Character.isLetter(cp)    != letterP.reset(str).matches()||
4489                 Character.isIdeographic(cp) != ideogP.reset(str).matches() ||
4490                 Character.isIdeographic(cp) != ideogJ.reset(str).matches() ||
4491                 (Character.UNASSIGNED == type) == definedP.reset(str).matches() ||
4492                 POSIX_Unicode.isNoncharacterCodePoint(cp) != nonCCPP.reset(str).matches() ||
4493                 POSIX_Unicode.isJoinControl(cp) != joinCrtl.reset(str).matches() ||
4494                 // gc_C
4495                 (Character.CONTROL == type || Character.FORMAT == type ||
4496                  Character.PRIVATE_USE == type || Character.SURROGATE == type ||
4497                  Character.UNASSIGNED == type)
4498                 != gcC.reset(str).matches()) {
4499                 failCount++;
4500             }
4501         }
4502 
4503         // bounds/word align
4504         twoFindIndexes(&quot; \u0180sherman\u0400 &quot;, bound, 1, 10);
4505         if (!bwbU.reset(&quot;\u0180sherman\u0400&quot;).matches())
4506             failCount++;
4507         twoFindIndexes(&quot; \u0180sh\u0345erman\u0400 &quot;, bound, 1, 11);
4508         if (!bwbU.reset(&quot;\u0180sh\u0345erman\u0400&quot;).matches())
4509             failCount++;
4510         twoFindIndexes(&quot; \u0724\u0739\u0724 &quot;, bound, 1, 4);
4511         if (!bwbU.reset(&quot;\u0724\u0739\u0724&quot;).matches())
4512             failCount++;
4513         if (!bwbEU.reset(&quot;\u0724\u0739\u0724&quot;).matches())
4514             failCount++;
4515         report(&quot;unicodePredefinedClasses&quot;);
4516     }
4517 
4518     private static void unicodeCharacterNameTest() throws Exception {
4519 
4520         for (int cp = 0; cp &lt; Character.MAX_CODE_POINT; cp++) {
4521             if (!Character.isValidCodePoint(cp) ||
4522                 Character.getType(cp) == Character.UNASSIGNED)
4523                 continue;
4524             String str = new String(Character.toChars(cp));
4525             // single
4526             String p = &quot;\\N{&quot; + Character.getName(cp) + &quot;}&quot;;
4527             if (!Pattern.compile(p).matcher(str).matches()) {
4528                 failCount++;
4529             }
4530             // class[c]
4531             p = &quot;[\\N{&quot; + Character.getName(cp) + &quot;}]&quot;;
4532             if (!Pattern.compile(p).matcher(str).matches()) {
4533                 failCount++;
4534             }
4535         }
4536 
4537         // range
4538         for (int i = 0; i &lt; 10; i++) {
4539             int start = generator.nextInt(20);
4540             int end = start + generator.nextInt(200);
4541             String p = &quot;[\\N{&quot; + Character.getName(start) + &quot;}-\\N{&quot; + Character.getName(end) + &quot;}]&quot;;
4542             String str;
4543             for (int cp = start; cp &lt; end; cp++) {
4544                 str = new String(Character.toChars(cp));
4545                 if (!Pattern.compile(p).matcher(str).matches()) {
4546                     failCount++;
4547                 }
4548             }
4549             str = new String(Character.toChars(end + 10));
4550             if (Pattern.compile(p).matcher(str).matches()) {
4551                 failCount++;
4552             }
4553         }
4554 
4555         // slice
4556         for (int i = 0; i &lt; 10; i++) {
4557             int n = generator.nextInt(256);
4558             int[] buf = new int[n];
4559             StringBuffer sb = new StringBuffer(1024);
4560             for (int j = 0; j &lt; n; j++) {
4561                 int cp = generator.nextInt(1000);
4562                 if (!Character.isValidCodePoint(cp) ||
4563                     Character.getType(cp) == Character.UNASSIGNED)
4564                     cp = 0x4e00;    // just use 4e00
4565                 sb.append(&quot;\\N{&quot; + Character.getName(cp) + &quot;}&quot;);
4566                 buf[j] = cp;
4567             }
4568             String p = sb.toString();
4569             String str = new String(buf, 0, buf.length);
4570             if (!Pattern.compile(p).matcher(str).matches()) {
4571                 failCount++;
4572             }
4573         }
4574         report(&quot;unicodeCharacterName&quot;);
4575     }
4576 
4577     private static void horizontalAndVerticalWSTest() throws Exception {
4578         String hws = new String (new char[] {
4579                                      0x09, 0x20, 0xa0, 0x1680, 0x180e,
4580                                      0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005,
4581                                      0x2006, 0x2007, 0x2008, 0x2009, 0x200a,
4582                                      0x202f, 0x205f, 0x3000 });
4583         String vws = new String (new char[] {
4584                                      0x0a, 0x0b, 0x0c, 0x0d, 0x85, 0x2028, 0x2029 });
4585         if (!Pattern.compile(&quot;\\h+&quot;).matcher(hws).matches() ||
4586             !Pattern.compile(&quot;[\\h]+&quot;).matcher(hws).matches())
4587             failCount++;
4588         if (Pattern.compile(&quot;\\H&quot;).matcher(hws).find() ||
4589             Pattern.compile(&quot;[\\H]&quot;).matcher(hws).find())
4590             failCount++;
4591         if (!Pattern.compile(&quot;\\v+&quot;).matcher(vws).matches() ||
4592             !Pattern.compile(&quot;[\\v]+&quot;).matcher(vws).matches())
4593             failCount++;
4594         if (Pattern.compile(&quot;\\V&quot;).matcher(vws).find() ||
4595             Pattern.compile(&quot;[\\V]&quot;).matcher(vws).find())
4596             failCount++;
4597         String prefix = &quot;abcd&quot;;
4598         String suffix = &quot;efgh&quot;;
4599         String ng = &quot;A&quot;;
4600         for (int i = 0; i &lt; hws.length(); i++) {
4601             String c = String.valueOf(hws.charAt(i));
4602             Matcher m = Pattern.compile(&quot;\\h&quot;).matcher(prefix + c + suffix);
4603             if (!m.find() || !c.equals(m.group()))
4604                 failCount++;
4605             m = Pattern.compile(&quot;[\\h]&quot;).matcher(prefix + c + suffix);
4606             if (!m.find() || !c.equals(m.group()))
4607                 failCount++;
4608 
4609             m = Pattern.compile(&quot;\\H&quot;).matcher(hws.substring(0, i) + ng + hws.substring(i));
4610             if (!m.find() || !ng.equals(m.group()))
4611                 failCount++;
4612             m = Pattern.compile(&quot;[\\H]&quot;).matcher(hws.substring(0, i) + ng + hws.substring(i));
4613             if (!m.find() || !ng.equals(m.group()))
4614                 failCount++;
4615         }
4616         for (int i = 0; i &lt; vws.length(); i++) {
4617             String c = String.valueOf(vws.charAt(i));
4618             Matcher m = Pattern.compile(&quot;\\v&quot;).matcher(prefix + c + suffix);
4619             if (!m.find() || !c.equals(m.group()))
4620                 failCount++;
4621             m = Pattern.compile(&quot;[\\v]&quot;).matcher(prefix + c + suffix);
4622             if (!m.find() || !c.equals(m.group()))
4623                 failCount++;
4624 
4625             m = Pattern.compile(&quot;\\V&quot;).matcher(vws.substring(0, i) + ng + vws.substring(i));
4626             if (!m.find() || !ng.equals(m.group()))
4627                 failCount++;
4628             m = Pattern.compile(&quot;[\\V]&quot;).matcher(vws.substring(0, i) + ng + vws.substring(i));
4629             if (!m.find() || !ng.equals(m.group()))
4630                 failCount++;
4631         }
4632         // \v in range is interpreted as 0x0B. This is the undocumented behavior
4633         if (!Pattern.compile(&quot;[\\v-\\v]&quot;).matcher(String.valueOf((char)0x0B)).matches())
4634             failCount++;
4635         report(&quot;horizontalAndVerticalWSTest&quot;);
4636     }
4637 
4638     private static void linebreakTest() throws Exception {
4639         String linebreaks = new String (new char[] {
4640             0x0A, 0x0B, 0x0C, 0x0D, 0x85, 0x2028, 0x2029 });
4641         String crnl = &quot;\r\n&quot;;
4642         if (!(Pattern.compile(&quot;\\R+&quot;).matcher(linebreaks).matches() &amp;&amp;
4643               Pattern.compile(&quot;\\R&quot;).matcher(crnl).matches() &amp;&amp;
4644               Pattern.compile(&quot;\\Rabc&quot;).matcher(crnl + &quot;abc&quot;).matches() &amp;&amp;
4645               Pattern.compile(&quot;\\Rabc&quot;).matcher(&quot;\rabc&quot;).matches() &amp;&amp;
4646               Pattern.compile(&quot;\\R\\R&quot;).matcher(crnl).matches() &amp;&amp;  // backtracking
4647               Pattern.compile(&quot;\\R\\n&quot;).matcher(crnl).matches()) &amp;&amp; // backtracking
4648               !Pattern.compile(&quot;((?&lt;!\\R)\\s)*&quot;).matcher(crnl).matches()) { // #8176029
4649             failCount++;
4650         }
4651         report(&quot;linebreakTest&quot;);
4652     }
4653 
4654     // #7189363
4655     private static void branchTest() throws Exception {
4656         if (!Pattern.compile(&quot;(a)?bc|d&quot;).matcher(&quot;d&quot;).find() ||     // greedy
4657             !Pattern.compile(&quot;(a)+bc|d&quot;).matcher(&quot;d&quot;).find() ||
4658             !Pattern.compile(&quot;(a)*bc|d&quot;).matcher(&quot;d&quot;).find() ||
4659             !Pattern.compile(&quot;(a)??bc|d&quot;).matcher(&quot;d&quot;).find() ||    // reluctant
4660             !Pattern.compile(&quot;(a)+?bc|d&quot;).matcher(&quot;d&quot;).find() ||
4661             !Pattern.compile(&quot;(a)*?bc|d&quot;).matcher(&quot;d&quot;).find() ||
4662             !Pattern.compile(&quot;(a)?+bc|d&quot;).matcher(&quot;d&quot;).find() ||    // possessive
4663             !Pattern.compile(&quot;(a)++bc|d&quot;).matcher(&quot;d&quot;).find() ||
4664             !Pattern.compile(&quot;(a)*+bc|d&quot;).matcher(&quot;d&quot;).find() ||
4665             !Pattern.compile(&quot;(a)?bc|d&quot;).matcher(&quot;d&quot;).matches() ||  // greedy
4666             !Pattern.compile(&quot;(a)+bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4667             !Pattern.compile(&quot;(a)*bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4668             !Pattern.compile(&quot;(a)??bc|d&quot;).matcher(&quot;d&quot;).matches() || // reluctant
4669             !Pattern.compile(&quot;(a)+?bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4670             !Pattern.compile(&quot;(a)*?bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4671             !Pattern.compile(&quot;(a)?+bc|d&quot;).matcher(&quot;d&quot;).matches() || // possessive
4672             !Pattern.compile(&quot;(a)++bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4673             !Pattern.compile(&quot;(a)*+bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4674             !Pattern.compile(&quot;(a)?bc|de&quot;).matcher(&quot;de&quot;).find() ||   // others
4675             !Pattern.compile(&quot;(a)??bc|de&quot;).matcher(&quot;de&quot;).find() ||
4676             !Pattern.compile(&quot;(a)?bc|de&quot;).matcher(&quot;de&quot;).matches() ||
4677             !Pattern.compile(&quot;(a)??bc|de&quot;).matcher(&quot;de&quot;).matches())
4678             failCount++;
4679         report(&quot;branchTest&quot;);
4680     }
4681 
4682     // This test is for 8007395
4683     private static void groupCurlyNotFoundSuppTest() throws Exception {
4684         String input = &quot;test this as \ud83d\ude0d&quot;;
4685         for (String pStr : new String[] { &quot;test(.)+(@[a-zA-Z.]+)&quot;,
4686                                           &quot;test(.)*(@[a-zA-Z.]+)&quot;,
4687                                           &quot;test([^B])+(@[a-zA-Z.]+)&quot;,
4688                                           &quot;test([^B])*(@[a-zA-Z.]+)&quot;,
4689                                           &quot;test(\\P{IsControl})+(@[a-zA-Z.]+)&quot;,
4690                                           &quot;test(\\P{IsControl})*(@[a-zA-Z.]+)&quot;,
4691                                         }) {
4692             Matcher m = Pattern.compile(pStr, Pattern.CASE_INSENSITIVE)
4693                                .matcher(input);
4694             try {
4695                 if (m.find()) {
4696                     failCount++;
4697                 }
4698             } catch (Exception x) {
4699                 failCount++;
4700             }
4701         }
4702         report(&quot;GroupCurly NotFoundSupp&quot;);
4703     }
4704 
4705     // This test is for 8023647
4706     private static void groupCurlyBackoffTest() throws Exception {
4707         if (!&quot;abc1c&quot;.matches(&quot;(\\w)+1\\1&quot;) ||
4708             &quot;abc11&quot;.matches(&quot;(\\w)+1\\1&quot;)) {
4709             failCount++;
4710         }
4711         report(&quot;GroupCurly backoff&quot;);
4712     }
4713 
4714     // This test is for 8012646
4715     private static void patternAsPredicate() throws Exception {
4716         Predicate&lt;String&gt; p = Pattern.compile(&quot;[a-z]+&quot;).asPredicate();
4717 
4718         if (p.test(&quot;&quot;)) {
4719             failCount++;
4720         }
4721         if (!p.test(&quot;word&quot;)) {
4722             failCount++;
4723         }
4724         if (p.test(&quot;1234&quot;)) {
4725             failCount++;
4726         }
4727         if (!p.test(&quot;word1234&quot;)) {
4728             failCount++;
4729         }
4730         report(&quot;Pattern.asPredicate&quot;);
4731     }
4732 
4733     // This test is for 8184692
4734     private static void patternAsMatchPredicate() throws Exception {
4735         Predicate&lt;String&gt; p = Pattern.compile(&quot;[a-z]+&quot;).asMatchPredicate();
4736 
4737         if (p.test(&quot;&quot;)) {
4738             failCount++;
4739         }
4740         if (!p.test(&quot;word&quot;)) {
4741             failCount++;
4742         }
4743         if (p.test(&quot;1234word&quot;)) {
4744             failCount++;
4745         }
4746         if (p.test(&quot;1234&quot;)) {
4747             failCount++;
4748         }
4749         report(&quot;Pattern.asMatchPredicate&quot;);
4750     }
4751 
4752 
4753     // This test is for 8035975
4754     private static void invalidFlags() throws Exception {
4755         for (int flag = 1; flag != 0; flag &lt;&lt;= 1) {
4756             switch (flag) {
4757             case Pattern.CASE_INSENSITIVE:
4758             case Pattern.MULTILINE:
4759             case Pattern.DOTALL:
4760             case Pattern.UNICODE_CASE:
4761             case Pattern.CANON_EQ:
4762             case Pattern.UNIX_LINES:
4763             case Pattern.LITERAL:
4764             case Pattern.UNICODE_CHARACTER_CLASS:
4765             case Pattern.COMMENTS:
4766                 // valid flag, continue
4767                 break;
4768             default:
4769                 try {
4770                     Pattern.compile(&quot;.&quot;, flag);
4771                     failCount++;
4772                 } catch (IllegalArgumentException expected) {
4773                 }
4774             }
4775         }
4776         report(&quot;Invalid compile flags&quot;);
4777     }
4778 
4779     // This test is for 8158482
4780     private static void embeddedFlags() throws Exception {
4781         try {
4782             Pattern.compile(&quot;(?i).(?-i).&quot;);
4783             Pattern.compile(&quot;(?m).(?-m).&quot;);
4784             Pattern.compile(&quot;(?s).(?-s).&quot;);
4785             Pattern.compile(&quot;(?d).(?-d).&quot;);
4786             Pattern.compile(&quot;(?u).(?-u).&quot;);
4787             Pattern.compile(&quot;(?c).(?-c).&quot;);
4788             Pattern.compile(&quot;(?x).(?-x).&quot;);
4789             Pattern.compile(&quot;(?U).(?-U).&quot;);
4790             Pattern.compile(&quot;(?imsducxU).(?-imsducxU).&quot;);
4791         } catch (PatternSyntaxException x) {
4792             failCount++;
4793         }
4794         report(&quot;Embedded flags&quot;);
4795     }
4796 
4797     private static void grapheme() throws Exception {
4798         Stream.concat(Files.lines(UCDFiles.GRAPHEME_BREAK_TEST),
4799                 Files.lines(Paths.get(System.getProperty(&quot;test.src&quot;, &quot;.&quot;), &quot;GraphemeTestCases.txt&quot;)))
4800             .filter( ln -&gt; ln.length() != 0 &amp;&amp; !ln.startsWith(&quot;#&quot;) )
4801             .forEach( ln -&gt; {
4802                 ln = ln.replaceAll(&quot;\\s+|\\([a-zA-Z]+\\)|\\[[a-zA-Z]]+\\]|#.*&quot;, &quot;&quot;);
4803                 // System.out.println(str);
4804                 String[] strs = ln.split(&quot;\u00f7|\u00d7&quot;);
4805                 StringBuilder src = new StringBuilder();
4806                 ArrayList&lt;String&gt; graphemes = new ArrayList&lt;&gt;();
4807                 StringBuilder buf = new StringBuilder();
4808                 int offBk = 0;
4809                 for (String str : strs) {
4810                     if (str.length() == 0)  // first empty str
4811                         continue;
4812                     int cp = Integer.parseInt(str, 16);
4813                     src.appendCodePoint(cp);
4814                     buf.appendCodePoint(cp);
4815                     offBk += (str.length() + 1);
4816                     if (ln.charAt(offBk) == &#39;\u00f7&#39;) {    // DIV
4817                         graphemes.add(buf.toString());
4818                         buf = new StringBuilder();
4819                     }
4820                 }
4821                 Pattern p = Pattern.compile(&quot;\\X&quot;);
4822                 Matcher m = p.matcher(src.toString());
4823                 Scanner s = new Scanner(src.toString()).useDelimiter(&quot;\\b{g}&quot;);
4824                 for (String g : graphemes) {
4825                     // System.out.printf(&quot;     grapheme:=[%s]%n&quot;, g);
4826                     // (1) test \\X directly
4827                     if (!m.find() || !m.group().equals(g)) {
4828                         System.out.println(&quot;Failed \\X [&quot; + ln + &quot;] : &quot; + g);
4829                         failCount++;
4830                     }
4831                     // (2) test \\b{g} + \\X  via Scanner
4832                     boolean hasNext = s.hasNext(p);
4833                     // if (!s.hasNext() || !s.next().equals(next)) {
4834                     if (!s.hasNext(p) || !s.next(p).equals(g)) {
4835                         System.out.println(&quot;Failed b{g} [&quot; + ln + &quot;] : &quot; + g);
4836                         failCount++;
4837                     }
4838                 }
4839             });
4840         // some sanity checks
4841         if (!Pattern.compile(&quot;\\X{10}&quot;).matcher(&quot;abcdefghij&quot;).matches() ||
4842             !Pattern.compile(&quot;\\b{g}(?:\\X\\b{g}){5}\\b{g}&quot;).matcher(&quot;abcde&quot;).matches() ||
4843             !Pattern.compile(&quot;(?:\\X\\b{g}){2}&quot;).matcher(&quot;\ud800\udc00\ud801\udc02&quot;).matches())
4844             failCount++;
4845         // make sure &quot;\b{n}&quot; still works
4846         if (!Pattern.compile(&quot;\\b{1}hello\\b{1} \\b{1}world\\b{1}&quot;).matcher(&quot;hello world&quot;).matches())
4847             failCount++;
4848         report(&quot;Unicode extended grapheme cluster&quot;);
4849     }
4850 
4851     // hangup/timeout if go into exponential backtracking
4852     private static void expoBacktracking() throws Exception {
4853 
4854         Object[][] patternMatchers = {
4855             // 6328855
4856             { &quot;(.*\n*)*&quot;,
4857               &quot;this little fine string lets\r\njava.lang.String.matches\r\ncrash\r\n(We don&#39;t know why but adding \r* to the regex makes it work again)&quot;,
4858               false },
4859             // 6192895
4860             { &quot; *([a-zA-Z0-9/\\-\\?:\\(\\)\\.,&#39;\\+\\{\\}]+ *)+&quot;,
4861               &quot;Hello World this is a test this is a test this is a test A&quot;,
4862               true },
4863             { &quot; *([a-zA-Z0-9/\\-\\?:\\(\\)\\.,&#39;\\+\\{\\}]+ *)+&quot;,
4864               &quot;Hello World this is a test this is a test this is a test \u4e00 &quot;,
4865               false },
4866             { &quot; *([a-z0-9]+ *)+&quot;,
4867               &quot;hello world this is a test this is a test this is a test A&quot;,
4868               false },
4869             // 4771934 [FIXED] #5013651?
4870             { &quot;^(\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,4})+[,;]?)+$&quot;,
4871               &quot;abc@efg.abc,efg@abc.abc,abc@xyz.mno;abc@sdfsd.com&quot;,
4872               true },
4873             // 4866249 [FIXED]
4874             { &quot;&lt;\\s*&quot; + &quot;(meta|META)&quot; + &quot;(\\s|[^&gt;])+&quot; + &quot;(CHARSET|charset)=&quot; + &quot;(\\s|[^&gt;])+&gt;&quot;,
4875               &quot;&lt;META http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html; charset=ISO-8859-5\&quot;&gt;&quot;,
4876               true },
4877             { &quot;^(\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,4})+[,;]?)+$&quot;,
4878               &quot;abc@efg.abc,efg@abc.abc,abc@xyz.mno;sdfsd.com&quot;,
4879               false },
4880             // 6345469
4881             { &quot;((&lt;[^&gt;]+&gt;)?(((\\s)?)*(\\&amp;nbsp;)?)*((\\s)?)*)+&quot;,
4882               &quot;&amp;nbsp;&amp;nbsp; &lt; br/&gt; &amp;nbsp; &lt; / p&gt; &lt;p&gt; &lt;html&gt; &lt;adfasfdasdf&gt;&amp;nbsp; &lt;/p&gt;&quot;,
4883               true }, // --&gt; matched
4884             { &quot;((&lt;[^&gt;]+&gt;)?(((\\s)?)*(\\&amp;nbsp;)?)*((\\s)?)*)+&quot;,
4885               &quot;&amp;nbsp;&amp;nbsp; &lt; br/&gt; &amp;nbsp; &lt; / p&gt; &lt;p&gt; &lt;html&gt; &lt;adfasfdasdf&gt;&amp;nbsp; p &lt;/p&gt;&quot;,
4886               false },
4887             // 5026912
4888             { &quot;^\\s*&quot; + &quot;(\\w|\\d|[\\xC0-\\xFF]|/)+&quot; + &quot;\\s+|$&quot;,
4889               &quot;156580451111112225588087755221111111566969655555555&quot;,
4890               false},
4891             // 6988218
4892             { &quot;^([+-]?((0[xX](\\p{XDigit}+))|(((\\p{Digit}+)(\\.)?((\\p{Digit}+)?)([eE][+-]?(\\p{Digit}+))?)|(\\.((\\p{Digit}+))([eE][+-]?(\\p{Digit}+))?)))|[n|N]?&#39;([^&#39;]*(?:&#39;&#39;)*[^&#39;]*)*&#39;)&quot;,
4893               &quot;&#39;%)) order by ANGEBOT.ID&quot;,
4894               false},    // find
4895             // 6693451
4896             { &quot;^(\\s*foo\\s*)*$&quot;,
4897               &quot;foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo&quot;,
4898               true },
4899             { &quot;^(\\s*foo\\s*)*$&quot;,
4900               &quot;foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo fo&quot;,
4901               false
4902             },
4903             // 7006761
4904             { &quot;(([0-9A-Z]+)([_]?+)*)*&quot;, &quot;FOOOOO_BAAAR_FOOOOOOOOO_BA_&quot;, true},
4905             { &quot;(([0-9A-Z]+)([_]?+)*)*&quot;, &quot;FOOOOO_BAAAR_FOOOOOOOOO_BA_ &quot;, false},
4906             // 8140212
4907             { &quot;(?&lt;before&gt;.*)\\{(?&lt;reflection&gt;\\w+):(?&lt;innerMethod&gt;\\w+(\\.?\\w+(\\(((?&lt;args&gt;((&#39;[^&#39;]*&#39;)|((/|\\w)+))(,((&#39;[^&#39;]*&#39;)|((/|\\w)+)))*))?\\))?)*)\\}(?&lt;after&gt;.*)&quot;,
4908               &quot;{CeGlobal:getSodCutoff.getGui.getAmqp.getSimpleModeEnabled()&quot;,
4909               false
4910             },
4911             { &quot;^(a+)+$&quot;, &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;, true},
4912             { &quot;^(a+)+$&quot;, &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!&quot;, false},
4913 
4914             { &quot;(x+)*y&quot;,  &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy&quot;, true },
4915             { &quot;(x+)*y&quot;,  &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz&quot;, false},
4916 
4917             { &quot;(x+x+)+y&quot;, &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy&quot;, true},
4918             { &quot;(x+x+)+y&quot;, &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz&quot;, false},
4919 
4920             { &quot;(([0-9A-Z]+)([_]?+)*)*&quot;, &quot;--------------------------------------&quot;, false},
4921 
4922             /* not fixed
4923             //8132141   ---&gt;    second level exponential backtracking
4924             { &quot;(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*&quot;,
4925               &quot;hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchicchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihichicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccchchhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihhichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihihiihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci&quot; },
4926             */
4927         };
4928 
4929         for (Object[] pm : patternMatchers) {
4930             String p = (String)pm[0];
4931             String s = (String)pm[1];
4932             boolean r = (Boolean)pm[2];
4933             if (r != Pattern.compile(p).matcher(s).matches()) {
4934                 failCount++;
4935             }
4936         }
4937     }
4938 
4939     private static void invalidGroupName() {
4940         // Invalid start of a group name
4941         for (String groupName : List.of(&quot;&quot;, &quot;.&quot;, &quot;0&quot;, &quot;\u0040&quot;, &quot;\u005b&quot;,
4942                 &quot;\u0060&quot;, &quot;\u007b&quot;, &quot;\u0416&quot;)) {
4943             for (String pat : List.of(&quot;(?&lt;&quot; + groupName + &quot;&gt;)&quot;,
4944                     &quot;\\k&lt;&quot; + groupName + &quot;&gt;&quot;)) {
4945                 try {
4946                     Pattern.compile(pat);
4947                     failCount++;
4948                 } catch (PatternSyntaxException e) {
4949                     if (!e.getMessage().startsWith(
4950                             &quot;capturing group name does not start with a&quot;
4951                             + &quot; Latin letter&quot;)) {
4952                         failCount++;
4953                     }
4954                 }
4955             }
4956         }
4957         // Invalid char in a group name
4958         for (String groupName : List.of(&quot;a.&quot;, &quot;b\u0040&quot;, &quot;c\u005b&quot;,
4959                 &quot;d\u0060&quot;, &quot;e\u007b&quot;, &quot;f\u0416&quot;)) {
4960             for (String pat : List.of(&quot;(?&lt;&quot; + groupName + &quot;&gt;)&quot;,
4961                     &quot;\\k&lt;&quot; + groupName + &quot;&gt;&quot;)) {
4962                 try {
4963                     Pattern.compile(pat);
4964                     failCount++;
4965                 } catch (PatternSyntaxException e) {
4966                     if (!e.getMessage().startsWith(
4967                             &quot;named capturing group is missing trailing &#39;&gt;&#39;&quot;)) {
4968                         failCount++;
4969                     }
4970                 }
4971             }
4972         }
4973         report(&quot;Invalid capturing group names&quot;);
4974     }
4975 
4976     private static void illegalRepetitionRange() {
4977         // huge integers &gt; (2^31 - 1)
4978         String n = BigInteger.valueOf(1L &lt;&lt; 32)
4979             .toString();
4980         String m = BigInteger.valueOf(1L &lt;&lt; 31)
4981             .add(new BigInteger(80, generator))
4982             .toString();
4983         for (String rep : List.of(&quot;&quot;, &quot;x&quot;, &quot;.&quot;, &quot;,&quot;, &quot;-1&quot;, &quot;2,1&quot;,
4984                 n, n + &quot;,&quot;, &quot;0,&quot; + n, n + &quot;,&quot; + m, m, m + &quot;,&quot;, &quot;0,&quot; + m)) {
4985             String pat = &quot;.{&quot; + rep + &quot;}&quot;;
4986             try {
4987                 Pattern.compile(pat);
4988                 failCount++;
4989                 System.out.println(&quot;Expected to fail. Pattern: &quot; + pat);
4990             } catch (PatternSyntaxException e) {
4991                 if (!e.getMessage().startsWith(&quot;Illegal repetition&quot;)) {
4992                     failCount++;
4993                     System.out.println(&quot;Unexpected error message: &quot; + e.getMessage());
4994                 }
4995             } catch (Throwable t) {
4996                 failCount++;
4997                 System.out.println(&quot;Unexpected exception: &quot; + t);
4998             }
4999         }
5000         report(&quot;illegalRepetitionRange&quot;);
5001     }
5002 
5003     private static void surrogatePairWithCanonEq() {
5004         try {
5005             Pattern.compile(&quot;\ud834\udd21&quot;, Pattern.CANON_EQ);
5006         } catch (Throwable t) {
5007             failCount++;
5008             System.out.println(&quot;Unexpected exception: &quot; + t);
5009         }
5010         report(&quot;surrogatePairWithCanonEq&quot;);
5011     }
5012 
5013     // This test is for 8235812
5014     private static void lineBreakWithQuantifier() {
5015         // key:    pattern
5016         // value:  lengths of input that must match the pattern
5017         Map&lt;String, List&lt;Integer&gt;&gt; cases = Map.ofEntries(
5018             Map.entry(&quot;\\R?&quot;,      List.of(0, 1)),
5019             Map.entry(&quot;\\R*&quot;,      List.of(0, 1, 2, 3)),
5020             Map.entry(&quot;\\R+&quot;,      List.of(1, 2, 3)),
5021             Map.entry(&quot;\\R{0}&quot;,    List.of(0)),
5022             Map.entry(&quot;\\R{1}&quot;,    List.of(1)),
5023             Map.entry(&quot;\\R{2}&quot;,    List.of(2)),
5024             Map.entry(&quot;\\R{3}&quot;,    List.of(3)),
5025             Map.entry(&quot;\\R{0,}&quot;,   List.of(0, 1, 2, 3)),
5026             Map.entry(&quot;\\R{1,}&quot;,   List.of(1, 2, 3)),
5027             Map.entry(&quot;\\R{2,}&quot;,   List.of(2, 3)),
5028             Map.entry(&quot;\\R{3,}&quot;,   List.of(3)),
5029             Map.entry(&quot;\\R{0,0}&quot;,  List.of(0)),
5030             Map.entry(&quot;\\R{0,1}&quot;,  List.of(0, 1)),
5031             Map.entry(&quot;\\R{0,2}&quot;,  List.of(0, 1, 2)),
5032             Map.entry(&quot;\\R{0,3}&quot;,  List.of(0, 1, 2, 3)),
5033             Map.entry(&quot;\\R{1,1}&quot;,  List.of(1)),
5034             Map.entry(&quot;\\R{1,2}&quot;,  List.of(1, 2)),
5035             Map.entry(&quot;\\R{1,3}&quot;,  List.of(1, 2, 3)),
5036             Map.entry(&quot;\\R{2,2}&quot;,  List.of(2)),
5037             Map.entry(&quot;\\R{2,3}&quot;,  List.of(2, 3)),
5038             Map.entry(&quot;\\R{3,3}&quot;,  List.of(3)),
5039             Map.entry(&quot;\\R&quot;,       List.of(1)),
5040             Map.entry(&quot;\\R\\R&quot;,    List.of(2)),
5041             Map.entry(&quot;\\R\\R\\R&quot;, List.of(3))
5042         );
5043 
5044         // key:    length of input
5045         // value:  all possible inputs of given length
5046         Map&lt;Integer, List&lt;String&gt;&gt; inputs = new HashMap&lt;&gt;();
5047         String[] Rs = { &quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;,
5048                         &quot;\u000B&quot;, &quot;\u000C&quot;, &quot;\u0085&quot;, &quot;\u2028&quot;, &quot;\u2029&quot; };
5049         StringBuilder sb = new StringBuilder();
5050         for (int len = 0; len &lt;= 3; ++len) {
5051             int[] idx = new int[len + 1];
5052             do {
5053                 sb.setLength(0);
5054                 for (int j = 0; j &lt; len; ++j)
5055                     sb.append(Rs[idx[j]]);
5056                 inputs.computeIfAbsent(len, ArrayList::new).add(sb.toString());
5057                 idx[0]++;
5058                 for (int j = 0; j &lt; len; ++j) {
5059                     if (idx[j] &lt; Rs.length)
5060                         break;
5061                     idx[j] = 0;
5062                     idx[j+1]++;
5063                 }
5064             } while (idx[len] == 0);
5065         }
5066 
5067         // exhaustive testing
5068         for (String patStr : cases.keySet()) {
5069             Pattern[] pats = patStr.endsWith(&quot;R&quot;)
5070                 ? new Pattern[] { Pattern.compile(patStr) }  // no quantifiers
5071                 : new Pattern[] { Pattern.compile(patStr),          // greedy
5072                                   Pattern.compile(patStr + &quot;?&quot;) };  // reluctant
5073             Matcher m = pats[0].matcher(&quot;&quot;);
5074             for (Pattern p : pats) {
5075                 m.usePattern(p);
5076                 for (int len : cases.get(patStr)) {
5077                     for (String in : inputs.get(len)) {
5078                         if (!m.reset(in).matches()) {
5079                             failCount++;
5080                             System.err.println(&quot;Expected to match &#39;&quot; +
5081                                     in + &quot;&#39; =~ /&quot; + p + &quot;/&quot;);
5082                         }
5083                     }
5084                 }
5085             }
5086         }
5087         report(&quot;lineBreakWithQuantifier&quot;);
5088     }
5089 }
    </pre>
  </body>
</html>
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
@@ -166,10 +166,15 @@
 
     boolean hasNaturalAlignment() {
         return size.isPresent() && size.getAsLong() == alignment;
     }
 
+    @Override
+    public boolean isPadding() {
+        return this instanceof PaddingLayout;
+    }
+
     @Override
     public int hashCode() {
         return attributes.hashCode() << Long.hashCode(alignment);
     }
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
@@ -390,10 +390,16 @@
             path = pathElem.apply(path);
         }
         return finalizer.apply(path);
     }
 
+    /**
+     * Is this a padding layout (e.g. a layout created from {@link #ofPaddingBits(long)} ?
+     * @return true, if this layout is a padding layout.
+     */
+    boolean isPadding();
+
     /**
      * Instances of this class are used to form <a href="MemoryLayout.html#layout-paths"><em>layout paths</em></a>. There
      * are two kinds of path elements: <em>group path elements</em> and <em>sequence path elements</em>. Group
      * path elements are used to select a given named member layout within a {@link GroupLayout}. Sequence
      * path elements are used to select a sequence element layout within a {@link SequenceLayout}; selection
diff a/test/jdk/java/foreign/TestLayouts.java b/test/jdk/java/foreign/TestLayouts.java
--- a/test/jdk/java/foreign/TestLayouts.java
+++ b/test/jdk/java/foreign/TestLayouts.java
@@ -206,10 +206,15 @@
         );
         assertEquals(struct.byteSize(), 8);
         assertEquals(struct.byteAlignment(), 8);
     }
 
+    @Test(dataProvider = "layoutKinds")
+    public void testPadding(LayoutKind kind) {
+        assertEquals(kind == LayoutKind.PADDING, kind.layout.isPadding());
+    }
+
     @Test(dataProvider="layoutsAndAlignments")
     public void testAlignmentString(MemoryLayout layout, long bitAlign) {
         long[] alignments = { 8, 16, 32, 64, 128 };
         for (long a : alignments) {
             assertFalse(layout.toString().contains("%"));
@@ -254,10 +259,17 @@
             values[(i * 2) + 1] = new Object[] { layoutKinds[i].layout, 18 }; // not a power of 2
         }
         return values;
     }
 
+    @DataProvider(name = "layoutKinds")
+    public Object[][] layoutsKinds() {
+        return Stream.of(LayoutKind.values())
+                .map(lk -> new Object[] { lk })
+                .toArray(Object[][]::new);
+    }
+
     enum SizedLayoutFactory {
         VALUE_LE(size -> MemoryLayout.ofValueBits(size, ByteOrder.LITTLE_ENDIAN)),
         VALUE_BE(size -> MemoryLayout.ofValueBits(size, ByteOrder.BIG_ENDIAN)),
         PADDING(MemoryLayout::ofPaddingBits),
         SEQUENCE(size -> MemoryLayout.ofSequence(size, MemoryLayouts.PAD_8));

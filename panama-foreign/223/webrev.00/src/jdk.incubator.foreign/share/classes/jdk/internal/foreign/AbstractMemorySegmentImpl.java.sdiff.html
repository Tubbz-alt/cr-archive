<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../incubator/foreign/MemorySegment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HeapMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 import jdk.incubator.foreign.MemoryLayouts;
 31 import jdk.incubator.foreign.MemorySegment;
 32 import jdk.incubator.foreign.SequenceLayout;
 33 import jdk.internal.access.JavaNioAccess;
 34 import jdk.internal.access.SharedSecrets;
 35 import jdk.internal.access.foreign.MemorySegmentProxy;
 36 import jdk.internal.access.foreign.UnmapperProxy;
 37 import jdk.internal.misc.Unsafe;
 38 import jdk.internal.util.ArraysSupport;
 39 import jdk.internal.vm.annotation.ForceInline;
 40 import sun.security.action.GetPropertyAction;
 41 
 42 import java.lang.invoke.VarHandle;
 43 import java.nio.ByteBuffer;
 44 import java.util.ArrayList;
 45 import java.util.List;
 46 import java.util.Objects;
 47 import java.util.Random;
 48 import java.util.Spliterator;
 49 import java.util.function.Consumer;


 50 
 51 /**
 52  * This abstract class provides an immutable implementation for the {@code MemorySegment} interface. This class contains information
 53  * about the segment&#39;s spatial and temporal bounds; each memory segment implementation is associated with an owner thread which is set at creation time.
 54  * Access to certain sensitive operations on the memory segment will fail with {@code IllegalStateException} if the
 55  * segment is either in an invalid state (e.g. it has already been closed) or if access occurs from a thread other
 56  * than the owner thread. See {@link MemoryScope} for more details on management of temporal bounds. Subclasses
 57  * are defined for each memory segment kind, see {@link NativeMemorySegmentImpl}, {@link HeapMemorySegmentImpl} and
 58  * {@link MappedMemorySegmentImpl}.
 59  */
 60 public abstract class AbstractMemorySegmentImpl implements MemorySegment, MemorySegmentProxy {
 61 
 62     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
 63 
 64     private static final boolean enableSmallSegments =
 65             Boolean.parseBoolean(GetPropertyAction.privilegedGetProperty(&quot;jdk.incubator.foreign.SmallSegments&quot;, &quot;true&quot;));
 66 
 67     final static int FIRST_RESERVED_FLAG = 1 &lt;&lt; 16; // upper 16 bits are reserved
 68     final static int SMALL = FIRST_RESERVED_FLAG;
 69     final static long NONCE = new Random().nextLong();
 70 
 71     final static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
 72 
 73     final long length;
 74     final int mask;
 75     final MemoryScope scope;
 76 
 77     @ForceInline
 78     AbstractMemorySegmentImpl(long length, int mask, MemoryScope scope) {
 79         this.length = length;
 80         this.mask = mask;
 81         this.scope = scope;
 82     }
 83 
<span class="line-modified"> 84     abstract long min();</span>
 85 
<span class="line-modified"> 86     abstract Object base();</span>
 87 
 88     abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope);
 89 
<span class="line-modified"> 90     abstract ByteBuffer makeByteBuffer();</span>
 91 
 92     static int defaultAccessModes(long size) {
 93         return (enableSmallSegments &amp;&amp; size &lt; Integer.MAX_VALUE) ?
 94                 ALL_ACCESS | SMALL :
 95                 ALL_ACCESS;
 96     }
 97 
 98     @Override
 99     public AbstractMemorySegmentImpl asSlice(long offset, long newSize) {
100         checkBounds(offset, newSize);
101         return asSliceNoCheck(offset, newSize);
102     }
103 
104     private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
105         return dup(offset, newSize, mask, scope);
106     }
107 
108     @SuppressWarnings(&quot;unchecked&quot;)
109     public static &lt;S extends MemorySegment&gt; Spliterator&lt;S&gt; spliterator(S segment, SequenceLayout sequenceLayout) {
110         ((AbstractMemorySegmentImpl)segment).checkValidState();
111         if (sequenceLayout.byteSize() != segment.byteSize()) {
112             throw new IllegalArgumentException();
113         }
114         return (Spliterator&lt;S&gt;)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
115                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() &amp; ~CLOSE));
116     }
117 
<span class="line-removed">118     @Override</span>
<span class="line-removed">119     public final MemorySegment fill(byte value){</span>
<span class="line-removed">120         checkRange(0, length, true);</span>
<span class="line-removed">121         UNSAFE.setMemory(base(), min(), length, value);</span>
<span class="line-removed">122         return this;</span>
<span class="line-removed">123     }</span>
<span class="line-removed">124 </span>
<span class="line-removed">125     public void copyFrom(MemorySegment src) {</span>
<span class="line-removed">126         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;</span>
<span class="line-removed">127         long size = that.byteSize();</span>
<span class="line-removed">128         checkRange(0, size, true);</span>
<span class="line-removed">129         that.checkRange(0, size, false);</span>
<span class="line-removed">130         UNSAFE.copyMemory(</span>
<span class="line-removed">131                 that.base(), that.min(),</span>
<span class="line-removed">132                 base(), min(), size);</span>
<span class="line-removed">133     }</span>
<span class="line-removed">134 </span>
<span class="line-removed">135     private final static VarHandle BYTE_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)</span>
<span class="line-removed">136             .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());</span>
<span class="line-removed">137 </span>
<span class="line-removed">138     @Override</span>
<span class="line-removed">139     public long mismatch(MemorySegment other) {</span>
<span class="line-removed">140         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;</span>
<span class="line-removed">141         final long thisSize = this.byteSize();</span>
<span class="line-removed">142         final long thatSize = that.byteSize();</span>
<span class="line-removed">143         final long length = Math.min(thisSize, thatSize);</span>
<span class="line-removed">144         this.checkRange(0, length, false);</span>
<span class="line-removed">145         that.checkRange(0, length, false);</span>
<span class="line-removed">146         if (this == other) {</span>
<span class="line-removed">147             return -1;</span>
<span class="line-removed">148         }</span>
<span class="line-removed">149 </span>
<span class="line-removed">150         long i = 0;</span>
<span class="line-removed">151         if (length &gt; 7) {</span>
<span class="line-removed">152             if ((byte) BYTE_HANDLE.get(this.baseAddress(), 0) != (byte) BYTE_HANDLE.get(that.baseAddress(), 0)) {</span>
<span class="line-removed">153                 return 0;</span>
<span class="line-removed">154             }</span>
<span class="line-removed">155             i = ArraysSupport.vectorizedMismatchLargeForBytes(</span>
<span class="line-removed">156                     this.base(), this.min(),</span>
<span class="line-removed">157                     that.base(), that.min(),</span>
<span class="line-removed">158                     length);</span>
<span class="line-removed">159             if (i &gt;= 0) {</span>
<span class="line-removed">160                 return i;</span>
<span class="line-removed">161             }</span>
<span class="line-removed">162             long remaining = ~i;</span>
<span class="line-removed">163             assert remaining &lt; 8 : &quot;remaining greater than 7: &quot; + remaining;</span>
<span class="line-removed">164             i = length - remaining;</span>
<span class="line-removed">165         }</span>
<span class="line-removed">166         MemoryAddress thisAddress = this.baseAddress();</span>
<span class="line-removed">167         MemoryAddress thatAddress = that.baseAddress();</span>
<span class="line-removed">168         for (; i &lt; length; i++) {</span>
<span class="line-removed">169             if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {</span>
<span class="line-removed">170                 return i;</span>
<span class="line-removed">171             }</span>
<span class="line-removed">172         }</span>
<span class="line-removed">173         return thisSize != thatSize ? length : -1;</span>
<span class="line-removed">174     }</span>
<span class="line-removed">175 </span>
176     @Override
177     @ForceInline
178     public final MemoryAddress baseAddress() {
179         return new MemoryAddressImpl(this, 0);
180     }
181 
<span class="line-removed">182     @Override</span>
<span class="line-removed">183     public final ByteBuffer asByteBuffer() {</span>
<span class="line-removed">184         if (!isSet(READ)) {</span>
<span class="line-removed">185             throw unsupportedAccessMode(READ);</span>
<span class="line-removed">186         }</span>
<span class="line-removed">187         checkIntSize(&quot;ByteBuffer&quot;);</span>
<span class="line-removed">188         ByteBuffer _bb = makeByteBuffer();</span>
<span class="line-removed">189         if (!isSet(WRITE)) {</span>
<span class="line-removed">190             //scope is IMMUTABLE - obtain a RO byte buffer</span>
<span class="line-removed">191             _bb = _bb.asReadOnlyBuffer();</span>
<span class="line-removed">192         }</span>
<span class="line-removed">193         return _bb;</span>
<span class="line-removed">194     }</span>
<span class="line-removed">195 </span>
196     @Override
197     public final int accessModes() {
198         return mask &amp; ALL_ACCESS;
199     }
200 
201     @Override
202     public final long byteSize() {
203         return length;
204     }
205 
206     @Override
207     public final boolean isAlive() {
208         return scope.isAlive();
209     }
210 
211     @Override
212     public Thread ownerThread() {
213         return scope.ownerThread();
214     }
215 
216     @Override
217     public AbstractMemorySegmentImpl withAccessModes(int accessModes) {
218         checkAccessModes(accessModes);
219         if ((~accessModes() &amp; accessModes) != 0) {
220             throw new IllegalArgumentException(&quot;Cannot acquire more access modes&quot;);
221         }
222         return dup(0, length, (mask &amp; ~ALL_ACCESS) | accessModes, scope);
223     }
224 
225     @Override
226     public boolean hasAccessModes(int accessModes) {
227         checkAccessModes(accessModes);
228         return (accessModes() &amp; accessModes) == accessModes;
229     }
230 
<span class="line-modified">231     private void checkAccessModes(int accessModes) {</span>
232         if ((accessModes &amp; ~ALL_ACCESS) != 0) {
233             throw new IllegalArgumentException(&quot;Invalid access modes&quot;);
234         }
235     }
236 
237     @Override
238     public MemorySegment withOwnerThread(Thread newOwner) {
239         Objects.requireNonNull(newOwner);
240         if (!isSet(HANDOFF)) {
241             throw unsupportedAccessMode(HANDOFF);
242         }
243         if (scope.ownerThread() == newOwner) {
244             throw new IllegalArgumentException(&quot;Segment already owned by thread: &quot; + newOwner);
245         } else {
246             try {
247                 return dup(0L, length, mask, scope.dup(newOwner));
248             } finally {
249                 //flush read/writes to segment memory before returning the new segment
250                 VarHandle.fullFence();
251             }
</pre>
<hr />
<pre>
254 
255     @Override
256     public final void close() {
257         if (!isSet(CLOSE)) {
258             throw unsupportedAccessMode(CLOSE);
259         }
260         closeNoCheck();
261     }
262 
263     private final void closeNoCheck() {
264         scope.close();
265     }
266 
267     final AbstractMemorySegmentImpl acquire() {
268         if (Thread.currentThread() != ownerThread() &amp;&amp; !isSet(ACQUIRE)) {
269             throw unsupportedAccessMode(ACQUIRE);
270         }
271         return dup(0, length, mask, scope.acquire());
272     }
273 
<span class="line-removed">274     @Override</span>
<span class="line-removed">275     public final byte[] toByteArray() {</span>
<span class="line-removed">276         checkIntSize(&quot;byte[]&quot;);</span>
<span class="line-removed">277         byte[] arr = new byte[(int)length];</span>
<span class="line-removed">278         MemorySegment arrSegment = MemorySegment.ofArray(arr);</span>
<span class="line-removed">279         arrSegment.copyFrom(this);</span>
<span class="line-removed">280         return arr;</span>
<span class="line-removed">281     }</span>
<span class="line-removed">282 </span>
283     boolean isSmall() {
284         return isSet(SMALL);
285     }
286 
<span class="line-modified">287     void checkRange(long offset, long length, boolean writeAccess) {</span>
288         scope.checkValidState();
289         if (writeAccess &amp;&amp; !isSet(WRITE)) {
290             throw unsupportedAccessMode(WRITE);
291         } else if (!writeAccess &amp;&amp; !isSet(READ)) {
292             throw unsupportedAccessMode(READ);
293         }
294         checkBounds(offset, length);
295     }
296 
297     @Override
298     public final void checkValidState() {
299         scope.checkValidState();
300     }
301 
302     // Helper methods
303 
304     private boolean isSet(int mask) {
305         return (this.mask &amp; mask) != 0;
306     }
307 
<span class="line-removed">308     private void checkIntSize(String typeName) {</span>
<span class="line-removed">309         if (length &gt; (Integer.MAX_VALUE - 8)) { //conservative check</span>
<span class="line-removed">310             throw new UnsupportedOperationException(String.format(&quot;Segment is too large to wrap as %s. Size: %d&quot;, typeName, length));</span>
<span class="line-removed">311         }</span>
<span class="line-removed">312     }</span>
<span class="line-removed">313 </span>
314     private void checkBounds(long offset, long length) {
315         if (isSmall()) {
316             checkBoundsSmall((int)offset, (int)length);
317         } else {
318             if (length &lt; 0 ||
319                     offset &lt; 0 ||
320                     offset &gt; this.length - length) { // careful of overflow
321                 throw outOfBoundException(offset, length);
322             }
323         }
324     }
325 
326     private void checkBoundsSmall(int offset, int length) {
327         if (length &lt; 0 ||
328                 offset &lt; 0 ||
329                 offset &gt; (int)this.length - length) { // careful of overflow
330             throw outOfBoundException(offset, length);
331         }
332     }
333 
</pre>
<hr />
<pre>
476         } else {
477             bufferScope = MemoryScope.create(bb, null);
478             modes = defaultAccessModes(size);
479         }
480         if (bb.isReadOnly()) {
481             modes &amp;= ~WRITE;
482         }
483         if (base != null) {
484             return new HeapMemorySegmentImpl&lt;&gt;(bbAddress + pos, () -&gt; (byte[])base, size, modes, bufferScope);
485         } else if (unmapper == null) {
486             return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, bufferScope);
487         } else {
488             return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, bufferScope);
489         }
490     }
491 
492     public static final AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(
493         0, 0, MemoryScope.createUnchecked(null, null, null)
494     ) {
495         @Override
<span class="line-modified">496         ByteBuffer makeByteBuffer() {</span>
497             throw new UnsupportedOperationException();
498         }
499 
500         @Override
<span class="line-modified">501         long min() {</span>
502             return 0;
503         }
504 
505         @Override
<span class="line-modified">506         Object base() {</span>
507             return null;
508         }
509 
510         @Override
511         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
512             throw new UnsupportedOperationException();
513         }
514     };
515 }
</pre>
</td>
<td>
<hr />
<pre>
 30 import jdk.incubator.foreign.MemoryLayouts;
 31 import jdk.incubator.foreign.MemorySegment;
 32 import jdk.incubator.foreign.SequenceLayout;
 33 import jdk.internal.access.JavaNioAccess;
 34 import jdk.internal.access.SharedSecrets;
 35 import jdk.internal.access.foreign.MemorySegmentProxy;
 36 import jdk.internal.access.foreign.UnmapperProxy;
 37 import jdk.internal.misc.Unsafe;
 38 import jdk.internal.util.ArraysSupport;
 39 import jdk.internal.vm.annotation.ForceInline;
 40 import sun.security.action.GetPropertyAction;
 41 
 42 import java.lang.invoke.VarHandle;
 43 import java.nio.ByteBuffer;
 44 import java.util.ArrayList;
 45 import java.util.List;
 46 import java.util.Objects;
 47 import java.util.Random;
 48 import java.util.Spliterator;
 49 import java.util.function.Consumer;
<span class="line-added"> 50 import java.util.function.Function;</span>
<span class="line-added"> 51 import java.util.function.IntFunction;</span>
 52 
 53 /**
 54  * This abstract class provides an immutable implementation for the {@code MemorySegment} interface. This class contains information
 55  * about the segment&#39;s spatial and temporal bounds; each memory segment implementation is associated with an owner thread which is set at creation time.
 56  * Access to certain sensitive operations on the memory segment will fail with {@code IllegalStateException} if the
 57  * segment is either in an invalid state (e.g. it has already been closed) or if access occurs from a thread other
 58  * than the owner thread. See {@link MemoryScope} for more details on management of temporal bounds. Subclasses
 59  * are defined for each memory segment kind, see {@link NativeMemorySegmentImpl}, {@link HeapMemorySegmentImpl} and
 60  * {@link MappedMemorySegmentImpl}.
 61  */
 62 public abstract class AbstractMemorySegmentImpl implements MemorySegment, MemorySegmentProxy {
 63 
 64     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
 65 
 66     private static final boolean enableSmallSegments =
 67             Boolean.parseBoolean(GetPropertyAction.privilegedGetProperty(&quot;jdk.incubator.foreign.SmallSegments&quot;, &quot;true&quot;));
 68 
 69     final static int FIRST_RESERVED_FLAG = 1 &lt;&lt; 16; // upper 16 bits are reserved
 70     final static int SMALL = FIRST_RESERVED_FLAG;
 71     final static long NONCE = new Random().nextLong();
 72 
 73     final static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
 74 
 75     final long length;
 76     final int mask;
 77     final MemoryScope scope;
 78 
 79     @ForceInline
 80     AbstractMemorySegmentImpl(long length, int mask, MemoryScope scope) {
 81         this.length = length;
 82         this.mask = mask;
 83         this.scope = scope;
 84     }
 85 
<span class="line-modified"> 86     public abstract long min();</span>
 87 
<span class="line-modified"> 88     public abstract Object base();</span>
 89 
 90     abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope);
 91 
<span class="line-modified"> 92     public abstract ByteBuffer makeByteBuffer();</span>
 93 
 94     static int defaultAccessModes(long size) {
 95         return (enableSmallSegments &amp;&amp; size &lt; Integer.MAX_VALUE) ?
 96                 ALL_ACCESS | SMALL :
 97                 ALL_ACCESS;
 98     }
 99 
100     @Override
101     public AbstractMemorySegmentImpl asSlice(long offset, long newSize) {
102         checkBounds(offset, newSize);
103         return asSliceNoCheck(offset, newSize);
104     }
105 
106     private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
107         return dup(offset, newSize, mask, scope);
108     }
109 
110     @SuppressWarnings(&quot;unchecked&quot;)
111     public static &lt;S extends MemorySegment&gt; Spliterator&lt;S&gt; spliterator(S segment, SequenceLayout sequenceLayout) {
112         ((AbstractMemorySegmentImpl)segment).checkValidState();
113         if (sequenceLayout.byteSize() != segment.byteSize()) {
114             throw new IllegalArgumentException();
115         }
116         return (Spliterator&lt;S&gt;)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
117                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() &amp; ~CLOSE));
118     }
119 


























































120     @Override
121     @ForceInline
122     public final MemoryAddress baseAddress() {
123         return new MemoryAddressImpl(this, 0);
124     }
125 














126     @Override
127     public final int accessModes() {
128         return mask &amp; ALL_ACCESS;
129     }
130 
131     @Override
132     public final long byteSize() {
133         return length;
134     }
135 
136     @Override
137     public final boolean isAlive() {
138         return scope.isAlive();
139     }
140 
141     @Override
142     public Thread ownerThread() {
143         return scope.ownerThread();
144     }
145 
146     @Override
147     public AbstractMemorySegmentImpl withAccessModes(int accessModes) {
148         checkAccessModes(accessModes);
149         if ((~accessModes() &amp; accessModes) != 0) {
150             throw new IllegalArgumentException(&quot;Cannot acquire more access modes&quot;);
151         }
152         return dup(0, length, (mask &amp; ~ALL_ACCESS) | accessModes, scope);
153     }
154 
155     @Override
156     public boolean hasAccessModes(int accessModes) {
157         checkAccessModes(accessModes);
158         return (accessModes() &amp; accessModes) == accessModes;
159     }
160 
<span class="line-modified">161     public void checkAccessModes(int accessModes) {</span>
162         if ((accessModes &amp; ~ALL_ACCESS) != 0) {
163             throw new IllegalArgumentException(&quot;Invalid access modes&quot;);
164         }
165     }
166 
167     @Override
168     public MemorySegment withOwnerThread(Thread newOwner) {
169         Objects.requireNonNull(newOwner);
170         if (!isSet(HANDOFF)) {
171             throw unsupportedAccessMode(HANDOFF);
172         }
173         if (scope.ownerThread() == newOwner) {
174             throw new IllegalArgumentException(&quot;Segment already owned by thread: &quot; + newOwner);
175         } else {
176             try {
177                 return dup(0L, length, mask, scope.dup(newOwner));
178             } finally {
179                 //flush read/writes to segment memory before returning the new segment
180                 VarHandle.fullFence();
181             }
</pre>
<hr />
<pre>
184 
185     @Override
186     public final void close() {
187         if (!isSet(CLOSE)) {
188             throw unsupportedAccessMode(CLOSE);
189         }
190         closeNoCheck();
191     }
192 
193     private final void closeNoCheck() {
194         scope.close();
195     }
196 
197     final AbstractMemorySegmentImpl acquire() {
198         if (Thread.currentThread() != ownerThread() &amp;&amp; !isSet(ACQUIRE)) {
199             throw unsupportedAccessMode(ACQUIRE);
200         }
201         return dup(0, length, mask, scope.acquire());
202     }
203 









204     boolean isSmall() {
205         return isSet(SMALL);
206     }
207 
<span class="line-modified">208     public void checkRange(long offset, long length, boolean writeAccess) {</span>
209         scope.checkValidState();
210         if (writeAccess &amp;&amp; !isSet(WRITE)) {
211             throw unsupportedAccessMode(WRITE);
212         } else if (!writeAccess &amp;&amp; !isSet(READ)) {
213             throw unsupportedAccessMode(READ);
214         }
215         checkBounds(offset, length);
216     }
217 
218     @Override
219     public final void checkValidState() {
220         scope.checkValidState();
221     }
222 
223     // Helper methods
224 
225     private boolean isSet(int mask) {
226         return (this.mask &amp; mask) != 0;
227     }
228 






229     private void checkBounds(long offset, long length) {
230         if (isSmall()) {
231             checkBoundsSmall((int)offset, (int)length);
232         } else {
233             if (length &lt; 0 ||
234                     offset &lt; 0 ||
235                     offset &gt; this.length - length) { // careful of overflow
236                 throw outOfBoundException(offset, length);
237             }
238         }
239     }
240 
241     private void checkBoundsSmall(int offset, int length) {
242         if (length &lt; 0 ||
243                 offset &lt; 0 ||
244                 offset &gt; (int)this.length - length) { // careful of overflow
245             throw outOfBoundException(offset, length);
246         }
247     }
248 
</pre>
<hr />
<pre>
391         } else {
392             bufferScope = MemoryScope.create(bb, null);
393             modes = defaultAccessModes(size);
394         }
395         if (bb.isReadOnly()) {
396             modes &amp;= ~WRITE;
397         }
398         if (base != null) {
399             return new HeapMemorySegmentImpl&lt;&gt;(bbAddress + pos, () -&gt; (byte[])base, size, modes, bufferScope);
400         } else if (unmapper == null) {
401             return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, bufferScope);
402         } else {
403             return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, bufferScope);
404         }
405     }
406 
407     public static final AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(
408         0, 0, MemoryScope.createUnchecked(null, null, null)
409     ) {
410         @Override
<span class="line-modified">411         public ByteBuffer makeByteBuffer() {</span>
412             throw new UnsupportedOperationException();
413         }
414 
415         @Override
<span class="line-modified">416         public long min() {</span>
417             return 0;
418         }
419 
420         @Override
<span class="line-modified">421         public Object base() {</span>
422             return null;
423         }
424 
425         @Override
426         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
427             throw new UnsupportedOperationException();
428         }
429     };
430 }
</pre>
</td>
</tr>
</table>
<center><a href="../../incubator/foreign/MemorySegment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HeapMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
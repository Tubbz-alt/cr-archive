<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegments.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 package jdk.incubator.foreign;
   2 
   3 import jdk.internal.foreign.AbstractMemorySegmentImpl;
   4 import jdk.internal.foreign.HeapMemorySegmentImpl;
   5 import jdk.internal.foreign.MappedMemorySegmentImpl;
   6 import jdk.internal.foreign.NativeMemorySegmentImpl;
   7 import jdk.internal.foreign.Utils;
   8 import jdk.internal.misc.Unsafe;
   9 import jdk.internal.util.ArraysSupport;
  10 
  11 import java.io.IOException;
  12 import java.lang.invoke.VarHandle;
  13 import java.nio.ByteBuffer;
  14 import java.nio.ByteOrder;
  15 import java.nio.channels.FileChannel;
  16 import java.nio.file.Path;
  17 import java.util.Objects;
  18 import java.util.Spliterator;
  19 import java.util.function.Consumer;
  20 import java.util.function.Function;
  21 import java.util.function.IntFunction;
  22 
  23 /**
  24  * This class contains various methods for creating memory segments from a variety of sources (byte buffers, arrrays),
  25  * for manipulating memory segments (such as filling contents of segments, or obtaining a segment
  26  * {@link Spliterator}), for mapping existing memory segments into different views (byte buffers, arrays) and
  27  * for accessing the memory segment contents in various ways.
  28  */
  29 public final class MemorySegments {
  30     private MemorySegments() {
  31         // just the one
  32     }
  33 
  34     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
  35 
  36     /**
  37      * Fills a value into the given memory segment.
  38      * &lt;p&gt;
  39      * More specifically, the given value is filled into each address of the given
  40      * segment. Equivalent to (but likely more efficient than) the following code:
  41      *
  42      * &lt;pre&gt;{@code
  43     byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
  44     .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
  45     for (long l = 0; l &lt; segment.byteSize(); l++) {
  46     byteHandle.set(segment.baseAddress(), l, value);
  47     }
  48      * }&lt;/pre&gt;
  49      *
  50      * without any regard or guarantees on the ordering of particular memory
  51      * elements being set.
  52      * &lt;p&gt;
  53      * Fill can be useful to initialize or reset the memory of a segment.
  54      *
  55      * @param segment the segment whose bytes are to be filled
  56      * @param value the value to fill into this segment
  57      * @throws IllegalStateException if the given segment is not &lt;em&gt;alive&lt;/em&gt;, or if access occurs from a thread other than the
  58      * thread owning the given segment
  59      * @throws UnsupportedOperationException if this segment does not support the {@link MemorySegment#WRITE} access mode
  60      */
  61     public static void fill(MemorySegment segment, byte value) {
  62         AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;
  63         segmentImpl.checkRange(0, segment.byteSize(), true);
  64         UNSAFE.setMemory(segmentImpl.base(), segmentImpl.min(), segmentImpl.byteSize(), value);
  65     }
  66 
  67     /**
  68      * Performs a bulk copy from given source segment to a given target segment. More specifically, the bytes at
  69      * offset {@code 0} through {@code from.byteSize() - 1} in the source segment are copied into the target segment
  70      * at offset {@code 0} through {@code to.byteSize() - 1}.
  71      * If the source segment overlaps with the target segment, then the copying is performed as if the bytes at
  72      * offset {@code 0} through {@code from.byteSize() - 1} in the source segment were first copied into a
  73      * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into
  74      * the target segment at offset {@code 0} through {@code to.byteSize() - 1}.
  75      * &lt;p&gt;
  76      * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the target segment
  77      * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.
  78      * For example, this may occur if the same file is {@link MemorySegments#mapFromPath mapped} to two segments.
  79      *
  80      * @param from the source segment.
  81      * @param to the target segment.
  82      * @throws IndexOutOfBoundsException if {@code from.byteSize() &gt; to.byteSize()}.
  83      * @throws IllegalStateException if either the source segment or this segment have been already closed,
  84      * or if access occurs from a thread other than the thread owning either segment.
  85      * @throws UnsupportedOperationException if either the source segment or this segment do not feature required access modes;
  86      * more specifically, {@code from} should feature at least the {@link MemorySegment#READ} access mode,
  87      * while {@code to} should feature at least the {@link MemorySegment#WRITE} access mode.
  88      */
  89     public static void copy(MemorySegment from, MemorySegment to) {
  90         AbstractMemorySegmentImpl fromImpl = (AbstractMemorySegmentImpl)from;
  91         AbstractMemorySegmentImpl toImpl = (AbstractMemorySegmentImpl)to;
  92         long size = from.byteSize();
  93         toImpl.checkRange(0, size, true);
  94         fromImpl.checkRange(0, size, false);
  95         UNSAFE.copyMemory(
  96                 fromImpl.base(), fromImpl.min(),
  97                 toImpl.base(), toImpl.min(), size);
  98     }
  99 
 100     /**
 101      * Finds and returns the offset, in bytes, of the first mismatch between
 102      * two given segments. The offset is relative to the
 103      * {@link MemorySegment#baseAddress() base address} of each segment and will be in the
 104      * range of 0 (inclusive) up to the {@link MemorySegment#byteSize() size} (in bytes) of
 105      * the smaller memory segment (exclusive).
 106      * &lt;p&gt;
 107      * If the two segments share a common prefix then the returned offset is
 108      * the length of the common prefix and it follows that there is a mismatch
 109      * between the two segments at that offset within the respective segments.
 110      * If one segment is a proper prefix of the other then the returned offset is
 111      * the smaller of the segment sizes, and it follows that the offset is only
 112      * valid for the larger segment. Otherwise, there is no mismatch and {@code
 113      * -1} is returned.
 114      *
 115      * @param src the first segment to be tested for a mismatch
 116      * @param dst the second segment to be tested for a mismatch
 117      * @return the relative offset, in bytes, of the first mismatch between this
 118      * and the given other segment, otherwise -1 if no mismatch
 119      * @throws IllegalStateException if either this segment of the other segment
 120      * have been already closed, or if access occurs from a thread other than the
 121      * thread owning either segment
 122      * @throws UnsupportedOperationException if either this segment or the other
 123      * segment does not feature at least the {@link MemorySegment#READ} access mode
 124      */
 125     public static long mismatch(MemorySegment src, MemorySegment dst) {
 126         AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)src;
 127         AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dst;
 128         final long thisSize = src.byteSize();
 129         final long thatSize = dst.byteSize();
 130         final long length = Math.min(thisSize, thatSize);
 131         srcImpl.checkRange(0, length, false);
 132         dstImpl.checkRange(0, length, false);
 133         if (src == dst) {
 134             return -1;
 135         }
 136 
 137         long i = 0;
 138         if (length &gt; 7) {
 139             if (getByte(src.baseAddress(), 0) != getByte(dst.baseAddress(), 0)) {
 140                 return 0;
 141             }
 142             i = ArraysSupport.vectorizedMismatchLargeForBytes(
 143                     srcImpl.base(), srcImpl.min(),
 144                     dstImpl.base(), dstImpl.min(),
 145                     length);
 146             if (i &gt;= 0) {
 147                 return i;
 148             }
 149             long remaining = ~i;
 150             assert remaining &lt; 8 : &quot;remaining greater than 7: &quot; + remaining;
 151             i = length - remaining;
 152         }
 153         MemoryAddress thisAddress = src.baseAddress();
 154         MemoryAddress thatAddress = dst.baseAddress();
 155         for (; i &lt; length; i++) {
 156             if (getByte(thisAddress, i) != getByte(thatAddress, i)) {
 157                 return i;
 158             }
 159         }
 160         return thisSize != thatSize ? length : -1;
 161     }
 162 
 163     /**
 164      * Returns a spliterator for the given memory segment. The returned spliterator reports {@link Spliterator#SIZED},
 165      * {@link Spliterator#SUBSIZED}, {@link Spliterator#IMMUTABLE}, {@link Spliterator#NONNULL} and {@link Spliterator#ORDERED}
 166      * characteristics.
 167      * &lt;p&gt;
 168      * The returned spliterator splits the segment according to the specified sequence layout; that is,
 169      * if the supplied layout is a sequence layout whose element count is {@code N}, then calling {@link Spliterator#trySplit()}
 170      * will result in a spliterator serving approximatively {@code N/2} elements (depending on whether N is even or not).
 171      * As such, splitting is possible as long as {@code N &gt;= 2}. The spliterator returns segments that feature the same
 172      * &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; as the given segment less the {@link MemorySegment#CLOSE} access mode.
 173      * &lt;p&gt;
 174      * The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then
 175      * be processed in parallel by multiple threads (if the access mode {@link MemorySegment#ACQUIRE} is set).
 176      * While closing the segment (see {@link MemorySegment#close()}) during pending concurrent execution will generally
 177      * fail with an exception, it is possible to close a segment when a spliterator has been obtained but no thread
 178      * is actively working on it using {@link Spliterator#tryAdvance(Consumer)}; in such cases, any subsequent call
 179      * to {@link Spliterator#tryAdvance(Consumer)} will fail with an exception.
 180      * @param segment the segment to be used for splitting.
 181      * @param layout the layout to be used for splitting.
 182      * @param &lt;S&gt; the memory segment type
 183      * @return the element spliterator for this segment
 184      * @throws IllegalStateException if the segment is not &lt;em&gt;alive&lt;/em&gt;, or if access occurs from a thread other than the
 185      * thread owning the given segment
 186      */
 187     public static &lt;S extends MemorySegment&gt; Spliterator&lt;S&gt; spliterator(S segment, SequenceLayout layout) {
 188         return AbstractMemorySegmentImpl.spliterator(segment, layout);
 189     }
 190 
 191     /**
 192      * Wraps the given segment in a {@link ByteBuffer}. Some of the properties of the returned buffer are linked to
 193      * the properties of the given segment. For instance, if the given segment is &lt;em&gt;immutable&lt;/em&gt;
 194      * (e.g. the segment has access mode {@link MemorySegment#READ} but not {@link MemorySegment#WRITE}), then the resulting buffer is &lt;em&gt;read-only&lt;/em&gt;
 195      * (see {@link ByteBuffer#isReadOnly()}. Additionally, if the given segment is a native memory segment, the resulting buffer is
 196      * &lt;em&gt;direct&lt;/em&gt; (see {@link ByteBuffer#isDirect()}).
 197      * &lt;p&gt;
 198      * The life-cycle of the returned buffer will be tied to that of the given segment. That means that if the given segment
 199      * is closed (see {@link MemorySegment#close()}, accessing the returned
 200      * buffer will throw an {@link IllegalStateException}.
 201      * &lt;p&gt;
 202      * The resulting buffer&#39;s byte order is {@link java.nio.ByteOrder#BIG_ENDIAN}; this can be changed using
 203      * {@link ByteBuffer#order(java.nio.ByteOrder)}.
 204      *
 205      * @param segment the segment from which a byte buffer view has to be created.
 206      * @return a {@link ByteBuffer} view of the given memory segment.
 207      * @throws UnsupportedOperationException if the given segment cannot be mapped onto a {@link ByteBuffer} instance,
 208      * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater
 209      * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link MemorySegment#READ} access mode.
 210      */
 211     public static ByteBuffer asByteBuffer(MemorySegment segment) {
 212         AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;
 213         segmentImpl.checkAccessModes(MemorySegment.READ);
 214         checkArraySize(&quot;ByteBuffer&quot;, 1, segment.byteSize());
 215         ByteBuffer _bb = segmentImpl.makeByteBuffer();
 216         if (!segment.hasAccessModes(MemorySegment.WRITE)) {
 217             //scope is IMMUTABLE - obtain a RO byte buffer
 218             _bb = _bb.asReadOnlyBuffer();
 219         }
 220         return _bb;
 221     }
 222 
 223     private static int checkArraySize(String typeName, int elemSize, long length) {
 224         if (length % elemSize != 0) {
 225             throw new UnsupportedOperationException(String.format(&quot;Segment size is not a multiple of %d. Size: %d&quot;, elemSize, length));
 226         }
 227         long arraySize = length / elemSize;
 228         if (arraySize &gt; (Integer.MAX_VALUE - 8)) { //conservative check
 229             throw new UnsupportedOperationException(String.format(&quot;Segment is too large to wrap as %s. Size: %d&quot;, typeName, length));
 230         }
 231         return (int)arraySize;
 232     }
 233 
 234     private static &lt;Z&gt; Z toArray(MemorySegment segment, Class&lt;Z&gt; arrayClass, int elemSize, IntFunction&lt;Z&gt; arrayFactory, Function&lt;Z, MemorySegment&gt; segmentFactory) {
 235         int size = checkArraySize(arrayClass.getSimpleName(), elemSize, segment.byteSize());
 236         Z arr = arrayFactory.apply(size);
 237         MemorySegment arrSegment = segmentFactory.apply(arr);
 238         copy(segment, arrSegment);
 239         return arr;
 240     }
 241 
 242     /**
 243      * Copy the contents of the given memory segment into a fresh byte array.
 244      * @param segment the segment whose contents are to be copied into a byte array.
 245      * @return a fresh byte array copy of the given memory segment.
 246      * @throws UnsupportedOperationException if the given segment does not feature the {@link MemorySegment#READ} access mode, or if the given
 247      * segment&#39;s contents cannot be copied into a {@link byte[]} instance, e.g. its size is greater than {@link Integer#MAX_VALUE},
 248      * @throws IllegalStateException if the given segment has been closed, or if access occurs from a thread other than the
 249      * thread owning the given segment.
 250      */
 251     public static byte[] toByteArray(MemorySegment segment) {
 252         return toArray(segment, byte[].class, 1, byte[]::new, MemorySegments::ofArray);
 253     }
 254 
 255     /**
 256      * Copy the contents of the given memory segment into a fresh short array.
 257      * @param segment the segment whose contents are to be copied into a short array.
 258      * @return a fresh short array copy of the given memory segment.
 259      * @throws UnsupportedOperationException if the given segment does not feature the {@link MemorySegment#READ} access mode, or if the given
 260      * segment&#39;s contents cannot be copied into a {@link short[]} instance, e.g. because {@code byteSize() % 4 != 0},
 261      * or {@code byteSize() / 2 &gt; Integer#MAX_VALUE}.
 262      * @throws IllegalStateException if the given segment has been closed, or if access occurs from a thread other than the
 263      * thread owning the given segment.
 264      */
 265     public static short[] toShortArray(MemorySegment segment) {
 266         return toArray(segment, short[].class, 2, short[]::new, MemorySegments::ofArray);
 267     }
 268 
 269     /**
 270      * Copy the contents of the given memory segment into a fresh char array.
 271      * @param segment the segment whose contents are to be copied into a char array.
 272      * @return a fresh char array copy of the given memory segment.
 273      * @throws UnsupportedOperationException if the given segment does not feature the {@link MemorySegment#READ} access mode, or if the given
 274      * segment&#39;s contents cannot be copied into a {@link char[]} instance, e.g. because {@code byteSize() % 2 != 0},
 275      * or {@code byteSize() / 2 &gt; Integer#MAX_VALUE}.
 276      * @throws IllegalStateException if the given segment has been closed, or if access occurs from a thread other than the
 277      * thread owning the given segment.
 278      */
 279     public static char[] toCharArray(MemorySegment segment) {
 280         return toArray(segment, char[].class, 2, char[]::new, MemorySegments::ofArray);
 281     }
 282 
 283     /**
 284      * Copy the contents of the given memory segment into a fresh int array.
 285      * @param segment the segment whose contents are to be copied into an int array.
 286      * @return a fresh int array copy of the given memory segment.
 287      * @throws UnsupportedOperationException if the given segment does not feature the {@link MemorySegment#READ} access mode, or if the given
 288      * segment&#39;s contents cannot be copied into a {@link int[]} instance, e.g. because {@code byteSize() % 4 != 0},
 289      * or {@code byteSize() / 4 &gt; Integer#MAX_VALUE}.
 290      * @throws IllegalStateException if the given segment has been closed, or if access occurs from a thread other than the
 291      * thread owning the given segment.
 292      */
 293     public static int[] toIntArray(MemorySegment segment) {
 294         return toArray(segment, int[].class, 4, int[]::new, MemorySegments::ofArray);
 295     }
 296 
 297     /**
 298      * Copy the contents of the given memory segment into a fresh float array.
 299      * @param segment the segment whose contents are to be copied into a float array.
 300      * @return a fresh float array copy of the given memory segment.
 301      * @throws UnsupportedOperationException if the given segment does not feature the {@link MemorySegment#READ} access mode, or if the given
 302      * segment&#39;s contents cannot be copied into a {@link float[]} instance, e.g. because {@code byteSize() % 4 != 0},
 303      * or {@code byteSize() / 4 &gt; Integer#MAX_VALUE}.
 304      * @throws IllegalStateException if the given segment has been closed, or if access occurs from a thread other than the
 305      * thread owning the given segment.
 306      */
 307     public static float[] toFloatArray(MemorySegment segment) {
 308         return toArray(segment, float[].class, 4, float[]::new, MemorySegments::ofArray);
 309     }
 310 
 311     /**
 312      * Copy the contents of the given memory segment into a fresh long array.
 313      * @param segment the segment whose contents are to be copied into a long array.
 314      * @return a fresh long array copy of the given memory segment.
 315      * @throws UnsupportedOperationException if the given segment does not feature the {@link MemorySegment#READ} access mode, or if the given
 316      * segment&#39;s contents cannot be copied into a {@link long[]} instance, e.g. because {@code byteSize() % 8 != 0},
 317      * or {@code byteSize() / 8 &gt; Integer#MAX_VALUE}.
 318      * @throws IllegalStateException if the given segment has been closed, or if access occurs from a thread other than the
 319      * thread owning the given segment.
 320      */
 321     public static long[] toLongArray(MemorySegment segment) {
 322         return toArray(segment, long[].class, 8, long[]::new, MemorySegments::ofArray);
 323     }
 324 
 325     /**
 326      * Copy the contents of the given memory segment into a fresh double array.
 327      * @param segment the segment whose contents are to be copied into a double array.
 328      * @return a fresh double array copy of the given memory segment.
 329      * @throws UnsupportedOperationException if the given segment does not feature the {@link MemorySegment#READ} access mode, or if the given
 330      * segment&#39;s contents cannot be copied into a {@link double[]} instance, e.g. because {@code byteSize() % 8 != 0},
 331      * or {@code byteSize() / 8 &gt; Integer#MAX_VALUE}.
 332      * @throws IllegalStateException if the given segment has been closed, or if access occurs from a thread other than the
 333      * thread owning the given segment.
 334      */
 335     public static double[] toDoubleArray(MemorySegment segment) {
 336         return toArray(segment, double[].class, 8, double[]::new, MemorySegments::ofArray);
 337     }
 338 
 339     /**
 340      * Creates a new buffer memory segment that models the memory associated with the given byte
 341      * buffer. The segment starts relative to the buffer&#39;s position (inclusive)
 342      * and ends relative to the buffer&#39;s limit (exclusive).
 343      * &lt;p&gt;
 344      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link MemorySegment#ALL_ACCESS}),
 345      * unless the given buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will
 346      * not feature the {@link MemorySegment#WRITE} access mode.
 347      * &lt;p&gt;
 348      * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
 349      * for the life-time of the segment.
 350      *
 351      * @param bb the byte buffer backing the buffer memory segment.
 352      * @return a new buffer memory segment.
 353      */
 354     public static MemorySegment ofByteBuffer(ByteBuffer bb) {
 355         return AbstractMemorySegmentImpl.ofBuffer(bb);
 356     }
 357 
 358     /**
 359      * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
 360      * &lt;p&gt;
 361      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
 362      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
 363      * (see {@link MemorySegment#ALL_ACCESS}).
 364      *
 365      * @param arr the primitive array backing the array memory segment.
 366      * @return a new array memory segment.
 367      */
 368     public static MemorySegment ofArray(byte[] arr) {
 369         return HeapMemorySegmentImpl.makeArraySegment(arr);
 370     }
 371 
 372     /**
 373      * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
 374      * &lt;p&gt;
 375      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
 376      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
 377      * (see {@link MemorySegment#ALL_ACCESS}).
 378      *
 379      * @param arr the primitive array backing the array memory segment.
 380      * @return a new array memory segment.
 381      */
 382     public static MemorySegment ofArray(char[] arr) {
 383         return HeapMemorySegmentImpl.makeArraySegment(arr);
 384     }
 385 
 386     /**
 387      * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
 388      * &lt;p&gt;
 389      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
 390      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
 391      * (see {@link MemorySegment#ALL_ACCESS}).
 392      *
 393      * @param arr the primitive array backing the array memory segment.
 394      * @return a new array memory segment.
 395      */
 396     public static MemorySegment ofArray(short[] arr) {
 397         return HeapMemorySegmentImpl.makeArraySegment(arr);
 398     }
 399 
 400     /**
 401      * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.
 402      * &lt;p&gt;
 403      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
 404      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.
 405      *
 406      * @param arr the primitive array backing the array memory segment.
 407      * @return a new array memory segment.
 408      */
 409     public static MemorySegment ofArray(int[] arr) {
 410         return HeapMemorySegmentImpl.makeArraySegment(arr);
 411     }
 412 
 413     /**
 414      * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
 415      * &lt;p&gt;
 416      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
 417      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
 418      * (see {@link MemorySegment#ALL_ACCESS}).
 419      *
 420      * @param arr the primitive array backing the array memory segment.
 421      * @return a new array memory segment.
 422      */
 423     public static MemorySegment ofArray(float[] arr) {
 424         return HeapMemorySegmentImpl.makeArraySegment(arr);
 425     }
 426 
 427     /**
 428      * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
 429      * &lt;p&gt;
 430      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
 431      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
 432      * (see {@link MemorySegment#ALL_ACCESS}).
 433      *
 434      * @param arr the primitive array backing the array memory segment.
 435      * @return a new array memory segment.
 436      */
 437     public static MemorySegment ofArray(long[] arr) {
 438         return HeapMemorySegmentImpl.makeArraySegment(arr);
 439     }
 440 
 441     /**
 442      * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
 443      * &lt;p&gt;
 444      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
 445      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
 446      * (see {@link MemorySegment#ALL_ACCESS}).
 447      *
 448      * @param arr the primitive array backing the array memory segment.
 449      * @return a new array memory segment.
 450      */
 451     public static MemorySegment ofArray(double[] arr) {
 452         return HeapMemorySegmentImpl.makeArraySegment(arr);
 453     }
 454 
 455     /**
 456      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.
 457      * &lt;p&gt;
 458      * This is equivalent to the following code:
 459      * &lt;blockquote&gt;&lt;pre&gt;{@code
 460     allocateNative(layout.bytesSize(), layout.bytesAlignment());
 461      * }&lt;/pre&gt;&lt;/blockquote&gt;
 462      *
 463      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
 464      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
 465      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
 466      *
 467      * @param layout the layout of the off-heap memory block backing the native memory segment.
 468      * @return a new native memory segment.
 469      * @throws IllegalArgumentException if the specified layout has illegal size or alignment constraint.
 470      */
 471     public static MemorySegment allocateNative(MemoryLayout layout) {
 472         return allocateNative(layout.byteSize(), layout.byteAlignment());
 473     }
 474 
 475     /**
 476      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).
 477      * &lt;p&gt;
 478      * This is equivalent to the following code:
 479      * &lt;blockquote&gt;&lt;pre&gt;{@code
 480     allocateNative(bytesSize, 1);
 481      * }&lt;/pre&gt;&lt;/blockquote&gt;
 482      *
 483      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
 484      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
 485      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
 486      *
 487      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
 488      * @return a new native memory segment.
 489      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}.
 490      */
 491     public static MemorySegment allocateNative(long bytesSize) {
 492         return allocateNative(bytesSize, 1);
 493     }
 494 
 495     /**
 496      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
 497      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
 498      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
 499      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
 500      * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
 501      * (see {@link MemorySegment#ALL_ACCESS}).
 502      * &lt;p&gt;
 503      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted methods are unsafe, and, if used incorrectly, their use might crash
 504      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
 505      * restricted methods, and use safe and supported functionalities, where possible.
 506      *
 507      * @param addr the desired base address
 508      * @param bytesSize the desired size.
 509      * @param owner the desired owner thread. If {@code owner == null}, the returned segment is &lt;em&gt;not&lt;/em&gt; confined.
 510      * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
 511      *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
 512      * @param attachment an object that must be kept alive by the returned segment; this can be useful when
 513      *                   the returned segment depends on memory which could be released if a certain object
 514      *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
 515      * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.
 516      * @throws IllegalArgumentException if {@code bytesSize &lt;= 0}.
 517      * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.
 518      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
 519      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
 520      * @throws NullPointerException if {@code addr == null}.
 521      */
 522     public static MemorySegment ofNativeRestricted(MemoryAddress addr, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {
 523         Objects.requireNonNull(addr);
 524         if (bytesSize &lt;= 0) {
 525             throw new IllegalArgumentException(&quot;Invalid size : &quot; + bytesSize);
 526         }
 527         Utils.checkRestrictedAccess(&quot;MemorySegment.ofNativeRestricted&quot;);
 528         return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, bytesSize, owner, cleanup, attachment);
 529     }
 530 
 531     /**
 532      * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
 533      * &lt;p&gt;
 534      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link MemorySegment#ALL_ACCESS}),
 535      * unless the given mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY}, in which case
 536      * the segment will not feature the {@link MemorySegment#WRITE} access mode.
 537      *
 538      * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
 539      * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
 540      *
 541      * @param path the path to the file to memory map.
 542      * @param bytesOffset the offset (expressed in bytes) within the file at which the mapped segment is to start.
 543      * @param bytesSize the size (in bytes) of the mapped memory backing the memory segment.
 544      * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode
 545      *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegment#force()}).
 546      * @return a new mapped memory segment.
 547      * @throws IllegalArgumentException if {@code bytesOffset &lt; 0}.
 548      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}.
 549      * @throws UnsupportedOperationException if an unsupported map mode is specified.
 550      * @throws IOException if the specified path does not point to an existing file, or if some other I/O error occurs.
 551      */
 552     public static MappedMemorySegment mapFromPath(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
 553         return MappedMemorySegmentImpl.makeMappedSegment(path, bytesOffset, bytesSize, mapMode);
 554     }
 555 
 556     /**
 557      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
 558      * alignment constraint (in bytes). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
 559      * (see {@link MemorySegment#ALL_ACCESS}).
 560      *
 561      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
 562      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
 563      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
 564      *
 565      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
 566      * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.
 567      * @return a new native memory segment.
 568      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}, {@code alignmentBytes &lt; 0}, or if {@code alignmentBytes}
 569      * is not a power of 2.
 570      */
 571     public static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {
 572         if (bytesSize &lt;= 0) {
 573             throw new IllegalArgumentException(&quot;Invalid allocation size : &quot; + bytesSize);
 574         }
 575 
 576         if (alignmentBytes &lt; 0 ||
 577                 ((alignmentBytes &amp; (alignmentBytes - 1)) != 0L)) {
 578             throw new IllegalArgumentException(&quot;Invalid alignment constraint : &quot; + alignmentBytes);
 579         }
 580 
 581         return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
 582     }
 583 
 584     private static final VarHandle byte_LE_handle = indexedHandle(MemoryLayouts.BITS_8_LE, byte.class);
 585     private static final VarHandle char_LE_handle = indexedHandle(MemoryLayouts.BITS_16_LE, char.class);
 586     private static final VarHandle short_LE_handle = indexedHandle(MemoryLayouts.BITS_16_LE, short.class);
 587     private static final VarHandle int_LE_handle = indexedHandle(MemoryLayouts.BITS_32_LE, int.class);
 588     private static final VarHandle float_LE_handle = indexedHandle(MemoryLayouts.BITS_32_LE, float.class);
 589     private static final VarHandle long_LE_handle = indexedHandle(MemoryLayouts.BITS_64_LE, long.class);
 590     private static final VarHandle double_LE_handle = indexedHandle(MemoryLayouts.BITS_64_LE, double.class);
 591 
 592     /**
 593      * Read a byte from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 594      * &lt;p&gt;
 595      * This is equivalent to the following code:
 596      * &lt;blockquote&gt;&lt;pre&gt;{@code
 597     VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);
 598     byte value = (byte)handle.get(addr, offset);
 599      * }&lt;/pre&gt;&lt;/blockquote&gt;
 600      *
 601      * @param addr base address.
 602      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 603      * @return a byte value read from {@code addr} at the offset specified by {@code index}.
 604      */
 605     public static byte getByte_LE(MemoryAddress addr, long offset) {
 606         return (byte)byte_LE_handle.get(addr, offset);
 607     }
 608 
 609     /**
 610      * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 611      * &lt;p&gt;
 612      * This is equivalent to the following code:
 613      * &lt;blockquote&gt;&lt;pre&gt;{@code
 614     VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);
 615     handle.set(addr, offset, value);
 616      * }&lt;/pre&gt;&lt;/blockquote&gt;
 617      * @param addr base address.
 618      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 619      * @param value the byte value to be written.
 620      */
 621     public static void setByte_LE(MemoryAddress addr, long offset, byte value) {
 622         byte_LE_handle.set(addr, offset, value);
 623     }
 624 
 625     /**
 626      * Read a char from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 627      * &lt;p&gt;
 628      * This is equivalent to the following code:
 629      * &lt;blockquote&gt;&lt;pre&gt;{@code
 630     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);
 631     char value = (char)handle.get(addr, offset);
 632      * }&lt;/pre&gt;&lt;/blockquote&gt;
 633      * @param addr base address.
 634      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 635      * @return a char value read from {@code addr} at the offset specified by {@code index}.
 636      */
 637     public static char getChar_LE(MemoryAddress addr, long offset) {
 638         return (char)char_LE_handle.get(addr, offset);
 639     }
 640 
 641     /**
 642      * Writes a char at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 643      * &lt;p&gt;
 644      * This is equivalent to the following code:
 645      * &lt;blockquote&gt;&lt;pre&gt;{@code
 646     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);
 647     handle.set(addr, offset, value);
 648      * }&lt;/pre&gt;&lt;/blockquote&gt;
 649      * @param addr base address.
 650      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 651      * @param value the char value to be written.
 652      */
 653     public static void setChar_LE(MemoryAddress addr, long offset, char value) {
 654         char_LE_handle.set(addr, offset, value);
 655     }
 656 
 657     /**
 658      * Read a short from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 659      * &lt;p&gt;
 660      * This is equivalent to the following code:
 661      * &lt;blockquote&gt;&lt;pre&gt;{@code
 662     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);
 663     short value = (short)handle.get(addr, offset);
 664      * }&lt;/pre&gt;&lt;/blockquote&gt;
 665      * @param addr base address.
 666      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 667      * @return a short value read from {@code addr} at the offset specified by {@code index}.
 668      */
 669     public static short getShort_LE(MemoryAddress addr, long offset) {
 670         return (short)short_LE_handle.get(addr, offset);
 671     }
 672 
 673     /**
 674      * Writes a short at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 675      * &lt;p&gt;
 676      * This is equivalent to the following code:
 677      * &lt;blockquote&gt;&lt;pre&gt;{@code
 678     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);
 679     handle.set(addr, offset, value);
 680      * }&lt;/pre&gt;&lt;/blockquote&gt;
 681      * @param addr base address.
 682      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 683      * @param value the short value to be written.
 684      */
 685     public static void setShort_LE(MemoryAddress addr, long offset, short value) {
 686         short_LE_handle.set(addr, offset, value);
 687     }
 688 
 689     /**
 690      * Read an int from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 691      * &lt;p&gt;
 692      * This is equivalent to the following code:
 693      * &lt;blockquote&gt;&lt;pre&gt;{@code
 694     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);
 695     int value = (int)handle.get(addr, offset);
 696      * }&lt;/pre&gt;&lt;/blockquote&gt;
 697      * @param addr base address.
 698      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 699      * @return an int value read from {@code addr} at the offset specified by {@code index}.
 700      */
 701     public static int getInt_LE(MemoryAddress addr, long offset) {
 702         return (int)int_LE_handle.get(addr, offset);
 703     }
 704 
 705     /**
 706      * Writes an int at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 707      * &lt;p&gt;
 708      * This is equivalent to the following code:
 709      * &lt;blockquote&gt;&lt;pre&gt;{@code
 710     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);
 711     handle.set(addr, offset, value);
 712      * }&lt;/pre&gt;&lt;/blockquote&gt;
 713      * @param addr base address.
 714      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 715      * @param value the int value to be written.
 716      */
 717     public static void setInt_LE(MemoryAddress addr, long offset, int value) {
 718         int_LE_handle.set(addr, offset, value);
 719     }
 720 
 721     /**
 722      * Read a float from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 723      * &lt;p&gt;
 724      * This is equivalent to the following code:
 725      * &lt;blockquote&gt;&lt;pre&gt;{@code
 726     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);
 727     float value = (float)handle.get(addr, offset);
 728      * }&lt;/pre&gt;&lt;/blockquote&gt;
 729      * @param addr base address.
 730      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 731      * @return a float value read from {@code addr} at the offset specified by {@code index}.
 732      */
 733     public static float getFloat_LE(MemoryAddress addr, long offset) {
 734         return (float)float_LE_handle.get(addr, offset);
 735     }
 736 
 737     /**
 738      * Writes a float at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 739      * &lt;p&gt;
 740      * This is equivalent to the following code:
 741      * &lt;blockquote&gt;&lt;pre&gt;{@code
 742     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);
 743     handle.set(addr, offset, value);
 744      * }&lt;/pre&gt;&lt;/blockquote&gt;
 745      * @param addr base address.
 746      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 747      * @param value the float value to be written.
 748      */
 749     public static void setFloat_LE(MemoryAddress addr, long offset, float value) {
 750         float_LE_handle.set(addr, offset, value);
 751     }
 752 
 753     /**
 754      * Read a long from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 755      * &lt;p&gt;
 756      * This is equivalent to the following code:
 757      * &lt;blockquote&gt;&lt;pre&gt;{@code
 758     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);
 759     long value = (long)handle.get(addr, offset);
 760      * }&lt;/pre&gt;&lt;/blockquote&gt;
 761      * @param addr base address.
 762      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 763      * @return a long value read from {@code addr} at the offset specified by {@code index}.
 764      */
 765     public static long getLong_LE(MemoryAddress addr, long offset) {
 766         return (long)long_LE_handle.get(addr, offset);
 767     }
 768 
 769     /**
 770      * Writes a long at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 771      * &lt;p&gt;
 772      * This is equivalent to the following code:
 773      * &lt;blockquote&gt;&lt;pre&gt;{@code
 774     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);
 775     handle.set(addr, offset, value);
 776      * }&lt;/pre&gt;&lt;/blockquote&gt;
 777      * @param addr base address.
 778      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 779      * @param value the long value to be written.
 780      */
 781     public static void setLong_LE(MemoryAddress addr, long offset, long value) {
 782         long_LE_handle.set(addr, offset, value);
 783     }
 784 
 785     /**
 786      * Read a double from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 787      * &lt;p&gt;
 788      * This is equivalent to the following code:
 789      * &lt;blockquote&gt;&lt;pre&gt;{@code
 790     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(double.class), 1L);
 791     double value = (double)handle.get(addr, offset);
 792      * }&lt;/pre&gt;&lt;/blockquote&gt;
 793      * @param addr base address.
 794      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 795      * @return a double value read from {@code addr} at the offset specified by {@code index}.
 796      */
 797     public static double getDouble_LE(MemoryAddress addr, long offset) {
 798         return (double)double_LE_handle.get(addr, offset);
 799     }
 800 
 801     /**
 802      * Writes a double at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 803      * &lt;p&gt;
 804      * This is equivalent to the following code:
 805      * &lt;blockquote&gt;&lt;pre&gt;{@code
 806     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(double.class), 1L);
 807     handle.set(addr, offset, value);
 808      * }&lt;/pre&gt;&lt;/blockquote&gt;
 809      * @param addr base address.
 810      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 811      * @param value the double value to be written.
 812      */
 813     public static void setDouble_LE(MemoryAddress addr, long offset, double value) {
 814         double_LE_handle.set(addr, offset, value);
 815     }
 816 
 817     private static final VarHandle byte_BE_handle = indexedHandle(MemoryLayouts.BITS_8_BE, byte.class);
 818     private static final VarHandle char_BE_handle = indexedHandle(MemoryLayouts.BITS_16_BE, char.class);
 819     private static final VarHandle short_BE_handle = indexedHandle(MemoryLayouts.BITS_16_BE, short.class);
 820     private static final VarHandle int_BE_handle = indexedHandle(MemoryLayouts.BITS_32_BE, int.class);
 821     private static final VarHandle float_BE_handle = indexedHandle(MemoryLayouts.BITS_32_BE, float.class);
 822     private static final VarHandle long_BE_handle = indexedHandle(MemoryLayouts.BITS_64_BE, long.class);
 823     private static final VarHandle double_BE_handle = indexedHandle(MemoryLayouts.BITS_64_BE, double.class);
 824 
 825     /**
 826      * Read a byte from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
 827      * &lt;p&gt;
 828      * This is equivalent to the following code:
 829      * &lt;blockquote&gt;&lt;pre&gt;{@code
 830     VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);
 831     byte value = (byte)handle.get(addr, offset);
 832      * }&lt;/pre&gt;&lt;/blockquote&gt;
 833      *
 834      * @param addr base address.
 835      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 836      * @return a byte value read from {@code addr} at the offset specified by {@code index}.
 837      */
 838     public static byte getByte_BE(MemoryAddress addr, long offset) {
 839         return (byte)byte_BE_handle.get(addr, offset);
 840     }
 841 
 842     /**
 843      * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
 844      * &lt;p&gt;
 845      * This is equivalent to the following code:
 846      * &lt;blockquote&gt;&lt;pre&gt;{@code
 847     VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);
 848     handle.set(addr, offset, value);
 849      * }&lt;/pre&gt;&lt;/blockquote&gt;
 850      * @param addr base address.
 851      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 852      * @param value the byte value to be written.
 853      */
 854     public static void setByte_BE(MemoryAddress addr, long offset, byte value) {
 855         byte_BE_handle.set(addr, offset, value);
 856     }
 857 
 858     /**
 859      * Read a char from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
 860      * &lt;p&gt;
 861      * This is equivalent to the following code:
 862      * &lt;blockquote&gt;&lt;pre&gt;{@code
 863     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);
 864     char value = (char)handle.get(addr, offset);
 865      * }&lt;/pre&gt;&lt;/blockquote&gt;
 866      * @param addr base address.
 867      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 868      * @return a char value read from {@code addr} at the offset specified by {@code index}.
 869      */
 870     public static char getChar_BE(MemoryAddress addr, long offset) {
 871         return (char)char_BE_handle.get(addr, offset);
 872     }
 873 
 874     /**
 875      * Writes a char at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
 876      * &lt;p&gt;
 877      * This is equivalent to the following code:
 878      * &lt;blockquote&gt;&lt;pre&gt;{@code
 879     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);
 880     handle.set(addr, offset, value);
 881      * }&lt;/pre&gt;&lt;/blockquote&gt;
 882      * @param addr base address.
 883      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 884      * @param value the char value to be written.
 885      */
 886     public static void setChar_BE(MemoryAddress addr, long offset, char value) {
 887         char_BE_handle.set(addr, offset, value);
 888     }
 889 
 890     /**
 891      * Read a short from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
 892      * &lt;p&gt;
 893      * This is equivalent to the following code:
 894      * &lt;blockquote&gt;&lt;pre&gt;{@code
 895     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);
 896     short value = (short)handle.get(addr, offset);
 897      * }&lt;/pre&gt;&lt;/blockquote&gt;
 898      * @param addr base address.
 899      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 900      * @return a short value read from {@code addr} at the offset specified by {@code index}.
 901      */
 902     public static short getShort_BE(MemoryAddress addr, long offset) {
 903         return (short)short_BE_handle.get(addr, offset);
 904     }
 905 
 906     /**
 907      * Writes a short at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
 908      * &lt;p&gt;
 909      * This is equivalent to the following code:
 910      * &lt;blockquote&gt;&lt;pre&gt;{@code
 911     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);
 912     handle.set(addr, offset, value);
 913      * }&lt;/pre&gt;&lt;/blockquote&gt;
 914      * @param addr base address.
 915      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 916      * @param value the short value to be written.
 917      */
 918     public static void setShort_BE(MemoryAddress addr, long offset, short value) {
 919         short_BE_handle.set(addr, offset, value);
 920     }
 921 
 922     /**
 923      * Read an int from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
 924      * &lt;p&gt;
 925      * This is equivalent to the following code:
 926      * &lt;blockquote&gt;&lt;pre&gt;{@code
 927     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);
 928     int value = (int)handle.get(addr, offset);
 929      * }&lt;/pre&gt;&lt;/blockquote&gt;
 930      * @param addr base address.
 931      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 932      * @return an int value read from {@code addr} at the offset specified by {@code index}.
 933      */
 934     public static int getInt_BE(MemoryAddress addr, long offset) {
 935         return (int)int_BE_handle.get(addr, offset);
 936     }
 937 
 938     /**
 939      * Writes an int at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
 940      * &lt;p&gt;
 941      * This is equivalent to the following code:
 942      * &lt;blockquote&gt;&lt;pre&gt;{@code
 943     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);
 944     handle.set(addr, offset, value);
 945      * }&lt;/pre&gt;&lt;/blockquote&gt;
 946      * @param addr base address.
 947      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 948      * @param value the int value to be written.
 949      */
 950     public static void setInt_BE(MemoryAddress addr, long offset, int value) {
 951         int_BE_handle.set(addr, offset, value);
 952     }
 953 
 954     /**
 955      * Read a float from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
 956      * &lt;p&gt;
 957      * This is equivalent to the following code:
 958      * &lt;blockquote&gt;&lt;pre&gt;{@code
 959     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);
 960     float value = (float)handle.get(addr, offset);
 961      * }&lt;/pre&gt;&lt;/blockquote&gt;
 962      * @param addr base address.
 963      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 964      * @return a float value read from {@code addr} at the offset specified by {@code index}.
 965      */
 966     public static float getFloat_BE(MemoryAddress addr, long offset) {
 967         return (float)float_BE_handle.get(addr, offset);
 968     }
 969 
 970     /**
 971      * Writes a float at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
 972      * &lt;p&gt;
 973      * This is equivalent to the following code:
 974      * &lt;blockquote&gt;&lt;pre&gt;{@code
 975     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);
 976     handle.set(addr, offset, value);
 977      * }&lt;/pre&gt;&lt;/blockquote&gt;
 978      * @param addr base address.
 979      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 980      * @param value the float value to be written.
 981      */
 982     public static void setFloat_BE(MemoryAddress addr, long offset, float value) {
 983         float_BE_handle.set(addr, offset, value);
 984     }
 985 
 986     /**
 987      * Read a long from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
 988      * &lt;p&gt;
 989      * This is equivalent to the following code:
 990      * &lt;blockquote&gt;&lt;pre&gt;{@code
 991     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);
 992     long value = (long)handle.get(addr, offset);
 993      * }&lt;/pre&gt;&lt;/blockquote&gt;
 994      * @param addr base address.
 995      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 996      * @return a long value read from {@code addr} at the offset specified by {@code index}.
 997      */
 998     public static long getLong_BE(MemoryAddress addr, long offset) {
 999         return (long)long_BE_handle.get(addr, offset);
1000     }
1001 
1002     /**
1003      * Writes a long at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
1004      * &lt;p&gt;
1005      * This is equivalent to the following code:
1006      * &lt;blockquote&gt;&lt;pre&gt;{@code
1007     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);
1008     handle.set(addr, offset, value);
1009      * }&lt;/pre&gt;&lt;/blockquote&gt;
1010      * @param addr base address.
1011      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1012      * @param value the long value to be written.
1013      */
1014     public static void setLong_BE(MemoryAddress addr, long offset, long value) {
1015         long_BE_handle.set(addr, offset, value);
1016     }
1017 
1018     /**
1019      * Read a double from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
1020      * &lt;p&gt;
1021      * This is equivalent to the following code:
1022      * &lt;blockquote&gt;&lt;pre&gt;{@code
1023     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(double.class), 1L);
1024     double value = (double)handle.get(addr, offset);
1025      * }&lt;/pre&gt;&lt;/blockquote&gt;
1026      * @param addr base address.
1027      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1028      * @return a double value read from {@code addr} at the offset specified by {@code index}.
1029      */
1030     public static double getDouble_BE(MemoryAddress addr, long offset) {
1031         return (double)double_BE_handle.get(addr, offset);
1032     }
1033 
1034     /**
1035      * Writes a double at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
1036      * &lt;p&gt;
1037      * This is equivalent to the following code:
1038      * &lt;blockquote&gt;&lt;pre&gt;{@code
1039     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(double.class), 1L);
1040     handle.set(addr, offset, value);
1041      * }&lt;/pre&gt;&lt;/blockquote&gt;
1042      * @param addr base address.
1043      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1044      * @param value the double value to be written.
1045      */
1046     public static void setDouble_BE(MemoryAddress addr, long offset, double value) {
1047         double_BE_handle.set(addr, offset, value);
1048     }
1049 
1050     /**
1051      * Read a byte from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
1052      * &lt;p&gt;
1053      * This is equivalent to the following code:
1054      * &lt;blockquote&gt;&lt;pre&gt;{@code
1055     VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);
1056     byte value = (byte)handle.get(addr, offset);
1057      * }&lt;/pre&gt;&lt;/blockquote&gt;
1058      *
1059      * @param addr base address.
1060      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1061      * @return a byte value read from {@code addr} at the offset specified by {@code index}.
1062      */
1063     public static byte getByte(MemoryAddress addr, long offset) {
1064         return (byte)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).get(addr, offset);
1065     }
1066 
1067     /**
1068      * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
1069      * &lt;p&gt;
1070      * This is equivalent to the following code:
1071      * &lt;blockquote&gt;&lt;pre&gt;{@code
1072     VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);
1073     handle.set(addr, offset, value);
1074      * }&lt;/pre&gt;&lt;/blockquote&gt;
1075      * @param addr base address.
1076      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1077      * @param value the byte value to be written.
1078      */
1079     public static void setByte(MemoryAddress addr, long offset, byte value) {
1080         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).set(addr, offset, value);
1081     }
1082 
1083     /**
1084      * Read a char from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
1085      * &lt;p&gt;
1086      * This is equivalent to the following code:
1087      * &lt;blockquote&gt;&lt;pre&gt;{@code
1088     VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);
1089     char value = (char)handle.get(addr, offset);
1090      * }&lt;/pre&gt;&lt;/blockquote&gt;
1091      * @param addr base address.
1092      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1093      * @return a char value read from {@code addr} at the offset specified by {@code index}.
1094      */
1095     public static char getChar(MemoryAddress addr, long offset) {
1096         return (char)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(addr, offset);
1097     }
1098 
1099     /**
1100      * Writes a char at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
1101      * &lt;p&gt;
1102      * This is equivalent to the following code:
1103      * &lt;blockquote&gt;&lt;pre&gt;{@code
1104     VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);
1105     handle.set(addr, offset, value);
1106      * }&lt;/pre&gt;&lt;/blockquote&gt;
1107      * @param addr base address.
1108      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1109      * @param value the char value to be written.
1110      */
1111     public static void setChar(MemoryAddress addr, long offset, char value) {
1112         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(addr, offset, value);
1113     }
1114 
1115     /**
1116      * Read a short from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
1117      * &lt;p&gt;
1118      * This is equivalent to the following code:
1119      * &lt;blockquote&gt;&lt;pre&gt;{@code
1120     VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);
1121     short value = (short)handle.get(addr, offset);
1122      * }&lt;/pre&gt;&lt;/blockquote&gt;
1123      * @param addr base address.
1124      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1125      * @return a short value read from {@code addr} at the offset specified by {@code index}.
1126      */
1127     public static short getShort(MemoryAddress addr, long offset) {
1128         return (short)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(addr, offset);
1129     }
1130 
1131     /**
1132      * Writes a short at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
1133      * &lt;p&gt;
1134      * This is equivalent to the following code:
1135      * &lt;blockquote&gt;&lt;pre&gt;{@code
1136     VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);
1137     handle.set(addr, offset, value);
1138      * }&lt;/pre&gt;&lt;/blockquote&gt;
1139      * @param addr base address.
1140      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1141      * @param value the short value to be written.
1142      */
1143     public static void setShort(MemoryAddress addr, long offset, short value) {
1144         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(addr, offset, value);
1145     }
1146 
1147     /**
1148      * Read an int from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
1149      * &lt;p&gt;
1150      * This is equivalent to the following code:
1151      * &lt;blockquote&gt;&lt;pre&gt;{@code
1152     VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);
1153     int value = (int)handle.get(addr, offset);
1154      * }&lt;/pre&gt;&lt;/blockquote&gt;
1155      * @param addr base address.
1156      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1157      * @return an int value read from {@code addr} at the offset specified by {@code index}.
1158      */
1159     public static int getInt(MemoryAddress addr, long offset) {
1160         return (int)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(addr, offset);
1161     }
1162 
1163     /**
1164      * Writes an int at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
1165      * &lt;p&gt;
1166      * This is equivalent to the following code:
1167      * &lt;blockquote&gt;&lt;pre&gt;{@code
1168     VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);
1169     handle.set(addr, offset, value);
1170      * }&lt;/pre&gt;&lt;/blockquote&gt;
1171      * @param addr base address.
1172      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1173      * @param value the int value to be written.
1174      */
1175     public static void setInt(MemoryAddress addr, long offset, int value) {
1176         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(addr, offset, value);
1177     }
1178 
1179     /**
1180      * Read a float from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
1181      * &lt;p&gt;
1182      * This is equivalent to the following code:
1183      * &lt;blockquote&gt;&lt;pre&gt;{@code
1184     VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);
1185     float value = (float)handle.get(addr, offset);
1186      * }&lt;/pre&gt;&lt;/blockquote&gt;
1187      * @param addr base address.
1188      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1189      * @return a float value read from {@code addr} at the offset specified by {@code index}.
1190      */
1191     public static float getFloat(MemoryAddress addr, long offset) {
1192         return (float)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(addr, offset);
1193     }
1194 
1195     /**
1196      * Writes a float at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
1197      * &lt;p&gt;
1198      * This is equivalent to the following code:
1199      * &lt;blockquote&gt;&lt;pre&gt;{@code
1200     VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);
1201     handle.set(addr, offset, value);
1202      * }&lt;/pre&gt;&lt;/blockquote&gt;
1203      * @param addr base address.
1204      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1205      * @param value the float value to be written.
1206      */
1207     public static void setFloat(MemoryAddress addr, long offset, float value) {
1208         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(addr, offset, value);
1209     }
1210 
1211     /**
1212      * Read a long from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
1213      * &lt;p&gt;
1214      * This is equivalent to the following code:
1215      * &lt;blockquote&gt;&lt;pre&gt;{@code
1216     VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);
1217     long value = (long)handle.get(addr, offset);
1218      * }&lt;/pre&gt;&lt;/blockquote&gt;
1219      * @param addr base address.
1220      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1221      * @return a long value read from {@code addr} at the offset specified by {@code index}.
1222      */
1223     public static long getLong(MemoryAddress addr, long offset) {
1224         return (long)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(addr, offset);
1225     }
1226 
1227     /**
1228      * Writes a long at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
1229      * &lt;p&gt;
1230      * This is equivalent to the following code:
1231      * &lt;blockquote&gt;&lt;pre&gt;{@code
1232     VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);
1233     handle.set(addr, offset, value);
1234      * }&lt;/pre&gt;&lt;/blockquote&gt;
1235      * @param addr base address.
1236      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1237      * @param value the long value to be written.
1238      */
1239     public static void setLong(MemoryAddress addr, long offset, long value) {
1240         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(addr, offset, value);
1241     }
1242 
1243     /**
1244      * Read a double from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
1245      * &lt;p&gt;
1246      * This is equivalent to the following code:
1247      * &lt;blockquote&gt;&lt;pre&gt;{@code
1248     VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);
1249     double value = (double)handle.get(addr, offset);
1250      * }&lt;/pre&gt;&lt;/blockquote&gt;
1251      * @param addr base address.
1252      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1253      * @return a double value read from {@code addr} at the offset specified by {@code index}.
1254      */
1255     public static double getDouble(MemoryAddress addr, long offset) {
1256         return (double)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(addr, offset);
1257     }
1258 
1259     /**
1260      * Writes a double at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
1261      * &lt;p&gt;
1262      * This is equivalent to the following code:
1263      * &lt;blockquote&gt;&lt;pre&gt;{@code
1264     VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);
1265     handle.set(addr, offset, value);
1266      * }&lt;/pre&gt;&lt;/blockquote&gt;
1267      * @param addr base address.
1268      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
1269      * @param value the double value to be written.
1270      */
1271     public static void setDouble(MemoryAddress addr, long offset, double value) {
1272         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(addr, offset, value);
1273     }
1274 
1275     private static VarHandle indexedHandle(MemoryLayout elementLayout, Class&lt;?&gt; carrier) {
1276         return MemoryHandles.withStride(elementLayout.withBitAlignment(8).varHandle(carrier), 1L);
1277     }
1278 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 
 27 package jdk.incubator.foreign;
 28 
 29 import java.nio.ByteBuffer;
 30 
<a name="1" id="anc1"></a>






 31 import java.nio.channels.FileChannel;
 32 import java.nio.file.Path;
<a name="2" id="anc2"></a>
 33 import java.util.Spliterator;
<a name="3" id="anc3"></a>
 34 
 35 /**
 36  * A memory segment models a contiguous region of memory. A memory segment is associated with both spatial
 37  * and temporal bounds. Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location
 38  * which falls &lt;em&gt;outside&lt;/em&gt; the boundaries of the memory segment being accessed. Temporal bounds ensure that memory access
 39  * operations on a segment cannot occur after a memory segment has been closed (see {@link MemorySegment#close()}).
 40  * &lt;p&gt;
 41  * All implementations of this interface must be &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;;
 42  * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on
 43  * instances of {@code MemorySegment} may have unpredictable results and should be avoided. The {@code equals} method should
 44  * be used for comparisons.
 45  * &lt;p&gt;
 46  * Non-platform classes should not implement {@linkplain MemorySegment} directly.
 47  *
 48  * &lt;h2&gt;Constructing memory segments from different sources&lt;/h2&gt;
 49  *
 50  * There are multiple ways to obtain a memory segment. First, memory segments backed by off-heap memory can
<a name="4" id="anc4"></a><span class="line-modified"> 51  * be allocated using one of the many factory methods provided (see {@link MemorySegments#allocateNative(MemoryLayout)},</span>
<span class="line-modified"> 52  * {@link MemorySegments#allocateNative(long)} and {@link MemorySegments#allocateNative(long, long)}). Memory segments obtained</span>
 53  * in this way are called &lt;em&gt;native memory segments&lt;/em&gt;.
 54  * &lt;p&gt;
 55  * It is also possible to obtain a memory segment backed by an existing heap-allocated Java array,
<a name="5" id="anc5"></a><span class="line-modified"> 56  * using one of the provided factory methods (e.g. {@link MemorySegments#ofArray(int[])}). Memory segments obtained</span>
 57  * in this way are called &lt;em&gt;array memory segments&lt;/em&gt;.
 58  * &lt;p&gt;
 59  * It is possible to obtain a memory segment backed by an existing Java byte buffer (see {@link ByteBuffer}),
<a name="6" id="anc6"></a><span class="line-modified"> 60  * using the factory method {@link MemorySegments#ofByteBuffer(ByteBuffer)}.</span>
 61  * Memory segments obtained in this way are called &lt;em&gt;buffer memory segments&lt;/em&gt;. Note that buffer memory segments might
 62  * be backed by native memory (as in the case of native memory segments) or heap memory (as in the case of array memory segments),
 63  * depending on the characteristics of the byte buffer instance the segment is associated with. For instance, a buffer memory
 64  * segment obtained from a byte buffer created with the {@link ByteBuffer#allocateDirect(int)} method will be backed
 65  * by native memory.
 66  * &lt;p&gt;
 67  * Finally, it is also possible to obtain a memory segment backed by a memory-mapped file using the factory method
<a name="7" id="anc7"></a><span class="line-modified"> 68  * {@link MemorySegments#mapFromPath(Path, long, long, FileChannel.MapMode)}. Such memory segments are called &lt;em&gt;mapped memory segments&lt;/em&gt;</span>
 69  * (see {@link MappedMemorySegment}).
 70  * &lt;p&gt;
 71  * Array and buffer segments are effectively &lt;em&gt;views&lt;/em&gt; over existing memory regions which might outlive the
 72  * lifecycle of the segments derived from them, and can even be manipulated directly (e.g. via array access, or direct use
 73  * of the {@link ByteBuffer} API) by other clients. As a result, while sharing array or buffer segments is possible,
 74  * it is strongly advised that clients wishing to do so take extra precautions to make sure that the underlying memory sources
 75  * associated with such segments remain inaccessible, and that said memory sources are never aliased by more than one segment
 76  * at a time - e.g. so as to prevent concurrent modifications of the contents of an array, or buffer segment.
 77  *
 78  * &lt;h2&gt;Closing a memory segment&lt;/h2&gt;
 79  *
 80  * Memory segments are closed explicitly (see {@link MemorySegment#close()}). When a segment is closed, it is no longer
 81  * &lt;em&gt;alive&lt;/em&gt; (see {@link #isAlive()}, and subsequent operation on the segment (or on any {@link MemoryAddress} instance
 82  * derived from it) will fail with {@link IllegalStateException}.
 83  * &lt;p&gt;
 84  * Closing a segment might trigger the releasing of the underlying memory resources associated with said segment, depending on
 85  * the kind of memory segment being considered:
 86  * &lt;ul&gt;
 87  *     &lt;li&gt;closing a native memory segment results in &lt;em&gt;freeing&lt;/em&gt; the native memory associated with it&lt;/li&gt;
 88  *     &lt;li&gt;closing a mapped memory segment results in the backing memory-mapped file to be unmapped&lt;/li&gt;
 89  *     &lt;li&gt;closing a buffer, or a heap segment does not have any side-effect, other than marking the segment
 90  *     as &lt;em&gt;not alive&lt;/em&gt; (see {@link MemorySegment#isAlive()}). Also, since the buffer and heap segments might keep
 91  *     strong references to the original buffer or array instance, it is the responsibility of clients to ensure that
 92  *     these segments are discarded in a timely manner, so as not to prevent garbage collection to reclaim the underlying
 93  *     objects.&lt;/li&gt;
 94  * &lt;/ul&gt;
 95  *
 96  * &lt;h2&gt;&lt;a id = &quot;access-modes&quot;&gt;Access modes&lt;/a&gt;&lt;/h2&gt;
 97  *
 98  * Memory segments supports zero or more &lt;em&gt;access modes&lt;/em&gt;. Supported access modes are {@link #READ},
 99  * {@link #WRITE}, {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}. The set of access modes supported by a segment alters the
100  * set of operations that are supported by that segment. For instance, attempting to call {@link #close()} on
101  * a segment which does not support the {@link #CLOSE} access mode will result in an exception.
102  * &lt;p&gt;
103  * The set of supported access modes can only be made stricter (by supporting &lt;em&gt;fewer&lt;/em&gt; access modes). This means
104  * that restricting the set of access modes supported by a segment before sharing it with other clients
105  * is generally a good practice if the creator of the segment wants to retain some control over how the segment
106  * is going to be accessed.
107  *
108  * &lt;h2&gt;Memory segment views&lt;/h2&gt;
109  *
110  * Memory segments support &lt;em&gt;views&lt;/em&gt;. For instance, it is possible to alter the set of supported access modes,
111  * by creating an &lt;em&gt;immutable&lt;/em&gt; view of a memory segment, as follows:
112  * &lt;blockquote&gt;&lt;pre&gt;{@code
113 MemorySegment segment = ...
114 MemorySegment roSegment = segment.withAccessModes(segment.accessModes() &amp; ~WRITE);
115  * }&lt;/pre&gt;&lt;/blockquote&gt;
116  * It is also possible to create views whose spatial bounds are stricter than the ones of the original segment
117  * (see {@link MemorySegment#asSlice(long, long)}).
118  * &lt;p&gt;
119  * Temporal bounds of the original segment are inherited by the view; that is, closing a segment view, such as a sliced
120  * view, will cause the original segment to be closed; as such special care must be taken when sharing views
121  * between multiple clients. If a client want to protect itself against early closure of a segment by
122  * another actor, it is the responsibility of that client to take protective measures, such as removing {@link #CLOSE}
123  * from the set of supported access modes, before sharing the view with another client.
124  * &lt;p&gt;
125  * To allow for interoperability with existing code, a byte buffer view can be obtained from a memory segment
<a name="8" id="anc8"></a><span class="line-modified">126  * (see {@link MemorySegments#asByteBuffer(MemorySegment)}). This can be useful, for instance, for those clients that want to keep using the</span>
127  * {@link ByteBuffer} API, but need to operate on large memory segments. Byte buffers obtained in such a way support
128  * the same spatial and temporal access restrictions associated to the memory segment from which they originated.
129  *
130  * &lt;h2&gt;&lt;a id = &quot;thread-confinement&quot;&gt;Thread confinement&lt;/a&gt;&lt;/h2&gt;
131  *
132  * Memory segments support strong thread-confinement guarantees. Upon creation, they are assigned an &lt;em&gt;owner thread&lt;/em&gt;,
133  * typically the thread which initiated the creation operation. After creation, only the owner thread will be allowed
134  * to directly manipulate the memory segment (e.g. close the memory segment) or access the underlying memory associated with
135  * the segment using a memory access var handle. Any attempt to perform such operations from a thread other than the
136  * owner thread will result in a runtime failure.
137  * &lt;p&gt;
138  * Memory segments support &lt;em&gt;serial thread confinement&lt;/em&gt;; that is, ownership of a memory segment can change (see
139  * {@link #withOwnerThread(Thread)}). This allows, for instance, for two threads {@code A} and {@code B} to share
140  * a segment in a controlled, cooperative and race-free fashion.
141  * &lt;p&gt;
142  * In some cases, it might be useful for multiple threads to process the contents of the same memory segment concurrently
143  * (e.g. in the case of parallel processing); while memory segments provide strong confinement guarantees, it is possible
144  * to obtain a {@link Spliterator} from a segment, which can be used to slice the segment and allow multiple thread to
145  * work in parallel on disjoint segment slices (this assumes that the access mode {@link #ACQUIRE} is set).
146  * For instance, the following code can be used to sum all int values in a memory segment in parallel:
147  * &lt;blockquote&gt;&lt;pre&gt;{@code
148 MemorySegment segment = ...
149 SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
150 VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);
151 int sum = StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)
152                        .mapToInt(s -&gt; (int)VH_int.get(s.baseAddress()))
153                        .sum();
154  * }&lt;/pre&gt;&lt;/blockquote&gt;
155  *
156  * @apiNote In the future, if the Java language permits, {@link MemorySegment}
157  * may become a {@code sealed} interface, which would prohibit subclassing except by
158  * {@link MappedMemorySegment} and other explicitly permitted subtypes.
159  *
160  * @implSpec
161  * Implementations of this interface are immutable, thread-safe and &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;.
162  */
163 public interface MemorySegment extends AutoCloseable {
164 
165     /**
166      * The base memory address associated with this memory segment. The returned address is
167      * a &lt;em&gt;checked&lt;/em&gt; memory address and can therefore be used in derefrence operations
168      * (see {@link MemoryAddress}).
169      * @return The base memory address.
170      */
171     MemoryAddress baseAddress();
172 
<a name="9" id="anc9"></a>



























173     /**
174      * The thread owning this segment.
175      * @return the thread owning this segment.
176      */
177     Thread ownerThread();
178 
179     /**
180      * Obtains a new memory segment backed by the same underlying memory region as this segment,
181      * but with different owner thread. As a side-effect, this segment will be marked as &lt;em&gt;not alive&lt;/em&gt;,
182      * and subsequent operations on this segment will result in runtime errors.
183      * &lt;p&gt;
184      * Write accesses to the segment&#39;s content &lt;a href=&quot;../../../java/util/concurrent/package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happens-before&lt;/i&gt;&lt;/a&gt;
185      * hand-over from the current owner thread to the new owner thread, which in turn &lt;i&gt;happens before&lt;/i&gt; read accesses to the segment&#39;s contents on
186      * the new owner thread.
187      *
188      * @param newOwner the new owner thread.
189      * @return a new memory segment backed by the same underlying memory region as this segment,
190      *      owned by {@code newOwner}.
191      * @throws IllegalStateException if this segment is not &lt;em&gt;alive&lt;/em&gt;, or if access occurs from a thread other than the
192      * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different
<a name="10" id="anc10"></a><span class="line-modified">193      * thread (see {@link MemorySegments#spliterator(MemorySegment, SequenceLayout)}).</span>
194      * @throws NullPointerException if {@code newOwner == null}
195      * @throws IllegalArgumentException if the segment is already a confined segment owner by {@code newOnwer}.
196      * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.
197      */
198     MemorySegment withOwnerThread(Thread newOwner);
199 
200     /**
201      * The size (in bytes) of this memory segment.
202      * @return The size (in bytes) of this memory segment.
203      */
204     long byteSize();
205 
206     /**
207      * Obtains a segment view with specific &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;. Supported access modes are {@link #READ}, {@link #WRITE},
208      * {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}. It is generally not possible to go from a segment with stricter access modes
209      * to one with less strict access modes. For instance, attempting to add {@link #WRITE} access mode to a read-only segment
210      * will be met with an exception.
211      * @param accessModes an ORed mask of zero or more access modes.
212      * @return a segment view with specific access modes.
213      * @throws IllegalArgumentException when {@code mask} is an access mask which is less strict than the one supported by this
214      * segment, or when {@code mask} contains bits not associated with any of the supported access modes.
215      */
216     MemorySegment withAccessModes(int accessModes);
217 
218     /**
219      * Does this segment support a given set of access modes?
220      * @param accessModes an ORed mask of zero or more access modes.
221      * @return true, if the access modes in {@code accessModes} are stricter than the ones supported by this segment.
222      * @throws IllegalArgumentException when {@code mask} contains bits not associated with any of the supported access modes.
223      */
224     boolean hasAccessModes(int accessModes);
225 
226     /**
227      * Returns the &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; associated with this segment; the result is represented as ORed values from
228      * {@link #READ}, {@link #WRITE}, {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}.
229      * @return the access modes associated with this segment.
230      */
231     int accessModes();
232 
233     /**
234      * Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset,
235      * and whose new size is specified by the given argument.
236      * @param offset The new segment base offset (relative to the current segment base address), specified in bytes.
237      * @param newSize The new segment size, specified in bytes.
238      * @return a new memory segment view with updated base/limit addresses.
239      * @throws IndexOutOfBoundsException if {@code offset &lt; 0}, {@code offset &gt; byteSize()}, {@code newSize &lt; 0}, or {@code newSize &gt; byteSize() - offset}
240      */
241     MemorySegment asSlice(long offset, long newSize);
242 
243     /**
244      * Is this segment alive?
245      * @return true, if the segment is alive.
246      * @see MemorySegment#close()
247      */
248     boolean isAlive();
249 
250     /**
251      * Closes this memory segment. Once a memory segment has been closed, any attempt to use the memory segment,
252      * or to access any {@link MemoryAddress} instance associated with it will fail with {@link IllegalStateException}.
253      * Depending on the kind of memory segment being closed, calling this method further triggers deallocation of all the resources
254      * associated with the memory segment.
255      * @throws IllegalStateException if this segment is not &lt;em&gt;alive&lt;/em&gt;, or if access occurs from a thread other than the
256      * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different
<a name="11" id="anc11"></a><span class="line-modified">257      * thread (see {@link MemorySegments#spliterator(MemorySegment, SequenceLayout)}).</span>
258      * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.
259      */
260     void close();
261 
<a name="12" id="anc12"></a>































































































































































































































































































































































262     // access mode masks
263 
264     /**
265      * Read access mode; read operations are supported by a segment which supports this access mode.
266      * @see MemorySegment#accessModes()
267      * @see MemorySegment#withAccessModes(int)
268      */
269     int READ = 1;
270 
271     /**
272      * Write access mode; write operations are supported by a segment which supports this access mode.
273      * @see MemorySegment#accessModes()
274      * @see MemorySegment#withAccessModes(int)
275      */
276     int WRITE = READ &lt;&lt; 1;
277 
278     /**
279      * Close access mode; calling {@link #close()} is supported by a segment which supports this access mode.
280      * @see MemorySegment#accessModes()
281      * @see MemorySegment#withAccessModes(int)
282      */
283     int CLOSE = WRITE &lt;&lt; 1;
284 
285     /**
286      * Acquire access mode; this segment support sharing with threads other than the owner thread, via spliterator
<a name="13" id="anc13"></a><span class="line-modified">287      * (see {@link MemorySegments#spliterator(MemorySegment, SequenceLayout)}).</span>
288      * @see MemorySegment#accessModes()
289      * @see MemorySegment#withAccessModes(int)
290      */
291     int ACQUIRE = CLOSE &lt;&lt; 1;
292 
293     /**
294      * Handoff access mode; this segment support serial thread-confinement via thread ownership changes
295      * (see {@link #withOwnerThread(Thread)}).
296      * @see MemorySegment#accessModes()
297      * @see MemorySegment#withAccessModes(int)
298      */
299     int HANDOFF = ACQUIRE &lt;&lt; 1;
300 
301     /**
302      * Default access mode; this is a union of all the access modes supported by memory segments.
303      * @see MemorySegment#accessModes()
304      * @see MemorySegment#withAccessModes(int)
305      */
306     int ALL_ACCESS = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;
307 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
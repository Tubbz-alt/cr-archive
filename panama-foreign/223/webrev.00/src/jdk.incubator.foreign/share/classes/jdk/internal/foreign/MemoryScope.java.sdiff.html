<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MappedMemorySegmentImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="NativeMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38  * This class manages the temporal bounds associated with a memory segment as well
 39  * as thread confinement.
 40  * A scope has a liveness bit, which is updated when the scope is closed
 41  * (this operation is triggered by {@link AbstractMemorySegmentImpl#close()}).
 42  * A scope may also have an associated &quot;owner&quot; thread that confines some operations to
 43  * associated owner thread such as {@link #close()} or {@link #dup(Thread)}.
 44  * Furthermore, a scope is either root scope ({@link #create(Object, Runnable) created}
 45  * when memory segment is allocated) or child scope ({@link #acquire() acquired} from root scope).
 46  * When a child scope is acquired from another child scope, it is actually acquired from
 47  * the root scope. There is only a single level of children. All child scopes are peers.
 48  * A child scope can be {@link #close() closed} at any time, but root scope can only
 49  * be closed after all its children have been closed, at which time any associated
 50  * cleanup action is executed (the associated memory segment is freed).
 51  * Besides thread-confined checked scopes, {@linkplain #createUnchecked(Thread, Object, Runnable)}
 52  * method may be used passing {@code null} as the &quot;owner&quot; thread to create a
 53  * scope that doesn&#39;t check for thread-confinement while its temporal bounds are
 54  * enforced reliably only under condition that thread that closes the scope is also
 55  * the single thread performing the checked access or there is an external synchronization
 56  * in place that prevents concurrent access and closing of the scope.
 57  */
<span class="line-modified"> 58 abstract class MemoryScope {</span>
 59 
 60     /**
 61      * Creates a root MemoryScope with given ref, cleanupAction and current
 62      * thread as the &quot;owner&quot; thread.
 63      * This method may be called in any thread.
 64      * The returned instance may be published unsafely to and used in any thread,
 65      * but methods that explicitly state that they may only be called in &quot;owner&quot; thread,
 66      * must strictly be called in the thread that created the scope
 67      * or else IllegalStateException is thrown.
 68      *
 69      * @param ref           an optional reference to an instance that needs to be kept reachable
 70      * @param cleanupAction an optional cleanup action to be executed when returned scope is closed
 71      * @return a root MemoryScope
 72      */
<span class="line-modified"> 73     static MemoryScope create(Object ref, Runnable cleanupAction) {</span>
 74         return new Root(Thread.currentThread(), ref, cleanupAction);
 75     }
 76 
 77     /**
 78      * Creates a root MemoryScope with given ref, cleanupAction and &quot;owner&quot; thread.
 79      * This method may be called in any thread.
 80      * The returned instance may be published unsafely to and used in any thread,
 81      * but methods that explicitly state that they may only be called in &quot;owner&quot; thread,
 82      * must strictly be called in given owner thread or else IllegalStateException is thrown.
 83      * If given owner thread is null, the returned MemoryScope is unchecked, meaning
 84      * that all methods may be called in any thread and that {@link #checkValidState()}
 85      * does not check for temporal bounds.
 86      *
 87      * @param owner         the desired owner thread. If {@code owner == null},
 88      *                      the returned scope is &lt;em&gt;not&lt;/em&gt; thread-confined and not checked.
 89      * @param ref           an optional reference to an instance that needs to be kept reachable
 90      * @param cleanupAction an optional cleanup action to be executed when returned scope is closed
 91      * @return a root MemoryScope
 92      */
 93     static MemoryScope createUnchecked(Thread owner, Object ref, Runnable cleanupAction) {
</pre>
</td>
<td>
<hr />
<pre>
 38  * This class manages the temporal bounds associated with a memory segment as well
 39  * as thread confinement.
 40  * A scope has a liveness bit, which is updated when the scope is closed
 41  * (this operation is triggered by {@link AbstractMemorySegmentImpl#close()}).
 42  * A scope may also have an associated &quot;owner&quot; thread that confines some operations to
 43  * associated owner thread such as {@link #close()} or {@link #dup(Thread)}.
 44  * Furthermore, a scope is either root scope ({@link #create(Object, Runnable) created}
 45  * when memory segment is allocated) or child scope ({@link #acquire() acquired} from root scope).
 46  * When a child scope is acquired from another child scope, it is actually acquired from
 47  * the root scope. There is only a single level of children. All child scopes are peers.
 48  * A child scope can be {@link #close() closed} at any time, but root scope can only
 49  * be closed after all its children have been closed, at which time any associated
 50  * cleanup action is executed (the associated memory segment is freed).
 51  * Besides thread-confined checked scopes, {@linkplain #createUnchecked(Thread, Object, Runnable)}
 52  * method may be used passing {@code null} as the &quot;owner&quot; thread to create a
 53  * scope that doesn&#39;t check for thread-confinement while its temporal bounds are
 54  * enforced reliably only under condition that thread that closes the scope is also
 55  * the single thread performing the checked access or there is an external synchronization
 56  * in place that prevents concurrent access and closing of the scope.
 57  */
<span class="line-modified"> 58 public abstract class MemoryScope {</span>
 59 
 60     /**
 61      * Creates a root MemoryScope with given ref, cleanupAction and current
 62      * thread as the &quot;owner&quot; thread.
 63      * This method may be called in any thread.
 64      * The returned instance may be published unsafely to and used in any thread,
 65      * but methods that explicitly state that they may only be called in &quot;owner&quot; thread,
 66      * must strictly be called in the thread that created the scope
 67      * or else IllegalStateException is thrown.
 68      *
 69      * @param ref           an optional reference to an instance that needs to be kept reachable
 70      * @param cleanupAction an optional cleanup action to be executed when returned scope is closed
 71      * @return a root MemoryScope
 72      */
<span class="line-modified"> 73     public static MemoryScope create(Object ref, Runnable cleanupAction) {</span>
 74         return new Root(Thread.currentThread(), ref, cleanupAction);
 75     }
 76 
 77     /**
 78      * Creates a root MemoryScope with given ref, cleanupAction and &quot;owner&quot; thread.
 79      * This method may be called in any thread.
 80      * The returned instance may be published unsafely to and used in any thread,
 81      * but methods that explicitly state that they may only be called in &quot;owner&quot; thread,
 82      * must strictly be called in given owner thread or else IllegalStateException is thrown.
 83      * If given owner thread is null, the returned MemoryScope is unchecked, meaning
 84      * that all methods may be called in any thread and that {@link #checkValidState()}
 85      * does not check for temporal bounds.
 86      *
 87      * @param owner         the desired owner thread. If {@code owner == null},
 88      *                      the returned scope is &lt;em&gt;not&lt;/em&gt; thread-confined and not checked.
 89      * @param ref           an optional reference to an instance that needs to be kept reachable
 90      * @param cleanupAction an optional cleanup action to be executed when returned scope is closed
 91      * @return a root MemoryScope
 92      */
 93     static MemoryScope createUnchecked(Thread owner, Object ref, Runnable cleanupAction) {
</pre>
</td>
</tr>
</table>
<center><a href="MappedMemorySegmentImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="NativeMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
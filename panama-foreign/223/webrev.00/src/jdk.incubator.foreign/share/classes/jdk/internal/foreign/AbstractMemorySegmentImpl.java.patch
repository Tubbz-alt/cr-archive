diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -45,10 +45,12 @@
 import java.util.List;
 import java.util.Objects;
 import java.util.Random;
 import java.util.Spliterator;
 import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.IntFunction;
 
 /**
  * This abstract class provides an immutable implementation for the {@code MemorySegment} interface. This class contains information
  * about the segment's spatial and temporal bounds; each memory segment implementation is associated with an owner thread which is set at creation time.
  * Access to certain sensitive operations on the memory segment will fail with {@code IllegalStateException} if the
@@ -79,17 +81,17 @@
         this.length = length;
         this.mask = mask;
         this.scope = scope;
     }
 
-    abstract long min();
+    public abstract long min();
 
-    abstract Object base();
+    public abstract Object base();
 
     abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope);
 
-    abstract ByteBuffer makeByteBuffer();
+    public abstract ByteBuffer makeByteBuffer();
 
     static int defaultAccessModes(long size) {
         return (enableSmallSegments && size < Integer.MAX_VALUE) ?
                 ALL_ACCESS | SMALL :
                 ALL_ACCESS;
@@ -113,88 +115,16 @@
         }
         return (Spliterator<S>)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() & ~CLOSE));
     }
 
-    @Override
-    public final MemorySegment fill(byte value){
-        checkRange(0, length, true);
-        UNSAFE.setMemory(base(), min(), length, value);
-        return this;
-    }
-
-    public void copyFrom(MemorySegment src) {
-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;
-        long size = that.byteSize();
-        checkRange(0, size, true);
-        that.checkRange(0, size, false);
-        UNSAFE.copyMemory(
-                that.base(), that.min(),
-                base(), min(), size);
-    }
-
-    private final static VarHandle BYTE_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
-            .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
-
-    @Override
-    public long mismatch(MemorySegment other) {
-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;
-        final long thisSize = this.byteSize();
-        final long thatSize = that.byteSize();
-        final long length = Math.min(thisSize, thatSize);
-        this.checkRange(0, length, false);
-        that.checkRange(0, length, false);
-        if (this == other) {
-            return -1;
-        }
-
-        long i = 0;
-        if (length > 7) {
-            if ((byte) BYTE_HANDLE.get(this.baseAddress(), 0) != (byte) BYTE_HANDLE.get(that.baseAddress(), 0)) {
-                return 0;
-            }
-            i = ArraysSupport.vectorizedMismatchLargeForBytes(
-                    this.base(), this.min(),
-                    that.base(), that.min(),
-                    length);
-            if (i >= 0) {
-                return i;
-            }
-            long remaining = ~i;
-            assert remaining < 8 : "remaining greater than 7: " + remaining;
-            i = length - remaining;
-        }
-        MemoryAddress thisAddress = this.baseAddress();
-        MemoryAddress thatAddress = that.baseAddress();
-        for (; i < length; i++) {
-            if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {
-                return i;
-            }
-        }
-        return thisSize != thatSize ? length : -1;
-    }
-
     @Override
     @ForceInline
     public final MemoryAddress baseAddress() {
         return new MemoryAddressImpl(this, 0);
     }
 
-    @Override
-    public final ByteBuffer asByteBuffer() {
-        if (!isSet(READ)) {
-            throw unsupportedAccessMode(READ);
-        }
-        checkIntSize("ByteBuffer");
-        ByteBuffer _bb = makeByteBuffer();
-        if (!isSet(WRITE)) {
-            //scope is IMMUTABLE - obtain a RO byte buffer
-            _bb = _bb.asReadOnlyBuffer();
-        }
-        return _bb;
-    }
-
     @Override
     public final int accessModes() {
         return mask & ALL_ACCESS;
     }
 
@@ -226,11 +156,11 @@
     public boolean hasAccessModes(int accessModes) {
         checkAccessModes(accessModes);
         return (accessModes() & accessModes) == accessModes;
     }
 
-    private void checkAccessModes(int accessModes) {
+    public void checkAccessModes(int accessModes) {
         if ((accessModes & ~ALL_ACCESS) != 0) {
             throw new IllegalArgumentException("Invalid access modes");
         }
     }
 
@@ -269,24 +199,15 @@
             throw unsupportedAccessMode(ACQUIRE);
         }
         return dup(0, length, mask, scope.acquire());
     }
 
-    @Override
-    public final byte[] toByteArray() {
-        checkIntSize("byte[]");
-        byte[] arr = new byte[(int)length];
-        MemorySegment arrSegment = MemorySegment.ofArray(arr);
-        arrSegment.copyFrom(this);
-        return arr;
-    }
-
     boolean isSmall() {
         return isSet(SMALL);
     }
 
-    void checkRange(long offset, long length, boolean writeAccess) {
+    public void checkRange(long offset, long length, boolean writeAccess) {
         scope.checkValidState();
         if (writeAccess && !isSet(WRITE)) {
             throw unsupportedAccessMode(WRITE);
         } else if (!writeAccess && !isSet(READ)) {
             throw unsupportedAccessMode(READ);
@@ -303,16 +224,10 @@
 
     private boolean isSet(int mask) {
         return (this.mask & mask) != 0;
     }
 
-    private void checkIntSize(String typeName) {
-        if (length > (Integer.MAX_VALUE - 8)) { //conservative check
-            throw new UnsupportedOperationException(String.format("Segment is too large to wrap as %s. Size: %d", typeName, length));
-        }
-    }
-
     private void checkBounds(long offset, long length) {
         if (isSmall()) {
             checkBoundsSmall((int)offset, (int)length);
         } else {
             if (length < 0 ||
@@ -491,21 +406,21 @@
 
     public static final AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(
         0, 0, MemoryScope.createUnchecked(null, null, null)
     ) {
         @Override
-        ByteBuffer makeByteBuffer() {
+        public ByteBuffer makeByteBuffer() {
             throw new UnsupportedOperationException();
         }
 
         @Override
-        long min() {
+        public long min() {
             return 0;
         }
 
         @Override
-        Object base() {
+        public Object base() {
             return null;
         }
 
         @Override
         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {

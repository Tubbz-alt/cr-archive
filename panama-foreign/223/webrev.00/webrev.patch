diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MappedMemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MappedMemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MappedMemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MappedMemorySegment.java
@@ -29,11 +29,11 @@
 import java.nio.file.Path;
 
 /**
  * A mapped memory segment, that is, a memory segment backed by memory-mapped file.
  *
- * <p> Mapped memory segments are created via the {@link MemorySegment#mapFromPath(Path, long, long, FileChannel.MapMode)}.
+ * <p> Mapped memory segments are created via the {@link MemorySegments#mapFromPath(Path, long, long, FileChannel.MapMode)}.
  * Mapped memory segments behave like ordinary segments, but provide additional capabilities to manipulate memory-mapped
  * memory regions, such as {@link #force()} and {@link #load()}.
  * <p>
  * All implementations of this interface must be <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>;
  * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
@@ -24,10 +24,11 @@
  *
  */
 
 package jdk.incubator.foreign;
 
+import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
 
 /**
  * This class defines useful layout constants. Some of the constants defined in this class are explicit in both
  * size and byte order (see {@link #BITS_64_BE}), and can therefore be used to explicitly and unambiguously specify the
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -26,22 +26,13 @@
 
 package jdk.incubator.foreign;
 
 import java.nio.ByteBuffer;
 
-import jdk.internal.foreign.AbstractMemorySegmentImpl;
-import jdk.internal.foreign.HeapMemorySegmentImpl;
-import jdk.internal.foreign.MappedMemorySegmentImpl;
-import jdk.internal.foreign.NativeMemorySegmentImpl;
-import jdk.internal.foreign.Utils;
-
-import java.io.IOException;
 import java.nio.channels.FileChannel;
 import java.nio.file.Path;
-import java.util.Objects;
 import java.util.Spliterator;
-import java.util.function.Consumer;
 
 /**
  * A memory segment models a contiguous region of memory. A memory segment is associated with both spatial
  * and temporal bounds. Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location
  * which falls <em>outside</em> the boundaries of the memory segment being accessed. Temporal bounds ensure that memory access
@@ -55,28 +46,28 @@
  * Non-platform classes should not implement {@linkplain MemorySegment} directly.
  *
  * <h2>Constructing memory segments from different sources</h2>
  *
  * There are multiple ways to obtain a memory segment. First, memory segments backed by off-heap memory can
- * be allocated using one of the many factory methods provided (see {@link MemorySegment#allocateNative(MemoryLayout)},
- * {@link MemorySegment#allocateNative(long)} and {@link MemorySegment#allocateNative(long, long)}). Memory segments obtained
+ * be allocated using one of the many factory methods provided (see {@link MemorySegments#allocateNative(MemoryLayout)},
+ * {@link MemorySegments#allocateNative(long)} and {@link MemorySegments#allocateNative(long, long)}). Memory segments obtained
  * in this way are called <em>native memory segments</em>.
  * <p>
  * It is also possible to obtain a memory segment backed by an existing heap-allocated Java array,
- * using one of the provided factory methods (e.g. {@link MemorySegment#ofArray(int[])}). Memory segments obtained
+ * using one of the provided factory methods (e.g. {@link MemorySegments#ofArray(int[])}). Memory segments obtained
  * in this way are called <em>array memory segments</em>.
  * <p>
  * It is possible to obtain a memory segment backed by an existing Java byte buffer (see {@link ByteBuffer}),
- * using the factory method {@link MemorySegment#ofByteBuffer(ByteBuffer)}.
+ * using the factory method {@link MemorySegments#ofByteBuffer(ByteBuffer)}.
  * Memory segments obtained in this way are called <em>buffer memory segments</em>. Note that buffer memory segments might
  * be backed by native memory (as in the case of native memory segments) or heap memory (as in the case of array memory segments),
  * depending on the characteristics of the byte buffer instance the segment is associated with. For instance, a buffer memory
  * segment obtained from a byte buffer created with the {@link ByteBuffer#allocateDirect(int)} method will be backed
  * by native memory.
  * <p>
  * Finally, it is also possible to obtain a memory segment backed by a memory-mapped file using the factory method
- * {@link MemorySegment#mapFromPath(Path, long, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments</em>
+ * {@link MemorySegments#mapFromPath(Path, long, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments</em>
  * (see {@link MappedMemorySegment}).
  * <p>
  * Array and buffer segments are effectively <em>views</em> over existing memory regions which might outlive the
  * lifecycle of the segments derived from them, and can even be manipulated directly (e.g. via array access, or direct use
  * of the {@link ByteBuffer} API) by other clients. As a result, while sharing array or buffer segments is possible,
@@ -130,11 +121,11 @@
  * between multiple clients. If a client want to protect itself against early closure of a segment by
  * another actor, it is the responsibility of that client to take protective measures, such as removing {@link #CLOSE}
  * from the set of supported access modes, before sharing the view with another client.
  * <p>
  * To allow for interoperability with existing code, a byte buffer view can be obtained from a memory segment
- * (see {@link #asByteBuffer()}). This can be useful, for instance, for those clients that want to keep using the
+ * (see {@link MemorySegments#asByteBuffer(MemorySegment)}). This can be useful, for instance, for those clients that want to keep using the
  * {@link ByteBuffer} API, but need to operate on large memory segments. Byte buffers obtained in such a way support
  * the same spatial and temporal access restrictions associated to the memory segment from which they originated.
  *
  * <h2><a id = "thread-confinement">Thread confinement</a></h2>
  *
@@ -177,38 +168,10 @@
      * (see {@link MemoryAddress}).
      * @return The base memory address.
      */
     MemoryAddress baseAddress();
 
-    /**
-     * Returns a spliterator for the given memory segment. The returned spliterator reports {@link Spliterator#SIZED},
-     * {@link Spliterator#SUBSIZED}, {@link Spliterator#IMMUTABLE}, {@link Spliterator#NONNULL} and {@link Spliterator#ORDERED}
-     * characteristics.
-     * <p>
-     * The returned spliterator splits the segment according to the specified sequence layout; that is,
-     * if the supplied layout is a sequence layout whose element count is {@code N}, then calling {@link Spliterator#trySplit()}
-     * will result in a spliterator serving approximatively {@code N/2} elements (depending on whether N is even or not).
-     * As such, splitting is possible as long as {@code N >= 2}. The spliterator returns segments that feature the same
-     * <a href="#access-modes">access modes</a> as the given segment less the {@link #CLOSE} access mode.
-     * <p>
-     * The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then
-     * be processed in parallel by multiple threads (if the access mode {@link #ACQUIRE} is set).
-     * While closing the segment (see {@link #close()}) during pending concurrent execution will generally
-     * fail with an exception, it is possible to close a segment when a spliterator has been obtained but no thread
-     * is actively working on it using {@link Spliterator#tryAdvance(Consumer)}; in such cases, any subsequent call
-     * to {@link Spliterator#tryAdvance(Consumer)} will fail with an exception.
-     * @param segment the segment to be used for splitting.
-     * @param layout the layout to be used for splitting.
-     * @param <S> the memory segment type
-     * @return the element spliterator for this segment
-     * @throws IllegalStateException if the segment is not <em>alive</em>, or if access occurs from a thread other than the
-     * thread owning this segment
-     */
-    static <S extends MemorySegment> Spliterator<S> spliterator(S segment, SequenceLayout layout) {
-        return AbstractMemorySegmentImpl.spliterator(segment, layout);
-    }
-
     /**
      * The thread owning this segment.
      * @return the thread owning this segment.
      */
     Thread ownerThread();
@@ -225,11 +188,11 @@
      * @param newOwner the new owner thread.
      * @return a new memory segment backed by the same underlying memory region as this segment,
      *      owned by {@code newOwner}.
      * @throws IllegalStateException if this segment is not <em>alive</em>, or if access occurs from a thread other than the
      * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different
-     * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).
+     * thread (see {@link MemorySegments#spliterator(MemorySegment, SequenceLayout)}).
      * @throws NullPointerException if {@code newOwner == null}
      * @throws IllegalArgumentException if the segment is already a confined segment owner by {@code newOnwer}.
      * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.
      */
     MemorySegment withOwnerThread(Thread newOwner);
@@ -289,367 +252,15 @@
      * or to access any {@link MemoryAddress} instance associated with it will fail with {@link IllegalStateException}.
      * Depending on the kind of memory segment being closed, calling this method further triggers deallocation of all the resources
      * associated with the memory segment.
      * @throws IllegalStateException if this segment is not <em>alive</em>, or if access occurs from a thread other than the
      * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different
-     * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).
+     * thread (see {@link MemorySegments#spliterator(MemorySegment, SequenceLayout)}).
      * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.
      */
     void close();
 
-    /**
-     * Fills a value into this memory segment.
-     * <p>
-     * More specifically, the given value is filled into each address of this
-     * segment. Equivalent to (but likely more efficient than) the following code:
-     *
-     * <pre>{@code
-byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
-         .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
-for (long l = 0; l < segment.byteSize(); l++) {
-     byteHandle.set(segment.baseAddress(), l, value);
-}
-     * }</pre>
-     *
-     * without any regard or guarantees on the ordering of particular memory
-     * elements being set.
-     * <p>
-     * Fill can be useful to initialize or reset the memory of a segment.
-     *
-     * @param value the value to fill into this segment
-     * @return this memory segment
-     * @throws IllegalStateException if this segment is not <em>alive</em>, or if access occurs from a thread other than the
-     * thread owning this segment
-     * @throws UnsupportedOperationException if this segment does not support the {@link #WRITE} access mode
-     */
-    MemorySegment fill(byte value);
-
-    /**
-     * Performs a bulk copy from given source segment to this segment. More specifically, the bytes at
-     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment are copied into this segment
-     * at offset {@code 0} through {@code src.byteSize() - 1}.
-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at
-     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment were first copied into a
-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into
-     * this segment at offset {@code 0} through {@code src.byteSize() - 1}.
-     * <p>
-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment
-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.
-     * For example, this may occur if the same file is {@link MemorySegment#mapFromPath mapped} to two segments.
-     *
-     * @param src the source segment.
-     * @throws IndexOutOfBoundsException if {@code src.byteSize() > this.byteSize()}.
-     * @throws IllegalStateException if either the source segment or this segment have been already closed,
-     * or if access occurs from a thread other than the thread owning either segment.
-     * @throws UnsupportedOperationException if either the source segment or this segment do not feature required access modes;
-     * more specifically, {@code src} should feature at least the {@link MemorySegment#READ} access mode,
-     * while this segment should feature at least the {@link MemorySegment#WRITE} access mode.
-     */
-    void copyFrom(MemorySegment src);
-
-    /**
-     * Finds and returns the offset, in bytes, of the first mismatch between
-     * this segment and a given other segment. The offset is relative to the
-     * {@link #baseAddress() base address} of each segment and will be in the
-     * range of 0 (inclusive) up to the {@link #byteSize() size} (in bytes) of
-     * the smaller memory segment (exclusive).
-     * <p>
-     * If the two segments share a common prefix then the returned offset is
-     * the length of the common prefix and it follows that there is a mismatch
-     * between the two segments at that offset within the respective segments.
-     * If one segment is a proper prefix of the other then the returned offset is
-     * the smaller of the segment sizes, and it follows that the offset is only
-     * valid for the larger segment. Otherwise, there is no mismatch and {@code
-     * -1} is returned.
-     *
-     * @param other the segment to be tested for a mismatch with this segment
-     * @return the relative offset, in bytes, of the first mismatch between this
-     * and the given other segment, otherwise -1 if no mismatch
-     * @throws IllegalStateException if either this segment of the other segment
-     * have been already closed, or if access occurs from a thread other than the
-     * thread owning either segment
-     * @throws UnsupportedOperationException if either this segment or the other
-     * segment does not feature at least the {@link MemorySegment#READ} access mode
-     */
-    long mismatch(MemorySegment other);
-
-    /**
-     * Wraps this segment in a {@link ByteBuffer}. Some of the properties of the returned buffer are linked to
-     * the properties of this segment. For instance, if this segment is <em>immutable</em>
-     * (e.g. the segment has access mode {@link #READ} but not {@link #WRITE}), then the resulting buffer is <em>read-only</em>
-     * (see {@link ByteBuffer#isReadOnly()}. Additionally, if this is a native memory segment, the resulting buffer is
-     * <em>direct</em> (see {@link ByteBuffer#isDirect()}).
-     * <p>
-     * The life-cycle of the returned buffer will be tied to that of this segment. That means that if the this segment
-     * is closed (see {@link MemorySegment#close()}, accessing the returned
-     * buffer will throw an {@link IllegalStateException}.
-     * <p>
-     * The resulting buffer's byte order is {@link java.nio.ByteOrder#BIG_ENDIAN}; this can be changed using
-     * {@link ByteBuffer#order(java.nio.ByteOrder)}.
-     *
-     * @return a {@link ByteBuffer} view of this memory segment.
-     * @throws UnsupportedOperationException if this segment cannot be mapped onto a {@link ByteBuffer} instance,
-     * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater
-     * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link #READ} access mode.
-     */
-    ByteBuffer asByteBuffer();
-
-    /**
-     * Copy the contents of this memory segment into a fresh byte array.
-     * @return a fresh byte array copy of this memory segment.
-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this
-     * segment's contents cannot be copied into a {@link byte[]} instance, e.g. its size is greater than {@link Integer#MAX_VALUE},
-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the
-     * thread owning this segment.
-     */
-    byte[] toByteArray();
-
-    /**
-     * Creates a new buffer memory segment that models the memory associated with the given byte
-     * buffer. The segment starts relative to the buffer's position (inclusive)
-     * and ends relative to the buffer's limit (exclusive).
-     * <p>
-     * The segment will feature all <a href="#access-modes">access modes</a> (see {@link #ALL_ACCESS}),
-     * unless the given buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will
-     * not feature the {@link #WRITE} access mode.
-     * <p>
-     * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment.
-     *
-     * @param bb the byte buffer backing the buffer memory segment.
-     * @return a new buffer memory segment.
-     */
-    static MemorySegment ofByteBuffer(ByteBuffer bb) {
-        return AbstractMemorySegmentImpl.ofBuffer(bb);
-    }
-
-    /**
-     * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
-     * <p>
-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
-     * (see {@link #ALL_ACCESS}).
-     *
-     * @param arr the primitive array backing the array memory segment.
-     * @return a new array memory segment.
-     */
-    static MemorySegment ofArray(byte[] arr) {
-        return HeapMemorySegmentImpl.makeArraySegment(arr);
-    }
-
-    /**
-     * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
-     * <p>
-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
-     * (see {@link #ALL_ACCESS}).
-     *
-     * @param arr the primitive array backing the array memory segment.
-     * @return a new array memory segment.
-     */
-    static MemorySegment ofArray(char[] arr) {
-        return HeapMemorySegmentImpl.makeArraySegment(arr);
-    }
-
-    /**
-     * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
-     * <p>
-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
-     * (see {@link #ALL_ACCESS}).
-     *
-     * @param arr the primitive array backing the array memory segment.
-     * @return a new array memory segment.
-     */
-    static MemorySegment ofArray(short[] arr) {
-        return HeapMemorySegmentImpl.makeArraySegment(arr);
-    }
-
-    /**
-     * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.
-     * <p>
-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>.
-     *
-     * @param arr the primitive array backing the array memory segment.
-     * @return a new array memory segment.
-     */
-    static MemorySegment ofArray(int[] arr) {
-        return HeapMemorySegmentImpl.makeArraySegment(arr);
-    }
-
-    /**
-     * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
-     * <p>
-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
-     * (see {@link #ALL_ACCESS}).
-     *
-     * @param arr the primitive array backing the array memory segment.
-     * @return a new array memory segment.
-     */
-    static MemorySegment ofArray(float[] arr) {
-        return HeapMemorySegmentImpl.makeArraySegment(arr);
-    }
-
-    /**
-     * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
-     * <p>
-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
-     * (see {@link #ALL_ACCESS}).
-     *
-     * @param arr the primitive array backing the array memory segment.
-     * @return a new array memory segment.
-     */
-    static MemorySegment ofArray(long[] arr) {
-        return HeapMemorySegmentImpl.makeArraySegment(arr);
-    }
-
-    /**
-     * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
-     * <p>
-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
-     * (see {@link #ALL_ACCESS}).
-     *
-     * @param arr the primitive array backing the array memory segment.
-     * @return a new array memory segment.
-     */
-    static MemorySegment ofArray(double[] arr) {
-        return HeapMemorySegmentImpl.makeArraySegment(arr);
-    }
-
-    /**
-     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.
-     * <p>
-     * This is equivalent to the following code:
-     * <blockquote><pre>{@code
-    allocateNative(layout.bytesSize(), layout.bytesAlignment());
-     * }</pre></blockquote>
-     *
-     * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
-     * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
-     * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
-     *
-     * @param layout the layout of the off-heap memory block backing the native memory segment.
-     * @return a new native memory segment.
-     * @throws IllegalArgumentException if the specified layout has illegal size or alignment constraint.
-     */
-    static MemorySegment allocateNative(MemoryLayout layout) {
-        return allocateNative(layout.byteSize(), layout.byteAlignment());
-    }
-
-    /**
-     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).
-     * <p>
-     * This is equivalent to the following code:
-     * <blockquote><pre>{@code
-allocateNative(bytesSize, 1);
-     * }</pre></blockquote>
-     *
-     * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
-     * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
-     * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
-     *
-     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
-     * @return a new native memory segment.
-     * @throws IllegalArgumentException if {@code bytesSize < 0}.
-     */
-    static MemorySegment allocateNative(long bytesSize) {
-        return allocateNative(bytesSize, 1);
-    }
-
-    /**
-     * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
-     * <p>
-     * The segment will feature all <a href="#access-modes">access modes</a> (see {@link #ALL_ACCESS}),
-     * unless the given mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, in which case
-     * the segment will not feature the {@link #WRITE} access mode.
-     *
-     * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
-     * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
-     *
-     * @param path the path to the file to memory map.
-     * @param bytesOffset the offset (expressed in bytes) within the file at which the mapped segment is to start.
-     * @param bytesSize the size (in bytes) of the mapped memory backing the memory segment.
-     * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode
-     *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegment#force()}).
-     * @return a new mapped memory segment.
-     * @throws IllegalArgumentException if {@code bytesOffset < 0}.
-     * @throws IllegalArgumentException if {@code bytesSize < 0}.
-     * @throws UnsupportedOperationException if an unsupported map mode is specified.
-     * @throws IOException if the specified path does not point to an existing file, or if some other I/O error occurs.
-     */
-    static MappedMemorySegment mapFromPath(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
-        return MappedMemorySegmentImpl.makeMappedSegment(path, bytesOffset, bytesSize, mapMode);
-    }
-
-    /**
-     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
-     * alignment constraint (in bytes). The segment will feature all <a href="#access-modes">access modes</a>
-     * (see {@link #ALL_ACCESS}).
-     *
-     * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
-     * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
-     * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
-     *
-     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
-     * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.
-     * @return a new native memory segment.
-     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes < 0}, or if {@code alignmentBytes}
-     * is not a power of 2.
-     */
-    static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {
-        if (bytesSize <= 0) {
-            throw new IllegalArgumentException("Invalid allocation size : " + bytesSize);
-        }
-
-        if (alignmentBytes < 0 ||
-                ((alignmentBytes & (alignmentBytes - 1)) != 0L)) {
-            throw new IllegalArgumentException("Invalid alignment constraint : " + alignmentBytes);
-        }
-
-        return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
-    }
-
-    /**
-     * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
-     * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
-     * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
-     * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
-     * (often as a plain {@code long} value). The segment will feature all <a href="#access-modes">access modes</a>
-     * (see {@link #ALL_ACCESS}).
-     * <p>
-     * This method is <em>restricted</em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash
-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
-     * restricted methods, and use safe and supported functionalities, where possible.
-     *
-     * @param addr the desired base address
-     * @param bytesSize the desired size.
-     * @param owner the desired owner thread. If {@code owner == null}, the returned segment is <em>not</em> confined.
-     * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
-     *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
-     * @param attachment an object that must be kept alive by the returned segment; this can be useful when
-     *                   the returned segment depends on memory which could be released if a certain object
-     *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
-     * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.
-     * @throws IllegalArgumentException if {@code bytesSize <= 0}.
-     * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.
-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
-     * @throws NullPointerException if {@code addr == null}.
-     */
-    static MemorySegment ofNativeRestricted(MemoryAddress addr, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {
-        Objects.requireNonNull(addr);
-        if (bytesSize <= 0) {
-            throw new IllegalArgumentException("Invalid size : " + bytesSize);
-        }
-        Utils.checkRestrictedAccess("MemorySegment.ofNativeRestricted");
-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, bytesSize, owner, cleanup, attachment);
-    }
-
     // access mode masks
 
     /**
      * Read access mode; read operations are supported by a segment which supports this access mode.
      * @see MemorySegment#accessModes()
@@ -671,11 +282,11 @@
      */
     int CLOSE = WRITE << 1;
 
     /**
      * Acquire access mode; this segment support sharing with threads other than the owner thread, via spliterator
-     * (see {@link #spliterator(MemorySegment, SequenceLayout)}).
+     * (see {@link MemorySegments#spliterator(MemorySegment, SequenceLayout)}).
      * @see MemorySegment#accessModes()
      * @see MemorySegment#withAccessModes(int)
      */
     int ACQUIRE = CLOSE << 1;
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegments.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegments.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegments.java
@@ -0,0 +1,1278 @@
+package jdk.incubator.foreign;
+
+import jdk.internal.foreign.AbstractMemorySegmentImpl;
+import jdk.internal.foreign.HeapMemorySegmentImpl;
+import jdk.internal.foreign.MappedMemorySegmentImpl;
+import jdk.internal.foreign.NativeMemorySegmentImpl;
+import jdk.internal.foreign.Utils;
+import jdk.internal.misc.Unsafe;
+import jdk.internal.util.ArraysSupport;
+
+import java.io.IOException;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.channels.FileChannel;
+import java.nio.file.Path;
+import java.util.Objects;
+import java.util.Spliterator;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.IntFunction;
+
+/**
+ * This class contains various methods for creating memory segments from a variety of sources (byte buffers, arrrays),
+ * for manipulating memory segments (such as filling contents of segments, or obtaining a segment
+ * {@link Spliterator}), for mapping existing memory segments into different views (byte buffers, arrays) and
+ * for accessing the memory segment contents in various ways.
+ */
+public final class MemorySegments {
+    private MemorySegments() {
+        // just the one
+    }
+
+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+
+    /**
+     * Fills a value into the given memory segment.
+     * <p>
+     * More specifically, the given value is filled into each address of the given
+     * segment. Equivalent to (but likely more efficient than) the following code:
+     *
+     * <pre>{@code
+    byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
+    .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
+    for (long l = 0; l < segment.byteSize(); l++) {
+    byteHandle.set(segment.baseAddress(), l, value);
+    }
+     * }</pre>
+     *
+     * without any regard or guarantees on the ordering of particular memory
+     * elements being set.
+     * <p>
+     * Fill can be useful to initialize or reset the memory of a segment.
+     *
+     * @param segment the segment whose bytes are to be filled
+     * @param value the value to fill into this segment
+     * @throws IllegalStateException if the given segment is not <em>alive</em>, or if access occurs from a thread other than the
+     * thread owning the given segment
+     * @throws UnsupportedOperationException if this segment does not support the {@link MemorySegment#WRITE} access mode
+     */
+    public static void fill(MemorySegment segment, byte value) {
+        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;
+        segmentImpl.checkRange(0, segment.byteSize(), true);
+        UNSAFE.setMemory(segmentImpl.base(), segmentImpl.min(), segmentImpl.byteSize(), value);
+    }
+
+    /**
+     * Performs a bulk copy from given source segment to a given target segment. More specifically, the bytes at
+     * offset {@code 0} through {@code from.byteSize() - 1} in the source segment are copied into the target segment
+     * at offset {@code 0} through {@code to.byteSize() - 1}.
+     * If the source segment overlaps with the target segment, then the copying is performed as if the bytes at
+     * offset {@code 0} through {@code from.byteSize() - 1} in the source segment were first copied into a
+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into
+     * the target segment at offset {@code 0} through {@code to.byteSize() - 1}.
+     * <p>
+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the target segment
+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.
+     * For example, this may occur if the same file is {@link MemorySegments#mapFromPath mapped} to two segments.
+     *
+     * @param from the source segment.
+     * @param to the target segment.
+     * @throws IndexOutOfBoundsException if {@code from.byteSize() > to.byteSize()}.
+     * @throws IllegalStateException if either the source segment or this segment have been already closed,
+     * or if access occurs from a thread other than the thread owning either segment.
+     * @throws UnsupportedOperationException if either the source segment or this segment do not feature required access modes;
+     * more specifically, {@code from} should feature at least the {@link MemorySegment#READ} access mode,
+     * while {@code to} should feature at least the {@link MemorySegment#WRITE} access mode.
+     */
+    public static void copy(MemorySegment from, MemorySegment to) {
+        AbstractMemorySegmentImpl fromImpl = (AbstractMemorySegmentImpl)from;
+        AbstractMemorySegmentImpl toImpl = (AbstractMemorySegmentImpl)to;
+        long size = from.byteSize();
+        toImpl.checkRange(0, size, true);
+        fromImpl.checkRange(0, size, false);
+        UNSAFE.copyMemory(
+                fromImpl.base(), fromImpl.min(),
+                toImpl.base(), toImpl.min(), size);
+    }
+
+    /**
+     * Finds and returns the offset, in bytes, of the first mismatch between
+     * two given segments. The offset is relative to the
+     * {@link MemorySegment#baseAddress() base address} of each segment and will be in the
+     * range of 0 (inclusive) up to the {@link MemorySegment#byteSize() size} (in bytes) of
+     * the smaller memory segment (exclusive).
+     * <p>
+     * If the two segments share a common prefix then the returned offset is
+     * the length of the common prefix and it follows that there is a mismatch
+     * between the two segments at that offset within the respective segments.
+     * If one segment is a proper prefix of the other then the returned offset is
+     * the smaller of the segment sizes, and it follows that the offset is only
+     * valid for the larger segment. Otherwise, there is no mismatch and {@code
+     * -1} is returned.
+     *
+     * @param src the first segment to be tested for a mismatch
+     * @param dst the second segment to be tested for a mismatch
+     * @return the relative offset, in bytes, of the first mismatch between this
+     * and the given other segment, otherwise -1 if no mismatch
+     * @throws IllegalStateException if either this segment of the other segment
+     * have been already closed, or if access occurs from a thread other than the
+     * thread owning either segment
+     * @throws UnsupportedOperationException if either this segment or the other
+     * segment does not feature at least the {@link MemorySegment#READ} access mode
+     */
+    public static long mismatch(MemorySegment src, MemorySegment dst) {
+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)src;
+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dst;
+        final long thisSize = src.byteSize();
+        final long thatSize = dst.byteSize();
+        final long length = Math.min(thisSize, thatSize);
+        srcImpl.checkRange(0, length, false);
+        dstImpl.checkRange(0, length, false);
+        if (src == dst) {
+            return -1;
+        }
+
+        long i = 0;
+        if (length > 7) {
+            if (getByte(src.baseAddress(), 0) != getByte(dst.baseAddress(), 0)) {
+                return 0;
+            }
+            i = ArraysSupport.vectorizedMismatchLargeForBytes(
+                    srcImpl.base(), srcImpl.min(),
+                    dstImpl.base(), dstImpl.min(),
+                    length);
+            if (i >= 0) {
+                return i;
+            }
+            long remaining = ~i;
+            assert remaining < 8 : "remaining greater than 7: " + remaining;
+            i = length - remaining;
+        }
+        MemoryAddress thisAddress = src.baseAddress();
+        MemoryAddress thatAddress = dst.baseAddress();
+        for (; i < length; i++) {
+            if (getByte(thisAddress, i) != getByte(thatAddress, i)) {
+                return i;
+            }
+        }
+        return thisSize != thatSize ? length : -1;
+    }
+
+    /**
+     * Returns a spliterator for the given memory segment. The returned spliterator reports {@link Spliterator#SIZED},
+     * {@link Spliterator#SUBSIZED}, {@link Spliterator#IMMUTABLE}, {@link Spliterator#NONNULL} and {@link Spliterator#ORDERED}
+     * characteristics.
+     * <p>
+     * The returned spliterator splits the segment according to the specified sequence layout; that is,
+     * if the supplied layout is a sequence layout whose element count is {@code N}, then calling {@link Spliterator#trySplit()}
+     * will result in a spliterator serving approximatively {@code N/2} elements (depending on whether N is even or not).
+     * As such, splitting is possible as long as {@code N >= 2}. The spliterator returns segments that feature the same
+     * <a href="#access-modes">access modes</a> as the given segment less the {@link MemorySegment#CLOSE} access mode.
+     * <p>
+     * The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then
+     * be processed in parallel by multiple threads (if the access mode {@link MemorySegment#ACQUIRE} is set).
+     * While closing the segment (see {@link MemorySegment#close()}) during pending concurrent execution will generally
+     * fail with an exception, it is possible to close a segment when a spliterator has been obtained but no thread
+     * is actively working on it using {@link Spliterator#tryAdvance(Consumer)}; in such cases, any subsequent call
+     * to {@link Spliterator#tryAdvance(Consumer)} will fail with an exception.
+     * @param segment the segment to be used for splitting.
+     * @param layout the layout to be used for splitting.
+     * @param <S> the memory segment type
+     * @return the element spliterator for this segment
+     * @throws IllegalStateException if the segment is not <em>alive</em>, or if access occurs from a thread other than the
+     * thread owning the given segment
+     */
+    public static <S extends MemorySegment> Spliterator<S> spliterator(S segment, SequenceLayout layout) {
+        return AbstractMemorySegmentImpl.spliterator(segment, layout);
+    }
+
+    /**
+     * Wraps the given segment in a {@link ByteBuffer}. Some of the properties of the returned buffer are linked to
+     * the properties of the given segment. For instance, if the given segment is <em>immutable</em>
+     * (e.g. the segment has access mode {@link MemorySegment#READ} but not {@link MemorySegment#WRITE}), then the resulting buffer is <em>read-only</em>
+     * (see {@link ByteBuffer#isReadOnly()}. Additionally, if the given segment is a native memory segment, the resulting buffer is
+     * <em>direct</em> (see {@link ByteBuffer#isDirect()}).
+     * <p>
+     * The life-cycle of the returned buffer will be tied to that of the given segment. That means that if the given segment
+     * is closed (see {@link MemorySegment#close()}, accessing the returned
+     * buffer will throw an {@link IllegalStateException}.
+     * <p>
+     * The resulting buffer's byte order is {@link java.nio.ByteOrder#BIG_ENDIAN}; this can be changed using
+     * {@link ByteBuffer#order(java.nio.ByteOrder)}.
+     *
+     * @param segment the segment from which a byte buffer view has to be created.
+     * @return a {@link ByteBuffer} view of the given memory segment.
+     * @throws UnsupportedOperationException if the given segment cannot be mapped onto a {@link ByteBuffer} instance,
+     * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater
+     * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link MemorySegment#READ} access mode.
+     */
+    public static ByteBuffer asByteBuffer(MemorySegment segment) {
+        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;
+        segmentImpl.checkAccessModes(MemorySegment.READ);
+        checkArraySize("ByteBuffer", 1, segment.byteSize());
+        ByteBuffer _bb = segmentImpl.makeByteBuffer();
+        if (!segment.hasAccessModes(MemorySegment.WRITE)) {
+            //scope is IMMUTABLE - obtain a RO byte buffer
+            _bb = _bb.asReadOnlyBuffer();
+        }
+        return _bb;
+    }
+
+    private static int checkArraySize(String typeName, int elemSize, long length) {
+        if (length % elemSize != 0) {
+            throw new UnsupportedOperationException(String.format("Segment size is not a multiple of %d. Size: %d", elemSize, length));
+        }
+        long arraySize = length / elemSize;
+        if (arraySize > (Integer.MAX_VALUE - 8)) { //conservative check
+            throw new UnsupportedOperationException(String.format("Segment is too large to wrap as %s. Size: %d", typeName, length));
+        }
+        return (int)arraySize;
+    }
+
+    private static <Z> Z toArray(MemorySegment segment, Class<Z> arrayClass, int elemSize, IntFunction<Z> arrayFactory, Function<Z, MemorySegment> segmentFactory) {
+        int size = checkArraySize(arrayClass.getSimpleName(), elemSize, segment.byteSize());
+        Z arr = arrayFactory.apply(size);
+        MemorySegment arrSegment = segmentFactory.apply(arr);
+        copy(segment, arrSegment);
+        return arr;
+    }
+
+    /**
+     * Copy the contents of the given memory segment into a fresh byte array.
+     * @param segment the segment whose contents are to be copied into a byte array.
+     * @return a fresh byte array copy of the given memory segment.
+     * @throws UnsupportedOperationException if the given segment does not feature the {@link MemorySegment#READ} access mode, or if the given
+     * segment's contents cannot be copied into a {@link byte[]} instance, e.g. its size is greater than {@link Integer#MAX_VALUE},
+     * @throws IllegalStateException if the given segment has been closed, or if access occurs from a thread other than the
+     * thread owning the given segment.
+     */
+    public static byte[] toByteArray(MemorySegment segment) {
+        return toArray(segment, byte[].class, 1, byte[]::new, MemorySegments::ofArray);
+    }
+
+    /**
+     * Copy the contents of the given memory segment into a fresh short array.
+     * @param segment the segment whose contents are to be copied into a short array.
+     * @return a fresh short array copy of the given memory segment.
+     * @throws UnsupportedOperationException if the given segment does not feature the {@link MemorySegment#READ} access mode, or if the given
+     * segment's contents cannot be copied into a {@link short[]} instance, e.g. because {@code byteSize() % 4 != 0},
+     * or {@code byteSize() / 2 > Integer#MAX_VALUE}.
+     * @throws IllegalStateException if the given segment has been closed, or if access occurs from a thread other than the
+     * thread owning the given segment.
+     */
+    public static short[] toShortArray(MemorySegment segment) {
+        return toArray(segment, short[].class, 2, short[]::new, MemorySegments::ofArray);
+    }
+
+    /**
+     * Copy the contents of the given memory segment into a fresh char array.
+     * @param segment the segment whose contents are to be copied into a char array.
+     * @return a fresh char array copy of the given memory segment.
+     * @throws UnsupportedOperationException if the given segment does not feature the {@link MemorySegment#READ} access mode, or if the given
+     * segment's contents cannot be copied into a {@link char[]} instance, e.g. because {@code byteSize() % 2 != 0},
+     * or {@code byteSize() / 2 > Integer#MAX_VALUE}.
+     * @throws IllegalStateException if the given segment has been closed, or if access occurs from a thread other than the
+     * thread owning the given segment.
+     */
+    public static char[] toCharArray(MemorySegment segment) {
+        return toArray(segment, char[].class, 2, char[]::new, MemorySegments::ofArray);
+    }
+
+    /**
+     * Copy the contents of the given memory segment into a fresh int array.
+     * @param segment the segment whose contents are to be copied into an int array.
+     * @return a fresh int array copy of the given memory segment.
+     * @throws UnsupportedOperationException if the given segment does not feature the {@link MemorySegment#READ} access mode, or if the given
+     * segment's contents cannot be copied into a {@link int[]} instance, e.g. because {@code byteSize() % 4 != 0},
+     * or {@code byteSize() / 4 > Integer#MAX_VALUE}.
+     * @throws IllegalStateException if the given segment has been closed, or if access occurs from a thread other than the
+     * thread owning the given segment.
+     */
+    public static int[] toIntArray(MemorySegment segment) {
+        return toArray(segment, int[].class, 4, int[]::new, MemorySegments::ofArray);
+    }
+
+    /**
+     * Copy the contents of the given memory segment into a fresh float array.
+     * @param segment the segment whose contents are to be copied into a float array.
+     * @return a fresh float array copy of the given memory segment.
+     * @throws UnsupportedOperationException if the given segment does not feature the {@link MemorySegment#READ} access mode, or if the given
+     * segment's contents cannot be copied into a {@link float[]} instance, e.g. because {@code byteSize() % 4 != 0},
+     * or {@code byteSize() / 4 > Integer#MAX_VALUE}.
+     * @throws IllegalStateException if the given segment has been closed, or if access occurs from a thread other than the
+     * thread owning the given segment.
+     */
+    public static float[] toFloatArray(MemorySegment segment) {
+        return toArray(segment, float[].class, 4, float[]::new, MemorySegments::ofArray);
+    }
+
+    /**
+     * Copy the contents of the given memory segment into a fresh long array.
+     * @param segment the segment whose contents are to be copied into a long array.
+     * @return a fresh long array copy of the given memory segment.
+     * @throws UnsupportedOperationException if the given segment does not feature the {@link MemorySegment#READ} access mode, or if the given
+     * segment's contents cannot be copied into a {@link long[]} instance, e.g. because {@code byteSize() % 8 != 0},
+     * or {@code byteSize() / 8 > Integer#MAX_VALUE}.
+     * @throws IllegalStateException if the given segment has been closed, or if access occurs from a thread other than the
+     * thread owning the given segment.
+     */
+    public static long[] toLongArray(MemorySegment segment) {
+        return toArray(segment, long[].class, 8, long[]::new, MemorySegments::ofArray);
+    }
+
+    /**
+     * Copy the contents of the given memory segment into a fresh double array.
+     * @param segment the segment whose contents are to be copied into a double array.
+     * @return a fresh double array copy of the given memory segment.
+     * @throws UnsupportedOperationException if the given segment does not feature the {@link MemorySegment#READ} access mode, or if the given
+     * segment's contents cannot be copied into a {@link double[]} instance, e.g. because {@code byteSize() % 8 != 0},
+     * or {@code byteSize() / 8 > Integer#MAX_VALUE}.
+     * @throws IllegalStateException if the given segment has been closed, or if access occurs from a thread other than the
+     * thread owning the given segment.
+     */
+    public static double[] toDoubleArray(MemorySegment segment) {
+        return toArray(segment, double[].class, 8, double[]::new, MemorySegments::ofArray);
+    }
+
+    /**
+     * Creates a new buffer memory segment that models the memory associated with the given byte
+     * buffer. The segment starts relative to the buffer's position (inclusive)
+     * and ends relative to the buffer's limit (exclusive).
+     * <p>
+     * The segment will feature all <a href="#access-modes">access modes</a> (see {@link MemorySegment#ALL_ACCESS}),
+     * unless the given buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will
+     * not feature the {@link MemorySegment#WRITE} access mode.
+     * <p>
+     * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains <em>reachable</em>
+     * for the life-time of the segment.
+     *
+     * @param bb the byte buffer backing the buffer memory segment.
+     * @return a new buffer memory segment.
+     */
+    public static MemorySegment ofByteBuffer(ByteBuffer bb) {
+        return AbstractMemorySegmentImpl.ofBuffer(bb);
+    }
+
+    /**
+     * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
+     * <p>
+     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
+     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
+     * (see {@link MemorySegment#ALL_ACCESS}).
+     *
+     * @param arr the primitive array backing the array memory segment.
+     * @return a new array memory segment.
+     */
+    public static MemorySegment ofArray(byte[] arr) {
+        return HeapMemorySegmentImpl.makeArraySegment(arr);
+    }
+
+    /**
+     * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
+     * <p>
+     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
+     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
+     * (see {@link MemorySegment#ALL_ACCESS}).
+     *
+     * @param arr the primitive array backing the array memory segment.
+     * @return a new array memory segment.
+     */
+    public static MemorySegment ofArray(char[] arr) {
+        return HeapMemorySegmentImpl.makeArraySegment(arr);
+    }
+
+    /**
+     * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
+     * <p>
+     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
+     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
+     * (see {@link MemorySegment#ALL_ACCESS}).
+     *
+     * @param arr the primitive array backing the array memory segment.
+     * @return a new array memory segment.
+     */
+    public static MemorySegment ofArray(short[] arr) {
+        return HeapMemorySegmentImpl.makeArraySegment(arr);
+    }
+
+    /**
+     * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.
+     * <p>
+     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
+     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>.
+     *
+     * @param arr the primitive array backing the array memory segment.
+     * @return a new array memory segment.
+     */
+    public static MemorySegment ofArray(int[] arr) {
+        return HeapMemorySegmentImpl.makeArraySegment(arr);
+    }
+
+    /**
+     * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
+     * <p>
+     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
+     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
+     * (see {@link MemorySegment#ALL_ACCESS}).
+     *
+     * @param arr the primitive array backing the array memory segment.
+     * @return a new array memory segment.
+     */
+    public static MemorySegment ofArray(float[] arr) {
+        return HeapMemorySegmentImpl.makeArraySegment(arr);
+    }
+
+    /**
+     * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
+     * <p>
+     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
+     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
+     * (see {@link MemorySegment#ALL_ACCESS}).
+     *
+     * @param arr the primitive array backing the array memory segment.
+     * @return a new array memory segment.
+     */
+    public static MemorySegment ofArray(long[] arr) {
+        return HeapMemorySegmentImpl.makeArraySegment(arr);
+    }
+
+    /**
+     * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
+     * <p>
+     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
+     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
+     * (see {@link MemorySegment#ALL_ACCESS}).
+     *
+     * @param arr the primitive array backing the array memory segment.
+     * @return a new array memory segment.
+     */
+    public static MemorySegment ofArray(double[] arr) {
+        return HeapMemorySegmentImpl.makeArraySegment(arr);
+    }
+
+    /**
+     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    allocateNative(layout.bytesSize(), layout.bytesAlignment());
+     * }</pre></blockquote>
+     *
+     * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
+     * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
+     * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
+     *
+     * @param layout the layout of the off-heap memory block backing the native memory segment.
+     * @return a new native memory segment.
+     * @throws IllegalArgumentException if the specified layout has illegal size or alignment constraint.
+     */
+    public static MemorySegment allocateNative(MemoryLayout layout) {
+        return allocateNative(layout.byteSize(), layout.byteAlignment());
+    }
+
+    /**
+     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    allocateNative(bytesSize, 1);
+     * }</pre></blockquote>
+     *
+     * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
+     * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
+     * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
+     *
+     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
+     * @return a new native memory segment.
+     * @throws IllegalArgumentException if {@code bytesSize < 0}.
+     */
+    public static MemorySegment allocateNative(long bytesSize) {
+        return allocateNative(bytesSize, 1);
+    }
+
+    /**
+     * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
+     * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
+     * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
+     * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
+     * (often as a plain {@code long} value). The segment will feature all <a href="#access-modes">access modes</a>
+     * (see {@link MemorySegment#ALL_ACCESS}).
+     * <p>
+     * This method is <em>restricted</em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash
+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
+     * restricted methods, and use safe and supported functionalities, where possible.
+     *
+     * @param addr the desired base address
+     * @param bytesSize the desired size.
+     * @param owner the desired owner thread. If {@code owner == null}, the returned segment is <em>not</em> confined.
+     * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
+     *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
+     * @param attachment an object that must be kept alive by the returned segment; this can be useful when
+     *                   the returned segment depends on memory which could be released if a certain object
+     *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
+     * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.
+     * @throws IllegalArgumentException if {@code bytesSize <= 0}.
+     * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.
+     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
+     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
+     * @throws NullPointerException if {@code addr == null}.
+     */
+    public static MemorySegment ofNativeRestricted(MemoryAddress addr, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {
+        Objects.requireNonNull(addr);
+        if (bytesSize <= 0) {
+            throw new IllegalArgumentException("Invalid size : " + bytesSize);
+        }
+        Utils.checkRestrictedAccess("MemorySegment.ofNativeRestricted");
+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, bytesSize, owner, cleanup, attachment);
+    }
+
+    /**
+     * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
+     * <p>
+     * The segment will feature all <a href="#access-modes">access modes</a> (see {@link MemorySegment#ALL_ACCESS}),
+     * unless the given mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY}, in which case
+     * the segment will not feature the {@link MemorySegment#WRITE} access mode.
+     *
+     * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
+     * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
+     *
+     * @param path the path to the file to memory map.
+     * @param bytesOffset the offset (expressed in bytes) within the file at which the mapped segment is to start.
+     * @param bytesSize the size (in bytes) of the mapped memory backing the memory segment.
+     * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode
+     *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegment#force()}).
+     * @return a new mapped memory segment.
+     * @throws IllegalArgumentException if {@code bytesOffset < 0}.
+     * @throws IllegalArgumentException if {@code bytesSize < 0}.
+     * @throws UnsupportedOperationException if an unsupported map mode is specified.
+     * @throws IOException if the specified path does not point to an existing file, or if some other I/O error occurs.
+     */
+    public static MappedMemorySegment mapFromPath(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
+        return MappedMemorySegmentImpl.makeMappedSegment(path, bytesOffset, bytesSize, mapMode);
+    }
+
+    /**
+     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
+     * alignment constraint (in bytes). The segment will feature all <a href="#access-modes">access modes</a>
+     * (see {@link MemorySegment#ALL_ACCESS}).
+     *
+     * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
+     * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
+     * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
+     *
+     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
+     * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.
+     * @return a new native memory segment.
+     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes < 0}, or if {@code alignmentBytes}
+     * is not a power of 2.
+     */
+    public static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {
+        if (bytesSize <= 0) {
+            throw new IllegalArgumentException("Invalid allocation size : " + bytesSize);
+        }
+
+        if (alignmentBytes < 0 ||
+                ((alignmentBytes & (alignmentBytes - 1)) != 0L)) {
+            throw new IllegalArgumentException("Invalid alignment constraint : " + alignmentBytes);
+        }
+
+        return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
+    }
+
+    private static final VarHandle byte_LE_handle = indexedHandle(MemoryLayouts.BITS_8_LE, byte.class);
+    private static final VarHandle char_LE_handle = indexedHandle(MemoryLayouts.BITS_16_LE, char.class);
+    private static final VarHandle short_LE_handle = indexedHandle(MemoryLayouts.BITS_16_LE, short.class);
+    private static final VarHandle int_LE_handle = indexedHandle(MemoryLayouts.BITS_32_LE, int.class);
+    private static final VarHandle float_LE_handle = indexedHandle(MemoryLayouts.BITS_32_LE, float.class);
+    private static final VarHandle long_LE_handle = indexedHandle(MemoryLayouts.BITS_64_LE, long.class);
+    private static final VarHandle double_LE_handle = indexedHandle(MemoryLayouts.BITS_64_LE, double.class);
+
+    /**
+     * Read a byte from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);
+    byte value = (byte)handle.get(addr, offset);
+     * }</pre></blockquote>
+     *
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a byte value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static byte getByte_LE(MemoryAddress addr, long offset) {
+        return (byte)byte_LE_handle.get(addr, offset);
+    }
+
+    /**
+     * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the byte value to be written.
+     */
+    public static void setByte_LE(MemoryAddress addr, long offset, byte value) {
+        byte_LE_handle.set(addr, offset, value);
+    }
+
+    /**
+     * Read a char from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);
+    char value = (char)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a char value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static char getChar_LE(MemoryAddress addr, long offset) {
+        return (char)char_LE_handle.get(addr, offset);
+    }
+
+    /**
+     * Writes a char at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the char value to be written.
+     */
+    public static void setChar_LE(MemoryAddress addr, long offset, char value) {
+        char_LE_handle.set(addr, offset, value);
+    }
+
+    /**
+     * Read a short from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);
+    short value = (short)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a short value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static short getShort_LE(MemoryAddress addr, long offset) {
+        return (short)short_LE_handle.get(addr, offset);
+    }
+
+    /**
+     * Writes a short at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the short value to be written.
+     */
+    public static void setShort_LE(MemoryAddress addr, long offset, short value) {
+        short_LE_handle.set(addr, offset, value);
+    }
+
+    /**
+     * Read an int from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);
+    int value = (int)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return an int value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static int getInt_LE(MemoryAddress addr, long offset) {
+        return (int)int_LE_handle.get(addr, offset);
+    }
+
+    /**
+     * Writes an int at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the int value to be written.
+     */
+    public static void setInt_LE(MemoryAddress addr, long offset, int value) {
+        int_LE_handle.set(addr, offset, value);
+    }
+
+    /**
+     * Read a float from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);
+    float value = (float)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a float value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static float getFloat_LE(MemoryAddress addr, long offset) {
+        return (float)float_LE_handle.get(addr, offset);
+    }
+
+    /**
+     * Writes a float at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the float value to be written.
+     */
+    public static void setFloat_LE(MemoryAddress addr, long offset, float value) {
+        float_LE_handle.set(addr, offset, value);
+    }
+
+    /**
+     * Read a long from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);
+    long value = (long)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a long value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static long getLong_LE(MemoryAddress addr, long offset) {
+        return (long)long_LE_handle.get(addr, offset);
+    }
+
+    /**
+     * Writes a long at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the long value to be written.
+     */
+    public static void setLong_LE(MemoryAddress addr, long offset, long value) {
+        long_LE_handle.set(addr, offset, value);
+    }
+
+    /**
+     * Read a double from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(double.class), 1L);
+    double value = (double)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a double value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static double getDouble_LE(MemoryAddress addr, long offset) {
+        return (double)double_LE_handle.get(addr, offset);
+    }
+
+    /**
+     * Writes a double at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(double.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the double value to be written.
+     */
+    public static void setDouble_LE(MemoryAddress addr, long offset, double value) {
+        double_LE_handle.set(addr, offset, value);
+    }
+
+    private static final VarHandle byte_BE_handle = indexedHandle(MemoryLayouts.BITS_8_BE, byte.class);
+    private static final VarHandle char_BE_handle = indexedHandle(MemoryLayouts.BITS_16_BE, char.class);
+    private static final VarHandle short_BE_handle = indexedHandle(MemoryLayouts.BITS_16_BE, short.class);
+    private static final VarHandle int_BE_handle = indexedHandle(MemoryLayouts.BITS_32_BE, int.class);
+    private static final VarHandle float_BE_handle = indexedHandle(MemoryLayouts.BITS_32_BE, float.class);
+    private static final VarHandle long_BE_handle = indexedHandle(MemoryLayouts.BITS_64_BE, long.class);
+    private static final VarHandle double_BE_handle = indexedHandle(MemoryLayouts.BITS_64_BE, double.class);
+
+    /**
+     * Read a byte from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);
+    byte value = (byte)handle.get(addr, offset);
+     * }</pre></blockquote>
+     *
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a byte value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static byte getByte_BE(MemoryAddress addr, long offset) {
+        return (byte)byte_BE_handle.get(addr, offset);
+    }
+
+    /**
+     * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the byte value to be written.
+     */
+    public static void setByte_BE(MemoryAddress addr, long offset, byte value) {
+        byte_BE_handle.set(addr, offset, value);
+    }
+
+    /**
+     * Read a char from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);
+    char value = (char)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a char value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static char getChar_BE(MemoryAddress addr, long offset) {
+        return (char)char_BE_handle.get(addr, offset);
+    }
+
+    /**
+     * Writes a char at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the char value to be written.
+     */
+    public static void setChar_BE(MemoryAddress addr, long offset, char value) {
+        char_BE_handle.set(addr, offset, value);
+    }
+
+    /**
+     * Read a short from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);
+    short value = (short)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a short value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static short getShort_BE(MemoryAddress addr, long offset) {
+        return (short)short_BE_handle.get(addr, offset);
+    }
+
+    /**
+     * Writes a short at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the short value to be written.
+     */
+    public static void setShort_BE(MemoryAddress addr, long offset, short value) {
+        short_BE_handle.set(addr, offset, value);
+    }
+
+    /**
+     * Read an int from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);
+    int value = (int)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return an int value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static int getInt_BE(MemoryAddress addr, long offset) {
+        return (int)int_BE_handle.get(addr, offset);
+    }
+
+    /**
+     * Writes an int at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the int value to be written.
+     */
+    public static void setInt_BE(MemoryAddress addr, long offset, int value) {
+        int_BE_handle.set(addr, offset, value);
+    }
+
+    /**
+     * Read a float from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);
+    float value = (float)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a float value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static float getFloat_BE(MemoryAddress addr, long offset) {
+        return (float)float_BE_handle.get(addr, offset);
+    }
+
+    /**
+     * Writes a float at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the float value to be written.
+     */
+    public static void setFloat_BE(MemoryAddress addr, long offset, float value) {
+        float_BE_handle.set(addr, offset, value);
+    }
+
+    /**
+     * Read a long from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);
+    long value = (long)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a long value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static long getLong_BE(MemoryAddress addr, long offset) {
+        return (long)long_BE_handle.get(addr, offset);
+    }
+
+    /**
+     * Writes a long at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the long value to be written.
+     */
+    public static void setLong_BE(MemoryAddress addr, long offset, long value) {
+        long_BE_handle.set(addr, offset, value);
+    }
+
+    /**
+     * Read a double from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(double.class), 1L);
+    double value = (double)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a double value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static double getDouble_BE(MemoryAddress addr, long offset) {
+        return (double)double_BE_handle.get(addr, offset);
+    }
+
+    /**
+     * Writes a double at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(double.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the double value to be written.
+     */
+    public static void setDouble_BE(MemoryAddress addr, long offset, double value) {
+        double_BE_handle.set(addr, offset, value);
+    }
+
+    /**
+     * Read a byte from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);
+    byte value = (byte)handle.get(addr, offset);
+     * }</pre></blockquote>
+     *
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a byte value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static byte getByte(MemoryAddress addr, long offset) {
+        return (byte)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).get(addr, offset);
+    }
+
+    /**
+     * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the byte value to be written.
+     */
+    public static void setByte(MemoryAddress addr, long offset, byte value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).set(addr, offset, value);
+    }
+
+    /**
+     * Read a char from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);
+    char value = (char)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a char value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static char getChar(MemoryAddress addr, long offset) {
+        return (char)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(addr, offset);
+    }
+
+    /**
+     * Writes a char at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the char value to be written.
+     */
+    public static void setChar(MemoryAddress addr, long offset, char value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(addr, offset, value);
+    }
+
+    /**
+     * Read a short from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);
+    short value = (short)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a short value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static short getShort(MemoryAddress addr, long offset) {
+        return (short)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(addr, offset);
+    }
+
+    /**
+     * Writes a short at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the short value to be written.
+     */
+    public static void setShort(MemoryAddress addr, long offset, short value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(addr, offset, value);
+    }
+
+    /**
+     * Read an int from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);
+    int value = (int)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return an int value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static int getInt(MemoryAddress addr, long offset) {
+        return (int)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(addr, offset);
+    }
+
+    /**
+     * Writes an int at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the int value to be written.
+     */
+    public static void setInt(MemoryAddress addr, long offset, int value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(addr, offset, value);
+    }
+
+    /**
+     * Read a float from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);
+    float value = (float)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a float value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static float getFloat(MemoryAddress addr, long offset) {
+        return (float)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(addr, offset);
+    }
+
+    /**
+     * Writes a float at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the float value to be written.
+     */
+    public static void setFloat(MemoryAddress addr, long offset, float value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(addr, offset, value);
+    }
+
+    /**
+     * Read a long from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);
+    long value = (long)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a long value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static long getLong(MemoryAddress addr, long offset) {
+        return (long)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(addr, offset);
+    }
+
+    /**
+     * Writes a long at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the long value to be written.
+     */
+    public static void setLong(MemoryAddress addr, long offset, long value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(addr, offset, value);
+    }
+
+    /**
+     * Read a double from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);
+    double value = (double)handle.get(addr, offset);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @return a double value read from {@code addr} at the offset specified by {@code index}.
+     */
+    public static double getDouble(MemoryAddress addr, long offset) {
+        return (double)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(addr, offset);
+    }
+
+    /**
+     * Writes a double at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);
+    handle.set(addr, offset, value);
+     * }</pre></blockquote>
+     * @param addr base address.
+     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param value the double value to be written.
+     */
+    public static void setDouble(MemoryAddress addr, long offset, double value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(addr, offset, value);
+    }
+
+    private static VarHandle indexedHandle(MemoryLayout elementLayout, Class<?> carrier) {
+        return MemoryHandles.withStride(elementLayout.withBitAlignment(8).varHandle(carrier), 1L);
+    }
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -45,10 +45,12 @@
 import java.util.List;
 import java.util.Objects;
 import java.util.Random;
 import java.util.Spliterator;
 import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.IntFunction;
 
 /**
  * This abstract class provides an immutable implementation for the {@code MemorySegment} interface. This class contains information
  * about the segment's spatial and temporal bounds; each memory segment implementation is associated with an owner thread which is set at creation time.
  * Access to certain sensitive operations on the memory segment will fail with {@code IllegalStateException} if the
@@ -79,17 +81,17 @@
         this.length = length;
         this.mask = mask;
         this.scope = scope;
     }
 
-    abstract long min();
+    public abstract long min();
 
-    abstract Object base();
+    public abstract Object base();
 
     abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope);
 
-    abstract ByteBuffer makeByteBuffer();
+    public abstract ByteBuffer makeByteBuffer();
 
     static int defaultAccessModes(long size) {
         return (enableSmallSegments && size < Integer.MAX_VALUE) ?
                 ALL_ACCESS | SMALL :
                 ALL_ACCESS;
@@ -113,88 +115,16 @@
         }
         return (Spliterator<S>)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() & ~CLOSE));
     }
 
-    @Override
-    public final MemorySegment fill(byte value){
-        checkRange(0, length, true);
-        UNSAFE.setMemory(base(), min(), length, value);
-        return this;
-    }
-
-    public void copyFrom(MemorySegment src) {
-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;
-        long size = that.byteSize();
-        checkRange(0, size, true);
-        that.checkRange(0, size, false);
-        UNSAFE.copyMemory(
-                that.base(), that.min(),
-                base(), min(), size);
-    }
-
-    private final static VarHandle BYTE_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
-            .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
-
-    @Override
-    public long mismatch(MemorySegment other) {
-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;
-        final long thisSize = this.byteSize();
-        final long thatSize = that.byteSize();
-        final long length = Math.min(thisSize, thatSize);
-        this.checkRange(0, length, false);
-        that.checkRange(0, length, false);
-        if (this == other) {
-            return -1;
-        }
-
-        long i = 0;
-        if (length > 7) {
-            if ((byte) BYTE_HANDLE.get(this.baseAddress(), 0) != (byte) BYTE_HANDLE.get(that.baseAddress(), 0)) {
-                return 0;
-            }
-            i = ArraysSupport.vectorizedMismatchLargeForBytes(
-                    this.base(), this.min(),
-                    that.base(), that.min(),
-                    length);
-            if (i >= 0) {
-                return i;
-            }
-            long remaining = ~i;
-            assert remaining < 8 : "remaining greater than 7: " + remaining;
-            i = length - remaining;
-        }
-        MemoryAddress thisAddress = this.baseAddress();
-        MemoryAddress thatAddress = that.baseAddress();
-        for (; i < length; i++) {
-            if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {
-                return i;
-            }
-        }
-        return thisSize != thatSize ? length : -1;
-    }
-
     @Override
     @ForceInline
     public final MemoryAddress baseAddress() {
         return new MemoryAddressImpl(this, 0);
     }
 
-    @Override
-    public final ByteBuffer asByteBuffer() {
-        if (!isSet(READ)) {
-            throw unsupportedAccessMode(READ);
-        }
-        checkIntSize("ByteBuffer");
-        ByteBuffer _bb = makeByteBuffer();
-        if (!isSet(WRITE)) {
-            //scope is IMMUTABLE - obtain a RO byte buffer
-            _bb = _bb.asReadOnlyBuffer();
-        }
-        return _bb;
-    }
-
     @Override
     public final int accessModes() {
         return mask & ALL_ACCESS;
     }
 
@@ -226,11 +156,11 @@
     public boolean hasAccessModes(int accessModes) {
         checkAccessModes(accessModes);
         return (accessModes() & accessModes) == accessModes;
     }
 
-    private void checkAccessModes(int accessModes) {
+    public void checkAccessModes(int accessModes) {
         if ((accessModes & ~ALL_ACCESS) != 0) {
             throw new IllegalArgumentException("Invalid access modes");
         }
     }
 
@@ -269,24 +199,15 @@
             throw unsupportedAccessMode(ACQUIRE);
         }
         return dup(0, length, mask, scope.acquire());
     }
 
-    @Override
-    public final byte[] toByteArray() {
-        checkIntSize("byte[]");
-        byte[] arr = new byte[(int)length];
-        MemorySegment arrSegment = MemorySegment.ofArray(arr);
-        arrSegment.copyFrom(this);
-        return arr;
-    }
-
     boolean isSmall() {
         return isSet(SMALL);
     }
 
-    void checkRange(long offset, long length, boolean writeAccess) {
+    public void checkRange(long offset, long length, boolean writeAccess) {
         scope.checkValidState();
         if (writeAccess && !isSet(WRITE)) {
             throw unsupportedAccessMode(WRITE);
         } else if (!writeAccess && !isSet(READ)) {
             throw unsupportedAccessMode(READ);
@@ -303,16 +224,10 @@
 
     private boolean isSet(int mask) {
         return (this.mask & mask) != 0;
     }
 
-    private void checkIntSize(String typeName) {
-        if (length > (Integer.MAX_VALUE - 8)) { //conservative check
-            throw new UnsupportedOperationException(String.format("Segment is too large to wrap as %s. Size: %d", typeName, length));
-        }
-    }
-
     private void checkBounds(long offset, long length) {
         if (isSmall()) {
             checkBoundsSmall((int)offset, (int)length);
         } else {
             if (length < 0 ||
@@ -491,21 +406,21 @@
 
     public static final AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(
         0, 0, MemoryScope.createUnchecked(null, null, null)
     ) {
         @Override
-        ByteBuffer makeByteBuffer() {
+        public ByteBuffer makeByteBuffer() {
             throw new UnsupportedOperationException();
         }
 
         @Override
-        long min() {
+        public long min() {
             return 0;
         }
 
         @Override
-        Object base() {
+        public Object base() {
             return null;
         }
 
         @Override
         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java
@@ -57,26 +57,26 @@
         this.offset = offset;
         this.baseProvider = baseProvider;
     }
 
     @Override
-    H base() {
+    public H base() {
         return Objects.requireNonNull(baseProvider.get());
     }
 
     @Override
-    long min() {
+    public long min() {
         return offset;
     }
 
     @Override
     HeapMemorySegmentImpl<H> dup(long offset, long size, int mask, MemoryScope scope) {
         return new HeapMemorySegmentImpl<>(this.offset + offset, baseProvider, size, mask, scope);
     }
 
     @Override
-    ByteBuffer makeByteBuffer() {
+    public ByteBuffer makeByteBuffer() {
         if (!(base() instanceof byte[])) {
             throw new UnsupportedOperationException("Not an address to an heap-allocated byte array");
         }
         JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
         return nioAccess.newHeapByteBuffer((byte[]) base(), (int)min() - BYTE_ARR_BASE, (int) byteSize(), this);
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java
@@ -52,11 +52,11 @@
         super(min, length, mask, scope);
         this.unmapper = unmapper;
     }
 
     @Override
-    ByteBuffer makeByteBuffer() {
+    public ByteBuffer makeByteBuffer() {
         JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
         return nioAccess.newMappedByteBuffer(unmapper, min, (int)length, null, this);
     }
 
     @Override
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
@@ -53,11 +53,11 @@
  * scope that doesn't check for thread-confinement while its temporal bounds are
  * enforced reliably only under condition that thread that closes the scope is also
  * the single thread performing the checked access or there is an external synchronization
  * in place that prevents concurrent access and closing of the scope.
  */
-abstract class MemoryScope {
+public abstract class MemoryScope {
 
     /**
      * Creates a root MemoryScope with given ref, cleanupAction and current
      * thread as the "owner" thread.
      * This method may be called in any thread.
@@ -68,11 +68,11 @@
      *
      * @param ref           an optional reference to an instance that needs to be kept reachable
      * @param cleanupAction an optional cleanup action to be executed when returned scope is closed
      * @return a root MemoryScope
      */
-    static MemoryScope create(Object ref, Runnable cleanupAction) {
+    public static MemoryScope create(Object ref, Runnable cleanupAction) {
         return new Root(Thread.currentThread(), ref, cleanupAction);
     }
 
     /**
      * Creates a root MemoryScope with given ref, cleanupAction and "owner" thread.
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java
@@ -62,22 +62,22 @@
     NativeMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
         return new NativeMemorySegmentImpl(min + offset, size, mask, scope);
     }
 
     @Override
-    ByteBuffer makeByteBuffer() {
+    public ByteBuffer makeByteBuffer() {
         JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
         return nioAccess.newDirectByteBuffer(min(), (int) this.length, null, this);
     }
 
     @Override
-    long min() {
+    public long min() {
         return min;
     }
 
     @Override
-    Object base() {
+    public Object base() {
         return null;
     }
 
     // factories
 
diff a/test/jdk/java/foreign/TestAdaptVarHandles.java b/test/jdk/java/foreign/TestAdaptVarHandles.java
--- a/test/jdk/java/foreign/TestAdaptVarHandles.java
+++ b/test/jdk/java/foreign/TestAdaptVarHandles.java
@@ -33,10 +33,11 @@
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import jdk.incubator.foreign.ValueLayout;
 import org.testng.annotations.*;
 import static org.testng.Assert.*;
 
 import java.lang.invoke.MethodHandle;
@@ -87,11 +88,11 @@
     }
 
     @Test
     public void testFilterValue() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
-        MemorySegment segment = MemorySegment.allocateNative(layout);
+        MemorySegment segment = MemorySegments.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, S2I, I2S);
         i2SHandle.set(segment.baseAddress(), "1");
         String oldValue = (String)i2SHandle.getAndAdd(segment.baseAddress(), "42");
         assertEquals(oldValue, "1");
@@ -106,11 +107,11 @@
     }
 
     @Test
     public void testFilterValueComposite() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
-        MemorySegment segment = MemorySegment.allocateNative(layout);
+        MemorySegment segment = MemorySegments.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         MethodHandle CTX_S2I = MethodHandles.dropArguments(S2I, 0, String.class, String.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, CTX_S2I, CTX_I2S);
         i2SHandle = MemoryHandles.insertCoordinates(i2SHandle, 1, "a", "b");
         i2SHandle.set(segment.baseAddress(), "1");
@@ -127,11 +128,11 @@
     }
 
     @Test
     public void testFilterValueLoose() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
-        MemorySegment segment = MemorySegment.allocateNative(layout);
+        MemorySegment segment = MemorySegments.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, O2I, I2O);
         i2SHandle.set(segment.baseAddress(), "1");
         String oldValue = (String)i2SHandle.getAndAdd(segment.baseAddress(), "42");
         assertEquals(oldValue, "1");
@@ -213,11 +214,11 @@
     }
 
     @Test
     public void testFilterCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
-        MemorySegment segment = MemorySegment.allocateNative(layout);
+        MemorySegment segment = MemorySegments.allocateNative(layout);
         VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
         VarHandle intHandle_longIndex = MemoryHandles.filterCoordinates(intHandle, 0, BASE_ADDR, S2L);
         intHandle_longIndex.set(segment, "0", 1);
         int oldValue = (int)intHandle_longIndex.getAndAdd(segment, "0", 42);
         assertEquals(oldValue, 1);
@@ -273,11 +274,11 @@
     }
 
     @Test
     public void testInsertCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
-        MemorySegment segment = MemorySegment.allocateNative(layout);
+        MemorySegment segment = MemorySegments.allocateNative(layout);
         VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
         VarHandle intHandle_longIndex = MemoryHandles.insertCoordinates(intHandle, 0, segment.baseAddress(), 0L);
         intHandle_longIndex.set(1);
         int oldValue = (int)intHandle_longIndex.getAndAdd(42);
         assertEquals(oldValue, 1);
@@ -327,11 +328,11 @@
     }
 
     @Test
     public void testPermuteCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
-        MemorySegment segment = MemorySegment.allocateNative(layout);
+        MemorySegment segment = MemorySegments.allocateNative(layout);
         VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
         VarHandle intHandle_swap = MemoryHandles.permuteCoordinates(intHandle,
                 List.of(long.class, MemoryAddress.class), 1, 0);
         intHandle_swap.set(0L, segment.baseAddress(), 1);
         int oldValue = (int)intHandle_swap.getAndAdd(0L, segment.baseAddress(), 42);
@@ -388,11 +389,11 @@
     }
 
     @Test
     public void testCollectCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
-        MemorySegment segment = MemorySegment.allocateNative(layout);
+        MemorySegment segment = MemorySegments.allocateNative(layout);
         VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
         VarHandle intHandle_sum = MemoryHandles.collectCoordinates(intHandle, 1, SUM_OFFSETS);
         intHandle_sum.set(segment.baseAddress(), -2L, 2L, 1);
         int oldValue = (int)intHandle_sum.getAndAdd(segment.baseAddress(), -2L, 2L, 42);
         assertEquals(oldValue, 1);
@@ -448,11 +449,11 @@
     }
 
     @Test
     public void testDropCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
-        MemorySegment segment = MemorySegment.allocateNative(layout);
+        MemorySegment segment = MemorySegments.allocateNative(layout);
         VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
         VarHandle intHandle_dummy = MemoryHandles.dropCoordinates(intHandle, 1, float.class, String.class);
         intHandle_dummy.set(segment.baseAddress(), 1f, "hello", 0L, 1);
         int oldValue = (int)intHandle_dummy.getAndAdd(segment.baseAddress(), 1f, "hello", 0L, 42);
         assertEquals(oldValue, 1);
diff a/test/jdk/java/foreign/TestAddressHandle.java b/test/jdk/java/foreign/TestAddressHandle.java
--- a/test/jdk/java/foreign/TestAddressHandle.java
+++ b/test/jdk/java/foreign/TestAddressHandle.java
@@ -60,11 +60,11 @@
     }
 
     @Test(dataProvider = "addressHandles")
     public void testAddressHandle(VarHandle addrHandle, int byteSize) {
         VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
-        try (MemorySegment segment = MemorySegment.allocateNative(8)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(8)) {
             MemoryAddress target = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?
                     segment.baseAddress().addOffset(8 - byteSize) :
                     segment.baseAddress();
             longHandle.set(segment.baseAddress(), 42L);
             MemoryAddress address = (MemoryAddress)addrHandle.get(target);
@@ -82,11 +82,11 @@
     }
 
     @Test(dataProvider = "addressHandles")
     public void testNull(VarHandle addrHandle, int byteSize) {
         VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
-        try (MemorySegment segment = MemorySegment.allocateNative(8)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(8)) {
             longHandle.set(segment.baseAddress(), 0L);
             MemoryAddress address = (MemoryAddress)addrHandle.get(segment.baseAddress());
             assertTrue(address == MemoryAddress.NULL);
         }
     }
diff a/test/jdk/java/foreign/TestArrays.java b/test/jdk/java/foreign/TestArrays.java
--- a/test/jdk/java/foreign/TestArrays.java
+++ b/test/jdk/java/foreign/TestArrays.java
@@ -22,23 +22,27 @@
  *
  */
 
 /*
  * @test
- * @run testng TestArrays
+ * @run testng/othervm -Dforeign.restricted=permit TestArrays
  */
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import jdk.incubator.foreign.SequenceLayout;
 
 import java.lang.invoke.VarHandle;
 import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
 import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.ToIntFunction;
 
 import org.testng.annotations.*;
 
 import static jdk.incubator.foreign.MemorySegment.READ;
 import static org.testng.Assert.*;
@@ -85,53 +89,69 @@
         for (long i = 0; i < seq.elementCount().getAsLong() ; i++) {
             handleSetter.accept(base, i);
         }
     }
 
-    static void checkBytes(MemoryAddress base, SequenceLayout layout) {
-        long nBytes = layout.elementCount().getAsLong() * layout.elementLayout().byteSize();
-        byte[] arr = base.segment().toByteArray();
-        for (long i = 0 ; i < nBytes ; i++) {
-            byte expected = (byte)byteHandle.get(base, i);
-            byte found = arr[(int)i];
+    static void checkBytes(MemoryAddress base, SequenceLayout layout, Function<MemorySegment, Object> arrayFactory, BiFunction<MemoryAddress, Long, Object> handleGetter) {
+        int nelems = (int)layout.elementCount().getAsLong();
+        Object arr = arrayFactory.apply(base.segment());
+        for (int i = 0; i < nelems; i++) {
+            Object found = handleGetter.apply(base, (long) i);
+            Object expected = java.lang.reflect.Array.get(arr, i);
             assertEquals(expected, found);
         }
     }
 
     @Test(dataProvider = "arrays")
-    public void testArrays(Consumer<MemoryAddress> init, SequenceLayout layout) {
-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
+    public void testArrays(Consumer<MemoryAddress> init, Consumer<MemoryAddress> checker, MemoryLayout layout) {
+        try (MemorySegment segment = MemorySegments.allocateNative(layout)) {
             init.accept(segment.baseAddress());
-            checkBytes(segment.baseAddress(), layout);
+            checker.accept(segment.baseAddress());
         }
     }
 
-    @Test(expectedExceptions = { UnsupportedOperationException.class,
-                                 IllegalArgumentException.class })
-    public void testTooBigForArray() {
-        MemorySegment.allocateNative((long) Integer.MAX_VALUE * 2).toByteArray();
+    @Test(dataProvider = "elemLayouts",
+          expectedExceptions = UnsupportedOperationException.class)
+    public void testTooBigForArray(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {
+        MemoryLayout seq = MemoryLayout.ofSequence((Integer.MAX_VALUE * layout.byteSize()) + 1, layout);
+        //do not really allocate here, as it's way too much memory
+        try (MemorySegment segment = MemorySegments.ofNativeRestricted(MemoryAddress.NULL, seq.byteSize(), null, null, null)) {
+            arrayFactory.apply(segment);
+        }
     }
 
-    @Test(expectedExceptions = IllegalStateException.class)
-    public void testArrayFromClosedSegment() {
-        MemorySegment segment = MemorySegment.allocateNative(8);
+    @Test(dataProvider = "elemLayouts",
+          expectedExceptions = UnsupportedOperationException.class)
+    public void testBadSize(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {
+        if (layout.byteSize() == 1) throw new UnsupportedOperationException(); //make it fail
+        try (MemorySegment segment = MemorySegments.allocateNative(layout.byteSize() + 1)) {
+            arrayFactory.apply(segment);
+        }
+    }
+
+    @Test(dataProvider = "elemLayouts",
+            expectedExceptions = IllegalStateException.class)
+    public void testArrayFromClosedSegment(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {
+        MemorySegment segment = MemorySegments.allocateNative(layout);
         segment.close();
-        segment.toByteArray();
+        arrayFactory.apply(segment);
     }
 
-    @Test(expectedExceptions = UnsupportedOperationException.class)
-    public void testArrayFromHeapSegmentWithoutAccess() {
-        MemorySegment segment = MemorySegment.ofArray(new byte[8]);
-        segment = segment.withAccessModes(segment.accessModes() & ~READ);
-        segment.toByteArray();
+    @Test(dataProvider = "elemLayouts",
+          expectedExceptions = UnsupportedOperationException.class)
+    public void testArrayFromHeapSegmentWithoutAccess(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {
+        MemorySegment segment = MemorySegments.ofArray(new byte[(int)layout.byteSize()]);
+        segment = segment.withAccessModes(MemorySegment.ALL_ACCESS & ~READ);
+        arrayFactory.apply(segment);
     }
 
-    @Test(expectedExceptions = UnsupportedOperationException.class)
-    public void testArrayFromNativeSegmentWithoutAccess() {
-        MemorySegment segment = MemorySegment.allocateNative(8);
-        segment = segment.withAccessModes(segment.accessModes() & ~READ);
-        segment.toByteArray();
+    @Test(dataProvider = "elemLayouts",
+            expectedExceptions = UnsupportedOperationException.class)
+    public void testArrayFromNativeSegmentWithoutAccess(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {
+        try (MemorySegment segment = MemorySegments.allocateNative(layout).withAccessModes(MemorySegment.ALL_ACCESS & ~READ)) {
+            arrayFactory.apply(segment);
+        }
     }
 
     @DataProvider(name = "arrays")
     public Object[][] nativeAccessOps() {
         Consumer<MemoryAddress> byteInitializer =
@@ -147,16 +167,44 @@
         Consumer<MemoryAddress> longInitializer =
                 (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));
         Consumer<MemoryAddress> doubleInitializer =
                 (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));
 
+        Consumer<MemoryAddress> byteChecker =
+                (base) -> checkBytes(base, bytes, MemorySegments::toByteArray, (addr, pos) -> (byte)byteHandle.get(addr, pos));
+        Consumer<MemoryAddress> shortChecker =
+                (base) -> checkBytes(base, shorts, MemorySegments::toShortArray, (addr, pos) -> (short)shortHandle.get(addr, pos));
+        Consumer<MemoryAddress> charChecker =
+                (base) -> checkBytes(base, chars, MemorySegments::toCharArray, (addr, pos) -> (char)charHandle.get(addr, pos));
+        Consumer<MemoryAddress> intChecker =
+                (base) -> checkBytes(base, ints, MemorySegments::toIntArray, (addr, pos) -> (int)intHandle.get(addr, pos));
+        Consumer<MemoryAddress> floatChecker =
+                (base) -> checkBytes(base, floats, MemorySegments::toFloatArray, (addr, pos) -> (float)floatHandle.get(addr, pos));
+        Consumer<MemoryAddress> longChecker =
+                (base) -> checkBytes(base, longs, MemorySegments::toLongArray, (addr, pos) -> (long)longHandle.get(addr, pos));
+        Consumer<MemoryAddress> doubleChecker =
+                (base) -> checkBytes(base, doubles, MemorySegments::toDoubleArray, (addr, pos) -> (double)doubleHandle.get(addr, pos));
+
         return new Object[][]{
-                {byteInitializer, bytes},
-                {charInitializer, chars},
-                {shortInitializer, shorts},
-                {intInitializer, ints},
-                {floatInitializer, floats},
-                {longInitializer, longs},
-                {doubleInitializer, doubles}
+                {byteInitializer, byteChecker, bytes},
+                {charInitializer, charChecker, chars},
+                {shortInitializer, shortChecker, shorts},
+                {intInitializer, intChecker, ints},
+                {floatInitializer, floatChecker, floats},
+                {longInitializer, longChecker, longs},
+                {doubleInitializer, doubleChecker, doubles}
+        };
+    }
+
+    @DataProvider(name = "elemLayouts")
+    public Object[][] elemLayouts() {
+        return new Object[][] {
+                { MemoryLayouts.JAVA_BYTE, (Function<MemorySegment, Object>) MemorySegments::toByteArray },
+                { MemoryLayouts.JAVA_SHORT, (Function<MemorySegment, Object>) MemorySegments::toShortArray },
+                { MemoryLayouts.JAVA_CHAR, (Function<MemorySegment, Object>) MemorySegments::toCharArray },
+                { MemoryLayouts.JAVA_INT, (Function<MemorySegment, Object>) MemorySegments::toIntArray },
+                { MemoryLayouts.JAVA_FLOAT, (Function<MemorySegment, Object>) MemorySegments::toFloatArray },
+                { MemoryLayouts.JAVA_LONG, (Function<MemorySegment, Object>) MemorySegments::toLongArray },
+                { MemoryLayouts.JAVA_DOUBLE, (Function<MemorySegment, Object>) MemorySegments::toDoubleArray }
         };
     }
 }
diff a/test/jdk/java/foreign/TestByteBuffer.java b/test/jdk/java/foreign/TestByteBuffer.java
--- a/test/jdk/java/foreign/TestByteBuffer.java
+++ b/test/jdk/java/foreign/TestByteBuffer.java
@@ -35,10 +35,11 @@
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
+import jdk.incubator.foreign.MemorySegments;
 import jdk.incubator.foreign.SequenceLayout;
 
 import java.io.File;
 import java.io.IOException;
 import java.lang.invoke.MethodHandle;
@@ -132,19 +133,10 @@
     );
 
     static VarHandle indexHandle = tuples.varHandle(int.class, PathElement.sequenceElement(), PathElement.groupElement("index"));
     static VarHandle valueHandle = tuples.varHandle(float.class, PathElement.sequenceElement(), PathElement.groupElement("value"));
 
-    static VarHandle byteHandle = bytes.varHandle(byte.class, PathElement.sequenceElement());
-    static VarHandle charHandle = chars.varHandle(char.class, PathElement.sequenceElement());
-    static VarHandle shortHandle = shorts.varHandle(short.class, PathElement.sequenceElement());
-    static VarHandle intHandle = ints.varHandle(int.class, PathElement.sequenceElement());
-    static VarHandle floatHandle = floats.varHandle(float.class, PathElement.sequenceElement());
-    static VarHandle longHandle = longs.varHandle(long.class, PathElement.sequenceElement());
-    static VarHandle doubleHandle = doubles.varHandle(double.class, PathElement.sequenceElement());
-
-
     static void initTuples(MemoryAddress base, long count) {
         for (long i = 0; i < count ; i++) {
             indexHandle.set(base, i, (int)i);
             valueHandle.set(base, i, (float)(i / 500f));
         }
@@ -173,11 +165,11 @@
         long nelems = layout.elementCount().getAsLong();
         long elemSize = layout.elementLayout().byteSize();
         for (long i = 0 ; i < nelems ; i++) {
             long limit = nelems - i;
             MemorySegment resizedSegment = base.segment().asSlice(i * elemSize, limit * elemSize);
-            ByteBuffer bb = resizedSegment.asByteBuffer();
+            ByteBuffer bb = MemorySegments.asByteBuffer(resizedSegment);
             Z z = bufFactory.apply(bb);
             for (long j = i ; j < limit ; j++) {
                 Object handleValue = handleExtractor.apply(resizedSegment.baseAddress(), j - i);
                 Object bufferValue = bufferExtractor.apply(z);
                 if (handleValue instanceof Number) {
@@ -191,27 +183,27 @@
         }
     }
 
     @Test
     public void testOffheap() {
-        try (MemorySegment segment = MemorySegment.allocateNative(tuples)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(tuples)) {
             MemoryAddress base = segment.baseAddress();
             initTuples(base, tuples.elementCount().getAsLong());
 
-            ByteBuffer bb = segment.asByteBuffer();
+            ByteBuffer bb = MemorySegments.asByteBuffer(segment);
             checkTuples(base, bb, tuples.elementCount().getAsLong());
         }
     }
 
     @Test
     public void testHeap() {
         byte[] arr = new byte[(int) tuples.byteSize()];
-        MemorySegment region = MemorySegment.ofArray(arr);
+        MemorySegment region = MemorySegments.ofArray(arr);
         MemoryAddress base = region.baseAddress();
         initTuples(base, tuples.elementCount().getAsLong());
 
-        ByteBuffer bb = region.asByteBuffer();
+        ByteBuffer bb = MemorySegments.asByteBuffer(region);
         checkTuples(base, bb, tuples.elementCount().getAsLong());
     }
 
     @Test
     public void testChannel() throws Throwable {
@@ -220,35 +212,35 @@
         f.deleteOnExit();
 
         //write to channel
         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -> {
-                MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
+                MemorySegment segment = MemorySegments.ofByteBuffer(mbb);
                 MemoryAddress base = segment.baseAddress();
                 initTuples(base, tuples.elementCount().getAsLong());
                 mbb.force();
             });
         }
 
         //read from channel
         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -> {
-                MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
+                MemorySegment segment = MemorySegments.ofByteBuffer(mbb);
                 MemoryAddress base = segment.baseAddress();
                 checkTuples(base, mbb, tuples.elementCount().getAsLong());
             });
         }
     }
 
     @Test
     public void testDefaultAccessModesMappedSegment() throws Throwable {
-        try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {
+        try (MappedMemorySegment segment = MemorySegments.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {
             assertTrue(segment.hasAccessModes(ALL_ACCESS));
             assertEquals(segment.accessModes(), ALL_ACCESS);
         }
 
-        try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {
+        try (MappedMemorySegment segment = MemorySegments.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {
             assertTrue(segment.hasAccessModes(ALL_ACCESS & ~WRITE));
             assertEquals(segment.accessModes(), ALL_ACCESS & ~WRITE);
         }
     }
 
@@ -257,20 +249,20 @@
         File f = new File("test2.out");
         f.createNewFile();
         f.deleteOnExit();
 
         //write to channel
-        try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
+        try (MappedMemorySegment segment = MemorySegments.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
             MemoryAddress base = segment.baseAddress();
             initTuples(base, tuples.elementCount().getAsLong());
             segment.force();
         }
 
         //read from channel
-        try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
+        try (MemorySegment segment = MemorySegments.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
             MemoryAddress base = segment.baseAddress();
-            checkTuples(base, segment.asByteBuffer(), tuples.elementCount().getAsLong());
+            checkTuples(base, MemorySegments.asByteBuffer(segment), tuples.elementCount().getAsLong());
         }
     }
 
     @Test
     public void testMappedSegmentOffset() throws Throwable {
@@ -281,23 +273,23 @@
         MemoryLayout tupleLayout = tuples.elementLayout();
 
         // write one at a time
         for (int i = 0 ; i < tuples.byteSize() ; i += tupleLayout.byteSize()) {
             //write to channel
-            try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
+            try (MappedMemorySegment segment = MemorySegments.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
                 MemoryAddress base = segment.baseAddress();
                 initTuples(base, 1);
                 segment.force();
             }
         }
 
         // check one at a time
         for (int i = 0 ; i < tuples.byteSize() ; i += tupleLayout.byteSize()) {
             //read from channel
-            try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
+            try (MemorySegment segment = MemorySegments.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
                 MemoryAddress base = segment.baseAddress();
-                checkTuples(base, segment.asByteBuffer(), 1);
+                checkTuples(base, MemorySegments.asByteBuffer(segment), 1);
             }
         }
     }
 
     static void withMappedBuffer(FileChannel channel, FileChannel.MapMode mode, long pos, long size, Consumer<MappedByteBuffer> action) throws Throwable {
@@ -320,13 +312,13 @@
     }
 
     @Test(dataProvider = "bufferOps")
     public void testScopedBuffer(Function<ByteBuffer, Buffer> bufferFactory, Map<Method, Object[]> members) {
         Buffer bb;
-        try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(bytes)) {
             MemoryAddress base = segment.baseAddress();
-            bb = bufferFactory.apply(segment.asByteBuffer());
+            bb = bufferFactory.apply(MemorySegments.asByteBuffer(segment));
         }
         //outside of scope!!
         for (Map.Entry<Method, Object[]> e : members.entrySet()) {
             if (!e.getKey().getName().contains("get") &&
                             !e.getKey().getName().contains("put")) {
@@ -353,12 +345,12 @@
     }
 
     @Test(dataProvider = "bufferHandleOps")
     public void testScopedBufferAndVarHandle(VarHandle bufferHandle) {
         ByteBuffer bb;
-        try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
-            bb = segment.asByteBuffer();
+        try (MemorySegment segment = MemorySegments.allocateNative(bytes)) {
+            bb = MemorySegments.asByteBuffer(segment);
             for (Map.Entry<MethodHandle, Object[]> e : varHandleMembers(bb, bufferHandle).entrySet()) {
                 MethodHandle handle = e.getKey().bindTo(bufferHandle)
                         .asSpreader(Object[].class, e.getValue().length);
                 try {
                     handle.invoke(e.getValue());
@@ -386,186 +378,186 @@
         }
     }
 
     @Test(dataProvider = "bufferOps")
     public void testDirectBuffer(Function<ByteBuffer, Buffer> bufferFactory, Map<Method, Object[]> members) {
-        try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(bytes)) {
             MemoryAddress base = segment.baseAddress();
-            Buffer bb = bufferFactory.apply(segment.asByteBuffer());
+            Buffer bb = bufferFactory.apply(MemorySegments.asByteBuffer(segment));
             assertTrue(bb.isDirect());
             DirectBuffer directBuffer = ((DirectBuffer)bb);
             assertEquals(directBuffer.address(), ((MemoryAddressImpl)base).unsafeGetOffset());
             assertTrue((directBuffer.attachment() == null) == (bb instanceof ByteBuffer));
             assertTrue(directBuffer.cleaner() == null);
         }
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeOffheap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
-        try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(seq)) {
             MemoryAddress base = segment.baseAddress();
             initializer.accept(base);
             checker.accept(base);
         }
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
-        MemoryAddress base = MemorySegment.ofArray(new byte[capacity]).baseAddress();
+        MemoryAddress base = MemorySegments.ofArray(new byte[capacity]).baseAddress();
         initializer.accept(base);
         checker.accept(base);
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeBuffer(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
-        MemoryAddress base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity])).baseAddress();
+        MemoryAddress base = MemorySegments.ofByteBuffer(ByteBuffer.wrap(new byte[capacity])).baseAddress();
         initializer.accept(base);
         checker.accept(base);
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeRoundtripHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
         byte[] arr = new byte[capacity];
-        MemorySegment segment = MemorySegment.ofArray(arr);
+        MemorySegment segment = MemorySegments.ofArray(arr);
         MemoryAddress first = segment.baseAddress();
         initializer.accept(first);
-        MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();
+        MemoryAddress second = MemorySegments.ofByteBuffer(MemorySegments.asByteBuffer(segment)).baseAddress();
         checker.accept(second);
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeRoundtripNative(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
-        try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(seq)) {
             MemoryAddress first = segment.baseAddress();
             initializer.accept(first);
-            MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();
+            MemoryAddress second = MemorySegments.ofByteBuffer(MemorySegments.asByteBuffer(segment)).baseAddress();
             checker.accept(second);
         }
     }
 
     @Test(expectedExceptions = IllegalStateException.class)
     public void testBufferOnClosedScope() {
         MemorySegment leaked;
-        try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(bytes)) {
             leaked = segment;
         }
-        ByteBuffer byteBuffer = leaked.asByteBuffer(); // ok
+        ByteBuffer byteBuffer = MemorySegments.asByteBuffer(leaked); // ok
         byteBuffer.get(); // should throw
     }
 
     @Test(expectedExceptions = { UnsupportedOperationException.class,
                                  IllegalArgumentException.class })
     public void testTooBigForByteBuffer() {
-        try (MemorySegment segment = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L)) {
-            segment.asByteBuffer();
+        try (MemorySegment segment = MemorySegments.allocateNative((long)Integer.MAX_VALUE + 10L)) {
+            MemorySegments.asByteBuffer(segment);
         }
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadMapNegativeSize() throws IOException {
         File f = new File("testNeg1.out");
         f.createNewFile();
         f.deleteOnExit();
-        MemorySegment.mapFromPath(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE);
+        MemorySegments.mapFromPath(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadMapNegativeOffset() throws IOException {
         File f = new File("testNeg2.out");
         f.createNewFile();
         f.deleteOnExit();
-        MemorySegment.mapFromPath(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE);
+        MemorySegments.mapFromPath(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE);
     }
 
     public void testMapZeroSize() throws IOException {
         File f = new File("testPos1.out");
         f.createNewFile();
         f.deleteOnExit();
-        try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE)) {
+        try (MemorySegment segment = MemorySegments.mapFromPath(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE)) {
             assertEquals(segment.byteSize(), 0);
         }
     }
 
     @Test(dataProvider="resizeOps")
     public void testCopyHeapToNative(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int bytes = (int)seq.byteSize();
-        try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
-             MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
+        try (MemorySegment nativeArray = MemorySegments.allocateNative(bytes);
+             MemorySegment heapArray = MemorySegments.ofArray(new byte[bytes])) {
             initializer.accept(heapArray.baseAddress());
-            nativeArray.copyFrom(heapArray);
+            MemorySegments.copy(heapArray, nativeArray);
             checker.accept(nativeArray.baseAddress());
         }
     }
 
     @Test(dataProvider="resizeOps")
     public void testCopyNativeToHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int bytes = (int)seq.byteSize();
-        try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
-             MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
+        try (MemorySegment nativeArray = MemorySegments.allocateNative(seq);
+             MemorySegment heapArray = MemorySegments.ofArray(new byte[bytes])) {
             initializer.accept(nativeArray.baseAddress());
-            heapArray.copyFrom(nativeArray);
+            MemorySegments.copy(nativeArray, heapArray);
             checker.accept(heapArray.baseAddress());
         }
     }
 
     @Test
     public void testDefaultAccessModesOfBuffer() {
         ByteBuffer rwBuffer = ByteBuffer.wrap(new byte[4]);
-        try (MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer)) {
+        try (MemorySegment segment = MemorySegments.ofByteBuffer(rwBuffer)) {
             assertTrue(segment.hasAccessModes(ALL_ACCESS));
             assertEquals(segment.accessModes(), ALL_ACCESS);
         }
 
         ByteBuffer roBuffer = rwBuffer.asReadOnlyBuffer();
-        try (MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer)) {
+        try (MemorySegment segment = MemorySegments.ofByteBuffer(roBuffer)) {
             assertTrue(segment.hasAccessModes(ALL_ACCESS & ~WRITE));
             assertEquals(segment.accessModes(), ALL_ACCESS & ~WRITE);
         }
     }
 
     @Test(dataProvider="bufferSources")
     public void testBufferToSegment(ByteBuffer bb, Predicate<MemorySegment> segmentChecker) {
-        MemorySegment segment = MemorySegment.ofByteBuffer(bb);
+        MemorySegment segment = MemorySegments.ofByteBuffer(bb);
         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
         assertTrue(segmentChecker.test(segment));
         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
         assertEquals(bb.capacity(), segment.byteSize());
         //another round trip
-        segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());
+        segment = MemorySegments.ofByteBuffer(MemorySegments.asByteBuffer(segment));
         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
         assertTrue(segmentChecker.test(segment));
         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
         assertEquals(bb.capacity(), segment.byteSize());
     }
 
     @Test
     public void testRoundTripAccess() {
-        try(MemorySegment ms = MemorySegment.allocateNative(4)) {
+        try(MemorySegment ms = MemorySegments.allocateNative(4)) {
             MemorySegment msNoAccess = ms.withAccessModes(MemorySegment.READ); // READ is required to make BB
-            MemorySegment msRoundTrip = MemorySegment.ofByteBuffer(msNoAccess.asByteBuffer());
+            MemorySegment msRoundTrip = MemorySegments.ofByteBuffer(MemorySegments.asByteBuffer(msNoAccess));
             assertEquals(msNoAccess.accessModes(), msRoundTrip.accessModes());
         }
     }
 
     @Test(expectedExceptions = IllegalStateException.class)
     public void testDeadAccessOnClosedBufferSegment() {
-        MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT);
-        MemorySegment s2 = MemorySegment.ofByteBuffer(s1.asByteBuffer());
+        MemorySegment s1 = MemorySegments.allocateNative(MemoryLayouts.JAVA_INT);
+        MemorySegment s2 = MemorySegments.ofByteBuffer(MemorySegments.asByteBuffer(s1));
 
         s1.close(); // memory freed
 
-        intHandle.set(s2.baseAddress(), 0L, 10); // Dead access!
+        MemorySegments.setInt(s2.baseAddress(), 0L, 10); // Dead access!
     }
 
     @DataProvider(name = "bufferOps")
     public static Object[][] bufferOps() throws Throwable {
         return new Object[][]{
@@ -622,38 +614,38 @@
     }
 
     @DataProvider(name = "resizeOps")
     public Object[][] resizeOps() {
         Consumer<MemoryAddress> byteInitializer =
-                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));
+                (base) -> initBytes(base, bytes, (addr, pos) -> MemorySegments.setByte_BE(addr, pos, (byte)(long)pos));
         Consumer<MemoryAddress> charInitializer =
-                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));
+                (base) -> initBytes(base, chars, (addr, pos) -> MemorySegments.setChar_BE(addr, pos * 2, (char)(long)pos));
         Consumer<MemoryAddress> shortInitializer =
-                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));
+                (base) -> initBytes(base, shorts, (addr, pos) -> MemorySegments.setShort_BE(addr, pos * 2, (short)(long)pos));
         Consumer<MemoryAddress> intInitializer =
-                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));
+                (base) -> initBytes(base, ints, (addr, pos) -> MemorySegments.setInt_BE(addr, pos * 4, (int)(long)pos));
         Consumer<MemoryAddress> floatInitializer =
-                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));
+                (base) -> initBytes(base, floats, (addr, pos) -> MemorySegments.setFloat_BE(addr, pos * 4, (float)(long)pos));
         Consumer<MemoryAddress> longInitializer =
-                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));
+                (base) -> initBytes(base, longs, (addr, pos) -> MemorySegments.setLong_BE(addr, pos * 8, (long)pos));
         Consumer<MemoryAddress> doubleInitializer =
-                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));
+                (base) -> initBytes(base, doubles, (addr, pos) -> MemorySegments.setDouble_BE(addr, pos * 8, (double)(long)pos));
 
         Consumer<MemoryAddress> byteChecker =
-                (base) -> checkBytes(base, bytes, Function.identity(), byteHandle::get, ByteBuffer::get);
+                (base) -> checkBytes(base, bytes, Function.identity(), MemorySegments::getByte_BE, ByteBuffer::get);
         Consumer<MemoryAddress> charChecker =
-                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, charHandle::get, CharBuffer::get);
+                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -> MemorySegments.getChar_BE(addr, pos * 2), CharBuffer::get);
         Consumer<MemoryAddress> shortChecker =
-                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, shortHandle::get, ShortBuffer::get);
+                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -> MemorySegments.getShort_BE(addr, pos * 2), ShortBuffer::get);
         Consumer<MemoryAddress> intChecker =
-                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, intHandle::get, IntBuffer::get);
+                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -> MemorySegments.getInt_BE(addr, pos * 4), IntBuffer::get);
         Consumer<MemoryAddress> floatChecker =
-                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, floatHandle::get, FloatBuffer::get);
+                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -> MemorySegments.getFloat_BE(addr, pos * 4), FloatBuffer::get);
         Consumer<MemoryAddress> longChecker =
-                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, longHandle::get, LongBuffer::get);
+                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -> MemorySegments.getLong_BE(addr, pos * 8), LongBuffer::get);
         Consumer<MemoryAddress> doubleChecker =
-                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, doubleHandle::get, DoubleBuffer::get);
+                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -> MemorySegments.getDouble_BE(addr, pos * 8), DoubleBuffer::get);
 
         return new Object[][]{
                 {byteChecker, byteInitializer, bytes},
                 {charChecker, charInitializer, chars},
                 {shortChecker, shortInitializer, shorts},
diff a/test/jdk/java/foreign/TestLayouts.java b/test/jdk/java/foreign/TestLayouts.java
--- a/test/jdk/java/foreign/TestLayouts.java
+++ b/test/jdk/java/foreign/TestLayouts.java
@@ -33,10 +33,11 @@
 import java.nio.ByteOrder;
 import java.util.function.LongFunction;
 import java.util.stream.Stream;
 
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import jdk.incubator.foreign.SequenceLayout;
 import org.testng.annotations.*;
 import static org.testng.Assert.*;
 
 public class TestLayouts {
@@ -60,11 +61,11 @@
         assertFalse(layout.hasSize());
         VarHandle size_handle = layout.varHandle(int.class, MemoryLayout.PathElement.groupElement("size"));
         VarHandle array_elem_handle = layout.varHandle(double.class,
                 MemoryLayout.PathElement.groupElement("arr"),
                 MemoryLayout.PathElement.sequenceElement());
-        try (MemorySegment segment = MemorySegment.allocateNative(
+        try (MemorySegment segment = MemorySegments.allocateNative(
                 layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement("arr")))) {
             size_handle.set(segment.baseAddress(), 4);
             for (int i = 0 ; i < 4 ; i++) {
                 array_elem_handle.set(segment.baseAddress(), i, (double)i);
             }
@@ -86,11 +87,11 @@
         VarHandle size_handle = layout.varHandle(int.class, MemoryLayout.PathElement.groupElement("size"));
         VarHandle array_elem_handle = layout.varHandle(double.class,
                 MemoryLayout.PathElement.groupElement("arr"),
                 MemoryLayout.PathElement.sequenceElement(0),
                 MemoryLayout.PathElement.sequenceElement());
-        try (MemorySegment segment = MemorySegment.allocateNative(
+        try (MemorySegment segment = MemorySegments.allocateNative(
                 layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement("arr"), MemoryLayout.PathElement.sequenceElement()))) {
             size_handle.set(segment.baseAddress(), 4);
             for (int i = 0 ; i < 4 ; i++) {
                 array_elem_handle.set(segment.baseAddress(), i, (double)i);
             }
@@ -103,11 +104,11 @@
     }
 
     @Test
     public void testIndexedSequencePath() {
         MemoryLayout seq = MemoryLayout.ofSequence(10, MemoryLayouts.JAVA_INT);
-        try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(seq)) {
             VarHandle indexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement());
             // init segment
             for (int i = 0 ; i < 10 ; i++) {
                 indexHandle.set(segment.baseAddress(), (long)i, i);
             }
diff a/test/jdk/java/foreign/TestMemoryAccess.java b/test/jdk/java/foreign/TestMemoryAccess.java
--- a/test/jdk/java/foreign/TestMemoryAccess.java
+++ b/test/jdk/java/foreign/TestMemoryAccess.java
@@ -32,10 +32,11 @@
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import java.lang.invoke.VarHandle;
 import java.util.function.Function;
@@ -81,11 +82,11 @@
         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);
     }
 
     private void testAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout layout, VarHandle handle, Checker checker) {
         MemoryAddress outer_address;
-        try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout))) {
+        try (MemorySegment segment = viewFactory.apply(MemorySegments.allocateNative(layout))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
             MemoryAddress addr = segment.baseAddress();
             try {
                 checker.check(handle, addr);
                 if (isRO) {
@@ -113,11 +114,11 @@
         }
     }
 
     private void testArrayAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, SequenceLayout seq, VarHandle handle, ArrayChecker checker) {
         MemoryAddress outer_address;
-        try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
+        try (MemorySegment segment = viewFactory.apply(MemorySegments.allocateNative(seq))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
             MemoryAddress addr = segment.baseAddress();
             try {
                 for (int i = 0; i < seq.elementCount().getAsLong(); i++) {
                     checker.check(handle, addr, i);
@@ -182,11 +183,11 @@
         l.varHandle(carrier);
     }
 
     private void testMatrixAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, SequenceLayout seq, VarHandle handle, MatrixChecker checker) {
         MemoryAddress outer_address;
-        try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
+        try (MemorySegment segment = viewFactory.apply(MemorySegments.allocateNative(seq))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
             MemoryAddress addr = segment.baseAddress();
             try {
                 for (int i = 0; i < seq.elementCount().getAsLong(); i++) {
                     for (int j = 0; j < ((SequenceLayout) seq.elementLayout()).elementCount().getAsLong(); j++) {
diff a/test/jdk/java/foreign/TestMemoryAlignment.java b/test/jdk/java/foreign/TestMemoryAlignment.java
--- a/test/jdk/java/foreign/TestMemoryAlignment.java
+++ b/test/jdk/java/foreign/TestMemoryAlignment.java
@@ -31,10 +31,11 @@
 
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
 import java.lang.invoke.VarHandle;
 import java.util.stream.LongStream;
 
@@ -48,11 +49,11 @@
         ValueLayout layout = MemoryLayouts.BITS_32_BE;
         assertEquals(layout.bitAlignment(), 32);
         ValueLayout aligned = layout.withBitAlignment(align);
         assertEquals(aligned.bitAlignment(), align); //unreasonable alignment here, to make sure access throws
         VarHandle vh = aligned.varHandle(int.class);
-        try (MemorySegment segment = MemorySegment.allocateNative(aligned)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(aligned)) {
             MemoryAddress addr = segment.baseAddress();
             vh.set(addr, -42);
             int val = (int)vh.get(addr);
             assertEquals(val, -42);
         }
@@ -64,11 +65,11 @@
         assertEquals(layout.bitAlignment(), 32);
         ValueLayout aligned = layout.withBitAlignment(align);
         MemoryLayout alignedGroup = MemoryLayout.ofStruct(MemoryLayouts.PAD_8, aligned);
         assertEquals(alignedGroup.bitAlignment(), align);
         VarHandle vh = aligned.varHandle(int.class);
-        try (MemorySegment segment = MemorySegment.allocateNative(alignedGroup)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(alignedGroup)) {
             MemoryAddress addr = segment.baseAddress();
             vh.set(addr.addOffset(1L), -42);
             assertEquals(align, 8); //this is the only case where access is aligned
         } catch (IllegalStateException ex) {
             assertNotEquals(align, 8); //if align != 8, access is always unaligned
@@ -91,11 +92,11 @@
     @Test(dataProvider = "alignments")
     public void testUnalignedSequence(long align) {
         SequenceLayout layout = MemoryLayout.ofSequence(5, MemoryLayouts.BITS_32_BE.withBitAlignment(align));
         try {
             VarHandle vh = layout.varHandle(int.class, PathElement.sequenceElement());
-            try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
+            try (MemorySegment segment = MemorySegments.allocateNative(layout)) {
                 MemoryAddress addr = segment.baseAddress();
                 for (long i = 0 ; i < 5 ; i++) {
                     vh.set(addr, i, -42);
                 }
             }
@@ -115,11 +116,11 @@
                                vInt.withBitAlignment(8).withName("c"));
         assertEquals(g.bitAlignment(), 8);
         VarHandle vh_c = g.varHandle(byte.class, PathElement.groupElement("a"));
         VarHandle vh_s = g.varHandle(short.class, PathElement.groupElement("b"));
         VarHandle vh_i = g.varHandle(int.class, PathElement.groupElement("c"));
-        try (MemorySegment segment = MemorySegment.allocateNative(g)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(g)) {
             MemoryAddress addr = segment.baseAddress();
             vh_c.set(addr, Byte.MIN_VALUE);
             assertEquals(vh_c.get(addr), Byte.MIN_VALUE);
             vh_s.set(addr, Short.MIN_VALUE);
             assertEquals(vh_s.get(addr), Short.MIN_VALUE);
diff a/test/jdk/java/foreign/TestMemoryCopy.java b/test/jdk/java/foreign/TestMemoryCopy.java
--- a/test/jdk/java/foreign/TestMemoryCopy.java
+++ b/test/jdk/java/foreign/TestMemoryCopy.java
@@ -28,10 +28,11 @@
  */
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -55,22 +56,22 @@
         }
         for (int i = 0 ; i < size ; i++) {
             BYTE_HANDLE.set(addr1.addOffset(i), (byte) i);
         }
         //perform copy
-        s2.segment.copyFrom(s1.segment.asSlice(0, size));
+        MemorySegments.copy(s1.segment.asSlice(0, size), s2.segment);
         //check that copy actually worked
         for (int i = 0 ; i < size ; i++) {
             assertEquals((byte)i, BYTE_HANDLE.get(addr2.addOffset(i)));
         }
     }
 
     static class SegmentSlice {
 
         enum Kind {
-            NATIVE(MemorySegment::allocateNative),
-            ARRAY(i -> MemorySegment.ofArray(new byte[i]));
+            NATIVE(MemorySegments::allocateNative),
+            ARRAY(i -> MemorySegments.ofArray(new byte[i]));
 
             final IntFunction<MemorySegment> segmentFactory;
 
             Kind(IntFunction<MemorySegment> segmentFactory) {
                 this.segmentFactory = segmentFactory;
diff a/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java b/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
--- a/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
+++ b/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
@@ -31,10 +31,12 @@
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
 import java.util.Arrays;
 import java.util.stream.IntStream;
 import java.util.stream.LongStream;
+
+import jdk.incubator.foreign.MemorySegments;
 import org.testng.annotations.*;
 import static java.nio.ByteOrder.BIG_ENDIAN;
 import static org.testng.Assert.*;
 
 /*
@@ -56,11 +58,11 @@
 
         MemoryLayout layout = MemoryLayouts.BITS_8_BE;
         VarHandle byteHandle = layout.varHandle(byte.class);
         VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
 
-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(layout)) {
             intHandle.set(segment.baseAddress(), intValue);
             int expectedIntValue = Byte.toUnsignedInt(byteValue);
             assertEquals((int) intHandle.get(segment.baseAddress()), expectedIntValue);
             assertEquals((byte) byteHandle.get(segment.baseAddress()), byteValue);
         }
@@ -78,11 +80,11 @@
 
         MemoryLayout layout = MemoryLayouts.BITS_8_BE;
         VarHandle byteHandle = layout.varHandle(byte.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(byteHandle, long.class);
 
-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(layout)) {
             longHandle.set(segment.baseAddress(), longValue);
             long expectedLongValue = Byte.toUnsignedLong(byteValue);
             assertEquals((long) longHandle.get(segment.baseAddress()), expectedLongValue);
             assertEquals((byte) byteHandle.get(segment.baseAddress()), byteValue);
         }
@@ -100,11 +102,11 @@
 
         MemoryLayout layout = MemoryLayouts.BITS_16_BE;
         VarHandle shortHandle = layout.varHandle(short.class);
         VarHandle intHandle = MemoryHandles.asUnsigned(shortHandle, int.class);
 
-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(layout)) {
             intHandle.set(segment.baseAddress(), intValue);
             int expectedIntValue = Short.toUnsignedInt(shortValue);
             assertEquals((int) intHandle.get(segment.baseAddress()), expectedIntValue);
             assertEquals((short) shortHandle.get(segment.baseAddress()), shortValue);
         }
@@ -122,11 +124,11 @@
 
         MemoryLayout layout = MemoryLayouts.BITS_16_BE;
         VarHandle shortHandle = layout.varHandle(short.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(shortHandle, long.class);
 
-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(layout)) {
             longHandle.set(segment.baseAddress(), longValue);
             long expectedLongValue = Short.toUnsignedLong(shortValue);
             assertEquals((long) longHandle.get(segment.baseAddress()), expectedLongValue);
             assertEquals((short) shortHandle.get(segment.baseAddress()), shortValue);
         }
@@ -148,11 +150,11 @@
 
         MemoryLayout layout = MemoryLayouts.BITS_32_BE;
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(intHandle, long.class);
 
-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(layout)) {
             longHandle.set(segment.baseAddress(), longValue);
             long expectedLongValue = Integer.toUnsignedLong(intValue);
             assertEquals((long) longHandle.get(segment.baseAddress()), expectedLongValue);
             assertEquals((int) intHandle.get(segment.baseAddress()), intValue);
         }
@@ -162,22 +164,22 @@
     public void testCoordinatesSequenceLayout() {
         MemoryLayout layout = MemoryLayout.ofSequence(2, MemoryLayouts.BITS_8_BE);
         VarHandle byteHandle = layout.varHandle(byte.class, PathElement.sequenceElement());
         VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
 
-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(layout)) {
             intHandle.set(segment.baseAddress(), 0L, (int) -1);
             assertEquals((int) intHandle.get(segment.baseAddress(), 0L), 255);
             intHandle.set(segment.baseAddress(), 1L, (int) 200);
             assertEquals((int) intHandle.get(segment.baseAddress(), 1L), 200);
         }
     }
 
     @Test
     public void testCoordinatesStride() {
         byte[] arr = { 0, 0, (byte) 129, 0 };
-        MemorySegment segment = MemorySegment.ofArray(arr);
+        MemorySegment segment = MemorySegments.ofArray(arr);
         MemoryAddress addr = segment.baseAddress();
 
         {
             VarHandle byteHandle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
             VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
diff a/test/jdk/java/foreign/TestMismatch.java b/test/jdk/java/foreign/TestMismatch.java
--- a/test/jdk/java/foreign/TestMismatch.java
+++ b/test/jdk/java/foreign/TestMismatch.java
@@ -32,10 +32,11 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.IntFunction;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 import static java.lang.System.out;
 import static jdk.incubator.foreign.MemorySegment.READ;
 import static org.testng.Assert.assertEquals;
@@ -59,19 +60,19 @@
         out.format("testSameValues s1:%s, s2:%s\n", ss1, ss2);
         MemorySegment s1 = initializeSegment(ss1);
         MemorySegment s2 = initializeSegment(ss2);
 
         if (s1.byteSize() == s2.byteSize()) {
-            assertEquals(s1.mismatch(s2), -1);  // identical
-            assertEquals(s2.mismatch(s1), -1);
+            assertEquals(MemorySegments.mismatch(s1, s2), -1);  // identical
+            assertEquals(MemorySegments.mismatch(s2, s1), -1);
         } else if (s1.byteSize() > s2.byteSize()) {
-            assertEquals(s1.mismatch(s2), s2.byteSize());  // proper prefix
-            assertEquals(s2.mismatch(s1), s2.byteSize());
+            assertEquals(MemorySegments.mismatch(s1, s2), s2.byteSize());  // proper prefix
+            assertEquals(MemorySegments.mismatch(s2, s1), s2.byteSize());
         } else {
             assert s1.byteSize() < s2.byteSize();
-            assertEquals(s1.mismatch(s2), s1.byteSize());  // proper prefix
-            assertEquals(s2.mismatch(s1), s1.byteSize());
+            assertEquals(MemorySegments.mismatch(s1, s2), s1.byteSize());  // proper prefix
+            assertEquals(MemorySegments.mismatch(s2, s1), s1.byteSize());
         }
     }
 
     @Test(dataProvider = "slices")
     public void testDifferentValues(MemorySegment s1, MemorySegment s2) {
@@ -82,42 +83,42 @@
         for (long i = s2.byteSize() -1 ; i >= 0; i--) {
             long expectedMismatchOffset = i;
             BYTE_HANDLE.set(s2.baseAddress().addOffset(i), (byte) 0xFF);
 
             if (s1.byteSize() == s2.byteSize()) {
-                assertEquals(s1.mismatch(s2), expectedMismatchOffset);
-                assertEquals(s2.mismatch(s1), expectedMismatchOffset);
+                assertEquals(MemorySegments.mismatch(s1, s2), expectedMismatchOffset);
+                assertEquals(MemorySegments.mismatch(s2, s1), expectedMismatchOffset);
             } else if (s1.byteSize() > s2.byteSize()) {
-                assertEquals(s1.mismatch(s2), expectedMismatchOffset);
-                assertEquals(s2.mismatch(s1), expectedMismatchOffset);
+                assertEquals(MemorySegments.mismatch(s1, s2), expectedMismatchOffset);
+                assertEquals(MemorySegments.mismatch(s2, s1), expectedMismatchOffset);
             } else {
                 assert s1.byteSize() < s2.byteSize();
                 var off = Math.min(s1.byteSize(), expectedMismatchOffset);
-                assertEquals(s1.mismatch(s2), off);  // proper prefix
-                assertEquals(s2.mismatch(s1), off);
+                assertEquals(MemorySegments.mismatch(s1, s2), off);  // proper prefix
+                assertEquals(MemorySegments.mismatch(s2, s1), off);
             }
         }
     }
 
     @Test
     public void testEmpty() {
-        var s1 = MemorySegment.ofArray(new byte[0]);
-        assertEquals(s1.mismatch(s1), -1);
-        try (var nativeSegment = MemorySegment.allocateNative(4)) {
+        var s1 = MemorySegments.ofArray(new byte[0]);
+        assertEquals(MemorySegments.mismatch(s1, s1), -1);
+        try (var nativeSegment = MemorySegments.allocateNative(4)) {
             var s2 = nativeSegment.asSlice(0, 0);
-            assertEquals(s1.mismatch(s2), -1);
-            assertEquals(s2.mismatch(s1), -1);
+            assertEquals(MemorySegments.mismatch(s1, s2), -1);
+            assertEquals(MemorySegments.mismatch(s2, s1), -1);
         }
     }
 
     @Test
     public void testLarge() {
-        try (var s1 = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L);
-             var s2 = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L)) {
-            assertEquals(s1.mismatch(s1), -1);
-            assertEquals(s1.mismatch(s2), -1);
-            assertEquals(s2.mismatch(s1), -1);
+        try (var s1 = MemorySegments.allocateNative((long)Integer.MAX_VALUE + 10L);
+             var s2 = MemorySegments.allocateNative((long)Integer.MAX_VALUE + 10L)) {
+            assertEquals(MemorySegments.mismatch(s1, s1), -1);
+            assertEquals(MemorySegments.mismatch(s1, s2), -1);
+            assertEquals(MemorySegments.mismatch(s2, s1), -1);
 
             testLargeAcrossMaxBoundary(s1, s2);
 
             testLargeMismatchAcrossMaxBoundary(s1, s2);
         }
@@ -125,64 +126,64 @@
 
     private void testLargeAcrossMaxBoundary(MemorySegment s1, MemorySegment s2) {
         for (long i = s2.byteSize() -1 ; i >= Integer.MAX_VALUE - 10L; i--) {
             var s3 = s1.asSlice(0, i);
             var s4 = s2.asSlice(0, i);
-            assertEquals(s3.mismatch(s3), -1);
-            assertEquals(s3.mismatch(s4), -1);
-            assertEquals(s4.mismatch(s3), -1);
+            assertEquals(MemorySegments.mismatch(s3, s3), -1);
+            assertEquals(MemorySegments.mismatch(s3, s4), -1);
+            assertEquals(MemorySegments.mismatch(s4, s3), -1);
         }
     }
 
     private void testLargeMismatchAcrossMaxBoundary(MemorySegment s1, MemorySegment s2) {
         for (long i = s2.byteSize() -1 ; i >= Integer.MAX_VALUE - 10L; i--) {
             BYTE_HANDLE.set(s2.baseAddress().addOffset(i), (byte) 0xFF);
             long expectedMismatchOffset = i;
-            assertEquals(s1.mismatch(s2), expectedMismatchOffset);
-            assertEquals(s2.mismatch(s1), expectedMismatchOffset);
+            assertEquals(MemorySegments.mismatch(s1, s2), expectedMismatchOffset);
+            assertEquals(MemorySegments.mismatch(s2, s1), expectedMismatchOffset);
         }
     }
 
     static final Class<IllegalStateException> ISE = IllegalStateException.class;
     static final Class<UnsupportedOperationException> UOE = UnsupportedOperationException.class;
 
     @Test
     public void testClosed() {
-        var s1 = MemorySegment.ofArray(new byte[4]);
-        var s2 = MemorySegment.ofArray(new byte[4]);
+        var s1 = MemorySegments.ofArray(new byte[4]);
+        var s2 = MemorySegments.ofArray(new byte[4]);
         s1.close();
-        assertThrows(ISE, () -> s1.mismatch(s1));
-        assertThrows(ISE, () -> s1.mismatch(s2));
-        assertThrows(ISE, () -> s2.mismatch(s1));
+        assertThrows(ISE, () -> MemorySegments.mismatch(s1, s1));
+        assertThrows(ISE, () -> MemorySegments.mismatch(s1, s2));
+        assertThrows(ISE, () -> MemorySegments.mismatch(s2, s1));
     }
 
     @Test
     public void testInsufficientAccessModes() {
-        var s1 = MemorySegment.ofArray(new byte[4]);
-        var s2 = MemorySegment.ofArray(new byte[4]);
+        var s1 = MemorySegments.ofArray(new byte[4]);
+        var s2 = MemorySegments.ofArray(new byte[4]);
         var s1WithoutRead = s1.withAccessModes(s1.accessModes() & ~READ);
         var s2WithoutRead = s2.withAccessModes(s2.accessModes() & ~READ);
 
-        assertThrows(UOE, () -> s1.mismatch(s2WithoutRead));
-        assertThrows(UOE, () -> s1WithoutRead.mismatch(s2));
-        assertThrows(UOE, () -> s1WithoutRead.mismatch(s2WithoutRead));
+        assertThrows(UOE, () -> MemorySegments.mismatch(s1, s2WithoutRead));
+        assertThrows(UOE, () -> MemorySegments.mismatch(s1WithoutRead, s2));
+        assertThrows(UOE, () -> MemorySegments.mismatch(s1WithoutRead, s2WithoutRead));
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testNull() {
-        var segment = MemorySegment.ofArray(new byte[4]);
-        segment.mismatch(null);
+        var segment = MemorySegments.ofArray(new byte[4]);
+        MemorySegments.mismatch(segment, null);
     }
 
     @Test
     public void testThreadAccess() throws Exception {
-        var segment = MemorySegment.ofArray(new byte[4]);
+        var segment = MemorySegments.ofArray(new byte[4]);
         {
             AtomicReference<RuntimeException> exception = new AtomicReference<>();
             Runnable action = () -> {
                 try {
-                    MemorySegment.ofArray(new byte[4]).mismatch(segment);
+                    MemorySegments.mismatch(MemorySegments.ofArray(new byte[4]), segment);
                 } catch (RuntimeException e) {
                     exception.set(e);
                 }
             };
             Thread thread = new Thread(action);
@@ -196,11 +197,11 @@
         }
         {
             AtomicReference<RuntimeException> exception = new AtomicReference<>();
             Runnable action = () -> {
                 try {
-                    segment.mismatch(MemorySegment.ofArray(new byte[4]));
+                    MemorySegments.mismatch(segment, MemorySegments.ofArray(new byte[4]));
                 } catch (RuntimeException e) {
                     exception.set(e);
                 }
             };
             Thread thread = new Thread(action);
@@ -213,12 +214,12 @@
             }
         }
     }
 
     enum SegmentKind {
-        NATIVE(MemorySegment::allocateNative),
-        ARRAY(i -> MemorySegment.ofArray(new byte[i]));
+        NATIVE(MemorySegments::allocateNative),
+        ARRAY(i -> MemorySegments.ofArray(new byte[i]));
 
         final IntFunction<MemorySegment> segmentFactory;
 
         SegmentKind(IntFunction<MemorySegment> segmentFactory) {
             this.segmentFactory = segmentFactory;
diff a/test/jdk/java/foreign/TestNative.java b/test/jdk/java/foreign/TestNative.java
--- a/test/jdk/java/foreign/TestNative.java
+++ b/test/jdk/java/foreign/TestNative.java
@@ -32,10 +32,11 @@
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.internal.misc.Unsafe;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
@@ -110,11 +111,11 @@
                                               BiFunction<MemoryAddress, Long, Object> handleExtractor,
                                               Function<ByteBuffer, Z> bufferFactory,
                                               BiFunction<Z, Integer, Object> nativeBufferExtractor,
                                               BiFunction<Long, Integer, Object> nativeRawExtractor) {
         long nelems = layout.elementCount().getAsLong();
-        ByteBuffer bb = base.segment().asSlice(base.segmentOffset(), (int)layout.byteSize()).asByteBuffer();
+        ByteBuffer bb = MemorySegments.asByteBuffer(base.segment().asSlice(base.segmentOffset(), (int)layout.byteSize()));
         Z z = bufferFactory.apply(bb);
         for (long i = 0 ; i < nelems ; i++) {
             Object handleValue = handleExtractor.apply(base, i);
             Object bufferValue = nativeBufferExtractor.apply(z, (int)i);
             Object rawValue = nativeRawExtractor.apply(base.toRawLongValue(), (int)i);
@@ -151,33 +152,33 @@
     public static native long allocate(int size);
     public static native void free(long address);
 
     @Test(dataProvider="nativeAccessOps")
     public void testNativeAccess(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
-        try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(seq)) {
             MemoryAddress address = segment.baseAddress();
             initializer.accept(address);
             checker.accept(address);
         }
     }
 
     @Test(dataProvider="buffers")
     public void testNativeCapacity(Function<ByteBuffer, Buffer> bufferFunction, int elemSize) {
         int capacity = (int)doubles.byteSize();
-        try (MemorySegment segment = MemorySegment.allocateNative(doubles)) {
-            ByteBuffer bb = segment.asByteBuffer();
+        try (MemorySegment segment = MemorySegments.allocateNative(doubles)) {
+            ByteBuffer bb = MemorySegments.asByteBuffer(segment);
             Buffer buf = bufferFunction.apply(bb);
             int expected = capacity / elemSize;
             assertEquals(buf.capacity(), expected);
             assertEquals(getCapacity(buf), expected);
         }
     }
 
     @Test
     public void testDefaultAccessModes() {
         MemoryAddress addr = MemoryAddress.ofLong(allocate(12));
-        MemorySegment mallocSegment = MemorySegment.ofNativeRestricted(addr, 12, null,
+        MemorySegment mallocSegment = MemorySegments.ofNativeRestricted(addr, 12, null,
                 () -> free(addr.toRawLongValue()), null);
         try (MemorySegment segment = mallocSegment) {
             assertTrue(segment.hasAccessModes(ALL_ACCESS));
             assertEquals(segment.accessModes(), ALL_ACCESS);
         }
@@ -185,27 +186,27 @@
 
     @Test
     public void testMallocSegment() {
         MemoryAddress addr = MemoryAddress.ofLong(allocate(12));
         assertNull(addr.segment());
-        MemorySegment mallocSegment = MemorySegment.ofNativeRestricted(addr, 12, null,
+        MemorySegment mallocSegment = MemorySegments.ofNativeRestricted(addr, 12, null,
                 () -> free(addr.toRawLongValue()), null);
         assertEquals(mallocSegment.byteSize(), 12);
         mallocSegment.close(); //free here
         assertTrue(!mallocSegment.isAlive());
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadResize() {
-        try (MemorySegment segment = MemorySegment.allocateNative(4)) {
-            MemorySegment.ofNativeRestricted(segment.baseAddress(), 0, null, null, null);
+        try (MemorySegment segment = MemorySegments.allocateNative(4)) {
+            MemorySegments.ofNativeRestricted(segment.baseAddress(), 0, null, null, null);
         }
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testNullUnsafeSegment() {
-        MemorySegment.ofNativeRestricted(null, 10, null, null, null);
+        MemorySegments.ofNativeRestricted(null, 10, null, null, null);
     }
 
     static {
         System.loadLibrary("NativeAccess");
     }
diff a/test/jdk/java/foreign/TestNoForeignUnsafeOverride.java b/test/jdk/java/foreign/TestNoForeignUnsafeOverride.java
--- a/test/jdk/java/foreign/TestNoForeignUnsafeOverride.java
+++ b/test/jdk/java/foreign/TestNoForeignUnsafeOverride.java
@@ -29,17 +29,18 @@
  */
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 
+import jdk.incubator.foreign.MemorySegments;
 import org.testng.annotations.Test;
 
 public class TestNoForeignUnsafeOverride {
     static {
         System.setProperty("foreign.restricted", "permit");
     }
 
     @Test(expectedExceptions = IllegalAccessError.class)
     public void testUnsafeAccess() {
-        MemorySegment.ofNativeRestricted(MemoryAddress.ofLong(42), 10, null, null, null);
+        MemorySegments.ofNativeRestricted(MemoryAddress.ofLong(42), 10, null, null, null);
     }
 }
diff a/test/jdk/java/foreign/TestRebase.java b/test/jdk/java/foreign/TestRebase.java
--- a/test/jdk/java/foreign/TestRebase.java
+++ b/test/jdk/java/foreign/TestRebase.java
@@ -28,10 +28,11 @@
  */
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -82,12 +83,12 @@
     }
 
     static class SegmentSlice {
 
         enum Kind {
-            NATIVE(MemorySegment::allocateNative),
-            ARRAY(i -> MemorySegment.ofArray(new byte[i]));
+            NATIVE(MemorySegments::allocateNative),
+            ARRAY(i -> MemorySegments.ofArray(new byte[i]));
 
             final IntFunction<MemorySegment> segmentFactory;
 
             Kind(IntFunction<MemorySegment> segmentFactory) {
                 this.segmentFactory = segmentFactory;
diff a/test/jdk/java/foreign/TestSegments.java b/test/jdk/java/foreign/TestSegments.java
--- a/test/jdk/java/foreign/TestSegments.java
+++ b/test/jdk/java/foreign/TestSegments.java
@@ -28,10 +28,11 @@
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.VarHandle;
 import java.lang.reflect.Method;
@@ -51,27 +52,27 @@
 
 public class TestSegments {
 
     @Test(dataProvider = "badSizeAndAlignments", expectedExceptions = IllegalArgumentException.class)
     public void testBadAllocateAlign(long size, long align) {
-        MemorySegment.allocateNative(size, align);
+        MemorySegments.allocateNative(size, align);
     }
 
     @Test(dataProvider = "badLayouts", expectedExceptions = UnsupportedOperationException.class)
     public void testBadAllocateLayout(MemoryLayout layout) {
-        MemorySegment.allocateNative(layout);
+        MemorySegments.allocateNative(layout);
     }
 
     @Test(expectedExceptions = { OutOfMemoryError.class,
                                  IllegalArgumentException.class })
     public void testAllocateTooBig() {
-        MemorySegment.allocateNative(Long.MAX_VALUE);
+        MemorySegments.allocateNative(Long.MAX_VALUE);
     }
 
     @Test(dataProvider = "segmentOperations")
     public void testOpOutsideConfinement(SegmentMember member) throws Throwable {
-        try (MemorySegment segment = MemorySegment.allocateNative(4)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(4)) {
             AtomicBoolean failed = new AtomicBoolean(false);
             Thread t = new Thread(() -> {
                 try {
                     Object o = member.method.invoke(segment, member.params);
                     if (member.method.getName().equals("acquire")) {
@@ -90,11 +91,11 @@
 
     @Test
     public void testNativeSegmentIsZeroed() {
         VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
                 .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
-        try (MemorySegment segment = MemorySegment.allocateNative(1000)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(1000)) {
             for (long i = 0 ; i < segment.byteSize() ; i++) {
                 assertEquals(0, (byte)byteHandle.get(segment.baseAddress(), i));
             }
         }
     }
@@ -122,11 +123,11 @@
 
     @Test
     public void testSlices() {
         VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
                 .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
-        try (MemorySegment segment = MemorySegment.allocateNative(10)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(10)) {
             //init
             for (byte i = 0 ; i < segment.byteSize() ; i++) {
                 byteHandle.set(segment.baseAddress(), (long)i, i);
             }
             long start = 0;
@@ -156,11 +157,11 @@
 
     @Test(dataProvider = "accessModes")
     public void testAccessModes(int accessModes) {
         int[] arr = new int[1];
         for (AccessActions action : AccessActions.values()) {
-            MemorySegment segment = MemorySegment.ofArray(arr);
+            MemorySegment segment = MemorySegments.ofArray(arr);
             MemorySegment restrictedSegment = segment.withAccessModes(accessModes);
             assertEquals(restrictedSegment.accessModes(), accessModes);
             boolean shouldFail = !restrictedSegment.hasAccessModes(action.accessMode);
             try {
                 action.run(restrictedSegment);
@@ -172,20 +173,20 @@
     }
 
     @DataProvider(name = "segmentFactories")
     public Object[][] segmentFactories() {
         List<Supplier<MemorySegment>> l = List.of(
-                () -> MemorySegment.ofArray(new byte[] { 0x00, 0x01, 0x02, 0x03 }),
-                () -> MemorySegment.ofArray(new char[] {'a', 'b', 'c', 'd' }),
-                () -> MemorySegment.ofArray(new double[] { 1d, 2d, 3d, 4d} ),
-                () -> MemorySegment.ofArray(new float[] { 1.0f, 2.0f, 3.0f, 4.0f }),
-                () -> MemorySegment.ofArray(new int[] { 1, 2, 3, 4 }),
-                () -> MemorySegment.ofArray(new long[] { 1l, 2l, 3l, 4l } ),
-                () -> MemorySegment.ofArray(new short[] { 1, 2, 3, 4 } ),
-                () -> MemorySegment.allocateNative(4),
-                () -> MemorySegment.allocateNative(4, 8),
-                () -> MemorySegment.allocateNative(MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder()))
+                () -> MemorySegments.ofArray(new byte[] { 0x00, 0x01, 0x02, 0x03 }),
+                () -> MemorySegments.ofArray(new char[] {'a', 'b', 'c', 'd' }),
+                () -> MemorySegments.ofArray(new double[] { 1d, 2d, 3d, 4d} ),
+                () -> MemorySegments.ofArray(new float[] { 1.0f, 2.0f, 3.0f, 4.0f }),
+                () -> MemorySegments.ofArray(new int[] { 1, 2, 3, 4 }),
+                () -> MemorySegments.ofArray(new long[] { 1l, 2l, 3l, 4l } ),
+                () -> MemorySegments.ofArray(new short[] { 1, 2, 3, 4 } ),
+                () -> MemorySegments.allocateNative(4),
+                () -> MemorySegments.allocateNative(4, 8),
+                () -> MemorySegments.allocateNative(MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder()))
         );
         return l.stream().map(s -> new Object[] { s }).toArray(Object[][]::new);
     }
 
     @Test(dataProvider = "segmentFactories")
@@ -193,17 +194,18 @@
         VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
                 .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
 
         for (byte value : new byte[] {(byte) 0xFF, (byte) 0x00, (byte) 0x45}) {
             try (MemorySegment segment = memorySegmentSupplier.get()) {
-                segment.fill(value);
+                MemorySegments.fill(segment, value);
                 for (long l = 0; l < segment.byteSize(); l++) {
                     assertEquals((byte) byteHandle.get(segment.baseAddress(), l), value);
                 }
 
                 // fill a slice
-                var sliceSegment = segment.asSlice(1, segment.byteSize() - 2).fill((byte) ~value);
+                var sliceSegment = segment.asSlice(1, segment.byteSize() - 2);
+                MemorySegments.fill(sliceSegment, (byte) ~value);
                 for (long l = 0; l < sliceSegment.byteSize(); l++) {
                     assertEquals((byte) byteHandle.get(sliceSegment.baseAddress(), l), ~value);
                 }
                 // assert enclosing slice
                 assertEquals((byte) byteHandle.get(segment.baseAddress(), 0L), value);
@@ -217,27 +219,27 @@
 
     @Test(dataProvider = "segmentFactories", expectedExceptions = IllegalStateException.class)
     public void testFillClosed(Supplier<MemorySegment> memorySegmentSupplier) {
         MemorySegment segment = memorySegmentSupplier.get();
         segment.close();
-        segment.fill((byte) 0xFF);
+        MemorySegments.fill(segment, (byte) 0xFF);
     }
 
     @Test(dataProvider = "segmentFactories", expectedExceptions = UnsupportedOperationException.class)
     public void testFillIllegalAccessMode(Supplier<MemorySegment> memorySegmentSupplier) {
         try (MemorySegment segment = memorySegmentSupplier.get()) {
-            segment.withAccessModes(segment.accessModes() & ~WRITE).fill((byte) 0xFF);
+            MemorySegments.fill(segment.withAccessModes(segment.accessModes() & ~WRITE), (byte) 0xFF);
         }
     }
 
     @Test(dataProvider = "segmentFactories")
     public void testFillThread(Supplier<MemorySegment> memorySegmentSupplier) throws Exception {
         try (MemorySegment segment = memorySegmentSupplier.get()) {
             AtomicReference<RuntimeException> exception = new AtomicReference<>();
             Runnable action = () -> {
                 try {
-                    segment.fill((byte) 0xBA);
+                    MemorySegments.fill(segment, (byte) 0xBA);
                 } catch (RuntimeException e) {
                     exception.set(e);
                 }
             };
             Thread thread = new Thread(action);
@@ -251,33 +253,33 @@
         }
     }
 
     @Test
     public void testFillEmpty() {
-        MemorySegment.ofArray(new byte[] { }).fill((byte) 0xFF);
-        MemorySegment.ofArray(new byte[2]).asSlice(0, 0).fill((byte) 0xFF);
-        MemorySegment.ofByteBuffer(ByteBuffer.allocateDirect(0)).fill((byte) 0xFF);
+        MemorySegments.fill(MemorySegments.ofArray(new byte[] { }), (byte) 0xFF);
+        MemorySegments.fill(MemorySegments.ofArray(new byte[2]).asSlice(0, 0), (byte) 0xFF);
+        MemorySegments.fill(MemorySegments.ofByteBuffer(ByteBuffer.allocateDirect(0)), (byte) 0xFF);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testWithAccessModesBadUnsupportedMode() {
         int[] arr = new int[1];
-        MemorySegment segment = MemorySegment.ofArray(arr);
+        MemorySegment segment = MemorySegments.ofArray(arr);
         segment.withAccessModes((1 << AccessActions.values().length) + 1);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadWithAccessModesBadStrongerMode() {
         int[] arr = new int[1];
-        MemorySegment segment = MemorySegment.ofArray(arr).withAccessModes(READ);
+        MemorySegment segment = MemorySegments.ofArray(arr).withAccessModes(READ);
         segment.withAccessModes(WRITE);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadHasAccessModes() {
         int[] arr = new int[1];
-        MemorySegment segment = MemorySegment.ofArray(arr);
+        MemorySegment segment = MemorySegments.ofArray(arr);
         segment.hasAccessModes((1 << AccessActions.values().length) + 1);
     }
 
     @DataProvider(name = "badSizeAndAlignments")
     public Object[][] sizesAndAlignments() {
@@ -338,10 +340,16 @@
                 "close",
                 "fill",
                 "copyFrom",
                 "mismatch",
                 "toByteArray",
+                "toCharArray",
+                "toShortArray",
+                "toIntArray",
+                "toFloatArray",
+                "toLongArray",
+                "toDoubleArray",
                 "withOwnerThread"
         );
 
         public SegmentMember(Method method, Object[] params) {
             this.method = method;
@@ -397,11 +405,11 @@
     enum AccessActions {
         ACQUIRE(MemorySegment.ACQUIRE) {
             @Override
             void run(MemorySegment segment) {
                 Spliterator<MemorySegment> spliterator =
-                        MemorySegment.spliterator(segment, MemoryLayout.ofSequence(segment.byteSize(), MemoryLayouts.JAVA_BYTE));
+                        MemorySegments.spliterator(segment, MemoryLayout.ofSequence(segment.byteSize(), MemoryLayouts.JAVA_BYTE));
                 AtomicReference<RuntimeException> exception = new AtomicReference<>();
                 Runnable action = () -> {
                     try {
                         spliterator.tryAdvance(s -> { });
                     } catch (RuntimeException e) {
diff a/test/jdk/java/foreign/TestSharedAccess.java b/test/jdk/java/foreign/TestSharedAccess.java
--- a/test/jdk/java/foreign/TestSharedAccess.java
+++ b/test/jdk/java/foreign/TestSharedAccess.java
@@ -29,10 +29,11 @@
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import jdk.incubator.foreign.SequenceLayout;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.VarHandle;
 import java.nio.ByteBuffer;
@@ -55,11 +56,11 @@
     static final VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
 
     @Test
     public void testConfined() throws Throwable {
         Thread owner = Thread.currentThread();
-        MemorySegment s = MemorySegment.allocateNative(4);
+        MemorySegment s = MemorySegments.allocateNative(4);
         AtomicReference<MemorySegment> confined = new AtomicReference<>(s);
         setInt(s.baseAddress(), 42);
         assertEquals(getInt(s.baseAddress()), 42);
         List<Thread> threads = new ArrayList<>();
         for (int i = 0 ; i < 1000 ; i++) {
@@ -81,17 +82,17 @@
     }
 
     @Test
     public void testShared() throws Throwable {
         SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
-        try (MemorySegment s = MemorySegment.allocateNative(layout)) {
+        try (MemorySegment s = MemorySegments.allocateNative(layout)) {
             for (int i = 0 ; i < layout.elementCount().getAsLong() ; i++) {
                 setInt(s.baseAddress().addOffset(i * 4), 42);
             }
             List<Thread> threads = new ArrayList<>();
             List<Spliterator<MemorySegment>> spliterators = new ArrayList<>();
-            spliterators.add(MemorySegment.spliterator(s, layout));
+            spliterators.add(MemorySegments.spliterator(s, layout));
             while (true) {
                 boolean progress = false;
                 List<Spliterator<MemorySegment>> newSpliterators = new ArrayList<>();
                 for (Spliterator<MemorySegment> spliterator : spliterators) {
                     Spliterator<MemorySegment> sub = spliterator.trySplit();
@@ -125,15 +126,15 @@
         }
     }
 
     @Test
     public void testSharedUnsafe() throws Throwable {
-        try (MemorySegment s = MemorySegment.allocateNative(4)) {
+        try (MemorySegment s = MemorySegments.allocateNative(4)) {
             setInt(s.baseAddress(), 42);
             assertEquals(getInt(s.baseAddress()), 42);
             List<Thread> threads = new ArrayList<>();
-            MemorySegment sharedSegment = MemorySegment.ofNativeRestricted(
+            MemorySegment sharedSegment = MemorySegments.ofNativeRestricted(
                     s.baseAddress(), s.byteSize(), null, null, null);
             for (int i = 0 ; i < 1000 ; i++) {
                 threads.add(new Thread(() -> {
                     assertEquals(getInt(sharedSegment.baseAddress()), 42);
                 }));
@@ -155,11 +156,11 @@
     }
 
     @Test(expectedExceptions=IllegalStateException.class)
     public void testBadCloseWithPendingAcquireBuffer() {
         withAcquired(segment -> {
-            segment = MemorySegment.ofByteBuffer(segment.asByteBuffer()); // original segment is lost
+            segment = MemorySegments.ofByteBuffer(MemorySegments.asByteBuffer(segment)); // original segment is lost
             segment.close(); // this should still fail
         });
     }
 
     @Test(expectedExceptions=IllegalStateException.class)
@@ -168,29 +169,29 @@
     }
 
     @Test(expectedExceptions=IllegalStateException.class)
     public void testBadHandoffWithPendingAcquireBuffer() {
         withAcquired(segment -> {
-            segment = MemorySegment.ofByteBuffer(segment.asByteBuffer()); // original segment is lost
+            segment = MemorySegments.ofByteBuffer(MemorySegments.asByteBuffer(segment)); // original segment is lost
             segment.withOwnerThread(new Thread()); // this should still fail
         });
     }
 
     @Test(expectedExceptions=IllegalArgumentException.class)
     public void testBadHandoffSameThread() {
-        MemorySegment.ofArray(new int[4]).withOwnerThread(Thread.currentThread());
+        MemorySegments.ofArray(new int[4]).withOwnerThread(Thread.currentThread());
     }
 
     @Test(expectedExceptions=NullPointerException.class)
     public void testBadHandoffNullThread() {
-        MemorySegment.ofArray(new int[4]).withOwnerThread(null);
+        MemorySegments.ofArray(new int[4]).withOwnerThread(null);
     }
 
     private void withAcquired(Consumer<MemorySegment> acquiredAction) {
         CountDownLatch holder = new CountDownLatch(1);
-        MemorySegment segment = MemorySegment.allocateNative(16);
-        Spliterator<MemorySegment> spliterator = MemorySegment.spliterator(segment,
+        MemorySegment segment = MemorySegments.allocateNative(16);
+        Spliterator<MemorySegment> spliterator = MemorySegments.spliterator(segment,
                 MemoryLayout.ofSequence(16, MemoryLayouts.JAVA_BYTE));
         CountDownLatch acquired = new CountDownLatch(1);
         Runnable r = () -> spliterator.tryAdvance(s -> {
             try {
                 acquired.countDown();
@@ -213,16 +214,16 @@
     @Test
     public void testOutsideConfinementThread() throws Throwable {
         CountDownLatch a = new CountDownLatch(1);
         CountDownLatch b = new CountDownLatch(1);
         CompletableFuture<?> r;
-        try (MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.ofSequence(2, MemoryLayouts.JAVA_INT))) {
+        try (MemorySegment s1 = MemorySegments.allocateNative(MemoryLayout.ofSequence(2, MemoryLayouts.JAVA_INT))) {
             r = CompletableFuture.runAsync(() -> {
                 try {
-                    ByteBuffer bb = s1.asByteBuffer();
+                    ByteBuffer bb = MemorySegments.asByteBuffer(s1);
 
-                    MemorySegment s2 = MemorySegment.ofByteBuffer(bb);
+                    MemorySegment s2 = MemorySegments.ofByteBuffer(bb);
                     a.countDown();
 
                     try {
                         b.await();
                     } catch (InterruptedException e) {
diff a/test/jdk/java/foreign/TestSlices.java b/test/jdk/java/foreign/TestSlices.java
--- a/test/jdk/java/foreign/TestSlices.java
+++ b/test/jdk/java/foreign/TestSlices.java
@@ -27,10 +27,11 @@
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 
 import java.lang.invoke.VarHandle;
 
+import jdk.incubator.foreign.MemorySegments;
 import org.testng.annotations.*;
 import static org.testng.Assert.*;
 
 /*
  * @test
@@ -46,11 +47,11 @@
 
     static VarHandle VH_INT = MemoryLayouts.JAVA_INT.varHandle(int.class);
 
     @Test(dataProvider = "slices")
     public void testSlices(VarHandle handle, int lo, int hi, int[] values) {
-        try (MemorySegment segment = MemorySegment.allocateNative(LAYOUT)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(LAYOUT)) {
             //init
             for (long i = 0 ; i < 2 ; i++) {
                 for (long j = 0 ; j < 5 ; j++) {
                     VH_ALL.set(segment.baseAddress(), i, j, (int)j + 1 + ((int)i * 5));
                 }
diff a/test/jdk/java/foreign/TestSpliterator.java b/test/jdk/java/foreign/TestSpliterator.java
--- a/test/jdk/java/foreign/TestSpliterator.java
+++ b/test/jdk/java/foreign/TestSpliterator.java
@@ -28,10 +28,11 @@
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import jdk.incubator.foreign.SequenceLayout;
 
 import java.lang.invoke.VarHandle;
 import java.util.LinkedList;
 import java.util.List;
@@ -59,44 +60,44 @@
     @Test(dataProvider = "splits")
     public void testSum(int size, int threshold) {
         SequenceLayout layout = MemoryLayout.ofSequence(size, MemoryLayouts.JAVA_INT);
 
         //setup
-        MemorySegment segment = MemorySegment.allocateNative(layout);
+        MemorySegment segment = MemorySegments.allocateNative(layout);
         for (int i = 0; i < layout.elementCount().getAsLong(); i++) {
             INT_HANDLE.set(segment.baseAddress(), (long) i, i);
         }
         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
         //serial
         long serial = sum(0, segment);
         assertEquals(serial, expected);
         //parallel counted completer
-        long parallelCounted = new SumSegmentCounted(null, MemorySegment.spliterator(segment, layout), threshold).invoke();
+        long parallelCounted = new SumSegmentCounted(null, MemorySegments.spliterator(segment, layout), threshold).invoke();
         assertEquals(parallelCounted, expected);
         //parallel recursive action
-        long parallelRecursive = new SumSegmentRecursive(MemorySegment.spliterator(segment, layout), threshold).invoke();
+        long parallelRecursive = new SumSegmentRecursive(MemorySegments.spliterator(segment, layout), threshold).invoke();
         assertEquals(parallelRecursive, expected);
         //parallel stream
-        long streamParallel = StreamSupport.stream(MemorySegment.spliterator(segment, layout), true)
+        long streamParallel = StreamSupport.stream(MemorySegments.spliterator(segment, layout), true)
                 .reduce(0L, TestSpliterator::sumSingle, Long::sum);
         assertEquals(streamParallel, expected);
         segment.close();
     }
 
     public void testSumSameThread() {
         SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
 
         //setup
-        MemorySegment segment = MemorySegment.allocateNative(layout);
+        MemorySegment segment = MemorySegments.allocateNative(layout);
         for (int i = 0; i < layout.elementCount().getAsLong(); i++) {
             INT_HANDLE.set(segment.baseAddress(), (long) i, i);
         }
         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
 
         //check that a segment w/o ACQUIRE access mode can still be used from same thread
         AtomicLong spliteratorSum = new AtomicLong();
-        spliterator(segment.withAccessModes(MemorySegment.READ), layout)
+        MemorySegments.spliterator(segment.withAccessModes(MemorySegment.READ), layout)
                 .forEachRemaining(s -> spliteratorSum.addAndGet(sumSingle(0L, s)));
         assertEquals(spliteratorSum.get(), expected);
     }
 
     static long sumSingle(long acc, MemorySegment segment) {
@@ -206,20 +207,20 @@
     }
 
     @DataProvider(name = "accessScenarios")
     public Object[][] accessScenarios() {
         SequenceLayout layout = MemoryLayout.ofSequence(16, MemoryLayouts.JAVA_INT);
-        var mallocSegment = MemorySegment.allocateNative(layout);
+        var mallocSegment = MemorySegments.allocateNative(layout);
 
         Map<Supplier<Spliterator<MemorySegment>>,Integer> l = Map.of(
-            () -> spliterator(mallocSegment.withAccessModes(ALL_ACCESS), layout), ALL_ACCESS,
-            () -> spliterator(mallocSegment.withAccessModes(0), layout), 0,
-            () -> spliterator(mallocSegment.withAccessModes(READ), layout), READ,
-            () -> spliterator(mallocSegment.withAccessModes(CLOSE), layout), 0,
-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE), layout), READ|WRITE,
-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE|ACQUIRE), layout), READ|WRITE|ACQUIRE,
-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE|ACQUIRE|HANDOFF), layout), READ|WRITE|ACQUIRE|HANDOFF
+            () -> MemorySegments.spliterator(mallocSegment.withAccessModes(ALL_ACCESS), layout), ALL_ACCESS,
+            () -> MemorySegments.spliterator(mallocSegment.withAccessModes(0), layout), 0,
+            () -> MemorySegments.spliterator(mallocSegment.withAccessModes(READ), layout), READ,
+            () -> MemorySegments.spliterator(mallocSegment.withAccessModes(CLOSE), layout), 0,
+            () -> MemorySegments.spliterator(mallocSegment.withAccessModes(READ|WRITE), layout), READ|WRITE,
+            () -> MemorySegments.spliterator(mallocSegment.withAccessModes(READ|WRITE|ACQUIRE), layout), READ|WRITE|ACQUIRE,
+            () -> MemorySegments.spliterator(mallocSegment.withAccessModes(READ|WRITE|ACQUIRE|HANDOFF), layout), READ|WRITE|ACQUIRE|HANDOFF
 
         );
         return l.entrySet().stream().map(e -> new Object[] { e.getKey(), e.getValue() }).toArray(Object[][]::new);
     }
 
diff a/test/jdk/java/foreign/TestTypeAccess.java b/test/jdk/java/foreign/TestTypeAccess.java
--- a/test/jdk/java/foreign/TestTypeAccess.java
+++ b/test/jdk/java/foreign/TestTypeAccess.java
@@ -27,10 +27,11 @@
  * @run testng TestTypeAccess
  */
 
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.MemorySegments;
 import org.testng.annotations.*;
 
 import java.lang.invoke.VarHandle;
 import java.lang.invoke.WrongMethodTypeException;
 
@@ -38,17 +39,17 @@
 
     static final VarHandle INT_HANDLE = MemoryLayouts.JAVA_INT.varHandle(int.class);
 
     @Test(expectedExceptions=ClassCastException.class)
     public void testMemoryAddressCoordinateAsString() {
-        try (MemorySegment s = MemorySegment.allocateNative(8)) {
+        try (MemorySegment s = MemorySegments.allocateNative(8)) {
             int v = (int)INT_HANDLE.get("string");
         }
     }
 
     @Test(expectedExceptions=WrongMethodTypeException.class)
     public void testMemoryCoordinatePrimitive() {
-        try (MemorySegment s = MemorySegment.allocateNative(8)) {
+        try (MemorySegment s = MemorySegments.allocateNative(8)) {
             int v = (int)INT_HANDLE.get(1);
         }
     }
 }
diff a/test/jdk/java/foreign/TestVarHandleCombinators.java b/test/jdk/java/foreign/TestVarHandleCombinators.java
--- a/test/jdk/java/foreign/TestVarHandleCombinators.java
+++ b/test/jdk/java/foreign/TestVarHandleCombinators.java
@@ -26,10 +26,11 @@
  * @test
  * @run testng TestVarHandleCombinators
  */
 
 import jdk.incubator.foreign.MemoryHandles;
+import jdk.incubator.foreign.MemorySegments;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
@@ -46,28 +47,28 @@
     public void testElementAccess() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
         vh = MemoryHandles.withStride(vh, 1);
 
         byte[] arr = { 0, 0, -1, 0 };
-        MemorySegment segment = MemorySegment.ofArray(arr);
+        MemorySegment segment = MemorySegments.ofArray(arr);
         MemoryAddress addr = segment.baseAddress();
 
         assertEquals((byte) vh.get(addr, 2), (byte) -1);
     }
 
     @Test(expectedExceptions = IllegalStateException.class)
     public void testUnalignedElement() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());
         vh = MemoryHandles.withStride(vh, 2);
-        MemorySegment segment = MemorySegment.ofArray(new byte[4]);
+        MemorySegment segment = MemorySegments.ofArray(new byte[4]);
         vh.get(segment.baseAddress(), 1L); //should throw
     }
 
     public void testZeroStrideElement() {
         VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
         VarHandle strided_vh = MemoryHandles.withStride(vh, 0);
-        MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
+        MemorySegment segment = MemorySegments.ofArray(new int[] { 42 });
         for (int i = 0 ; i < 100 ; i++) {
             assertEquals((int)vh.get(segment.baseAddress()), strided_vh.get(segment.baseAddress(), (long)i));
         }
     }
 
@@ -89,11 +90,11 @@
 
     @Test
     public void testAlign() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());
 
-        MemorySegment segment = MemorySegment.allocateNative(1, 2);
+        MemorySegment segment = MemorySegments.allocateNative(1, 2);
         MemoryAddress address = segment.baseAddress();
 
         vh.set(address, (byte) 10); // fine, memory region is aligned
         assertEquals((byte) vh.get(address), (byte) 10);
     }
@@ -101,20 +102,20 @@
     @Test(expectedExceptions = IllegalStateException.class)
     public void testAlignBadAccess() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());
         vh = MemoryHandles.withOffset(vh, 1); // offset by 1 byte
 
-        MemorySegment segment = MemorySegment.allocateNative(2, 2);
+        MemorySegment segment = MemorySegments.allocateNative(2, 2);
         MemoryAddress address = segment.baseAddress();
 
         vh.set(address, (byte) 10); // should be bad align
     }
 
     public void testZeroOffsetElement() {
         VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
         VarHandle offset_vh = MemoryHandles.withOffset(vh, 0);
-        MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
+        MemorySegment segment = MemorySegments.ofArray(new int[] { 42 });
         for (int i = 0 ; i < 100 ; i++) {
             assertEquals((int)vh.get(segment.baseAddress()), offset_vh.get(segment.baseAddress(), (long)i));
         }
     }
 
@@ -126,31 +127,31 @@
 
     @Test(expectedExceptions = IllegalStateException.class)
     public void testUnalignedOffset() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());
         vh = MemoryHandles.withOffset(vh, 2);
-        MemorySegment segment = MemorySegment.ofArray(new byte[4]);
+        MemorySegment segment = MemorySegments.ofArray(new byte[4]);
         vh.get(segment.baseAddress()); //should throw
     }
 
     @Test
     public void testOffset() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
         vh = MemoryHandles.withOffset(vh, 1);
 
-        MemorySegment segment = MemorySegment.ofArray(new byte[2]);
+        MemorySegment segment = MemorySegments.ofArray(new byte[2]);
         MemoryAddress address = segment.baseAddress();
 
         vh.set(address, (byte) 10);
         assertEquals((byte) vh.get(address), (byte) 10);
     }
 
     @Test
     public void testByteOrderLE() {
         VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.LITTLE_ENDIAN);
         byte[] arr = new byte[2];
-        MemorySegment segment = MemorySegment.ofArray(arr);
+        MemorySegment segment = MemorySegments.ofArray(arr);
         MemoryAddress address = segment.baseAddress();
 
         vh.set(address, (short) 0xFF);
         assertEquals(arr[0], (byte) 0xFF);
         assertEquals(arr[1], (byte) 0);
@@ -158,11 +159,11 @@
 
     @Test
     public void testByteOrderBE() {
         VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.BIG_ENDIAN);
         byte[] arr = new byte[2];
-        MemorySegment segment = MemorySegment.ofArray(arr);
+        MemorySegment segment = MemorySegments.ofArray(arr);
         MemoryAddress address = segment.baseAddress();
 
         vh.set(address, (short) 0xFF);
         assertEquals(arr[0], (byte) 0);
         assertEquals(arr[1], (byte) 0xFF);
@@ -178,11 +179,11 @@
         VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
         vh = MemoryHandles.withOffset(vh, 4);
         VarHandle inner_vh = MemoryHandles.withStride(vh, 8);
         VarHandle outer_vh = MemoryHandles.withStride(inner_vh, 5 * 8);
         int count = 0;
-        try (MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(inner_size * outer_size * 8)) {
             for (long i = 0; i < outer_size; i++) {
                 for (long j = 0; j < inner_size; j++) {
                     outer_vh.set(segment.baseAddress(), i, j, count);
                     assertEquals(
                             (int)inner_vh.get(segment.baseAddress().addOffset(i * inner_size * 8), j),
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/BulkOps.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/BulkOps.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/BulkOps.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/BulkOps.java
@@ -22,10 +22,11 @@
  *
  */
 
 package org.openjdk.bench.jdk.incubator.foreign;
 
+import jdk.incubator.foreign.MemorySegments;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Fork;
 import org.openjdk.jmh.annotations.Measurement;
 import org.openjdk.jmh.annotations.Mode;
@@ -53,39 +54,39 @@
     static final int ELEM_SIZE = 1_000_000;
     static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();
     static final int ALLOC_SIZE = ELEM_SIZE * CARRIER_SIZE;
 
     static final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);
-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);
+    static final MemorySegment segment = MemorySegments.allocateNative(ALLOC_SIZE);
 
     static final int[] bytes = new int[ELEM_SIZE];
-    static final MemorySegment bytesSegment = MemorySegment.ofArray(bytes);
+    static final MemorySegment bytesSegment = MemorySegments.ofArray(bytes);
     static final int UNSAFE_INT_OFFSET = unsafe.arrayBaseOffset(int[].class);
 
     // large(ish) segments/buffers with same content, 0, for mismatch, non-multiple-of-8 sized
     static final int SIZE_WITH_TAIL = (1024 * 1024) + 7;
-    static final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL);
-    static final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL);
+    static final MemorySegment mismatchSegmentLarge1 = MemorySegments.allocateNative(SIZE_WITH_TAIL);
+    static final MemorySegment mismatchSegmentLarge2 = MemorySegments.allocateNative(SIZE_WITH_TAIL);
     static final ByteBuffer mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);
     static final ByteBuffer mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);
 
     // mismatch at first byte
-    static final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7);
-    static final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7);
+    static final MemorySegment mismatchSegmentSmall1 = MemorySegments.allocateNative(7);
+    static final MemorySegment mismatchSegmentSmall2 = MemorySegments.allocateNative(7);
     static final ByteBuffer mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);
     static final ByteBuffer mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);
     static {
-        mismatchSegmentSmall1.fill((byte) 0xFF);
+        MemorySegments.fill(mismatchSegmentSmall1, (byte) 0xFF);
         mismatchBufferSmall1.put((byte) 0xFF).clear();
         // verify expected mismatch indices
-        long si = mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);
+        long si = MemorySegments.mismatch(mismatchSegmentLarge1, mismatchSegmentLarge2);
         if (si != -1)
             throw new AssertionError("Unexpected mismatch index:" + si);
         int bi = mismatchBufferLarge1.mismatch(mismatchBufferLarge2);
         if (bi != -1)
             throw new AssertionError("Unexpected mismatch index:" + bi);
-        si = mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);
+        si = MemorySegments.mismatch(mismatchSegmentSmall1, mismatchSegmentSmall2);
         if (si != 0)
             throw new AssertionError("Unexpected mismatch index:" + si);
         bi = mismatchBufferSmall1.mismatch(mismatchBufferSmall2);
         if (bi != 0)
             throw new AssertionError("Unexpected mismatch index:" + bi);
@@ -104,11 +105,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public void segment_fill() {
-        segment.fill((byte)42);
+        MemorySegments.fill(segment, (byte)42);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public void unsafe_copy() {
@@ -116,17 +117,17 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public void segment_copy() {
-        segment.copyFrom(bytesSegment);
+        MemorySegments.copy(bytesSegment, segment);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public long mismatch_large_segment() {
-        return mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);
+        return MemorySegments.mismatch(mismatchSegmentLarge1, mismatchSegmentLarge2);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int mismatch_large_bytebuffer() {
@@ -134,11 +135,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public long mismatch_small_segment() {
-        return mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);
+        return MemorySegments.mismatch(mismatchSegmentSmall1, mismatchSegmentSmall2);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int mismatch_small_bytebuffer() {
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
@@ -21,10 +21,11 @@
  * questions.
  */
 package org.openjdk.bench.jdk.incubator.foreign;
 
 import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegments;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.CompilerControl;
 import org.openjdk.jmh.annotations.Fork;
 import org.openjdk.jmh.annotations.Measurement;
@@ -70,11 +71,11 @@
         }
     }
 
     //setup native memory segment
 
-    static final MemoryAddress segment_addr = MemorySegment.allocateNative(ALLOC_SIZE).baseAddress();
+    static final MemoryAddress segment_addr = MemorySegments.allocateNative(ALLOC_SIZE).baseAddress();
     static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());
 
     static {
         for (int i = 0; i < ELEM_SIZE; i++) {
             VH_int.set(segment_addr, (long) i, i);
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
@@ -23,10 +23,11 @@
 package org.openjdk.bench.jdk.incubator.foreign;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Fork;
 import org.openjdk.jmh.annotations.Measurement;
 import org.openjdk.jmh.annotations.Mode;
@@ -70,11 +71,11 @@
         unsafe.freeMemory(unsafe_addr);
     }
 
     @Benchmark
     public void segment_loop() {
-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);
+        MemorySegment segment = MemorySegments.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
             VH_int.set(segment.baseAddress(), (long) i, i);
         }
         segment.close();
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
@@ -22,11 +22,13 @@
  */
 package org.openjdk.bench.jdk.incubator.foreign;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Fork;
 import org.openjdk.jmh.annotations.Measurement;
 import org.openjdk.jmh.annotations.Mode;
@@ -69,11 +71,11 @@
     public void setup() {
         unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
             unsafe.putInt(unsafe_addr + (i * CARRIER_SIZE) , i);
         }
-        segment = MemorySegment.allocateNative(ALLOC_SIZE);
+        segment = MemorySegments.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
             VH_int.set(segment.baseAddress(), (long) i, i);
         }
         byteBuffer = ByteBuffer.allocateDirect(ALLOC_SIZE).order(ByteOrder.nativeOrder());
         for (int i = 0; i < ELEM_SIZE; i++) {
@@ -113,10 +115,19 @@
             res += unsafe.getInt(unsafe_addr + (i * CARRIER_SIZE));
         }
         return res;
     }
 
+    @Benchmark
+    public int segment_loop_static() {
+        int res = 0;
+        for (int i = 0; i < ELEM_SIZE; i ++) {
+            res += MemorySegments.getInt(segment.baseAddress(), i * CARRIER_SIZE);
+        }
+        return res;
+    }
+
     @Benchmark
     public int segment_loop() {
         int sum = 0;
         MemoryAddress base = segment.baseAddress();
         for (int i = 0; i < ELEM_SIZE; i++) {
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
@@ -22,11 +22,13 @@
  */
 package org.openjdk.bench.jdk.incubator.foreign;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Fork;
 import org.openjdk.jmh.annotations.Measurement;
 import org.openjdk.jmh.annotations.Mode;
@@ -70,11 +72,11 @@
     public void setup() {
         base = new byte[ALLOC_SIZE];
         for (int i = 0; i < ELEM_SIZE; i++) {
             unsafe.putInt(base, UNSAFE_BYTE_BASE + (i * CARRIER_SIZE) , i);
         }
-        segment = MemorySegment.ofArray(base);
+        segment = MemorySegments.ofArray(base);
         byteBuffer = ByteBuffer.wrap(base).order(ByteOrder.nativeOrder());
     }
 
     @TearDown
     public void tearDown() {
@@ -116,10 +118,19 @@
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
+    @Benchmark
+    public int segment_loop_static() {
+        int res = 0;
+        for (int i = 0; i < ELEM_SIZE; i ++) {
+            res += MemorySegments.getInt(segment.baseAddress(), i * CARRIER_SIZE);
+        }
+        return res;
+    }
+
     @Benchmark
     public int segment_loop_slice() {
         int sum = 0;
         MemoryAddress base = segment.asSlice(0, segment.byteSize()).baseAddress();
         for (int i = 0; i < ELEM_SIZE; i++) {
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
@@ -20,13 +20,16 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package org.openjdk.bench.jdk.incubator.foreign;
 
+import jdk.incubator.foreign.MappedMemorySegment;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Fork;
 import org.openjdk.jmh.annotations.Measurement;
 import org.openjdk.jmh.annotations.Mode;
@@ -93,11 +96,11 @@
             for (int i = 0; i < ELEM_SIZE; i++) {
                 byteBuffer.putInt(i * CARRIER_SIZE, i);
             }
             ((MappedByteBuffer)byteBuffer).force();
         }
-        segment = MemorySegment.mapFromPath(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE);
+        segment = MemorySegments.mapFromPath(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE);
         unsafe_addr = segment.baseAddress().toRawLongValue();
     }
 
     @TearDown
     public void tearDown() {
@@ -140,10 +143,19 @@
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
+    @Benchmark
+    public int segment_loop_static() {
+        int res = 0;
+        for (int i = 0; i < ELEM_SIZE; i ++) {
+            res += MemorySegments.getInt(segment.baseAddress(), i * CARRIER_SIZE);
+        }
+        return res;
+    }
+
     @Benchmark
     public int segment_loop_slice() {
         int sum = 0;
         MemoryAddress base = segment.asSlice(0, segment.byteSize()).baseAddress();
         for (int i = 0; i < ELEM_SIZE; i++) {
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
@@ -23,10 +23,11 @@
 
 package org.openjdk.bench.jdk.incubator.foreign;
 
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.MemorySegments;
 import jdk.incubator.foreign.SequenceLayout;
 import sun.misc.Unsafe;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Fork;
@@ -83,11 +84,11 @@
     public void setup() {
         address = unsafe.allocateMemory(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
             unsafe.putInt(address + (i * CARRIER_SIZE), i);
         }
-        segment = MemorySegment.allocateNative(ALLOC_SIZE);
+        segment = MemorySegments.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
             VH_int.set(segment.baseAddress(), (long) i, i);
         }
     }
 
@@ -116,27 +117,27 @@
         return res;
     }
 
     @Benchmark
     public int segment_parallel() {
-        return new SumSegment(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), SEGMENT_TO_INT).invoke();
+        return new SumSegment(MemorySegments.spliterator(segment, SEQUENCE_LAYOUT), SEGMENT_TO_INT).invoke();
     }
 
     @Benchmark
     public int segment_parallel_bulk() {
-        return new SumSegment(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), SEGMENT_TO_INT_BULK).invoke();
+        return new SumSegment(MemorySegments.spliterator(segment, SEQUENCE_LAYOUT_BULK), SEGMENT_TO_INT_BULK).invoke();
     }
 
     @Benchmark
     public int segment_stream_parallel() {
-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)
+        return StreamSupport.stream(MemorySegments.spliterator(segment, SEQUENCE_LAYOUT), true)
                 .mapToInt(SEGMENT_TO_INT).sum();
     }
 
     @Benchmark
     public int segment_stream_parallel_bulk() {
-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), true)
+        return StreamSupport.stream(MemorySegments.spliterator(segment, SEQUENCE_LAYOUT_BULK), true)
                 .mapToInt(SEGMENT_TO_INT_BULK).sum();
     }
 
     final static ToIntFunction<MemorySegment> SEGMENT_TO_INT = slice ->
             (int) VH_int.get(slice.baseAddress(), 0L);
@@ -150,32 +151,32 @@
         return res;
     };
 
     @Benchmark
     public Optional<MemorySegment> segment_stream_findany_serial() {
-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), false)
+        return StreamSupport.stream(MemorySegments.spliterator(segment, SEQUENCE_LAYOUT), false)
                 .filter(FIND_SINGLE)
                 .findAny();
     }
 
     @Benchmark
     public Optional<MemorySegment> segment_stream_findany_parallel() {
-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)
+        return StreamSupport.stream(MemorySegments.spliterator(segment, SEQUENCE_LAYOUT), true)
                 .filter(FIND_SINGLE)
                 .findAny();
     }
 
     @Benchmark
     public Optional<MemorySegment> segment_stream_findany_serial_bulk() {
-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), false)
+        return StreamSupport.stream(MemorySegments.spliterator(segment, SEQUENCE_LAYOUT_BULK), false)
                 .filter(FIND_BULK)
                 .findAny();
     }
 
     @Benchmark
     public Optional<MemorySegment> segment_stream_findany_parallel_bulk() {
-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), true)
+        return StreamSupport.stream(MemorySegments.spliterator(segment, SEQUENCE_LAYOUT_BULK), true)
                 .filter(FIND_BULK)
                 .findAny();
     }
 
     final static Predicate<MemorySegment> FIND_SINGLE = slice ->
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
@@ -27,10 +27,11 @@
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Fork;
 import org.openjdk.jmh.annotations.Measurement;
 import org.openjdk.jmh.annotations.Mode;
@@ -94,11 +95,11 @@
     static final MethodHandle MH_int = VH_int.toMethodHandle(VarHandle.AccessMode.GET);
 
     static final MethodHandle MH_box_int = MethodHandles.filterReturnValue(MH_int, INT_TO_INTBOX);
 
     int[] base = new int[ELEM_SIZE];
-    MemorySegment segment = MemorySegment.ofArray(base);
+    MemorySegment segment = MemorySegments.ofArray(base);
 
     @Setup
     public void setup() {
         for (int i = 0; i < ELEM_SIZE; i++) {
             base[i] = i;
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
@@ -23,10 +23,11 @@
 package org.openjdk.bench.jdk.incubator.foreign.points.support;
 
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
 
 import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;
@@ -38,15 +39,14 @@
         MemoryLayouts.JAVA_INT.withOrder(ByteOrder.nativeOrder()).withName("y")
     );
 
     private static final VarHandle VH_x = LAYOUT.varHandle(int.class, groupElement("x"));
     private static final VarHandle VH_y = LAYOUT.varHandle(int.class, groupElement("y"));
-
     private final MemorySegment segment;
 
     public PanamaPoint(int x, int y) {
-        this(MemorySegment.allocateNative(LAYOUT), x, y);
+        this(MemorySegments.allocateNative(LAYOUT), x, y);
     }
 
     public PanamaPoint(MemorySegment segment, int x, int y) {
         this(segment);
         setX(x);

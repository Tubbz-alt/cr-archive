diff a/test/jdk/java/foreign/TestMemoryAlignment.java b/test/jdk/java/foreign/TestMemoryAlignment.java
--- a/test/jdk/java/foreign/TestMemoryAlignment.java
+++ b/test/jdk/java/foreign/TestMemoryAlignment.java
@@ -31,10 +31,11 @@
 
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySegments;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
 import java.lang.invoke.VarHandle;
 import java.util.stream.LongStream;
 
@@ -48,11 +49,11 @@
         ValueLayout layout = MemoryLayouts.BITS_32_BE;
         assertEquals(layout.bitAlignment(), 32);
         ValueLayout aligned = layout.withBitAlignment(align);
         assertEquals(aligned.bitAlignment(), align); //unreasonable alignment here, to make sure access throws
         VarHandle vh = aligned.varHandle(int.class);
-        try (MemorySegment segment = MemorySegment.allocateNative(aligned)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(aligned)) {
             MemoryAddress addr = segment.baseAddress();
             vh.set(addr, -42);
             int val = (int)vh.get(addr);
             assertEquals(val, -42);
         }
@@ -64,11 +65,11 @@
         assertEquals(layout.bitAlignment(), 32);
         ValueLayout aligned = layout.withBitAlignment(align);
         MemoryLayout alignedGroup = MemoryLayout.ofStruct(MemoryLayouts.PAD_8, aligned);
         assertEquals(alignedGroup.bitAlignment(), align);
         VarHandle vh = aligned.varHandle(int.class);
-        try (MemorySegment segment = MemorySegment.allocateNative(alignedGroup)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(alignedGroup)) {
             MemoryAddress addr = segment.baseAddress();
             vh.set(addr.addOffset(1L), -42);
             assertEquals(align, 8); //this is the only case where access is aligned
         } catch (IllegalStateException ex) {
             assertNotEquals(align, 8); //if align != 8, access is always unaligned
@@ -91,11 +92,11 @@
     @Test(dataProvider = "alignments")
     public void testUnalignedSequence(long align) {
         SequenceLayout layout = MemoryLayout.ofSequence(5, MemoryLayouts.BITS_32_BE.withBitAlignment(align));
         try {
             VarHandle vh = layout.varHandle(int.class, PathElement.sequenceElement());
-            try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
+            try (MemorySegment segment = MemorySegments.allocateNative(layout)) {
                 MemoryAddress addr = segment.baseAddress();
                 for (long i = 0 ; i < 5 ; i++) {
                     vh.set(addr, i, -42);
                 }
             }
@@ -115,11 +116,11 @@
                                vInt.withBitAlignment(8).withName("c"));
         assertEquals(g.bitAlignment(), 8);
         VarHandle vh_c = g.varHandle(byte.class, PathElement.groupElement("a"));
         VarHandle vh_s = g.varHandle(short.class, PathElement.groupElement("b"));
         VarHandle vh_i = g.varHandle(int.class, PathElement.groupElement("c"));
-        try (MemorySegment segment = MemorySegment.allocateNative(g)) {
+        try (MemorySegment segment = MemorySegments.allocateNative(g)) {
             MemoryAddress addr = segment.baseAddress();
             vh_c.set(addr, Byte.MIN_VALUE);
             assertEquals(vh_c.get(addr), Byte.MIN_VALUE);
             vh_s.set(addr, Short.MIN_VALUE);
             assertEquals(vh_s.get(addr), Short.MIN_VALUE);

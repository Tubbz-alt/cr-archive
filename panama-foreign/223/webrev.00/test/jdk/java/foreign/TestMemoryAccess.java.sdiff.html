<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/TestMemoryAccess.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="TestLayouts.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestMemoryAlignment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/TestMemoryAccess.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  *  or visit www.oracle.com if you need additional information or have any
 21  *  questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestMemoryAccess
 27  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestMemoryAccess
 28  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestMemoryAccess
 29  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestMemoryAccess
 30  */
 31 
 32 import jdk.incubator.foreign.GroupLayout;
 33 import jdk.incubator.foreign.MemoryLayouts;
 34 import jdk.incubator.foreign.MemoryLayout;
 35 import jdk.incubator.foreign.MemoryLayout.PathElement;
 36 import jdk.incubator.foreign.MemorySegment;

 37 import jdk.incubator.foreign.SequenceLayout;
 38 import jdk.incubator.foreign.ValueLayout;
 39 import jdk.incubator.foreign.MemoryAddress;
 40 import java.lang.invoke.VarHandle;
 41 import java.util.function.Function;
 42 
 43 import org.testng.annotations.*;
 44 import static org.testng.Assert.*;
 45 
 46 public class TestMemoryAccess {
 47 
 48     @Test(dataProvider = &quot;elements&quot;)
 49     public void testAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, ValueLayout elemLayout, Class&lt;?&gt; carrier, Checker checker) {
 50         ValueLayout layout = elemLayout.withName(&quot;elem&quot;);
 51         testAccessInternal(viewFactory, layout, layout.varHandle(carrier), checker);
 52     }
 53 
 54     @Test(dataProvider = &quot;elements&quot;)
 55     public void testPaddedAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, Checker checker) {
 56         GroupLayout layout = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;));
</pre>
<hr />
<pre>
 66     @Test(dataProvider = &quot;arrayElements&quot;)
 67     public void testArrayAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 68         SequenceLayout seq = MemoryLayout.ofSequence(10, elemLayout.withName(&quot;elem&quot;));
 69         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement()), checker);
 70     }
 71 
 72     @Test(dataProvider = &quot;arrayElements&quot;)
 73     public void testPaddedArrayAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 74         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;)));
 75         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.groupElement(&quot;elem&quot;)), checker);
 76     }
 77 
 78     @Test(dataProvider = &quot;arrayElements&quot;)
 79     public void testPaddedArrayAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 80         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout));
 81         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);
 82     }
 83 
 84     private void testAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout layout, VarHandle handle, Checker checker) {
 85         MemoryAddress outer_address;
<span class="line-modified"> 86         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout))) {</span>
 87             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
 88             MemoryAddress addr = segment.baseAddress();
 89             try {
 90                 checker.check(handle, addr);
 91                 if (isRO) {
 92                     throw new AssertionError(); //not ok, memory should be immutable
 93                 }
 94             } catch (UnsupportedOperationException ex) {
 95                 if (!isRO) {
 96                     throw new AssertionError(); //we should not have failed!
 97                 }
 98                 return;
 99             }
100             try {
101                 checker.check(handle, addr.addOffset(layout.byteSize()));
102                 throw new AssertionError(); //not ok, out of bounds
103             } catch (IndexOutOfBoundsException ex) {
104                 //ok, should fail (out of bounds)
105             }
106             outer_address = addr; //leak!
107         }
108         try {
109             checker.check(handle, outer_address);
110             throw new AssertionError(); //not ok, scope is closed
111         } catch (IllegalStateException ex) {
112             //ok, should fail (scope is closed)
113         }
114     }
115 
116     private void testArrayAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, SequenceLayout seq, VarHandle handle, ArrayChecker checker) {
117         MemoryAddress outer_address;
<span class="line-modified">118         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {</span>
119             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
120             MemoryAddress addr = segment.baseAddress();
121             try {
122                 for (int i = 0; i &lt; seq.elementCount().getAsLong(); i++) {
123                     checker.check(handle, addr, i);
124                 }
125                 if (isRO) {
126                     throw new AssertionError(); //not ok, memory should be immutable
127                 }
128             } catch (UnsupportedOperationException ex) {
129                 if (!isRO) {
130                     throw new AssertionError(); //we should not have failed!
131                 }
132                 return;
133             }
134             try {
135                 checker.check(handle, addr, seq.elementCount().getAsLong());
136                 throw new AssertionError(); //not ok, out of bounds
137             } catch (IndexOutOfBoundsException ex) {
138                 //ok, should fail (out of bounds)
</pre>
<hr />
<pre>
167 
168     @Test(dataProvider = &quot;matrixElements&quot;)
169     public void testPaddedMatrixAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, MatrixChecker checker) {
170         SequenceLayout seq = MemoryLayout.ofSequence(20,
171                 MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout)));
172         testMatrixAccessInternal(viewFactory, seq,
173                 seq.varHandle(carrier,
174                         PathElement.sequenceElement(), PathElement.sequenceElement(), PathElement.sequenceElement(1)),
175                 checker);
176     }
177 
178     @Test(dataProvider = &quot;badCarriers&quot;,
179           expectedExceptions = IllegalArgumentException.class)
180     public void testBadCarriers(Class&lt;?&gt; carrier) {
181         ValueLayout l = MemoryLayouts.BITS_32_LE.withName(&quot;elem&quot;);
182         l.varHandle(carrier);
183     }
184 
185     private void testMatrixAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, SequenceLayout seq, VarHandle handle, MatrixChecker checker) {
186         MemoryAddress outer_address;
<span class="line-modified">187         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {</span>
188             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
189             MemoryAddress addr = segment.baseAddress();
190             try {
191                 for (int i = 0; i &lt; seq.elementCount().getAsLong(); i++) {
192                     for (int j = 0; j &lt; ((SequenceLayout) seq.elementLayout()).elementCount().getAsLong(); j++) {
193                         checker.check(handle, addr, i, j);
194                     }
195                 }
196                 if (isRO) {
197                     throw new AssertionError(); //not ok, memory should be immutable
198                 }
199             } catch (UnsupportedOperationException ex) {
200                 if (!isRO) {
201                     throw new AssertionError(); //we should not have failed!
202                 }
203                 return;
204             }
205             try {
206                 checker.check(handle, addr, seq.elementCount().getAsLong(),
207                         ((SequenceLayout)seq.elementLayout()).elementCount().getAsLong());
</pre>
</td>
<td>
<hr />
<pre>
 17  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  *  or visit www.oracle.com if you need additional information or have any
 21  *  questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestMemoryAccess
 27  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestMemoryAccess
 28  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestMemoryAccess
 29  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestMemoryAccess
 30  */
 31 
 32 import jdk.incubator.foreign.GroupLayout;
 33 import jdk.incubator.foreign.MemoryLayouts;
 34 import jdk.incubator.foreign.MemoryLayout;
 35 import jdk.incubator.foreign.MemoryLayout.PathElement;
 36 import jdk.incubator.foreign.MemorySegment;
<span class="line-added"> 37 import jdk.incubator.foreign.MemorySegments;</span>
 38 import jdk.incubator.foreign.SequenceLayout;
 39 import jdk.incubator.foreign.ValueLayout;
 40 import jdk.incubator.foreign.MemoryAddress;
 41 import java.lang.invoke.VarHandle;
 42 import java.util.function.Function;
 43 
 44 import org.testng.annotations.*;
 45 import static org.testng.Assert.*;
 46 
 47 public class TestMemoryAccess {
 48 
 49     @Test(dataProvider = &quot;elements&quot;)
 50     public void testAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, ValueLayout elemLayout, Class&lt;?&gt; carrier, Checker checker) {
 51         ValueLayout layout = elemLayout.withName(&quot;elem&quot;);
 52         testAccessInternal(viewFactory, layout, layout.varHandle(carrier), checker);
 53     }
 54 
 55     @Test(dataProvider = &quot;elements&quot;)
 56     public void testPaddedAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, Checker checker) {
 57         GroupLayout layout = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;));
</pre>
<hr />
<pre>
 67     @Test(dataProvider = &quot;arrayElements&quot;)
 68     public void testArrayAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 69         SequenceLayout seq = MemoryLayout.ofSequence(10, elemLayout.withName(&quot;elem&quot;));
 70         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement()), checker);
 71     }
 72 
 73     @Test(dataProvider = &quot;arrayElements&quot;)
 74     public void testPaddedArrayAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 75         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;)));
 76         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.groupElement(&quot;elem&quot;)), checker);
 77     }
 78 
 79     @Test(dataProvider = &quot;arrayElements&quot;)
 80     public void testPaddedArrayAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 81         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout));
 82         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);
 83     }
 84 
 85     private void testAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout layout, VarHandle handle, Checker checker) {
 86         MemoryAddress outer_address;
<span class="line-modified"> 87         try (MemorySegment segment = viewFactory.apply(MemorySegments.allocateNative(layout))) {</span>
 88             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
 89             MemoryAddress addr = segment.baseAddress();
 90             try {
 91                 checker.check(handle, addr);
 92                 if (isRO) {
 93                     throw new AssertionError(); //not ok, memory should be immutable
 94                 }
 95             } catch (UnsupportedOperationException ex) {
 96                 if (!isRO) {
 97                     throw new AssertionError(); //we should not have failed!
 98                 }
 99                 return;
100             }
101             try {
102                 checker.check(handle, addr.addOffset(layout.byteSize()));
103                 throw new AssertionError(); //not ok, out of bounds
104             } catch (IndexOutOfBoundsException ex) {
105                 //ok, should fail (out of bounds)
106             }
107             outer_address = addr; //leak!
108         }
109         try {
110             checker.check(handle, outer_address);
111             throw new AssertionError(); //not ok, scope is closed
112         } catch (IllegalStateException ex) {
113             //ok, should fail (scope is closed)
114         }
115     }
116 
117     private void testArrayAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, SequenceLayout seq, VarHandle handle, ArrayChecker checker) {
118         MemoryAddress outer_address;
<span class="line-modified">119         try (MemorySegment segment = viewFactory.apply(MemorySegments.allocateNative(seq))) {</span>
120             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
121             MemoryAddress addr = segment.baseAddress();
122             try {
123                 for (int i = 0; i &lt; seq.elementCount().getAsLong(); i++) {
124                     checker.check(handle, addr, i);
125                 }
126                 if (isRO) {
127                     throw new AssertionError(); //not ok, memory should be immutable
128                 }
129             } catch (UnsupportedOperationException ex) {
130                 if (!isRO) {
131                     throw new AssertionError(); //we should not have failed!
132                 }
133                 return;
134             }
135             try {
136                 checker.check(handle, addr, seq.elementCount().getAsLong());
137                 throw new AssertionError(); //not ok, out of bounds
138             } catch (IndexOutOfBoundsException ex) {
139                 //ok, should fail (out of bounds)
</pre>
<hr />
<pre>
168 
169     @Test(dataProvider = &quot;matrixElements&quot;)
170     public void testPaddedMatrixAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, MatrixChecker checker) {
171         SequenceLayout seq = MemoryLayout.ofSequence(20,
172                 MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout)));
173         testMatrixAccessInternal(viewFactory, seq,
174                 seq.varHandle(carrier,
175                         PathElement.sequenceElement(), PathElement.sequenceElement(), PathElement.sequenceElement(1)),
176                 checker);
177     }
178 
179     @Test(dataProvider = &quot;badCarriers&quot;,
180           expectedExceptions = IllegalArgumentException.class)
181     public void testBadCarriers(Class&lt;?&gt; carrier) {
182         ValueLayout l = MemoryLayouts.BITS_32_LE.withName(&quot;elem&quot;);
183         l.varHandle(carrier);
184     }
185 
186     private void testMatrixAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, SequenceLayout seq, VarHandle handle, MatrixChecker checker) {
187         MemoryAddress outer_address;
<span class="line-modified">188         try (MemorySegment segment = viewFactory.apply(MemorySegments.allocateNative(seq))) {</span>
189             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
190             MemoryAddress addr = segment.baseAddress();
191             try {
192                 for (int i = 0; i &lt; seq.elementCount().getAsLong(); i++) {
193                     for (int j = 0; j &lt; ((SequenceLayout) seq.elementLayout()).elementCount().getAsLong(); j++) {
194                         checker.check(handle, addr, i, j);
195                     }
196                 }
197                 if (isRO) {
198                     throw new AssertionError(); //not ok, memory should be immutable
199                 }
200             } catch (UnsupportedOperationException ex) {
201                 if (!isRO) {
202                     throw new AssertionError(); //we should not have failed!
203                 }
204                 return;
205             }
206             try {
207                 checker.check(handle, addr, seq.elementCount().getAsLong(),
208                         ((SequenceLayout)seq.elementLayout()).elementCount().getAsLong());
</pre>
</td>
</tr>
</table>
<center><a href="TestLayouts.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestMemoryAlignment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/TestMismatch.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="TestMemoryHandleAsUnsigned.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestNative.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/TestMismatch.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  *  or visit www.oracle.com if you need additional information or have any
 21  *  questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @run testng TestMismatch
 27  */
 28 
 29 import java.lang.invoke.VarHandle;
 30 import java.util.ArrayList;
 31 import java.util.List;
 32 import java.util.concurrent.atomic.AtomicReference;
 33 import java.util.function.IntFunction;
 34 import jdk.incubator.foreign.MemoryAddress;
 35 import jdk.incubator.foreign.MemoryLayouts;
 36 import jdk.incubator.foreign.MemorySegment;

 37 import org.testng.annotations.DataProvider;
 38 import org.testng.annotations.Test;
 39 import static java.lang.System.out;
 40 import static jdk.incubator.foreign.MemorySegment.READ;
 41 import static org.testng.Assert.assertEquals;
 42 import static org.testng.Assert.assertThrows;
 43 
 44 public class TestMismatch {
 45 
 46     final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);
 47 
 48     // stores a increasing sequence of values into the memory of the given segment
 49     static MemorySegment initializeSegment(MemorySegment segment) {
 50         MemoryAddress addr = segment.baseAddress();
 51         for (int i = 0 ; i &lt; segment.byteSize() ; i++) {
 52             BYTE_HANDLE.set(addr.addOffset(i), (byte)i);
 53         }
 54         return segment;
 55     }
 56 
 57     @Test(dataProvider = &quot;slices&quot;)
 58     public void testSameValues(MemorySegment ss1, MemorySegment ss2) {
 59         out.format(&quot;testSameValues s1:%s, s2:%s\n&quot;, ss1, ss2);
 60         MemorySegment s1 = initializeSegment(ss1);
 61         MemorySegment s2 = initializeSegment(ss2);
 62 
 63         if (s1.byteSize() == s2.byteSize()) {
<span class="line-modified"> 64             assertEquals(s1.mismatch(s2), -1);  // identical</span>
<span class="line-modified"> 65             assertEquals(s2.mismatch(s1), -1);</span>
 66         } else if (s1.byteSize() &gt; s2.byteSize()) {
<span class="line-modified"> 67             assertEquals(s1.mismatch(s2), s2.byteSize());  // proper prefix</span>
<span class="line-modified"> 68             assertEquals(s2.mismatch(s1), s2.byteSize());</span>
 69         } else {
 70             assert s1.byteSize() &lt; s2.byteSize();
<span class="line-modified"> 71             assertEquals(s1.mismatch(s2), s1.byteSize());  // proper prefix</span>
<span class="line-modified"> 72             assertEquals(s2.mismatch(s1), s1.byteSize());</span>
 73         }
 74     }
 75 
 76     @Test(dataProvider = &quot;slices&quot;)
 77     public void testDifferentValues(MemorySegment s1, MemorySegment s2) {
 78         out.format(&quot;testDifferentValues s1:%s, s2:%s\n&quot;, s1, s2);
 79         s1 = initializeSegment(s1);
 80         s2 = initializeSegment(s2);
 81 
 82         for (long i = s2.byteSize() -1 ; i &gt;= 0; i--) {
 83             long expectedMismatchOffset = i;
 84             BYTE_HANDLE.set(s2.baseAddress().addOffset(i), (byte) 0xFF);
 85 
 86             if (s1.byteSize() == s2.byteSize()) {
<span class="line-modified"> 87                 assertEquals(s1.mismatch(s2), expectedMismatchOffset);</span>
<span class="line-modified"> 88                 assertEquals(s2.mismatch(s1), expectedMismatchOffset);</span>
 89             } else if (s1.byteSize() &gt; s2.byteSize()) {
<span class="line-modified"> 90                 assertEquals(s1.mismatch(s2), expectedMismatchOffset);</span>
<span class="line-modified"> 91                 assertEquals(s2.mismatch(s1), expectedMismatchOffset);</span>
 92             } else {
 93                 assert s1.byteSize() &lt; s2.byteSize();
 94                 var off = Math.min(s1.byteSize(), expectedMismatchOffset);
<span class="line-modified"> 95                 assertEquals(s1.mismatch(s2), off);  // proper prefix</span>
<span class="line-modified"> 96                 assertEquals(s2.mismatch(s1), off);</span>
 97             }
 98         }
 99     }
100 
101     @Test
102     public void testEmpty() {
<span class="line-modified">103         var s1 = MemorySegment.ofArray(new byte[0]);</span>
<span class="line-modified">104         assertEquals(s1.mismatch(s1), -1);</span>
<span class="line-modified">105         try (var nativeSegment = MemorySegment.allocateNative(4)) {</span>
106             var s2 = nativeSegment.asSlice(0, 0);
<span class="line-modified">107             assertEquals(s1.mismatch(s2), -1);</span>
<span class="line-modified">108             assertEquals(s2.mismatch(s1), -1);</span>
109         }
110     }
111 
112     @Test
113     public void testLarge() {
<span class="line-modified">114         try (var s1 = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L);</span>
<span class="line-modified">115              var s2 = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L)) {</span>
<span class="line-modified">116             assertEquals(s1.mismatch(s1), -1);</span>
<span class="line-modified">117             assertEquals(s1.mismatch(s2), -1);</span>
<span class="line-modified">118             assertEquals(s2.mismatch(s1), -1);</span>
119 
120             testLargeAcrossMaxBoundary(s1, s2);
121 
122             testLargeMismatchAcrossMaxBoundary(s1, s2);
123         }
124     }
125 
126     private void testLargeAcrossMaxBoundary(MemorySegment s1, MemorySegment s2) {
127         for (long i = s2.byteSize() -1 ; i &gt;= Integer.MAX_VALUE - 10L; i--) {
128             var s3 = s1.asSlice(0, i);
129             var s4 = s2.asSlice(0, i);
<span class="line-modified">130             assertEquals(s3.mismatch(s3), -1);</span>
<span class="line-modified">131             assertEquals(s3.mismatch(s4), -1);</span>
<span class="line-modified">132             assertEquals(s4.mismatch(s3), -1);</span>
133         }
134     }
135 
136     private void testLargeMismatchAcrossMaxBoundary(MemorySegment s1, MemorySegment s2) {
137         for (long i = s2.byteSize() -1 ; i &gt;= Integer.MAX_VALUE - 10L; i--) {
138             BYTE_HANDLE.set(s2.baseAddress().addOffset(i), (byte) 0xFF);
139             long expectedMismatchOffset = i;
<span class="line-modified">140             assertEquals(s1.mismatch(s2), expectedMismatchOffset);</span>
<span class="line-modified">141             assertEquals(s2.mismatch(s1), expectedMismatchOffset);</span>
142         }
143     }
144 
145     static final Class&lt;IllegalStateException&gt; ISE = IllegalStateException.class;
146     static final Class&lt;UnsupportedOperationException&gt; UOE = UnsupportedOperationException.class;
147 
148     @Test
149     public void testClosed() {
<span class="line-modified">150         var s1 = MemorySegment.ofArray(new byte[4]);</span>
<span class="line-modified">151         var s2 = MemorySegment.ofArray(new byte[4]);</span>
152         s1.close();
<span class="line-modified">153         assertThrows(ISE, () -&gt; s1.mismatch(s1));</span>
<span class="line-modified">154         assertThrows(ISE, () -&gt; s1.mismatch(s2));</span>
<span class="line-modified">155         assertThrows(ISE, () -&gt; s2.mismatch(s1));</span>
156     }
157 
158     @Test
159     public void testInsufficientAccessModes() {
<span class="line-modified">160         var s1 = MemorySegment.ofArray(new byte[4]);</span>
<span class="line-modified">161         var s2 = MemorySegment.ofArray(new byte[4]);</span>
162         var s1WithoutRead = s1.withAccessModes(s1.accessModes() &amp; ~READ);
163         var s2WithoutRead = s2.withAccessModes(s2.accessModes() &amp; ~READ);
164 
<span class="line-modified">165         assertThrows(UOE, () -&gt; s1.mismatch(s2WithoutRead));</span>
<span class="line-modified">166         assertThrows(UOE, () -&gt; s1WithoutRead.mismatch(s2));</span>
<span class="line-modified">167         assertThrows(UOE, () -&gt; s1WithoutRead.mismatch(s2WithoutRead));</span>
168     }
169 
170     @Test(expectedExceptions = NullPointerException.class)
171     public void testNull() {
<span class="line-modified">172         var segment = MemorySegment.ofArray(new byte[4]);</span>
<span class="line-modified">173         segment.mismatch(null);</span>
174     }
175 
176     @Test
177     public void testThreadAccess() throws Exception {
<span class="line-modified">178         var segment = MemorySegment.ofArray(new byte[4]);</span>
179         {
180             AtomicReference&lt;RuntimeException&gt; exception = new AtomicReference&lt;&gt;();
181             Runnable action = () -&gt; {
182                 try {
<span class="line-modified">183                     MemorySegment.ofArray(new byte[4]).mismatch(segment);</span>
184                 } catch (RuntimeException e) {
185                     exception.set(e);
186                 }
187             };
188             Thread thread = new Thread(action);
189             thread.start();
190             thread.join();
191 
192             RuntimeException e = exception.get();
193             if (!(e instanceof IllegalStateException)) {
194                 throw e;
195             }
196         }
197         {
198             AtomicReference&lt;RuntimeException&gt; exception = new AtomicReference&lt;&gt;();
199             Runnable action = () -&gt; {
200                 try {
<span class="line-modified">201                     segment.mismatch(MemorySegment.ofArray(new byte[4]));</span>
202                 } catch (RuntimeException e) {
203                     exception.set(e);
204                 }
205             };
206             Thread thread = new Thread(action);
207             thread.start();
208             thread.join();
209 
210             RuntimeException e = exception.get();
211             if (!(e instanceof IllegalStateException)) {
212                 throw e;
213             }
214         }
215     }
216 
217     enum SegmentKind {
<span class="line-modified">218         NATIVE(MemorySegment::allocateNative),</span>
<span class="line-modified">219         ARRAY(i -&gt; MemorySegment.ofArray(new byte[i]));</span>
220 
221         final IntFunction&lt;MemorySegment&gt; segmentFactory;
222 
223         SegmentKind(IntFunction&lt;MemorySegment&gt; segmentFactory) {
224             this.segmentFactory = segmentFactory;
225         }
226 
227         MemorySegment makeSegment(int elems) {
228             return segmentFactory.apply(elems);
229         }
230     }
231 
232     @DataProvider(name = &quot;slices&quot;)
233     static Object[][] slices() {
234         int[] sizes = { 16, 8, 1 };
235         List&lt;MemorySegment&gt; aSlices = new ArrayList&lt;&gt;();
236         List&lt;MemorySegment&gt; bSlices = new ArrayList&lt;&gt;();
237         for (List&lt;MemorySegment&gt; slices : List.of(aSlices, bSlices)) {
238             for (SegmentKind kind : SegmentKind.values()) {
239                 MemorySegment segment = kind.makeSegment(16);
</pre>
</td>
<td>
<hr />
<pre>
 17  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  *  or visit www.oracle.com if you need additional information or have any
 21  *  questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @run testng TestMismatch
 27  */
 28 
 29 import java.lang.invoke.VarHandle;
 30 import java.util.ArrayList;
 31 import java.util.List;
 32 import java.util.concurrent.atomic.AtomicReference;
 33 import java.util.function.IntFunction;
 34 import jdk.incubator.foreign.MemoryAddress;
 35 import jdk.incubator.foreign.MemoryLayouts;
 36 import jdk.incubator.foreign.MemorySegment;
<span class="line-added"> 37 import jdk.incubator.foreign.MemorySegments;</span>
 38 import org.testng.annotations.DataProvider;
 39 import org.testng.annotations.Test;
 40 import static java.lang.System.out;
 41 import static jdk.incubator.foreign.MemorySegment.READ;
 42 import static org.testng.Assert.assertEquals;
 43 import static org.testng.Assert.assertThrows;
 44 
 45 public class TestMismatch {
 46 
 47     final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);
 48 
 49     // stores a increasing sequence of values into the memory of the given segment
 50     static MemorySegment initializeSegment(MemorySegment segment) {
 51         MemoryAddress addr = segment.baseAddress();
 52         for (int i = 0 ; i &lt; segment.byteSize() ; i++) {
 53             BYTE_HANDLE.set(addr.addOffset(i), (byte)i);
 54         }
 55         return segment;
 56     }
 57 
 58     @Test(dataProvider = &quot;slices&quot;)
 59     public void testSameValues(MemorySegment ss1, MemorySegment ss2) {
 60         out.format(&quot;testSameValues s1:%s, s2:%s\n&quot;, ss1, ss2);
 61         MemorySegment s1 = initializeSegment(ss1);
 62         MemorySegment s2 = initializeSegment(ss2);
 63 
 64         if (s1.byteSize() == s2.byteSize()) {
<span class="line-modified"> 65             assertEquals(MemorySegments.mismatch(s1, s2), -1);  // identical</span>
<span class="line-modified"> 66             assertEquals(MemorySegments.mismatch(s2, s1), -1);</span>
 67         } else if (s1.byteSize() &gt; s2.byteSize()) {
<span class="line-modified"> 68             assertEquals(MemorySegments.mismatch(s1, s2), s2.byteSize());  // proper prefix</span>
<span class="line-modified"> 69             assertEquals(MemorySegments.mismatch(s2, s1), s2.byteSize());</span>
 70         } else {
 71             assert s1.byteSize() &lt; s2.byteSize();
<span class="line-modified"> 72             assertEquals(MemorySegments.mismatch(s1, s2), s1.byteSize());  // proper prefix</span>
<span class="line-modified"> 73             assertEquals(MemorySegments.mismatch(s2, s1), s1.byteSize());</span>
 74         }
 75     }
 76 
 77     @Test(dataProvider = &quot;slices&quot;)
 78     public void testDifferentValues(MemorySegment s1, MemorySegment s2) {
 79         out.format(&quot;testDifferentValues s1:%s, s2:%s\n&quot;, s1, s2);
 80         s1 = initializeSegment(s1);
 81         s2 = initializeSegment(s2);
 82 
 83         for (long i = s2.byteSize() -1 ; i &gt;= 0; i--) {
 84             long expectedMismatchOffset = i;
 85             BYTE_HANDLE.set(s2.baseAddress().addOffset(i), (byte) 0xFF);
 86 
 87             if (s1.byteSize() == s2.byteSize()) {
<span class="line-modified"> 88                 assertEquals(MemorySegments.mismatch(s1, s2), expectedMismatchOffset);</span>
<span class="line-modified"> 89                 assertEquals(MemorySegments.mismatch(s2, s1), expectedMismatchOffset);</span>
 90             } else if (s1.byteSize() &gt; s2.byteSize()) {
<span class="line-modified"> 91                 assertEquals(MemorySegments.mismatch(s1, s2), expectedMismatchOffset);</span>
<span class="line-modified"> 92                 assertEquals(MemorySegments.mismatch(s2, s1), expectedMismatchOffset);</span>
 93             } else {
 94                 assert s1.byteSize() &lt; s2.byteSize();
 95                 var off = Math.min(s1.byteSize(), expectedMismatchOffset);
<span class="line-modified"> 96                 assertEquals(MemorySegments.mismatch(s1, s2), off);  // proper prefix</span>
<span class="line-modified"> 97                 assertEquals(MemorySegments.mismatch(s2, s1), off);</span>
 98             }
 99         }
100     }
101 
102     @Test
103     public void testEmpty() {
<span class="line-modified">104         var s1 = MemorySegments.ofArray(new byte[0]);</span>
<span class="line-modified">105         assertEquals(MemorySegments.mismatch(s1, s1), -1);</span>
<span class="line-modified">106         try (var nativeSegment = MemorySegments.allocateNative(4)) {</span>
107             var s2 = nativeSegment.asSlice(0, 0);
<span class="line-modified">108             assertEquals(MemorySegments.mismatch(s1, s2), -1);</span>
<span class="line-modified">109             assertEquals(MemorySegments.mismatch(s2, s1), -1);</span>
110         }
111     }
112 
113     @Test
114     public void testLarge() {
<span class="line-modified">115         try (var s1 = MemorySegments.allocateNative((long)Integer.MAX_VALUE + 10L);</span>
<span class="line-modified">116              var s2 = MemorySegments.allocateNative((long)Integer.MAX_VALUE + 10L)) {</span>
<span class="line-modified">117             assertEquals(MemorySegments.mismatch(s1, s1), -1);</span>
<span class="line-modified">118             assertEquals(MemorySegments.mismatch(s1, s2), -1);</span>
<span class="line-modified">119             assertEquals(MemorySegments.mismatch(s2, s1), -1);</span>
120 
121             testLargeAcrossMaxBoundary(s1, s2);
122 
123             testLargeMismatchAcrossMaxBoundary(s1, s2);
124         }
125     }
126 
127     private void testLargeAcrossMaxBoundary(MemorySegment s1, MemorySegment s2) {
128         for (long i = s2.byteSize() -1 ; i &gt;= Integer.MAX_VALUE - 10L; i--) {
129             var s3 = s1.asSlice(0, i);
130             var s4 = s2.asSlice(0, i);
<span class="line-modified">131             assertEquals(MemorySegments.mismatch(s3, s3), -1);</span>
<span class="line-modified">132             assertEquals(MemorySegments.mismatch(s3, s4), -1);</span>
<span class="line-modified">133             assertEquals(MemorySegments.mismatch(s4, s3), -1);</span>
134         }
135     }
136 
137     private void testLargeMismatchAcrossMaxBoundary(MemorySegment s1, MemorySegment s2) {
138         for (long i = s2.byteSize() -1 ; i &gt;= Integer.MAX_VALUE - 10L; i--) {
139             BYTE_HANDLE.set(s2.baseAddress().addOffset(i), (byte) 0xFF);
140             long expectedMismatchOffset = i;
<span class="line-modified">141             assertEquals(MemorySegments.mismatch(s1, s2), expectedMismatchOffset);</span>
<span class="line-modified">142             assertEquals(MemorySegments.mismatch(s2, s1), expectedMismatchOffset);</span>
143         }
144     }
145 
146     static final Class&lt;IllegalStateException&gt; ISE = IllegalStateException.class;
147     static final Class&lt;UnsupportedOperationException&gt; UOE = UnsupportedOperationException.class;
148 
149     @Test
150     public void testClosed() {
<span class="line-modified">151         var s1 = MemorySegments.ofArray(new byte[4]);</span>
<span class="line-modified">152         var s2 = MemorySegments.ofArray(new byte[4]);</span>
153         s1.close();
<span class="line-modified">154         assertThrows(ISE, () -&gt; MemorySegments.mismatch(s1, s1));</span>
<span class="line-modified">155         assertThrows(ISE, () -&gt; MemorySegments.mismatch(s1, s2));</span>
<span class="line-modified">156         assertThrows(ISE, () -&gt; MemorySegments.mismatch(s2, s1));</span>
157     }
158 
159     @Test
160     public void testInsufficientAccessModes() {
<span class="line-modified">161         var s1 = MemorySegments.ofArray(new byte[4]);</span>
<span class="line-modified">162         var s2 = MemorySegments.ofArray(new byte[4]);</span>
163         var s1WithoutRead = s1.withAccessModes(s1.accessModes() &amp; ~READ);
164         var s2WithoutRead = s2.withAccessModes(s2.accessModes() &amp; ~READ);
165 
<span class="line-modified">166         assertThrows(UOE, () -&gt; MemorySegments.mismatch(s1, s2WithoutRead));</span>
<span class="line-modified">167         assertThrows(UOE, () -&gt; MemorySegments.mismatch(s1WithoutRead, s2));</span>
<span class="line-modified">168         assertThrows(UOE, () -&gt; MemorySegments.mismatch(s1WithoutRead, s2WithoutRead));</span>
169     }
170 
171     @Test(expectedExceptions = NullPointerException.class)
172     public void testNull() {
<span class="line-modified">173         var segment = MemorySegments.ofArray(new byte[4]);</span>
<span class="line-modified">174         MemorySegments.mismatch(segment, null);</span>
175     }
176 
177     @Test
178     public void testThreadAccess() throws Exception {
<span class="line-modified">179         var segment = MemorySegments.ofArray(new byte[4]);</span>
180         {
181             AtomicReference&lt;RuntimeException&gt; exception = new AtomicReference&lt;&gt;();
182             Runnable action = () -&gt; {
183                 try {
<span class="line-modified">184                     MemorySegments.mismatch(MemorySegments.ofArray(new byte[4]), segment);</span>
185                 } catch (RuntimeException e) {
186                     exception.set(e);
187                 }
188             };
189             Thread thread = new Thread(action);
190             thread.start();
191             thread.join();
192 
193             RuntimeException e = exception.get();
194             if (!(e instanceof IllegalStateException)) {
195                 throw e;
196             }
197         }
198         {
199             AtomicReference&lt;RuntimeException&gt; exception = new AtomicReference&lt;&gt;();
200             Runnable action = () -&gt; {
201                 try {
<span class="line-modified">202                     MemorySegments.mismatch(segment, MemorySegments.ofArray(new byte[4]));</span>
203                 } catch (RuntimeException e) {
204                     exception.set(e);
205                 }
206             };
207             Thread thread = new Thread(action);
208             thread.start();
209             thread.join();
210 
211             RuntimeException e = exception.get();
212             if (!(e instanceof IllegalStateException)) {
213                 throw e;
214             }
215         }
216     }
217 
218     enum SegmentKind {
<span class="line-modified">219         NATIVE(MemorySegments::allocateNative),</span>
<span class="line-modified">220         ARRAY(i -&gt; MemorySegments.ofArray(new byte[i]));</span>
221 
222         final IntFunction&lt;MemorySegment&gt; segmentFactory;
223 
224         SegmentKind(IntFunction&lt;MemorySegment&gt; segmentFactory) {
225             this.segmentFactory = segmentFactory;
226         }
227 
228         MemorySegment makeSegment(int elems) {
229             return segmentFactory.apply(elems);
230         }
231     }
232 
233     @DataProvider(name = &quot;slices&quot;)
234     static Object[][] slices() {
235         int[] sizes = { 16, 8, 1 };
236         List&lt;MemorySegment&gt; aSlices = new ArrayList&lt;&gt;();
237         List&lt;MemorySegment&gt; bSlices = new ArrayList&lt;&gt;();
238         for (List&lt;MemorySegment&gt; slices : List.of(aSlices, bSlices)) {
239             for (SegmentKind kind : SegmentKind.values()) {
240                 MemorySegment segment = kind.makeSegment(16);
</pre>
</td>
</tr>
</table>
<center><a href="TestMemoryHandleAsUnsigned.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestNative.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/foreign/TestMemoryAccess.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.
  8  *
  9  *  This code is distributed in the hope that it will be useful, but WITHOUT
 10  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  *  version 2 for more details (a copy is included in the LICENSE file that
 13  *  accompanied this code).
 14  *
 15  *  You should have received a copy of the GNU General Public License version
 16  *  2 along with this work; if not, write to the Free Software Foundation,
 17  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  *  or visit www.oracle.com if you need additional information or have any
 21  *  questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestMemoryAccess
 27  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestMemoryAccess
 28  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestMemoryAccess
 29  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestMemoryAccess
 30  */
 31 
 32 import jdk.incubator.foreign.GroupLayout;
 33 import jdk.incubator.foreign.MemoryLayouts;
 34 import jdk.incubator.foreign.MemoryLayout;
 35 import jdk.incubator.foreign.MemoryLayout.PathElement;
 36 import jdk.incubator.foreign.MemorySegment;
 37 import jdk.incubator.foreign.MemorySegments;
 38 import jdk.incubator.foreign.SequenceLayout;
 39 import jdk.incubator.foreign.ValueLayout;
 40 import jdk.incubator.foreign.MemoryAddress;
 41 import java.lang.invoke.VarHandle;
 42 import java.util.function.Function;
 43 
 44 import org.testng.annotations.*;
 45 import static org.testng.Assert.*;
 46 
 47 public class TestMemoryAccess {
 48 
 49     @Test(dataProvider = &quot;elements&quot;)
 50     public void testAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, ValueLayout elemLayout, Class&lt;?&gt; carrier, Checker checker) {
 51         ValueLayout layout = elemLayout.withName(&quot;elem&quot;);
 52         testAccessInternal(viewFactory, layout, layout.varHandle(carrier), checker);
 53     }
 54 
 55     @Test(dataProvider = &quot;elements&quot;)
 56     public void testPaddedAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, Checker checker) {
 57         GroupLayout layout = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;));
 58         testAccessInternal(viewFactory, layout, layout.varHandle(carrier, PathElement.groupElement(&quot;elem&quot;)), checker);
 59     }
 60 
 61     @Test(dataProvider = &quot;elements&quot;)
 62     public void testPaddedAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, Checker checker) {
 63         SequenceLayout layout = MemoryLayout.ofSequence(2, elemLayout);
 64         testAccessInternal(viewFactory, layout, layout.varHandle(carrier, PathElement.sequenceElement(1)), checker);
 65     }
 66 
 67     @Test(dataProvider = &quot;arrayElements&quot;)
 68     public void testArrayAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 69         SequenceLayout seq = MemoryLayout.ofSequence(10, elemLayout.withName(&quot;elem&quot;));
 70         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement()), checker);
 71     }
 72 
 73     @Test(dataProvider = &quot;arrayElements&quot;)
 74     public void testPaddedArrayAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 75         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;)));
 76         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.groupElement(&quot;elem&quot;)), checker);
 77     }
 78 
 79     @Test(dataProvider = &quot;arrayElements&quot;)
 80     public void testPaddedArrayAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 81         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout));
 82         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);
 83     }
 84 
 85     private void testAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout layout, VarHandle handle, Checker checker) {
 86         MemoryAddress outer_address;
 87         try (MemorySegment segment = viewFactory.apply(MemorySegments.allocateNative(layout))) {
 88             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
 89             MemoryAddress addr = segment.baseAddress();
 90             try {
 91                 checker.check(handle, addr);
 92                 if (isRO) {
 93                     throw new AssertionError(); //not ok, memory should be immutable
 94                 }
 95             } catch (UnsupportedOperationException ex) {
 96                 if (!isRO) {
 97                     throw new AssertionError(); //we should not have failed!
 98                 }
 99                 return;
100             }
101             try {
102                 checker.check(handle, addr.addOffset(layout.byteSize()));
103                 throw new AssertionError(); //not ok, out of bounds
104             } catch (IndexOutOfBoundsException ex) {
105                 //ok, should fail (out of bounds)
106             }
107             outer_address = addr; //leak!
108         }
109         try {
110             checker.check(handle, outer_address);
111             throw new AssertionError(); //not ok, scope is closed
112         } catch (IllegalStateException ex) {
113             //ok, should fail (scope is closed)
114         }
115     }
116 
117     private void testArrayAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, SequenceLayout seq, VarHandle handle, ArrayChecker checker) {
118         MemoryAddress outer_address;
119         try (MemorySegment segment = viewFactory.apply(MemorySegments.allocateNative(seq))) {
120             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
121             MemoryAddress addr = segment.baseAddress();
122             try {
123                 for (int i = 0; i &lt; seq.elementCount().getAsLong(); i++) {
124                     checker.check(handle, addr, i);
125                 }
126                 if (isRO) {
127                     throw new AssertionError(); //not ok, memory should be immutable
128                 }
129             } catch (UnsupportedOperationException ex) {
130                 if (!isRO) {
131                     throw new AssertionError(); //we should not have failed!
132                 }
133                 return;
134             }
135             try {
136                 checker.check(handle, addr, seq.elementCount().getAsLong());
137                 throw new AssertionError(); //not ok, out of bounds
138             } catch (IndexOutOfBoundsException ex) {
139                 //ok, should fail (out of bounds)
140             }
141             outer_address = addr; //leak!
142         }
143         try {
144             checker.check(handle, outer_address, 0);
145             throw new AssertionError(); //not ok, scope is closed
146         } catch (IllegalStateException ex) {
147             //ok, should fail (scope is closed)
148         }
149     }
150 
151     @Test(dataProvider = &quot;matrixElements&quot;)
152     public void testMatrixAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, MatrixChecker checker) {
153         SequenceLayout seq = MemoryLayout.ofSequence(20,
154                 MemoryLayout.ofSequence(10, elemLayout.withName(&quot;elem&quot;)));
155         testMatrixAccessInternal(viewFactory, seq, seq.varHandle(carrier,
156                 PathElement.sequenceElement(), PathElement.sequenceElement()), checker);
157     }
158 
159     @Test(dataProvider = &quot;matrixElements&quot;)
160     public void testPaddedMatrixAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, MatrixChecker checker) {
161         SequenceLayout seq = MemoryLayout.ofSequence(20,
162                 MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;))));
163         testMatrixAccessInternal(viewFactory, seq,
164                 seq.varHandle(carrier,
165                         PathElement.sequenceElement(), PathElement.sequenceElement(), PathElement.groupElement(&quot;elem&quot;)),
166                 checker);
167     }
168 
169     @Test(dataProvider = &quot;matrixElements&quot;)
170     public void testPaddedMatrixAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, MatrixChecker checker) {
171         SequenceLayout seq = MemoryLayout.ofSequence(20,
172                 MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout)));
173         testMatrixAccessInternal(viewFactory, seq,
174                 seq.varHandle(carrier,
175                         PathElement.sequenceElement(), PathElement.sequenceElement(), PathElement.sequenceElement(1)),
176                 checker);
177     }
178 
179     @Test(dataProvider = &quot;badCarriers&quot;,
180           expectedExceptions = IllegalArgumentException.class)
181     public void testBadCarriers(Class&lt;?&gt; carrier) {
182         ValueLayout l = MemoryLayouts.BITS_32_LE.withName(&quot;elem&quot;);
183         l.varHandle(carrier);
184     }
185 
186     private void testMatrixAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, SequenceLayout seq, VarHandle handle, MatrixChecker checker) {
187         MemoryAddress outer_address;
188         try (MemorySegment segment = viewFactory.apply(MemorySegments.allocateNative(seq))) {
189             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
190             MemoryAddress addr = segment.baseAddress();
191             try {
192                 for (int i = 0; i &lt; seq.elementCount().getAsLong(); i++) {
193                     for (int j = 0; j &lt; ((SequenceLayout) seq.elementLayout()).elementCount().getAsLong(); j++) {
194                         checker.check(handle, addr, i, j);
195                     }
196                 }
197                 if (isRO) {
198                     throw new AssertionError(); //not ok, memory should be immutable
199                 }
200             } catch (UnsupportedOperationException ex) {
201                 if (!isRO) {
202                     throw new AssertionError(); //we should not have failed!
203                 }
204                 return;
205             }
206             try {
207                 checker.check(handle, addr, seq.elementCount().getAsLong(),
208                         ((SequenceLayout)seq.elementLayout()).elementCount().getAsLong());
209                 throw new AssertionError(); //not ok, out of bounds
210             } catch (IndexOutOfBoundsException ex) {
211                 //ok, should fail (out of bounds)
212             }
213             outer_address = addr; //leak!
214         }
215         try {
216             checker.check(handle, outer_address, 0, 0);
217             throw new AssertionError(); //not ok, scope is closed
218         } catch (IllegalStateException ex) {
219             //ok, should fail (scope is closed)
220         }
221     }
222 
223     static Function&lt;MemorySegment, MemorySegment&gt; ID = Function.identity();
224     static Function&lt;MemorySegment, MemorySegment&gt; IMMUTABLE = ms -&gt; ms.withAccessModes(MemorySegment.READ | MemorySegment.CLOSE);
225 
226     @DataProvider(name = &quot;elements&quot;)
227     public Object[][] createData() {
228         return new Object[][] {
229                 //BE, RW
230                 { ID, MemoryLayouts.BITS_8_BE, byte.class, Checker.BYTE },
231                 { ID, MemoryLayouts.BITS_16_BE, short.class, Checker.SHORT },
232                 { ID, MemoryLayouts.BITS_16_BE, char.class, Checker.CHAR },
233                 { ID, MemoryLayouts.BITS_32_BE, int.class, Checker.INT },
234                 { ID, MemoryLayouts.BITS_64_BE, long.class, Checker.LONG },
235                 { ID, MemoryLayouts.BITS_32_BE, float.class, Checker.FLOAT },
236                 { ID, MemoryLayouts.BITS_64_BE, double.class, Checker.DOUBLE },
237                 //BE, RO
238                 { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, Checker.BYTE },
239                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, Checker.SHORT },
240                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, Checker.CHAR },
241                 { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, Checker.INT },
242                 { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, Checker.LONG },
243                 { IMMUTABLE, MemoryLayouts.BITS_32_BE, float.class, Checker.FLOAT },
244                 { IMMUTABLE, MemoryLayouts.BITS_64_BE, double.class, Checker.DOUBLE },
245                 //LE, RW
246                 { ID, MemoryLayouts.BITS_8_LE, byte.class, Checker.BYTE },
247                 { ID, MemoryLayouts.BITS_16_LE, short.class, Checker.SHORT },
248                 { ID, MemoryLayouts.BITS_16_LE, char.class, Checker.CHAR },
249                 { ID, MemoryLayouts.BITS_32_LE, int.class, Checker.INT },
250                 { ID, MemoryLayouts.BITS_64_LE, long.class, Checker.LONG },
251                 { ID, MemoryLayouts.BITS_32_LE, float.class, Checker.FLOAT },
252                 { ID, MemoryLayouts.BITS_64_LE, double.class, Checker.DOUBLE },
253                 //LE, RO
254                 { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, Checker.BYTE },
255                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, Checker.SHORT },
256                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, Checker.CHAR },
257                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, Checker.INT },
258                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, Checker.LONG },
259                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, Checker.FLOAT },
260                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, Checker.DOUBLE },
261         };
262     }
263 
264     interface Checker {
265         void check(VarHandle handle, MemoryAddress addr);
266 
267         Checker BYTE = (handle, addr) -&gt; {
268             handle.set(addr, (byte)42);
269             assertEquals(42, (byte)handle.get(addr));
270         };
271 
272         Checker SHORT = (handle, addr) -&gt; {
273             handle.set(addr, (short)42);
274             assertEquals(42, (short)handle.get(addr));
275         };
276 
277         Checker CHAR = (handle, addr) -&gt; {
278             handle.set(addr, (char)42);
279             assertEquals(42, (char)handle.get(addr));
280         };
281 
282         Checker INT = (handle, addr) -&gt; {
283             handle.set(addr, 42);
284             assertEquals(42, (int)handle.get(addr));
285         };
286 
287         Checker LONG = (handle, addr) -&gt; {
288             handle.set(addr, (long)42);
289             assertEquals(42, (long)handle.get(addr));
290         };
291 
292         Checker FLOAT = (handle, addr) -&gt; {
293             handle.set(addr, (float)42);
294             assertEquals((float)42, (float)handle.get(addr));
295         };
296 
297         Checker DOUBLE = (handle, addr) -&gt; {
298             handle.set(addr, (double)42);
299             assertEquals((double)42, (double)handle.get(addr));
300         };
301     }
302 
303     @DataProvider(name = &quot;arrayElements&quot;)
304     public Object[][] createArrayData() {
305         return new Object[][] {
306                 //BE, RW
307                 { ID, MemoryLayouts.BITS_8_BE, byte.class, ArrayChecker.BYTE },
308                 { ID, MemoryLayouts.BITS_16_BE, short.class, ArrayChecker.SHORT },
309                 { ID, MemoryLayouts.BITS_16_BE, char.class, ArrayChecker.CHAR },
310                 { ID, MemoryLayouts.BITS_32_BE, int.class, ArrayChecker.INT },
311                 { ID, MemoryLayouts.BITS_64_BE, long.class, ArrayChecker.LONG },
312                 { ID, MemoryLayouts.BITS_32_BE, float.class, ArrayChecker.FLOAT },
313                 { ID, MemoryLayouts.BITS_64_BE, double.class, ArrayChecker.DOUBLE },
314                 //BE, RO
315                 { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, ArrayChecker.BYTE },
316                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, ArrayChecker.SHORT },
317                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, ArrayChecker.CHAR },
318                 { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, ArrayChecker.INT },
319                 { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, ArrayChecker.LONG },
320                 { IMMUTABLE, MemoryLayouts.BITS_32_BE, float.class, ArrayChecker.FLOAT },
321                 { IMMUTABLE, MemoryLayouts.BITS_64_BE, double.class, ArrayChecker.DOUBLE },
322                 //LE, RW
323                 { ID, MemoryLayouts.BITS_8_LE, byte.class, ArrayChecker.BYTE },
324                 { ID, MemoryLayouts.BITS_16_LE, short.class, ArrayChecker.SHORT },
325                 { ID, MemoryLayouts.BITS_16_LE, char.class, ArrayChecker.CHAR },
326                 { ID, MemoryLayouts.BITS_32_LE, int.class, ArrayChecker.INT },
327                 { ID, MemoryLayouts.BITS_64_LE, long.class, ArrayChecker.LONG },
328                 { ID, MemoryLayouts.BITS_32_LE, float.class, ArrayChecker.FLOAT },
329                 { ID, MemoryLayouts.BITS_64_LE, double.class, ArrayChecker.DOUBLE },
330                 //LE, RO
331                 { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, ArrayChecker.BYTE },
332                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, ArrayChecker.SHORT },
333                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, ArrayChecker.CHAR },
334                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, ArrayChecker.INT },
335                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, ArrayChecker.LONG },
336                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, ArrayChecker.FLOAT },
337                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, ArrayChecker.DOUBLE },
338         };
339     }
340 
341     interface ArrayChecker {
342         void check(VarHandle handle, MemoryAddress addr, long index);
343 
344         ArrayChecker BYTE = (handle, addr, i) -&gt; {
345             handle.set(addr, i, (byte)i);
346             assertEquals(i, (byte)handle.get(addr, i));
347         };
348 
349         ArrayChecker SHORT = (handle, addr, i) -&gt; {
350             handle.set(addr, i, (short)i);
351             assertEquals(i, (short)handle.get(addr, i));
352         };
353 
354         ArrayChecker CHAR = (handle, addr, i) -&gt; {
355             handle.set(addr, i, (char)i);
356             assertEquals(i, (char)handle.get(addr, i));
357         };
358 
359         ArrayChecker INT = (handle, addr, i) -&gt; {
360             handle.set(addr, i, (int)i);
361             assertEquals(i, (int)handle.get(addr, i));
362         };
363 
364         ArrayChecker LONG = (handle, addr, i) -&gt; {
365             handle.set(addr, i, (long)i);
366             assertEquals(i, (long)handle.get(addr, i));
367         };
368 
369         ArrayChecker FLOAT = (handle, addr, i) -&gt; {
370             handle.set(addr, i, (float)i);
371             assertEquals((float)i, (float)handle.get(addr, i));
372         };
373 
374         ArrayChecker DOUBLE = (handle, addr, i) -&gt; {
375             handle.set(addr, i, (double)i);
376             assertEquals((double)i, (double)handle.get(addr, i));
377         };
378     }
379 
380     @DataProvider(name = &quot;matrixElements&quot;)
381     public Object[][] createMatrixData() {
382         return new Object[][] {
383                 //BE, RW
384                 { ID, MemoryLayouts.BITS_8_BE, byte.class, MatrixChecker.BYTE },
385                 { ID, MemoryLayouts.BITS_16_BE, short.class, MatrixChecker.SHORT },
386                 { ID, MemoryLayouts.BITS_16_BE, char.class, MatrixChecker.CHAR },
387                 { ID, MemoryLayouts.BITS_32_BE, int.class, MatrixChecker.INT },
388                 { ID, MemoryLayouts.BITS_64_BE, long.class, MatrixChecker.LONG },
389                 { ID, MemoryLayouts.BITS_32_BE, float.class, MatrixChecker.FLOAT },
390                 { ID, MemoryLayouts.BITS_64_BE, double.class, MatrixChecker.DOUBLE },
391                 //BE, RO
392                 { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, MatrixChecker.BYTE },
393                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, MatrixChecker.SHORT },
394                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, MatrixChecker.CHAR },
395                 { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, MatrixChecker.INT },
396                 { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, MatrixChecker.LONG },
397                 { IMMUTABLE, MemoryLayouts.BITS_32_BE, float.class, MatrixChecker.FLOAT },
398                 { IMMUTABLE, MemoryLayouts.BITS_64_BE, double.class, MatrixChecker.DOUBLE },
399                 //LE, RW
400                 { ID, MemoryLayouts.BITS_8_LE, byte.class, MatrixChecker.BYTE },
401                 { ID, MemoryLayouts.BITS_16_LE, short.class, MatrixChecker.SHORT },
402                 { ID, MemoryLayouts.BITS_16_LE, char.class, MatrixChecker.CHAR },
403                 { ID, MemoryLayouts.BITS_32_LE, int.class, MatrixChecker.INT },
404                 { ID, MemoryLayouts.BITS_64_LE, long.class, MatrixChecker.LONG },
405                 { ID, MemoryLayouts.BITS_32_LE, float.class, MatrixChecker.FLOAT },
406                 { ID, MemoryLayouts.BITS_64_LE, double.class, MatrixChecker.DOUBLE },
407                 //LE, RO
408                 { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, MatrixChecker.BYTE },
409                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, MatrixChecker.SHORT },
410                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, MatrixChecker.CHAR },
411                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, MatrixChecker.INT },
412                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, MatrixChecker.LONG },
413                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, MatrixChecker.FLOAT },
414                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, MatrixChecker.DOUBLE },
415         };
416     }
417 
418     interface MatrixChecker {
419         void check(VarHandle handle, MemoryAddress addr, long row, long col);
420 
421         MatrixChecker BYTE = (handle, addr, r, c) -&gt; {
422             handle.set(addr, r, c, (byte)(r + c));
423             assertEquals(r + c, (byte)handle.get(addr, r, c));
424         };
425 
426         MatrixChecker SHORT = (handle, addr, r, c) -&gt; {
427             handle.set(addr, r, c, (short)(r + c));
428             assertEquals(r + c, (short)handle.get(addr, r, c));
429         };
430 
431         MatrixChecker CHAR = (handle, addr, r, c) -&gt; {
432             handle.set(addr, r, c, (char)(r + c));
433             assertEquals(r + c, (char)handle.get(addr, r, c));
434         };
435 
436         MatrixChecker INT = (handle, addr, r, c) -&gt; {
437             handle.set(addr, r, c, (int)(r + c));
438             assertEquals(r + c, (int)handle.get(addr, r, c));
439         };
440 
441         MatrixChecker LONG = (handle, addr, r, c) -&gt; {
442             handle.set(addr, r, c, r + c);
443             assertEquals(r + c, (long)handle.get(addr, r, c));
444         };
445 
446         MatrixChecker FLOAT = (handle, addr, r, c) -&gt; {
447             handle.set(addr, r, c, (float)(r + c));
448             assertEquals((float)(r + c), (float)handle.get(addr, r, c));
449         };
450 
451         MatrixChecker DOUBLE = (handle, addr, r, c) -&gt; {
452             handle.set(addr, r, c, (double)(r + c));
453             assertEquals((double)(r + c), (double)handle.get(addr, r, c));
454         };
455     }
456 
457     @DataProvider(name = &quot;badCarriers&quot;)
458     public Object[][] createBadCarriers() {
459         return new Object[][] {
460                 { void.class },
461                 { boolean.class },
462                 { Object.class },
463                 { int[].class }
464         };
465     }
466 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/TestByteBuffer.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="TestArrays.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestLayouts.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/TestByteBuffer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * @test
 28  * @modules java.base/sun.nio.ch
 29  *          jdk.incubator.foreign/jdk.internal.foreign
 30  * @run testng TestByteBuffer
 31  */
 32 
 33 
 34 import jdk.incubator.foreign.MappedMemorySegment;
 35 import jdk.incubator.foreign.MemoryLayouts;
 36 import jdk.incubator.foreign.MemoryLayout;
 37 import jdk.incubator.foreign.MemoryAddress;
 38 import jdk.incubator.foreign.MemorySegment;
 39 import jdk.incubator.foreign.MemoryLayout.PathElement;

 40 import jdk.incubator.foreign.SequenceLayout;
 41 
 42 import java.io.File;
 43 import java.io.IOException;
 44 import java.lang.invoke.MethodHandle;
 45 import java.lang.invoke.MethodHandles;
 46 import java.lang.invoke.VarHandle;
 47 import java.lang.ref.WeakReference;
 48 import java.lang.reflect.InvocationTargetException;
 49 import java.lang.reflect.Method;
 50 import java.lang.reflect.Modifier;
 51 import java.nio.Buffer;
 52 import java.nio.ByteBuffer;
 53 import java.nio.ByteOrder;
 54 import java.nio.CharBuffer;
 55 import java.nio.DoubleBuffer;
 56 import java.nio.FloatBuffer;
 57 import java.nio.IntBuffer;
 58 import java.nio.LongBuffer;
 59 import java.nio.MappedByteBuffer;
</pre>
<hr />
<pre>
117 
118     static SequenceLayout ints = MemoryLayout.ofSequence(100,
119             MemoryLayouts.BITS_32_BE
120     );
121 
122     static SequenceLayout floats = MemoryLayout.ofSequence(100,
123             MemoryLayouts.BITS_32_BE
124     );
125 
126     static SequenceLayout longs = MemoryLayout.ofSequence(100,
127             MemoryLayouts.BITS_64_BE
128     );
129 
130     static SequenceLayout doubles = MemoryLayout.ofSequence(100,
131             MemoryLayouts.BITS_64_BE
132     );
133 
134     static VarHandle indexHandle = tuples.varHandle(int.class, PathElement.sequenceElement(), PathElement.groupElement(&quot;index&quot;));
135     static VarHandle valueHandle = tuples.varHandle(float.class, PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
136 
<span class="line-removed">137     static VarHandle byteHandle = bytes.varHandle(byte.class, PathElement.sequenceElement());</span>
<span class="line-removed">138     static VarHandle charHandle = chars.varHandle(char.class, PathElement.sequenceElement());</span>
<span class="line-removed">139     static VarHandle shortHandle = shorts.varHandle(short.class, PathElement.sequenceElement());</span>
<span class="line-removed">140     static VarHandle intHandle = ints.varHandle(int.class, PathElement.sequenceElement());</span>
<span class="line-removed">141     static VarHandle floatHandle = floats.varHandle(float.class, PathElement.sequenceElement());</span>
<span class="line-removed">142     static VarHandle longHandle = longs.varHandle(long.class, PathElement.sequenceElement());</span>
<span class="line-removed">143     static VarHandle doubleHandle = doubles.varHandle(double.class, PathElement.sequenceElement());</span>
<span class="line-removed">144 </span>
<span class="line-removed">145 </span>
146     static void initTuples(MemoryAddress base, long count) {
147         for (long i = 0; i &lt; count ; i++) {
148             indexHandle.set(base, i, (int)i);
149             valueHandle.set(base, i, (float)(i / 500f));
150         }
151     }
152 
153     static void checkTuples(MemoryAddress base, ByteBuffer bb, long count) {
154         for (long i = 0; i &lt; count ; i++) {
155             int index;
156             float value;
157             assertEquals(index = bb.getInt(), (int)indexHandle.get(base, i));
158             assertEquals(value = bb.getFloat(), (float)valueHandle.get(base, i));
159             assertEquals(value, index / 500f);
160         }
161     }
162 
163     static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer&lt;MemoryAddress, Long&gt; handleSetter) {
164         for (long i = 0; i &lt; seq.elementCount().getAsLong() ; i++) {
165             handleSetter.accept(base, i);
166         }
167     }
168 
169     static &lt;Z extends Buffer&gt; void checkBytes(MemoryAddress base, SequenceLayout layout,
170                                               Function&lt;ByteBuffer, Z&gt; bufFactory,
171                                               BiFunction&lt;MemoryAddress, Long, Object&gt; handleExtractor,
172                                               Function&lt;Z, Object&gt; bufferExtractor) {
173         long nelems = layout.elementCount().getAsLong();
174         long elemSize = layout.elementLayout().byteSize();
175         for (long i = 0 ; i &lt; nelems ; i++) {
176             long limit = nelems - i;
177             MemorySegment resizedSegment = base.segment().asSlice(i * elemSize, limit * elemSize);
<span class="line-modified">178             ByteBuffer bb = resizedSegment.asByteBuffer();</span>
179             Z z = bufFactory.apply(bb);
180             for (long j = i ; j &lt; limit ; j++) {
181                 Object handleValue = handleExtractor.apply(resizedSegment.baseAddress(), j - i);
182                 Object bufferValue = bufferExtractor.apply(z);
183                 if (handleValue instanceof Number) {
184                     assertEquals(((Number)handleValue).longValue(), j);
185                     assertEquals(((Number)bufferValue).longValue(), j);
186                 } else {
187                     assertEquals((long)(char)handleValue, j);
188                     assertEquals((long)(char)bufferValue, j);
189                 }
190             }
191         }
192     }
193 
194     @Test
195     public void testOffheap() {
<span class="line-modified">196         try (MemorySegment segment = MemorySegment.allocateNative(tuples)) {</span>
197             MemoryAddress base = segment.baseAddress();
198             initTuples(base, tuples.elementCount().getAsLong());
199 
<span class="line-modified">200             ByteBuffer bb = segment.asByteBuffer();</span>
201             checkTuples(base, bb, tuples.elementCount().getAsLong());
202         }
203     }
204 
205     @Test
206     public void testHeap() {
207         byte[] arr = new byte[(int) tuples.byteSize()];
<span class="line-modified">208         MemorySegment region = MemorySegment.ofArray(arr);</span>
209         MemoryAddress base = region.baseAddress();
210         initTuples(base, tuples.elementCount().getAsLong());
211 
<span class="line-modified">212         ByteBuffer bb = region.asByteBuffer();</span>
213         checkTuples(base, bb, tuples.elementCount().getAsLong());
214     }
215 
216     @Test
217     public void testChannel() throws Throwable {
218         File f = new File(&quot;test.out&quot;);
219         assertTrue(f.createNewFile());
220         f.deleteOnExit();
221 
222         //write to channel
223         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
224             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -&gt; {
<span class="line-modified">225                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);</span>
226                 MemoryAddress base = segment.baseAddress();
227                 initTuples(base, tuples.elementCount().getAsLong());
228                 mbb.force();
229             });
230         }
231 
232         //read from channel
233         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
234             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -&gt; {
<span class="line-modified">235                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);</span>
236                 MemoryAddress base = segment.baseAddress();
237                 checkTuples(base, mbb, tuples.elementCount().getAsLong());
238             });
239         }
240     }
241 
242     @Test
243     public void testDefaultAccessModesMappedSegment() throws Throwable {
<span class="line-modified">244         try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {</span>
245             assertTrue(segment.hasAccessModes(ALL_ACCESS));
246             assertEquals(segment.accessModes(), ALL_ACCESS);
247         }
248 
<span class="line-modified">249         try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {</span>
250             assertTrue(segment.hasAccessModes(ALL_ACCESS &amp; ~WRITE));
251             assertEquals(segment.accessModes(), ALL_ACCESS &amp; ~WRITE);
252         }
253     }
254 
255     @Test
256     public void testMappedSegment() throws Throwable {
257         File f = new File(&quot;test2.out&quot;);
258         f.createNewFile();
259         f.deleteOnExit();
260 
261         //write to channel
<span class="line-modified">262         try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {</span>
263             MemoryAddress base = segment.baseAddress();
264             initTuples(base, tuples.elementCount().getAsLong());
265             segment.force();
266         }
267 
268         //read from channel
<span class="line-modified">269         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {</span>
270             MemoryAddress base = segment.baseAddress();
<span class="line-modified">271             checkTuples(base, segment.asByteBuffer(), tuples.elementCount().getAsLong());</span>
272         }
273     }
274 
275     @Test
276     public void testMappedSegmentOffset() throws Throwable {
277         File f = new File(&quot;test3.out&quot;);
278         f.createNewFile();
279         f.deleteOnExit();
280 
281         MemoryLayout tupleLayout = tuples.elementLayout();
282 
283         // write one at a time
284         for (int i = 0 ; i &lt; tuples.byteSize() ; i += tupleLayout.byteSize()) {
285             //write to channel
<span class="line-modified">286             try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {</span>
287                 MemoryAddress base = segment.baseAddress();
288                 initTuples(base, 1);
289                 segment.force();
290             }
291         }
292 
293         // check one at a time
294         for (int i = 0 ; i &lt; tuples.byteSize() ; i += tupleLayout.byteSize()) {
295             //read from channel
<span class="line-modified">296             try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {</span>
297                 MemoryAddress base = segment.baseAddress();
<span class="line-modified">298                 checkTuples(base, segment.asByteBuffer(), 1);</span>
299             }
300         }
301     }
302 
303     static void withMappedBuffer(FileChannel channel, FileChannel.MapMode mode, long pos, long size, Consumer&lt;MappedByteBuffer&gt; action) throws Throwable {
304         MappedByteBuffer mbb = channel.map(mode, pos, size);
305         var ref = new WeakReference&lt;&gt;(mbb);
306         action.accept(mbb);
307         mbb = null;
308         //wait for it to be GCed
309         System.gc();
310         while (ref.get() != null) {
311             Thread.sleep(20);
312         }
313     }
314 
315     static void checkByteArrayAlignment(MemoryLayout layout) {
316         if (layout.bitSize() &gt; 32
317                 &amp;&amp; System.getProperty(&quot;sun.arch.data.model&quot;).equals(&quot;32&quot;)) {
318             throw new SkipException(&quot;avoid unaligned access on 32-bit system&quot;);
319         }
320     }
321 
322     @Test(dataProvider = &quot;bufferOps&quot;)
323     public void testScopedBuffer(Function&lt;ByteBuffer, Buffer&gt; bufferFactory, Map&lt;Method, Object[]&gt; members) {
324         Buffer bb;
<span class="line-modified">325         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {</span>
326             MemoryAddress base = segment.baseAddress();
<span class="line-modified">327             bb = bufferFactory.apply(segment.asByteBuffer());</span>
328         }
329         //outside of scope!!
330         for (Map.Entry&lt;Method, Object[]&gt; e : members.entrySet()) {
331             if (!e.getKey().getName().contains(&quot;get&quot;) &amp;&amp;
332                             !e.getKey().getName().contains(&quot;put&quot;)) {
333                 //skip
334                 return;
335             }
336             try {
337                 e.getKey().invoke(bb, e.getValue());
338                 assertTrue(false);
339             } catch (InvocationTargetException ex) {
340                 Throwable cause = ex.getCause();
341                 if (cause instanceof IllegalStateException) {
342                     //all get/set buffer operation should fail because of the scope check
343                     assertTrue(ex.getCause().getMessage().contains(&quot;already closed&quot;));
344                 } else {
345                     //all other exceptions were unexpected - fail
346                     assertTrue(false);
347                 }
348             } catch (Throwable ex) {
349                 //unexpected exception - fail
350                 assertTrue(false);
351             }
352         }
353     }
354 
355     @Test(dataProvider = &quot;bufferHandleOps&quot;)
356     public void testScopedBufferAndVarHandle(VarHandle bufferHandle) {
357         ByteBuffer bb;
<span class="line-modified">358         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {</span>
<span class="line-modified">359             bb = segment.asByteBuffer();</span>
360             for (Map.Entry&lt;MethodHandle, Object[]&gt; e : varHandleMembers(bb, bufferHandle).entrySet()) {
361                 MethodHandle handle = e.getKey().bindTo(bufferHandle)
362                         .asSpreader(Object[].class, e.getValue().length);
363                 try {
364                     handle.invoke(e.getValue());
365                 } catch (UnsupportedOperationException ex) {
366                     //skip
367                 } catch (Throwable ex) {
368                     //should not fail - segment is alive!
369                     fail();
370                 }
371             }
372         }
373         for (Map.Entry&lt;MethodHandle, Object[]&gt; e : varHandleMembers(bb, bufferHandle).entrySet()) {
374             try {
375                 MethodHandle handle = e.getKey().bindTo(bufferHandle)
376                         .asSpreader(Object[].class, e.getValue().length);
377                 handle.invoke(e.getValue());
378                 fail();
379             } catch (IllegalStateException ex) {
380                 assertTrue(ex.getMessage().contains(&quot;already closed&quot;));
381             } catch (UnsupportedOperationException ex) {
382                 //skip
383             } catch (Throwable ex) {
384                 fail();
385             }
386         }
387     }
388 
389     @Test(dataProvider = &quot;bufferOps&quot;)
390     public void testDirectBuffer(Function&lt;ByteBuffer, Buffer&gt; bufferFactory, Map&lt;Method, Object[]&gt; members) {
<span class="line-modified">391         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {</span>
392             MemoryAddress base = segment.baseAddress();
<span class="line-modified">393             Buffer bb = bufferFactory.apply(segment.asByteBuffer());</span>
394             assertTrue(bb.isDirect());
395             DirectBuffer directBuffer = ((DirectBuffer)bb);
396             assertEquals(directBuffer.address(), ((MemoryAddressImpl)base).unsafeGetOffset());
397             assertTrue((directBuffer.attachment() == null) == (bb instanceof ByteBuffer));
398             assertTrue(directBuffer.cleaner() == null);
399         }
400     }
401 
402     @Test(dataProvider=&quot;resizeOps&quot;)
403     public void testResizeOffheap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
<span class="line-modified">404         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {</span>
405             MemoryAddress base = segment.baseAddress();
406             initializer.accept(base);
407             checker.accept(base);
408         }
409     }
410 
411     @Test(dataProvider=&quot;resizeOps&quot;)
412     public void testResizeHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
413         checkByteArrayAlignment(seq.elementLayout());
414         int capacity = (int)seq.byteSize();
<span class="line-modified">415         MemoryAddress base = MemorySegment.ofArray(new byte[capacity]).baseAddress();</span>
416         initializer.accept(base);
417         checker.accept(base);
418     }
419 
420     @Test(dataProvider=&quot;resizeOps&quot;)
421     public void testResizeBuffer(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
422         checkByteArrayAlignment(seq.elementLayout());
423         int capacity = (int)seq.byteSize();
<span class="line-modified">424         MemoryAddress base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity])).baseAddress();</span>
425         initializer.accept(base);
426         checker.accept(base);
427     }
428 
429     @Test(dataProvider=&quot;resizeOps&quot;)
430     public void testResizeRoundtripHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
431         checkByteArrayAlignment(seq.elementLayout());
432         int capacity = (int)seq.byteSize();
433         byte[] arr = new byte[capacity];
<span class="line-modified">434         MemorySegment segment = MemorySegment.ofArray(arr);</span>
435         MemoryAddress first = segment.baseAddress();
436         initializer.accept(first);
<span class="line-modified">437         MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();</span>
438         checker.accept(second);
439     }
440 
441     @Test(dataProvider=&quot;resizeOps&quot;)
442     public void testResizeRoundtripNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
<span class="line-modified">443         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {</span>
444             MemoryAddress first = segment.baseAddress();
445             initializer.accept(first);
<span class="line-modified">446             MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();</span>
447             checker.accept(second);
448         }
449     }
450 
451     @Test(expectedExceptions = IllegalStateException.class)
452     public void testBufferOnClosedScope() {
453         MemorySegment leaked;
<span class="line-modified">454         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {</span>
455             leaked = segment;
456         }
<span class="line-modified">457         ByteBuffer byteBuffer = leaked.asByteBuffer(); // ok</span>
458         byteBuffer.get(); // should throw
459     }
460 
461     @Test(expectedExceptions = { UnsupportedOperationException.class,
462                                  IllegalArgumentException.class })
463     public void testTooBigForByteBuffer() {
<span class="line-modified">464         try (MemorySegment segment = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L)) {</span>
<span class="line-modified">465             segment.asByteBuffer();</span>
466         }
467     }
468 
469     @Test(expectedExceptions = IllegalArgumentException.class)
470     public void testBadMapNegativeSize() throws IOException {
471         File f = new File(&quot;testNeg1.out&quot;);
472         f.createNewFile();
473         f.deleteOnExit();
<span class="line-modified">474         MemorySegment.mapFromPath(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE);</span>
475     }
476 
477     @Test(expectedExceptions = IllegalArgumentException.class)
478     public void testBadMapNegativeOffset() throws IOException {
479         File f = new File(&quot;testNeg2.out&quot;);
480         f.createNewFile();
481         f.deleteOnExit();
<span class="line-modified">482         MemorySegment.mapFromPath(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE);</span>
483     }
484 
485     public void testMapZeroSize() throws IOException {
486         File f = new File(&quot;testPos1.out&quot;);
487         f.createNewFile();
488         f.deleteOnExit();
<span class="line-modified">489         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE)) {</span>
490             assertEquals(segment.byteSize(), 0);
491         }
492     }
493 
494     @Test(dataProvider=&quot;resizeOps&quot;)
495     public void testCopyHeapToNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
496         checkByteArrayAlignment(seq.elementLayout());
497         int bytes = (int)seq.byteSize();
<span class="line-modified">498         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);</span>
<span class="line-modified">499              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {</span>
500             initializer.accept(heapArray.baseAddress());
<span class="line-modified">501             nativeArray.copyFrom(heapArray);</span>
502             checker.accept(nativeArray.baseAddress());
503         }
504     }
505 
506     @Test(dataProvider=&quot;resizeOps&quot;)
507     public void testCopyNativeToHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
508         checkByteArrayAlignment(seq.elementLayout());
509         int bytes = (int)seq.byteSize();
<span class="line-modified">510         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);</span>
<span class="line-modified">511              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {</span>
512             initializer.accept(nativeArray.baseAddress());
<span class="line-modified">513             heapArray.copyFrom(nativeArray);</span>
514             checker.accept(heapArray.baseAddress());
515         }
516     }
517 
518     @Test
519     public void testDefaultAccessModesOfBuffer() {
520         ByteBuffer rwBuffer = ByteBuffer.wrap(new byte[4]);
<span class="line-modified">521         try (MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer)) {</span>
522             assertTrue(segment.hasAccessModes(ALL_ACCESS));
523             assertEquals(segment.accessModes(), ALL_ACCESS);
524         }
525 
526         ByteBuffer roBuffer = rwBuffer.asReadOnlyBuffer();
<span class="line-modified">527         try (MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer)) {</span>
528             assertTrue(segment.hasAccessModes(ALL_ACCESS &amp; ~WRITE));
529             assertEquals(segment.accessModes(), ALL_ACCESS &amp; ~WRITE);
530         }
531     }
532 
533     @Test(dataProvider=&quot;bufferSources&quot;)
534     public void testBufferToSegment(ByteBuffer bb, Predicate&lt;MemorySegment&gt; segmentChecker) {
<span class="line-modified">535         MemorySegment segment = MemorySegment.ofByteBuffer(bb);</span>
536         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
537         assertTrue(segmentChecker.test(segment));
538         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
539         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
540         assertEquals(bb.capacity(), segment.byteSize());
541         //another round trip
<span class="line-modified">542         segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());</span>
543         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
544         assertTrue(segmentChecker.test(segment));
545         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
546         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
547         assertEquals(bb.capacity(), segment.byteSize());
548     }
549 
550     @Test
551     public void testRoundTripAccess() {
<span class="line-modified">552         try(MemorySegment ms = MemorySegment.allocateNative(4)) {</span>
553             MemorySegment msNoAccess = ms.withAccessModes(MemorySegment.READ); // READ is required to make BB
<span class="line-modified">554             MemorySegment msRoundTrip = MemorySegment.ofByteBuffer(msNoAccess.asByteBuffer());</span>
555             assertEquals(msNoAccess.accessModes(), msRoundTrip.accessModes());
556         }
557     }
558 
559     @Test(expectedExceptions = IllegalStateException.class)
560     public void testDeadAccessOnClosedBufferSegment() {
<span class="line-modified">561         MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT);</span>
<span class="line-modified">562         MemorySegment s2 = MemorySegment.ofByteBuffer(s1.asByteBuffer());</span>
563 
564         s1.close(); // memory freed
565 
<span class="line-modified">566         intHandle.set(s2.baseAddress(), 0L, 10); // Dead access!</span>
567     }
568 
569     @DataProvider(name = &quot;bufferOps&quot;)
570     public static Object[][] bufferOps() throws Throwable {
571         return new Object[][]{
572                 { (Function&lt;ByteBuffer, Buffer&gt;) bb -&gt; bb, bufferMembers(ByteBuffer.class)},
573                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asCharBuffer, bufferMembers(CharBuffer.class)},
574                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asShortBuffer, bufferMembers(ShortBuffer.class)},
575                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asIntBuffer, bufferMembers(IntBuffer.class)},
576                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asFloatBuffer, bufferMembers(FloatBuffer.class)},
577                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asLongBuffer, bufferMembers(LongBuffer.class)},
578                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asDoubleBuffer, bufferMembers(DoubleBuffer.class)},
579         };
580     }
581 
582     static Map&lt;Method, Object[]&gt; bufferMembers(Class&lt;?&gt; bufferClass) {
583         Map&lt;Method, Object[]&gt; members = new HashMap&lt;&gt;();
584         for (Method m : bufferClass.getMethods()) {
585             //skip statics and method declared in j.l.Object
586             if (m.getDeclaringClass().equals(Object.class) ||
</pre>
<hr />
<pre>
607 
608     static Map&lt;MethodHandle, Object[]&gt; varHandleMembers(ByteBuffer bb, VarHandle handle) {
609         Map&lt;MethodHandle, Object[]&gt; members = new HashMap&lt;&gt;();
610         for (VarHandle.AccessMode mode : VarHandle.AccessMode.values()) {
611             Class&lt;?&gt;[] params = handle.accessModeType(mode).parameterArray();
612             Object[] args = Stream.concat(Stream.of(bb), Stream.of(params).skip(1)
613                     .map(TestByteBuffer::defaultValue))
614                     .toArray();
615             try {
616                 members.put(MethodHandles.varHandleInvoker(mode, handle.accessModeType(mode)), args);
617             } catch (Throwable ex) {
618                 throw new AssertionError(ex);
619             }
620         }
621         return members;
622     }
623 
624     @DataProvider(name = &quot;resizeOps&quot;)
625     public Object[][] resizeOps() {
626         Consumer&lt;MemoryAddress&gt; byteInitializer =
<span class="line-modified">627                 (base) -&gt; initBytes(base, bytes, (addr, pos) -&gt; byteHandle.set(addr, pos, (byte)(long)pos));</span>
628         Consumer&lt;MemoryAddress&gt; charInitializer =
<span class="line-modified">629                 (base) -&gt; initBytes(base, chars, (addr, pos) -&gt; charHandle.set(addr, pos, (char)(long)pos));</span>
630         Consumer&lt;MemoryAddress&gt; shortInitializer =
<span class="line-modified">631                 (base) -&gt; initBytes(base, shorts, (addr, pos) -&gt; shortHandle.set(addr, pos, (short)(long)pos));</span>
632         Consumer&lt;MemoryAddress&gt; intInitializer =
<span class="line-modified">633                 (base) -&gt; initBytes(base, ints, (addr, pos) -&gt; intHandle.set(addr, pos, (int)(long)pos));</span>
634         Consumer&lt;MemoryAddress&gt; floatInitializer =
<span class="line-modified">635                 (base) -&gt; initBytes(base, floats, (addr, pos) -&gt; floatHandle.set(addr, pos, (float)(long)pos));</span>
636         Consumer&lt;MemoryAddress&gt; longInitializer =
<span class="line-modified">637                 (base) -&gt; initBytes(base, longs, (addr, pos) -&gt; longHandle.set(addr, pos, (long)pos));</span>
638         Consumer&lt;MemoryAddress&gt; doubleInitializer =
<span class="line-modified">639                 (base) -&gt; initBytes(base, doubles, (addr, pos) -&gt; doubleHandle.set(addr, pos, (double)(long)pos));</span>
640 
641         Consumer&lt;MemoryAddress&gt; byteChecker =
<span class="line-modified">642                 (base) -&gt; checkBytes(base, bytes, Function.identity(), byteHandle::get, ByteBuffer::get);</span>
643         Consumer&lt;MemoryAddress&gt; charChecker =
<span class="line-modified">644                 (base) -&gt; checkBytes(base, chars, ByteBuffer::asCharBuffer, charHandle::get, CharBuffer::get);</span>
645         Consumer&lt;MemoryAddress&gt; shortChecker =
<span class="line-modified">646                 (base) -&gt; checkBytes(base, shorts, ByteBuffer::asShortBuffer, shortHandle::get, ShortBuffer::get);</span>
647         Consumer&lt;MemoryAddress&gt; intChecker =
<span class="line-modified">648                 (base) -&gt; checkBytes(base, ints, ByteBuffer::asIntBuffer, intHandle::get, IntBuffer::get);</span>
649         Consumer&lt;MemoryAddress&gt; floatChecker =
<span class="line-modified">650                 (base) -&gt; checkBytes(base, floats, ByteBuffer::asFloatBuffer, floatHandle::get, FloatBuffer::get);</span>
651         Consumer&lt;MemoryAddress&gt; longChecker =
<span class="line-modified">652                 (base) -&gt; checkBytes(base, longs, ByteBuffer::asLongBuffer, longHandle::get, LongBuffer::get);</span>
653         Consumer&lt;MemoryAddress&gt; doubleChecker =
<span class="line-modified">654                 (base) -&gt; checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, doubleHandle::get, DoubleBuffer::get);</span>
655 
656         return new Object[][]{
657                 {byteChecker, byteInitializer, bytes},
658                 {charChecker, charInitializer, chars},
659                 {shortChecker, shortInitializer, shorts},
660                 {intChecker, intInitializer, ints},
661                 {floatChecker, floatInitializer, floats},
662                 {longChecker, longInitializer, longs},
663                 {doubleChecker, doubleInitializer, doubles}
664         };
665     }
666 
667     static Object defaultValue(Class&lt;?&gt; c) {
668         if (c.isPrimitive()) {
669             if (c == char.class) {
670                 return (char)0;
671             } else if (c == boolean.class) {
672                 return false;
673             } else if (c == byte.class) {
674                 return (byte)0;
</pre>
</td>
<td>
<hr />
<pre>
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * @test
 28  * @modules java.base/sun.nio.ch
 29  *          jdk.incubator.foreign/jdk.internal.foreign
 30  * @run testng TestByteBuffer
 31  */
 32 
 33 
 34 import jdk.incubator.foreign.MappedMemorySegment;
 35 import jdk.incubator.foreign.MemoryLayouts;
 36 import jdk.incubator.foreign.MemoryLayout;
 37 import jdk.incubator.foreign.MemoryAddress;
 38 import jdk.incubator.foreign.MemorySegment;
 39 import jdk.incubator.foreign.MemoryLayout.PathElement;
<span class="line-added"> 40 import jdk.incubator.foreign.MemorySegments;</span>
 41 import jdk.incubator.foreign.SequenceLayout;
 42 
 43 import java.io.File;
 44 import java.io.IOException;
 45 import java.lang.invoke.MethodHandle;
 46 import java.lang.invoke.MethodHandles;
 47 import java.lang.invoke.VarHandle;
 48 import java.lang.ref.WeakReference;
 49 import java.lang.reflect.InvocationTargetException;
 50 import java.lang.reflect.Method;
 51 import java.lang.reflect.Modifier;
 52 import java.nio.Buffer;
 53 import java.nio.ByteBuffer;
 54 import java.nio.ByteOrder;
 55 import java.nio.CharBuffer;
 56 import java.nio.DoubleBuffer;
 57 import java.nio.FloatBuffer;
 58 import java.nio.IntBuffer;
 59 import java.nio.LongBuffer;
 60 import java.nio.MappedByteBuffer;
</pre>
<hr />
<pre>
118 
119     static SequenceLayout ints = MemoryLayout.ofSequence(100,
120             MemoryLayouts.BITS_32_BE
121     );
122 
123     static SequenceLayout floats = MemoryLayout.ofSequence(100,
124             MemoryLayouts.BITS_32_BE
125     );
126 
127     static SequenceLayout longs = MemoryLayout.ofSequence(100,
128             MemoryLayouts.BITS_64_BE
129     );
130 
131     static SequenceLayout doubles = MemoryLayout.ofSequence(100,
132             MemoryLayouts.BITS_64_BE
133     );
134 
135     static VarHandle indexHandle = tuples.varHandle(int.class, PathElement.sequenceElement(), PathElement.groupElement(&quot;index&quot;));
136     static VarHandle valueHandle = tuples.varHandle(float.class, PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
137 









138     static void initTuples(MemoryAddress base, long count) {
139         for (long i = 0; i &lt; count ; i++) {
140             indexHandle.set(base, i, (int)i);
141             valueHandle.set(base, i, (float)(i / 500f));
142         }
143     }
144 
145     static void checkTuples(MemoryAddress base, ByteBuffer bb, long count) {
146         for (long i = 0; i &lt; count ; i++) {
147             int index;
148             float value;
149             assertEquals(index = bb.getInt(), (int)indexHandle.get(base, i));
150             assertEquals(value = bb.getFloat(), (float)valueHandle.get(base, i));
151             assertEquals(value, index / 500f);
152         }
153     }
154 
155     static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer&lt;MemoryAddress, Long&gt; handleSetter) {
156         for (long i = 0; i &lt; seq.elementCount().getAsLong() ; i++) {
157             handleSetter.accept(base, i);
158         }
159     }
160 
161     static &lt;Z extends Buffer&gt; void checkBytes(MemoryAddress base, SequenceLayout layout,
162                                               Function&lt;ByteBuffer, Z&gt; bufFactory,
163                                               BiFunction&lt;MemoryAddress, Long, Object&gt; handleExtractor,
164                                               Function&lt;Z, Object&gt; bufferExtractor) {
165         long nelems = layout.elementCount().getAsLong();
166         long elemSize = layout.elementLayout().byteSize();
167         for (long i = 0 ; i &lt; nelems ; i++) {
168             long limit = nelems - i;
169             MemorySegment resizedSegment = base.segment().asSlice(i * elemSize, limit * elemSize);
<span class="line-modified">170             ByteBuffer bb = MemorySegments.asByteBuffer(resizedSegment);</span>
171             Z z = bufFactory.apply(bb);
172             for (long j = i ; j &lt; limit ; j++) {
173                 Object handleValue = handleExtractor.apply(resizedSegment.baseAddress(), j - i);
174                 Object bufferValue = bufferExtractor.apply(z);
175                 if (handleValue instanceof Number) {
176                     assertEquals(((Number)handleValue).longValue(), j);
177                     assertEquals(((Number)bufferValue).longValue(), j);
178                 } else {
179                     assertEquals((long)(char)handleValue, j);
180                     assertEquals((long)(char)bufferValue, j);
181                 }
182             }
183         }
184     }
185 
186     @Test
187     public void testOffheap() {
<span class="line-modified">188         try (MemorySegment segment = MemorySegments.allocateNative(tuples)) {</span>
189             MemoryAddress base = segment.baseAddress();
190             initTuples(base, tuples.elementCount().getAsLong());
191 
<span class="line-modified">192             ByteBuffer bb = MemorySegments.asByteBuffer(segment);</span>
193             checkTuples(base, bb, tuples.elementCount().getAsLong());
194         }
195     }
196 
197     @Test
198     public void testHeap() {
199         byte[] arr = new byte[(int) tuples.byteSize()];
<span class="line-modified">200         MemorySegment region = MemorySegments.ofArray(arr);</span>
201         MemoryAddress base = region.baseAddress();
202         initTuples(base, tuples.elementCount().getAsLong());
203 
<span class="line-modified">204         ByteBuffer bb = MemorySegments.asByteBuffer(region);</span>
205         checkTuples(base, bb, tuples.elementCount().getAsLong());
206     }
207 
208     @Test
209     public void testChannel() throws Throwable {
210         File f = new File(&quot;test.out&quot;);
211         assertTrue(f.createNewFile());
212         f.deleteOnExit();
213 
214         //write to channel
215         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
216             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -&gt; {
<span class="line-modified">217                 MemorySegment segment = MemorySegments.ofByteBuffer(mbb);</span>
218                 MemoryAddress base = segment.baseAddress();
219                 initTuples(base, tuples.elementCount().getAsLong());
220                 mbb.force();
221             });
222         }
223 
224         //read from channel
225         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
226             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -&gt; {
<span class="line-modified">227                 MemorySegment segment = MemorySegments.ofByteBuffer(mbb);</span>
228                 MemoryAddress base = segment.baseAddress();
229                 checkTuples(base, mbb, tuples.elementCount().getAsLong());
230             });
231         }
232     }
233 
234     @Test
235     public void testDefaultAccessModesMappedSegment() throws Throwable {
<span class="line-modified">236         try (MappedMemorySegment segment = MemorySegments.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {</span>
237             assertTrue(segment.hasAccessModes(ALL_ACCESS));
238             assertEquals(segment.accessModes(), ALL_ACCESS);
239         }
240 
<span class="line-modified">241         try (MappedMemorySegment segment = MemorySegments.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {</span>
242             assertTrue(segment.hasAccessModes(ALL_ACCESS &amp; ~WRITE));
243             assertEquals(segment.accessModes(), ALL_ACCESS &amp; ~WRITE);
244         }
245     }
246 
247     @Test
248     public void testMappedSegment() throws Throwable {
249         File f = new File(&quot;test2.out&quot;);
250         f.createNewFile();
251         f.deleteOnExit();
252 
253         //write to channel
<span class="line-modified">254         try (MappedMemorySegment segment = MemorySegments.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {</span>
255             MemoryAddress base = segment.baseAddress();
256             initTuples(base, tuples.elementCount().getAsLong());
257             segment.force();
258         }
259 
260         //read from channel
<span class="line-modified">261         try (MemorySegment segment = MemorySegments.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {</span>
262             MemoryAddress base = segment.baseAddress();
<span class="line-modified">263             checkTuples(base, MemorySegments.asByteBuffer(segment), tuples.elementCount().getAsLong());</span>
264         }
265     }
266 
267     @Test
268     public void testMappedSegmentOffset() throws Throwable {
269         File f = new File(&quot;test3.out&quot;);
270         f.createNewFile();
271         f.deleteOnExit();
272 
273         MemoryLayout tupleLayout = tuples.elementLayout();
274 
275         // write one at a time
276         for (int i = 0 ; i &lt; tuples.byteSize() ; i += tupleLayout.byteSize()) {
277             //write to channel
<span class="line-modified">278             try (MappedMemorySegment segment = MemorySegments.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {</span>
279                 MemoryAddress base = segment.baseAddress();
280                 initTuples(base, 1);
281                 segment.force();
282             }
283         }
284 
285         // check one at a time
286         for (int i = 0 ; i &lt; tuples.byteSize() ; i += tupleLayout.byteSize()) {
287             //read from channel
<span class="line-modified">288             try (MemorySegment segment = MemorySegments.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {</span>
289                 MemoryAddress base = segment.baseAddress();
<span class="line-modified">290                 checkTuples(base, MemorySegments.asByteBuffer(segment), 1);</span>
291             }
292         }
293     }
294 
295     static void withMappedBuffer(FileChannel channel, FileChannel.MapMode mode, long pos, long size, Consumer&lt;MappedByteBuffer&gt; action) throws Throwable {
296         MappedByteBuffer mbb = channel.map(mode, pos, size);
297         var ref = new WeakReference&lt;&gt;(mbb);
298         action.accept(mbb);
299         mbb = null;
300         //wait for it to be GCed
301         System.gc();
302         while (ref.get() != null) {
303             Thread.sleep(20);
304         }
305     }
306 
307     static void checkByteArrayAlignment(MemoryLayout layout) {
308         if (layout.bitSize() &gt; 32
309                 &amp;&amp; System.getProperty(&quot;sun.arch.data.model&quot;).equals(&quot;32&quot;)) {
310             throw new SkipException(&quot;avoid unaligned access on 32-bit system&quot;);
311         }
312     }
313 
314     @Test(dataProvider = &quot;bufferOps&quot;)
315     public void testScopedBuffer(Function&lt;ByteBuffer, Buffer&gt; bufferFactory, Map&lt;Method, Object[]&gt; members) {
316         Buffer bb;
<span class="line-modified">317         try (MemorySegment segment = MemorySegments.allocateNative(bytes)) {</span>
318             MemoryAddress base = segment.baseAddress();
<span class="line-modified">319             bb = bufferFactory.apply(MemorySegments.asByteBuffer(segment));</span>
320         }
321         //outside of scope!!
322         for (Map.Entry&lt;Method, Object[]&gt; e : members.entrySet()) {
323             if (!e.getKey().getName().contains(&quot;get&quot;) &amp;&amp;
324                             !e.getKey().getName().contains(&quot;put&quot;)) {
325                 //skip
326                 return;
327             }
328             try {
329                 e.getKey().invoke(bb, e.getValue());
330                 assertTrue(false);
331             } catch (InvocationTargetException ex) {
332                 Throwable cause = ex.getCause();
333                 if (cause instanceof IllegalStateException) {
334                     //all get/set buffer operation should fail because of the scope check
335                     assertTrue(ex.getCause().getMessage().contains(&quot;already closed&quot;));
336                 } else {
337                     //all other exceptions were unexpected - fail
338                     assertTrue(false);
339                 }
340             } catch (Throwable ex) {
341                 //unexpected exception - fail
342                 assertTrue(false);
343             }
344         }
345     }
346 
347     @Test(dataProvider = &quot;bufferHandleOps&quot;)
348     public void testScopedBufferAndVarHandle(VarHandle bufferHandle) {
349         ByteBuffer bb;
<span class="line-modified">350         try (MemorySegment segment = MemorySegments.allocateNative(bytes)) {</span>
<span class="line-modified">351             bb = MemorySegments.asByteBuffer(segment);</span>
352             for (Map.Entry&lt;MethodHandle, Object[]&gt; e : varHandleMembers(bb, bufferHandle).entrySet()) {
353                 MethodHandle handle = e.getKey().bindTo(bufferHandle)
354                         .asSpreader(Object[].class, e.getValue().length);
355                 try {
356                     handle.invoke(e.getValue());
357                 } catch (UnsupportedOperationException ex) {
358                     //skip
359                 } catch (Throwable ex) {
360                     //should not fail - segment is alive!
361                     fail();
362                 }
363             }
364         }
365         for (Map.Entry&lt;MethodHandle, Object[]&gt; e : varHandleMembers(bb, bufferHandle).entrySet()) {
366             try {
367                 MethodHandle handle = e.getKey().bindTo(bufferHandle)
368                         .asSpreader(Object[].class, e.getValue().length);
369                 handle.invoke(e.getValue());
370                 fail();
371             } catch (IllegalStateException ex) {
372                 assertTrue(ex.getMessage().contains(&quot;already closed&quot;));
373             } catch (UnsupportedOperationException ex) {
374                 //skip
375             } catch (Throwable ex) {
376                 fail();
377             }
378         }
379     }
380 
381     @Test(dataProvider = &quot;bufferOps&quot;)
382     public void testDirectBuffer(Function&lt;ByteBuffer, Buffer&gt; bufferFactory, Map&lt;Method, Object[]&gt; members) {
<span class="line-modified">383         try (MemorySegment segment = MemorySegments.allocateNative(bytes)) {</span>
384             MemoryAddress base = segment.baseAddress();
<span class="line-modified">385             Buffer bb = bufferFactory.apply(MemorySegments.asByteBuffer(segment));</span>
386             assertTrue(bb.isDirect());
387             DirectBuffer directBuffer = ((DirectBuffer)bb);
388             assertEquals(directBuffer.address(), ((MemoryAddressImpl)base).unsafeGetOffset());
389             assertTrue((directBuffer.attachment() == null) == (bb instanceof ByteBuffer));
390             assertTrue(directBuffer.cleaner() == null);
391         }
392     }
393 
394     @Test(dataProvider=&quot;resizeOps&quot;)
395     public void testResizeOffheap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
<span class="line-modified">396         try (MemorySegment segment = MemorySegments.allocateNative(seq)) {</span>
397             MemoryAddress base = segment.baseAddress();
398             initializer.accept(base);
399             checker.accept(base);
400         }
401     }
402 
403     @Test(dataProvider=&quot;resizeOps&quot;)
404     public void testResizeHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
405         checkByteArrayAlignment(seq.elementLayout());
406         int capacity = (int)seq.byteSize();
<span class="line-modified">407         MemoryAddress base = MemorySegments.ofArray(new byte[capacity]).baseAddress();</span>
408         initializer.accept(base);
409         checker.accept(base);
410     }
411 
412     @Test(dataProvider=&quot;resizeOps&quot;)
413     public void testResizeBuffer(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
414         checkByteArrayAlignment(seq.elementLayout());
415         int capacity = (int)seq.byteSize();
<span class="line-modified">416         MemoryAddress base = MemorySegments.ofByteBuffer(ByteBuffer.wrap(new byte[capacity])).baseAddress();</span>
417         initializer.accept(base);
418         checker.accept(base);
419     }
420 
421     @Test(dataProvider=&quot;resizeOps&quot;)
422     public void testResizeRoundtripHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
423         checkByteArrayAlignment(seq.elementLayout());
424         int capacity = (int)seq.byteSize();
425         byte[] arr = new byte[capacity];
<span class="line-modified">426         MemorySegment segment = MemorySegments.ofArray(arr);</span>
427         MemoryAddress first = segment.baseAddress();
428         initializer.accept(first);
<span class="line-modified">429         MemoryAddress second = MemorySegments.ofByteBuffer(MemorySegments.asByteBuffer(segment)).baseAddress();</span>
430         checker.accept(second);
431     }
432 
433     @Test(dataProvider=&quot;resizeOps&quot;)
434     public void testResizeRoundtripNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
<span class="line-modified">435         try (MemorySegment segment = MemorySegments.allocateNative(seq)) {</span>
436             MemoryAddress first = segment.baseAddress();
437             initializer.accept(first);
<span class="line-modified">438             MemoryAddress second = MemorySegments.ofByteBuffer(MemorySegments.asByteBuffer(segment)).baseAddress();</span>
439             checker.accept(second);
440         }
441     }
442 
443     @Test(expectedExceptions = IllegalStateException.class)
444     public void testBufferOnClosedScope() {
445         MemorySegment leaked;
<span class="line-modified">446         try (MemorySegment segment = MemorySegments.allocateNative(bytes)) {</span>
447             leaked = segment;
448         }
<span class="line-modified">449         ByteBuffer byteBuffer = MemorySegments.asByteBuffer(leaked); // ok</span>
450         byteBuffer.get(); // should throw
451     }
452 
453     @Test(expectedExceptions = { UnsupportedOperationException.class,
454                                  IllegalArgumentException.class })
455     public void testTooBigForByteBuffer() {
<span class="line-modified">456         try (MemorySegment segment = MemorySegments.allocateNative((long)Integer.MAX_VALUE + 10L)) {</span>
<span class="line-modified">457             MemorySegments.asByteBuffer(segment);</span>
458         }
459     }
460 
461     @Test(expectedExceptions = IllegalArgumentException.class)
462     public void testBadMapNegativeSize() throws IOException {
463         File f = new File(&quot;testNeg1.out&quot;);
464         f.createNewFile();
465         f.deleteOnExit();
<span class="line-modified">466         MemorySegments.mapFromPath(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE);</span>
467     }
468 
469     @Test(expectedExceptions = IllegalArgumentException.class)
470     public void testBadMapNegativeOffset() throws IOException {
471         File f = new File(&quot;testNeg2.out&quot;);
472         f.createNewFile();
473         f.deleteOnExit();
<span class="line-modified">474         MemorySegments.mapFromPath(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE);</span>
475     }
476 
477     public void testMapZeroSize() throws IOException {
478         File f = new File(&quot;testPos1.out&quot;);
479         f.createNewFile();
480         f.deleteOnExit();
<span class="line-modified">481         try (MemorySegment segment = MemorySegments.mapFromPath(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE)) {</span>
482             assertEquals(segment.byteSize(), 0);
483         }
484     }
485 
486     @Test(dataProvider=&quot;resizeOps&quot;)
487     public void testCopyHeapToNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
488         checkByteArrayAlignment(seq.elementLayout());
489         int bytes = (int)seq.byteSize();
<span class="line-modified">490         try (MemorySegment nativeArray = MemorySegments.allocateNative(bytes);</span>
<span class="line-modified">491              MemorySegment heapArray = MemorySegments.ofArray(new byte[bytes])) {</span>
492             initializer.accept(heapArray.baseAddress());
<span class="line-modified">493             MemorySegments.copy(heapArray, nativeArray);</span>
494             checker.accept(nativeArray.baseAddress());
495         }
496     }
497 
498     @Test(dataProvider=&quot;resizeOps&quot;)
499     public void testCopyNativeToHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
500         checkByteArrayAlignment(seq.elementLayout());
501         int bytes = (int)seq.byteSize();
<span class="line-modified">502         try (MemorySegment nativeArray = MemorySegments.allocateNative(seq);</span>
<span class="line-modified">503              MemorySegment heapArray = MemorySegments.ofArray(new byte[bytes])) {</span>
504             initializer.accept(nativeArray.baseAddress());
<span class="line-modified">505             MemorySegments.copy(nativeArray, heapArray);</span>
506             checker.accept(heapArray.baseAddress());
507         }
508     }
509 
510     @Test
511     public void testDefaultAccessModesOfBuffer() {
512         ByteBuffer rwBuffer = ByteBuffer.wrap(new byte[4]);
<span class="line-modified">513         try (MemorySegment segment = MemorySegments.ofByteBuffer(rwBuffer)) {</span>
514             assertTrue(segment.hasAccessModes(ALL_ACCESS));
515             assertEquals(segment.accessModes(), ALL_ACCESS);
516         }
517 
518         ByteBuffer roBuffer = rwBuffer.asReadOnlyBuffer();
<span class="line-modified">519         try (MemorySegment segment = MemorySegments.ofByteBuffer(roBuffer)) {</span>
520             assertTrue(segment.hasAccessModes(ALL_ACCESS &amp; ~WRITE));
521             assertEquals(segment.accessModes(), ALL_ACCESS &amp; ~WRITE);
522         }
523     }
524 
525     @Test(dataProvider=&quot;bufferSources&quot;)
526     public void testBufferToSegment(ByteBuffer bb, Predicate&lt;MemorySegment&gt; segmentChecker) {
<span class="line-modified">527         MemorySegment segment = MemorySegments.ofByteBuffer(bb);</span>
528         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
529         assertTrue(segmentChecker.test(segment));
530         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
531         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
532         assertEquals(bb.capacity(), segment.byteSize());
533         //another round trip
<span class="line-modified">534         segment = MemorySegments.ofByteBuffer(MemorySegments.asByteBuffer(segment));</span>
535         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
536         assertTrue(segmentChecker.test(segment));
537         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
538         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
539         assertEquals(bb.capacity(), segment.byteSize());
540     }
541 
542     @Test
543     public void testRoundTripAccess() {
<span class="line-modified">544         try(MemorySegment ms = MemorySegments.allocateNative(4)) {</span>
545             MemorySegment msNoAccess = ms.withAccessModes(MemorySegment.READ); // READ is required to make BB
<span class="line-modified">546             MemorySegment msRoundTrip = MemorySegments.ofByteBuffer(MemorySegments.asByteBuffer(msNoAccess));</span>
547             assertEquals(msNoAccess.accessModes(), msRoundTrip.accessModes());
548         }
549     }
550 
551     @Test(expectedExceptions = IllegalStateException.class)
552     public void testDeadAccessOnClosedBufferSegment() {
<span class="line-modified">553         MemorySegment s1 = MemorySegments.allocateNative(MemoryLayouts.JAVA_INT);</span>
<span class="line-modified">554         MemorySegment s2 = MemorySegments.ofByteBuffer(MemorySegments.asByteBuffer(s1));</span>
555 
556         s1.close(); // memory freed
557 
<span class="line-modified">558         MemorySegments.setInt(s2.baseAddress(), 0L, 10); // Dead access!</span>
559     }
560 
561     @DataProvider(name = &quot;bufferOps&quot;)
562     public static Object[][] bufferOps() throws Throwable {
563         return new Object[][]{
564                 { (Function&lt;ByteBuffer, Buffer&gt;) bb -&gt; bb, bufferMembers(ByteBuffer.class)},
565                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asCharBuffer, bufferMembers(CharBuffer.class)},
566                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asShortBuffer, bufferMembers(ShortBuffer.class)},
567                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asIntBuffer, bufferMembers(IntBuffer.class)},
568                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asFloatBuffer, bufferMembers(FloatBuffer.class)},
569                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asLongBuffer, bufferMembers(LongBuffer.class)},
570                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asDoubleBuffer, bufferMembers(DoubleBuffer.class)},
571         };
572     }
573 
574     static Map&lt;Method, Object[]&gt; bufferMembers(Class&lt;?&gt; bufferClass) {
575         Map&lt;Method, Object[]&gt; members = new HashMap&lt;&gt;();
576         for (Method m : bufferClass.getMethods()) {
577             //skip statics and method declared in j.l.Object
578             if (m.getDeclaringClass().equals(Object.class) ||
</pre>
<hr />
<pre>
599 
600     static Map&lt;MethodHandle, Object[]&gt; varHandleMembers(ByteBuffer bb, VarHandle handle) {
601         Map&lt;MethodHandle, Object[]&gt; members = new HashMap&lt;&gt;();
602         for (VarHandle.AccessMode mode : VarHandle.AccessMode.values()) {
603             Class&lt;?&gt;[] params = handle.accessModeType(mode).parameterArray();
604             Object[] args = Stream.concat(Stream.of(bb), Stream.of(params).skip(1)
605                     .map(TestByteBuffer::defaultValue))
606                     .toArray();
607             try {
608                 members.put(MethodHandles.varHandleInvoker(mode, handle.accessModeType(mode)), args);
609             } catch (Throwable ex) {
610                 throw new AssertionError(ex);
611             }
612         }
613         return members;
614     }
615 
616     @DataProvider(name = &quot;resizeOps&quot;)
617     public Object[][] resizeOps() {
618         Consumer&lt;MemoryAddress&gt; byteInitializer =
<span class="line-modified">619                 (base) -&gt; initBytes(base, bytes, (addr, pos) -&gt; MemorySegments.setByte_BE(addr, pos, (byte)(long)pos));</span>
620         Consumer&lt;MemoryAddress&gt; charInitializer =
<span class="line-modified">621                 (base) -&gt; initBytes(base, chars, (addr, pos) -&gt; MemorySegments.setChar_BE(addr, pos * 2, (char)(long)pos));</span>
622         Consumer&lt;MemoryAddress&gt; shortInitializer =
<span class="line-modified">623                 (base) -&gt; initBytes(base, shorts, (addr, pos) -&gt; MemorySegments.setShort_BE(addr, pos * 2, (short)(long)pos));</span>
624         Consumer&lt;MemoryAddress&gt; intInitializer =
<span class="line-modified">625                 (base) -&gt; initBytes(base, ints, (addr, pos) -&gt; MemorySegments.setInt_BE(addr, pos * 4, (int)(long)pos));</span>
626         Consumer&lt;MemoryAddress&gt; floatInitializer =
<span class="line-modified">627                 (base) -&gt; initBytes(base, floats, (addr, pos) -&gt; MemorySegments.setFloat_BE(addr, pos * 4, (float)(long)pos));</span>
628         Consumer&lt;MemoryAddress&gt; longInitializer =
<span class="line-modified">629                 (base) -&gt; initBytes(base, longs, (addr, pos) -&gt; MemorySegments.setLong_BE(addr, pos * 8, (long)pos));</span>
630         Consumer&lt;MemoryAddress&gt; doubleInitializer =
<span class="line-modified">631                 (base) -&gt; initBytes(base, doubles, (addr, pos) -&gt; MemorySegments.setDouble_BE(addr, pos * 8, (double)(long)pos));</span>
632 
633         Consumer&lt;MemoryAddress&gt; byteChecker =
<span class="line-modified">634                 (base) -&gt; checkBytes(base, bytes, Function.identity(), MemorySegments::getByte_BE, ByteBuffer::get);</span>
635         Consumer&lt;MemoryAddress&gt; charChecker =
<span class="line-modified">636                 (base) -&gt; checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -&gt; MemorySegments.getChar_BE(addr, pos * 2), CharBuffer::get);</span>
637         Consumer&lt;MemoryAddress&gt; shortChecker =
<span class="line-modified">638                 (base) -&gt; checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -&gt; MemorySegments.getShort_BE(addr, pos * 2), ShortBuffer::get);</span>
639         Consumer&lt;MemoryAddress&gt; intChecker =
<span class="line-modified">640                 (base) -&gt; checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -&gt; MemorySegments.getInt_BE(addr, pos * 4), IntBuffer::get);</span>
641         Consumer&lt;MemoryAddress&gt; floatChecker =
<span class="line-modified">642                 (base) -&gt; checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -&gt; MemorySegments.getFloat_BE(addr, pos * 4), FloatBuffer::get);</span>
643         Consumer&lt;MemoryAddress&gt; longChecker =
<span class="line-modified">644                 (base) -&gt; checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -&gt; MemorySegments.getLong_BE(addr, pos * 8), LongBuffer::get);</span>
645         Consumer&lt;MemoryAddress&gt; doubleChecker =
<span class="line-modified">646                 (base) -&gt; checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -&gt; MemorySegments.getDouble_BE(addr, pos * 8), DoubleBuffer::get);</span>
647 
648         return new Object[][]{
649                 {byteChecker, byteInitializer, bytes},
650                 {charChecker, charInitializer, chars},
651                 {shortChecker, shortInitializer, shorts},
652                 {intChecker, intInitializer, ints},
653                 {floatChecker, floatInitializer, floats},
654                 {longChecker, longInitializer, longs},
655                 {doubleChecker, doubleInitializer, doubles}
656         };
657     }
658 
659     static Object defaultValue(Class&lt;?&gt; c) {
660         if (c.isPrimitive()) {
661             if (c == char.class) {
662                 return (char)0;
663             } else if (c == boolean.class) {
664                 return false;
665             } else if (c == byte.class) {
666                 return (byte)0;
</pre>
</td>
</tr>
</table>
<center><a href="TestArrays.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestLayouts.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
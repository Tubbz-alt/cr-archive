<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/TestSpliterator.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="TestSlices.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestTypeAccess.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/TestSpliterator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @run testng TestSpliterator
 27  */
 28 
 29 import jdk.incubator.foreign.MemoryAddress;
 30 import jdk.incubator.foreign.MemoryLayout;
 31 import jdk.incubator.foreign.MemoryLayouts;
 32 import jdk.incubator.foreign.MemorySegment;

 33 import jdk.incubator.foreign.SequenceLayout;
 34 
 35 import java.lang.invoke.VarHandle;
 36 import java.util.LinkedList;
 37 import java.util.List;
 38 import java.util.Map;
 39 import java.util.Spliterator;
 40 import java.util.concurrent.CountedCompleter;
 41 import java.util.concurrent.RecursiveTask;
 42 import java.util.concurrent.atomic.AtomicLong;
 43 import java.util.function.Consumer;
 44 import java.util.function.Supplier;
 45 import java.util.stream.LongStream;
 46 import java.util.stream.StreamSupport;
 47 
 48 import org.testng.annotations.*;
 49 import static jdk.incubator.foreign.MemorySegment.*;
 50 import static org.testng.Assert.*;
 51 
 52 public class TestSpliterator {
 53 
 54     static final VarHandle INT_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)
 55             .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());
 56 
 57     final static int CARRIER_SIZE = 4;
 58 
 59     @Test(dataProvider = &quot;splits&quot;)
 60     public void testSum(int size, int threshold) {
 61         SequenceLayout layout = MemoryLayout.ofSequence(size, MemoryLayouts.JAVA_INT);
 62 
 63         //setup
<span class="line-modified"> 64         MemorySegment segment = MemorySegment.allocateNative(layout);</span>
 65         for (int i = 0; i &lt; layout.elementCount().getAsLong(); i++) {
 66             INT_HANDLE.set(segment.baseAddress(), (long) i, i);
 67         }
 68         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
 69         //serial
 70         long serial = sum(0, segment);
 71         assertEquals(serial, expected);
 72         //parallel counted completer
<span class="line-modified"> 73         long parallelCounted = new SumSegmentCounted(null, MemorySegment.spliterator(segment, layout), threshold).invoke();</span>
 74         assertEquals(parallelCounted, expected);
 75         //parallel recursive action
<span class="line-modified"> 76         long parallelRecursive = new SumSegmentRecursive(MemorySegment.spliterator(segment, layout), threshold).invoke();</span>
 77         assertEquals(parallelRecursive, expected);
 78         //parallel stream
<span class="line-modified"> 79         long streamParallel = StreamSupport.stream(MemorySegment.spliterator(segment, layout), true)</span>
 80                 .reduce(0L, TestSpliterator::sumSingle, Long::sum);
 81         assertEquals(streamParallel, expected);
 82         segment.close();
 83     }
 84 
 85     public void testSumSameThread() {
 86         SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
 87 
 88         //setup
<span class="line-modified"> 89         MemorySegment segment = MemorySegment.allocateNative(layout);</span>
 90         for (int i = 0; i &lt; layout.elementCount().getAsLong(); i++) {
 91             INT_HANDLE.set(segment.baseAddress(), (long) i, i);
 92         }
 93         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
 94 
 95         //check that a segment w/o ACQUIRE access mode can still be used from same thread
 96         AtomicLong spliteratorSum = new AtomicLong();
<span class="line-modified"> 97         spliterator(segment.withAccessModes(MemorySegment.READ), layout)</span>
 98                 .forEachRemaining(s -&gt; spliteratorSum.addAndGet(sumSingle(0L, s)));
 99         assertEquals(spliteratorSum.get(), expected);
100     }
101 
102     static long sumSingle(long acc, MemorySegment segment) {
103         return acc + (int)INT_HANDLE.get(segment.baseAddress(), 0L);
104     }
105 
106     static long sum(long start, MemorySegment segment) {
107         long sum = start;
108         MemoryAddress base = segment.baseAddress();
109         int length = (int)segment.byteSize();
110         for (int i = 0 ; i &lt; length / CARRIER_SIZE ; i++) {
111             sum += (int)INT_HANDLE.get(base, (long)i);
112         }
113         return sum;
114     }
115 
116     static class SumSegmentCounted extends CountedCompleter&lt;Long&gt; {
117 
</pre>
<hr />
<pre>
191                 { 1000, 10 },
192                 { 10000, 10 },
193                 { 10, 100 },
194                 { 100, 100 },
195                 { 1000, 100 },
196                 { 10000, 100 },
197                 { 10, 1000 },
198                 { 100, 1000 },
199                 { 1000, 1000 },
200                 { 10000, 1000 },
201                 { 10, 10000 },
202                 { 100, 10000 },
203                 { 1000, 10000 },
204                 { 10000, 10000 },
205         };
206     }
207 
208     @DataProvider(name = &quot;accessScenarios&quot;)
209     public Object[][] accessScenarios() {
210         SequenceLayout layout = MemoryLayout.ofSequence(16, MemoryLayouts.JAVA_INT);
<span class="line-modified">211         var mallocSegment = MemorySegment.allocateNative(layout);</span>
212 
213         Map&lt;Supplier&lt;Spliterator&lt;MemorySegment&gt;&gt;,Integer&gt; l = Map.of(
<span class="line-modified">214             () -&gt; spliterator(mallocSegment.withAccessModes(ALL_ACCESS), layout), ALL_ACCESS,</span>
<span class="line-modified">215             () -&gt; spliterator(mallocSegment.withAccessModes(0), layout), 0,</span>
<span class="line-modified">216             () -&gt; spliterator(mallocSegment.withAccessModes(READ), layout), READ,</span>
<span class="line-modified">217             () -&gt; spliterator(mallocSegment.withAccessModes(CLOSE), layout), 0,</span>
<span class="line-modified">218             () -&gt; spliterator(mallocSegment.withAccessModes(READ|WRITE), layout), READ|WRITE,</span>
<span class="line-modified">219             () -&gt; spliterator(mallocSegment.withAccessModes(READ|WRITE|ACQUIRE), layout), READ|WRITE|ACQUIRE,</span>
<span class="line-modified">220             () -&gt; spliterator(mallocSegment.withAccessModes(READ|WRITE|ACQUIRE|HANDOFF), layout), READ|WRITE|ACQUIRE|HANDOFF</span>
221 
222         );
223         return l.entrySet().stream().map(e -&gt; new Object[] { e.getKey(), e.getValue() }).toArray(Object[][]::new);
224     }
225 
226     static Consumer&lt;MemorySegment&gt; assertAccessModes(int accessModes) {
227         return segment -&gt; {
228             assertTrue(segment.hasAccessModes(accessModes &amp; ~CLOSE));
229             assertEquals(segment.accessModes(), accessModes &amp; ~CLOSE);
230         };
231     }
232 
233     @Test(dataProvider = &quot;accessScenarios&quot;)
234     public void testAccessModes(Supplier&lt;Spliterator&lt;MemorySegment&gt;&gt; spliteratorSupplier,
235                                 int expectedAccessModes) {
236         Spliterator&lt;MemorySegment&gt; spliterator = spliteratorSupplier.get();
237         spliterator.forEachRemaining(assertAccessModes(expectedAccessModes));
238 
239         spliterator = spliteratorSupplier.get();
240         do { } while (spliterator.tryAdvance(assertAccessModes(expectedAccessModes)));
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @run testng TestSpliterator
 27  */
 28 
 29 import jdk.incubator.foreign.MemoryAddress;
 30 import jdk.incubator.foreign.MemoryLayout;
 31 import jdk.incubator.foreign.MemoryLayouts;
 32 import jdk.incubator.foreign.MemorySegment;
<span class="line-added"> 33 import jdk.incubator.foreign.MemorySegments;</span>
 34 import jdk.incubator.foreign.SequenceLayout;
 35 
 36 import java.lang.invoke.VarHandle;
 37 import java.util.LinkedList;
 38 import java.util.List;
 39 import java.util.Map;
 40 import java.util.Spliterator;
 41 import java.util.concurrent.CountedCompleter;
 42 import java.util.concurrent.RecursiveTask;
 43 import java.util.concurrent.atomic.AtomicLong;
 44 import java.util.function.Consumer;
 45 import java.util.function.Supplier;
 46 import java.util.stream.LongStream;
 47 import java.util.stream.StreamSupport;
 48 
 49 import org.testng.annotations.*;
 50 import static jdk.incubator.foreign.MemorySegment.*;
 51 import static org.testng.Assert.*;
 52 
 53 public class TestSpliterator {
 54 
 55     static final VarHandle INT_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)
 56             .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());
 57 
 58     final static int CARRIER_SIZE = 4;
 59 
 60     @Test(dataProvider = &quot;splits&quot;)
 61     public void testSum(int size, int threshold) {
 62         SequenceLayout layout = MemoryLayout.ofSequence(size, MemoryLayouts.JAVA_INT);
 63 
 64         //setup
<span class="line-modified"> 65         MemorySegment segment = MemorySegments.allocateNative(layout);</span>
 66         for (int i = 0; i &lt; layout.elementCount().getAsLong(); i++) {
 67             INT_HANDLE.set(segment.baseAddress(), (long) i, i);
 68         }
 69         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
 70         //serial
 71         long serial = sum(0, segment);
 72         assertEquals(serial, expected);
 73         //parallel counted completer
<span class="line-modified"> 74         long parallelCounted = new SumSegmentCounted(null, MemorySegments.spliterator(segment, layout), threshold).invoke();</span>
 75         assertEquals(parallelCounted, expected);
 76         //parallel recursive action
<span class="line-modified"> 77         long parallelRecursive = new SumSegmentRecursive(MemorySegments.spliterator(segment, layout), threshold).invoke();</span>
 78         assertEquals(parallelRecursive, expected);
 79         //parallel stream
<span class="line-modified"> 80         long streamParallel = StreamSupport.stream(MemorySegments.spliterator(segment, layout), true)</span>
 81                 .reduce(0L, TestSpliterator::sumSingle, Long::sum);
 82         assertEquals(streamParallel, expected);
 83         segment.close();
 84     }
 85 
 86     public void testSumSameThread() {
 87         SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
 88 
 89         //setup
<span class="line-modified"> 90         MemorySegment segment = MemorySegments.allocateNative(layout);</span>
 91         for (int i = 0; i &lt; layout.elementCount().getAsLong(); i++) {
 92             INT_HANDLE.set(segment.baseAddress(), (long) i, i);
 93         }
 94         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
 95 
 96         //check that a segment w/o ACQUIRE access mode can still be used from same thread
 97         AtomicLong spliteratorSum = new AtomicLong();
<span class="line-modified"> 98         MemorySegments.spliterator(segment.withAccessModes(MemorySegment.READ), layout)</span>
 99                 .forEachRemaining(s -&gt; spliteratorSum.addAndGet(sumSingle(0L, s)));
100         assertEquals(spliteratorSum.get(), expected);
101     }
102 
103     static long sumSingle(long acc, MemorySegment segment) {
104         return acc + (int)INT_HANDLE.get(segment.baseAddress(), 0L);
105     }
106 
107     static long sum(long start, MemorySegment segment) {
108         long sum = start;
109         MemoryAddress base = segment.baseAddress();
110         int length = (int)segment.byteSize();
111         for (int i = 0 ; i &lt; length / CARRIER_SIZE ; i++) {
112             sum += (int)INT_HANDLE.get(base, (long)i);
113         }
114         return sum;
115     }
116 
117     static class SumSegmentCounted extends CountedCompleter&lt;Long&gt; {
118 
</pre>
<hr />
<pre>
192                 { 1000, 10 },
193                 { 10000, 10 },
194                 { 10, 100 },
195                 { 100, 100 },
196                 { 1000, 100 },
197                 { 10000, 100 },
198                 { 10, 1000 },
199                 { 100, 1000 },
200                 { 1000, 1000 },
201                 { 10000, 1000 },
202                 { 10, 10000 },
203                 { 100, 10000 },
204                 { 1000, 10000 },
205                 { 10000, 10000 },
206         };
207     }
208 
209     @DataProvider(name = &quot;accessScenarios&quot;)
210     public Object[][] accessScenarios() {
211         SequenceLayout layout = MemoryLayout.ofSequence(16, MemoryLayouts.JAVA_INT);
<span class="line-modified">212         var mallocSegment = MemorySegments.allocateNative(layout);</span>
213 
214         Map&lt;Supplier&lt;Spliterator&lt;MemorySegment&gt;&gt;,Integer&gt; l = Map.of(
<span class="line-modified">215             () -&gt; MemorySegments.spliterator(mallocSegment.withAccessModes(ALL_ACCESS), layout), ALL_ACCESS,</span>
<span class="line-modified">216             () -&gt; MemorySegments.spliterator(mallocSegment.withAccessModes(0), layout), 0,</span>
<span class="line-modified">217             () -&gt; MemorySegments.spliterator(mallocSegment.withAccessModes(READ), layout), READ,</span>
<span class="line-modified">218             () -&gt; MemorySegments.spliterator(mallocSegment.withAccessModes(CLOSE), layout), 0,</span>
<span class="line-modified">219             () -&gt; MemorySegments.spliterator(mallocSegment.withAccessModes(READ|WRITE), layout), READ|WRITE,</span>
<span class="line-modified">220             () -&gt; MemorySegments.spliterator(mallocSegment.withAccessModes(READ|WRITE|ACQUIRE), layout), READ|WRITE|ACQUIRE,</span>
<span class="line-modified">221             () -&gt; MemorySegments.spliterator(mallocSegment.withAccessModes(READ|WRITE|ACQUIRE|HANDOFF), layout), READ|WRITE|ACQUIRE|HANDOFF</span>
222 
223         );
224         return l.entrySet().stream().map(e -&gt; new Object[] { e.getKey(), e.getValue() }).toArray(Object[][]::new);
225     }
226 
227     static Consumer&lt;MemorySegment&gt; assertAccessModes(int accessModes) {
228         return segment -&gt; {
229             assertTrue(segment.hasAccessModes(accessModes &amp; ~CLOSE));
230             assertEquals(segment.accessModes(), accessModes &amp; ~CLOSE);
231         };
232     }
233 
234     @Test(dataProvider = &quot;accessScenarios&quot;)
235     public void testAccessModes(Supplier&lt;Spliterator&lt;MemorySegment&gt;&gt; spliteratorSupplier,
236                                 int expectedAccessModes) {
237         Spliterator&lt;MemorySegment&gt; spliterator = spliteratorSupplier.get();
238         spliterator.forEachRemaining(assertAccessModes(expectedAccessModes));
239 
240         spliterator = spliteratorSupplier.get();
241         do { } while (spliterator.tryAdvance(assertAccessModes(expectedAccessModes)));
</pre>
</td>
</tr>
</table>
<center><a href="TestSlices.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestTypeAccess.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
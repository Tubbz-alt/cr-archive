<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/lang/ClassLoader.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.  Oracle designates this
   9  * particular file as subject to the &quot;Classpath&quot; exception as provided
  10  * by Oracle in the LICENSE file that accompanied this code.
  11  *
  12  * This code is distributed in the hope that it will be useful, but WITHOUT
  13  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  14  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  15  * version 2 for more details (a copy is included in the LICENSE file that
  16  * accompanied this code).
  17  *
  18  * You should have received a copy of the GNU General Public License version
  19  * 2 along with this work; if not, write to the Free Software Foundation,
  20  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  21  *
  22  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  23  * or visit www.oracle.com if you need additional information or have any
  24  * questions.
  25  */
  26 
  27 package java.lang;
  28 
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.UncheckedIOException;
  32 import java.io.File;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.InvocationTargetException;
  35 import java.net.URL;
  36 import java.security.AccessController;
  37 import java.security.AccessControlContext;
  38 import java.security.CodeSource;
  39 import java.security.PrivilegedAction;
  40 import java.security.ProtectionDomain;
  41 import java.security.cert.Certificate;
  42 import java.util.ArrayDeque;
  43 import java.util.ArrayList;
  44 import java.util.Arrays;
  45 import java.util.Collections;
  46 import java.util.Deque;
  47 import java.util.Enumeration;
  48 import java.util.HashMap;
  49 import java.util.HashSet;
  50 import java.util.Map;
  51 import java.util.NoSuchElementException;
  52 import java.util.Objects;
  53 import java.util.Set;
  54 import java.util.Spliterator;
  55 import java.util.Spliterators;
  56 import java.util.WeakHashMap;
  57 import java.util.concurrent.ConcurrentHashMap;
  58 import java.util.function.Supplier;
  59 import java.util.stream.Stream;
  60 import java.util.stream.StreamSupport;
  61 
  62 import jdk.internal.access.foreign.NativeLibraryProxy;
  63 import jdk.internal.loader.BuiltinClassLoader;
  64 import jdk.internal.perf.PerfCounter;
  65 import jdk.internal.loader.BootLoader;
  66 import jdk.internal.loader.ClassLoaders;
  67 import jdk.internal.misc.Unsafe;
  68 import jdk.internal.misc.VM;
  69 import jdk.internal.ref.CleanerFactory;
  70 import jdk.internal.reflect.CallerSensitive;
  71 import jdk.internal.reflect.Reflection;
  72 import jdk.internal.util.StaticProperty;
  73 import sun.reflect.misc.ReflectUtil;
  74 import sun.security.util.SecurityConstants;
  75 
  76 /**
  77  * A class loader is an object that is responsible for loading classes. The
  78  * class {@code ClassLoader} is an abstract class.  Given the &lt;a
  79  * href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of a class, a class loader should attempt to
  80  * locate or generate data that constitutes a definition for the class.  A
  81  * typical strategy is to transform the name into a file name and then read a
  82  * &quot;class file&quot; of that name from a file system.
  83  *
  84  * &lt;p&gt; Every {@link java.lang.Class Class} object contains a {@link
  85  * Class#getClassLoader() reference} to the {@code ClassLoader} that defined
  86  * it.
  87  *
  88  * &lt;p&gt; {@code Class} objects for array classes are not created by class
  89  * loaders, but are created automatically as required by the Java runtime.
  90  * The class loader for an array class, as returned by {@link
  91  * Class#getClassLoader()} is the same as the class loader for its element
  92  * type; if the element type is a primitive type, then the array class has no
  93  * class loader.
  94  *
  95  * &lt;p&gt; Applications implement subclasses of {@code ClassLoader} in order to
  96  * extend the manner in which the Java virtual machine dynamically loads
  97  * classes.
  98  *
  99  * &lt;p&gt; Class loaders may typically be used by security managers to indicate
 100  * security domains.
 101  *
 102  * &lt;p&gt; In addition to loading classes, a class loader is also responsible for
 103  * locating resources. A resource is some data (a &quot;{@code .class}&quot; file,
 104  * configuration data, or an image for example) that is identified with an
 105  * abstract &#39;/&#39;-separated path name. Resources are typically packaged with an
 106  * application or library so that they can be located by code in the
 107  * application or library. In some cases, the resources are included so that
 108  * they can be located by other libraries.
 109  *
 110  * &lt;p&gt; The {@code ClassLoader} class uses a delegation model to search for
 111  * classes and resources.  Each instance of {@code ClassLoader} has an
 112  * associated parent class loader. When requested to find a class or
 113  * resource, a {@code ClassLoader} instance will usually delegate the search
 114  * for the class or resource to its parent class loader before attempting to
 115  * find the class or resource itself.
 116  *
 117  * &lt;p&gt; Class loaders that support concurrent loading of classes are known as
 118  * &lt;em&gt;{@linkplain #isRegisteredAsParallelCapable() parallel capable}&lt;/em&gt; class
 119  * loaders and are required to register themselves at their class initialization
 120  * time by invoking the {@link
 121  * #registerAsParallelCapable ClassLoader.registerAsParallelCapable}
 122  * method. Note that the {@code ClassLoader} class is registered as parallel
 123  * capable by default. However, its subclasses still need to register themselves
 124  * if they are parallel capable.
 125  * In environments in which the delegation model is not strictly
 126  * hierarchical, class loaders need to be parallel capable, otherwise class
 127  * loading can lead to deadlocks because the loader lock is held for the
 128  * duration of the class loading process (see {@link #loadClass
 129  * loadClass} methods).
 130  *
 131  * &lt;h2&gt; &lt;a id=&quot;builtinLoaders&quot;&gt;Run-time Built-in Class Loaders&lt;/a&gt;&lt;/h2&gt;
 132  *
 133  * The Java run-time has the following built-in class loaders:
 134  *
 135  * &lt;ul&gt;
 136  * &lt;li&gt;&lt;p&gt;Bootstrap class loader.
 137  *     It is the virtual machine&#39;s built-in class loader, typically represented
 138  *     as {@code null}, and does not have a parent.&lt;/li&gt;
 139  * &lt;li&gt;&lt;p&gt;{@linkplain #getPlatformClassLoader() Platform class loader}.
 140  *     All &lt;em&gt;platform classes&lt;/em&gt; are visible to the platform class loader
 141  *     that can be used as the parent of a {@code ClassLoader} instance.
 142  *     Platform classes include Java SE platform APIs, their implementation
 143  *     classes and JDK-specific run-time classes that are defined by the
 144  *     platform class loader or its ancestors.
 145  *     &lt;p&gt; To allow for upgrading/overriding of modules defined to the platform
 146  *     class loader, and where upgraded modules read modules defined to class
 147  *     loaders other than the platform class loader and its ancestors, then
 148  *     the platform class loader may have to delegate to other class loaders,
 149  *     the application class loader for example.
 150  *     In other words, classes in named modules defined to class loaders
 151  *     other than the platform class loader and its ancestors may be visible
 152  *     to the platform class loader. &lt;/li&gt;
 153  * &lt;li&gt;&lt;p&gt;{@linkplain #getSystemClassLoader() System class loader}.
 154  *     It is also known as &lt;em&gt;application class loader&lt;/em&gt; and is distinct
 155  *     from the platform class loader.
 156  *     The system class loader is typically used to define classes on the
 157  *     application class path, module path, and JDK-specific tools.
 158  *     The platform class loader is a parent or an ancestor of the system class
 159  *     loader that all platform classes are visible to it.&lt;/li&gt;
 160  * &lt;/ul&gt;
 161  *
 162  * &lt;p&gt; Normally, the Java virtual machine loads classes from the local file
 163  * system in a platform-dependent manner.
 164  * However, some classes may not originate from a file; they may originate
 165  * from other sources, such as the network, or they could be constructed by an
 166  * application.  The method {@link #defineClass(String, byte[], int, int)
 167  * defineClass} converts an array of bytes into an instance of class
 168  * {@code Class}. Instances of this newly defined class can be created using
 169  * {@link Class#newInstance Class.newInstance}.
 170  *
 171  * &lt;p&gt; The methods and constructors of objects created by a class loader may
 172  * reference other classes.  To determine the class(es) referred to, the Java
 173  * virtual machine invokes the {@link #loadClass loadClass} method of
 174  * the class loader that originally created the class.
 175  *
 176  * &lt;p&gt; For example, an application could create a network class loader to
 177  * download class files from a server.  Sample code might look like:
 178  *
 179  * &lt;blockquote&gt;&lt;pre&gt;
 180  *   ClassLoader loader&amp;nbsp;= new NetworkClassLoader(host,&amp;nbsp;port);
 181  *   Object main&amp;nbsp;= loader.loadClass(&quot;Main&quot;, true).newInstance();
 182  *       &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
 183  * &lt;/pre&gt;&lt;/blockquote&gt;
 184  *
 185  * &lt;p&gt; The network class loader subclass must define the methods {@link
 186  * #findClass findClass} and {@code loadClassData} to load a class
 187  * from the network.  Once it has downloaded the bytes that make up the class,
 188  * it should use the method {@link #defineClass defineClass} to
 189  * create a class instance.  A sample implementation is:
 190  *
 191  * &lt;blockquote&gt;&lt;pre&gt;
 192  *     class NetworkClassLoader extends ClassLoader {
 193  *         String host;
 194  *         int port;
 195  *
 196  *         public Class findClass(String name) {
 197  *             byte[] b = loadClassData(name);
 198  *             return defineClass(name, b, 0, b.length);
 199  *         }
 200  *
 201  *         private byte[] loadClassData(String name) {
 202  *             // load the class data from the connection
 203  *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
 204  *         }
 205  *     }
 206  * &lt;/pre&gt;&lt;/blockquote&gt;
 207  *
 208  * &lt;h3&gt; &lt;a id=&quot;binary-name&quot;&gt;Binary names&lt;/a&gt; &lt;/h3&gt;
 209  *
 210  * &lt;p&gt; Any class name provided as a {@code String} parameter to methods in
 211  * {@code ClassLoader} must be a binary name as defined by
 212  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 213  *
 214  * &lt;p&gt; Examples of valid class names include:
 215  * &lt;blockquote&gt;&lt;pre&gt;
 216  *   &quot;java.lang.String&quot;
 217  *   &quot;javax.swing.JSpinner$DefaultEditor&quot;
 218  *   &quot;java.security.KeyStore$Builder$FileBuilder$1&quot;
 219  *   &quot;java.net.URLClassLoader$3$1&quot;
 220  * &lt;/pre&gt;&lt;/blockquote&gt;
 221  *
 222  * &lt;p&gt; Any package name provided as a {@code String} parameter to methods in
 223  * {@code ClassLoader} must be either the empty string (denoting an unnamed package)
 224  * or a fully qualified name as defined by
 225  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 226  *
 227  * @jls 6.7 Fully Qualified Names
 228  * @jls 13.1 The Form of a Binary
 229  * @see      #resolveClass(Class)
 230  * @since 1.0
 231  * @revised 9
 232  * @spec JPMS
 233  */
 234 public abstract class ClassLoader {
 235 
 236     private static native void registerNatives();
 237     static {
 238         registerNatives();
 239     }
 240 
 241     // The parent class loader for delegation
 242     // Note: VM hardcoded the offset of this field, thus all new fields
 243     // must be added *after* it.
 244     private final ClassLoader parent;
 245 
 246     // class loader name
 247     private final String name;
 248 
 249     // the unnamed module for this ClassLoader
 250     private final Module unnamedModule;
 251 
 252     // a string for exception message printing
 253     private final String nameAndId;
 254 
 255     /**
 256      * Encapsulates the set of parallel capable loader types.
 257      */
 258     private static class ParallelLoaders {
 259         private ParallelLoaders() {}
 260 
 261         // the set of parallel capable loader types
 262         private static final Set&lt;Class&lt;? extends ClassLoader&gt;&gt; loaderTypes =
 263             Collections.newSetFromMap(new WeakHashMap&lt;&gt;());
 264         static {
 265             synchronized (loaderTypes) { loaderTypes.add(ClassLoader.class); }
 266         }
 267 
 268         /**
 269          * Registers the given class loader type as parallel capable.
 270          * Returns {@code true} is successfully registered; {@code false} if
 271          * loader&#39;s super class is not registered.
 272          */
 273         static boolean register(Class&lt;? extends ClassLoader&gt; c) {
 274             synchronized (loaderTypes) {
 275                 if (loaderTypes.contains(c.getSuperclass())) {
 276                     // register the class loader as parallel capable
 277                     // if and only if all of its super classes are.
 278                     // Note: given current classloading sequence, if
 279                     // the immediate super class is parallel capable,
 280                     // all the super classes higher up must be too.
 281                     loaderTypes.add(c);
 282                     return true;
 283                 } else {
 284                     return false;
 285                 }
 286             }
 287         }
 288 
 289         /**
 290          * Returns {@code true} if the given class loader type is
 291          * registered as parallel capable.
 292          */
 293         static boolean isRegistered(Class&lt;? extends ClassLoader&gt; c) {
 294             synchronized (loaderTypes) {
 295                 return loaderTypes.contains(c);
 296             }
 297         }
 298     }
 299 
 300     // Maps class name to the corresponding lock object when the current
 301     // class loader is parallel capable.
 302     // Note: VM also uses this field to decide if the current class loader
 303     // is parallel capable and the appropriate lock object for class loading.
 304     private final ConcurrentHashMap&lt;String, Object&gt; parallelLockMap;
 305 
 306     // Maps packages to certs
 307     private final ConcurrentHashMap&lt;String, Certificate[]&gt; package2certs;
 308 
 309     // Shared among all packages with unsigned classes
 310     private static final Certificate[] nocerts = new Certificate[0];
 311 
 312     // The classes loaded by this class loader. The only purpose of this table
 313     // is to keep the classes from being GC&#39;ed until the loader is GC&#39;ed.
 314     private final ArrayList&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;();
 315 
 316     // The &quot;default&quot; domain. Set as the default ProtectionDomain on newly
 317     // created classes.
 318     private final ProtectionDomain defaultDomain =
 319         new ProtectionDomain(new CodeSource(null, (Certificate[]) null),
 320                              null, this, null);
 321 
 322     // Invoked by the VM to record every loaded class with this loader.
 323     void addClass(Class&lt;?&gt; c) {
 324         synchronized (classes) {
 325             classes.add(c);
 326         }
 327     }
 328 
 329     // The packages defined in this class loader.  Each package name is
 330     // mapped to its corresponding NamedPackage object.
 331     //
 332     // The value is a Package object if ClassLoader::definePackage,
 333     // Class::getPackage, ClassLoader::getDefinePackage(s) or
 334     // Package::getPackage(s) method is called to define it.
 335     // Otherwise, the value is a NamedPackage object.
 336     private final ConcurrentHashMap&lt;String, NamedPackage&gt; packages
 337             = new ConcurrentHashMap&lt;&gt;();
 338 
 339     /*
 340      * Returns a named package for the given module.
 341      */
 342     private NamedPackage getNamedPackage(String pn, Module m) {
 343         NamedPackage p = packages.get(pn);
 344         if (p == null) {
 345             p = new NamedPackage(pn, m);
 346 
 347             NamedPackage value = packages.putIfAbsent(pn, p);
 348             if (value != null) {
 349                 // Package object already be defined for the named package
 350                 p = value;
 351                 // if definePackage is called by this class loader to define
 352                 // a package in a named module, this will return Package
 353                 // object of the same name.  Package object may contain
 354                 // unexpected information but it does not impact the runtime.
 355                 // this assertion may be helpful for troubleshooting
 356                 assert value.module() == m;
 357             }
 358         }
 359         return p;
 360     }
 361 
 362     private static Void checkCreateClassLoader() {
 363         return checkCreateClassLoader(null);
 364     }
 365 
 366     private static Void checkCreateClassLoader(String name) {
 367         if (name != null &amp;&amp; name.isEmpty()) {
 368             throw new IllegalArgumentException(&quot;name must be non-empty or null&quot;);
 369         }
 370 
 371         SecurityManager security = System.getSecurityManager();
 372         if (security != null) {
 373             security.checkCreateClassLoader();
 374         }
 375         return null;
 376     }
 377 
 378     private ClassLoader(Void unused, String name, ClassLoader parent) {
 379         this.name = name;
 380         this.parent = parent;
 381         this.unnamedModule = new Module(this);
 382         if (ParallelLoaders.isRegistered(this.getClass())) {
 383             parallelLockMap = new ConcurrentHashMap&lt;&gt;();
 384             assertionLock = new Object();
 385         } else {
 386             // no finer-grained lock; lock on the classloader instance
 387             parallelLockMap = null;
 388             assertionLock = this;
 389         }
 390         this.package2certs = new ConcurrentHashMap&lt;&gt;();
 391         this.nameAndId = nameAndId(this);
 392     }
 393 
 394     /**
 395      * If the defining loader has a name explicitly set then
 396      *       &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
 397      * If the defining loader has no name then
 398      *       &lt;qualified-class-name&gt; @&lt;id&gt;
 399      * If it&#39;s built-in loader then omit `@&lt;id&gt;` as there is only one instance.
 400      */
 401     private static String nameAndId(ClassLoader ld) {
 402         String nid = ld.getName() != null ? &quot;\&#39;&quot; + ld.getName() + &quot;\&#39;&quot;
 403                                           : ld.getClass().getName();
 404         if (!(ld instanceof BuiltinClassLoader)) {
 405             String id = Integer.toHexString(System.identityHashCode(ld));
 406             nid = nid + &quot; @&quot; + id;
 407         }
 408         return nid;
 409     }
 410 
 411     /**
 412      * Creates a new class loader of the specified name and using the
 413      * specified parent class loader for delegation.
 414      *
 415      * @apiNote If the parent is specified as {@code null} (for the
 416      * bootstrap class loader) then there is no guarantee that all platform
 417      * classes are visible.
 418      *
 419      * @param  name   class loader name; or {@code null} if not named
 420      * @param  parent the parent class loader
 421      *
 422      * @throws IllegalArgumentException if the given name is empty.
 423      *
 424      * @throws SecurityException
 425      *         If a security manager exists and its
 426      *         {@link SecurityManager#checkCreateClassLoader()}
 427      *         method doesn&#39;t allow creation of a new class loader.
 428      *
 429      * @since  9
 430      * @spec JPMS
 431      */
 432     protected ClassLoader(String name, ClassLoader parent) {
 433         this(checkCreateClassLoader(name), name, parent);
 434     }
 435 
 436     /**
 437      * Creates a new class loader using the specified parent class loader for
 438      * delegation.
 439      *
 440      * &lt;p&gt; If there is a security manager, its {@link
 441      * SecurityManager#checkCreateClassLoader() checkCreateClassLoader} method
 442      * is invoked.  This may result in a security exception.  &lt;/p&gt;
 443      *
 444      * @apiNote If the parent is specified as {@code null} (for the
 445      * bootstrap class loader) then there is no guarantee that all platform
 446      * classes are visible.
 447      *
 448      * @param  parent
 449      *         The parent class loader
 450      *
 451      * @throws SecurityException
 452      *         If a security manager exists and its
 453      *         {@code checkCreateClassLoader} method doesn&#39;t allow creation
 454      *         of a new class loader.
 455      *
 456      * @since  1.2
 457      */
 458     protected ClassLoader(ClassLoader parent) {
 459         this(checkCreateClassLoader(), null, parent);
 460     }
 461 
 462     /**
 463      * Creates a new class loader using the {@code ClassLoader} returned by
 464      * the method {@link #getSystemClassLoader()
 465      * getSystemClassLoader()} as the parent class loader.
 466      *
 467      * &lt;p&gt; If there is a security manager, its {@link
 468      * SecurityManager#checkCreateClassLoader()
 469      * checkCreateClassLoader} method is invoked.  This may result in
 470      * a security exception.  &lt;/p&gt;
 471      *
 472      * @throws  SecurityException
 473      *          If a security manager exists and its
 474      *          {@code checkCreateClassLoader} method doesn&#39;t allow creation
 475      *          of a new class loader.
 476      */
 477     protected ClassLoader() {
 478         this(checkCreateClassLoader(), null, getSystemClassLoader());
 479     }
 480 
 481     /**
 482      * Returns the name of this class loader or {@code null} if
 483      * this class loader is not named.
 484      *
 485      * @apiNote This method is non-final for compatibility.  If this
 486      * method is overridden, this method must return the same name
 487      * as specified when this class loader was instantiated.
 488      *
 489      * @return name of this class loader; or {@code null} if
 490      * this class loader is not named.
 491      *
 492      * @since 9
 493      * @spec JPMS
 494      */
 495     public String getName() {
 496         return name;
 497     }
 498 
 499     // package-private used by StackTraceElement to avoid
 500     // calling the overrideable getName method
 501     final String name() {
 502         return name;
 503     }
 504 
 505     // -- Class --
 506 
 507     /**
 508      * Loads the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.
 509      * This method searches for classes in the same manner as the {@link
 510      * #loadClass(String, boolean)} method.  It is invoked by the Java virtual
 511      * machine to resolve class references.  Invoking this method is equivalent
 512      * to invoking {@link #loadClass(String, boolean) loadClass(name,
 513      * false)}.
 514      *
 515      * @param   name
 516      *          The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class
 517      *
 518      * @return  The resulting {@code Class} object
 519      *
 520      * @throws  ClassNotFoundException
 521      *          If the class was not found
 522      */
 523     public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
 524         return loadClass(name, false);
 525     }
 526 
 527     /**
 528      * Loads the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.  The
 529      * default implementation of this method searches for classes in the
 530      * following order:
 531      *
 532      * &lt;ol&gt;
 533      *
 534      *   &lt;li&gt;&lt;p&gt; Invoke {@link #findLoadedClass(String)} to check if the class
 535      *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;
 536      *
 537      *   &lt;li&gt;&lt;p&gt; Invoke the {@link #loadClass(String) loadClass} method
 538      *   on the parent class loader.  If the parent is {@code null} the class
 539      *   loader built into the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;
 540      *
 541      *   &lt;li&gt;&lt;p&gt; Invoke the {@link #findClass(String)} method to find the
 542      *   class.  &lt;/p&gt;&lt;/li&gt;
 543      *
 544      * &lt;/ol&gt;
 545      *
 546      * &lt;p&gt; If the class was found using the above steps, and the
 547      * {@code resolve} flag is true, this method will then invoke the {@link
 548      * #resolveClass(Class)} method on the resulting {@code Class} object.
 549      *
 550      * &lt;p&gt; Subclasses of {@code ClassLoader} are encouraged to override {@link
 551      * #findClass(String)}, rather than this method.  &lt;/p&gt;
 552      *
 553      * &lt;p&gt; Unless overridden, this method synchronizes on the result of
 554      * {@link #getClassLoadingLock getClassLoadingLock} method
 555      * during the entire class loading process.
 556      *
 557      * @param   name
 558      *          The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class
 559      *
 560      * @param   resolve
 561      *          If {@code true} then resolve the class
 562      *
 563      * @return  The resulting {@code Class} object
 564      *
 565      * @throws  ClassNotFoundException
 566      *          If the class could not be found
 567      */
 568     protected Class&lt;?&gt; loadClass(String name, boolean resolve)
 569         throws ClassNotFoundException
 570     {
 571         synchronized (getClassLoadingLock(name)) {
 572             // First, check if the class has already been loaded
 573             Class&lt;?&gt; c = findLoadedClass(name);
 574             if (c == null) {
 575                 long t0 = System.nanoTime();
 576                 try {
 577                     if (parent != null) {
 578                         c = parent.loadClass(name, false);
 579                     } else {
 580                         c = findBootstrapClassOrNull(name);
 581                     }
 582                 } catch (ClassNotFoundException e) {
 583                     // ClassNotFoundException thrown if class not found
 584                     // from the non-null parent class loader
 585                 }
 586 
 587                 if (c == null) {
 588                     // If still not found, then invoke findClass in order
 589                     // to find the class.
 590                     long t1 = System.nanoTime();
 591                     c = findClass(name);
 592 
 593                     // this is the defining class loader; record the stats
 594                     PerfCounter.getParentDelegationTime().addTime(t1 - t0);
 595                     PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
 596                     PerfCounter.getFindClasses().increment();
 597                 }
 598             }
 599             if (resolve) {
 600                 resolveClass(c);
 601             }
 602             return c;
 603         }
 604     }
 605 
 606     /**
 607      * Loads the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;
 608      * in a module defined to this class loader.  This method returns {@code null}
 609      * if the class could not be found.
 610      *
 611      * @apiNote This method does not delegate to the parent class loader.
 612      *
 613      * @implSpec The default implementation of this method searches for classes
 614      * in the following order:
 615      *
 616      * &lt;ol&gt;
 617      *   &lt;li&gt;Invoke {@link #findLoadedClass(String)} to check if the class
 618      *   has already been loaded.&lt;/li&gt;
 619      *   &lt;li&gt;Invoke the {@link #findClass(String, String)} method to find the
 620      *   class in the given module.&lt;/li&gt;
 621      * &lt;/ol&gt;
 622      *
 623      * @param  module
 624      *         The module
 625      * @param  name
 626      *         The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class
 627      *
 628      * @return The resulting {@code Class} object in a module defined by
 629      *         this class loader, or {@code null} if the class could not be found.
 630      */
 631     final Class&lt;?&gt; loadClass(Module module, String name) {
 632         synchronized (getClassLoadingLock(name)) {
 633             // First, check if the class has already been loaded
 634             Class&lt;?&gt; c = findLoadedClass(name);
 635             if (c == null) {
 636                 c = findClass(module.getName(), name);
 637             }
 638             if (c != null &amp;&amp; c.getModule() == module) {
 639                 return c;
 640             } else {
 641                 return null;
 642             }
 643         }
 644     }
 645 
 646     /**
 647      * Returns the lock object for class loading operations.
 648      * For backward compatibility, the default implementation of this method
 649      * behaves as follows. If this ClassLoader object is registered as
 650      * parallel capable, the method returns a dedicated object associated
 651      * with the specified class name. Otherwise, the method returns this
 652      * ClassLoader object.
 653      *
 654      * @param  className
 655      *         The name of the to-be-loaded class
 656      *
 657      * @return the lock for class loading operations
 658      *
 659      * @throws NullPointerException
 660      *         If registered as parallel capable and {@code className} is null
 661      *
 662      * @see #loadClass(String, boolean)
 663      *
 664      * @since  1.7
 665      */
 666     protected Object getClassLoadingLock(String className) {
 667         Object lock = this;
 668         if (parallelLockMap != null) {
 669             Object newLock = new Object();
 670             lock = parallelLockMap.putIfAbsent(className, newLock);
 671             if (lock == null) {
 672                 lock = newLock;
 673             }
 674         }
 675         return lock;
 676     }
 677 
 678     // Invoked by the VM after loading class with this loader.
 679     private void checkPackageAccess(Class&lt;?&gt; cls, ProtectionDomain pd) {
 680         final SecurityManager sm = System.getSecurityManager();
 681         if (sm != null) {
 682             if (ReflectUtil.isNonPublicProxyClass(cls)) {
 683                 for (Class&lt;?&gt; intf: cls.getInterfaces()) {
 684                     checkPackageAccess(intf, pd);
 685                 }
 686                 return;
 687             }
 688 
 689             final String packageName = cls.getPackageName();
 690             if (!packageName.isEmpty()) {
 691                 AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
 692                     public Void run() {
 693                         sm.checkPackageAccess(packageName);
 694                         return null;
 695                     }
 696                 }, new AccessControlContext(new ProtectionDomain[] {pd}));
 697             }
 698         }
 699     }
 700 
 701     /**
 702      * Finds the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.
 703      * This method should be overridden by class loader implementations that
 704      * follow the delegation model for loading classes, and will be invoked by
 705      * the {@link #loadClass loadClass} method after checking the
 706      * parent class loader for the requested class.
 707      *
 708      * @implSpec The default implementation throws {@code ClassNotFoundException}.
 709      *
 710      * @param   name
 711      *          The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class
 712      *
 713      * @return  The resulting {@code Class} object
 714      *
 715      * @throws  ClassNotFoundException
 716      *          If the class could not be found
 717      *
 718      * @since  1.2
 719      */
 720     protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
 721         throw new ClassNotFoundException(name);
 722     }
 723 
 724     /**
 725      * Finds the class with the given &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;
 726      * in a module defined to this class loader.
 727      * Class loader implementations that support loading from modules
 728      * should override this method.
 729      *
 730      * @apiNote This method returns {@code null} rather than throwing
 731      *          {@code ClassNotFoundException} if the class could not be found.
 732      *
 733      * @implSpec The default implementation attempts to find the class by
 734      * invoking {@link #findClass(String)} when the {@code moduleName} is
 735      * {@code null}. It otherwise returns {@code null}.
 736      *
 737      * @param  moduleName
 738      *         The module name; or {@code null} to find the class in the
 739      *         {@linkplain #getUnnamedModule() unnamed module} for this
 740      *         class loader
 741 
 742      * @param  name
 743      *         The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class
 744      *
 745      * @return The resulting {@code Class} object, or {@code null}
 746      *         if the class could not be found.
 747      *
 748      * @since 9
 749      * @spec JPMS
 750      */
 751     protected Class&lt;?&gt; findClass(String moduleName, String name) {
 752         if (moduleName == null) {
 753             try {
 754                 return findClass(name);
 755             } catch (ClassNotFoundException ignore) { }
 756         }
 757         return null;
 758     }
 759 
 760 
 761     /**
 762      * Converts an array of bytes into an instance of class {@code Class}.
 763      * Before the {@code Class} can be used it must be resolved.  This method
 764      * is deprecated in favor of the version that takes a &lt;a
 765      * href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; as its first argument, and is more secure.
 766      *
 767      * @param  b
 768      *         The bytes that make up the class data.  The bytes in positions
 769      *         {@code off} through {@code off+len-1} should have the format
 770      *         of a valid class file as defined by
 771      *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
 772      *
 773      * @param  off
 774      *         The start offset in {@code b} of the class data
 775      *
 776      * @param  len
 777      *         The length of the class data
 778      *
 779      * @return  The {@code Class} object that was created from the specified
 780      *          class data
 781      *
 782      * @throws  ClassFormatError
 783      *          If the data did not contain a valid class
 784      *
 785      * @throws  IndexOutOfBoundsException
 786      *          If either {@code off} or {@code len} is negative, or if
 787      *          {@code off+len} is greater than {@code b.length}.
 788      *
 789      * @throws  SecurityException
 790      *          If an attempt is made to add this class to a package that
 791      *          contains classes that were signed by a different set of
 792      *          certificates than this class, or if an attempt is made
 793      *          to define a class in a package with a fully-qualified name
 794      *          that starts with &quot;{@code java.}&quot;.
 795      *
 796      * @see  #loadClass(String, boolean)
 797      * @see  #resolveClass(Class)
 798      *
 799      * @deprecated  Replaced by {@link #defineClass(String, byte[], int, int)
 800      * defineClass(String, byte[], int, int)}
 801      */
 802     @Deprecated(since=&quot;1.1&quot;)
 803     protected final Class&lt;?&gt; defineClass(byte[] b, int off, int len)
 804         throws ClassFormatError
 805     {
 806         return defineClass(null, b, off, len, null);
 807     }
 808 
 809     /**
 810      * Converts an array of bytes into an instance of class {@code Class}.
 811      * Before the {@code Class} can be used it must be resolved.
 812      *
 813      * &lt;p&gt; This method assigns a default {@link java.security.ProtectionDomain
 814      * ProtectionDomain} to the newly defined class.  The
 815      * {@code ProtectionDomain} is effectively granted the same set of
 816      * permissions returned when {@link
 817      * java.security.Policy#getPermissions(java.security.CodeSource)
 818      * Policy.getPolicy().getPermissions(new CodeSource(null, null))}
 819      * is invoked.  The default protection domain is created on the first invocation
 820      * of {@link #defineClass(String, byte[], int, int) defineClass},
 821      * and re-used on subsequent invocations.
 822      *
 823      * &lt;p&gt; To assign a specific {@code ProtectionDomain} to the class, use
 824      * the {@link #defineClass(String, byte[], int, int,
 825      * java.security.ProtectionDomain) defineClass} method that takes a
 826      * {@code ProtectionDomain} as one of its arguments.  &lt;/p&gt;
 827      *
 828      * &lt;p&gt;
 829      * This method defines a package in this class loader corresponding to the
 830      * package of the {@code Class} (if such a package has not already been defined
 831      * in this class loader). The name of the defined package is derived from
 832      * the &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class specified by
 833      * the byte array {@code b}.
 834      * Other properties of the defined package are as specified by {@link Package}.
 835      *
 836      * @param  name
 837      *         The expected &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class, or
 838      *         {@code null} if not known
 839      *
 840      * @param  b
 841      *         The bytes that make up the class data.  The bytes in positions
 842      *         {@code off} through {@code off+len-1} should have the format
 843      *         of a valid class file as defined by
 844      *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
 845      *
 846      * @param  off
 847      *         The start offset in {@code b} of the class data
 848      *
 849      * @param  len
 850      *         The length of the class data
 851      *
 852      * @return  The {@code Class} object that was created from the specified
 853      *          class data.
 854      *
 855      * @throws  ClassFormatError
 856      *          If the data did not contain a valid class
 857      *
 858      * @throws  IndexOutOfBoundsException
 859      *          If either {@code off} or {@code len} is negative, or if
 860      *          {@code off+len} is greater than {@code b.length}.
 861      *
 862      * @throws  SecurityException
 863      *          If an attempt is made to add this class to a package that
 864      *          contains classes that were signed by a different set of
 865      *          certificates than this class (which is unsigned), or if
 866      *          {@code name} begins with &quot;{@code java.}&quot;.
 867      *
 868      * @see  #loadClass(String, boolean)
 869      * @see  #resolveClass(Class)
 870      * @see  java.security.CodeSource
 871      * @see  java.security.SecureClassLoader
 872      *
 873      * @since  1.1
 874      * @revised 9
 875      * @spec JPMS
 876      */
 877     protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)
 878         throws ClassFormatError
 879     {
 880         return defineClass(name, b, off, len, null);
 881     }
 882 
 883     /* Determine protection domain, and check that:
 884         - not define java.* class,
 885         - signer of this class matches signers for the rest of the classes in
 886           package.
 887     */
 888     private ProtectionDomain preDefineClass(String name,
 889                                             ProtectionDomain pd)
 890     {
 891         if (!checkName(name))
 892             throw new NoClassDefFoundError(&quot;IllegalName: &quot; + name);
 893 
 894         // Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias
 895         // relies on the fact that spoofing is impossible if a class has a name
 896         // of the form &quot;java.*&quot;
 897         if ((name != null) &amp;&amp; name.startsWith(&quot;java.&quot;)
 898                 &amp;&amp; this != getBuiltinPlatformClassLoader()) {
 899             throw new SecurityException
 900                 (&quot;Prohibited package name: &quot; +
 901                  name.substring(0, name.lastIndexOf(&#39;.&#39;)));
 902         }
 903         if (pd == null) {
 904             pd = defaultDomain;
 905         }
 906 
 907         if (name != null) {
 908             checkCerts(name, pd.getCodeSource());
 909         }
 910 
 911         return pd;
 912     }
 913 
 914     private String defineClassSourceLocation(ProtectionDomain pd) {
 915         CodeSource cs = pd.getCodeSource();
 916         String source = null;
 917         if (cs != null &amp;&amp; cs.getLocation() != null) {
 918             source = cs.getLocation().toString();
 919         }
 920         return source;
 921     }
 922 
 923     private void postDefineClass(Class&lt;?&gt; c, ProtectionDomain pd) {
 924         // define a named package, if not present
 925         getNamedPackage(c.getPackageName(), c.getModule());
 926 
 927         if (pd.getCodeSource() != null) {
 928             Certificate certs[] = pd.getCodeSource().getCertificates();
 929             if (certs != null)
 930                 setSigners(c, certs);
 931         }
 932     }
 933 
 934     /**
 935      * Converts an array of bytes into an instance of class {@code Class},
 936      * with a given {@code ProtectionDomain}.
 937      *
 938      * &lt;p&gt; If the given {@code ProtectionDomain} is {@code null},
 939      * then a default protection domain will be assigned to the class as specified
 940      * in the documentation for {@link #defineClass(String, byte[], int, int)}.
 941      * Before the class can be used it must be resolved.
 942      *
 943      * &lt;p&gt; The first class defined in a package determines the exact set of
 944      * certificates that all subsequent classes defined in that package must
 945      * contain.  The set of certificates for a class is obtained from the
 946      * {@link java.security.CodeSource CodeSource} within the
 947      * {@code ProtectionDomain} of the class.  Any classes added to that
 948      * package must contain the same set of certificates or a
 949      * {@code SecurityException} will be thrown.  Note that if
 950      * {@code name} is {@code null}, this check is not performed.
 951      * You should always pass in the &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the
 952      * class you are defining as well as the bytes.  This ensures that the
 953      * class you are defining is indeed the class you think it is.
 954      *
 955      * &lt;p&gt; If the specified {@code name} begins with &quot;{@code java.}&quot;, it can
 956      * only be defined by the {@linkplain #getPlatformClassLoader()
 957      * platform class loader} or its ancestors; otherwise {@code SecurityException}
 958      * will be thrown.  If {@code name} is not {@code null}, it must be equal to
 959      * the &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class
 960      * specified by the byte array {@code b}, otherwise a {@link
 961      * NoClassDefFoundError NoClassDefFoundError} will be thrown.
 962      *
 963      * &lt;p&gt; This method defines a package in this class loader corresponding to the
 964      * package of the {@code Class} (if such a package has not already been defined
 965      * in this class loader). The name of the defined package is derived from
 966      * the &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class specified by
 967      * the byte array {@code b}.
 968      * Other properties of the defined package are as specified by {@link Package}.
 969      *
 970      * @param  name
 971      *         The expected &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class, or
 972      *         {@code null} if not known
 973      *
 974      * @param  b
 975      *         The bytes that make up the class data. The bytes in positions
 976      *         {@code off} through {@code off+len-1} should have the format
 977      *         of a valid class file as defined by
 978      *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
 979      *
 980      * @param  off
 981      *         The start offset in {@code b} of the class data
 982      *
 983      * @param  len
 984      *         The length of the class data
 985      *
 986      * @param  protectionDomain
 987      *         The {@code ProtectionDomain} of the class
 988      *
 989      * @return  The {@code Class} object created from the data,
 990      *          and {@code ProtectionDomain}.
 991      *
 992      * @throws  ClassFormatError
 993      *          If the data did not contain a valid class
 994      *
 995      * @throws  NoClassDefFoundError
 996      *          If {@code name} is not {@code null} and not equal to the
 997      *          &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class specified by {@code b}
 998      *
 999      * @throws  IndexOutOfBoundsException
1000      *          If either {@code off} or {@code len} is negative, or if
1001      *          {@code off+len} is greater than {@code b.length}.
1002      *
1003      * @throws  SecurityException
1004      *          If an attempt is made to add this class to a package that
1005      *          contains classes that were signed by a different set of
1006      *          certificates than this class, or if {@code name} begins with
1007      *          &quot;{@code java.}&quot; and this class loader is not the platform
1008      *          class loader or its ancestor.
1009      *
1010      * @revised 9
1011      * @spec JPMS
1012      */
1013     protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,
1014                                          ProtectionDomain protectionDomain)
1015         throws ClassFormatError
1016     {
1017         protectionDomain = preDefineClass(name, protectionDomain);
1018         String source = defineClassSourceLocation(protectionDomain);
1019         Class&lt;?&gt; c = defineClass1(this, name, b, off, len, protectionDomain, source);
1020         postDefineClass(c, protectionDomain);
1021         return c;
1022     }
1023 
1024     /**
1025      * Converts a {@link java.nio.ByteBuffer ByteBuffer} into an instance
1026      * of class {@code Class}, with the given {@code ProtectionDomain}.
1027      * If the given {@code ProtectionDomain} is {@code null}, then a default
1028      * protection domain will be assigned to the class as
1029      * specified in the documentation for {@link #defineClass(String, byte[],
1030      * int, int)}.  Before the class can be used it must be resolved.
1031      *
1032      * &lt;p&gt;The rules about the first class defined in a package determining the
1033      * set of certificates for the package, the restrictions on class names,
1034      * and the defined package of the class
1035      * are identical to those specified in the documentation for {@link
1036      * #defineClass(String, byte[], int, int, ProtectionDomain)}.
1037      *
1038      * &lt;p&gt; An invocation of this method of the form
1039      * &lt;i&gt;cl&lt;/i&gt;{@code .defineClass(}&lt;i&gt;name&lt;/i&gt;{@code ,}
1040      * &lt;i&gt;bBuffer&lt;/i&gt;{@code ,} &lt;i&gt;pd&lt;/i&gt;{@code )} yields exactly the same
1041      * result as the statements
1042      *
1043      *&lt;p&gt; &lt;code&gt;
1044      * ...&lt;br&gt;
1045      * byte[] temp = new byte[bBuffer.{@link
1046      * java.nio.ByteBuffer#remaining remaining}()];&lt;br&gt;
1047      *     bBuffer.{@link java.nio.ByteBuffer#get(byte[])
1048      * get}(temp);&lt;br&gt;
1049      *     return {@link #defineClass(String, byte[], int, int, ProtectionDomain)
1050      * cl.defineClass}(name, temp, 0,
1051      * temp.length, pd);&lt;br&gt;
1052      * &lt;/code&gt;&lt;/p&gt;
1053      *
1054      * @param  name
1055      *         The expected &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;. of the class, or
1056      *         {@code null} if not known
1057      *
1058      * @param  b
1059      *         The bytes that make up the class data. The bytes from positions
1060      *         {@code b.position()} through {@code b.position() + b.limit() -1
1061      *         } should have the format of a valid class file as defined by
1062      *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1063      *
1064      * @param  protectionDomain
1065      *         The {@code ProtectionDomain} of the class, or {@code null}.
1066      *
1067      * @return  The {@code Class} object created from the data,
1068      *          and {@code ProtectionDomain}.
1069      *
1070      * @throws  ClassFormatError
1071      *          If the data did not contain a valid class.
1072      *
1073      * @throws  NoClassDefFoundError
1074      *          If {@code name} is not {@code null} and not equal to the
1075      *          &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class specified by {@code b}
1076      *
1077      * @throws  SecurityException
1078      *          If an attempt is made to add this class to a package that
1079      *          contains classes that were signed by a different set of
1080      *          certificates than this class, or if {@code name} begins with
1081      *          &quot;{@code java.}&quot;.
1082      *
1083      * @see      #defineClass(String, byte[], int, int, ProtectionDomain)
1084      *
1085      * @since  1.5
1086      * @revised 9
1087      * @spec JPMS
1088      */
1089     protected final Class&lt;?&gt; defineClass(String name, java.nio.ByteBuffer b,
1090                                          ProtectionDomain protectionDomain)
1091         throws ClassFormatError
1092     {
1093         int len = b.remaining();
1094 
1095         // Use byte[] if not a direct ByteBuffer:
1096         if (!b.isDirect()) {
1097             if (b.hasArray()) {
1098                 return defineClass(name, b.array(),
1099                                    b.position() + b.arrayOffset(), len,
1100                                    protectionDomain);
1101             } else {
1102                 // no array, or read-only array
1103                 byte[] tb = new byte[len];
1104                 b.get(tb);  // get bytes out of byte buffer.
1105                 return defineClass(name, tb, 0, len, protectionDomain);
1106             }
1107         }
1108 
1109         protectionDomain = preDefineClass(name, protectionDomain);
1110         String source = defineClassSourceLocation(protectionDomain);
1111         Class&lt;?&gt; c = defineClass2(this, name, b, b.position(), len, protectionDomain, source);
1112         postDefineClass(c, protectionDomain);
1113         return c;
1114     }
1115 
1116     static native Class&lt;?&gt; defineClass1(ClassLoader loader, String name, byte[] b, int off, int len,
1117                                         ProtectionDomain pd, String source);
1118 
1119     static native Class&lt;?&gt; defineClass2(ClassLoader loader, String name, java.nio.ByteBuffer b,
1120                                         int off, int len, ProtectionDomain pd,
1121                                         String source);
1122 
1123     // true if the name is null or has the potential to be a valid binary name
1124     private boolean checkName(String name) {
1125         if ((name == null) || (name.isEmpty()))
1126             return true;
1127         if ((name.indexOf(&#39;/&#39;) != -1) || (name.charAt(0) == &#39;[&#39;))
1128             return false;
1129         return true;
1130     }
1131 
1132     private void checkCerts(String name, CodeSource cs) {
1133         int i = name.lastIndexOf(&#39;.&#39;);
1134         String pname = (i == -1) ? &quot;&quot; : name.substring(0, i);
1135 
1136         Certificate[] certs = null;
1137         if (cs != null) {
1138             certs = cs.getCertificates();
1139         }
1140         certs = certs == null ? nocerts : certs;
1141         Certificate[] pcerts = package2certs.putIfAbsent(pname, certs);
1142         if (pcerts != null &amp;&amp; !compareCerts(pcerts, certs)) {
1143             throw new SecurityException(&quot;class \&quot;&quot; + name
1144                 + &quot;\&quot;&#39;s signer information does not match signer information&quot;
1145                 + &quot; of other classes in the same package&quot;);
1146         }
1147     }
1148 
1149     /**
1150      * check to make sure the certs for the new class (certs) are the same as
1151      * the certs for the first class inserted in the package (pcerts)
1152      */
1153     private boolean compareCerts(Certificate[] pcerts, Certificate[] certs) {
1154         // empty array fast-path
1155         if (certs.length == 0)
1156             return pcerts.length == 0;
1157 
1158         // the length must be the same at this point
1159         if (certs.length != pcerts.length)
1160             return false;
1161 
1162         // go through and make sure all the certs in one array
1163         // are in the other and vice-versa.
1164         boolean match;
1165         for (Certificate cert : certs) {
1166             match = false;
1167             for (Certificate pcert : pcerts) {
1168                 if (cert.equals(pcert)) {
1169                     match = true;
1170                     break;
1171                 }
1172             }
1173             if (!match) return false;
1174         }
1175 
1176         // now do the same for pcerts
1177         for (Certificate pcert : pcerts) {
1178             match = false;
1179             for (Certificate cert : certs) {
1180                 if (pcert.equals(cert)) {
1181                     match = true;
1182                     break;
1183                 }
1184             }
1185             if (!match) return false;
1186         }
1187 
1188         return true;
1189     }
1190 
1191     /**
1192      * Links the specified class.  This (misleadingly named) method may be
1193      * used by a class loader to link a class.  If the class {@code c} has
1194      * already been linked, then this method simply returns. Otherwise, the
1195      * class is linked as described in the &quot;Execution&quot; chapter of
1196      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
1197      *
1198      * @param  c
1199      *         The class to link
1200      *
1201      * @throws  NullPointerException
1202      *          If {@code c} is {@code null}.
1203      *
1204      * @see  #defineClass(String, byte[], int, int)
1205      */
1206     protected final void resolveClass(Class&lt;?&gt; c) {
1207         if (c == null) {
1208             throw new NullPointerException();
1209         }
1210     }
1211 
1212     /**
1213      * Finds a class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;,
1214      * loading it if necessary.
1215      *
1216      * &lt;p&gt; This method loads the class through the system class loader (see
1217      * {@link #getSystemClassLoader()}).  The {@code Class} object returned
1218      * might have more than one {@code ClassLoader} associated with it.
1219      * Subclasses of {@code ClassLoader} need not usually invoke this method,
1220      * because most class loaders need to override just {@link
1221      * #findClass(String)}.  &lt;/p&gt;
1222      *
1223      * @param  name
1224      *         The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class
1225      *
1226      * @return  The {@code Class} object for the specified {@code name}
1227      *
1228      * @throws  ClassNotFoundException
1229      *          If the class could not be found
1230      *
1231      * @see  #ClassLoader(ClassLoader)
1232      * @see  #getParent()
1233      */
1234     protected final Class&lt;?&gt; findSystemClass(String name)
1235         throws ClassNotFoundException
1236     {
1237         return getSystemClassLoader().loadClass(name);
1238     }
1239 
1240     /**
1241      * Returns a class loaded by the bootstrap class loader;
1242      * or return null if not found.
1243      */
1244     Class&lt;?&gt; findBootstrapClassOrNull(String name) {
1245         if (!checkName(name)) return null;
1246 
1247         return findBootstrapClass(name);
1248     }
1249 
1250     // return null if not found
1251     private native Class&lt;?&gt; findBootstrapClass(String name);
1252 
1253     /**
1254      * Returns the class with the given &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; if this
1255      * loader has been recorded by the Java virtual machine as an initiating
1256      * loader of a class with that &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.  Otherwise
1257      * {@code null} is returned.
1258      *
1259      * @param  name
1260      *         The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class
1261      *
1262      * @return  The {@code Class} object, or {@code null} if the class has
1263      *          not been loaded
1264      *
1265      * @since  1.1
1266      */
1267     protected final Class&lt;?&gt; findLoadedClass(String name) {
1268         if (!checkName(name))
1269             return null;
1270         return findLoadedClass0(name);
1271     }
1272 
1273     private final native Class&lt;?&gt; findLoadedClass0(String name);
1274 
1275     /**
1276      * Sets the signers of a class.  This should be invoked after defining a
1277      * class.
1278      *
1279      * @param  c
1280      *         The {@code Class} object
1281      *
1282      * @param  signers
1283      *         The signers for the class
1284      *
1285      * @since  1.1
1286      */
1287     protected final void setSigners(Class&lt;?&gt; c, Object[] signers) {
1288         c.setSigners(signers);
1289     }
1290 
1291 
1292     // -- Resources --
1293 
1294     /**
1295      * Returns a URL to a resource in a module defined to this class loader.
1296      * Class loader implementations that support loading from modules
1297      * should override this method.
1298      *
1299      * @apiNote This method is the basis for the {@link
1300      * Class#getResource Class.getResource}, {@link Class#getResourceAsStream
1301      * Class.getResourceAsStream}, and {@link Module#getResourceAsStream
1302      * Module.getResourceAsStream} methods. It is not subject to the rules for
1303      * encapsulation specified by {@code Module.getResourceAsStream}.
1304      *
1305      * @implSpec The default implementation attempts to find the resource by
1306      * invoking {@link #findResource(String)} when the {@code moduleName} is
1307      * {@code null}. It otherwise returns {@code null}.
1308      *
1309      * @param  moduleName
1310      *         The module name; or {@code null} to find a resource in the
1311      *         {@linkplain #getUnnamedModule() unnamed module} for this
1312      *         class loader
1313      * @param  name
1314      *         The resource name
1315      *
1316      * @return A URL to the resource; {@code null} if the resource could not be
1317      *         found, a URL could not be constructed to locate the resource,
1318      *         access to the resource is denied by the security manager, or
1319      *         there isn&#39;t a module of the given name defined to the class
1320      *         loader.
1321      *
1322      * @throws IOException
1323      *         If I/O errors occur
1324      *
1325      * @see java.lang.module.ModuleReader#find(String)
1326      * @since 9
1327      * @spec JPMS
1328      */
1329     protected URL findResource(String moduleName, String name) throws IOException {
1330         if (moduleName == null) {
1331             return findResource(name);
1332         } else {
1333             return null;
1334         }
1335     }
1336 
1337     /**
1338      * Finds the resource with the given name.  A resource is some data
1339      * (images, audio, text, etc) that can be accessed by class code in a way
1340      * that is independent of the location of the code.
1341      *
1342      * &lt;p&gt; The name of a resource is a &#39;{@code /}&#39;-separated path name that
1343      * identifies the resource. &lt;/p&gt;
1344      *
1345      * &lt;p&gt; Resources in named modules are subject to the encapsulation rules
1346      * specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.
1347      * Additionally, and except for the special case where the resource has a
1348      * name ending with &quot;{@code .class}&quot;, this method will only find resources in
1349      * packages of named modules when the package is {@link Module#isOpen(String)
1350      * opened} unconditionally (even if the caller of this method is in the
1351      * same module as the resource). &lt;/p&gt;
1352      *
1353      * @implSpec The default implementation will first search the parent class
1354      * loader for the resource; if the parent is {@code null} the path of the
1355      * class loader built into the virtual machine is searched. If not found,
1356      * this method will invoke {@link #findResource(String)} to find the resource.
1357      *
1358      * @apiNote Where several modules are defined to the same class loader,
1359      * and where more than one module contains a resource with the given name,
1360      * then the ordering that modules are searched is not specified and may be
1361      * very unpredictable.
1362      * When overriding this method it is recommended that an implementation
1363      * ensures that any delegation is consistent with the {@link
1364      * #getResources(java.lang.String) getResources(String)} method.
1365      *
1366      * @param  name
1367      *         The resource name
1368      *
1369      * @return  {@code URL} object for reading the resource; {@code null} if
1370      *          the resource could not be found, a {@code URL} could not be
1371      *          constructed to locate the resource, the resource is in a package
1372      *          that is not opened unconditionally, or access to the resource is
1373      *          denied by the security manager.
1374      *
1375      * @throws  NullPointerException If {@code name} is {@code null}
1376      *
1377      * @since  1.1
1378      * @revised 9
1379      * @spec JPMS
1380      */
1381     public URL getResource(String name) {
1382         Objects.requireNonNull(name);
1383         URL url;
1384         if (parent != null) {
1385             url = parent.getResource(name);
1386         } else {
1387             url = BootLoader.findResource(name);
1388         }
1389         if (url == null) {
1390             url = findResource(name);
1391         }
1392         return url;
1393     }
1394 
1395     /**
1396      * Finds all the resources with the given name. A resource is some data
1397      * (images, audio, text, etc) that can be accessed by class code in a way
1398      * that is independent of the location of the code.
1399      *
1400      * &lt;p&gt; The name of a resource is a {@code /}-separated path name that
1401      * identifies the resource. &lt;/p&gt;
1402      *
1403      * &lt;p&gt; Resources in named modules are subject to the encapsulation rules
1404      * specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.
1405      * Additionally, and except for the special case where the resource has a
1406      * name ending with &quot;{@code .class}&quot;, this method will only find resources in
1407      * packages of named modules when the package is {@link Module#isOpen(String)
1408      * opened} unconditionally (even if the caller of this method is in the
1409      * same module as the resource). &lt;/p&gt;
1410      *
1411      * @implSpec The default implementation will first search the parent class
1412      * loader for the resource; if the parent is {@code null} the path of the
1413      * class loader built into the virtual machine is searched. It then
1414      * invokes {@link #findResources(String)} to find the resources with the
1415      * name in this class loader. It returns an enumeration whose elements
1416      * are the URLs found by searching the parent class loader followed by
1417      * the elements found with {@code findResources}.
1418      *
1419      * @apiNote Where several modules are defined to the same class loader,
1420      * and where more than one module contains a resource with the given name,
1421      * then the ordering is not specified and may be very unpredictable.
1422      * When overriding this method it is recommended that an
1423      * implementation ensures that any delegation is consistent with the {@link
1424      * #getResource(java.lang.String) getResource(String)} method. This should
1425      * ensure that the first element returned by the Enumeration&#39;s
1426      * {@code nextElement} method is the same resource that the
1427      * {@code getResource(String)} method would return.
1428      *
1429      * @param  name
1430      *         The resource name
1431      *
1432      * @return  An enumeration of {@link java.net.URL URL} objects for the
1433      *          resource. If no resources could be found, the enumeration will
1434      *          be empty. Resources for which a {@code URL} cannot be
1435      *          constructed, are in a package that is not opened
1436      *          unconditionally, or access to the resource is denied by the
1437      *          security manager, are not returned in the enumeration.
1438      *
1439      * @throws  IOException
1440      *          If I/O errors occur
1441      * @throws  NullPointerException If {@code name} is {@code null}
1442      *
1443      * @since  1.2
1444      * @revised 9
1445      * @spec JPMS
1446      */
1447     public Enumeration&lt;URL&gt; getResources(String name) throws IOException {
1448         Objects.requireNonNull(name);
1449         @SuppressWarnings(&quot;unchecked&quot;)
1450         Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) new Enumeration&lt;?&gt;[2];
1451         if (parent != null) {
1452             tmp[0] = parent.getResources(name);
1453         } else {
1454             tmp[0] = BootLoader.findResources(name);
1455         }
1456         tmp[1] = findResources(name);
1457 
1458         return new CompoundEnumeration&lt;&gt;(tmp);
1459     }
1460 
1461     /**
1462      * Returns a stream whose elements are the URLs of all the resources with
1463      * the given name. A resource is some data (images, audio, text, etc) that
1464      * can be accessed by class code in a way that is independent of the
1465      * location of the code.
1466      *
1467      * &lt;p&gt; The name of a resource is a {@code /}-separated path name that
1468      * identifies the resource.
1469      *
1470      * &lt;p&gt; The resources will be located when the returned stream is evaluated.
1471      * If the evaluation results in an {@code IOException} then the I/O
1472      * exception is wrapped in an {@link UncheckedIOException} that is then
1473      * thrown.
1474      *
1475      * &lt;p&gt; Resources in named modules are subject to the encapsulation rules
1476      * specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.
1477      * Additionally, and except for the special case where the resource has a
1478      * name ending with &quot;{@code .class}&quot;, this method will only find resources in
1479      * packages of named modules when the package is {@link Module#isOpen(String)
1480      * opened} unconditionally (even if the caller of this method is in the
1481      * same module as the resource). &lt;/p&gt;
1482      *
1483      * @implSpec The default implementation invokes {@link #getResources(String)
1484      * getResources} to find all the resources with the given name and returns
1485      * a stream with the elements in the enumeration as the source.
1486      *
1487      * @apiNote When overriding this method it is recommended that an
1488      * implementation ensures that any delegation is consistent with the {@link
1489      * #getResource(java.lang.String) getResource(String)} method. This should
1490      * ensure that the first element returned by the stream is the same
1491      * resource that the {@code getResource(String)} method would return.
1492      *
1493      * @param  name
1494      *         The resource name
1495      *
1496      * @return  A stream of resource {@link java.net.URL URL} objects. If no
1497      *          resources could  be found, the stream will be empty. Resources
1498      *          for which a {@code URL} cannot be constructed, are in a package
1499      *          that is not opened unconditionally, or access to the resource
1500      *          is denied by the security manager, will not be in the stream.
1501      *
1502      * @throws  NullPointerException If {@code name} is {@code null}
1503      *
1504      * @since  9
1505      */
1506     public Stream&lt;URL&gt; resources(String name) {
1507         Objects.requireNonNull(name);
1508         int characteristics = Spliterator.NONNULL | Spliterator.IMMUTABLE;
1509         Supplier&lt;Spliterator&lt;URL&gt;&gt; si = () -&gt; {
1510             try {
1511                 return Spliterators.spliteratorUnknownSize(
1512                     getResources(name).asIterator(), characteristics);
1513             } catch (IOException e) {
1514                 throw new UncheckedIOException(e);
1515             }
1516         };
1517         return StreamSupport.stream(si, characteristics, false);
1518     }
1519 
1520     /**
1521      * Finds the resource with the given name. Class loader implementations
1522      * should override this method.
1523      *
1524      * &lt;p&gt; For resources in named modules then the method must implement the
1525      * rules for encapsulation specified in the {@code Module} {@link
1526      * Module#getResourceAsStream getResourceAsStream} method. Additionally,
1527      * it must not find non-&quot;{@code .class}&quot; resources in packages of named
1528      * modules unless the package is {@link Module#isOpen(String) opened}
1529      * unconditionally. &lt;/p&gt;
1530      *
1531      * @implSpec The default implementation returns {@code null}.
1532      *
1533      * @param  name
1534      *         The resource name
1535      *
1536      * @return  {@code URL} object for reading the resource; {@code null} if
1537      *          the resource could not be found, a {@code URL} could not be
1538      *          constructed to locate the resource, the resource is in a package
1539      *          that is not opened unconditionally, or access to the resource is
1540      *          denied by the security manager.
1541      *
1542      * @since  1.2
1543      * @revised 9
1544      * @spec JPMS
1545      */
1546     protected URL findResource(String name) {
1547         return null;
1548     }
1549 
1550     /**
1551      * Returns an enumeration of {@link java.net.URL URL} objects
1552      * representing all the resources with the given name. Class loader
1553      * implementations should override this method.
1554      *
1555      * &lt;p&gt; For resources in named modules then the method must implement the
1556      * rules for encapsulation specified in the {@code Module} {@link
1557      * Module#getResourceAsStream getResourceAsStream} method. Additionally,
1558      * it must not find non-&quot;{@code .class}&quot; resources in packages of named
1559      * modules unless the package is {@link Module#isOpen(String) opened}
1560      * unconditionally. &lt;/p&gt;
1561      *
1562      * @implSpec The default implementation returns an enumeration that
1563      * contains no elements.
1564      *
1565      * @param  name
1566      *         The resource name
1567      *
1568      * @return  An enumeration of {@link java.net.URL URL} objects for
1569      *          the resource. If no resources could  be found, the enumeration
1570      *          will be empty. Resources for which a {@code URL} cannot be
1571      *          constructed, are in a package that is not opened unconditionally,
1572      *          or access to the resource is denied by the security manager,
1573      *          are not returned in the enumeration.
1574      *
1575      * @throws  IOException
1576      *          If I/O errors occur
1577      *
1578      * @since  1.2
1579      * @revised 9
1580      * @spec JPMS
1581      */
1582     protected Enumeration&lt;URL&gt; findResources(String name) throws IOException {
1583         return Collections.emptyEnumeration();
1584     }
1585 
1586     /**
1587      * Registers the caller as
1588      * {@linkplain #isRegisteredAsParallelCapable() parallel capable}.
1589      * The registration succeeds if and only if all of the following
1590      * conditions are met:
1591      * &lt;ol&gt;
1592      * &lt;li&gt; no instance of the caller has been created&lt;/li&gt;
1593      * &lt;li&gt; all of the super classes (except class Object) of the caller are
1594      * registered as parallel capable&lt;/li&gt;
1595      * &lt;/ol&gt;
1596      * &lt;p&gt;Note that once a class loader is registered as parallel capable, there
1597      * is no way to change it back.&lt;/p&gt;
1598      *
1599      * @return  {@code true} if the caller is successfully registered as
1600      *          parallel capable and {@code false} if otherwise.
1601      *
1602      * @see #isRegisteredAsParallelCapable()
1603      *
1604      * @since   1.7
1605      */
1606     @CallerSensitive
1607     protected static boolean registerAsParallelCapable() {
1608         Class&lt;? extends ClassLoader&gt; callerClass =
1609             Reflection.getCallerClass().asSubclass(ClassLoader.class);
1610         return ParallelLoaders.register(callerClass);
1611     }
1612 
1613     /**
1614      * Returns {@code true} if this class loader is registered as
1615      * {@linkplain #registerAsParallelCapable parallel capable}, otherwise
1616      * {@code false}.
1617      *
1618      * @return  {@code true} if this class loader is parallel capable,
1619      *          otherwise {@code false}.
1620      *
1621      * @see #registerAsParallelCapable()
1622      *
1623      * @since   9
1624      */
1625     public final boolean isRegisteredAsParallelCapable() {
1626         return ParallelLoaders.isRegistered(this.getClass());
1627     }
1628 
1629     /**
1630      * Find a resource of the specified name from the search path used to load
1631      * classes.  This method locates the resource through the system class
1632      * loader (see {@link #getSystemClassLoader()}).
1633      *
1634      * &lt;p&gt; Resources in named modules are subject to the encapsulation rules
1635      * specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.
1636      * Additionally, and except for the special case where the resource has a
1637      * name ending with &quot;{@code .class}&quot;, this method will only find resources in
1638      * packages of named modules when the package is {@link Module#isOpen(String)
1639      * opened} unconditionally. &lt;/p&gt;
1640      *
1641      * @param  name
1642      *         The resource name
1643      *
1644      * @return  A {@link java.net.URL URL} to the resource; {@code
1645      *          null} if the resource could not be found, a URL could not be
1646      *          constructed to locate the resource, the resource is in a package
1647      *          that is not opened unconditionally or access to the resource is
1648      *          denied by the security manager.
1649      *
1650      * @since  1.1
1651      * @revised 9
1652      * @spec JPMS
1653      */
1654     public static URL getSystemResource(String name) {
1655         return getSystemClassLoader().getResource(name);
1656     }
1657 
1658     /**
1659      * Finds all resources of the specified name from the search path used to
1660      * load classes.  The resources thus found are returned as an
1661      * {@link java.util.Enumeration Enumeration} of {@link
1662      * java.net.URL URL} objects.
1663      *
1664      * &lt;p&gt; The search order is described in the documentation for {@link
1665      * #getSystemResource(String)}.  &lt;/p&gt;
1666      *
1667      * &lt;p&gt; Resources in named modules are subject to the encapsulation rules
1668      * specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.
1669      * Additionally, and except for the special case where the resource has a
1670      * name ending with &quot;{@code .class}&quot;, this method will only find resources in
1671      * packages of named modules when the package is {@link Module#isOpen(String)
1672      * opened} unconditionally. &lt;/p&gt;
1673      *
1674      * @param  name
1675      *         The resource name
1676      *
1677      * @return  An enumeration of {@link java.net.URL URL} objects for
1678      *          the resource. If no resources could  be found, the enumeration
1679      *          will be empty. Resources for which a {@code URL} cannot be
1680      *          constructed, are in a package that is not opened unconditionally,
1681      *          or access to the resource is denied by the security manager,
1682      *          are not returned in the enumeration.
1683      *
1684      * @throws  IOException
1685      *          If I/O errors occur
1686      *
1687      * @since  1.2
1688      * @revised 9
1689      * @spec JPMS
1690      */
1691     public static Enumeration&lt;URL&gt; getSystemResources(String name)
1692         throws IOException
1693     {
1694         return getSystemClassLoader().getResources(name);
1695     }
1696 
1697     /**
1698      * Returns an input stream for reading the specified resource.
1699      *
1700      * &lt;p&gt; The search order is described in the documentation for {@link
1701      * #getResource(String)}.  &lt;/p&gt;
1702      *
1703      * &lt;p&gt; Resources in named modules are subject to the encapsulation rules
1704      * specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.
1705      * Additionally, and except for the special case where the resource has a
1706      * name ending with &quot;{@code .class}&quot;, this method will only find resources in
1707      * packages of named modules when the package is {@link Module#isOpen(String)
1708      * opened} unconditionally. &lt;/p&gt;
1709      *
1710      * @param  name
1711      *         The resource name
1712      *
1713      * @return  An input stream for reading the resource; {@code null} if the
1714      *          resource could not be found, the resource is in a package that
1715      *          is not opened unconditionally, or access to the resource is
1716      *          denied by the security manager.
1717      *
1718      * @throws  NullPointerException If {@code name} is {@code null}
1719      *
1720      * @since  1.1
1721      * @revised 9
1722      * @spec JPMS
1723      */
1724     public InputStream getResourceAsStream(String name) {
1725         Objects.requireNonNull(name);
1726         URL url = getResource(name);
1727         try {
1728             return url != null ? url.openStream() : null;
1729         } catch (IOException e) {
1730             return null;
1731         }
1732     }
1733 
1734     /**
1735      * Open for reading, a resource of the specified name from the search path
1736      * used to load classes.  This method locates the resource through the
1737      * system class loader (see {@link #getSystemClassLoader()}).
1738      *
1739      * &lt;p&gt; Resources in named modules are subject to the encapsulation rules
1740      * specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.
1741      * Additionally, and except for the special case where the resource has a
1742      * name ending with &quot;{@code .class}&quot;, this method will only find resources in
1743      * packages of named modules when the package is {@link Module#isOpen(String)
1744      * opened} unconditionally. &lt;/p&gt;
1745      *
1746      * @param  name
1747      *         The resource name
1748      *
1749      * @return  An input stream for reading the resource; {@code null} if the
1750      *          resource could not be found, the resource is in a package that
1751      *          is not opened unconditionally, or access to the resource is
1752      *          denied by the security manager.
1753      *
1754      * @since  1.1
1755      * @revised 9
1756      * @spec JPMS
1757      */
1758     public static InputStream getSystemResourceAsStream(String name) {
1759         URL url = getSystemResource(name);
1760         try {
1761             return url != null ? url.openStream() : null;
1762         } catch (IOException e) {
1763             return null;
1764         }
1765     }
1766 
1767 
1768     // -- Hierarchy --
1769 
1770     /**
1771      * Returns the parent class loader for delegation. Some implementations may
1772      * use {@code null} to represent the bootstrap class loader. This method
1773      * will return {@code null} in such implementations if this class loader&#39;s
1774      * parent is the bootstrap class loader.
1775      *
1776      * @return  The parent {@code ClassLoader}
1777      *
1778      * @throws  SecurityException
1779      *          If a security manager is present, and the caller&#39;s class loader
1780      *          is not {@code null} and is not an ancestor of this class loader,
1781      *          and the caller does not have the
1782      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
1783      *
1784      * @since  1.2
1785      */
1786     @CallerSensitive
1787     public final ClassLoader getParent() {
1788         if (parent == null)
1789             return null;
1790         SecurityManager sm = System.getSecurityManager();
1791         if (sm != null) {
1792             // Check access to the parent class loader
1793             // If the caller&#39;s class loader is same as this class loader,
1794             // permission check is performed.
1795             checkClassLoaderPermission(parent, Reflection.getCallerClass());
1796         }
1797         return parent;
1798     }
1799 
1800     /**
1801      * Returns the unnamed {@code Module} for this class loader.
1802      *
1803      * @return The unnamed Module for this class loader
1804      *
1805      * @see Module#isNamed()
1806      * @since 9
1807      * @spec JPMS
1808      */
1809     public final Module getUnnamedModule() {
1810         return unnamedModule;
1811     }
1812 
1813     /**
1814      * Returns the platform class loader.  All
1815      * &lt;a href=&quot;#builtinLoaders&quot;&gt;platform classes&lt;/a&gt; are visible to
1816      * the platform class loader.
1817      *
1818      * @implNote The name of the builtin platform class loader is
1819      * {@code &quot;platform&quot;}.
1820      *
1821      * @return  The platform {@code ClassLoader}.
1822      *
1823      * @throws  SecurityException
1824      *          If a security manager is present, and the caller&#39;s class loader is
1825      *          not {@code null}, and the caller&#39;s class loader is not the same
1826      *          as or an ancestor of the platform class loader,
1827      *          and the caller does not have the
1828      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
1829      *
1830      * @since 9
1831      * @spec JPMS
1832      */
1833     @CallerSensitive
1834     public static ClassLoader getPlatformClassLoader() {
1835         SecurityManager sm = System.getSecurityManager();
1836         ClassLoader loader = getBuiltinPlatformClassLoader();
1837         if (sm != null) {
1838             checkClassLoaderPermission(loader, Reflection.getCallerClass());
1839         }
1840         return loader;
1841     }
1842 
1843     /**
1844      * Returns the system class loader.  This is the default
1845      * delegation parent for new {@code ClassLoader} instances, and is
1846      * typically the class loader used to start the application.
1847      *
1848      * &lt;p&gt; This method is first invoked early in the runtime&#39;s startup
1849      * sequence, at which point it creates the system class loader. This
1850      * class loader will be the context class loader for the main application
1851      * thread (for example, the thread that invokes the {@code main} method of
1852      * the main class).
1853      *
1854      * &lt;p&gt; The default system class loader is an implementation-dependent
1855      * instance of this class.
1856      *
1857      * &lt;p&gt; If the system property &quot;{@systemProperty java.system.class.loader}&quot;
1858      * is defined when this method is first invoked then the value of that
1859      * property is taken to be the name of a class that will be returned as the
1860      * system class loader. The class is loaded using the default system class
1861      * loader and must define a public constructor that takes a single parameter
1862      * of type {@code ClassLoader} which is used as the delegation parent. An
1863      * instance is then created using this constructor with the default system
1864      * class loader as the parameter.  The resulting class loader is defined
1865      * to be the system class loader. During construction, the class loader
1866      * should take great care to avoid calling {@code getSystemClassLoader()}.
1867      * If circular initialization of the system class loader is detected then
1868      * an {@code IllegalStateException} is thrown.
1869      *
1870      * @implNote The system property to override the system class loader is not
1871      * examined until the VM is almost fully initialized. Code that executes
1872      * this method during startup should take care not to cache the return
1873      * value until the system is fully initialized.
1874      *
1875      * &lt;p&gt; The name of the built-in system class loader is {@code &quot;app&quot;}.
1876      * The system property &quot;{@code java.class.path}&quot; is read during early
1877      * initialization of the VM to determine the class path.
1878      * An empty value of &quot;{@code java.class.path}&quot; property is interpreted
1879      * differently depending on whether the initial module (the module
1880      * containing the main class) is named or unnamed:
1881      * If named, the built-in system class loader will have no class path and
1882      * will search for classes and resources using the application module path;
1883      * otherwise, if unnamed, it will set the class path to the current
1884      * working directory.
1885      *
1886      * &lt;p&gt; JAR files on the class path may contain a {@code Class-Path} manifest
1887      * attribute to specify dependent JAR files to be included in the class path.
1888      * {@code Class-Path} entries must meet certain conditions for validity (see
1889      * the &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#class-path-attribute&quot;&gt;
1890      * JAR File Specification&lt;/a&gt; for details).  Invalid {@code Class-Path}
1891      * entries are ignored.  For debugging purposes, ignored entries can be
1892      * printed to the console if the
1893      * {@systemProperty jdk.net.URLClassPath.showIgnoredClassPathEntries} system
1894      * property is set to {@code true}.
1895      *
1896      * @return  The system {@code ClassLoader}
1897      *
1898      * @throws  SecurityException
1899      *          If a security manager is present, and the caller&#39;s class loader
1900      *          is not {@code null} and is not the same as or an ancestor of the
1901      *          system class loader, and the caller does not have the
1902      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
1903      *
1904      * @throws  IllegalStateException
1905      *          If invoked recursively during the construction of the class
1906      *          loader specified by the &quot;{@code java.system.class.loader}&quot;
1907      *          property.
1908      *
1909      * @throws  Error
1910      *          If the system property &quot;{@code java.system.class.loader}&quot;
1911      *          is defined but the named class could not be loaded, the
1912      *          provider class does not define the required constructor, or an
1913      *          exception is thrown by that constructor when it is invoked. The
1914      *          underlying cause of the error can be retrieved via the
1915      *          {@link Throwable#getCause()} method.
1916      *
1917      * @revised  1.4
1918      * @revised 9
1919      * @spec JPMS
1920      */
1921     @CallerSensitive
1922     public static ClassLoader getSystemClassLoader() {
1923         switch (VM.initLevel()) {
1924             case 0:
1925             case 1:
1926             case 2:
1927                 // the system class loader is the built-in app class loader during startup
1928                 return getBuiltinAppClassLoader();
1929             case 3:
1930                 String msg = &quot;getSystemClassLoader cannot be called during the system class loader instantiation&quot;;
1931                 throw new IllegalStateException(msg);
1932             default:
1933                 // system fully initialized
1934                 assert VM.isBooted() &amp;&amp; scl != null;
1935                 SecurityManager sm = System.getSecurityManager();
1936                 if (sm != null) {
1937                     checkClassLoaderPermission(scl, Reflection.getCallerClass());
1938                 }
1939                 return scl;
1940         }
1941     }
1942 
1943     static ClassLoader getBuiltinPlatformClassLoader() {
1944         return ClassLoaders.platformClassLoader();
1945     }
1946 
1947     static ClassLoader getBuiltinAppClassLoader() {
1948         return ClassLoaders.appClassLoader();
1949     }
1950 
1951     /*
1952      * Initialize the system class loader that may be a custom class on the
1953      * application class path or application module path.
1954      *
1955      * @see java.lang.System#initPhase3
1956      */
1957     static synchronized ClassLoader initSystemClassLoader() {
1958         if (VM.initLevel() != 3) {
1959             throw new InternalError(&quot;system class loader cannot be set at initLevel &quot; +
1960                                     VM.initLevel());
1961         }
1962 
1963         // detect recursive initialization
1964         if (scl != null) {
1965             throw new IllegalStateException(&quot;recursive invocation&quot;);
1966         }
1967 
1968         ClassLoader builtinLoader = getBuiltinAppClassLoader();
1969 
1970         // All are privileged frames.  No need to call doPrivileged.
1971         String cn = System.getProperty(&quot;java.system.class.loader&quot;);
1972         if (cn != null) {
1973             try {
1974                 // custom class loader is only supported to be loaded from unnamed module
1975                 Constructor&lt;?&gt; ctor = Class.forName(cn, false, builtinLoader)
1976                                            .getDeclaredConstructor(ClassLoader.class);
1977                 scl = (ClassLoader) ctor.newInstance(builtinLoader);
1978             } catch (Exception e) {
1979                 Throwable cause = e;
1980                 if (e instanceof InvocationTargetException) {
1981                     cause = e.getCause();
1982                     if (cause instanceof Error) {
1983                         throw (Error) cause;
1984                     }
1985                 }
1986                 if (cause instanceof RuntimeException) {
1987                     throw (RuntimeException) cause;
1988                 }
1989                 throw new Error(cause.getMessage(), cause);
1990             }
1991         } else {
1992             scl = builtinLoader;
1993         }
1994         return scl;
1995     }
1996 
1997     // Returns true if the specified class loader can be found in this class
1998     // loader&#39;s delegation chain.
1999     boolean isAncestor(ClassLoader cl) {
2000         ClassLoader acl = this;
2001         do {
2002             acl = acl.parent;
2003             if (cl == acl) {
2004                 return true;
2005             }
2006         } while (acl != null);
2007         return false;
2008     }
2009 
2010     // Tests if class loader access requires &quot;getClassLoader&quot; permission
2011     // check.  A class loader &#39;from&#39; can access class loader &#39;to&#39; if
2012     // class loader &#39;from&#39; is same as class loader &#39;to&#39; or an ancestor
2013     // of &#39;to&#39;.  The class loader in a system domain can access
2014     // any class loader.
2015     private static boolean needsClassLoaderPermissionCheck(ClassLoader from,
2016                                                            ClassLoader to)
2017     {
2018         if (from == to)
2019             return false;
2020 
2021         if (from == null)
2022             return false;
2023 
2024         return !to.isAncestor(from);
2025     }
2026 
2027     // Returns the class&#39;s class loader, or null if none.
2028     static ClassLoader getClassLoader(Class&lt;?&gt; caller) {
2029         // This can be null if the VM is requesting it
2030         if (caller == null) {
2031             return null;
2032         }
2033         // Circumvent security check since this is package-private
2034         return caller.getClassLoader0();
2035     }
2036 
2037     /*
2038      * Checks RuntimePermission(&quot;getClassLoader&quot;) permission
2039      * if caller&#39;s class loader is not null and caller&#39;s class loader
2040      * is not the same as or an ancestor of the given cl argument.
2041      */
2042     static void checkClassLoaderPermission(ClassLoader cl, Class&lt;?&gt; caller) {
2043         SecurityManager sm = System.getSecurityManager();
2044         if (sm != null) {
2045             // caller can be null if the VM is requesting it
2046             ClassLoader ccl = getClassLoader(caller);
2047             if (needsClassLoaderPermissionCheck(ccl, cl)) {
2048                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
2049             }
2050         }
2051     }
2052 
2053     // The system class loader
2054     // @GuardedBy(&quot;ClassLoader.class&quot;)
2055     private static volatile ClassLoader scl;
2056 
2057     // -- Package --
2058 
2059     /**
2060      * Define a Package of the given Class object.
2061      *
2062      * If the given class represents an array type, a primitive type or void,
2063      * this method returns {@code null}.
2064      *
2065      * This method does not throw IllegalArgumentException.
2066      */
2067     Package definePackage(Class&lt;?&gt; c) {
2068         if (c.isPrimitive() || c.isArray()) {
2069             return null;
2070         }
2071 
2072         return definePackage(c.getPackageName(), c.getModule());
2073     }
2074 
2075     /**
2076      * Defines a Package of the given name and module
2077      *
2078      * This method does not throw IllegalArgumentException.
2079      *
2080      * @param name package name
2081      * @param m    module
2082      */
2083     Package definePackage(String name, Module m) {
2084         if (name.isEmpty() &amp;&amp; m.isNamed()) {
2085             throw new InternalError(&quot;unnamed package in  &quot; + m);
2086         }
2087 
2088         // check if Package object is already defined
2089         NamedPackage pkg = packages.get(name);
2090         if (pkg instanceof Package)
2091             return (Package)pkg;
2092 
2093         return (Package)packages.compute(name, (n, p) -&gt; toPackage(n, p, m));
2094     }
2095 
2096     /*
2097      * Returns a Package object for the named package
2098      */
2099     private Package toPackage(String name, NamedPackage p, Module m) {
2100         // define Package object if the named package is not yet defined
2101         if (p == null)
2102             return NamedPackage.toPackage(name, m);
2103 
2104         // otherwise, replace the NamedPackage object with Package object
2105         if (p instanceof Package)
2106             return (Package)p;
2107 
2108         return NamedPackage.toPackage(p.packageName(), p.module());
2109     }
2110 
2111     /**
2112      * Defines a package by &lt;a href=&quot;#binary-name&quot;&gt;name&lt;/a&gt; in this {@code ClassLoader}.
2113      * &lt;p&gt;
2114      * &lt;a href=&quot;#binary-name&quot;&gt;Package names&lt;/a&gt; must be unique within a class loader and
2115      * cannot be redefined or changed once created.
2116      * &lt;p&gt;
2117      * If a class loader wishes to define a package with specific properties,
2118      * such as version information, then the class loader should call this
2119      * {@code definePackage} method before calling {@code defineClass}.
2120      * Otherwise, the
2121      * {@link #defineClass(String, byte[], int, int, ProtectionDomain) defineClass}
2122      * method will define a package in this class loader corresponding to the package
2123      * of the newly defined class; the properties of this defined package are
2124      * specified by {@link Package}.
2125      *
2126      * @apiNote
2127      * A class loader that wishes to define a package for classes in a JAR
2128      * typically uses the specification and implementation titles, versions, and
2129      * vendors from the JAR&#39;s manifest. If the package is specified as
2130      * {@linkplain java.util.jar.Attributes.Name#SEALED sealed} in the JAR&#39;s manifest,
2131      * the {@code URL} of the JAR file is typically used as the {@code sealBase}.
2132      * If classes of package {@code &#39;p&#39;} defined by this class loader
2133      * are loaded from multiple JARs, the {@code Package} object may contain
2134      * different information depending on the first class of package {@code &#39;p&#39;}
2135      * defined and which JAR&#39;s manifest is read first to explicitly define
2136      * package {@code &#39;p&#39;}.
2137      *
2138      * &lt;p&gt; It is strongly recommended that a class loader does not call this
2139      * method to explicitly define packages in &lt;em&gt;named modules&lt;/em&gt;; instead,
2140      * the package will be automatically defined when a class is {@linkplain
2141      * #defineClass(String, byte[], int, int, ProtectionDomain) being defined}.
2142      * If it is desirable to define {@code Package} explicitly, it should ensure
2143      * that all packages in a named module are defined with the properties
2144      * specified by {@link Package}.  Otherwise, some {@code Package} objects
2145      * in a named module may be for example sealed with different seal base.
2146      *
2147      * @param  name
2148      *         The &lt;a href=&quot;#binary-name&quot;&gt;package name&lt;/a&gt;
2149      *
2150      * @param  specTitle
2151      *         The specification title
2152      *
2153      * @param  specVersion
2154      *         The specification version
2155      *
2156      * @param  specVendor
2157      *         The specification vendor
2158      *
2159      * @param  implTitle
2160      *         The implementation title
2161      *
2162      * @param  implVersion
2163      *         The implementation version
2164      *
2165      * @param  implVendor
2166      *         The implementation vendor
2167      *
2168      * @param  sealBase
2169      *         If not {@code null}, then this package is sealed with
2170      *         respect to the given code source {@link java.net.URL URL}
2171      *         object.  Otherwise, the package is not sealed.
2172      *
2173      * @return  The newly defined {@code Package} object
2174      *
2175      * @throws  NullPointerException
2176      *          if {@code name} is {@code null}.
2177      *
2178      * @throws  IllegalArgumentException
2179      *          if a package of the given {@code name} is already
2180      *          defined by this class loader
2181      *
2182      *
2183      * @since  1.2
2184      * @revised 9
2185      * @spec JPMS
2186      *
2187      * @jvms 5.3 Creation and Loading
2188      * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#package-sealing&quot;&gt;
2189      *      The JAR File Specification: Package Sealing&lt;/a&gt;
2190      */
2191     protected Package definePackage(String name, String specTitle,
2192                                     String specVersion, String specVendor,
2193                                     String implTitle, String implVersion,
2194                                     String implVendor, URL sealBase)
2195     {
2196         Objects.requireNonNull(name);
2197 
2198         // definePackage is not final and may be overridden by custom class loader
2199         Package p = new Package(name, specTitle, specVersion, specVendor,
2200                                 implTitle, implVersion, implVendor,
2201                                 sealBase, this);
2202 
2203         if (packages.putIfAbsent(name, p) != null)
2204             throw new IllegalArgumentException(name);
2205 
2206         return p;
2207     }
2208 
2209     /**
2210      * Returns a {@code Package} of the given &lt;a href=&quot;#binary-name&quot;&gt;name&lt;/a&gt; that
2211      * has been defined by this class loader.
2212      *
2213      * @param  name The &lt;a href=&quot;#binary-name&quot;&gt;package name&lt;/a&gt;
2214      *
2215      * @return The {@code Package} of the given name that has been defined
2216      *         by this class loader, or {@code null} if not found
2217      *
2218      * @throws  NullPointerException
2219      *          if {@code name} is {@code null}.
2220      *
2221      * @jvms 5.3 Creation and Loading
2222      *
2223      * @since  9
2224      * @spec JPMS
2225      */
2226     public final Package getDefinedPackage(String name) {
2227         Objects.requireNonNull(name, &quot;name cannot be null&quot;);
2228 
2229         NamedPackage p = packages.get(name);
2230         if (p == null)
2231             return null;
2232 
2233         return definePackage(name, p.module());
2234     }
2235 
2236     /**
2237      * Returns all of the {@code Package}s that have been defined by
2238      * this class loader.  The returned array has no duplicated {@code Package}s
2239      * of the same name.
2240      *
2241      * @apiNote This method returns an array rather than a {@code Set} or {@code Stream}
2242      *          for consistency with the existing {@link #getPackages} method.
2243      *
2244      * @return The array of {@code Package} objects that have been defined by
2245      *         this class loader; or an zero length array if no package has been
2246      *         defined by this class loader.
2247      *
2248      * @jvms 5.3 Creation and Loading
2249      *
2250      * @since  9
2251      * @spec JPMS
2252      */
2253     public final Package[] getDefinedPackages() {
2254         return packages().toArray(Package[]::new);
2255     }
2256 
2257     /**
2258      * Finds a package by &lt;a href=&quot;#binary-name&quot;&gt;name&lt;/a&gt; in this class loader and its ancestors.
2259      * &lt;p&gt;
2260      * If this class loader defines a {@code Package} of the given name,
2261      * the {@code Package} is returned. Otherwise, the ancestors of
2262      * this class loader are searched recursively (parent by parent)
2263      * for a {@code Package} of the given name.
2264      *
2265      * @apiNote The {@link #getPlatformClassLoader() platform class loader}
2266      * may delegate to the application class loader but the application class
2267      * loader is not its ancestor.  When invoked on the platform class loader,
2268      * this method  will not find packages defined to the application
2269      * class loader.
2270      *
2271      * @param  name
2272      *         The &lt;a href=&quot;#binary-name&quot;&gt;package name&lt;/a&gt;
2273      *
2274      * @return The {@code Package} of the given name that has been defined by
2275      *         this class loader or its ancestors, or {@code null} if not found.
2276      *
2277      * @throws  NullPointerException
2278      *          if {@code name} is {@code null}.
2279      *
2280      * @deprecated
2281      * If multiple class loaders delegate to each other and define classes
2282      * with the same package name, and one such loader relies on the lookup
2283      * behavior of {@code getPackage} to return a {@code Package} from
2284      * a parent loader, then the properties exposed by the {@code Package}
2285      * may not be as expected in the rest of the program.
2286      * For example, the {@code Package} will only expose annotations from the
2287      * {@code package-info.class} file defined by the parent loader, even if
2288      * annotations exist in a {@code package-info.class} file defined by
2289      * a child loader.  A more robust approach is to use the
2290      * {@link ClassLoader#getDefinedPackage} method which returns
2291      * a {@code Package} for the specified class loader.
2292      *
2293      * @see ClassLoader#getDefinedPackage(String)
2294      *
2295      * @since  1.2
2296      * @revised 9
2297      * @spec JPMS
2298      */
2299     @Deprecated(since=&quot;9&quot;)
2300     protected Package getPackage(String name) {
2301         Package pkg = getDefinedPackage(name);
2302         if (pkg == null) {
2303             if (parent != null) {
2304                 pkg = parent.getPackage(name);
2305             } else {
2306                 pkg = BootLoader.getDefinedPackage(name);
2307             }
2308         }
2309         return pkg;
2310     }
2311 
2312     /**
2313      * Returns all of the {@code Package}s that have been defined by
2314      * this class loader and its ancestors.  The returned array may contain
2315      * more than one {@code Package} object of the same package name, each
2316      * defined by a different class loader in the class loader hierarchy.
2317      *
2318      * @apiNote The {@link #getPlatformClassLoader() platform class loader}
2319      * may delegate to the application class loader. In other words,
2320      * packages in modules defined to the application class loader may be
2321      * visible to the platform class loader.  On the other hand,
2322      * the application class loader is not its ancestor and hence
2323      * when invoked on the platform class loader, this method will not
2324      * return any packages defined to the application class loader.
2325      *
2326      * @return  The array of {@code Package} objects that have been defined by
2327      *          this class loader and its ancestors
2328      *
2329      * @see ClassLoader#getDefinedPackages()
2330      *
2331      * @since  1.2
2332      * @revised 9
2333      * @spec JPMS
2334      */
2335     protected Package[] getPackages() {
2336         Stream&lt;Package&gt; pkgs = packages();
2337         ClassLoader ld = parent;
2338         while (ld != null) {
2339             pkgs = Stream.concat(ld.packages(), pkgs);
2340             ld = ld.parent;
2341         }
2342         return Stream.concat(BootLoader.packages(), pkgs)
2343                      .toArray(Package[]::new);
2344     }
2345 
2346 
2347 
2348     // package-private
2349 
2350     /**
2351      * Returns a stream of Packages defined in this class loader
2352      */
2353     Stream&lt;Package&gt; packages() {
2354         return packages.values().stream()
2355                        .map(p -&gt; definePackage(p.packageName(), p.module()));
2356     }
2357 
2358     // -- Native library access --
2359 
2360     /**
2361      * Returns the absolute path name of a native library.  The VM invokes this
2362      * method to locate the native libraries that belong to classes loaded with
2363      * this class loader. If this method returns {@code null}, the VM
2364      * searches the library along the path specified as the
2365      * &quot;{@code java.library.path}&quot; property.
2366      *
2367      * @param  libname
2368      *         The library name
2369      *
2370      * @return  The absolute path of the native library
2371      *
2372      * @see  System#loadLibrary(String)
2373      * @see  System#mapLibraryName(String)
2374      *
2375      * @since  1.2
2376      */
2377     protected String findLibrary(String libname) {
2378         return null;
2379     }
2380 
2381     /**
2382      * The inner class NativeLibrary denotes a loaded native library instance.
2383      * Every classloader contains a vector of loaded native libraries in the
2384      * private field {@code nativeLibraries}.  The native libraries loaded
2385      * into the system are entered into the {@code systemNativeLibraries}
2386      * vector.
2387      *
2388      * &lt;p&gt; Every native library requires a particular version of JNI. This is
2389      * denoted by the private {@code jniVersion} field.  This field is set by
2390      * the VM when it loads the library, and used by the VM to pass the correct
2391      * version of JNI to the native methods.  &lt;/p&gt;
2392      *
2393      * @see      ClassLoader
2394      * @since    1.2
2395      */
2396     static class NativeLibrary implements NativeLibraryProxy {
2397         // the class from which the library is loaded, also indicates
2398         // the loader this native library belongs.
2399         final Class&lt;?&gt; fromClass;
2400         // the canonicalized name of the native library.
2401         // or static library name
2402         final String name;
2403         // Indicates if the native library is linked into the VM
2404         final boolean isBuiltin;
2405 
2406         // opaque handle to native library, used in native code.
2407         long handle;
2408         // the version of JNI environment the native library requires.
2409         int jniVersion;
2410 
2411         native boolean load0(String name, boolean isBuiltin);
2412 
2413         private native long findEntry0(String name);
2414 
2415         // used by default library
2416         private static native long findEntryInProcess(String name);
2417 
2418         long findEntry(String name) {
2419             return findEntry0(name);
2420         }
2421 
2422         NativeLibrary(Class&lt;?&gt; fromClass, String name, boolean isBuiltin) {
2423             this.name = name;
2424             this.fromClass = fromClass;
2425             this.isBuiltin = isBuiltin;
2426         }
2427 
2428         @Override
2429         public long lookup(String name) throws NoSuchMethodException {
2430             long addr = findEntry(name);
2431             if (0 == addr) {
2432                 throw new NoSuchMethodException(&quot;Cannot find symbol &quot; + name + &quot; in library &quot; + this.name);
2433             }
2434             return addr;
2435         }
2436 
2437         /*
2438          * Loads the native library and registers for cleanup when its
2439          * associated class loader is unloaded
2440          */
2441         boolean load() {
2442             if (handle != 0) {
2443                 throw new InternalError(&quot;Native library &quot; + name + &quot; has been loaded&quot;);
2444             }
2445 
2446             if (!load0(name, isBuiltin)) return false;
2447 
2448             // register the class loader for cleanup when unloaded
2449             // builtin class loaders are never unloaded
2450             ClassLoader loader = fromClass.getClassLoader();
2451             if (loader != null &amp;&amp;
2452                 loader != getBuiltinPlatformClassLoader() &amp;&amp;
2453                 loader != getBuiltinAppClassLoader()) {
2454                 CleanerFactory.cleaner().register(loader,
2455                         new Unloader(name, handle, isBuiltin));
2456             }
2457             return true;
2458         }
2459 
2460         static NativeLibrary defaultLibrary = new NativeLibrary(Object.class, &quot;&lt;default&gt;&quot;, true) {
2461 
2462             @Override
2463             boolean load() {
2464                 throw new UnsupportedOperationException(&quot;Cannot load default library&quot;);
2465             }
2466 
2467             @Override
2468             long findEntry(String name) {
2469                 return NativeLibrary.findEntryInProcess(name);
2470             }
2471             
2472         };
2473 
2474         static NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, String name, boolean isBuiltin) {
2475             ClassLoader loader =
2476                 fromClass == null ? null : fromClass.getClassLoader();
2477 
2478             synchronized (loadedLibraryNames) {
2479                 Map&lt;String, NativeLibrary&gt; libs =
2480                     loader != null ? loader.nativeLibraries() : systemNativeLibraries();
2481                 NativeLibrary cached = libs.get(name);
2482                 if (cached != null) {
2483                     return cached;
2484                 }
2485 
2486                 if (loadedLibraryNames.contains(name)) {
2487                     throw new UnsatisfiedLinkError(&quot;Native Library &quot; + name +
2488                         &quot; already loaded in another classloader&quot;);
2489                 }
2490 
2491                 /*
2492                  * When a library is being loaded, JNI_OnLoad function can cause
2493                  * another loadLibrary invocation that should succeed.
2494                  *
2495                  * We use a static stack to hold the list of libraries we are
2496                  * loading because this can happen only when called by the
2497                  * same thread because this block is synchronous.
2498                  *
2499                  * If there is a pending load operation for the library, we
2500                  * immediately return success; otherwise, we raise
2501                  * UnsatisfiedLinkError.
2502                  */
2503                 for (NativeLibrary lib : nativeLibraryContext) {
2504                     if (name.equals(lib.name)) {
2505                         if (loader == lib.fromClass.getClassLoader()) {
2506                             return lib;
2507                         } else {
2508                             throw new UnsatisfiedLinkError(&quot;Native Library &quot; +
2509                                 name + &quot; is being loaded in another classloader&quot;);
2510                         }
2511                     }
2512                 }
2513                 NativeLibrary lib = new NativeLibrary(fromClass, name, isBuiltin);
2514                 // load the native library
2515                 nativeLibraryContext.push(lib);
2516                 try {
2517                     if (!lib.load()) return null;
2518                 } finally {
2519                     nativeLibraryContext.pop();
2520                 }
2521                 // register the loaded native library
2522                 loadedLibraryNames.add(name);
2523                 libs.put(name, lib);
2524                 return lib;
2525             }
2526         }
2527 
2528         // Invoked in the VM to determine the context class in JNI_OnLoad
2529         // and JNI_OnUnload
2530         static Class&lt;?&gt; getFromClass() {
2531             if(nativeLibraryContext.isEmpty()) { // only default library 
2532                 return defaultLibrary.fromClass;
2533             }
2534             return nativeLibraryContext.peek().fromClass;
2535         }
2536 
2537         // native libraries being loaded
2538         static Deque&lt;NativeLibrary&gt; nativeLibraryContext = new ArrayDeque&lt;&gt;(8);
2539 
2540         /*
2541          * The run() method will be invoked when this class loader becomes
2542          * phantom reachable to unload the native library.
2543          */
2544         static class Unloader implements Runnable {
2545             // This represents the context when a native library is unloaded
2546             // and getFromClass() will return null,
2547             static final NativeLibrary UNLOADER =
2548                 new NativeLibrary(null, &quot;dummy&quot;, false);
2549             final String name;
2550             final long handle;
2551             final boolean isBuiltin;
2552 
2553             Unloader(String name, long handle, boolean isBuiltin) {
2554                 if (handle == 0) {
2555                     throw new IllegalArgumentException(
2556                         &quot;Invalid handle for native library &quot; + name);
2557                 }
2558 
2559                 this.name = name;
2560                 this.handle = handle;
2561                 this.isBuiltin = isBuiltin;
2562             }
2563 
2564             @Override
2565             public void run() {
2566                 synchronized (loadedLibraryNames) {
2567                     /* remove the native library name */
2568                     loadedLibraryNames.remove(name);
2569                     nativeLibraryContext.push(UNLOADER);
2570                     try {
2571                         unload(name, isBuiltin, handle);
2572                     } finally {
2573                         nativeLibraryContext.pop();
2574                     }
2575 
2576                 }
2577             }
2578         }
2579 
2580         // JNI FindClass expects the caller class if invoked from JNI_OnLoad
2581         // and JNI_OnUnload is NativeLibrary class
2582         static native void unload(String name, boolean isBuiltin, long handle);
2583     }
2584 
2585     /**
2586      * Holds system and user library paths derived from the
2587      * {@code java.library.path} and {@code sun.boot.library.path} system
2588      * properties. The system properties are eagerly read at bootstrap, then
2589      * lazily parsed on first use to avoid initialization ordering issues.
2590      */
2591     private static class LibraryPaths {
2592         static final String[] USER =
2593                 ClassLoaderHelper.parsePath(StaticProperty.javaLibraryPath());
2594         static final String[] SYS =
2595                 ClassLoaderHelper.parsePath(StaticProperty.sunBootLibraryPath());
2596     }
2597 
2598     // Invoked in the java.lang.Runtime class to implement load and loadLibrary.
2599     static NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, String name,
2600                                      boolean isAbsolute) {
2601         ClassLoader loader =
2602             (fromClass == null) ? null : fromClass.getClassLoader();
2603 
2604         if (isAbsolute) {
2605             NativeLibrary nl = loadLibrary0(fromClass, new File(name));
2606             if (nl != null) {
2607                 return nl;
2608             }
2609             throw new UnsatisfiedLinkError(&quot;Can&#39;t load library: &quot; + name);
2610         }
2611         if (loader != null) {
2612             String libfilename = loader.findLibrary(name);
2613             if (libfilename != null) {
2614                 File libfile = new File(libfilename);
2615                 if (!libfile.isAbsolute()) {
2616                     throw new UnsatisfiedLinkError(
2617                         &quot;ClassLoader.findLibrary failed to return an absolute path: &quot; + libfilename);
2618                 }
2619                 NativeLibrary nl = loadLibrary0(fromClass, libfile);
2620                 if (nl != null) {
2621                     return nl;
2622                 }
2623                 throw new UnsatisfiedLinkError(&quot;Can&#39;t load &quot; + libfilename);
2624             }
2625         }
2626         for (String sysPath : LibraryPaths.SYS) {
2627             File libfile = new File(sysPath, System.mapLibraryName(name));
2628             NativeLibrary nl = loadLibrary0(fromClass, libfile);
2629             if (nl != null) {
2630                 return nl;
2631             }
2632             libfile = ClassLoaderHelper.mapAlternativeName(libfile);
2633             if (libfile != null) {
2634                 nl = loadLibrary0(fromClass, libfile);
2635                 if (nl != null) {
2636                     return nl;
2637                 }
2638             }
2639         }
2640         if (loader != null) {
2641             for (String userPath : LibraryPaths.USER) {
2642                 File libfile = new File(userPath, System.mapLibraryName(name));
2643                 NativeLibrary nl = loadLibrary0(fromClass, libfile);
2644                 if (nl != null) {
2645                     return nl;
2646                 }
2647                 libfile = ClassLoaderHelper.mapAlternativeName(libfile);
2648                 if (libfile != null) {
2649                     nl = loadLibrary0(fromClass, libfile);
2650                     if (nl != null) {
2651                         return nl;
2652                     }
2653                 }
2654             }
2655         }
2656         // Oops, it failed
2657         throw new UnsatisfiedLinkError(&quot;no &quot; + name +
2658             &quot; in java.library.path: &quot; + Arrays.toString(LibraryPaths.USER));
2659     }
2660 
2661     private static native String findBuiltinLib(String name);
2662 
2663     private static NativeLibrary loadLibrary0(Class&lt;?&gt; fromClass, final File file) {
2664         // Check to see if we&#39;re attempting to access a static library
2665         String name = findBuiltinLib(file.getName());
2666         boolean isBuiltin = (name != null);
2667         if (!isBuiltin) {
2668             name = AccessController.doPrivileged(
2669                 new PrivilegedAction&lt;&gt;() {
2670                     public String run() {
2671                         try {
2672                             return file.exists() ? file.getCanonicalPath() : null;
2673                         } catch (IOException e) {
2674                             return null;
2675                         }
2676                     }
2677                 });
2678             if (name == null) {
2679                 return null;
2680             }
2681         }
2682         return NativeLibrary.loadLibrary(fromClass, name, isBuiltin);
2683     }
2684 
2685     /*
2686      * Invoked in the VM class linking code.
2687      */
2688     private static long findNative(ClassLoader loader, String entryName) {
2689         Map&lt;String, NativeLibrary&gt; libs =
2690             loader != null ? loader.nativeLibraries() : systemNativeLibraries();
2691         if (libs.isEmpty())
2692             return 0;
2693 
2694         // the native libraries map may be updated in another thread
2695         // when a native library is being loaded.  No symbol will be
2696         // searched from it yet.
2697         for (NativeLibrary lib : libs.values()) {
2698             long entry = lib.findEntry(entryName);
2699             if (entry != 0) return entry;
2700         }
2701         return 0;
2702     }
2703 
2704     // All native library names we&#39;ve loaded.
2705     // This also serves as the lock to obtain nativeLibraries
2706     // and write to nativeLibraryContext.
2707     private static final Set&lt;String&gt; loadedLibraryNames = new HashSet&lt;&gt;();
2708 
2709     // Native libraries belonging to system classes.
2710     private static volatile Map&lt;String, NativeLibrary&gt; systemNativeLibraries;
2711 
2712     // Native libraries associated with the class loader.
2713     private volatile Map&lt;String, NativeLibrary&gt; nativeLibraries;
2714 
2715     /*
2716      * Returns the native libraries map associated with bootstrap class loader
2717      * This method will create the map at the first time when called.
2718      */
2719     private static Map&lt;String, NativeLibrary&gt; systemNativeLibraries() {
2720         Map&lt;String, NativeLibrary&gt; libs = systemNativeLibraries;
2721         if (libs == null) {
2722             synchronized (loadedLibraryNames) {
2723                 libs = systemNativeLibraries;
2724                 if (libs == null) {
2725                     libs = systemNativeLibraries = new ConcurrentHashMap&lt;&gt;();
2726                 }
2727             }
2728         }
2729         return libs;
2730     }
2731 
2732     /*
2733      * Returns the native libraries map associated with this class loader
2734      * This method will create the map at the first time when called.
2735      */
2736     private Map&lt;String, NativeLibrary&gt; nativeLibraries() {
2737         Map&lt;String, NativeLibrary&gt; libs = nativeLibraries;
2738         if (libs == null) {
2739             synchronized (loadedLibraryNames) {
2740                 libs = nativeLibraries;
2741                 if (libs == null) {
2742                     libs = nativeLibraries = new ConcurrentHashMap&lt;&gt;();
2743                 }
2744             }
2745         }
2746         return libs;
2747     }
2748 
2749     // -- Assertion management --
2750 
2751     final Object assertionLock;
2752 
2753     // The default toggle for assertion checking.
2754     // @GuardedBy(&quot;assertionLock&quot;)
2755     private boolean defaultAssertionStatus = false;
2756 
2757     // Maps String packageName to Boolean package default assertion status Note
2758     // that the default package is placed under a null map key.  If this field
2759     // is null then we are delegating assertion status queries to the VM, i.e.,
2760     // none of this ClassLoader&#39;s assertion status modification methods have
2761     // been invoked.
2762     // @GuardedBy(&quot;assertionLock&quot;)
2763     private Map&lt;String, Boolean&gt; packageAssertionStatus = null;
2764 
2765     // Maps String fullyQualifiedClassName to Boolean assertionStatus If this
2766     // field is null then we are delegating assertion status queries to the VM,
2767     // i.e., none of this ClassLoader&#39;s assertion status modification methods
2768     // have been invoked.
2769     // @GuardedBy(&quot;assertionLock&quot;)
2770     Map&lt;String, Boolean&gt; classAssertionStatus = null;
2771 
2772     /**
2773      * Sets the default assertion status for this class loader.  This setting
2774      * determines whether classes loaded by this class loader and initialized
2775      * in the future will have assertions enabled or disabled by default.
2776      * This setting may be overridden on a per-package or per-class basis by
2777      * invoking {@link #setPackageAssertionStatus(String, boolean)} or {@link
2778      * #setClassAssertionStatus(String, boolean)}.
2779      *
2780      * @param  enabled
2781      *         {@code true} if classes loaded by this class loader will
2782      *         henceforth have assertions enabled by default, {@code false}
2783      *         if they will have assertions disabled by default.
2784      *
2785      * @since  1.4
2786      */
2787     public void setDefaultAssertionStatus(boolean enabled) {
2788         synchronized (assertionLock) {
2789             if (classAssertionStatus == null)
2790                 initializeJavaAssertionMaps();
2791 
2792             defaultAssertionStatus = enabled;
2793         }
2794     }
2795 
2796     /**
2797      * Sets the package default assertion status for the named package.  The
2798      * package default assertion status determines the assertion status for
2799      * classes initialized in the future that belong to the named package or
2800      * any of its &quot;subpackages&quot;.
2801      *
2802      * &lt;p&gt; A subpackage of a package named p is any package whose name begins
2803      * with &quot;{@code p.}&quot;.  For example, {@code javax.swing.text} is a
2804      * subpackage of {@code javax.swing}, and both {@code java.util} and
2805      * {@code java.lang.reflect} are subpackages of {@code java}.
2806      *
2807      * &lt;p&gt; In the event that multiple package defaults apply to a given class,
2808      * the package default pertaining to the most specific package takes
2809      * precedence over the others.  For example, if {@code javax.lang} and
2810      * {@code javax.lang.reflect} both have package defaults associated with
2811      * them, the latter package default applies to classes in
2812      * {@code javax.lang.reflect}.
2813      *
2814      * &lt;p&gt; Package defaults take precedence over the class loader&#39;s default
2815      * assertion status, and may be overridden on a per-class basis by invoking
2816      * {@link #setClassAssertionStatus(String, boolean)}.  &lt;/p&gt;
2817      *
2818      * @param  packageName
2819      *         The name of the package whose package default assertion status
2820      *         is to be set. A {@code null} value indicates the unnamed
2821      *         package that is &quot;current&quot;
2822      *         (see section 7.4.2 of
2823      *         &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.)
2824      *
2825      * @param  enabled
2826      *         {@code true} if classes loaded by this classloader and
2827      *         belonging to the named package or any of its subpackages will
2828      *         have assertions enabled by default, {@code false} if they will
2829      *         have assertions disabled by default.
2830      *
2831      * @since  1.4
2832      */
2833     public void setPackageAssertionStatus(String packageName,
2834                                           boolean enabled) {
2835         synchronized (assertionLock) {
2836             if (packageAssertionStatus == null)
2837                 initializeJavaAssertionMaps();
2838 
2839             packageAssertionStatus.put(packageName, enabled);
2840         }
2841     }
2842 
2843     /**
2844      * Sets the desired assertion status for the named top-level class in this
2845      * class loader and any nested classes contained therein.  This setting
2846      * takes precedence over the class loader&#39;s default assertion status, and
2847      * over any applicable per-package default.  This method has no effect if
2848      * the named class has already been initialized.  (Once a class is
2849      * initialized, its assertion status cannot change.)
2850      *
2851      * &lt;p&gt; If the named class is not a top-level class, this invocation will
2852      * have no effect on the actual assertion status of any class. &lt;/p&gt;
2853      *
2854      * @param  className
2855      *         The fully qualified class name of the top-level class whose
2856      *         assertion status is to be set.
2857      *
2858      * @param  enabled
2859      *         {@code true} if the named class is to have assertions
2860      *         enabled when (and if) it is initialized, {@code false} if the
2861      *         class is to have assertions disabled.
2862      *
2863      * @since  1.4
2864      */
2865     public void setClassAssertionStatus(String className, boolean enabled) {
2866         synchronized (assertionLock) {
2867             if (classAssertionStatus == null)
2868                 initializeJavaAssertionMaps();
2869 
2870             classAssertionStatus.put(className, enabled);
2871         }
2872     }
2873 
2874     /**
2875      * Sets the default assertion status for this class loader to
2876      * {@code false} and discards any package defaults or class assertion
2877      * status settings associated with the class loader.  This method is
2878      * provided so that class loaders can be made to ignore any command line or
2879      * persistent assertion status settings and &quot;start with a clean slate.&quot;
2880      *
2881      * @since  1.4
2882      */
2883     public void clearAssertionStatus() {
2884         /*
2885          * Whether or not &quot;Java assertion maps&quot; are initialized, set
2886          * them to empty maps, effectively ignoring any present settings.
2887          */
2888         synchronized (assertionLock) {
2889             classAssertionStatus = new HashMap&lt;&gt;();
2890             packageAssertionStatus = new HashMap&lt;&gt;();
2891             defaultAssertionStatus = false;
2892         }
2893     }
2894 
2895     /**
2896      * Returns the assertion status that would be assigned to the specified
2897      * class if it were to be initialized at the time this method is invoked.
2898      * If the named class has had its assertion status set, the most recent
2899      * setting will be returned; otherwise, if any package default assertion
2900      * status pertains to this class, the most recent setting for the most
2901      * specific pertinent package default assertion status is returned;
2902      * otherwise, this class loader&#39;s default assertion status is returned.
2903      * &lt;/p&gt;
2904      *
2905      * @param  className
2906      *         The fully qualified class name of the class whose desired
2907      *         assertion status is being queried.
2908      *
2909      * @return  The desired assertion status of the specified class.
2910      *
2911      * @see  #setClassAssertionStatus(String, boolean)
2912      * @see  #setPackageAssertionStatus(String, boolean)
2913      * @see  #setDefaultAssertionStatus(boolean)
2914      *
2915      * @since  1.4
2916      */
2917     boolean desiredAssertionStatus(String className) {
2918         synchronized (assertionLock) {
2919             // assert classAssertionStatus   != null;
2920             // assert packageAssertionStatus != null;
2921 
2922             // Check for a class entry
2923             Boolean result = classAssertionStatus.get(className);
2924             if (result != null)
2925                 return result.booleanValue();
2926 
2927             // Check for most specific package entry
2928             int dotIndex = className.lastIndexOf(&#39;.&#39;);
2929             if (dotIndex &lt; 0) { // default package
2930                 result = packageAssertionStatus.get(null);
2931                 if (result != null)
2932                     return result.booleanValue();
2933             }
2934             while(dotIndex &gt; 0) {
2935                 className = className.substring(0, dotIndex);
2936                 result = packageAssertionStatus.get(className);
2937                 if (result != null)
2938                     return result.booleanValue();
2939                 dotIndex = className.lastIndexOf(&#39;.&#39;, dotIndex-1);
2940             }
2941 
2942             // Return the classloader default
2943             return defaultAssertionStatus;
2944         }
2945     }
2946 
2947     // Set up the assertions with information provided by the VM.
2948     // Note: Should only be called inside a synchronized block
2949     private void initializeJavaAssertionMaps() {
2950         // assert Thread.holdsLock(assertionLock);
2951 
2952         classAssertionStatus = new HashMap&lt;&gt;();
2953         packageAssertionStatus = new HashMap&lt;&gt;();
2954         AssertionStatusDirectives directives = retrieveDirectives();
2955 
2956         for(int i = 0; i &lt; directives.classes.length; i++)
2957             classAssertionStatus.put(directives.classes[i],
2958                                      directives.classEnabled[i]);
2959 
2960         for(int i = 0; i &lt; directives.packages.length; i++)
2961             packageAssertionStatus.put(directives.packages[i],
2962                                        directives.packageEnabled[i]);
2963 
2964         defaultAssertionStatus = directives.deflt;
2965     }
2966 
2967     // Retrieves the assertion directives from the VM.
2968     private static native AssertionStatusDirectives retrieveDirectives();
2969 
2970 
2971     // -- Misc --
2972 
2973     /**
2974      * Returns the ConcurrentHashMap used as a storage for ClassLoaderValue(s)
2975      * associated with this ClassLoader, creating it if it doesn&#39;t already exist.
2976      */
2977     ConcurrentHashMap&lt;?, ?&gt; createOrGetClassLoaderValueMap() {
2978         ConcurrentHashMap&lt;?, ?&gt; map = classLoaderValueMap;
2979         if (map == null) {
2980             map = new ConcurrentHashMap&lt;&gt;();
2981             boolean set = trySetObjectField(&quot;classLoaderValueMap&quot;, map);
2982             if (!set) {
2983                 // beaten by someone else
2984                 map = classLoaderValueMap;
2985             }
2986         }
2987         return map;
2988     }
2989 
2990     // the storage for ClassLoaderValue(s) associated with this ClassLoader
2991     private volatile ConcurrentHashMap&lt;?, ?&gt; classLoaderValueMap;
2992 
2993     /**
2994      * Attempts to atomically set a volatile field in this object. Returns
2995      * {@code true} if not beaten by another thread. Avoids the use of
2996      * AtomicReferenceFieldUpdater in this class.
2997      */
2998     private boolean trySetObjectField(String name, Object obj) {
2999         Unsafe unsafe = Unsafe.getUnsafe();
3000         Class&lt;?&gt; k = ClassLoader.class;
3001         long offset;
3002         offset = unsafe.objectFieldOffset(k, name);
3003         return unsafe.compareAndSetReference(this, offset, null, obj);
3004     }
3005 }
3006 
3007 /*
3008  * A utility class that will enumerate over an array of enumerations.
3009  */
3010 final class CompoundEnumeration&lt;E&gt; implements Enumeration&lt;E&gt; {
3011     private final Enumeration&lt;E&gt;[] enums;
3012     private int index;
3013 
3014     public CompoundEnumeration(Enumeration&lt;E&gt;[] enums) {
3015         this.enums = enums;
3016     }
3017 
3018     private boolean next() {
3019         while (index &lt; enums.length) {
3020             if (enums[index] != null &amp;&amp; enums[index].hasMoreElements()) {
3021                 return true;
3022             }
3023             index++;
3024         }
3025         return false;
3026     }
3027 
3028     public boolean hasMoreElements() {
3029         return next();
3030     }
3031 
3032     public E nextElement() {
3033         if (!next()) {
3034             throw new NoSuchElementException();
3035         }
3036         return enums[index].nextElement();
3037     }
3038 }
    </pre>
  </body>
</html>
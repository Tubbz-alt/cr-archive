diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeAllocationScope.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeAllocationScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeAllocationScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeAllocationScope.java
@@ -24,12 +24,12 @@
  *
  */
 
 package jdk.incubator.foreign;
 
-import jdk.internal.foreign.BoundedAllocationScope;
-import jdk.internal.foreign.UnboundedAllocationScope;
+import jdk.internal.foreign.AbstractAllocationScope;
+import jdk.internal.foreign.AbstractMemorySegmentImpl;
 
 import java.lang.invoke.VarHandle;
 import java.util.OptionalLong;
 
 /**
@@ -37,19 +37,33 @@
  * by off-heap memory. Allocation scopes can be either <em>bounded</em> or <em>unbounded</em>, depending on whether the size
  * of the allocation scope is known statically. If an application knows before-hand how much memory it needs to allocate the values it needs,
  * using a <em>bounded</em> allocation scope will typically provide better performances than independently allocating the memory
  * for each value (e.g. using {@link MemorySegment#allocateNative(long)}), or using an <em>unbounded</em> allocation scope.
  * For this reason, using a bounded allocation scope is recommended in cases where programs might need to emulate native stack allocation.
+ * <p>
+ * Allocation scopes are thread-confined (see {@link #ownerThread()}; as such, the resulting {@code MemoryAddress} instances
+ * returned by the allocation scope will be backed by memory segments confined by the same owner thread as the allocation scope.
+ * <p>
+ * To allow for more usability, it is possible for an allocation scope to claim ownership of an existing memory segment
+ * (see {@link #claim(MemorySegment)}). This might be useful to allow one or more segments which were independently
+ * created to share the same life-cycle as a given allocation scope - which in turns enables client to group all memory
+ * allocation and usage under a single <em>try-with-resources block</em>.
  */
 public abstract class NativeAllocationScope implements AutoCloseable {
 
     /**
      * If this allocation scope is bounded, returns the size, in bytes, of this allocation scope.
      * @return the size, in bytes, of this allocation scope (if available).
      */
     public abstract OptionalLong byteSize();
 
+    /**
+     * The thread owning this allocation scope.
+     * @return the thread owning this allocation scope.
+     */
+    public abstract Thread ownerThread();
+
     /**
      * Returns the number of allocated bytes in this allocation scope.
      * @return the number of allocated bytes in this allocation scope.
      */
     public abstract long allocatedBytes();
@@ -224,10 +238,29 @@
      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
      * {@code limit() - size() < bytesSize}.
      */
     public abstract MemoryAddress allocate(long bytesSize, long bytesAlignment);
 
+    /**
+     * Claim ownership of a given segment. The input segment must be closeable - that is, it must feature
+     * the {@link MemorySegment#CLOSE} access mode. As a side-effect, the input segment will be marked
+     * as <em>not alive</em>, and a new segment will be returned.
+     * <p>
+     * The returned segment will feature only {@link MemorySegment#READ} and
+     * {@link MemorySegment#WRITE} access modes (assuming these were available in the original segment). As such
+     * the resulting segment cannot be closed directly using {@link MemorySegment#close()} - but it will be closed
+     * indirectly when this allocation scope is closed.
+     * @param segment the segment whose ownership will be claimed by this allocation scope.
+     * @return a new, non closeable memory segment, backed by the same underlying region as {@code segment},
+     * but whose life-cycle is tied to that of this allocation scope.
+     * @throws IllegalStateException if {@code segment} is not <em>alive</em> (see {@link MemorySegment#isAlive()}).
+     * @throws NullPointerException if {@code segment == null}
+     * @throws IllegalArgumentException if {@code segment.ownerThread() != this.ownerThread()}, or if {@code segment}
+     * does not feature the {@link MemorySegment#CLOSE} access mode.
+     */
+    public abstract MemorySegment claim(MemorySegment segment);
+
     /**
      * Close this allocation scope; calling this method will render any address obtained through this allocation scope
      * unusable and might release any backing memory resources associated with this allocation scope.
      */
     @Override
@@ -237,16 +270,16 @@
      * Creates a new bounded allocation scope, backed by off-heap memory.
      * @param size the size of the allocation scope.
      * @return a new bounded allocation scope, with given size (in bytes).
      */
     public static NativeAllocationScope boundedScope(long size) {
-        return new BoundedAllocationScope(size);
+        return new AbstractAllocationScope.BoundedAllocationScope(size);
     }
 
     /**
      * Creates a new unbounded allocation scope, backed by off-heap memory.
      * @return a new unbounded allocation scope.
      */
     public static NativeAllocationScope unboundedScope() {
-        return new UnboundedAllocationScope();
+        return new AbstractAllocationScope.UnboundedAllocationScope();
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractAllocationScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractAllocationScope.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractAllocationScope.java
@@ -0,0 +1,154 @@
+package jdk.internal.foreign;
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeAllocationScope;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.OptionalLong;
+
+public abstract class AbstractAllocationScope extends NativeAllocationScope {
+
+    private final List<MemorySegment> segments = new ArrayList<>();
+    private final Thread ownerThread;
+
+    private static final int SCOPE_MASK = MemorySegment.READ | MemorySegment.WRITE; // no terminal operations allowed
+
+    AbstractAllocationScope(Thread ownerThread) {
+        this.ownerThread = ownerThread;
+    }
+
+    @Override
+    public Thread ownerThread() {
+        return ownerThread;
+    }
+
+    @Override
+    public void close() {
+        for (MemorySegment segment : segments) {
+            try {
+                segment.close();
+            } catch (IllegalStateException ex) {
+                //already closed - skip
+            }
+        }
+    }
+
+    void checkOwnerThread() {
+        if (Thread.currentThread() != ownerThread()) {
+            throw new IllegalStateException("Attempt to access scope from different thread");
+        }
+    }
+
+    MemorySegment newSegment(long size, long align) {
+        MemorySegment segment = MemorySegment.allocateNative(size, align);
+        segments.add(segment);
+        return segment;
+    }
+
+    MemorySegment newSegment(long size) {
+        return newSegment(size, size);
+    }
+
+    @Override
+    public MemorySegment claim(MemorySegment segment) {
+        Objects.requireNonNull(segment);
+        if (segment.ownerThread() != ownerThread()) {
+            throw new IllegalArgumentException("Cannot register segment owned by a different thread");
+        } else if (!segment.hasAccessModes(MemorySegment.CLOSE)) {
+            throw new IllegalArgumentException("Cannot register a non-closeable segment");
+        }
+        MemorySegment attachedSegment = ((AbstractMemorySegmentImpl)segment)
+                .dupAndClose(ownerThread());
+        segments.add(attachedSegment);
+        return attachedSegment
+                .withAccessModes(segment.accessModes() & SCOPE_MASK);
+    }
+
+    public static class UnboundedAllocationScope extends AbstractAllocationScope {
+
+        private static final long BLOCK_SIZE = 4 * 1024;
+        private static final long MAX_ALLOC_SIZE = BLOCK_SIZE / 2;
+
+        private MemorySegment segment;
+        private long sp = 0L;
+        private long size = 0L;
+
+        @Override
+        public OptionalLong byteSize() {
+            return OptionalLong.empty();
+        }
+
+        @Override
+        public long allocatedBytes() {
+            return size;
+        }
+
+        public UnboundedAllocationScope() {
+            super(Thread.currentThread());
+            this.segment = newSegment(BLOCK_SIZE);
+        }
+
+        @Override
+        public MemoryAddress allocate(long bytesSize, long bytesAlignment) {
+            checkOwnerThread();
+            if (bytesSize > MAX_ALLOC_SIZE) {
+                MemorySegment segment = newSegment(bytesSize, bytesAlignment);
+                return segment.withAccessModes(SCOPE_MASK)
+                        .baseAddress();
+            }
+            for (int i = 0; i < 2; i++) {
+                long min = ((MemoryAddressImpl) segment.baseAddress()).unsafeGetOffset();
+                long start = Utils.alignUp(min + sp, bytesAlignment) - min;
+                try {
+                    MemorySegment slice = segment.asSlice(start, bytesSize)
+                            .withAccessModes(SCOPE_MASK);
+                    sp = start + bytesSize;
+                    size += Utils.alignUp(bytesSize, bytesAlignment);
+                    return slice.baseAddress();
+                } catch (IndexOutOfBoundsException ex) {
+                    sp = 0L;
+                    segment = newSegment(BLOCK_SIZE, 1L);
+                }
+            }
+            throw new AssertionError("Cannot get here!");
+        }
+    }
+
+    public static class BoundedAllocationScope extends AbstractAllocationScope {
+        private final MemorySegment segment;
+        private long sp = 0L;
+
+        @Override
+        public OptionalLong byteSize() {
+            return OptionalLong.of(segment.byteSize());
+        }
+
+        @Override
+        public long allocatedBytes() {
+            return sp;
+        }
+
+        public BoundedAllocationScope(long size) {
+            super(Thread.currentThread());
+            this.segment = newSegment(size, 1);
+        }
+
+        @Override
+        public MemoryAddress allocate(long bytesSize, long bytesAlignment) {
+            checkOwnerThread();
+            long min = ((MemoryAddressImpl)segment.baseAddress()).unsafeGetOffset();
+            long start = Utils.alignUp(min + sp, bytesAlignment) - min;
+            try {
+                MemorySegment slice = segment.asSlice(start, bytesSize)
+                        .withAccessModes(SCOPE_MASK);
+                sp = start + bytesSize;
+                return slice.baseAddress();
+            } catch (IndexOutOfBoundsException ex) {
+                throw new OutOfMemoryError("Not enough space left to allocate");
+            }
+        }
+    }
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -236,16 +236,20 @@
             throw unsupportedAccessMode(HANDOFF);
         }
         if (scope.ownerThread() == newOwner) {
             throw new IllegalArgumentException("Segment already owned by thread: " + newOwner);
         } else {
-            try {
-                return dup(0L, length, mask, scope.dup(newOwner));
-            } finally {
-                //flush read/writes to segment memory before returning the new segment
-                VarHandle.fullFence();
-            }
+            return dupAndClose(newOwner);
+        }
+    }
+
+    public MemorySegment dupAndClose(Thread newOwner) {
+        try {
+            return dup(0L, length, mask, scope.dup(newOwner));
+        } finally {
+            //flush read/writes to segment memory before returning the new segment
+            VarHandle.fullFence();
         }
     }
 
     @Override
     public final void close() {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/BoundedAllocationScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/BoundedAllocationScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/BoundedAllocationScope.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package jdk.internal.foreign;
-
-import jdk.incubator.foreign.NativeAllocationScope;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemorySegment;
-
-import java.util.OptionalLong;
-
-public class BoundedAllocationScope extends NativeAllocationScope {
-    private final MemorySegment segment;
-    private long sp = 0L;
-
-    @Override
-    public OptionalLong byteSize() {
-        return OptionalLong.of(segment.byteSize());
-    }
-
-    @Override
-    public long allocatedBytes() {
-        return sp;
-    }
-
-    public BoundedAllocationScope(long size) {
-        this.segment = MemorySegment.allocateNative(size);
-    }
-
-    @Override
-    public MemoryAddress allocate(long bytesSize, long bytesAlignment) {
-        long min = ((MemoryAddressImpl)segment.baseAddress()).unsafeGetOffset();
-        long start = Utils.alignUp(min + sp, bytesAlignment) - min;
-        try {
-            MemorySegment slice = segment.asSlice(start, bytesSize)
-                    .withAccessModes(MemorySegment.READ | MemorySegment.WRITE | MemorySegment.ACQUIRE);
-            sp = start + bytesSize;
-            return slice.baseAddress();
-        } catch (IndexOutOfBoundsException ex) {
-            throw new OutOfMemoryError("Not enough space left to allocate");
-        }
-    }
-
-    @Override
-    public void close() {
-        segment.close();
-    }
-}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/UnboundedAllocationScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/UnboundedAllocationScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/UnboundedAllocationScope.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package jdk.internal.foreign;
-
-import jdk.incubator.foreign.NativeAllocationScope;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemorySegment;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.OptionalLong;
-import java.util.function.LongFunction;
-
-public class UnboundedAllocationScope extends NativeAllocationScope {
-
-    private static final long BLOCK_SIZE = 4 * 1024;
-    private static final long MAX_ALLOC_SIZE = BLOCK_SIZE / 2;
-
-    private final List<MemorySegment> usedSegments = new ArrayList<>();
-    private MemorySegment segment;
-    private long sp = 0L;
-    private long size = 0L;
-
-    @Override
-    public OptionalLong byteSize() {
-        return OptionalLong.empty();
-    }
-
-    @Override
-    public long allocatedBytes() {
-        return size;
-    }
-
-    public UnboundedAllocationScope() {
-        this.segment = MemorySegment.allocateNative(BLOCK_SIZE);
-    }
-
-    @Override
-    public MemoryAddress allocate(long bytesSize, long bytesAlignment) {
-        if (bytesSize > MAX_ALLOC_SIZE) {
-            MemorySegment segment = MemorySegment.allocateNative(bytesSize, bytesAlignment);
-            usedSegments.add(segment);
-            return segment.withAccessModes(MemorySegment.READ | MemorySegment.WRITE | MemorySegment.ACQUIRE)
-                    .baseAddress();
-        }
-        for (int i = 0; i < 2; i++) {
-            long min = ((MemoryAddressImpl) segment.baseAddress()).unsafeGetOffset();
-            long start = Utils.alignUp(min + sp, bytesAlignment) - min;
-            try {
-                MemorySegment slice = segment.asSlice(start, bytesSize)
-                        .withAccessModes(MemorySegment.READ | MemorySegment.WRITE | MemorySegment.ACQUIRE);
-                sp = start + bytesSize;
-                size += Utils.alignUp(bytesSize, bytesAlignment);
-                return slice.baseAddress();
-            } catch (IndexOutOfBoundsException ex) {
-                sp = 0L;
-                usedSegments.add(segment);
-                segment = MemorySegment.allocateNative(BLOCK_SIZE);
-            }
-        }
-        throw new AssertionError("Cannot get here!");
-    }
-
-    @Override
-    public void close() {
-        segment.close();
-        usedSegments.forEach(MemorySegment::close);
-    }
-}
diff a/test/jdk/java/foreign/TestAllocationScope.java b/test/jdk/java/foreign/TestAllocationScope.java
--- a/test/jdk/java/foreign/TestAllocationScope.java
+++ b/test/jdk/java/foreign/TestAllocationScope.java
@@ -25,10 +25,11 @@
 /*
  * @test
  * @run testng TestAllocationScope
  */
 
+import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.NativeAllocationScope;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryAddress;
@@ -36,12 +37,15 @@
 import org.testng.annotations.*;
 
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Function;
 
+import static jdk.incubator.foreign.MemorySegment.CLOSE;
+import static jdk.incubator.foreign.MemorySegment.HANDOFF;
 import static org.testng.Assert.*;
 
 public class TestAllocationScope {
 
     final static int ELEMS = 128;
@@ -101,10 +105,87 @@
                 assertTrue(address.segment().baseAddress().toRawLongValue() % i == 0);
             }
         }
     }
 
+    @Test
+    public void testAttachClose() {
+        MemorySegment s1 = MemorySegment.ofArray(new byte[1]);
+        MemorySegment s2 = MemorySegment.ofArray(new byte[1]);
+        MemorySegment s3 = MemorySegment.ofArray(new byte[1]);
+        assertTrue(s1.isAlive());
+        assertTrue(s2.isAlive());
+        assertTrue(s3.isAlive());
+        try (NativeAllocationScope scope = NativeAllocationScope.boundedScope(10)) {
+            MemorySegment ss1 = scope.claim(s1);
+            assertFalse(s1.isAlive());
+            assertTrue(ss1.isAlive());
+            s1 = ss1;
+            MemorySegment ss2 = scope.claim(s2);
+            assertFalse(s2.isAlive());
+            assertTrue(ss2.isAlive());
+            s2 = ss2;
+            MemorySegment ss3 = scope.claim(s3);
+            assertFalse(s3.isAlive());
+            assertTrue(ss3.isAlive());
+            s3 = ss3;
+        }
+        assertFalse(s1.isAlive());
+        assertFalse(s2.isAlive());
+        assertFalse(s3.isAlive());
+    }
+
+    @Test
+    public void testNoTerminalOps() {
+        try (NativeAllocationScope scope = NativeAllocationScope.boundedScope(10)) {
+            MemorySegment s1 = MemorySegment.ofArray(new byte[1]);
+            MemorySegment attached = scope.claim(s1);
+            int[] terminalOps = {CLOSE, HANDOFF};
+            for (int mode : terminalOps) {
+                if (attached.hasAccessModes(mode)) {
+                    fail();
+                }
+            }
+        }
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testNoReattach() {
+        MemorySegment s1 = MemorySegment.ofArray(new byte[1]);
+        NativeAllocationScope scope1 = NativeAllocationScope.boundedScope(10);
+        NativeAllocationScope scope2 = NativeAllocationScope.boundedScope(10);
+        scope2.claim(scope1.claim(s1));
+    }
+
+    @Test(expectedExceptions = NullPointerException.class)
+    public void testNullClaim() {
+        NativeAllocationScope.boundedScope(10).claim(null);
+    }
+
+    @Test(expectedExceptions = IllegalStateException.class)
+    public void testNotAliveClaim() {
+        MemorySegment segment = MemorySegment.ofArray(new byte[1]);
+        segment.close();
+        NativeAllocationScope.boundedScope(10).claim(segment);
+    }
+
+    @Test
+    public void testNoClaimFromWrongThread() throws InterruptedException {
+        MemorySegment s = MemorySegment.ofArray(new byte[1]);
+        AtomicBoolean failed = new AtomicBoolean(false);
+        Thread t = new Thread(() -> {
+            try {
+                NativeAllocationScope.boundedScope(10).claim(s);
+            } catch (IllegalArgumentException ex) {
+                failed.set(true);
+            }
+        });
+        t.start();
+        t.join();
+        assertTrue(failed.get());
+    }
+
     @DataProvider(name = "allocationScopes")
     static Object[][] allocationScopes() {
         return new Object[][] {
                 { (byte)42, (ScopeFactory) NativeAllocationScope::boundedScope, MemoryLayouts.BITS_8_BE, byte.class,
                         (AllocationFunction<Byte>) NativeAllocationScope::allocate,

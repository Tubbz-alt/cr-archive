<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeAllocationScope.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeAllocationScope.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 
 27 package jdk.incubator.foreign;
 28 
<span class="line-modified"> 29 import jdk.internal.foreign.BoundedAllocationScope;</span>
<span class="line-modified"> 30 import jdk.internal.foreign.UnboundedAllocationScope;</span>
 31 
 32 import java.lang.invoke.VarHandle;
 33 import java.util.OptionalLong;
 34 
 35 /**
 36  * This class provides a scope of given size, within which several allocations can be performed. An allocation scope is backed
 37  * by off-heap memory. Allocation scopes can be either &lt;em&gt;bounded&lt;/em&gt; or &lt;em&gt;unbounded&lt;/em&gt;, depending on whether the size
 38  * of the allocation scope is known statically. If an application knows before-hand how much memory it needs to allocate the values it needs,
 39  * using a &lt;em&gt;bounded&lt;/em&gt; allocation scope will typically provide better performances than independently allocating the memory
 40  * for each value (e.g. using {@link MemorySegment#allocateNative(long)}), or using an &lt;em&gt;unbounded&lt;/em&gt; allocation scope.
 41  * For this reason, using a bounded allocation scope is recommended in cases where programs might need to emulate native stack allocation.








 42  */
 43 public abstract class NativeAllocationScope implements AutoCloseable {
 44 
 45     /**
 46      * If this allocation scope is bounded, returns the size, in bytes, of this allocation scope.
 47      * @return the size, in bytes, of this allocation scope (if available).
 48      */
 49     public abstract OptionalLong byteSize();
 50 






 51     /**
 52      * Returns the number of allocated bytes in this allocation scope.
 53      * @return the number of allocated bytes in this allocation scope.
 54      */
 55     public abstract long allocatedBytes();
 56 
 57     /**
 58      * Allocate a block of memory in this allocation scope with given layout and initialize it with given byte value.
 59      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
 60      * address must conform to the layout alignment constraints.
 61      * @param layout the layout of the block of memory to be allocated.
 62      * @param value the value to be set on the newly allocated memory block.
 63      * @return an address which points to the newly allocated memory block.
 64      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
 65      * {@code limit() - size() &lt; layout.byteSize()}.
 66      * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a byte value.
 67      */
 68     public MemoryAddress allocate(MemoryLayout layout, byte value) {
 69         VarHandle handle = layout.varHandle(byte.class);
 70         MemoryAddress addr = allocate(layout);
</pre>
<hr />
<pre>
209      * @return an address which points to the newly allocated memory block.
210      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
211      * {@code limit() - size() &lt; bytesSize}.
212      */
213     public MemoryAddress allocate(long bytesSize) {
214         return allocate(bytesSize, bytesSize);
215     }
216 
217     /**
218      * Allocate a block of memory in this allocation scope with given size and alignment constraint.
219      * The address returned by this method is associated with a segment which cannot be closed. Moreover,
220      * the returned address must be aligned to {@code alignment}.
221      * @param bytesSize the size (in bytes) of the block of memory to be allocated.
222      * @param bytesAlignment the alignment (in bytes) of the block of memory to be allocated.
223      * @return an address which points to the newly allocated memory block.
224      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
225      * {@code limit() - size() &lt; bytesSize}.
226      */
227     public abstract MemoryAddress allocate(long bytesSize, long bytesAlignment);
228 



















229     /**
230      * Close this allocation scope; calling this method will render any address obtained through this allocation scope
231      * unusable and might release any backing memory resources associated with this allocation scope.
232      */
233     @Override
234     public abstract void close();
235 
236     /**
237      * Creates a new bounded allocation scope, backed by off-heap memory.
238      * @param size the size of the allocation scope.
239      * @return a new bounded allocation scope, with given size (in bytes).
240      */
241     public static NativeAllocationScope boundedScope(long size) {
<span class="line-modified">242         return new BoundedAllocationScope(size);</span>
243     }
244 
245     /**
246      * Creates a new unbounded allocation scope, backed by off-heap memory.
247      * @return a new unbounded allocation scope.
248      */
249     public static NativeAllocationScope unboundedScope() {
<span class="line-modified">250         return new UnboundedAllocationScope();</span>
251     }
252 }
</pre>
</td>
<td>
<hr />
<pre>
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 
 27 package jdk.incubator.foreign;
 28 
<span class="line-modified"> 29 import jdk.internal.foreign.AbstractAllocationScope;</span>
<span class="line-modified"> 30 import jdk.internal.foreign.AbstractMemorySegmentImpl;</span>
 31 
 32 import java.lang.invoke.VarHandle;
 33 import java.util.OptionalLong;
 34 
 35 /**
 36  * This class provides a scope of given size, within which several allocations can be performed. An allocation scope is backed
 37  * by off-heap memory. Allocation scopes can be either &lt;em&gt;bounded&lt;/em&gt; or &lt;em&gt;unbounded&lt;/em&gt;, depending on whether the size
 38  * of the allocation scope is known statically. If an application knows before-hand how much memory it needs to allocate the values it needs,
 39  * using a &lt;em&gt;bounded&lt;/em&gt; allocation scope will typically provide better performances than independently allocating the memory
 40  * for each value (e.g. using {@link MemorySegment#allocateNative(long)}), or using an &lt;em&gt;unbounded&lt;/em&gt; allocation scope.
 41  * For this reason, using a bounded allocation scope is recommended in cases where programs might need to emulate native stack allocation.
<span class="line-added"> 42  * &lt;p&gt;</span>
<span class="line-added"> 43  * Allocation scopes are thread-confined (see {@link #ownerThread()}; as such, the resulting {@code MemoryAddress} instances</span>
<span class="line-added"> 44  * returned by the allocation scope will be backed by memory segments confined by the same owner thread as the allocation scope.</span>
<span class="line-added"> 45  * &lt;p&gt;</span>
<span class="line-added"> 46  * To allow for more usability, it is possible for an allocation scope to claim ownership of an existing memory segment</span>
<span class="line-added"> 47  * (see {@link #claim(MemorySegment)}). This might be useful to allow one or more segments which were independently</span>
<span class="line-added"> 48  * created to share the same life-cycle as a given allocation scope - which in turns enables client to group all memory</span>
<span class="line-added"> 49  * allocation and usage under a single &lt;em&gt;try-with-resources block&lt;/em&gt;.</span>
 50  */
 51 public abstract class NativeAllocationScope implements AutoCloseable {
 52 
 53     /**
 54      * If this allocation scope is bounded, returns the size, in bytes, of this allocation scope.
 55      * @return the size, in bytes, of this allocation scope (if available).
 56      */
 57     public abstract OptionalLong byteSize();
 58 
<span class="line-added"> 59     /**</span>
<span class="line-added"> 60      * The thread owning this allocation scope.</span>
<span class="line-added"> 61      * @return the thread owning this allocation scope.</span>
<span class="line-added"> 62      */</span>
<span class="line-added"> 63     public abstract Thread ownerThread();</span>
<span class="line-added"> 64 </span>
 65     /**
 66      * Returns the number of allocated bytes in this allocation scope.
 67      * @return the number of allocated bytes in this allocation scope.
 68      */
 69     public abstract long allocatedBytes();
 70 
 71     /**
 72      * Allocate a block of memory in this allocation scope with given layout and initialize it with given byte value.
 73      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
 74      * address must conform to the layout alignment constraints.
 75      * @param layout the layout of the block of memory to be allocated.
 76      * @param value the value to be set on the newly allocated memory block.
 77      * @return an address which points to the newly allocated memory block.
 78      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
 79      * {@code limit() - size() &lt; layout.byteSize()}.
 80      * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a byte value.
 81      */
 82     public MemoryAddress allocate(MemoryLayout layout, byte value) {
 83         VarHandle handle = layout.varHandle(byte.class);
 84         MemoryAddress addr = allocate(layout);
</pre>
<hr />
<pre>
223      * @return an address which points to the newly allocated memory block.
224      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
225      * {@code limit() - size() &lt; bytesSize}.
226      */
227     public MemoryAddress allocate(long bytesSize) {
228         return allocate(bytesSize, bytesSize);
229     }
230 
231     /**
232      * Allocate a block of memory in this allocation scope with given size and alignment constraint.
233      * The address returned by this method is associated with a segment which cannot be closed. Moreover,
234      * the returned address must be aligned to {@code alignment}.
235      * @param bytesSize the size (in bytes) of the block of memory to be allocated.
236      * @param bytesAlignment the alignment (in bytes) of the block of memory to be allocated.
237      * @return an address which points to the newly allocated memory block.
238      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
239      * {@code limit() - size() &lt; bytesSize}.
240      */
241     public abstract MemoryAddress allocate(long bytesSize, long bytesAlignment);
242 
<span class="line-added">243     /**</span>
<span class="line-added">244      * Claim ownership of a given segment. The input segment must be closeable - that is, it must feature</span>
<span class="line-added">245      * the {@link MemorySegment#CLOSE} access mode. As a side-effect, the input segment will be marked</span>
<span class="line-added">246      * as &lt;em&gt;not alive&lt;/em&gt;, and a new segment will be returned.</span>
<span class="line-added">247      * &lt;p&gt;</span>
<span class="line-added">248      * The returned segment will feature only {@link MemorySegment#READ} and</span>
<span class="line-added">249      * {@link MemorySegment#WRITE} access modes (assuming these were available in the original segment). As such</span>
<span class="line-added">250      * the resulting segment cannot be closed directly using {@link MemorySegment#close()} - but it will be closed</span>
<span class="line-added">251      * indirectly when this allocation scope is closed.</span>
<span class="line-added">252      * @param segment the segment whose ownership will be claimed by this allocation scope.</span>
<span class="line-added">253      * @return a new, non closeable memory segment, backed by the same underlying region as {@code segment},</span>
<span class="line-added">254      * but whose life-cycle is tied to that of this allocation scope.</span>
<span class="line-added">255      * @throws IllegalStateException if {@code segment} is not &lt;em&gt;alive&lt;/em&gt; (see {@link MemorySegment#isAlive()}).</span>
<span class="line-added">256      * @throws NullPointerException if {@code segment == null}</span>
<span class="line-added">257      * @throws IllegalArgumentException if {@code segment.ownerThread() != this.ownerThread()}, or if {@code segment}</span>
<span class="line-added">258      * does not feature the {@link MemorySegment#CLOSE} access mode.</span>
<span class="line-added">259      */</span>
<span class="line-added">260     public abstract MemorySegment claim(MemorySegment segment);</span>
<span class="line-added">261 </span>
262     /**
263      * Close this allocation scope; calling this method will render any address obtained through this allocation scope
264      * unusable and might release any backing memory resources associated with this allocation scope.
265      */
266     @Override
267     public abstract void close();
268 
269     /**
270      * Creates a new bounded allocation scope, backed by off-heap memory.
271      * @param size the size of the allocation scope.
272      * @return a new bounded allocation scope, with given size (in bytes).
273      */
274     public static NativeAllocationScope boundedScope(long size) {
<span class="line-modified">275         return new AbstractAllocationScope.BoundedAllocationScope(size);</span>
276     }
277 
278     /**
279      * Creates a new unbounded allocation scope, backed by off-heap memory.
280      * @return a new unbounded allocation scope.
281      */
282     public static NativeAllocationScope unboundedScope() {
<span class="line-modified">283         return new AbstractAllocationScope.UnboundedAllocationScope();</span>
284     }
285 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
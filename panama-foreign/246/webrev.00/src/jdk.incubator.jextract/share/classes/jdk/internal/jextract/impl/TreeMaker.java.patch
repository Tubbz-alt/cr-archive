diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java
@@ -29,17 +29,21 @@
 import java.nio.ByteOrder;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.ConcurrentModificationException;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.Set;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.jextract.Declaration;
 import jdk.incubator.jextract.Position;
 import jdk.incubator.jextract.Type;
@@ -241,14 +245,18 @@
 
     private static boolean isEnum(Declaration d) {
         return d instanceof Declaration.Scoped && ((Declaration.Scoped)d).kind() == Declaration.Scoped.Kind.ENUM;
     }
 
+    private static boolean isAnonymousStruct(Declaration declaration) {
+        return ((CursorPosition)declaration.pos()).cursor.isAnonymousStruct();
+    }
+
     private List<Declaration> filterNestedDeclarations(List<Declaration> declarations) {
         return declarations.stream()
                 .filter(Objects::nonNull)
-                .filter(d -> isEnum(d) || !d.name().isEmpty() || ((CursorPosition)d.pos()).cursor.isAnonymousStruct())
+                .filter(d -> isEnum(d) || !d.name().isEmpty() || isAnonymousStruct(d))
                 .collect(Collectors.toList());
     }
 
     private Declaration.Typedef createTypedef(Cursor c) {
         Type cursorType = toType(c);
@@ -281,18 +289,42 @@
             }
             return varFactory.make(toPos(c), c.spelling(), type);
         }
     }
 
+    private static void collectNestedBitFields(Set<Declaration> out, Declaration.Scoped anonymousStruct) {
+        for  (Declaration field : anonymousStruct.members()) {
+            if (isAnonymousStruct(field)) {
+                collectNestedBitFields(out, (Declaration.Scoped) field);
+            } else if (field instanceof Declaration.Scoped
+                       && ((Declaration.Scoped) field).kind() == Declaration.Scoped.Kind.BITFIELDS) {
+                out.addAll(((Declaration.Scoped) field).members());
+            }
+        }
+    }
+
+    private static Set<Declaration> nestedBitFields(List<Declaration> members) {
+        Set<Declaration> res = new HashSet<>();
+        for (Declaration member : members) {
+            if (isAnonymousStruct(member)) {
+                collectNestedBitFields(res, (Declaration.Scoped) member);
+            }
+        }
+        return res;
+    }
+
     private List<Declaration> collectBitfields(MemoryLayout layout, List<Declaration> declarations) {
+        Set<String> nestedBitfieldNames = nestedBitFields(declarations).stream()
+                                                                       .map(Declaration::name)
+                                                                       .collect(Collectors.toSet());
         List<Declaration> newDecls = new ArrayList<>();
         for (MemoryLayout e : ((GroupLayout)layout).memberLayouts()) {
             Optional<GroupLayout> contents = Utils.getContents(e);
             if (contents.isPresent()) {
                 List<Declaration.Variable> bfDecls = new ArrayList<>();
                 outer: for (MemoryLayout bitfield : contents.get().memberLayouts()) {
-                    if (bitfield.name().isPresent()) {
+                    if (bitfield.name().isPresent() && !nestedBitfieldNames.contains(bitfield.name().get())) {
                         Iterator<Declaration> declIt = declarations.iterator();
                         while (declIt.hasNext()) {
                             Declaration d = declIt.next();
                             if (d.name().equals(bitfield.name().get())) {
                                 bfDecls.add((Declaration.Variable)d);
@@ -301,11 +333,13 @@
                             }
                         }
                         throw new IllegalStateException("No matching declaration found for bitfield: " + bitfield);
                     }
                 }
-                newDecls.add(Declaration.bitfields(bfDecls.get(0).pos(), "", contents.get(), bfDecls.toArray(new Declaration.Variable[0])));
+                if (!bfDecls.isEmpty()) {
+                    newDecls.add(Declaration.bitfields(bfDecls.get(0).pos(), "", contents.get(), bfDecls.toArray(new Declaration.Variable[0])));
+                }
             }
         }
         newDecls.addAll(declarations);
         return newDecls;
     }

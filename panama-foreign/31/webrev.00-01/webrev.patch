diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
@@ -149,44 +149,40 @@
     /**
      * Obtain the base object (if any) associated with this address. This can be used in conjunction with
      * {@link #getUnsafeOffset(MemoryAddress)} in order to obtain a base/offset addressing coordinate pair
      * to be used with methods like {@link sun.misc.Unsafe#getInt(Object, long)} and the likes.
      * <p>
-     * This method is <em>unsafe</em>. It's use can result in putting the VM in a corrupt state when used incorrectly,
+     * This method is <em>unsafe</em>. Its use can result in putting the VM in a corrupt state when used incorrectly,
      * and is provided solely to cover use-cases that can not otherwise be addressed safely. When used incorrectly, there
-     * are no guarantees made about the behaviour of the program. Particularly, incorrect use is not guaranteed to
-     * result in a VM crash, but might instead silently cause memory to be corrupted.
+     * are no guarantees made about the behaviour of the program. More specifically, incorrect uses of this method might
+     * result in a JVM crash or, worse, might silently result in memory corruption.
      *
      * @param address the address whose base object is to be obtained.
      * @return the base object associated with the address, or {@code null}.
-     * @throws IllegalAccessError if the permission jkd.incubator.foreign.permitUnsafeInterop is not set
+     * @throws IllegalAccessError if the permission jkd.incubator.foreign.restrictedMethods is set to 'deny'
      */
     static Object getUnsafeBase(MemoryAddress address) throws IllegalAccessError {
-        if (!Utils.permitUnsafeInterop) {
-            throw new IllegalAccessError("Can not get unsafe base. Permission is not enabled");
-        }
+        Utils.checkUnsafeAccess("jdk.incubator.foreign.MemoryAddress#getUnsafeBase");
         return ((MemoryAddressImpl)address).unsafeGetBase();
     }
 
     /**
      * Obtain the offset associated with this address. If {@link #getUnsafeBase(MemoryAddress)} returns {@code null} on the passed
      * address, then the offset is to be interpreted as the (absolute) numerical value associated said address.
      * Alternatively, the offset represents the displacement of a field or an array element within the containing
      * base object. This can be used in conjunction with {@link #getUnsafeBase(MemoryAddress)} in order to obtain a base/offset
      * addressing coordinate pair to be used with methods like {@link sun.misc.Unsafe#getInt(Object, long)} and the likes.
      * <p>
-     * This method is <em>unsafe</em>. It's use can result in putting the VM in a corrupt state when used incorrectly,
+     * This method is <em>unsafe</em>. Its use can result in putting the VM in a corrupt state when used incorrectly,
      * and is provided solely to cover use-cases that can not otherwise be addressed safely. When used incorrectly, there
-     * are no guarantees made about the behaviour of the program. Particularly, incorrect use is not guaranteed to
-     * result in a VM crash, but might instead silently cause memory to be corrupted.
+     * are no guarantees made about the behaviour of the program. More specifically, incorrect uses of this method might
+     * result in a JVM crash or, worse, might silently result in memory corruption.
      *
      * @param address the address whose offset is to be obtained.
      * @return the offset associated with the address.
-     * @throws IllegalAccessError if the permission jkd.incubator.foreign.permitUnsafeInterop is not set
+     * @throws IllegalAccessError if the permission jkd.incubator.foreign.restrictedMethods is set to 'deny'
      */
     static long getUnsafeOffset(MemoryAddress address) throws IllegalAccessError {
-        if (!Utils.permitUnsafeInterop) {
-            throw new IllegalAccessError("Can not get unsafe offset. Permission is not enabled");
-        }
+        Utils.checkUnsafeAccess("jdk.incubator.foreign.MemoryAddress#getUnsafeOffset");
         return ((MemoryAddressImpl)address).unsafeGetOffset();
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -26,11 +26,10 @@
 
 package jdk.incubator.foreign;
 
 import java.nio.ByteBuffer;
 
-import jdk.internal.foreign.MemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 
 import java.io.IOException;
 import java.nio.channels.FileChannel;
 import java.nio.file.Path;
@@ -429,28 +428,26 @@
     /**
      * Returns a new native memory segment with given base address and size. The returned segment has its own temporal
      * bounds, and can therefore be closed; closing such a segment does <em>not</em> result in any resource being
      * deallocated.
      * <p>
-     * This method is <em>unsafe</em>. It's use can result in putting the VM in a corrupt state when used incorrectly,
+     * This method is <em>unsafe</em>. Its use can result in putting the VM in a corrupt state when used incorrectly,
      * and is provided solely to cover use-cases that can not otherwise be addressed safely. When used incorrectly, there
-     * are no guarantees made about the behaviour of the program. Particularly, incorrect use is not guaranteed to
-     * result in a VM crash, but might instead silently cause memory to be corrupted.
+     * are no guarantees made about the behaviour of the program. More specifically, incorrect uses of this method might
+     * result in a JVM crash or, worse, might silently result in memory corruption.
      * <p>
      * This method allows for making an otherwise in-accessible memory region accessible. However, there
      * is no guarantee that this memory is safe to access, or that the given size for the new segment is not too large,
      * potentially resulting in out-of-bounds accesses. The developer is trusted to make the judgement that the use of the
      * returned memory segment is safe.
      *
      * @param base the desired base address
      * @param byteSize the desired size.
      * @return a new native memory segment with given base address and size.
      * @throws IllegalArgumentException if {@code base} does not encapsulate a native memory address.
-     * @throws IllegalAccessError if the permission jkd.incubator.foreign.premitUncheckedSegments is not set
+     * @throws IllegalAccessError if the permission jkd.incubator.foreign.restrictedMethods is set to 'deny'
      */
     static MemorySegment ofNativeUnchecked(MemoryAddress base, long byteSize) throws IllegalAccessError {
-        if (!Utils.premitUncheckedSegments) {
-            throw new IllegalAccessError("Can not create unchecked segments. Permission is not enabled");
-        }
+        Utils.checkUnsafeAccess("jdk.incubator.foreign.MemorySegment#ofNativeUnchecked");
         return Utils.makeNativeSegmentUnchecked(base, byteSize);
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -37,10 +37,11 @@
 import jdk.internal.access.foreign.UnmapperProxy;
 import jdk.internal.misc.Unsafe;
 import sun.invoke.util.Wrapper;
 import sun.nio.ch.FileChannelImpl;
 import sun.security.action.GetBooleanAction;
+import sun.security.action.GetPropertyAction;
 
 import java.io.IOException;
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.constant.Constable;
@@ -87,14 +88,27 @@
     private final static long POINTER_SIZE = 8;
 
     private static final JavaNioAccess javaNioAccess = SharedSecrets.getJavaNioAccess();
     private static final JavaLangInvokeAccess javaLangInvokeAccess = SharedSecrets.getJavaLangInvokeAccess();
 
-    public static final boolean premitUncheckedSegments = GetBooleanAction.privilegedGetProperty("jdk.incubator.foreign.permitUncheckedSegments");
-    public static final boolean permitUnsafeInterop = GetBooleanAction.privilegedGetProperty("jdk.incubator.foreign.permitUnsafeInterop");
+    private static final String restrictedMethods = GetPropertyAction.privilegedGetProperty("jdk.incubator.foreign.restrictedMethods", "deny");
     private static final boolean skipZeroMemory = GetBooleanAction.privilegedGetProperty("jdk.internal.foreign.skipZeroMemory");
 
+    public static void checkUnsafeAccess(String sourceMethod) {
+        switch (restrictedMethods) {
+            case "deny" ->
+                throw new IllegalAccessError("Can not access unsafe method: " + sourceMethod + "." +
+                        " jdk.incubator.foreign.permitUnsafe is set to 'deny'");
+            case "warn" ->
+                System.err.println("WARNING: Accessing unsafe method: " + sourceMethod);
+            case "debug" ->
+                System.out.println("DEBUG: Accessing unsafe method: " + sourceMethod);
+            case "permit" -> {}
+            default -> {}
+        }
+    }
+
     public static long alignUp(long n, long alignment) {
         return (n + alignment - 1) & -alignment;
     }
 
     public static long bitsToBytesOrThrow(long bits, Supplier<RuntimeException> exFactory) {
diff a/test/jdk/java/foreign/StdLibTest.java b/test/jdk/java/foreign/StdLibTest.java
--- a/test/jdk/java/foreign/StdLibTest.java
+++ b/test/jdk/java/foreign/StdLibTest.java
@@ -28,11 +28,11 @@
   * @modules jdk.incubator.foreign/jdk.incubator.foreign.unsafe
  *          jdk.incubator.foreign/jdk.internal.foreign
  *          jdk.incubator.foreign/jdk.internal.foreign.abi
  *          java.base/sun.security.action
  * @build NativeTestHelper StdLibTest
- * @run testng/othervm -Djdk.incubator.foreign.permitUncheckedSegments=true StdLibTest
+ * @run testng/othervm -Djdk.incubator.foreign.restrictedMethods=permit StdLibTest
  */
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
diff a/test/jdk/java/foreign/TestDowncall.java b/test/jdk/java/foreign/TestDowncall.java
--- a/test/jdk/java/foreign/TestDowncall.java
+++ b/test/jdk/java/foreign/TestDowncall.java
@@ -30,11 +30,11 @@
  *          jdk.incubator.foreign/jdk.internal.foreign
  *          jdk.incubator.foreign/jdk.internal.foreign.abi
  *          java.base/sun.security.action
  * @build NativeTestHelper CallGeneratorHelper TestDowncall
  *
- * @run testng/othervm -Djdk.incubator.foreign.permitUnsafeInterop=true TestDowncall
+ * @run testng/othervm -Djdk.incubator.foreign.restrictedMethods=permit TestDowncall
  */
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
diff a/test/jdk/java/foreign/TestNative.java b/test/jdk/java/foreign/TestNative.java
--- a/test/jdk/java/foreign/TestNative.java
+++ b/test/jdk/java/foreign/TestNative.java
@@ -24,11 +24,11 @@
 
 /*
  * @test
  * @modules java.base/jdk.internal.misc
  *          jdk.incubator.foreign/jdk.incubator.foreign.unsafe
- * @run testng/othervm -Djdk.incubator.foreign.permitUnsafeInterop=true TestNative
+ * @run testng/othervm -Djdk.incubator.foreign.restrictedMethods=permit TestNative
  */
 
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
diff a/test/jdk/java/foreign/TestUpcall.java b/test/jdk/java/foreign/TestUpcall.java
--- a/test/jdk/java/foreign/TestUpcall.java
+++ b/test/jdk/java/foreign/TestUpcall.java
@@ -28,11 +28,11 @@
  *          jdk.incubator.foreign/jdk.internal.foreign
  *          jdk.incubator.foreign/jdk.internal.foreign.abi
  *          java.base/sun.security.action
  * @build NativeTestHelper CallGeneratorHelper TestUpcall
  *
- * @run testng/othervm -Djdk.incubator.foreign.permitUnsafeInterop=true TestUpcall
+ * @run testng/othervm -Djdk.incubator.foreign.restrictedMethods=permit TestUpcall
  */
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.LibraryLookup;

diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
@@ -26,10 +26,11 @@
 
 package jdk.incubator.foreign;
 
 import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.MemorySegmentImpl;
+import jdk.internal.foreign.Utils;
 
 /**
  * A memory address encodes an offset within a given {@link MemorySegment}. Memory addresses are typically obtained
  * using the {@link MemorySegment#baseAddress()} method; such addresses can then be adjusted as required,
  * using {@link MemoryAddress#addOffset(long)}.
@@ -140,6 +141,25 @@
     static MemoryAddress ofLong(long value) {
         return value == 0 ?
                 NULL :
                 MemorySegmentImpl.NOTHING.baseAddress().addOffset(value);
     }
+
+    // The following methods can be used in conjunction with the java.foreign API.
+
+    /**
+     * Returns the absolute address represented by the given off-heap memory address as a {@code long}.
+     * <p>
+     * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
+     * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
+     * restricted methods, and use safe and supported functionalities, where possible.
+     *
+     * @param address the address to turn into a {@code long}
+     * @return the address as a {@code long}
+     * @throws IllegalAccessError if the permission jkd.incubator.foreign.restrictedMethods is set to 'deny'
+     * @throws IllegalStateException if the given address is not an off-heap address
+     */
+    static long asLong(MemoryAddress address) throws IllegalAccessError {
+        Utils.checkRestrictedAcccess("jdk.incubator.foreign.MemoryAddress#asLong");
+        return MemoryAddressImpl.addressof(address);
+    }
 }

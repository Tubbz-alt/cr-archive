diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -37,10 +37,11 @@
 import jdk.internal.access.foreign.UnmapperProxy;
 import jdk.internal.misc.Unsafe;
 import sun.invoke.util.Wrapper;
 import sun.nio.ch.FileChannelImpl;
 import sun.security.action.GetBooleanAction;
+import sun.security.action.GetPropertyAction;
 
 import java.io.IOException;
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.constant.Constable;
@@ -87,12 +88,44 @@
     private final static long POINTER_SIZE = 8;
 
     private static final JavaNioAccess javaNioAccess = SharedSecrets.getJavaNioAccess();
     private static final JavaLangInvokeAccess javaLangInvokeAccess = SharedSecrets.getJavaLangInvokeAccess();
 
+    private static final String restrictedMethods = GetPropertyAction.privilegedGetProperty("jdk.incubator.foreign.restrictedMethods", "deny");
     private static final boolean skipZeroMemory = GetBooleanAction.privilegedGetProperty("jdk.internal.foreign.skipZeroMemory");
 
+    private static boolean isBootModuleCaller() {
+        Class<?> caller = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)
+                .walk(s -> s.skip(3).findFirst().orElseThrow().getDeclaringClass());
+        return ModuleLayer.boot().modules().contains(caller.getModule());
+    }
+
+    public static void checkRestrictedAcccess(String sourceMethod) {
+        switch (restrictedMethods) {
+            case "deny" -> {
+                if (isBootModuleCaller()) return;
+                throw new IllegalAccessError("Can not access restricted method: " + sourceMethod + "." +
+                        " jdk.incubator.foreign.restrictedMethods is set to 'deny'");
+            }
+            case "warn" -> {
+                if (isBootModuleCaller()) return;
+                System.err.println("WARNING: Accessing restricted method: " + sourceMethod);
+            }
+            case "debug" -> {
+                StringBuilder sb = new StringBuilder("DEBUG: Accessing restricted method: " + sourceMethod);
+                StackWalker.getInstance().walk(s -> {
+                    s.skip(2)
+                     .forEach(f -> sb.append(System.lineSeparator()).append("\tat " + f));
+                    return null;
+                });
+                System.out.println(sb.toString());
+            }
+            case "permit" -> {}
+            default -> {}
+        }
+    }
+
     public static long alignUp(long n, long alignment) {
         return (n + alignment - 1) & -alignment;
     }
 
     public static long bitsToBytesOrThrow(long bits, Supplier<RuntimeException> exFactory) {

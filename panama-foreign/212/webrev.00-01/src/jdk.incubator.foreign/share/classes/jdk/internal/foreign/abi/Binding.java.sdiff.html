<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BindingInterpreter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.internal.foreign.abi;
 24 

 25 import jdk.incubator.foreign.MemoryHandles;
 26 import jdk.incubator.foreign.MemoryLayout;



 27 



 28 import java.util.ArrayList;

 29 import java.util.List;

 30 import java.util.Objects;
 31 
 32 import java.lang.invoke.VarHandle;
 33 import java.nio.ByteOrder;







 34 
 35 /**
 36  * The binding operators defined in the Binding class can be combined into argument and return value processing &#39;recipes&#39;.
 37  *
 38  * The binding operators are interpreted using a stack-base interpreter. Operators can either consume operands from the
 39  * stack, or push them onto the stack.
 40  *
 41  * In the description of each binding we talk about &#39;boxing&#39; and &#39;unboxing&#39;.
 42  *  - Unboxing is the process of taking a Java value and decomposing it, and storing components into machine
 43  *    storage locations. As such, the binding interpreter stack starts with the Java value on it, and should end empty.
 44  *  - Boxing is the process of re-composing a Java value by pulling components from machine storage locations.
 45  *    If a MemorySegment is needed to store the result, one should be allocated using the ALLOCATE_BUFFER operator.
 46  *    The binding interpreter stack starts off empty, and ends with the value to be returned as the only value on it.
 47  * A binding operator can be interpreted differently based on whether we are boxing or unboxing a value. For example,
 48  * the CONVERT_ADDRESS operator &#39;unboxes&#39; a MemoryAddress to a long, but &#39;boxes&#39; a long to a MemoryAddress.
 49  *
 50  * Here are some examples of binding recipes derived from C declarations, and according to the Windows ABI (recipes are
 51  * ABI-specific). Note that each argument has it&#39;s own recipe, which is indicated by &#39;[number]:&#39; (though, the only
 52  * example that has multiple arguments is the one using varargs).
 53  *
</pre>
<hr />
<pre>
169  *
170  * --------------------
171  *
172  * void f(int dummy, ...); // varargs
173  *
174  * f(0, 10f); // passing a float
175  *
176  * Argument bindings:
177  * 0: MOVE(rcx, int.class) // moves the &#39;int dummy&#39; into the RCX register
178  *
179  * 1: DUP // duplicates the &#39;10f&#39; argument
180  *    MOVE(rdx, float.class) // move one copy into the RDX register
181  *    MOVE(xmm1, float.class) // moves the other copy into the xmm2 register
182  *
183  * Return bindings:
184  * none
185  *
186  * --------------------
187  */
188 public abstract class Binding {
























189     enum Tag {
190         MOVE,
191         DEREFERENCE,
192         COPY_BUFFER,
193         ALLOC_BUFFER,
194         CONVERT_ADDRESS,
195         BASE_ADDRESS,
196         DUP
197     }
198 
199     private final Tag tag;
200 
201     private Binding(Tag tag) {
202         this.tag = tag;
203     }
204 
205     public Tag tag() {
206         return tag;
207     }
208 






























209     private static void checkType(Class&lt;?&gt; type) {
210         if (!type.isPrimitive() || type == void.class || type == boolean.class)
211             throw new IllegalArgumentException(&quot;Illegal type: &quot; + type);
212     }
213 






214     public static Move move(VMStorage storage, Class&lt;?&gt; type) {
215         checkType(type);
216         return new Move(storage, type);
217     }
218 
219     public static Dereference dereference(long offset, Class&lt;?&gt; type) {
220         checkType(type);
221         if (offset &lt; 0)
222             throw new IllegalArgumentException(&quot;Negative offset: &quot; + offset);
223         return new Dereference(offset, type);
224     }
225 
226     public static Copy copy(MemoryLayout layout) {
227         return new Copy(layout.byteSize(), layout.byteAlignment());
228     }
229 
230     public static Allocate allocate(MemoryLayout layout) {
231         return new Allocate(layout.byteSize(), layout.byteAlignment());
232     }
233 
</pre>
<hr />
<pre>
323             return &quot;Move{&quot; +
324                     &quot;tag=&quot; + tag() +
325                     &quot;, storage=&quot; + storage +
326                     &quot;, type=&quot; + type +
327                     &#39;}&#39;;
328         }
329 
330         @Override
331         public boolean equals(Object o) {
332             if (this == o) return true;
333             if (o == null || getClass() != o.getClass()) return false;
334             Move move = (Move) o;
335             return storage.equals(move.storage) &amp;&amp;
336                     type.equals(move.type);
337         }
338 
339         @Override
340         public int hashCode() {
341             return Objects.hash(tag(), storage, type);
342         }
































343     }
344 
345     /**
346      * DEREFERENCE([offset into memory region], [type])
347      *   When unboxing: pops a MemorySegment from the operand stack,
348      *     loads a [type] from [offset into memory region] from it, and pushes it onto the operand stack
349      *   When boxing: pops a [type], and then a MemorySegment from the operand stack,
350      *     and then stores [type] to [offset into memory region] of the MemorySegment
351      * The [type] must be one of byte, short, char, int, long, float, or double
352      */
353     public static class Dereference extends Binding {
354         private final long offset;
355         private final Class&lt;?&gt; type;
356 
357         private Dereference(long offset, Class&lt;?&gt; type) {
358             super(Tag.DEREFERENCE);
359             this.offset = offset;
360             this.type = type;
361         }
362 
363         public long offset() {
364             return offset;
365         }
366 
367         public Class&lt;?&gt; type() {
368             return type;
369         }
370 
<span class="line-removed">371         public VarHandle varHandle() {</span>
<span class="line-removed">372             return MemoryHandles.withOffset(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), offset);</span>
<span class="line-removed">373         }</span>
<span class="line-removed">374 </span>
375         @Override
376         public String toString() {
377             return &quot;Dereference{&quot; +
378                     &quot;tag=&quot; + tag() +
379                     &quot;, offset=&quot; + offset +
380                     &quot;, type=&quot; + type +
381                     &#39;}&#39;;
382         }
383 
384         @Override
385         public boolean equals(Object o) {
386             if (this == o) return true;
387             if (o == null || getClass() != o.getClass()) return false;
388             Dereference that = (Dereference) o;
389             return offset == that.offset &amp;&amp;
390                     type.equals(that.type);
391         }
392 
393         @Override
394         public int hashCode() {
395             return Objects.hash(tag(), offset, type);
396         }























































397     }
398 
399     /**
400      * COPY([size], [alignment])
401      *   Creates a new MemorySegment with the given [size] and [alignment],
402      *     and copies contents from a MemorySegment popped from the top of the operand stack into this new buffer,
403      *     and pushes the new buffer onto the operand stack
404      */
405     public static class Copy extends Binding {
406         private final long size;
407         private final long alignment;
408 
409         private Copy(long size, long alignment) {
410             super(Tag.COPY_BUFFER);
411             this.size = size;
412             this.alignment = alignment;
413         }
414 
415         public long size() {
416             return size;
</pre>
<hr />
<pre>
425             return &quot;Copy{&quot; +
426                     &quot;tag=&quot; + tag() +
427                     &quot;, size=&quot; + size +
428                     &quot;, alignment=&quot; + alignment +
429                     &#39;}&#39;;
430         }
431 
432         @Override
433         public boolean equals(Object o) {
434             if (this == o) return true;
435             if (o == null || getClass() != o.getClass()) return false;
436             Copy copy = (Copy) o;
437             return size == copy.size &amp;&amp;
438                     alignment == copy.alignment;
439         }
440 
441         @Override
442         public int hashCode() {
443             return Objects.hash(tag(), size, alignment);
444         }











































445     }
446 
447     /**
448      * ALLOCATE([size], [alignment])
449      *   Creates a new MemorySegment with the give [size] and [alignment], and pushes it onto the operand stack.
450      */
451     public static class Allocate extends Binding {
452         private final long size;
453         private final long alignment;
454 
455         private Allocate(long size, long alignment) {
456             super(Tag.ALLOC_BUFFER);
457             this.size = size;
458             this.alignment = alignment;
459         }
460 
461         public long size() {
462             return size;
463         }
464 
</pre>
<hr />
<pre>
471             return &quot;AllocateBuffer{&quot; +
472                     &quot;tag=&quot; + tag() +
473                     &quot;size=&quot; + size +
474                     &quot;, alignment=&quot; + alignment +
475                     &#39;}&#39;;
476         }
477 
478         @Override
479         public boolean equals(Object o) {
480             if (this == o) return true;
481             if (o == null || getClass() != o.getClass()) return false;
482             Allocate that = (Allocate) o;
483             return size == that.size &amp;&amp;
484                     alignment == that.alignment;
485         }
486 
487         @Override
488         public int hashCode() {
489             return Objects.hash(tag(), size, alignment);
490         }






























491     }
492 
493     /**
494      * CONVERT_ADDRESS()
495      *   When unboxing: pops a &#39;MemoryAddress&#39; from the operand stack, converts it to a &#39;long&#39;,
496      *     and pushes that onto the operand stack
497      *   When boxing: pops a &#39;long&#39; from the operand stack, converts it to a &#39;MemoryAddress&#39;,
498      *     and pushes that onto the operand stack
499      */
500     public static class ConvertAddress extends Binding {
501         private static final ConvertAddress INSTANCE = new ConvertAddress();
502         private ConvertAddress() {
503             super(Tag.CONVERT_ADDRESS);
504         }
505 
506         @Override
507         public String toString() {
508             return &quot;BoxAddress{&quot; +
509                     &quot;tag=&quot; + tag() +
510                     &quot;}&quot;;
511         }
512 
513         @Override
514         public int hashCode() {
515             return tag().hashCode();
516         }
517 
518         @Override
519         public boolean equals(Object o) {
520             if (this == o) return true;
521             return o != null &amp;&amp; getClass() == o.getClass();
522         }


































523     }
524 
525     /**
526      * BASE_ADDRESS()
527      *   Pops a MemorySegment from the operand stack, and takes the base address of the segment
528      *   (the MemoryAddress that points to the start), and pushes that onto the operand stack
529      */
530     public static class BaseAddress extends Binding {
531         private static final BaseAddress INSTANCE = new BaseAddress();
532         private BaseAddress() {
533             super(Tag.BASE_ADDRESS);
534         }
535 
536         @Override
537         public String toString() {
538             return &quot;BaseAddress{&quot; +
539                     &quot;tag=&quot; + tag() +
540                     &quot;}&quot;;
541         }
542 
543         @Override
544         public int hashCode() {
545             return tag().hashCode();
546         }
547 
548         @Override
549         public boolean equals(Object o) {
550             if (this == o) return true;
551             return o != null &amp;&amp; getClass() == o.getClass();
552         }


































553     }
554 
555     /**
556      * DUP()
557      *   Duplicates the value on the top of the operand stack (without popping it!),
558      *   and pushes the duplicate onto the operand stack
559      */
560     public static class Dup extends Binding {
561         private static final Dup INSTANCE = new Dup();
562         private Dup() {
563             super(Tag.DUP);
564         }
565 
566         @Override
567         public String toString() {
568             return &quot;Dup{&quot; +
569                     &quot;tag=&quot; + tag() +
570                     &quot;}&quot;;
571         }
572 
573         @Override
574         public int hashCode() {
575             return tag().hashCode();
576         }
577 
578         @Override
579         public boolean equals(Object o) {
580             if (this == o) return true;
581             return o != null &amp;&amp; getClass() == o.getClass();
582         }


































































583     }
584 }
</pre>
</td>
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.internal.foreign.abi;
 24 
<span class="line-added"> 25 import jdk.incubator.foreign.MemoryAddress;</span>
 26 import jdk.incubator.foreign.MemoryHandles;
 27 import jdk.incubator.foreign.MemoryLayout;
<span class="line-added"> 28 import jdk.incubator.foreign.MemorySegment;</span>
<span class="line-added"> 29 import jdk.incubator.foreign.NativeScope;</span>
<span class="line-added"> 30 import jdk.internal.foreign.MemoryAddressImpl;</span>
 31 
<span class="line-added"> 32 import java.lang.invoke.MethodHandle;</span>
<span class="line-added"> 33 import java.lang.invoke.MethodHandles;</span>
<span class="line-added"> 34 import java.lang.invoke.MethodType;</span>
 35 import java.util.ArrayList;
<span class="line-added"> 36 import java.util.Deque;</span>
 37 import java.util.List;
<span class="line-added"> 38 import java.util.Map;</span>
 39 import java.util.Objects;
 40 
 41 import java.lang.invoke.VarHandle;
 42 import java.nio.ByteOrder;
<span class="line-added"> 43 import java.util.concurrent.ConcurrentHashMap;</span>
<span class="line-added"> 44 </span>
<span class="line-added"> 45 import static java.lang.invoke.MethodHandles.collectArguments;</span>
<span class="line-added"> 46 import static java.lang.invoke.MethodHandles.filterArguments;</span>
<span class="line-added"> 47 import static java.lang.invoke.MethodHandles.insertArguments;</span>
<span class="line-added"> 48 import static java.lang.invoke.MethodHandles.permuteArguments;</span>
<span class="line-added"> 49 import static java.lang.invoke.MethodType.methodType;</span>
 50 
 51 /**
 52  * The binding operators defined in the Binding class can be combined into argument and return value processing &#39;recipes&#39;.
 53  *
 54  * The binding operators are interpreted using a stack-base interpreter. Operators can either consume operands from the
 55  * stack, or push them onto the stack.
 56  *
 57  * In the description of each binding we talk about &#39;boxing&#39; and &#39;unboxing&#39;.
 58  *  - Unboxing is the process of taking a Java value and decomposing it, and storing components into machine
 59  *    storage locations. As such, the binding interpreter stack starts with the Java value on it, and should end empty.
 60  *  - Boxing is the process of re-composing a Java value by pulling components from machine storage locations.
 61  *    If a MemorySegment is needed to store the result, one should be allocated using the ALLOCATE_BUFFER operator.
 62  *    The binding interpreter stack starts off empty, and ends with the value to be returned as the only value on it.
 63  * A binding operator can be interpreted differently based on whether we are boxing or unboxing a value. For example,
 64  * the CONVERT_ADDRESS operator &#39;unboxes&#39; a MemoryAddress to a long, but &#39;boxes&#39; a long to a MemoryAddress.
 65  *
 66  * Here are some examples of binding recipes derived from C declarations, and according to the Windows ABI (recipes are
 67  * ABI-specific). Note that each argument has it&#39;s own recipe, which is indicated by &#39;[number]:&#39; (though, the only
 68  * example that has multiple arguments is the one using varargs).
 69  *
</pre>
<hr />
<pre>
185  *
186  * --------------------
187  *
188  * void f(int dummy, ...); // varargs
189  *
190  * f(0, 10f); // passing a float
191  *
192  * Argument bindings:
193  * 0: MOVE(rcx, int.class) // moves the &#39;int dummy&#39; into the RCX register
194  *
195  * 1: DUP // duplicates the &#39;10f&#39; argument
196  *    MOVE(rdx, float.class) // move one copy into the RDX register
197  *    MOVE(xmm1, float.class) // moves the other copy into the xmm2 register
198  *
199  * Return bindings:
200  * none
201  *
202  * --------------------
203  */
204 public abstract class Binding {
<span class="line-added">205     private static final MethodHandle MH_UNBOX_ADDRESS;</span>
<span class="line-added">206     private static final MethodHandle MH_BOX_ADDRESS;</span>
<span class="line-added">207     private static final MethodHandle MH_BASE_ADDRESS;</span>
<span class="line-added">208     private static final MethodHandle MH_COPY_BUFFER;</span>
<span class="line-added">209     private static final MethodHandle MH_ALLOCATE_BUFFER;</span>
<span class="line-added">210 </span>
<span class="line-added">211     static {</span>
<span class="line-added">212         try {</span>
<span class="line-added">213             MethodHandles.Lookup lookup = MethodHandles.lookup();</span>
<span class="line-added">214             MH_UNBOX_ADDRESS = lookup.findVirtual(MemoryAddress.class, &quot;toRawLongValue&quot;,</span>
<span class="line-added">215                     methodType(long.class));</span>
<span class="line-added">216             MH_BOX_ADDRESS = lookup.findStatic(MemoryAddress.class, &quot;ofLong&quot;,</span>
<span class="line-added">217                     methodType(MemoryAddress.class, long.class));</span>
<span class="line-added">218             MH_BASE_ADDRESS = lookup.findVirtual(MemorySegment.class, &quot;baseAddress&quot;,</span>
<span class="line-added">219                     methodType(MemoryAddress.class));</span>
<span class="line-added">220             MH_COPY_BUFFER = lookup.findStatic(Binding.class, &quot;copyBuffer&quot;,</span>
<span class="line-added">221                     methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, NativeScope.class));</span>
<span class="line-added">222             MH_ALLOCATE_BUFFER = lookup.findStatic(MemorySegment.class, &quot;allocateNative&quot;,</span>
<span class="line-added">223                     methodType(MemorySegment.class, long.class, long.class));</span>
<span class="line-added">224         } catch (ReflectiveOperationException e) {</span>
<span class="line-added">225             throw new RuntimeException(e);</span>
<span class="line-added">226         }</span>
<span class="line-added">227     }</span>
<span class="line-added">228 </span>
229     enum Tag {
230         MOVE,
231         DEREFERENCE,
232         COPY_BUFFER,
233         ALLOC_BUFFER,
234         CONVERT_ADDRESS,
235         BASE_ADDRESS,
236         DUP
237     }
238 
239     private final Tag tag;
240 
241     private Binding(Tag tag) {
242         this.tag = tag;
243     }
244 
245     public Tag tag() {
246         return tag;
247     }
248 
<span class="line-added">249     public abstract void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack);</span>
<span class="line-added">250     public abstract void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack);</span>
<span class="line-added">251 </span>
<span class="line-added">252     public abstract void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope);</span>
<span class="line-added">253     public abstract void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc);</span>
<span class="line-added">254 </span>
<span class="line-added">255     public abstract MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos);</span>
<span class="line-added">256     public abstract MethodHandle specializeBox(MethodHandle returnFilter);</span>
<span class="line-added">257 </span>
<span class="line-added">258     private static MethodHandle mergeArguments(MethodHandle mh, int sourceIndex, int destIndex) {</span>
<span class="line-added">259         MethodType oldType = mh.type();</span>
<span class="line-added">260         Class&lt;?&gt; sourceType = oldType.parameterType(sourceIndex);</span>
<span class="line-added">261         Class&lt;?&gt; destType = oldType.parameterType(destIndex);</span>
<span class="line-added">262         if (sourceType != destType) {</span>
<span class="line-added">263             // TODO meet?</span>
<span class="line-added">264             throw new IllegalArgumentException(&quot;Parameter types differ: &quot; + sourceType + &quot; != &quot; + destType);</span>
<span class="line-added">265         }</span>
<span class="line-added">266         MethodType newType = oldType.dropParameterTypes(destIndex, destIndex + 1);</span>
<span class="line-added">267         int[] reorder = new int[oldType.parameterCount()];</span>
<span class="line-added">268         assert destIndex &gt; sourceIndex;</span>
<span class="line-added">269         for (int i = 0, index = 0; i &lt; reorder.length; i++) {</span>
<span class="line-added">270             if (i != destIndex) {</span>
<span class="line-added">271                 reorder[i] = index++;</span>
<span class="line-added">272             } else {</span>
<span class="line-added">273                 reorder[i] = sourceIndex;</span>
<span class="line-added">274             }</span>
<span class="line-added">275         }</span>
<span class="line-added">276         return permuteArguments(mh, newType, reorder);</span>
<span class="line-added">277     }</span>
<span class="line-added">278 </span>
279     private static void checkType(Class&lt;?&gt; type) {
280         if (!type.isPrimitive() || type == void.class || type == boolean.class)
281             throw new IllegalArgumentException(&quot;Illegal type: &quot; + type);
282     }
283 
<span class="line-added">284     private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, NativeScope allocator) {</span>
<span class="line-added">285         MemorySegment copy = allocator.allocate(size, alignment).segment();</span>
<span class="line-added">286         copy.copyFrom(operand.asSlice(0, size));</span>
<span class="line-added">287         return copy;</span>
<span class="line-added">288     }</span>
<span class="line-added">289 </span>
290     public static Move move(VMStorage storage, Class&lt;?&gt; type) {
291         checkType(type);
292         return new Move(storage, type);
293     }
294 
295     public static Dereference dereference(long offset, Class&lt;?&gt; type) {
296         checkType(type);
297         if (offset &lt; 0)
298             throw new IllegalArgumentException(&quot;Negative offset: &quot; + offset);
299         return new Dereference(offset, type);
300     }
301 
302     public static Copy copy(MemoryLayout layout) {
303         return new Copy(layout.byteSize(), layout.byteAlignment());
304     }
305 
306     public static Allocate allocate(MemoryLayout layout) {
307         return new Allocate(layout.byteSize(), layout.byteAlignment());
308     }
309 
</pre>
<hr />
<pre>
399             return &quot;Move{&quot; +
400                     &quot;tag=&quot; + tag() +
401                     &quot;, storage=&quot; + storage +
402                     &quot;, type=&quot; + type +
403                     &#39;}&#39;;
404         }
405 
406         @Override
407         public boolean equals(Object o) {
408             if (this == o) return true;
409             if (o == null || getClass() != o.getClass()) return false;
410             Move move = (Move) o;
411             return storage.equals(move.storage) &amp;&amp;
412                     type.equals(move.type);
413         }
414 
415         @Override
416         public int hashCode() {
417             return Objects.hash(tag(), storage, type);
418         }
<span class="line-added">419 </span>
<span class="line-added">420         @Override</span>
<span class="line-added">421         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">422             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">423             Class&lt;?&gt; expectedType = type;</span>
<span class="line-added">424             SharedUtils.checkType(actualType, expectedType);</span>
<span class="line-added">425         }</span>
<span class="line-added">426 </span>
<span class="line-added">427         @Override</span>
<span class="line-added">428         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">429             stack.push(type);</span>
<span class="line-added">430         }</span>
<span class="line-added">431 </span>
<span class="line-added">432         @Override</span>
<span class="line-added">433         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {</span>
<span class="line-added">434             storeFunc.store(storage, type, stack.pop());</span>
<span class="line-added">435         }</span>
<span class="line-added">436 </span>
<span class="line-added">437         @Override</span>
<span class="line-added">438         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {</span>
<span class="line-added">439             stack.push(loadFunc.load(storage, type));</span>
<span class="line-added">440         }</span>
<span class="line-added">441 </span>
<span class="line-added">442         @Override</span>
<span class="line-added">443         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {</span>
<span class="line-added">444             return specializedHandle; // no-op</span>
<span class="line-added">445         }</span>
<span class="line-added">446 </span>
<span class="line-added">447         @Override</span>
<span class="line-added">448         public MethodHandle specializeBox(MethodHandle returnFilter) {</span>
<span class="line-added">449             return returnFilter; // no-op</span>
<span class="line-added">450         }</span>
451     }
452 
453     /**
454      * DEREFERENCE([offset into memory region], [type])
455      *   When unboxing: pops a MemorySegment from the operand stack,
456      *     loads a [type] from [offset into memory region] from it, and pushes it onto the operand stack
457      *   When boxing: pops a [type], and then a MemorySegment from the operand stack,
458      *     and then stores [type] to [offset into memory region] of the MemorySegment
459      * The [type] must be one of byte, short, char, int, long, float, or double
460      */
461     public static class Dereference extends Binding {
462         private final long offset;
463         private final Class&lt;?&gt; type;
464 
465         private Dereference(long offset, Class&lt;?&gt; type) {
466             super(Tag.DEREFERENCE);
467             this.offset = offset;
468             this.type = type;
469         }
470 
471         public long offset() {
472             return offset;
473         }
474 
475         public Class&lt;?&gt; type() {
476             return type;
477         }
478 




479         @Override
480         public String toString() {
481             return &quot;Dereference{&quot; +
482                     &quot;tag=&quot; + tag() +
483                     &quot;, offset=&quot; + offset +
484                     &quot;, type=&quot; + type +
485                     &#39;}&#39;;
486         }
487 
488         @Override
489         public boolean equals(Object o) {
490             if (this == o) return true;
491             if (o == null || getClass() != o.getClass()) return false;
492             Dereference that = (Dereference) o;
493             return offset == that.offset &amp;&amp;
494                     type.equals(that.type);
495         }
496 
497         @Override
498         public int hashCode() {
499             return Objects.hash(tag(), offset, type);
500         }
<span class="line-added">501 </span>
<span class="line-added">502         @Override</span>
<span class="line-added">503         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">504             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">505             SharedUtils.checkType(actualType, MemorySegment.class);</span>
<span class="line-added">506             Class&lt;?&gt; newType = type;</span>
<span class="line-added">507             stack.push(newType);</span>
<span class="line-added">508         }</span>
<span class="line-added">509 </span>
<span class="line-added">510         @Override</span>
<span class="line-added">511         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">512             Class&lt;?&gt; storeType = stack.pop();</span>
<span class="line-added">513             SharedUtils.checkType(storeType, type);</span>
<span class="line-added">514             Class&lt;?&gt; segmentType = stack.pop();</span>
<span class="line-added">515             SharedUtils.checkType(segmentType, MemorySegment.class);</span>
<span class="line-added">516         }</span>
<span class="line-added">517 </span>
<span class="line-added">518         @Override</span>
<span class="line-added">519         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {</span>
<span class="line-added">520             MemorySegment operand = (MemorySegment) stack.pop();</span>
<span class="line-added">521             MemoryAddress baseAddress = operand.baseAddress();</span>
<span class="line-added">522             MemoryAddress readAddress = baseAddress.addOffset(offset);</span>
<span class="line-added">523             stack.push(SharedUtils.read(readAddress, type));</span>
<span class="line-added">524         }</span>
<span class="line-added">525 </span>
<span class="line-added">526         @Override</span>
<span class="line-added">527         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {</span>
<span class="line-added">528             Object value = stack.pop();</span>
<span class="line-added">529             MemorySegment operand = (MemorySegment) stack.pop();</span>
<span class="line-added">530             MemoryAddress baseAddress = operand.baseAddress();</span>
<span class="line-added">531             MemoryAddress writeAddress = baseAddress.addOffset(offset);</span>
<span class="line-added">532             SharedUtils.write(writeAddress, type, value);</span>
<span class="line-added">533         }</span>
<span class="line-added">534 </span>
<span class="line-added">535         private VarHandle varHandle() {</span>
<span class="line-added">536             return MemoryHandles.withOffset(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), offset);</span>
<span class="line-added">537         }</span>
<span class="line-added">538 </span>
<span class="line-added">539         @Override</span>
<span class="line-added">540         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {</span>
<span class="line-added">541             MethodHandle filter = filterArguments(</span>
<span class="line-added">542                 varHandle()</span>
<span class="line-added">543                     .toMethodHandle(VarHandle.AccessMode.GET)</span>
<span class="line-added">544                     .asType(methodType(type, MemoryAddress.class)), 0, MH_BASE_ADDRESS);</span>
<span class="line-added">545             return filterArguments(specializedHandle, insertPos, filter);</span>
<span class="line-added">546         }</span>
<span class="line-added">547 </span>
<span class="line-added">548         @Override</span>
<span class="line-added">549         public MethodHandle specializeBox(MethodHandle returnFilter) {</span>
<span class="line-added">550             MethodHandle setter = varHandle().toMethodHandle(VarHandle.AccessMode.SET);</span>
<span class="line-added">551             setter = filterArguments(</span>
<span class="line-added">552                 setter.asType(methodType(void.class, MemoryAddress.class, type)),</span>
<span class="line-added">553                 0, MH_BASE_ADDRESS);</span>
<span class="line-added">554             return collectArguments(returnFilter, returnFilter.type().parameterCount(), setter);</span>
<span class="line-added">555         }</span>
556     }
557 
558     /**
559      * COPY([size], [alignment])
560      *   Creates a new MemorySegment with the given [size] and [alignment],
561      *     and copies contents from a MemorySegment popped from the top of the operand stack into this new buffer,
562      *     and pushes the new buffer onto the operand stack
563      */
564     public static class Copy extends Binding {
565         private final long size;
566         private final long alignment;
567 
568         private Copy(long size, long alignment) {
569             super(Tag.COPY_BUFFER);
570             this.size = size;
571             this.alignment = alignment;
572         }
573 
574         public long size() {
575             return size;
</pre>
<hr />
<pre>
584             return &quot;Copy{&quot; +
585                     &quot;tag=&quot; + tag() +
586                     &quot;, size=&quot; + size +
587                     &quot;, alignment=&quot; + alignment +
588                     &#39;}&#39;;
589         }
590 
591         @Override
592         public boolean equals(Object o) {
593             if (this == o) return true;
594             if (o == null || getClass() != o.getClass()) return false;
595             Copy copy = (Copy) o;
596             return size == copy.size &amp;&amp;
597                     alignment == copy.alignment;
598         }
599 
600         @Override
601         public int hashCode() {
602             return Objects.hash(tag(), size, alignment);
603         }
<span class="line-added">604 </span>
<span class="line-added">605         @Override</span>
<span class="line-added">606         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">607             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">608             SharedUtils.checkType(actualType, MemorySegment.class);</span>
<span class="line-added">609             stack.push(MemorySegment.class);</span>
<span class="line-added">610         }</span>
<span class="line-added">611 </span>
<span class="line-added">612         @Override</span>
<span class="line-added">613         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">614             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">615             SharedUtils.checkType(actualType, MemoryAddress.class);</span>
<span class="line-added">616             stack.push(MemorySegment.class);</span>
<span class="line-added">617         }</span>
<span class="line-added">618 </span>
<span class="line-added">619         @Override</span>
<span class="line-added">620         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {</span>
<span class="line-added">621             MemorySegment operand = (MemorySegment) stack.pop();</span>
<span class="line-added">622             MemorySegment copy = scope.allocate(size, alignment).segment();</span>
<span class="line-added">623             copy.copyFrom(operand.asSlice(0, size));</span>
<span class="line-added">624             stack.push(copy);</span>
<span class="line-added">625         }</span>
<span class="line-added">626 </span>
<span class="line-added">627         @Override</span>
<span class="line-added">628         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {</span>
<span class="line-added">629             MemoryAddress operand = (MemoryAddress) stack.pop();</span>
<span class="line-added">630             operand = MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);</span>
<span class="line-added">631             MemorySegment copy = MemorySegment.allocateNative(size, alignment);</span>
<span class="line-added">632             copy.copyFrom(operand.segment().asSlice(0, size));</span>
<span class="line-added">633             stack.push(copy); // leaked</span>
<span class="line-added">634         }</span>
<span class="line-added">635 </span>
<span class="line-added">636         @Override</span>
<span class="line-added">637         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {</span>
<span class="line-added">638             MethodHandle filter = insertArguments(MH_COPY_BUFFER, 1, size, alignment);</span>
<span class="line-added">639             specializedHandle = collectArguments(specializedHandle, insertPos, filter);</span>
<span class="line-added">640             return mergeArguments(specializedHandle, 0, insertPos + 1);</span>
<span class="line-added">641         }</span>
<span class="line-added">642 </span>
<span class="line-added">643         @Override</span>
<span class="line-added">644         public MethodHandle specializeBox(MethodHandle returnFilter) {</span>
<span class="line-added">645             throw new UnsupportedOperationException();</span>
<span class="line-added">646         }</span>
647     }
648 
649     /**
650      * ALLOCATE([size], [alignment])
651      *   Creates a new MemorySegment with the give [size] and [alignment], and pushes it onto the operand stack.
652      */
653     public static class Allocate extends Binding {
654         private final long size;
655         private final long alignment;
656 
657         private Allocate(long size, long alignment) {
658             super(Tag.ALLOC_BUFFER);
659             this.size = size;
660             this.alignment = alignment;
661         }
662 
663         public long size() {
664             return size;
665         }
666 
</pre>
<hr />
<pre>
673             return &quot;AllocateBuffer{&quot; +
674                     &quot;tag=&quot; + tag() +
675                     &quot;size=&quot; + size +
676                     &quot;, alignment=&quot; + alignment +
677                     &#39;}&#39;;
678         }
679 
680         @Override
681         public boolean equals(Object o) {
682             if (this == o) return true;
683             if (o == null || getClass() != o.getClass()) return false;
684             Allocate that = (Allocate) o;
685             return size == that.size &amp;&amp;
686                     alignment == that.alignment;
687         }
688 
689         @Override
690         public int hashCode() {
691             return Objects.hash(tag(), size, alignment);
692         }
<span class="line-added">693 </span>
<span class="line-added">694         @Override</span>
<span class="line-added">695         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">696             throw new UnsupportedOperationException();</span>
<span class="line-added">697         }</span>
<span class="line-added">698 </span>
<span class="line-added">699         @Override</span>
<span class="line-added">700         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">701             stack.push(MemorySegment.class);</span>
<span class="line-added">702         }</span>
<span class="line-added">703 </span>
<span class="line-added">704         @Override</span>
<span class="line-added">705         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {</span>
<span class="line-added">706             throw new UnsupportedOperationException();</span>
<span class="line-added">707         }</span>
<span class="line-added">708 </span>
<span class="line-added">709         @Override</span>
<span class="line-added">710         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {</span>
<span class="line-added">711             stack.push(MemorySegment.allocateNative(size, alignment));</span>
<span class="line-added">712         }</span>
<span class="line-added">713 </span>
<span class="line-added">714         @Override</span>
<span class="line-added">715         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {</span>
<span class="line-added">716             throw new UnsupportedOperationException();</span>
<span class="line-added">717         }</span>
<span class="line-added">718 </span>
<span class="line-added">719         @Override</span>
<span class="line-added">720         public MethodHandle specializeBox(MethodHandle returnFilter) {</span>
<span class="line-added">721             return collectArguments(returnFilter, 0, insertArguments(MH_ALLOCATE_BUFFER, 0, size, alignment));</span>
<span class="line-added">722         }</span>
723     }
724 
725     /**
726      * CONVERT_ADDRESS()
727      *   When unboxing: pops a &#39;MemoryAddress&#39; from the operand stack, converts it to a &#39;long&#39;,
728      *     and pushes that onto the operand stack
729      *   When boxing: pops a &#39;long&#39; from the operand stack, converts it to a &#39;MemoryAddress&#39;,
730      *     and pushes that onto the operand stack
731      */
732     public static class ConvertAddress extends Binding {
733         private static final ConvertAddress INSTANCE = new ConvertAddress();
734         private ConvertAddress() {
735             super(Tag.CONVERT_ADDRESS);
736         }
737 
738         @Override
739         public String toString() {
740             return &quot;BoxAddress{&quot; +
741                     &quot;tag=&quot; + tag() +
742                     &quot;}&quot;;
743         }
744 
745         @Override
746         public int hashCode() {
747             return tag().hashCode();
748         }
749 
750         @Override
751         public boolean equals(Object o) {
752             if (this == o) return true;
753             return o != null &amp;&amp; getClass() == o.getClass();
754         }
<span class="line-added">755 </span>
<span class="line-added">756         @Override</span>
<span class="line-added">757         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">758             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">759             SharedUtils.checkType(actualType, MemoryAddress.class);</span>
<span class="line-added">760             stack.push(long.class);</span>
<span class="line-added">761         }</span>
<span class="line-added">762 </span>
<span class="line-added">763         @Override</span>
<span class="line-added">764         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">765             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">766             SharedUtils.checkType(actualType, long.class);</span>
<span class="line-added">767             stack.push(MemoryAddress.class);</span>
<span class="line-added">768         }</span>
<span class="line-added">769 </span>
<span class="line-added">770         @Override</span>
<span class="line-added">771         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {</span>
<span class="line-added">772             stack.push(((MemoryAddress) stack.pop()).toRawLongValue());</span>
<span class="line-added">773         }</span>
<span class="line-added">774 </span>
<span class="line-added">775         @Override</span>
<span class="line-added">776         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {</span>
<span class="line-added">777             stack.push(MemoryAddress.ofLong((long) stack.pop()));</span>
<span class="line-added">778         }</span>
<span class="line-added">779 </span>
<span class="line-added">780         @Override</span>
<span class="line-added">781         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {</span>
<span class="line-added">782             return filterArguments(specializedHandle, insertPos, MH_UNBOX_ADDRESS);</span>
<span class="line-added">783         }</span>
<span class="line-added">784 </span>
<span class="line-added">785         @Override</span>
<span class="line-added">786         public MethodHandle specializeBox(MethodHandle returnFilter) {</span>
<span class="line-added">787             return filterArguments(returnFilter, 0, MH_BOX_ADDRESS);</span>
<span class="line-added">788         }</span>
789     }
790 
791     /**
792      * BASE_ADDRESS()
793      *   Pops a MemorySegment from the operand stack, and takes the base address of the segment
794      *   (the MemoryAddress that points to the start), and pushes that onto the operand stack
795      */
796     public static class BaseAddress extends Binding {
797         private static final BaseAddress INSTANCE = new BaseAddress();
798         private BaseAddress() {
799             super(Tag.BASE_ADDRESS);
800         }
801 
802         @Override
803         public String toString() {
804             return &quot;BaseAddress{&quot; +
805                     &quot;tag=&quot; + tag() +
806                     &quot;}&quot;;
807         }
808 
809         @Override
810         public int hashCode() {
811             return tag().hashCode();
812         }
813 
814         @Override
815         public boolean equals(Object o) {
816             if (this == o) return true;
817             return o != null &amp;&amp; getClass() == o.getClass();
818         }
<span class="line-added">819 </span>
<span class="line-added">820         @Override</span>
<span class="line-added">821         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">822             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">823             SharedUtils.checkType(actualType, MemorySegment.class);</span>
<span class="line-added">824             stack.push(MemoryAddress.class);</span>
<span class="line-added">825         }</span>
<span class="line-added">826 </span>
<span class="line-added">827         @Override</span>
<span class="line-added">828         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">829             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">830             SharedUtils.checkType(actualType, MemorySegment.class);</span>
<span class="line-added">831             stack.push(MemoryAddress.class);</span>
<span class="line-added">832         }</span>
<span class="line-added">833 </span>
<span class="line-added">834         @Override</span>
<span class="line-added">835         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {</span>
<span class="line-added">836             stack.push(((MemorySegment) stack.pop()).baseAddress());</span>
<span class="line-added">837         }</span>
<span class="line-added">838 </span>
<span class="line-added">839         @Override</span>
<span class="line-added">840         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {</span>
<span class="line-added">841             stack.push(((MemorySegment) stack.pop()).baseAddress());</span>
<span class="line-added">842         }</span>
<span class="line-added">843 </span>
<span class="line-added">844         @Override</span>
<span class="line-added">845         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {</span>
<span class="line-added">846             return filterArguments(specializedHandle, insertPos, MH_BASE_ADDRESS);</span>
<span class="line-added">847         }</span>
<span class="line-added">848 </span>
<span class="line-added">849         @Override</span>
<span class="line-added">850         public MethodHandle specializeBox(MethodHandle returnFilter) {</span>
<span class="line-added">851             throw new UnsupportedOperationException();</span>
<span class="line-added">852         }</span>
853     }
854 
855     /**
856      * DUP()
857      *   Duplicates the value on the top of the operand stack (without popping it!),
858      *   and pushes the duplicate onto the operand stack
859      */
860     public static class Dup extends Binding {
861         private static final Dup INSTANCE = new Dup();
862         private Dup() {
863             super(Tag.DUP);
864         }
865 
866         @Override
867         public String toString() {
868             return &quot;Dup{&quot; +
869                     &quot;tag=&quot; + tag() +
870                     &quot;}&quot;;
871         }
872 
873         @Override
874         public int hashCode() {
875             return tag().hashCode();
876         }
877 
878         @Override
879         public boolean equals(Object o) {
880             if (this == o) return true;
881             return o != null &amp;&amp; getClass() == o.getClass();
882         }
<span class="line-added">883 </span>
<span class="line-added">884         @Override</span>
<span class="line-added">885         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">886             stack.push(stack.peekLast());</span>
<span class="line-added">887         }</span>
<span class="line-added">888 </span>
<span class="line-added">889         @Override</span>
<span class="line-added">890         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">891             stack.push(stack.peekLast());</span>
<span class="line-added">892         }</span>
<span class="line-added">893 </span>
<span class="line-added">894         @Override</span>
<span class="line-added">895         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {</span>
<span class="line-added">896             stack.push(stack.peekLast());</span>
<span class="line-added">897         }</span>
<span class="line-added">898 </span>
<span class="line-added">899         @Override</span>
<span class="line-added">900         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {</span>
<span class="line-added">901             stack.push(stack.peekLast());</span>
<span class="line-added">902         }</span>
<span class="line-added">903 </span>
<span class="line-added">904         /*</span>
<span class="line-added">905          * Fixes up Y-shaped data graphs (produced by DEREFERENCE):</span>
<span class="line-added">906          *</span>
<span class="line-added">907          * 1. DUP()</span>
<span class="line-added">908          * 2. DEREFERENCE(0, int.class)</span>
<span class="line-added">909          * 3. MOVE  (ignored)</span>
<span class="line-added">910          * 4. DEREFERENCE(4, int.class)</span>
<span class="line-added">911          * 5. MOVE  (ignored)</span>
<span class="line-added">912          *</span>
<span class="line-added">913          * (specialized in reverse!)</span>
<span class="line-added">914          *</span>
<span class="line-added">915          * 5. (int, int) -&gt; void                       insertPos = 1</span>
<span class="line-added">916          * 4. (MemorySegment, int) -&gt; void             insertPos = 1</span>
<span class="line-added">917          * 3. (MemorySegment, int) -&gt; void             insertPos = 0</span>
<span class="line-added">918          * 2. (MemorySegment, MemorySegment) -&gt; void   insertPos = 0</span>
<span class="line-added">919          * 1. (MemorySegment) -&gt; void                  insertPos = 0</span>
<span class="line-added">920          *</span>
<span class="line-added">921          */</span>
<span class="line-added">922         @Override</span>
<span class="line-added">923         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {</span>
<span class="line-added">924             return mergeArguments(specializedHandle, insertPos, insertPos + 1);</span>
<span class="line-added">925         }</span>
<span class="line-added">926 </span>
<span class="line-added">927         /*</span>
<span class="line-added">928          * Fixes up Y-shaped data graphs (produced by DEREFERENCE):</span>
<span class="line-added">929          *</span>
<span class="line-added">930          * 1. ALLOCATE_BUFFER(4, 4)</span>
<span class="line-added">931          * 2. DUP</span>
<span class="line-added">932          * 3. MOVE  (ignored)</span>
<span class="line-added">933          * 4. DEREFERNCE(0, int.class)</span>
<span class="line-added">934          *</span>
<span class="line-added">935          * (specialized in reverse!)</span>
<span class="line-added">936          *</span>
<span class="line-added">937          * input: (MemorySegment) -&gt; MemorySegment (identity function of high-level return)</span>
<span class="line-added">938          * 4. (MemorySegment, MemorySegment, int) -&gt; MemorySegment</span>
<span class="line-added">939          * 3. (MemorySegment, MemorySegment, int) -&gt; MemorySegment</span>
<span class="line-added">940          * 2. (MemorySegment, int) -&gt; MemorySegment</span>
<span class="line-added">941          * 1. (int) -&gt; MemorySegment</span>
<span class="line-added">942          *</span>
<span class="line-added">943          */</span>
<span class="line-added">944         @Override</span>
<span class="line-added">945         public MethodHandle specializeBox(MethodHandle returnFilter) {</span>
<span class="line-added">946             // assumes shape like: (MS, ..., MS, T) R</span>
<span class="line-added">947             return mergeArguments(returnFilter, 0, returnFilter.type().parameterCount() - 2);</span>
<span class="line-added">948         }</span>
949     }
950 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BindingInterpreter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BindingInterpreter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.internal.foreign.abi;
 24 


 25 import jdk.incubator.foreign.MemoryLayout;



 26 



 27 import java.util.ArrayList;

 28 import java.util.List;

 29 import java.util.Objects;
 30 










 31 /**
 32  * The binding operators defined in the Binding class can be combined into argument and return value processing &#39;recipes&#39;.
 33  *
 34  * The binding operators are interpreted using a stack-base interpreter. Operators can either consume operands from the
 35  * stack, or push them onto the stack.
 36  *
 37  * In the description of each binding we talk about &#39;boxing&#39; and &#39;unboxing&#39;.
 38  *  - Unboxing is the process of taking a Java value and decomposing it, and storing components into machine
 39  *    storage locations. As such, the binding interpreter stack starts with the Java value on it, and should end empty.
 40  *  - Boxing is the process of re-composing a Java value by pulling components from machine storage locations.
 41  *    If a MemorySegment is needed to store the result, one should be allocated using the ALLOCATE_BUFFER operator.
 42  *    The binding interpreter stack starts off empty, and ends with the value to be returned as the only value on it.
 43  * A binding operator can be interpreted differently based on whether we are boxing or unboxing a value. For example,
 44  * the CONVERT_ADDRESS operator &#39;unboxes&#39; a MemoryAddress to a long, but &#39;boxes&#39; a long to a MemoryAddress.
 45  *
 46  * Here are some examples of binding recipes derived from C declarations, and according to the Windows ABI (recipes are
 47  * ABI-specific). Note that each argument has it&#39;s own recipe, which is indicated by &#39;[number]:&#39; (though, the only
 48  * example that has multiple arguments is the one using varargs).
 49  *
 50  * --------------------
</pre>
<hr />
<pre>
165  *
166  * --------------------
167  *
168  * void f(int dummy, ...); // varargs
169  *
170  * f(0, 10f); // passing a float
171  *
172  * Argument bindings:
173  * 0: MOVE(rcx, int.class) // moves the &#39;int dummy&#39; into the RCX register
174  *
175  * 1: DUP // duplicates the &#39;10f&#39; argument
176  *    MOVE(rdx, float.class) // move one copy into the RDX register
177  *    MOVE(xmm1, float.class) // moves the other copy into the xmm2 register
178  *
179  * Return bindings:
180  * none
181  *
182  * --------------------
183  */
184 public abstract class Binding {
























185     enum Tag {
186         MOVE,
187         DEREFERENCE,
188         COPY_BUFFER,
189         ALLOC_BUFFER,
190         CONVERT_ADDRESS,
191         BASE_ADDRESS,
192         DUP
193     }
194 
195     private final Tag tag;
196 
197     private Binding(Tag tag) {
198         this.tag = tag;
199     }
200 
201     public Tag tag() {
202         return tag;
203     }
204 






























205     private static void checkType(Class&lt;?&gt; type) {
206         if (!type.isPrimitive() || type == void.class || type == boolean.class)
207             throw new IllegalArgumentException(&quot;Illegal type: &quot; + type);
208     }
209 






210     public static Move move(VMStorage storage, Class&lt;?&gt; type) {
211         checkType(type);
212         return new Move(storage, type);
213     }
214 
215     public static Dereference dereference(long offset, Class&lt;?&gt; type) {
216         checkType(type);
217         if (offset &lt; 0)
218             throw new IllegalArgumentException(&quot;Negative offset: &quot; + offset);
219         return new Dereference(offset, type);
220     }
221 
222     public static Copy copy(MemoryLayout layout) {
223         return new Copy(layout.byteSize(), layout.byteAlignment());
224     }
225 
226     public static Allocate allocate(MemoryLayout layout) {
227         return new Allocate(layout.byteSize(), layout.byteAlignment());
228     }
229 
</pre>
<hr />
<pre>
319             return &quot;Move{&quot; +
320                     &quot;tag=&quot; + tag() +
321                     &quot;, storage=&quot; + storage +
322                     &quot;, type=&quot; + type +
323                     &#39;}&#39;;
324         }
325 
326         @Override
327         public boolean equals(Object o) {
328             if (this == o) return true;
329             if (o == null || getClass() != o.getClass()) return false;
330             Move move = (Move) o;
331             return storage.equals(move.storage) &amp;&amp;
332                     type.equals(move.type);
333         }
334 
335         @Override
336         public int hashCode() {
337             return Objects.hash(tag(), storage, type);
338         }
































339     }
340 
341     /**
342      * DEREFERENCE([offset into memory region], [type])
343      *   When unboxing: pops a MemorySegment from the operand stack,
344      *     loads a [type] from [offset into memory region] from it, and pushes it onto the operand stack
345      *   When boxing: pops a [type], and then a MemorySegment from the operand stack,
346      *     and then stores [type] to [offset into memory region] of the MemorySegment
347      * The [type] must be one of byte, short, char, int, long, float, or double
348      */
349     public static class Dereference extends Binding {
350         private final long offset;
351         private final Class&lt;?&gt; type;
352 
353         private Dereference(long offset, Class&lt;?&gt; type) {
354             super(Tag.DEREFERENCE);
355             this.offset = offset;
356             this.type = type;
357         }
358 
</pre>
<hr />
<pre>
369             return &quot;Dereference{&quot; +
370                     &quot;tag=&quot; + tag() +
371                     &quot;, offset=&quot; + offset +
372                     &quot;, type=&quot; + type +
373                     &#39;}&#39;;
374         }
375 
376         @Override
377         public boolean equals(Object o) {
378             if (this == o) return true;
379             if (o == null || getClass() != o.getClass()) return false;
380             Dereference that = (Dereference) o;
381             return offset == that.offset &amp;&amp;
382                     type.equals(that.type);
383         }
384 
385         @Override
386         public int hashCode() {
387             return Objects.hash(tag(), offset, type);
388         }























































389     }
390 
391     /**
392      * COPY([size], [alignment])
393      *   Creates a new MemorySegment with the given [size] and [alignment],
394      *     and copies contents from a MemorySegment popped from the top of the operand stack into this new buffer,
395      *     and pushes the new buffer onto the operand stack
396      */
397     public static class Copy extends Binding {
398         private final long size;
399         private final long alignment;
400 
401         private Copy(long size, long alignment) {
402             super(Tag.COPY_BUFFER);
403             this.size = size;
404             this.alignment = alignment;
405         }
406 
407         public long size() {
408             return size;
</pre>
<hr />
<pre>
417             return &quot;Copy{&quot; +
418                     &quot;tag=&quot; + tag() +
419                     &quot;, size=&quot; + size +
420                     &quot;, alignment=&quot; + alignment +
421                     &#39;}&#39;;
422         }
423 
424         @Override
425         public boolean equals(Object o) {
426             if (this == o) return true;
427             if (o == null || getClass() != o.getClass()) return false;
428             Copy copy = (Copy) o;
429             return size == copy.size &amp;&amp;
430                     alignment == copy.alignment;
431         }
432 
433         @Override
434         public int hashCode() {
435             return Objects.hash(tag(), size, alignment);
436         }











































437     }
438 
439     /**
440      * ALLOCATE([size], [alignment])
441      *   Creates a new MemorySegment with the give [size] and [alignment], and pushes it onto the operand stack.
442      */
443     public static class Allocate extends Binding {
444         private final long size;
445         private final long alignment;
446 
447         private Allocate(long size, long alignment) {
448             super(Tag.ALLOC_BUFFER);
449             this.size = size;
450             this.alignment = alignment;
451         }
452 
453         public long size() {
454             return size;
455         }
456 
</pre>
<hr />
<pre>
463             return &quot;AllocateBuffer{&quot; +
464                     &quot;tag=&quot; + tag() +
465                     &quot;size=&quot; + size +
466                     &quot;, alignment=&quot; + alignment +
467                     &#39;}&#39;;
468         }
469 
470         @Override
471         public boolean equals(Object o) {
472             if (this == o) return true;
473             if (o == null || getClass() != o.getClass()) return false;
474             Allocate that = (Allocate) o;
475             return size == that.size &amp;&amp;
476                     alignment == that.alignment;
477         }
478 
479         @Override
480         public int hashCode() {
481             return Objects.hash(tag(), size, alignment);
482         }






























483     }
484 
485     /**
486      * CONVERT_ADDRESS()
487      *   When unboxing: pops a &#39;MemoryAddress&#39; from the operand stack, converts it to a &#39;long&#39;,
488      *     and pushes that onto the operand stack
489      *   When boxing: pops a &#39;long&#39; from the operand stack, converts it to a &#39;MemoryAddress&#39;,
490      *     and pushes that onto the operand stack
491      */
492     public static class ConvertAddress extends Binding {
493         private static final ConvertAddress INSTANCE = new ConvertAddress();
494         private ConvertAddress() {
495             super(Tag.CONVERT_ADDRESS);
496         }
497 
498         @Override
499         public String toString() {
500             return &quot;BoxAddress{&quot; +
501                     &quot;tag=&quot; + tag() +
502                     &quot;}&quot;;
503         }
504 
505         @Override
506         public int hashCode() {
507             return tag().hashCode();
508         }
509 
510         @Override
511         public boolean equals(Object o) {
512             if (this == o) return true;
513             return o != null &amp;&amp; getClass() == o.getClass();
514         }


































515     }
516 
517     /**
518      * BASE_ADDRESS()
519      *   Pops a MemorySegment from the operand stack, and takes the base address of the segment
520      *   (the MemoryAddress that points to the start), and pushes that onto the operand stack
521      */
522     public static class BaseAddress extends Binding {
523         private static final BaseAddress INSTANCE = new BaseAddress();
524         private BaseAddress() {
525             super(Tag.BASE_ADDRESS);
526         }
527 
528         @Override
529         public String toString() {
530             return &quot;BaseAddress{&quot; +
531                     &quot;tag=&quot; + tag() +
532                     &quot;}&quot;;
533         }
534 
535         @Override
536         public int hashCode() {
537             return tag().hashCode();
538         }
539 
540         @Override
541         public boolean equals(Object o) {
542             if (this == o) return true;
543             return o != null &amp;&amp; getClass() == o.getClass();
544         }


































545     }
546 
547     /**
548      * DUP()
549      *   Duplicates the value on the top of the operand stack (without popping it!),
550      *   and pushes the duplicate onto the operand stack
551      */
552     public static class Dup extends Binding {
553         private static final Dup INSTANCE = new Dup();
554         private Dup() {
555             super(Tag.DUP);
556         }
557 
558         @Override
559         public String toString() {
560             return &quot;Dup{&quot; +
561                     &quot;tag=&quot; + tag() +
562                     &quot;}&quot;;
563         }
564 
565         @Override
566         public int hashCode() {
567             return tag().hashCode();
568         }
569 
570         @Override
571         public boolean equals(Object o) {
572             if (this == o) return true;
573             return o != null &amp;&amp; getClass() == o.getClass();
574         }


































































575     }
576 }
</pre>
</td>
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.internal.foreign.abi;
 24 
<span class="line-added"> 25 import jdk.incubator.foreign.MemoryAddress;</span>
<span class="line-added"> 26 import jdk.incubator.foreign.MemoryHandles;</span>
 27 import jdk.incubator.foreign.MemoryLayout;
<span class="line-added"> 28 import jdk.incubator.foreign.MemorySegment;</span>
<span class="line-added"> 29 import jdk.incubator.foreign.NativeScope;</span>
<span class="line-added"> 30 import jdk.internal.foreign.MemoryAddressImpl;</span>
 31 
<span class="line-added"> 32 import java.lang.invoke.MethodHandle;</span>
<span class="line-added"> 33 import java.lang.invoke.MethodHandles;</span>
<span class="line-added"> 34 import java.lang.invoke.MethodType;</span>
 35 import java.util.ArrayList;
<span class="line-added"> 36 import java.util.Deque;</span>
 37 import java.util.List;
<span class="line-added"> 38 import java.util.Map;</span>
 39 import java.util.Objects;
 40 
<span class="line-added"> 41 import java.lang.invoke.VarHandle;</span>
<span class="line-added"> 42 import java.nio.ByteOrder;</span>
<span class="line-added"> 43 import java.util.concurrent.ConcurrentHashMap;</span>
<span class="line-added"> 44 </span>
<span class="line-added"> 45 import static java.lang.invoke.MethodHandles.collectArguments;</span>
<span class="line-added"> 46 import static java.lang.invoke.MethodHandles.filterArguments;</span>
<span class="line-added"> 47 import static java.lang.invoke.MethodHandles.insertArguments;</span>
<span class="line-added"> 48 import static java.lang.invoke.MethodHandles.permuteArguments;</span>
<span class="line-added"> 49 import static java.lang.invoke.MethodType.methodType;</span>
<span class="line-added"> 50 </span>
 51 /**
 52  * The binding operators defined in the Binding class can be combined into argument and return value processing &#39;recipes&#39;.
 53  *
 54  * The binding operators are interpreted using a stack-base interpreter. Operators can either consume operands from the
 55  * stack, or push them onto the stack.
 56  *
 57  * In the description of each binding we talk about &#39;boxing&#39; and &#39;unboxing&#39;.
 58  *  - Unboxing is the process of taking a Java value and decomposing it, and storing components into machine
 59  *    storage locations. As such, the binding interpreter stack starts with the Java value on it, and should end empty.
 60  *  - Boxing is the process of re-composing a Java value by pulling components from machine storage locations.
 61  *    If a MemorySegment is needed to store the result, one should be allocated using the ALLOCATE_BUFFER operator.
 62  *    The binding interpreter stack starts off empty, and ends with the value to be returned as the only value on it.
 63  * A binding operator can be interpreted differently based on whether we are boxing or unboxing a value. For example,
 64  * the CONVERT_ADDRESS operator &#39;unboxes&#39; a MemoryAddress to a long, but &#39;boxes&#39; a long to a MemoryAddress.
 65  *
 66  * Here are some examples of binding recipes derived from C declarations, and according to the Windows ABI (recipes are
 67  * ABI-specific). Note that each argument has it&#39;s own recipe, which is indicated by &#39;[number]:&#39; (though, the only
 68  * example that has multiple arguments is the one using varargs).
 69  *
 70  * --------------------
</pre>
<hr />
<pre>
185  *
186  * --------------------
187  *
188  * void f(int dummy, ...); // varargs
189  *
190  * f(0, 10f); // passing a float
191  *
192  * Argument bindings:
193  * 0: MOVE(rcx, int.class) // moves the &#39;int dummy&#39; into the RCX register
194  *
195  * 1: DUP // duplicates the &#39;10f&#39; argument
196  *    MOVE(rdx, float.class) // move one copy into the RDX register
197  *    MOVE(xmm1, float.class) // moves the other copy into the xmm2 register
198  *
199  * Return bindings:
200  * none
201  *
202  * --------------------
203  */
204 public abstract class Binding {
<span class="line-added">205     private static final MethodHandle MH_UNBOX_ADDRESS;</span>
<span class="line-added">206     private static final MethodHandle MH_BOX_ADDRESS;</span>
<span class="line-added">207     private static final MethodHandle MH_BASE_ADDRESS;</span>
<span class="line-added">208     private static final MethodHandle MH_COPY_BUFFER;</span>
<span class="line-added">209     private static final MethodHandle MH_ALLOCATE_BUFFER;</span>
<span class="line-added">210 </span>
<span class="line-added">211     static {</span>
<span class="line-added">212         try {</span>
<span class="line-added">213             MethodHandles.Lookup lookup = MethodHandles.lookup();</span>
<span class="line-added">214             MH_UNBOX_ADDRESS = lookup.findVirtual(MemoryAddress.class, &quot;toRawLongValue&quot;,</span>
<span class="line-added">215                     methodType(long.class));</span>
<span class="line-added">216             MH_BOX_ADDRESS = lookup.findStatic(MemoryAddress.class, &quot;ofLong&quot;,</span>
<span class="line-added">217                     methodType(MemoryAddress.class, long.class));</span>
<span class="line-added">218             MH_BASE_ADDRESS = lookup.findVirtual(MemorySegment.class, &quot;baseAddress&quot;,</span>
<span class="line-added">219                     methodType(MemoryAddress.class));</span>
<span class="line-added">220             MH_COPY_BUFFER = lookup.findStatic(Binding.class, &quot;copyBuffer&quot;,</span>
<span class="line-added">221                     methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, NativeScope.class));</span>
<span class="line-added">222             MH_ALLOCATE_BUFFER = lookup.findStatic(MemorySegment.class, &quot;allocateNative&quot;,</span>
<span class="line-added">223                     methodType(MemorySegment.class, long.class, long.class));</span>
<span class="line-added">224         } catch (ReflectiveOperationException e) {</span>
<span class="line-added">225             throw new RuntimeException(e);</span>
<span class="line-added">226         }</span>
<span class="line-added">227     }</span>
<span class="line-added">228 </span>
229     enum Tag {
230         MOVE,
231         DEREFERENCE,
232         COPY_BUFFER,
233         ALLOC_BUFFER,
234         CONVERT_ADDRESS,
235         BASE_ADDRESS,
236         DUP
237     }
238 
239     private final Tag tag;
240 
241     private Binding(Tag tag) {
242         this.tag = tag;
243     }
244 
245     public Tag tag() {
246         return tag;
247     }
248 
<span class="line-added">249     public abstract void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack);</span>
<span class="line-added">250     public abstract void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack);</span>
<span class="line-added">251 </span>
<span class="line-added">252     public abstract void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope);</span>
<span class="line-added">253     public abstract void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc);</span>
<span class="line-added">254 </span>
<span class="line-added">255     public abstract MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos);</span>
<span class="line-added">256     public abstract MethodHandle specializeBox(MethodHandle returnFilter);</span>
<span class="line-added">257 </span>
<span class="line-added">258     private static MethodHandle mergeArguments(MethodHandle mh, int sourceIndex, int destIndex) {</span>
<span class="line-added">259         MethodType oldType = mh.type();</span>
<span class="line-added">260         Class&lt;?&gt; sourceType = oldType.parameterType(sourceIndex);</span>
<span class="line-added">261         Class&lt;?&gt; destType = oldType.parameterType(destIndex);</span>
<span class="line-added">262         if (sourceType != destType) {</span>
<span class="line-added">263             // TODO meet?</span>
<span class="line-added">264             throw new IllegalArgumentException(&quot;Parameter types differ: &quot; + sourceType + &quot; != &quot; + destType);</span>
<span class="line-added">265         }</span>
<span class="line-added">266         MethodType newType = oldType.dropParameterTypes(destIndex, destIndex + 1);</span>
<span class="line-added">267         int[] reorder = new int[oldType.parameterCount()];</span>
<span class="line-added">268         assert destIndex &gt; sourceIndex;</span>
<span class="line-added">269         for (int i = 0, index = 0; i &lt; reorder.length; i++) {</span>
<span class="line-added">270             if (i != destIndex) {</span>
<span class="line-added">271                 reorder[i] = index++;</span>
<span class="line-added">272             } else {</span>
<span class="line-added">273                 reorder[i] = sourceIndex;</span>
<span class="line-added">274             }</span>
<span class="line-added">275         }</span>
<span class="line-added">276         return permuteArguments(mh, newType, reorder);</span>
<span class="line-added">277     }</span>
<span class="line-added">278 </span>
279     private static void checkType(Class&lt;?&gt; type) {
280         if (!type.isPrimitive() || type == void.class || type == boolean.class)
281             throw new IllegalArgumentException(&quot;Illegal type: &quot; + type);
282     }
283 
<span class="line-added">284     private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, NativeScope allocator) {</span>
<span class="line-added">285         MemorySegment copy = allocator.allocate(size, alignment).segment();</span>
<span class="line-added">286         copy.copyFrom(operand.asSlice(0, size));</span>
<span class="line-added">287         return copy;</span>
<span class="line-added">288     }</span>
<span class="line-added">289 </span>
290     public static Move move(VMStorage storage, Class&lt;?&gt; type) {
291         checkType(type);
292         return new Move(storage, type);
293     }
294 
295     public static Dereference dereference(long offset, Class&lt;?&gt; type) {
296         checkType(type);
297         if (offset &lt; 0)
298             throw new IllegalArgumentException(&quot;Negative offset: &quot; + offset);
299         return new Dereference(offset, type);
300     }
301 
302     public static Copy copy(MemoryLayout layout) {
303         return new Copy(layout.byteSize(), layout.byteAlignment());
304     }
305 
306     public static Allocate allocate(MemoryLayout layout) {
307         return new Allocate(layout.byteSize(), layout.byteAlignment());
308     }
309 
</pre>
<hr />
<pre>
399             return &quot;Move{&quot; +
400                     &quot;tag=&quot; + tag() +
401                     &quot;, storage=&quot; + storage +
402                     &quot;, type=&quot; + type +
403                     &#39;}&#39;;
404         }
405 
406         @Override
407         public boolean equals(Object o) {
408             if (this == o) return true;
409             if (o == null || getClass() != o.getClass()) return false;
410             Move move = (Move) o;
411             return storage.equals(move.storage) &amp;&amp;
412                     type.equals(move.type);
413         }
414 
415         @Override
416         public int hashCode() {
417             return Objects.hash(tag(), storage, type);
418         }
<span class="line-added">419 </span>
<span class="line-added">420         @Override</span>
<span class="line-added">421         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">422             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">423             Class&lt;?&gt; expectedType = type;</span>
<span class="line-added">424             SharedUtils.checkType(actualType, expectedType);</span>
<span class="line-added">425         }</span>
<span class="line-added">426 </span>
<span class="line-added">427         @Override</span>
<span class="line-added">428         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">429             stack.push(type);</span>
<span class="line-added">430         }</span>
<span class="line-added">431 </span>
<span class="line-added">432         @Override</span>
<span class="line-added">433         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {</span>
<span class="line-added">434             storeFunc.store(storage, type, stack.pop());</span>
<span class="line-added">435         }</span>
<span class="line-added">436 </span>
<span class="line-added">437         @Override</span>
<span class="line-added">438         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {</span>
<span class="line-added">439             stack.push(loadFunc.load(storage, type));</span>
<span class="line-added">440         }</span>
<span class="line-added">441 </span>
<span class="line-added">442         @Override</span>
<span class="line-added">443         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {</span>
<span class="line-added">444             return specializedHandle; // no-op</span>
<span class="line-added">445         }</span>
<span class="line-added">446 </span>
<span class="line-added">447         @Override</span>
<span class="line-added">448         public MethodHandle specializeBox(MethodHandle returnFilter) {</span>
<span class="line-added">449             return returnFilter; // no-op</span>
<span class="line-added">450         }</span>
451     }
452 
453     /**
454      * DEREFERENCE([offset into memory region], [type])
455      *   When unboxing: pops a MemorySegment from the operand stack,
456      *     loads a [type] from [offset into memory region] from it, and pushes it onto the operand stack
457      *   When boxing: pops a [type], and then a MemorySegment from the operand stack,
458      *     and then stores [type] to [offset into memory region] of the MemorySegment
459      * The [type] must be one of byte, short, char, int, long, float, or double
460      */
461     public static class Dereference extends Binding {
462         private final long offset;
463         private final Class&lt;?&gt; type;
464 
465         private Dereference(long offset, Class&lt;?&gt; type) {
466             super(Tag.DEREFERENCE);
467             this.offset = offset;
468             this.type = type;
469         }
470 
</pre>
<hr />
<pre>
481             return &quot;Dereference{&quot; +
482                     &quot;tag=&quot; + tag() +
483                     &quot;, offset=&quot; + offset +
484                     &quot;, type=&quot; + type +
485                     &#39;}&#39;;
486         }
487 
488         @Override
489         public boolean equals(Object o) {
490             if (this == o) return true;
491             if (o == null || getClass() != o.getClass()) return false;
492             Dereference that = (Dereference) o;
493             return offset == that.offset &amp;&amp;
494                     type.equals(that.type);
495         }
496 
497         @Override
498         public int hashCode() {
499             return Objects.hash(tag(), offset, type);
500         }
<span class="line-added">501 </span>
<span class="line-added">502         @Override</span>
<span class="line-added">503         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">504             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">505             SharedUtils.checkType(actualType, MemorySegment.class);</span>
<span class="line-added">506             Class&lt;?&gt; newType = type;</span>
<span class="line-added">507             stack.push(newType);</span>
<span class="line-added">508         }</span>
<span class="line-added">509 </span>
<span class="line-added">510         @Override</span>
<span class="line-added">511         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">512             Class&lt;?&gt; storeType = stack.pop();</span>
<span class="line-added">513             SharedUtils.checkType(storeType, type);</span>
<span class="line-added">514             Class&lt;?&gt; segmentType = stack.pop();</span>
<span class="line-added">515             SharedUtils.checkType(segmentType, MemorySegment.class);</span>
<span class="line-added">516         }</span>
<span class="line-added">517 </span>
<span class="line-added">518         @Override</span>
<span class="line-added">519         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {</span>
<span class="line-added">520             MemorySegment operand = (MemorySegment) stack.pop();</span>
<span class="line-added">521             MemoryAddress baseAddress = operand.baseAddress();</span>
<span class="line-added">522             MemoryAddress readAddress = baseAddress.addOffset(offset);</span>
<span class="line-added">523             stack.push(SharedUtils.read(readAddress, type));</span>
<span class="line-added">524         }</span>
<span class="line-added">525 </span>
<span class="line-added">526         @Override</span>
<span class="line-added">527         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {</span>
<span class="line-added">528             Object value = stack.pop();</span>
<span class="line-added">529             MemorySegment operand = (MemorySegment) stack.pop();</span>
<span class="line-added">530             MemoryAddress baseAddress = operand.baseAddress();</span>
<span class="line-added">531             MemoryAddress writeAddress = baseAddress.addOffset(offset);</span>
<span class="line-added">532             SharedUtils.write(writeAddress, type, value);</span>
<span class="line-added">533         }</span>
<span class="line-added">534 </span>
<span class="line-added">535         private VarHandle varHandle() {</span>
<span class="line-added">536             return MemoryHandles.withOffset(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), offset);</span>
<span class="line-added">537         }</span>
<span class="line-added">538 </span>
<span class="line-added">539         @Override</span>
<span class="line-added">540         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {</span>
<span class="line-added">541             MethodHandle filter = filterArguments(</span>
<span class="line-added">542                 varHandle()</span>
<span class="line-added">543                     .toMethodHandle(VarHandle.AccessMode.GET)</span>
<span class="line-added">544                     .asType(methodType(type, MemoryAddress.class)), 0, MH_BASE_ADDRESS);</span>
<span class="line-added">545             return filterArguments(specializedHandle, insertPos, filter);</span>
<span class="line-added">546         }</span>
<span class="line-added">547 </span>
<span class="line-added">548         @Override</span>
<span class="line-added">549         public MethodHandle specializeBox(MethodHandle returnFilter) {</span>
<span class="line-added">550             MethodHandle setter = varHandle().toMethodHandle(VarHandle.AccessMode.SET);</span>
<span class="line-added">551             setter = filterArguments(</span>
<span class="line-added">552                 setter.asType(methodType(void.class, MemoryAddress.class, type)),</span>
<span class="line-added">553                 0, MH_BASE_ADDRESS);</span>
<span class="line-added">554             return collectArguments(returnFilter, returnFilter.type().parameterCount(), setter);</span>
<span class="line-added">555         }</span>
556     }
557 
558     /**
559      * COPY([size], [alignment])
560      *   Creates a new MemorySegment with the given [size] and [alignment],
561      *     and copies contents from a MemorySegment popped from the top of the operand stack into this new buffer,
562      *     and pushes the new buffer onto the operand stack
563      */
564     public static class Copy extends Binding {
565         private final long size;
566         private final long alignment;
567 
568         private Copy(long size, long alignment) {
569             super(Tag.COPY_BUFFER);
570             this.size = size;
571             this.alignment = alignment;
572         }
573 
574         public long size() {
575             return size;
</pre>
<hr />
<pre>
584             return &quot;Copy{&quot; +
585                     &quot;tag=&quot; + tag() +
586                     &quot;, size=&quot; + size +
587                     &quot;, alignment=&quot; + alignment +
588                     &#39;}&#39;;
589         }
590 
591         @Override
592         public boolean equals(Object o) {
593             if (this == o) return true;
594             if (o == null || getClass() != o.getClass()) return false;
595             Copy copy = (Copy) o;
596             return size == copy.size &amp;&amp;
597                     alignment == copy.alignment;
598         }
599 
600         @Override
601         public int hashCode() {
602             return Objects.hash(tag(), size, alignment);
603         }
<span class="line-added">604 </span>
<span class="line-added">605         @Override</span>
<span class="line-added">606         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">607             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">608             SharedUtils.checkType(actualType, MemorySegment.class);</span>
<span class="line-added">609             stack.push(MemorySegment.class);</span>
<span class="line-added">610         }</span>
<span class="line-added">611 </span>
<span class="line-added">612         @Override</span>
<span class="line-added">613         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">614             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">615             SharedUtils.checkType(actualType, MemoryAddress.class);</span>
<span class="line-added">616             stack.push(MemorySegment.class);</span>
<span class="line-added">617         }</span>
<span class="line-added">618 </span>
<span class="line-added">619         @Override</span>
<span class="line-added">620         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {</span>
<span class="line-added">621             MemorySegment operand = (MemorySegment) stack.pop();</span>
<span class="line-added">622             MemorySegment copy = scope.allocate(size, alignment).segment();</span>
<span class="line-added">623             copy.copyFrom(operand.asSlice(0, size));</span>
<span class="line-added">624             stack.push(copy);</span>
<span class="line-added">625         }</span>
<span class="line-added">626 </span>
<span class="line-added">627         @Override</span>
<span class="line-added">628         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {</span>
<span class="line-added">629             MemoryAddress operand = (MemoryAddress) stack.pop();</span>
<span class="line-added">630             operand = MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);</span>
<span class="line-added">631             MemorySegment copy = MemorySegment.allocateNative(size, alignment);</span>
<span class="line-added">632             copy.copyFrom(operand.segment().asSlice(0, size));</span>
<span class="line-added">633             stack.push(copy); // leaked</span>
<span class="line-added">634         }</span>
<span class="line-added">635 </span>
<span class="line-added">636         @Override</span>
<span class="line-added">637         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {</span>
<span class="line-added">638             MethodHandle filter = insertArguments(MH_COPY_BUFFER, 1, size, alignment);</span>
<span class="line-added">639             specializedHandle = collectArguments(specializedHandle, insertPos, filter);</span>
<span class="line-added">640             return mergeArguments(specializedHandle, 0, insertPos + 1);</span>
<span class="line-added">641         }</span>
<span class="line-added">642 </span>
<span class="line-added">643         @Override</span>
<span class="line-added">644         public MethodHandle specializeBox(MethodHandle returnFilter) {</span>
<span class="line-added">645             throw new UnsupportedOperationException();</span>
<span class="line-added">646         }</span>
647     }
648 
649     /**
650      * ALLOCATE([size], [alignment])
651      *   Creates a new MemorySegment with the give [size] and [alignment], and pushes it onto the operand stack.
652      */
653     public static class Allocate extends Binding {
654         private final long size;
655         private final long alignment;
656 
657         private Allocate(long size, long alignment) {
658             super(Tag.ALLOC_BUFFER);
659             this.size = size;
660             this.alignment = alignment;
661         }
662 
663         public long size() {
664             return size;
665         }
666 
</pre>
<hr />
<pre>
673             return &quot;AllocateBuffer{&quot; +
674                     &quot;tag=&quot; + tag() +
675                     &quot;size=&quot; + size +
676                     &quot;, alignment=&quot; + alignment +
677                     &#39;}&#39;;
678         }
679 
680         @Override
681         public boolean equals(Object o) {
682             if (this == o) return true;
683             if (o == null || getClass() != o.getClass()) return false;
684             Allocate that = (Allocate) o;
685             return size == that.size &amp;&amp;
686                     alignment == that.alignment;
687         }
688 
689         @Override
690         public int hashCode() {
691             return Objects.hash(tag(), size, alignment);
692         }
<span class="line-added">693 </span>
<span class="line-added">694         @Override</span>
<span class="line-added">695         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">696             throw new UnsupportedOperationException();</span>
<span class="line-added">697         }</span>
<span class="line-added">698 </span>
<span class="line-added">699         @Override</span>
<span class="line-added">700         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">701             stack.push(MemorySegment.class);</span>
<span class="line-added">702         }</span>
<span class="line-added">703 </span>
<span class="line-added">704         @Override</span>
<span class="line-added">705         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {</span>
<span class="line-added">706             throw new UnsupportedOperationException();</span>
<span class="line-added">707         }</span>
<span class="line-added">708 </span>
<span class="line-added">709         @Override</span>
<span class="line-added">710         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {</span>
<span class="line-added">711             stack.push(MemorySegment.allocateNative(size, alignment));</span>
<span class="line-added">712         }</span>
<span class="line-added">713 </span>
<span class="line-added">714         @Override</span>
<span class="line-added">715         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {</span>
<span class="line-added">716             throw new UnsupportedOperationException();</span>
<span class="line-added">717         }</span>
<span class="line-added">718 </span>
<span class="line-added">719         @Override</span>
<span class="line-added">720         public MethodHandle specializeBox(MethodHandle returnFilter) {</span>
<span class="line-added">721             return collectArguments(returnFilter, 0, insertArguments(MH_ALLOCATE_BUFFER, 0, size, alignment));</span>
<span class="line-added">722         }</span>
723     }
724 
725     /**
726      * CONVERT_ADDRESS()
727      *   When unboxing: pops a &#39;MemoryAddress&#39; from the operand stack, converts it to a &#39;long&#39;,
728      *     and pushes that onto the operand stack
729      *   When boxing: pops a &#39;long&#39; from the operand stack, converts it to a &#39;MemoryAddress&#39;,
730      *     and pushes that onto the operand stack
731      */
732     public static class ConvertAddress extends Binding {
733         private static final ConvertAddress INSTANCE = new ConvertAddress();
734         private ConvertAddress() {
735             super(Tag.CONVERT_ADDRESS);
736         }
737 
738         @Override
739         public String toString() {
740             return &quot;BoxAddress{&quot; +
741                     &quot;tag=&quot; + tag() +
742                     &quot;}&quot;;
743         }
744 
745         @Override
746         public int hashCode() {
747             return tag().hashCode();
748         }
749 
750         @Override
751         public boolean equals(Object o) {
752             if (this == o) return true;
753             return o != null &amp;&amp; getClass() == o.getClass();
754         }
<span class="line-added">755 </span>
<span class="line-added">756         @Override</span>
<span class="line-added">757         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">758             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">759             SharedUtils.checkType(actualType, MemoryAddress.class);</span>
<span class="line-added">760             stack.push(long.class);</span>
<span class="line-added">761         }</span>
<span class="line-added">762 </span>
<span class="line-added">763         @Override</span>
<span class="line-added">764         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">765             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">766             SharedUtils.checkType(actualType, long.class);</span>
<span class="line-added">767             stack.push(MemoryAddress.class);</span>
<span class="line-added">768         }</span>
<span class="line-added">769 </span>
<span class="line-added">770         @Override</span>
<span class="line-added">771         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {</span>
<span class="line-added">772             stack.push(((MemoryAddress) stack.pop()).toRawLongValue());</span>
<span class="line-added">773         }</span>
<span class="line-added">774 </span>
<span class="line-added">775         @Override</span>
<span class="line-added">776         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {</span>
<span class="line-added">777             stack.push(MemoryAddress.ofLong((long) stack.pop()));</span>
<span class="line-added">778         }</span>
<span class="line-added">779 </span>
<span class="line-added">780         @Override</span>
<span class="line-added">781         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {</span>
<span class="line-added">782             return filterArguments(specializedHandle, insertPos, MH_UNBOX_ADDRESS);</span>
<span class="line-added">783         }</span>
<span class="line-added">784 </span>
<span class="line-added">785         @Override</span>
<span class="line-added">786         public MethodHandle specializeBox(MethodHandle returnFilter) {</span>
<span class="line-added">787             return filterArguments(returnFilter, 0, MH_BOX_ADDRESS);</span>
<span class="line-added">788         }</span>
789     }
790 
791     /**
792      * BASE_ADDRESS()
793      *   Pops a MemorySegment from the operand stack, and takes the base address of the segment
794      *   (the MemoryAddress that points to the start), and pushes that onto the operand stack
795      */
796     public static class BaseAddress extends Binding {
797         private static final BaseAddress INSTANCE = new BaseAddress();
798         private BaseAddress() {
799             super(Tag.BASE_ADDRESS);
800         }
801 
802         @Override
803         public String toString() {
804             return &quot;BaseAddress{&quot; +
805                     &quot;tag=&quot; + tag() +
806                     &quot;}&quot;;
807         }
808 
809         @Override
810         public int hashCode() {
811             return tag().hashCode();
812         }
813 
814         @Override
815         public boolean equals(Object o) {
816             if (this == o) return true;
817             return o != null &amp;&amp; getClass() == o.getClass();
818         }
<span class="line-added">819 </span>
<span class="line-added">820         @Override</span>
<span class="line-added">821         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">822             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">823             SharedUtils.checkType(actualType, MemorySegment.class);</span>
<span class="line-added">824             stack.push(MemoryAddress.class);</span>
<span class="line-added">825         }</span>
<span class="line-added">826 </span>
<span class="line-added">827         @Override</span>
<span class="line-added">828         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">829             Class&lt;?&gt; actualType = stack.pop();</span>
<span class="line-added">830             SharedUtils.checkType(actualType, MemorySegment.class);</span>
<span class="line-added">831             stack.push(MemoryAddress.class);</span>
<span class="line-added">832         }</span>
<span class="line-added">833 </span>
<span class="line-added">834         @Override</span>
<span class="line-added">835         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {</span>
<span class="line-added">836             stack.push(((MemorySegment) stack.pop()).baseAddress());</span>
<span class="line-added">837         }</span>
<span class="line-added">838 </span>
<span class="line-added">839         @Override</span>
<span class="line-added">840         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {</span>
<span class="line-added">841             stack.push(((MemorySegment) stack.pop()).baseAddress());</span>
<span class="line-added">842         }</span>
<span class="line-added">843 </span>
<span class="line-added">844         @Override</span>
<span class="line-added">845         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {</span>
<span class="line-added">846             return filterArguments(specializedHandle, insertPos, MH_BASE_ADDRESS);</span>
<span class="line-added">847         }</span>
<span class="line-added">848 </span>
<span class="line-added">849         @Override</span>
<span class="line-added">850         public MethodHandle specializeBox(MethodHandle returnFilter) {</span>
<span class="line-added">851             throw new UnsupportedOperationException();</span>
<span class="line-added">852         }</span>
853     }
854 
855     /**
856      * DUP()
857      *   Duplicates the value on the top of the operand stack (without popping it!),
858      *   and pushes the duplicate onto the operand stack
859      */
860     public static class Dup extends Binding {
861         private static final Dup INSTANCE = new Dup();
862         private Dup() {
863             super(Tag.DUP);
864         }
865 
866         @Override
867         public String toString() {
868             return &quot;Dup{&quot; +
869                     &quot;tag=&quot; + tag() +
870                     &quot;}&quot;;
871         }
872 
873         @Override
874         public int hashCode() {
875             return tag().hashCode();
876         }
877 
878         @Override
879         public boolean equals(Object o) {
880             if (this == o) return true;
881             return o != null &amp;&amp; getClass() == o.getClass();
882         }
<span class="line-added">883 </span>
<span class="line-added">884         @Override</span>
<span class="line-added">885         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">886             stack.push(stack.peekLast());</span>
<span class="line-added">887         }</span>
<span class="line-added">888 </span>
<span class="line-added">889         @Override</span>
<span class="line-added">890         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {</span>
<span class="line-added">891             stack.push(stack.peekLast());</span>
<span class="line-added">892         }</span>
<span class="line-added">893 </span>
<span class="line-added">894         @Override</span>
<span class="line-added">895         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {</span>
<span class="line-added">896             stack.push(stack.peekLast());</span>
<span class="line-added">897         }</span>
<span class="line-added">898 </span>
<span class="line-added">899         @Override</span>
<span class="line-added">900         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {</span>
<span class="line-added">901             stack.push(stack.peekLast());</span>
<span class="line-added">902         }</span>
<span class="line-added">903 </span>
<span class="line-added">904         /*</span>
<span class="line-added">905          * Fixes up Y-shaped data graphs (produced by DEREFERENCE):</span>
<span class="line-added">906          *</span>
<span class="line-added">907          * 1. DUP()</span>
<span class="line-added">908          * 2. DEREFERENCE(0, int.class)</span>
<span class="line-added">909          * 3. MOVE  (ignored)</span>
<span class="line-added">910          * 4. DEREFERENCE(4, int.class)</span>
<span class="line-added">911          * 5. MOVE  (ignored)</span>
<span class="line-added">912          *</span>
<span class="line-added">913          * (specialized in reverse!)</span>
<span class="line-added">914          *</span>
<span class="line-added">915          * 5. (int, int) -&gt; void                       insertPos = 1</span>
<span class="line-added">916          * 4. (MemorySegment, int) -&gt; void             insertPos = 1</span>
<span class="line-added">917          * 3. (MemorySegment, int) -&gt; void             insertPos = 0</span>
<span class="line-added">918          * 2. (MemorySegment, MemorySegment) -&gt; void   insertPos = 0</span>
<span class="line-added">919          * 1. (MemorySegment) -&gt; void                  insertPos = 0</span>
<span class="line-added">920          *</span>
<span class="line-added">921          */</span>
<span class="line-added">922         @Override</span>
<span class="line-added">923         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {</span>
<span class="line-added">924             return mergeArguments(specializedHandle, insertPos, insertPos + 1);</span>
<span class="line-added">925         }</span>
<span class="line-added">926 </span>
<span class="line-added">927         /*</span>
<span class="line-added">928          * Fixes up Y-shaped data graphs (produced by DEREFERENCE):</span>
<span class="line-added">929          *</span>
<span class="line-added">930          * 1. ALLOCATE_BUFFER(4, 4)</span>
<span class="line-added">931          * 2. DUP</span>
<span class="line-added">932          * 3. MOVE  (ignored)</span>
<span class="line-added">933          * 4. DEREFERNCE(0, int.class)</span>
<span class="line-added">934          *</span>
<span class="line-added">935          * (specialized in reverse!)</span>
<span class="line-added">936          *</span>
<span class="line-added">937          * input: (MemorySegment) -&gt; MemorySegment (identity function of high-level return)</span>
<span class="line-added">938          * 4. (MemorySegment, MemorySegment, int) -&gt; MemorySegment</span>
<span class="line-added">939          * 3. (MemorySegment, MemorySegment, int) -&gt; MemorySegment</span>
<span class="line-added">940          * 2. (MemorySegment, int) -&gt; MemorySegment</span>
<span class="line-added">941          * 1. (int) -&gt; MemorySegment</span>
<span class="line-added">942          *</span>
<span class="line-added">943          */</span>
<span class="line-added">944         @Override</span>
<span class="line-added">945         public MethodHandle specializeBox(MethodHandle returnFilter) {</span>
<span class="line-added">946             // assumes shape like: (MS, ..., MS, T) R</span>
<span class="line-added">947             return mergeArguments(returnFilter, 0, returnFilter.type().parameterCount() - 2);</span>
<span class="line-added">948         }</span>
949     }
950 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BindingInterpreter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
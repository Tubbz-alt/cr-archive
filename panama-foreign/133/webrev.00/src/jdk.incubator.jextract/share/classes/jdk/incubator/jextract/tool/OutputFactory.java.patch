diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
@@ -35,10 +35,11 @@
 
 import javax.tools.JavaFileObject;
 import javax.tools.SimpleJavaFileObject;
 import java.io.IOException;
 import java.io.UncheckedIOException;
+import java.lang.constant.ClassDesc;
 import java.lang.invoke.MethodType;
 import java.net.URI;
 import java.net.URL;
 import java.net.URISyntaxException;
 import java.nio.file.Files;
@@ -60,17 +61,17 @@
     private final Set<String> constants = new HashSet<>();
     // To detect duplicate Variable and Function declarations.
     private final Set<Declaration.Variable> variables = new HashSet<>();
     private final Set<Declaration.Function> functions = new HashSet<>();
 
-    private final Set<String> structsAndVars = new HashSet<>();
-    private final Map<String, String> mangledNames = new HashMap<>();
-
-    protected final JavaSourceBuilder builder;
+    protected final HeaderBuilder builder;
+    protected final ConstantHelper constantHelper;
     protected final TypeTranslator typeTranslator = new TypeTranslator();
     private final String clsName;
     private final String pkgName;
+    private StructBuilder structBuilder;
+    private List<JavaFileObject> structFiles = new ArrayList<>();
 
     // have we seen this Variable earlier?
     protected boolean variableSeen(Declaration.Variable tree) {
         return !variables.add(tree);
     }
@@ -78,50 +79,24 @@
     // have we seen this Function earlier?
     protected boolean functionSeen(Declaration.Function tree) {
         return !functions.add(tree);
     }
 
-    // have we visited a struct/union or a global variable of given name?
-    protected boolean structOrVariableSeen(String name) {
-        return !structsAndVars.add(name);
-    }
-
-    private void setMangledName(String name, String prefix) {
-        if (!name.isEmpty() && structOrVariableSeen(name)) {
-            mangledNames.put(name, prefix + name);
-        }
-    }
-
-    protected void setMangledName(Declaration.Scoped d) {
-        switch (d.kind()) {
-            case STRUCT:
-                setMangledName(d.name(), "struct$");
-                break;
-            case UNION:
-                setMangledName(d.name(), "union$");
-                break;
-        }
-    }
-
-    protected void setMangledName(Declaration.Variable v) {
-        setMangledName(v.name(), "var$");
-    }
-
-    protected String getMangledName(Declaration d) {
-        String name = d.name();
-        return name.isEmpty()? name : mangledNames.getOrDefault(name, name);
-    }
-
     static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String clsName, String pkgName, List<String> libraryNames) {
-        return new OutputFactory(clsName, pkgName, libraryNames,
-                new JavaSourceBuilder(pkgName, libraryNames.toArray(String[]::new))).generate(decl);
+        String qualName = pkgName.isEmpty() ? clsName : pkgName + "." + clsName;
+        ConstantHelper constantHelper = new ConstantHelper(qualName,
+                ClassDesc.of(pkgName, "RuntimeHelper"), ClassDesc.of(pkgName, "Cstring"),
+                libraryNames.toArray(String[]::new));
+        return new OutputFactory(clsName, pkgName,
+                new HeaderBuilder(clsName, pkgName, constantHelper), constantHelper).generate(decl);
     }
 
-    public OutputFactory(String clsName, String pkgName, List<String> libraryNames, JavaSourceBuilder builder) {
+    public OutputFactory(String clsName, String pkgName, HeaderBuilder builder, ConstantHelper constantHelper) {
         this.clsName = clsName;
         this.pkgName = pkgName;
         this.builder = builder;
+        this.constantHelper = constantHelper;
     }
 
     private static String getCLangConstantsHolder() {
         String prefix = "jdk.incubator.foreign.MemoryLayouts.";
         String abi = SharedUtils.getSystemABI().name();
@@ -138,21 +113,22 @@
     }
 
     static final String C_LANG_CONSTANTS_HOLDER = getCLangConstantsHolder();
 
     public JavaFileObject[] generate(Declaration.Scoped decl) {
-        builder.classBegin(clsName);
+        builder.classBegin();
         //generate all decls
         decl.members().forEach(this::generateDecl);
 
         builder.classEnd();
         List<JavaFileObject> outputs = builder.build();
         try {
             List<JavaFileObject> files = new ArrayList<>(outputs);
             files.add(fileFromString(pkgName,"RuntimeHelper", getRuntimeHelperSource()));
             files.add(getCstringFile(pkgName));
             files.addAll(getPrimitiveTypeFiles(pkgName));
+            files.addAll(structFiles);
             return files.toArray(new JavaFileObject[0]);
         } catch (IOException ex) {
             throw new UncheckedIOException(ex);
         } catch (URISyntaxException ex2) {
             throw new RuntimeException(ex2);
@@ -245,30 +221,35 @@
         }
         if (d.layout().isEmpty()) {
             //skip decl-only
             return null;
         }
-        String name;
-        // FIXME: we need tree transformer. The mangling should be a separate tree transform phase
-        if (d.name().isEmpty() && parent != null) {
-            name = getMangledName(parent);
-        } else {
-            setMangledName(d);
-            name = getMangledName(d);
+        String name = d.name();
+        if (name.isEmpty() && parent != null) {
+            name = parent.name();
         }
 
+        boolean structClass = false;
         if (!d.name().isEmpty() || !isRecord(parent)) {
             //only add explicit struct layout if the struct is not to be flattened inside another struct
             switch (d.kind()) {
                 case STRUCT:
                 case UNION: {
-                    builder.addLayoutGetter(Utils.javaSafeIdentifier(name), d.layout().get());
+                    structClass = true;
+                    this.structBuilder = new StructBuilder("C" + name, pkgName, constantHelper);
+                    structBuilder.classBegin();
+                    structBuilder.addLayoutGetter("C" + name, d.layout().get());
                     break;
                 }
             }
         }
         d.members().forEach(fieldTree -> fieldTree.accept(this, d.name().isEmpty() ? parent : d));
+        if (structClass) {
+            this.structBuilder.classEnd();
+            structFiles.add(structBuilder.build());
+            this.structBuilder = null;
+        }
         return null;
     }
 
     @Override
     public Void visitFunction(Declaration.Function funcTree, Declaration parent) {
@@ -336,12 +317,11 @@
         assert !symbol.isEmpty();
         assert !fieldName.isEmpty();
 
         // FIXME: we need tree transformer. The mangling should be a separate tree transform phase
         if (parent == null) {
-            setMangledName(tree);
-            fieldName = getMangledName(tree);
+            fieldName = tree.name();
         }
         fieldName = Utils.javaSafeIdentifier(fieldName);
 
         Type type = tree.type();
         MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));
@@ -357,16 +337,14 @@
         }
 
         MemoryLayout treeLayout = tree.layout().orElseThrow();
         if (parent != null) { //struct field
             Declaration.Scoped parentC = (Declaration.Scoped) parent;
-            String parentName = Utils.javaSafeIdentifier(getMangledName(parentC));
-            fieldName = parentName + "$" + fieldName;
             MemoryLayout parentLayout = parentLayout(parentC);
-            builder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
-            builder.addGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
-            builder.addSetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+            structBuilder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+            structBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+            structBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
         } else {
             builder.addLayoutGetter(fieldName, layout);
             builder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, null);
             builder.addAddressGetter(fieldName, tree.name());
             builder.addGetter(fieldName, tree.name(), treeLayout, clazz, null);

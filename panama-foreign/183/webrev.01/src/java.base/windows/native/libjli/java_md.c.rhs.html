<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/windows/native/libjli/java_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;windows.h&gt;
  27 #include &lt;io.h&gt;
  28 #include &lt;process.h&gt;
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;stdio.h&gt;
  31 #include &lt;stdarg.h&gt;
  32 #include &lt;string.h&gt;
  33 #include &lt;sys/types.h&gt;
  34 #include &lt;sys/stat.h&gt;
  35 #include &lt;wtypes.h&gt;
  36 #include &lt;commctrl.h&gt;
  37 #include &lt;assert.h&gt;
  38 
  39 #include &lt;jni.h&gt;
  40 #include &quot;java.h&quot;
  41 
  42 #define JVM_DLL &quot;jvm.dll&quot;
  43 #define JAVA_DLL &quot;java.dll&quot;
  44 
  45 /*
  46  * Prototypes.
  47  */
  48 static jboolean GetJVMPath(const char *jrepath, const char *jvmtype,
  49                            char *jvmpath, jint jvmpathsize);
  50 static jboolean GetJREPath(char *path, jint pathsize);
  51 
  52 #ifdef USE_REGISTRY_LOOKUP
  53 jboolean GetPublicJREHome(char *buf, jint bufsize);
  54 #endif
  55 
  56 /* We supports warmup for UI stack that is performed in parallel
  57  * to VM initialization.
  58  * This helps to improve startup of UI application as warmup phase
  59  * might be long due to initialization of OS or hardware resources.
  60  * It is not CPU bound and therefore it does not interfere with VM init.
  61  * Obviously such warmup only has sense for UI apps and therefore it needs
  62  * to be explicitly requested by passing -Dsun.awt.warmup=true property
  63  * (this is always the case for plugin/javaws).
  64  *
  65  * Implementation launches new thread after VM starts and use it to perform
  66  * warmup code (platform dependent).
  67  * This thread is later reused as AWT toolkit thread as graphics toolkit
  68  * often assume that they are used from the same thread they were launched on.
  69  *
  70  * At the moment we only support warmup for D3D. It only possible on windows
  71  * and only if other flags do not prohibit this (e.g. OpenGL support requested).
  72  */
  73 #undef ENABLE_AWT_PRELOAD
  74 #ifndef JAVA_ARGS /* turn off AWT preloading for javac, jar, etc */
  75     /* CR6999872: fastdebug crashes if awt library is loaded before JVM is
  76      * initialized*/
  77     #if !defined(DEBUG)
  78         #define ENABLE_AWT_PRELOAD
  79     #endif
  80 #endif
  81 
  82 #ifdef ENABLE_AWT_PRELOAD
  83 /* &quot;AWT was preloaded&quot; flag;
  84  * turned on by AWTPreload().
  85  */
  86 int awtPreloaded = 0;
  87 
  88 /* Calls a function with the name specified
  89  * the function must be int(*fn)(void).
  90  */
  91 int AWTPreload(const char *funcName);
  92 /* stops AWT preloading */
  93 void AWTPreloadStop();
  94 
  95 /* D3D preloading */
  96 /* -1: not initialized; 0: OFF, 1: ON */
  97 int awtPreloadD3D = -1;
  98 /* command line parameter to swith D3D preloading on */
  99 #define PARAM_PRELOAD_D3D &quot;-Dsun.awt.warmup&quot;
 100 /* D3D/OpenGL management parameters */
 101 #define PARAM_NODDRAW &quot;-Dsun.java2d.noddraw&quot;
 102 #define PARAM_D3D &quot;-Dsun.java2d.d3d&quot;
 103 #define PARAM_OPENGL &quot;-Dsun.java2d.opengl&quot;
 104 /* funtion in awt.dll (src/windows/native/sun/java2d/d3d/D3DPipelineManager.cpp) */
 105 #define D3D_PRELOAD_FUNC &quot;preloadD3D&quot;
 106 
 107 /* Extracts value of a parameter with the specified name
 108  * from command line argument (returns pointer in the argument).
 109  * Returns NULL if the argument does not contains the parameter.
 110  * e.g.:
 111  * GetParamValue(&quot;theParam&quot;, &quot;theParam=value&quot;) returns pointer to &quot;value&quot;.
 112  */
 113 const char * GetParamValue(const char *paramName, const char *arg) {
 114     size_t nameLen = JLI_StrLen(paramName);
 115     if (JLI_StrNCmp(paramName, arg, nameLen) == 0) {
 116         /* arg[nameLen] is valid (may contain final NULL) */
 117         if (arg[nameLen] == &#39;=&#39;) {
 118             return arg + nameLen + 1;
 119         }
 120     }
 121     return NULL;
 122 }
 123 
 124 /* Checks if commandline argument contains property specified
 125  * and analyze it as boolean property (true/false).
 126  * Returns -1 if the argument does not contain the parameter;
 127  * Returns 1 if the argument contains the parameter and its value is &quot;true&quot;;
 128  * Returns 0 if the argument contains the parameter and its value is &quot;false&quot;.
 129  */
 130 int GetBoolParamValue(const char *paramName, const char *arg) {
 131     const char * paramValue = GetParamValue(paramName, arg);
 132     if (paramValue != NULL) {
 133         if (JLI_StrCaseCmp(paramValue, &quot;true&quot;) == 0) {
 134             return 1;
 135         }
 136         if (JLI_StrCaseCmp(paramValue, &quot;false&quot;) == 0) {
 137             return 0;
 138         }
 139     }
 140     return -1;
 141 }
 142 #endif /* ENABLE_AWT_PRELOAD */
 143 
 144 
 145 static jboolean _isjavaw = JNI_FALSE;
 146 
 147 
 148 jboolean
 149 IsJavaw()
 150 {
 151     return _isjavaw;
 152 }
 153 
 154 /*
 155  *
 156  */
 157 void
 158 CreateExecutionEnvironment(int *pargc, char ***pargv,
 159                            char *jrepath, jint so_jrepath,
 160                            char *jvmpath, jint so_jvmpath,
 161                            char *jvmcfg,  jint so_jvmcfg) {
 162 
 163     char *jvmtype;
 164     int i = 0;
 165     char** argv = *pargv;
 166 
 167     /* Find out where the JRE is that we will be using. */
 168     if (!GetJREPath(jrepath, so_jrepath)) {
 169         JLI_ReportErrorMessage(JRE_ERROR1);
 170         exit(2);
 171     }
 172 
 173     JLI_Snprintf(jvmcfg, so_jvmcfg, &quot;%s%slib%sjvm.cfg&quot;,
 174         jrepath, FILESEP, FILESEP);
 175 
 176     /* Find the specified JVM type */
 177     if (ReadKnownVMs(jvmcfg, JNI_FALSE) &lt; 1) {
 178         JLI_ReportErrorMessage(CFG_ERROR7);
 179         exit(1);
 180     }
 181 
 182     jvmtype = CheckJvmType(pargc, pargv, JNI_FALSE);
 183     if (JLI_StrCmp(jvmtype, &quot;ERROR&quot;) == 0) {
 184         JLI_ReportErrorMessage(CFG_ERROR9);
 185         exit(4);
 186     }
 187 
 188     jvmpath[0] = &#39;\0&#39;;
 189     if (!GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath)) {
 190         JLI_ReportErrorMessage(CFG_ERROR8, jvmtype, jvmpath);
 191         exit(4);
 192     }
 193     /* If we got here, jvmpath has been correctly initialized. */
 194 
 195     /* Check if we need preload AWT */
 196 #ifdef ENABLE_AWT_PRELOAD
 197     argv = *pargv;
 198     for (i = 0; i &lt; *pargc ; i++) {
 199         /* Tests the &quot;turn on&quot; parameter only if not set yet. */
 200         if (awtPreloadD3D &lt; 0) {
 201             if (GetBoolParamValue(PARAM_PRELOAD_D3D, argv[i]) == 1) {
 202                 awtPreloadD3D = 1;
 203             }
 204         }
 205         /* Test parameters which can disable preloading if not already disabled. */
 206         if (awtPreloadD3D != 0) {
 207             if (GetBoolParamValue(PARAM_NODDRAW, argv[i]) == 1
 208                 || GetBoolParamValue(PARAM_D3D, argv[i]) == 0
 209                 || GetBoolParamValue(PARAM_OPENGL, argv[i]) == 1)
 210             {
 211                 awtPreloadD3D = 0;
 212                 /* no need to test the rest of the parameters */
 213                 break;
 214             }
 215         }
 216     }
 217 #endif /* ENABLE_AWT_PRELOAD */
 218 }
 219 
 220 
 221 static jboolean
 222 LoadMSVCRT()
 223 {
 224     // Only do this once
 225     static int loaded = 0;
 226     char crtpath[MAXPATHLEN];
 227 
 228     if (!loaded) {
 229         /*
 230          * The Microsoft C Runtime Library needs to be loaded first.  A copy is
 231          * assumed to be present in the &quot;JRE path&quot; directory.  If it is not found
 232          * there (or &quot;JRE path&quot; fails to resolve), skip the explicit load and let
 233          * nature take its course, which is likely to be a failure to execute.
 234          * The makefiles will provide the correct lib contained in quotes in the
 235          * macro MSVCR_DLL_NAME.
 236          */
 237 #ifdef MSVCR_DLL_NAME
 238         if (GetJREPath(crtpath, MAXPATHLEN)) {
 239             if (JLI_StrLen(crtpath) + JLI_StrLen(&quot;\\bin\\&quot;) +
 240                     JLI_StrLen(MSVCR_DLL_NAME) &gt;= MAXPATHLEN) {
 241                 JLI_ReportErrorMessage(JRE_ERROR11);
 242                 return JNI_FALSE;
 243             }
 244             (void)JLI_StrCat(crtpath, &quot;\\bin\\&quot; MSVCR_DLL_NAME);   /* Add crt dll */
 245             JLI_TraceLauncher(&quot;CRT path is %s\n&quot;, crtpath);
 246             if (_access(crtpath, 0) == 0) {
 247                 if (LoadLibrary(crtpath) == 0) {
 248                     JLI_ReportErrorMessage(DLL_ERROR4, crtpath);
 249                     return JNI_FALSE;
 250                 }
 251             }
 252         }
 253 #endif /* MSVCR_DLL_NAME */
 254 #ifdef VCRUNTIME_1_DLL_NAME
 255         if (GetJREPath(crtpath, MAXPATHLEN)) {
 256             if (JLI_StrLen(crtpath) + JLI_StrLen(&quot;\\bin\\&quot;) +
 257                     JLI_StrLen(VCRUNTIME_1_DLL_NAME) &gt;= MAXPATHLEN) {
 258                 JLI_ReportErrorMessage(JRE_ERROR11);
 259                 return JNI_FALSE;
 260             }
 261             (void)JLI_StrCat(crtpath, &quot;\\bin\\&quot; VCRUNTIME_1_DLL_NAME);   /* Add crt dll */
 262             JLI_TraceLauncher(&quot;CRT path is %s\n&quot;, crtpath);
 263             if (_access(crtpath, 0) == 0) {
 264                 if (LoadLibrary(crtpath) == 0) {
 265                     JLI_ReportErrorMessage(DLL_ERROR4, crtpath);
 266                     return JNI_FALSE;
 267                 }
 268             }
 269         }
 270 #endif /* VCRUNTIME_1_DLL_NAME */
 271 #ifdef MSVCP_DLL_NAME
 272         if (GetJREPath(crtpath, MAXPATHLEN)) {
 273             if (JLI_StrLen(crtpath) + JLI_StrLen(&quot;\\bin\\&quot;) +
 274                     JLI_StrLen(MSVCP_DLL_NAME) &gt;= MAXPATHLEN) {
 275                 JLI_ReportErrorMessage(JRE_ERROR11);
 276                 return JNI_FALSE;
 277             }
 278             (void)JLI_StrCat(crtpath, &quot;\\bin\\&quot; MSVCP_DLL_NAME);   /* Add prt dll */
 279             JLI_TraceLauncher(&quot;PRT path is %s\n&quot;, crtpath);
 280             if (_access(crtpath, 0) == 0) {
 281                 if (LoadLibrary(crtpath) == 0) {
 282                     JLI_ReportErrorMessage(DLL_ERROR4, crtpath);
 283                     return JNI_FALSE;
 284                 }
 285             }
 286         }
 287 #endif /* MSVCP_DLL_NAME */
 288         loaded = 1;
 289     }
 290     return JNI_TRUE;
 291 }
 292 
 293 
 294 /*
 295  * Find path to JRE based on .exe&#39;s location or registry settings.
 296  */
 297 jboolean
 298 GetJREPath(char *path, jint pathsize)
 299 {
 300     char javadll[MAXPATHLEN];
 301     struct stat s;
 302 
 303     if (GetApplicationHome(path, pathsize)) {
 304         /* Is JRE co-located with the application? */
 305         JLI_Snprintf(javadll, sizeof(javadll), &quot;%s\\bin\\&quot; JAVA_DLL, path);
 306         if (stat(javadll, &amp;s) == 0) {
 307             JLI_TraceLauncher(&quot;JRE path is %s\n&quot;, path);
 308             return JNI_TRUE;
 309         }
 310         /* ensure storage for path + \jre + NULL */
 311         if ((JLI_StrLen(path) + 4 + 1) &gt; (size_t) pathsize) {
 312             JLI_TraceLauncher(&quot;Insufficient space to store JRE path\n&quot;);
 313             return JNI_FALSE;
 314         }
 315         /* Does this app ship a private JRE in &lt;apphome&gt;\jre directory? */
 316         JLI_Snprintf(javadll, sizeof (javadll), &quot;%s\\jre\\bin\\&quot; JAVA_DLL, path);
 317         if (stat(javadll, &amp;s) == 0) {
 318             JLI_StrCat(path, &quot;\\jre&quot;);
 319             JLI_TraceLauncher(&quot;JRE path is %s\n&quot;, path);
 320             return JNI_TRUE;
 321         }
 322     }
 323 
 324     /* Try getting path to JRE from path to JLI.DLL */
 325     if (GetApplicationHomeFromDll(path, pathsize)) {
 326         JLI_Snprintf(javadll, sizeof(javadll), &quot;%s\\bin\\&quot; JAVA_DLL, path);
 327         if (stat(javadll, &amp;s) == 0) {
 328             JLI_TraceLauncher(&quot;JRE path is %s\n&quot;, path);
 329             return JNI_TRUE;
 330         }
 331     }
 332 
 333 #ifdef USE_REGISTRY_LOOKUP
 334     /* Lookup public JRE using Windows registry. */
 335     if (GetPublicJREHome(path, pathsize)) {
 336         JLI_TraceLauncher(&quot;JRE path is %s\n&quot;, path);
 337         return JNI_TRUE;
 338     }
 339 #endif
 340 
 341     JLI_ReportErrorMessage(JRE_ERROR8 JAVA_DLL);
 342     return JNI_FALSE;
 343 }
 344 
 345 /*
 346  * Given a JRE location and a JVM type, construct what the name the
 347  * JVM shared library will be.  Return true, if such a library
 348  * exists, false otherwise.
 349  */
 350 static jboolean
 351 GetJVMPath(const char *jrepath, const char *jvmtype,
 352            char *jvmpath, jint jvmpathsize)
 353 {
 354     struct stat s;
 355     if (JLI_StrChr(jvmtype, &#39;/&#39;) || JLI_StrChr(jvmtype, &#39;\\&#39;)) {
 356         JLI_Snprintf(jvmpath, jvmpathsize, &quot;%s\\&quot; JVM_DLL, jvmtype);
 357     } else {
 358         JLI_Snprintf(jvmpath, jvmpathsize, &quot;%s\\bin\\%s\\&quot; JVM_DLL,
 359                      jrepath, jvmtype);
 360     }
 361     if (stat(jvmpath, &amp;s) == 0) {
 362         return JNI_TRUE;
 363     } else {
 364         return JNI_FALSE;
 365     }
 366 }
 367 
 368 /*
 369  * Load a jvm from &quot;jvmpath&quot; and initialize the invocation functions.
 370  */
 371 jboolean
 372 LoadJavaVM(const char *jvmpath, InvocationFunctions *ifn)
 373 {
 374     HINSTANCE handle;
 375 
 376     JLI_TraceLauncher(&quot;JVM path is %s\n&quot;, jvmpath);
 377 
 378     /*
 379      * The Microsoft C Runtime Library needs to be loaded first.  A copy is
 380      * assumed to be present in the &quot;JRE path&quot; directory.  If it is not found
 381      * there (or &quot;JRE path&quot; fails to resolve), skip the explicit load and let
 382      * nature take its course, which is likely to be a failure to execute.
 383      *
 384      */
 385     LoadMSVCRT();
 386 
 387     /* Load the Java VM DLL */
 388     if ((handle = LoadLibrary(jvmpath)) == 0) {
 389         JLI_ReportErrorMessage(DLL_ERROR4, (char *)jvmpath);
 390         return JNI_FALSE;
 391     }
 392 
 393     /* Now get the function addresses */
 394     ifn-&gt;CreateJavaVM =
 395         (void *)GetProcAddress(handle, &quot;JNI_CreateJavaVM&quot;);
 396     ifn-&gt;GetDefaultJavaVMInitArgs =
 397         (void *)GetProcAddress(handle, &quot;JNI_GetDefaultJavaVMInitArgs&quot;);
 398     if (ifn-&gt;CreateJavaVM == 0 || ifn-&gt;GetDefaultJavaVMInitArgs == 0) {
 399         JLI_ReportErrorMessage(JNI_ERROR1, (char *)jvmpath);
 400         return JNI_FALSE;
 401     }
 402 
 403     return JNI_TRUE;
 404 }
 405 
 406 /*
 407  * Removes the trailing file name and one sub-folder from a path.
 408  * If buf is &quot;c:\foo\bin\javac&quot;, then put &quot;c:\foo&quot; into buf.
 409  */
 410 jboolean
 411 TruncatePath(char *buf)
 412 {
 413     char *cp;
 414     *JLI_StrRChr(buf, &#39;\\&#39;) = &#39;\0&#39;; /* remove .exe file name */
 415     if ((cp = JLI_StrRChr(buf, &#39;\\&#39;)) == 0) {
 416         /* This happens if the application is in a drive root, and
 417          * there is no bin directory. */
 418         buf[0] = &#39;\0&#39;;
 419         return JNI_FALSE;
 420     }
 421     *cp = &#39;\0&#39;; /* remove the bin\ part */
 422     return JNI_TRUE;
 423 }
 424 
 425 /*
 426  * Retrieves the path to the JRE home by locating the executable file
 427  * of the current process and then truncating the path to the executable
 428  */
 429 jboolean
 430 GetApplicationHome(char *buf, jint bufsize)
 431 {
 432     GetModuleFileName(NULL, buf, bufsize);
 433     return TruncatePath(buf);
 434 }
 435 
 436 /*
 437  * Retrieves the path to the JRE home by locating JLI.DLL and
 438  * then truncating the path to JLI.DLL
 439  */
 440 jboolean
 441 GetApplicationHomeFromDll(char *buf, jint bufsize)
 442 {
 443     HMODULE module;
 444     DWORD flags = GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
 445                   GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT;
 446 
 447     if (GetModuleHandleEx(flags, (LPCSTR)&amp;GetJREPath, &amp;module) != 0) {
 448         if (GetModuleFileName(module, buf, bufsize) != 0) {
 449             return TruncatePath(buf);
 450         }
 451     }
 452     return JNI_FALSE;
 453 }
 454 
 455 /*
 456  * Support for doing cheap, accurate interval timing.
 457  */
 458 static jboolean counterAvailable = JNI_FALSE;
 459 static jboolean counterInitialized = JNI_FALSE;
 460 static LARGE_INTEGER counterFrequency;
 461 
<a name="1" id="anc1"></a><span class="line-modified"> 462 jlong CurrentTimeMicros()</span>
 463 {
 464     LARGE_INTEGER count;
 465 
 466     if (!counterInitialized) {
 467         counterAvailable = QueryPerformanceFrequency(&amp;counterFrequency);
 468         counterInitialized = JNI_TRUE;
 469     }
 470     if (!counterAvailable) {
 471         return 0;
 472     }
 473     QueryPerformanceCounter(&amp;count);
<a name="2" id="anc2"></a>

 474 
<a name="3" id="anc3"></a><span class="line-modified"> 475     return (jlong)(count.QuadPart * 1000 * 1000 / counterFrequency.QuadPart);</span>





 476 }
<a name="4" id="anc4"></a><span class="line-added"> 477 </span>
 478 /*
 479  * windows snprintf does not guarantee a null terminator in the buffer,
 480  * if the computed size is equal to or greater than the buffer size,
 481  * as well as error conditions. This function guarantees a null terminator
 482  * under all these conditions. An unreasonable buffer or size will return
 483  * an error value. Under all other conditions this function will return the
 484  * size of the bytes actually written minus the null terminator, similar
 485  * to ansi snprintf api. Thus when calling this function the caller must
 486  * ensure storage for the null terminator.
 487  */
 488 int
 489 JLI_Snprintf(char* buffer, size_t size, const char* format, ...) {
 490     int rc;
 491     va_list vl;
 492     if (size == 0 || buffer == NULL)
 493         return -1;
 494     buffer[0] = &#39;\0&#39;;
 495     va_start(vl, format);
 496     rc = vsnprintf(buffer, size, format, vl);
 497     va_end(vl);
 498     /* force a null terminator, if something is amiss */
 499     if (rc &lt; 0) {
 500         /* apply ansi semantics */
 501         buffer[size - 1] = &#39;\0&#39;;
 502         return (int)size;
 503     } else if (rc == size) {
 504         /* force a null terminator */
 505         buffer[size - 1] = &#39;\0&#39;;
 506     }
 507     return rc;
 508 }
 509 
 510 static errno_t convert_to_unicode(const char* path, const wchar_t* prefix, wchar_t** wpath) {
 511     int unicode_path_len;
 512     size_t prefix_len, wpath_len;
 513 
 514     /*
 515      * Get required buffer size to convert to Unicode.
 516      * The return value includes the terminating null character.
 517      */
 518     unicode_path_len = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS,
 519                                            path, -1, NULL, 0);
 520     if (unicode_path_len == 0) {
 521         return EINVAL;
 522     }
 523 
 524     prefix_len = wcslen(prefix);
 525     wpath_len = prefix_len + unicode_path_len;
 526     *wpath = (wchar_t*)JLI_MemAlloc(wpath_len * sizeof(wchar_t));
 527     if (*wpath == NULL) {
 528         return ENOMEM;
 529     }
 530 
 531     wcsncpy(*wpath, prefix, prefix_len);
 532     if (MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS,
 533                             path, -1, &amp;((*wpath)[prefix_len]), (int)wpath_len) == 0) {
 534         JLI_MemFree(*wpath);
 535         *wpath = NULL;
 536         return EINVAL;
 537     }
 538 
 539     return ERROR_SUCCESS;
 540 }
 541 
 542 /* taken from hotspot and slightly adjusted for jli lib;
 543  * creates a UNC/ELP path from input &#39;path&#39;
 544  * the return buffer is allocated in C heap and needs to be freed using
 545  * JLI_MemFree by the caller.
 546  */
 547 static wchar_t* create_unc_path(const char* path, errno_t* err) {
 548     wchar_t* wpath = NULL;
 549     size_t converted_chars = 0;
 550     size_t path_len = strlen(path) + 1; /* includes the terminating NULL */
 551     if (path[0] == &#39;\\&#39; &amp;&amp; path[1] == &#39;\\&#39;) {
 552         if (path[2] == &#39;?&#39; &amp;&amp; path[3] == &#39;\\&#39;) {
 553             /* if it already has a \\?\ don&#39;t do the prefix */
 554             *err = convert_to_unicode(path, L&quot;&quot;, &amp;wpath);
 555         } else {
 556             /* only UNC pathname includes double slashes here */
 557             *err = convert_to_unicode(path, L&quot;\\\\?\\UNC&quot;, &amp;wpath);
 558         }
 559     } else {
 560         *err = convert_to_unicode(path, L&quot;\\\\?\\&quot;, &amp;wpath);
 561     }
 562     return wpath;
 563 }
 564 
 565 int JLI_Open(const char* name, int flags) {
 566     int fd;
 567     if (strlen(name) &lt; MAX_PATH) {
 568         fd = _open(name, flags);
 569     } else {
 570         errno_t err = ERROR_SUCCESS;
 571         wchar_t* wpath = create_unc_path(name, &amp;err);
 572         if (err != ERROR_SUCCESS) {
 573             if (wpath != NULL) JLI_MemFree(wpath);
 574             errno = err;
 575             return -1;
 576         }
 577         fd = _wopen(wpath, flags);
 578         if (fd == -1) {
 579             errno = GetLastError();
 580         }
 581         JLI_MemFree(wpath);
 582     }
 583     return fd;
 584 }
 585 
 586 JNIEXPORT void JNICALL
 587 JLI_ReportErrorMessage(const char* fmt, ...) {
 588     va_list vl;
 589     va_start(vl,fmt);
 590 
 591     if (IsJavaw()) {
 592         char *message;
 593 
 594         /* get the length of the string we need */
 595         int n = _vscprintf(fmt, vl);
 596 
 597         message = (char *)JLI_MemAlloc(n + 1);
 598         _vsnprintf(message, n, fmt, vl);
 599         message[n]=&#39;\0&#39;;
 600         MessageBox(NULL, message, &quot;Java Virtual Machine Launcher&quot;,
 601             (MB_OK|MB_ICONSTOP|MB_APPLMODAL));
 602         JLI_MemFree(message);
 603     } else {
 604         vfprintf(stderr, fmt, vl);
 605         fprintf(stderr, &quot;\n&quot;);
 606     }
 607     va_end(vl);
 608 }
 609 
 610 /*
 611  * Just like JLI_ReportErrorMessage, except that it concatenates the system
 612  * error message if any, its upto the calling routine to correctly
 613  * format the separation of the messages.
 614  */
 615 JNIEXPORT void JNICALL
 616 JLI_ReportErrorMessageSys(const char *fmt, ...)
 617 {
 618     va_list vl;
 619 
 620     int save_errno = errno;
 621     DWORD       errval;
 622     jboolean freeit = JNI_FALSE;
 623     char  *errtext = NULL;
 624 
 625     va_start(vl, fmt);
 626 
 627     if ((errval = GetLastError()) != 0) {               /* Platform SDK / DOS Error */
 628         int n = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|
 629             FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_ALLOCATE_BUFFER,
 630             NULL, errval, 0, (LPTSTR)&amp;errtext, 0, NULL);
 631         if (errtext == NULL || n == 0) {                /* Paranoia check */
 632             errtext = &quot;&quot;;
 633             n = 0;
 634         } else {
 635             freeit = JNI_TRUE;
 636             if (n &gt; 2) {                                /* Drop final CR, LF */
 637                 if (errtext[n - 1] == &#39;\n&#39;) n--;
 638                 if (errtext[n - 1] == &#39;\r&#39;) n--;
 639                 errtext[n] = &#39;\0&#39;;
 640             }
 641         }
 642     } else {   /* C runtime error that has no corresponding DOS error code */
 643         errtext = strerror(save_errno);
 644     }
 645 
 646     if (IsJavaw()) {
 647         char *message;
 648         int mlen;
 649         /* get the length of the string we need */
 650         int len = mlen =  _vscprintf(fmt, vl) + 1;
 651         if (freeit) {
 652            mlen += (int)JLI_StrLen(errtext);
 653         }
 654 
 655         message = (char *)JLI_MemAlloc(mlen);
 656         _vsnprintf(message, len, fmt, vl);
 657         message[len]=&#39;\0&#39;;
 658 
 659         if (freeit) {
 660            JLI_StrCat(message, errtext);
 661         }
 662 
 663         MessageBox(NULL, message, &quot;Java Virtual Machine Launcher&quot;,
 664             (MB_OK|MB_ICONSTOP|MB_APPLMODAL));
 665 
 666         JLI_MemFree(message);
 667     } else {
 668         vfprintf(stderr, fmt, vl);
 669         if (freeit) {
 670            fprintf(stderr, &quot;%s&quot;, errtext);
 671         }
 672     }
 673     if (freeit) {
 674         (void)LocalFree((HLOCAL)errtext);
 675     }
 676     va_end(vl);
 677 }
 678 
 679 JNIEXPORT void JNICALL
 680 JLI_ReportExceptionDescription(JNIEnv * env) {
 681     if (IsJavaw()) {
 682        /*
 683         * This code should be replaced by code which opens a window with
 684         * the exception detail message, for now atleast put a dialog up.
 685         */
 686         MessageBox(NULL, &quot;A Java Exception has occurred.&quot;, &quot;Java Virtual Machine Launcher&quot;,
 687                (MB_OK|MB_ICONSTOP|MB_APPLMODAL));
 688     } else {
 689         (*env)-&gt;ExceptionDescribe(env);
 690     }
 691 }
 692 
 693 /*
 694  * Wrapper for platform dependent unsetenv function.
 695  */
 696 int
 697 UnsetEnv(char *name)
 698 {
 699     int ret;
 700     char *buf = JLI_MemAlloc(JLI_StrLen(name) + 2);
 701     buf = JLI_StrCat(JLI_StrCpy(buf, name), &quot;=&quot;);
 702     ret = _putenv(buf);
 703     JLI_MemFree(buf);
 704     return (ret);
 705 }
 706 
 707 /* --- Splash Screen shared library support --- */
 708 
 709 static const char* SPLASHSCREEN_SO = &quot;\\bin\\splashscreen.dll&quot;;
 710 
 711 static HMODULE hSplashLib = NULL;
 712 
 713 void* SplashProcAddress(const char* name) {
 714     char libraryPath[MAXPATHLEN]; /* some extra space for JLI_StrCat&#39;ing SPLASHSCREEN_SO */
 715 
 716     if (!GetJREPath(libraryPath, MAXPATHLEN)) {
 717         return NULL;
 718     }
 719     if (JLI_StrLen(libraryPath)+JLI_StrLen(SPLASHSCREEN_SO) &gt;= MAXPATHLEN) {
 720         return NULL;
 721     }
 722     JLI_StrCat(libraryPath, SPLASHSCREEN_SO);
 723 
 724     if (!hSplashLib) {
 725         hSplashLib = LoadLibrary(libraryPath);
 726     }
 727     if (hSplashLib) {
 728         return GetProcAddress(hSplashLib, name);
 729     } else {
 730         return NULL;
 731     }
 732 }
 733 
 734 /*
 735  * Signature adapter for _beginthreadex().
 736  */
 737 static unsigned __stdcall ThreadJavaMain(void* args) {
 738     return (unsigned)JavaMain(args);
 739 }
 740 
 741 /*
 742  * Block current thread and continue execution in a new thread.
 743  */
 744 int
 745 CallJavaMainInNewThread(jlong stack_size, void* args) {
 746     int rslt = 0;
 747     unsigned thread_id;
 748 
 749 #ifndef STACK_SIZE_PARAM_IS_A_RESERVATION
 750 #define STACK_SIZE_PARAM_IS_A_RESERVATION  (0x10000)
 751 #endif
 752 
 753     /*
 754      * STACK_SIZE_PARAM_IS_A_RESERVATION is what we want, but it&#39;s not
 755      * supported on older version of Windows. Try first with the flag; and
 756      * if that fails try again without the flag. See MSDN document or HotSpot
 757      * source (os_win32.cpp) for details.
 758      */
 759     HANDLE thread_handle =
 760         (HANDLE)_beginthreadex(NULL,
 761                                (unsigned)stack_size,
 762                                ThreadJavaMain,
 763                                args,
 764                                STACK_SIZE_PARAM_IS_A_RESERVATION,
 765                                &amp;thread_id);
 766     if (thread_handle == NULL) {
 767         thread_handle =
 768         (HANDLE)_beginthreadex(NULL,
 769                                (unsigned)stack_size,
 770                                ThreadJavaMain,
 771                                args,
 772                                0,
 773                                &amp;thread_id);
 774     }
 775 
 776     /* AWT preloading (AFTER main thread start) */
 777 #ifdef ENABLE_AWT_PRELOAD
 778     /* D3D preloading */
 779     if (awtPreloadD3D != 0) {
 780         char *envValue;
 781         /* D3D routines checks env.var J2D_D3D if no appropriate
 782          * command line params was specified
 783          */
 784         envValue = getenv(&quot;J2D_D3D&quot;);
 785         if (envValue != NULL &amp;&amp; JLI_StrCaseCmp(envValue, &quot;false&quot;) == 0) {
 786             awtPreloadD3D = 0;
 787         }
 788         /* Test that AWT preloading isn&#39;t disabled by J2D_D3D_PRELOAD env.var */
 789         envValue = getenv(&quot;J2D_D3D_PRELOAD&quot;);
 790         if (envValue != NULL &amp;&amp; JLI_StrCaseCmp(envValue, &quot;false&quot;) == 0) {
 791             awtPreloadD3D = 0;
 792         }
 793         if (awtPreloadD3D &lt; 0) {
 794             /* If awtPreloadD3D is still undefined (-1), test
 795              * if it is turned on by J2D_D3D_PRELOAD env.var.
 796              * By default it&#39;s turned OFF.
 797              */
 798             awtPreloadD3D = 0;
 799             if (envValue != NULL &amp;&amp; JLI_StrCaseCmp(envValue, &quot;true&quot;) == 0) {
 800                 awtPreloadD3D = 1;
 801             }
 802          }
 803     }
 804     if (awtPreloadD3D) {
 805         AWTPreload(D3D_PRELOAD_FUNC);
 806     }
 807 #endif /* ENABLE_AWT_PRELOAD */
 808 
 809     if (thread_handle) {
 810         WaitForSingleObject(thread_handle, INFINITE);
 811         GetExitCodeThread(thread_handle, &amp;rslt);
 812         CloseHandle(thread_handle);
 813     } else {
 814         rslt = JavaMain(args);
 815     }
 816 
 817 #ifdef ENABLE_AWT_PRELOAD
 818     if (awtPreloaded) {
 819         AWTPreloadStop();
 820     }
 821 #endif /* ENABLE_AWT_PRELOAD */
 822 
 823     return rslt;
 824 }
 825 
 826 /*
 827  * The implementation for finding classes from the bootstrap
 828  * class loader, refer to java.h
 829  */
 830 static FindClassFromBootLoader_t *findBootClass = NULL;
 831 
 832 jclass FindBootStrapClass(JNIEnv *env, const char *classname)
 833 {
 834    HMODULE hJvm;
 835 
 836    if (findBootClass == NULL) {
 837        hJvm = GetModuleHandle(JVM_DLL);
 838        if (hJvm == NULL) return NULL;
 839        /* need to use the demangled entry point */
 840        findBootClass = (FindClassFromBootLoader_t *)GetProcAddress(hJvm,
 841             &quot;JVM_FindClassFromBootLoader&quot;);
 842        if (findBootClass == NULL) {
 843           JLI_ReportErrorMessage(DLL_ERROR4, &quot;JVM_FindClassFromBootLoader&quot;);
 844           return NULL;
 845        }
 846    }
 847    return findBootClass(env, classname);
 848 }
 849 
 850 void
 851 InitLauncher(boolean javaw)
 852 {
 853     INITCOMMONCONTROLSEX icx;
 854 
 855     /*
 856      * Required for javaw mode MessageBox output as well as for
 857      * HotSpot -XX:+ShowMessageBoxOnError in java mode, an empty
 858      * flag field is sufficient to perform the basic UI initialization.
 859      */
 860     memset(&amp;icx, 0, sizeof(INITCOMMONCONTROLSEX));
 861     icx.dwSize = sizeof(INITCOMMONCONTROLSEX);
 862     InitCommonControlsEx(&amp;icx);
 863     _isjavaw = javaw;
 864     JLI_SetTraceLauncher();
 865 }
 866 
 867 
 868 /* ============================== */
 869 /* AWT preloading */
 870 #ifdef ENABLE_AWT_PRELOAD
 871 
 872 typedef int FnPreloadStart(void);
 873 typedef void FnPreloadStop(void);
 874 static FnPreloadStop *fnPreloadStop = NULL;
 875 static HMODULE hPreloadAwt = NULL;
 876 
 877 /*
 878  * Starts AWT preloading
 879  */
 880 int AWTPreload(const char *funcName)
 881 {
 882     int result = -1;
 883     /* load AWT library once (if several preload function should be called) */
 884     if (hPreloadAwt == NULL) {
 885         /* awt.dll is not loaded yet */
 886         char libraryPath[MAXPATHLEN];
 887         size_t jrePathLen = 0;
 888         HMODULE hJava = NULL;
 889         HMODULE hVerify = NULL;
 890 
 891         while (1) {
 892             /* awt.dll depends on jvm.dll &amp; java.dll;
 893              * jvm.dll is already loaded, so we need only java.dll;
 894              * java.dll depends on MSVCRT lib &amp; verify.dll.
 895              */
 896             if (!GetJREPath(libraryPath, MAXPATHLEN)) {
 897                 break;
 898             }
 899 
 900             /* save path length */
 901             jrePathLen = JLI_StrLen(libraryPath);
 902 
 903             if (jrePathLen + JLI_StrLen(&quot;\\bin\\verify.dll&quot;) &gt;= MAXPATHLEN) {
 904               /* jre path is too long, the library path will not fit there;
 905                * report and abort preloading
 906                */
 907               JLI_ReportErrorMessage(JRE_ERROR11);
 908               break;
 909             }
 910 
 911             /* load msvcrt 1st */
 912             LoadMSVCRT();
 913 
 914             /* load verify.dll */
 915             JLI_StrCat(libraryPath, &quot;\\bin\\verify.dll&quot;);
 916             hVerify = LoadLibrary(libraryPath);
 917             if (hVerify == NULL) {
 918                 break;
 919             }
 920 
 921             /* restore jrePath */
 922             libraryPath[jrePathLen] = 0;
 923             /* load java.dll */
 924             JLI_StrCat(libraryPath, &quot;\\bin\\&quot; JAVA_DLL);
 925             hJava = LoadLibrary(libraryPath);
 926             if (hJava == NULL) {
 927                 break;
 928             }
 929 
 930             /* restore jrePath */
 931             libraryPath[jrePathLen] = 0;
 932             /* load awt.dll */
 933             JLI_StrCat(libraryPath, &quot;\\bin\\awt.dll&quot;);
 934             hPreloadAwt = LoadLibrary(libraryPath);
 935             if (hPreloadAwt == NULL) {
 936                 break;
 937             }
 938 
 939             /* get &quot;preloadStop&quot; func ptr */
 940             fnPreloadStop = (FnPreloadStop *)GetProcAddress(hPreloadAwt, &quot;preloadStop&quot;);
 941 
 942             break;
 943         }
 944     }
 945 
 946     if (hPreloadAwt != NULL) {
 947         FnPreloadStart *fnInit = (FnPreloadStart *)GetProcAddress(hPreloadAwt, funcName);
 948         if (fnInit != NULL) {
 949             /* don&#39;t forget to stop preloading */
 950             awtPreloaded = 1;
 951 
 952             result = fnInit();
 953         }
 954     }
 955 
 956     return result;
 957 }
 958 
 959 /*
 960  * Terminates AWT preloading
 961  */
 962 void AWTPreloadStop() {
 963     if (fnPreloadStop != NULL) {
 964         fnPreloadStop();
 965     }
 966 }
 967 
 968 #endif /* ENABLE_AWT_PRELOAD */
 969 
 970 int
 971 JVMInit(InvocationFunctions* ifn, jlong threadStackSize,
 972         int argc, char **argv,
 973         int mode, char *what, int ret)
 974 {
 975     ShowSplashScreen();
 976     return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);
 977 }
 978 
 979 void
 980 PostJVMInit(JNIEnv *env, jclass mainClass, JavaVM *vm)
 981 {
 982     // stubbed out for windows and *nixes.
 983 }
 984 
 985 void
 986 RegisterThread()
 987 {
 988     // stubbed out for windows and *nixes.
 989 }
 990 
 991 /*
 992  * on windows, we return a false to indicate this option is not applicable
 993  */
 994 jboolean
 995 ProcessPlatformOption(const char *arg)
 996 {
 997     return JNI_FALSE;
 998 }
 999 
1000 /*
1001  * At this point we have the arguments to the application, and we need to
1002  * check with original stdargs in order to compare which of these truly
1003  * needs expansion. cmdtoargs will specify this if it finds a bare
1004  * (unquoted) argument containing a glob character(s) ie. * or ?
1005  */
1006 jobjectArray
1007 CreateApplicationArgs(JNIEnv *env, char **strv, int argc)
1008 {
1009     int i, j, idx;
1010     size_t tlen;
1011     jobjectArray outArray, inArray;
1012     char *arg, **nargv;
1013     jboolean needs_expansion = JNI_FALSE;
1014     jmethodID mid;
1015     int stdargc;
1016     StdArg *stdargs;
1017     int *appArgIdx;
1018     int isTool;
1019     jclass cls = GetLauncherHelperClass(env);
1020     NULL_CHECK0(cls);
1021 
1022     if (argc == 0) {
1023         return NewPlatformStringArray(env, strv, argc);
1024     }
1025     // the holy grail we need to compare with.
1026     stdargs = JLI_GetStdArgs();
1027     stdargc = JLI_GetStdArgc();
1028 
1029     // sanity check, this should never happen
1030     if (argc &gt; stdargc) {
1031         JLI_TraceLauncher(&quot;Warning: app args is larger than the original, %d %d\n&quot;, argc, stdargc);
1032         JLI_TraceLauncher(&quot;passing arguments as-is.\n&quot;);
1033         return NewPlatformStringArray(env, strv, argc);
1034     }
1035 
1036     // sanity check, match the args we have, to the holy grail
1037     idx = JLI_GetAppArgIndex();
1038 
1039     // First arg index is NOT_FOUND
1040     if (idx &lt; 0) {
1041         // The only allowed value should be NOT_FOUND (-1) unless another change introduces
1042         // a different negative index
1043         assert (idx == -1);
1044         JLI_TraceLauncher(&quot;Warning: first app arg index not found, %d\n&quot;, idx);
1045         JLI_TraceLauncher(&quot;passing arguments as-is.\n&quot;);
1046         return NewPlatformStringArray(env, strv, argc);
1047     }
1048 
1049     isTool = (idx == 0);
1050     if (isTool) { idx++; } // skip tool name
1051     JLI_TraceLauncher(&quot;AppArgIndex: %d points to %s\n&quot;, idx, stdargs[idx].arg);
1052 
1053     appArgIdx = calloc(argc, sizeof(int));
1054     for (i = idx, j = 0; i &lt; stdargc; i++) {
1055         if (isTool) { // filter -J used by tools to pass JVM options
1056             arg = stdargs[i].arg;
1057             if (arg[0] == &#39;-&#39; &amp;&amp; arg[1] == &#39;J&#39;) {
1058                 continue;
1059             }
1060         }
1061         appArgIdx[j++] = i;
1062     }
1063     // sanity check, ensure same number of arguments for application
1064     if (j != argc) {
1065         JLI_TraceLauncher(&quot;Warning: app args count doesn&#39;t match, %d %d\n&quot;, j, argc);
1066         JLI_TraceLauncher(&quot;passing arguments as-is.\n&quot;);
1067         JLI_MemFree(appArgIdx);
1068         return NewPlatformStringArray(env, strv, argc);
1069     }
1070 
1071     // make a copy of the args which will be expanded in java if required.
1072     nargv = (char **)JLI_MemAlloc(argc * sizeof(char*));
1073     for (i = 0; i &lt; argc; i++) {
1074         jboolean arg_expand;
1075         j = appArgIdx[i];
1076         arg_expand = (JLI_StrCmp(stdargs[j].arg, strv[i]) == 0)
1077             ? stdargs[j].has_wildcard
1078             : JNI_FALSE;
1079         if (needs_expansion == JNI_FALSE)
1080             needs_expansion = arg_expand;
1081 
1082         // indicator char + String + NULL terminator, the java method will strip
1083         // out the first character, the indicator character, so no matter what
1084         // we add the indicator
1085         tlen = 1 + JLI_StrLen(strv[i]) + 1;
1086         nargv[i] = (char *) JLI_MemAlloc(tlen);
1087         if (JLI_Snprintf(nargv[i], tlen, &quot;%c%s&quot;, arg_expand ? &#39;T&#39; : &#39;F&#39;,
1088                          strv[i]) &lt; 0) {
1089             return NULL;
1090         }
1091         JLI_TraceLauncher(&quot;%s\n&quot;, nargv[i]);
1092     }
1093 
1094     if (!needs_expansion) {
1095         // clean up any allocated memory and return back the old arguments
1096         for (i = 0 ; i &lt; argc ; i++) {
1097             JLI_MemFree(nargv[i]);
1098         }
1099         JLI_MemFree(nargv);
1100         JLI_MemFree(appArgIdx);
1101         return NewPlatformStringArray(env, strv, argc);
1102     }
1103     NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls,
1104                                                 &quot;expandArgs&quot;,
1105                                                 &quot;([Ljava/lang/String;)[Ljava/lang/String;&quot;));
1106 
1107     // expand the arguments that require expansion, the java method will strip
1108     // out the indicator character.
1109     NULL_CHECK0(inArray = NewPlatformStringArray(env, nargv, argc));
1110     outArray = (*env)-&gt;CallStaticObjectMethod(env, cls, mid, inArray);
1111     for (i = 0; i &lt; argc; i++) {
1112         JLI_MemFree(nargv[i]);
1113     }
1114     JLI_MemFree(nargv);
1115     JLI_MemFree(appArgIdx);
1116     return outArray;
1117 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
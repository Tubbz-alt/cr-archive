<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemoryAccessVarHandleGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/Executable.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,16 ***</span>
  
  package java.lang.invoke;
  
  import jdk.internal.access.JavaLangAccess;
  import jdk.internal.access.SharedSecrets;
<span class="line-removed">- import jdk.internal.misc.Unsafe;</span>
<span class="line-removed">- import jdk.internal.misc.VM;</span>
<span class="line-removed">- import jdk.internal.org.objectweb.asm.ClassWriter;</span>
<span class="line-removed">- import jdk.internal.org.objectweb.asm.Label;</span>
<span class="line-removed">- import jdk.internal.org.objectweb.asm.MethodVisitor;</span>
<span class="line-removed">- import jdk.internal.org.objectweb.asm.Opcodes;</span>
  import jdk.internal.vm.annotation.Stable;
  import sun.invoke.util.Wrapper;
  
  import java.lang.invoke.MethodHandles.Lookup;
  import java.util.ArrayList;
<span class="line-new-header">--- 25,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,14 ***</span>
  import java.util.Objects;
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.concurrent.ConcurrentMap;
  import java.util.function.Function;
  
<span class="line-removed">- import static java.lang.invoke.MethodHandles.lookup;</span>
  import static java.lang.invoke.MethodType.methodType;
<span class="line-removed">- import static java.lang.invoke.MethodHandles.Lookup.ClassOption.*;</span>
<span class="line-removed">- import static jdk.internal.org.objectweb.asm.Opcodes.*;</span>
  
  /**
   * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
   * can be used to efficiently concatenate a known number of arguments of known
   * types, possibly after type adaptation and partial evaluation of arguments.
<span class="line-new-header">--- 37,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 126,116 ***</span>
       * we do not use all those slots, to let the strategies with MethodHandle
       * combinators to use some arguments.
       */
      private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Concatenation strategy to use. See {@link Strategy} for possible options.</span>
<span class="line-removed">-      * This option is controllable with -Djava.lang.invoke.stringConcat JDK option.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * Defaults to MH_INLINE_SIZED_EXACT if not set.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static final Strategy STRATEGY;</span>
<span class="line-removed">- </span>
      private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
  
<span class="line-removed">-     private enum Strategy {</span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Bytecode generator, calling into {@link java.lang.StringBuilder}.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         BC_SB,</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Bytecode generator, calling into {@link java.lang.StringBuilder};</span>
<span class="line-removed">-          * but trying to estimate the required storage.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         BC_SB_SIZED,</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Bytecode generator, calling into {@link java.lang.StringBuilder};</span>
<span class="line-removed">-          * but computing the required storage exactly.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         BC_SB_SIZED_EXACT,</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.</span>
<span class="line-removed">-          * This strategy also tries to estimate the required storage.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         MH_SB_SIZED,</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.</span>
<span class="line-removed">-          * This strategy also estimate the required storage exactly.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         MH_SB_SIZED_EXACT,</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * MethodHandle-based generator, that constructs its own byte[] array from</span>
<span class="line-removed">-          * the arguments. It computes the required storage exactly.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         MH_INLINE_SIZED_EXACT</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)</span>
<span class="line-removed">-      * checks, etc.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static final boolean DEBUG;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static {</span>
<span class="line-removed">-         final String strategy =</span>
<span class="line-removed">-                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);</span>
<span class="line-removed">-         STRATEGY = (strategy == null) ? null : Strategy.valueOf(strategy);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (STRATEGY == null || STRATEGY == Strategy.MH_INLINE_SIZED_EXACT) {</span>
<span class="line-removed">-             // Force initialization of default strategy:</span>
<span class="line-removed">-             Unsafe.getUnsafe().ensureClassInitialized(MethodHandleInlineCopyStrategy.class);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         DEBUG = Boolean.parseBoolean(</span>
<span class="line-removed">-                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Cache key is a composite of:</span>
<span class="line-removed">-      *   - class name, that lets to disambiguate stubs, to avoid excess sharing</span>
<span class="line-removed">-      *   - method type, describing the dynamic arguments for concatenation</span>
<span class="line-removed">-      *   - concat recipe, describing the constants and concat shape</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static final class Key {</span>
<span class="line-removed">-         final String className;</span>
<span class="line-removed">-         final MethodType mt;</span>
<span class="line-removed">-         final Recipe recipe;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public Key(String className, MethodType mt, Recipe recipe) {</span>
<span class="line-removed">-             this.className = className;</span>
<span class="line-removed">-             this.mt = mt;</span>
<span class="line-removed">-             this.recipe = recipe;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public boolean equals(Object o) {</span>
<span class="line-removed">-             if (this == o) return true;</span>
<span class="line-removed">-             if (o == null || getClass() != o.getClass()) return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             Key key = (Key) o;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (!className.equals(key.className)) return false;</span>
<span class="line-removed">-             if (!mt.equals(key.mt)) return false;</span>
<span class="line-removed">-             if (!recipe.equals(key.recipe)) return false;</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public int hashCode() {</span>
<span class="line-removed">-             int result = className.hashCode();</span>
<span class="line-removed">-             result = 31 * result + mt.hashCode();</span>
<span class="line-removed">-             result = 31 * result + recipe.hashCode();</span>
<span class="line-removed">-             return result;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Parses the recipe string, and produces a traversable collection of
       * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
       * strategies. Notably, this class parses out the constants from the recipe
       * and from other static arguments.
<span class="line-new-header">--- 117,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 443,14 ***</span>
       * @jls 15.18.1 String Concatenation Operator +
       */
      public static CallSite makeConcat(MethodHandles.Lookup lookup,
                                        String name,
                                        MethodType concatType) throws StringConcatException {
<span class="line-removed">-         if (DEBUG) {</span>
<span class="line-removed">-             System.out.println(&quot;StringConcatFactory &quot; + STRATEGY + &quot; is here for &quot; + concatType);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          return doStringConcat(lookup, name, concatType, true, null);
      }
  
      /**
       * Facilitates the creation of optimized String concatenation methods, that
<span class="line-new-header">--- 330,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 566,14 ***</span>
      public static CallSite makeConcatWithConstants(MethodHandles.Lookup lookup,
                                                     String name,
                                                     MethodType concatType,
                                                     String recipe,
                                                     Object... constants) throws StringConcatException {
<span class="line-removed">-         if (DEBUG) {</span>
<span class="line-removed">-             System.out.println(&quot;StringConcatFactory &quot; + STRATEGY + &quot; is here for &quot; + concatType + &quot;, {&quot; + recipe + &quot;}, &quot; + Arrays.toString(constants));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          return doStringConcat(lookup, name, concatType, false, recipe, constants);
      }
  
      private static CallSite doStringConcat(MethodHandles.Lookup lookup,
                                             String name,
<span class="line-new-header">--- 449,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 641,1263 ***</span>
                      concatType.parameterSlotCount() +
                      &quot;, can only accept &quot; +
                      MAX_INDY_CONCAT_ARG_SLOTS);
          }
  
<span class="line-removed">-         MethodType mt = adaptType(concatType);</span>
          Recipe rec = new Recipe(recipe, constants);
<span class="line-modified">!         MethodHandle mh = generate(lookup, mt, rec);</span>
          return new ConstantCallSite(mh.asType(concatType));
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Adapt method type to an API we are going to use.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * This strips the concrete classes from the signatures, thus preventing</span>
<span class="line-removed">-      * class leakage when we cache the concatenation stubs.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param args actual argument types</span>
<span class="line-removed">-      * @return argument types the strategy is going to use</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static MethodType adaptType(MethodType args) {</span>
<span class="line-removed">-         Class&lt;?&gt;[] ptypes = null;</span>
<span class="line-removed">-         for (int i = 0; i &lt; args.parameterCount(); i++) {</span>
<span class="line-removed">-             Class&lt;?&gt; ptype = args.parameterType(i);</span>
<span class="line-removed">-             if (!ptype.isPrimitive() &amp;&amp;</span>
<span class="line-removed">-                     ptype != String.class &amp;&amp;</span>
<span class="line-removed">-                     ptype != Object.class) { // truncate to Object</span>
<span class="line-removed">-                 if (ptypes == null) {</span>
<span class="line-removed">-                     ptypes = args.parameterArray();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 ptypes[i] = Object.class;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             // else other primitives or String or Object (unchanged)</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return (ptypes != null)</span>
<span class="line-removed">-                 ? MethodType.methodType(args.returnType(), ptypes)</span>
<span class="line-removed">-                 : args;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {
          try {
<span class="line-modified">!             if (STRATEGY == null) {</span>
<span class="line-removed">-                 return MethodHandleInlineCopyStrategy.generate(mt, recipe);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             switch (STRATEGY) {</span>
<span class="line-removed">-                 case BC_SB:</span>
<span class="line-removed">-                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.DEFAULT);</span>
<span class="line-removed">-                 case BC_SB_SIZED:</span>
<span class="line-removed">-                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED);</span>
<span class="line-removed">-                 case BC_SB_SIZED_EXACT:</span>
<span class="line-removed">-                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED_EXACT);</span>
<span class="line-removed">-                 case MH_SB_SIZED:</span>
<span class="line-removed">-                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED);</span>
<span class="line-removed">-                 case MH_SB_SIZED_EXACT:</span>
<span class="line-removed">-                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED_EXACT);</span>
<span class="line-removed">-                 case MH_INLINE_SIZED_EXACT:</span>
<span class="line-removed">-                     return MethodHandleInlineCopyStrategy.generate(mt, recipe);</span>
<span class="line-removed">-                 default:</span>
<span class="line-removed">-                     throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);</span>
<span class="line-removed">-             }</span>
          } catch (Error | StringConcatException e) {
              // Pass through any error or existing StringConcatException
              throw e;
          } catch (Throwable t) {
              throw new StringConcatException(&quot;Generator failed&quot;, t);
          }
      }
  
<span class="line-removed">-     private enum Mode {</span>
<span class="line-removed">-         DEFAULT(false, false),</span>
<span class="line-removed">-         SIZED(true, false),</span>
<span class="line-removed">-         SIZED_EXACT(true, true);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private final boolean sized;</span>
<span class="line-removed">-         private final boolean exact;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         Mode(boolean sized, boolean exact) {</span>
<span class="line-removed">-             this.sized = sized;</span>
<span class="line-removed">-             this.exact = exact;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         boolean isSized() {</span>
<span class="line-removed">-             return sized;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         boolean isExact() {</span>
<span class="line-removed">-             return exact;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  
      /**
<span class="line-modified">!      * Bytecode StringBuilder strategy.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * &lt;p&gt;This strategy operates in three modes, gated by {@link Mode}.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB}: &quot;bytecode StringBuilder&quot;.&lt;/b&gt;</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt;This strategy spins up the bytecode that has the same StringBuilder</span>
<span class="line-removed">-      * chain javac would otherwise emit. This strategy uses only the public API,</span>
<span class="line-removed">-      * and comes as the baseline for the current JDK behavior. On other words,</span>
<span class="line-removed">-      * this strategy moves the javac generated bytecode to runtime. The</span>
<span class="line-removed">-      * generated bytecode is loaded via Lookup::defineClass, but with</span>
<span class="line-removed">-      * the caller class coming from the BSM -- in other words, the protection</span>
<span class="line-removed">-      * guarantees are inherited from the method where invokedynamic was</span>
<span class="line-removed">-      * originally called. This means, among other things, that the bytecode is</span>
<span class="line-removed">-      * verified for all non-JDK uses.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED}: &quot;bytecode StringBuilder, but</span>
<span class="line-removed">-      * sized&quot;.&lt;/b&gt;</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt;This strategy acts similarly to {@link Strategy#BC_SB}, but it also</span>
<span class="line-removed">-      * tries to guess the capacity required for StringBuilder to accept all</span>
<span class="line-removed">-      * arguments without resizing. This strategy only makes an educated guess:</span>
<span class="line-removed">-      * it only guesses the space required for known types (e.g. primitives and</span>
<span class="line-removed">-      * Strings), but does not otherwise convert arguments. Therefore, the</span>
<span class="line-removed">-      * capacity estimate may be wrong, and StringBuilder may have to</span>
<span class="line-removed">-      * transparently resize or trim when doing the actual concatenation. While</span>
<span class="line-removed">-      * this does not constitute a correctness issue (in the end, that what BC_SB</span>
<span class="line-removed">-      * has to do anyway), this does pose a potential performance problem.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED_EXACT}: &quot;bytecode StringBuilder, but</span>
<span class="line-removed">-      * sized exactly&quot;.&lt;/b&gt;</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt;This strategy improves on @link Strategy#BC_SB_SIZED}, by first</span>
<span class="line-removed">-      * converting all arguments to String in order to get the exact capacity</span>
<span class="line-removed">-      * StringBuilder should have. The conversion is done via the public</span>
<span class="line-removed">-      * String.valueOf and/or Object.toString methods, and does not touch any</span>
<span class="line-removed">-      * private String API.</span>
       */
<span class="line-modified">!     private static final class BytecodeStringBuilderStrategy {</span>
<span class="line-removed">-         static final int CLASSFILE_VERSION = 52;</span>
<span class="line-removed">-         static final String METHOD_NAME = &quot;concat&quot;;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated</span>
<span class="line-removed">-          * code, at the expense of contaminating the profiles.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private static final boolean CACHE_ENABLE;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Dump generated classes to disk, for debugging purposes.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private static final ProxyClassesDumper DUMPER;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static {</span>
<span class="line-removed">-             CACHE_ENABLE = Boolean.parseBoolean(</span>
<span class="line-removed">-                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
<span class="line-removed">-             CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             final String dumpPath =</span>
<span class="line-removed">-                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private BytecodeStringBuilderStrategy() {</span>
<span class="line-removed">-             // no instantiation</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static MethodHandle generate(Lookup lookup, MethodType args, Recipe recipe, Mode mode) throws Exception {</span>
<span class="line-removed">-             String className = getClassName(lookup.lookupClass());</span>
<span class="line-removed">-             Key key = null;</span>
<span class="line-removed">-             if (CACHE_ENABLE) {</span>
<span class="line-removed">-                 key = new Key(className, args, recipe);</span>
<span class="line-removed">-                 MethodHandle mh = CACHE.get(key);</span>
<span class="line-removed">-                 if (mh != null) {</span>
<span class="line-removed">-                     return mh;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             cw.visit(CLASSFILE_VERSION,</span>
<span class="line-removed">-                     ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,</span>
<span class="line-removed">-                     className,</span>
<span class="line-removed">-                     null,</span>
<span class="line-removed">-                     &quot;java/lang/Object&quot;,</span>
<span class="line-removed">-                     null</span>
<span class="line-removed">-             );</span>
<span class="line-removed">- </span>
<span class="line-removed">-             MethodVisitor mv = cw.visitMethod(</span>
<span class="line-removed">-                     ACC_PUBLIC + ACC_STATIC + ACC_FINAL,</span>
<span class="line-removed">-                     METHOD_NAME,</span>
<span class="line-removed">-                     args.toMethodDescriptorString(),</span>
<span class="line-removed">-                     null,</span>
<span class="line-removed">-                     null);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // use of @ForceInline no longer has any effect</span>
<span class="line-removed">-             mv.visitAnnotation(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;, true);</span>
<span class="line-removed">-             mv.visitCode();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             Class&lt;?&gt;[] arr = args.parameterArray();</span>
<span class="line-removed">-             boolean[] guaranteedNonNull = new boolean[arr.length];</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (mode.isExact()) {</span>
<span class="line-removed">-                 /*</span>
<span class="line-removed">-                     In exact mode, we need to convert all arguments to their String representations,</span>
<span class="line-removed">-                     as this allows to compute their String sizes exactly. We cannot use private</span>
<span class="line-removed">-                     methods for primitives in here, therefore we need to convert those as well.</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     We also record what arguments are guaranteed to be non-null as the result</span>
<span class="line-removed">-                     of the conversion. String.valueOf does the null checks for us. The only</span>
<span class="line-removed">-                     corner case to take care of is String.valueOf(Object) returning null itself.</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     Also, if any conversion happened, then the slot indices in the incoming</span>
<span class="line-removed">-                     arguments are not equal to the final local maps. The only case this may break</span>
<span class="line-removed">-                     is when converting 2-slot long/double argument to 1-slot String. Therefore,</span>
<span class="line-removed">-                     we get away with tracking modified offset, since no conversion can overwrite</span>
<span class="line-removed">-                     the upcoming the argument.</span>
<span class="line-removed">-                  */</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 int off = 0;</span>
<span class="line-removed">-                 int modOff = 0;</span>
<span class="line-removed">-                 for (int c = 0; c &lt; arr.length; c++) {</span>
<span class="line-removed">-                     Class&lt;?&gt; cl = arr[c];</span>
<span class="line-removed">-                     if (cl == String.class) {</span>
<span class="line-removed">-                         if (off != modOff) {</span>
<span class="line-removed">-                             mv.visitIntInsn(getLoadOpcode(cl), off);</span>
<span class="line-removed">-                             mv.visitIntInsn(ASTORE, modOff);</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         mv.visitIntInsn(getLoadOpcode(cl), off);</span>
<span class="line-removed">-                         mv.visitMethodInsn(</span>
<span class="line-removed">-                                 INVOKESTATIC,</span>
<span class="line-removed">-                                 &quot;java/lang/String&quot;,</span>
<span class="line-removed">-                                 &quot;valueOf&quot;,</span>
<span class="line-removed">-                                 getStringValueOfDesc(cl),</span>
<span class="line-removed">-                                 false</span>
<span class="line-removed">-                         );</span>
<span class="line-removed">-                         mv.visitIntInsn(ASTORE, modOff);</span>
<span class="line-removed">-                         arr[c] = String.class;</span>
<span class="line-removed">-                         guaranteedNonNull[c] = cl.isPrimitive();</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     off += getParameterSize(cl);</span>
<span class="line-removed">-                     modOff += getParameterSize(String.class);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (mode.isSized()) {</span>
<span class="line-removed">-                 /*</span>
<span class="line-removed">-                     When operating in sized mode (this includes exact mode), it makes sense to make</span>
<span class="line-removed">-                     StringBuilder append chains look familiar to OptimizeStringConcat. For that, we</span>
<span class="line-removed">-                     need to do null-checks early, not make the append chain shape simpler.</span>
<span class="line-removed">-                  */</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 int off = 0;</span>
<span class="line-removed">-                 for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed">-                     switch (el.getTag()) {</span>
<span class="line-removed">-                         case TAG_CONST:</span>
<span class="line-removed">-                             // Guaranteed non-null, no null check required.</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         case TAG_ARG:</span>
<span class="line-removed">-                             // Null-checks are needed only for String arguments, and when a previous stage</span>
<span class="line-removed">-                             // did not do implicit null-checks. If a String is null, we eagerly replace it</span>
<span class="line-removed">-                             // with &quot;null&quot; constant. Note, we omit Objects here, because we don&#39;t call</span>
<span class="line-removed">-                             // .length() on them down below.</span>
<span class="line-removed">-                             int ac = el.getArgPos();</span>
<span class="line-removed">-                             Class&lt;?&gt; cl = arr[ac];</span>
<span class="line-removed">-                             if (cl == String.class &amp;&amp; !guaranteedNonNull[ac]) {</span>
<span class="line-removed">-                                 Label l0 = new Label();</span>
<span class="line-removed">-                                 mv.visitIntInsn(ALOAD, off);</span>
<span class="line-removed">-                                 mv.visitJumpInsn(IFNONNULL, l0);</span>
<span class="line-removed">-                                 mv.visitLdcInsn(&quot;null&quot;);</span>
<span class="line-removed">-                                 mv.visitIntInsn(ASTORE, off);</span>
<span class="line-removed">-                                 mv.visitLabel(l0);</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                             off += getParameterSize(cl);</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         default:</span>
<span class="line-removed">-                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Prepare StringBuilder instance</span>
<span class="line-removed">-             mv.visitTypeInsn(NEW, &quot;java/lang/StringBuilder&quot;);</span>
<span class="line-removed">-             mv.visitInsn(DUP);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (mode.isSized()) {</span>
<span class="line-removed">-                 /*</span>
<span class="line-removed">-                     Sized mode requires us to walk through the arguments, and estimate the final length.</span>
<span class="line-removed">-                     In exact mode, this will operate on Strings only. This code would accumulate the</span>
<span class="line-removed">-                     final length on stack.</span>
<span class="line-removed">-                  */</span>
<span class="line-removed">-                 int len = 0;</span>
<span class="line-removed">-                 int off = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 mv.visitInsn(ICONST_0);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed">-                     switch (el.getTag()) {</span>
<span class="line-removed">-                         case TAG_CONST:</span>
<span class="line-removed">-                             len += el.getValue().length();</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         case TAG_ARG:</span>
<span class="line-removed">-                             /*</span>
<span class="line-removed">-                                 If an argument is String, then we can call .length() on it. Sized/Exact modes have</span>
<span class="line-removed">-                                 converted arguments for us. If an argument is primitive, we can provide a guess</span>
<span class="line-removed">-                                 for its String representation size.</span>
<span class="line-removed">-                             */</span>
<span class="line-removed">-                             Class&lt;?&gt; cl = arr[el.getArgPos()];</span>
<span class="line-removed">-                             if (cl == String.class) {</span>
<span class="line-removed">-                                 mv.visitIntInsn(ALOAD, off);</span>
<span class="line-removed">-                                 mv.visitMethodInsn(</span>
<span class="line-removed">-                                         INVOKEVIRTUAL,</span>
<span class="line-removed">-                                         &quot;java/lang/String&quot;,</span>
<span class="line-removed">-                                         &quot;length&quot;,</span>
<span class="line-removed">-                                         &quot;()I&quot;,</span>
<span class="line-removed">-                                         false</span>
<span class="line-removed">-                                 );</span>
<span class="line-removed">-                                 mv.visitInsn(IADD);</span>
<span class="line-removed">-                             } else if (cl.isPrimitive()) {</span>
<span class="line-removed">-                                 len += estimateSize(cl);</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                             off += getParameterSize(cl);</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         default:</span>
<span class="line-removed">-                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 // Constants have non-zero length, mix in</span>
<span class="line-removed">-                 if (len &gt; 0) {</span>
<span class="line-removed">-                     iconst(mv, len);</span>
<span class="line-removed">-                     mv.visitInsn(IADD);</span>
<span class="line-removed">-                 }</span>
  
<span class="line-modified">!                 mv.visitMethodInsn(</span>
<span class="line-modified">!                         INVOKESPECIAL,</span>
<span class="line-modified">!                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-modified">!                         &quot;&lt;init&gt;&quot;,</span>
<span class="line-modified">!                         &quot;(I)V&quot;,</span>
<span class="line-modified">!                         false</span>
<span class="line-modified">!                 );</span>
<span class="line-modified">!             } else {</span>
<span class="line-removed">-                 mv.visitMethodInsn(</span>
<span class="line-removed">-                         INVOKESPECIAL,</span>
<span class="line-removed">-                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed">-                         &quot;&lt;init&gt;&quot;,</span>
<span class="line-removed">-                         &quot;()V&quot;,</span>
<span class="line-removed">-                         false</span>
<span class="line-removed">-                 );</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // At this point, we have a blank StringBuilder on stack, fill it in with .append calls.</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 int off = 0;</span>
<span class="line-removed">-                 for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed">-                     String desc;</span>
<span class="line-removed">-                     switch (el.getTag()) {</span>
<span class="line-removed">-                         case TAG_CONST:</span>
<span class="line-removed">-                             mv.visitLdcInsn(el.getValue());</span>
<span class="line-removed">-                             desc = getSBAppendDesc(String.class);</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         case TAG_ARG:</span>
<span class="line-removed">-                             Class&lt;?&gt; cl = arr[el.getArgPos()];</span>
<span class="line-removed">-                             mv.visitVarInsn(getLoadOpcode(cl), off);</span>
<span class="line-removed">-                             off += getParameterSize(cl);</span>
<span class="line-removed">-                             desc = getSBAppendDesc(cl);</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         default:</span>
<span class="line-removed">-                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     mv.visitMethodInsn(</span>
<span class="line-removed">-                             INVOKEVIRTUAL,</span>
<span class="line-removed">-                             &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed">-                             &quot;append&quot;,</span>
<span class="line-removed">-                             desc,</span>
<span class="line-removed">-                             false</span>
<span class="line-removed">-                     );</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (DEBUG &amp;&amp; mode.isExact()) {</span>
<span class="line-removed">-                 /*</span>
<span class="line-removed">-                     Exactness checks compare the final StringBuilder.capacity() with a resulting</span>
<span class="line-removed">-                     String.length(). If these values disagree, that means StringBuilder had to perform</span>
<span class="line-removed">-                     storage trimming, which defeats the purpose of exact strategies.</span>
<span class="line-removed">-                  */</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 /*</span>
<span class="line-removed">-                    The logic for this check is as follows:</span>
<span class="line-removed">- </span>
<span class="line-removed">-                      Stack before:     Op:</span>
<span class="line-removed">-                       (SB)              dup, dup</span>
<span class="line-removed">-                       (SB, SB, SB)      capacity()</span>
<span class="line-removed">-                       (int, SB, SB)     swap</span>
<span class="line-removed">-                       (SB, int, SB)     toString()</span>
<span class="line-removed">-                       (S, int, SB)      length()</span>
<span class="line-removed">-                       (int, int, SB)    if_icmpeq</span>
<span class="line-removed">-                       (SB)              &lt;end&gt;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                    Note that it leaves the same StringBuilder on exit, like the one on enter.</span>
<span class="line-removed">-                  */</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 mv.visitInsn(DUP);</span>
<span class="line-removed">-                 mv.visitInsn(DUP);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 mv.visitMethodInsn(</span>
<span class="line-removed">-                         INVOKEVIRTUAL,</span>
<span class="line-removed">-                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed">-                         &quot;capacity&quot;,</span>
<span class="line-removed">-                         &quot;()I&quot;,</span>
<span class="line-removed">-                         false</span>
<span class="line-removed">-                 );</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 mv.visitInsn(SWAP);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 mv.visitMethodInsn(</span>
<span class="line-removed">-                         INVOKEVIRTUAL,</span>
<span class="line-removed">-                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed">-                         &quot;toString&quot;,</span>
<span class="line-removed">-                         &quot;()Ljava/lang/String;&quot;,</span>
<span class="line-removed">-                         false</span>
<span class="line-removed">-                 );</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 mv.visitMethodInsn(</span>
<span class="line-removed">-                         INVOKEVIRTUAL,</span>
<span class="line-removed">-                         &quot;java/lang/String&quot;,</span>
<span class="line-removed">-                         &quot;length&quot;,</span>
<span class="line-removed">-                         &quot;()I&quot;,</span>
<span class="line-removed">-                         false</span>
<span class="line-removed">-                 );</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 Label l0 = new Label();</span>
<span class="line-removed">-                 mv.visitJumpInsn(IF_ICMPEQ, l0);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 mv.visitTypeInsn(NEW, &quot;java/lang/AssertionError&quot;);</span>
<span class="line-removed">-                 mv.visitInsn(DUP);</span>
<span class="line-removed">-                 mv.visitLdcInsn(&quot;Failed exactness check&quot;);</span>
<span class="line-removed">-                 mv.visitMethodInsn(INVOKESPECIAL,</span>
<span class="line-removed">-                         &quot;java/lang/AssertionError&quot;,</span>
<span class="line-removed">-                         &quot;&lt;init&gt;&quot;,</span>
<span class="line-removed">-                         &quot;(Ljava/lang/Object;)V&quot;,</span>
<span class="line-removed">-                         false);</span>
<span class="line-removed">-                 mv.visitInsn(ATHROW);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 mv.visitLabel(l0);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             mv.visitMethodInsn(</span>
<span class="line-removed">-                     INVOKEVIRTUAL,</span>
<span class="line-removed">-                     &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed">-                     &quot;toString&quot;,</span>
<span class="line-removed">-                     &quot;()Ljava/lang/String;&quot;,</span>
<span class="line-removed">-                     false</span>
<span class="line-removed">-             );</span>
<span class="line-removed">- </span>
<span class="line-removed">-             mv.visitInsn(ARETURN);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             mv.visitMaxs(-1, -1);</span>
<span class="line-removed">-             mv.visitEnd();</span>
<span class="line-removed">-             cw.visitEnd();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             byte[] classBytes = cw.toByteArray();</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 Class&lt;?&gt; innerClass = lookup.defineHiddenClass(classBytes, true, STRONG).lookupClass();</span>
<span class="line-removed">-                 dumpIfEnabled(className, classBytes);</span>
<span class="line-removed">-                 MethodHandle mh = lookup.findStatic(innerClass, METHOD_NAME, args);</span>
<span class="line-removed">-                 if (CACHE_ENABLE) {</span>
<span class="line-removed">-                     CACHE.put(key, mh);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 return mh;</span>
<span class="line-removed">-             } catch (Exception e) {</span>
<span class="line-removed">-                 dumpIfEnabled(className + &quot;$$FAILED&quot;, classBytes);</span>
<span class="line-removed">-                 throw new StringConcatException(&quot;Exception while spinning the class&quot;, e);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * The generated class is in the same package as the host class as</span>
<span class="line-removed">-          * it&#39;s the implementation of the string concatenation for the host</span>
<span class="line-removed">-          * class.</span>
<span class="line-removed">-          *</span>
<span class="line-removed">-          * When cache is enabled, we want to cache as much as we can.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private static String getClassName(Class&lt;?&gt; hostClass) {</span>
<span class="line-removed">-             if (CACHE_ENABLE) {</span>
<span class="line-removed">-                 String pkgName = hostClass.getPackageName();</span>
<span class="line-removed">-                 return (!pkgName.isEmpty() ? pkgName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; : &quot;&quot;) + &quot;Stubs$$StringConcat&quot;;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 String name = hostClass.isHidden() ? hostClass.getName().replace(&#39;/&#39;, &#39;_&#39;)</span>
<span class="line-removed">-                         : hostClass.getName();</span>
<span class="line-removed">-                 return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$StringConcat&quot;;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static void dumpIfEnabled(String name, byte[] bytes) {</span>
<span class="line-removed">-             if (DUMPER != null) {</span>
<span class="line-removed">-                 DUMPER.dumpClass(name, bytes);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static String getSBAppendDesc(Class&lt;?&gt; cl) {</span>
<span class="line-removed">-             if (cl.isPrimitive()) {</span>
<span class="line-removed">-                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {</span>
<span class="line-removed">-                     return &quot;(I)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">-                 } else if (cl == Boolean.TYPE) {</span>
<span class="line-removed">-                     return &quot;(Z)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">-                 } else if (cl == Character.TYPE) {</span>
<span class="line-removed">-                     return &quot;(C)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">-                 } else if (cl == Double.TYPE) {</span>
<span class="line-removed">-                     return &quot;(D)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">-                 } else if (cl == Float.TYPE) {</span>
<span class="line-removed">-                     return &quot;(F)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">-                 } else if (cl == Long.TYPE) {</span>
<span class="line-removed">-                     return &quot;(J)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     throw new IllegalStateException(&quot;Unhandled primitive StringBuilder.append: &quot; + cl);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             } else if (cl == String.class) {</span>
<span class="line-removed">-                 return &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 return &quot;(Ljava/lang/Object;)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static String getStringValueOfDesc(Class&lt;?&gt; cl) {</span>
<span class="line-removed">-             if (cl.isPrimitive()) {</span>
<span class="line-removed">-                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {</span>
<span class="line-removed">-                     return &quot;(I)Ljava/lang/String;&quot;;</span>
<span class="line-removed">-                 } else if (cl == Boolean.TYPE) {</span>
<span class="line-removed">-                     return &quot;(Z)Ljava/lang/String;&quot;;</span>
<span class="line-removed">-                 } else if (cl == Character.TYPE) {</span>
<span class="line-removed">-                     return &quot;(C)Ljava/lang/String;&quot;;</span>
<span class="line-removed">-                 } else if (cl == Double.TYPE) {</span>
<span class="line-removed">-                     return &quot;(D)Ljava/lang/String;&quot;;</span>
<span class="line-removed">-                 } else if (cl == Float.TYPE) {</span>
<span class="line-removed">-                     return &quot;(F)Ljava/lang/String;&quot;;</span>
<span class="line-removed">-                 } else if (cl == Long.TYPE) {</span>
<span class="line-removed">-                     return &quot;(J)Ljava/lang/String;&quot;;</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     throw new IllegalStateException(&quot;Unhandled String.valueOf: &quot; + cl);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             } else if (cl == String.class) {</span>
<span class="line-removed">-                 return &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 return &quot;(Ljava/lang/Object;)Ljava/lang/String;&quot;;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * The following method is copied from</span>
<span class="line-removed">-          * org.objectweb.asm.commons.InstructionAdapter. Part of ASM: a very small</span>
<span class="line-removed">-          * and fast Java bytecode manipulation framework.</span>
<span class="line-removed">-          * Copyright (c) 2000-2005 INRIA, France Telecom All rights reserved.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private static void iconst(MethodVisitor mv, final int cst) {</span>
<span class="line-removed">-             if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {</span>
<span class="line-removed">-                 mv.visitInsn(Opcodes.ICONST_0 + cst);</span>
<span class="line-removed">-             } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {</span>
<span class="line-removed">-                 mv.visitIntInsn(Opcodes.BIPUSH, cst);</span>
<span class="line-removed">-             } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {</span>
<span class="line-removed">-                 mv.visitIntInsn(Opcodes.SIPUSH, cst);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 mv.visitLdcInsn(cst);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static int getLoadOpcode(Class&lt;?&gt; c) {</span>
<span class="line-removed">-             if (c == Void.TYPE) {</span>
<span class="line-removed">-                 throw new InternalError(&quot;Unexpected void type of load opcode&quot;);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return ILOAD + getOpcodeOffset(c);</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         private static int getOpcodeOffset(Class&lt;?&gt; c) {</span>
<span class="line-removed">-             if (c.isPrimitive()) {</span>
<span class="line-removed">-                 if (c == Long.TYPE) {</span>
<span class="line-removed">-                     return 1;</span>
<span class="line-removed">-                 } else if (c == Float.TYPE) {</span>
<span class="line-removed">-                     return 2;</span>
<span class="line-removed">-                 } else if (c == Double.TYPE) {</span>
<span class="line-removed">-                     return 3;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 return 0;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 return 4;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         private static int getParameterSize(Class&lt;?&gt; c) {</span>
<span class="line-modified">!             if (c == Void.TYPE) {</span>
<span class="line-modified">!                 return 0;</span>
<span class="line-modified">!             } else if (c == Long.TYPE || c == Double.TYPE) {</span>
<span class="line-removed">-                 return 2;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return 1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * MethodHandle StringBuilder strategy.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt;This strategy operates in two modes, gated by {@link Mode}.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_SB_SIZED}: &quot;MethodHandles StringBuilder,</span>
<span class="line-removed">-      * sized&quot;.&lt;/b&gt;</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt;This strategy avoids spinning up the bytecode by building the</span>
<span class="line-removed">-      * computation on MethodHandle combinators. The computation is built with</span>
<span class="line-removed">-      * public MethodHandle APIs, resolved from a public Lookup sequence, and</span>
<span class="line-removed">-      * ends up calling the public StringBuilder API. Therefore, this strategy</span>
<span class="line-removed">-      * does not use any private API at all since everything is handled under</span>
<span class="line-removed">-      * cover by java.lang.invoke APIs.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_SB_SIZED_EXACT}: &quot;MethodHandles StringBuilder,</span>
<span class="line-removed">-      * sized exactly&quot;.&lt;/b&gt;</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt;This strategy improves on @link Strategy#MH_SB_SIZED}, by first</span>
<span class="line-removed">-      * converting all arguments to String in order to get the exact capacity</span>
<span class="line-removed">-      * StringBuilder should have. The conversion is done via the public</span>
<span class="line-removed">-      * String.valueOf and/or Object.toString methods, and does not touch any</span>
<span class="line-removed">-      * private String API.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static final class MethodHandleStringBuilderStrategy {</span>
<span class="line-removed">-         private MethodHandleStringBuilderStrategy() {</span>
<span class="line-removed">-             // no instantiation</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         private static MethodHandle generate(MethodType mt, Recipe recipe, Mode mode) throws Exception {</span>
<span class="line-modified">!             int pc = mt.parameterCount();</span>
<span class="line-modified">! </span>
<span class="line-modified">!             Class&lt;?&gt;[] ptypes = mt.parameterArray();</span>
<span class="line-modified">!             MethodHandle[] filters = new MethodHandle[ptypes.length];</span>
<span class="line-removed">-             for (int i = 0; i &lt; ptypes.length; i++) {</span>
<span class="line-removed">-                 MethodHandle filter;</span>
<span class="line-removed">-                 switch (mode) {</span>
<span class="line-removed">-                     case SIZED:</span>
<span class="line-removed">-                         // In sized mode, we convert all references and floats/doubles</span>
<span class="line-removed">-                         // to String: there is no specialization for different</span>
<span class="line-removed">-                         // classes in StringBuilder API, and it will convert to</span>
<span class="line-removed">-                         // String internally anyhow.</span>
<span class="line-removed">-                         filter = Stringifiers.forMost(ptypes[i]);</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     case SIZED_EXACT:</span>
<span class="line-removed">-                         // In exact mode, we convert everything to String:</span>
<span class="line-removed">-                         // this helps to compute the storage exactly.</span>
<span class="line-removed">-                         filter = Stringifiers.forAny(ptypes[i]);</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     default:</span>
<span class="line-removed">-                         throw new StringConcatException(&quot;Not supported&quot;);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (filter != null) {</span>
<span class="line-removed">-                     filters[i] = filter;</span>
<span class="line-removed">-                     ptypes[i] = filter.type().returnType();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             MethodHandle[] lengthers = new MethodHandle[pc];</span>
<span class="line-modified">! </span>
<span class="line-modified">!             // Figure out lengths: constants&#39; lengths can be deduced on the spot.</span>
<span class="line-modified">!             // All reference arguments were filtered to String in the combinators below, so we can</span>
<span class="line-modified">!             // call the usual String.length(). Primitive values string sizes can be estimated.</span>
<span class="line-removed">-             int initial = 0;</span>
<span class="line-removed">-             for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed">-                 switch (el.getTag()) {</span>
<span class="line-removed">-                     case TAG_CONST:</span>
<span class="line-removed">-                         initial += el.getValue().length();</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     case TAG_ARG:</span>
<span class="line-removed">-                         final int i = el.getArgPos();</span>
<span class="line-removed">-                         Class&lt;?&gt; type = ptypes[i];</span>
<span class="line-removed">-                         if (type.isPrimitive()) {</span>
<span class="line-removed">-                             MethodHandle est = MethodHandles.constant(int.class, estimateSize(type));</span>
<span class="line-removed">-                             est = MethodHandles.dropArguments(est, 0, type);</span>
<span class="line-removed">-                             lengthers[i] = est;</span>
<span class="line-removed">-                         } else {</span>
<span class="line-removed">-                             lengthers[i] = STRING_LENGTH;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     default:</span>
<span class="line-removed">-                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
  
<span class="line-removed">-             // Create (StringBuilder, &lt;args&gt;) shape for appending:</span>
<span class="line-removed">-             MethodHandle builder = MethodHandles.dropArguments(MethodHandles.identity(StringBuilder.class), 1, ptypes);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Compose append calls. This is done in reverse because the application order is</span>
<span class="line-removed">-             // reverse as well.</span>
<span class="line-removed">-             List&lt;RecipeElement&gt; elements = recipe.getElements();</span>
<span class="line-removed">-             for (int i = elements.size() - 1; i &gt;= 0; i--) {</span>
<span class="line-removed">-                 RecipeElement el = elements.get(i);</span>
<span class="line-removed">-                 MethodHandle appender;</span>
<span class="line-removed">-                 switch (el.getTag()) {</span>
<span class="line-removed">-                     case TAG_CONST:</span>
<span class="line-removed">-                         MethodHandle mh = appender(adaptToStringBuilder(String.class));</span>
<span class="line-removed">-                         appender = MethodHandles.insertArguments(mh, 1, el.getValue());</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     case TAG_ARG:</span>
<span class="line-removed">-                         int ac = el.getArgPos();</span>
<span class="line-removed">-                         appender = appender(ptypes[ac]);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                         // Insert dummy arguments to match the prefix in the signature.</span>
<span class="line-removed">-                         // The actual appender argument will be the ac-ith argument.</span>
<span class="line-removed">-                         if (ac != 0) {</span>
<span class="line-removed">-                             appender = MethodHandles.dropArguments(appender, 1, Arrays.copyOf(ptypes, ac));</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     default:</span>
<span class="line-removed">-                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
                  }
<span class="line-removed">-                 builder = MethodHandles.foldArguments(builder, appender);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Build the sub-tree that adds the sizes and produces a StringBuilder:</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // a) Start with the reducer that accepts all arguments, plus one</span>
<span class="line-removed">-             //    slot for the initial value. Inject the initial value right away.</span>
<span class="line-removed">-             //    This produces (&lt;ints&gt;)int shape:</span>
<span class="line-removed">-             MethodHandle sum = getReducerFor(pc + 1);</span>
<span class="line-removed">-             MethodHandle adder = MethodHandles.insertArguments(sum, 0, initial);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // b) Apply lengthers to transform arguments to lengths, producing (&lt;args&gt;)int</span>
<span class="line-removed">-             adder = MethodHandles.filterArguments(adder, 0, lengthers);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // c) Instantiate StringBuilder (&lt;args&gt;)int -&gt; (&lt;args&gt;)StringBuilder</span>
<span class="line-removed">-             MethodHandle newBuilder = MethodHandles.filterReturnValue(adder, NEW_STRING_BUILDER);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // d) Fold in StringBuilder constructor, this produces (&lt;args&gt;)StringBuilder</span>
<span class="line-removed">-             MethodHandle mh = MethodHandles.foldArguments(builder, newBuilder);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Convert non-primitive arguments to Strings</span>
<span class="line-removed">-             mh = MethodHandles.filterArguments(mh, 0, filters);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Convert (&lt;args&gt;)StringBuilder to (&lt;args&gt;)String</span>
<span class="line-removed">-             if (DEBUG &amp;&amp; mode.isExact()) {</span>
<span class="line-removed">-                 mh = MethodHandles.filterReturnValue(mh, BUILDER_TO_STRING_CHECKED);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 mh = MethodHandles.filterReturnValue(mh, BUILDER_TO_STRING);</span>
              }
<span class="line-modified">! </span>
<span class="line-removed">-             return mh;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static MethodHandle getReducerFor(int cnt) {</span>
<span class="line-removed">-             return SUMMERS.computeIfAbsent(cnt, SUMMER);</span>
          }
  
<span class="line-modified">!         private static MethodHandle appender(Class&lt;?&gt; appendType) {</span>
<span class="line-modified">!             MethodHandle appender = lookupVirtual(MethodHandles.publicLookup(), StringBuilder.class, &quot;append&quot;,</span>
<span class="line-modified">!                     StringBuilder.class, adaptToStringBuilder(appendType));</span>
<span class="line-modified">! </span>
<span class="line-modified">!             // appenders should return void, this would not modify the target signature during folding</span>
<span class="line-modified">!             MethodType nt = MethodType.methodType(void.class, StringBuilder.class, appendType);</span>
<span class="line-modified">!             return appender.asType(nt);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         private static String toStringChecked(StringBuilder sb) {</span>
<span class="line-removed">-             String s = sb.toString();</span>
<span class="line-removed">-             if (s.length() != sb.capacity()) {</span>
<span class="line-removed">-                 throw new AssertionError(&quot;Exactness check failed: result length = &quot; + s.length() + &quot;, buffer capacity = &quot; + sb.capacity());</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return s;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static int sum(int v1, int v2) {</span>
<span class="line-removed">-             return v1 + v2;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static int sum(int v1, int v2, int v3) {</span>
<span class="line-removed">-             return v1 + v2 + v3;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static int sum(int v1, int v2, int v3, int v4) {</span>
<span class="line-removed">-             return v1 + v2 + v3 + v4;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static int sum(int v1, int v2, int v3, int v4, int v5) {</span>
<span class="line-removed">-             return v1 + v2 + v3 + v4 + v5;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6) {</span>
<span class="line-removed">-             return v1 + v2 + v3 + v4 + v5 + v6;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6, int v7) {</span>
<span class="line-removed">-             return v1 + v2 + v3 + v4 + v5 + v6 + v7;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8) {</span>
<span class="line-removed">-             return v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static int sum(int initial, int[] vs) {</span>
<span class="line-removed">-             int sum = initial;</span>
<span class="line-removed">-             for (int v : vs) {</span>
<span class="line-removed">-                 sum += v;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return sum;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static final Lookup MHSBS_LOOKUP = lookup();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static final ConcurrentMap&lt;Integer, MethodHandle&gt; SUMMERS;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-removed">-         private static final Function&lt;Integer, MethodHandle&gt; SUMMER = new Function&lt;Integer, MethodHandle&gt;() {</span>
<span class="line-removed">-             @Override</span>
<span class="line-removed">-             public MethodHandle apply(Integer cnt) {</span>
<span class="line-removed">-                 if (cnt == 1) {</span>
<span class="line-removed">-                     return MethodHandles.identity(int.class);</span>
<span class="line-removed">-                 } else if (cnt &lt;= 8) {</span>
<span class="line-removed">-                     // Variable-arity collectors are not as efficient as small-count methods,</span>
<span class="line-removed">-                     // unroll some initial sizes.</span>
<span class="line-removed">-                     Class&lt;?&gt;[] cls = new Class&lt;?&gt;[cnt];</span>
<span class="line-removed">-                     Arrays.fill(cls, int.class);</span>
<span class="line-removed">-                     return lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class, &quot;sum&quot;, int.class, cls);</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     return lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class, &quot;sum&quot;, int.class, int.class, int[].class)</span>
<span class="line-removed">-                             .asCollector(int[].class, cnt - 1);</span>
                  }
<span class="line-modified">!             }</span>
<span class="line-modified">!         };</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static final MethodHandle NEW_STRING_BUILDER, STRING_LENGTH, BUILDER_TO_STRING, BUILDER_TO_STRING_CHECKED;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static {</span>
<span class="line-removed">-             SUMMERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-removed">-             Lookup publicLookup = MethodHandles.publicLookup();</span>
<span class="line-removed">-             NEW_STRING_BUILDER = lookupConstructor(publicLookup, StringBuilder.class, int.class);</span>
<span class="line-removed">-             STRING_LENGTH = lookupVirtual(publicLookup, String.class, &quot;length&quot;, int.class);</span>
<span class="line-removed">-             BUILDER_TO_STRING = lookupVirtual(publicLookup, StringBuilder.class, &quot;toString&quot;, String.class);</span>
<span class="line-removed">-             if (DEBUG) {</span>
<span class="line-removed">-                 BUILDER_TO_STRING_CHECKED = lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class,</span>
<span class="line-removed">-                         &quot;toStringChecked&quot;, String.class, StringBuilder.class);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 BUILDER_TO_STRING_CHECKED = null;</span>
              }
          }
  
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_INLINE_SIZED_EXACT}: &quot;MethodHandles inline,</span>
<span class="line-removed">-      * sized exactly&quot;.&lt;/b&gt;</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the</span>
<span class="line-removed">-      * byte[] array on its own and passes that byte[] array to String</span>
<span class="line-removed">-      * constructor. This strategy requires access to some private APIs in JDK,</span>
<span class="line-removed">-      * most notably, the read-only Integer/Long.stringSize methods that measure</span>
<span class="line-removed">-      * the character length of the integers, and the private String constructor</span>
<span class="line-removed">-      * that accepts byte[] arrays without copying. While this strategy assumes a</span>
<span class="line-removed">-      * particular implementation details for String, this opens the door for</span>
<span class="line-removed">-      * building a very optimal concatenation sequence. This is the only strategy</span>
<span class="line-removed">-      * that requires porting if there are private JDK changes occur.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static final class MethodHandleInlineCopyStrategy {</span>
<span class="line-removed">-         private MethodHandleInlineCopyStrategy() {</span>
<span class="line-removed">-             // no instantiation</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static MethodHandle generate(MethodType mt, Recipe recipe) throws Throwable {</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Fast-path two-argument Object + Object concatenations</span>
<span class="line-removed">-             if (recipe.getElements().size() == 2) {</span>
<span class="line-removed">-                 // Two object arguments</span>
<span class="line-removed">-                 if (mt.parameterCount() == 2 &amp;&amp;</span>
<span class="line-removed">-                     !mt.parameterType(0).isPrimitive() &amp;&amp;</span>
<span class="line-removed">-                     !mt.parameterType(1).isPrimitive() &amp;&amp;</span>
<span class="line-removed">-                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;</span>
<span class="line-removed">-                     recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
  
<span class="line-modified">!                     return simpleConcat();</span>
  
<span class="line-modified">!                 } else if (mt.parameterCount() == 1 &amp;&amp;</span>
<span class="line-removed">-                            !mt.parameterType(0).isPrimitive()) {</span>
<span class="line-removed">-                     // One Object argument, one constant</span>
<span class="line-removed">-                     MethodHandle mh = simpleConcat();</span>
  
<span class="line-modified">!                     if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-modified">!                         recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="line-modified">!                         // First recipe element is a constant</span>
<span class="line-removed">-                         return MethodHandles.insertArguments(mh, 0,</span>
<span class="line-removed">-                                 recipe.getElements().get(0).getValue());</span>
  
<span class="line-modified">!                     } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-modified">!                                recipe.getElements().get(0).getTag() == TAG_ARG) {</span>
<span class="line-modified">!                         // Second recipe element is a constant</span>
<span class="line-modified">!                         return MethodHandles.insertArguments(mh, 1,</span>
<span class="line-modified">!                                 recipe.getElements().get(1).getValue());</span>
  
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 }</span>
<span class="line-removed">-                 // else... fall-through to slow-path</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             // Create filters and obtain filtered parameter types. Filters would be used in the beginning</span>
<span class="line-modified">!             // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).</span>
<span class="line-modified">!             // The filtered argument type list is used all over in the combinators below.</span>
<span class="line-modified">!             Class&lt;?&gt;[] ptypes = mt.parameterArray();</span>
<span class="line-modified">!             MethodHandle[] filters = null;</span>
<span class="line-modified">!             for (int i = 0; i &lt; ptypes.length; i++) {</span>
<span class="line-removed">-                 MethodHandle filter = Stringifiers.forMost(ptypes[i]);</span>
<span class="line-removed">-                 if (filter != null) {</span>
<span class="line-removed">-                     if (filters == null) {</span>
<span class="line-removed">-                         filters = new MethodHandle[ptypes.length];</span>
                      }
<span class="line-modified">!                     filters[i] = filter;</span>
<span class="line-removed">-                     ptypes[i] = filter.type().returnType();</span>
                  }
<span class="line-modified">!             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;</span>
<span class="line-removed">-             // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are</span>
<span class="line-removed">-             // assembled bottom-up, which makes the code arguably hard to read.</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Drop all remaining parameter types, leave only helper arguments:</span>
<span class="line-removed">-             MethodHandle mh;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             mh = MethodHandles.dropArguments(newString(), 2, ptypes);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             long initialLengthCoder = INITIAL_CODER;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already</span>
<span class="line-removed">-             // known from the combinators below. We are assembling the string backwards, so the index coded</span>
<span class="line-removed">-             // into indexCoder is the *ending* index.</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // We need one prepender per argument, but also need to fold in constants. We do so by greedily</span>
<span class="line-removed">-             // create prependers that fold in surrounding constants into the argument prepender. This reduces</span>
<span class="line-removed">-             // the number of unique MH combinator tree shapes we&#39;ll create in an application.</span>
<span class="line-removed">-             String prefixConstant = null, suffixConstant = null;</span>
<span class="line-removed">-             int pos = -1;</span>
<span class="line-removed">-             for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed">-                 // Do the prepend, and put &quot;new&quot; index at index 1</span>
<span class="line-removed">-                 switch (el.getTag()) {</span>
<span class="line-removed">-                     case TAG_CONST: {</span>
<span class="line-removed">-                         String constantValue = el.getValue();</span>
<span class="line-removed">- </span>
<span class="line-removed">-                         // Eagerly update the initialLengthCoder value</span>
<span class="line-removed">-                         initialLengthCoder = (long)mixer(String.class).invoke(initialLengthCoder, constantValue);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                         if (pos &lt; 0) {</span>
<span class="line-removed">-                             // Collecting into prefixConstant</span>
<span class="line-removed">-                             prefixConstant = prefixConstant == null ? constantValue : prefixConstant + constantValue;</span>
<span class="line-removed">-                         } else {</span>
<span class="line-removed">-                             // Collecting into suffixConstant</span>
<span class="line-removed">-                             suffixConstant = suffixConstant == null ? constantValue : suffixConstant + constantValue;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     case TAG_ARG: {</span>
  
<span class="line-modified">!                         if (pos &gt;= 0) {</span>
<span class="line-modified">!                             // Flush the previous non-constant arg with any prefix/suffix constant</span>
<span class="line-modified">!                             mh = MethodHandles.filterArgumentsWithCombiner(</span>
                                  mh, 1,
                                  prepender(prefixConstant, ptypes[pos], suffixConstant),
                                  1, 0, // indexCoder, storage
                                  2 + pos  // selected argument
<span class="line-modified">!                             );</span>
<span class="line-modified">!                             prefixConstant = suffixConstant = null;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         // Mark the pos of next non-constant arg</span>
<span class="line-removed">-                         pos = el.getArgPos();</span>
<span class="line-removed">-                         break;</span>
                      }
<span class="line-modified">!                     default:</span>
<span class="line-modified">!                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
                  }
              }
  
<span class="line-modified">!             // Insert any trailing args, constants</span>
<span class="line-modified">!             if (pos &gt;= 0) {</span>
<span class="line-modified">!                 mh = MethodHandles.filterArgumentsWithCombiner(</span>
                      mh, 1,
                      prepender(prefixConstant, ptypes[pos], suffixConstant),
                      1, 0, // indexCoder, storage
                      2 + pos  // selected argument
<span class="line-modified">!                 );</span>
<span class="line-modified">!             } else if (prefixConstant != null) {</span>
<span class="line-modified">!                 assert (suffixConstant == null);</span>
<span class="line-modified">!                 // Sole prefixConstant can only happen if there were no non-constant arguments</span>
<span class="line-modified">!                 mh = MethodHandles.filterArgumentsWithCombiner(</span>
                      mh, 1,
                      MethodHandles.insertArguments(prepender(null, String.class, null), 2, prefixConstant),
                      1, 0 // indexCoder, storage
<span class="line-removed">-                 );</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Fold in byte[] instantiation at argument 0</span>
<span class="line-removed">-             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArray(),</span>
<span class="line-removed">-                     1 // index</span>
              );
  
<span class="line-modified">!             // Start combining length and coder mixers.</span>
<span class="line-modified">!             //</span>
<span class="line-modified">!             // Length is easy: constant lengths can be computed on the spot, and all non-constant</span>
<span class="line-modified">!             // shapes have been either converted to Strings, or explicit methods for getting the</span>
<span class="line-modified">!             // string length out of primitives are provided.</span>
<span class="line-modified">!             //</span>
<span class="line-modified">!             // Coders are more interesting. Only Object, String and char arguments (and constants)</span>
<span class="line-modified">!             // can have non-Latin1 encoding. It is easier to blindly convert constants to String,</span>
<span class="line-modified">!             // and deduce the coder from there. Arguments would be either converted to Strings</span>
<span class="line-modified">!             // during the initial filtering, or handled by specializations in MIXERS.</span>
<span class="line-modified">!             //</span>
<span class="line-modified">!             // The method handle shape before all mixers are combined in is:</span>
<span class="line-modified">!             //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)</span>
<span class="line-modified">!             //</span>
<span class="line-modified">!             // We will bind the initialLengthCoder value to the last mixer (the one that will be</span>
<span class="line-modified">!             // executed first), then fold that in. This leaves the shape after all mixers are</span>
<span class="line-modified">!             // combined in as:</span>
<span class="line-modified">!             //   (&lt;args&gt;)String = (&lt;args&gt;)</span>
<span class="line-modified">! </span>
<span class="line-modified">!             int ac = -1;</span>
<span class="line-modified">!             MethodHandle mix = null;</span>
<span class="line-modified">!             for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-modified">!                 switch (el.getTag()) {</span>
<span class="line-modified">!                     case TAG_CONST:</span>
<span class="line-modified">!                         // Constants already handled in the code above</span>
<span class="line-modified">!                         break;</span>
<span class="line-modified">!                     case TAG_ARG:</span>
<span class="line-modified">!                         if (ac &gt;= 0) {</span>
<span class="line-modified">!                             // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.</span>
<span class="line-modified">!                             mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-modified">!                                     0, // old-index</span>
<span class="line-modified">!                                     1 + ac // selected argument</span>
<span class="line-modified">!                             );</span>
<span class="line-modified">!                         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         ac = el.getArgPos();</span>
<span class="line-modified">!                         Class&lt;?&gt; argClass = ptypes[ac];</span>
<span class="line-modified">!                         mix = mixer(argClass);</span>
<span class="line-modified">! </span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     default:</span>
<span class="line-removed">-                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             // Insert the initialLengthCoder value into the final mixer, then</span>
<span class="line-modified">!             // fold that into the base method handle</span>
<span class="line-modified">!             if (ac &gt;= 0) {</span>
<span class="line-modified">!                 mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);</span>
<span class="line-modified">!                 mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-modified">!                         1 + ac // selected argument</span>
<span class="line-modified">!                 );</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 // No mixer (constants only concat), insert initialLengthCoder directly</span>
<span class="line-removed">-                 mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);</span>
              }
  
<span class="line-modified">!             // The method handle shape here is (&lt;args&gt;).</span>
  
<span class="line-modified">!             // Apply filters, converting the arguments:</span>
<span class="line-removed">-             if (filters != null) {</span>
<span class="line-removed">-                 mh = MethodHandles.filterArguments(mh, 0, filters);</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             return mh;</span>
          }
  
<span class="line-modified">!         private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {</span>
<span class="line-modified">!             return MethodHandles.insertArguments(</span>
<span class="line-modified">!                     MethodHandles.insertArguments(</span>
<span class="line-modified">!                         PREPENDERS.computeIfAbsent(cl, PREPEND), 2, prefix), 3, suffix);</span>
          }
  
<span class="line-modified">!         private static MethodHandle mixer(Class&lt;?&gt; cl) {</span>
<span class="line-modified">!             return MIXERS.computeIfAbsent(cl, MIX);</span>
          }
  
<span class="line-modified">!         // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-modified">!         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-modified">!                 return JLA.stringConcatHelper(&quot;prepend&quot;,</span>
<span class="line-modified">!                             methodType(long.class, long.class, byte[].class,</span>
<span class="line-modified">!                                        String.class, Wrapper.asPrimitiveType(c), String.class));</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         };</span>
  
<span class="line-modified">!         // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-modified">!         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-modified">!                 return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         };</span>
  
<span class="line-modified">!         private @Stable static MethodHandle SIMPLE_CONCAT;</span>
<span class="line-modified">!         private static MethodHandle simpleConcat() {</span>
<span class="line-modified">!             if (SIMPLE_CONCAT == null) {</span>
<span class="line-modified">!                 SIMPLE_CONCAT = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return SIMPLE_CONCAT;</span>
          }
  
<span class="line-modified">!         private @Stable static MethodHandle NEW_STRING;</span>
<span class="line-modified">!         private static MethodHandle newString() {</span>
<span class="line-modified">!             MethodHandle mh = NEW_STRING;</span>
<span class="line-modified">!             if (mh == null) {</span>
<span class="line-modified">!                 NEW_STRING = mh =</span>
                      JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));
<span class="line-removed">-             }</span>
<span class="line-removed">-             return mh;</span>
          }
<span class="line-modified">!         private @Stable static MethodHandle NEW_ARRAY;</span>
<span class="line-modified">!         private static MethodHandle newArray() {</span>
<span class="line-modified">!             MethodHandle mh = NEW_ARRAY;</span>
<span class="line-modified">!             if (mh == null) {</span>
<span class="line-modified">!                 NEW_ARRAY = mh =</span>
                      JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));
<span class="line-removed">-             }</span>
<span class="line-removed">-             return mh;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;</span>
<span class="line-removed">-         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;</span>
<span class="line-removed">-         private static final long INITIAL_CODER;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static {</span>
<span class="line-removed">-             INITIAL_CODER = JLA.stringConcatInitialCoder();</span>
<span class="line-removed">-             PREPENDERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-removed">-             MIXERS = new ConcurrentHashMap&lt;&gt;();</span>
          }
      }
  
      /**
<span class="line-modified">!      * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally</span>
<span class="line-modified">!      * delegate to {@code String.valueOf}, depending on argument&#39;s type.</span>
       */
<span class="line-modified">!     private static final class Stringifiers {</span>
<span class="line-modified">!         private Stringifiers() {</span>
<span class="line-modified">!             // no instantiation</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         private static final MethodHandle OBJECT_INSTANCE =</span>
<span class="line-modified">!                 JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));</span>
<span class="line-modified">! </span>
<span class="line-modified">!         private static class FloatStringifiers {</span>
<span class="line-modified">!             private static final MethodHandle FLOAT_INSTANCE =</span>
                      lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
<span class="line-removed">- </span>
<span class="line-removed">-             private static final MethodHandle DOUBLE_INSTANCE =</span>
<span class="line-removed">-                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static class StringifierAny extends ClassValue&lt;MethodHandle&gt; {</span>
<span class="line-removed">- </span>
<span class="line-removed">-             private static final ClassValue&lt;MethodHandle&gt; INSTANCE = new StringifierAny();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             @Override</span>
<span class="line-removed">-             protected MethodHandle computeValue(Class&lt;?&gt; cl) {</span>
<span class="line-removed">-                 if (cl == byte.class || cl == short.class || cl == int.class) {</span>
<span class="line-removed">-                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, int.class);</span>
<span class="line-removed">-                 } else if (cl == boolean.class) {</span>
<span class="line-removed">-                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, boolean.class);</span>
<span class="line-removed">-                 } else if (cl == char.class) {</span>
<span class="line-removed">-                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, char.class);</span>
<span class="line-removed">-                 } else if (cl == long.class) {</span>
<span class="line-removed">-                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, long.class);</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     MethodHandle mh = forMost(cl);</span>
<span class="line-removed">-                     if (mh != null) {</span>
<span class="line-removed">-                         return mh;</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         throw new IllegalStateException(&quot;Unknown class: &quot; + cl);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Returns a stringifier for references and floats/doubles only.</span>
<span class="line-removed">-          * Always returns null for other primitives.</span>
<span class="line-removed">-          *</span>
<span class="line-removed">-          * @param t class to stringify</span>
<span class="line-removed">-          * @return stringifier; null, if not available</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         static MethodHandle forMost(Class&lt;?&gt; t) {</span>
<span class="line-removed">-             if (!t.isPrimitive()) {</span>
<span class="line-removed">-                 return OBJECT_INSTANCE;</span>
<span class="line-removed">-             } else if (t == float.class) {</span>
<span class="line-removed">-                 return FloatStringifiers.FLOAT_INSTANCE;</span>
<span class="line-removed">-             } else if (t == double.class) {</span>
<span class="line-removed">-                 return FloatStringifiers.DOUBLE_INSTANCE;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return null;</span>
          }
<span class="line-modified">! </span>
<span class="line-modified">!         /**</span>
<span class="line-modified">!          * Returns a stringifier for any type. Never returns null.</span>
<span class="line-modified">!          *</span>
<span class="line-modified">!          * @param t class to stringify</span>
<span class="line-modified">!          * @return stringifier</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         static MethodHandle forAny(Class&lt;?&gt; t) {</span>
<span class="line-removed">-             return StringifierAny.INSTANCE.get(t);</span>
          }
      }
  
<span class="line-modified">!     /* ------------------------------- Common utilities ------------------------------------ */</span>
  
<span class="line-modified">!     static MethodHandle lookupStatic(Lookup lookup, Class&lt;?&gt; refc, String name, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             return lookup.findStatic(refc, name, MethodType.methodType(rtype, ptypes));</span>
<span class="line-modified">!         } catch (NoSuchMethodException | IllegalAccessException e) {</span>
<span class="line-modified">!             throw new AssertionError(e);</span>
<span class="line-removed">-         }</span>
      }
  
<span class="line-modified">!     static MethodHandle lookupVirtual(Lookup lookup, Class&lt;?&gt; refc, String name, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             return lookup.findVirtual(refc, name, MethodType.methodType(rtype, ptypes));</span>
<span class="line-modified">!         } catch (NoSuchMethodException | IllegalAccessException e) {</span>
<span class="line-modified">!             throw new AssertionError(e);</span>
<span class="line-modified">!         }</span>
      }
  
<span class="line-modified">!     static MethodHandle lookupConstructor(Lookup lookup, Class&lt;?&gt; refc, Class&lt;?&gt; ptypes) {</span>
          try {
<span class="line-modified">!             return lookup.findConstructor(refc, MethodType.methodType(void.class, ptypes));</span>
          } catch (NoSuchMethodException | IllegalAccessException e) {
              throw new AssertionError(e);
          }
      }
  
<span class="line-removed">-     static int estimateSize(Class&lt;?&gt; cl) {</span>
<span class="line-removed">-         if (cl == Integer.TYPE) {</span>
<span class="line-removed">-             return 11; // &quot;-2147483648&quot;</span>
<span class="line-removed">-         } else if (cl == Boolean.TYPE) {</span>
<span class="line-removed">-             return 5; // &quot;false&quot;</span>
<span class="line-removed">-         } else if (cl == Byte.TYPE) {</span>
<span class="line-removed">-             return 4; // &quot;-128&quot;</span>
<span class="line-removed">-         } else if (cl == Character.TYPE) {</span>
<span class="line-removed">-             return 1; // duh</span>
<span class="line-removed">-         } else if (cl == Short.TYPE) {</span>
<span class="line-removed">-             return 6; // &quot;-32768&quot;</span>
<span class="line-removed">-         } else if (cl == Double.TYPE) {</span>
<span class="line-removed">-             return 26; // apparently, no larger than this, see FloatingDecimal.BinaryToASCIIBuffer.buffer</span>
<span class="line-removed">-         } else if (cl == Float.TYPE) {</span>
<span class="line-removed">-             return 26; // apparently, no larger than this, see FloatingDecimal.BinaryToASCIIBuffer.buffer</span>
<span class="line-removed">-         } else if (cl == Long.TYPE)  {</span>
<span class="line-removed">-             return 20; // &quot;-9223372036854775808&quot;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;Cannot estimate the size for &quot; + cl);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static Class&lt;?&gt; adaptToStringBuilder(Class&lt;?&gt; c) {</span>
<span class="line-removed">-         if (c.isPrimitive()) {</span>
<span class="line-removed">-             if (c == Byte.TYPE || c == Short.TYPE) {</span>
<span class="line-removed">-                 return int.class;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             if (c != String.class) {</span>
<span class="line-removed">-                 return Object.class;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return c;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      private StringConcatFactory() {
          // no instantiation
      }
<span class="line-removed">- </span>
  }
<span class="line-new-header">--- 520,370 ---</span>
                      concatType.parameterSlotCount() +
                      &quot;, can only accept &quot; +
                      MAX_INDY_CONCAT_ARG_SLOTS);
          }
  
          Recipe rec = new Recipe(recipe, constants);
<span class="line-modified">!         MethodHandle mh = generate(lookup, concatType, rec);</span>
          return new ConstantCallSite(mh.asType(concatType));
      }
  
      private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {
          try {
<span class="line-modified">!             return generateMHInlineCopy(mt, recipe);</span>
          } catch (Error | StringConcatException e) {
              // Pass through any error or existing StringConcatException
              throw e;
          } catch (Throwable t) {
              throw new StringConcatException(&quot;Generator failed&quot;, t);
          }
      }
  
  
      /**
<span class="line-modified">!      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the</span>
<span class="line-modified">!      * byte[] array on its own and passes that byte[] array to String</span>
<span class="line-modified">!      * constructor. This strategy requires access to some private APIs in JDK,</span>
<span class="line-modified">!      * most notably, the private String constructor that accepts byte[] arrays</span>
<span class="line-modified">!      * without copying.</span>
       */
<span class="line-modified">!     private static MethodHandle generateMHInlineCopy(MethodType mt, Recipe recipe) throws Throwable {</span>
  
<span class="line-modified">!         // Fast-path two-argument Object + Object concatenations</span>
<span class="line-modified">!         if (recipe.getElements().size() == 2) {</span>
<span class="line-modified">!             // Two object arguments</span>
<span class="line-modified">!             if (mt.parameterCount() == 2 &amp;&amp;</span>
<span class="line-modified">!                     !mt.parameterType(0).isPrimitive() &amp;&amp;</span>
<span class="line-modified">!                     !mt.parameterType(1).isPrimitive() &amp;&amp;</span>
<span class="line-modified">!                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;</span>
<span class="line-modified">!                     recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
  
<span class="line-modified">!                 return simpleConcat();</span>
  
<span class="line-modified">!             } else if (mt.parameterCount() == 1 &amp;&amp;</span>
<span class="line-modified">!                     !mt.parameterType(0).isPrimitive()) {</span>
<span class="line-modified">!                 // One Object argument, one constant</span>
<span class="line-modified">!                 MethodHandle mh = simpleConcat();</span>
  
<span class="line-modified">!                 if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-modified">!                         recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="line-modified">!                     // First recipe element is a constant</span>
<span class="line-modified">!                     return MethodHandles.insertArguments(mh, 0,</span>
<span class="line-modified">!                             recipe.getElements().get(0).getValue());</span>
  
<span class="line-modified">!                 } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-modified">!                         recipe.getElements().get(0).getTag() == TAG_ARG) {</span>
<span class="line-modified">!                     // Second recipe element is a constant</span>
<span class="line-modified">!                     return MethodHandles.insertArguments(mh, 1,</span>
<span class="line-modified">!                             recipe.getElements().get(1).getValue());</span>
  
                  }
              }
<span class="line-modified">!             // else... fall-through to slow-path</span>
          }
  
<span class="line-modified">!         // Create filters and obtain filtered parameter types. Filters would be used in the beginning</span>
<span class="line-modified">!         // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).</span>
<span class="line-modified">!         // The filtered argument type list is used all over in the combinators below.</span>
<span class="line-modified">!         Class&lt;?&gt;[] ptypes = mt.parameterArray();</span>
<span class="line-modified">!         MethodHandle[] filters = null;</span>
<span class="line-modified">!         for (int i = 0; i &lt; ptypes.length; i++) {</span>
<span class="line-modified">!             MethodHandle filter = stringifierFor(ptypes[i]);</span>
<span class="line-modified">!             if (filter != null) {</span>
<span class="line-modified">!                 if (filters == null) {</span>
<span class="line-modified">!                     filters = new MethodHandle[ptypes.length];</span>
                  }
<span class="line-modified">!                 filters[i] = filter;</span>
<span class="line-modified">!                 ptypes[i] = filter.type().returnType();</span>
              }
          }
  
<span class="line-modified">!         // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;</span>
<span class="line-modified">!         // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are</span>
<span class="line-added">+         // assembled bottom-up, which makes the code arguably hard to read.</span>
  
<span class="line-modified">!         // Drop all remaining parameter types, leave only helper arguments:</span>
<span class="line-modified">!         MethodHandle mh;</span>
  
<span class="line-modified">!         mh = MethodHandles.dropArguments(newString(), 2, ptypes);</span>
  
<span class="line-modified">!         long initialLengthCoder = INITIAL_CODER;</span>
  
<span class="line-modified">!         // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already</span>
<span class="line-modified">!         // known from the combinators below. We are assembling the string backwards, so the index coded</span>
<span class="line-modified">!         // into indexCoder is the *ending* index.</span>
  
<span class="line-modified">!         // We need one prepender per argument, but also need to fold in constants. We do so by greedily</span>
<span class="line-modified">!         // create prependers that fold in surrounding constants into the argument prepender. This reduces</span>
<span class="line-modified">!         // the number of unique MH combinator tree shapes we&#39;ll create in an application.</span>
<span class="line-modified">!         String prefixConstant = null, suffixConstant = null;</span>
<span class="line-modified">!         int pos = -1;</span>
<span class="line-added">+         for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-added">+             // Do the prepend, and put &quot;new&quot; index at index 1</span>
<span class="line-added">+             switch (el.getTag()) {</span>
<span class="line-added">+                 case TAG_CONST: {</span>
<span class="line-added">+                     String constantValue = el.getValue();</span>
  
<span class="line-modified">!                     // Eagerly update the initialLengthCoder value</span>
<span class="line-modified">!                     initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, constantValue);</span>
  
<span class="line-modified">!                     if (pos &lt; 0) {</span>
<span class="line-modified">!                         // Collecting into prefixConstant</span>
<span class="line-modified">!                         prefixConstant = prefixConstant == null ? constantValue : prefixConstant + constantValue;</span>
<span class="line-modified">!                     } else {</span>
<span class="line-modified">!                         // Collecting into suffixConstant</span>
<span class="line-modified">!                         suffixConstant = suffixConstant == null ? constantValue : suffixConstant + constantValue;</span>
                      }
<span class="line-modified">!                     break;</span>
                  }
<span class="line-modified">!                 case TAG_ARG: {</span>
  
<span class="line-modified">!                     if (pos &gt;= 0) {</span>
<span class="line-modified">!                         // Flush the previous non-constant arg with any prefix/suffix constant</span>
<span class="line-modified">!                         mh = MethodHandles.filterArgumentsWithCombiner(</span>
                                  mh, 1,
                                  prepender(prefixConstant, ptypes[pos], suffixConstant),
                                  1, 0, // indexCoder, storage
                                  2 + pos  // selected argument
<span class="line-modified">!                         );</span>
<span class="line-modified">!                         prefixConstant = suffixConstant = null;</span>
                      }
<span class="line-modified">!                     // Mark the pos of next non-constant arg</span>
<span class="line-modified">!                     pos = el.getArgPos();</span>
<span class="line-added">+                     break;</span>
                  }
<span class="line-added">+                 default:</span>
<span class="line-added">+                     throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
              }
<span class="line-added">+         }</span>
  
<span class="line-modified">!         // Insert any trailing args, constants</span>
<span class="line-modified">!         if (pos &gt;= 0) {</span>
<span class="line-modified">!             mh = MethodHandles.filterArgumentsWithCombiner(</span>
                      mh, 1,
                      prepender(prefixConstant, ptypes[pos], suffixConstant),
                      1, 0, // indexCoder, storage
                      2 + pos  // selected argument
<span class="line-modified">!             );</span>
<span class="line-modified">!         } else if (prefixConstant != null) {</span>
<span class="line-modified">!             assert (suffixConstant == null);</span>
<span class="line-modified">!             // Sole prefixConstant can only happen if there were no non-constant arguments</span>
<span class="line-modified">!             mh = MethodHandles.filterArgumentsWithCombiner(</span>
                      mh, 1,
                      MethodHandles.insertArguments(prepender(null, String.class, null), 2, prefixConstant),
                      1, 0 // indexCoder, storage
              );
<span class="line-added">+         }</span>
  
<span class="line-modified">!         // Fold in byte[] instantiation at argument 0</span>
<span class="line-modified">!         mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArray(),</span>
<span class="line-modified">!                 1 // index</span>
<span class="line-modified">!         );</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Start combining length and coder mixers.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Length is easy: constant lengths can be computed on the spot, and all non-constant</span>
<span class="line-modified">!         // shapes have been either converted to Strings, or explicit methods for getting the</span>
<span class="line-modified">!         // string length out of primitives are provided.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Coders are more interesting. Only Object, String and char arguments (and constants)</span>
<span class="line-modified">!         // can have non-Latin1 encoding. It is easier to blindly convert constants to String,</span>
<span class="line-modified">!         // and deduce the coder from there. Arguments would be either converted to Strings</span>
<span class="line-modified">!         // during the initial filtering, or handled by specializations in MIXERS.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // The method handle shape before all mixers are combined in is:</span>
<span class="line-modified">!         //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // We will bind the initialLengthCoder value to the last mixer (the one that will be</span>
<span class="line-modified">!         // executed first), then fold that in. This leaves the shape after all mixers are</span>
<span class="line-modified">!         // combined in as:</span>
<span class="line-modified">!         //   (&lt;args&gt;)String = (&lt;args&gt;)</span>
<span class="line-modified">! </span>
<span class="line-modified">!         int ac = -1;</span>
<span class="line-modified">!         MethodHandle mix = null;</span>
<span class="line-modified">!         for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-modified">!             switch (el.getTag()) {</span>
<span class="line-modified">!                 case TAG_CONST:</span>
<span class="line-modified">!                     // Constants already handled in the code above</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 case TAG_ARG:</span>
<span class="line-modified">!                     if (ac &gt;= 0) {</span>
<span class="line-modified">!                         // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.</span>
<span class="line-modified">!                         mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-modified">!                                 0, // old-index</span>
<span class="line-modified">!                                 1 + ac // selected argument</span>
<span class="line-modified">!                         );</span>
<span class="line-modified">!                     }</span>
  
<span class="line-modified">!                     ac = el.getArgPos();</span>
<span class="line-modified">!                     Class&lt;?&gt; argClass = ptypes[ac];</span>
<span class="line-modified">!                     mix = mixer(argClass);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 default:</span>
<span class="line-modified">!                     throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
              }
<span class="line-added">+         }</span>
  
<span class="line-modified">!         // Insert the initialLengthCoder value into the final mixer, then</span>
<span class="line-added">+         // fold that into the base method handle</span>
<span class="line-added">+         if (ac &gt;= 0) {</span>
<span class="line-added">+             mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);</span>
<span class="line-added">+             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-added">+                     1 + ac // selected argument</span>
<span class="line-added">+             );</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             // No mixer (constants only concat), insert initialLengthCoder directly</span>
<span class="line-added">+             mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         // The method handle shape here is (&lt;args&gt;).</span>
  
<span class="line-modified">!         // Apply filters, converting the arguments:</span>
<span class="line-added">+         if (filters != null) {</span>
<span class="line-added">+             mh = MethodHandles.filterArguments(mh, 0, filters);</span>
          }
  
<span class="line-modified">!         return mh;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {</span>
<span class="line-added">+         if (prefix == null &amp;&amp; suffix == null) {</span>
<span class="line-added">+             return NULL_PREPENDERS.computeIfAbsent(cl, NULL_PREPEND);</span>
          }
<span class="line-added">+         return MethodHandles.insertArguments(</span>
<span class="line-added">+                         PREPENDERS.computeIfAbsent(cl, PREPEND), 3, prefix, suffix);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     private static MethodHandle mixer(Class&lt;?&gt; cl) {</span>
<span class="line-modified">!         return MIXERS.computeIfAbsent(cl, MIX);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-added">+     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-added">+             return JLA.stringConcatHelper(&quot;prepend&quot;,</span>
<span class="line-added">+                     methodType(long.class, long.class, byte[].class,</span>
<span class="line-added">+                             Wrapper.asPrimitiveType(c), String.class, String.class));</span>
          }
<span class="line-added">+     };</span>
  
<span class="line-modified">!     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; NULL_PREPEND = new Function&lt;&gt;() {</span>
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-modified">!             return MethodHandles.insertArguments(</span>
<span class="line-modified">!                             PREPENDERS.computeIfAbsent(c, PREPEND), 3, (String)null, (String)null);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-modified">!     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {</span>
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-modified">!             return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     private @Stable static MethodHandle SIMPLE_CONCAT;</span>
<span class="line-modified">!     private static MethodHandle simpleConcat() {</span>
<span class="line-modified">!         if (SIMPLE_CONCAT == null) {</span>
<span class="line-modified">!             SIMPLE_CONCAT = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));</span>
          }
<span class="line-added">+         return SIMPLE_CONCAT;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     private @Stable static MethodHandle NEW_STRING;</span>
<span class="line-modified">!     private static MethodHandle newString() {</span>
<span class="line-modified">!         MethodHandle mh = NEW_STRING;</span>
<span class="line-modified">!         if (mh == null) {</span>
<span class="line-modified">!             NEW_STRING = mh =</span>
                      JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));
          }
<span class="line-modified">!         return mh;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     private @Stable static MethodHandle NEW_ARRAY;</span>
<span class="line-modified">!     private static MethodHandle newArray() {</span>
<span class="line-modified">!         MethodHandle mh = NEW_ARRAY;</span>
<span class="line-added">+         if (mh == null) {</span>
<span class="line-added">+             NEW_ARRAY = mh =</span>
                      JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));
          }
<span class="line-added">+         return mh;</span>
      }
  
      /**
<span class="line-modified">!      * Public gateways to public &quot;stringify&quot; methods. These methods have the</span>
<span class="line-modified">!      * form String apply(T obj), and normally delegate to {@code String.valueOf},</span>
<span class="line-added">+      * depending on argument&#39;s type.</span>
       */
<span class="line-modified">!     private @Stable static MethodHandle OBJECT_STRINGIFIER;</span>
<span class="line-modified">!     private static MethodHandle objectStringifier() {</span>
<span class="line-modified">!         MethodHandle mh = OBJECT_STRINGIFIER;</span>
<span class="line-modified">!         if (mh == null) {</span>
<span class="line-modified">!             OBJECT_STRINGIFIER = mh =</span>
<span class="line-modified">!                     JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return mh;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     private @Stable static MethodHandle FLOAT_STRINGIFIER;</span>
<span class="line-added">+     private static MethodHandle floatStringifier() {</span>
<span class="line-added">+         MethodHandle mh = FLOAT_STRINGIFIER;</span>
<span class="line-added">+         if (mh == null) {</span>
<span class="line-added">+             FLOAT_STRINGIFIER = mh =</span>
                      lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
          }
<span class="line-modified">!         return mh;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     private @Stable static MethodHandle DOUBLE_STRINGIFIER;</span>
<span class="line-modified">!     private static MethodHandle doubleStringifier() {</span>
<span class="line-modified">!         MethodHandle mh = DOUBLE_STRINGIFIER;</span>
<span class="line-modified">!         if (mh == null) {</span>
<span class="line-modified">!             DOUBLE_STRINGIFIER = mh =</span>
<span class="line-modified">!                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);</span>
          }
<span class="line-added">+         return mh;</span>
      }
  
<span class="line-modified">!     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;</span>
<span class="line-added">+     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; NULL_PREPENDERS;</span>
<span class="line-added">+     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;</span>
<span class="line-added">+     private static final long INITIAL_CODER;</span>
  
<span class="line-modified">!     static {</span>
<span class="line-modified">!         INITIAL_CODER = JLA.stringConcatInitialCoder();</span>
<span class="line-modified">!         PREPENDERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-modified">!         NULL_PREPENDERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-modified">!         MIXERS = new ConcurrentHashMap&lt;&gt;();</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Returns a stringifier for references and floats/doubles only.</span>
<span class="line-modified">!      * Always returns null for other primitives.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param t class to stringify</span>
<span class="line-modified">!      * @return stringifier; null, if not available</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static MethodHandle stringifierFor(Class&lt;?&gt; t) {</span>
<span class="line-added">+         if (!t.isPrimitive()) {</span>
<span class="line-added">+             return objectStringifier();</span>
<span class="line-added">+         } else if (t == float.class) {</span>
<span class="line-added">+             return floatStringifier();</span>
<span class="line-added">+         } else if (t == double.class) {</span>
<span class="line-added">+             return doubleStringifier();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return null;</span>
      }
  
<span class="line-modified">!     private static MethodHandle lookupStatic(Lookup lookup, Class&lt;?&gt; refc, String name,</span>
<span class="line-added">+                                      Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {</span>
          try {
<span class="line-modified">!             return lookup.findStatic(refc, name, MethodType.methodType(rtype, ptypes));</span>
          } catch (NoSuchMethodException | IllegalAccessException e) {
              throw new AssertionError(e);
          }
      }
  
      private StringConcatFactory() {
          // no instantiation
      }
  }
</pre>
<center><a href="MemoryAccessVarHandleGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/Executable.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
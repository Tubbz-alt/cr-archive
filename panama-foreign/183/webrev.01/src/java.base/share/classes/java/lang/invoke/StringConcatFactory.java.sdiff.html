<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemoryAccessVarHandleGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/Executable.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangAccess;
  29 import jdk.internal.access.SharedSecrets;
<span class="line-removed">  30 import jdk.internal.misc.Unsafe;</span>
<span class="line-removed">  31 import jdk.internal.misc.VM;</span>
<span class="line-removed">  32 import jdk.internal.org.objectweb.asm.ClassWriter;</span>
<span class="line-removed">  33 import jdk.internal.org.objectweb.asm.Label;</span>
<span class="line-removed">  34 import jdk.internal.org.objectweb.asm.MethodVisitor;</span>
<span class="line-removed">  35 import jdk.internal.org.objectweb.asm.Opcodes;</span>
  36 import jdk.internal.vm.annotation.Stable;
  37 import sun.invoke.util.Wrapper;
  38 
  39 import java.lang.invoke.MethodHandles.Lookup;
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
  42 import java.util.List;
  43 import java.util.Objects;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 import java.util.concurrent.ConcurrentMap;
  46 import java.util.function.Function;
  47 
<span class="line-removed">  48 import static java.lang.invoke.MethodHandles.lookup;</span>
  49 import static java.lang.invoke.MethodType.methodType;
<span class="line-removed">  50 import static java.lang.invoke.MethodHandles.Lookup.ClassOption.*;</span>
<span class="line-removed">  51 import static jdk.internal.org.objectweb.asm.Opcodes.*;</span>
  52 
  53 /**
  54  * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
  55  * can be used to efficiently concatenate a known number of arguments of known
  56  * types, possibly after type adaptation and partial evaluation of arguments.
  57  * These methods are typically used as &lt;em&gt;bootstrap methods&lt;/em&gt; for {@code
  58  * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
  59  * feature of the Java Programming Language.
  60  *
  61  * &lt;p&gt;Indirect access to the behavior specified by the provided {@code
  62  * MethodHandle} proceeds in order through two phases:
  63  *
  64  * &lt;ol&gt;
  65  *     &lt;li&gt;&lt;em&gt;Linkage&lt;/em&gt; occurs when the methods in this class are invoked.
  66  * They take as arguments a method type describing the concatenated arguments
  67  * count and types, and optionally the String &lt;em&gt;recipe&lt;/em&gt;, plus the
  68  * constants that participate in the String concatenation. The details on
  69  * accepted recipe shapes are described further below. Linkage may involve
  70  * dynamically loading a new class that implements the expected concatenation
  71  * behavior. The {@code CallSite} holds the {@code MethodHandle} pointing to the
</pre>
<hr />
<pre>
 111 
 112     /**
 113      * Tag used to demarcate an ordinary argument.
 114      */
 115     private static final char TAG_ARG = &#39;\u0001&#39;;
 116 
 117     /**
 118      * Tag used to demarcate a constant.
 119      */
 120     private static final char TAG_CONST = &#39;\u0002&#39;;
 121 
 122     /**
 123      * Maximum number of argument slots in String Concat call.
 124      *
 125      * While the maximum number of argument slots that indy call can handle is 253,
 126      * we do not use all those slots, to let the strategies with MethodHandle
 127      * combinators to use some arguments.
 128      */
 129     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
 130 
<span class="line-removed"> 131     /**</span>
<span class="line-removed"> 132      * Concatenation strategy to use. See {@link Strategy} for possible options.</span>
<span class="line-removed"> 133      * This option is controllable with -Djava.lang.invoke.stringConcat JDK option.</span>
<span class="line-removed"> 134      *</span>
<span class="line-removed"> 135      * Defaults to MH_INLINE_SIZED_EXACT if not set.</span>
<span class="line-removed"> 136      */</span>
<span class="line-removed"> 137     private static final Strategy STRATEGY;</span>
<span class="line-removed"> 138 </span>
 139     private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
 140 
<span class="line-removed"> 141     private enum Strategy {</span>
<span class="line-removed"> 142         /**</span>
<span class="line-removed"> 143          * Bytecode generator, calling into {@link java.lang.StringBuilder}.</span>
<span class="line-removed"> 144          */</span>
<span class="line-removed"> 145         BC_SB,</span>
<span class="line-removed"> 146 </span>
<span class="line-removed"> 147         /**</span>
<span class="line-removed"> 148          * Bytecode generator, calling into {@link java.lang.StringBuilder};</span>
<span class="line-removed"> 149          * but trying to estimate the required storage.</span>
<span class="line-removed"> 150          */</span>
<span class="line-removed"> 151         BC_SB_SIZED,</span>
<span class="line-removed"> 152 </span>
<span class="line-removed"> 153         /**</span>
<span class="line-removed"> 154          * Bytecode generator, calling into {@link java.lang.StringBuilder};</span>
<span class="line-removed"> 155          * but computing the required storage exactly.</span>
<span class="line-removed"> 156          */</span>
<span class="line-removed"> 157         BC_SB_SIZED_EXACT,</span>
<span class="line-removed"> 158 </span>
<span class="line-removed"> 159         /**</span>
<span class="line-removed"> 160          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.</span>
<span class="line-removed"> 161          * This strategy also tries to estimate the required storage.</span>
<span class="line-removed"> 162          */</span>
<span class="line-removed"> 163         MH_SB_SIZED,</span>
<span class="line-removed"> 164 </span>
<span class="line-removed"> 165         /**</span>
<span class="line-removed"> 166          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.</span>
<span class="line-removed"> 167          * This strategy also estimate the required storage exactly.</span>
<span class="line-removed"> 168          */</span>
<span class="line-removed"> 169         MH_SB_SIZED_EXACT,</span>
<span class="line-removed"> 170 </span>
<span class="line-removed"> 171         /**</span>
<span class="line-removed"> 172          * MethodHandle-based generator, that constructs its own byte[] array from</span>
<span class="line-removed"> 173          * the arguments. It computes the required storage exactly.</span>
<span class="line-removed"> 174          */</span>
<span class="line-removed"> 175         MH_INLINE_SIZED_EXACT</span>
<span class="line-removed"> 176     }</span>
<span class="line-removed"> 177 </span>
<span class="line-removed"> 178     /**</span>
<span class="line-removed"> 179      * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)</span>
<span class="line-removed"> 180      * checks, etc.</span>
<span class="line-removed"> 181      */</span>
<span class="line-removed"> 182     private static final boolean DEBUG;</span>
<span class="line-removed"> 183 </span>
<span class="line-removed"> 184     static {</span>
<span class="line-removed"> 185         final String strategy =</span>
<span class="line-removed"> 186                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);</span>
<span class="line-removed"> 187         STRATEGY = (strategy == null) ? null : Strategy.valueOf(strategy);</span>
<span class="line-removed"> 188 </span>
<span class="line-removed"> 189         if (STRATEGY == null || STRATEGY == Strategy.MH_INLINE_SIZED_EXACT) {</span>
<span class="line-removed"> 190             // Force initialization of default strategy:</span>
<span class="line-removed"> 191             Unsafe.getUnsafe().ensureClassInitialized(MethodHandleInlineCopyStrategy.class);</span>
<span class="line-removed"> 192         }</span>
<span class="line-removed"> 193 </span>
<span class="line-removed"> 194         DEBUG = Boolean.parseBoolean(</span>
<span class="line-removed"> 195                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));</span>
<span class="line-removed"> 196     }</span>
<span class="line-removed"> 197 </span>
<span class="line-removed"> 198     /**</span>
<span class="line-removed"> 199      * Cache key is a composite of:</span>
<span class="line-removed"> 200      *   - class name, that lets to disambiguate stubs, to avoid excess sharing</span>
<span class="line-removed"> 201      *   - method type, describing the dynamic arguments for concatenation</span>
<span class="line-removed"> 202      *   - concat recipe, describing the constants and concat shape</span>
<span class="line-removed"> 203      */</span>
<span class="line-removed"> 204     private static final class Key {</span>
<span class="line-removed"> 205         final String className;</span>
<span class="line-removed"> 206         final MethodType mt;</span>
<span class="line-removed"> 207         final Recipe recipe;</span>
<span class="line-removed"> 208 </span>
<span class="line-removed"> 209         public Key(String className, MethodType mt, Recipe recipe) {</span>
<span class="line-removed"> 210             this.className = className;</span>
<span class="line-removed"> 211             this.mt = mt;</span>
<span class="line-removed"> 212             this.recipe = recipe;</span>
<span class="line-removed"> 213         }</span>
<span class="line-removed"> 214 </span>
<span class="line-removed"> 215         @Override</span>
<span class="line-removed"> 216         public boolean equals(Object o) {</span>
<span class="line-removed"> 217             if (this == o) return true;</span>
<span class="line-removed"> 218             if (o == null || getClass() != o.getClass()) return false;</span>
<span class="line-removed"> 219 </span>
<span class="line-removed"> 220             Key key = (Key) o;</span>
<span class="line-removed"> 221 </span>
<span class="line-removed"> 222             if (!className.equals(key.className)) return false;</span>
<span class="line-removed"> 223             if (!mt.equals(key.mt)) return false;</span>
<span class="line-removed"> 224             if (!recipe.equals(key.recipe)) return false;</span>
<span class="line-removed"> 225             return true;</span>
<span class="line-removed"> 226         }</span>
<span class="line-removed"> 227 </span>
<span class="line-removed"> 228         @Override</span>
<span class="line-removed"> 229         public int hashCode() {</span>
<span class="line-removed"> 230             int result = className.hashCode();</span>
<span class="line-removed"> 231             result = 31 * result + mt.hashCode();</span>
<span class="line-removed"> 232             result = 31 * result + recipe.hashCode();</span>
<span class="line-removed"> 233             return result;</span>
<span class="line-removed"> 234         }</span>
<span class="line-removed"> 235     }</span>
<span class="line-removed"> 236 </span>
 237     /**
 238      * Parses the recipe string, and produces a traversable collection of
 239      * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
 240      * strategies. Notably, this class parses out the constants from the recipe
 241      * and from other static arguments.
 242      */
 243     private static final class Recipe {
 244         private final List&lt;RecipeElement&gt; elements;
 245 
 246         public Recipe(String src, Object[] constants) {
 247             List&lt;RecipeElement&gt; el = new ArrayList&lt;&gt;();
 248 
 249             int constC = 0;
 250             int argC = 0;
 251 
 252             StringBuilder acc = new StringBuilder();
 253 
 254             for (int i = 0; i &lt; src.length(); i++) {
 255                 char c = src.charAt(i);
 256 
</pre>
<hr />
<pre>
 428      *                   java.lang.String}.  When used with {@code invokedynamic},
 429      *                   this is provided by the {@code NameAndType} of the {@code
 430      *                   InvokeDynamic} structure and is stacked automatically by
 431      *                   the VM.
 432      * @return a CallSite whose target can be used to perform String
 433      * concatenation, with dynamic concatenation arguments described by the given
 434      * {@code concatType}.
 435      * @throws StringConcatException If any of the linkage invariants described
 436      *                               here are violated, or the lookup context
 437      *                               does not have private access privileges.
 438      * @throws NullPointerException If any of the incoming arguments is null.
 439      *                              This will never happen when a bootstrap method
 440      *                              is called with invokedynamic.
 441      *
 442      * @jls  5.1.11 String Conversion
 443      * @jls 15.18.1 String Concatenation Operator +
 444      */
 445     public static CallSite makeConcat(MethodHandles.Lookup lookup,
 446                                       String name,
 447                                       MethodType concatType) throws StringConcatException {
<span class="line-removed"> 448         if (DEBUG) {</span>
<span class="line-removed"> 449             System.out.println(&quot;StringConcatFactory &quot; + STRATEGY + &quot; is here for &quot; + concatType);</span>
<span class="line-removed"> 450         }</span>
<span class="line-removed"> 451 </span>
 452         return doStringConcat(lookup, name, concatType, true, null);
 453     }
 454 
 455     /**
 456      * Facilitates the creation of optimized String concatenation methods, that
 457      * can be used to efficiently concatenate a known number of arguments of
 458      * known types, possibly after type adaptation and partial evaluation of
 459      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
 460      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
 461      * feature of the Java Programming Language.
 462      *
 463      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
 464      * invoked, it returns the result of String concatenation, taking all
 465      * function arguments and constants passed to the linkage method as inputs for
 466      * concatenation. The target signature is given by {@code concatType}, and
 467      * does not include constants.
 468      * For a target accepting:
 469      * &lt;ul&gt;
 470      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
 471      *     &lt;li&gt;one input, concatenation results in the single
</pre>
<hr />
<pre>
 551      * @throws NullPointerException If any of the incoming arguments is null, or
 552      *                              any constant in {@code recipe} is null.
 553      *                              This will never happen when a bootstrap method
 554      *                              is called with invokedynamic.
 555      * @apiNote Code generators have three distinct ways to process a constant
 556      * string operand S in a string concatenation expression.  First, S can be
 557      * materialized as a reference (using ldc) and passed as an ordinary argument
 558      * (recipe &#39;\1&#39;). Or, S can be stored in the constant pool and passed as a
 559      * constant (recipe &#39;\2&#39;) . Finally, if S contains neither of the recipe
 560      * tag characters (&#39;\1&#39;, &#39;\2&#39;) then S can be interpolated into the recipe
 561      * itself, causing its characters to be inserted into the result.
 562      *
 563      * @jls  5.1.11 String Conversion
 564      * @jls 15.18.1 String Concatenation Operator +
 565      */
 566     public static CallSite makeConcatWithConstants(MethodHandles.Lookup lookup,
 567                                                    String name,
 568                                                    MethodType concatType,
 569                                                    String recipe,
 570                                                    Object... constants) throws StringConcatException {
<span class="line-removed"> 571         if (DEBUG) {</span>
<span class="line-removed"> 572             System.out.println(&quot;StringConcatFactory &quot; + STRATEGY + &quot; is here for &quot; + concatType + &quot;, {&quot; + recipe + &quot;}, &quot; + Arrays.toString(constants));</span>
<span class="line-removed"> 573         }</span>
<span class="line-removed"> 574 </span>
 575         return doStringConcat(lookup, name, concatType, false, recipe, constants);
 576     }
 577 
 578     private static CallSite doStringConcat(MethodHandles.Lookup lookup,
 579                                            String name,
 580                                            MethodType concatType,
 581                                            boolean generateRecipe,
 582                                            String recipe,
 583                                            Object... constants) throws StringConcatException {
 584         Objects.requireNonNull(lookup, &quot;Lookup is null&quot;);
 585         Objects.requireNonNull(name, &quot;Name is null&quot;);
 586         Objects.requireNonNull(concatType, &quot;Concat type is null&quot;);
 587         Objects.requireNonNull(constants, &quot;Constants are null&quot;);
 588 
 589         for (Object o : constants) {
 590             Objects.requireNonNull(o, &quot;Cannot accept null constants&quot;);
 591         }
 592 
 593         if ((lookup.lookupModes() &amp; MethodHandles.Lookup.PRIVATE) == 0) {
 594             throw new StringConcatException(&quot;Invalid caller: &quot; +
</pre>
<hr />
<pre>
 626                     &quot;Mismatched number of concat constants: recipe wants &quot; +
 627                             cCount +
 628                             &quot; constants, but only &quot; +
 629                             constants.length +
 630                             &quot; are passed&quot;);
 631         }
 632 
 633         if (!concatType.returnType().isAssignableFrom(String.class)) {
 634             throw new StringConcatException(
 635                     &quot;The return type should be compatible with String, but it is &quot; +
 636                             concatType.returnType());
 637         }
 638 
 639         if (concatType.parameterSlotCount() &gt; MAX_INDY_CONCAT_ARG_SLOTS) {
 640             throw new StringConcatException(&quot;Too many concat argument slots: &quot; +
 641                     concatType.parameterSlotCount() +
 642                     &quot;, can only accept &quot; +
 643                     MAX_INDY_CONCAT_ARG_SLOTS);
 644         }
 645 
<span class="line-removed"> 646         MethodType mt = adaptType(concatType);</span>
 647         Recipe rec = new Recipe(recipe, constants);
<span class="line-modified"> 648         MethodHandle mh = generate(lookup, mt, rec);</span>
 649         return new ConstantCallSite(mh.asType(concatType));
 650     }
 651 
<span class="line-removed"> 652     /**</span>
<span class="line-removed"> 653      * Adapt method type to an API we are going to use.</span>
<span class="line-removed"> 654      *</span>
<span class="line-removed"> 655      * This strips the concrete classes from the signatures, thus preventing</span>
<span class="line-removed"> 656      * class leakage when we cache the concatenation stubs.</span>
<span class="line-removed"> 657      *</span>
<span class="line-removed"> 658      * @param args actual argument types</span>
<span class="line-removed"> 659      * @return argument types the strategy is going to use</span>
<span class="line-removed"> 660      */</span>
<span class="line-removed"> 661     private static MethodType adaptType(MethodType args) {</span>
<span class="line-removed"> 662         Class&lt;?&gt;[] ptypes = null;</span>
<span class="line-removed"> 663         for (int i = 0; i &lt; args.parameterCount(); i++) {</span>
<span class="line-removed"> 664             Class&lt;?&gt; ptype = args.parameterType(i);</span>
<span class="line-removed"> 665             if (!ptype.isPrimitive() &amp;&amp;</span>
<span class="line-removed"> 666                     ptype != String.class &amp;&amp;</span>
<span class="line-removed"> 667                     ptype != Object.class) { // truncate to Object</span>
<span class="line-removed"> 668                 if (ptypes == null) {</span>
<span class="line-removed"> 669                     ptypes = args.parameterArray();</span>
<span class="line-removed"> 670                 }</span>
<span class="line-removed"> 671                 ptypes[i] = Object.class;</span>
<span class="line-removed"> 672             }</span>
<span class="line-removed"> 673             // else other primitives or String or Object (unchanged)</span>
<span class="line-removed"> 674         }</span>
<span class="line-removed"> 675         return (ptypes != null)</span>
<span class="line-removed"> 676                 ? MethodType.methodType(args.returnType(), ptypes)</span>
<span class="line-removed"> 677                 : args;</span>
<span class="line-removed"> 678     }</span>
<span class="line-removed"> 679 </span>
 680     private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {
 681         try {
<span class="line-modified"> 682             if (STRATEGY == null) {</span>
<span class="line-removed"> 683                 return MethodHandleInlineCopyStrategy.generate(mt, recipe);</span>
<span class="line-removed"> 684             }</span>
<span class="line-removed"> 685             switch (STRATEGY) {</span>
<span class="line-removed"> 686                 case BC_SB:</span>
<span class="line-removed"> 687                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.DEFAULT);</span>
<span class="line-removed"> 688                 case BC_SB_SIZED:</span>
<span class="line-removed"> 689                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED);</span>
<span class="line-removed"> 690                 case BC_SB_SIZED_EXACT:</span>
<span class="line-removed"> 691                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED_EXACT);</span>
<span class="line-removed"> 692                 case MH_SB_SIZED:</span>
<span class="line-removed"> 693                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED);</span>
<span class="line-removed"> 694                 case MH_SB_SIZED_EXACT:</span>
<span class="line-removed"> 695                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED_EXACT);</span>
<span class="line-removed"> 696                 case MH_INLINE_SIZED_EXACT:</span>
<span class="line-removed"> 697                     return MethodHandleInlineCopyStrategy.generate(mt, recipe);</span>
<span class="line-removed"> 698                 default:</span>
<span class="line-removed"> 699                     throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);</span>
<span class="line-removed"> 700             }</span>
 701         } catch (Error | StringConcatException e) {
 702             // Pass through any error or existing StringConcatException
 703             throw e;
 704         } catch (Throwable t) {
 705             throw new StringConcatException(&quot;Generator failed&quot;, t);
 706         }
 707     }
 708 
<span class="line-removed"> 709     private enum Mode {</span>
<span class="line-removed"> 710         DEFAULT(false, false),</span>
<span class="line-removed"> 711         SIZED(true, false),</span>
<span class="line-removed"> 712         SIZED_EXACT(true, true);</span>
<span class="line-removed"> 713 </span>
<span class="line-removed"> 714         private final boolean sized;</span>
<span class="line-removed"> 715         private final boolean exact;</span>
<span class="line-removed"> 716 </span>
<span class="line-removed"> 717         Mode(boolean sized, boolean exact) {</span>
<span class="line-removed"> 718             this.sized = sized;</span>
<span class="line-removed"> 719             this.exact = exact;</span>
<span class="line-removed"> 720         }</span>
<span class="line-removed"> 721 </span>
<span class="line-removed"> 722         boolean isSized() {</span>
<span class="line-removed"> 723             return sized;</span>
<span class="line-removed"> 724         }</span>
<span class="line-removed"> 725 </span>
<span class="line-removed"> 726         boolean isExact() {</span>
<span class="line-removed"> 727             return exact;</span>
<span class="line-removed"> 728         }</span>
<span class="line-removed"> 729     }</span>
 730 
 731     /**
<span class="line-modified"> 732      * Bytecode StringBuilder strategy.</span>
<span class="line-modified"> 733      *</span>
<span class="line-modified"> 734      * &lt;p&gt;This strategy operates in three modes, gated by {@link Mode}.</span>
<span class="line-modified"> 735      *</span>
<span class="line-modified"> 736      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB}: &quot;bytecode StringBuilder&quot;.&lt;/b&gt;</span>
<span class="line-removed"> 737      *</span>
<span class="line-removed"> 738      * &lt;p&gt;This strategy spins up the bytecode that has the same StringBuilder</span>
<span class="line-removed"> 739      * chain javac would otherwise emit. This strategy uses only the public API,</span>
<span class="line-removed"> 740      * and comes as the baseline for the current JDK behavior. On other words,</span>
<span class="line-removed"> 741      * this strategy moves the javac generated bytecode to runtime. The</span>
<span class="line-removed"> 742      * generated bytecode is loaded via Lookup::defineClass, but with</span>
<span class="line-removed"> 743      * the caller class coming from the BSM -- in other words, the protection</span>
<span class="line-removed"> 744      * guarantees are inherited from the method where invokedynamic was</span>
<span class="line-removed"> 745      * originally called. This means, among other things, that the bytecode is</span>
<span class="line-removed"> 746      * verified for all non-JDK uses.</span>
<span class="line-removed"> 747      *</span>
<span class="line-removed"> 748      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED}: &quot;bytecode StringBuilder, but</span>
<span class="line-removed"> 749      * sized&quot;.&lt;/b&gt;</span>
<span class="line-removed"> 750      *</span>
<span class="line-removed"> 751      * &lt;p&gt;This strategy acts similarly to {@link Strategy#BC_SB}, but it also</span>
<span class="line-removed"> 752      * tries to guess the capacity required for StringBuilder to accept all</span>
<span class="line-removed"> 753      * arguments without resizing. This strategy only makes an educated guess:</span>
<span class="line-removed"> 754      * it only guesses the space required for known types (e.g. primitives and</span>
<span class="line-removed"> 755      * Strings), but does not otherwise convert arguments. Therefore, the</span>
<span class="line-removed"> 756      * capacity estimate may be wrong, and StringBuilder may have to</span>
<span class="line-removed"> 757      * transparently resize or trim when doing the actual concatenation. While</span>
<span class="line-removed"> 758      * this does not constitute a correctness issue (in the end, that what BC_SB</span>
<span class="line-removed"> 759      * has to do anyway), this does pose a potential performance problem.</span>
<span class="line-removed"> 760      *</span>
<span class="line-removed"> 761      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED_EXACT}: &quot;bytecode StringBuilder, but</span>
<span class="line-removed"> 762      * sized exactly&quot;.&lt;/b&gt;</span>
<span class="line-removed"> 763      *</span>
<span class="line-removed"> 764      * &lt;p&gt;This strategy improves on @link Strategy#BC_SB_SIZED}, by first</span>
<span class="line-removed"> 765      * converting all arguments to String in order to get the exact capacity</span>
<span class="line-removed"> 766      * StringBuilder should have. The conversion is done via the public</span>
<span class="line-removed"> 767      * String.valueOf and/or Object.toString methods, and does not touch any</span>
<span class="line-removed"> 768      * private String API.</span>
 769      */
<span class="line-modified"> 770     private static final class BytecodeStringBuilderStrategy {</span>
<span class="line-removed"> 771         static final int CLASSFILE_VERSION = 52;</span>
<span class="line-removed"> 772         static final String METHOD_NAME = &quot;concat&quot;;</span>
<span class="line-removed"> 773 </span>
<span class="line-removed"> 774         private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;</span>
<span class="line-removed"> 775 </span>
<span class="line-removed"> 776         /**</span>
<span class="line-removed"> 777          * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated</span>
<span class="line-removed"> 778          * code, at the expense of contaminating the profiles.</span>
<span class="line-removed"> 779          */</span>
<span class="line-removed"> 780         private static final boolean CACHE_ENABLE;</span>
<span class="line-removed"> 781 </span>
<span class="line-removed"> 782         /**</span>
<span class="line-removed"> 783          * Dump generated classes to disk, for debugging purposes.</span>
<span class="line-removed"> 784          */</span>
<span class="line-removed"> 785         private static final ProxyClassesDumper DUMPER;</span>
<span class="line-removed"> 786 </span>
<span class="line-removed"> 787         static {</span>
<span class="line-removed"> 788             CACHE_ENABLE = Boolean.parseBoolean(</span>
<span class="line-removed"> 789                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
<span class="line-removed"> 790             CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;</span>
<span class="line-removed"> 791 </span>
<span class="line-removed"> 792             final String dumpPath =</span>
<span class="line-removed"> 793                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
<span class="line-removed"> 794 </span>
<span class="line-removed"> 795             DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);</span>
<span class="line-removed"> 796         }</span>
<span class="line-removed"> 797 </span>
<span class="line-removed"> 798         private BytecodeStringBuilderStrategy() {</span>
<span class="line-removed"> 799             // no instantiation</span>
<span class="line-removed"> 800         }</span>
<span class="line-removed"> 801 </span>
<span class="line-removed"> 802         private static MethodHandle generate(Lookup lookup, MethodType args, Recipe recipe, Mode mode) throws Exception {</span>
<span class="line-removed"> 803             String className = getClassName(lookup.lookupClass());</span>
<span class="line-removed"> 804             Key key = null;</span>
<span class="line-removed"> 805             if (CACHE_ENABLE) {</span>
<span class="line-removed"> 806                 key = new Key(className, args, recipe);</span>
<span class="line-removed"> 807                 MethodHandle mh = CACHE.get(key);</span>
<span class="line-removed"> 808                 if (mh != null) {</span>
<span class="line-removed"> 809                     return mh;</span>
<span class="line-removed"> 810                 }</span>
<span class="line-removed"> 811             }</span>
<span class="line-removed"> 812 </span>
<span class="line-removed"> 813             ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);</span>
<span class="line-removed"> 814 </span>
<span class="line-removed"> 815             cw.visit(CLASSFILE_VERSION,</span>
<span class="line-removed"> 816                     ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,</span>
<span class="line-removed"> 817                     className,</span>
<span class="line-removed"> 818                     null,</span>
<span class="line-removed"> 819                     &quot;java/lang/Object&quot;,</span>
<span class="line-removed"> 820                     null</span>
<span class="line-removed"> 821             );</span>
<span class="line-removed"> 822 </span>
<span class="line-removed"> 823             MethodVisitor mv = cw.visitMethod(</span>
<span class="line-removed"> 824                     ACC_PUBLIC + ACC_STATIC + ACC_FINAL,</span>
<span class="line-removed"> 825                     METHOD_NAME,</span>
<span class="line-removed"> 826                     args.toMethodDescriptorString(),</span>
<span class="line-removed"> 827                     null,</span>
<span class="line-removed"> 828                     null);</span>
<span class="line-removed"> 829 </span>
<span class="line-removed"> 830             // use of @ForceInline no longer has any effect</span>
<span class="line-removed"> 831             mv.visitAnnotation(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;, true);</span>
<span class="line-removed"> 832             mv.visitCode();</span>
<span class="line-removed"> 833 </span>
<span class="line-removed"> 834             Class&lt;?&gt;[] arr = args.parameterArray();</span>
<span class="line-removed"> 835             boolean[] guaranteedNonNull = new boolean[arr.length];</span>
<span class="line-removed"> 836 </span>
<span class="line-removed"> 837             if (mode.isExact()) {</span>
<span class="line-removed"> 838                 /*</span>
<span class="line-removed"> 839                     In exact mode, we need to convert all arguments to their String representations,</span>
<span class="line-removed"> 840                     as this allows to compute their String sizes exactly. We cannot use private</span>
<span class="line-removed"> 841                     methods for primitives in here, therefore we need to convert those as well.</span>
<span class="line-removed"> 842 </span>
<span class="line-removed"> 843                     We also record what arguments are guaranteed to be non-null as the result</span>
<span class="line-removed"> 844                     of the conversion. String.valueOf does the null checks for us. The only</span>
<span class="line-removed"> 845                     corner case to take care of is String.valueOf(Object) returning null itself.</span>
<span class="line-removed"> 846 </span>
<span class="line-removed"> 847                     Also, if any conversion happened, then the slot indices in the incoming</span>
<span class="line-removed"> 848                     arguments are not equal to the final local maps. The only case this may break</span>
<span class="line-removed"> 849                     is when converting 2-slot long/double argument to 1-slot String. Therefore,</span>
<span class="line-removed"> 850                     we get away with tracking modified offset, since no conversion can overwrite</span>
<span class="line-removed"> 851                     the upcoming the argument.</span>
<span class="line-removed"> 852                  */</span>
<span class="line-removed"> 853 </span>
<span class="line-removed"> 854                 int off = 0;</span>
<span class="line-removed"> 855                 int modOff = 0;</span>
<span class="line-removed"> 856                 for (int c = 0; c &lt; arr.length; c++) {</span>
<span class="line-removed"> 857                     Class&lt;?&gt; cl = arr[c];</span>
<span class="line-removed"> 858                     if (cl == String.class) {</span>
<span class="line-removed"> 859                         if (off != modOff) {</span>
<span class="line-removed"> 860                             mv.visitIntInsn(getLoadOpcode(cl), off);</span>
<span class="line-removed"> 861                             mv.visitIntInsn(ASTORE, modOff);</span>
<span class="line-removed"> 862                         }</span>
<span class="line-removed"> 863                     } else {</span>
<span class="line-removed"> 864                         mv.visitIntInsn(getLoadOpcode(cl), off);</span>
<span class="line-removed"> 865                         mv.visitMethodInsn(</span>
<span class="line-removed"> 866                                 INVOKESTATIC,</span>
<span class="line-removed"> 867                                 &quot;java/lang/String&quot;,</span>
<span class="line-removed"> 868                                 &quot;valueOf&quot;,</span>
<span class="line-removed"> 869                                 getStringValueOfDesc(cl),</span>
<span class="line-removed"> 870                                 false</span>
<span class="line-removed"> 871                         );</span>
<span class="line-removed"> 872                         mv.visitIntInsn(ASTORE, modOff);</span>
<span class="line-removed"> 873                         arr[c] = String.class;</span>
<span class="line-removed"> 874                         guaranteedNonNull[c] = cl.isPrimitive();</span>
<span class="line-removed"> 875                     }</span>
<span class="line-removed"> 876                     off += getParameterSize(cl);</span>
<span class="line-removed"> 877                     modOff += getParameterSize(String.class);</span>
<span class="line-removed"> 878                 }</span>
<span class="line-removed"> 879             }</span>
<span class="line-removed"> 880 </span>
<span class="line-removed"> 881             if (mode.isSized()) {</span>
<span class="line-removed"> 882                 /*</span>
<span class="line-removed"> 883                     When operating in sized mode (this includes exact mode), it makes sense to make</span>
<span class="line-removed"> 884                     StringBuilder append chains look familiar to OptimizeStringConcat. For that, we</span>
<span class="line-removed"> 885                     need to do null-checks early, not make the append chain shape simpler.</span>
<span class="line-removed"> 886                  */</span>
<span class="line-removed"> 887 </span>
<span class="line-removed"> 888                 int off = 0;</span>
<span class="line-removed"> 889                 for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed"> 890                     switch (el.getTag()) {</span>
<span class="line-removed"> 891                         case TAG_CONST:</span>
<span class="line-removed"> 892                             // Guaranteed non-null, no null check required.</span>
<span class="line-removed"> 893                             break;</span>
<span class="line-removed"> 894                         case TAG_ARG:</span>
<span class="line-removed"> 895                             // Null-checks are needed only for String arguments, and when a previous stage</span>
<span class="line-removed"> 896                             // did not do implicit null-checks. If a String is null, we eagerly replace it</span>
<span class="line-removed"> 897                             // with &quot;null&quot; constant. Note, we omit Objects here, because we don&#39;t call</span>
<span class="line-removed"> 898                             // .length() on them down below.</span>
<span class="line-removed"> 899                             int ac = el.getArgPos();</span>
<span class="line-removed"> 900                             Class&lt;?&gt; cl = arr[ac];</span>
<span class="line-removed"> 901                             if (cl == String.class &amp;&amp; !guaranteedNonNull[ac]) {</span>
<span class="line-removed"> 902                                 Label l0 = new Label();</span>
<span class="line-removed"> 903                                 mv.visitIntInsn(ALOAD, off);</span>
<span class="line-removed"> 904                                 mv.visitJumpInsn(IFNONNULL, l0);</span>
<span class="line-removed"> 905                                 mv.visitLdcInsn(&quot;null&quot;);</span>
<span class="line-removed"> 906                                 mv.visitIntInsn(ASTORE, off);</span>
<span class="line-removed"> 907                                 mv.visitLabel(l0);</span>
<span class="line-removed"> 908                             }</span>
<span class="line-removed"> 909                             off += getParameterSize(cl);</span>
<span class="line-removed"> 910                             break;</span>
<span class="line-removed"> 911                         default:</span>
<span class="line-removed"> 912                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed"> 913                     }</span>
<span class="line-removed"> 914                 }</span>
<span class="line-removed"> 915             }</span>
<span class="line-removed"> 916 </span>
<span class="line-removed"> 917             // Prepare StringBuilder instance</span>
<span class="line-removed"> 918             mv.visitTypeInsn(NEW, &quot;java/lang/StringBuilder&quot;);</span>
<span class="line-removed"> 919             mv.visitInsn(DUP);</span>
<span class="line-removed"> 920 </span>
<span class="line-removed"> 921             if (mode.isSized()) {</span>
<span class="line-removed"> 922                 /*</span>
<span class="line-removed"> 923                     Sized mode requires us to walk through the arguments, and estimate the final length.</span>
<span class="line-removed"> 924                     In exact mode, this will operate on Strings only. This code would accumulate the</span>
<span class="line-removed"> 925                     final length on stack.</span>
<span class="line-removed"> 926                  */</span>
<span class="line-removed"> 927                 int len = 0;</span>
<span class="line-removed"> 928                 int off = 0;</span>
<span class="line-removed"> 929 </span>
<span class="line-removed"> 930                 mv.visitInsn(ICONST_0);</span>
<span class="line-removed"> 931 </span>
<span class="line-removed"> 932                 for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed"> 933                     switch (el.getTag()) {</span>
<span class="line-removed"> 934                         case TAG_CONST:</span>
<span class="line-removed"> 935                             len += el.getValue().length();</span>
<span class="line-removed"> 936                             break;</span>
<span class="line-removed"> 937                         case TAG_ARG:</span>
<span class="line-removed"> 938                             /*</span>
<span class="line-removed"> 939                                 If an argument is String, then we can call .length() on it. Sized/Exact modes have</span>
<span class="line-removed"> 940                                 converted arguments for us. If an argument is primitive, we can provide a guess</span>
<span class="line-removed"> 941                                 for its String representation size.</span>
<span class="line-removed"> 942                             */</span>
<span class="line-removed"> 943                             Class&lt;?&gt; cl = arr[el.getArgPos()];</span>
<span class="line-removed"> 944                             if (cl == String.class) {</span>
<span class="line-removed"> 945                                 mv.visitIntInsn(ALOAD, off);</span>
<span class="line-removed"> 946                                 mv.visitMethodInsn(</span>
<span class="line-removed"> 947                                         INVOKEVIRTUAL,</span>
<span class="line-removed"> 948                                         &quot;java/lang/String&quot;,</span>
<span class="line-removed"> 949                                         &quot;length&quot;,</span>
<span class="line-removed"> 950                                         &quot;()I&quot;,</span>
<span class="line-removed"> 951                                         false</span>
<span class="line-removed"> 952                                 );</span>
<span class="line-removed"> 953                                 mv.visitInsn(IADD);</span>
<span class="line-removed"> 954                             } else if (cl.isPrimitive()) {</span>
<span class="line-removed"> 955                                 len += estimateSize(cl);</span>
<span class="line-removed"> 956                             }</span>
<span class="line-removed"> 957                             off += getParameterSize(cl);</span>
<span class="line-removed"> 958                             break;</span>
<span class="line-removed"> 959                         default:</span>
<span class="line-removed"> 960                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed"> 961                     }</span>
<span class="line-removed"> 962                 }</span>
<span class="line-removed"> 963 </span>
<span class="line-removed"> 964                 // Constants have non-zero length, mix in</span>
<span class="line-removed"> 965                 if (len &gt; 0) {</span>
<span class="line-removed"> 966                     iconst(mv, len);</span>
<span class="line-removed"> 967                     mv.visitInsn(IADD);</span>
<span class="line-removed"> 968                 }</span>
 969 
<span class="line-modified"> 970                 mv.visitMethodInsn(</span>
<span class="line-modified"> 971                         INVOKESPECIAL,</span>
<span class="line-modified"> 972                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-modified"> 973                         &quot;&lt;init&gt;&quot;,</span>
<span class="line-modified"> 974                         &quot;(I)V&quot;,</span>
<span class="line-modified"> 975                         false</span>
<span class="line-modified"> 976                 );</span>
<span class="line-modified"> 977             } else {</span>
<span class="line-removed"> 978                 mv.visitMethodInsn(</span>
<span class="line-removed"> 979                         INVOKESPECIAL,</span>
<span class="line-removed"> 980                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed"> 981                         &quot;&lt;init&gt;&quot;,</span>
<span class="line-removed"> 982                         &quot;()V&quot;,</span>
<span class="line-removed"> 983                         false</span>
<span class="line-removed"> 984                 );</span>
<span class="line-removed"> 985             }</span>
<span class="line-removed"> 986 </span>
<span class="line-removed"> 987             // At this point, we have a blank StringBuilder on stack, fill it in with .append calls.</span>
<span class="line-removed"> 988             {</span>
<span class="line-removed"> 989                 int off = 0;</span>
<span class="line-removed"> 990                 for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed"> 991                     String desc;</span>
<span class="line-removed"> 992                     switch (el.getTag()) {</span>
<span class="line-removed"> 993                         case TAG_CONST:</span>
<span class="line-removed"> 994                             mv.visitLdcInsn(el.getValue());</span>
<span class="line-removed"> 995                             desc = getSBAppendDesc(String.class);</span>
<span class="line-removed"> 996                             break;</span>
<span class="line-removed"> 997                         case TAG_ARG:</span>
<span class="line-removed"> 998                             Class&lt;?&gt; cl = arr[el.getArgPos()];</span>
<span class="line-removed"> 999                             mv.visitVarInsn(getLoadOpcode(cl), off);</span>
<span class="line-removed">1000                             off += getParameterSize(cl);</span>
<span class="line-removed">1001                             desc = getSBAppendDesc(cl);</span>
<span class="line-removed">1002                             break;</span>
<span class="line-removed">1003                         default:</span>
<span class="line-removed">1004                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed">1005                     }</span>
<span class="line-removed">1006 </span>
<span class="line-removed">1007                     mv.visitMethodInsn(</span>
<span class="line-removed">1008                             INVOKEVIRTUAL,</span>
<span class="line-removed">1009                             &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed">1010                             &quot;append&quot;,</span>
<span class="line-removed">1011                             desc,</span>
<span class="line-removed">1012                             false</span>
<span class="line-removed">1013                     );</span>
<span class="line-removed">1014                 }</span>
<span class="line-removed">1015             }</span>
<span class="line-removed">1016 </span>
<span class="line-removed">1017             if (DEBUG &amp;&amp; mode.isExact()) {</span>
<span class="line-removed">1018                 /*</span>
<span class="line-removed">1019                     Exactness checks compare the final StringBuilder.capacity() with a resulting</span>
<span class="line-removed">1020                     String.length(). If these values disagree, that means StringBuilder had to perform</span>
<span class="line-removed">1021                     storage trimming, which defeats the purpose of exact strategies.</span>
<span class="line-removed">1022                  */</span>
<span class="line-removed">1023 </span>
<span class="line-removed">1024                 /*</span>
<span class="line-removed">1025                    The logic for this check is as follows:</span>
<span class="line-removed">1026 </span>
<span class="line-removed">1027                      Stack before:     Op:</span>
<span class="line-removed">1028                       (SB)              dup, dup</span>
<span class="line-removed">1029                       (SB, SB, SB)      capacity()</span>
<span class="line-removed">1030                       (int, SB, SB)     swap</span>
<span class="line-removed">1031                       (SB, int, SB)     toString()</span>
<span class="line-removed">1032                       (S, int, SB)      length()</span>
<span class="line-removed">1033                       (int, int, SB)    if_icmpeq</span>
<span class="line-removed">1034                       (SB)              &lt;end&gt;</span>
<span class="line-removed">1035 </span>
<span class="line-removed">1036                    Note that it leaves the same StringBuilder on exit, like the one on enter.</span>
<span class="line-removed">1037                  */</span>
<span class="line-removed">1038 </span>
<span class="line-removed">1039                 mv.visitInsn(DUP);</span>
<span class="line-removed">1040                 mv.visitInsn(DUP);</span>
<span class="line-removed">1041 </span>
<span class="line-removed">1042                 mv.visitMethodInsn(</span>
<span class="line-removed">1043                         INVOKEVIRTUAL,</span>
<span class="line-removed">1044                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed">1045                         &quot;capacity&quot;,</span>
<span class="line-removed">1046                         &quot;()I&quot;,</span>
<span class="line-removed">1047                         false</span>
<span class="line-removed">1048                 );</span>
<span class="line-removed">1049 </span>
<span class="line-removed">1050                 mv.visitInsn(SWAP);</span>
<span class="line-removed">1051 </span>
<span class="line-removed">1052                 mv.visitMethodInsn(</span>
<span class="line-removed">1053                         INVOKEVIRTUAL,</span>
<span class="line-removed">1054                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed">1055                         &quot;toString&quot;,</span>
<span class="line-removed">1056                         &quot;()Ljava/lang/String;&quot;,</span>
<span class="line-removed">1057                         false</span>
<span class="line-removed">1058                 );</span>
<span class="line-removed">1059 </span>
<span class="line-removed">1060                 mv.visitMethodInsn(</span>
<span class="line-removed">1061                         INVOKEVIRTUAL,</span>
<span class="line-removed">1062                         &quot;java/lang/String&quot;,</span>
<span class="line-removed">1063                         &quot;length&quot;,</span>
<span class="line-removed">1064                         &quot;()I&quot;,</span>
<span class="line-removed">1065                         false</span>
<span class="line-removed">1066                 );</span>
<span class="line-removed">1067 </span>
<span class="line-removed">1068                 Label l0 = new Label();</span>
<span class="line-removed">1069                 mv.visitJumpInsn(IF_ICMPEQ, l0);</span>
<span class="line-removed">1070 </span>
<span class="line-removed">1071                 mv.visitTypeInsn(NEW, &quot;java/lang/AssertionError&quot;);</span>
<span class="line-removed">1072                 mv.visitInsn(DUP);</span>
<span class="line-removed">1073                 mv.visitLdcInsn(&quot;Failed exactness check&quot;);</span>
<span class="line-removed">1074                 mv.visitMethodInsn(INVOKESPECIAL,</span>
<span class="line-removed">1075                         &quot;java/lang/AssertionError&quot;,</span>
<span class="line-removed">1076                         &quot;&lt;init&gt;&quot;,</span>
<span class="line-removed">1077                         &quot;(Ljava/lang/Object;)V&quot;,</span>
<span class="line-removed">1078                         false);</span>
<span class="line-removed">1079                 mv.visitInsn(ATHROW);</span>
<span class="line-removed">1080 </span>
<span class="line-removed">1081                 mv.visitLabel(l0);</span>
<span class="line-removed">1082             }</span>
<span class="line-removed">1083 </span>
<span class="line-removed">1084             mv.visitMethodInsn(</span>
<span class="line-removed">1085                     INVOKEVIRTUAL,</span>
<span class="line-removed">1086                     &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed">1087                     &quot;toString&quot;,</span>
<span class="line-removed">1088                     &quot;()Ljava/lang/String;&quot;,</span>
<span class="line-removed">1089                     false</span>
<span class="line-removed">1090             );</span>
<span class="line-removed">1091 </span>
<span class="line-removed">1092             mv.visitInsn(ARETURN);</span>
<span class="line-removed">1093 </span>
<span class="line-removed">1094             mv.visitMaxs(-1, -1);</span>
<span class="line-removed">1095             mv.visitEnd();</span>
<span class="line-removed">1096             cw.visitEnd();</span>
<span class="line-removed">1097 </span>
<span class="line-removed">1098             byte[] classBytes = cw.toByteArray();</span>
<span class="line-removed">1099             try {</span>
<span class="line-removed">1100                 Class&lt;?&gt; innerClass = lookup.defineHiddenClass(classBytes, true, STRONG).lookupClass();</span>
<span class="line-removed">1101                 dumpIfEnabled(className, classBytes);</span>
<span class="line-removed">1102                 MethodHandle mh = lookup.findStatic(innerClass, METHOD_NAME, args);</span>
<span class="line-removed">1103                 if (CACHE_ENABLE) {</span>
<span class="line-removed">1104                     CACHE.put(key, mh);</span>
<span class="line-removed">1105                 }</span>
<span class="line-removed">1106                 return mh;</span>
<span class="line-removed">1107             } catch (Exception e) {</span>
<span class="line-removed">1108                 dumpIfEnabled(className + &quot;$$FAILED&quot;, classBytes);</span>
<span class="line-removed">1109                 throw new StringConcatException(&quot;Exception while spinning the class&quot;, e);</span>
<span class="line-removed">1110             }</span>
<span class="line-removed">1111         }</span>
<span class="line-removed">1112 </span>
<span class="line-removed">1113         /**</span>
<span class="line-removed">1114          * The generated class is in the same package as the host class as</span>
<span class="line-removed">1115          * it&#39;s the implementation of the string concatenation for the host</span>
<span class="line-removed">1116          * class.</span>
<span class="line-removed">1117          *</span>
<span class="line-removed">1118          * When cache is enabled, we want to cache as much as we can.</span>
<span class="line-removed">1119          */</span>
<span class="line-removed">1120         private static String getClassName(Class&lt;?&gt; hostClass) {</span>
<span class="line-removed">1121             if (CACHE_ENABLE) {</span>
<span class="line-removed">1122                 String pkgName = hostClass.getPackageName();</span>
<span class="line-removed">1123                 return (!pkgName.isEmpty() ? pkgName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; : &quot;&quot;) + &quot;Stubs$$StringConcat&quot;;</span>
<span class="line-removed">1124             } else {</span>
<span class="line-removed">1125                 String name = hostClass.isHidden() ? hostClass.getName().replace(&#39;/&#39;, &#39;_&#39;)</span>
<span class="line-removed">1126                         : hostClass.getName();</span>
<span class="line-removed">1127                 return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$StringConcat&quot;;</span>
<span class="line-removed">1128             }</span>
<span class="line-removed">1129         }</span>
<span class="line-removed">1130 </span>
<span class="line-removed">1131         private static void dumpIfEnabled(String name, byte[] bytes) {</span>
<span class="line-removed">1132             if (DUMPER != null) {</span>
<span class="line-removed">1133                 DUMPER.dumpClass(name, bytes);</span>
<span class="line-removed">1134             }</span>
<span class="line-removed">1135         }</span>
<span class="line-removed">1136 </span>
<span class="line-removed">1137         private static String getSBAppendDesc(Class&lt;?&gt; cl) {</span>
<span class="line-removed">1138             if (cl.isPrimitive()) {</span>
<span class="line-removed">1139                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {</span>
<span class="line-removed">1140                     return &quot;(I)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">1141                 } else if (cl == Boolean.TYPE) {</span>
<span class="line-removed">1142                     return &quot;(Z)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">1143                 } else if (cl == Character.TYPE) {</span>
<span class="line-removed">1144                     return &quot;(C)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">1145                 } else if (cl == Double.TYPE) {</span>
<span class="line-removed">1146                     return &quot;(D)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">1147                 } else if (cl == Float.TYPE) {</span>
<span class="line-removed">1148                     return &quot;(F)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">1149                 } else if (cl == Long.TYPE) {</span>
<span class="line-removed">1150                     return &quot;(J)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">1151                 } else {</span>
<span class="line-removed">1152                     throw new IllegalStateException(&quot;Unhandled primitive StringBuilder.append: &quot; + cl);</span>
<span class="line-removed">1153                 }</span>
<span class="line-removed">1154             } else if (cl == String.class) {</span>
<span class="line-removed">1155                 return &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">1156             } else {</span>
<span class="line-removed">1157                 return &quot;(Ljava/lang/Object;)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">1158             }</span>
<span class="line-removed">1159         }</span>
<span class="line-removed">1160 </span>
<span class="line-removed">1161         private static String getStringValueOfDesc(Class&lt;?&gt; cl) {</span>
<span class="line-removed">1162             if (cl.isPrimitive()) {</span>
<span class="line-removed">1163                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {</span>
<span class="line-removed">1164                     return &quot;(I)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1165                 } else if (cl == Boolean.TYPE) {</span>
<span class="line-removed">1166                     return &quot;(Z)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1167                 } else if (cl == Character.TYPE) {</span>
<span class="line-removed">1168                     return &quot;(C)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1169                 } else if (cl == Double.TYPE) {</span>
<span class="line-removed">1170                     return &quot;(D)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1171                 } else if (cl == Float.TYPE) {</span>
<span class="line-removed">1172                     return &quot;(F)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1173                 } else if (cl == Long.TYPE) {</span>
<span class="line-removed">1174                     return &quot;(J)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1175                 } else {</span>
<span class="line-removed">1176                     throw new IllegalStateException(&quot;Unhandled String.valueOf: &quot; + cl);</span>
<span class="line-removed">1177                 }</span>
<span class="line-removed">1178             } else if (cl == String.class) {</span>
<span class="line-removed">1179                 return &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1180             } else {</span>
<span class="line-removed">1181                 return &quot;(Ljava/lang/Object;)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1182             }</span>
<span class="line-removed">1183         }</span>
<span class="line-removed">1184 </span>
<span class="line-removed">1185         /**</span>
<span class="line-removed">1186          * The following method is copied from</span>
<span class="line-removed">1187          * org.objectweb.asm.commons.InstructionAdapter. Part of ASM: a very small</span>
<span class="line-removed">1188          * and fast Java bytecode manipulation framework.</span>
<span class="line-removed">1189          * Copyright (c) 2000-2005 INRIA, France Telecom All rights reserved.</span>
<span class="line-removed">1190          */</span>
<span class="line-removed">1191         private static void iconst(MethodVisitor mv, final int cst) {</span>
<span class="line-removed">1192             if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {</span>
<span class="line-removed">1193                 mv.visitInsn(Opcodes.ICONST_0 + cst);</span>
<span class="line-removed">1194             } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {</span>
<span class="line-removed">1195                 mv.visitIntInsn(Opcodes.BIPUSH, cst);</span>
<span class="line-removed">1196             } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {</span>
<span class="line-removed">1197                 mv.visitIntInsn(Opcodes.SIPUSH, cst);</span>
<span class="line-removed">1198             } else {</span>
<span class="line-removed">1199                 mv.visitLdcInsn(cst);</span>
<span class="line-removed">1200             }</span>
<span class="line-removed">1201         }</span>
<span class="line-removed">1202 </span>
<span class="line-removed">1203         private static int getLoadOpcode(Class&lt;?&gt; c) {</span>
<span class="line-removed">1204             if (c == Void.TYPE) {</span>
<span class="line-removed">1205                 throw new InternalError(&quot;Unexpected void type of load opcode&quot;);</span>
<span class="line-removed">1206             }</span>
<span class="line-removed">1207             return ILOAD + getOpcodeOffset(c);</span>
<span class="line-removed">1208         }</span>
1209 
<span class="line-modified">1210         private static int getOpcodeOffset(Class&lt;?&gt; c) {</span>
<span class="line-removed">1211             if (c.isPrimitive()) {</span>
<span class="line-removed">1212                 if (c == Long.TYPE) {</span>
<span class="line-removed">1213                     return 1;</span>
<span class="line-removed">1214                 } else if (c == Float.TYPE) {</span>
<span class="line-removed">1215                     return 2;</span>
<span class="line-removed">1216                 } else if (c == Double.TYPE) {</span>
<span class="line-removed">1217                     return 3;</span>
<span class="line-removed">1218                 }</span>
<span class="line-removed">1219                 return 0;</span>
<span class="line-removed">1220             } else {</span>
<span class="line-removed">1221                 return 4;</span>
<span class="line-removed">1222             }</span>
<span class="line-removed">1223         }</span>
1224 
<span class="line-modified">1225         private static int getParameterSize(Class&lt;?&gt; c) {</span>
<span class="line-modified">1226             if (c == Void.TYPE) {</span>
<span class="line-modified">1227                 return 0;</span>
<span class="line-modified">1228             } else if (c == Long.TYPE || c == Double.TYPE) {</span>
<span class="line-removed">1229                 return 2;</span>
<span class="line-removed">1230             }</span>
<span class="line-removed">1231             return 1;</span>
<span class="line-removed">1232         }</span>
<span class="line-removed">1233     }</span>
<span class="line-removed">1234 </span>
<span class="line-removed">1235     /**</span>
<span class="line-removed">1236      * MethodHandle StringBuilder strategy.</span>
<span class="line-removed">1237      *</span>
<span class="line-removed">1238      * &lt;p&gt;This strategy operates in two modes, gated by {@link Mode}.</span>
<span class="line-removed">1239      *</span>
<span class="line-removed">1240      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_SB_SIZED}: &quot;MethodHandles StringBuilder,</span>
<span class="line-removed">1241      * sized&quot;.&lt;/b&gt;</span>
<span class="line-removed">1242      *</span>
<span class="line-removed">1243      * &lt;p&gt;This strategy avoids spinning up the bytecode by building the</span>
<span class="line-removed">1244      * computation on MethodHandle combinators. The computation is built with</span>
<span class="line-removed">1245      * public MethodHandle APIs, resolved from a public Lookup sequence, and</span>
<span class="line-removed">1246      * ends up calling the public StringBuilder API. Therefore, this strategy</span>
<span class="line-removed">1247      * does not use any private API at all since everything is handled under</span>
<span class="line-removed">1248      * cover by java.lang.invoke APIs.</span>
<span class="line-removed">1249      *</span>
<span class="line-removed">1250      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_SB_SIZED_EXACT}: &quot;MethodHandles StringBuilder,</span>
<span class="line-removed">1251      * sized exactly&quot;.&lt;/b&gt;</span>
<span class="line-removed">1252      *</span>
<span class="line-removed">1253      * &lt;p&gt;This strategy improves on @link Strategy#MH_SB_SIZED}, by first</span>
<span class="line-removed">1254      * converting all arguments to String in order to get the exact capacity</span>
<span class="line-removed">1255      * StringBuilder should have. The conversion is done via the public</span>
<span class="line-removed">1256      * String.valueOf and/or Object.toString methods, and does not touch any</span>
<span class="line-removed">1257      * private String API.</span>
<span class="line-removed">1258      */</span>
<span class="line-removed">1259     private static final class MethodHandleStringBuilderStrategy {</span>
<span class="line-removed">1260         private MethodHandleStringBuilderStrategy() {</span>
<span class="line-removed">1261             // no instantiation</span>
<span class="line-removed">1262         }</span>
1263 
<span class="line-modified">1264         private static MethodHandle generate(MethodType mt, Recipe recipe, Mode mode) throws Exception {</span>
<span class="line-modified">1265             int pc = mt.parameterCount();</span>
<span class="line-modified">1266 </span>
<span class="line-modified">1267             Class&lt;?&gt;[] ptypes = mt.parameterArray();</span>
<span class="line-modified">1268             MethodHandle[] filters = new MethodHandle[ptypes.length];</span>
<span class="line-removed">1269             for (int i = 0; i &lt; ptypes.length; i++) {</span>
<span class="line-removed">1270                 MethodHandle filter;</span>
<span class="line-removed">1271                 switch (mode) {</span>
<span class="line-removed">1272                     case SIZED:</span>
<span class="line-removed">1273                         // In sized mode, we convert all references and floats/doubles</span>
<span class="line-removed">1274                         // to String: there is no specialization for different</span>
<span class="line-removed">1275                         // classes in StringBuilder API, and it will convert to</span>
<span class="line-removed">1276                         // String internally anyhow.</span>
<span class="line-removed">1277                         filter = Stringifiers.forMost(ptypes[i]);</span>
<span class="line-removed">1278                         break;</span>
<span class="line-removed">1279                     case SIZED_EXACT:</span>
<span class="line-removed">1280                         // In exact mode, we convert everything to String:</span>
<span class="line-removed">1281                         // this helps to compute the storage exactly.</span>
<span class="line-removed">1282                         filter = Stringifiers.forAny(ptypes[i]);</span>
<span class="line-removed">1283                         break;</span>
<span class="line-removed">1284                     default:</span>
<span class="line-removed">1285                         throw new StringConcatException(&quot;Not supported&quot;);</span>
<span class="line-removed">1286                 }</span>
<span class="line-removed">1287                 if (filter != null) {</span>
<span class="line-removed">1288                     filters[i] = filter;</span>
<span class="line-removed">1289                     ptypes[i] = filter.type().returnType();</span>
<span class="line-removed">1290                 }</span>
<span class="line-removed">1291             }</span>
1292 
<span class="line-modified">1293             MethodHandle[] lengthers = new MethodHandle[pc];</span>
<span class="line-modified">1294 </span>
<span class="line-modified">1295             // Figure out lengths: constants&#39; lengths can be deduced on the spot.</span>
<span class="line-modified">1296             // All reference arguments were filtered to String in the combinators below, so we can</span>
<span class="line-modified">1297             // call the usual String.length(). Primitive values string sizes can be estimated.</span>
<span class="line-removed">1298             int initial = 0;</span>
<span class="line-removed">1299             for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed">1300                 switch (el.getTag()) {</span>
<span class="line-removed">1301                     case TAG_CONST:</span>
<span class="line-removed">1302                         initial += el.getValue().length();</span>
<span class="line-removed">1303                         break;</span>
<span class="line-removed">1304                     case TAG_ARG:</span>
<span class="line-removed">1305                         final int i = el.getArgPos();</span>
<span class="line-removed">1306                         Class&lt;?&gt; type = ptypes[i];</span>
<span class="line-removed">1307                         if (type.isPrimitive()) {</span>
<span class="line-removed">1308                             MethodHandle est = MethodHandles.constant(int.class, estimateSize(type));</span>
<span class="line-removed">1309                             est = MethodHandles.dropArguments(est, 0, type);</span>
<span class="line-removed">1310                             lengthers[i] = est;</span>
<span class="line-removed">1311                         } else {</span>
<span class="line-removed">1312                             lengthers[i] = STRING_LENGTH;</span>
<span class="line-removed">1313                         }</span>
<span class="line-removed">1314                         break;</span>
<span class="line-removed">1315                     default:</span>
<span class="line-removed">1316                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed">1317                 }</span>
<span class="line-removed">1318             }</span>
1319 
<span class="line-removed">1320             // Create (StringBuilder, &lt;args&gt;) shape for appending:</span>
<span class="line-removed">1321             MethodHandle builder = MethodHandles.dropArguments(MethodHandles.identity(StringBuilder.class), 1, ptypes);</span>
<span class="line-removed">1322 </span>
<span class="line-removed">1323             // Compose append calls. This is done in reverse because the application order is</span>
<span class="line-removed">1324             // reverse as well.</span>
<span class="line-removed">1325             List&lt;RecipeElement&gt; elements = recipe.getElements();</span>
<span class="line-removed">1326             for (int i = elements.size() - 1; i &gt;= 0; i--) {</span>
<span class="line-removed">1327                 RecipeElement el = elements.get(i);</span>
<span class="line-removed">1328                 MethodHandle appender;</span>
<span class="line-removed">1329                 switch (el.getTag()) {</span>
<span class="line-removed">1330                     case TAG_CONST:</span>
<span class="line-removed">1331                         MethodHandle mh = appender(adaptToStringBuilder(String.class));</span>
<span class="line-removed">1332                         appender = MethodHandles.insertArguments(mh, 1, el.getValue());</span>
<span class="line-removed">1333                         break;</span>
<span class="line-removed">1334                     case TAG_ARG:</span>
<span class="line-removed">1335                         int ac = el.getArgPos();</span>
<span class="line-removed">1336                         appender = appender(ptypes[ac]);</span>
<span class="line-removed">1337 </span>
<span class="line-removed">1338                         // Insert dummy arguments to match the prefix in the signature.</span>
<span class="line-removed">1339                         // The actual appender argument will be the ac-ith argument.</span>
<span class="line-removed">1340                         if (ac != 0) {</span>
<span class="line-removed">1341                             appender = MethodHandles.dropArguments(appender, 1, Arrays.copyOf(ptypes, ac));</span>
<span class="line-removed">1342                         }</span>
<span class="line-removed">1343                         break;</span>
<span class="line-removed">1344                     default:</span>
<span class="line-removed">1345                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
1346                 }
<span class="line-removed">1347                 builder = MethodHandles.foldArguments(builder, appender);</span>
<span class="line-removed">1348             }</span>
<span class="line-removed">1349 </span>
<span class="line-removed">1350             // Build the sub-tree that adds the sizes and produces a StringBuilder:</span>
<span class="line-removed">1351 </span>
<span class="line-removed">1352             // a) Start with the reducer that accepts all arguments, plus one</span>
<span class="line-removed">1353             //    slot for the initial value. Inject the initial value right away.</span>
<span class="line-removed">1354             //    This produces (&lt;ints&gt;)int shape:</span>
<span class="line-removed">1355             MethodHandle sum = getReducerFor(pc + 1);</span>
<span class="line-removed">1356             MethodHandle adder = MethodHandles.insertArguments(sum, 0, initial);</span>
<span class="line-removed">1357 </span>
<span class="line-removed">1358             // b) Apply lengthers to transform arguments to lengths, producing (&lt;args&gt;)int</span>
<span class="line-removed">1359             adder = MethodHandles.filterArguments(adder, 0, lengthers);</span>
<span class="line-removed">1360 </span>
<span class="line-removed">1361             // c) Instantiate StringBuilder (&lt;args&gt;)int -&gt; (&lt;args&gt;)StringBuilder</span>
<span class="line-removed">1362             MethodHandle newBuilder = MethodHandles.filterReturnValue(adder, NEW_STRING_BUILDER);</span>
<span class="line-removed">1363 </span>
<span class="line-removed">1364             // d) Fold in StringBuilder constructor, this produces (&lt;args&gt;)StringBuilder</span>
<span class="line-removed">1365             MethodHandle mh = MethodHandles.foldArguments(builder, newBuilder);</span>
<span class="line-removed">1366 </span>
<span class="line-removed">1367             // Convert non-primitive arguments to Strings</span>
<span class="line-removed">1368             mh = MethodHandles.filterArguments(mh, 0, filters);</span>
<span class="line-removed">1369 </span>
<span class="line-removed">1370             // Convert (&lt;args&gt;)StringBuilder to (&lt;args&gt;)String</span>
<span class="line-removed">1371             if (DEBUG &amp;&amp; mode.isExact()) {</span>
<span class="line-removed">1372                 mh = MethodHandles.filterReturnValue(mh, BUILDER_TO_STRING_CHECKED);</span>
<span class="line-removed">1373             } else {</span>
<span class="line-removed">1374                 mh = MethodHandles.filterReturnValue(mh, BUILDER_TO_STRING);</span>
1375             }
<span class="line-modified">1376 </span>
<span class="line-removed">1377             return mh;</span>
<span class="line-removed">1378         }</span>
<span class="line-removed">1379 </span>
<span class="line-removed">1380         private static MethodHandle getReducerFor(int cnt) {</span>
<span class="line-removed">1381             return SUMMERS.computeIfAbsent(cnt, SUMMER);</span>
1382         }
1383 
<span class="line-modified">1384         private static MethodHandle appender(Class&lt;?&gt; appendType) {</span>
<span class="line-modified">1385             MethodHandle appender = lookupVirtual(MethodHandles.publicLookup(), StringBuilder.class, &quot;append&quot;,</span>
<span class="line-modified">1386                     StringBuilder.class, adaptToStringBuilder(appendType));</span>
<span class="line-modified">1387 </span>
<span class="line-modified">1388             // appenders should return void, this would not modify the target signature during folding</span>
<span class="line-modified">1389             MethodType nt = MethodType.methodType(void.class, StringBuilder.class, appendType);</span>
<span class="line-modified">1390             return appender.asType(nt);</span>
<span class="line-modified">1391         }</span>
<span class="line-modified">1392 </span>
<span class="line-modified">1393         private static String toStringChecked(StringBuilder sb) {</span>
<span class="line-removed">1394             String s = sb.toString();</span>
<span class="line-removed">1395             if (s.length() != sb.capacity()) {</span>
<span class="line-removed">1396                 throw new AssertionError(&quot;Exactness check failed: result length = &quot; + s.length() + &quot;, buffer capacity = &quot; + sb.capacity());</span>
<span class="line-removed">1397             }</span>
<span class="line-removed">1398             return s;</span>
<span class="line-removed">1399         }</span>
<span class="line-removed">1400 </span>
<span class="line-removed">1401         private static int sum(int v1, int v2) {</span>
<span class="line-removed">1402             return v1 + v2;</span>
<span class="line-removed">1403         }</span>
<span class="line-removed">1404 </span>
<span class="line-removed">1405         private static int sum(int v1, int v2, int v3) {</span>
<span class="line-removed">1406             return v1 + v2 + v3;</span>
<span class="line-removed">1407         }</span>
<span class="line-removed">1408 </span>
<span class="line-removed">1409         private static int sum(int v1, int v2, int v3, int v4) {</span>
<span class="line-removed">1410             return v1 + v2 + v3 + v4;</span>
<span class="line-removed">1411         }</span>
<span class="line-removed">1412 </span>
<span class="line-removed">1413         private static int sum(int v1, int v2, int v3, int v4, int v5) {</span>
<span class="line-removed">1414             return v1 + v2 + v3 + v4 + v5;</span>
<span class="line-removed">1415         }</span>
<span class="line-removed">1416 </span>
<span class="line-removed">1417         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6) {</span>
<span class="line-removed">1418             return v1 + v2 + v3 + v4 + v5 + v6;</span>
<span class="line-removed">1419         }</span>
<span class="line-removed">1420 </span>
<span class="line-removed">1421         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6, int v7) {</span>
<span class="line-removed">1422             return v1 + v2 + v3 + v4 + v5 + v6 + v7;</span>
<span class="line-removed">1423         }</span>
<span class="line-removed">1424 </span>
<span class="line-removed">1425         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8) {</span>
<span class="line-removed">1426             return v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8;</span>
<span class="line-removed">1427         }</span>
<span class="line-removed">1428 </span>
<span class="line-removed">1429         private static int sum(int initial, int[] vs) {</span>
<span class="line-removed">1430             int sum = initial;</span>
<span class="line-removed">1431             for (int v : vs) {</span>
<span class="line-removed">1432                 sum += v;</span>
<span class="line-removed">1433             }</span>
<span class="line-removed">1434             return sum;</span>
<span class="line-removed">1435         }</span>
<span class="line-removed">1436 </span>
<span class="line-removed">1437         private static final Lookup MHSBS_LOOKUP = lookup();</span>
<span class="line-removed">1438 </span>
<span class="line-removed">1439         private static final ConcurrentMap&lt;Integer, MethodHandle&gt; SUMMERS;</span>
<span class="line-removed">1440 </span>
<span class="line-removed">1441         // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-removed">1442         private static final Function&lt;Integer, MethodHandle&gt; SUMMER = new Function&lt;Integer, MethodHandle&gt;() {</span>
<span class="line-removed">1443             @Override</span>
<span class="line-removed">1444             public MethodHandle apply(Integer cnt) {</span>
<span class="line-removed">1445                 if (cnt == 1) {</span>
<span class="line-removed">1446                     return MethodHandles.identity(int.class);</span>
<span class="line-removed">1447                 } else if (cnt &lt;= 8) {</span>
<span class="line-removed">1448                     // Variable-arity collectors are not as efficient as small-count methods,</span>
<span class="line-removed">1449                     // unroll some initial sizes.</span>
<span class="line-removed">1450                     Class&lt;?&gt;[] cls = new Class&lt;?&gt;[cnt];</span>
<span class="line-removed">1451                     Arrays.fill(cls, int.class);</span>
<span class="line-removed">1452                     return lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class, &quot;sum&quot;, int.class, cls);</span>
<span class="line-removed">1453                 } else {</span>
<span class="line-removed">1454                     return lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class, &quot;sum&quot;, int.class, int.class, int[].class)</span>
<span class="line-removed">1455                             .asCollector(int[].class, cnt - 1);</span>
1456                 }
<span class="line-modified">1457             }</span>
<span class="line-modified">1458         };</span>
<span class="line-removed">1459 </span>
<span class="line-removed">1460         private static final MethodHandle NEW_STRING_BUILDER, STRING_LENGTH, BUILDER_TO_STRING, BUILDER_TO_STRING_CHECKED;</span>
<span class="line-removed">1461 </span>
<span class="line-removed">1462         static {</span>
<span class="line-removed">1463             SUMMERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-removed">1464             Lookup publicLookup = MethodHandles.publicLookup();</span>
<span class="line-removed">1465             NEW_STRING_BUILDER = lookupConstructor(publicLookup, StringBuilder.class, int.class);</span>
<span class="line-removed">1466             STRING_LENGTH = lookupVirtual(publicLookup, String.class, &quot;length&quot;, int.class);</span>
<span class="line-removed">1467             BUILDER_TO_STRING = lookupVirtual(publicLookup, StringBuilder.class, &quot;toString&quot;, String.class);</span>
<span class="line-removed">1468             if (DEBUG) {</span>
<span class="line-removed">1469                 BUILDER_TO_STRING_CHECKED = lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class,</span>
<span class="line-removed">1470                         &quot;toStringChecked&quot;, String.class, StringBuilder.class);</span>
<span class="line-removed">1471             } else {</span>
<span class="line-removed">1472                 BUILDER_TO_STRING_CHECKED = null;</span>
1473             }
1474         }
1475 
<span class="line-modified">1476     }</span>
<span class="line-modified">1477 </span>

1478 
<span class="line-modified">1479     /**</span>
<span class="line-modified">1480      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_INLINE_SIZED_EXACT}: &quot;MethodHandles inline,</span>
<span class="line-removed">1481      * sized exactly&quot;.&lt;/b&gt;</span>
<span class="line-removed">1482      *</span>
<span class="line-removed">1483      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the</span>
<span class="line-removed">1484      * byte[] array on its own and passes that byte[] array to String</span>
<span class="line-removed">1485      * constructor. This strategy requires access to some private APIs in JDK,</span>
<span class="line-removed">1486      * most notably, the read-only Integer/Long.stringSize methods that measure</span>
<span class="line-removed">1487      * the character length of the integers, and the private String constructor</span>
<span class="line-removed">1488      * that accepts byte[] arrays without copying. While this strategy assumes a</span>
<span class="line-removed">1489      * particular implementation details for String, this opens the door for</span>
<span class="line-removed">1490      * building a very optimal concatenation sequence. This is the only strategy</span>
<span class="line-removed">1491      * that requires porting if there are private JDK changes occur.</span>
<span class="line-removed">1492      */</span>
<span class="line-removed">1493     private static final class MethodHandleInlineCopyStrategy {</span>
<span class="line-removed">1494         private MethodHandleInlineCopyStrategy() {</span>
<span class="line-removed">1495             // no instantiation</span>
<span class="line-removed">1496         }</span>
<span class="line-removed">1497 </span>
<span class="line-removed">1498         static MethodHandle generate(MethodType mt, Recipe recipe) throws Throwable {</span>
<span class="line-removed">1499 </span>
<span class="line-removed">1500             // Fast-path two-argument Object + Object concatenations</span>
<span class="line-removed">1501             if (recipe.getElements().size() == 2) {</span>
<span class="line-removed">1502                 // Two object arguments</span>
<span class="line-removed">1503                 if (mt.parameterCount() == 2 &amp;&amp;</span>
<span class="line-removed">1504                     !mt.parameterType(0).isPrimitive() &amp;&amp;</span>
<span class="line-removed">1505                     !mt.parameterType(1).isPrimitive() &amp;&amp;</span>
<span class="line-removed">1506                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;</span>
<span class="line-removed">1507                     recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
1508 
<span class="line-modified">1509                     return simpleConcat();</span>
1510 
<span class="line-modified">1511                 } else if (mt.parameterCount() == 1 &amp;&amp;</span>
<span class="line-removed">1512                            !mt.parameterType(0).isPrimitive()) {</span>
<span class="line-removed">1513                     // One Object argument, one constant</span>
<span class="line-removed">1514                     MethodHandle mh = simpleConcat();</span>
1515 
<span class="line-modified">1516                     if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-modified">1517                         recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="line-modified">1518                         // First recipe element is a constant</span>
<span class="line-removed">1519                         return MethodHandles.insertArguments(mh, 0,</span>
<span class="line-removed">1520                                 recipe.getElements().get(0).getValue());</span>
1521 
<span class="line-modified">1522                     } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-modified">1523                                recipe.getElements().get(0).getTag() == TAG_ARG) {</span>
<span class="line-modified">1524                         // Second recipe element is a constant</span>
<span class="line-modified">1525                         return MethodHandles.insertArguments(mh, 1,</span>
<span class="line-modified">1526                                 recipe.getElements().get(1).getValue());</span>





1527 
<span class="line-modified">1528                     }</span>
<span class="line-modified">1529                 }</span>
<span class="line-removed">1530                 // else... fall-through to slow-path</span>
<span class="line-removed">1531             }</span>
1532 
<span class="line-modified">1533             // Create filters and obtain filtered parameter types. Filters would be used in the beginning</span>
<span class="line-modified">1534             // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).</span>
<span class="line-modified">1535             // The filtered argument type list is used all over in the combinators below.</span>
<span class="line-modified">1536             Class&lt;?&gt;[] ptypes = mt.parameterArray();</span>
<span class="line-modified">1537             MethodHandle[] filters = null;</span>
<span class="line-modified">1538             for (int i = 0; i &lt; ptypes.length; i++) {</span>
<span class="line-removed">1539                 MethodHandle filter = Stringifiers.forMost(ptypes[i]);</span>
<span class="line-removed">1540                 if (filter != null) {</span>
<span class="line-removed">1541                     if (filters == null) {</span>
<span class="line-removed">1542                         filters = new MethodHandle[ptypes.length];</span>
1543                     }
<span class="line-modified">1544                     filters[i] = filter;</span>
<span class="line-removed">1545                     ptypes[i] = filter.type().returnType();</span>
1546                 }
<span class="line-modified">1547             }</span>
<span class="line-removed">1548 </span>
<span class="line-removed">1549             // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;</span>
<span class="line-removed">1550             // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are</span>
<span class="line-removed">1551             // assembled bottom-up, which makes the code arguably hard to read.</span>
<span class="line-removed">1552 </span>
<span class="line-removed">1553             // Drop all remaining parameter types, leave only helper arguments:</span>
<span class="line-removed">1554             MethodHandle mh;</span>
<span class="line-removed">1555 </span>
<span class="line-removed">1556             mh = MethodHandles.dropArguments(newString(), 2, ptypes);</span>
<span class="line-removed">1557 </span>
<span class="line-removed">1558             long initialLengthCoder = INITIAL_CODER;</span>
<span class="line-removed">1559 </span>
<span class="line-removed">1560             // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already</span>
<span class="line-removed">1561             // known from the combinators below. We are assembling the string backwards, so the index coded</span>
<span class="line-removed">1562             // into indexCoder is the *ending* index.</span>
<span class="line-removed">1563 </span>
<span class="line-removed">1564             // We need one prepender per argument, but also need to fold in constants. We do so by greedily</span>
<span class="line-removed">1565             // create prependers that fold in surrounding constants into the argument prepender. This reduces</span>
<span class="line-removed">1566             // the number of unique MH combinator tree shapes we&#39;ll create in an application.</span>
<span class="line-removed">1567             String prefixConstant = null, suffixConstant = null;</span>
<span class="line-removed">1568             int pos = -1;</span>
<span class="line-removed">1569             for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed">1570                 // Do the prepend, and put &quot;new&quot; index at index 1</span>
<span class="line-removed">1571                 switch (el.getTag()) {</span>
<span class="line-removed">1572                     case TAG_CONST: {</span>
<span class="line-removed">1573                         String constantValue = el.getValue();</span>
<span class="line-removed">1574 </span>
<span class="line-removed">1575                         // Eagerly update the initialLengthCoder value</span>
<span class="line-removed">1576                         initialLengthCoder = (long)mixer(String.class).invoke(initialLengthCoder, constantValue);</span>
<span class="line-removed">1577 </span>
<span class="line-removed">1578                         if (pos &lt; 0) {</span>
<span class="line-removed">1579                             // Collecting into prefixConstant</span>
<span class="line-removed">1580                             prefixConstant = prefixConstant == null ? constantValue : prefixConstant + constantValue;</span>
<span class="line-removed">1581                         } else {</span>
<span class="line-removed">1582                             // Collecting into suffixConstant</span>
<span class="line-removed">1583                             suffixConstant = suffixConstant == null ? constantValue : suffixConstant + constantValue;</span>
<span class="line-removed">1584                         }</span>
<span class="line-removed">1585                         break;</span>
<span class="line-removed">1586                     }</span>
<span class="line-removed">1587                     case TAG_ARG: {</span>
1588 
<span class="line-modified">1589                         if (pos &gt;= 0) {</span>
<span class="line-modified">1590                             // Flush the previous non-constant arg with any prefix/suffix constant</span>
<span class="line-modified">1591                             mh = MethodHandles.filterArgumentsWithCombiner(</span>
1592                                 mh, 1,
1593                                 prepender(prefixConstant, ptypes[pos], suffixConstant),
1594                                 1, 0, // indexCoder, storage
1595                                 2 + pos  // selected argument
<span class="line-modified">1596                             );</span>
<span class="line-modified">1597                             prefixConstant = suffixConstant = null;</span>
<span class="line-removed">1598                         }</span>
<span class="line-removed">1599                         // Mark the pos of next non-constant arg</span>
<span class="line-removed">1600                         pos = el.getArgPos();</span>
<span class="line-removed">1601                         break;</span>
1602                     }
<span class="line-modified">1603                     default:</span>
<span class="line-modified">1604                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>

1605                 }


1606             }

1607 
<span class="line-modified">1608             // Insert any trailing args, constants</span>
<span class="line-modified">1609             if (pos &gt;= 0) {</span>
<span class="line-modified">1610                 mh = MethodHandles.filterArgumentsWithCombiner(</span>
1611                     mh, 1,
1612                     prepender(prefixConstant, ptypes[pos], suffixConstant),
1613                     1, 0, // indexCoder, storage
1614                     2 + pos  // selected argument
<span class="line-modified">1615                 );</span>
<span class="line-modified">1616             } else if (prefixConstant != null) {</span>
<span class="line-modified">1617                 assert (suffixConstant == null);</span>
<span class="line-modified">1618                 // Sole prefixConstant can only happen if there were no non-constant arguments</span>
<span class="line-modified">1619                 mh = MethodHandles.filterArgumentsWithCombiner(</span>
1620                     mh, 1,
1621                     MethodHandles.insertArguments(prepender(null, String.class, null), 2, prefixConstant),
1622                     1, 0 // indexCoder, storage
<span class="line-removed">1623                 );</span>
<span class="line-removed">1624             }</span>
<span class="line-removed">1625 </span>
<span class="line-removed">1626             // Fold in byte[] instantiation at argument 0</span>
<span class="line-removed">1627             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArray(),</span>
<span class="line-removed">1628                     1 // index</span>
1629             );

1630 
<span class="line-modified">1631             // Start combining length and coder mixers.</span>
<span class="line-modified">1632             //</span>
<span class="line-modified">1633             // Length is easy: constant lengths can be computed on the spot, and all non-constant</span>
<span class="line-modified">1634             // shapes have been either converted to Strings, or explicit methods for getting the</span>
<span class="line-modified">1635             // string length out of primitives are provided.</span>
<span class="line-modified">1636             //</span>
<span class="line-modified">1637             // Coders are more interesting. Only Object, String and char arguments (and constants)</span>
<span class="line-modified">1638             // can have non-Latin1 encoding. It is easier to blindly convert constants to String,</span>
<span class="line-modified">1639             // and deduce the coder from there. Arguments would be either converted to Strings</span>
<span class="line-modified">1640             // during the initial filtering, or handled by specializations in MIXERS.</span>
<span class="line-modified">1641             //</span>
<span class="line-modified">1642             // The method handle shape before all mixers are combined in is:</span>
<span class="line-modified">1643             //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)</span>
<span class="line-modified">1644             //</span>
<span class="line-modified">1645             // We will bind the initialLengthCoder value to the last mixer (the one that will be</span>
<span class="line-modified">1646             // executed first), then fold that in. This leaves the shape after all mixers are</span>
<span class="line-modified">1647             // combined in as:</span>
<span class="line-modified">1648             //   (&lt;args&gt;)String = (&lt;args&gt;)</span>
<span class="line-modified">1649 </span>
<span class="line-modified">1650             int ac = -1;</span>
<span class="line-modified">1651             MethodHandle mix = null;</span>
<span class="line-modified">1652             for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-modified">1653                 switch (el.getTag()) {</span>
<span class="line-modified">1654                     case TAG_CONST:</span>
<span class="line-modified">1655                         // Constants already handled in the code above</span>
<span class="line-modified">1656                         break;</span>
<span class="line-modified">1657                     case TAG_ARG:</span>
<span class="line-modified">1658                         if (ac &gt;= 0) {</span>
<span class="line-modified">1659                             // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.</span>
<span class="line-modified">1660                             mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-modified">1661                                     0, // old-index</span>
<span class="line-modified">1662                                     1 + ac // selected argument</span>
<span class="line-modified">1663                             );</span>
<span class="line-modified">1664                         }</span>
<span class="line-modified">1665 </span>
<span class="line-modified">1666                         ac = el.getArgPos();</span>
<span class="line-modified">1667                         Class&lt;?&gt; argClass = ptypes[ac];</span>
<span class="line-modified">1668                         mix = mixer(argClass);</span>
<span class="line-modified">1669 </span>
<span class="line-removed">1670                         break;</span>
<span class="line-removed">1671                     default:</span>
<span class="line-removed">1672                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed">1673                 }</span>
<span class="line-removed">1674             }</span>
1675 
<span class="line-modified">1676             // Insert the initialLengthCoder value into the final mixer, then</span>
<span class="line-modified">1677             // fold that into the base method handle</span>
<span class="line-modified">1678             if (ac &gt;= 0) {</span>
<span class="line-modified">1679                 mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);</span>
<span class="line-modified">1680                 mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-modified">1681                         1 + ac // selected argument</span>
<span class="line-modified">1682                 );</span>
<span class="line-removed">1683             } else {</span>
<span class="line-removed">1684                 // No mixer (constants only concat), insert initialLengthCoder directly</span>
<span class="line-removed">1685                 mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);</span>
1686             }

1687 
<span class="line-modified">1688             // The method handle shape here is (&lt;args&gt;).</span>










1689 
<span class="line-modified">1690             // Apply filters, converting the arguments:</span>
<span class="line-removed">1691             if (filters != null) {</span>
<span class="line-removed">1692                 mh = MethodHandles.filterArguments(mh, 0, filters);</span>
<span class="line-removed">1693             }</span>
1694 
<span class="line-modified">1695             return mh;</span>


1696         }
1697 
<span class="line-modified">1698         private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {</span>
<span class="line-modified">1699             return MethodHandles.insertArguments(</span>
<span class="line-modified">1700                     MethodHandles.insertArguments(</span>
<span class="line-modified">1701                         PREPENDERS.computeIfAbsent(cl, PREPEND), 2, prefix), 3, suffix);</span>


1702         }



1703 
<span class="line-modified">1704         private static MethodHandle mixer(Class&lt;?&gt; cl) {</span>
<span class="line-modified">1705             return MIXERS.computeIfAbsent(cl, MIX);</span>









1706         }

1707 
<span class="line-modified">1708         // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-modified">1709         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {</span>
<span class="line-modified">1710             @Override</span>
<span class="line-modified">1711             public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-modified">1712                 return JLA.stringConcatHelper(&quot;prepend&quot;,</span>
<span class="line-modified">1713                             methodType(long.class, long.class, byte[].class,</span>
<span class="line-modified">1714                                        String.class, Wrapper.asPrimitiveType(c), String.class));</span>
<span class="line-removed">1715             }</span>
<span class="line-removed">1716         };</span>
1717 
<span class="line-modified">1718         // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-modified">1719         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {</span>
<span class="line-modified">1720             @Override</span>
<span class="line-modified">1721             public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-modified">1722                 return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));</span>
<span class="line-modified">1723             }</span>
<span class="line-modified">1724         };</span>
1725 
<span class="line-modified">1726         private @Stable static MethodHandle SIMPLE_CONCAT;</span>
<span class="line-modified">1727         private static MethodHandle simpleConcat() {</span>
<span class="line-modified">1728             if (SIMPLE_CONCAT == null) {</span>
<span class="line-modified">1729                 SIMPLE_CONCAT = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));</span>
<span class="line-removed">1730             }</span>
<span class="line-removed">1731             return SIMPLE_CONCAT;</span>
1732         }


1733 
<span class="line-modified">1734         private @Stable static MethodHandle NEW_STRING;</span>
<span class="line-modified">1735         private static MethodHandle newString() {</span>
<span class="line-modified">1736             MethodHandle mh = NEW_STRING;</span>
<span class="line-modified">1737             if (mh == null) {</span>
<span class="line-modified">1738                 NEW_STRING = mh =</span>
1739                     JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));
<span class="line-removed">1740             }</span>
<span class="line-removed">1741             return mh;</span>
1742         }
<span class="line-modified">1743         private @Stable static MethodHandle NEW_ARRAY;</span>
<span class="line-modified">1744         private static MethodHandle newArray() {</span>
<span class="line-modified">1745             MethodHandle mh = NEW_ARRAY;</span>
<span class="line-modified">1746             if (mh == null) {</span>
<span class="line-modified">1747                 NEW_ARRAY = mh =</span>


1748                     JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));
<span class="line-removed">1749             }</span>
<span class="line-removed">1750             return mh;</span>
<span class="line-removed">1751         }</span>
<span class="line-removed">1752 </span>
<span class="line-removed">1753         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;</span>
<span class="line-removed">1754         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;</span>
<span class="line-removed">1755         private static final long INITIAL_CODER;</span>
<span class="line-removed">1756 </span>
<span class="line-removed">1757         static {</span>
<span class="line-removed">1758             INITIAL_CODER = JLA.stringConcatInitialCoder();</span>
<span class="line-removed">1759             PREPENDERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-removed">1760             MIXERS = new ConcurrentHashMap&lt;&gt;();</span>
1761         }

1762     }
1763 
1764     /**
<span class="line-modified">1765      * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally</span>
<span class="line-modified">1766      * delegate to {@code String.valueOf}, depending on argument&#39;s type.</span>

1767      */
<span class="line-modified">1768     private static final class Stringifiers {</span>
<span class="line-modified">1769         private Stringifiers() {</span>
<span class="line-modified">1770             // no instantiation</span>
<span class="line-modified">1771         }</span>
<span class="line-modified">1772 </span>
<span class="line-modified">1773         private static final MethodHandle OBJECT_INSTANCE =</span>
<span class="line-modified">1774                 JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));</span>
<span class="line-modified">1775 </span>
<span class="line-modified">1776         private static class FloatStringifiers {</span>
<span class="line-modified">1777             private static final MethodHandle FLOAT_INSTANCE =</span>




1778                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
<span class="line-removed">1779 </span>
<span class="line-removed">1780             private static final MethodHandle DOUBLE_INSTANCE =</span>
<span class="line-removed">1781                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);</span>
<span class="line-removed">1782         }</span>
<span class="line-removed">1783 </span>
<span class="line-removed">1784         private static class StringifierAny extends ClassValue&lt;MethodHandle&gt; {</span>
<span class="line-removed">1785 </span>
<span class="line-removed">1786             private static final ClassValue&lt;MethodHandle&gt; INSTANCE = new StringifierAny();</span>
<span class="line-removed">1787 </span>
<span class="line-removed">1788             @Override</span>
<span class="line-removed">1789             protected MethodHandle computeValue(Class&lt;?&gt; cl) {</span>
<span class="line-removed">1790                 if (cl == byte.class || cl == short.class || cl == int.class) {</span>
<span class="line-removed">1791                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, int.class);</span>
<span class="line-removed">1792                 } else if (cl == boolean.class) {</span>
<span class="line-removed">1793                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, boolean.class);</span>
<span class="line-removed">1794                 } else if (cl == char.class) {</span>
<span class="line-removed">1795                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, char.class);</span>
<span class="line-removed">1796                 } else if (cl == long.class) {</span>
<span class="line-removed">1797                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, long.class);</span>
<span class="line-removed">1798                 } else {</span>
<span class="line-removed">1799                     MethodHandle mh = forMost(cl);</span>
<span class="line-removed">1800                     if (mh != null) {</span>
<span class="line-removed">1801                         return mh;</span>
<span class="line-removed">1802                     } else {</span>
<span class="line-removed">1803                         throw new IllegalStateException(&quot;Unknown class: &quot; + cl);</span>
<span class="line-removed">1804                     }</span>
<span class="line-removed">1805                 }</span>
<span class="line-removed">1806             }</span>
<span class="line-removed">1807         }</span>
<span class="line-removed">1808 </span>
<span class="line-removed">1809         /**</span>
<span class="line-removed">1810          * Returns a stringifier for references and floats/doubles only.</span>
<span class="line-removed">1811          * Always returns null for other primitives.</span>
<span class="line-removed">1812          *</span>
<span class="line-removed">1813          * @param t class to stringify</span>
<span class="line-removed">1814          * @return stringifier; null, if not available</span>
<span class="line-removed">1815          */</span>
<span class="line-removed">1816         static MethodHandle forMost(Class&lt;?&gt; t) {</span>
<span class="line-removed">1817             if (!t.isPrimitive()) {</span>
<span class="line-removed">1818                 return OBJECT_INSTANCE;</span>
<span class="line-removed">1819             } else if (t == float.class) {</span>
<span class="line-removed">1820                 return FloatStringifiers.FLOAT_INSTANCE;</span>
<span class="line-removed">1821             } else if (t == double.class) {</span>
<span class="line-removed">1822                 return FloatStringifiers.DOUBLE_INSTANCE;</span>
<span class="line-removed">1823             }</span>
<span class="line-removed">1824             return null;</span>
1825         }
<span class="line-modified">1826 </span>
<span class="line-modified">1827         /**</span>
<span class="line-modified">1828          * Returns a stringifier for any type. Never returns null.</span>
<span class="line-modified">1829          *</span>
<span class="line-modified">1830          * @param t class to stringify</span>
<span class="line-modified">1831          * @return stringifier</span>
<span class="line-modified">1832          */</span>
<span class="line-modified">1833         static MethodHandle forAny(Class&lt;?&gt; t) {</span>
<span class="line-removed">1834             return StringifierAny.INSTANCE.get(t);</span>
1835         }

1836     }
1837 
<span class="line-modified">1838     /* ------------------------------- Common utilities ------------------------------------ */</span>



1839 
<span class="line-modified">1840     static MethodHandle lookupStatic(Lookup lookup, Class&lt;?&gt; refc, String name, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {</span>
<span class="line-modified">1841         try {</span>
<span class="line-modified">1842             return lookup.findStatic(refc, name, MethodType.methodType(rtype, ptypes));</span>
<span class="line-modified">1843         } catch (NoSuchMethodException | IllegalAccessException e) {</span>
<span class="line-modified">1844             throw new AssertionError(e);</span>
<span class="line-removed">1845         }</span>
1846     }
1847 
<span class="line-modified">1848     static MethodHandle lookupVirtual(Lookup lookup, Class&lt;?&gt; refc, String name, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {</span>
<span class="line-modified">1849         try {</span>
<span class="line-modified">1850             return lookup.findVirtual(refc, name, MethodType.methodType(rtype, ptypes));</span>
<span class="line-modified">1851         } catch (NoSuchMethodException | IllegalAccessException e) {</span>
<span class="line-modified">1852             throw new AssertionError(e);</span>
<span class="line-modified">1853         }</span>










1854     }
1855 
<span class="line-modified">1856     static MethodHandle lookupConstructor(Lookup lookup, Class&lt;?&gt; refc, Class&lt;?&gt; ptypes) {</span>

1857         try {
<span class="line-modified">1858             return lookup.findConstructor(refc, MethodType.methodType(void.class, ptypes));</span>
1859         } catch (NoSuchMethodException | IllegalAccessException e) {
1860             throw new AssertionError(e);
1861         }
1862     }
1863 
<span class="line-removed">1864     static int estimateSize(Class&lt;?&gt; cl) {</span>
<span class="line-removed">1865         if (cl == Integer.TYPE) {</span>
<span class="line-removed">1866             return 11; // &quot;-2147483648&quot;</span>
<span class="line-removed">1867         } else if (cl == Boolean.TYPE) {</span>
<span class="line-removed">1868             return 5; // &quot;false&quot;</span>
<span class="line-removed">1869         } else if (cl == Byte.TYPE) {</span>
<span class="line-removed">1870             return 4; // &quot;-128&quot;</span>
<span class="line-removed">1871         } else if (cl == Character.TYPE) {</span>
<span class="line-removed">1872             return 1; // duh</span>
<span class="line-removed">1873         } else if (cl == Short.TYPE) {</span>
<span class="line-removed">1874             return 6; // &quot;-32768&quot;</span>
<span class="line-removed">1875         } else if (cl == Double.TYPE) {</span>
<span class="line-removed">1876             return 26; // apparently, no larger than this, see FloatingDecimal.BinaryToASCIIBuffer.buffer</span>
<span class="line-removed">1877         } else if (cl == Float.TYPE) {</span>
<span class="line-removed">1878             return 26; // apparently, no larger than this, see FloatingDecimal.BinaryToASCIIBuffer.buffer</span>
<span class="line-removed">1879         } else if (cl == Long.TYPE)  {</span>
<span class="line-removed">1880             return 20; // &quot;-9223372036854775808&quot;</span>
<span class="line-removed">1881         } else {</span>
<span class="line-removed">1882             throw new IllegalArgumentException(&quot;Cannot estimate the size for &quot; + cl);</span>
<span class="line-removed">1883         }</span>
<span class="line-removed">1884     }</span>
<span class="line-removed">1885 </span>
<span class="line-removed">1886     static Class&lt;?&gt; adaptToStringBuilder(Class&lt;?&gt; c) {</span>
<span class="line-removed">1887         if (c.isPrimitive()) {</span>
<span class="line-removed">1888             if (c == Byte.TYPE || c == Short.TYPE) {</span>
<span class="line-removed">1889                 return int.class;</span>
<span class="line-removed">1890             }</span>
<span class="line-removed">1891         } else {</span>
<span class="line-removed">1892             if (c != String.class) {</span>
<span class="line-removed">1893                 return Object.class;</span>
<span class="line-removed">1894             }</span>
<span class="line-removed">1895         }</span>
<span class="line-removed">1896         return c;</span>
<span class="line-removed">1897     }</span>
<span class="line-removed">1898 </span>
1899     private StringConcatFactory() {
1900         // no instantiation
1901     }
<span class="line-removed">1902 </span>
1903 }
</pre>
</td>
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangAccess;
  29 import jdk.internal.access.SharedSecrets;






  30 import jdk.internal.vm.annotation.Stable;
  31 import sun.invoke.util.Wrapper;
  32 
  33 import java.lang.invoke.MethodHandles.Lookup;
  34 import java.util.ArrayList;
  35 import java.util.Arrays;
  36 import java.util.List;
  37 import java.util.Objects;
  38 import java.util.concurrent.ConcurrentHashMap;
  39 import java.util.concurrent.ConcurrentMap;
  40 import java.util.function.Function;
  41 

  42 import static java.lang.invoke.MethodType.methodType;


  43 
  44 /**
  45  * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
  46  * can be used to efficiently concatenate a known number of arguments of known
  47  * types, possibly after type adaptation and partial evaluation of arguments.
  48  * These methods are typically used as &lt;em&gt;bootstrap methods&lt;/em&gt; for {@code
  49  * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
  50  * feature of the Java Programming Language.
  51  *
  52  * &lt;p&gt;Indirect access to the behavior specified by the provided {@code
  53  * MethodHandle} proceeds in order through two phases:
  54  *
  55  * &lt;ol&gt;
  56  *     &lt;li&gt;&lt;em&gt;Linkage&lt;/em&gt; occurs when the methods in this class are invoked.
  57  * They take as arguments a method type describing the concatenated arguments
  58  * count and types, and optionally the String &lt;em&gt;recipe&lt;/em&gt;, plus the
  59  * constants that participate in the String concatenation. The details on
  60  * accepted recipe shapes are described further below. Linkage may involve
  61  * dynamically loading a new class that implements the expected concatenation
  62  * behavior. The {@code CallSite} holds the {@code MethodHandle} pointing to the
</pre>
<hr />
<pre>
 102 
 103     /**
 104      * Tag used to demarcate an ordinary argument.
 105      */
 106     private static final char TAG_ARG = &#39;\u0001&#39;;
 107 
 108     /**
 109      * Tag used to demarcate a constant.
 110      */
 111     private static final char TAG_CONST = &#39;\u0002&#39;;
 112 
 113     /**
 114      * Maximum number of argument slots in String Concat call.
 115      *
 116      * While the maximum number of argument slots that indy call can handle is 253,
 117      * we do not use all those slots, to let the strategies with MethodHandle
 118      * combinators to use some arguments.
 119      */
 120     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
 121 








 122     private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
 123 
































































































 124     /**
 125      * Parses the recipe string, and produces a traversable collection of
 126      * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
 127      * strategies. Notably, this class parses out the constants from the recipe
 128      * and from other static arguments.
 129      */
 130     private static final class Recipe {
 131         private final List&lt;RecipeElement&gt; elements;
 132 
 133         public Recipe(String src, Object[] constants) {
 134             List&lt;RecipeElement&gt; el = new ArrayList&lt;&gt;();
 135 
 136             int constC = 0;
 137             int argC = 0;
 138 
 139             StringBuilder acc = new StringBuilder();
 140 
 141             for (int i = 0; i &lt; src.length(); i++) {
 142                 char c = src.charAt(i);
 143 
</pre>
<hr />
<pre>
 315      *                   java.lang.String}.  When used with {@code invokedynamic},
 316      *                   this is provided by the {@code NameAndType} of the {@code
 317      *                   InvokeDynamic} structure and is stacked automatically by
 318      *                   the VM.
 319      * @return a CallSite whose target can be used to perform String
 320      * concatenation, with dynamic concatenation arguments described by the given
 321      * {@code concatType}.
 322      * @throws StringConcatException If any of the linkage invariants described
 323      *                               here are violated, or the lookup context
 324      *                               does not have private access privileges.
 325      * @throws NullPointerException If any of the incoming arguments is null.
 326      *                              This will never happen when a bootstrap method
 327      *                              is called with invokedynamic.
 328      *
 329      * @jls  5.1.11 String Conversion
 330      * @jls 15.18.1 String Concatenation Operator +
 331      */
 332     public static CallSite makeConcat(MethodHandles.Lookup lookup,
 333                                       String name,
 334                                       MethodType concatType) throws StringConcatException {




 335         return doStringConcat(lookup, name, concatType, true, null);
 336     }
 337 
 338     /**
 339      * Facilitates the creation of optimized String concatenation methods, that
 340      * can be used to efficiently concatenate a known number of arguments of
 341      * known types, possibly after type adaptation and partial evaluation of
 342      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
 343      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
 344      * feature of the Java Programming Language.
 345      *
 346      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
 347      * invoked, it returns the result of String concatenation, taking all
 348      * function arguments and constants passed to the linkage method as inputs for
 349      * concatenation. The target signature is given by {@code concatType}, and
 350      * does not include constants.
 351      * For a target accepting:
 352      * &lt;ul&gt;
 353      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
 354      *     &lt;li&gt;one input, concatenation results in the single
</pre>
<hr />
<pre>
 434      * @throws NullPointerException If any of the incoming arguments is null, or
 435      *                              any constant in {@code recipe} is null.
 436      *                              This will never happen when a bootstrap method
 437      *                              is called with invokedynamic.
 438      * @apiNote Code generators have three distinct ways to process a constant
 439      * string operand S in a string concatenation expression.  First, S can be
 440      * materialized as a reference (using ldc) and passed as an ordinary argument
 441      * (recipe &#39;\1&#39;). Or, S can be stored in the constant pool and passed as a
 442      * constant (recipe &#39;\2&#39;) . Finally, if S contains neither of the recipe
 443      * tag characters (&#39;\1&#39;, &#39;\2&#39;) then S can be interpolated into the recipe
 444      * itself, causing its characters to be inserted into the result.
 445      *
 446      * @jls  5.1.11 String Conversion
 447      * @jls 15.18.1 String Concatenation Operator +
 448      */
 449     public static CallSite makeConcatWithConstants(MethodHandles.Lookup lookup,
 450                                                    String name,
 451                                                    MethodType concatType,
 452                                                    String recipe,
 453                                                    Object... constants) throws StringConcatException {




 454         return doStringConcat(lookup, name, concatType, false, recipe, constants);
 455     }
 456 
 457     private static CallSite doStringConcat(MethodHandles.Lookup lookup,
 458                                            String name,
 459                                            MethodType concatType,
 460                                            boolean generateRecipe,
 461                                            String recipe,
 462                                            Object... constants) throws StringConcatException {
 463         Objects.requireNonNull(lookup, &quot;Lookup is null&quot;);
 464         Objects.requireNonNull(name, &quot;Name is null&quot;);
 465         Objects.requireNonNull(concatType, &quot;Concat type is null&quot;);
 466         Objects.requireNonNull(constants, &quot;Constants are null&quot;);
 467 
 468         for (Object o : constants) {
 469             Objects.requireNonNull(o, &quot;Cannot accept null constants&quot;);
 470         }
 471 
 472         if ((lookup.lookupModes() &amp; MethodHandles.Lookup.PRIVATE) == 0) {
 473             throw new StringConcatException(&quot;Invalid caller: &quot; +
</pre>
<hr />
<pre>
 505                     &quot;Mismatched number of concat constants: recipe wants &quot; +
 506                             cCount +
 507                             &quot; constants, but only &quot; +
 508                             constants.length +
 509                             &quot; are passed&quot;);
 510         }
 511 
 512         if (!concatType.returnType().isAssignableFrom(String.class)) {
 513             throw new StringConcatException(
 514                     &quot;The return type should be compatible with String, but it is &quot; +
 515                             concatType.returnType());
 516         }
 517 
 518         if (concatType.parameterSlotCount() &gt; MAX_INDY_CONCAT_ARG_SLOTS) {
 519             throw new StringConcatException(&quot;Too many concat argument slots: &quot; +
 520                     concatType.parameterSlotCount() +
 521                     &quot;, can only accept &quot; +
 522                     MAX_INDY_CONCAT_ARG_SLOTS);
 523         }
 524 

 525         Recipe rec = new Recipe(recipe, constants);
<span class="line-modified"> 526         MethodHandle mh = generate(lookup, concatType, rec);</span>
 527         return new ConstantCallSite(mh.asType(concatType));
 528     }
 529 




























 530     private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {
 531         try {
<span class="line-modified"> 532             return generateMHInlineCopy(mt, recipe);</span>


















 533         } catch (Error | StringConcatException e) {
 534             // Pass through any error or existing StringConcatException
 535             throw e;
 536         } catch (Throwable t) {
 537             throw new StringConcatException(&quot;Generator failed&quot;, t);
 538         }
 539     }
 540 





















 541 
 542     /**
<span class="line-modified"> 543      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the</span>
<span class="line-modified"> 544      * byte[] array on its own and passes that byte[] array to String</span>
<span class="line-modified"> 545      * constructor. This strategy requires access to some private APIs in JDK,</span>
<span class="line-modified"> 546      * most notably, the private String constructor that accepts byte[] arrays</span>
<span class="line-modified"> 547      * without copying.</span>
































 548      */
<span class="line-modified"> 549     private static MethodHandle generateMHInlineCopy(MethodType mt, Recipe recipe) throws Throwable {</span>






































































































































































































 550 
<span class="line-modified"> 551         // Fast-path two-argument Object + Object concatenations</span>
<span class="line-modified"> 552         if (recipe.getElements().size() == 2) {</span>
<span class="line-modified"> 553             // Two object arguments</span>
<span class="line-modified"> 554             if (mt.parameterCount() == 2 &amp;&amp;</span>
<span class="line-modified"> 555                     !mt.parameterType(0).isPrimitive() &amp;&amp;</span>
<span class="line-modified"> 556                     !mt.parameterType(1).isPrimitive() &amp;&amp;</span>
<span class="line-modified"> 557                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;</span>
<span class="line-modified"> 558                     recipe.getElements().get(1).getTag() == TAG_ARG) {</span>







































































































































































































































 559 
<span class="line-modified"> 560                 return simpleConcat();</span>













 561 
<span class="line-modified"> 562             } else if (mt.parameterCount() == 1 &amp;&amp;</span>
<span class="line-modified"> 563                     !mt.parameterType(0).isPrimitive()) {</span>
<span class="line-modified"> 564                 // One Object argument, one constant</span>
<span class="line-modified"> 565                 MethodHandle mh = simpleConcat();</span>


































 566 
<span class="line-modified"> 567                 if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-modified"> 568                         recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="line-modified"> 569                     // First recipe element is a constant</span>
<span class="line-modified"> 570                     return MethodHandles.insertArguments(mh, 0,</span>
<span class="line-modified"> 571                             recipe.getElements().get(0).getValue());</span>























 572 
<span class="line-modified"> 573                 } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-modified"> 574                         recipe.getElements().get(0).getTag() == TAG_ARG) {</span>
<span class="line-modified"> 575                     // Second recipe element is a constant</span>
<span class="line-modified"> 576                     return MethodHandles.insertArguments(mh, 1,</span>
<span class="line-modified"> 577                             recipe.getElements().get(1).getValue());</span>





















 578 


























 579                 }




























 580             }
<span class="line-modified"> 581             // else... fall-through to slow-path</span>





 582         }
 583 
<span class="line-modified"> 584         // Create filters and obtain filtered parameter types. Filters would be used in the beginning</span>
<span class="line-modified"> 585         // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).</span>
<span class="line-modified"> 586         // The filtered argument type list is used all over in the combinators below.</span>
<span class="line-modified"> 587         Class&lt;?&gt;[] ptypes = mt.parameterArray();</span>
<span class="line-modified"> 588         MethodHandle[] filters = null;</span>
<span class="line-modified"> 589         for (int i = 0; i &lt; ptypes.length; i++) {</span>
<span class="line-modified"> 590             MethodHandle filter = stringifierFor(ptypes[i]);</span>
<span class="line-modified"> 591             if (filter != null) {</span>
<span class="line-modified"> 592                 if (filters == null) {</span>
<span class="line-modified"> 593                     filters = new MethodHandle[ptypes.length];</span>






























































 594                 }
<span class="line-modified"> 595                 filters[i] = filter;</span>
<span class="line-modified"> 596                 ptypes[i] = filter.type().returnType();</span>














 597             }
 598         }
 599 
<span class="line-modified"> 600         // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;</span>
<span class="line-modified"> 601         // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are</span>
<span class="line-added"> 602         // assembled bottom-up, which makes the code arguably hard to read.</span>
 603 
<span class="line-modified"> 604         // Drop all remaining parameter types, leave only helper arguments:</span>
<span class="line-modified"> 605         MethodHandle mh;</span>



























 606 
<span class="line-modified"> 607         mh = MethodHandles.dropArguments(newString(), 2, ptypes);</span>
 608 
<span class="line-modified"> 609         long initialLengthCoder = INITIAL_CODER;</span>



 610 
<span class="line-modified"> 611         // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already</span>
<span class="line-modified"> 612         // known from the combinators below. We are assembling the string backwards, so the index coded</span>
<span class="line-modified"> 613         // into indexCoder is the *ending* index.</span>


 614 
<span class="line-modified"> 615         // We need one prepender per argument, but also need to fold in constants. We do so by greedily</span>
<span class="line-modified"> 616         // create prependers that fold in surrounding constants into the argument prepender. This reduces</span>
<span class="line-modified"> 617         // the number of unique MH combinator tree shapes we&#39;ll create in an application.</span>
<span class="line-modified"> 618         String prefixConstant = null, suffixConstant = null;</span>
<span class="line-modified"> 619         int pos = -1;</span>
<span class="line-added"> 620         for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-added"> 621             // Do the prepend, and put &quot;new&quot; index at index 1</span>
<span class="line-added"> 622             switch (el.getTag()) {</span>
<span class="line-added"> 623                 case TAG_CONST: {</span>
<span class="line-added"> 624                     String constantValue = el.getValue();</span>
 625 
<span class="line-modified"> 626                     // Eagerly update the initialLengthCoder value</span>
<span class="line-modified"> 627                     initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, constantValue);</span>


 628 
<span class="line-modified"> 629                     if (pos &lt; 0) {</span>
<span class="line-modified"> 630                         // Collecting into prefixConstant</span>
<span class="line-modified"> 631                         prefixConstant = prefixConstant == null ? constantValue : prefixConstant + constantValue;</span>
<span class="line-modified"> 632                     } else {</span>
<span class="line-modified"> 633                         // Collecting into suffixConstant</span>
<span class="line-modified"> 634                         suffixConstant = suffixConstant == null ? constantValue : suffixConstant + constantValue;</span>




 635                     }
<span class="line-modified"> 636                     break;</span>

 637                 }
<span class="line-modified"> 638                 case TAG_ARG: {</span>








































 639 
<span class="line-modified"> 640                     if (pos &gt;= 0) {</span>
<span class="line-modified"> 641                         // Flush the previous non-constant arg with any prefix/suffix constant</span>
<span class="line-modified"> 642                         mh = MethodHandles.filterArgumentsWithCombiner(</span>
 643                                 mh, 1,
 644                                 prepender(prefixConstant, ptypes[pos], suffixConstant),
 645                                 1, 0, // indexCoder, storage
 646                                 2 + pos  // selected argument
<span class="line-modified"> 647                         );</span>
<span class="line-modified"> 648                         prefixConstant = suffixConstant = null;</span>




 649                     }
<span class="line-modified"> 650                     // Mark the pos of next non-constant arg</span>
<span class="line-modified"> 651                     pos = el.getArgPos();</span>
<span class="line-added"> 652                     break;</span>
 653                 }
<span class="line-added"> 654                 default:</span>
<span class="line-added"> 655                     throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
 656             }
<span class="line-added"> 657         }</span>
 658 
<span class="line-modified"> 659         // Insert any trailing args, constants</span>
<span class="line-modified"> 660         if (pos &gt;= 0) {</span>
<span class="line-modified"> 661             mh = MethodHandles.filterArgumentsWithCombiner(</span>
 662                     mh, 1,
 663                     prepender(prefixConstant, ptypes[pos], suffixConstant),
 664                     1, 0, // indexCoder, storage
 665                     2 + pos  // selected argument
<span class="line-modified"> 666             );</span>
<span class="line-modified"> 667         } else if (prefixConstant != null) {</span>
<span class="line-modified"> 668             assert (suffixConstant == null);</span>
<span class="line-modified"> 669             // Sole prefixConstant can only happen if there were no non-constant arguments</span>
<span class="line-modified"> 670             mh = MethodHandles.filterArgumentsWithCombiner(</span>
 671                     mh, 1,
 672                     MethodHandles.insertArguments(prepender(null, String.class, null), 2, prefixConstant),
 673                     1, 0 // indexCoder, storage






 674             );
<span class="line-added"> 675         }</span>
 676 
<span class="line-modified"> 677         // Fold in byte[] instantiation at argument 0</span>
<span class="line-modified"> 678         mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArray(),</span>
<span class="line-modified"> 679                 1 // index</span>
<span class="line-modified"> 680         );</span>
<span class="line-modified"> 681 </span>
<span class="line-modified"> 682         // Start combining length and coder mixers.</span>
<span class="line-modified"> 683         //</span>
<span class="line-modified"> 684         // Length is easy: constant lengths can be computed on the spot, and all non-constant</span>
<span class="line-modified"> 685         // shapes have been either converted to Strings, or explicit methods for getting the</span>
<span class="line-modified"> 686         // string length out of primitives are provided.</span>
<span class="line-modified"> 687         //</span>
<span class="line-modified"> 688         // Coders are more interesting. Only Object, String and char arguments (and constants)</span>
<span class="line-modified"> 689         // can have non-Latin1 encoding. It is easier to blindly convert constants to String,</span>
<span class="line-modified"> 690         // and deduce the coder from there. Arguments would be either converted to Strings</span>
<span class="line-modified"> 691         // during the initial filtering, or handled by specializations in MIXERS.</span>
<span class="line-modified"> 692         //</span>
<span class="line-modified"> 693         // The method handle shape before all mixers are combined in is:</span>
<span class="line-modified"> 694         //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)</span>
<span class="line-modified"> 695         //</span>
<span class="line-modified"> 696         // We will bind the initialLengthCoder value to the last mixer (the one that will be</span>
<span class="line-modified"> 697         // executed first), then fold that in. This leaves the shape after all mixers are</span>
<span class="line-modified"> 698         // combined in as:</span>
<span class="line-modified"> 699         //   (&lt;args&gt;)String = (&lt;args&gt;)</span>
<span class="line-modified"> 700 </span>
<span class="line-modified"> 701         int ac = -1;</span>
<span class="line-modified"> 702         MethodHandle mix = null;</span>
<span class="line-modified"> 703         for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-modified"> 704             switch (el.getTag()) {</span>
<span class="line-modified"> 705                 case TAG_CONST:</span>
<span class="line-modified"> 706                     // Constants already handled in the code above</span>
<span class="line-modified"> 707                     break;</span>
<span class="line-modified"> 708                 case TAG_ARG:</span>
<span class="line-modified"> 709                     if (ac &gt;= 0) {</span>
<span class="line-modified"> 710                         // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.</span>
<span class="line-modified"> 711                         mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-modified"> 712                                 0, // old-index</span>
<span class="line-modified"> 713                                 1 + ac // selected argument</span>
<span class="line-modified"> 714                         );</span>
<span class="line-modified"> 715                     }</span>





 716 
<span class="line-modified"> 717                     ac = el.getArgPos();</span>
<span class="line-modified"> 718                     Class&lt;?&gt; argClass = ptypes[ac];</span>
<span class="line-modified"> 719                     mix = mixer(argClass);</span>
<span class="line-modified"> 720 </span>
<span class="line-modified"> 721                     break;</span>
<span class="line-modified"> 722                 default:</span>
<span class="line-modified"> 723                     throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>



 724             }
<span class="line-added"> 725         }</span>
 726 
<span class="line-modified"> 727         // Insert the initialLengthCoder value into the final mixer, then</span>
<span class="line-added"> 728         // fold that into the base method handle</span>
<span class="line-added"> 729         if (ac &gt;= 0) {</span>
<span class="line-added"> 730             mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);</span>
<span class="line-added"> 731             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-added"> 732                     1 + ac // selected argument</span>
<span class="line-added"> 733             );</span>
<span class="line-added"> 734         } else {</span>
<span class="line-added"> 735             // No mixer (constants only concat), insert initialLengthCoder directly</span>
<span class="line-added"> 736             mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);</span>
<span class="line-added"> 737         }</span>
 738 
<span class="line-modified"> 739         // The method handle shape here is (&lt;args&gt;).</span>



 740 
<span class="line-modified"> 741         // Apply filters, converting the arguments:</span>
<span class="line-added"> 742         if (filters != null) {</span>
<span class="line-added"> 743             mh = MethodHandles.filterArguments(mh, 0, filters);</span>
 744         }
 745 
<span class="line-modified"> 746         return mh;</span>
<span class="line-modified"> 747     }</span>
<span class="line-modified"> 748 </span>
<span class="line-modified"> 749     private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {</span>
<span class="line-added"> 750         if (prefix == null &amp;&amp; suffix == null) {</span>
<span class="line-added"> 751             return NULL_PREPENDERS.computeIfAbsent(cl, NULL_PREPEND);</span>
 752         }
<span class="line-added"> 753         return MethodHandles.insertArguments(</span>
<span class="line-added"> 754                         PREPENDERS.computeIfAbsent(cl, PREPEND), 3, prefix, suffix);</span>
<span class="line-added"> 755     }</span>
 756 
<span class="line-modified"> 757     private static MethodHandle mixer(Class&lt;?&gt; cl) {</span>
<span class="line-modified"> 758         return MIXERS.computeIfAbsent(cl, MIX);</span>
<span class="line-added"> 759     }</span>
<span class="line-added"> 760 </span>
<span class="line-added"> 761     // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-added"> 762     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {</span>
<span class="line-added"> 763         @Override</span>
<span class="line-added"> 764         public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-added"> 765             return JLA.stringConcatHelper(&quot;prepend&quot;,</span>
<span class="line-added"> 766                     methodType(long.class, long.class, byte[].class,</span>
<span class="line-added"> 767                             Wrapper.asPrimitiveType(c), String.class, String.class));</span>
 768         }
<span class="line-added"> 769     };</span>
 770 
<span class="line-modified"> 771     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; NULL_PREPEND = new Function&lt;&gt;() {</span>
<span class="line-modified"> 772         @Override</span>
<span class="line-modified"> 773         public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-modified"> 774             return MethodHandles.insertArguments(</span>
<span class="line-modified"> 775                             PREPENDERS.computeIfAbsent(c, PREPEND), 3, (String)null, (String)null);</span>
<span class="line-modified"> 776         }</span>
<span class="line-modified"> 777     };</span>


 778 
<span class="line-modified"> 779     // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-modified"> 780     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {</span>
<span class="line-modified"> 781         @Override</span>
<span class="line-modified"> 782         public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-modified"> 783             return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));</span>
<span class="line-modified"> 784         }</span>
<span class="line-modified"> 785     };</span>
 786 
<span class="line-modified"> 787     private @Stable static MethodHandle SIMPLE_CONCAT;</span>
<span class="line-modified"> 788     private static MethodHandle simpleConcat() {</span>
<span class="line-modified"> 789         if (SIMPLE_CONCAT == null) {</span>
<span class="line-modified"> 790             SIMPLE_CONCAT = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));</span>


 791         }
<span class="line-added"> 792         return SIMPLE_CONCAT;</span>
<span class="line-added"> 793     }</span>
 794 
<span class="line-modified"> 795     private @Stable static MethodHandle NEW_STRING;</span>
<span class="line-modified"> 796     private static MethodHandle newString() {</span>
<span class="line-modified"> 797         MethodHandle mh = NEW_STRING;</span>
<span class="line-modified"> 798         if (mh == null) {</span>
<span class="line-modified"> 799             NEW_STRING = mh =</span>
 800                     JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));


 801         }
<span class="line-modified"> 802         return mh;</span>
<span class="line-modified"> 803     }</span>
<span class="line-modified"> 804     private @Stable static MethodHandle NEW_ARRAY;</span>
<span class="line-modified"> 805     private static MethodHandle newArray() {</span>
<span class="line-modified"> 806         MethodHandle mh = NEW_ARRAY;</span>
<span class="line-added"> 807         if (mh == null) {</span>
<span class="line-added"> 808             NEW_ARRAY = mh =</span>
 809                     JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));












 810         }
<span class="line-added"> 811         return mh;</span>
 812     }
 813 
 814     /**
<span class="line-modified"> 815      * Public gateways to public &quot;stringify&quot; methods. These methods have the</span>
<span class="line-modified"> 816      * form String apply(T obj), and normally delegate to {@code String.valueOf},</span>
<span class="line-added"> 817      * depending on argument&#39;s type.</span>
 818      */
<span class="line-modified"> 819     private @Stable static MethodHandle OBJECT_STRINGIFIER;</span>
<span class="line-modified"> 820     private static MethodHandle objectStringifier() {</span>
<span class="line-modified"> 821         MethodHandle mh = OBJECT_STRINGIFIER;</span>
<span class="line-modified"> 822         if (mh == null) {</span>
<span class="line-modified"> 823             OBJECT_STRINGIFIER = mh =</span>
<span class="line-modified"> 824                     JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));</span>
<span class="line-modified"> 825         }</span>
<span class="line-modified"> 826         return mh;</span>
<span class="line-modified"> 827     }</span>
<span class="line-modified"> 828     private @Stable static MethodHandle FLOAT_STRINGIFIER;</span>
<span class="line-added"> 829     private static MethodHandle floatStringifier() {</span>
<span class="line-added"> 830         MethodHandle mh = FLOAT_STRINGIFIER;</span>
<span class="line-added"> 831         if (mh == null) {</span>
<span class="line-added"> 832             FLOAT_STRINGIFIER = mh =</span>
 833                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);














































 834         }
<span class="line-modified"> 835         return mh;</span>
<span class="line-modified"> 836     }</span>
<span class="line-modified"> 837     private @Stable static MethodHandle DOUBLE_STRINGIFIER;</span>
<span class="line-modified"> 838     private static MethodHandle doubleStringifier() {</span>
<span class="line-modified"> 839         MethodHandle mh = DOUBLE_STRINGIFIER;</span>
<span class="line-modified"> 840         if (mh == null) {</span>
<span class="line-modified"> 841             DOUBLE_STRINGIFIER = mh =</span>
<span class="line-modified"> 842                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);</span>

 843         }
<span class="line-added"> 844         return mh;</span>
 845     }
 846 
<span class="line-modified"> 847     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;</span>
<span class="line-added"> 848     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; NULL_PREPENDERS;</span>
<span class="line-added"> 849     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;</span>
<span class="line-added"> 850     private static final long INITIAL_CODER;</span>
 851 
<span class="line-modified"> 852     static {</span>
<span class="line-modified"> 853         INITIAL_CODER = JLA.stringConcatInitialCoder();</span>
<span class="line-modified"> 854         PREPENDERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-modified"> 855         NULL_PREPENDERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-modified"> 856         MIXERS = new ConcurrentHashMap&lt;&gt;();</span>

 857     }
 858 
<span class="line-modified"> 859     /**</span>
<span class="line-modified"> 860      * Returns a stringifier for references and floats/doubles only.</span>
<span class="line-modified"> 861      * Always returns null for other primitives.</span>
<span class="line-modified"> 862      *</span>
<span class="line-modified"> 863      * @param t class to stringify</span>
<span class="line-modified"> 864      * @return stringifier; null, if not available</span>
<span class="line-added"> 865      */</span>
<span class="line-added"> 866     private static MethodHandle stringifierFor(Class&lt;?&gt; t) {</span>
<span class="line-added"> 867         if (!t.isPrimitive()) {</span>
<span class="line-added"> 868             return objectStringifier();</span>
<span class="line-added"> 869         } else if (t == float.class) {</span>
<span class="line-added"> 870             return floatStringifier();</span>
<span class="line-added"> 871         } else if (t == double.class) {</span>
<span class="line-added"> 872             return doubleStringifier();</span>
<span class="line-added"> 873         }</span>
<span class="line-added"> 874         return null;</span>
 875     }
 876 
<span class="line-modified"> 877     private static MethodHandle lookupStatic(Lookup lookup, Class&lt;?&gt; refc, String name,</span>
<span class="line-added"> 878                                      Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {</span>
 879         try {
<span class="line-modified"> 880             return lookup.findStatic(refc, name, MethodType.methodType(rtype, ptypes));</span>
 881         } catch (NoSuchMethodException | IllegalAccessException e) {
 882             throw new AssertionError(e);
 883         }
 884     }
 885 



































 886     private StringConcatFactory() {
 887         // no instantiation
 888     }

 889 }
</pre>
</td>
</tr>
</table>
<center><a href="MemoryAccessVarHandleGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/Executable.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
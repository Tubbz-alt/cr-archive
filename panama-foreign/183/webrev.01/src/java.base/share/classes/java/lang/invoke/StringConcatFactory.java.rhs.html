<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import jdk.internal.access.JavaLangAccess;
 29 import jdk.internal.access.SharedSecrets;
<a name="1" id="anc1"></a>





 30 import jdk.internal.vm.annotation.Stable;
 31 import sun.invoke.util.Wrapper;
 32 
 33 import java.lang.invoke.MethodHandles.Lookup;
 34 import java.util.ArrayList;
 35 import java.util.Arrays;
 36 import java.util.List;
 37 import java.util.Objects;
 38 import java.util.concurrent.ConcurrentHashMap;
 39 import java.util.concurrent.ConcurrentMap;
 40 import java.util.function.Function;
 41 
<a name="2" id="anc2"></a>
 42 import static java.lang.invoke.MethodType.methodType;
<a name="3" id="anc3"></a>

 43 
 44 /**
 45  * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
 46  * can be used to efficiently concatenate a known number of arguments of known
 47  * types, possibly after type adaptation and partial evaluation of arguments.
 48  * These methods are typically used as &lt;em&gt;bootstrap methods&lt;/em&gt; for {@code
 49  * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
 50  * feature of the Java Programming Language.
 51  *
 52  * &lt;p&gt;Indirect access to the behavior specified by the provided {@code
 53  * MethodHandle} proceeds in order through two phases:
 54  *
 55  * &lt;ol&gt;
 56  *     &lt;li&gt;&lt;em&gt;Linkage&lt;/em&gt; occurs when the methods in this class are invoked.
 57  * They take as arguments a method type describing the concatenated arguments
 58  * count and types, and optionally the String &lt;em&gt;recipe&lt;/em&gt;, plus the
 59  * constants that participate in the String concatenation. The details on
 60  * accepted recipe shapes are described further below. Linkage may involve
 61  * dynamically loading a new class that implements the expected concatenation
 62  * behavior. The {@code CallSite} holds the {@code MethodHandle} pointing to the
 63  * exact concatenation method. The concatenation methods may be shared among
 64  * different {@code CallSite}s, e.g. if linkage methods produce them as pure
 65  * functions.&lt;/li&gt;
 66  *
 67  * &lt;li&gt;&lt;em&gt;Invocation&lt;/em&gt; occurs when a generated concatenation method is
 68  * invoked with the exact dynamic arguments. This may occur many times for a
 69  * single concatenation method. The method referenced by the behavior {@code
 70  * MethodHandle} is invoked with the static arguments and any additional dynamic
 71  * arguments provided on invocation, as if by {@link MethodHandle#invoke(Object...)}.&lt;/li&gt;
 72  * &lt;/ol&gt;
 73  *
 74  * &lt;p&gt; This class provides two forms of linkage methods: a simple version
 75  * ({@link #makeConcat(java.lang.invoke.MethodHandles.Lookup, String,
 76  * MethodType)}) using only the dynamic arguments, and an advanced version
 77  * ({@link #makeConcatWithConstants(java.lang.invoke.MethodHandles.Lookup,
 78  * String, MethodType, String, Object...)} using the advanced forms of capturing
 79  * the constant arguments. The advanced strategy can produce marginally better
 80  * invocation bytecode, at the expense of exploding the number of shapes of
 81  * string concatenation methods present at runtime, because those shapes would
 82  * include constant static arguments as well.
 83  *
 84  * @author Aleksey Shipilev
 85  * @author Remi Forax
 86  * @author Peter Levart
 87  *
 88  * @apiNote
 89  * &lt;p&gt;There is a JVM limit (classfile structural constraint): no method
 90  * can call with more than 255 slots. This limits the number of static and
 91  * dynamic arguments one can pass to bootstrap method. Since there are potential
 92  * concatenation strategies that use {@code MethodHandle} combinators, we need
 93  * to reserve a few empty slots on the parameter lists to capture the
 94  * temporal results. This is why bootstrap methods in this factory do not accept
 95  * more than 200 argument slots. Users requiring more than 200 argument slots in
 96  * concatenation are expected to split the large concatenation in smaller
 97  * expressions.
 98  *
 99  * @since 9
100  */
101 public final class StringConcatFactory {
102 
103     /**
104      * Tag used to demarcate an ordinary argument.
105      */
106     private static final char TAG_ARG = &#39;\u0001&#39;;
107 
108     /**
109      * Tag used to demarcate a constant.
110      */
111     private static final char TAG_CONST = &#39;\u0002&#39;;
112 
113     /**
114      * Maximum number of argument slots in String Concat call.
115      *
116      * While the maximum number of argument slots that indy call can handle is 253,
117      * we do not use all those slots, to let the strategies with MethodHandle
118      * combinators to use some arguments.
119      */
120     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
121 
<a name="4" id="anc4"></a>







122     private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
123 
<a name="5" id="anc5"></a>































































































124     /**
125      * Parses the recipe string, and produces a traversable collection of
126      * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
127      * strategies. Notably, this class parses out the constants from the recipe
128      * and from other static arguments.
129      */
130     private static final class Recipe {
131         private final List&lt;RecipeElement&gt; elements;
132 
133         public Recipe(String src, Object[] constants) {
134             List&lt;RecipeElement&gt; el = new ArrayList&lt;&gt;();
135 
136             int constC = 0;
137             int argC = 0;
138 
139             StringBuilder acc = new StringBuilder();
140 
141             for (int i = 0; i &lt; src.length(); i++) {
142                 char c = src.charAt(i);
143 
144                 if (c == TAG_CONST || c == TAG_ARG) {
145                     // Detected a special tag, flush all accumulated characters
146                     // as a constant first:
147                     if (acc.length() &gt; 0) {
148                         el.add(new RecipeElement(acc.toString()));
149                         acc.setLength(0);
150                     }
151                     if (c == TAG_CONST) {
152                         Object cnst = constants[constC++];
153                         el.add(new RecipeElement(cnst));
154                     } else if (c == TAG_ARG) {
155                         el.add(new RecipeElement(argC++));
156                     }
157                 } else {
158                     // Not a special character, this is a constant embedded into
159                     // the recipe itself.
160                     acc.append(c);
161                 }
162             }
163 
164             // Flush the remaining characters as constant:
165             if (acc.length() &gt; 0) {
166                 el.add(new RecipeElement(acc.toString()));
167             }
168 
169             elements = el;
170         }
171 
172         public List&lt;RecipeElement&gt; getElements() {
173             return elements;
174         }
175 
176         @Override
177         public boolean equals(Object o) {
178             if (this == o) return true;
179             if (o == null || getClass() != o.getClass()) return false;
180 
181             Recipe recipe = (Recipe) o;
182             return elements.equals(recipe.elements);
183         }
184 
185         @Override
186         public String toString() {
187             return &quot;Recipe{&quot; +
188                     &quot;elements=&quot; + elements +
189                     &#39;}&#39;;
190         }
191 
192         @Override
193         public int hashCode() {
194             return elements.hashCode();
195         }
196     }
197 
198     private static final class RecipeElement {
199         private final String value;
200         private final int argPos;
201         private final char tag;
202 
203         public RecipeElement(Object cnst) {
204             this.value = String.valueOf(Objects.requireNonNull(cnst));
205             this.argPos = -1;
206             this.tag = TAG_CONST;
207         }
208 
209         public RecipeElement(int arg) {
210             this.value = null;
211             this.argPos = arg;
212             this.tag = TAG_ARG;
213         }
214 
215         public String getValue() {
216             assert (tag == TAG_CONST);
217             return value;
218         }
219 
220         public int getArgPos() {
221             assert (tag == TAG_ARG);
222             return argPos;
223         }
224 
225         public char getTag() {
226             return tag;
227         }
228 
229         @Override
230         public boolean equals(Object o) {
231             if (this == o) return true;
232             if (o == null || getClass() != o.getClass()) return false;
233 
234             RecipeElement that = (RecipeElement) o;
235 
236             if (this.tag != that.tag) return false;
237             if (this.tag == TAG_CONST &amp;&amp; (!value.equals(that.value))) return false;
238             if (this.tag == TAG_ARG &amp;&amp; (argPos != that.argPos)) return false;
239             return true;
240         }
241 
242         @Override
243         public String toString() {
244             return &quot;RecipeElement{&quot; +
245                     &quot;value=&#39;&quot; + value + &#39;\&#39;&#39; +
246                     &quot;, argPos=&quot; + argPos +
247                     &quot;, tag=&quot; + tag +
248                     &#39;}&#39;;
249         }
250 
251         @Override
252         public int hashCode() {
253             return (int)tag;
254         }
255     }
256 
257     // StringConcatFactory bootstrap methods are startup sensitive, and may be
258     // special cased in java.lang.invokeBootstrapMethodInvoker to ensure
259     // methods are invoked with exact type information to avoid generating
260     // code for runtime checks. Take care any changes or additions here are
261     // reflected there as appropriate.
262 
263     /**
264      * Facilitates the creation of optimized String concatenation methods, that
265      * can be used to efficiently concatenate a known number of arguments of
266      * known types, possibly after type adaptation and partial evaluation of
267      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
268      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
269      * feature of the Java Programming Language.
270      *
271      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
272      * invoked, it returns the result of String concatenation, taking all
273      * function arguments passed to the linkage method as inputs for
274      * concatenation. The target signature is given by {@code concatType}.
275      * For a target accepting:
276      * &lt;ul&gt;
277      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
278      *     &lt;li&gt;one input, concatenation results in the single
279      *     input converted as per JLS 5.1.11 &quot;String Conversion&quot;; otherwise&lt;/li&gt;
280      *     &lt;li&gt;two or more inputs, the inputs are concatenated as per
281      *     requirements stated in JLS 15.18.1 &quot;String Concatenation Operator +&quot;.
282      *     The inputs are converted as per JLS 5.1.11 &quot;String Conversion&quot;,
283      *     and combined from left to right.&lt;/li&gt;
284      * &lt;/ul&gt;
285      *
286      * &lt;p&gt;Assume the linkage arguments are as follows:
287      *
288      * &lt;ul&gt;
289      *     &lt;li&gt;{@code concatType}, describing the {@code CallSite} signature&lt;/li&gt;
290      * &lt;/ul&gt;
291      *
292      * &lt;p&gt;Then the following linkage invariants must hold:
293      *
294      * &lt;ul&gt;
295      *     &lt;li&gt;The number of parameter slots in {@code concatType} is
296      *         less than or equal to 200&lt;/li&gt;
297      *     &lt;li&gt;The return type in {@code concatType} is assignable from {@link java.lang.String}&lt;/li&gt;
298      * &lt;/ul&gt;
299      *
300      * @param lookup   Represents a lookup context with the accessibility
301      *                 privileges of the caller. Specifically, the lookup
302      *                 context must have
303      *                 {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()
304      *                 full privilege access}.
305      *                 When used with {@code invokedynamic}, this is stacked
306      *                 automatically by the VM.
307      * @param name     The name of the method to implement. This name is
308      *                 arbitrary, and has no meaning for this linkage method.
309      *                 When used with {@code invokedynamic}, this is provided by
310      *                 the {@code NameAndType} of the {@code InvokeDynamic}
311      *                 structure and is stacked automatically by the VM.
312      * @param concatType The expected signature of the {@code CallSite}.  The
313      *                   parameter types represent the types of concatenation
314      *                   arguments; the return type is always assignable from {@link
315      *                   java.lang.String}.  When used with {@code invokedynamic},
316      *                   this is provided by the {@code NameAndType} of the {@code
317      *                   InvokeDynamic} structure and is stacked automatically by
318      *                   the VM.
319      * @return a CallSite whose target can be used to perform String
320      * concatenation, with dynamic concatenation arguments described by the given
321      * {@code concatType}.
322      * @throws StringConcatException If any of the linkage invariants described
323      *                               here are violated, or the lookup context
324      *                               does not have private access privileges.
325      * @throws NullPointerException If any of the incoming arguments is null.
326      *                              This will never happen when a bootstrap method
327      *                              is called with invokedynamic.
328      *
329      * @jls  5.1.11 String Conversion
330      * @jls 15.18.1 String Concatenation Operator +
331      */
332     public static CallSite makeConcat(MethodHandles.Lookup lookup,
333                                       String name,
334                                       MethodType concatType) throws StringConcatException {
<a name="6" id="anc6"></a>



335         return doStringConcat(lookup, name, concatType, true, null);
336     }
337 
338     /**
339      * Facilitates the creation of optimized String concatenation methods, that
340      * can be used to efficiently concatenate a known number of arguments of
341      * known types, possibly after type adaptation and partial evaluation of
342      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
343      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
344      * feature of the Java Programming Language.
345      *
346      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
347      * invoked, it returns the result of String concatenation, taking all
348      * function arguments and constants passed to the linkage method as inputs for
349      * concatenation. The target signature is given by {@code concatType}, and
350      * does not include constants.
351      * For a target accepting:
352      * &lt;ul&gt;
353      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
354      *     &lt;li&gt;one input, concatenation results in the single
355      *     input converted as per JLS 5.1.11 &quot;String Conversion&quot;; otherwise&lt;/li&gt;
356      *     &lt;li&gt;two or more inputs, the inputs are concatenated as per
357      *     requirements stated in JLS 15.18.1 &quot;String Concatenation Operator +&quot;.
358      *     The inputs are converted as per JLS 5.1.11 &quot;String Conversion&quot;,
359      *     and combined from left to right.&lt;/li&gt;
360      * &lt;/ul&gt;
361      *
362      * &lt;p&gt;The concatenation &lt;em&gt;recipe&lt;/em&gt; is a String description for the way to
363      * construct a concatenated String from the arguments and constants. The
364      * recipe is processed from left to right, and each character represents an
365      * input to concatenation. Recipe characters mean:
366      *
367      * &lt;ul&gt;
368      *
369      *   &lt;li&gt;&lt;em&gt;\1 (Unicode point 0001)&lt;/em&gt;: an ordinary argument. This
370      *   input is passed through dynamic argument, and is provided during the
371      *   concatenation method invocation. This input can be null.&lt;/li&gt;
372      *
373      *   &lt;li&gt;&lt;em&gt;\2 (Unicode point 0002):&lt;/em&gt; a constant. This input passed
374      *   through static bootstrap argument. This constant can be any value
375      *   representable in constant pool. If necessary, the factory would call
376      *   {@code toString} to perform a one-time String conversion.&lt;/li&gt;
377      *
378      *   &lt;li&gt;&lt;em&gt;Any other char value:&lt;/em&gt; a single character constant.&lt;/li&gt;
379      * &lt;/ul&gt;
380      *
381      * &lt;p&gt;Assume the linkage arguments are as follows:
382      *
383      * &lt;ul&gt;
384      *   &lt;li&gt;{@code concatType}, describing the {@code CallSite} signature&lt;/li&gt;
385      *   &lt;li&gt;{@code recipe}, describing the String recipe&lt;/li&gt;
386      *   &lt;li&gt;{@code constants}, the vararg array of constants&lt;/li&gt;
387      * &lt;/ul&gt;
388      *
389      * &lt;p&gt;Then the following linkage invariants must hold:
390      *
391      * &lt;ul&gt;
392      *   &lt;li&gt;The number of parameter slots in {@code concatType} is less than
393      *       or equal to 200&lt;/li&gt;
394      *
395      *   &lt;li&gt;The parameter count in {@code concatType} is equal to number of \1 tags
396      *   in {@code recipe}&lt;/li&gt;
397      *
398      *   &lt;li&gt;The return type in {@code concatType} is assignable
399      *   from {@link java.lang.String}, and matches the return type of the
400      *   returned {@link MethodHandle}&lt;/li&gt;
401      *
402      *   &lt;li&gt;The number of elements in {@code constants} is equal to number of \2
403      *   tags in {@code recipe}&lt;/li&gt;
404      * &lt;/ul&gt;
405      *
406      * @param lookup    Represents a lookup context with the accessibility
407      *                  privileges of the caller. Specifically, the lookup
408      *                  context must have
409      *                  {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()
410      *                  full privilege access}.
411      *                  When used with {@code invokedynamic}, this is stacked
412      *                  automatically by the VM.
413      * @param name      The name of the method to implement. This name is
414      *                  arbitrary, and has no meaning for this linkage method.
415      *                  When used with {@code invokedynamic}, this is provided
416      *                  by the {@code NameAndType} of the {@code InvokeDynamic}
417      *                  structure and is stacked automatically by the VM.
418      * @param concatType The expected signature of the {@code CallSite}.  The
419      *                  parameter types represent the types of dynamic concatenation
420      *                  arguments; the return type is always assignable from {@link
421      *                  java.lang.String}.  When used with {@code
422      *                  invokedynamic}, this is provided by the {@code
423      *                  NameAndType} of the {@code InvokeDynamic} structure and
424      *                  is stacked automatically by the VM.
425      * @param recipe    Concatenation recipe, described above.
426      * @param constants A vararg parameter representing the constants passed to
427      *                  the linkage method.
428      * @return a CallSite whose target can be used to perform String
429      * concatenation, with dynamic concatenation arguments described by the given
430      * {@code concatType}.
431      * @throws StringConcatException If any of the linkage invariants described
432      *                               here are violated, or the lookup context
433      *                               does not have private access privileges.
434      * @throws NullPointerException If any of the incoming arguments is null, or
435      *                              any constant in {@code recipe} is null.
436      *                              This will never happen when a bootstrap method
437      *                              is called with invokedynamic.
438      * @apiNote Code generators have three distinct ways to process a constant
439      * string operand S in a string concatenation expression.  First, S can be
440      * materialized as a reference (using ldc) and passed as an ordinary argument
441      * (recipe &#39;\1&#39;). Or, S can be stored in the constant pool and passed as a
442      * constant (recipe &#39;\2&#39;) . Finally, if S contains neither of the recipe
443      * tag characters (&#39;\1&#39;, &#39;\2&#39;) then S can be interpolated into the recipe
444      * itself, causing its characters to be inserted into the result.
445      *
446      * @jls  5.1.11 String Conversion
447      * @jls 15.18.1 String Concatenation Operator +
448      */
449     public static CallSite makeConcatWithConstants(MethodHandles.Lookup lookup,
450                                                    String name,
451                                                    MethodType concatType,
452                                                    String recipe,
453                                                    Object... constants) throws StringConcatException {
<a name="7" id="anc7"></a>



454         return doStringConcat(lookup, name, concatType, false, recipe, constants);
455     }
456 
457     private static CallSite doStringConcat(MethodHandles.Lookup lookup,
458                                            String name,
459                                            MethodType concatType,
460                                            boolean generateRecipe,
461                                            String recipe,
462                                            Object... constants) throws StringConcatException {
463         Objects.requireNonNull(lookup, &quot;Lookup is null&quot;);
464         Objects.requireNonNull(name, &quot;Name is null&quot;);
465         Objects.requireNonNull(concatType, &quot;Concat type is null&quot;);
466         Objects.requireNonNull(constants, &quot;Constants are null&quot;);
467 
468         for (Object o : constants) {
469             Objects.requireNonNull(o, &quot;Cannot accept null constants&quot;);
470         }
471 
472         if ((lookup.lookupModes() &amp; MethodHandles.Lookup.PRIVATE) == 0) {
473             throw new StringConcatException(&quot;Invalid caller: &quot; +
474                     lookup.lookupClass().getName());
475         }
476 
477         int cCount = 0;
478         int oCount = 0;
479         if (generateRecipe) {
480             // Mock the recipe to reuse the concat generator code
481             char[] value = new char[concatType.parameterCount()];
482             Arrays.fill(value, TAG_ARG);
483             recipe = new String(value);
484             oCount = concatType.parameterCount();
485         } else {
486             Objects.requireNonNull(recipe, &quot;Recipe is null&quot;);
487 
488             for (int i = 0; i &lt; recipe.length(); i++) {
489                 char c = recipe.charAt(i);
490                 if (c == TAG_CONST) cCount++;
491                 if (c == TAG_ARG)   oCount++;
492             }
493         }
494 
495         if (oCount != concatType.parameterCount()) {
496             throw new StringConcatException(
497                     &quot;Mismatched number of concat arguments: recipe wants &quot; +
498                             oCount +
499                             &quot; arguments, but signature provides &quot; +
500                             concatType.parameterCount());
501         }
502 
503         if (cCount != constants.length) {
504             throw new StringConcatException(
505                     &quot;Mismatched number of concat constants: recipe wants &quot; +
506                             cCount +
507                             &quot; constants, but only &quot; +
508                             constants.length +
509                             &quot; are passed&quot;);
510         }
511 
512         if (!concatType.returnType().isAssignableFrom(String.class)) {
513             throw new StringConcatException(
514                     &quot;The return type should be compatible with String, but it is &quot; +
515                             concatType.returnType());
516         }
517 
518         if (concatType.parameterSlotCount() &gt; MAX_INDY_CONCAT_ARG_SLOTS) {
519             throw new StringConcatException(&quot;Too many concat argument slots: &quot; +
520                     concatType.parameterSlotCount() +
521                     &quot;, can only accept &quot; +
522                     MAX_INDY_CONCAT_ARG_SLOTS);
523         }
524 
<a name="8" id="anc8"></a>
525         Recipe rec = new Recipe(recipe, constants);
<a name="9" id="anc9"></a><span class="line-modified">526         MethodHandle mh = generate(lookup, concatType, rec);</span>
527         return new ConstantCallSite(mh.asType(concatType));
528     }
529 
<a name="10" id="anc10"></a>



























530     private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {
531         try {
<a name="11" id="anc11"></a><span class="line-modified">532             return generateMHInlineCopy(mt, recipe);</span>


















533         } catch (Error | StringConcatException e) {
534             // Pass through any error or existing StringConcatException
535             throw e;
536         } catch (Throwable t) {
537             throw new StringConcatException(&quot;Generator failed&quot;, t);
538         }
539     }
540 
<a name="12" id="anc12"></a>




















541 
542     /**
<a name="13" id="anc13"></a><span class="line-modified">543      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the</span>
<span class="line-modified">544      * byte[] array on its own and passes that byte[] array to String</span>
<span class="line-modified">545      * constructor. This strategy requires access to some private APIs in JDK,</span>
<span class="line-modified">546      * most notably, the private String constructor that accepts byte[] arrays</span>
<span class="line-modified">547      * without copying.</span>
































548      */
<a name="14" id="anc14"></a><span class="line-modified">549     private static MethodHandle generateMHInlineCopy(MethodType mt, Recipe recipe) throws Throwable {</span>






































































































































































































550 
<a name="15" id="anc15"></a><span class="line-modified">551         // Fast-path two-argument Object + Object concatenations</span>
<span class="line-modified">552         if (recipe.getElements().size() == 2) {</span>
<span class="line-modified">553             // Two object arguments</span>
<span class="line-modified">554             if (mt.parameterCount() == 2 &amp;&amp;</span>
<span class="line-modified">555                     !mt.parameterType(0).isPrimitive() &amp;&amp;</span>
<span class="line-modified">556                     !mt.parameterType(1).isPrimitive() &amp;&amp;</span>
<span class="line-modified">557                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;</span>
<span class="line-modified">558                     recipe.getElements().get(1).getTag() == TAG_ARG) {</span>







































































































































































































































559 
<a name="16" id="anc16"></a><span class="line-modified">560                 return simpleConcat();</span>













561 
<a name="17" id="anc17"></a><span class="line-modified">562             } else if (mt.parameterCount() == 1 &amp;&amp;</span>
<span class="line-modified">563                     !mt.parameterType(0).isPrimitive()) {</span>
<span class="line-modified">564                 // One Object argument, one constant</span>
<span class="line-modified">565                 MethodHandle mh = simpleConcat();</span>


































566 
<a name="18" id="anc18"></a><span class="line-modified">567                 if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-modified">568                         recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="line-modified">569                     // First recipe element is a constant</span>
<span class="line-modified">570                     return MethodHandles.insertArguments(mh, 0,</span>
<span class="line-modified">571                             recipe.getElements().get(0).getValue());</span>























572 
<a name="19" id="anc19"></a><span class="line-modified">573                 } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-modified">574                         recipe.getElements().get(0).getTag() == TAG_ARG) {</span>
<span class="line-modified">575                     // Second recipe element is a constant</span>
<span class="line-modified">576                     return MethodHandles.insertArguments(mh, 1,</span>
<span class="line-modified">577                             recipe.getElements().get(1).getValue());</span>





















578 
<a name="20" id="anc20"></a>

























579                 }
<a name="21" id="anc21"></a>



























580             }
<a name="22" id="anc22"></a><span class="line-modified">581             // else... fall-through to slow-path</span>





582         }
583 
<a name="23" id="anc23"></a><span class="line-modified">584         // Create filters and obtain filtered parameter types. Filters would be used in the beginning</span>
<span class="line-modified">585         // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).</span>
<span class="line-modified">586         // The filtered argument type list is used all over in the combinators below.</span>
<span class="line-modified">587         Class&lt;?&gt;[] ptypes = mt.parameterArray();</span>
<span class="line-modified">588         MethodHandle[] filters = null;</span>
<span class="line-modified">589         for (int i = 0; i &lt; ptypes.length; i++) {</span>
<span class="line-modified">590             MethodHandle filter = stringifierFor(ptypes[i]);</span>
<span class="line-modified">591             if (filter != null) {</span>
<span class="line-modified">592                 if (filters == null) {</span>
<span class="line-modified">593                     filters = new MethodHandle[ptypes.length];</span>






























































594                 }
<a name="24" id="anc24"></a><span class="line-modified">595                 filters[i] = filter;</span>
<span class="line-modified">596                 ptypes[i] = filter.type().returnType();</span>














597             }
598         }
599 
<a name="25" id="anc25"></a><span class="line-modified">600         // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;</span>
<span class="line-modified">601         // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are</span>
<span class="line-added">602         // assembled bottom-up, which makes the code arguably hard to read.</span>
603 
<a name="26" id="anc26"></a><span class="line-modified">604         // Drop all remaining parameter types, leave only helper arguments:</span>
<span class="line-modified">605         MethodHandle mh;</span>



























606 
<a name="27" id="anc27"></a><span class="line-modified">607         mh = MethodHandles.dropArguments(newString(), 2, ptypes);</span>
608 
<a name="28" id="anc28"></a><span class="line-modified">609         long initialLengthCoder = INITIAL_CODER;</span>



610 
<a name="29" id="anc29"></a><span class="line-modified">611         // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already</span>
<span class="line-modified">612         // known from the combinators below. We are assembling the string backwards, so the index coded</span>
<span class="line-modified">613         // into indexCoder is the *ending* index.</span>


614 
<a name="30" id="anc30"></a><span class="line-modified">615         // We need one prepender per argument, but also need to fold in constants. We do so by greedily</span>
<span class="line-modified">616         // create prependers that fold in surrounding constants into the argument prepender. This reduces</span>
<span class="line-modified">617         // the number of unique MH combinator tree shapes we&#39;ll create in an application.</span>
<span class="line-modified">618         String prefixConstant = null, suffixConstant = null;</span>
<span class="line-modified">619         int pos = -1;</span>
<span class="line-added">620         for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-added">621             // Do the prepend, and put &quot;new&quot; index at index 1</span>
<span class="line-added">622             switch (el.getTag()) {</span>
<span class="line-added">623                 case TAG_CONST: {</span>
<span class="line-added">624                     String constantValue = el.getValue();</span>
625 
<a name="31" id="anc31"></a><span class="line-modified">626                     // Eagerly update the initialLengthCoder value</span>
<span class="line-modified">627                     initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, constantValue);</span>


628 
<a name="32" id="anc32"></a><span class="line-modified">629                     if (pos &lt; 0) {</span>
<span class="line-modified">630                         // Collecting into prefixConstant</span>
<span class="line-modified">631                         prefixConstant = prefixConstant == null ? constantValue : prefixConstant + constantValue;</span>
<span class="line-modified">632                     } else {</span>
<span class="line-modified">633                         // Collecting into suffixConstant</span>
<span class="line-modified">634                         suffixConstant = suffixConstant == null ? constantValue : suffixConstant + constantValue;</span>




635                     }
<a name="33" id="anc33"></a><span class="line-modified">636                     break;</span>

637                 }
<a name="34" id="anc34"></a><span class="line-modified">638                 case TAG_ARG: {</span>








































639 
<a name="35" id="anc35"></a><span class="line-modified">640                     if (pos &gt;= 0) {</span>
<span class="line-modified">641                         // Flush the previous non-constant arg with any prefix/suffix constant</span>
<span class="line-modified">642                         mh = MethodHandles.filterArgumentsWithCombiner(</span>
643                                 mh, 1,
644                                 prepender(prefixConstant, ptypes[pos], suffixConstant),
645                                 1, 0, // indexCoder, storage
646                                 2 + pos  // selected argument
<a name="36" id="anc36"></a><span class="line-modified">647                         );</span>
<span class="line-modified">648                         prefixConstant = suffixConstant = null;</span>




649                     }
<a name="37" id="anc37"></a><span class="line-modified">650                     // Mark the pos of next non-constant arg</span>
<span class="line-modified">651                     pos = el.getArgPos();</span>
<span class="line-added">652                     break;</span>
653                 }
<a name="38" id="anc38"></a><span class="line-added">654                 default:</span>
<span class="line-added">655                     throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
656             }
<a name="39" id="anc39"></a><span class="line-added">657         }</span>
658 
<a name="40" id="anc40"></a><span class="line-modified">659         // Insert any trailing args, constants</span>
<span class="line-modified">660         if (pos &gt;= 0) {</span>
<span class="line-modified">661             mh = MethodHandles.filterArgumentsWithCombiner(</span>
662                     mh, 1,
663                     prepender(prefixConstant, ptypes[pos], suffixConstant),
664                     1, 0, // indexCoder, storage
665                     2 + pos  // selected argument
<a name="41" id="anc41"></a><span class="line-modified">666             );</span>
<span class="line-modified">667         } else if (prefixConstant != null) {</span>
<span class="line-modified">668             assert (suffixConstant == null);</span>
<span class="line-modified">669             // Sole prefixConstant can only happen if there were no non-constant arguments</span>
<span class="line-modified">670             mh = MethodHandles.filterArgumentsWithCombiner(</span>
671                     mh, 1,
672                     MethodHandles.insertArguments(prepender(null, String.class, null), 2, prefixConstant),
673                     1, 0 // indexCoder, storage
<a name="42" id="anc42"></a>





674             );
<a name="43" id="anc43"></a><span class="line-added">675         }</span>
676 
<a name="44" id="anc44"></a><span class="line-modified">677         // Fold in byte[] instantiation at argument 0</span>
<span class="line-modified">678         mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArray(),</span>
<span class="line-modified">679                 1 // index</span>
<span class="line-modified">680         );</span>
<span class="line-modified">681 </span>
<span class="line-modified">682         // Start combining length and coder mixers.</span>
<span class="line-modified">683         //</span>
<span class="line-modified">684         // Length is easy: constant lengths can be computed on the spot, and all non-constant</span>
<span class="line-modified">685         // shapes have been either converted to Strings, or explicit methods for getting the</span>
<span class="line-modified">686         // string length out of primitives are provided.</span>
<span class="line-modified">687         //</span>
<span class="line-modified">688         // Coders are more interesting. Only Object, String and char arguments (and constants)</span>
<span class="line-modified">689         // can have non-Latin1 encoding. It is easier to blindly convert constants to String,</span>
<span class="line-modified">690         // and deduce the coder from there. Arguments would be either converted to Strings</span>
<span class="line-modified">691         // during the initial filtering, or handled by specializations in MIXERS.</span>
<span class="line-modified">692         //</span>
<span class="line-modified">693         // The method handle shape before all mixers are combined in is:</span>
<span class="line-modified">694         //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)</span>
<span class="line-modified">695         //</span>
<span class="line-modified">696         // We will bind the initialLengthCoder value to the last mixer (the one that will be</span>
<span class="line-modified">697         // executed first), then fold that in. This leaves the shape after all mixers are</span>
<span class="line-modified">698         // combined in as:</span>
<span class="line-modified">699         //   (&lt;args&gt;)String = (&lt;args&gt;)</span>
<span class="line-modified">700 </span>
<span class="line-modified">701         int ac = -1;</span>
<span class="line-modified">702         MethodHandle mix = null;</span>
<span class="line-modified">703         for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-modified">704             switch (el.getTag()) {</span>
<span class="line-modified">705                 case TAG_CONST:</span>
<span class="line-modified">706                     // Constants already handled in the code above</span>
<span class="line-modified">707                     break;</span>
<span class="line-modified">708                 case TAG_ARG:</span>
<span class="line-modified">709                     if (ac &gt;= 0) {</span>
<span class="line-modified">710                         // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.</span>
<span class="line-modified">711                         mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-modified">712                                 0, // old-index</span>
<span class="line-modified">713                                 1 + ac // selected argument</span>
<span class="line-modified">714                         );</span>
<span class="line-modified">715                     }</span>





716 
<a name="45" id="anc45"></a><span class="line-modified">717                     ac = el.getArgPos();</span>
<span class="line-modified">718                     Class&lt;?&gt; argClass = ptypes[ac];</span>
<span class="line-modified">719                     mix = mixer(argClass);</span>
<span class="line-modified">720 </span>
<span class="line-modified">721                     break;</span>
<span class="line-modified">722                 default:</span>
<span class="line-modified">723                     throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>



724             }
<a name="46" id="anc46"></a><span class="line-added">725         }</span>
726 
<a name="47" id="anc47"></a><span class="line-modified">727         // Insert the initialLengthCoder value into the final mixer, then</span>
<span class="line-added">728         // fold that into the base method handle</span>
<span class="line-added">729         if (ac &gt;= 0) {</span>
<span class="line-added">730             mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);</span>
<span class="line-added">731             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-added">732                     1 + ac // selected argument</span>
<span class="line-added">733             );</span>
<span class="line-added">734         } else {</span>
<span class="line-added">735             // No mixer (constants only concat), insert initialLengthCoder directly</span>
<span class="line-added">736             mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);</span>
<span class="line-added">737         }</span>
738 
<a name="48" id="anc48"></a><span class="line-modified">739         // The method handle shape here is (&lt;args&gt;).</span>



740 
<a name="49" id="anc49"></a><span class="line-modified">741         // Apply filters, converting the arguments:</span>
<span class="line-added">742         if (filters != null) {</span>
<span class="line-added">743             mh = MethodHandles.filterArguments(mh, 0, filters);</span>
744         }
745 
<a name="50" id="anc50"></a><span class="line-modified">746         return mh;</span>
<span class="line-modified">747     }</span>
<span class="line-modified">748 </span>
<span class="line-modified">749     private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {</span>
<span class="line-added">750         if (prefix == null &amp;&amp; suffix == null) {</span>
<span class="line-added">751             return NULL_PREPENDERS.computeIfAbsent(cl, NULL_PREPEND);</span>
752         }
<a name="51" id="anc51"></a><span class="line-added">753         return MethodHandles.insertArguments(</span>
<span class="line-added">754                         PREPENDERS.computeIfAbsent(cl, PREPEND), 3, prefix, suffix);</span>
<span class="line-added">755     }</span>
756 
<a name="52" id="anc52"></a><span class="line-modified">757     private static MethodHandle mixer(Class&lt;?&gt; cl) {</span>
<span class="line-modified">758         return MIXERS.computeIfAbsent(cl, MIX);</span>
<span class="line-added">759     }</span>
<span class="line-added">760 </span>
<span class="line-added">761     // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-added">762     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {</span>
<span class="line-added">763         @Override</span>
<span class="line-added">764         public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-added">765             return JLA.stringConcatHelper(&quot;prepend&quot;,</span>
<span class="line-added">766                     methodType(long.class, long.class, byte[].class,</span>
<span class="line-added">767                             Wrapper.asPrimitiveType(c), String.class, String.class));</span>
768         }
<a name="53" id="anc53"></a><span class="line-added">769     };</span>
770 
<a name="54" id="anc54"></a><span class="line-modified">771     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; NULL_PREPEND = new Function&lt;&gt;() {</span>
<span class="line-modified">772         @Override</span>
<span class="line-modified">773         public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-modified">774             return MethodHandles.insertArguments(</span>
<span class="line-modified">775                             PREPENDERS.computeIfAbsent(c, PREPEND), 3, (String)null, (String)null);</span>
<span class="line-modified">776         }</span>
<span class="line-modified">777     };</span>


778 
<a name="55" id="anc55"></a><span class="line-modified">779     // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-modified">780     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {</span>
<span class="line-modified">781         @Override</span>
<span class="line-modified">782         public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-modified">783             return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));</span>
<span class="line-modified">784         }</span>
<span class="line-modified">785     };</span>
786 
<a name="56" id="anc56"></a><span class="line-modified">787     private @Stable static MethodHandle SIMPLE_CONCAT;</span>
<span class="line-modified">788     private static MethodHandle simpleConcat() {</span>
<span class="line-modified">789         if (SIMPLE_CONCAT == null) {</span>
<span class="line-modified">790             SIMPLE_CONCAT = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));</span>


791         }
<a name="57" id="anc57"></a><span class="line-added">792         return SIMPLE_CONCAT;</span>
<span class="line-added">793     }</span>
794 
<a name="58" id="anc58"></a><span class="line-modified">795     private @Stable static MethodHandle NEW_STRING;</span>
<span class="line-modified">796     private static MethodHandle newString() {</span>
<span class="line-modified">797         MethodHandle mh = NEW_STRING;</span>
<span class="line-modified">798         if (mh == null) {</span>
<span class="line-modified">799             NEW_STRING = mh =</span>
800                     JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));
<a name="59" id="anc59"></a>

801         }
<a name="60" id="anc60"></a><span class="line-modified">802         return mh;</span>
<span class="line-modified">803     }</span>
<span class="line-modified">804     private @Stable static MethodHandle NEW_ARRAY;</span>
<span class="line-modified">805     private static MethodHandle newArray() {</span>
<span class="line-modified">806         MethodHandle mh = NEW_ARRAY;</span>
<span class="line-added">807         if (mh == null) {</span>
<span class="line-added">808             NEW_ARRAY = mh =</span>
809                     JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));
<a name="61" id="anc61"></a>











810         }
<a name="62" id="anc62"></a><span class="line-added">811         return mh;</span>
812     }
813 
814     /**
<a name="63" id="anc63"></a><span class="line-modified">815      * Public gateways to public &quot;stringify&quot; methods. These methods have the</span>
<span class="line-modified">816      * form String apply(T obj), and normally delegate to {@code String.valueOf},</span>
<span class="line-added">817      * depending on argument&#39;s type.</span>
818      */
<a name="64" id="anc64"></a><span class="line-modified">819     private @Stable static MethodHandle OBJECT_STRINGIFIER;</span>
<span class="line-modified">820     private static MethodHandle objectStringifier() {</span>
<span class="line-modified">821         MethodHandle mh = OBJECT_STRINGIFIER;</span>
<span class="line-modified">822         if (mh == null) {</span>
<span class="line-modified">823             OBJECT_STRINGIFIER = mh =</span>
<span class="line-modified">824                     JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));</span>
<span class="line-modified">825         }</span>
<span class="line-modified">826         return mh;</span>
<span class="line-modified">827     }</span>
<span class="line-modified">828     private @Stable static MethodHandle FLOAT_STRINGIFIER;</span>
<span class="line-added">829     private static MethodHandle floatStringifier() {</span>
<span class="line-added">830         MethodHandle mh = FLOAT_STRINGIFIER;</span>
<span class="line-added">831         if (mh == null) {</span>
<span class="line-added">832             FLOAT_STRINGIFIER = mh =</span>
833                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
<a name="65" id="anc65"></a>













































834         }
<a name="66" id="anc66"></a><span class="line-modified">835         return mh;</span>
<span class="line-modified">836     }</span>
<span class="line-modified">837     private @Stable static MethodHandle DOUBLE_STRINGIFIER;</span>
<span class="line-modified">838     private static MethodHandle doubleStringifier() {</span>
<span class="line-modified">839         MethodHandle mh = DOUBLE_STRINGIFIER;</span>
<span class="line-modified">840         if (mh == null) {</span>
<span class="line-modified">841             DOUBLE_STRINGIFIER = mh =</span>
<span class="line-modified">842                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);</span>

843         }
<a name="67" id="anc67"></a><span class="line-added">844         return mh;</span>
845     }
846 
<a name="68" id="anc68"></a><span class="line-modified">847     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;</span>
<span class="line-added">848     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; NULL_PREPENDERS;</span>
<span class="line-added">849     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;</span>
<span class="line-added">850     private static final long INITIAL_CODER;</span>
851 
<a name="69" id="anc69"></a><span class="line-modified">852     static {</span>
<span class="line-modified">853         INITIAL_CODER = JLA.stringConcatInitialCoder();</span>
<span class="line-modified">854         PREPENDERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-modified">855         NULL_PREPENDERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-modified">856         MIXERS = new ConcurrentHashMap&lt;&gt;();</span>

857     }
858 
<a name="70" id="anc70"></a><span class="line-modified">859     /**</span>
<span class="line-modified">860      * Returns a stringifier for references and floats/doubles only.</span>
<span class="line-modified">861      * Always returns null for other primitives.</span>
<span class="line-modified">862      *</span>
<span class="line-modified">863      * @param t class to stringify</span>
<span class="line-modified">864      * @return stringifier; null, if not available</span>
<span class="line-added">865      */</span>
<span class="line-added">866     private static MethodHandle stringifierFor(Class&lt;?&gt; t) {</span>
<span class="line-added">867         if (!t.isPrimitive()) {</span>
<span class="line-added">868             return objectStringifier();</span>
<span class="line-added">869         } else if (t == float.class) {</span>
<span class="line-added">870             return floatStringifier();</span>
<span class="line-added">871         } else if (t == double.class) {</span>
<span class="line-added">872             return doubleStringifier();</span>
<span class="line-added">873         }</span>
<span class="line-added">874         return null;</span>
875     }
876 
<a name="71" id="anc71"></a><span class="line-modified">877     private static MethodHandle lookupStatic(Lookup lookup, Class&lt;?&gt; refc, String name,</span>
<span class="line-added">878                                      Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {</span>
879         try {
<a name="72" id="anc72"></a><span class="line-modified">880             return lookup.findStatic(refc, name, MethodType.methodType(rtype, ptypes));</span>
881         } catch (NoSuchMethodException | IllegalAccessException e) {
882             throw new AssertionError(e);
883         }
884     }
885 
<a name="73" id="anc73"></a>


































886     private StringConcatFactory() {
887         // no instantiation
888     }
<a name="74" id="anc74"></a>
889 }
<a name="75" id="anc75"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="75" type="hidden" />
</body>
</html>
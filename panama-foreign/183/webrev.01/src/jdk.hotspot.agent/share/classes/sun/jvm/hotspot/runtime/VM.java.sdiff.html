<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/VM.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../oops/InstanceKlass.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/VM.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  59     registers an Observer with the VM class via
  60     VM.registerVMInitializedObserver(). This Observer is guaranteed to
  61     be notified whenever the VM is initialized (or re-initialized). To
  62     implement the first-time initialization, the observer is also
  63     notified when it registers itself with the VM. (For bootstrapping
  64     reasons, this implies that the constructor of VM can not
  65     instantiate any such objects, since VM.soleInstance will not have
  66     been set yet. This is a bootstrapping issue which may have to be
  67     revisited later.) &lt;/P&gt;
  68 */
  69 
  70 public class VM {
  71   private static VM    soleInstance;
  72   private static List&lt;Observer&gt; vmInitializedObservers = new ArrayList&lt;&gt;();
  73   private List&lt;Observer&gt; vmResumedObservers   = new ArrayList&lt;&gt;();
  74   private List&lt;Observer&gt; vmSuspendedObservers = new ArrayList&lt;&gt;();
  75   private TypeDataBase db;
  76   private boolean      isBigEndian;
  77   /** This is only present if in a debugging system */
  78   private JVMDebugger  debugger;
<span class="line-removed">  79   private long         stackBias;</span>
  80   private long         logAddressSize;
  81   private Universe     universe;
  82   private ObjectHeap   heap;
  83   private SystemDictionary dict;
  84   private ClassLoaderDataGraph cldGraph;
  85   private Threads      threads;
  86   private ObjectSynchronizer synchronizer;
  87   private JNIHandles   handles;
  88   private Interpreter  interpreter;
  89   private StubRoutines stubRoutines;
  90   private FileMapInfo  fileMapInfo;
  91   private Bytes        bytes;
  92 
  93   /** Flag indicating if JVMTI support is included in the build */
  94   private boolean      isJvmtiSupported;
  95   /** Flags indicating whether we are attached to a core, C1, or C2 build */
  96   private boolean      usingClientCompiler;
  97   private boolean      usingServerCompiler;
  98   /** alignment constants */
  99   private boolean      isLP64;
</pre>
<hr />
<pre>
 426     }
 427 
 428     // read VM version info
 429     try {
 430        Type vmVersion = db.lookupType(&quot;Abstract_VM_Version&quot;);
 431        Address releaseAddr = vmVersion.getAddressField(&quot;_s_vm_release&quot;).getValue();
 432        vmRelease = CStringUtilities.getString(releaseAddr);
 433        Address vmInternalInfoAddr = vmVersion.getAddressField(&quot;_s_internal_vm_info_string&quot;).getValue();
 434        vmInternalInfo = CStringUtilities.getString(vmInternalInfoAddr);
 435 
 436        Type threadLocalAllocBuffer = db.lookupType(&quot;ThreadLocalAllocBuffer&quot;);
 437        CIntegerType intType = (CIntegerType) db.lookupType(&quot;int&quot;);
 438        CIntegerField reserveForAllocationPrefetchField = threadLocalAllocBuffer.getCIntegerField(&quot;_reserve_for_allocation_prefetch&quot;);
 439        reserveForAllocationPrefetch = (int)reserveForAllocationPrefetchField.getCInteger(intType);
 440     } catch (Exception exp) {
 441        throw new RuntimeException(&quot;can&#39;t determine target&#39;s VM version : &quot; + exp.getMessage());
 442     }
 443 
 444     checkVMVersion(vmRelease);
 445 
<span class="line-removed"> 446     stackBias    = db.lookupIntConstant(&quot;STACK_BIAS&quot;).intValue();</span>
 447     invocationEntryBCI = db.lookupIntConstant(&quot;InvocationEntryBci&quot;).intValue();
 448 
 449     // We infer the presence of JVMTI from the presence of the InstanceKlass::_breakpoints field.
 450     {
 451       Type type = db.lookupType(&quot;InstanceKlass&quot;);
 452       if (type.getField(&quot;_breakpoints&quot;, false, false) == null) {
 453         isJvmtiSupported = false;
 454       } else {
 455         isJvmtiSupported = true;
 456       }
 457     }
 458 
 459     // We infer the presence of C1 or C2 from a couple of fields we
 460     // already have present in the type database
 461     {
 462       Type type = db.lookupType(&quot;Method&quot;);
 463       if (type.getField(&quot;_from_compiled_entry&quot;, false, false) == null) {
 464         // Neither C1 nor C2 is present
 465         usingClientCompiler = false;
 466         usingServerCompiler = false;
</pre>
<hr />
<pre>
 655   static public long getAddressValue(Address addr) {
 656     return VM.getVM().getDebugger().getAddressValue(addr);
 657   }
 658 
 659   public long getAddressSize() {
 660     return db.getAddressSize();
 661   }
 662 
 663   public long getOopSize() {
 664     return oopSize;
 665   }
 666 
 667   public long getLogAddressSize() {
 668     return logAddressSize;
 669   }
 670 
 671   public long getIntSize() {
 672     return db.getJIntType().getSize();
 673   }
 674 
<span class="line-removed"> 675   /** NOTE: this offset is in BYTES in this system! */</span>
<span class="line-removed"> 676   public long getStackBias() {</span>
<span class="line-removed"> 677     return stackBias;</span>
<span class="line-removed"> 678   }</span>
<span class="line-removed"> 679 </span>
 680   /** Indicates whether the underlying machine supports the LP64 data
 681       model. This is needed for conditionalizing code in a few places */
 682   public boolean isLP64() {
 683     if (Assert.ASSERTS_ENABLED) {
 684       Assert.that(isDebugging(), &quot;Debugging system only for now&quot;);
 685     }
 686     return isLP64;
 687   }
 688 
 689   /** Get bytes-per-long == long/double natural alignment. */
 690   public int getBytesPerLong() {
 691     return bytesPerLong;
 692   }
 693 
 694   public int getBytesPerWord() {
 695     return bytesPerWord;
 696   }
 697 
 698   /** Get minimum object alignment in bytes. */
 699   public int getMinObjAlignmentInBytes() {
</pre>
</td>
<td>
<hr />
<pre>
  59     registers an Observer with the VM class via
  60     VM.registerVMInitializedObserver(). This Observer is guaranteed to
  61     be notified whenever the VM is initialized (or re-initialized). To
  62     implement the first-time initialization, the observer is also
  63     notified when it registers itself with the VM. (For bootstrapping
  64     reasons, this implies that the constructor of VM can not
  65     instantiate any such objects, since VM.soleInstance will not have
  66     been set yet. This is a bootstrapping issue which may have to be
  67     revisited later.) &lt;/P&gt;
  68 */
  69 
  70 public class VM {
  71   private static VM    soleInstance;
  72   private static List&lt;Observer&gt; vmInitializedObservers = new ArrayList&lt;&gt;();
  73   private List&lt;Observer&gt; vmResumedObservers   = new ArrayList&lt;&gt;();
  74   private List&lt;Observer&gt; vmSuspendedObservers = new ArrayList&lt;&gt;();
  75   private TypeDataBase db;
  76   private boolean      isBigEndian;
  77   /** This is only present if in a debugging system */
  78   private JVMDebugger  debugger;

  79   private long         logAddressSize;
  80   private Universe     universe;
  81   private ObjectHeap   heap;
  82   private SystemDictionary dict;
  83   private ClassLoaderDataGraph cldGraph;
  84   private Threads      threads;
  85   private ObjectSynchronizer synchronizer;
  86   private JNIHandles   handles;
  87   private Interpreter  interpreter;
  88   private StubRoutines stubRoutines;
  89   private FileMapInfo  fileMapInfo;
  90   private Bytes        bytes;
  91 
  92   /** Flag indicating if JVMTI support is included in the build */
  93   private boolean      isJvmtiSupported;
  94   /** Flags indicating whether we are attached to a core, C1, or C2 build */
  95   private boolean      usingClientCompiler;
  96   private boolean      usingServerCompiler;
  97   /** alignment constants */
  98   private boolean      isLP64;
</pre>
<hr />
<pre>
 425     }
 426 
 427     // read VM version info
 428     try {
 429        Type vmVersion = db.lookupType(&quot;Abstract_VM_Version&quot;);
 430        Address releaseAddr = vmVersion.getAddressField(&quot;_s_vm_release&quot;).getValue();
 431        vmRelease = CStringUtilities.getString(releaseAddr);
 432        Address vmInternalInfoAddr = vmVersion.getAddressField(&quot;_s_internal_vm_info_string&quot;).getValue();
 433        vmInternalInfo = CStringUtilities.getString(vmInternalInfoAddr);
 434 
 435        Type threadLocalAllocBuffer = db.lookupType(&quot;ThreadLocalAllocBuffer&quot;);
 436        CIntegerType intType = (CIntegerType) db.lookupType(&quot;int&quot;);
 437        CIntegerField reserveForAllocationPrefetchField = threadLocalAllocBuffer.getCIntegerField(&quot;_reserve_for_allocation_prefetch&quot;);
 438        reserveForAllocationPrefetch = (int)reserveForAllocationPrefetchField.getCInteger(intType);
 439     } catch (Exception exp) {
 440        throw new RuntimeException(&quot;can&#39;t determine target&#39;s VM version : &quot; + exp.getMessage());
 441     }
 442 
 443     checkVMVersion(vmRelease);
 444 

 445     invocationEntryBCI = db.lookupIntConstant(&quot;InvocationEntryBci&quot;).intValue();
 446 
 447     // We infer the presence of JVMTI from the presence of the InstanceKlass::_breakpoints field.
 448     {
 449       Type type = db.lookupType(&quot;InstanceKlass&quot;);
 450       if (type.getField(&quot;_breakpoints&quot;, false, false) == null) {
 451         isJvmtiSupported = false;
 452       } else {
 453         isJvmtiSupported = true;
 454       }
 455     }
 456 
 457     // We infer the presence of C1 or C2 from a couple of fields we
 458     // already have present in the type database
 459     {
 460       Type type = db.lookupType(&quot;Method&quot;);
 461       if (type.getField(&quot;_from_compiled_entry&quot;, false, false) == null) {
 462         // Neither C1 nor C2 is present
 463         usingClientCompiler = false;
 464         usingServerCompiler = false;
</pre>
<hr />
<pre>
 653   static public long getAddressValue(Address addr) {
 654     return VM.getVM().getDebugger().getAddressValue(addr);
 655   }
 656 
 657   public long getAddressSize() {
 658     return db.getAddressSize();
 659   }
 660 
 661   public long getOopSize() {
 662     return oopSize;
 663   }
 664 
 665   public long getLogAddressSize() {
 666     return logAddressSize;
 667   }
 668 
 669   public long getIntSize() {
 670     return db.getJIntType().getSize();
 671   }
 672 





 673   /** Indicates whether the underlying machine supports the LP64 data
 674       model. This is needed for conditionalizing code in a few places */
 675   public boolean isLP64() {
 676     if (Assert.ASSERTS_ENABLED) {
 677       Assert.that(isDebugging(), &quot;Debugging system only for now&quot;);
 678     }
 679     return isLP64;
 680   }
 681 
 682   /** Get bytes-per-long == long/double natural alignment. */
 683   public int getBytesPerLong() {
 684     return bytesPerLong;
 685   }
 686 
 687   public int getBytesPerWord() {
 688     return bytesPerWord;
 689   }
 690 
 691   /** Get minimum object alignment in bytes. */
 692   public int getMinObjAlignmentInBytes() {
</pre>
</td>
</tr>
</table>
<center><a href="../oops/InstanceKlass.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
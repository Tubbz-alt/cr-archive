<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/InstanceKlass.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 package sun.jvm.hotspot.oops;
  26 
  27 import java.io.*;
  28 import java.util.*;
  29 import sun.jvm.hotspot.classfile.ClassLoaderData;
  30 import sun.jvm.hotspot.debugger.*;
  31 import sun.jvm.hotspot.memory.*;
  32 import sun.jvm.hotspot.memory.Dictionary;
  33 import sun.jvm.hotspot.runtime.*;
  34 import sun.jvm.hotspot.types.*;
  35 import sun.jvm.hotspot.utilities.*;
  36 import sun.jvm.hotspot.utilities.Observable;
  37 import sun.jvm.hotspot.utilities.Observer;
  38 
  39 // An InstanceKlass is the VM level representation of a Java class.
  40 
  41 public class InstanceKlass extends Klass {
  42   static {
  43     VM.registerVMInitializedObserver(new Observer() {
  44         public void update(Observable o, Object data) {
  45           initialize(VM.getVM().getTypeDataBase());
  46         }
  47       });
  48   }
  49 
  50   // field offset constants
  51   private static int ACCESS_FLAGS_OFFSET;
  52   private static int NAME_INDEX_OFFSET;
  53   private static int SIGNATURE_INDEX_OFFSET;
  54   private static int INITVAL_INDEX_OFFSET;
  55   private static int LOW_OFFSET;
  56   private static int HIGH_OFFSET;
  57   private static int FIELD_SLOTS;
  58   private static short FIELDINFO_TAG_SIZE;
  59   private static short FIELDINFO_TAG_MASK;
  60   private static short FIELDINFO_TAG_OFFSET;
  61 
  62   // ClassState constants
  63   private static int CLASS_STATE_ALLOCATED;
  64   private static int CLASS_STATE_LOADED;
  65   private static int CLASS_STATE_LINKED;
  66   private static int CLASS_STATE_BEING_INITIALIZED;
  67   private static int CLASS_STATE_FULLY_INITIALIZED;
  68   private static int CLASS_STATE_INITIALIZATION_ERROR;
  69 
  70   // _misc_flags constants
  71   private static int MISC_REWRITTEN;
  72   private static int MISC_HAS_NONSTATIC_FIELDS;
  73   private static int MISC_SHOULD_VERIFY_CLASS;
  74   private static int MISC_IS_UNSAFE_ANONYMOUS;
  75   private static int MISC_IS_CONTENDED;
  76   private static int MISC_HAS_NONSTATIC_CONCRETE_METHODS;
  77   private static int MISC_DECLARES_NONSTATIC_CONCRETE_METHODS;
  78   private static int MISC_HAS_BEEN_REDEFINED;
  79   private static int MISC_HAS_PASSED_FINGERPRINT_CHECK;
  80   private static int MISC_IS_SCRATCH_CLASS;
  81   private static int MISC_IS_SHARED_BOOT_CLASS;
  82   private static int MISC_IS_SHARED_PLATFORM_CLASS;
  83   private static int MISC_IS_SHARED_APP_CLASS;
  84 
  85   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
  86     Type type            = db.lookupType(&quot;InstanceKlass&quot;);
  87     arrayKlasses         = new MetadataField(type.getAddressField(&quot;_array_klasses&quot;), 0);
  88     methods              = type.getAddressField(&quot;_methods&quot;);
  89     defaultMethods       = type.getAddressField(&quot;_default_methods&quot;);
  90     methodOrdering       = type.getAddressField(&quot;_method_ordering&quot;);
  91     localInterfaces      = type.getAddressField(&quot;_local_interfaces&quot;);
  92     transitiveInterfaces = type.getAddressField(&quot;_transitive_interfaces&quot;);
  93     fields               = type.getAddressField(&quot;_fields&quot;);
  94     javaFieldsCount      = new CIntField(type.getCIntegerField(&quot;_java_fields_count&quot;), 0);
  95     constants            = new MetadataField(type.getAddressField(&quot;_constants&quot;), 0);
  96     sourceDebugExtension = type.getAddressField(&quot;_source_debug_extension&quot;);
  97     innerClasses         = type.getAddressField(&quot;_inner_classes&quot;);
  98     nonstaticFieldSize   = new CIntField(type.getCIntegerField(&quot;_nonstatic_field_size&quot;), 0);
  99     staticFieldSize      = new CIntField(type.getCIntegerField(&quot;_static_field_size&quot;), 0);
 100     staticOopFieldCount  = new CIntField(type.getCIntegerField(&quot;_static_oop_field_count&quot;), 0);
 101     nonstaticOopMapSize  = new CIntField(type.getCIntegerField(&quot;_nonstatic_oop_map_size&quot;), 0);
 102     isMarkedDependent    = new CIntField(type.getCIntegerField(&quot;_is_marked_dependent&quot;), 0);
 103     initState            = new CIntField(type.getCIntegerField(&quot;_init_state&quot;), 0);
 104     itableLen            = new CIntField(type.getCIntegerField(&quot;_itable_len&quot;), 0);
 105     if (VM.getVM().isJvmtiSupported()) {
 106       breakpoints        = type.getAddressField(&quot;_breakpoints&quot;);
 107     }
 108     miscFlags            = new CIntField(type.getCIntegerField(&quot;_misc_flags&quot;), 0);
 109     headerSize           = type.getSize();
 110 
 111     // read field offset constants
 112     ACCESS_FLAGS_OFFSET            = db.lookupIntConstant(&quot;FieldInfo::access_flags_offset&quot;).intValue();
 113     NAME_INDEX_OFFSET              = db.lookupIntConstant(&quot;FieldInfo::name_index_offset&quot;).intValue();
 114     SIGNATURE_INDEX_OFFSET         = db.lookupIntConstant(&quot;FieldInfo::signature_index_offset&quot;).intValue();
 115     INITVAL_INDEX_OFFSET           = db.lookupIntConstant(&quot;FieldInfo::initval_index_offset&quot;).intValue();
 116     LOW_OFFSET                     = db.lookupIntConstant(&quot;FieldInfo::low_packed_offset&quot;).intValue();
 117     HIGH_OFFSET                    = db.lookupIntConstant(&quot;FieldInfo::high_packed_offset&quot;).intValue();
 118     FIELD_SLOTS                    = db.lookupIntConstant(&quot;FieldInfo::field_slots&quot;).intValue();
 119     FIELDINFO_TAG_SIZE             = db.lookupIntConstant(&quot;FIELDINFO_TAG_SIZE&quot;).shortValue();
 120     FIELDINFO_TAG_MASK             = db.lookupIntConstant(&quot;FIELDINFO_TAG_MASK&quot;).shortValue();
 121     FIELDINFO_TAG_OFFSET           = db.lookupIntConstant(&quot;FIELDINFO_TAG_OFFSET&quot;).shortValue();
 122 
 123     // read ClassState constants
 124     CLASS_STATE_ALLOCATED = db.lookupIntConstant(&quot;InstanceKlass::allocated&quot;).intValue();
 125     CLASS_STATE_LOADED = db.lookupIntConstant(&quot;InstanceKlass::loaded&quot;).intValue();
 126     CLASS_STATE_LINKED = db.lookupIntConstant(&quot;InstanceKlass::linked&quot;).intValue();
 127     CLASS_STATE_BEING_INITIALIZED = db.lookupIntConstant(&quot;InstanceKlass::being_initialized&quot;).intValue();
 128     CLASS_STATE_FULLY_INITIALIZED = db.lookupIntConstant(&quot;InstanceKlass::fully_initialized&quot;).intValue();
 129     CLASS_STATE_INITIALIZATION_ERROR = db.lookupIntConstant(&quot;InstanceKlass::initialization_error&quot;).intValue();
 130 
 131     MISC_REWRITTEN                    = db.lookupIntConstant(&quot;InstanceKlass::_misc_rewritten&quot;).intValue();
 132     MISC_HAS_NONSTATIC_FIELDS         = db.lookupIntConstant(&quot;InstanceKlass::_misc_has_nonstatic_fields&quot;).intValue();
 133     MISC_SHOULD_VERIFY_CLASS          = db.lookupIntConstant(&quot;InstanceKlass::_misc_should_verify_class&quot;).intValue();
 134     MISC_IS_UNSAFE_ANONYMOUS          = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_unsafe_anonymous&quot;).intValue();
 135     MISC_IS_CONTENDED                 = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_contended&quot;).intValue();
 136     MISC_HAS_NONSTATIC_CONCRETE_METHODS      = db.lookupIntConstant(&quot;InstanceKlass::_misc_has_nonstatic_concrete_methods&quot;).intValue();
 137     MISC_DECLARES_NONSTATIC_CONCRETE_METHODS = db.lookupIntConstant(&quot;InstanceKlass::_misc_declares_nonstatic_concrete_methods&quot;).intValue();
 138     MISC_HAS_BEEN_REDEFINED           = db.lookupIntConstant(&quot;InstanceKlass::_misc_has_been_redefined&quot;).intValue();
 139     MISC_HAS_PASSED_FINGERPRINT_CHECK = db.lookupIntConstant(&quot;InstanceKlass::_misc_has_passed_fingerprint_check&quot;).intValue();
 140     MISC_IS_SCRATCH_CLASS             = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_scratch_class&quot;).intValue();
 141     MISC_IS_SHARED_BOOT_CLASS         = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_shared_boot_class&quot;).intValue();
 142     MISC_IS_SHARED_PLATFORM_CLASS     = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_shared_platform_class&quot;).intValue();
 143     MISC_IS_SHARED_APP_CLASS          = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_shared_app_class&quot;).intValue();
 144   }
 145 
 146   public InstanceKlass(Address addr) {
 147     super(addr);
<a name="1" id="anc1"></a><span class="line-added"> 148 </span>
<span class="line-added"> 149     // If the class hasn&#39;t yet reached the &quot;loaded&quot; init state, then don&#39;t go any further</span>
<span class="line-added"> 150     // or we&#39;ll run into problems trying to look at fields that are not yet setup.</span>
<span class="line-added"> 151     // Attempted lookups of this InstanceKlass via ClassLoaderDataGraph, ClassLoaderData,</span>
<span class="line-added"> 152     // and Dictionary will all refuse to return it. The main purpose of allowing this</span>
<span class="line-added"> 153     // InstanceKlass to initialize is so ClassLoaderData.getKlasses() will succeed, allowing</span>
<span class="line-added"> 154     // ClassLoaderData.classesDo() to iterate over all Klasses (skipping those that are</span>
<span class="line-added"> 155     // not yet fully loaded).</span>
<span class="line-added"> 156     if (!isLoaded()) {</span>
<span class="line-added"> 157         return;</span>
<span class="line-added"> 158     }</span>
<span class="line-added"> 159 </span>
 160     if (getJavaFieldsCount() != getAllFieldsCount()) {
 161       // Exercise the injected field logic
 162       for (int i = getJavaFieldsCount(); i &lt; getAllFieldsCount(); i++) {
 163         getFieldName(i);
 164         getFieldSignature(i);
 165       }
 166     }
 167   }
 168 
 169   private static MetadataField arrayKlasses;
 170   private static AddressField  methods;
 171   private static AddressField  defaultMethods;
 172   private static AddressField  methodOrdering;
 173   private static AddressField  localInterfaces;
 174   private static AddressField  transitiveInterfaces;
 175   private static AddressField fields;
 176   private static CIntField javaFieldsCount;
 177   private static MetadataField constants;
 178   private static AddressField  sourceDebugExtension;
 179   private static AddressField  innerClasses;
 180   private static CIntField nonstaticFieldSize;
 181   private static CIntField staticFieldSize;
 182   private static CIntField staticOopFieldCount;
 183   private static CIntField nonstaticOopMapSize;
 184   private static CIntField isMarkedDependent;
 185   private static CIntField initState;
 186   private static CIntField itableLen;
 187   private static AddressField breakpoints;
 188   private static CIntField miscFlags;
 189 
 190   // type safe enum for ClassState from instanceKlass.hpp
 191   public static class ClassState {
 192      public static final ClassState ALLOCATED    = new ClassState(&quot;allocated&quot;);
 193      public static final ClassState LOADED       = new ClassState(&quot;loaded&quot;);
 194      public static final ClassState LINKED       = new ClassState(&quot;linked&quot;);
 195      public static final ClassState BEING_INITIALIZED      = new ClassState(&quot;beingInitialized&quot;);
 196      public static final ClassState FULLY_INITIALIZED    = new ClassState(&quot;fullyInitialized&quot;);
 197      public static final ClassState INITIALIZATION_ERROR = new ClassState(&quot;initializationError&quot;);
 198 
 199      private ClassState(String value) {
 200         this.value = value;
 201      }
 202 
 203      public String toString() {
 204         return value;
 205      }
 206 
 207      private String value;
 208   }
 209 
 210   public int  getInitStateAsInt() { return (int) initState.getValue(this); }
 211   public ClassState getInitState() {
 212      int state = getInitStateAsInt();
 213      if (state == CLASS_STATE_ALLOCATED) {
 214         return ClassState.ALLOCATED;
 215      } else if (state == CLASS_STATE_LOADED) {
 216         return ClassState.LOADED;
 217      } else if (state == CLASS_STATE_LINKED) {
 218         return ClassState.LINKED;
 219      } else if (state == CLASS_STATE_BEING_INITIALIZED) {
 220         return ClassState.BEING_INITIALIZED;
 221      } else if (state == CLASS_STATE_FULLY_INITIALIZED) {
 222         return ClassState.FULLY_INITIALIZED;
 223      } else if (state == CLASS_STATE_INITIALIZATION_ERROR) {
 224         return ClassState.INITIALIZATION_ERROR;
 225      } else {
 226         throw new RuntimeException(&quot;should not reach here&quot;);
 227      }
 228   }
 229 
 230   // initialization state quaries
 231   public boolean isLoaded() {
 232      return getInitStateAsInt() &gt;= CLASS_STATE_LOADED;
 233   }
 234 
 235   public boolean isLinked() {
 236      return getInitStateAsInt() &gt;= CLASS_STATE_LINKED;
 237   }
 238 
 239   public boolean isInitialized() {
 240      return getInitStateAsInt() == CLASS_STATE_FULLY_INITIALIZED;
 241   }
 242 
 243   public boolean isNotInitialized() {
 244      return getInitStateAsInt() &lt; CLASS_STATE_BEING_INITIALIZED;
 245   }
 246 
 247   public boolean isBeingInitialized() {
 248      return getInitStateAsInt() == CLASS_STATE_BEING_INITIALIZED;
 249   }
 250 
 251   public boolean isInErrorState() {
 252      return getInitStateAsInt() == CLASS_STATE_INITIALIZATION_ERROR;
 253   }
 254 
 255   public int getClassStatus() {
 256      int result = 0;
 257      if (isLinked()) {
 258         result |= JVMDIClassStatus.VERIFIED | JVMDIClassStatus.PREPARED;
 259      }
 260 
 261      if (isInitialized()) {
 262         if (Assert.ASSERTS_ENABLED) {
 263            Assert.that(isLinked(), &quot;Class status is not consistent&quot;);
 264         }
 265         result |= JVMDIClassStatus.INITIALIZED;
 266      }
 267 
 268      if (isInErrorState()) {
 269         result |= JVMDIClassStatus.ERROR;
 270      }
 271      return result;
 272   }
 273 
 274   // Byteside of the header
 275   private static long headerSize;
 276 
 277   public long getObjectSize(Oop object) {
 278     return getSizeHelper() * VM.getVM().getAddressSize();
 279   }
 280 
 281   public long getSize() { // in number of bytes
 282     long wordLength = VM.getVM().getBytesPerWord();
 283     long size = getHeaderSize() +
 284                 (getVtableLen() +
 285                  getItableLen() +
 286                  getNonstaticOopMapSize()) * wordLength;
 287     if (isInterface()) {
 288       size += wordLength;
 289     }
 290     if (isUnsafeAnonymous()) {
 291       size += wordLength;
 292     }
 293     if (hasStoredFingerprint()) {
 294       size += 8; // uint64_t
 295     }
 296     return alignSize(size);
 297   }
 298 
 299   private int getMiscFlags() {
 300     return (int) miscFlags.getValue(this);
 301   }
 302 
 303   public boolean isUnsafeAnonymous() {
 304     return (getMiscFlags() &amp; MISC_IS_UNSAFE_ANONYMOUS) != 0;
 305   }
 306 
 307   public static boolean shouldStoreFingerprint() {
 308     VM vm = VM.getVM();
 309     if (vm.getCommandLineBooleanFlag(&quot;EnableJVMCI&quot;) &amp;&amp; !vm.getCommandLineBooleanFlag(&quot;UseJVMCICompiler&quot;)) {
 310       return true;
 311     }
 312     if (vm.getCommandLineBooleanFlag(&quot;DumpSharedSpaces&quot;)) {
 313       return true;
 314     }
 315     return false;
 316   }
 317 
 318   public boolean hasStoredFingerprint() {
 319     return shouldStoreFingerprint() || isShared();
 320   }
 321 
 322   public static long getHeaderSize() { return headerSize; }
 323 
 324   public short getFieldAccessFlags(int index) {
 325     return getFields().at(index * FIELD_SLOTS + ACCESS_FLAGS_OFFSET);
 326   }
 327 
 328   public short getFieldNameIndex(int index) {
 329     if (index &gt;= getJavaFieldsCount()) throw new IndexOutOfBoundsException(&quot;not a Java field;&quot;);
 330     return getFields().at(index * FIELD_SLOTS + NAME_INDEX_OFFSET);
 331   }
 332 
 333   public Symbol getFieldName(int index) {
 334     int nameIndex = getFields().at(index * FIELD_SLOTS + NAME_INDEX_OFFSET);
 335     if (index &lt; getJavaFieldsCount()) {
 336       return getConstants().getSymbolAt(nameIndex);
 337     } else {
 338       return vmSymbols.symbolAt(nameIndex);
 339     }
 340   }
 341 
 342   public short getFieldSignatureIndex(int index) {
 343     if (index &gt;= getJavaFieldsCount()) throw new IndexOutOfBoundsException(&quot;not a Java field;&quot;);
 344     return getFields().at(index * FIELD_SLOTS + SIGNATURE_INDEX_OFFSET);
 345   }
 346 
 347   public Symbol getFieldSignature(int index) {
 348     int signatureIndex = getFields().at(index * FIELD_SLOTS + SIGNATURE_INDEX_OFFSET);
 349     if (index &lt; getJavaFieldsCount()) {
 350       return getConstants().getSymbolAt(signatureIndex);
 351     } else {
 352       return vmSymbols.symbolAt(signatureIndex);
 353     }
 354   }
 355 
 356   public short getFieldGenericSignatureIndex(int index) {
 357     // int len = getFields().length();
 358     int allFieldsCount = getAllFieldsCount();
 359     int generic_signature_slot = allFieldsCount * FIELD_SLOTS;
 360     for (int i = 0; i &lt; allFieldsCount; i++) {
 361       short flags = getFieldAccessFlags(i);
 362       AccessFlags access = new AccessFlags(flags);
 363       if (i == index) {
 364         if (access.fieldHasGenericSignature()) {
 365            return getFields().at(generic_signature_slot);
 366         } else {
 367           return 0;
 368         }
 369       } else {
 370         if (access.fieldHasGenericSignature()) {
 371           generic_signature_slot ++;
 372         }
 373       }
 374     }
 375     return 0;
 376   }
 377 
 378   public Symbol getFieldGenericSignature(int index) {
 379     short genericSignatureIndex = getFieldGenericSignatureIndex(index);
 380     if (genericSignatureIndex != 0)  {
 381       return getConstants().getSymbolAt(genericSignatureIndex);
 382     }
 383     return null;
 384   }
 385 
 386   public short getFieldInitialValueIndex(int index) {
 387     if (index &gt;= getJavaFieldsCount()) throw new IndexOutOfBoundsException(&quot;not a Java field;&quot;);
 388     return getFields().at(index * FIELD_SLOTS + INITVAL_INDEX_OFFSET);
 389   }
 390 
 391   public int getFieldOffset(int index) {
 392     U2Array fields = getFields();
 393     short lo = fields.at(index * FIELD_SLOTS + LOW_OFFSET);
 394     short hi = fields.at(index * FIELD_SLOTS + HIGH_OFFSET);
 395     if ((lo &amp; FIELDINFO_TAG_MASK) == FIELDINFO_TAG_OFFSET) {
 396       return VM.getVM().buildIntFromShorts(lo, hi) &gt;&gt; FIELDINFO_TAG_SIZE;
 397     }
 398     throw new RuntimeException(&quot;should not reach here&quot;);
 399   }
 400 
 401   // Accessors for declared fields
 402   public Klass     getArrayKlasses()        { return (Klass)        arrayKlasses.getValue(this); }
 403   public MethodArray  getMethods()              { return new MethodArray(methods.getValue(getAddress())); }
 404 
 405   public MethodArray  getDefaultMethods() {
 406     if (defaultMethods != null) {
 407       Address addr = defaultMethods.getValue(getAddress());
 408       if ((addr != null) &amp;&amp; (addr.getAddressAt(0) != null)) {
 409         return new MethodArray(addr);
 410       } else {
 411         return null;
 412       }
 413     } else {
 414       return null;
 415     }
 416   }
 417 
 418   public KlassArray   getLocalInterfaces()      { return new KlassArray(localInterfaces.getValue(getAddress())); }
 419   public KlassArray   getTransitiveInterfaces() { return new KlassArray(transitiveInterfaces.getValue(getAddress())); }
 420   public int       getJavaFieldsCount()     { return                (int) javaFieldsCount.getValue(this); }
 421   public int       getAllFieldsCount()      {
 422     int len = getFields().length();
 423     int allFieldsCount = 0;
 424     for (; allFieldsCount*FIELD_SLOTS &lt; len; allFieldsCount++) {
 425       short flags = getFieldAccessFlags(allFieldsCount);
 426       AccessFlags access = new AccessFlags(flags);
 427       if (access.fieldHasGenericSignature()) {
 428         len --;
 429       }
 430     }
 431     return allFieldsCount;
 432   }
 433   public ConstantPool getConstants()        { return (ConstantPool) constants.getValue(this); }
 434   public Symbol    getSourceFileName()      { return                getConstants().getSourceFileName(); }
 435   public String    getSourceDebugExtension(){ return                CStringUtilities.getString(sourceDebugExtension.getValue(getAddress())); }
 436   public long      getNonstaticFieldSize()  { return                nonstaticFieldSize.getValue(this); }
 437   public long      getStaticOopFieldCount() { return                staticOopFieldCount.getValue(this); }
 438   public long      getNonstaticOopMapSize() { return                nonstaticOopMapSize.getValue(this); }
 439   public boolean   getIsMarkedDependent()   { return                isMarkedDependent.getValue(this) != 0; }
 440   public long      getItableLen()           { return                itableLen.getValue(this); }
 441   public long      majorVersion()           { return                getConstants().majorVersion(); }
 442   public long      minorVersion()           { return                getConstants().minorVersion(); }
 443   public Symbol    getGenericSignature()    { return                getConstants().getGenericSignature(); }
 444 
 445   // &quot;size helper&quot; == instance size in words
 446   public long getSizeHelper() {
 447     int lh = getLayoutHelper();
 448     if (Assert.ASSERTS_ENABLED) {
 449       Assert.that(lh &gt; 0, &quot;layout helper initialized for instance class&quot;);
 450     }
 451     return lh / VM.getVM().getAddressSize();
 452   }
 453 
 454   // same as enum InnerClassAttributeOffset in VM code.
 455   private static class InnerClassAttributeOffset {
 456     // from JVM spec. &quot;InnerClasses&quot; attribute
 457     public static int innerClassInnerClassInfoOffset;
 458     public static int innerClassOuterClassInfoOffset;
 459     public static int innerClassInnerNameOffset;
 460     public static int innerClassAccessFlagsOffset;
 461     public static int innerClassNextOffset;
 462     static {
 463       VM.registerVMInitializedObserver(new Observer() {
 464           public void update(Observable o, Object data) {
 465               initialize(VM.getVM().getTypeDataBase());
 466           }
 467       });
 468     }
 469 
 470     private static synchronized void initialize(TypeDataBase db) {
 471       innerClassInnerClassInfoOffset = db.lookupIntConstant(
 472           &quot;InstanceKlass::inner_class_inner_class_info_offset&quot;).intValue();
 473       innerClassOuterClassInfoOffset = db.lookupIntConstant(
 474           &quot;InstanceKlass::inner_class_outer_class_info_offset&quot;).intValue();
 475       innerClassInnerNameOffset = db.lookupIntConstant(
 476           &quot;InstanceKlass::inner_class_inner_name_offset&quot;).intValue();
 477       innerClassAccessFlagsOffset = db.lookupIntConstant(
 478           &quot;InstanceKlass::inner_class_access_flags_offset&quot;).intValue();
 479       innerClassNextOffset = db.lookupIntConstant(
 480           &quot;InstanceKlass::inner_class_next_offset&quot;).intValue();
 481     }
 482   }
 483 
 484   private static class EnclosingMethodAttributeOffset {
 485     public static int enclosingMethodAttributeSize;
 486     static {
 487       VM.registerVMInitializedObserver(new Observer() {
 488           public void update(Observable o, Object data) {
 489               initialize(VM.getVM().getTypeDataBase());
 490           }
 491       });
 492     }
 493     private static synchronized void initialize(TypeDataBase db) {
 494       enclosingMethodAttributeSize = db.lookupIntConstant(&quot;InstanceKlass::enclosing_method_attribute_size&quot;).intValue();
 495     }
 496   }
 497 
 498   // refer to compute_modifier_flags in VM code.
 499   public long computeModifierFlags() {
 500     long access = getAccessFlags();
 501     // But check if it happens to be member class.
 502     U2Array innerClassList = getInnerClasses();
 503     int length = (innerClassList == null)? 0 : (int) innerClassList.length();
 504     if (length &gt; 0) {
 505        if (Assert.ASSERTS_ENABLED) {
 506           Assert.that(length % InnerClassAttributeOffset.innerClassNextOffset == 0 ||
 507                       length % InnerClassAttributeOffset.innerClassNextOffset == EnclosingMethodAttributeOffset.enclosingMethodAttributeSize,
 508                       &quot;just checking&quot;);
 509        }
 510        for (int i = 0; i &lt; length; i += InnerClassAttributeOffset.innerClassNextOffset) {
 511           if (i == length - EnclosingMethodAttributeOffset.enclosingMethodAttributeSize) {
 512               break;
 513           }
 514           int ioff = innerClassList.at(i +
 515                          InnerClassAttributeOffset.innerClassInnerClassInfoOffset);
 516           // &#39;ioff&#39; can be zero.
 517           // refer to JVM spec. section 4.7.5.
 518           if (ioff != 0) {
 519              // only look at classes that are already loaded
 520              // since we are looking for the flags for our self.
 521              Symbol name = getConstants().getKlassNameAt(ioff);
 522 
 523              if (name.equals(getName())) {
 524                 // This is really a member class
 525                 access = innerClassList.at(i +
 526                         InnerClassAttributeOffset.innerClassAccessFlagsOffset);
 527                 break;
 528              }
 529           }
 530        } // for inner classes
 531     }
 532 
 533     // Remember to strip ACC_SUPER bit
 534     return (access &amp; (~JVM_ACC_SUPER)) &amp; JVM_ACC_WRITTEN_FLAGS;
 535   }
 536 
 537 
 538   // whether given Symbol is name of an inner/nested Klass of this Klass?
 539   // anonymous and local classes are excluded.
 540   public boolean isInnerClassName(Symbol sym) {
 541     return isInInnerClasses(sym, false);
 542   }
 543 
 544   // whether given Symbol is name of an inner/nested Klass of this Klass?
 545   // anonymous classes excluded, but local classes are included.
 546   public boolean isInnerOrLocalClassName(Symbol sym) {
 547     return isInInnerClasses(sym, true);
 548   }
 549 
 550   private boolean isInInnerClasses(Symbol sym, boolean includeLocals) {
 551     U2Array innerClassList = getInnerClasses();
 552     int length = ( innerClassList == null)? 0 : (int) innerClassList.length();
 553     if (length &gt; 0) {
 554        if (Assert.ASSERTS_ENABLED) {
 555          Assert.that(length % InnerClassAttributeOffset.innerClassNextOffset == 0 ||
 556                      length % InnerClassAttributeOffset.innerClassNextOffset == EnclosingMethodAttributeOffset.enclosingMethodAttributeSize,
 557                      &quot;just checking&quot;);
 558        }
 559        for (int i = 0; i &lt; length; i += InnerClassAttributeOffset.innerClassNextOffset) {
 560          if (i == length - EnclosingMethodAttributeOffset.enclosingMethodAttributeSize) {
 561              break;
 562          }
 563          int ioff = innerClassList.at(i +
 564                         InnerClassAttributeOffset.innerClassInnerClassInfoOffset);
 565          // &#39;ioff&#39; can be zero.
 566          // refer to JVM spec. section 4.7.5.
 567          if (ioff != 0) {
 568             Symbol innerName = getConstants().getKlassNameAt(ioff);
 569             Symbol myname = getName();
 570             int ooff = innerClassList.at(i +
 571                         InnerClassAttributeOffset.innerClassOuterClassInfoOffset);
 572             // for anonymous classes inner_name_index of InnerClasses
 573             // attribute is zero.
 574             int innerNameIndex = innerClassList.at(i +
 575                         InnerClassAttributeOffset.innerClassInnerNameOffset);
 576             // if this is not a member (anonymous, local etc.), &#39;ooff&#39; will be zero
 577             // refer to JVM spec. section 4.7.5.
 578             if (ooff == 0) {
 579                if (includeLocals) {
 580                   // does it looks like my local class?
 581                   if (innerName.equals(sym) &amp;&amp;
 582                      innerName.asString().startsWith(myname.asString())) {
 583                      // exclude anonymous classes.
 584                      return (innerNameIndex != 0);
 585                   }
 586                }
 587             } else {
 588                Symbol outerName = getConstants().getKlassNameAt(ooff);
 589 
 590                // include only if current class is outer class.
 591                if (outerName.equals(myname) &amp;&amp; innerName.equals(sym)) {
 592                   return true;
 593                }
 594            }
 595          }
 596        } // for inner classes
 597        return false;
 598     } else {
 599        return false;
 600     }
 601   }
 602 
 603   public boolean implementsInterface(Klass k) {
 604     if (Assert.ASSERTS_ENABLED) {
 605       Assert.that(k.isInterface(), &quot;should not reach here&quot;);
 606     }
 607     KlassArray interfaces =  getTransitiveInterfaces();
 608     final int len = interfaces.length();
 609     for (int i = 0; i &lt; len; i++) {
 610       if (interfaces.getAt(i).equals(k)) return true;
 611     }
 612     return false;
 613   }
 614 
 615   boolean computeSubtypeOf(Klass k) {
 616     if (k.isInterface()) {
 617       return implementsInterface(k);
 618     } else {
 619       return super.computeSubtypeOf(k);
 620     }
 621   }
 622 
 623   public void printValueOn(PrintStream tty) {
 624     tty.print(&quot;InstanceKlass for &quot; + getName().asString());
 625   }
 626 
 627   public void iterateFields(MetadataVisitor visitor) {
 628     super.iterateFields(visitor);
 629     visitor.doMetadata(arrayKlasses, true);
 630     // visitor.doOop(methods, true);
 631     // visitor.doOop(localInterfaces, true);
 632     // visitor.doOop(transitiveInterfaces, true);
 633       visitor.doCInt(nonstaticFieldSize, true);
 634       visitor.doCInt(staticFieldSize, true);
 635       visitor.doCInt(staticOopFieldCount, true);
 636       visitor.doCInt(nonstaticOopMapSize, true);
 637       visitor.doCInt(isMarkedDependent, true);
 638       visitor.doCInt(initState, true);
 639       visitor.doCInt(itableLen, true);
 640     }
 641 
 642   /*
 643    *  Visit the static fields of this InstanceKlass with the obj of
 644    *  the visitor set to the oop holding the fields, which is
 645    *  currently the java mirror.
 646    */
 647   public void iterateStaticFields(OopVisitor visitor) {
 648     visitor.setObj(getJavaMirror());
 649     visitor.prologue();
 650     iterateStaticFieldsInternal(visitor);
 651     visitor.epilogue();
 652 
 653   }
 654 
 655   void iterateStaticFieldsInternal(OopVisitor visitor) {
 656     int length = getJavaFieldsCount();
 657     for (int index = 0; index &lt; length; index++) {
 658       short accessFlags    = getFieldAccessFlags(index);
 659       FieldType   type   = new FieldType(getFieldSignature(index));
 660       AccessFlags access = new AccessFlags(accessFlags);
 661       if (access.isStatic()) {
 662         visitField(visitor, type, index);
 663       }
 664     }
 665   }
 666 
 667   public Klass getJavaSuper() {
 668     return getSuper();
 669   }
 670 
 671   public static class StaticField {
 672     public AccessFlags flags;
 673     public Field field;
 674 
 675     StaticField(Field field, AccessFlags flags) {
 676       this.field = field;
 677       this.flags = flags;
 678     }
 679   }
 680 
 681   public Field[] getStaticFields() {
 682     U2Array fields = getFields();
 683     int length = getJavaFieldsCount();
 684     ArrayList&lt;Field&gt; result = new ArrayList&lt;&gt;();
 685     for (int index = 0; index &lt; length; index++) {
 686       Field f = newField(index);
 687       if (f.isStatic()) {
 688         result.add(f);
 689       }
 690     }
 691     return result.toArray(new Field[result.size()]);
 692   }
 693 
 694   public void iterateNonStaticFields(OopVisitor visitor, Oop obj) {
 695     if (getSuper() != null) {
 696       ((InstanceKlass) getSuper()).iterateNonStaticFields(visitor, obj);
 697     }
 698     int length = getJavaFieldsCount();
 699     for (int index = 0; index &lt; length; index++) {
 700       short accessFlags    = getFieldAccessFlags(index);
 701       FieldType   type   = new FieldType(getFieldSignature(index));
 702       AccessFlags access = new AccessFlags(accessFlags);
 703       if (!access.isStatic()) {
 704         visitField(visitor, type, index);
 705       }
 706     }
 707   }
 708 
 709   /** Field access by name. */
 710   public Field findLocalField(String name, String sig) {
 711     int length = getJavaFieldsCount();
 712     for (int i = 0; i &lt; length; i++) {
 713       Symbol f_name = getFieldName(i);
 714       Symbol f_sig  = getFieldSignature(i);
 715       if (f_name.equals(name) &amp;&amp; f_sig.equals(sig)) {
 716         return newField(i);
 717       }
 718     }
 719 
 720     return null;
 721   }
 722 
 723   /** Find field in direct superinterfaces. */
 724   public Field findInterfaceField(String name, String sig) {
 725     KlassArray interfaces = getLocalInterfaces();
 726     int n = interfaces.length();
 727     for (int i = 0; i &lt; n; i++) {
 728       InstanceKlass intf1 = (InstanceKlass) interfaces.getAt(i);
 729       if (Assert.ASSERTS_ENABLED) {
 730         Assert.that(intf1.isInterface(), &quot;just checking type&quot;);
 731      }
 732       // search for field in current interface
 733       Field f = intf1.findLocalField(name, sig);
 734       if (f != null) {
 735         if (Assert.ASSERTS_ENABLED) {
 736           Assert.that(f.getAccessFlagsObj().isStatic(), &quot;interface field must be static&quot;);
 737         }
 738         return f;
 739       }
 740       // search for field in direct superinterfaces
 741       f = intf1.findInterfaceField(name, sig);
 742       if (f != null) return f;
 743     }
 744     // otherwise field lookup fails
 745     return null;
 746   }
 747 
 748   /** Find field according to JVM spec 5.4.3.2, returns the klass in
 749       which the field is defined. */
 750   public Field findField(String name, String sig) {
 751     // search order according to newest JVM spec (5.4.3.2, p.167).
 752     // 1) search for field in current klass
 753     Field f = findLocalField(name, sig);
 754     if (f != null) return f;
 755 
 756     // 2) search for field recursively in direct superinterfaces
 757     f = findInterfaceField(name, sig);
 758     if (f != null) return f;
 759 
 760     // 3) apply field lookup recursively if superclass exists
 761     InstanceKlass supr = (InstanceKlass) getSuper();
 762     if (supr != null) return supr.findField(name, sig);
 763 
 764     // 4) otherwise field lookup fails
 765     return null;
 766   }
 767 
 768   /** Find field according to JVM spec 5.4.3.2, returns the klass in
 769       which the field is defined (retained only for backward
 770       compatibility with jdbx) */
 771   public Field findFieldDbg(String name, String sig) {
 772     return findField(name, sig);
 773   }
 774 
 775   /** Get field by its index in the fields array. Only designed for
 776       use in a debugging system. */
 777   public Field getFieldByIndex(int fieldIndex) {
 778     return newField(fieldIndex);
 779   }
 780 
 781 
 782     /** Return a List of SA Fields for the fields declared in this class.
 783         Inherited fields are not included.
 784         Return an empty list if there are no fields declared in this class.
 785         Only designed for use in a debugging system. */
 786     public List&lt;Field&gt; getImmediateFields() {
 787         // A list of Fields for each field declared in this class/interface,
 788         // not including inherited fields.
 789         int length = getJavaFieldsCount();
 790         List&lt;Field&gt; immediateFields = new ArrayList&lt;&gt;(length);
 791         for (int index = 0; index &lt; length; index++) {
 792             immediateFields.add(getFieldByIndex(index));
 793         }
 794 
 795         return immediateFields;
 796     }
 797 
 798     /** Return a List of SA Fields for all the java fields in this class,
 799         including all inherited fields.  This includes hidden
 800         fields.  Thus the returned list can contain fields with
 801         the same name.
 802         Return an empty list if there are no fields.
 803         Only designed for use in a debugging system. */
 804     public List&lt;Field&gt; getAllFields() {
 805         // Contains a Field for each field in this class, including immediate
 806         // fields and inherited fields.
 807         List&lt;Field&gt; allFields = getImmediateFields();
 808 
 809         // transitiveInterfaces contains all interfaces implemented
 810         // by this class and its superclass chain with no duplicates.
 811 
 812         KlassArray interfaces = getTransitiveInterfaces();
 813         int n = interfaces.length();
 814         for (int i = 0; i &lt; n; i++) {
 815             InstanceKlass intf1 = (InstanceKlass) interfaces.getAt(i);
 816             if (Assert.ASSERTS_ENABLED) {
 817                 Assert.that(intf1.isInterface(), &quot;just checking type&quot;);
 818             }
 819             allFields.addAll(intf1.getImmediateFields());
 820         }
 821 
 822         // Get all fields in the superclass, recursively.  But, don&#39;t
 823         // include fields in interfaces implemented by superclasses;
 824         // we already have all those.
 825         if (!isInterface()) {
 826             InstanceKlass supr;
 827             if  ( (supr = (InstanceKlass) getSuper()) != null) {
 828                 allFields.addAll(supr.getImmediateFields());
 829             }
 830         }
 831 
 832         return allFields;
 833     }
 834 
 835 
 836     /** Return a List of SA Methods declared directly in this class/interface.
 837         Return an empty list if there are none, or if this isn&#39;t a class/
 838         interface.
 839     */
 840     public List&lt;Method&gt; getImmediateMethods() {
 841       // Contains a Method for each method declared in this class/interface
 842       // not including inherited methods.
 843 
 844       MethodArray methods = getMethods();
 845       int length = methods.length();
 846       Method[] tmp = new Method[length];
 847 
 848       IntArray methodOrdering = getMethodOrdering();
 849       if (methodOrdering.length() != length) {
 850          // no ordering info present
 851          for (int index = 0; index &lt; length; index++) {
 852             tmp[index] = methods.at(index);
 853          }
 854       } else {
 855          for (int index = 0; index &lt; length; index++) {
 856             int originalIndex = methodOrdering.at(index);
 857             tmp[originalIndex] = methods.at(index);
 858          }
 859       }
 860 
 861       return Arrays.asList(tmp);
 862     }
 863 
 864     /** Return a List containing an SA InstanceKlass for each
 865         interface named in this class&#39;s &#39;implements&#39; clause.
 866     */
 867     public List&lt;Klass&gt; getDirectImplementedInterfaces() {
 868         // Contains an InstanceKlass for each interface in this classes
 869         // &#39;implements&#39; clause.
 870 
 871         KlassArray interfaces = getLocalInterfaces();
 872         int length = interfaces.length();
 873         List&lt;Klass&gt; directImplementedInterfaces = new ArrayList&lt;&gt;(length);
 874 
 875         for (int index = 0; index &lt; length; index ++) {
 876             directImplementedInterfaces.add(interfaces.getAt(index));
 877         }
 878 
 879         return directImplementedInterfaces;
 880     }
 881 
 882   public Klass arrayKlassImpl(boolean orNull, int n) {
 883     // FIXME: in reflective system this would need to change to
 884     // actually allocate
 885     if (getArrayKlasses() == null) { return null; }
 886     ObjArrayKlass oak = (ObjArrayKlass) getArrayKlasses();
 887     if (orNull) {
 888       return oak.arrayKlassOrNull(n);
 889     }
 890     return oak.arrayKlass(n);
 891   }
 892 
 893   public Klass arrayKlassImpl(boolean orNull) {
 894     return arrayKlassImpl(orNull, 1);
 895   }
 896 
 897   public String signature() {
 898      return &quot;L&quot; + super.signature() + &quot;;&quot;;
 899   }
 900 
 901   /** Find method in vtable. */
 902   public Method findMethod(String name, String sig) {
 903     return findMethod(getMethods(), name, sig);
 904   }
 905 
 906   /** Breakpoint support (see methods on Method* for details) */
 907   public BreakpointInfo getBreakpoints() {
 908     if (!VM.getVM().isJvmtiSupported()) {
 909       return null;
 910     }
 911     Address addr = getAddress().getAddressAt(breakpoints.getOffset());
 912     return (BreakpointInfo) VMObjectFactory.newObject(BreakpointInfo.class, addr);
 913   }
 914 
 915   public IntArray  getMethodOrdering() {
 916     Address addr = getAddress().getAddressAt(methodOrdering.getOffset());
 917     return (IntArray) VMObjectFactory.newObject(IntArray.class, addr);
 918   }
 919 
 920   public U2Array getFields() {
 921     Address addr = getAddress().getAddressAt(fields.getOffset());
 922     return (U2Array) VMObjectFactory.newObject(U2Array.class, addr);
 923   }
 924 
 925   public U2Array getInnerClasses() {
 926     Address addr = getAddress().getAddressAt(innerClasses.getOffset());
 927     return (U2Array) VMObjectFactory.newObject(U2Array.class, addr);
 928   }
 929 
 930 
 931   //----------------------------------------------------------------------
 932   // Internals only below this point
 933   //
 934 
 935   private void visitField(OopVisitor visitor, FieldType type, int index) {
 936     Field f = newField(index);
 937     if (type.isOop()) {
 938       visitor.doOop((OopField) f, false);
 939       return;
 940     }
 941     if (type.isByte()) {
 942       visitor.doByte((ByteField) f, false);
 943       return;
 944     }
 945     if (type.isChar()) {
 946       visitor.doChar((CharField) f, false);
 947       return;
 948     }
 949     if (type.isDouble()) {
 950       visitor.doDouble((DoubleField) f, false);
 951       return;
 952     }
 953     if (type.isFloat()) {
 954       visitor.doFloat((FloatField) f, false);
 955       return;
 956     }
 957     if (type.isInt()) {
 958       visitor.doInt((IntField) f, false);
 959       return;
 960     }
 961     if (type.isLong()) {
 962       visitor.doLong((LongField) f, false);
 963       return;
 964     }
 965     if (type.isShort()) {
 966       visitor.doShort((ShortField) f, false);
 967       return;
 968     }
 969     if (type.isBoolean()) {
 970       visitor.doBoolean((BooleanField) f, false);
 971       return;
 972     }
 973   }
 974 
 975   // Creates new field from index in fields TypeArray
 976   private Field newField(int index) {
 977     FieldType type = new FieldType(getFieldSignature(index));
 978     if (type.isOop()) {
 979      if (VM.getVM().isCompressedOopsEnabled()) {
 980         return new NarrowOopField(this, index);
 981      } else {
 982         return new OopField(this, index);
 983      }
 984     }
 985     if (type.isByte()) {
 986       return new ByteField(this, index);
 987     }
 988     if (type.isChar()) {
 989       return new CharField(this, index);
 990     }
 991     if (type.isDouble()) {
 992       return new DoubleField(this, index);
 993     }
 994     if (type.isFloat()) {
 995       return new FloatField(this, index);
 996     }
 997     if (type.isInt()) {
 998       return new IntField(this, index);
 999     }
1000     if (type.isLong()) {
1001       return new LongField(this, index);
1002     }
1003     if (type.isShort()) {
1004       return new ShortField(this, index);
1005     }
1006     if (type.isBoolean()) {
1007       return new BooleanField(this, index);
1008     }
1009     throw new RuntimeException(&quot;Illegal field type at index &quot; + index);
1010   }
1011 
1012   private static Method findMethod(MethodArray methods, String name, String signature) {
1013     int index = linearSearch(methods, name, signature);
1014     if (index != -1) {
1015       return methods.at(index);
1016     } else {
1017       return null;
1018     }
1019   }
1020 
1021   private static int linearSearch(MethodArray methods, String name, String signature) {
1022     int len = (int) methods.length();
1023     for (int index = 0; index &lt; len; index++) {
1024       Method m = methods.at(index);
1025       if (m.getSignature().equals(signature) &amp;&amp; m.getName().equals(name)) {
1026         return index;
1027       }
1028     }
1029     return -1;
1030   }
1031 
1032   public void dumpReplayData(PrintStream out) {
1033     ConstantPool cp = getConstants();
1034 
1035     // Try to record related loaded classes
1036     Klass sub = getSubklassKlass();
1037     while (sub != null) {
1038         if (sub instanceof InstanceKlass) {
1039             out.println(&quot;instanceKlass &quot; + sub.getName().asString());
1040         }
1041         sub = sub.getNextSiblingKlass();
1042     }
1043 
1044     final int length = (int) cp.getLength();
1045     out.print(&quot;ciInstanceKlass &quot; + getName().asString() + &quot; &quot; + (isLinked() ? 1 : 0) + &quot; &quot; + (isInitialized() ? 1 : 0) + &quot; &quot; + length);
1046     for (int index = 1; index &lt; length; index++) {
1047       out.print(&quot; &quot; + cp.getTags().at(index));
1048     }
1049     out.println();
1050     if (isInitialized()) {
1051       Field[] staticFields = getStaticFields();
1052       for (int i = 0; i &lt; staticFields.length; i++) {
1053         Field f = staticFields[i];
1054         Oop mirror = getJavaMirror();
1055         if (f.isFinal() &amp;&amp; !f.hasInitialValue()) {
1056           out.print(&quot;staticfield &quot; + getName().asString() + &quot; &quot; +
1057                     OopUtilities.escapeString(f.getID().getName()) + &quot; &quot; +
1058                     f.getFieldType().getSignature().asString() + &quot; &quot;);
1059           if (f instanceof ByteField) {
1060             ByteField bf = (ByteField)f;
1061             out.println(bf.getValue(mirror));
1062           } else if (f instanceof BooleanField) {
1063             BooleanField bf = (BooleanField)f;
1064             out.println(bf.getValue(mirror) ? 1 : 0);
1065           } else if (f instanceof ShortField) {
1066             ShortField bf = (ShortField)f;
1067             out.println(bf.getValue(mirror));
1068           } else if (f instanceof CharField) {
1069             CharField bf = (CharField)f;
1070             out.println(bf.getValue(mirror) &amp; 0xffff);
1071           } else if (f instanceof IntField) {
1072             IntField bf = (IntField)f;
1073             out.println(bf.getValue(mirror));
1074           } else  if (f instanceof LongField) {
1075             LongField bf = (LongField)f;
1076             out.println(bf.getValue(mirror));
1077           } else if (f instanceof FloatField) {
1078             FloatField bf = (FloatField)f;
1079             out.println(Float.floatToRawIntBits(bf.getValue(mirror)));
1080           } else if (f instanceof DoubleField) {
1081             DoubleField bf = (DoubleField)f;
1082             out.println(Double.doubleToRawLongBits(bf.getValue(mirror)));
1083           } else if (f instanceof OopField) {
1084             OopField bf = (OopField)f;
1085 
1086             Oop value = bf.getValue(mirror);
1087             if (value == null) {
1088               out.println(&quot;null&quot;);
1089             } else if (value.isInstance()) {
1090               Instance inst = (Instance)value;
1091               if (inst.isA(SystemDictionary.getStringKlass())) {
1092                 out.println(&quot;\&quot;&quot; + OopUtilities.stringOopToEscapedString(inst) + &quot;\&quot;&quot;);
1093               } else {
1094                 out.println(inst.getKlass().getName().asString());
1095               }
1096             } else if (value.isObjArray()) {
1097               ObjArray oa = (ObjArray)value;
1098               Klass ek = (ObjArrayKlass)oa.getKlass();
1099               out.println(oa.getLength() + &quot; &quot; + ek.getName().asString());
1100             } else if (value.isTypeArray()) {
1101               TypeArray ta = (TypeArray)value;
1102               out.println(ta.getLength());
1103             } else {
1104               out.println(value);
1105             }
1106           }
1107         }
1108       }
1109     }
1110   }
1111 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
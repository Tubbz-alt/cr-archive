diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -29,11 +29,10 @@
 import java.nio.ByteBuffer;
 
 import jdk.internal.foreign.AbstractMemorySegmentImpl;
 import jdk.internal.foreign.HeapMemorySegmentImpl;
 import jdk.internal.foreign.MappedMemorySegmentImpl;
-import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.NativeMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 
 import java.io.IOException;
 import java.nio.channels.FileChannel;
@@ -109,25 +108,26 @@
  * (e.g. in the case of parallel processing); while memory segments provide strong confinement guarantees, it is possible
  * to obtain a {@link Spliterator} from a segment, which can be used to slice the segment and allow multiple thread to
  * work in parallel on disjoint segment slices (this assumes that the access mode {@link #ACQUIRE} is set).
  * For instance, the following code can be used to sum all int values in a memory segment in parallel:
  * <blockquote><pre>{@code
+MemorySegment segment = ...
 SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
 VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);
-int sum = StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)
-            .mapToInt(segment -> (int)VH_int.get(segment.baseAddress))
+int sum = StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)
+            .mapToInt(s -> (int)VH_int.get(s.baseAddress()))
             .sum();
  * }</pre></blockquote>
  *
  * <h2><a id = "access-modes">Access modes</a></h2>
  *
  * Memory segments supports zero or more <em>access modes</em>. Supported access modes are {@link #READ},
- * {@link #WRITE}, {@link #CLOSE} and {@link #ACQUIRE}. The set of access modes supported by a segment alters the
+ * {@link #WRITE}, {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}. The set of access modes supported by a segment alters the
  * set of operations that are supported by that segment. For instance, attempting to call {@link #close()} on
  * a segment which does not support the {@link #CLOSE} access mode will result in an exception.
  * <p>
- * The set of supported access modes can only be made stricter (by supporting <em>less</em> access modes). This means
+ * The set of supported access modes can only be made stricter (by supporting <em>fewer</em> access modes). This means
  * that restricting the set of access modes supported by a segment before sharing it with other clients
  * is generally a good practice if the creator of the segment wants to retain some control over how the segment
  * is going to be accessed.
  *
  * <h2>Memory segment views</h2>
@@ -148,11 +148,11 @@
  * from the set of supported access modes, before sharing the view with another client.
  * <p>
  * To allow for interoperability with existing code, a byte buffer view can be obtained from a memory segment
  * (see {@link #asByteBuffer()}). This can be useful, for instance, for those clients that want to keep using the
  * {@link ByteBuffer} API, but need to operate on large memory segments. Byte buffers obtained in such a way support
- * the same spatial and temporal access restrictions associated to the memory address from which they originated.
+ * the same spatial and temporal access restrictions associated to the memory segment from which they originated.
  *
  * @apiNote In the future, if the Java language permits, {@link MemorySegment}
  * may become a {@code sealed} interface, which would prohibit subclassing except by
  * {@link MappedMemorySegment} and other explicitly permitted subtypes.
  *
@@ -175,11 +175,12 @@
      * characteristics.
      * <p>
      * The returned spliterator splits the segment according to the specified sequence layout; that is,
      * if the supplied layout is a sequence layout whose element count is {@code N}, then calling {@link Spliterator#trySplit()}
      * will result in a spliterator serving approximatively {@code N/2} elements (depending on whether N is even or not).
-     * As such, splitting is possible as long as {@code N >= 2}.
+     * As such, splitting is possible as long as {@code N >= 2}. The spliterator returns segments that feature the same
+     * <a href="#access-modes">access modes</a> as the given segment less the {@link #CLOSE} access mode.
      * <p>
      * The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then
      * be processed in parallel by multiple threads (if the access mode {@link #ACQUIRE} is set).
      * While closing the segment (see {@link #close()}) during pending concurrent execution will generally
      * fail with an exception, it is possible to close a segment when a spliterator has been obtained but no thread
@@ -214,11 +215,11 @@
      * @param newOwner the new owner thread.
      * @return a new memory segment backed by the same underlying memory region as this segment,
      *      owned by {@code newOwner}.
      * @throws IllegalStateException if this segment is not <em>alive</em>, or if access occurs from a thread other than the
      * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different
-     * thread (see {@link #spliterator(SequenceLayout)}).
+     * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).
      * @throws NullPointerException if {@code newOwner == null}
      * @throws IllegalArgumentException if the segment is already a confined segment owner by {@code newOnwer}.
      * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.
      */
     MemorySegment withOwnerThread(Thread newOwner);
@@ -229,30 +230,31 @@
      */
     long byteSize();
 
     /**
      * Obtains a segment view with specific <a href="#access-modes">access modes</a>. Supported access modes are {@link #READ}, {@link #WRITE},
-     * {@link #CLOSE} and {@link #ACQUIRE}. It is generally not possible to go from a segment with stricter access modes
+     * {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}. It is generally not possible to go from a segment with stricter access modes
      * to one with less strict access modes. For instance, attempting to add {@link #WRITE} access mode to a read-only segment
      * will be met with an exception.
      * @param accessModes an ORed mask of zero or more access modes.
      * @return a segment view with specific access modes.
-     * @throws UnsupportedOperationException when {@code mask} is an access mask which is less strict than the one supported by this
-     * segment.
+     * @throws IllegalArgumentException when {@code mask} is an access mask which is less strict than the one supported by this
+     * segment, or when {@code mask} contains bits not associated with any of the supported access modes.
      */
     MemorySegment withAccessModes(int accessModes);
 
     /**
      * Does this segment support a given set of access modes?
      * @param accessModes an ORed mask of zero or more access modes.
      * @return true, if the access modes in {@code accessModes} are stricter than the ones supported by this segment.
+     * @throws IllegalArgumentException when {@code mask} contains bits not associated with any of the supported access modes.
      */
     boolean hasAccessModes(int accessModes);
 
     /**
      * Returns the <a href="#access-modes">access modes</a> associated with this segment; the result is represented as ORed values from
-     * {@link #READ}, {@link #WRITE}, {@link #CLOSE} and {@link #ACQUIRE}.
+     * {@link #READ}, {@link #WRITE}, {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}.
      * @return the access modes associated with this segment.
      */
     int accessModes();
 
     /**
@@ -392,10 +394,14 @@
     /**
      * Creates a new buffer memory segment that models the memory associated with the given byte
      * buffer. The segment starts relative to the buffer's position (inclusive)
      * and ends relative to the buffer's limit (exclusive).
      * <p>
+     * The segment will feature all <a href="#access-modes">access modes</a>, unless the given
+     * buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will
+     * not feature the {@link #WRITE} access mode.
+     * <p>
      * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains <em>reachable</em>
      * for the life-time of the segment.
      *
      * @param bb the byte buffer backing the buffer memory segment.
      * @return a new buffer memory segment.
@@ -406,11 +412,11 @@
 
     /**
      * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
      * <p>
      * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment.
+     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>.
      *
      * @param arr the primitive array backing the array memory segment.
      * @return a new array memory segment.
      */
     static MemorySegment ofArray(byte[] arr) {
@@ -419,11 +425,11 @@
 
     /**
      * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
      * <p>
      * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment.
+     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>.
      *
      * @param arr the primitive array backing the array memory segment.
      * @return a new array memory segment.
      */
     static MemorySegment ofArray(char[] arr) {
@@ -432,11 +438,11 @@
 
     /**
      * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
      * <p>
      * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment.
+     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>.
      *
      * @param arr the primitive array backing the array memory segment.
      * @return a new array memory segment.
      */
     static MemorySegment ofArray(short[] arr) {
@@ -445,11 +451,11 @@
 
     /**
      * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.
      * <p>
      * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment.
+     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>.
      *
      * @param arr the primitive array backing the array memory segment.
      * @return a new array memory segment.
      */
     static MemorySegment ofArray(int[] arr) {
@@ -458,11 +464,11 @@
 
     /**
      * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
      * <p>
      * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment.
+     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>.
      *
      * @param arr the primitive array backing the array memory segment.
      * @return a new array memory segment.
      */
     static MemorySegment ofArray(float[] arr) {
@@ -471,11 +477,11 @@
 
     /**
      * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
      * <p>
      * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment.
+     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>.
      *
      * @param arr the primitive array backing the array memory segment.
      * @return a new array memory segment.
      */
     static MemorySegment ofArray(long[] arr) {
@@ -484,11 +490,11 @@
 
     /**
      * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
      * <p>
      * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
-     * for the life-time of the segment.
+     * for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>.
      *
      * @param arr the primitive array backing the array memory segment.
      * @return a new array memory segment.
      */
     static MemorySegment ofArray(double[] arr) {
@@ -535,10 +541,14 @@
         return allocateNative(bytesSize, 1);
     }
 
     /**
      * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
+     * <p>
+     * The segment will feature all <a href="#access-modes">access modes</a>, unless the given mapping mode
+     * is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, in which case the segment will not feature
+     * the {@link #WRITE} access mode.
      *
      * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
      * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
      *
      * @param path the path to the file to memory map.
@@ -554,11 +564,11 @@
         return MappedMemorySegmentImpl.makeMappedSegment(path, bytesSize, mapMode);
     }
 
     /**
      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
-     * alignment constraint (in bytes).
+     * alignment constraint (in bytes). The segment will feature all <a href="#access-modes">access modes</a>.
      *
      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
      *
@@ -584,11 +594,11 @@
     /**
      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
-     * (often as a plain {@code long} value).
+     * (often as a plain {@code long} value). The segment will feature all <a href="#access-modes">access modes</a>.
      * <p>
      * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
      * restricted methods, and use safe and supported functionalities, where possible.
      *

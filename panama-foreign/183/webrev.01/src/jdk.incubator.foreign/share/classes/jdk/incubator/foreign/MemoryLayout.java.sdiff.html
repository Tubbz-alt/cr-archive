<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemoryHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemorySegment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
151 MemoryLayout newSeq = MemoryLayout.ofSequence(5,
152     MemoryLayout.ofStruct(
153         MemoryLayout.ofPaddingBits(32),
154         MemoryLayout.ofPaddingBits(32)
155 ));
156  * }&lt;/pre&gt;&lt;/blockquote&gt;
157  *
158  * Layout paths can feature one or more &lt;em&gt;free dimensions&lt;/em&gt;. For instance, a layout path traversing
159  * an unspecified sequence element (that is, where one of the path component was obtained with the
160  * {@link PathElement#sequenceElement()} method) features an additional free dimension, which will have to be bound at runtime.
161  * This is important when obtaining memory access var handle from layouts, as in the following code:
162  *
163  * &lt;blockquote&gt;&lt;pre&gt;{@code
164 VarHandle valueHandle = seq.map(int.class, PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
165  * }&lt;/pre&gt;&lt;/blockquote&gt;
166  *
167  * Since the layout path {@code seq} constructed in the above example features exactly one free dimension,
168  * it follows that the memory access var handle {@code valueHandle} will feature an extra {@code long}
169  * access coordinate.
170  *







171  * @apiNote In the future, if the Java language permits, {@link MemoryLayout}
172  * may become a {@code sealed} interface, which would prohibit subclassing except by
173  * explicitly permitted types.
174  *
175  * @implSpec
176  * Implementations of this class are immutable and thread-safe.
177  */
178 public interface MemoryLayout extends Constable {
179 
180     /**
181      * Returns an {@link Optional} containing the nominal descriptor for this
182      * layout, if one can be constructed, or an empty {@link Optional}
183      * if one cannot be constructed.
184      *
185      * @return An {@link Optional} containing the resulting nominal descriptor,
186      * or an empty {@link Optional} if one cannot be constructed.
187      */
188     @Override
189     Optional&lt;? extends DynamicConstantDesc&lt;? extends MemoryLayout&gt;&gt; describeConstable();
190 
</pre>
<hr />
<pre>
204      *
205      * @return the layout size, in bits.
206      * @throws UnsupportedOperationException if the layout is, or contains, a sequence layout with unspecified size (see {@link SequenceLayout}).
207      */
208     long bitSize();
209 
210     /**
211      * Computes the layout size, in bytes.
212      *
213      * @return the layout size, in bytes.
214      * @throws UnsupportedOperationException if the layout is, or contains, a sequence layout with unspecified size (see {@link SequenceLayout}),
215      * or if {@code bitSize()} is not a multiple of 8.
216      */
217     default long byteSize() {
218         return Utils.bitsToBytesOrThrow(bitSize(),
219                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte size; bit size is not a multiple of 8&quot;));
220     }
221 
222     /**
223      * Return the &lt;em&gt;name&lt;/em&gt; (if any) associated with this layout.





224      *
225      * @return the layout &lt;em&gt;name&lt;/em&gt; (if any).
226      * @see MemoryLayout#withName(String)
227      */
228     Optional&lt;String&gt; name();
229 
230     /**
231      * Creates a new layout which features the desired layout &lt;em&gt;name&lt;/em&gt;.





232      *
233      * @param name the layout name.
234      * @return a new layout which is the same as this layout, except for the &lt;em&gt;name&lt;/em&gt; associated to it.
235      * @see MemoryLayout#name()
236      */
237     MemoryLayout withName(String name);
238 
239     /**
240      * Returns the alignment constraint associated with this layout, expressed in bits. Layout alignment defines a power
241      * of two {@code A} which is the bit-wise alignment of the layout. If {@code A &lt;= 8} then {@code A/8} is the number of
242      * bytes that must be aligned for any pointer that correctly points to this layout. Thus:
243      *
244      * &lt;ul&gt;
245      * &lt;li&gt;{@code A=8} means unaligned (in the usual sense), which is common in packets.&lt;/li&gt;
246      * &lt;li&gt;{@code A=64} means word aligned (on LP64), {@code A=32} int aligned, {@code A=16} short aligned, etc.&lt;/li&gt;
247      * &lt;li&gt;{@code A=512} is the most strict alignment required by the x86/SV ABI (for AVX-512 data).&lt;/li&gt;
248      * &lt;/ul&gt;
249      *
250      * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),
251      * then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bits) associated with this layout.
</pre>
<hr />
<pre>
269      * then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bytes) associated with this layout.
270      *
271      * @return the layout alignment constraint, in bytes.
272      * @throws UnsupportedOperationException if {@code bitAlignment()} is not a multiple of 8.
273      */
274     default long byteAlignment() {
275         return Utils.bitsToBytesOrThrow(bitAlignment(),
276                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte alignment; bit alignment is not a multiple of 8&quot;));
277     }
278 
279     /**
280      * Creates a new layout which features the desired alignment constraint.
281      *
282      * @param bitAlignment the layout alignment constraint, expressed in bits.
283      * @return a new layout which is the same as this layout, except for the alignment constraint associated to it.
284      * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it&#39;s less than than 8.
285      */
286     MemoryLayout withBitAlignment(long bitAlignment);
287 
288     /**
<span class="line-modified">289      * Returns the attribute with the given name if it exists, or an empty optional</span>
290      *
<span class="line-modified">291      * @param name the name of the attribute</span>
<span class="line-modified">292      * @return the optional attribute</span>
293      */
294     Optional&lt;Constable&gt; attribute(String name);
295 
296     /**
<span class="line-modified">297      * Returns a new MemoryLayout with the given additional attribute</span>


298      *
<span class="line-modified">299      * @param name the name of the attribute</span>
<span class="line-modified">300      * @param value the value of the attribute</span>
<span class="line-modified">301      * @return the new MemoryLayout</span>
302      */
303     MemoryLayout withAttribute(String name, Constable value);
304 
305     /**
<span class="line-modified">306      * Returns a stream of the names of the attributes of this layout</span>
307      *
<span class="line-modified">308      * @return the stream of names</span>
309      */
310     Stream&lt;String&gt; attributes();
311 
312     /**
313      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
314      * layout.
315      *
316      * @apiNote if the layout path has one (or more) free dimensions,
317      * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.
318      *
319      * @param elements the layout path elements.
320      * @return The offset, in bits, of the layout selected by the layout path in {@code elements}.
321      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the
322      * layout path contains one or more path elements that select multiple sequence element indices
323      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).
324      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.
325      */
326     default long bitOffset(PathElement... elements) {
327         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset, EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);
328     }
</pre>
<hr />
<pre>
396      * (see {@link PathElement#sequenceElement(long)} and {@link PathElement#sequenceElement(long, long)}).
397      */
398     default MemoryLayout map(UnaryOperator&lt;MemoryLayout&gt; op, PathElement... elements) {
399         return computePathOp(LayoutPath.rootPath(this, l -&gt; 0L), path -&gt; path.map(op),
400                 EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE), elements);
401     }
402 
403     private static &lt;Z&gt; Z computePathOp(LayoutPath path, Function&lt;LayoutPath, Z&gt; finalizer,
404                                        Set&lt;LayoutPath.PathElementImpl.PathKind&gt; badKinds, PathElement... elements) {
405         for (PathElement e : elements) {
406             LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)e;
407             if (badKinds.contains(pathElem.kind())) {
408                 throw new IllegalArgumentException(String.format(&quot;Invalid %s selection in layout path&quot;, pathElem.kind().description()));
409             }
410             path = pathElem.apply(path);
411         }
412         return finalizer.apply(path);
413     }
414 
415     /**
<span class="line-modified">416      * Is this a padding layout (e.g. a layout created from {@link #ofPaddingBits(long)} ?</span>
417      * @return true, if this layout is a padding layout.
418      */
419     boolean isPadding();
420 
421     /**
422      * Instances of this class are used to form &lt;a href=&quot;MemoryLayout.html#layout-paths&quot;&gt;&lt;em&gt;layout paths&lt;/em&gt;&lt;/a&gt;. There
423      * are two kinds of path elements: &lt;em&gt;group path elements&lt;/em&gt; and &lt;em&gt;sequence path elements&lt;/em&gt;. Group
424      * path elements are used to select a given named member layout within a {@link GroupLayout}. Sequence
425      * path elements are used to select a sequence element layout within a {@link SequenceLayout}; selection
426      * of sequence element layout can be &lt;em&gt;explicit&lt;/em&gt; (see {@link PathElement#sequenceElement(long)}) or
427      * &lt;em&gt;implicit&lt;/em&gt; (see {@link PathElement#sequenceElement()}). When a path uses one or more implicit
428      * sequence path elements, it acquires additional &lt;em&gt;free dimensions&lt;/em&gt;.
429      * &lt;p&gt;
430      * Non-platform classes should not implement {@linkplain PathElement} directly.
431      *
432      * @apiNote In the future, if the Java language permits, {@link PathElement}
433      * may become a {@code sealed} interface, which would prohibit subclassing except by
434      * explicitly permitted types.
435      *
436      * @implSpec
</pre>
<hr />
<pre>
599 
600     /**
601      * Create a new &lt;em&gt;struct&lt;/em&gt; group layout with given member layouts.
602      *
603      * @param elements The member layouts of the &lt;em&gt;struct&lt;/em&gt; group layout.
604      * @return a new &lt;em&gt;struct&lt;/em&gt; group layout with given member layouts.
605      */
606     static GroupLayout ofStruct(MemoryLayout... elements) {
607         return new GroupLayout(GroupLayout.Kind.STRUCT, List.of(elements));
608     }
609 
610     /**
611      * Create a new &lt;em&gt;union&lt;/em&gt; group layout with given member layouts.
612      *
613      * @param elements The member layouts of the &lt;em&gt;union&lt;/em&gt; layout.
614      * @return a new &lt;em&gt;union&lt;/em&gt; group layout with given member layouts.
615      */
616     static GroupLayout ofUnion(MemoryLayout... elements) {
617         return new GroupLayout(GroupLayout.Kind.UNION, List.of(elements));
618     }





619 }
</pre>
</td>
<td>
<hr />
<pre>
151 MemoryLayout newSeq = MemoryLayout.ofSequence(5,
152     MemoryLayout.ofStruct(
153         MemoryLayout.ofPaddingBits(32),
154         MemoryLayout.ofPaddingBits(32)
155 ));
156  * }&lt;/pre&gt;&lt;/blockquote&gt;
157  *
158  * Layout paths can feature one or more &lt;em&gt;free dimensions&lt;/em&gt;. For instance, a layout path traversing
159  * an unspecified sequence element (that is, where one of the path component was obtained with the
160  * {@link PathElement#sequenceElement()} method) features an additional free dimension, which will have to be bound at runtime.
161  * This is important when obtaining memory access var handle from layouts, as in the following code:
162  *
163  * &lt;blockquote&gt;&lt;pre&gt;{@code
164 VarHandle valueHandle = seq.map(int.class, PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
165  * }&lt;/pre&gt;&lt;/blockquote&gt;
166  *
167  * Since the layout path {@code seq} constructed in the above example features exactly one free dimension,
168  * it follows that the memory access var handle {@code valueHandle} will feature an extra {@code long}
169  * access coordinate.
170  *
<span class="line-added">171  * &lt;h2&gt;Layout attributes&lt;/h2&gt;</span>
<span class="line-added">172  *</span>
<span class="line-added">173  * Layouts can be optionally associated with one or more &lt;em&gt;attributes&lt;/em&gt;. A layout attribute forms a &lt;em&gt;name/value&lt;/em&gt;</span>
<span class="line-added">174  * pair, where the name is a {@link String} and the value is a {@link Constable}. The most common form of layout attribute</span>
<span class="line-added">175  * is the &lt;em&gt;layout name&lt;/em&gt; (see {@link #LAYOUT_NAME}), a custom name that can be associated to memory layouts and that can be referred to when</span>
<span class="line-added">176  * constructing &lt;a href=&quot;MemoryLayout.html#layout-paths&quot;&gt;&lt;em&gt;layout paths&lt;/em&gt;&lt;/a&gt;.</span>
<span class="line-added">177  *</span>
178  * @apiNote In the future, if the Java language permits, {@link MemoryLayout}
179  * may become a {@code sealed} interface, which would prohibit subclassing except by
180  * explicitly permitted types.
181  *
182  * @implSpec
183  * Implementations of this class are immutable and thread-safe.
184  */
185 public interface MemoryLayout extends Constable {
186 
187     /**
188      * Returns an {@link Optional} containing the nominal descriptor for this
189      * layout, if one can be constructed, or an empty {@link Optional}
190      * if one cannot be constructed.
191      *
192      * @return An {@link Optional} containing the resulting nominal descriptor,
193      * or an empty {@link Optional} if one cannot be constructed.
194      */
195     @Override
196     Optional&lt;? extends DynamicConstantDesc&lt;? extends MemoryLayout&gt;&gt; describeConstable();
197 
</pre>
<hr />
<pre>
211      *
212      * @return the layout size, in bits.
213      * @throws UnsupportedOperationException if the layout is, or contains, a sequence layout with unspecified size (see {@link SequenceLayout}).
214      */
215     long bitSize();
216 
217     /**
218      * Computes the layout size, in bytes.
219      *
220      * @return the layout size, in bytes.
221      * @throws UnsupportedOperationException if the layout is, or contains, a sequence layout with unspecified size (see {@link SequenceLayout}),
222      * or if {@code bitSize()} is not a multiple of 8.
223      */
224     default long byteSize() {
225         return Utils.bitsToBytesOrThrow(bitSize(),
226                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte size; bit size is not a multiple of 8&quot;));
227     }
228 
229     /**
230      * Return the &lt;em&gt;name&lt;/em&gt; (if any) associated with this layout.
<span class="line-added">231      * &lt;p&gt;</span>
<span class="line-added">232      * This is equivalent to the following code:</span>
<span class="line-added">233      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">234     attribute(LAYOUT_NAME).map(String.class::cast);</span>
<span class="line-added">235      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
236      *
237      * @return the layout &lt;em&gt;name&lt;/em&gt; (if any).
238      * @see MemoryLayout#withName(String)
239      */
240     Optional&lt;String&gt; name();
241 
242     /**
243      * Creates a new layout which features the desired layout &lt;em&gt;name&lt;/em&gt;.
<span class="line-added">244      * &lt;p&gt;</span>
<span class="line-added">245      * This is equivalent to the following code:</span>
<span class="line-added">246      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">247     withAttribute(LAYOUT_NAME, name);</span>
<span class="line-added">248      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
249      *
250      * @param name the layout name.
251      * @return a new layout which is the same as this layout, except for the &lt;em&gt;name&lt;/em&gt; associated to it.
252      * @see MemoryLayout#name()
253      */
254     MemoryLayout withName(String name);
255 
256     /**
257      * Returns the alignment constraint associated with this layout, expressed in bits. Layout alignment defines a power
258      * of two {@code A} which is the bit-wise alignment of the layout. If {@code A &lt;= 8} then {@code A/8} is the number of
259      * bytes that must be aligned for any pointer that correctly points to this layout. Thus:
260      *
261      * &lt;ul&gt;
262      * &lt;li&gt;{@code A=8} means unaligned (in the usual sense), which is common in packets.&lt;/li&gt;
263      * &lt;li&gt;{@code A=64} means word aligned (on LP64), {@code A=32} int aligned, {@code A=16} short aligned, etc.&lt;/li&gt;
264      * &lt;li&gt;{@code A=512} is the most strict alignment required by the x86/SV ABI (for AVX-512 data).&lt;/li&gt;
265      * &lt;/ul&gt;
266      *
267      * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),
268      * then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bits) associated with this layout.
</pre>
<hr />
<pre>
286      * then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bytes) associated with this layout.
287      *
288      * @return the layout alignment constraint, in bytes.
289      * @throws UnsupportedOperationException if {@code bitAlignment()} is not a multiple of 8.
290      */
291     default long byteAlignment() {
292         return Utils.bitsToBytesOrThrow(bitAlignment(),
293                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte alignment; bit alignment is not a multiple of 8&quot;));
294     }
295 
296     /**
297      * Creates a new layout which features the desired alignment constraint.
298      *
299      * @param bitAlignment the layout alignment constraint, expressed in bits.
300      * @return a new layout which is the same as this layout, except for the alignment constraint associated to it.
301      * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it&#39;s less than than 8.
302      */
303     MemoryLayout withBitAlignment(long bitAlignment);
304 
305     /**
<span class="line-modified">306      * Returns the attribute with the given name (if it exists).</span>
307      *
<span class="line-modified">308      * @param name the attribute name</span>
<span class="line-modified">309      * @return the attribute with the given name (if it exists).</span>
310      */
311     Optional&lt;Constable&gt; attribute(String name);
312 
313     /**
<span class="line-modified">314      * Returns a new memory layout which features the same attributes as this layout, plus the newly specified attribute.</span>
<span class="line-added">315      * If this layout already contains an attribute with the same name, the existing attribute value is overwritten in the returned</span>
<span class="line-added">316      * layout.</span>
317      *
<span class="line-modified">318      * @param name the attribute name.</span>
<span class="line-modified">319      * @param value the attribute value.</span>
<span class="line-modified">320      * @return a new memory layout which features the same attributes as this layout, plus the newly specified attribute.</span>
321      */
322     MemoryLayout withAttribute(String name, Constable value);
323 
324     /**
<span class="line-modified">325      * Returns a stream of the attribute names associated with this layout.</span>
326      *
<span class="line-modified">327      * @return a stream of the attribute names associated with this layout.</span>
328      */
329     Stream&lt;String&gt; attributes();
330 
331     /**
332      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
333      * layout.
334      *
335      * @apiNote if the layout path has one (or more) free dimensions,
336      * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.
337      *
338      * @param elements the layout path elements.
339      * @return The offset, in bits, of the layout selected by the layout path in {@code elements}.
340      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the
341      * layout path contains one or more path elements that select multiple sequence element indices
342      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).
343      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.
344      */
345     default long bitOffset(PathElement... elements) {
346         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset, EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);
347     }
</pre>
<hr />
<pre>
415      * (see {@link PathElement#sequenceElement(long)} and {@link PathElement#sequenceElement(long, long)}).
416      */
417     default MemoryLayout map(UnaryOperator&lt;MemoryLayout&gt; op, PathElement... elements) {
418         return computePathOp(LayoutPath.rootPath(this, l -&gt; 0L), path -&gt; path.map(op),
419                 EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE), elements);
420     }
421 
422     private static &lt;Z&gt; Z computePathOp(LayoutPath path, Function&lt;LayoutPath, Z&gt; finalizer,
423                                        Set&lt;LayoutPath.PathElementImpl.PathKind&gt; badKinds, PathElement... elements) {
424         for (PathElement e : elements) {
425             LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)e;
426             if (badKinds.contains(pathElem.kind())) {
427                 throw new IllegalArgumentException(String.format(&quot;Invalid %s selection in layout path&quot;, pathElem.kind().description()));
428             }
429             path = pathElem.apply(path);
430         }
431         return finalizer.apply(path);
432     }
433 
434     /**
<span class="line-modified">435      * Is this a padding layout (e.g. a layout created from {@link #ofPaddingBits(long)}) ?</span>
436      * @return true, if this layout is a padding layout.
437      */
438     boolean isPadding();
439 
440     /**
441      * Instances of this class are used to form &lt;a href=&quot;MemoryLayout.html#layout-paths&quot;&gt;&lt;em&gt;layout paths&lt;/em&gt;&lt;/a&gt;. There
442      * are two kinds of path elements: &lt;em&gt;group path elements&lt;/em&gt; and &lt;em&gt;sequence path elements&lt;/em&gt;. Group
443      * path elements are used to select a given named member layout within a {@link GroupLayout}. Sequence
444      * path elements are used to select a sequence element layout within a {@link SequenceLayout}; selection
445      * of sequence element layout can be &lt;em&gt;explicit&lt;/em&gt; (see {@link PathElement#sequenceElement(long)}) or
446      * &lt;em&gt;implicit&lt;/em&gt; (see {@link PathElement#sequenceElement()}). When a path uses one or more implicit
447      * sequence path elements, it acquires additional &lt;em&gt;free dimensions&lt;/em&gt;.
448      * &lt;p&gt;
449      * Non-platform classes should not implement {@linkplain PathElement} directly.
450      *
451      * @apiNote In the future, if the Java language permits, {@link PathElement}
452      * may become a {@code sealed} interface, which would prohibit subclassing except by
453      * explicitly permitted types.
454      *
455      * @implSpec
</pre>
<hr />
<pre>
618 
619     /**
620      * Create a new &lt;em&gt;struct&lt;/em&gt; group layout with given member layouts.
621      *
622      * @param elements The member layouts of the &lt;em&gt;struct&lt;/em&gt; group layout.
623      * @return a new &lt;em&gt;struct&lt;/em&gt; group layout with given member layouts.
624      */
625     static GroupLayout ofStruct(MemoryLayout... elements) {
626         return new GroupLayout(GroupLayout.Kind.STRUCT, List.of(elements));
627     }
628 
629     /**
630      * Create a new &lt;em&gt;union&lt;/em&gt; group layout with given member layouts.
631      *
632      * @param elements The member layouts of the &lt;em&gt;union&lt;/em&gt; layout.
633      * @return a new &lt;em&gt;union&lt;/em&gt; group layout with given member layouts.
634      */
635     static GroupLayout ofUnion(MemoryLayout... elements) {
636         return new GroupLayout(GroupLayout.Kind.UNION, List.of(elements));
637     }
<span class="line-added">638 </span>
<span class="line-added">639     /**</span>
<span class="line-added">640      * Attribute name used to specify the &lt;em&gt;name&lt;/em&gt; property of a memory layout (see {@link #name()} and {@link #withName(String)}).</span>
<span class="line-added">641      */</span>
<span class="line-added">642     String LAYOUT_NAME = &quot;layout/name&quot;;</span>
643 }
</pre>
</td>
</tr>
</table>
<center><a href="MemoryHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemorySegment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
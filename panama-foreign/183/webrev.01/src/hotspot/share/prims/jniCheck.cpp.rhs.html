<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jniCheck.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jni.h&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;logging/log.hpp&quot;
  32 #include &quot;logging/logTag.hpp&quot;
  33 #include &quot;memory/allocation.inline.hpp&quot;
  34 #include &quot;memory/guardedMemory.hpp&quot;
  35 #include &quot;oops/instanceKlass.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;oops/symbol.hpp&quot;
  38 #include &quot;prims/jniCheck.hpp&quot;
  39 #include &quot;prims/jvm_misc.hpp&quot;
  40 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  41 #include &quot;runtime/handles.inline.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  44 #include &quot;runtime/jniHandles.inline.hpp&quot;
  45 #include &quot;runtime/thread.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  46 #include &quot;utilities/utf8.hpp&quot;</span>
  47 
  48 // Complain every extra number of unplanned local refs
  49 #define CHECK_JNI_LOCAL_REF_CAP_WARN_THRESHOLD 32
  50 
  51 // Heap objects are allowed to be directly referenced only in VM code,
  52 // not in native code.
  53 
  54 #define ASSERT_OOPS_ALLOWED                                          \
  55     assert(JavaThread::current()-&gt;thread_state() == _thread_in_vm,   \
  56            &quot;jniCheck examining oops in bad state.&quot;)
  57 
  58 
  59 // Execute the given block of source code with the thread in VM state.
  60 // To do this, transition from the NATIVE state to the VM state, execute
  61 // the code, and transtition back.  The ThreadInVMfromNative constructor
  62 // performs the transition to VM state, its destructor restores the
  63 // NATIVE state.
  64 
  65 #define IN_VM(source_code)   {                                         \
  66     {                                                                  \
  67       ThreadInVMfromNative __tiv(thr);                                 \
  68       source_code                                                      \
  69     }                                                                  \
  70   }
  71 
  72 
  73 /*
  74  * DECLARATIONS
  75  */
  76 
  77 static struct JNINativeInterface_ * unchecked_jni_NativeInterface;
  78 
  79 
  80 /*
  81  * MACRO DEFINITIONS
  82  */
  83 
  84 // All JNI checked functions here use JNI_ENTRY_CHECKED() instead of the
  85 // QUICK_ENTRY or LEAF variants found in jni.cpp.  This allows handles
  86 // to be created if a fatal error should occur.
  87 
  88 // Check for thread not attached to VM;  need to catch this before
  89 // assertions in the wrapper routines might fire
  90 
  91 // Check for env being the one value appropriate for this thread.
  92 
  93 #define JNI_ENTRY_CHECKED(result_type, header)                           \
  94 extern &quot;C&quot; {                                                             \
  95   result_type JNICALL header {                                           \
  96     JavaThread* thr = (JavaThread*) Thread::current_or_null();           \
  97     if (thr == NULL || !thr-&gt;is_Java_thread()) {                         \
  98       tty-&gt;print_cr(&quot;%s&quot;, fatal_using_jnienv_in_nonjava);                \
  99       os::abort(true);                                                   \
 100     }                                                                    \
 101     JNIEnv* xenv = thr-&gt;jni_environment();                               \
 102     if (env != xenv) {                                                   \
 103       NativeReportJNIFatalError(thr, warn_wrong_jnienv);                 \
 104     }                                                                    \
 105     VM_ENTRY_BASE(result_type, header, thr)
 106 
 107 
 108 #define UNCHECKED() (unchecked_jni_NativeInterface)
 109 
 110 static const char * warn_wrong_jnienv = &quot;Using JNIEnv in the wrong thread&quot;;
 111 static const char * warn_bad_class_descriptor1 = &quot;JNI FindClass received a bad class descriptor \&quot;&quot;;
 112 static const char * warn_bad_class_descriptor2 = &quot;\&quot;.  A correct class descriptor &quot; \
 113   &quot;has no leading \&quot;L\&quot; or trailing \&quot;;\&quot;.  Incorrect descriptors will not be accepted in future releases.&quot;;
 114 static const char * fatal_using_jnienv_in_nonjava = &quot;FATAL ERROR in native method: Using JNIEnv in non-Java thread&quot;;
 115 static const char * warn_other_function_in_critical = &quot;Warning: Calling other JNI functions in the scope of &quot; \
 116   &quot;Get/ReleasePrimitiveArrayCritical or Get/ReleaseStringCritical&quot;;
 117 static const char * fatal_bad_ref_to_jni = &quot;Bad global or local ref passed to JNI&quot;;
 118 static const char * fatal_received_null_class = &quot;JNI received a null class&quot;;
 119 static const char * fatal_class_not_a_class = &quot;JNI received a class argument that is not a class&quot;;
 120 static const char * fatal_class_not_a_throwable_class = &quot;JNI Throw or ThrowNew received a class argument that is not a Throwable or Throwable subclass&quot;;
 121 static const char * fatal_wrong_class_or_method = &quot;Wrong object class or methodID passed to JNI call&quot;;
 122 static const char * fatal_non_weak_method = &quot;non-weak methodID passed to JNI call&quot;;
 123 static const char * fatal_unknown_array_object = &quot;Unknown array object passed to JNI array operations&quot;;
 124 static const char * fatal_object_array_expected = &quot;Object array expected but not received for JNI array operation&quot;;
 125 static const char * fatal_prim_type_array_expected = &quot;Primitive type array expected but not received for JNI array operation&quot;;
 126 static const char * fatal_non_array  = &quot;Non-array passed to JNI array operations&quot;;
 127 static const char * fatal_element_type_mismatch = &quot;Array element type mismatch in JNI&quot;;
 128 static const char * fatal_should_be_static = &quot;Non-static field ID passed to JNI&quot;;
 129 static const char * fatal_wrong_static_field = &quot;Wrong static field ID passed to JNI&quot;;
 130 static const char * fatal_static_field_not_found = &quot;Static field not found in JNI get/set field operations&quot;;
 131 static const char * fatal_static_field_mismatch = &quot;Field type (static) mismatch in JNI get/set field operations&quot;;
 132 static const char * fatal_should_be_nonstatic = &quot;Static field ID passed to JNI&quot;;
 133 static const char * fatal_null_object = &quot;Null object passed to JNI&quot;;
 134 static const char * fatal_wrong_field = &quot;Wrong field ID passed to JNI&quot;;
 135 static const char * fatal_instance_field_not_found = &quot;Instance field not found in JNI get/set field operations&quot;;
 136 static const char * fatal_instance_field_mismatch = &quot;Field type (instance) mismatch in JNI get/set field operations&quot;;
 137 static const char * fatal_non_string = &quot;JNI string operation received a non-string&quot;;
<a name="3" id="anc3"></a><span class="line-added"> 138 static const char * fatal_non_utf8_class_name1 = &quot;JNI class name is not a valid UTF8 string \&quot;&quot;;</span>
<span class="line-added"> 139 static const char * fatal_non_utf8_class_name2 = &quot;\&quot;&quot;;</span>
 140 
 141 
 142 // When in VM state:
 143 static void ReportJNIWarning(JavaThread* thr, const char *msg) {
 144   tty-&gt;print_cr(&quot;WARNING in native method: %s&quot;, msg);
 145   thr-&gt;print_stack();
 146 }
 147 
 148 // When in NATIVE state:
 149 static void NativeReportJNIFatalError(JavaThread* thr, const char *msg) {
 150   IN_VM(
 151     ReportJNIFatalError(thr, msg);
 152   )
 153 }
 154 
 155 static void NativeReportJNIWarning(JavaThread* thr, const char *msg) {
 156   IN_VM(
 157     ReportJNIWarning(thr, msg);
 158   )
 159 }
 160 
 161 
 162 
 163 
 164 /*
 165  * SUPPORT FUNCTIONS
 166  */
 167 
 168 /**
 169  * Check whether or not a programmer has actually checked for exceptions. According
 170  * to the JNI Specification (&quot;jni/spec/design.html#java_exceptions&quot;):
 171  *
 172  * There are two cases where the programmer needs to check for exceptions without
 173  * being able to first check an error code:
 174  *
 175  * - The JNI functions that invoke a Java method return the result of the Java method.
 176  * The programmer must call ExceptionOccurred() to check for possible exceptions
 177  * that occurred during the execution of the Java method.
 178  *
 179  * - Some of the JNI array access functions do not return an error code, but may
 180  * throw an ArrayIndexOutOfBoundsException or ArrayStoreException.
 181  *
 182  * In all other cases, a non-error return value guarantees that no exceptions have been thrown.
 183  *
 184  * Programmers often defend against ArrayIndexOutOfBoundsException, so warning
 185  * for these functions would be pedantic.
 186  */
 187 static inline void
 188 check_pending_exception(JavaThread* thr) {
 189   if (thr-&gt;has_pending_exception()) {
 190     NativeReportJNIWarning(thr, &quot;JNI call made with exception pending&quot;);
 191   }
 192   if (thr-&gt;is_pending_jni_exception_check()) {
 193     IN_VM(
 194       tty-&gt;print_cr(&quot;WARNING in native method: JNI call made without checking exceptions when required to from %s&quot;,
 195         thr-&gt;get_pending_jni_exception_check());
 196       thr-&gt;print_stack();
 197     )
 198     thr-&gt;clear_pending_jni_exception_check(); // Just complain once
 199   }
 200 }
 201 
 202 /**
 203  * Add to the planned number of handles. I.e. plus current live &amp; warning threshold
 204  */
 205 static inline void
 206 add_planned_handle_capacity(JNIHandleBlock* handles, size_t capacity) {
 207   handles-&gt;set_planned_capacity(capacity +
 208                                 handles-&gt;get_number_of_live_handles() +
 209                                 CHECK_JNI_LOCAL_REF_CAP_WARN_THRESHOLD);
 210 }
 211 
 212 
 213 static inline void
 214 functionEnterCritical(JavaThread* thr)
 215 {
 216   check_pending_exception(thr);
 217 }
 218 
 219 static inline void
 220 functionEnterCriticalExceptionAllowed(JavaThread* thr)
 221 {
 222 }
 223 
 224 static inline void
 225 functionEnter(JavaThread* thr)
 226 {
 227   if (thr-&gt;in_critical()) {
 228     tty-&gt;print_cr(&quot;%s&quot;, warn_other_function_in_critical);
 229   }
 230   check_pending_exception(thr);
 231 }
 232 
 233 static inline void
 234 functionEnterExceptionAllowed(JavaThread* thr)
 235 {
 236   if (thr-&gt;in_critical()) {
 237     tty-&gt;print_cr(&quot;%s&quot;, warn_other_function_in_critical);
 238   }
 239 }
 240 
 241 static inline void
 242 functionExit(JavaThread* thr)
 243 {
 244   JNIHandleBlock* handles = thr-&gt;active_handles();
 245   size_t planned_capacity = handles-&gt;get_planned_capacity();
 246   size_t live_handles = handles-&gt;get_number_of_live_handles();
 247   if (live_handles &gt; planned_capacity) {
 248     IN_VM(
 249       tty-&gt;print_cr(&quot;WARNING: JNI local refs: &quot; SIZE_FORMAT &quot;, exceeds capacity: &quot; SIZE_FORMAT,
 250                     live_handles, planned_capacity);
 251       thr-&gt;print_stack();
 252     )
 253     // Complain just the once, reset to current + warn threshold
 254     add_planned_handle_capacity(handles, 0);
 255   }
 256 }
 257 
 258 static inline void
 259 checkStaticFieldID(JavaThread* thr, jfieldID fid, jclass cls, int ftype)
 260 {
 261   fieldDescriptor fd;
 262 
 263   /* make sure it is a static field */
 264   if (!jfieldIDWorkaround::is_static_jfieldID(fid))
 265     ReportJNIFatalError(thr, fatal_should_be_static);
 266 
 267   /* validate the class being passed */
 268   ASSERT_OOPS_ALLOWED;
 269   Klass* k_oop = jniCheck::validate_class(thr, cls, false);
 270 
 271   /* check for proper subclass hierarchy */
 272   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fid);
 273   Klass* f_oop = id-&gt;holder();
 274   if (!k_oop-&gt;is_subtype_of(f_oop))
 275     ReportJNIFatalError(thr, fatal_wrong_static_field);
 276 
 277   /* check for proper field type */
 278   if (!id-&gt;find_local_field(&amp;fd))
 279     ReportJNIFatalError(thr, fatal_static_field_not_found);
 280   if ((fd.field_type() != ftype) &amp;&amp;
 281       !(fd.field_type() == T_ARRAY &amp;&amp; ftype == T_OBJECT)) {
 282     ReportJNIFatalError(thr, fatal_static_field_mismatch);
 283   }
 284 }
 285 
 286 static inline void
 287 checkInstanceFieldID(JavaThread* thr, jfieldID fid, jobject obj, int ftype)
 288 {
 289   fieldDescriptor fd;
 290 
 291   /* make sure it is an instance field */
 292   if (jfieldIDWorkaround::is_static_jfieldID(fid))
 293     ReportJNIFatalError(thr, fatal_should_be_nonstatic);
 294 
 295   /* validate the object being passed and then get its class */
 296   ASSERT_OOPS_ALLOWED;
 297   oop oopObj = jniCheck::validate_object(thr, obj);
 298   if (oopObj == NULL) {
 299     ReportJNIFatalError(thr, fatal_null_object);
 300   }
 301   Klass* k_oop = oopObj-&gt;klass();
 302 
 303   if (!jfieldIDWorkaround::is_valid_jfieldID(k_oop, fid)) {
 304     ReportJNIFatalError(thr, fatal_wrong_field);
 305   }
 306 
 307   /* make sure the field exists */
 308   int offset = jfieldIDWorkaround::from_instance_jfieldID(k_oop, fid);
 309   if (!InstanceKlass::cast(k_oop)-&gt;contains_field_offset(offset))
 310     ReportJNIFatalError(thr, fatal_wrong_field);
 311 
 312   /* check for proper field type */
 313   if (!InstanceKlass::cast(k_oop)-&gt;find_field_from_offset(offset,
 314                                                               false, &amp;fd))
 315     ReportJNIFatalError(thr, fatal_instance_field_not_found);
 316 
 317   if ((fd.field_type() != ftype) &amp;&amp;
 318       !(fd.field_type() == T_ARRAY &amp;&amp; ftype == T_OBJECT)) {
 319     ReportJNIFatalError(thr, fatal_instance_field_mismatch);
 320   }
 321 }
 322 
 323 static inline void
 324 checkString(JavaThread* thr, jstring js)
 325 {
 326   ASSERT_OOPS_ALLOWED;
 327   oop s = jniCheck::validate_object(thr, js);
 328   if ((s == NULL) || !java_lang_String::is_instance(s))
 329     ReportJNIFatalError(thr, fatal_non_string);
 330 }
 331 
 332 static inline arrayOop
 333 check_is_array(JavaThread* thr, jarray jArray)
 334 {
 335   ASSERT_OOPS_ALLOWED;
 336   arrayOop aOop;
 337 
 338   aOop = (arrayOop)jniCheck::validate_object(thr, jArray);
 339   if (aOop == NULL || !aOop-&gt;is_array()) {
 340     ReportJNIFatalError(thr, fatal_non_array);
 341   }
 342   return aOop;
 343 }
 344 
 345 static inline arrayOop
 346 check_is_primitive_array(JavaThread* thr, jarray jArray) {
 347   arrayOop aOop = check_is_array(thr, jArray);
 348 
 349   if (!aOop-&gt;is_typeArray()) {
 350      ReportJNIFatalError(thr, fatal_prim_type_array_expected);
 351   }
 352   return aOop;
 353 }
 354 
 355 static inline void
 356 check_primitive_array_type(JavaThread* thr, jarray jArray, BasicType elementType)
 357 {
 358   BasicType array_type;
 359   arrayOop aOop;
 360 
 361   aOop = check_is_primitive_array(thr, jArray);
 362   array_type = TypeArrayKlass::cast(aOop-&gt;klass())-&gt;element_type();
 363   if (array_type != elementType) {
 364     ReportJNIFatalError(thr, fatal_element_type_mismatch);
 365   }
 366 }
 367 
 368 static inline void
 369 check_is_obj_array(JavaThread* thr, jarray jArray) {
 370   arrayOop aOop = check_is_array(thr, jArray);
 371   if (!aOop-&gt;is_objArray()) {
 372     ReportJNIFatalError(thr, fatal_object_array_expected);
 373   }
 374 }
 375 
 376 /*
 377  * Copy and wrap array elements for bounds checking.
 378  * Remember the original elements (GuardedMemory::get_tag())
 379  */
 380 static void* check_jni_wrap_copy_array(JavaThread* thr, jarray array,
 381     void* orig_elements) {
 382   void* result;
 383   IN_VM(
 384     oop a = JNIHandles::resolve_non_null(array);
 385     size_t len = arrayOop(a)-&gt;length() &lt;&lt;
 386         TypeArrayKlass::cast(a-&gt;klass())-&gt;log2_element_size();
 387     result = GuardedMemory::wrap_copy(orig_elements, len, orig_elements);
 388   )
 389   return result;
 390 }
 391 
 392 static void* check_wrapped_array(JavaThread* thr, const char* fn_name,
 393     void* obj, void* carray, size_t* rsz) {
 394   if (carray == NULL) {
 395     tty-&gt;print_cr(&quot;%s: elements vector NULL&quot; PTR_FORMAT, fn_name, p2i(obj));
 396     NativeReportJNIFatalError(thr, &quot;Elements vector NULL&quot;);
 397   }
 398   GuardedMemory guarded(carray);
 399   void* orig_result = guarded.get_tag();
 400   if (!guarded.verify_guards()) {
 401     tty-&gt;print_cr(&quot;ReleasePrimitiveArrayCritical: release array failed bounds &quot;
 402         &quot;check, incorrect pointer returned ? array: &quot; PTR_FORMAT &quot; carray: &quot;
 403         PTR_FORMAT, p2i(obj), p2i(carray));
 404     guarded.print_on(tty);
 405     NativeReportJNIFatalError(thr, &quot;ReleasePrimitiveArrayCritical: &quot;
 406         &quot;failed bounds check&quot;);
 407   }
 408   if (orig_result == NULL) {
 409     tty-&gt;print_cr(&quot;ReleasePrimitiveArrayCritical: unrecognized elements. array: &quot;
 410         PTR_FORMAT &quot; carray: &quot; PTR_FORMAT, p2i(obj), p2i(carray));
 411     guarded.print_on(tty);
 412     NativeReportJNIFatalError(thr, &quot;ReleasePrimitiveArrayCritical: &quot;
 413         &quot;unrecognized elements&quot;);
 414   }
 415   if (rsz != NULL) {
 416     *rsz = guarded.get_user_size();
 417   }
 418   return orig_result;
 419 }
 420 
 421 static void* check_wrapped_array_release(JavaThread* thr, const char* fn_name,
 422     void* obj, void* carray, jint mode) {
 423   size_t sz;
 424   void* orig_result = check_wrapped_array(thr, fn_name, obj, carray, &amp;sz);
 425   switch (mode) {
 426   // As we never make copies, mode 0 and JNI_COMMIT are the same.
 427   case 0:
 428   case JNI_COMMIT:
 429     memcpy(orig_result, carray, sz);
 430     break;
 431   case JNI_ABORT:
 432     break;
 433   default:
 434     tty-&gt;print_cr(&quot;%s: Unrecognized mode %i releasing array &quot;
 435         PTR_FORMAT &quot; elements &quot; PTR_FORMAT, fn_name, mode, p2i(obj), p2i(carray));
 436     NativeReportJNIFatalError(thr, &quot;Unrecognized array release mode&quot;);
 437   }
 438   // We always need to release the copy we made with GuardedMemory
 439   GuardedMemory::free_copy(carray);
 440   return orig_result;
 441 }
 442 
 443 oop jniCheck::validate_handle(JavaThread* thr, jobject obj) {
 444   if ((obj != NULL) &amp;&amp; (JNIHandles::handle_type(thr, obj) != JNIInvalidRefType)) {
 445     ASSERT_OOPS_ALLOWED;
 446     return JNIHandles::resolve_external_guard(obj);
 447   }
 448   ReportJNIFatalError(thr, fatal_bad_ref_to_jni);
 449   return NULL;
 450 }
 451 
 452 
 453 Method* jniCheck::validate_jmethod_id(JavaThread* thr, jmethodID method_id) {
 454   ASSERT_OOPS_ALLOWED;
 455   // do the fast jmethodID check first
 456   Method* m = Method::checked_resolve_jmethod_id(method_id);
 457   if (m == NULL) {
 458     ReportJNIFatalError(thr, fatal_wrong_class_or_method);
 459   }
 460   // jmethodIDs are handles in the class loader data,
 461   // but that can be expensive so check it last
 462   else if (!Method::is_method_id(method_id)) {
 463     ReportJNIFatalError(thr, fatal_non_weak_method);
 464   }
 465   return m;
 466 }
 467 
 468 
 469 oop jniCheck::validate_object(JavaThread* thr, jobject obj) {
 470   if (obj == NULL) return NULL;
 471   ASSERT_OOPS_ALLOWED;
 472   oop oopObj = jniCheck::validate_handle(thr, obj);
 473   if (oopObj == NULL) {
 474     ReportJNIFatalError(thr, fatal_bad_ref_to_jni);
 475   }
 476   return oopObj;
 477 }
 478 
 479 // Warn if a class descriptor is in decorated form; class descriptors
 480 // passed to JNI findClass should not be decorated unless they are
 481 // array descriptors.
 482 void jniCheck::validate_class_descriptor(JavaThread* thr, const char* name) {
 483   if (name == NULL) return;  // implementation accepts NULL so just return
 484 
 485   size_t len = strlen(name);
 486 
 487   if (len &gt;= 2 &amp;&amp;
 488       name[0] == JVM_SIGNATURE_CLASS &amp;&amp;            // &#39;L&#39;
 489       name[len-1] == JVM_SIGNATURE_ENDCLASS ) {    // &#39;;&#39;
 490     char msg[JVM_MAXPATHLEN];
 491     jio_snprintf(msg, JVM_MAXPATHLEN, &quot;%s%s%s&quot;,
 492                  warn_bad_class_descriptor1, name, warn_bad_class_descriptor2);
 493     ReportJNIWarning(thr, msg);
 494   }
<a name="4" id="anc4"></a><span class="line-added"> 495 </span>
<span class="line-added"> 496   // Verify that the class name given is a valid utf8 string</span>
<span class="line-added"> 497   if (!UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false)) {</span>
<span class="line-added"> 498     char msg[JVM_MAXPATHLEN];</span>
<span class="line-added"> 499     jio_snprintf(msg, JVM_MAXPATHLEN, &quot;%s%s%s&quot;, fatal_non_utf8_class_name1, name, fatal_non_utf8_class_name2);</span>
<span class="line-added"> 500     ReportJNIFatalError(thr, msg);</span>
<span class="line-added"> 501   }</span>
 502 }
 503 
 504 Klass* jniCheck::validate_class(JavaThread* thr, jclass clazz, bool allow_primitive) {
 505   ASSERT_OOPS_ALLOWED;
 506   oop mirror = jniCheck::validate_handle(thr, clazz);
 507   if (mirror == NULL) {
 508     ReportJNIFatalError(thr, fatal_received_null_class);
 509   }
 510 
 511   if (mirror-&gt;klass() != SystemDictionary::Class_klass()) {
 512     ReportJNIFatalError(thr, fatal_class_not_a_class);
 513   }
 514 
 515   Klass* k = java_lang_Class::as_Klass(mirror);
 516   // Make allowances for primitive classes ...
 517   if (!(k != NULL || (allow_primitive &amp;&amp; java_lang_Class::is_primitive(mirror)))) {
 518     ReportJNIFatalError(thr, fatal_class_not_a_class);
 519   }
 520   return k;
 521 }
 522 
 523 void jniCheck::validate_throwable_klass(JavaThread* thr, Klass* klass) {
 524   ASSERT_OOPS_ALLOWED;
 525   assert(klass != NULL, &quot;klass argument must have a value&quot;);
 526 
 527   if (!klass-&gt;is_instance_klass() ||
 528       !klass-&gt;is_subclass_of(SystemDictionary::Throwable_klass())) {
 529     ReportJNIFatalError(thr, fatal_class_not_a_throwable_class);
 530   }
 531 }
 532 
 533 void jniCheck::validate_call(JavaThread* thr, jclass clazz, jmethodID method_id, jobject obj) {
 534   ASSERT_OOPS_ALLOWED;
 535   Method* m = jniCheck::validate_jmethod_id(thr, method_id);
 536   InstanceKlass* holder = m-&gt;method_holder();
 537 
 538   if (clazz != NULL) {
 539     Klass* k = jniCheck::validate_class(thr, clazz, false);
 540     // Check that method is in the class, must be InstanceKlass
 541     if (!InstanceKlass::cast(k)-&gt;is_subtype_of(holder)) {
 542       ReportJNIFatalError(thr, fatal_wrong_class_or_method);
 543     }
 544   }
 545 
 546   if (obj != NULL) {
 547     oop recv = jniCheck::validate_object(thr, obj);
 548     assert(recv != NULL, &quot;validate_object checks that&quot;);
 549     Klass* rk = recv-&gt;klass();
 550 
 551     // Check that the object is a subtype of method holder too.
 552     if (!rk-&gt;is_subtype_of(holder)) {
 553       ReportJNIFatalError(thr, fatal_wrong_class_or_method);
 554     }
 555   }
 556 }
 557 
 558 
 559 /*
 560  * IMPLEMENTATION OF FUNCTIONS IN CHECKED TABLE
 561  */
 562 
 563 JNI_ENTRY_CHECKED(jclass,
 564   checked_jni_DefineClass(JNIEnv *env,
 565                           const char *name,
 566                           jobject loader,
 567                           const jbyte *buf,
 568                           jsize len))
 569     functionEnter(thr);
 570     IN_VM(
 571       jniCheck::validate_object(thr, loader);
 572     )
 573     jclass result = UNCHECKED()-&gt;DefineClass(env, name, loader, buf, len);
 574     functionExit(thr);
 575     return result;
 576 JNI_END
 577 
 578 JNI_ENTRY_CHECKED(jclass,
 579   checked_jni_FindClass(JNIEnv *env,
 580                         const char *name))
 581     functionEnter(thr);
 582     IN_VM(
 583       jniCheck::validate_class_descriptor(thr, name);
 584     )
 585     jclass result = UNCHECKED()-&gt;FindClass(env, name);
 586     functionExit(thr);
 587     return result;
 588 JNI_END
 589 
 590 JNI_ENTRY_CHECKED(jmethodID,
 591   checked_jni_FromReflectedMethod(JNIEnv *env,
 592                                   jobject method))
 593     functionEnter(thr);
 594     IN_VM(
 595       jniCheck::validate_object(thr, method);
 596     )
 597     jmethodID result = UNCHECKED()-&gt;FromReflectedMethod(env, method);
 598     functionExit(thr);
 599     return result;
 600 JNI_END
 601 
 602 JNI_ENTRY_CHECKED(jfieldID,
 603   checked_jni_FromReflectedField(JNIEnv *env,
 604                                  jobject field))
 605     functionEnter(thr);
 606     IN_VM(
 607       jniCheck::validate_object(thr, field);
 608     )
 609     jfieldID result = UNCHECKED()-&gt;FromReflectedField(env, field);
 610     functionExit(thr);
 611     return result;
 612 JNI_END
 613 
 614 JNI_ENTRY_CHECKED(jobject,
 615   checked_jni_ToReflectedMethod(JNIEnv *env,
 616                                 jclass cls,
 617                                 jmethodID methodID,
 618                                 jboolean isStatic))
 619     functionEnter(thr);
 620     IN_VM(
 621       jniCheck::validate_call(thr, cls, methodID);
 622     )
 623     jobject result = UNCHECKED()-&gt;ToReflectedMethod(env, cls, methodID,
 624                                                     isStatic);
 625     functionExit(thr);
 626     return result;
 627 JNI_END
 628 
 629 JNI_ENTRY_CHECKED(jclass,
 630   checked_jni_GetSuperclass(JNIEnv *env,
 631                             jclass sub))
 632     functionEnter(thr);
 633     IN_VM(
 634       jniCheck::validate_class(thr, sub, true);
 635     )
 636     jclass result = UNCHECKED()-&gt;GetSuperclass(env, sub);
 637     functionExit(thr);
 638     return result;
 639 JNI_END
 640 
 641 JNI_ENTRY_CHECKED(jboolean,
 642   checked_jni_IsAssignableFrom(JNIEnv *env,
 643                                jclass sub,
 644                                jclass sup))
 645     functionEnter(thr);
 646     IN_VM(
 647       jniCheck::validate_class(thr, sub, true);
 648       jniCheck::validate_class(thr, sup, true);
 649     )
 650     jboolean result = UNCHECKED()-&gt;IsAssignableFrom(env, sub, sup);
 651     functionExit(thr);
 652     return result;
 653 JNI_END
 654 
 655 JNI_ENTRY_CHECKED(jobject,
 656   checked_jni_ToReflectedField(JNIEnv *env,
 657                                jclass cls,
 658                                jfieldID fieldID,
 659                                jboolean isStatic))
 660     functionEnter(thr);
 661     IN_VM(
 662       jniCheck::validate_class(thr, cls, false);
 663     )
 664     jobject result = UNCHECKED()-&gt;ToReflectedField(env, cls, fieldID,
 665                                                    isStatic);
 666     functionExit(thr);
 667     return result;
 668 JNI_END
 669 
 670 JNI_ENTRY_CHECKED(jint,
 671   checked_jni_Throw(JNIEnv *env,
 672                     jthrowable obj))
 673     functionEnter(thr);
 674     IN_VM(
 675       oop oopObj = jniCheck::validate_object(thr, obj);
 676       if (oopObj == NULL) {
 677         // Unchecked Throw tolerates a NULL obj, so just warn
 678         ReportJNIWarning(thr, &quot;JNI Throw called with NULL throwable&quot;);
 679       } else {
 680         jniCheck::validate_throwable_klass(thr, oopObj-&gt;klass());
 681       }
 682     )
 683     jint result = UNCHECKED()-&gt;Throw(env, obj);
 684     functionExit(thr);
 685     return result;
 686 JNI_END
 687 
 688 JNI_ENTRY_CHECKED(jint,
 689   checked_jni_ThrowNew(JNIEnv *env,
 690                        jclass clazz,
 691                        const char *msg))
 692     functionEnter(thr);
 693     IN_VM(
 694       Klass* k = jniCheck::validate_class(thr, clazz, false);
 695       assert(k != NULL, &quot;validate_class shouldn&#39;t return NULL Klass*&quot;);
 696       jniCheck::validate_throwable_klass(thr, k);
 697     )
 698     jint result = UNCHECKED()-&gt;ThrowNew(env, clazz, msg);
 699     functionExit(thr);
 700     return result;
 701 JNI_END
 702 
 703 JNI_ENTRY_CHECKED(jthrowable,
 704   checked_jni_ExceptionOccurred(JNIEnv *env))
 705     thr-&gt;clear_pending_jni_exception_check();
 706     functionEnterExceptionAllowed(thr);
 707     jthrowable result = UNCHECKED()-&gt;ExceptionOccurred(env);
 708     functionExit(thr);
 709     return result;
 710 JNI_END
 711 
 712 JNI_ENTRY_CHECKED(void,
 713   checked_jni_ExceptionDescribe(JNIEnv *env))
 714     functionEnterExceptionAllowed(thr);
 715     UNCHECKED()-&gt;ExceptionDescribe(env);
 716     functionExit(thr);
 717 JNI_END
 718 
 719 JNI_ENTRY_CHECKED(void,
 720   checked_jni_ExceptionClear(JNIEnv *env))
 721     thr-&gt;clear_pending_jni_exception_check();
 722     functionEnterExceptionAllowed(thr);
 723     UNCHECKED()-&gt;ExceptionClear(env);
 724     functionExit(thr);
 725 JNI_END
 726 
 727 JNI_ENTRY_CHECKED(void,
 728   checked_jni_FatalError(JNIEnv *env,
 729                          const char *msg))
 730     thr-&gt;clear_pending_jni_exception_check();
 731     functionEnter(thr);
 732     UNCHECKED()-&gt;FatalError(env, msg);
 733     functionExit(thr);
 734 JNI_END
 735 
 736 JNI_ENTRY_CHECKED(jint,
 737   checked_jni_PushLocalFrame(JNIEnv *env,
 738                              jint capacity))
 739     functionEnterExceptionAllowed(thr);
 740     if (capacity &lt; 0)
 741       NativeReportJNIFatalError(thr, &quot;negative capacity&quot;);
 742     jint result = UNCHECKED()-&gt;PushLocalFrame(env, capacity);
 743     if (result == JNI_OK) {
 744       add_planned_handle_capacity(thr-&gt;active_handles(), capacity);
 745     }
 746     functionExit(thr);
 747     return result;
 748 JNI_END
 749 
 750 JNI_ENTRY_CHECKED(jobject,
 751   checked_jni_PopLocalFrame(JNIEnv *env,
 752                             jobject result))
 753     functionEnterExceptionAllowed(thr);
 754     jobject res = UNCHECKED()-&gt;PopLocalFrame(env, result);
 755     functionExit(thr);
 756     return res;
 757 JNI_END
 758 
 759 JNI_ENTRY_CHECKED(jobject,
 760   checked_jni_NewGlobalRef(JNIEnv *env,
 761                            jobject lobj))
 762     functionEnter(thr);
 763     IN_VM(
 764       if (lobj != NULL) {
 765         jniCheck::validate_handle(thr, lobj);
 766       }
 767     )
 768     jobject result = UNCHECKED()-&gt;NewGlobalRef(env,lobj);
 769     functionExit(thr);
 770     return result;
 771 JNI_END
 772 
 773 JNI_ENTRY_CHECKED(void,
 774   checked_jni_DeleteGlobalRef(JNIEnv *env,
 775                               jobject gref))
 776     functionEnterExceptionAllowed(thr);
 777     IN_VM(
 778       jniCheck::validate_object(thr, gref);
 779       if (gref &amp;&amp; !JNIHandles::is_global_handle(gref)) {
 780         ReportJNIFatalError(thr,
 781             &quot;Invalid global JNI handle passed to DeleteGlobalRef&quot;);
 782       }
 783     )
 784     UNCHECKED()-&gt;DeleteGlobalRef(env,gref);
 785     functionExit(thr);
 786 JNI_END
 787 
 788 JNI_ENTRY_CHECKED(void,
 789   checked_jni_DeleteLocalRef(JNIEnv *env,
 790                              jobject obj))
 791     functionEnterExceptionAllowed(thr);
 792     IN_VM(
 793       jniCheck::validate_object(thr, obj);
 794       if (obj &amp;&amp; !(JNIHandles::is_local_handle(thr, obj) ||
 795                    JNIHandles::is_frame_handle(thr, obj)))
 796         ReportJNIFatalError(thr,
 797             &quot;Invalid local JNI handle passed to DeleteLocalRef&quot;);
 798     )
 799     UNCHECKED()-&gt;DeleteLocalRef(env, obj);
 800     functionExit(thr);
 801 JNI_END
 802 
 803 JNI_ENTRY_CHECKED(jboolean,
 804   checked_jni_IsSameObject(JNIEnv *env,
 805                            jobject obj1,
 806                            jobject obj2))
 807     functionEnterExceptionAllowed(thr);
 808     IN_VM(
 809       /* This JNI function can be used to compare weak global references
 810        * to NULL objects. If the handles are valid, but contain NULL,
 811        * then don&#39;t attempt to validate the object.
 812        */
 813       if (obj1 != NULL &amp;&amp; jniCheck::validate_handle(thr, obj1) != NULL) {
 814         jniCheck::validate_object(thr, obj1);
 815       }
 816       if (obj2 != NULL &amp;&amp; jniCheck::validate_handle(thr, obj2) != NULL) {
 817         jniCheck::validate_object(thr, obj2);
 818       }
 819     )
 820     jboolean result = UNCHECKED()-&gt;IsSameObject(env,obj1,obj2);
 821     functionExit(thr);
 822     return result;
 823 JNI_END
 824 
 825 JNI_ENTRY_CHECKED(jobject,
 826   checked_jni_NewLocalRef(JNIEnv *env,
 827                           jobject ref))
 828     functionEnter(thr);
 829     IN_VM(
 830       if (ref != NULL) {
 831         jniCheck::validate_handle(thr, ref);
 832       }
 833     )
 834     jobject result = UNCHECKED()-&gt;NewLocalRef(env, ref);
 835     functionExit(thr);
 836     return result;
 837 JNI_END
 838 
 839 JNI_ENTRY_CHECKED(jint,
 840   checked_jni_EnsureLocalCapacity(JNIEnv *env,
 841                                   jint capacity))
 842     functionEnter(thr);
 843     if (capacity &lt; 0) {
 844       NativeReportJNIFatalError(thr, &quot;negative capacity&quot;);
 845     }
 846     jint result = UNCHECKED()-&gt;EnsureLocalCapacity(env, capacity);
 847     if (result == JNI_OK) {
 848       // increase local ref capacity if needed
 849       if ((size_t)capacity &gt; thr-&gt;active_handles()-&gt;get_planned_capacity()) {
 850         add_planned_handle_capacity(thr-&gt;active_handles(), capacity);
 851       }
 852     }
 853     functionExit(thr);
 854     return result;
 855 JNI_END
 856 
 857 JNI_ENTRY_CHECKED(jobject,
 858   checked_jni_AllocObject(JNIEnv *env,
 859                           jclass clazz))
 860     functionEnter(thr);
 861     IN_VM(
 862       jniCheck::validate_class(thr, clazz, false);
 863     )
 864     jobject result = UNCHECKED()-&gt;AllocObject(env,clazz);
 865     functionExit(thr);
 866     return result;
 867 JNI_END
 868 
 869 JNI_ENTRY_CHECKED(jobject,
 870   checked_jni_NewObject(JNIEnv *env,
 871                         jclass clazz,
 872                         jmethodID methodID,
 873                         ...))
 874     functionEnter(thr);
 875     va_list args;
 876     IN_VM(
 877       jniCheck::validate_call(thr, clazz, methodID);
 878     )
 879     va_start(args, methodID);
 880     jobject result = UNCHECKED()-&gt;NewObjectV(env,clazz,methodID,args);
 881     va_end(args);
 882     functionExit(thr);
 883     return result;
 884 JNI_END
 885 
 886 JNI_ENTRY_CHECKED(jobject,
 887   checked_jni_NewObjectV(JNIEnv *env,
 888                          jclass clazz,
 889                          jmethodID methodID,
 890                          va_list args))
 891     functionEnter(thr);
 892     IN_VM(
 893       jniCheck::validate_call(thr, clazz, methodID);
 894     )
 895     jobject result = UNCHECKED()-&gt;NewObjectV(env,clazz,methodID,args);
 896     functionExit(thr);
 897     return result;
 898 JNI_END
 899 
 900 JNI_ENTRY_CHECKED(jobject,
 901   checked_jni_NewObjectA(JNIEnv *env,
 902                          jclass clazz,
 903                          jmethodID methodID,
 904                          const jvalue *args))
 905     functionEnter(thr);
 906     IN_VM(
 907       jniCheck::validate_call(thr, clazz, methodID);
 908     )
 909     jobject result = UNCHECKED()-&gt;NewObjectA(env,clazz,methodID,args);
 910     functionExit(thr);
 911     return result;
 912 JNI_END
 913 
 914 JNI_ENTRY_CHECKED(jclass,
 915   checked_jni_GetObjectClass(JNIEnv *env,
 916                              jobject obj))
 917     functionEnter(thr);
 918     IN_VM(
 919       jniCheck::validate_object(thr, obj);
 920     )
 921     jclass result = UNCHECKED()-&gt;GetObjectClass(env,obj);
 922     functionExit(thr);
 923     return result;
 924 JNI_END
 925 
 926 JNI_ENTRY_CHECKED(jboolean,
 927   checked_jni_IsInstanceOf(JNIEnv *env,
 928                            jobject obj,
 929                            jclass clazz))
 930     functionEnter(thr);
 931     IN_VM(
 932       jniCheck::validate_object(thr, obj);
 933       jniCheck::validate_class(thr, clazz, true);
 934     )
 935     jboolean result = UNCHECKED()-&gt;IsInstanceOf(env,obj,clazz);
 936     functionExit(thr);
 937     return result;
 938 JNI_END
 939 
 940 JNI_ENTRY_CHECKED(jmethodID,
 941   checked_jni_GetMethodID(JNIEnv *env,
 942                           jclass clazz,
 943                           const char *name,
 944                           const char *sig))
 945     functionEnter(thr);
 946     IN_VM(
 947       jniCheck::validate_class(thr, clazz, false);
 948     )
 949     jmethodID result = UNCHECKED()-&gt;GetMethodID(env,clazz,name,sig);
 950     functionExit(thr);
 951     return result;
 952 JNI_END
 953 
 954 #define WRAPPER_CallMethod(ResultType, Result) \
 955 JNI_ENTRY_CHECKED(ResultType,  \
 956   checked_jni_Call##Result##Method(JNIEnv *env, \
 957                                    jobject obj, \
 958                                    jmethodID methodID, \
 959                                    ...)) \
 960     functionEnter(thr); \
 961     va_list args; \
 962     IN_VM( \
 963       jniCheck::validate_call(thr, NULL, methodID, obj); \
 964     ) \
 965     va_start(args,methodID); \
 966     ResultType result =UNCHECKED()-&gt;Call##Result##MethodV(env, obj, methodID, \
 967                                                           args); \
 968     va_end(args); \
 969     thr-&gt;set_pending_jni_exception_check(&quot;Call&quot;#Result&quot;Method&quot;); \
 970     functionExit(thr); \
 971     return result; \
 972 JNI_END \
 973 \
 974 JNI_ENTRY_CHECKED(ResultType,  \
 975   checked_jni_Call##Result##MethodV(JNIEnv *env, \
 976                                     jobject obj, \
 977                                     jmethodID methodID, \
 978                                     va_list args)) \
 979     functionEnter(thr); \
 980     IN_VM(\
 981       jniCheck::validate_call(thr, NULL, methodID, obj); \
 982     ) \
 983     ResultType result = UNCHECKED()-&gt;Call##Result##MethodV(env, obj, methodID,\
 984                                                            args); \
 985     thr-&gt;set_pending_jni_exception_check(&quot;Call&quot;#Result&quot;MethodV&quot;); \
 986     functionExit(thr); \
 987     return result; \
 988 JNI_END \
 989 \
 990 JNI_ENTRY_CHECKED(ResultType,  \
 991   checked_jni_Call##Result##MethodA(JNIEnv *env, \
 992                                     jobject obj, \
 993                                     jmethodID methodID, \
 994                                     const jvalue * args)) \
 995     functionEnter(thr); \
 996     IN_VM( \
 997       jniCheck::validate_call(thr, NULL, methodID, obj); \
 998     ) \
 999     ResultType result = UNCHECKED()-&gt;Call##Result##MethodA(env, obj, methodID,\
1000                                                            args); \
1001     thr-&gt;set_pending_jni_exception_check(&quot;Call&quot;#Result&quot;MethodA&quot;); \
1002     functionExit(thr); \
1003     return result; \
1004 JNI_END
1005 
1006 WRAPPER_CallMethod(jobject,Object)
1007 WRAPPER_CallMethod(jboolean,Boolean)
1008 WRAPPER_CallMethod(jbyte,Byte)
1009 WRAPPER_CallMethod(jshort,Short)
1010 WRAPPER_CallMethod(jchar,Char)
1011 WRAPPER_CallMethod(jint,Int)
1012 WRAPPER_CallMethod(jlong,Long)
1013 WRAPPER_CallMethod(jfloat,Float)
1014 WRAPPER_CallMethod(jdouble,Double)
1015 
1016 JNI_ENTRY_CHECKED(void,
1017   checked_jni_CallVoidMethod(JNIEnv *env, \
1018                              jobject obj, \
1019                              jmethodID methodID, \
1020                              ...))
1021     functionEnter(thr);
1022     va_list args;
1023     IN_VM(
1024       jniCheck::validate_call(thr, NULL, methodID, obj);
1025     )
1026     va_start(args,methodID);
1027     UNCHECKED()-&gt;CallVoidMethodV(env,obj,methodID,args);
1028     va_end(args);
1029     thr-&gt;set_pending_jni_exception_check(&quot;CallVoidMethod&quot;);
1030     functionExit(thr);
1031 JNI_END
1032 
1033 JNI_ENTRY_CHECKED(void,
1034   checked_jni_CallVoidMethodV(JNIEnv *env,
1035                               jobject obj,
1036                               jmethodID methodID,
1037                               va_list args))
1038     functionEnter(thr);
1039     IN_VM(
1040       jniCheck::validate_call(thr, NULL, methodID, obj);
1041     )
1042     UNCHECKED()-&gt;CallVoidMethodV(env,obj,methodID,args);
1043     thr-&gt;set_pending_jni_exception_check(&quot;CallVoidMethodV&quot;);
1044     functionExit(thr);
1045 JNI_END
1046 
1047 JNI_ENTRY_CHECKED(void,
1048   checked_jni_CallVoidMethodA(JNIEnv *env,
1049                               jobject obj,
1050                               jmethodID methodID,
1051                               const jvalue * args))
1052     functionEnter(thr);
1053     IN_VM(
1054       jniCheck::validate_call(thr, NULL, methodID, obj);
1055     )
1056     UNCHECKED()-&gt;CallVoidMethodA(env,obj,methodID,args);
1057     thr-&gt;set_pending_jni_exception_check(&quot;CallVoidMethodA&quot;);
1058     functionExit(thr);
1059 JNI_END
1060 
1061 #define WRAPPER_CallNonvirtualMethod(ResultType, Result) \
1062 JNI_ENTRY_CHECKED(ResultType,  \
1063   checked_jni_CallNonvirtual##Result##Method(JNIEnv *env, \
1064                                              jobject obj, \
1065                                              jclass clazz, \
1066                                              jmethodID methodID, \
1067                                              ...)) \
1068     functionEnter(thr); \
1069     va_list args; \
1070     IN_VM( \
1071       jniCheck::validate_call(thr, clazz, methodID, obj); \
1072     ) \
1073     va_start(args,methodID); \
1074     ResultType result = UNCHECKED()-&gt;CallNonvirtual##Result##MethodV(env, \
1075                                                                      obj, \
1076                                                                      clazz, \
1077                                                                      methodID,\
1078                                                                      args); \
1079     va_end(args); \
1080     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtual&quot;#Result&quot;Method&quot;); \
1081     functionExit(thr); \
1082     return result; \
1083 JNI_END \
1084 \
1085 JNI_ENTRY_CHECKED(ResultType,  \
1086   checked_jni_CallNonvirtual##Result##MethodV(JNIEnv *env, \
1087                                               jobject obj, \
1088                                               jclass clazz, \
1089                                               jmethodID methodID, \
1090                                               va_list args)) \
1091     functionEnter(thr); \
1092     IN_VM( \
1093       jniCheck::validate_call(thr, clazz, methodID, obj); \
1094     ) \
1095     ResultType result = UNCHECKED()-&gt;CallNonvirtual##Result##MethodV(env, \
1096                                                                      obj, \
1097                                                                      clazz, \
1098                                                                      methodID,\
1099                                                                      args); \
1100     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtual&quot;#Result&quot;MethodV&quot;); \
1101     functionExit(thr); \
1102     return result; \
1103 JNI_END \
1104 \
1105 JNI_ENTRY_CHECKED(ResultType,  \
1106   checked_jni_CallNonvirtual##Result##MethodA(JNIEnv *env, \
1107                                               jobject obj, \
1108                                               jclass clazz, \
1109                                               jmethodID methodID, \
1110                                               const jvalue * args)) \
1111     functionEnter(thr); \
1112     IN_VM( \
1113       jniCheck::validate_call(thr, clazz, methodID, obj); \
1114     ) \
1115     ResultType result = UNCHECKED()-&gt;CallNonvirtual##Result##MethodA(env, \
1116                                                                      obj, \
1117                                                                      clazz, \
1118                                                                      methodID,\
1119                                                                      args); \
1120     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtual&quot;#Result&quot;MethodA&quot;); \
1121     functionExit(thr); \
1122     return result; \
1123 JNI_END
1124 
1125 WRAPPER_CallNonvirtualMethod(jobject,Object)
1126 WRAPPER_CallNonvirtualMethod(jboolean,Boolean)
1127 WRAPPER_CallNonvirtualMethod(jbyte,Byte)
1128 WRAPPER_CallNonvirtualMethod(jshort,Short)
1129 WRAPPER_CallNonvirtualMethod(jchar,Char)
1130 WRAPPER_CallNonvirtualMethod(jint,Int)
1131 WRAPPER_CallNonvirtualMethod(jlong,Long)
1132 WRAPPER_CallNonvirtualMethod(jfloat,Float)
1133 WRAPPER_CallNonvirtualMethod(jdouble,Double)
1134 
1135 JNI_ENTRY_CHECKED(void,
1136   checked_jni_CallNonvirtualVoidMethod(JNIEnv *env,
1137                                        jobject obj,
1138                                        jclass clazz,
1139                                        jmethodID methodID,
1140                                        ...))
1141     functionEnter(thr);
1142     va_list args;
1143     IN_VM(
1144       jniCheck::validate_call(thr, clazz, methodID, obj);
1145     )
1146     va_start(args,methodID);
1147     UNCHECKED()-&gt;CallNonvirtualVoidMethodV(env,obj,clazz,methodID,args);
1148     va_end(args);
1149     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtualVoidMethod&quot;);
1150     functionExit(thr);
1151 JNI_END
1152 
1153 JNI_ENTRY_CHECKED(void,
1154   checked_jni_CallNonvirtualVoidMethodV(JNIEnv *env,
1155                                         jobject obj,
1156                                         jclass clazz,
1157                                         jmethodID methodID,
1158                                         va_list args))
1159     functionEnter(thr);
1160     IN_VM(
1161       jniCheck::validate_call(thr, clazz, methodID, obj);
1162     )
1163     UNCHECKED()-&gt;CallNonvirtualVoidMethodV(env,obj,clazz,methodID,args);
1164     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtualVoidMethodV&quot;);
1165     functionExit(thr);
1166 JNI_END
1167 
1168 JNI_ENTRY_CHECKED(void,
1169   checked_jni_CallNonvirtualVoidMethodA(JNIEnv *env,
1170                                         jobject obj,
1171                                         jclass clazz,
1172                                         jmethodID methodID,
1173                                         const jvalue * args))
1174     functionEnter(thr);
1175     IN_VM(
1176       jniCheck::validate_call(thr, clazz, methodID, obj);
1177     )
1178     UNCHECKED()-&gt;CallNonvirtualVoidMethodA(env,obj,clazz,methodID,args);
1179     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtualVoidMethodA&quot;);
1180     functionExit(thr);
1181 JNI_END
1182 
1183 JNI_ENTRY_CHECKED(jfieldID,
1184   checked_jni_GetFieldID(JNIEnv *env,
1185                          jclass clazz,
1186                          const char *name,
1187                          const char *sig))
1188     functionEnter(thr);
1189     IN_VM(
1190       jniCheck::validate_class(thr, clazz, false);
1191     )
1192     jfieldID result = UNCHECKED()-&gt;GetFieldID(env,clazz,name,sig);
1193     functionExit(thr);
1194     return result;
1195 JNI_END
1196 
1197 #define WRAPPER_GetField(ReturnType,Result,FieldType) \
1198 JNI_ENTRY_CHECKED(ReturnType,  \
1199   checked_jni_Get##Result##Field(JNIEnv *env, \
1200                                  jobject obj, \
1201                                  jfieldID fieldID)) \
1202     functionEnter(thr); \
1203     IN_VM( \
1204       checkInstanceFieldID(thr, fieldID, obj, FieldType); \
1205     ) \
1206     ReturnType result = UNCHECKED()-&gt;Get##Result##Field(env,obj,fieldID); \
1207     functionExit(thr); \
1208     return result; \
1209 JNI_END
1210 
1211 WRAPPER_GetField(jobject,  Object,  T_OBJECT)
1212 WRAPPER_GetField(jboolean, Boolean, T_BOOLEAN)
1213 WRAPPER_GetField(jbyte,    Byte,    T_BYTE)
1214 WRAPPER_GetField(jshort,   Short,   T_SHORT)
1215 WRAPPER_GetField(jchar,    Char,    T_CHAR)
1216 WRAPPER_GetField(jint,     Int,     T_INT)
1217 WRAPPER_GetField(jlong,    Long,    T_LONG)
1218 WRAPPER_GetField(jfloat,   Float,   T_FLOAT)
1219 WRAPPER_GetField(jdouble,  Double,  T_DOUBLE)
1220 
1221 #define WRAPPER_SetField(ValueType,Result,FieldType) \
1222 JNI_ENTRY_CHECKED(void,  \
1223   checked_jni_Set##Result##Field(JNIEnv *env, \
1224                                  jobject obj, \
1225                                  jfieldID fieldID, \
1226                                  ValueType val)) \
1227     functionEnter(thr); \
1228     IN_VM( \
1229       checkInstanceFieldID(thr, fieldID, obj, FieldType); \
1230     ) \
1231     UNCHECKED()-&gt;Set##Result##Field(env,obj,fieldID,val); \
1232     functionExit(thr); \
1233 JNI_END
1234 
1235 WRAPPER_SetField(jobject,  Object,  T_OBJECT)
1236 WRAPPER_SetField(jboolean, Boolean, T_BOOLEAN)
1237 WRAPPER_SetField(jbyte,    Byte,    T_BYTE)
1238 WRAPPER_SetField(jshort,   Short,   T_SHORT)
1239 WRAPPER_SetField(jchar,    Char,    T_CHAR)
1240 WRAPPER_SetField(jint,     Int,     T_INT)
1241 WRAPPER_SetField(jlong,    Long,    T_LONG)
1242 WRAPPER_SetField(jfloat,   Float,   T_FLOAT)
1243 WRAPPER_SetField(jdouble,  Double,  T_DOUBLE)
1244 
1245 
1246 JNI_ENTRY_CHECKED(jmethodID,
1247   checked_jni_GetStaticMethodID(JNIEnv *env,
1248                                 jclass clazz,
1249                                 const char *name,
1250                                 const char *sig))
1251     functionEnter(thr);
1252     IN_VM(
1253       jniCheck::validate_class(thr, clazz, false);
1254     )
1255     jmethodID result = UNCHECKED()-&gt;GetStaticMethodID(env,clazz,name,sig);
1256     functionExit(thr);
1257     return result;
1258 JNI_END
1259 
1260 #define WRAPPER_CallStaticMethod(ReturnType,Result) \
1261 JNI_ENTRY_CHECKED(ReturnType,  \
1262   checked_jni_CallStatic##Result##Method(JNIEnv *env, \
1263                                          jclass clazz, \
1264                                          jmethodID methodID, \
1265                                          ...)) \
1266     functionEnter(thr); \
1267     va_list args; \
1268     IN_VM( \
1269       jniCheck::validate_call(thr, clazz, methodID); \
1270     ) \
1271     va_start(args,methodID); \
1272     ReturnType result = UNCHECKED()-&gt;CallStatic##Result##MethodV(env, \
1273                                                                  clazz, \
1274                                                                  methodID, \
1275                                                                  args); \
1276     va_end(args); \
1277     thr-&gt;set_pending_jni_exception_check(&quot;CallStatic&quot;#Result&quot;Method&quot;); \
1278     functionExit(thr); \
1279     return result; \
1280 JNI_END \
1281 \
1282 JNI_ENTRY_CHECKED(ReturnType,  \
1283   checked_jni_CallStatic##Result##MethodV(JNIEnv *env, \
1284                                           jclass clazz, \
1285                                           jmethodID methodID,\
1286                                           va_list args)) \
1287     functionEnter(thr); \
1288     IN_VM( \
1289       jniCheck::validate_call(thr, clazz, methodID); \
1290     ) \
1291     ReturnType result = UNCHECKED()-&gt;CallStatic##Result##MethodV(env, \
1292                                                                  clazz, \
1293                                                                  methodID, \
1294                                                                  args); \
1295     thr-&gt;set_pending_jni_exception_check(&quot;CallStatic&quot;#Result&quot;MethodV&quot;); \
1296     functionExit(thr); \
1297     return result; \
1298 JNI_END \
1299 \
1300 JNI_ENTRY_CHECKED(ReturnType,  \
1301   checked_jni_CallStatic##Result##MethodA(JNIEnv *env, \
1302                                           jclass clazz, \
1303                                           jmethodID methodID, \
1304                                           const jvalue *args)) \
1305     functionEnter(thr); \
1306     IN_VM( \
1307       jniCheck::validate_call(thr, clazz, methodID); \
1308     ) \
1309     ReturnType result = UNCHECKED()-&gt;CallStatic##Result##MethodA(env, \
1310                                                                  clazz, \
1311                                                                  methodID, \
1312                                                                  args); \
1313     thr-&gt;set_pending_jni_exception_check(&quot;CallStatic&quot;#Result&quot;MethodA&quot;); \
1314     functionExit(thr); \
1315     return result; \
1316 JNI_END
1317 
1318 WRAPPER_CallStaticMethod(jobject,Object)
1319 WRAPPER_CallStaticMethod(jboolean,Boolean)
1320 WRAPPER_CallStaticMethod(jbyte,Byte)
1321 WRAPPER_CallStaticMethod(jshort,Short)
1322 WRAPPER_CallStaticMethod(jchar,Char)
1323 WRAPPER_CallStaticMethod(jint,Int)
1324 WRAPPER_CallStaticMethod(jlong,Long)
1325 WRAPPER_CallStaticMethod(jfloat,Float)
1326 WRAPPER_CallStaticMethod(jdouble,Double)
1327 
1328 JNI_ENTRY_CHECKED(void,
1329   checked_jni_CallStaticVoidMethod(JNIEnv *env,
1330                                    jclass cls,
1331                                    jmethodID methodID,
1332                                    ...))
1333     functionEnter(thr);
1334     va_list args;
1335     IN_VM(
1336       jniCheck::validate_call(thr, cls, methodID);
1337     )
1338     va_start(args,methodID);
1339     UNCHECKED()-&gt;CallStaticVoidMethodV(env,cls,methodID,args);
1340     va_end(args);
1341     thr-&gt;set_pending_jni_exception_check(&quot;CallStaticVoidMethod&quot;);
1342     functionExit(thr);
1343 JNI_END
1344 
1345 JNI_ENTRY_CHECKED(void,
1346   checked_jni_CallStaticVoidMethodV(JNIEnv *env,
1347                                     jclass cls,
1348                                     jmethodID methodID,
1349                                     va_list args))
1350     functionEnter(thr);
1351     IN_VM(
1352       jniCheck::validate_call(thr, cls, methodID);
1353     )
1354     UNCHECKED()-&gt;CallStaticVoidMethodV(env,cls,methodID,args);
1355     thr-&gt;set_pending_jni_exception_check(&quot;CallStaticVoidMethodV&quot;);
1356     functionExit(thr);
1357 JNI_END
1358 
1359 JNI_ENTRY_CHECKED(void,
1360   checked_jni_CallStaticVoidMethodA(JNIEnv *env,
1361                                     jclass cls,
1362                                     jmethodID methodID,
1363                                     const jvalue * args))
1364     functionEnter(thr);
1365     IN_VM(
1366       jniCheck::validate_call(thr, cls, methodID);
1367     )
1368     UNCHECKED()-&gt;CallStaticVoidMethodA(env,cls,methodID,args);
1369     thr-&gt;set_pending_jni_exception_check(&quot;CallStaticVoidMethodA&quot;);
1370     functionExit(thr);
1371 JNI_END
1372 
1373 JNI_ENTRY_CHECKED(jfieldID,
1374   checked_jni_GetStaticFieldID(JNIEnv *env,
1375                                jclass clazz,
1376                                const char *name,
1377                                const char *sig))
1378     functionEnter(thr);
1379     IN_VM(
1380       jniCheck::validate_class(thr, clazz, false);
1381     )
1382     jfieldID result = UNCHECKED()-&gt;GetStaticFieldID(env,clazz,name,sig);
1383     functionExit(thr);
1384     return result;
1385 JNI_END
1386 
1387 #define WRAPPER_GetStaticField(ReturnType,Result,FieldType) \
1388 JNI_ENTRY_CHECKED(ReturnType,  \
1389   checked_jni_GetStatic##Result##Field(JNIEnv *env, \
1390                                        jclass clazz, \
1391                                        jfieldID fieldID)) \
1392     functionEnter(thr); \
1393     IN_VM( \
1394       jniCheck::validate_class(thr, clazz, false); \
1395       checkStaticFieldID(thr, fieldID, clazz, FieldType); \
1396     ) \
1397     ReturnType result = UNCHECKED()-&gt;GetStatic##Result##Field(env, \
1398                                                               clazz, \
1399                                                               fieldID); \
1400     functionExit(thr); \
1401     return result; \
1402 JNI_END
1403 
1404 WRAPPER_GetStaticField(jobject,  Object,  T_OBJECT)
1405 WRAPPER_GetStaticField(jboolean, Boolean, T_BOOLEAN)
1406 WRAPPER_GetStaticField(jbyte,    Byte,    T_BYTE)
1407 WRAPPER_GetStaticField(jshort,   Short,   T_SHORT)
1408 WRAPPER_GetStaticField(jchar,    Char,    T_CHAR)
1409 WRAPPER_GetStaticField(jint,     Int,     T_INT)
1410 WRAPPER_GetStaticField(jlong,    Long,    T_LONG)
1411 WRAPPER_GetStaticField(jfloat,   Float,   T_FLOAT)
1412 WRAPPER_GetStaticField(jdouble,  Double,  T_DOUBLE)
1413 
1414 #define WRAPPER_SetStaticField(ValueType,Result,FieldType) \
1415 JNI_ENTRY_CHECKED(void,  \
1416   checked_jni_SetStatic##Result##Field(JNIEnv *env, \
1417                                        jclass clazz, \
1418                                        jfieldID fieldID, \
1419                                        ValueType value)) \
1420     functionEnter(thr); \
1421     IN_VM( \
1422       jniCheck::validate_class(thr, clazz, false); \
1423       checkStaticFieldID(thr, fieldID, clazz, FieldType); \
1424     ) \
1425     UNCHECKED()-&gt;SetStatic##Result##Field(env,clazz,fieldID,value); \
1426     functionExit(thr); \
1427 JNI_END
1428 
1429 WRAPPER_SetStaticField(jobject,  Object,  T_OBJECT)
1430 WRAPPER_SetStaticField(jboolean, Boolean, T_BOOLEAN)
1431 WRAPPER_SetStaticField(jbyte,    Byte,    T_BYTE)
1432 WRAPPER_SetStaticField(jshort,   Short,   T_SHORT)
1433 WRAPPER_SetStaticField(jchar,    Char,    T_CHAR)
1434 WRAPPER_SetStaticField(jint,     Int,     T_INT)
1435 WRAPPER_SetStaticField(jlong,    Long,    T_LONG)
1436 WRAPPER_SetStaticField(jfloat,   Float,   T_FLOAT)
1437 WRAPPER_SetStaticField(jdouble,  Double,  T_DOUBLE)
1438 
1439 
1440 JNI_ENTRY_CHECKED(jstring,
1441   checked_jni_NewString(JNIEnv *env,
1442                         const jchar *unicode,
1443                         jsize len))
1444     functionEnter(thr);
1445     jstring result = UNCHECKED()-&gt;NewString(env,unicode,len);
1446     functionExit(thr);
1447     return result;
1448 JNI_END
1449 
1450 JNI_ENTRY_CHECKED(jsize,
1451   checked_jni_GetStringLength(JNIEnv *env,
1452                               jstring str))
1453     functionEnter(thr);
1454     IN_VM(
1455       checkString(thr, str);
1456     )
1457     jsize result = UNCHECKED()-&gt;GetStringLength(env,str);
1458     functionExit(thr);
1459     return result;
1460 JNI_END
1461 
1462 // Arbitrary (but well-known) tag
1463 const void* STRING_TAG = (void*)0x47114711;
1464 
1465 JNI_ENTRY_CHECKED(const jchar *,
1466   checked_jni_GetStringChars(JNIEnv *env,
1467                              jstring str,
1468                              jboolean *isCopy))
1469     functionEnter(thr);
1470     IN_VM(
1471       checkString(thr, str);
1472     )
1473     jchar* new_result = NULL;
1474     const jchar *result = UNCHECKED()-&gt;GetStringChars(env,str,isCopy);
1475     assert (isCopy == NULL || *isCopy == JNI_TRUE, &quot;GetStringChars didn&#39;t return a copy as expected&quot;);
1476     if (result != NULL) {
1477       size_t len = UNCHECKED()-&gt;GetStringLength(env,str) + 1; // + 1 for NULL termination
1478       len *= sizeof(jchar);
1479       new_result = (jchar*) GuardedMemory::wrap_copy(result, len, STRING_TAG);
1480       if (new_result == NULL) {
1481         vm_exit_out_of_memory(len, OOM_MALLOC_ERROR, &quot;checked_jni_GetStringChars&quot;);
1482       }
1483       // Avoiding call to UNCHECKED()-&gt;ReleaseStringChars() since that will fire unexpected dtrace probes
1484       // Note that the dtrace arguments for the allocated memory will not match up with this solution.
1485       FreeHeap((char*)result);
1486     }
1487     functionExit(thr);
1488     return new_result;
1489 JNI_END
1490 
1491 JNI_ENTRY_CHECKED(void,
1492   checked_jni_ReleaseStringChars(JNIEnv *env,
1493                                  jstring str,
1494                                  const jchar *chars))
1495     functionEnterExceptionAllowed(thr);
1496     IN_VM(
1497       checkString(thr, str);
1498     )
1499     if (chars == NULL) {
1500        // still do the unchecked call to allow dtrace probes
1501        UNCHECKED()-&gt;ReleaseStringChars(env,str,chars);
1502     }
1503     else {
1504       GuardedMemory guarded((void*)chars);
1505       if (!guarded.verify_guards()) {
1506         tty-&gt;print_cr(&quot;ReleaseStringChars: release chars failed bounds check. &quot;
1507             &quot;string: &quot; PTR_FORMAT &quot; chars: &quot; PTR_FORMAT, p2i(str), p2i(chars));
1508         guarded.print_on(tty);
1509         NativeReportJNIFatalError(thr, &quot;ReleaseStringChars: &quot;
1510             &quot;release chars failed bounds check.&quot;);
1511       }
1512       if (guarded.get_tag() != STRING_TAG) {
1513         tty-&gt;print_cr(&quot;ReleaseStringChars: called on something not allocated &quot;
1514             &quot;by GetStringChars. string: &quot; PTR_FORMAT &quot; chars: &quot; PTR_FORMAT,
1515             p2i(str), p2i(chars));
1516         NativeReportJNIFatalError(thr, &quot;ReleaseStringChars called on something &quot;
1517             &quot;not allocated by GetStringChars&quot;);
1518       }
1519        UNCHECKED()-&gt;ReleaseStringChars(env, str,
1520            (const jchar*) guarded.release_for_freeing());
1521     }
1522     functionExit(thr);
1523 JNI_END
1524 
1525 JNI_ENTRY_CHECKED(jstring,
1526   checked_jni_NewStringUTF(JNIEnv *env,
1527                            const char *utf))
1528     functionEnter(thr);
1529     jstring result = UNCHECKED()-&gt;NewStringUTF(env,utf);
1530     functionExit(thr);
1531     return result;
1532 JNI_END
1533 
1534 JNI_ENTRY_CHECKED(jsize,
1535   checked_jni_GetStringUTFLength(JNIEnv *env,
1536                                  jstring str))
1537     functionEnter(thr);
1538     IN_VM(
1539       checkString(thr, str);
1540     )
1541     jsize result = UNCHECKED()-&gt;GetStringUTFLength(env,str);
1542     functionExit(thr);
1543     return result;
1544 JNI_END
1545 
1546 // Arbitrary (but well-known) tag - different than GetStringChars
1547 const void* STRING_UTF_TAG = (void*) 0x48124812;
1548 
1549 JNI_ENTRY_CHECKED(const char *,
1550   checked_jni_GetStringUTFChars(JNIEnv *env,
1551                                 jstring str,
1552                                 jboolean *isCopy))
1553     functionEnter(thr);
1554     IN_VM(
1555       checkString(thr, str);
1556     )
1557     char* new_result = NULL;
1558     const char *result = UNCHECKED()-&gt;GetStringUTFChars(env,str,isCopy);
1559     assert (isCopy == NULL || *isCopy == JNI_TRUE, &quot;GetStringUTFChars didn&#39;t return a copy as expected&quot;);
1560     if (result != NULL) {
1561       size_t len = strlen(result) + 1; // + 1 for NULL termination
1562       new_result = (char*) GuardedMemory::wrap_copy(result, len, STRING_UTF_TAG);
1563       if (new_result == NULL) {
1564         vm_exit_out_of_memory(len, OOM_MALLOC_ERROR, &quot;checked_jni_GetStringUTFChars&quot;);
1565       }
1566       // Avoiding call to UNCHECKED()-&gt;ReleaseStringUTFChars() since that will fire unexpected dtrace probes
1567       // Note that the dtrace arguments for the allocated memory will not match up with this solution.
1568       FreeHeap((char*)result);
1569     }
1570     functionExit(thr);
1571     return new_result;
1572 JNI_END
1573 
1574 JNI_ENTRY_CHECKED(void,
1575   checked_jni_ReleaseStringUTFChars(JNIEnv *env,
1576                                     jstring str,
1577                                     const char* chars))
1578     functionEnterExceptionAllowed(thr);
1579     IN_VM(
1580       checkString(thr, str);
1581     )
1582     if (chars == NULL) {
1583        // still do the unchecked call to allow dtrace probes
1584        UNCHECKED()-&gt;ReleaseStringUTFChars(env,str,chars);
1585     }
1586     else {
1587       GuardedMemory guarded((void*)chars);
1588       if (!guarded.verify_guards()) {
1589         tty-&gt;print_cr(&quot;ReleaseStringUTFChars: release chars failed bounds check. &quot;
1590             &quot;string: &quot; PTR_FORMAT &quot; chars: &quot; PTR_FORMAT, p2i(str), p2i(chars));
1591         guarded.print_on(tty);
1592         NativeReportJNIFatalError(thr, &quot;ReleaseStringUTFChars: &quot;
1593             &quot;release chars failed bounds check.&quot;);
1594       }
1595       if (guarded.get_tag() != STRING_UTF_TAG) {
1596         tty-&gt;print_cr(&quot;ReleaseStringUTFChars: called on something not &quot;
1597             &quot;allocated by GetStringUTFChars. string: &quot; PTR_FORMAT &quot; chars: &quot;
1598             PTR_FORMAT, p2i(str), p2i(chars));
1599         NativeReportJNIFatalError(thr, &quot;ReleaseStringUTFChars &quot;
1600             &quot;called on something not allocated by GetStringUTFChars&quot;);
1601       }
1602       UNCHECKED()-&gt;ReleaseStringUTFChars(env, str,
1603           (const char*) guarded.release_for_freeing());
1604     }
1605     functionExit(thr);
1606 JNI_END
1607 
1608 JNI_ENTRY_CHECKED(jsize,
1609   checked_jni_GetArrayLength(JNIEnv *env,
1610                              jarray array))
1611     functionEnter(thr);
1612     IN_VM(
1613       check_is_array(thr, array);
1614     )
1615     jsize result = UNCHECKED()-&gt;GetArrayLength(env,array);
1616     functionExit(thr);
1617     return result;
1618 JNI_END
1619 
1620 JNI_ENTRY_CHECKED(jobjectArray,
1621   checked_jni_NewObjectArray(JNIEnv *env,
1622                              jsize len,
1623                              jclass clazz,
1624                              jobject init))
1625     functionEnter(thr);
1626     jobjectArray result = UNCHECKED()-&gt;NewObjectArray(env,len,clazz,init);
1627     functionExit(thr);
1628     return result;
1629 JNI_END
1630 
1631 JNI_ENTRY_CHECKED(jobject,
1632   checked_jni_GetObjectArrayElement(JNIEnv *env,
1633                                     jobjectArray array,
1634                                     jsize index))
1635     functionEnter(thr);
1636     IN_VM(
1637       check_is_obj_array(thr, array);
1638     )
1639     jobject result = UNCHECKED()-&gt;GetObjectArrayElement(env,array,index);
1640     functionExit(thr);
1641     return result;
1642 JNI_END
1643 
1644 JNI_ENTRY_CHECKED(void,
1645   checked_jni_SetObjectArrayElement(JNIEnv *env,
1646                                     jobjectArray array,
1647                                     jsize index,
1648                                     jobject val))
1649     functionEnter(thr);
1650     IN_VM(
1651       check_is_obj_array(thr, array);
1652     )
1653     UNCHECKED()-&gt;SetObjectArrayElement(env,array,index,val);
1654     functionExit(thr);
1655 JNI_END
1656 
1657 #define WRAPPER_NewScalarArray(Return, Result) \
1658 JNI_ENTRY_CHECKED(Return, \
1659   checked_jni_New##Result##Array(JNIEnv *env, \
1660                                  jsize len)) \
1661     functionEnter(thr); \
1662     Return result = UNCHECKED()-&gt;New##Result##Array(env,len); \
1663     functionExit(thr); \
1664     return (Return) result; \
1665 JNI_END
1666 
1667 WRAPPER_NewScalarArray(jbooleanArray, Boolean)
1668 WRAPPER_NewScalarArray(jbyteArray, Byte)
1669 WRAPPER_NewScalarArray(jshortArray, Short)
1670 WRAPPER_NewScalarArray(jcharArray, Char)
1671 WRAPPER_NewScalarArray(jintArray, Int)
1672 WRAPPER_NewScalarArray(jlongArray, Long)
1673 WRAPPER_NewScalarArray(jfloatArray, Float)
1674 WRAPPER_NewScalarArray(jdoubleArray, Double)
1675 
1676 #define WRAPPER_GetScalarArrayElements(ElementTag,ElementType,Result) \
1677 JNI_ENTRY_CHECKED(ElementType *,  \
1678   checked_jni_Get##Result##ArrayElements(JNIEnv *env, \
1679                                          ElementType##Array array, \
1680                                          jboolean *isCopy)) \
1681     functionEnter(thr); \
1682     IN_VM( \
1683       check_primitive_array_type(thr, array, ElementTag); \
1684     ) \
1685     ElementType *result = UNCHECKED()-&gt;Get##Result##ArrayElements(env, \
1686                                                                   array, \
1687                                                                   isCopy); \
1688     if (result != NULL) { \
1689       result = (ElementType *) check_jni_wrap_copy_array(thr, array, result); \
1690     } \
1691     functionExit(thr); \
1692     return result; \
1693 JNI_END
1694 
1695 WRAPPER_GetScalarArrayElements(T_BOOLEAN, jboolean, Boolean)
1696 WRAPPER_GetScalarArrayElements(T_BYTE,    jbyte,    Byte)
1697 WRAPPER_GetScalarArrayElements(T_SHORT,   jshort,   Short)
1698 WRAPPER_GetScalarArrayElements(T_CHAR,    jchar,    Char)
1699 WRAPPER_GetScalarArrayElements(T_INT,     jint,     Int)
1700 WRAPPER_GetScalarArrayElements(T_LONG,    jlong,    Long)
1701 WRAPPER_GetScalarArrayElements(T_FLOAT,   jfloat,   Float)
1702 WRAPPER_GetScalarArrayElements(T_DOUBLE,  jdouble,  Double)
1703 
1704 #define WRAPPER_ReleaseScalarArrayElements(ElementTag,ElementType,Result,Tag) \
1705 JNI_ENTRY_CHECKED(void,  \
1706   checked_jni_Release##Result##ArrayElements(JNIEnv *env, \
1707                                              ElementType##Array array, \
1708                                              ElementType *elems, \
1709                                              jint mode)) \
1710     functionEnterExceptionAllowed(thr); \
1711     IN_VM( \
1712       check_primitive_array_type(thr, array, ElementTag); \
1713       ASSERT_OOPS_ALLOWED; \
1714       typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
1715     ) \
1716     ElementType* orig_result = (ElementType *) check_wrapped_array_release( \
1717         thr, &quot;checked_jni_Release&quot;#Result&quot;ArrayElements&quot;, array, elems, mode); \
1718     UNCHECKED()-&gt;Release##Result##ArrayElements(env, array, orig_result, mode); \
1719     functionExit(thr); \
1720 JNI_END
1721 
1722 WRAPPER_ReleaseScalarArrayElements(T_BOOLEAN,jboolean, Boolean, bool)
1723 WRAPPER_ReleaseScalarArrayElements(T_BYTE,   jbyte,    Byte,    byte)
1724 WRAPPER_ReleaseScalarArrayElements(T_SHORT,  jshort,   Short,   short)
1725 WRAPPER_ReleaseScalarArrayElements(T_CHAR,   jchar,    Char,    char)
1726 WRAPPER_ReleaseScalarArrayElements(T_INT,    jint,     Int,     int)
1727 WRAPPER_ReleaseScalarArrayElements(T_LONG,   jlong,    Long,    long)
1728 WRAPPER_ReleaseScalarArrayElements(T_FLOAT,  jfloat,   Float,   float)
1729 WRAPPER_ReleaseScalarArrayElements(T_DOUBLE, jdouble,  Double,  double)
1730 
1731 #define WRAPPER_GetScalarArrayRegion(ElementTag,ElementType,Result) \
1732 JNI_ENTRY_CHECKED(void,  \
1733   checked_jni_Get##Result##ArrayRegion(JNIEnv *env, \
1734                                        ElementType##Array array, \
1735                                        jsize start, \
1736                                        jsize len, \
1737                                        ElementType *buf)) \
1738     functionEnter(thr); \
1739     IN_VM( \
1740       check_primitive_array_type(thr, array, ElementTag); \
1741     ) \
1742     UNCHECKED()-&gt;Get##Result##ArrayRegion(env,array,start,len,buf); \
1743     functionExit(thr); \
1744 JNI_END
1745 
1746 WRAPPER_GetScalarArrayRegion(T_BOOLEAN, jboolean, Boolean)
1747 WRAPPER_GetScalarArrayRegion(T_BYTE,    jbyte,    Byte)
1748 WRAPPER_GetScalarArrayRegion(T_SHORT,   jshort,   Short)
1749 WRAPPER_GetScalarArrayRegion(T_CHAR,    jchar,    Char)
1750 WRAPPER_GetScalarArrayRegion(T_INT,     jint,     Int)
1751 WRAPPER_GetScalarArrayRegion(T_LONG,    jlong,    Long)
1752 WRAPPER_GetScalarArrayRegion(T_FLOAT,   jfloat,   Float)
1753 WRAPPER_GetScalarArrayRegion(T_DOUBLE,  jdouble,  Double)
1754 
1755 #define WRAPPER_SetScalarArrayRegion(ElementTag,ElementType,Result) \
1756 JNI_ENTRY_CHECKED(void,  \
1757   checked_jni_Set##Result##ArrayRegion(JNIEnv *env, \
1758                                        ElementType##Array array, \
1759                                        jsize start, \
1760                                        jsize len, \
1761                                        const ElementType *buf)) \
1762     functionEnter(thr); \
1763     IN_VM( \
1764       check_primitive_array_type(thr, array, ElementTag); \
1765     ) \
1766     UNCHECKED()-&gt;Set##Result##ArrayRegion(env,array,start,len,buf); \
1767     functionExit(thr); \
1768 JNI_END
1769 
1770 WRAPPER_SetScalarArrayRegion(T_BOOLEAN, jboolean, Boolean)
1771 WRAPPER_SetScalarArrayRegion(T_BYTE,    jbyte,    Byte)
1772 WRAPPER_SetScalarArrayRegion(T_SHORT,   jshort,   Short)
1773 WRAPPER_SetScalarArrayRegion(T_CHAR,    jchar,    Char)
1774 WRAPPER_SetScalarArrayRegion(T_INT,     jint,     Int)
1775 WRAPPER_SetScalarArrayRegion(T_LONG,    jlong,    Long)
1776 WRAPPER_SetScalarArrayRegion(T_FLOAT,   jfloat,   Float)
1777 WRAPPER_SetScalarArrayRegion(T_DOUBLE,  jdouble,  Double)
1778 
1779 JNI_ENTRY_CHECKED(jint,
1780   checked_jni_RegisterNatives(JNIEnv *env,
1781                               jclass clazz,
1782                               const JNINativeMethod *methods,
1783                               jint nMethods))
1784     functionEnter(thr);
1785     jint result = UNCHECKED()-&gt;RegisterNatives(env,clazz,methods,nMethods);
1786     functionExit(thr);
1787     return result;
1788 JNI_END
1789 
1790 JNI_ENTRY_CHECKED(jint,
1791   checked_jni_UnregisterNatives(JNIEnv *env,
1792                                 jclass clazz))
1793     functionEnter(thr);
1794     jint result = UNCHECKED()-&gt;UnregisterNatives(env,clazz);
1795     functionExit(thr);
1796     return result;
1797 JNI_END
1798 
1799 JNI_ENTRY_CHECKED(jint,
1800   checked_jni_MonitorEnter(JNIEnv *env,
1801                            jobject obj))
1802     functionEnter(thr);
1803     IN_VM(
1804       jniCheck::validate_object(thr, obj);
1805     )
1806     jint result = UNCHECKED()-&gt;MonitorEnter(env,obj);
1807     functionExit(thr);
1808     return result;
1809 JNI_END
1810 
1811 JNI_ENTRY_CHECKED(jint,
1812   checked_jni_MonitorExit(JNIEnv *env,
1813                           jobject obj))
1814     functionEnterExceptionAllowed(thr);
1815     IN_VM(
1816       jniCheck::validate_object(thr, obj);
1817     )
1818     jint result = UNCHECKED()-&gt;MonitorExit(env,obj);
1819     functionExit(thr);
1820     return result;
1821 JNI_END
1822 
1823 JNI_ENTRY_CHECKED(jint,
1824   checked_jni_GetJavaVM(JNIEnv *env,
1825                         JavaVM **vm))
1826     functionEnter(thr);
1827     jint result = UNCHECKED()-&gt;GetJavaVM(env,vm);
1828     functionExit(thr);
1829     return result;
1830 JNI_END
1831 
1832 JNI_ENTRY_CHECKED(void,
1833   checked_jni_GetStringRegion(JNIEnv *env,
1834                               jstring str,
1835                               jsize start,
1836                               jsize len,
1837                               jchar *buf))
1838     functionEnter(thr);
1839     IN_VM(
1840       checkString(thr, str);
1841     )
1842     UNCHECKED()-&gt;GetStringRegion(env, str, start, len, buf);
1843     functionExit(thr);
1844 JNI_END
1845 
1846 JNI_ENTRY_CHECKED(void,
1847   checked_jni_GetStringUTFRegion(JNIEnv *env,
1848                                  jstring str,
1849                                  jsize start,
1850                                  jsize len,
1851                                  char *buf))
1852     functionEnter(thr);
1853     IN_VM(
1854       checkString(thr, str);
1855     )
1856     UNCHECKED()-&gt;GetStringUTFRegion(env, str, start, len, buf);
1857     functionExit(thr);
1858 JNI_END
1859 
1860 JNI_ENTRY_CHECKED(void *,
1861   checked_jni_GetPrimitiveArrayCritical(JNIEnv *env,
1862                                         jarray array,
1863                                         jboolean *isCopy))
1864     functionEnterCritical(thr);
1865     IN_VM(
1866       check_is_primitive_array(thr, array);
1867     )
1868     void *result = UNCHECKED()-&gt;GetPrimitiveArrayCritical(env, array, isCopy);
1869     if (result != NULL) {
1870       result = check_jni_wrap_copy_array(thr, array, result);
1871     }
1872     functionExit(thr);
1873     return result;
1874 JNI_END
1875 
1876 JNI_ENTRY_CHECKED(void,
1877   checked_jni_ReleasePrimitiveArrayCritical(JNIEnv *env,
1878                                             jarray array,
1879                                             void *carray,
1880                                             jint mode))
1881     functionEnterCriticalExceptionAllowed(thr);
1882     IN_VM(
1883       check_is_primitive_array(thr, array);
1884     )
1885     // Check the element array...
1886     void* orig_result = check_wrapped_array_release(thr, &quot;ReleasePrimitiveArrayCritical&quot;, array, carray, mode);
1887     UNCHECKED()-&gt;ReleasePrimitiveArrayCritical(env, array, orig_result, mode);
1888     functionExit(thr);
1889 JNI_END
1890 
1891 JNI_ENTRY_CHECKED(const jchar*,
1892   checked_jni_GetStringCritical(JNIEnv *env,
1893                                 jstring string,
1894                                 jboolean *isCopy))
1895     functionEnterCritical(thr);
1896     IN_VM(
1897       checkString(thr, string);
1898     )
1899     const jchar *result = UNCHECKED()-&gt;GetStringCritical(env, string, isCopy);
1900     functionExit(thr);
1901     return result;
1902 JNI_END
1903 
1904 JNI_ENTRY_CHECKED(void,
1905   checked_jni_ReleaseStringCritical(JNIEnv *env,
1906                                     jstring str,
1907                                     const jchar *chars))
1908     functionEnterCriticalExceptionAllowed(thr);
1909     IN_VM(
1910       checkString(thr, str);
1911     )
1912     /* The Hotspot JNI code does not use the parameters, so just check the
1913      * string parameter as a minor sanity check
1914      */
1915     UNCHECKED()-&gt;ReleaseStringCritical(env, str, chars);
1916     functionExit(thr);
1917 JNI_END
1918 
1919 JNI_ENTRY_CHECKED(jweak,
1920   checked_jni_NewWeakGlobalRef(JNIEnv *env,
1921                                jobject obj))
1922     functionEnter(thr);
1923     IN_VM(
1924       if (obj != NULL) {
1925         jniCheck::validate_handle(thr, obj);
1926       }
1927     )
1928     jweak result = UNCHECKED()-&gt;NewWeakGlobalRef(env, obj);
1929     functionExit(thr);
1930     return result;
1931 JNI_END
1932 
1933 JNI_ENTRY_CHECKED(void,
1934   checked_jni_DeleteWeakGlobalRef(JNIEnv *env,
1935                                   jweak ref))
1936     functionEnterExceptionAllowed(thr);
1937     IN_VM(
1938       if (ref &amp;&amp; !JNIHandles::is_weak_global_handle(ref)) {
1939         ReportJNIFatalError(thr,
1940              &quot;Invalid weak global JNI handle passed to DeleteWeakGlobalRef&quot;);
1941       }
1942     )
1943     UNCHECKED()-&gt;DeleteWeakGlobalRef(env, ref);
1944     functionExit(thr);
1945 JNI_END
1946 
1947 JNI_ENTRY_CHECKED(jboolean,
1948   checked_jni_ExceptionCheck(JNIEnv *env))
1949     thr-&gt;clear_pending_jni_exception_check();
1950     functionEnterExceptionAllowed(thr);
1951     jboolean result = UNCHECKED()-&gt;ExceptionCheck(env);
1952     functionExit(thr);
1953     return result;
1954 JNI_END
1955 
1956 JNI_ENTRY_CHECKED(jobject,
1957   checked_jni_NewDirectByteBuffer(JNIEnv *env,
1958                                   void *address,
1959                                   jlong capacity))
1960     functionEnter(thr);
1961     jobject result = UNCHECKED()-&gt;NewDirectByteBuffer(env, address, capacity);
1962     functionExit(thr);
1963     return result;
1964 JNI_END
1965 
1966 JNI_ENTRY_CHECKED(void *,
1967   checked_jni_GetDirectBufferAddress(JNIEnv *env,
1968                                      jobject buf))
1969     functionEnter(thr);
1970     void* result = UNCHECKED()-&gt;GetDirectBufferAddress(env, buf);
1971     functionExit(thr);
1972     return result;
1973 JNI_END
1974 
1975 JNI_ENTRY_CHECKED(jlong,
1976   checked_jni_GetDirectBufferCapacity(JNIEnv *env,
1977                                       jobject buf))
1978     functionEnter(thr);
1979     jlong result = UNCHECKED()-&gt;GetDirectBufferCapacity(env, buf);
1980     functionExit(thr);
1981     return result;
1982 JNI_END
1983 
1984 JNI_ENTRY_CHECKED(jobjectRefType,
1985   checked_jni_GetObjectRefType(JNIEnv *env,
1986                                jobject obj))
1987     functionEnter(thr);
1988     /* validate the object being passed */
1989     IN_VM(
1990       jniCheck::validate_object(thr, obj);
1991     )
1992     jobjectRefType result = UNCHECKED()-&gt;GetObjectRefType(env, obj);
1993     functionExit(thr);
1994     return result;
1995 JNI_END
1996 
1997 
1998 JNI_ENTRY_CHECKED(jint,
1999   checked_jni_GetVersion(JNIEnv *env))
2000     functionEnter(thr);
2001     jint result = UNCHECKED()-&gt;GetVersion(env);
2002     functionExit(thr);
2003     return result;
2004 JNI_END
2005 
2006 JNI_ENTRY_CHECKED(jobject,
2007   checked_jni_GetModule(JNIEnv *env,
2008                         jclass clazz))
2009     functionEnter(thr);
2010     jobject result = UNCHECKED()-&gt;GetModule(env,clazz);
2011     functionExit(thr);
2012     return result;
2013 JNI_END
2014 
2015 /*
2016  * Structure containing all checked jni functions
2017  */
2018 struct JNINativeInterface_  checked_jni_NativeInterface = {
2019     NULL,
2020     NULL,
2021     NULL,
2022 
2023     NULL,
2024 
2025     checked_jni_GetVersion,
2026 
2027     checked_jni_DefineClass,
2028     checked_jni_FindClass,
2029 
2030     checked_jni_FromReflectedMethod,
2031     checked_jni_FromReflectedField,
2032 
2033     checked_jni_ToReflectedMethod,
2034 
2035     checked_jni_GetSuperclass,
2036     checked_jni_IsAssignableFrom,
2037 
2038     checked_jni_ToReflectedField,
2039 
2040     checked_jni_Throw,
2041     checked_jni_ThrowNew,
2042     checked_jni_ExceptionOccurred,
2043     checked_jni_ExceptionDescribe,
2044     checked_jni_ExceptionClear,
2045     checked_jni_FatalError,
2046 
2047     checked_jni_PushLocalFrame,
2048     checked_jni_PopLocalFrame,
2049 
2050     checked_jni_NewGlobalRef,
2051     checked_jni_DeleteGlobalRef,
2052     checked_jni_DeleteLocalRef,
2053     checked_jni_IsSameObject,
2054 
2055     checked_jni_NewLocalRef,
2056     checked_jni_EnsureLocalCapacity,
2057 
2058     checked_jni_AllocObject,
2059     checked_jni_NewObject,
2060     checked_jni_NewObjectV,
2061     checked_jni_NewObjectA,
2062 
2063     checked_jni_GetObjectClass,
2064     checked_jni_IsInstanceOf,
2065 
2066     checked_jni_GetMethodID,
2067 
2068     checked_jni_CallObjectMethod,
2069     checked_jni_CallObjectMethodV,
2070     checked_jni_CallObjectMethodA,
2071     checked_jni_CallBooleanMethod,
2072     checked_jni_CallBooleanMethodV,
2073     checked_jni_CallBooleanMethodA,
2074     checked_jni_CallByteMethod,
2075     checked_jni_CallByteMethodV,
2076     checked_jni_CallByteMethodA,
2077     checked_jni_CallCharMethod,
2078     checked_jni_CallCharMethodV,
2079     checked_jni_CallCharMethodA,
2080     checked_jni_CallShortMethod,
2081     checked_jni_CallShortMethodV,
2082     checked_jni_CallShortMethodA,
2083     checked_jni_CallIntMethod,
2084     checked_jni_CallIntMethodV,
2085     checked_jni_CallIntMethodA,
2086     checked_jni_CallLongMethod,
2087     checked_jni_CallLongMethodV,
2088     checked_jni_CallLongMethodA,
2089     checked_jni_CallFloatMethod,
2090     checked_jni_CallFloatMethodV,
2091     checked_jni_CallFloatMethodA,
2092     checked_jni_CallDoubleMethod,
2093     checked_jni_CallDoubleMethodV,
2094     checked_jni_CallDoubleMethodA,
2095     checked_jni_CallVoidMethod,
2096     checked_jni_CallVoidMethodV,
2097     checked_jni_CallVoidMethodA,
2098 
2099     checked_jni_CallNonvirtualObjectMethod,
2100     checked_jni_CallNonvirtualObjectMethodV,
2101     checked_jni_CallNonvirtualObjectMethodA,
2102     checked_jni_CallNonvirtualBooleanMethod,
2103     checked_jni_CallNonvirtualBooleanMethodV,
2104     checked_jni_CallNonvirtualBooleanMethodA,
2105     checked_jni_CallNonvirtualByteMethod,
2106     checked_jni_CallNonvirtualByteMethodV,
2107     checked_jni_CallNonvirtualByteMethodA,
2108     checked_jni_CallNonvirtualCharMethod,
2109     checked_jni_CallNonvirtualCharMethodV,
2110     checked_jni_CallNonvirtualCharMethodA,
2111     checked_jni_CallNonvirtualShortMethod,
2112     checked_jni_CallNonvirtualShortMethodV,
2113     checked_jni_CallNonvirtualShortMethodA,
2114     checked_jni_CallNonvirtualIntMethod,
2115     checked_jni_CallNonvirtualIntMethodV,
2116     checked_jni_CallNonvirtualIntMethodA,
2117     checked_jni_CallNonvirtualLongMethod,
2118     checked_jni_CallNonvirtualLongMethodV,
2119     checked_jni_CallNonvirtualLongMethodA,
2120     checked_jni_CallNonvirtualFloatMethod,
2121     checked_jni_CallNonvirtualFloatMethodV,
2122     checked_jni_CallNonvirtualFloatMethodA,
2123     checked_jni_CallNonvirtualDoubleMethod,
2124     checked_jni_CallNonvirtualDoubleMethodV,
2125     checked_jni_CallNonvirtualDoubleMethodA,
2126     checked_jni_CallNonvirtualVoidMethod,
2127     checked_jni_CallNonvirtualVoidMethodV,
2128     checked_jni_CallNonvirtualVoidMethodA,
2129 
2130     checked_jni_GetFieldID,
2131 
2132     checked_jni_GetObjectField,
2133     checked_jni_GetBooleanField,
2134     checked_jni_GetByteField,
2135     checked_jni_GetCharField,
2136     checked_jni_GetShortField,
2137     checked_jni_GetIntField,
2138     checked_jni_GetLongField,
2139     checked_jni_GetFloatField,
2140     checked_jni_GetDoubleField,
2141 
2142     checked_jni_SetObjectField,
2143     checked_jni_SetBooleanField,
2144     checked_jni_SetByteField,
2145     checked_jni_SetCharField,
2146     checked_jni_SetShortField,
2147     checked_jni_SetIntField,
2148     checked_jni_SetLongField,
2149     checked_jni_SetFloatField,
2150     checked_jni_SetDoubleField,
2151 
2152     checked_jni_GetStaticMethodID,
2153 
2154     checked_jni_CallStaticObjectMethod,
2155     checked_jni_CallStaticObjectMethodV,
2156     checked_jni_CallStaticObjectMethodA,
2157     checked_jni_CallStaticBooleanMethod,
2158     checked_jni_CallStaticBooleanMethodV,
2159     checked_jni_CallStaticBooleanMethodA,
2160     checked_jni_CallStaticByteMethod,
2161     checked_jni_CallStaticByteMethodV,
2162     checked_jni_CallStaticByteMethodA,
2163     checked_jni_CallStaticCharMethod,
2164     checked_jni_CallStaticCharMethodV,
2165     checked_jni_CallStaticCharMethodA,
2166     checked_jni_CallStaticShortMethod,
2167     checked_jni_CallStaticShortMethodV,
2168     checked_jni_CallStaticShortMethodA,
2169     checked_jni_CallStaticIntMethod,
2170     checked_jni_CallStaticIntMethodV,
2171     checked_jni_CallStaticIntMethodA,
2172     checked_jni_CallStaticLongMethod,
2173     checked_jni_CallStaticLongMethodV,
2174     checked_jni_CallStaticLongMethodA,
2175     checked_jni_CallStaticFloatMethod,
2176     checked_jni_CallStaticFloatMethodV,
2177     checked_jni_CallStaticFloatMethodA,
2178     checked_jni_CallStaticDoubleMethod,
2179     checked_jni_CallStaticDoubleMethodV,
2180     checked_jni_CallStaticDoubleMethodA,
2181     checked_jni_CallStaticVoidMethod,
2182     checked_jni_CallStaticVoidMethodV,
2183     checked_jni_CallStaticVoidMethodA,
2184 
2185     checked_jni_GetStaticFieldID,
2186 
2187     checked_jni_GetStaticObjectField,
2188     checked_jni_GetStaticBooleanField,
2189     checked_jni_GetStaticByteField,
2190     checked_jni_GetStaticCharField,
2191     checked_jni_GetStaticShortField,
2192     checked_jni_GetStaticIntField,
2193     checked_jni_GetStaticLongField,
2194     checked_jni_GetStaticFloatField,
2195     checked_jni_GetStaticDoubleField,
2196 
2197     checked_jni_SetStaticObjectField,
2198     checked_jni_SetStaticBooleanField,
2199     checked_jni_SetStaticByteField,
2200     checked_jni_SetStaticCharField,
2201     checked_jni_SetStaticShortField,
2202     checked_jni_SetStaticIntField,
2203     checked_jni_SetStaticLongField,
2204     checked_jni_SetStaticFloatField,
2205     checked_jni_SetStaticDoubleField,
2206 
2207     checked_jni_NewString,
2208     checked_jni_GetStringLength,
2209     checked_jni_GetStringChars,
2210     checked_jni_ReleaseStringChars,
2211 
2212     checked_jni_NewStringUTF,
2213     checked_jni_GetStringUTFLength,
2214     checked_jni_GetStringUTFChars,
2215     checked_jni_ReleaseStringUTFChars,
2216 
2217     checked_jni_GetArrayLength,
2218 
2219     checked_jni_NewObjectArray,
2220     checked_jni_GetObjectArrayElement,
2221     checked_jni_SetObjectArrayElement,
2222 
2223     checked_jni_NewBooleanArray,
2224     checked_jni_NewByteArray,
2225     checked_jni_NewCharArray,
2226     checked_jni_NewShortArray,
2227     checked_jni_NewIntArray,
2228     checked_jni_NewLongArray,
2229     checked_jni_NewFloatArray,
2230     checked_jni_NewDoubleArray,
2231 
2232     checked_jni_GetBooleanArrayElements,
2233     checked_jni_GetByteArrayElements,
2234     checked_jni_GetCharArrayElements,
2235     checked_jni_GetShortArrayElements,
2236     checked_jni_GetIntArrayElements,
2237     checked_jni_GetLongArrayElements,
2238     checked_jni_GetFloatArrayElements,
2239     checked_jni_GetDoubleArrayElements,
2240 
2241     checked_jni_ReleaseBooleanArrayElements,
2242     checked_jni_ReleaseByteArrayElements,
2243     checked_jni_ReleaseCharArrayElements,
2244     checked_jni_ReleaseShortArrayElements,
2245     checked_jni_ReleaseIntArrayElements,
2246     checked_jni_ReleaseLongArrayElements,
2247     checked_jni_ReleaseFloatArrayElements,
2248     checked_jni_ReleaseDoubleArrayElements,
2249 
2250     checked_jni_GetBooleanArrayRegion,
2251     checked_jni_GetByteArrayRegion,
2252     checked_jni_GetCharArrayRegion,
2253     checked_jni_GetShortArrayRegion,
2254     checked_jni_GetIntArrayRegion,
2255     checked_jni_GetLongArrayRegion,
2256     checked_jni_GetFloatArrayRegion,
2257     checked_jni_GetDoubleArrayRegion,
2258 
2259     checked_jni_SetBooleanArrayRegion,
2260     checked_jni_SetByteArrayRegion,
2261     checked_jni_SetCharArrayRegion,
2262     checked_jni_SetShortArrayRegion,
2263     checked_jni_SetIntArrayRegion,
2264     checked_jni_SetLongArrayRegion,
2265     checked_jni_SetFloatArrayRegion,
2266     checked_jni_SetDoubleArrayRegion,
2267 
2268     checked_jni_RegisterNatives,
2269     checked_jni_UnregisterNatives,
2270 
2271     checked_jni_MonitorEnter,
2272     checked_jni_MonitorExit,
2273 
2274     checked_jni_GetJavaVM,
2275 
2276     checked_jni_GetStringRegion,
2277     checked_jni_GetStringUTFRegion,
2278 
2279     checked_jni_GetPrimitiveArrayCritical,
2280     checked_jni_ReleasePrimitiveArrayCritical,
2281 
2282     checked_jni_GetStringCritical,
2283     checked_jni_ReleaseStringCritical,
2284 
2285     checked_jni_NewWeakGlobalRef,
2286     checked_jni_DeleteWeakGlobalRef,
2287 
2288     checked_jni_ExceptionCheck,
2289 
2290     checked_jni_NewDirectByteBuffer,
2291     checked_jni_GetDirectBufferAddress,
2292     checked_jni_GetDirectBufferCapacity,
2293 
2294     // New 1.6 Features
2295 
2296     checked_jni_GetObjectRefType,
2297 
2298     // Module Features
2299 
2300     checked_jni_GetModule
2301 };
2302 
2303 
2304 // Returns the function structure
2305 struct JNINativeInterface_* jni_functions_check() {
2306 
2307   unchecked_jni_NativeInterface = jni_functions_nocheck();
2308 
2309   // make sure the last pointer in the checked table is not null, indicating
2310   // an addition to the JNINativeInterface_ structure without initializing
2311   // it in the checked table.
2312   debug_only(int *lastPtr = (int *)((char *)&amp;checked_jni_NativeInterface + \
2313              sizeof(*unchecked_jni_NativeInterface) - sizeof(char *));)
2314   assert(*lastPtr != 0,
2315          &quot;Mismatched JNINativeInterface tables, check for new entries&quot;);
2316 
2317   // with -verbose:jni this message will print
2318   log_debug(jni, resolve)(&quot;Checked JNI functions are being used to validate JNI usage&quot;);
2319 
2320   return &amp;checked_jni_NativeInterface;
2321 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
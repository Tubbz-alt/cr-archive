<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/methodHandles_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_x86_32.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/methodHandles_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
485       __ bind(L_incompatible_class_change_error);
486       __ jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));
487     }
488   }
489 }
490 
491 #ifndef PRODUCT
492 void trace_method_handle_stub(const char* adaptername,
493                               oop mh,
494                               intptr_t* saved_regs,
495                               intptr_t* entry_sp) {
496   // called as a leaf from native code: do not block the JVM!
497   bool has_mh = (strstr(adaptername, &quot;/static&quot;) == NULL &amp;&amp;
498                  strstr(adaptername, &quot;linkTo&quot;) == NULL);    // static linkers don&#39;t have MH
499   const char* mh_reg_name = has_mh ? &quot;rcx_mh&quot; : &quot;rcx&quot;;
500   tty-&gt;print_cr(&quot;MH %s %s=&quot; PTR_FORMAT &quot; sp=&quot; PTR_FORMAT,
501                 adaptername, mh_reg_name,
502                 p2i(mh), p2i(entry_sp));
503 
504   if (Verbose) {

505     tty-&gt;print_cr(&quot;Registers:&quot;);
506     const int saved_regs_count = RegisterImpl::number_of_registers;
507     for (int i = 0; i &lt; saved_regs_count; i++) {
508       Register r = as_Register(i);
509       // The registers are stored in reverse order on the stack (by pusha).
510 #ifdef AMD64
511       assert(RegisterImpl::number_of_registers == 16, &quot;sanity&quot;);
512       if (r == rsp) {
513         // rsp is actually not stored by pusha(), compute the old rsp from saved_regs (rsp after pusha): saved_regs + 16 = old rsp
514         tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), (intptr_t)(&amp;saved_regs[16]));
515       } else {
516         tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), saved_regs[((saved_regs_count - 1) - i)]);
517       }
518 #else
519       tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), saved_regs[((saved_regs_count - 1) - i)]);
520 #endif
521       if ((i + 1) % 4 == 0) {
522         tty-&gt;cr();
523       } else {
524         tty-&gt;print(&quot;, &quot;);
525       }
526     }
527     tty-&gt;cr();
528 
529     {
<span class="line-modified">530      // dumping last frame with frame::describe</span>
531 
532       JavaThread* p = JavaThread::active();
533 
<span class="line-modified">534       ResourceMark rm;</span>
<span class="line-removed">535       PRESERVE_EXCEPTION_MARK; // may not be needed by safer and unexpensive here</span>
536       FrameValues values;
537 
538       // Note: We want to allow trace_method_handle from any call site.
539       // While trace_method_handle creates a frame, it may be entered
540       // without a PC on the stack top (e.g. not just after a call).
541       // Walking that frame could lead to failures due to that invalid PC.
542       // =&gt; carefully detect that frame when doing the stack walking
543 
544       // Current C frame
545       frame cur_frame = os::current_frame();
546 
547       // Robust search of trace_calling_frame (independant of inlining).
548       // Assumes saved_regs comes from a pusha in the trace_calling_frame.
549       assert(cur_frame.sp() &lt; saved_regs, &quot;registers not saved on stack ?&quot;);
550       frame trace_calling_frame = os::get_sender_for_C_frame(&amp;cur_frame);
551       while (trace_calling_frame.fp() &lt; saved_regs) {
552         trace_calling_frame = os::get_sender_for_C_frame(&amp;trace_calling_frame);
553       }
554 
555       // safely create a frame and call frame::describe
</pre>
<hr />
<pre>
564         // failing. Alternatively, frame constructors could be
565         // modified to support the current or future non walkable
566         // frames (but this is more intrusive and is not considered as
567         // part of this RFE, which will instead use a simpler output).
568         frame dump_frame = frame(dump_sp, dump_fp);
569         dump_frame.describe(values, 1);
570       } else {
571         // Stack may not be walkable (invalid PC above FP):
572         // Add descriptions without building a Java frame to avoid issues
573         values.describe(-1, dump_fp, &quot;fp for #1 &lt;not parsed, cannot trust pc&gt;&quot;);
574         values.describe(-1, dump_sp, &quot;sp for #1&quot;);
575       }
576       values.describe(-1, entry_sp, &quot;raw top of stack&quot;);
577 
578       tty-&gt;print_cr(&quot;Stack layout:&quot;);
579       values.print(p);
580     }
581     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
582       mh-&gt;print();
583       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
<span class="line-modified">584         if (java_lang_invoke_MethodHandle::form_offset_in_bytes() != 0)</span>
585           java_lang_invoke_MethodHandle::form(mh)-&gt;print();

586       }
587     }
588   }
589 }
590 
591 // The stub wraps the arguments in a struct on the stack to avoid
592 // dealing with the different calling conventions for passing 6
593 // arguments.
594 struct MethodHandleStubArguments {
595   const char* adaptername;
596   oopDesc* mh;
597   intptr_t* saved_regs;
598   intptr_t* entry_sp;
599 };
600 void trace_method_handle_stub_wrapper(MethodHandleStubArguments* args) {
601   trace_method_handle_stub(args-&gt;adaptername,
602                            args-&gt;mh,
603                            args-&gt;saved_regs,
604                            args-&gt;entry_sp);
605 }
</pre>
</td>
<td>
<hr />
<pre>
485       __ bind(L_incompatible_class_change_error);
486       __ jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));
487     }
488   }
489 }
490 
491 #ifndef PRODUCT
492 void trace_method_handle_stub(const char* adaptername,
493                               oop mh,
494                               intptr_t* saved_regs,
495                               intptr_t* entry_sp) {
496   // called as a leaf from native code: do not block the JVM!
497   bool has_mh = (strstr(adaptername, &quot;/static&quot;) == NULL &amp;&amp;
498                  strstr(adaptername, &quot;linkTo&quot;) == NULL);    // static linkers don&#39;t have MH
499   const char* mh_reg_name = has_mh ? &quot;rcx_mh&quot; : &quot;rcx&quot;;
500   tty-&gt;print_cr(&quot;MH %s %s=&quot; PTR_FORMAT &quot; sp=&quot; PTR_FORMAT,
501                 adaptername, mh_reg_name,
502                 p2i(mh), p2i(entry_sp));
503 
504   if (Verbose) {
<span class="line-added">505     ResourceMark rm;</span>
506     tty-&gt;print_cr(&quot;Registers:&quot;);
507     const int saved_regs_count = RegisterImpl::number_of_registers;
508     for (int i = 0; i &lt; saved_regs_count; i++) {
509       Register r = as_Register(i);
510       // The registers are stored in reverse order on the stack (by pusha).
511 #ifdef AMD64
512       assert(RegisterImpl::number_of_registers == 16, &quot;sanity&quot;);
513       if (r == rsp) {
514         // rsp is actually not stored by pusha(), compute the old rsp from saved_regs (rsp after pusha): saved_regs + 16 = old rsp
515         tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), (intptr_t)(&amp;saved_regs[16]));
516       } else {
517         tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), saved_regs[((saved_regs_count - 1) - i)]);
518       }
519 #else
520       tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), saved_regs[((saved_regs_count - 1) - i)]);
521 #endif
522       if ((i + 1) % 4 == 0) {
523         tty-&gt;cr();
524       } else {
525         tty-&gt;print(&quot;, &quot;);
526       }
527     }
528     tty-&gt;cr();
529 
530     {
<span class="line-modified">531       // dumping last frame with frame::describe</span>
532 
533       JavaThread* p = JavaThread::active();
534 
<span class="line-modified">535       PRESERVE_EXCEPTION_MARK; // may not be needed but safer and inexpensive here</span>

536       FrameValues values;
537 
538       // Note: We want to allow trace_method_handle from any call site.
539       // While trace_method_handle creates a frame, it may be entered
540       // without a PC on the stack top (e.g. not just after a call).
541       // Walking that frame could lead to failures due to that invalid PC.
542       // =&gt; carefully detect that frame when doing the stack walking
543 
544       // Current C frame
545       frame cur_frame = os::current_frame();
546 
547       // Robust search of trace_calling_frame (independant of inlining).
548       // Assumes saved_regs comes from a pusha in the trace_calling_frame.
549       assert(cur_frame.sp() &lt; saved_regs, &quot;registers not saved on stack ?&quot;);
550       frame trace_calling_frame = os::get_sender_for_C_frame(&amp;cur_frame);
551       while (trace_calling_frame.fp() &lt; saved_regs) {
552         trace_calling_frame = os::get_sender_for_C_frame(&amp;trace_calling_frame);
553       }
554 
555       // safely create a frame and call frame::describe
</pre>
<hr />
<pre>
564         // failing. Alternatively, frame constructors could be
565         // modified to support the current or future non walkable
566         // frames (but this is more intrusive and is not considered as
567         // part of this RFE, which will instead use a simpler output).
568         frame dump_frame = frame(dump_sp, dump_fp);
569         dump_frame.describe(values, 1);
570       } else {
571         // Stack may not be walkable (invalid PC above FP):
572         // Add descriptions without building a Java frame to avoid issues
573         values.describe(-1, dump_fp, &quot;fp for #1 &lt;not parsed, cannot trust pc&gt;&quot;);
574         values.describe(-1, dump_sp, &quot;sp for #1&quot;);
575       }
576       values.describe(-1, entry_sp, &quot;raw top of stack&quot;);
577 
578       tty-&gt;print_cr(&quot;Stack layout:&quot;);
579       values.print(p);
580     }
581     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
582       mh-&gt;print();
583       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
<span class="line-modified">584         if (java_lang_invoke_MethodHandle::form_offset_in_bytes() != 0) {</span>
585           java_lang_invoke_MethodHandle::form(mh)-&gt;print();
<span class="line-added">586         }</span>
587       }
588     }
589   }
590 }
591 
592 // The stub wraps the arguments in a struct on the stack to avoid
593 // dealing with the different calling conventions for passing 6
594 // arguments.
595 struct MethodHandleStubArguments {
596   const char* adaptername;
597   oopDesc* mh;
598   intptr_t* saved_regs;
599   intptr_t* entry_sp;
600 };
601 void trace_method_handle_stub_wrapper(MethodHandleStubArguments* args) {
602   trace_method_handle_stub(args-&gt;adaptername,
603                            args-&gt;mh,
604                            args-&gt;saved_regs,
605                            args-&gt;entry_sp);
606 }
</pre>
</td>
</tr>
</table>
<center><a href="gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_x86_32.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
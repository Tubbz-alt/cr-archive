<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/gc/g1/g1BarrierSetAssembler_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../disassembler_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../globalDefinitions_ppc.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/gc/g1/g1BarrierSetAssembler_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
135   }
136   __ cmpdi(CCR0, tmp1, 0);
137   __ beq(CCR0, filtered);
138 
139   // Do we need to load the previous value?
140   if (!preloaded) {
141     // Load the previous value...
142     if (UseCompressedOops) {
143       __ lwz(pre_val, ind_or_offs, obj);
144     } else {
145       __ ld(pre_val, ind_or_offs, obj);
146     }
147     // Previous value has been loaded into Rpre_val.
148   }
149   assert(pre_val != noreg, &quot;must have a real register&quot;);
150 
151   // Is the previous value null?
152   if (preloaded &amp;&amp; not_null) {
153 #ifdef ASSERT
154     __ cmpdi(CCR0, pre_val, 0);
<span class="line-modified">155     __ asm_assert_ne(&quot;null oop not allowed (G1 pre)&quot;, 0x321); // Checked by caller.</span>
156 #endif
157   } else {
158     __ cmpdi(CCR0, pre_val, 0);
159     __ beq(CCR0, filtered);
160   }
161 
162   if (!preloaded &amp;&amp; UseCompressedOops) {
163     __ decode_heap_oop_not_null(pre_val);
164   }
165 
166   // OK, it&#39;s not filtered, so we&#39;ll need to call enqueue. In the normal
167   // case, pre_val will be a scratch G-reg, but there are some cases in
168   // which it&#39;s an O-reg. In the first case, do a normal call. In the
169   // latter, do a save here and call the frameless version.
170 
171   // Can we store original value in the thread&#39;s buffer?
172   // Is index == 0?
173   // (The index field is typed as size_t.)
174   const Register Rbuffer = tmp1, Rindex = tmp2;
175 
</pre>
<hr />
<pre>
206 }
207 
208 void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm, DecoratorSet decorators, Register store_addr, Register new_val,
209                                                   Register tmp1, Register tmp2, Register tmp3) {
210   bool not_null = (decorators &amp; IS_NOT_NULL) != 0;
211 
212   Label runtime, filtered;
213   assert_different_registers(store_addr, new_val, tmp1, tmp2);
214 
215   CardTableBarrierSet* ct = barrier_set_cast&lt;CardTableBarrierSet&gt;(BarrierSet::barrier_set());
216 
217   // Does store cross heap regions?
218   __ xorr(tmp1, store_addr, new_val);
219   __ srdi_(tmp1, tmp1, HeapRegion::LogOfHRGrainBytes);
220   __ beq(CCR0, filtered);
221 
222   // Crosses regions, storing NULL?
223   if (not_null) {
224 #ifdef ASSERT
225     __ cmpdi(CCR0, new_val, 0);
<span class="line-modified">226     __ asm_assert_ne(&quot;null oop not allowed (G1 post)&quot;, 0x322); // Checked by caller.</span>
227 #endif
228   } else {
229     __ cmpdi(CCR0, new_val, 0);
230     __ beq(CCR0, filtered);
231   }
232 
233   // Storing region crossing non-NULL, is card already dirty?
234   const Register Rcard_addr = tmp1;
235   Register Rbase = tmp2;
236   __ load_const_optimized(Rbase, (address)(ct-&gt;card_table()-&gt;byte_map_base()), /*temp*/ tmp3);
237 
238   __ srdi(Rcard_addr, store_addr, CardTable::card_shift);
239 
240   // Get the address of the card.
241   __ lbzx(/*card value*/ tmp3, Rbase, Rcard_addr);
242   __ cmpwi(CCR0, tmp3, (int)G1CardTable::g1_young_card_val());
243   __ beq(CCR0, filtered);
244 
245   __ membar(Assembler::StoreLoad);
246   __ lbzx(/*card value*/ tmp3, Rbase, Rcard_addr);  // Reload after membar.
</pre>
</td>
<td>
<hr />
<pre>
135   }
136   __ cmpdi(CCR0, tmp1, 0);
137   __ beq(CCR0, filtered);
138 
139   // Do we need to load the previous value?
140   if (!preloaded) {
141     // Load the previous value...
142     if (UseCompressedOops) {
143       __ lwz(pre_val, ind_or_offs, obj);
144     } else {
145       __ ld(pre_val, ind_or_offs, obj);
146     }
147     // Previous value has been loaded into Rpre_val.
148   }
149   assert(pre_val != noreg, &quot;must have a real register&quot;);
150 
151   // Is the previous value null?
152   if (preloaded &amp;&amp; not_null) {
153 #ifdef ASSERT
154     __ cmpdi(CCR0, pre_val, 0);
<span class="line-modified">155     __ asm_assert_ne(&quot;null oop not allowed (G1 pre)&quot;); // Checked by caller.</span>
156 #endif
157   } else {
158     __ cmpdi(CCR0, pre_val, 0);
159     __ beq(CCR0, filtered);
160   }
161 
162   if (!preloaded &amp;&amp; UseCompressedOops) {
163     __ decode_heap_oop_not_null(pre_val);
164   }
165 
166   // OK, it&#39;s not filtered, so we&#39;ll need to call enqueue. In the normal
167   // case, pre_val will be a scratch G-reg, but there are some cases in
168   // which it&#39;s an O-reg. In the first case, do a normal call. In the
169   // latter, do a save here and call the frameless version.
170 
171   // Can we store original value in the thread&#39;s buffer?
172   // Is index == 0?
173   // (The index field is typed as size_t.)
174   const Register Rbuffer = tmp1, Rindex = tmp2;
175 
</pre>
<hr />
<pre>
206 }
207 
208 void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm, DecoratorSet decorators, Register store_addr, Register new_val,
209                                                   Register tmp1, Register tmp2, Register tmp3) {
210   bool not_null = (decorators &amp; IS_NOT_NULL) != 0;
211 
212   Label runtime, filtered;
213   assert_different_registers(store_addr, new_val, tmp1, tmp2);
214 
215   CardTableBarrierSet* ct = barrier_set_cast&lt;CardTableBarrierSet&gt;(BarrierSet::barrier_set());
216 
217   // Does store cross heap regions?
218   __ xorr(tmp1, store_addr, new_val);
219   __ srdi_(tmp1, tmp1, HeapRegion::LogOfHRGrainBytes);
220   __ beq(CCR0, filtered);
221 
222   // Crosses regions, storing NULL?
223   if (not_null) {
224 #ifdef ASSERT
225     __ cmpdi(CCR0, new_val, 0);
<span class="line-modified">226     __ asm_assert_ne(&quot;null oop not allowed (G1 post)&quot;); // Checked by caller.</span>
227 #endif
228   } else {
229     __ cmpdi(CCR0, new_val, 0);
230     __ beq(CCR0, filtered);
231   }
232 
233   // Storing region crossing non-NULL, is card already dirty?
234   const Register Rcard_addr = tmp1;
235   Register Rbase = tmp2;
236   __ load_const_optimized(Rbase, (address)(ct-&gt;card_table()-&gt;byte_map_base()), /*temp*/ tmp3);
237 
238   __ srdi(Rcard_addr, store_addr, CardTable::card_shift);
239 
240   // Get the address of the card.
241   __ lbzx(/*card value*/ tmp3, Rbase, Rcard_addr);
242   __ cmpwi(CCR0, tmp3, (int)G1CardTable::g1_young_card_val());
243   __ beq(CCR0, filtered);
244 
245   __ membar(Assembler::StoreLoad);
246   __ lbzx(/*card value*/ tmp3, Rbase, Rcard_addr);  // Reload after membar.
</pre>
</td>
</tr>
</table>
<center><a href="../../disassembler_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../globalDefinitions_ppc.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
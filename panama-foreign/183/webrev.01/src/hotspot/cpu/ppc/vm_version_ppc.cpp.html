<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/ppc/vm_version_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2012, 2020 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;jvm.h&quot;
 28 #include &quot;asm/assembler.inline.hpp&quot;
 29 #include &quot;asm/macroAssembler.inline.hpp&quot;
 30 #include &quot;compiler/disassembler.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;runtime/os.hpp&quot;
 34 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 35 #include &quot;runtime/vm_version.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 #include &quot;utilities/defaultStream.hpp&quot;
 38 #include &quot;utilities/globalDefinitions.hpp&quot;
 39 #include &quot;utilities/powerOfTwo.hpp&quot;
 40 
 41 #include &lt;sys/sysinfo.h&gt;
 42 #if defined(_AIX)
 43 #include &lt;libperfstat.h&gt;
 44 #endif
 45 
 46 #if defined(LINUX) &amp;&amp; defined(VM_LITTLE_ENDIAN)
 47 #include &lt;sys/auxv.h&gt;
 48 
 49 #ifndef PPC_FEATURE2_HTM_NOSC
 50 #define PPC_FEATURE2_HTM_NOSC (1 &lt;&lt; 24)
 51 #endif
 52 #endif
 53 
 54 bool VM_Version::_is_determine_features_test_running = false;
 55 uint64_t VM_Version::_dscr_val = 0;
 56 
 57 #define MSG(flag)   \
 58   if (flag &amp;&amp; !FLAG_IS_DEFAULT(flag))                                  \
 59       jio_fprintf(defaultStream::error_stream(),                       \
 60                   &quot;warning: -XX:+&quot; #flag &quot; requires -XX:+UseSIGTRAP\n&quot; \
 61                   &quot;         -XX:+&quot; #flag &quot; will be disabled!\n&quot;);
 62 
 63 void VM_Version::initialize() {
 64 
 65   // Test which instructions are supported and measure cache line size.
 66   determine_features();
 67 
 68   // If PowerArchitecturePPC64 hasn&#39;t been specified explicitly determine from features.
 69   if (FLAG_IS_DEFAULT(PowerArchitecturePPC64)) {
 70     if (VM_Version::has_darn()) {
 71       FLAG_SET_ERGO(PowerArchitecturePPC64, 9);
 72     } else if (VM_Version::has_lqarx()) {
 73       FLAG_SET_ERGO(PowerArchitecturePPC64, 8);
 74     } else if (VM_Version::has_popcntw()) {
 75       FLAG_SET_ERGO(PowerArchitecturePPC64, 7);
 76     } else if (VM_Version::has_cmpb()) {
 77       FLAG_SET_ERGO(PowerArchitecturePPC64, 6);
 78     } else if (VM_Version::has_popcntb()) {
 79       FLAG_SET_ERGO(PowerArchitecturePPC64, 5);
 80     } else {
 81       FLAG_SET_ERGO(PowerArchitecturePPC64, 0);
 82     }
 83   }
 84 
 85   bool PowerArchitecturePPC64_ok = false;
 86   switch (PowerArchitecturePPC64) {
 87     case 9: if (!VM_Version::has_darn()   ) break;
 88     case 8: if (!VM_Version::has_lqarx()  ) break;
 89     case 7: if (!VM_Version::has_popcntw()) break;
 90     case 6: if (!VM_Version::has_cmpb()   ) break;
 91     case 5: if (!VM_Version::has_popcntb()) break;
 92     case 0: PowerArchitecturePPC64_ok = true; break;
 93     default: break;
 94   }
 95   guarantee(PowerArchitecturePPC64_ok, &quot;PowerArchitecturePPC64 cannot be set to &quot;
 96             UINTX_FORMAT &quot; on this machine&quot;, PowerArchitecturePPC64);
 97 
 98   // Power 8: Configure Data Stream Control Register.
 99   if (PowerArchitecturePPC64 &gt;= 8 &amp;&amp; has_mfdscr()) {
100     config_dscr();
101   }
102 
103   if (!UseSIGTRAP) {
104     MSG(TrapBasedICMissChecks);
105     MSG(TrapBasedNullChecks);
106     FLAG_SET_ERGO(TrapBasedNullChecks,       false);
107     FLAG_SET_ERGO(TrapBasedICMissChecks,     false);
108   }
109 
110 #ifdef COMPILER2
111   if (!UseSIGTRAP) {
112     MSG(TrapBasedRangeChecks);
113     FLAG_SET_ERGO(TrapBasedRangeChecks, false);
114   }
115 
116   // On Power6 test for section size.
117   if (PowerArchitecturePPC64 == 6) {
118     determine_section_size();
119   // TODO: PPC port } else {
120   // TODO: PPC port PdScheduling::power6SectorSize = 0x20;
121   }
122 
123   if (PowerArchitecturePPC64 &gt;= 8) {
124     if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {
125       FLAG_SET_ERGO(SuperwordUseVSX, true);
126     }
127   } else {
128     if (SuperwordUseVSX) {
129       warning(&quot;SuperwordUseVSX specified, but needs at least Power8.&quot;);
130       FLAG_SET_DEFAULT(SuperwordUseVSX, false);
131     }
132   }
133   MaxVectorSize = SuperwordUseVSX ? 16 : 8;
134 
135   if (PowerArchitecturePPC64 &gt;= 9) {
136     if (FLAG_IS_DEFAULT(UseCountTrailingZerosInstructionsPPC64)) {
137       FLAG_SET_ERGO(UseCountTrailingZerosInstructionsPPC64, true);
138     }
139     if (FLAG_IS_DEFAULT(UseCharacterCompareIntrinsics)) {
140       FLAG_SET_ERGO(UseCharacterCompareIntrinsics, true);
141     }
142     if (FLAG_IS_DEFAULT(UseVectorByteReverseInstructionsPPC64)) {
143       FLAG_SET_ERGO(UseVectorByteReverseInstructionsPPC64, true);
144     }
145   } else {
146     if (UseCountTrailingZerosInstructionsPPC64) {
147       warning(&quot;UseCountTrailingZerosInstructionsPPC64 specified, but needs at least Power9.&quot;);
148       FLAG_SET_DEFAULT(UseCountTrailingZerosInstructionsPPC64, false);
149     }
150     if (UseCharacterCompareIntrinsics) {
151       warning(&quot;UseCharacterCompareIntrinsics specified, but needs at least Power9.&quot;);
152       FLAG_SET_DEFAULT(UseCharacterCompareIntrinsics, false);
153     }
154     if (UseVectorByteReverseInstructionsPPC64) {
155       warning(&quot;UseVectorByteReverseInstructionsPPC64 specified, but needs at least Power9.&quot;);
156       FLAG_SET_DEFAULT(UseVectorByteReverseInstructionsPPC64, false);
157     }
158   }
159 #endif
160 
161   // Create and print feature-string.
162   char buf[(num_features+1) * 16]; // Max 16 chars per feature.
163   jio_snprintf(buf, sizeof(buf),
164                &quot;ppc64%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;,
165                (has_fsqrt()   ? &quot; fsqrt&quot;   : &quot;&quot;),
166                (has_isel()    ? &quot; isel&quot;    : &quot;&quot;),
167                (has_lxarxeh() ? &quot; lxarxeh&quot; : &quot;&quot;),
168                (has_cmpb()    ? &quot; cmpb&quot;    : &quot;&quot;),
169                (has_popcntb() ? &quot; popcntb&quot; : &quot;&quot;),
170                (has_popcntw() ? &quot; popcntw&quot; : &quot;&quot;),
171                (has_fcfids()  ? &quot; fcfids&quot;  : &quot;&quot;),
172                (has_vand()    ? &quot; vand&quot;    : &quot;&quot;),
173                (has_lqarx()   ? &quot; lqarx&quot;   : &quot;&quot;),
174                (has_vcipher() ? &quot; aes&quot;     : &quot;&quot;),
175                (has_vpmsumb() ? &quot; vpmsumb&quot; : &quot;&quot;),
176                (has_mfdscr()  ? &quot; mfdscr&quot;  : &quot;&quot;),
177                (has_vsx()     ? &quot; vsx&quot;     : &quot;&quot;),
178                (has_ldbrx()   ? &quot; ldbrx&quot;   : &quot;&quot;),
179                (has_stdbrx()  ? &quot; stdbrx&quot;  : &quot;&quot;),
180                (has_vshasig() ? &quot; sha&quot;     : &quot;&quot;),
181                (has_tm()      ? &quot; rtm&quot;     : &quot;&quot;),
182                (has_darn()    ? &quot; darn&quot;    : &quot;&quot;)
183                // Make sure number of %s matches num_features!
184               );
185   _features_string = os::strdup(buf);
186   if (Verbose) {
187     print_features();
188   }
189 
190   // PPC64 supports 8-byte compare-exchange operations (see Atomic::cmpxchg)
191   // and &#39;atomic long memory ops&#39; (see Unsafe_GetLongVolatile).
192   _supports_cx8 = true;
193 
194   // Used by C1.
195   _supports_atomic_getset4 = true;
196   _supports_atomic_getadd4 = true;
197   _supports_atomic_getset8 = true;
198   _supports_atomic_getadd8 = true;
199 
200   intx cache_line_size = L1_data_cache_line_size();
201 
202   if (PowerArchitecturePPC64 &gt;= 9) {
203     if (os::supports_map_sync() == true) {
204       _data_cache_line_flush_size = cache_line_size;
205     }
206   }
207 
208   if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) AllocatePrefetchStyle = 1;
209 
210   if (cache_line_size &gt; AllocatePrefetchStepSize) AllocatePrefetchStepSize = cache_line_size;
211   // PPC processors have an automatic prefetch engine.
212   if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 1;
213   if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 3 * cache_line_size;
214 
215   assert(AllocatePrefetchLines &gt; 0, &quot;invalid value&quot;);
216   if (AllocatePrefetchLines &lt; 1) { // Set valid value in product VM.
217     AllocatePrefetchLines = 1; // Conservative value.
218   }
219 
220   if (AllocatePrefetchStyle == 3 &amp;&amp; AllocatePrefetchDistance &lt; cache_line_size) {
221     AllocatePrefetchStyle = 1; // Fall back if inappropriate.
222   }
223 
224   assert(AllocatePrefetchStyle &gt;= 0, &quot;AllocatePrefetchStyle should be positive&quot;);
225 
226   if (FLAG_IS_DEFAULT(ContendedPaddingWidth) &amp;&amp; (cache_line_size &gt; ContendedPaddingWidth)) {
227     ContendedPaddingWidth = cache_line_size;
228   }
229 
230   // If running on Power8 or newer hardware, the implementation uses the available vector instructions.
231   // In all other cases, the implementation uses only generally available instructions.
232   if (!UseCRC32Intrinsics) {
233     if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {
234       FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);
235     }
236   }
237 
238   // Implementation does not use any of the vector instructions available with Power8.
239   // Their exploitation is still pending (aka &quot;work in progress&quot;).
240   if (!UseCRC32CIntrinsics) {
241     if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
242       FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
243     }
244   }
245 
246   // TODO: Provide implementation.
247   if (UseAdler32Intrinsics) {
248     warning(&quot;Adler32Intrinsics not available on this CPU.&quot;);
249     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
250   }
251 
252   // The AES intrinsic stubs require AES instruction support.
253   if (has_vcipher()) {
254     if (FLAG_IS_DEFAULT(UseAES)) {
255       UseAES = true;
256     }
257   } else if (UseAES) {
258     if (!FLAG_IS_DEFAULT(UseAES))
259       warning(&quot;AES instructions are not available on this CPU&quot;);
260     FLAG_SET_DEFAULT(UseAES, false);
261   }
262 
263   if (UseAES &amp;&amp; has_vcipher()) {
264     if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {
265       UseAESIntrinsics = true;
266     }
267   } else if (UseAESIntrinsics) {
268     if (!FLAG_IS_DEFAULT(UseAESIntrinsics))
269       warning(&quot;AES intrinsics are not available on this CPU&quot;);
270     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
271   }
272 
273   if (UseAESCTRIntrinsics) {
274     warning(&quot;AES/CTR intrinsics are not available on this CPU&quot;);
275     FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
276   }
277 
278   if (UseGHASHIntrinsics) {
279     warning(&quot;GHASH intrinsics are not available on this CPU&quot;);
280     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
281   }
282 
283   if (FLAG_IS_DEFAULT(UseFMA)) {
284     FLAG_SET_DEFAULT(UseFMA, true);
285   }
286 
287   if (has_vshasig()) {
288     if (FLAG_IS_DEFAULT(UseSHA)) {
289       UseSHA = true;
290     }
291   } else if (UseSHA) {
292     if (!FLAG_IS_DEFAULT(UseSHA))
293       warning(&quot;SHA instructions are not available on this CPU&quot;);
294     FLAG_SET_DEFAULT(UseSHA, false);
295   }
296 
297   if (UseSHA1Intrinsics) {
298     warning(&quot;Intrinsics for SHA-1 crypto hash functions not available on this CPU.&quot;);
299     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
300   }
301 
302   if (UseSHA &amp;&amp; has_vshasig()) {
303     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
304       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
305     }
306   } else if (UseSHA256Intrinsics) {
307     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
308     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
309   }
310 
311   if (UseSHA &amp;&amp; has_vshasig()) {
312     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
313       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
314     }
315   } else if (UseSHA512Intrinsics) {
316     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
317     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
318   }
319 
320   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
321     FLAG_SET_DEFAULT(UseSHA, false);
322   }
323 
324 #ifdef COMPILER2
325   if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {
326     UseSquareToLenIntrinsic = true;
327   }
328   if (FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {
329     UseMulAddIntrinsic = true;
330   }
331   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
332     UseMultiplyToLenIntrinsic = true;
333   }
334   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
335     UseMontgomeryMultiplyIntrinsic = true;
336   }
337   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
338     UseMontgomerySquareIntrinsic = true;
339   }
340 #endif
341 
342   if (UseVectorizedMismatchIntrinsic) {
343     warning(&quot;UseVectorizedMismatchIntrinsic specified, but not available on this CPU.&quot;);
344     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
345   }
346 
347 
348   // Adjust RTM (Restricted Transactional Memory) flags.
349   if (UseRTMLocking) {
350     // If CPU or OS do not support TM:
351     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
352     // setting during arguments processing. See use_biased_locking().
353     // VM_Version_init() is executed after UseBiasedLocking is used
354     // in Thread::allocate().
355     if (PowerArchitecturePPC64 &lt; 8) {
356       vm_exit_during_initialization(&quot;RTM instructions are not available on this CPU.&quot;);
357     }
358 
359     if (!has_tm()) {
360       vm_exit_during_initialization(&quot;RTM is not supported on this OS version.&quot;);
361     }
362   }
363 
364   if (UseRTMLocking) {
365 #if INCLUDE_RTM_OPT
366     if (!FLAG_IS_CMDLINE(UseRTMLocking)) {
367       // RTM locking should be used only for applications with
368       // high lock contention. For now we do not use it by default.
369       vm_exit_during_initialization(&quot;UseRTMLocking flag should be only set on command line&quot;);
370     }
371 #else
372     // Only C2 does RTM locking optimization.
373     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
374     // setting during arguments processing. See use_biased_locking().
375     vm_exit_during_initialization(&quot;RTM locking optimization is not supported in this VM&quot;);
376 #endif
377   } else { // !UseRTMLocking
378     if (UseRTMForStackLocks) {
379       if (!FLAG_IS_DEFAULT(UseRTMForStackLocks)) {
380         warning(&quot;UseRTMForStackLocks flag should be off when UseRTMLocking flag is off&quot;);
381       }
382       FLAG_SET_DEFAULT(UseRTMForStackLocks, false);
383     }
384     if (UseRTMDeopt) {
385       FLAG_SET_DEFAULT(UseRTMDeopt, false);
386     }
387 #ifdef COMPILER2
388     if (PrintPreciseRTMLockingStatistics) {
389       FLAG_SET_DEFAULT(PrintPreciseRTMLockingStatistics, false);
390     }
391 #endif
392   }
393 
394   // This machine allows unaligned memory accesses
395   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
396     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
397   }
398 
399   check_virtualizations();
400 }
401 
402 void VM_Version::check_virtualizations() {
403 #if defined(_AIX)
404   int rc = 0;
405   perfstat_partition_total_t pinfo;
406   rc = perfstat_partition_total(NULL, &amp;pinfo, sizeof(perfstat_partition_total_t), 1);
407   if (rc == 1) {
408     Abstract_VM_Version::_detected_virtualization = PowerVM;
409   }
410 #else
411   const char* info_file = &quot;/proc/ppc64/lparcfg&quot;;
412   // system_type=...qemu indicates PowerKVM
413   // e.g. system_type=IBM pSeries (emulated by qemu)
414   char line[500];
415   FILE* fp = fopen(info_file, &quot;r&quot;);
416   if (fp == NULL) {
417     return;
418   }
419   const char* system_type=&quot;system_type=&quot;;  // in case this line contains qemu, it is KVM
420   const char* num_lpars=&quot;NumLpars=&quot;; // in case of non-KVM : if this line is found it is PowerVM
421   bool num_lpars_found = false;
422 
423   while (fgets(line, sizeof(line), fp) != NULL) {
424     if (strncmp(line, system_type, strlen(system_type)) == 0) {
425       if (strstr(line, &quot;qemu&quot;) != 0) {
426         Abstract_VM_Version::_detected_virtualization = PowerKVM;
427         fclose(fp);
428         return;
429       }
430     }
431     if (strncmp(line, num_lpars, strlen(num_lpars)) == 0) {
432       num_lpars_found = true;
433     }
434   }
435   if (num_lpars_found) {
436     Abstract_VM_Version::_detected_virtualization = PowerVM;
437   } else {
438     Abstract_VM_Version::_detected_virtualization = PowerFullPartitionMode;
439   }
440   fclose(fp);
441 #endif
442 }
443 
444 void VM_Version::print_platform_virtualization_info(outputStream* st) {
445 #if defined(_AIX)
446   // more info about perfstat API see
447   // https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/com.ibm.aix.prftools/idprftools_perfstat_glob_partition.htm
448   int rc = 0;
449   perfstat_partition_total_t pinfo;
450   memset(&amp;pinfo, 0, sizeof(perfstat_partition_total_t));
451   rc = perfstat_partition_total(NULL, &amp;pinfo, sizeof(perfstat_partition_total_t), 1);
452   if (rc != 1) {
453     return;
454   } else {
455     st-&gt;print_cr(&quot;Virtualization type   : PowerVM&quot;);
456   }
457   // CPU information
458   perfstat_cpu_total_t cpuinfo;
459   memset(&amp;cpuinfo, 0, sizeof(perfstat_cpu_total_t));
460   rc = perfstat_cpu_total(NULL, &amp;cpuinfo, sizeof(perfstat_cpu_total_t), 1);
461   if (rc != 1) {
462     return;
463   }
464 
465   st-&gt;print_cr(&quot;Processor description : %s&quot;, cpuinfo.description);
466   st-&gt;print_cr(&quot;Processor speed       : %llu Hz&quot;, cpuinfo.processorHZ);
467 
468   st-&gt;print_cr(&quot;LPAR partition name           : %s&quot;, pinfo.name);
469   st-&gt;print_cr(&quot;LPAR partition number         : %u&quot;, pinfo.lpar_id);
470   st-&gt;print_cr(&quot;LPAR partition type           : %s&quot;, pinfo.type.b.shared_enabled ? &quot;shared&quot; : &quot;dedicated&quot;);
471   st-&gt;print_cr(&quot;LPAR mode                     : %s&quot;, pinfo.type.b.donate_enabled ? &quot;donating&quot; : pinfo.type.b.capped ? &quot;capped&quot; : &quot;uncapped&quot;);
472   st-&gt;print_cr(&quot;LPAR partition group ID       : %u&quot;, pinfo.group_id);
473   st-&gt;print_cr(&quot;LPAR shared pool ID           : %u&quot;, pinfo.pool_id);
474 
475   st-&gt;print_cr(&quot;AMS (active memory sharing)   : %s&quot;, pinfo.type.b.ams_capable ? &quot;capable&quot; : &quot;not capable&quot;);
476   st-&gt;print_cr(&quot;AMS (active memory sharing)   : %s&quot;, pinfo.type.b.ams_enabled ? &quot;on&quot; : &quot;off&quot;);
477   st-&gt;print_cr(&quot;AME (active memory expansion) : %s&quot;, pinfo.type.b.ame_enabled ? &quot;on&quot; : &quot;off&quot;);
478 
479   if (pinfo.type.b.ame_enabled) {
480     st-&gt;print_cr(&quot;AME true memory in bytes      : %llu&quot;, pinfo.true_memory);
481     st-&gt;print_cr(&quot;AME expanded memory in bytes  : %llu&quot;, pinfo.expanded_memory);
482   }
483 
484   st-&gt;print_cr(&quot;SMT : %s&quot;, pinfo.type.b.smt_capable ? &quot;capable&quot; : &quot;not capable&quot;);
485   st-&gt;print_cr(&quot;SMT : %s&quot;, pinfo.type.b.smt_enabled ? &quot;on&quot; : &quot;off&quot;);
486   int ocpus = pinfo.online_cpus &gt; 0 ?  pinfo.online_cpus : 1;
487   st-&gt;print_cr(&quot;LPAR threads              : %d&quot;, cpuinfo.ncpus/ocpus);
488   st-&gt;print_cr(&quot;LPAR online virtual cpus  : %d&quot;, pinfo.online_cpus);
489   st-&gt;print_cr(&quot;LPAR logical cpus         : %d&quot;, cpuinfo.ncpus);
490   st-&gt;print_cr(&quot;LPAR maximum virtual cpus : %u&quot;, pinfo.max_cpus);
491   st-&gt;print_cr(&quot;LPAR minimum virtual cpus : %u&quot;, pinfo.min_cpus);
492   st-&gt;print_cr(&quot;LPAR entitled capacity    : %4.2f&quot;, (double) (pinfo.entitled_proc_capacity/100.0));
493   st-&gt;print_cr(&quot;LPAR online memory        : %llu MB&quot;, pinfo.online_memory);
494   st-&gt;print_cr(&quot;LPAR maximum memory       : %llu MB&quot;, pinfo.max_memory);
495   st-&gt;print_cr(&quot;LPAR minimum memory       : %llu MB&quot;, pinfo.min_memory);
496 #else
497   const char* info_file = &quot;/proc/ppc64/lparcfg&quot;;
498   const char* kw[] = { &quot;system_type=&quot;, // qemu indicates PowerKVM
499                        &quot;partition_entitled_capacity=&quot;, // entitled processor capacity percentage
500                        &quot;partition_max_entitled_capacity=&quot;,
501                        &quot;capacity_weight=&quot;, // partition CPU weight
502                        &quot;partition_active_processors=&quot;,
503                        &quot;partition_potential_processors=&quot;,
504                        &quot;entitled_proc_capacity_available=&quot;,
505                        &quot;capped=&quot;, // 0 - uncapped, 1 - vcpus capped at entitled processor capacity percentage
506                        &quot;shared_processor_mode=&quot;, // (non)dedicated partition
507                        &quot;system_potential_processors=&quot;,
508                        &quot;pool=&quot;, // CPU-pool number
509                        &quot;pool_capacity=&quot;,
510                        &quot;NumLpars=&quot;, // on non-KVM machines, NumLpars is not found for full partition mode machines
511                        NULL };
512   if (!print_matching_lines_from_file(info_file, st, kw)) {
513     st-&gt;print_cr(&quot;  &lt;%s Not Available&gt;&quot;, info_file);
514   }
515 #endif
516 }
517 
518 bool VM_Version::use_biased_locking() {
519 #if INCLUDE_RTM_OPT
520   // RTM locking is most useful when there is high lock contention and
521   // low data contention. With high lock contention the lock is usually
522   // inflated and biased locking is not suitable for that case.
523   // RTM locking code requires that biased locking is off.
524   // Note: we can&#39;t switch off UseBiasedLocking in get_processor_features()
525   // because it is used by Thread::allocate() which is called before
526   // VM_Version::initialize().
527   if (UseRTMLocking &amp;&amp; UseBiasedLocking) {
528     if (FLAG_IS_DEFAULT(UseBiasedLocking)) {
529       FLAG_SET_DEFAULT(UseBiasedLocking, false);
530     } else {
531       warning(&quot;Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.&quot; );
532       UseBiasedLocking = false;
533     }
534   }
535 #endif
536   return UseBiasedLocking;
537 }
538 
539 void VM_Version::print_features() {
540   tty-&gt;print_cr(&quot;Version: %s L1_data_cache_line_size=%d&quot;, features_string(), L1_data_cache_line_size());
541 
542   if (Verbose) {
543     if (ContendedPaddingWidth &gt; 0) {
544       tty-&gt;cr();
545       tty-&gt;print_cr(&quot;ContendedPaddingWidth &quot; INTX_FORMAT, ContendedPaddingWidth);
546     }
547   }
548 }
549 
550 #ifdef COMPILER2
551 // Determine section size on power6: If section size is 8 instructions,
552 // there should be a difference between the two testloops of ~15 %. If
553 // no difference is detected the section is assumed to be 32 instructions.
554 void VM_Version::determine_section_size() {
555 
556   int unroll = 80;
557 
558   const int code_size = (2* unroll * 32 + 100)*BytesPerInstWord;
559 
560   // Allocate space for the code.
561   ResourceMark rm;
562   CodeBuffer cb(&quot;detect_section_size&quot;, code_size, 0);
563   MacroAssembler* a = new MacroAssembler(&amp;cb);
564 
565   uint32_t *code = (uint32_t *)a-&gt;pc();
566   // Emit code.
567   void (*test1)() = (void(*)())(void *)a-&gt;function_entry();
568 
569   Label l1;
570 
571   a-&gt;li(R4, 1);
572   a-&gt;sldi(R4, R4, 28);
573   a-&gt;b(l1);
574   a-&gt;align(CodeEntryAlignment);
575 
576   a-&gt;bind(l1);
577 
578   for (int i = 0; i &lt; unroll; i++) {
579     // Schleife 1
580     // ------- sector 0 ------------
581     // ;; 0
582     a-&gt;nop();                   // 1
583     a-&gt;fpnop0();                // 2
584     a-&gt;fpnop1();                // 3
585     a-&gt;addi(R4,R4, -1); // 4
586 
587     // ;;  1
588     a-&gt;nop();                   // 5
589     a-&gt;fmr(F6, F6);             // 6
590     a-&gt;fmr(F7, F7);             // 7
591     a-&gt;endgroup();              // 8
592     // ------- sector 8 ------------
593 
594     // ;;  2
595     a-&gt;nop();                   // 9
596     a-&gt;nop();                   // 10
597     a-&gt;fmr(F8, F8);             // 11
598     a-&gt;fmr(F9, F9);             // 12
599 
600     // ;;  3
601     a-&gt;nop();                   // 13
602     a-&gt;fmr(F10, F10);           // 14
603     a-&gt;fmr(F11, F11);           // 15
604     a-&gt;endgroup();              // 16
605     // -------- sector 16 -------------
606 
607     // ;;  4
608     a-&gt;nop();                   // 17
609     a-&gt;nop();                   // 18
610     a-&gt;fmr(F15, F15);           // 19
611     a-&gt;fmr(F16, F16);           // 20
612 
613     // ;;  5
614     a-&gt;nop();                   // 21
615     a-&gt;fmr(F17, F17);           // 22
616     a-&gt;fmr(F18, F18);           // 23
617     a-&gt;endgroup();              // 24
618     // ------- sector 24  ------------
619 
620     // ;;  6
621     a-&gt;nop();                   // 25
622     a-&gt;nop();                   // 26
623     a-&gt;fmr(F19, F19);           // 27
624     a-&gt;fmr(F20, F20);           // 28
625 
626     // ;;  7
627     a-&gt;nop();                   // 29
628     a-&gt;fmr(F21, F21);           // 30
629     a-&gt;fmr(F22, F22);           // 31
630     a-&gt;brnop0();                // 32
631 
632     // ------- sector 32 ------------
633   }
634 
635   // ;; 8
636   a-&gt;cmpdi(CCR0, R4, unroll);   // 33
637   a-&gt;bge(CCR0, l1);             // 34
638   a-&gt;blr();
639 
640   // Emit code.
641   void (*test2)() = (void(*)())(void *)a-&gt;function_entry();
642   // uint32_t *code = (uint32_t *)a-&gt;pc();
643 
644   Label l2;
645 
646   a-&gt;li(R4, 1);
647   a-&gt;sldi(R4, R4, 28);
648   a-&gt;b(l2);
649   a-&gt;align(CodeEntryAlignment);
650 
651   a-&gt;bind(l2);
652 
653   for (int i = 0; i &lt; unroll; i++) {
654     // Schleife 2
655     // ------- sector 0 ------------
656     // ;; 0
657     a-&gt;brnop0();                  // 1
658     a-&gt;nop();                     // 2
659     //a-&gt;cmpdi(CCR0, R4, unroll);
660     a-&gt;fpnop0();                  // 3
661     a-&gt;fpnop1();                  // 4
662     a-&gt;addi(R4,R4, -1);           // 5
663 
664     // ;; 1
665 
666     a-&gt;nop();                     // 6
667     a-&gt;fmr(F6, F6);               // 7
668     a-&gt;fmr(F7, F7);               // 8
669     // ------- sector 8 ---------------
670 
671     // ;; 2
672     a-&gt;endgroup();                // 9
673 
674     // ;; 3
675     a-&gt;nop();                     // 10
676     a-&gt;nop();                     // 11
677     a-&gt;fmr(F8, F8);               // 12
678 
679     // ;; 4
680     a-&gt;fmr(F9, F9);               // 13
681     a-&gt;nop();                     // 14
682     a-&gt;fmr(F10, F10);             // 15
683 
684     // ;; 5
685     a-&gt;fmr(F11, F11);             // 16
686     // -------- sector 16 -------------
687 
688     // ;; 6
689     a-&gt;endgroup();                // 17
690 
691     // ;; 7
692     a-&gt;nop();                     // 18
693     a-&gt;nop();                     // 19
694     a-&gt;fmr(F15, F15);             // 20
695 
696     // ;; 8
697     a-&gt;fmr(F16, F16);             // 21
698     a-&gt;nop();                     // 22
699     a-&gt;fmr(F17, F17);             // 23
700 
701     // ;; 9
702     a-&gt;fmr(F18, F18);             // 24
703     // -------- sector 24 -------------
704 
705     // ;; 10
706     a-&gt;endgroup();                // 25
707 
708     // ;; 11
709     a-&gt;nop();                     // 26
710     a-&gt;nop();                     // 27
711     a-&gt;fmr(F19, F19);             // 28
712 
713     // ;; 12
714     a-&gt;fmr(F20, F20);             // 29
715     a-&gt;nop();                     // 30
716     a-&gt;fmr(F21, F21);             // 31
717 
718     // ;; 13
719     a-&gt;fmr(F22, F22);             // 32
720   }
721 
722   // -------- sector 32 -------------
723   // ;; 14
724   a-&gt;cmpdi(CCR0, R4, unroll); // 33
725   a-&gt;bge(CCR0, l2);           // 34
726 
727   a-&gt;blr();
728   uint32_t *code_end = (uint32_t *)a-&gt;pc();
729   a-&gt;flush();
730 
731   cb.insts()-&gt;set_end((u_char*)code_end);
732 
733   double loop1_seconds,loop2_seconds, rel_diff;
734   uint64_t start1, stop1;
735 
736   start1 = os::current_thread_cpu_time(false);
737   (*test1)();
738   stop1 = os::current_thread_cpu_time(false);
739   loop1_seconds = (stop1- start1) / (1000 *1000 *1000.0);
740 
741 
742   start1 = os::current_thread_cpu_time(false);
743   (*test2)();
744   stop1 = os::current_thread_cpu_time(false);
745 
746   loop2_seconds = (stop1 - start1) / (1000 *1000 *1000.0);
747 
748   rel_diff = (loop2_seconds - loop1_seconds) / loop1_seconds *100;
749 
750   if (PrintAssembly || PrintStubCode) {
751     ttyLocker ttyl;
752     tty-&gt;print_cr(&quot;Decoding section size detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
753     // Use existing decode function. This enables the [MachCode] format which is needed to DecodeErrorFile.
754     Disassembler::decode(&amp;cb, (u_char*)code, (u_char*)code_end, tty);
755     tty-&gt;print_cr(&quot;Time loop1 :%f&quot;, loop1_seconds);
756     tty-&gt;print_cr(&quot;Time loop2 :%f&quot;, loop2_seconds);
757     tty-&gt;print_cr(&quot;(time2 - time1) / time1 = %f %%&quot;, rel_diff);
758 
759     if (rel_diff &gt; 12.0) {
760       tty-&gt;print_cr(&quot;Section Size 8 Instructions&quot;);
761     } else{
762       tty-&gt;print_cr(&quot;Section Size 32 Instructions or Power5&quot;);
763     }
764   }
765 
766 #if 0 // TODO: PPC port
767   // Set sector size (if not set explicitly).
768   if (FLAG_IS_DEFAULT(Power6SectorSize128PPC64)) {
769     if (rel_diff &gt; 12.0) {
770       PdScheduling::power6SectorSize = 0x20;
771     } else {
772       PdScheduling::power6SectorSize = 0x80;
773     }
774   } else if (Power6SectorSize128PPC64) {
775     PdScheduling::power6SectorSize = 0x80;
776   } else {
777     PdScheduling::power6SectorSize = 0x20;
778   }
779 #endif
780   if (UsePower6SchedulerPPC64) Unimplemented();
781 }
782 #endif // COMPILER2
783 
784 void VM_Version::determine_features() {
785 #if defined(ABI_ELFv2)
786   // 1 InstWord per call for the blr instruction.
787   const int code_size = (num_features+1+2*1)*BytesPerInstWord;
788 #else
789   // 7 InstWords for each call (function descriptor + blr instruction).
790   const int code_size = (num_features+1+2*7)*BytesPerInstWord;
791 #endif
792   int features = 0;
793 
794   // create test area
795   enum { BUFFER_SIZE = 2*4*K }; // Needs to be &gt;=2* max cache line size (cache line size can&#39;t exceed min page size).
796   char test_area[BUFFER_SIZE];
797   char *mid_of_test_area = &amp;test_area[BUFFER_SIZE&gt;&gt;1];
798 
799   // Allocate space for the code.
800   ResourceMark rm;
801   CodeBuffer cb(&quot;detect_cpu_features&quot;, code_size, 0);
802   MacroAssembler* a = new MacroAssembler(&amp;cb);
803 
804   // Must be set to true so we can generate the test code.
805   _features = VM_Version::all_features_m;
806 
807   // Emit code.
808   void (*test)(address addr, uint64_t offset)=(void(*)(address addr, uint64_t offset))(void *)a-&gt;function_entry();
809   uint32_t *code = (uint32_t *)a-&gt;pc();
810   // Don&#39;t use R0 in ldarx.
811   // Keep R3_ARG1 unmodified, it contains &amp;field (see below).
812   // Keep R4_ARG2 unmodified, it contains offset = 0 (see below).
813   a-&gt;fsqrt(F3, F4);                            // code[0]  -&gt; fsqrt_m
814   a-&gt;fsqrts(F3, F4);                           // code[1]  -&gt; fsqrts_m
815   a-&gt;isel(R7, R5, R6, 0);                      // code[2]  -&gt; isel_m
816   a-&gt;ldarx_unchecked(R7, R3_ARG1, R4_ARG2, 1); // code[3]  -&gt; lxarx_m
817   a-&gt;cmpb(R7, R5, R6);                         // code[4]  -&gt; cmpb
818   a-&gt;popcntb(R7, R5);                          // code[5]  -&gt; popcntb
819   a-&gt;popcntw(R7, R5);                          // code[6]  -&gt; popcntw
820   a-&gt;fcfids(F3, F4);                           // code[7]  -&gt; fcfids
821   a-&gt;vand(VR0, VR0, VR0);                      // code[8]  -&gt; vand
822   // arg0 of lqarx must be an even register, (arg1 + arg2) must be a multiple of 16
823   a-&gt;lqarx_unchecked(R6, R3_ARG1, R4_ARG2, 1); // code[9]  -&gt; lqarx_m
824   a-&gt;vcipher(VR0, VR1, VR2);                   // code[10] -&gt; vcipher
825   a-&gt;vpmsumb(VR0, VR1, VR2);                   // code[11] -&gt; vpmsumb
826   a-&gt;mfdscr(R0);                               // code[12] -&gt; mfdscr
827   a-&gt;lxvd2x(VSR0, R3_ARG1);                    // code[13] -&gt; vsx
828   a-&gt;ldbrx(R7, R3_ARG1, R4_ARG2);              // code[14] -&gt; ldbrx
829   a-&gt;stdbrx(R7, R3_ARG1, R4_ARG2);             // code[15] -&gt; stdbrx
830   a-&gt;vshasigmaw(VR0, VR1, 1, 0xF);             // code[16] -&gt; vshasig
831   // rtm is determined by OS
832   a-&gt;darn(R7);                                 // code[17] -&gt; darn
833   a-&gt;blr();
834 
835   // Emit function to set one cache line to zero. Emit function descriptor and get pointer to it.
836   void (*zero_cacheline_func_ptr)(char*) = (void(*)(char*))(void *)a-&gt;function_entry();
837   a-&gt;dcbz(R3_ARG1); // R3_ARG1 = addr
838   a-&gt;blr();
839 
840   uint32_t *code_end = (uint32_t *)a-&gt;pc();
841   a-&gt;flush();
842   _features = VM_Version::unknown_m;
843 
844   // Print the detection code.
845   if (PrintAssembly) {
846     ttyLocker ttyl;
847     tty-&gt;print_cr(&quot;Decoding cpu-feature detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
848     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
849   }
850 
851   // Measure cache line size.
852   memset(test_area, 0xFF, BUFFER_SIZE); // Fill test area with 0xFF.
853   (*zero_cacheline_func_ptr)(mid_of_test_area); // Call function which executes dcbz to the middle.
854   int count = 0; // count zeroed bytes
855   for (int i = 0; i &lt; BUFFER_SIZE; i++) if (test_area[i] == 0) count++;
856   guarantee(is_power_of_2(count), &quot;cache line size needs to be a power of 2&quot;);
857   _L1_data_cache_line_size = count;
858 
859   // Execute code. Illegal instructions will be replaced by 0 in the signal handler.
860   VM_Version::_is_determine_features_test_running = true;
861   // We must align the first argument to 16 bytes because of the lqarx check.
862   (*test)(align_up((address)mid_of_test_area, 16), 0);
863   VM_Version::_is_determine_features_test_running = false;
864 
865   // determine which instructions are legal.
866   int feature_cntr = 0;
867   if (code[feature_cntr++]) features |= fsqrt_m;
868   if (code[feature_cntr++]) features |= fsqrts_m;
869   if (code[feature_cntr++]) features |= isel_m;
870   if (code[feature_cntr++]) features |= lxarxeh_m;
871   if (code[feature_cntr++]) features |= cmpb_m;
872   if (code[feature_cntr++]) features |= popcntb_m;
873   if (code[feature_cntr++]) features |= popcntw_m;
874   if (code[feature_cntr++]) features |= fcfids_m;
875   if (code[feature_cntr++]) features |= vand_m;
876   if (code[feature_cntr++]) features |= lqarx_m;
877   if (code[feature_cntr++]) features |= vcipher_m;
878   if (code[feature_cntr++]) features |= vpmsumb_m;
879   if (code[feature_cntr++]) features |= mfdscr_m;
880   if (code[feature_cntr++]) features |= vsx_m;
881   if (code[feature_cntr++]) features |= ldbrx_m;
882   if (code[feature_cntr++]) features |= stdbrx_m;
883   if (code[feature_cntr++]) features |= vshasig_m;
884   // feature rtm_m is determined by OS
885   if (code[feature_cntr++]) features |= darn_m;
886 
887   // Print the detection code.
888   if (PrintAssembly) {
889     ttyLocker ttyl;
890     tty-&gt;print_cr(&quot;Decoding cpu-feature detection stub at &quot; INTPTR_FORMAT &quot; after execution:&quot;, p2i(code));
891     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
892   }
893 
894   _features = features;
895 
896 #ifdef AIX
897   // To enable it on AIX it&#39;s necessary POWER8 or above and at least AIX 7.2.
898   // Actually, this is supported since AIX 7.1.. Unfortunately, this first
899   // contained bugs, so that it can only be enabled after AIX 7.1.3.30.
900   // The Java property os.version, which is used in RTM tests to decide
901   // whether the feature is available, only knows major and minor versions.
902   // We don&#39;t want to change this property, as user code might depend on it.
903   // So the tests can not check on subversion 3.30, and we only enable RTM
904   // with AIX 7.2.
905   if (has_lqarx()) { // POWER8 or above
906     if (os::Aix::os_version() &gt;= 0x07020000) { // At least AIX 7.2.
907       _features |= rtm_m;
908     }
909   }
910 #endif
911 #if defined(LINUX) &amp;&amp; defined(VM_LITTLE_ENDIAN)
912   unsigned long auxv = getauxval(AT_HWCAP2);
913 
914   if (auxv &amp; PPC_FEATURE2_HTM_NOSC) {
915     if (auxv &amp; PPC_FEATURE2_HAS_HTM) {
916       // TM on POWER8 and POWER9 in compat mode (VM) is supported by the JVM.
917       // TM on POWER9 DD2.1 NV (baremetal) is not supported by the JVM (TM on
918       // POWER9 DD2.1 NV has a few issues that need a couple of firmware
919       // and kernel workarounds, so there is a new mode only supported
920       // on non-virtualized P9 machines called HTM with no Suspend Mode).
921       // TM on POWER9 D2.2+ NV is not supported at all by Linux.
922       _features |= rtm_m;
923     }
924   }
925 #endif
926 }
927 
928 // Power 8: Configure Data Stream Control Register.
929 void VM_Version::config_dscr() {
930   // 7 InstWords for each call (function descriptor + blr instruction).
931   const int code_size = (2+2*7)*BytesPerInstWord;
932 
933   // Allocate space for the code.
934   ResourceMark rm;
935   CodeBuffer cb(&quot;config_dscr&quot;, code_size, 0);
936   MacroAssembler* a = new MacroAssembler(&amp;cb);
937 
938   // Emit code.
939   uint64_t (*get_dscr)() = (uint64_t(*)())(void *)a-&gt;function_entry();
940   uint32_t *code = (uint32_t *)a-&gt;pc();
941   a-&gt;mfdscr(R3);
942   a-&gt;blr();
943 
944   void (*set_dscr)(long) = (void(*)(long))(void *)a-&gt;function_entry();
945   a-&gt;mtdscr(R3);
946   a-&gt;blr();
947 
948   uint32_t *code_end = (uint32_t *)a-&gt;pc();
949   a-&gt;flush();
950 
951   // Print the detection code.
952   if (PrintAssembly) {
953     ttyLocker ttyl;
954     tty-&gt;print_cr(&quot;Decoding dscr configuration stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
955     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
956   }
957 
958   // Apply the configuration if needed.
959   _dscr_val = (*get_dscr)();
960   if (Verbose) {
961     tty-&gt;print_cr(&quot;dscr value was 0x%lx&quot; , _dscr_val);
962   }
963   bool change_requested = false;
964   if (DSCR_PPC64 != (uintx)-1) {
965     _dscr_val = DSCR_PPC64;
966     change_requested = true;
967   }
968   if (DSCR_DPFD_PPC64 &lt;= 7) {
969     uint64_t mask = 0x7;
970     if ((_dscr_val &amp; mask) != DSCR_DPFD_PPC64) {
971       _dscr_val = (_dscr_val &amp; ~mask) | (DSCR_DPFD_PPC64);
972       change_requested = true;
973     }
974   }
975   if (DSCR_URG_PPC64 &lt;= 7) {
976     uint64_t mask = 0x7 &lt;&lt; 6;
977     if ((_dscr_val &amp; mask) != DSCR_DPFD_PPC64 &lt;&lt; 6) {
978       _dscr_val = (_dscr_val &amp; ~mask) | (DSCR_URG_PPC64 &lt;&lt; 6);
979       change_requested = true;
980     }
981   }
982   if (change_requested) {
983     (*set_dscr)(_dscr_val);
984     if (Verbose) {
985       tty-&gt;print_cr(&quot;dscr was set to 0x%lx&quot; , (*get_dscr)());
986     }
987   }
988 }
989 
990 static uint64_t saved_features = 0;
991 
992 void VM_Version::allow_all() {
993   saved_features = _features;
994   _features      = all_features_m;
995 }
996 
997 void VM_Version::revert() {
998   _features = saved_features;
999 }
    </pre>
  </body>
</html>
diff a/src/hotspot/cpu/ppc/c1_FrameMap_ppc.cpp b/src/hotspot/cpu/ppc/c1_FrameMap_ppc.cpp
--- a/src/hotspot/cpu/ppc/c1_FrameMap_ppc.cpp
+++ b/src/hotspot/cpu/ppc/c1_FrameMap_ppc.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2012, 2019 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -40,11 +40,11 @@
   if (r_1->is_stack()) {
     // Convert stack slot to an SP offset.
     // The calling convention does not count the SharedRuntime::out_preserve_stack_slots() value
     // so we must add it in here.
     int st_off = (r_1->reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
-    opr = LIR_OprFact::address(new LIR_Address(SP_opr, st_off + STACK_BIAS, type));
+    opr = LIR_OprFact::address(new LIR_Address(SP_opr, st_off, type));
   } else if (r_1->is_Register()) {
     Register reg = r_1->as_Register();
     //if (outgoing) {
     //  assert(!reg->is_in(), "should be using I regs");
     //} else {
@@ -360,11 +360,11 @@
   }
 }
 
 
 Address FrameMap::make_new_address(ByteSize sp_offset) const {
-  return Address(R1_SP, STACK_BIAS + in_bytes(sp_offset));
+  return Address(R1_SP, in_bytes(sp_offset));
 }
 
 
 VMReg FrameMap::fpu_regname (int n) {
   return as_FloatRegister(n)->as_VMReg();
@@ -392,7 +392,7 @@
     if (opr->is_stack()) {
       max_offset = MAX2(_argument_locations->at(java_index), max_offset);
     }
     java_index += type2size[opr->type()];
   }
-  return Assembler::is_simm16(max_offset + STACK_BIAS);
+  return Assembler::is_simm16(max_offset);
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/TestByteBuffer.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../ProblemList.txt.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestLayoutAttributes.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/TestByteBuffer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 61 import java.nio.channels.FileChannel;
 62 import java.nio.file.Files;
 63 import java.nio.file.Path;
 64 import java.nio.file.StandardOpenOption;
 65 import java.util.HashMap;
 66 import java.util.Map;
 67 import java.util.function.BiConsumer;
 68 import java.util.function.BiFunction;
 69 import java.util.function.Consumer;
 70 import java.util.function.Function;
 71 import java.util.function.Predicate;
 72 import java.util.stream.Stream;
 73 
 74 import jdk.internal.foreign.HeapMemorySegmentImpl;
 75 import jdk.internal.foreign.MappedMemorySegmentImpl;
 76 import jdk.internal.foreign.MemoryAddressImpl;
 77 import jdk.internal.foreign.NativeMemorySegmentImpl;
 78 import org.testng.SkipException;
 79 import org.testng.annotations.*;
 80 import sun.nio.ch.DirectBuffer;
<span class="line-modified"> 81 </span>
 82 import static org.testng.Assert.*;
 83 
 84 public class TestByteBuffer {
 85 
 86     static Path tempPath;
 87 
 88     static {
 89         try {
 90             File file = File.createTempFile(&quot;buffer&quot;, &quot;txt&quot;);
 91             file.deleteOnExit();
 92             tempPath = file.toPath();
 93             Files.write(file.toPath(), new byte[256], StandardOpenOption.WRITE);
 94 
 95         } catch (IOException ex) {
 96             throw new ExceptionInInitializerError(ex);
 97         }
 98     }
 99 
100     static SequenceLayout tuples = MemoryLayout.ofSequence(500,
101             MemoryLayout.ofStruct(
</pre>
<hr />
<pre>
219         //write to channel
220         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
221             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -&gt; {
222                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
223                 MemoryAddress base = segment.baseAddress();
224                 initTuples(base);
225                 mbb.force();
226             });
227         }
228 
229         //read from channel
230         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
231             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -&gt; {
232                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
233                 MemoryAddress base = segment.baseAddress();
234                 checkTuples(base, mbb);
235             });
236         }
237     }
238 















239     @Test
240     public void testMappedSegment() throws Throwable {
241         File f = new File(&quot;test2.out&quot;);
242         f.createNewFile();
243         f.deleteOnExit();
244 
245         //write to channel
246         try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
247             MemoryAddress base = segment.baseAddress();
248             initTuples(base);
249             segment.force();
250         }
251 
252         //read from channel
253         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
254             MemoryAddress base = segment.baseAddress();
255             checkTuples(base, segment.asByteBuffer());
256         }
257     }
258 
</pre>
<hr />
<pre>
429         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
430              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
431             initializer.accept(heapArray.baseAddress());
432             nativeArray.copyFrom(heapArray);
433             checker.accept(nativeArray.baseAddress());
434         }
435     }
436 
437     @Test(dataProvider=&quot;resizeOps&quot;)
438     public void testCopyNativeToHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
439         checkByteArrayAlignment(seq.elementLayout());
440         int bytes = (int)seq.byteSize();
441         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
442              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
443             initializer.accept(nativeArray.baseAddress());
444             heapArray.copyFrom(nativeArray);
445             checker.accept(heapArray.baseAddress());
446         }
447     }
448 















449     @Test(dataProvider=&quot;bufferSources&quot;)
450     public void testBufferToSegment(ByteBuffer bb, Predicate&lt;MemorySegment&gt; segmentChecker) {
451         MemorySegment segment = MemorySegment.ofByteBuffer(bb);
452         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
453         assertTrue(segmentChecker.test(segment));
454         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
455         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
456         assertEquals(bb.capacity(), segment.byteSize());
457         //another round trip
458         segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());
459         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
460         assertTrue(segmentChecker.test(segment));
461         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
462         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
463         assertEquals(bb.capacity(), segment.byteSize());
464     }
465 
466     @Test
467     public void testRoundTripAccess() {
468         try(MemorySegment ms = MemorySegment.allocateNative(4)) {
</pre>
</td>
<td>
<hr />
<pre>
 61 import java.nio.channels.FileChannel;
 62 import java.nio.file.Files;
 63 import java.nio.file.Path;
 64 import java.nio.file.StandardOpenOption;
 65 import java.util.HashMap;
 66 import java.util.Map;
 67 import java.util.function.BiConsumer;
 68 import java.util.function.BiFunction;
 69 import java.util.function.Consumer;
 70 import java.util.function.Function;
 71 import java.util.function.Predicate;
 72 import java.util.stream.Stream;
 73 
 74 import jdk.internal.foreign.HeapMemorySegmentImpl;
 75 import jdk.internal.foreign.MappedMemorySegmentImpl;
 76 import jdk.internal.foreign.MemoryAddressImpl;
 77 import jdk.internal.foreign.NativeMemorySegmentImpl;
 78 import org.testng.SkipException;
 79 import org.testng.annotations.*;
 80 import sun.nio.ch.DirectBuffer;
<span class="line-modified"> 81 import static jdk.incubator.foreign.MemorySegment.*;</span>
 82 import static org.testng.Assert.*;
 83 
 84 public class TestByteBuffer {
 85 
 86     static Path tempPath;
 87 
 88     static {
 89         try {
 90             File file = File.createTempFile(&quot;buffer&quot;, &quot;txt&quot;);
 91             file.deleteOnExit();
 92             tempPath = file.toPath();
 93             Files.write(file.toPath(), new byte[256], StandardOpenOption.WRITE);
 94 
 95         } catch (IOException ex) {
 96             throw new ExceptionInInitializerError(ex);
 97         }
 98     }
 99 
100     static SequenceLayout tuples = MemoryLayout.ofSequence(500,
101             MemoryLayout.ofStruct(
</pre>
<hr />
<pre>
219         //write to channel
220         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
221             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -&gt; {
222                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
223                 MemoryAddress base = segment.baseAddress();
224                 initTuples(base);
225                 mbb.force();
226             });
227         }
228 
229         //read from channel
230         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
231             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -&gt; {
232                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
233                 MemoryAddress base = segment.baseAddress();
234                 checkTuples(base, mbb);
235             });
236         }
237     }
238 
<span class="line-added">239     static final int ALL_ACCESS_MODES = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;</span>
<span class="line-added">240 </span>
<span class="line-added">241     @Test</span>
<span class="line-added">242     public void testDefaultAccessModesMappedSegment() throws Throwable {</span>
<span class="line-added">243         try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 8, FileChannel.MapMode.READ_WRITE)) {</span>
<span class="line-added">244             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES));</span>
<span class="line-added">245             assertEquals(segment.accessModes(), ALL_ACCESS_MODES);</span>
<span class="line-added">246         }</span>
<span class="line-added">247 </span>
<span class="line-added">248         try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 8, FileChannel.MapMode.READ_ONLY)) {</span>
<span class="line-added">249             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES &amp; ~WRITE));</span>
<span class="line-added">250             assertEquals(segment.accessModes(), ALL_ACCESS_MODES&amp; ~WRITE);</span>
<span class="line-added">251         }</span>
<span class="line-added">252     }</span>
<span class="line-added">253 </span>
254     @Test
255     public void testMappedSegment() throws Throwable {
256         File f = new File(&quot;test2.out&quot;);
257         f.createNewFile();
258         f.deleteOnExit();
259 
260         //write to channel
261         try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
262             MemoryAddress base = segment.baseAddress();
263             initTuples(base);
264             segment.force();
265         }
266 
267         //read from channel
268         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
269             MemoryAddress base = segment.baseAddress();
270             checkTuples(base, segment.asByteBuffer());
271         }
272     }
273 
</pre>
<hr />
<pre>
444         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
445              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
446             initializer.accept(heapArray.baseAddress());
447             nativeArray.copyFrom(heapArray);
448             checker.accept(nativeArray.baseAddress());
449         }
450     }
451 
452     @Test(dataProvider=&quot;resizeOps&quot;)
453     public void testCopyNativeToHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
454         checkByteArrayAlignment(seq.elementLayout());
455         int bytes = (int)seq.byteSize();
456         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
457              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
458             initializer.accept(nativeArray.baseAddress());
459             heapArray.copyFrom(nativeArray);
460             checker.accept(heapArray.baseAddress());
461         }
462     }
463 
<span class="line-added">464     @Test</span>
<span class="line-added">465     public void testDefaultAccessModesOfBuffer() {</span>
<span class="line-added">466         ByteBuffer rwBuffer = ByteBuffer.wrap(new byte[4]);</span>
<span class="line-added">467         try (MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer)) {</span>
<span class="line-added">468             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES));</span>
<span class="line-added">469             assertEquals(segment.accessModes(), ALL_ACCESS_MODES);</span>
<span class="line-added">470         }</span>
<span class="line-added">471 </span>
<span class="line-added">472         ByteBuffer roBuffer = rwBuffer.asReadOnlyBuffer();</span>
<span class="line-added">473         try (MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer)) {</span>
<span class="line-added">474             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES &amp; ~WRITE));</span>
<span class="line-added">475             assertEquals(segment.accessModes(), ALL_ACCESS_MODES &amp; ~WRITE);</span>
<span class="line-added">476         }</span>
<span class="line-added">477     }</span>
<span class="line-added">478 </span>
479     @Test(dataProvider=&quot;bufferSources&quot;)
480     public void testBufferToSegment(ByteBuffer bb, Predicate&lt;MemorySegment&gt; segmentChecker) {
481         MemorySegment segment = MemorySegment.ofByteBuffer(bb);
482         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
483         assertTrue(segmentChecker.test(segment));
484         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
485         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
486         assertEquals(bb.capacity(), segment.byteSize());
487         //another round trip
488         segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());
489         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
490         assertTrue(segmentChecker.test(segment));
491         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
492         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
493         assertEquals(bb.capacity(), segment.byteSize());
494     }
495 
496     @Test
497     public void testRoundTripAccess() {
498         try(MemorySegment ms = MemorySegment.allocateNative(4)) {
</pre>
</td>
</tr>
</table>
<center><a href="../../ProblemList.txt.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestLayoutAttributes.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
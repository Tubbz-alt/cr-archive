<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/googletest/include/gtest/internal/gtest-type-util.h.pump</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 $$ -*- mode: c++; -*-
  2 $var n = 50  $$ Maximum length of type lists we want to support.
  3 // Copyright 2008 Google Inc.
  4 // All Rights Reserved.
  5 //
  6 // Redistribution and use in source and binary forms, with or without
  7 // modification, are permitted provided that the following conditions are
  8 // met:
  9 //
 10 //     * Redistributions of source code must retain the above copyright
 11 // notice, this list of conditions and the following disclaimer.
 12 //     * Redistributions in binary form must reproduce the above
 13 // copyright notice, this list of conditions and the following disclaimer
 14 // in the documentation and/or other materials provided with the
 15 // distribution.
 16 //     * Neither the name of Google Inc. nor the names of its
 17 // contributors may be used to endorse or promote products derived from
 18 // this software without specific prior written permission.
 19 //
 20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 21 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 22 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 23 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 24 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 25 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 26 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 27 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 28 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31 
 32 
 33 // Type utilities needed for implementing typed and type-parameterized
 34 // tests.  This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!
 35 //
 36 // Currently we support at most $n types in a list, and at most $n
 37 // type-parameterized tests in one type-parameterized test case.
 38 // Please contact googletestframework@googlegroups.com if you need
 39 // more.
 40 
 41 // GOOGLETEST_CM0001 DO NOT DELETE
 42 
 43 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_
 44 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_
 45 
 46 #include &quot;gtest/internal/gtest-port.h&quot;
 47 
 48 // #ifdef __GNUC__ is too general here.  It is possible to use gcc without using
 49 // libstdc++ (which is where cxxabi.h comes from).
 50 # if GTEST_HAS_CXXABI_H_
 51 #  include &lt;cxxabi.h&gt;
 52 # elif defined(__HP_aCC)
 53 #  include &lt;acxx_demangle.h&gt;
 54 # endif  // GTEST_HASH_CXXABI_H_
 55 
 56 namespace testing {
 57 namespace internal {
 58 
 59 // Canonicalizes a given name with respect to the Standard C++ Library.
 60 // This handles removing the inline namespace within `std` that is
 61 // used by various standard libraries (e.g., `std::__1`).  Names outside
 62 // of namespace std are returned unmodified.
 63 inline std::string CanonicalizeForStdLibVersioning(std::string s) {
 64   static const char prefix[] = &quot;std::__&quot;;
 65   if (s.compare(0, strlen(prefix), prefix) == 0) {
 66     std::string::size_type end = s.find(&quot;::&quot;, strlen(prefix));
 67     if (end != s.npos) {
 68       // Erase everything between the initial `std` and the second `::`.
 69       s.erase(strlen(&quot;std&quot;), end - strlen(&quot;std&quot;));
 70     }
 71   }
 72   return s;
 73 }
 74 
 75 // GetTypeName&lt;T&gt;() returns a human-readable name of type T.
 76 // NB: This function is also used in Google Mock, so don&#39;t move it inside of
 77 // the typed-test-only section below.
 78 template &lt;typename T&gt;
 79 std::string GetTypeName() {
 80 # if GTEST_HAS_RTTI
 81 
 82   const char* const name = typeid(T).name();
 83 #  if GTEST_HAS_CXXABI_H_ || defined(__HP_aCC)
 84   int status = 0;
 85   // gcc&#39;s implementation of typeid(T).name() mangles the type name,
 86   // so we have to demangle it.
 87 #   if GTEST_HAS_CXXABI_H_
 88   using abi::__cxa_demangle;
 89 #   endif  // GTEST_HAS_CXXABI_H_
 90   char* const readable_name = __cxa_demangle(name, 0, 0, &amp;status);
 91   const std::string name_str(status == 0 ? readable_name : name);
 92   free(readable_name);
 93   return CanonicalizeForStdLibVersioning(name_str);
 94 #  else
 95   return name;
 96 #  endif  // GTEST_HAS_CXXABI_H_ || __HP_aCC
 97 
 98 # else
 99 
100   return &quot;&lt;type&gt;&quot;;
101 
102 # endif  // GTEST_HAS_RTTI
103 }
104 
105 #if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
106 
107 // AssertyTypeEq&lt;T1, T2&gt;::type is defined iff T1 and T2 are the same
108 // type.  This can be used as a compile-time assertion to ensure that
109 // two types are equal.
110 
111 template &lt;typename T1, typename T2&gt;
112 struct AssertTypeEq;
113 
114 template &lt;typename T&gt;
115 struct AssertTypeEq&lt;T, T&gt; {
116   typedef bool type;
117 };
118 
119 // A unique type used as the default value for the arguments of class
120 // template Types.  This allows us to simulate variadic templates
121 // (e.g. Types&lt;int&gt;, Type&lt;int, double&gt;, and etc), which C++ doesn&#39;t
122 // support directly.
123 struct None {};
124 
125 // The following family of struct and struct templates are used to
126 // represent type lists.  In particular, TypesN&lt;T1, T2, ..., TN&gt;
127 // represents a type list with N types (T1, T2, ..., and TN) in it.
128 // Except for Types0, every struct in the family has two member types:
129 // Head for the first type in the list, and Tail for the rest of the
130 // list.
131 
132 // The empty type list.
133 struct Types0 {};
134 
135 // Type lists of length 1, 2, 3, and so on.
136 
137 template &lt;typename T1&gt;
138 struct Types1 {
139   typedef T1 Head;
140   typedef Types0 Tail;
141 };
142 
143 $range i 2..n
144 
145 $for i [[
146 $range j 1..i
147 $range k 2..i
148 template &lt;$for j, [[typename T$j]]&gt;
149 struct Types$i {
150   typedef T1 Head;
151   typedef Types$(i-1)&lt;$for k, [[T$k]]&gt; Tail;
152 };
153 
154 
155 ]]
156 
157 }  // namespace internal
158 
159 // We don&#39;t want to require the users to write TypesN&lt;...&gt; directly,
160 // as that would require them to count the length.  Types&lt;...&gt; is much
161 // easier to write, but generates horrible messages when there is a
162 // compiler error, as gcc insists on printing out each template
163 // argument, even if it has the default value (this means Types&lt;int&gt;
164 // will appear as Types&lt;int, None, None, ..., None&gt; in the compiler
165 // errors).
166 //
167 // Our solution is to combine the best part of the two approaches: a
168 // user would write Types&lt;T1, ..., TN&gt;, and Google Test will translate
169 // that to TypesN&lt;T1, ..., TN&gt; internally to make error messages
170 // readable.  The translation is done by the &#39;type&#39; member of the
171 // Types template.
172 
173 $range i 1..n
174 template &lt;$for i, [[typename T$i = internal::None]]&gt;
175 struct Types {
176   typedef internal::Types$n&lt;$for i, [[T$i]]&gt; type;
177 };
178 
179 template &lt;&gt;
180 struct Types&lt;$for i, [[internal::None]]&gt; {
181   typedef internal::Types0 type;
182 };
183 
184 $range i 1..n-1
185 $for i [[
186 $range j 1..i
187 $range k i+1..n
188 template &lt;$for j, [[typename T$j]]&gt;
189 struct Types&lt;$for j, [[T$j]]$for k[[, internal::None]]&gt; {
190   typedef internal::Types$i&lt;$for j, [[T$j]]&gt; type;
191 };
192 
193 ]]
194 
195 namespace internal {
196 
197 # define GTEST_TEMPLATE_ template &lt;typename T&gt; class
198 
199 // The template &quot;selector&quot; struct TemplateSel&lt;Tmpl&gt; is used to
200 // represent Tmpl, which must be a class template with one type
201 // parameter, as a type.  TemplateSel&lt;Tmpl&gt;::Bind&lt;T&gt;::type is defined
202 // as the type Tmpl&lt;T&gt;.  This allows us to actually instantiate the
203 // template &quot;selected&quot; by TemplateSel&lt;Tmpl&gt;.
204 //
205 // This trick is necessary for simulating typedef for class templates,
206 // which C++ doesn&#39;t support directly.
207 template &lt;GTEST_TEMPLATE_ Tmpl&gt;
208 struct TemplateSel {
209   template &lt;typename T&gt;
210   struct Bind {
211     typedef Tmpl&lt;T&gt; type;
212   };
213 };
214 
215 # define GTEST_BIND_(TmplSel, T) \
216   TmplSel::template Bind&lt;T&gt;::type
217 
218 // A unique struct template used as the default value for the
219 // arguments of class template Templates.  This allows us to simulate
220 // variadic templates (e.g. Templates&lt;int&gt;, Templates&lt;int, double&gt;,
221 // and etc), which C++ doesn&#39;t support directly.
222 template &lt;typename T&gt;
223 struct NoneT {};
224 
225 // The following family of struct and struct templates are used to
226 // represent template lists.  In particular, TemplatesN&lt;T1, T2, ...,
227 // TN&gt; represents a list of N templates (T1, T2, ..., and TN).  Except
228 // for Templates0, every struct in the family has two member types:
229 // Head for the selector of the first template in the list, and Tail
230 // for the rest of the list.
231 
232 // The empty template list.
233 struct Templates0 {};
234 
235 // Template lists of length 1, 2, 3, and so on.
236 
237 template &lt;GTEST_TEMPLATE_ T1&gt;
238 struct Templates1 {
239   typedef TemplateSel&lt;T1&gt; Head;
240   typedef Templates0 Tail;
241 };
242 
243 $range i 2..n
244 
245 $for i [[
246 $range j 1..i
247 $range k 2..i
248 template &lt;$for j, [[GTEST_TEMPLATE_ T$j]]&gt;
249 struct Templates$i {
250   typedef TemplateSel&lt;T1&gt; Head;
251   typedef Templates$(i-1)&lt;$for k, [[T$k]]&gt; Tail;
252 };
253 
254 
255 ]]
256 
257 // We don&#39;t want to require the users to write TemplatesN&lt;...&gt; directly,
258 // as that would require them to count the length.  Templates&lt;...&gt; is much
259 // easier to write, but generates horrible messages when there is a
260 // compiler error, as gcc insists on printing out each template
261 // argument, even if it has the default value (this means Templates&lt;list&gt;
262 // will appear as Templates&lt;list, NoneT, NoneT, ..., NoneT&gt; in the compiler
263 // errors).
264 //
265 // Our solution is to combine the best part of the two approaches: a
266 // user would write Templates&lt;T1, ..., TN&gt;, and Google Test will translate
267 // that to TemplatesN&lt;T1, ..., TN&gt; internally to make error messages
268 // readable.  The translation is done by the &#39;type&#39; member of the
269 // Templates template.
270 
271 $range i 1..n
272 template &lt;$for i, [[GTEST_TEMPLATE_ T$i = NoneT]]&gt;
273 struct Templates {
274   typedef Templates$n&lt;$for i, [[T$i]]&gt; type;
275 };
276 
277 template &lt;&gt;
278 struct Templates&lt;$for i, [[NoneT]]&gt; {
279   typedef Templates0 type;
280 };
281 
282 $range i 1..n-1
283 $for i [[
284 $range j 1..i
285 $range k i+1..n
286 template &lt;$for j, [[GTEST_TEMPLATE_ T$j]]&gt;
287 struct Templates&lt;$for j, [[T$j]]$for k[[, NoneT]]&gt; {
288   typedef Templates$i&lt;$for j, [[T$j]]&gt; type;
289 };
290 
291 ]]
292 
293 // The TypeList template makes it possible to use either a single type
294 // or a Types&lt;...&gt; list in TYPED_TEST_CASE() and
295 // INSTANTIATE_TYPED_TEST_CASE_P().
296 
297 template &lt;typename T&gt;
298 struct TypeList {
299   typedef Types1&lt;T&gt; type;
300 };
301 
302 
303 $range i 1..n
304 template &lt;$for i, [[typename T$i]]&gt;
305 struct TypeList&lt;Types&lt;$for i, [[T$i]]&gt; &gt; {
306   typedef typename Types&lt;$for i, [[T$i]]&gt;::type type;
307 };
308 
309 #endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
310 
311 }  // namespace internal
312 }  // namespace testing
313 
314 #endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_
    </pre>
  </body>
</html>
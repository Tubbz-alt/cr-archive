<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/googletest/include/gtest/gtest-param-test.h.pump</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 $$ -*- mode: c++; -*-
  2 $var n = 50  $$ Maximum length of Values arguments we want to support.
  3 $var maxtuple = 10  $$ Maximum number of Combine arguments we want to support.
  4 // Copyright 2008, Google Inc.
  5 // All rights reserved.
  6 //
  7 // Redistribution and use in source and binary forms, with or without
  8 // modification, are permitted provided that the following conditions are
  9 // met:
 10 //
 11 //     * Redistributions of source code must retain the above copyright
 12 // notice, this list of conditions and the following disclaimer.
 13 //     * Redistributions in binary form must reproduce the above
 14 // copyright notice, this list of conditions and the following disclaimer
 15 // in the documentation and/or other materials provided with the
 16 // distribution.
 17 //     * Neither the name of Google Inc. nor the names of its
 18 // contributors may be used to endorse or promote products derived from
 19 // this software without specific prior written permission.
 20 //
 21 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 22 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 23 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 24 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 25 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 26 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 27 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 28 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 29 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 30 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 31 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32 //
 33 // Macros and functions for implementing parameterized tests
 34 // in Google C++ Testing and Mocking Framework (Google Test)
 35 //
 36 // This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!
 37 //
 38 // GOOGLETEST_CM0001 DO NOT DELETE
 39 #ifndef GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_
 40 #define GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_
 41 
 42 
 43 // Value-parameterized tests allow you to test your code with different
 44 // parameters without writing multiple copies of the same test.
 45 //
 46 // Here is how you use value-parameterized tests:
 47 
 48 #if 0
 49 
 50 // To write value-parameterized tests, first you should define a fixture
 51 // class. It is usually derived from testing::TestWithParam&lt;T&gt; (see below for
 52 // another inheritance scheme that&#39;s sometimes useful in more complicated
 53 // class hierarchies), where the type of your parameter values.
 54 // TestWithParam&lt;T&gt; is itself derived from testing::Test. T can be any
 55 // copyable type. If it&#39;s a raw pointer, you are responsible for managing the
 56 // lifespan of the pointed values.
 57 
 58 class FooTest : public ::testing::TestWithParam&lt;const char*&gt; {
 59   // You can implement all the usual class fixture members here.
 60 };
 61 
 62 // Then, use the TEST_P macro to define as many parameterized tests
 63 // for this fixture as you want. The _P suffix is for &quot;parameterized&quot;
 64 // or &quot;pattern&quot;, whichever you prefer to think.
 65 
 66 TEST_P(FooTest, DoesBlah) {
 67   // Inside a test, access the test parameter with the GetParam() method
 68   // of the TestWithParam&lt;T&gt; class:
 69   EXPECT_TRUE(foo.Blah(GetParam()));
 70   ...
 71 }
 72 
 73 TEST_P(FooTest, HasBlahBlah) {
 74   ...
 75 }
 76 
 77 // Finally, you can use INSTANTIATE_TEST_CASE_P to instantiate the test
 78 // case with any set of parameters you want. Google Test defines a number
 79 // of functions for generating test parameters. They return what we call
 80 // (surprise!) parameter generators. Here is a summary of them, which
 81 // are all in the testing namespace:
 82 //
 83 //
 84 //  Range(begin, end [, step]) - Yields values {begin, begin+step,
 85 //                               begin+step+step, ...}. The values do not
 86 //                               include end. step defaults to 1.
 87 //  Values(v1, v2, ..., vN)    - Yields values {v1, v2, ..., vN}.
 88 //  ValuesIn(container)        - Yields values from a C-style array, an STL
 89 //  ValuesIn(begin,end)          container, or an iterator range [begin, end).
 90 //  Bool()                     - Yields sequence {false, true}.
 91 //  Combine(g1, g2, ..., gN)   - Yields all combinations (the Cartesian product
 92 //                               for the math savvy) of the values generated
 93 //                               by the N generators.
 94 //
 95 // For more details, see comments at the definitions of these functions below
 96 // in this file.
 97 //
 98 // The following statement will instantiate tests from the FooTest test case
 99 // each with parameter values &quot;meeny&quot;, &quot;miny&quot;, and &quot;moe&quot;.
100 
101 INSTANTIATE_TEST_CASE_P(InstantiationName,
102                         FooTest,
103                         Values(&quot;meeny&quot;, &quot;miny&quot;, &quot;moe&quot;));
104 
105 // To distinguish different instances of the pattern, (yes, you
106 // can instantiate it more then once) the first argument to the
107 // INSTANTIATE_TEST_CASE_P macro is a prefix that will be added to the
108 // actual test case name. Remember to pick unique prefixes for different
109 // instantiations. The tests from the instantiation above will have
110 // these names:
111 //
112 //    * InstantiationName/FooTest.DoesBlah/0 for &quot;meeny&quot;
113 //    * InstantiationName/FooTest.DoesBlah/1 for &quot;miny&quot;
114 //    * InstantiationName/FooTest.DoesBlah/2 for &quot;moe&quot;
115 //    * InstantiationName/FooTest.HasBlahBlah/0 for &quot;meeny&quot;
116 //    * InstantiationName/FooTest.HasBlahBlah/1 for &quot;miny&quot;
117 //    * InstantiationName/FooTest.HasBlahBlah/2 for &quot;moe&quot;
118 //
119 // You can use these names in --gtest_filter.
120 //
121 // This statement will instantiate all tests from FooTest again, each
122 // with parameter values &quot;cat&quot; and &quot;dog&quot;:
123 
124 const char* pets[] = {&quot;cat&quot;, &quot;dog&quot;};
125 INSTANTIATE_TEST_CASE_P(AnotherInstantiationName, FooTest, ValuesIn(pets));
126 
127 // The tests from the instantiation above will have these names:
128 //
129 //    * AnotherInstantiationName/FooTest.DoesBlah/0 for &quot;cat&quot;
130 //    * AnotherInstantiationName/FooTest.DoesBlah/1 for &quot;dog&quot;
131 //    * AnotherInstantiationName/FooTest.HasBlahBlah/0 for &quot;cat&quot;
132 //    * AnotherInstantiationName/FooTest.HasBlahBlah/1 for &quot;dog&quot;
133 //
134 // Please note that INSTANTIATE_TEST_CASE_P will instantiate all tests
135 // in the given test case, whether their definitions come before or
136 // AFTER the INSTANTIATE_TEST_CASE_P statement.
137 //
138 // Please also note that generator expressions (including parameters to the
139 // generators) are evaluated in InitGoogleTest(), after main() has started.
140 // This allows the user on one hand, to adjust generator parameters in order
141 // to dynamically determine a set of tests to run and on the other hand,
142 // give the user a chance to inspect the generated tests with Google Test
143 // reflection API before RUN_ALL_TESTS() is executed.
144 //
145 // You can see samples/sample7_unittest.cc and samples/sample8_unittest.cc
146 // for more examples.
147 //
148 // In the future, we plan to publish the API for defining new parameter
149 // generators. But for now this interface remains part of the internal
150 // implementation and is subject to change.
151 //
152 //
153 // A parameterized test fixture must be derived from testing::Test and from
154 // testing::WithParamInterface&lt;T&gt;, where T is the type of the parameter
155 // values. Inheriting from TestWithParam&lt;T&gt; satisfies that requirement because
156 // TestWithParam&lt;T&gt; inherits from both Test and WithParamInterface. In more
157 // complicated hierarchies, however, it is occasionally useful to inherit
158 // separately from Test and WithParamInterface. For example:
159 
160 class BaseTest : public ::testing::Test {
161   // You can inherit all the usual members for a non-parameterized test
162   // fixture here.
163 };
164 
165 class DerivedTest : public BaseTest, public ::testing::WithParamInterface&lt;int&gt; {
166   // The usual test fixture members go here too.
167 };
168 
169 TEST_F(BaseTest, HasFoo) {
170   // This is an ordinary non-parameterized test.
171 }
172 
173 TEST_P(DerivedTest, DoesBlah) {
174   // GetParam works just the same here as if you inherit from TestWithParam.
175   EXPECT_TRUE(foo.Blah(GetParam()));
176 }
177 
178 #endif  // 0
179 
180 #include &quot;gtest/internal/gtest-port.h&quot;
181 
182 #if !GTEST_OS_SYMBIAN
183 # include &lt;utility&gt;
184 #endif
185 
186 #include &quot;gtest/internal/gtest-internal.h&quot;
187 #include &quot;gtest/internal/gtest-param-util.h&quot;
188 #include &quot;gtest/internal/gtest-param-util-generated.h&quot;
189 
190 namespace testing {
191 
192 // Functions producing parameter generators.
193 //
194 // Google Test uses these generators to produce parameters for value-
195 // parameterized tests. When a parameterized test case is instantiated
196 // with a particular generator, Google Test creates and runs tests
197 // for each element in the sequence produced by the generator.
198 //
199 // In the following sample, tests from test case FooTest are instantiated
200 // each three times with parameter values 3, 5, and 8:
201 //
202 // class FooTest : public TestWithParam&lt;int&gt; { ... };
203 //
204 // TEST_P(FooTest, TestThis) {
205 // }
206 // TEST_P(FooTest, TestThat) {
207 // }
208 // INSTANTIATE_TEST_CASE_P(TestSequence, FooTest, Values(3, 5, 8));
209 //
210 
211 // Range() returns generators providing sequences of values in a range.
212 //
213 // Synopsis:
214 // Range(start, end)
215 //   - returns a generator producing a sequence of values {start, start+1,
216 //     start+2, ..., }.
217 // Range(start, end, step)
218 //   - returns a generator producing a sequence of values {start, start+step,
219 //     start+step+step, ..., }.
220 // Notes:
221 //   * The generated sequences never include end. For example, Range(1, 5)
222 //     returns a generator producing a sequence {1, 2, 3, 4}. Range(1, 9, 2)
223 //     returns a generator producing {1, 3, 5, 7}.
224 //   * start and end must have the same type. That type may be any integral or
225 //     floating-point type or a user defined type satisfying these conditions:
226 //     * It must be assignable (have operator=() defined).
227 //     * It must have operator+() (operator+(int-compatible type) for
228 //       two-operand version).
229 //     * It must have operator&lt;() defined.
230 //     Elements in the resulting sequences will also have that type.
231 //   * Condition start &lt; end must be satisfied in order for resulting sequences
232 //     to contain any elements.
233 //
234 template &lt;typename T, typename IncrementT&gt;
235 internal::ParamGenerator&lt;T&gt; Range(T start, T end, IncrementT step) {
236   return internal::ParamGenerator&lt;T&gt;(
237       new internal::RangeGenerator&lt;T, IncrementT&gt;(start, end, step));
238 }
239 
240 template &lt;typename T&gt;
241 internal::ParamGenerator&lt;T&gt; Range(T start, T end) {
242   return Range(start, end, 1);
243 }
244 
245 // ValuesIn() function allows generation of tests with parameters coming from
246 // a container.
247 //
248 // Synopsis:
249 // ValuesIn(const T (&amp;array)[N])
250 //   - returns a generator producing sequences with elements from
251 //     a C-style array.
252 // ValuesIn(const Container&amp; container)
253 //   - returns a generator producing sequences with elements from
254 //     an STL-style container.
255 // ValuesIn(Iterator begin, Iterator end)
256 //   - returns a generator producing sequences with elements from
257 //     a range [begin, end) defined by a pair of STL-style iterators. These
258 //     iterators can also be plain C pointers.
259 //
260 // Please note that ValuesIn copies the values from the containers
261 // passed in and keeps them to generate tests in RUN_ALL_TESTS().
262 //
263 // Examples:
264 //
265 // This instantiates tests from test case StringTest
266 // each with C-string values of &quot;foo&quot;, &quot;bar&quot;, and &quot;baz&quot;:
267 //
268 // const char* strings[] = {&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;};
269 // INSTANTIATE_TEST_CASE_P(StringSequence, StringTest, ValuesIn(strings));
270 //
271 // This instantiates tests from test case StlStringTest
272 // each with STL strings with values &quot;a&quot; and &quot;b&quot;:
273 //
274 // ::std::vector&lt; ::std::string&gt; GetParameterStrings() {
275 //   ::std::vector&lt; ::std::string&gt; v;
276 //   v.push_back(&quot;a&quot;);
277 //   v.push_back(&quot;b&quot;);
278 //   return v;
279 // }
280 //
281 // INSTANTIATE_TEST_CASE_P(CharSequence,
282 //                         StlStringTest,
283 //                         ValuesIn(GetParameterStrings()));
284 //
285 //
286 // This will also instantiate tests from CharTest
287 // each with parameter values &#39;a&#39; and &#39;b&#39;:
288 //
289 // ::std::list&lt;char&gt; GetParameterChars() {
290 //   ::std::list&lt;char&gt; list;
291 //   list.push_back(&#39;a&#39;);
292 //   list.push_back(&#39;b&#39;);
293 //   return list;
294 // }
295 // ::std::list&lt;char&gt; l = GetParameterChars();
296 // INSTANTIATE_TEST_CASE_P(CharSequence2,
297 //                         CharTest,
298 //                         ValuesIn(l.begin(), l.end()));
299 //
300 template &lt;typename ForwardIterator&gt;
301 internal::ParamGenerator&lt;
302   typename ::testing::internal::IteratorTraits&lt;ForwardIterator&gt;::value_type&gt;
303 ValuesIn(ForwardIterator begin, ForwardIterator end) {
304   typedef typename ::testing::internal::IteratorTraits&lt;ForwardIterator&gt;
305       ::value_type ParamType;
306   return internal::ParamGenerator&lt;ParamType&gt;(
307       new internal::ValuesInIteratorRangeGenerator&lt;ParamType&gt;(begin, end));
308 }
309 
310 template &lt;typename T, size_t N&gt;
311 internal::ParamGenerator&lt;T&gt; ValuesIn(const T (&amp;array)[N]) {
312   return ValuesIn(array, array + N);
313 }
314 
315 template &lt;class Container&gt;
316 internal::ParamGenerator&lt;typename Container::value_type&gt; ValuesIn(
317     const Container&amp; container) {
318   return ValuesIn(container.begin(), container.end());
319 }
320 
321 // Values() allows generating tests from explicitly specified list of
322 // parameters.
323 //
324 // Synopsis:
325 // Values(T v1, T v2, ..., T vN)
326 //   - returns a generator producing sequences with elements v1, v2, ..., vN.
327 //
328 // For example, this instantiates tests from test case BarTest each
329 // with values &quot;one&quot;, &quot;two&quot;, and &quot;three&quot;:
330 //
331 // INSTANTIATE_TEST_CASE_P(NumSequence, BarTest, Values(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;));
332 //
333 // This instantiates tests from test case BazTest each with values 1, 2, 3.5.
334 // The exact type of values will depend on the type of parameter in BazTest.
335 //
336 // INSTANTIATE_TEST_CASE_P(FloatingNumbers, BazTest, Values(1, 2, 3.5));
337 //
338 // Currently, Values() supports from 1 to $n parameters.
339 //
340 $range i 1..n
341 $for i [[
342 $range j 1..i
343 
344 template &lt;$for j, [[typename T$j]]&gt;
345 internal::ValueArray$i&lt;$for j, [[T$j]]&gt; Values($for j, [[T$j v$j]]) {
346   return internal::ValueArray$i&lt;$for j, [[T$j]]&gt;($for j, [[v$j]]);
347 }
348 
349 ]]
350 
351 // Bool() allows generating tests with parameters in a set of (false, true).
352 //
353 // Synopsis:
354 // Bool()
355 //   - returns a generator producing sequences with elements {false, true}.
356 //
357 // It is useful when testing code that depends on Boolean flags. Combinations
358 // of multiple flags can be tested when several Bool()&#39;s are combined using
359 // Combine() function.
360 //
361 // In the following example all tests in the test case FlagDependentTest
362 // will be instantiated twice with parameters false and true.
363 //
364 // class FlagDependentTest : public testing::TestWithParam&lt;bool&gt; {
365 //   virtual void SetUp() {
366 //     external_flag = GetParam();
367 //   }
368 // }
369 // INSTANTIATE_TEST_CASE_P(BoolSequence, FlagDependentTest, Bool());
370 //
371 inline internal::ParamGenerator&lt;bool&gt; Bool() {
372   return Values(false, true);
373 }
374 
375 # if GTEST_HAS_COMBINE
376 // Combine() allows the user to combine two or more sequences to produce
377 // values of a Cartesian product of those sequences&#39; elements.
378 //
379 // Synopsis:
380 // Combine(gen1, gen2, ..., genN)
381 //   - returns a generator producing sequences with elements coming from
382 //     the Cartesian product of elements from the sequences generated by
383 //     gen1, gen2, ..., genN. The sequence elements will have a type of
384 //     tuple&lt;T1, T2, ..., TN&gt; where T1, T2, ..., TN are the types
385 //     of elements from sequences produces by gen1, gen2, ..., genN.
386 //
387 // Combine can have up to $maxtuple arguments. This number is currently limited
388 // by the maximum number of elements in the tuple implementation used by Google
389 // Test.
390 //
391 // Example:
392 //
393 // This will instantiate tests in test case AnimalTest each one with
394 // the parameter values tuple(&quot;cat&quot;, BLACK), tuple(&quot;cat&quot;, WHITE),
395 // tuple(&quot;dog&quot;, BLACK), and tuple(&quot;dog&quot;, WHITE):
396 //
397 // enum Color { BLACK, GRAY, WHITE };
398 // class AnimalTest
399 //     : public testing::TestWithParam&lt;tuple&lt;const char*, Color&gt; &gt; {...};
400 //
401 // TEST_P(AnimalTest, AnimalLooksNice) {...}
402 //
403 // INSTANTIATE_TEST_CASE_P(AnimalVariations, AnimalTest,
404 //                         Combine(Values(&quot;cat&quot;, &quot;dog&quot;),
405 //                                 Values(BLACK, WHITE)));
406 //
407 // This will instantiate tests in FlagDependentTest with all variations of two
408 // Boolean flags:
409 //
410 // class FlagDependentTest
411 //     : public testing::TestWithParam&lt;tuple&lt;bool, bool&gt; &gt; {
412 //   virtual void SetUp() {
413 //     // Assigns external_flag_1 and external_flag_2 values from the tuple.
414 //     tie(external_flag_1, external_flag_2) = GetParam();
415 //   }
416 // };
417 //
418 // TEST_P(FlagDependentTest, TestFeature1) {
419 //   // Test your code using external_flag_1 and external_flag_2 here.
420 // }
421 // INSTANTIATE_TEST_CASE_P(TwoBoolSequence, FlagDependentTest,
422 //                         Combine(Bool(), Bool()));
423 //
424 $range i 2..maxtuple
425 $for i [[
426 $range j 1..i
427 
428 template &lt;$for j, [[typename Generator$j]]&gt;
429 internal::CartesianProductHolder$i&lt;$for j, [[Generator$j]]&gt; Combine(
430     $for j, [[const Generator$j&amp; g$j]]) {
431   return internal::CartesianProductHolder$i&lt;$for j, [[Generator$j]]&gt;(
432       $for j, [[g$j]]);
433 }
434 
435 ]]
436 # endif  // GTEST_HAS_COMBINE
437 
438 # define TEST_P(test_case_name, test_name) \
439   class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \
440       : public test_case_name { \
441    public: \
442     GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {} \
443     virtual void TestBody(); \
444    private: \
445     static int AddToRegistry() { \
446       ::testing::UnitTest::GetInstance()-&gt;parameterized_test_registry(). \
447           GetTestCasePatternHolder&lt;test_case_name&gt;(\
448               #test_case_name, \
449               ::testing::internal::CodeLocation(\
450                   __FILE__, __LINE__))-&gt;AddTestPattern(\
451                       GTEST_STRINGIFY_(test_case_name), \
452                       GTEST_STRINGIFY_(test_name), \
453                       new ::testing::internal::TestMetaFactory&lt; \
454                           GTEST_TEST_CLASS_NAME_(\
455                               test_case_name, test_name)&gt;()); \
456       return 0; \
457     } \
458     static int gtest_registering_dummy_ GTEST_ATTRIBUTE_UNUSED_; \
459     GTEST_DISALLOW_COPY_AND_ASSIGN_(\
460         GTEST_TEST_CLASS_NAME_(test_case_name, test_name)); \
461   }; \
462   int GTEST_TEST_CLASS_NAME_(test_case_name, \
463                              test_name)::gtest_registering_dummy_ = \
464       GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::AddToRegistry(); \
465   void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()
466 
467 // The optional last argument to INSTANTIATE_TEST_CASE_P allows the user
468 // to specify a function or functor that generates custom test name suffixes
469 // based on the test parameters. The function should accept one argument of
470 // type testing::TestParamInfo&lt;class ParamType&gt;, and return std::string.
471 //
472 // testing::PrintToStringParamName is a builtin test suffix generator that
473 // returns the value of testing::PrintToString(GetParam()).
474 //
475 // Note: test names must be non-empty, unique, and may only contain ASCII
476 // alphanumeric characters or underscore. Because PrintToString adds quotes
477 // to std::string and C strings, it won&#39;t work for these types.
478 
479 # define INSTANTIATE_TEST_CASE_P(prefix, test_case_name, generator, ...) \
480   static ::testing::internal::ParamGenerator&lt;test_case_name::ParamType&gt; \
481       gtest_##prefix##test_case_name##_EvalGenerator_() { return generator; } \
482   static ::std::string gtest_##prefix##test_case_name##_EvalGenerateName_( \
483       const ::testing::TestParamInfo&lt;test_case_name::ParamType&gt;&amp; info) { \
484     return ::testing::internal::GetParamNameGen&lt;test_case_name::ParamType&gt; \
485         (__VA_ARGS__)(info); \
486   } \
487   static int gtest_##prefix##test_case_name##_dummy_ GTEST_ATTRIBUTE_UNUSED_ = \
488       ::testing::UnitTest::GetInstance()-&gt;parameterized_test_registry(). \
489           GetTestCasePatternHolder&lt;test_case_name&gt;(\
490               #test_case_name, \
491               ::testing::internal::CodeLocation(\
492                   __FILE__, __LINE__))-&gt;AddTestCaseInstantiation(\
493                       #prefix, \
494                       &amp;gtest_##prefix##test_case_name##_EvalGenerator_, \
495                       &amp;gtest_##prefix##test_case_name##_EvalGenerateName_, \
496                       __FILE__, __LINE__)
497 
498 }  // namespace testing
499 
500 #endif  // GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_
    </pre>
  </body>
</html>
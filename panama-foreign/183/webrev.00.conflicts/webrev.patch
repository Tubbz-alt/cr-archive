diff a/src/java.base/share/classes/java/lang/invoke/Invokers.java b/src/java.base/share/classes/java/lang/invoke/Invokers.java
--- a/src/java.base/share/classes/java/lang/invoke/Invokers.java
+++ b/src/java.base/share/classes/java/lang/invoke/Invokers.java
@@ -363,11 +363,15 @@
         final int THIS_VH      = 0;
         final int ARG_BASE     = THIS_VH + 1;
         final int ARG_LIMIT = ARG_BASE + mtype.parameterCount();
         int nameCursor = ARG_LIMIT;
         final int VAD_ARG      = nameCursor++;
+<<<<<<< HEAD
         final int UNBOUND_VH   = nameCursor++;
+=======
+        final int UNBOUND_VH      = nameCursor++;
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         final int CHECK_TYPE   = nameCursor++;
         final int CHECK_CUSTOM = (CUSTOMIZE_THRESHOLD >= 0) ? nameCursor++ : -1;
         final int LINKER_CALL  = nameCursor++;
 
         Name[] names = new Name[LINKER_CALL + 1];
diff a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java
--- a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java
+++ b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java
@@ -59,13 +59,16 @@
 import static jdk.internal.org.objectweb.asm.Opcodes.CHECKCAST;
 import static jdk.internal.org.objectweb.asm.Opcodes.GETFIELD;
 import static jdk.internal.org.objectweb.asm.Opcodes.GETSTATIC;
 import static jdk.internal.org.objectweb.asm.Opcodes.H_INVOKESTATIC;
 import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_0;
+<<<<<<< HEAD:src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java
 import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_1;
 import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_2;
 import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_3;
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059:src/java.base/share/classes/java/lang/invoke/AddressVarHandleGenerator.java
 import static jdk.internal.org.objectweb.asm.Opcodes.ILOAD;
 import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;
 import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESTATIC;
 import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
 import static jdk.internal.org.objectweb.asm.Opcodes.LALOAD;
@@ -329,18 +332,27 @@
             mv.visitVarInsn(ALOAD, 0); // load recv
             mv.visitTypeInsn(CHECKCAST, Type.getInternalName(BASE_CLASS));
             mv.visitFieldInsn(GETFIELD, Type.getInternalName(BASE_CLASS), "offset", "J");
             for (int i = 0 ; i < dimensions ; i++) {
                 // load ADD MH
+<<<<<<< HEAD:src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java
                 mv.visitFieldInsn(GETSTATIC, implClassName, "addHandle", MethodHandle.class.descriptorString());
+=======
+                mv.visitLdcInsn(cw.makeConstantPoolPatch(ADD_OFFSETS_HANDLE));
+                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059:src/java.base/share/classes/java/lang/invoke/AddressVarHandleGenerator.java
 
                 //fixup stack so that ADD MH ends up bottom
                 mv.visitInsn(Opcodes.DUP_X2);
                 mv.visitInsn(Opcodes.POP);
 
                 // load MUL MH
+<<<<<<< HEAD:src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java
                 mv.visitFieldInsn(GETSTATIC, implClassName, "mulHandle", MethodHandle.class.descriptorString());
+=======
+                mv.visitLdcInsn(cw.makeConstantPoolPatch(MUL_OFFSETS_HANDLE));
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059:src/java.base/share/classes/java/lang/invoke/AddressVarHandleGenerator.java
                 mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
 
                 mv.visitVarInsn(ALOAD, 0); // load recv
                 mv.visitTypeInsn(CHECKCAST, implClassName);
                 mv.visitFieldInsn(GETFIELD, implClassName, "dim" + i, "J");
diff a/src/java.base/share/classes/java/lang/invoke/VarHandles.java b/src/java.base/share/classes/java/lang/invoke/VarHandles.java
--- a/src/java.base/share/classes/java/lang/invoke/VarHandles.java
+++ b/src/java.base/share/classes/java/lang/invoke/VarHandles.java
@@ -354,10 +354,11 @@
         Objects.nonNull(filterFromTarget);
         //check that from/to filters do not throw checked exceptions
         noCheckedExceptions(filterToTarget);
         noCheckedExceptions(filterFromTarget);
 
+<<<<<<< HEAD
         //check that from/to filters have right signatures
         if (filterFromTarget.type().parameterCount() != 1) {
             throw newIllegalArgumentException("filterFromTarget filter type has wrong arity", filterFromTarget.type());
         } else if (filterToTarget.type().parameterCount() != 1) {
             throw newIllegalArgumentException("filterToTarget filter type has wrong arity", filterFromTarget.type());
@@ -386,15 +387,106 @@
                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);
                         }
                         case COMPARE_AND_SET -> {
                             MethodHandle adapter = MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);
                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);
+=======
+        List<Class<?>> newCoordinates = new ArrayList<>();
+        List<Class<?>> additionalCoordinates = new ArrayList<>();
+        newCoordinates.addAll(target.coordinateTypes());
+
+        //check that from/to filters have right signatures
+        if (filterFromTarget.type().parameterCount() != filterToTarget.type().parameterCount()) {
+            throw newIllegalArgumentException("filterFromTarget and filterToTarget have different arity", filterFromTarget.type(), filterToTarget.type());
+        } else if (filterFromTarget.type().parameterCount() < 1) {
+            throw newIllegalArgumentException("filterFromTarget filter type has wrong arity", filterFromTarget.type());
+        } else if (filterToTarget.type().parameterCount() < 1) {
+            throw newIllegalArgumentException("filterToTarget filter type has wrong arity", filterFromTarget.type());
+        } else if (filterFromTarget.type().lastParameterType() != filterToTarget.type().returnType() ||
+                filterToTarget.type().lastParameterType() != filterFromTarget.type().returnType()) {
+            throw newIllegalArgumentException("filterFromTarget and filterToTarget filter types do not match", filterFromTarget.type(), filterToTarget.type());
+        } else if (target.varType() != filterFromTarget.type().lastParameterType()) {
+            throw newIllegalArgumentException("filterFromTarget filter type does not match target var handle type", filterFromTarget.type(), target.varType());
+        } else if (target.varType() != filterToTarget.type().returnType()) {
+            throw newIllegalArgumentException("filterFromTarget filter type does not match target var handle type", filterToTarget.type(), target.varType());
+        } else if (filterFromTarget.type().parameterCount() > 1) {
+            for (int i = 0 ; i < filterFromTarget.type().parameterCount() - 1 ; i++) {
+                if (filterFromTarget.type().parameterType(i) != filterToTarget.type().parameterType(i)) {
+                    throw newIllegalArgumentException("filterFromTarget and filterToTarget filter types do not match", filterFromTarget.type(), filterToTarget.type());
+                } else {
+                    newCoordinates.add(filterFromTarget.type().parameterType(i));
+                    additionalCoordinates.add((filterFromTarget.type().parameterType(i)));
+                }
+            }
+        }
+
+        return new IndirectVarHandle(target, filterFromTarget.type().returnType(), newCoordinates.toArray(new Class<?>[0]),
+                (mode, modeHandle) -> {
+                    int lastParameterPos = modeHandle.type().parameterCount() - 1;
+                    return switch (mode.at) {
+                        case GET -> MethodHandles.collectReturnValue(modeHandle, filterFromTarget);
+                        case SET -> MethodHandles.collectArguments(modeHandle, lastParameterPos, filterToTarget);
+                        case GET_AND_UPDATE -> {
+                            MethodHandle adapter = MethodHandles.collectReturnValue(modeHandle, filterFromTarget);
+                            MethodHandle res = MethodHandles.collectArguments(adapter, lastParameterPos, filterToTarget);
+                            if (additionalCoordinates.size() > 0) {
+                                res = joinDuplicateArgs(res, lastParameterPos,
+                                        lastParameterPos + additionalCoordinates.size() + 1,
+                                        additionalCoordinates.size());
+                            }
+                            yield res;
+                        }
+                        case COMPARE_AND_EXCHANGE -> {
+                            MethodHandle adapter = MethodHandles.collectReturnValue(modeHandle, filterFromTarget);
+                            adapter = MethodHandles.collectArguments(adapter, lastParameterPos, filterToTarget);
+                            if (additionalCoordinates.size() > 0) {
+                                adapter = joinDuplicateArgs(adapter, lastParameterPos,
+                                        lastParameterPos + additionalCoordinates.size() + 1,
+                                        additionalCoordinates.size());
+                            }
+                            MethodHandle res = MethodHandles.collectArguments(adapter, lastParameterPos - 1, filterToTarget);
+                            if (additionalCoordinates.size() > 0) {
+                                res = joinDuplicateArgs(res, lastParameterPos - 1,
+                                        lastParameterPos + additionalCoordinates.size(),
+                                        additionalCoordinates.size());
+                            }
+                            yield res;
+                        }
+                        case COMPARE_AND_SET -> {
+                            MethodHandle adapter = MethodHandles.collectArguments(modeHandle, lastParameterPos, filterToTarget);
+                            MethodHandle res = MethodHandles.collectArguments(adapter, lastParameterPos - 1, filterToTarget);
+                            if (additionalCoordinates.size() > 0) {
+                                res = joinDuplicateArgs(res, lastParameterPos - 1,
+                                        lastParameterPos + additionalCoordinates.size(),
+                                        additionalCoordinates.size());
+                            }
+                            yield res;
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
                         }
                     };
                 });
     }
 
+<<<<<<< HEAD
+=======
+    private static MethodHandle joinDuplicateArgs(MethodHandle handle, int originalStart, int dropStart, int length) {
+        int[] perms = new int[handle.type().parameterCount()];
+        for (int i = 0 ; i < dropStart; i++) {
+            perms[i] = i;
+        }
+        for (int i = 0 ; i < length ; i++) {
+            perms[dropStart + i] = originalStart + i;
+        }
+        for (int i = dropStart + length ; i < perms.length ; i++) {
+            perms[i] = i - length;
+        }
+        return MethodHandles.permuteArguments(handle,
+                handle.type().dropParameterTypes(dropStart, dropStart + length),
+                perms);
+    }
+
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {
         Objects.nonNull(target);
         Objects.nonNull(filters);
 
         List<Class<?>> targetCoordinates = target.coordinateTypes();
@@ -540,10 +632,11 @@
     }
 
     private static void noCheckedExceptions(MethodHandle handle) {
         if (handle instanceof DirectMethodHandle) {
             DirectMethodHandle directHandle = (DirectMethodHandle)handle;
+<<<<<<< HEAD
             MethodHandleInfo info = MethodHandles.Lookup.IMPL_LOOKUP.revealDirect(directHandle);
             Class<?>[] exceptionTypes = switch (info.getReferenceKind()) {
                 case MethodHandleInfo.REF_invokeInterface, MethodHandleInfo.REF_invokeSpecial,
                         MethodHandleInfo.REF_invokeStatic, MethodHandleInfo.REF_invokeVirtual ->
                         info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP).getExceptionTypes();
@@ -551,10 +644,29 @@
                         info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP).getExceptionTypes();
                 case MethodHandleInfo.REF_getField, MethodHandleInfo.REF_getStatic,
                         MethodHandleInfo.REF_putField, MethodHandleInfo.REF_putStatic -> null;
                 default -> throw new AssertionError("Cannot get here");
             };
+=======
+            byte refKind = directHandle.member.getReferenceKind();
+            MethodHandleInfo info = new InfoFromMemberName(
+                    MethodHandles.Lookup.IMPL_LOOKUP,
+                    directHandle.member,
+                    refKind);
+            final Class<?>[] exceptionTypes;
+            if (MethodHandleNatives.refKindIsMethod(refKind)) {
+                exceptionTypes = info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP)
+                        .getExceptionTypes();
+            } else if (MethodHandleNatives.refKindIsField(refKind)) {
+                exceptionTypes = null;
+            } else if (MethodHandleNatives.refKindIsConstructor(refKind)) {
+                exceptionTypes = info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP)
+                        .getExceptionTypes();
+            } else {
+                throw new AssertionError("Cannot get here");
+            }
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
             if (exceptionTypes != null) {
                 if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {
                     throw newIllegalArgumentException("Cannot adapt a var handle with a method handle which throws checked exceptions");
                 }
             }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
@@ -46,29 +46,46 @@
 import static java.lang.constant.ConstantDescs.BSM_INVOKE;
 import static java.lang.constant.ConstantDescs.CD_String;
 import static java.lang.constant.ConstantDescs.CD_long;
 
 abstract class AbstractLayout implements MemoryLayout {
+<<<<<<< HEAD
 
     private final OptionalLong size;
     final long alignment;
     final Map<String, Constable> attributes;
+=======
+    // memory layout attribute key for layout name
+    static final String NAME = "name";
+
+    private final OptionalLong size;
+    final long alignment;
+    protected final Map<String, Constable> attributes;
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 
     public AbstractLayout(OptionalLong size, long alignment, Map<String, Constable> attributes) {
         this.size = size;
         this.alignment = alignment;
         this.attributes = Collections.unmodifiableMap(attributes);
     }
 
     @Override
     public AbstractLayout withName(String name) {
+<<<<<<< HEAD
         return withAttribute(LAYOUT_NAME, name);
+=======
+        return withAttribute(NAME, name);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @Override
     public final Optional<String> name() {
+<<<<<<< HEAD
         return attribute(LAYOUT_NAME).map(String.class::cast);
+=======
+        return attribute(NAME).map(String.class::cast);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @Override
     public Optional<Constable> attribute(String name) {
         return Optional.ofNullable(attributes.get(name));
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MappedMemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MappedMemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MappedMemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MappedMemorySegment.java
@@ -30,12 +30,17 @@
 
 /**
  * A mapped memory segment, that is, a memory segment backed by memory-mapped file.
  *
  * <p> Mapped memory segments are created via the {@link MemorySegment#mapFromPath(Path, long, FileChannel.MapMode)}.
+<<<<<<< HEAD
  * Mapped memory segments behave like ordinary segments, but provide additional capabilities to manipulate memory-mapped
  * memory regions, such as {@link #force()} and {@link #load()}.
+=======
+ * Mapped memory segments behave like ordinary segments, but also provide additional capabilities that are specific to
+ * mapped memory segments, such as {@link #force()} and {@link #load()}.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  * <p>
  * All implementations of this interface must be <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>;
  * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on
  * instances of {@code MemoryLayout} may have unpredictable results and should be avoided. The {@code equals} method should
  * be used for comparisons.
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
@@ -65,10 +65,11 @@
     /**
      * Returns the offset of this memory address into the underlying segment (if any).
      * @return the offset of this memory address into the underlying segment (if any).
      * @throws UnsupportedOperationException if no segment is associated with this memory address,
      * e.g. if {@code segment() == null}.
+<<<<<<< HEAD
      */
     long segmentOffset();
 
     /**
      * Returns the raw long value associated to this memory address.
@@ -76,10 +77,23 @@
      * @throws UnsupportedOperationException if this memory address is associated with an heap segment.
      */
     long toRawLongValue();
 
     /**
+=======
+     */
+    long segmentOffset();
+
+    /**
+     * Returns the raw long value associated to this memory address.
+     * @return The raw long value associated to this memory address.
+     * @throws UnsupportedOperationException if this memory address is associated with an heap segment.
+     */
+    long toRawLongValue();
+
+    /**
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      * Returns the memory segment (if any) this address belongs to.
      * @return The memory segment this address belongs to, or {@code null} if no such segment exists.
      */
     MemorySegment segment();
 
@@ -114,10 +128,11 @@
      */
     @Override
     int hashCode();
 
     /**
+<<<<<<< HEAD
      * Perform bulk copy from source address to target address. More specifically, the bytes at addresses {@code src}
      * through {@code src.addOffset(bytes - 1)} are copied into addresses {@code dst} through {@code dst.addOffset(bytes - 1)}.
      * If the source and address ranges overlap, then the copying is performed as if the bytes at addresses {@code src}
      * through {@code src.addOffset(bytes - 1)} were first copied into a temporary segment with size {@code bytes},
      * and then the contents of the temporary segment were copied into the bytes at addresses {@code dst} through
@@ -135,13 +150,27 @@
      * @throws IllegalStateException if either the source address or the target address belong to memory segments
      * which have been already closed, or if access occurs from a thread other than the thread owning either segment.
      * @throws UnsupportedOperationException if either {@code src} or {@code dst} do not feature required access modes;
      * more specifically, {@code src} should be associated with a segment with {@link MemorySegment#READ} access mode,
      * while {@code dst} should be associated with a segment with {@link MemorySegment#WRITE} access mode.
+=======
+     * The <em>unchecked</em> memory address instance modelling the {@code NULL} address. This address is <em>not</em> backed by
+     * a memory segment and hence it cannot be dereferenced.
      */
-    static void copy(MemoryAddress src, MemoryAddress dst, long bytes) {
-        MemoryAddressImpl.copy((MemoryAddressImpl)src, (MemoryAddressImpl)dst, bytes);
+    MemoryAddress NULL = new MemoryAddressImpl( 0L);
+
+    /**
+     * Obtain a new <em>unchecked</em> memory address instance from given long address. The returned address is <em>not</em> backed by
+     * a memory segment and hence it cannot be dereferenced.
+     * @param value the long address.
+     * @return the new memory address instance.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
+     */
+    static MemoryAddress ofLong(long value) {
+        return value == 0 ?
+                NULL :
+                new MemoryAddressImpl(value);
     }
 
     /**
      * The <em>unchecked</em> memory address instance modelling the {@code NULL} address. This address is <em>not</em> backed by
      * a memory segment and hence it cannot be dereferenced.
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
@@ -34,10 +34,14 @@
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
 import java.util.List;
+<<<<<<< HEAD
+=======
+import java.util.Objects;
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 
 /**
  * This class defines several factory methods for constructing and combining memory access var handles.
  * To obtain a memory access var handle, clients must start from one of the <em>leaf</em> methods
  * (see {@link MemoryHandles#varHandle(Class, ByteOrder)},
@@ -130,10 +134,24 @@
     private static final MethodHandle LONG_TO_ADDRESS;
     private static final MethodHandle ADDRESS_TO_LONG;
     private static final MethodHandle ADD_OFFSET;
     private static final MethodHandle ADD_STRIDE;
 
+<<<<<<< HEAD
+=======
+    private static final MethodHandle INT_TO_BYTE;
+    private static final MethodHandle BYTE_TO_UNSIGNED_INT;
+    private static final MethodHandle INT_TO_SHORT;
+    private static final MethodHandle SHORT_TO_UNSIGNED_INT;
+    private static final MethodHandle LONG_TO_BYTE;
+    private static final MethodHandle BYTE_TO_UNSIGNED_LONG;
+    private static final MethodHandle LONG_TO_SHORT;
+    private static final MethodHandle SHORT_TO_UNSIGNED_LONG;
+    private static final MethodHandle LONG_TO_INT;
+    private static final MethodHandle INT_TO_UNSIGNED_LONG;
+
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     static {
         try {
             LONG_TO_ADDRESS = MethodHandles.lookup().findStatic(MemoryHandles.class, "longToAddress",
                     MethodType.methodType(MemoryAddress.class, long.class));
             ADDRESS_TO_LONG = MethodHandles.lookup().findStatic(MemoryHandles.class, "addressToLong",
@@ -141,10 +159,34 @@
             ADD_OFFSET = MethodHandles.lookup().findStatic(MemoryHandles.class, "addOffset",
                     MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class));
 
             ADD_STRIDE = MethodHandles.lookup().findStatic(MemoryHandles.class, "addStride",
                     MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class, long.class));
+<<<<<<< HEAD
+=======
+
+            INT_TO_BYTE = MethodHandles.explicitCastArguments(MethodHandles.identity(byte.class),
+                    MethodType.methodType(byte.class, int.class));
+            BYTE_TO_UNSIGNED_INT = MethodHandles.lookup().findStatic(Byte.class, "toUnsignedInt",
+                    MethodType.methodType(int.class, byte.class));
+            INT_TO_SHORT = MethodHandles.explicitCastArguments(MethodHandles.identity(short.class),
+                    MethodType.methodType(short.class, int.class));
+            SHORT_TO_UNSIGNED_INT = MethodHandles.lookup().findStatic(Short.class, "toUnsignedInt",
+                    MethodType.methodType(int.class, short.class));
+            LONG_TO_BYTE = MethodHandles.explicitCastArguments(MethodHandles.identity(byte.class),
+                    MethodType.methodType(byte.class, long.class));
+            BYTE_TO_UNSIGNED_LONG = MethodHandles.lookup().findStatic(Byte.class, "toUnsignedLong",
+                    MethodType.methodType(long.class, byte.class));
+            LONG_TO_SHORT = MethodHandles.explicitCastArguments(MethodHandles.identity(short.class),
+                    MethodType.methodType(short.class, long.class));
+            SHORT_TO_UNSIGNED_LONG = MethodHandles.lookup().findStatic(Short.class, "toUnsignedLong",
+                    MethodType.methodType(long.class, short.class));
+            LONG_TO_INT = MethodHandles.explicitCastArguments(MethodHandles.identity(int.class),
+                    MethodType.methodType(int.class, long.class));
+            INT_TO_UNSIGNED_LONG = MethodHandles.lookup().findStatic(Integer.class, "toUnsignedLong",
+                    MethodType.methodType(long.class, int.class));
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         } catch (Throwable ex) {
             throw new ExceptionInInitializerError(ex);
         }
     }
 
@@ -251,20 +293,25 @@
      * The returned var handle will feature the same type as the target var handle; an additional access coordinate
      * of type {@code long} will be added to the access coordinate types of the target var handle at the position
      * immediately following the leading access coordinate of type {@link MemoryAddress}.
      *
      * @param target the target memory access handle to access after the scale adjustment.
+<<<<<<< HEAD
      * @param bytesStride the stride, in bytes, by which to multiply the coordinate value.
+=======
+     * @param bytesStride the stride, in bytes, by which to multiply the coordinate value. Must be greater than zero.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      * @return the adapted var handle.
      * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.
      */
     public static VarHandle withStride(VarHandle target, long bytesStride) {
         if (bytesStride == 0) {
             return dropCoordinates(target, 1, long.class); // dummy coordinate
         }
 
         checkAddressFirstCoordinate(target);
+<<<<<<< HEAD
 
         if (JLI.isMemoryAccessVarHandle(target) &&
                 (bytesStride & JLI.memoryAddressAlignmentMask(target)) == 0) {
             //flatten
             long[] strides = JLI.memoryAddressStrides(target);
@@ -283,10 +330,52 @@
             VarHandle res = collectCoordinates(target, 0, ADD_STRIDE);
             return insertCoordinates(res, 2, bytesStride);
         }
     }
 
+    /**
+     * Adapt an existing var handle into a new var handle whose carrier type is {@link MemoryAddress}.
+     * That is, when calling {@link VarHandle#get(Object...)} on the returned var handle,
+     * the read numeric value will be turned into a memory address (as if by calling {@link MemoryAddress#ofLong(long)});
+     * similarly, when calling {@link VarHandle#set(Object...)}, the memory address to be set will be converted
+     * into a numeric value, and then written into memory. The amount of bytes read (resp. written) from (resp. to)
+     * memory depends on the carrier of the original memory access var handle.
+     *
+     * @param target the memory access var handle to be adapted
+     * @return the adapted var handle.
+     * @throws IllegalArgumentException if the carrier type of {@code varHandle} is either {@code boolean},
+     * {@code float}, or {@code double}, or is not a primitive type.
+     */
+    public static VarHandle asAddressVarHandle(VarHandle target) {
+        Class<?> carrier = target.varType();
+        if (!carrier.isPrimitive() || carrier == boolean.class ||
+                carrier == float.class || carrier == double.class) {
+            throw new IllegalArgumentException("Unsupported carrier type: " + carrier.getName());
+=======
+
+        if (JLI.isMemoryAccessVarHandle(target) &&
+                (bytesStride & JLI.memoryAddressAlignmentMask(target)) == 0) {
+            //flatten
+            long[] strides = JLI.memoryAddressStrides(target);
+            long[] newStrides = new long[strides.length + 1];
+            System.arraycopy(strides, 0, newStrides, 1, strides.length);
+            newStrides[0] = bytesStride;
+
+            return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(
+                    JLI.memoryAddressCarrier(target),
+                    JLI.memoryAddressAlignmentMask(target),
+                    JLI.memoryAddressByteOrder(target),
+                    JLI.memoryAddressOffset(target),
+                    newStrides));
+        } else {
+            //slow path
+            VarHandle res = collectCoordinates(target, 0, ADD_STRIDE);
+            return insertCoordinates(res, 2, bytesStride);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
+        }
+    }
+
     /**
      * Adapt an existing var handle into a new var handle whose carrier type is {@link MemoryAddress}.
      * That is, when calling {@link VarHandle#get(Object...)} on the returned var handle,
      * the read numeric value will be turned into a memory address (as if by calling {@link MemoryAddress#ofLong(long)});
      * similarly, when calling {@link VarHandle#set(Object...)}, the memory address to be set will be converted
@@ -314,10 +403,182 @@
             // fast-path
             return filterValue(target, ADDRESS_TO_LONG, LONG_TO_ADDRESS);
         }
     }
 
+    /**
+     * Adapts a target var handle by narrowing incoming values and widening
+     * outgoing values, to and from the given type, respectively.
+     * <p>
+     * The returned var handle can be used to conveniently treat unsigned
+     * primitive data types as if they were a wider signed primitive type. For
+     * example, it is often convenient to model an <i>unsigned short</i> as a
+     * Java {@code int} to avoid dealing with negative values, which would be
+     * the case if modeled as a Java {@code short}. The returned var handle
+     * converts to and from wider primitive types, to a more narrow possibly
+     * unsigned primitive type.
+     * <p>
+     * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var
+     * handle, the incoming value (of type {@code adaptedType}) is converted by a
+     * <i>narrowing primitive conversion</i> and then passed to the {@code
+     * target} var handle. A narrowing primitive conversion may lose information
+     * about the overall magnitude of a numeric value. Conversely, when calling
+     * e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the
+     * returned value obtained from the {@code target} var handle is converted
+     * by a <i>unsigned widening conversion</i> before being returned to the
+     * caller. In an unsigned widening conversion the high-order bits greater
+     * than that of the {@code target} carrier type are zero, and the low-order
+     * bits (equal to the width of the {@code target} carrier type) are equal to
+     * the bits of the value obtained from the {@code target} var handle.
+     * <p>
+     * The returned var handle will feature the variable type {@code adaptedType},
+     * and the same access coordinates, the same access modes (see {@link
+     * java.lang.invoke.VarHandle.AccessMode}, and the same atomic access
+     * guarantees, as those featured by the {@code target} var handle.
+     *
+     * @param target the memory access var handle to be adapted
+     * @param adaptedType the adapted type
+     * @returns the adapted var handle.
+     * @throws IllegalArgumentException if the carrier type of {@code target}
+     * is not one of {@code byte}, {@code short}, or {@code int}; if {@code
+     * adaptedType} is not one of {@code int}, or {@code long}; if the bitwidth
+     * of the {@code adaptedType} is not greater than that of the {@code target}
+     * carrier type
+     * @throws NullPointerException if either of {@code target} or {@code
+     * adaptedType} is null
+     *
+     * @jls 5.1.3 Narrowing Primitive Conversion
+     */
+    public static VarHandle asUnsigned(VarHandle target, final Class<?> adaptedType) {
+        Objects.requireNonNull(target);
+        Objects.requireNonNull(adaptedType);
+        final Class<?> carrier = target.varType();
+        checkWidenable(carrier);
+        checkNarrowable(adaptedType);
+        checkTargetWiderThanCarrier(carrier, adaptedType);
+
+        if (adaptedType == int.class && carrier == byte.class) {
+            return filterValue(target, INT_TO_BYTE, BYTE_TO_UNSIGNED_INT);
+        } else if (adaptedType == int.class && carrier == short.class) {
+            return filterValue(target, INT_TO_SHORT, SHORT_TO_UNSIGNED_INT);
+        } else if (adaptedType == long.class && carrier == byte.class) {
+            return filterValue(target, LONG_TO_BYTE, BYTE_TO_UNSIGNED_LONG);
+        } else if (adaptedType == long.class && carrier == short.class) {
+            return filterValue(target, LONG_TO_SHORT, SHORT_TO_UNSIGNED_LONG);
+        } else if (adaptedType == long.class && carrier == int.class) {
+            return filterValue(target, LONG_TO_INT, INT_TO_UNSIGNED_LONG);
+        } else {
+            throw new InternalError("should not reach here");
+        }
+    }
+
+    /**
+     * Adapts a target var handle by pre-processing incoming and outgoing values using a pair of filter functions.
+     * <p>
+     * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var handle, the incoming value (of type {@code T}, where
+     * {@code T} is the <em>last</em> parameter type of the first filter function) is processed using the first filter and then passed
+     * to the target var handle.
+     * Conversely, when calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the return value obtained from
+     * the target var handle (of type {@code T}, where {@code T} is the <em>last</em> parameter type of the second filter function)
+     * is processed using the second filter and returned to the caller. More advanced access mode types, such as
+     * {@link java.lang.invoke.VarHandle.AccessMode#COMPARE_AND_EXCHANGE} might apply both filters at the same time.
+     * <p>
+     * For the boxing and unboxing filters to be well formed, their types must be of the form {@code (A... , S) -> T} and
+     * {@code (A... , T) -> S}, respectively, where {@code T} is the type of the target var handle. If this is the case,
+     * the resulting var handle will have type {@code S} and will feature the additional coordinates {@code A...} (which
+     * will be appended to the coordinates of the target var handle).
+     * <p>
+     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
+     * atomic access guarantees as those featured by the target var handle.
+     *
+     * @param target the target var handle
+     * @param filterToTarget a filter to convert some type {@code S} into the type of {@code target}
+     * @param filterFromTarget a filter to convert the type of {@code target} to some type {@code S}
+     * @return an adapter var handle which accepts a new type, performing the provided boxing/unboxing conversions.
+     * @throws NullPointerException if either {@code target}, {@code filterToTarget} or {@code filterFromTarget} are {@code == null}.
+     * @throws IllegalArgumentException if {@code filterFromTarget} and {@code filterToTarget} are not well-formed, that is, they have types
+     * other than {@code (A... , S) -> T} and {@code (A... , T) -> S}, respectively, where {@code T} is the type of the target var handle,
+     * or if either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.
+     */
+    public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {
+        return JLI.filterValue(target, filterToTarget, filterFromTarget);
+    }
+
+    /**
+     * Adapts a target var handle by pre-processing incoming coordinate values using unary filter functions.
+     * <p>
+     * When calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the incoming coordinate values
+     * starting at position {@code pos} (of type {@code C1, C2 ... Cn}, where {@code C1, C2 ... Cn} are the return type
+     * of the unary filter functions) are transformed into new values (of type {@code S1, S2 ... Sn}, where {@code S1, S2 ... Sn} are the
+     * parameter types of the unary filter functions), and then passed (along with any coordinate that was left unaltered
+     * by the adaptation) to the target var handle.
+     * <p>
+     * For the coordinate filters to be well formed, their types must be of the form {@code S1 -> T1, S2 -> T1 ... Sn -> Tn},
+     * where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos} of the target var handle.
+     * <p>
+     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
+     * atomic access guarantees as those featured by the target var handle.
+     *
+     * @param target the target var handle
+     * @param pos the position of the first coordinate to be transformed
+     * @param filters the unary functions which are used to transform coordinates starting at position {@code pos}
+     * @return an adapter var handle which accepts new coordinate types, applying the provided transformation
+     * to the new coordinate values.
+     * @throws NullPointerException if either {@code target}, {@code filters} are {@code == null}.
+     * @throws IllegalArgumentException if the handles in {@code filters} are not well-formed, that is, they have types
+     * other than {@code S1 -> T1, S2 -> T2, ... Sn -> Tn} where {@code T1, T2 ... Tn} are the coordinate types starting
+     * at position {@code pos} of the target var handle, if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,
+     * or if more filters are provided than the actual number of coordinate types, or if any of the filters throws any
+     * checked exceptions.
+     * available starting at {@code pos}.
+     */
+    public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {
+        return JLI.filterCoordinates(target, pos, filters);
+    }
+
+    /**
+     * Provides a target var handle with one or more <em>bound coordinates</em>
+     * in advance of the var handle's invocation. As a consequence, the resulting var handle will feature less
+     * coordinate types than the target var handle.
+     * <p>
+     * When calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, incoming coordinate values
+     * are joined with bound coordinate values, and then passed to the target var handle.
+     * <p>
+     * For the bound coordinates to be well formed, their types must be {@code T1, T2 ... Tn },
+     * where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos} of the target var handle.
+     * <p>
+     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
+     * atomic access guarantees as those featured by the target var handle.
+     *
+     * @param target the var handle to invoke after the bound coordinates are inserted
+     * @param pos the position of the first coordinate to be inserted
+     * @param values the series of bound coordinates to insert
+     * @return an adapter var handle which inserts an additional coordinates,
+     *         before calling the target var handle
+     * @throws NullPointerException if either {@code target}, {@code values} are {@code == null}.
+     * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,
+     * or if more values are provided than the actual number of coordinate types available starting at {@code pos}.
+     * @throws ClassCastException if the bound coordinates in {@code values} are not well-formed, that is, they have types
+     * other than {@code T1, T2 ... Tn }, where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos}
+     * of the target var handle.
+     */
+    public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {
+        return JLI.insertCoordinates(target, pos, values);
+    }
+
+<<<<<<< HEAD
+        if (carrier != long.class) {
+            // slow-path, we need to adapt
+            return filterValue(target,
+                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(carrier, MemoryAddress.class)),
+                    MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, carrier)));
+        } else {
+            // fast-path
+            return filterValue(target, ADDRESS_TO_LONG, LONG_TO_ADDRESS);
+        }
+    }
+
     /**
      * Adapts a target var handle by pre-processing incoming and outgoing values using a pair of unary filter functions.
      * <p>
      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var handle, the incoming value (of type {@code T}, where
      * {@code T} is the parameter type of the first filter function) is processed using the first filter and then passed
@@ -488,19 +749,107 @@
     public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {
         return JLI.collectCoordinates(target, pos, filter);
     }
 
     /**
+=======
+    /**
+     * Provides a var handle which adapts the coordinate values of the target var handle, by re-arranging them
+     * so that the new coordinates match the provided ones.
+     * <p>
+     * The given array controls the reordering.
+     * Call {@code #I} the number of incoming coordinates (the value
+     * {@code newCoordinates.size()}, and call {@code #O} the number
+     * of outgoing coordinates (the number of coordinates associated with the target var handle).
+     * Then the length of the reordering array must be {@code #O},
+     * and each element must be a non-negative number less than {@code #I}.
+     * For every {@code N} less than {@code #O}, the {@code N}-th
+     * outgoing coordinate will be taken from the {@code I}-th incoming
+     * coordinate, where {@code I} is {@code reorder[N]}.
+     * <p>
+     * No coordinate value conversions are applied.
+     * The type of each incoming coordinate, as determined by {@code newCoordinates},
+     * must be identical to the type of the corresponding outgoing coordinate
+     * in the target var handle.
+     * <p>
+     * The reordering array need not specify an actual permutation.
+     * An incoming coordinate will be duplicated if its index appears
+     * more than once in the array, and an incoming coordinate will be dropped
+     * if its index does not appear in the array.
+     * <p>
+     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
+     * atomic access guarantees as those featured by the target var handle.
+     * @param target the var handle to invoke after the coordinates have been reordered
+     * @param newCoordinates the new coordinate types
+     * @param reorder an index array which controls the reordering
+     * @return an adapter var handle which re-arranges the incoming coordinate values,
+     * before calling the target var handle
+     * @throws NullPointerException if either {@code target}, {@code newCoordinates} or {@code reorder} are {@code == null}.
+     * @throws IllegalArgumentException if the index array length is not equal to
+     * the number of coordinates of the target var handle, or if any index array element is not a valid index for
+     * a coordinate of {@code newCoordinates}, or if two corresponding coordinate types in
+     * the target var handle and in {@code newCoordinates} are not identical.
+     */
+    public static VarHandle permuteCoordinates(VarHandle target, List<Class<?>> newCoordinates, int... reorder) {
+        return JLI.permuteCoordinates(target, newCoordinates, reorder);
+    }
+
+    /**
+     * Adapts a target var handle handle by pre-processing
+     * a sub-sequence of its coordinate values with a filter (a method handle).
+     * The pre-processed coordinates are replaced by the result (if any) of the
+     * filter function and the target var handle is then called on the modified (usually shortened)
+     * coordinate list.
+     * <p>
+     * If {code R} is the return type of the filter (which cannot be void), the target var handle must accept a value of
+     * type {@code R} as its coordinate in position {@code pos}, preceded and/or followed by
+     * any coordinate not passed to the filter.
+     * No coordinates are reordered, and the result returned from the filter
+     * replaces (in order) the whole subsequence of coordinates originally
+     * passed to the adapter.
+     * <p>
+     * The argument types (if any) of the filter
+     * replace zero or one coordinate types of the target var handle, at position {@code pos},
+     * in the resulting adapted var handle.
+     * The return type of the filter must be identical to the
+     * coordinate type of the target var handle at position {@code pos}, and that target var handle
+     * coordinate is supplied by the return value of the filter.
+     * <p>
+     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
+     * atomic access guarantees as those featured by the target var handle.
+     *
+     * @param target the var handle to invoke after the coordinates have been filtered
+     * @param pos the position of the coordinate to be filtered
+     * @param filter the filter method handle
+     * @return an adapter var handle which filters the incoming coordinate values,
+     * before calling the target var handle
+     * @throws NullPointerException if either {@code target}, {@code filter} are {@code == null}.
+     * @throws IllegalArgumentException if the return type of {@code filter}
+     * is void, or it is not the same as the {@code pos} coordinate of the target var handle,
+     * if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,
+     * if the resulting var handle's type would have <a href="MethodHandle.html#maxarity">too many coordinates</a>,
+     * or if {@code filter} throws any checked exceptions.
+     */
+    public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {
+        return JLI.collectCoordinates(target, pos, filter);
+    }
+
+    /**
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      * Returns a var handle which will discard some dummy coordinates before delegating to the
      * target var handle. As a consequence, the resulting var handle will feature more
      * coordinate types than the target var handle.
      * <p>
      * The {@code pos} argument may range between zero and <i>N</i>, where <i>N</i> is the arity of the
      * target var handle's coordinate types. If {@code pos} is zero, the dummy coordinates will precede
      * the target's real arguments; if {@code pos} is <i>N</i> they will come after.
      * <p>
+<<<<<<< HEAD
      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode}) and
+=======
+     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      * atomic access guarantees as those featured by the target var handle.
      *
      * @param target the var handle to invoke after the dummy coordinates are dropped
      * @param pos position of first coordinate to drop (zero for the leftmost)
      * @param valueTypes the type(s) of the coordinate(s) to drop
@@ -529,10 +878,32 @@
     private static long carrierSize(Class<?> carrier) {
         long bitsAlignment = Math.max(8, Wrapper.forPrimitiveType(carrier).bitWidth());
         return Utils.bitsToBytesOrThrow(bitsAlignment, IllegalStateException::new);
     }
 
+<<<<<<< HEAD
+=======
+    private static void checkWidenable(Class<?> carrier) {
+        if (!(carrier == byte.class || carrier == short.class || carrier == int.class)) {
+            throw new IllegalArgumentException("illegal carrier:" + carrier.getSimpleName());
+        }
+    }
+
+    private static void checkNarrowable(Class<?> type) {
+        if (!(type == int.class || type == long.class)) {
+            throw new IllegalArgumentException("illegal adapter type: " + type.getSimpleName());
+        }
+    }
+
+    private static void checkTargetWiderThanCarrier(Class<?> carrier, Class<?> target) {
+        if (Wrapper.forPrimitiveType(target).bitWidth() <= Wrapper.forPrimitiveType(carrier).bitWidth()) {
+            throw new IllegalArgumentException(
+                    target.getSimpleName() + " is not wider than: " + carrier.getSimpleName());
+        }
+    }
+
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     private static MemoryAddress longToAddress(long value) {
         return MemoryAddress.ofLong(value);
     }
 
     private static long addressToLong(MemoryAddress value) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
@@ -95,11 +95,11 @@
  * A <em>layout path</em> originates from a <em>root</em> layout (typically a group or a sequence layout) and terminates
  * at a layout nested within the root layout - this is the layout <em>selected</em> by the layout path.
  * Layout paths are typically expressed as a sequence of one or more {@link PathElement} instances.
  * <p>
  * Layout paths are for example useful in order to obtain offsets of arbitrarily nested layouts inside another layout
- * (see {@link MemoryLayout#offset(PathElement...)}), to quickly obtain a memory access handle corresponding to the selected
+ * (see {@link MemoryLayout#bitOffset(PathElement...)}), to quickly obtain a memory access handle corresponding to the selected
  * layout (see {@link MemoryLayout#varHandle(Class, PathElement...)}), to select an arbitrarily nested layout inside
  * another layout (see {@link MemoryLayout#select(PathElement...)}, or to transform a nested layout element inside
  * another layout (see {@link MemoryLayout#map(UnaryOperator, PathElement...)}).
  * <p>
  * Such <em>layout paths</em> can be constructed programmatically using the methods in this class.
@@ -110,13 +110,32 @@
         MemoryLayout.ofPaddingBits(32),
         MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName("value")
 ));
  * }</pre></blockquote>
  *
- * We can obtain the offset of the member layout named <code>value</code> from <code>seq</code>, as follows:
+ * We can obtain the offset, in bits, of the member layout named <code>value</code> from <code>seq</code>, as follows:
  * <blockquote><pre>{@code
-long valueOffset = seq.addOffset(PathElement.sequenceElement(), PathElement.groupElement("value"));
+long valueOffset = seq.bitOffset(PathElement.sequenceElement(), PathElement.groupElement("value"));
+ * }</pre></blockquote>
+ *
+ * Similarly, we can select the member layout named {@code value}, as follows:
+ * <blockquote><pre>{@code
+MemoryLayout value = seq.select(PathElement.sequenceElement(), PathElement.groupElement("value"));
+ * }</pre></blockquote>
+ *
+ * And, we can also replace the layout named {@code value} with another layout, as follows:
+ * <blockquote><pre>{@code
+MemoryLayout newSeq = seq.map(l -> MemoryLayout.ofPadding(32), PathElement.sequenceElement(), PathElement.groupElement("value"));
+ * }</pre></blockquote>
+ *
+ * That is, the above declaration is identical to the following, more verbose one:
+ * <blockquote><pre>{@code
+MemoryLayout newSeq = MemoryLayout.ofSequence(5,
+    MemoryLayout.ofStruct(
+        MemoryLayout.ofPaddingBits(32),
+        MemoryLayout.ofPaddingBits(32)
+));
  * }</pre></blockquote>
  *
  * Similarly, we can select the member layout named {@code value}, as follows:
  * <blockquote><pre>{@code
 MemoryLayout value = seq.select(PathElement.sequenceElement(), PathElement.groupElement("value"));
@@ -301,32 +320,53 @@
      * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it's less than than 8.
      */
     MemoryLayout withBitAlignment(long bitAlignment);
 
     /**
+<<<<<<< HEAD
      * Returns the attribute with the given name (if it exists).
      *
      * @param name the attribute name
      * @return the attribute with the given name (if it exists).
+=======
+     * Returns the attribute with the given name if it exists, or an empty optional
+     *
+     * @param name the name of the attribute
+     * @return the optional attribute
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      */
     Optional<Constable> attribute(String name);
 
     /**
+<<<<<<< HEAD
      * Returns a new memory layout which features the same attributes as this layout, plus the newly specified attribute.
      * If this layout already contains an attribute with the same name, the existing attribute value is overwritten in the returned
      * layout.
      *
      * @param name the attribute name.
      * @param value the attribute value.
      * @return a new memory layout which features the same attributes as this layout, plus the newly specified attribute.
+=======
+     * Returns a new MemoryLayout with the given additional attribute
+     *
+     * @param name the name of the attribute
+     * @param value the value of the attribute
+     * @return the new MemoryLayout
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      */
     MemoryLayout withAttribute(String name, Constable value);
 
     /**
+<<<<<<< HEAD
      * Returns a stream of the attribute names associated with this layout.
      *
      * @return a stream of the attribute names associated with this layout.
+=======
+     * Returns a stream of the names of the attributes of this layout
+     *
+     * @return the stream of names
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      */
     Stream<String> attributes();
 
     /**
      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
@@ -340,14 +380,34 @@
      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the
      * layout path contains one or more path elements that select multiple sequence element indices
      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).
      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.
      */
-    default long offset(PathElement... elements) {
+    default long bitOffset(PathElement... elements) {
         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset, EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);
     }
 
+    /**
+     * Computes the offset, in bytes, of the layout selected by a given layout path, where the path is considered rooted in this
+     * layout.
+     *
+     * @apiNote if the layout path has one (or more) free dimensions,
+     * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.
+     *
+     * @param elements the layout path elements.
+     * @return The offset, in bytes, of the layout selected by the layout path in {@code elements}.
+     * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the
+     * layout path contains one or more path elements that select multiple sequence element indices
+     * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).
+     * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size,
+     * or if {@code bitOffset(elements)} is not a multiple of 8.
+     */
+    default long byteOffset(PathElement... elements) {
+        return Utils.bitsToBytesOrThrow(bitOffset(elements),
+                () -> new UnsupportedOperationException("Cannot compute byte offset; bit offset is not a multiple of 8"));
+    }
+
     /**
      * Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path,
      * where the path is considered rooted in this layout.
      *
      * @apiNote the resulting var handle will feature an additional {@code long} access coordinate for every
@@ -410,11 +470,15 @@
         }
         return finalizer.apply(path);
     }
 
     /**
+<<<<<<< HEAD
      * Is this a padding layout (e.g. a layout created from {@link #ofPaddingBits(long)}) ?
+=======
+     * Is this a padding layout (e.g. a layout created from {@link #ofPaddingBits(long)} ?
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      * @return true, if this layout is a padding layout.
      */
     boolean isPadding();
 
     /**
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -29,10 +29,14 @@
 import java.nio.ByteBuffer;
 
 import jdk.internal.foreign.AbstractMemorySegmentImpl;
 import jdk.internal.foreign.HeapMemorySegmentImpl;
 import jdk.internal.foreign.MappedMemorySegmentImpl;
+<<<<<<< HEAD
+=======
+import jdk.internal.foreign.MemoryAddressImpl;
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 import jdk.internal.foreign.NativeMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 
 import java.io.IOException;
 import java.nio.channels.FileChannel;
@@ -108,26 +112,41 @@
  * (e.g. in the case of parallel processing); while memory segments provide strong confinement guarantees, it is possible
  * to obtain a {@link Spliterator} from a segment, which can be used to slice the segment and allow multiple thread to
  * work in parallel on disjoint segment slices (this assumes that the access mode {@link #ACQUIRE} is set).
  * For instance, the following code can be used to sum all int values in a memory segment in parallel:
  * <blockquote><pre>{@code
+<<<<<<< HEAD
 MemorySegment segment = ...
 SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
 VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);
 int sum = StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)
             .mapToInt(s -> (int)VH_int.get(s.baseAddress()))
+=======
+SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
+VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);
+int sum = StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)
+            .mapToInt(segment -> (int)VH_int.get(segment.baseAddress))
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
             .sum();
  * }</pre></blockquote>
  *
  * <h2><a id = "access-modes">Access modes</a></h2>
  *
  * Memory segments supports zero or more <em>access modes</em>. Supported access modes are {@link #READ},
+<<<<<<< HEAD
  * {@link #WRITE}, {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}. The set of access modes supported by a segment alters the
  * set of operations that are supported by that segment. For instance, attempting to call {@link #close()} on
  * a segment which does not support the {@link #CLOSE} access mode will result in an exception.
  * <p>
  * The set of supported access modes can only be made stricter (by supporting <em>fewer</em> access modes). This means
+=======
+ * {@link #WRITE}, {@link #CLOSE} and {@link #ACQUIRE}. The set of access modes supported by a segment alters the
+ * set of operations that are supported by that segment. For instance, attempting to call {@link #close()} on
+ * a segment which does not support the {@link #CLOSE} access mode will result in an exception.
+ * <p>
+ * The set of supported access modes can only be made stricter (by supporting <em>less</em> access modes). This means
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  * that restricting the set of access modes supported by a segment before sharing it with other clients
  * is generally a good practice if the creator of the segment wants to retain some control over how the segment
  * is going to be accessed.
  *
  * <h2>Memory segment views</h2>
@@ -175,12 +194,16 @@
      * characteristics.
      * <p>
      * The returned spliterator splits the segment according to the specified sequence layout; that is,
      * if the supplied layout is a sequence layout whose element count is {@code N}, then calling {@link Spliterator#trySplit()}
      * will result in a spliterator serving approximatively {@code N/2} elements (depending on whether N is even or not).
+<<<<<<< HEAD
      * As such, splitting is possible as long as {@code N >= 2}. The spliterator returns segments that feature the same
      * <a href="#access-modes">access modes</a> as the given segment less the {@link #CLOSE} access mode.
+=======
+     * As such, splitting is possible as long as {@code N >= 2}.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      * <p>
      * The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then
      * be processed in parallel by multiple threads (if the access mode {@link #ACQUIRE} is set).
      * While closing the segment (see {@link #close()}) during pending concurrent execution will generally
      * fail with an exception, it is possible to close a segment when a spliterator has been obtained but no thread
@@ -215,11 +238,15 @@
      * @param newOwner the new owner thread.
      * @return a new memory segment backed by the same underlying memory region as this segment,
      *      owned by {@code newOwner}.
      * @throws IllegalStateException if this segment is not <em>alive</em>, or if access occurs from a thread other than the
      * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different
+<<<<<<< HEAD
      * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).
+=======
+     * thread (see {@link #spliterator(SequenceLayout)}).
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      * @throws NullPointerException if {@code newOwner == null}
      * @throws IllegalArgumentException if the segment is already a confined segment owner by {@code newOnwer}.
      * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.
      */
     MemorySegment withOwnerThread(Thread newOwner);
@@ -230,31 +257,47 @@
      */
     long byteSize();
 
     /**
      * Obtains a segment view with specific <a href="#access-modes">access modes</a>. Supported access modes are {@link #READ}, {@link #WRITE},
+<<<<<<< HEAD
      * {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}. It is generally not possible to go from a segment with stricter access modes
+=======
+     * {@link #CLOSE} and {@link #ACQUIRE}. It is generally not possible to go from a segment with stricter access modes
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      * to one with less strict access modes. For instance, attempting to add {@link #WRITE} access mode to a read-only segment
      * will be met with an exception.
      * @param accessModes an ORed mask of zero or more access modes.
      * @return a segment view with specific access modes.
+<<<<<<< HEAD
      * @throws IllegalArgumentException when {@code mask} is an access mask which is less strict than the one supported by this
      * segment, or when {@code mask} contains bits not associated with any of the supported access modes.
+=======
+     * @throws UnsupportedOperationException when {@code mask} is an access mask which is less strict than the one supported by this
+     * segment.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      */
     MemorySegment withAccessModes(int accessModes);
 
     /**
      * Does this segment support a given set of access modes?
      * @param accessModes an ORed mask of zero or more access modes.
      * @return true, if the access modes in {@code accessModes} are stricter than the ones supported by this segment.
+<<<<<<< HEAD
      * @throws IllegalArgumentException when {@code mask} contains bits not associated with any of the supported access modes.
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      */
     boolean hasAccessModes(int accessModes);
 
     /**
      * Returns the <a href="#access-modes">access modes</a> associated with this segment; the result is represented as ORed values from
+<<<<<<< HEAD
      * {@link #READ}, {@link #WRITE}, {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}.
+=======
+     * {@link #READ}, {@link #WRITE}, {@link #CLOSE} and {@link #ACQUIRE}.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      * @return the access modes associated with this segment.
      */
     int accessModes();
 
     /**
@@ -284,10 +327,84 @@
      * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).
      * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.
      */
     void close();
 
+    /**
+     * Fills a value into this memory segment.
+     * <p>
+     * More specifically, the given value is filled into each address of this
+     * segment. Equivalent to (but likely more efficient than) the following code:
+     *
+     * <blockquote><pre>
+     * byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
+     *         .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
+     * for (long l = 0; l < segment.byteSize(); l++) {
+     *     byteHandle.set(segment.baseAddress(), l, value);
+     * }</pre></blockquote>
+     * without any regard or guarantees on the ordering of particular memory
+     * elements being set.
+     * <p>
+     * Fill can be useful to initialize or reset the memory of a segment.
+     *
+     * @param value the value to fill into this segment
+     * @return this memory segment
+     * @throws IllegalStateException if this segment is not <em>alive</em>, or if access occurs from a thread other than the
+     * thread owning this segment
+     * @throws UnsupportedOperationException if this segment does not support the {@link #WRITE} access mode
+     */
+    MemorySegment fill(byte value);
+
+    /**
+     * Performs a bulk copy from given source segment to this segment. More specifically, the bytes at
+     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment are copied into this segment
+     * at offset {@code 0} through {@code src.byteSize() - 1}.
+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at
+     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment were first copied into a
+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into
+     * this segment at offset {@code 0} through {@code src.byteSize() - 1}.
+     * <p>
+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment
+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.
+     * For example, this may occur if the same file is {@link MemorySegment#mapFromPath mapped} to two segments.
+     *
+     * @param src the source segment.
+     * @throws IndexOutOfBoundsException if {src.byteSize() > this.byteSize()}.
+     * @throws IllegalStateException if either the source segment or this segment have been already closed,
+     * or if access occurs from a thread other than the thread owning either segment.
+     * @throws UnsupportedOperationException if either the source segment or this segment do not feature required access modes;
+     * more specifically, {@code src} should feature at least the {@link MemorySegment#READ} access mode,
+     * while this segment should feature at least the {@link MemorySegment#WRITE} access mode.
+     */
+    void copyFrom(MemorySegment src);
+
+    /**
+     * Finds and returns the offset, in bytes, of the first mismatch between
+     * this segment and a given other segment. The offset is relative to the
+     * {@link #baseAddress() base address} of each segment and will be in the
+     * range of 0 (inclusive) up to the {@link #byteSize() size} (in bytes) of
+     * the smaller memory segment (exclusive).
+     * <p>
+     * If the two segments share a common prefix then the returned offset is
+     * the length of the common prefix and it follows that there is a mismatch
+     * between the two segments at that offset within the respective segments.
+     * If one segment is a proper prefix of the other then the returned offset is
+     * the smaller of the segment sizes, and it follows that the offset is only
+     * valid for the larger segment. Otherwise, there is no mismatch and {@code
+     * -1} is returned.
+     *
+     * @param other the segment to be tested for a mismatch with this segment
+     * @return the relative offset, in bytes, of the first mismatch between this
+     * and the given other segment, otherwise -1 if no mismatch
+     * @throws IllegalStateException if either this segment of the other segment
+     * have been already closed, or if access occurs from a thread other than the
+     * thread owning either segment
+     * @throws UnsupportedOperationException if either this segment or the other
+     * segment does not feature at least the {@link MemorySegment#READ} access mode
+     */
+    long mismatch(MemorySegment other);
+
     /**
      * Wraps this segment in a {@link ByteBuffer}. Some of the properties of the returned buffer are linked to
      * the properties of this segment. For instance, if this segment is <em>immutable</em>
      * (e.g. the segment has access mode {@link #READ} but not {@link #WRITE}), then the resulting buffer is <em>read-only</em>
      * (see {@link ByteBuffer#isReadOnly()}. Additionally, if this is a native memory segment, the resulting buffer is
@@ -520,11 +637,15 @@
     /**
      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
+<<<<<<< HEAD
      * (often as a plain {@code long} value). The segment will feature all <a href="#access-modes">access modes</a>.
+=======
+     * (often as a plain {@code long} value).
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      * <p>
      * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
      * restricted methods, and use safe and supported functionalities, where possible.
      *
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SequenceLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SequenceLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SequenceLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SequenceLayout.java
@@ -112,11 +112,15 @@
 
     /**
      * Returns a new sequence layout where element layouts in the flattened projection of this
      * sequence layout (see {@link #flatten()}) are re-arranged into one or more nested sequence layouts
      * according to the provided element counts. This transformation preserves the layout size;
+<<<<<<< HEAD
      * that is, multiplying the provided element counts must yield the same element count
+=======
+     * that is, multiplying the provided element counts should yield the same element count
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      * as the flattened projection of this sequence layout.
      * <p>
      * For instance, given a sequence layout of the kind:
      * <pre>{@code
     var seq = MemoryLayout.ofSequence(4, MemoryLayout.ofSequence(3, MemoryLayouts.JAVA_INT));
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -24,16 +24,26 @@
  */
 
 package jdk.internal.foreign;
 
 import jdk.incubator.foreign.MemoryAddress;
+<<<<<<< HEAD
+=======
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayouts;
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.internal.access.JavaNioAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.access.foreign.UnmapperProxy;
+<<<<<<< HEAD
+=======
+import jdk.internal.misc.Unsafe;
+import jdk.internal.util.ArraysSupport;
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 import jdk.internal.vm.annotation.ForceInline;
 import sun.security.action.GetPropertyAction;
 
 import java.lang.invoke.VarHandle;
 import java.nio.ByteBuffer;
@@ -53,10 +63,15 @@
  * are defined for each memory segment kind, see {@link NativeMemorySegmentImpl}, {@link HeapMemorySegmentImpl} and
  * {@link MappedMemorySegmentImpl}.
  */
 public abstract class AbstractMemorySegmentImpl implements MemorySegment, MemorySegmentProxy {
 
+<<<<<<< HEAD
+=======
+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     private static final boolean enableSmallSegments =
             Boolean.parseBoolean(GetPropertyAction.privilegedGetProperty("jdk.incubator.foreign.SmallSegments", "true"));
 
     final static int ACCESS_MASK = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;
     final static int FIRST_RESERVED_FLAG = 1 << 16; // upper 16 bits are reserved
@@ -66,26 +81,39 @@
 
     final static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
 
     final long length;
     final int mask;
+<<<<<<< HEAD
     final Thread owner;
     final MemoryScope scope;
 
     @ForceInline
     AbstractMemorySegmentImpl(long length, int mask, Thread owner, MemoryScope scope) {
         this.length = length;
         this.mask = mask;
         this.owner = owner;
+=======
+    final MemoryScope scope;
+
+    @ForceInline
+    AbstractMemorySegmentImpl(long length, int mask, MemoryScope scope) {
+        this.length = length;
+        this.mask = mask;
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         this.scope = scope;
     }
 
     abstract long min();
 
     abstract Object base();
 
+<<<<<<< HEAD
     abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope);
+=======
+    abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 
     abstract ByteBuffer makeByteBuffer();
 
     static int defaultAccessModes(long size) {
         return (enableSmallSegments && size < Integer.MAX_VALUE) ?
@@ -98,11 +126,15 @@
         checkBounds(offset, newSize);
         return asSliceNoCheck(offset, newSize);
     }
 
     private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
+<<<<<<< HEAD
         return dup(offset, newSize, mask, owner, scope);
+=======
+        return dup(offset, newSize, mask, scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @SuppressWarnings("unchecked")
     public static <S extends MemorySegment> Spliterator<S> spliterator(S segment, SequenceLayout sequenceLayout) {
         ((AbstractMemorySegmentImpl)segment).checkValidState();
@@ -112,10 +144,66 @@
         return (Spliterator<S>)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() & ~CLOSE));
     }
 
     @Override
+<<<<<<< HEAD
+=======
+    public final MemorySegment fill(byte value){
+        checkRange(0, length, true);
+        UNSAFE.setMemory(base(), min(), length, value);
+        return this;
+    }
+
+    public void copyFrom(MemorySegment src) {
+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;
+        long size = that.byteSize();
+        checkRange(0, size, true);
+        that.checkRange(0, size, false);
+        UNSAFE.copyMemory(
+                that.base(), that.min(),
+                base(), min(), size);
+    }
+
+    private final static VarHandle BYTE_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
+            .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
+
+    @Override
+    public long mismatch(MemorySegment other) {
+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;
+        final long thisSize = this.byteSize();
+        final long thatSize = that.byteSize();
+        final long length = Math.min(thisSize, thatSize);
+        this.checkRange(0, length, false);
+        that.checkRange(0, length, false);
+        if (this == other) {
+            return -1;
+        }
+
+        long i = 0;
+        if (length > 7) {
+            i = ArraysSupport.vectorizedMismatchLarge(
+                    this.base(), this.min(),
+                    that.base(), that.min(),
+                    length, ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE);
+            if (i >= 0) {
+                return i;
+            }
+            i = length - ~i;
+        }
+        MemoryAddress thisAddress = this.baseAddress();
+        MemoryAddress thatAddress = that.baseAddress();
+        for (; i < length; i++) {
+            if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {
+                return i;
+            }
+        }
+        return thisSize != thatSize ? length : -1;
+    }
+
+    @Override
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     @ForceInline
     public final MemoryAddress baseAddress() {
         return new MemoryAddressImpl(this, 0);
     }
 
@@ -143,25 +231,39 @@
         return length;
     }
 
     @Override
     public final boolean isAlive() {
+<<<<<<< HEAD
         return scope.isAliveThreadSafe();
+=======
+        return scope.isAlive();
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @Override
     public Thread ownerThread() {
+<<<<<<< HEAD
         return owner;
+=======
+        return scope.ownerThread();
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @Override
     public AbstractMemorySegmentImpl withAccessModes(int accessModes) {
         checkAccessModes(accessModes);
         if ((~accessModes() & accessModes) != 0) {
+<<<<<<< HEAD
             throw new IllegalArgumentException("Cannot acquire more access modes");
         }
         return dup(0, length, (mask & ~ACCESS_MASK) | accessModes, owner, scope);
+=======
+            throw new UnsupportedOperationException("Cannot acquire more access modes");
+        }
+        return dup(0, length, (mask & ~ACCESS_MASK) | accessModes, scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @Override
     public boolean hasAccessModes(int accessModes) {
         checkAccessModes(accessModes);
@@ -175,10 +277,11 @@
     }
 
     @Override
     public MemorySegment withOwnerThread(Thread newOwner) {
         Objects.requireNonNull(newOwner);
+<<<<<<< HEAD
         checkValidState();
         if (!isSet(HANDOFF)) {
             throw unsupportedAccessMode(HANDOFF);
         }
         if (owner == newOwner) {
@@ -186,64 +289,99 @@
         } else {
             try {
                 return dup(0L, length, mask, newOwner, scope.dup());
             } finally {
                 //flush read/writes to memory before returning the new segment
+=======
+        if (!isSet(HANDOFF)) {
+            throw unsupportedAccessMode(HANDOFF);
+        }
+        if (scope.ownerThread() == newOwner) {
+            throw new IllegalArgumentException("Segment already owned by thread: " + newOwner);
+        } else {
+            try {
+                return dup(0L, length, mask, scope.dup(newOwner));
+            } finally {
+                //flush read/writes to segment memory before returning the new segment
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
                 VarHandle.fullFence();
             }
         }
     }
 
     @Override
     public final void close() {
         if (!isSet(CLOSE)) {
             throw unsupportedAccessMode(CLOSE);
         }
+<<<<<<< HEAD
         checkValidState();
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         closeNoCheck();
     }
 
     private final void closeNoCheck() {
+<<<<<<< HEAD
         scope.close(true);
+=======
+        scope.close();
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     final AbstractMemorySegmentImpl acquire() {
         if (Thread.currentThread() != ownerThread() && !isSet(ACQUIRE)) {
             throw unsupportedAccessMode(ACQUIRE);
         }
+<<<<<<< HEAD
         return dup(0, length, mask, Thread.currentThread(), scope.acquire());
+=======
+        return dup(0, length, mask, scope.acquire());
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @Override
     public final byte[] toByteArray() {
         checkIntSize("byte[]");
         byte[] arr = new byte[(int)length];
         MemorySegment arrSegment = MemorySegment.ofArray(arr);
+<<<<<<< HEAD
         MemoryAddress.copy(baseAddress(), arrSegment.baseAddress(), length);
+=======
+        arrSegment.copyFrom(this);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         return arr;
     }
 
     boolean isSmall() {
         return isSet(SMALL);
     }
 
     void checkRange(long offset, long length, boolean writeAccess) {
+<<<<<<< HEAD
         checkValidState();
+=======
+        scope.checkValidState();
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         if (writeAccess && !isSet(WRITE)) {
             throw unsupportedAccessMode(WRITE);
         } else if (!writeAccess && !isSet(READ)) {
             throw unsupportedAccessMode(READ);
         }
         checkBounds(offset, length);
     }
 
     @Override
     public final void checkValidState() {
+<<<<<<< HEAD
         if (owner != null && owner != Thread.currentThread()) {
             throw new IllegalStateException("Attempt to access segment outside owning thread");
         }
         scope.checkAliveConfined();
+=======
+        scope.checkValidState();
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     // Helper methods
 
     private boolean isSet(int mask) {
@@ -413,33 +551,56 @@
         int size = limit - pos;
 
         AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl)nioAccess.bufferSegment(bb);
         final MemoryScope bufferScope;
         int modes;
+<<<<<<< HEAD
         final Thread owner;
         if (bufferSegment != null) {
             bufferScope = bufferSegment.scope;
             modes = bufferSegment.mask;
             owner = bufferSegment.owner;
         } else {
             bufferScope = new MemoryScope(bb, null);
             modes = defaultAccessModes(size);
             owner = Thread.currentThread();
+=======
+        if (bufferSegment != null) {
+            bufferScope = bufferSegment.scope;
+            modes = bufferSegment.mask;
+        } else {
+            bufferScope = MemoryScope.create(bb, null);
+            modes = defaultAccessModes(size);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         }
         if (bb.isReadOnly()) {
             modes &= ~WRITE;
         }
         if (base != null) {
+<<<<<<< HEAD
             return new HeapMemorySegmentImpl<>(bbAddress + pos, () -> (byte[])base, size, modes, owner, bufferScope);
         } else if (unmapper == null) {
             return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, owner, bufferScope);
         } else {
             return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, owner, bufferScope);
         }
     }
 
     public static AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(0, 0, null, MemoryScope.GLOBAL) {
+=======
+            return new HeapMemorySegmentImpl<>(bbAddress + pos, () -> (byte[])base, size, modes, bufferScope);
+        } else if (unmapper == null) {
+            return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, bufferScope);
+        } else {
+            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, bufferScope);
+        }
+    }
+
+    public static final AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(
+        0, 0, MemoryScope.createUnchecked(null, null, null)
+    ) {
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         @Override
         ByteBuffer makeByteBuffer() {
             throw new UnsupportedOperationException();
         }
 
@@ -452,10 +613,14 @@
         Object base() {
             return null;
         }
 
         @Override
+<<<<<<< HEAD
         AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
+=======
+        AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
             throw new UnsupportedOperationException();
         }
     };
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java
@@ -50,12 +50,17 @@
 
     final long offset;
     final Supplier<H> baseProvider;
 
     @ForceInline
+<<<<<<< HEAD
     HeapMemorySegmentImpl(long offset, Supplier<H> baseProvider, long length, int mask, Thread owner, MemoryScope scope) {
         super(length, mask, owner, scope);
+=======
+    HeapMemorySegmentImpl(long offset, Supplier<H> baseProvider, long length, int mask, MemoryScope scope) {
+        super(length, mask, scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         this.offset = offset;
         this.baseProvider = baseProvider;
     }
 
     @Override
@@ -67,12 +72,17 @@
     long min() {
         return offset;
     }
 
     @Override
+<<<<<<< HEAD
     HeapMemorySegmentImpl<H> dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
         return new HeapMemorySegmentImpl<H>(this.offset + offset, baseProvider, size, mask, owner, scope);
+=======
+    HeapMemorySegmentImpl<H> dup(long offset, long size, int mask, MemoryScope scope) {
+        return new HeapMemorySegmentImpl<>(this.offset + offset, baseProvider, size, mask, scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @Override
     ByteBuffer makeByteBuffer() {
         if (!(base() instanceof byte[])) {
@@ -119,9 +129,14 @@
                 Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE);
     }
 
     static <Z> HeapMemorySegmentImpl<Z> makeHeapSegment(Supplier<Z> obj, int length, int base, int scale) {
         int byteSize = length * scale;
+<<<<<<< HEAD
         MemoryScope scope = new MemoryScope(null, null);
         return new HeapMemorySegmentImpl<>(base, obj, byteSize, defaultAccessModes(byteSize), Thread.currentThread(), scope);
+=======
+        MemoryScope scope = MemoryScope.create(null, null);
+        return new HeapMemorySegmentImpl<>(base, obj, byteSize, defaultAccessModes(byteSize), scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java
@@ -46,24 +46,34 @@
  */
 public class MappedMemorySegmentImpl extends NativeMemorySegmentImpl implements MappedMemorySegment {
 
     private final UnmapperProxy unmapper;
 
+<<<<<<< HEAD
     MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, Thread owner, MemoryScope scope) {
         super(min, length, mask, owner, scope);
+=======
+    MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, MemoryScope scope) {
+        super(min, length, mask, scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         this.unmapper = unmapper;
     }
 
     @Override
     ByteBuffer makeByteBuffer() {
         JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
         return nioAccess.newMappedByteBuffer(unmapper, min, (int)length, null, this);
     }
 
     @Override
+<<<<<<< HEAD
     MappedMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
         return new MappedMemorySegmentImpl(min + offset, unmapper, size, mask, owner, scope);
+=======
+    MappedMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
+        return new MappedMemorySegmentImpl(min + offset, unmapper, size, mask, scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     // mapped segment methods
 
 
@@ -101,17 +111,23 @@
 
     public static MappedMemorySegment makeMappedSegment(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
         if (bytesSize <= 0) throw new IllegalArgumentException("Requested bytes size must be > 0.");
         try (FileChannelImpl channelImpl = (FileChannelImpl)FileChannel.open(path, openOptions(mapMode))) {
             UnmapperProxy unmapperProxy = channelImpl.mapInternal(mapMode, 0L, bytesSize);
+<<<<<<< HEAD
             MemoryScope scope = new MemoryScope(null, unmapperProxy::unmap);
             int modes = defaultAccessModes(bytesSize);
             if (mapMode == FileChannel.MapMode.READ_ONLY) {
                 modes &= ~WRITE;
             }
             return new MappedMemorySegmentImpl(unmapperProxy.address(), unmapperProxy, bytesSize,
                     modes, Thread.currentThread(), scope);
+=======
+            MemoryScope scope = MemoryScope.create(null, unmapperProxy::unmap);
+            return new MappedMemorySegmentImpl(unmapperProxy.address(), unmapperProxy, bytesSize,
+                    defaultAccessModes(bytesSize), scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         }
     }
 
     private static OpenOption[] openOptions(FileChannel.MapMode mapMode) {
         if (mapMode == FileChannel.MapMode.READ_ONLY) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
@@ -44,27 +44,24 @@
     private final AbstractMemorySegmentImpl segment;
     private final long offset;
 
     public MemoryAddressImpl(long offset) {
         this.segment = AbstractMemorySegmentImpl.NOTHING;
+<<<<<<< HEAD
         this.offset = offset;
     }
 
     public MemoryAddressImpl(AbstractMemorySegmentImpl segment, long offset) {
         this.segment = Objects.requireNonNull(segment);
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         this.offset = offset;
     }
 
-    public static void copy(MemoryAddressImpl src, MemoryAddressImpl dst, long size) {
-        src.checkAccess(0, size, true);
-        dst.checkAccess(0, size, false);
-        //check disjoint
-        long offsetSrc = src.unsafeGetOffset();
-        long offsetDst = dst.unsafeGetOffset();
-        Object baseSrc = src.unsafeGetBase();
-        Object baseDst = dst.unsafeGetBase();
-        UNSAFE.copyMemory(baseSrc, offsetSrc, baseDst, offsetDst, size);
+    public MemoryAddressImpl(AbstractMemorySegmentImpl segment, long offset) {
+        this.segment = Objects.requireNonNull(segment);
+        this.offset = offset;
     }
 
     // MemoryAddress methods
 
     @Override
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
@@ -24,91 +24,244 @@
  *
  */
 
 package jdk.internal.foreign;
 
+import jdk.internal.vm.annotation.ForceInline;
+
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
+import java.util.Objects;
+import java.util.concurrent.atomic.LongAdder;
+import java.util.concurrent.locks.StampedLock;
 
 /**
+<<<<<<< HEAD
  * This class manages the temporal bounds associated with a memory segment. A scope has a liveness bit, which is updated
  * when the scope is closed (this operation is triggered by {@link AbstractMemorySegmentImpl#close()}). Furthermore, a scope is
  * associated with an <em>atomic</em> counter which can be incremented (upon calling the {@link #acquire()} method),
  * and is decremented (when a previously acquired segment is later closed).
+=======
+ * This class manages the temporal bounds associated with a memory segment as well
+ * as thread confinement.
+ * A scope has a liveness bit, which is updated when the scope is closed
+ * (this operation is triggered by {@link AbstractMemorySegmentImpl#close()}).
+ * A scope may also have an associated "owner" thread that confines some operations to
+ * associated owner thread such as {@link #close()} or {@link #dup(Thread)}.
+ * Furthermore, a scope is either root scope ({@link #create(Object, Runnable) created}
+ * when memory segment is allocated) or child scope ({@link #acquire() acquired} from root scope).
+ * When a child scope is acquired from another child scope, it is actually acquired from
+ * the root scope. There is only a single level of children. All child scopes are peers.
+ * A child scope can be {@link #close() closed} at any time, but root scope can only
+ * be closed after all its children have been closed, at which time any associated
+ * cleanup action is executed (the associated memory segment is freed).
+ * Besides thread-confined checked scopes, {@linkplain #createUnchecked(Thread, Object, Runnable)}
+ * method may be used passing {@code null} as the "owner" thread to create a
+ * scope that doesn't check for thread-confinement while its temporal bounds are
+ * enforced reliably only under condition that thread that closes the scope is also
+ * the single thread performing the checked access or there is an external synchronization
+ * in place that prevents concurrent access and closing of the scope.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  */
-public final class MemoryScope {
+abstract class MemoryScope {
 
-    //reference to keep hold onto
-    final Object ref;
+    /**
+     * Creates a root MemoryScope with given ref, cleanupAction and current
+     * thread as the "owner" thread.
+     * This method may be called in any thread.
+     * The returned instance may be published unsafely to and used in any thread,
+     * but methods that explicitly state that they may only be called in "owner" thread,
+     * must strictly be called in the thread that created the scope
+     * or else IllegalStateException is thrown.
+     *
+     * @param ref           an optional reference to an instance that needs to be kept reachable
+     * @param cleanupAction an optional cleanup action to be executed when returned scope is closed
+     * @return a root MemoryScope
+     */
+    static MemoryScope create(Object ref, Runnable cleanupAction) {
+        return new Root(Thread.currentThread(), ref, cleanupAction);
+    }
 
-    int activeCount = UNACQUIRED;
+    /**
+     * Creates a root MemoryScope with given ref, cleanupAction and "owner" thread.
+     * This method may be called in any thread.
+     * The returned instance may be published unsafely to and used in any thread,
+     * but methods that explicitly state that they may only be called in "owner" thread,
+     * must strictly be called in given owner thread or else IllegalStateException is thrown.
+     * If given owner thread is null, the returned MemoryScope is unchecked, meaning
+     * that all methods may be called in any thread and that {@link #checkValidState()}
+     * does not check for temporal bounds.
+     *
+     * @param owner         the desired owner thread. If {@code owner == null},
+     *                      the returned scope is <em>not</em> thread-confined and not checked.
+     * @param ref           an optional reference to an instance that needs to be kept reachable
+     * @param cleanupAction an optional cleanup action to be executed when returned scope is closed
+     * @return a root MemoryScope
+     */
+    static MemoryScope createUnchecked(Thread owner, Object ref, Runnable cleanupAction) {
+        return new Root(owner, ref, cleanupAction);
+    }
 
-    final static VarHandle COUNT_HANDLE;
+    private final Thread owner;
+    private boolean closed; // = false
+    private static final VarHandle CLOSED;
 
     static {
         try {
-            COUNT_HANDLE = MethodHandles.lookup().findVarHandle(MemoryScope.class, "activeCount", int.class);
+            CLOSED = MethodHandles.lookup().findVarHandle(MemoryScope.class, "closed", boolean.class);
         } catch (Throwable ex) {
             throw new ExceptionInInitializerError(ex);
         }
     }
 
-    final static int UNACQUIRED = 0;
-    final static int CLOSED = -1;
-    final static int MAX_ACQUIRE = Integer.MAX_VALUE;
+    private MemoryScope(Thread owner) {
+        this.owner = owner;
+    }
+
+    /**
+     * Acquires a child scope (or peer scope if this is a child) with current
+     * thread as the "owner" thread.
+     * This method may be called in any thread.
+     * The returned instance may be published unsafely to and used in any thread,
+     * but methods that explicitly state that they may only be called in "owner" thread,
+     * must strictly be called in the thread that acquired the scope
+     * or else IllegalStateException is thrown.
+     *
+     * @return a child (or peer) scope
+     * @throws IllegalStateException if root scope is already closed
+     */
+    abstract MemoryScope acquire();
+
+    /**
+     * Closes this scope, executing any cleanup action if this is the root scope.
+     * This method may only be called in the "owner" thread of this scope unless the
+     * scope is a root scope with no owner thread - i.e. is not checked.
+     *
+     * @throws IllegalStateException if this scope is already closed or if this is
+     *                               a root scope and there is/are still active child
+     *                               scope(s) or if this method is called outside of
+     *                               owner thread in checked scope
+     */
+    abstract void close();
 
-    final Runnable cleanupAction;
+    /**
+     * Duplicates this scope with given new "owner" thread and {@link #close() closes} it.
+     * If this is a root scope, a new root scope is returned; this root scope is closed, but
+     * without executing the cleanup action, which is instead transferred to the duped scope.
+     * If this is a child scope, a new child scope is returned.
+     * This method may only be called in the "owner" thread of this scope unless the
+     * scope is a root scope with no owner thread - i.e. is not checked.
+     * The returned instance may be published unsafely to and used in any thread,
+     * but methods that explicitly state that they may only be called in "owner" thread,
+     * must strictly be called in given new "owner" thread
+     * or else IllegalStateException is thrown.
+     *
+     * @param newOwner new owner thread of the returned MemoryScope
+     * @return a duplicate of this scope
+     * @throws NullPointerException  if given owner thread is null
+     * @throws IllegalStateException if this scope is already closed or if this is
+     *                               a root scope and there is/are still active child
+     *                               scope(s) or if this method is called outside of
+     *                               owner thread in checked scope
+     */
+    abstract MemoryScope dup(Thread newOwner);
 
+<<<<<<< HEAD
     final static MemoryScope GLOBAL = new MemoryScope(null, null);
 
     public MemoryScope(Object ref, Runnable cleanupAction) {
         this.ref = ref;
         this.cleanupAction = cleanupAction;
+=======
+    /**
+     * Returns "owner" thread of this scope.
+     *
+     * @return owner thread (or null for unchecked scope)
+     */
+    final Thread ownerThread() {
+        return owner;
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     /**
-     * This method performs a full, thread-safe liveness check; can be used outside confinement thread.
+     * This method may be called in any thread.
+     *
+     * @return {@code true} if this scope is not closed yet.
      */
-    final boolean isAliveThreadSafe() {
-        return ((int)COUNT_HANDLE.getVolatile(this)) != CLOSED;
+    final boolean isAlive() {
+        return !((boolean)CLOSED.getVolatile(this));
     }
 
     /**
-     * This method performs a quick liveness check; must be called from the confinement thread.
+     * Checks that this scope is still alive and that this method is executed
+     * in the "owner" thread of this scope or this scope is unchecked (not associated
+     * with owner thread).
+     *
+     * @throws IllegalStateException if this scope is already closed or this
+     *                               method is executed outside owning thread
+     *                               in checked scope
      */
-    final void checkAliveConfined() {
-        if (activeCount == CLOSED) {
-            throw new IllegalStateException("Segment is not alive");
+    @ForceInline
+    final void checkValidState() {
+        if (owner != null && owner != Thread.currentThread()) {
+            throw new IllegalStateException("Attempted access outside owning thread");
         }
+        checkAliveConfined(this);
     }
 
-    MemoryScope acquire() {
-        int value;
-        do {
-            value = (int)COUNT_HANDLE.getVolatile(this);
-            if (value == CLOSED) {
-                //segment is not alive!
-                throw new IllegalStateException("Segment is not alive");
-            } else if (value == MAX_ACQUIRE) {
-                //overflow
-                throw new IllegalStateException("Segment acquire limit exceeded");
-            }
-        } while (!COUNT_HANDLE.compareAndSet(this, value, value + 1));
-        return new MemoryScope(ref, this::release);
+    /**
+     * Checks that this scope is still alive.
+     *
+     * @throws IllegalStateException if this scope is already closed
+     */
+    @ForceInline
+    private static void checkAliveConfined(MemoryScope scope) {
+        if (scope.closed) {
+            throw new IllegalStateException("This scope is already closed");
+        }
     }
 
-    private void release() {
-        int value;
-        do {
-            value = (int)COUNT_HANDLE.getVolatile(this);
-            if (value <= UNACQUIRED) {
-                //cannot get here - we can't close segment twice
-                throw new IllegalStateException();
+    private static final class Root extends MemoryScope {
+        private final StampedLock lock = new StampedLock();
+        private final LongAdder acquired = new LongAdder();
+        private final Object ref;
+        private final Runnable cleanupAction;
+
+        private Root(Thread owner, Object ref, Runnable cleanupAction) {
+            super(owner);
+            this.ref = ref;
+            this.cleanupAction = cleanupAction;
+        }
+
+        @Override
+        MemoryScope acquire() {
+            // try to optimistically acquire the lock
+            long stamp = lock.tryOptimisticRead();
+            try {
+                for (; ; stamp = lock.readLock()) {
+                    if (stamp == 0L)
+                        continue;
+                    checkAliveConfined(this); // plain read is enough here (either successful optimistic read, or full read lock)
+
+                    // increment acquires
+                    acquired.increment();
+                    // did a call to close() occur since we acquired the lock?
+                    if (lock.validate(stamp)) {
+                        // no, just return the acquired scope
+                        return new Child(Thread.currentThread());
+                    } else {
+                        // yes, just back off and retry (close might have failed, after all)
+                        acquired.decrement();
+                    }
+                }
+            } finally {
+                if (StampedLock.isReadLockStamp(stamp))
+                    lock.unlockRead(stamp);
             }
-        } while (!COUNT_HANDLE.compareAndSet(this, value, value - 1));
-    }
+        }
 
+<<<<<<< HEAD
     void close(boolean doCleanup) {
         if (!COUNT_HANDLE.compareAndSet(this, UNACQUIRED, CLOSED)) {
             //first check if already closed...
             checkAliveConfined();
             //...if not, then we have acquired views that are still active
@@ -122,5 +275,73 @@
     MemoryScope dup() {
         close(false);
         return new MemoryScope(ref, cleanupAction);
     }
 }
+=======
+        @Override
+        MemoryScope dup(Thread newOwner) {
+            Objects.requireNonNull(newOwner, "newOwner");
+            // pre-allocate duped scope so we don't get OOME later and be left with this scope closed
+            var duped = new Root(newOwner, ref, cleanupAction);
+            justClose();
+            return duped;
+        }
+
+        @Override
+        void close() {
+            justClose();
+            if (cleanupAction != null) {
+                cleanupAction.run();
+            }
+        }
+
+        @ForceInline
+        private void justClose() {
+            // enter critical section - no acquires are possible past this point
+            long stamp = lock.writeLock();
+            try {
+                checkValidState(); // plain read is enough here (full write lock)
+                // check for absence of active acquired children
+                if (acquired.sum() > 0) {
+                    throw new IllegalStateException("Cannot close this scope as it has active acquired children");
+                }
+                // now that we made sure there's no active acquired children, we can mark scope as closed
+                CLOSED.set(this, true); // plain write is enough here (full write lock)
+            } finally {
+                // leave critical section
+                lock.unlockWrite(stamp);
+            }
+        }
+
+        private final class Child extends MemoryScope {
+
+            private Child(Thread owner) {
+                super(owner);
+            }
+
+            @Override
+            MemoryScope acquire() {
+                return Root.this.acquire();
+            }
+
+            @Override
+            MemoryScope dup(Thread newOwner) {
+                checkValidState(); // child scope is always checked
+                // pre-allocate duped scope so we don't get OOME later and be left with this scope closed
+                var duped = new Child(newOwner);
+                CLOSED.setVolatile(this, true);
+                return duped;
+            }
+
+            @Override
+            void close() {
+                checkValidState(); // child scope is always checked
+                CLOSED.set(this, true);
+                // following acts as a volatile write after plain write above so
+                // plain write gets flushed too (which is important for isAliveThreadSafe())
+                Root.this.acquired.decrement();
+            }
+        }
+    }
+}
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java
@@ -51,18 +51,28 @@
     private static final boolean skipZeroMemory = GetBooleanAction.privilegedGetProperty("jdk.internal.foreign.skipZeroMemory");
 
     final long min;
 
     @ForceInline
+<<<<<<< HEAD
     NativeMemorySegmentImpl(long min, long length, int mask, Thread owner, MemoryScope scope) {
         super(length, mask, owner, scope);
+=======
+    NativeMemorySegmentImpl(long min, long length, int mask, MemoryScope scope) {
+        super(length, mask, scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         this.min = min;
     }
 
     @Override
+<<<<<<< HEAD
     NativeMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
         return new NativeMemorySegmentImpl(min + offset, size, mask, owner, scope);
+=======
+    NativeMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
+        return new NativeMemorySegmentImpl(min + offset, size, mask, scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @Override
     ByteBuffer makeByteBuffer() {
         JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
@@ -91,20 +101,32 @@
         long buf = unsafe.allocateMemory(alignedSize);
         if (!skipZeroMemory) {
             unsafe.setMemory(buf, alignedSize, (byte)0);
         }
         long alignedBuf = Utils.alignUp(buf, alignmentBytes);
+<<<<<<< HEAD
         MemoryScope scope = new MemoryScope(null, () -> unsafe.freeMemory(buf));
         MemorySegment segment = new NativeMemorySegmentImpl(buf, alignedSize, defaultAccessModes(alignedSize),
                 Thread.currentThread(), scope);
+=======
+        MemoryScope scope = MemoryScope.create(null, () -> unsafe.freeMemory(buf));
+        MemorySegment segment = new NativeMemorySegmentImpl(buf, alignedSize,
+                                                            defaultAccessModes(alignedSize),
+                                                            scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         if (alignedSize != bytesSize) {
             long delta = alignedBuf - buf;
             segment = segment.asSlice(delta, bytesSize);
         }
         return segment;
     }
 
     public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {
+<<<<<<< HEAD
         MemoryScope scope = new MemoryScope(attachment, cleanup);
         return new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, defaultAccessModes(bytesSize), owner, scope);
+=======
+        MemoryScope scope = MemoryScope.createUnchecked(owner, attachment, cleanup);
+        return new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, defaultAccessModes(bytesSize), scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 }
diff a/test/jdk/java/foreign/TestAdaptVarHandles.java b/test/jdk/java/foreign/TestAdaptVarHandles.java
--- a/test/jdk/java/foreign/TestAdaptVarHandles.java
+++ b/test/jdk/java/foreign/TestAdaptVarHandles.java
@@ -47,10 +47,16 @@
 
 public class TestAdaptVarHandles {
 
     static MethodHandle S2I;
     static MethodHandle I2S;
+<<<<<<< HEAD
+=======
+    static MethodHandle CTX_I2S;
+    static MethodHandle O2I;
+    static MethodHandle I2O;
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     static MethodHandle S2L;
     static MethodHandle S2L_EX;
     static MethodHandle S2I_EX;
     static MethodHandle I2S_EX;
     static MethodHandle BASE_ADDR;
@@ -59,10 +65,17 @@
 
     static {
         try {
             S2I = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "stringToInt", MethodType.methodType(int.class, String.class));
             I2S = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "intToString", MethodType.methodType(String.class, int.class));
+<<<<<<< HEAD
+=======
+            CTX_I2S = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "ctxIntToString",
+                    MethodType.methodType(String.class, String.class, String.class, int.class));
+            O2I = MethodHandles.explicitCastArguments(S2I, MethodType.methodType(int.class, Object.class));
+            I2O = MethodHandles.explicitCastArguments(I2S, MethodType.methodType(Object.class, int.class));
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
             S2L = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "stringToLong", MethodType.methodType(long.class, String.class));
             S2L_EX = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "stringToLongException", MethodType.methodType(long.class, String.class));
             BASE_ADDR = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "baseAddress", MethodType.methodType(MemoryAddress.class, MemorySegment.class));
             SUM_OFFSETS = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "sumOffsets", MethodType.methodType(long.class, long.class, long.class));
             VOID_FILTER = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "void_filter", MethodType.methodType(void.class, String.class));
@@ -96,10 +109,53 @@
         assertEquals(oldValue, "12");
         value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress());
         assertEquals(value, "42");
     }
 
+<<<<<<< HEAD
+=======
+    @Test
+    public void testFilterValueComposite() throws Throwable {
+        ValueLayout layout = MemoryLayouts.JAVA_INT;
+        MemorySegment segment = MemorySegment.allocateNative(layout);
+        VarHandle intHandle = layout.varHandle(int.class);
+        MethodHandle CTX_S2I = MethodHandles.dropArguments(S2I, 0, String.class, String.class);
+        VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, CTX_S2I, CTX_I2S);
+        i2SHandle = MemoryHandles.insertCoordinates(i2SHandle, 1, "a", "b");
+        i2SHandle.set(segment.baseAddress(), "1");
+        String oldValue = (String)i2SHandle.getAndAdd(segment.baseAddress(), "42");
+        assertEquals(oldValue, "ab1");
+        String value = (String)i2SHandle.get(segment.baseAddress());
+        assertEquals(value, "ab43");
+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.baseAddress(), "43", "12");
+        assertTrue(swapped);
+        oldValue = (String)i2SHandle.compareAndExchange(segment.baseAddress(), "12", "42");
+        assertEquals(oldValue, "ab12");
+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress());
+        assertEquals(value, "ab42");
+    }
+
+    @Test
+    public void testFilterValueLoose() throws Throwable {
+        ValueLayout layout = MemoryLayouts.JAVA_INT;
+        MemorySegment segment = MemorySegment.allocateNative(layout);
+        VarHandle intHandle = layout.varHandle(int.class);
+        VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, O2I, I2O);
+        i2SHandle.set(segment.baseAddress(), "1");
+        String oldValue = (String)i2SHandle.getAndAdd(segment.baseAddress(), "42");
+        assertEquals(oldValue, "1");
+        String value = (String)i2SHandle.get(segment.baseAddress());
+        assertEquals(value, "43");
+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.baseAddress(), "43", "12");
+        assertTrue(swapped);
+        oldValue = (String)i2SHandle.compareAndExchange(segment.baseAddress(), "12", "42");
+        assertEquals(oldValue, "12");
+        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress());
+        assertEquals(value, "42");
+    }
+
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadFilterNullTarget() {
         MemoryHandles.filterValue(null, S2I, I2S);
     }
 
@@ -132,10 +188,21 @@
         VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.filterValue(intHandle, S2I, I2S.bindTo(42));
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
+<<<<<<< HEAD
+=======
+    public void testBadFilterBoxPrefixCoordinates() {
+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
+        MemoryHandles.filterValue(intHandle,
+                MethodHandles.dropArguments(S2I, 1, int.class),
+                MethodHandles.dropArguments(I2S, 1, long.class));
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     public void testBadFilterBoxException() {
         VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.filterValue(intHandle, I2S, S2L_EX);
     }
 
@@ -459,6 +526,13 @@
     static long sumOffsets(long l1, long l2) {
         return l1 + l2;
     }
 
     static void void_filter(String s) { }
+<<<<<<< HEAD
+=======
+
+    static String ctxIntToString(String a, String b, int i) {
+        return a + b + String.valueOf(i);
+    }
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 }
diff a/test/jdk/java/foreign/TestByteBuffer.java b/test/jdk/java/foreign/TestByteBuffer.java
--- a/test/jdk/java/foreign/TestByteBuffer.java
+++ b/test/jdk/java/foreign/TestByteBuffer.java
@@ -309,11 +309,11 @@
                 assertTrue(false);
             } catch (InvocationTargetException ex) {
                 Throwable cause = ex.getCause();
                 if (cause instanceof IllegalStateException) {
                     //all get/set buffer operation should fail because of the scope check
-                    assertTrue(ex.getCause().getMessage().contains("not alive"));
+                    assertTrue(ex.getCause().getMessage().contains("already closed"));
                 } else {
                     //all other exceptions were unexpected - fail
                     assertTrue(false);
                 }
             } catch (Throwable ex) {
@@ -346,11 +346,11 @@
                 MethodHandle handle = e.getKey().bindTo(bufferHandle)
                         .asSpreader(Object[].class, e.getValue().length);
                 handle.invoke(e.getValue());
                 fail();
             } catch (IllegalStateException ex) {
-                assertTrue(ex.getMessage().contains("not alive"));
+                assertTrue(ex.getMessage().contains("already closed"));
             } catch (UnsupportedOperationException ex) {
                 //skip
             } catch (Throwable ex) {
                 fail();
             }
@@ -442,11 +442,11 @@
         checkByteArrayAlignment(seq.elementLayout());
         int bytes = (int)seq.byteSize();
         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
             initializer.accept(heapArray.baseAddress());
-            MemoryAddress.copy(heapArray.baseAddress(), nativeArray.baseAddress(), bytes);
+            nativeArray.copyFrom(heapArray);
             checker.accept(nativeArray.baseAddress());
         }
     }
 
     @Test(dataProvider="resizeOps")
@@ -454,15 +454,16 @@
         checkByteArrayAlignment(seq.elementLayout());
         int bytes = (int)seq.byteSize();
         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
             initializer.accept(nativeArray.baseAddress());
-            MemoryAddress.copy(nativeArray.baseAddress(), heapArray.baseAddress(), bytes);
+            heapArray.copyFrom(nativeArray);
             checker.accept(heapArray.baseAddress());
         }
     }
 
+<<<<<<< HEAD
     @Test
     public void testDefaultAccessModesOfBuffer() {
         ByteBuffer rwBuffer = ByteBuffer.wrap(new byte[4]);
         try (MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer)) {
             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES));
@@ -474,10 +475,12 @@
             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES & ~WRITE));
             assertEquals(segment.accessModes(), ALL_ACCESS_MODES & ~WRITE);
         }
     }
 
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     @Test(dataProvider="bufferSources")
     public void testBufferToSegment(ByteBuffer bb, Predicate<MemorySegment> segmentChecker) {
         MemorySegment segment = MemorySegment.ofByteBuffer(bb);
         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
         assertTrue(segmentChecker.test(segment));
diff a/test/jdk/java/foreign/TestLayoutAttributes.java b/test/jdk/java/foreign/TestLayoutAttributes.java
--- a/test/jdk/java/foreign/TestLayoutAttributes.java
+++ b/test/jdk/java/foreign/TestLayoutAttributes.java
@@ -44,19 +44,22 @@
                 .withAttribute("MyAttribute", 10L);
         assertEquals((long) ml.attribute("MyAttribute").orElseThrow(), 10L);
     }
 
     @Test
+<<<<<<< HEAD
     public void testAttributeOverwrite() {
         MemoryLayout ml = MemoryLayouts.BITS_32_LE
                 .withAttribute("MyAttribute", 10L);
         assertEquals((long) ml.attribute("MyAttribute").orElseThrow(), 10L);
         ml = ml.withAttribute("MyAttribute", 11L);
         assertEquals((long) ml.attribute("MyAttribute").orElseThrow(), 11L);
     }
 
     @Test
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     public void testAttributeNonExistent() {
         MemoryLayout ml = MemoryLayouts.BITS_32_LE
                 .withAttribute("MyAttribute", 10L);
         assertTrue(ml.attribute("Foo").isEmpty());
     }
@@ -64,20 +67,28 @@
     @Test
     public void testNameAttribute() {
         MemoryLayout ml = MemoryLayouts.BITS_32_LE
                 .withName("foo");
         assertEquals(ml.name().orElseThrow(), "foo");
+<<<<<<< HEAD
         assertEquals(ml.attribute(MemoryLayout.LAYOUT_NAME).orElseThrow(), "foo");
+=======
+        assertEquals(ml.attribute("name").orElseThrow(), "foo");
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @Test
     public void testAttributesStream() {
         MemoryLayout ml = MemoryLayouts.BITS_32_LE
                 .withName("foo")
                 .withAttribute("MyAttribute", 10L);
         List<String> attribs = ml.attributes().collect(Collectors.toList());
+<<<<<<< HEAD
         assertEquals(attribs.size(), 2);
         assertTrue(attribs.contains("MyAttribute"));
         assertTrue(attribs.contains(MemoryLayout.LAYOUT_NAME));
+=======
+        assertEquals(attribs, List.of("name", "MyAttribute"));
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
 }
diff a/test/jdk/java/foreign/TestNative.java b/test/jdk/java/foreign/TestNative.java
--- a/test/jdk/java/foreign/TestNative.java
+++ b/test/jdk/java/foreign/TestNative.java
@@ -147,11 +147,15 @@
     public static native double getDoubleRaw(long addr, int index);
 
     public static native long getCapacity(Buffer buffer);
 
     public static native long allocate(int size);
+<<<<<<< HEAD
     public static native void free(long address);
+=======
+    public static native long free(long address);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 
     @Test(dataProvider="nativeAccessOps")
     public void testNativeAccess(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
             MemoryAddress address = segment.baseAddress();
@@ -170,10 +174,11 @@
             assertEquals(buf.capacity(), expected);
             assertEquals(getCapacity(buf), expected);
         }
     }
 
+<<<<<<< HEAD
     static final int ALL_ACCESS_MODES = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;
 
     @Test
     public void testDefaultAccessModes() {
         MemoryAddress addr = MemoryAddress.ofLong(allocate(12));
@@ -183,10 +188,12 @@
             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES));
             assertEquals(segment.accessModes(), ALL_ACCESS_MODES);
         }
     }
 
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     @Test
     public void testMallocSegment() {
         MemoryAddress addr = MemoryAddress.ofLong(allocate(12));
         assertNull(addr.segment());
         MemorySegment mallocSegment = MemorySegment.ofNativeRestricted(addr, 12, null,
diff a/test/jdk/java/foreign/TestRebase.java b/test/jdk/java/foreign/TestRebase.java
--- a/test/jdk/java/foreign/TestRebase.java
+++ b/test/jdk/java/foreign/TestRebase.java
@@ -1,7 +1,11 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+=======
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  *  This code is free software; you can redistribute it and/or modify it
  *  under the terms of the GNU General Public License version 2 only, as
  *  published by the Free Software Foundation.
diff a/test/jdk/java/foreign/TestSegments.java b/test/jdk/java/foreign/TestSegments.java
--- a/test/jdk/java/foreign/TestSegments.java
+++ b/test/jdk/java/foreign/TestSegments.java
@@ -30,24 +30,32 @@
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
+<<<<<<< HEAD
 
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 import java.lang.invoke.VarHandle;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Spliterator;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.LongFunction;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
+<<<<<<< HEAD
 import static jdk.incubator.foreign.MemorySegment.*;
+=======
+import static jdk.incubator.foreign.MemorySegment.WRITE;
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 import static org.testng.Assert.*;
 
 public class TestSegments {
 
     @Test(dataProvider = "badSizeAndAlignments", expectedExceptions = IllegalArgumentException.class)
@@ -143,10 +151,11 @@
                 start++;
             }
         }
     }
 
+<<<<<<< HEAD
     static final int ALL_ACCESS_MODES = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;
 
     @DataProvider(name = "segmentFactories")
     public Object[][] segmentFactories() {
         List<Supplier<MemorySegment>> l = List.of(
@@ -170,10 +179,12 @@
             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES));
             assertEquals(segment.accessModes(), ALL_ACCESS_MODES);
         }
     }
 
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     @Test(dataProvider = "accessModes")
     public void testAccessModes(int accessModes) {
         int[] arr = new int[1];
         for (AccessActions action : AccessActions.values()) {
             MemorySegment segment = MemorySegment.ofArray(arr);
@@ -187,10 +198,11 @@
                 assertTrue(shouldFail);
             }
         }
     }
 
+<<<<<<< HEAD
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testWithAccessModesBadUnsupportedMode() {
         int[] arr = new int[1];
         MemorySegment segment = MemorySegment.ofArray(arr);
         segment.withAccessModes((1 << AccessActions.values().length) + 1);
@@ -199,10 +211,104 @@
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadWithAccessModesBadStrongerMode() {
         int[] arr = new int[1];
         MemorySegment segment = MemorySegment.ofArray(arr).withAccessModes(READ);
         segment.withAccessModes(WRITE);
+=======
+    @DataProvider(name = "segmentFactories")
+    public Object[][] segmentFactories() {
+        List<Supplier<MemorySegment>> l = List.of(
+                () -> MemorySegment.ofArray(new byte[] { 0x00, 0x01, 0x02, 0x03 }),
+                () -> MemorySegment.ofArray(new char[] {'a', 'b', 'c', 'd' }),
+                () -> MemorySegment.ofArray(new double[] { 1d, 2d, 3d, 4d} ),
+                () -> MemorySegment.ofArray(new float[] { 1.0f, 2.0f, 3.0f, 4.0f }),
+                () -> MemorySegment.ofArray(new int[] { 1, 2, 3, 4 }),
+                () -> MemorySegment.ofArray(new long[] { 1l, 2l, 3l, 4l } ),
+                () -> MemorySegment.ofArray(new short[] { 1, 2, 3, 4 } ),
+                () -> MemorySegment.allocateNative(4),
+                () -> MemorySegment.allocateNative(4, 8),
+                () -> MemorySegment.allocateNative(MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder()))
+        );
+        return l.stream().map(s -> new Object[] { s }).toArray(Object[][]::new);
+    }
+
+    @Test(dataProvider = "segmentFactories")
+    public void testFill(Supplier<MemorySegment> memorySegmentSupplier) {
+        VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
+                .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
+
+        for (byte value : new byte[] {(byte) 0xFF, (byte) 0x00, (byte) 0x45}) {
+            try (MemorySegment segment = memorySegmentSupplier.get()) {
+                segment.fill(value);
+                for (long l = 0; l < segment.byteSize(); l++) {
+                    assertEquals((byte) byteHandle.get(segment.baseAddress(), l), value);
+                }
+
+                // fill a slice
+                var sliceSegment = segment.asSlice(1, segment.byteSize() - 2).fill((byte) ~value);
+                for (long l = 0; l < sliceSegment.byteSize(); l++) {
+                    assertEquals((byte) byteHandle.get(sliceSegment.baseAddress(), l), ~value);
+                }
+                // assert enclosing slice
+                assertEquals((byte) byteHandle.get(segment.baseAddress(), 0L), value);
+                for (long l = 1; l < segment.byteSize() - 2; l++) {
+                    assertEquals((byte) byteHandle.get(segment.baseAddress(), l), (byte) ~value);
+                }
+                assertEquals((byte) byteHandle.get(segment.baseAddress(), segment.byteSize() - 1L), value);
+            }
+        }
+    }
+
+    @Test(dataProvider = "segmentFactories", expectedExceptions = IllegalStateException.class)
+    public void testFillClosed(Supplier<MemorySegment> memorySegmentSupplier) {
+        MemorySegment segment = memorySegmentSupplier.get();
+        segment.close();
+        segment.fill((byte) 0xFF);
+    }
+
+    @Test(dataProvider = "segmentFactories", expectedExceptions = UnsupportedOperationException.class)
+    public void testFillIllegalAccessMode(Supplier<MemorySegment> memorySegmentSupplier) {
+        try (MemorySegment segment = memorySegmentSupplier.get()) {
+            segment.withAccessModes(segment.accessModes() & ~WRITE).fill((byte) 0xFF);
+        }
+    }
+
+    @Test(dataProvider = "segmentFactories")
+    public void testFillThread(Supplier<MemorySegment> memorySegmentSupplier) throws Exception {
+        try (MemorySegment segment = memorySegmentSupplier.get()) {
+            AtomicReference<RuntimeException> exception = new AtomicReference<>();
+            Runnable action = () -> {
+                try {
+                    segment.fill((byte) 0xBA);
+                } catch (RuntimeException e) {
+                    exception.set(e);
+                }
+            };
+            Thread thread = new Thread(action);
+            thread.start();
+            thread.join();
+
+            RuntimeException e = exception.get();
+            if (!(e instanceof IllegalStateException)) {
+                throw e;
+            }
+        }
+    }
+
+    @Test
+    public void testFillEmpty() {
+        MemorySegment.ofArray(new byte[] { }).fill((byte) 0xFF);
+        MemorySegment.ofArray(new byte[2]).asSlice(0, 0).fill((byte) 0xFF);
+        MemorySegment.ofByteBuffer(ByteBuffer.allocateDirect(0)).fill((byte) 0xFF);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadWithAccessModes() {
+        int[] arr = new int[1];
+        MemorySegment segment = MemorySegment.ofArray(arr);
+        segment.withAccessModes((1 << AccessActions.values().length) + 1);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadHasAccessModes() {
         int[] arr = new int[1];
@@ -265,10 +371,15 @@
         final Method method;
         final Object[] params;
 
         final static List<String> CONFINED_NAMES = List.of(
                 "close",
+<<<<<<< HEAD
+=======
+                "fill",
+                "copyFrom",
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
                 "toByteArray",
                 "withOwnerThread"
         );
 
         public SegmentMember(Method method, Object[] params) {
diff a/test/jdk/java/foreign/TestSpliterator.java b/test/jdk/java/foreign/TestSpliterator.java
--- a/test/jdk/java/foreign/TestSpliterator.java
+++ b/test/jdk/java/foreign/TestSpliterator.java
@@ -2,11 +2,17 @@
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
+<<<<<<< HEAD
  * published by the Free Software Foundation.
+=======
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  *
  * This code is distributed in the hope that it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  * version 2 for more details (a copy is included in the LICENSE file that
@@ -33,22 +39,31 @@
 import jdk.incubator.foreign.SequenceLayout;
 
 import java.lang.invoke.VarHandle;
 import java.util.LinkedList;
 import java.util.List;
+<<<<<<< HEAD
 import java.util.Map;
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 import java.util.Spliterator;
 import java.util.concurrent.CountedCompleter;
 import java.util.concurrent.RecursiveTask;
 import java.util.concurrent.atomic.AtomicLong;
+<<<<<<< HEAD
 import java.util.function.Consumer;
 import java.util.function.Supplier;
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 import java.util.stream.LongStream;
 import java.util.stream.StreamSupport;
 
 import org.testng.annotations.*;
+<<<<<<< HEAD
 import static jdk.incubator.foreign.MemorySegment.*;
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 import static org.testng.Assert.*;
 
 public class TestSpliterator {
 
     static final VarHandle INT_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)
@@ -92,11 +107,15 @@
         }
         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
 
         //check that a segment w/o ACQUIRE access mode can still be used from same thread
         AtomicLong spliteratorSum = new AtomicLong();
+<<<<<<< HEAD
         spliterator(segment.withAccessModes(MemorySegment.READ), layout)
+=======
+        MemorySegment.spliterator(segment.withAccessModes(MemorySegment.READ), layout)
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
                 .forEachRemaining(s -> spliteratorSum.addAndGet(sumSingle(0L, s)));
         assertEquals(spliteratorSum.get(), expected);
     }
 
     static long sumSingle(long acc, MemorySegment segment) {
@@ -202,10 +221,11 @@
                 { 100, 10000 },
                 { 1000, 10000 },
                 { 10000, 10000 },
         };
     }
+<<<<<<< HEAD
 
     static final int ALL_ACCESS_MODES = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;
 
     @DataProvider(name = "accessScenarios")
     public Object[][] accessScenarios() {
@@ -252,6 +272,8 @@
             splitOrConsume(spliterator, consumer);
         } else {
             spliterator.forEachRemaining(consumer);
         }
     }
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 }
diff a/test/jdk/java/foreign/libNativeAccess.c b/test/jdk/java/foreign/libNativeAccess.c
--- a/test/jdk/java/foreign/libNativeAccess.c
+++ b/test/jdk/java/foreign/libNativeAccess.c
@@ -116,12 +116,20 @@
     return (*env)->GetDirectBufferCapacity(env, buf);
 }
 
 JNIEXPORT jlong JNICALL
 Java_TestNative_allocate(JNIEnv *env, jclass cls, jint size) {
+<<<<<<< HEAD
     return (jlong)(uintptr_t)malloc(size);
+=======
+    return (jlong)malloc(size);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 }
 
 JNIEXPORT void JNICALL
 Java_TestNative_free(JNIEnv *env, jclass cls, jlong ptr) {
+<<<<<<< HEAD
     free((void*)(uintptr_t)ptr);
+=======
+    free((void*) ptr);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 }
diff a/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java b/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java
--- a/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java
+++ b/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java
@@ -2,11 +2,17 @@
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
+<<<<<<< HEAD
  * published by the Free Software Foundation.
+=======
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  *
  * This code is distributed in the hope that it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  * version 2 for more details (a copy is included in the LICENSE file that
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
@@ -1,6 +1,7 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -18,10 +19,37 @@
  *
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
+=======
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 package org.openjdk.bench.jdk.incubator.foreign;
 
 import jdk.incubator.foreign.MemoryLayout;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
@@ -1,7 +1,8 @@
 /*
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+<<<<<<< HEAD
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -17,10 +18,32 @@
  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
+=======
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  */
 package org.openjdk.bench.jdk.incubator.foreign;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
@@ -1,7 +1,11 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+=======
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
@@ -1,7 +1,11 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+=======
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
@@ -1,7 +1,11 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+=======
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
@@ -1,6 +1,7 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -17,10 +18,35 @@
  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
+=======
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  */
 
 package org.openjdk.bench.jdk.incubator.foreign;
 
 import jdk.incubator.foreign.MemoryLayout;
@@ -137,11 +163,15 @@
         return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), true)
                 .mapToInt(SEGMENT_TO_INT_BULK).sum();
     }
 
     final static ToIntFunction<MemorySegment> SEGMENT_TO_INT = slice ->
+<<<<<<< HEAD
             (int) VH_int.get(slice.baseAddress(), 0L);
+=======
+        (int) VH_int.get(slice.baseAddress(), 0L);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 
     final static ToIntFunction<MemorySegment> SEGMENT_TO_INT_BULK = slice -> {
         int res = 0;
         MemoryAddress base = slice.baseAddress();
         for (int i = 0; i < BULK_FACTOR ; i++) {
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/Utils.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/Utils.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/Utils.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/Utils.java
@@ -1,6 +1,7 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -18,10 +19,37 @@
  *
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
+=======
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 package org.openjdk.bench.jdk.incubator.foreign;
 
 import sun.misc.Unsafe;
 
 import java.lang.reflect.Field;
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/PointsAccess.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/PointsAccess.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/PointsAccess.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/PointsAccess.java
@@ -1,7 +1,11 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+=======
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/PointsAlloc.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/PointsAlloc.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/PointsAlloc.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/PointsAlloc.java
@@ -1,7 +1,11 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+=======
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/PointsFree.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/PointsFree.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/PointsFree.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/PointsFree.java
@@ -1,7 +1,11 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+=======
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/BBPoint.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/BBPoint.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/BBPoint.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/BBPoint.java
@@ -1,7 +1,11 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+=======
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/JNIPoint.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/JNIPoint.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/JNIPoint.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/JNIPoint.java
@@ -1,7 +1,11 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+=======
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
@@ -1,7 +1,11 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+=======
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/libJNIPoint.c b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/libJNIPoint.c
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/libJNIPoint.c
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/libJNIPoint.c
@@ -1,7 +1,11 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+=======
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/points.h b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/points.h
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/points.h
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/points.h
@@ -1,7 +1,11 @@
 /*
+<<<<<<< HEAD
  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+=======
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.

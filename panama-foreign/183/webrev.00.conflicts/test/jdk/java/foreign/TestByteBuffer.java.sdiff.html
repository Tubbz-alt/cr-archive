<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/TestByteBuffer.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="TestAdaptVarHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestLayoutAttributes.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/TestByteBuffer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
294     public void testScopedBuffer(Function&lt;ByteBuffer, Buffer&gt; bufferFactory, Map&lt;Method, Object[]&gt; members) {
295         Buffer bb;
296         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
297             MemoryAddress base = segment.baseAddress();
298             bb = bufferFactory.apply(segment.asByteBuffer());
299         }
300         //outside of scope!!
301         for (Map.Entry&lt;Method, Object[]&gt; e : members.entrySet()) {
302             if (!e.getKey().getName().contains(&quot;get&quot;) &amp;&amp;
303                             !e.getKey().getName().contains(&quot;put&quot;)) {
304                 //skip
305                 return;
306             }
307             try {
308                 e.getKey().invoke(bb, e.getValue());
309                 assertTrue(false);
310             } catch (InvocationTargetException ex) {
311                 Throwable cause = ex.getCause();
312                 if (cause instanceof IllegalStateException) {
313                     //all get/set buffer operation should fail because of the scope check
<span class="line-modified">314                     assertTrue(ex.getCause().getMessage().contains(&quot;not alive&quot;));</span>
315                 } else {
316                     //all other exceptions were unexpected - fail
317                     assertTrue(false);
318                 }
319             } catch (Throwable ex) {
320                 //unexpected exception - fail
321                 assertTrue(false);
322             }
323         }
324     }
325 
326     @Test(dataProvider = &quot;bufferHandleOps&quot;)
327     public void testScopedBufferAndVarHandle(VarHandle bufferHandle) {
328         ByteBuffer bb;
329         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
330             bb = segment.asByteBuffer();
331             for (Map.Entry&lt;MethodHandle, Object[]&gt; e : varHandleMembers(bb, bufferHandle).entrySet()) {
332                 MethodHandle handle = e.getKey().bindTo(bufferHandle)
333                         .asSpreader(Object[].class, e.getValue().length);
334                 try {
335                     handle.invoke(e.getValue());
336                 } catch (UnsupportedOperationException ex) {
337                     //skip
338                 } catch (Throwable ex) {
339                     //should not fail - segment is alive!
340                     fail();
341                 }
342             }
343         }
344         for (Map.Entry&lt;MethodHandle, Object[]&gt; e : varHandleMembers(bb, bufferHandle).entrySet()) {
345             try {
346                 MethodHandle handle = e.getKey().bindTo(bufferHandle)
347                         .asSpreader(Object[].class, e.getValue().length);
348                 handle.invoke(e.getValue());
349                 fail();
350             } catch (IllegalStateException ex) {
<span class="line-modified">351                 assertTrue(ex.getMessage().contains(&quot;not alive&quot;));</span>
352             } catch (UnsupportedOperationException ex) {
353                 //skip
354             } catch (Throwable ex) {
355                 fail();
356             }
357         }
358     }
359 
360     @Test(dataProvider = &quot;bufferOps&quot;)
361     public void testDirectBuffer(Function&lt;ByteBuffer, Buffer&gt; bufferFactory, Map&lt;Method, Object[]&gt; members) {
362         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
363             MemoryAddress base = segment.baseAddress();
364             Buffer bb = bufferFactory.apply(segment.asByteBuffer());
365             assertTrue(bb.isDirect());
366             DirectBuffer directBuffer = ((DirectBuffer)bb);
367             assertEquals(directBuffer.address(), ((MemoryAddressImpl)base).unsafeGetOffset());
368             assertTrue((directBuffer.attachment() == null) == (bb instanceof ByteBuffer));
369             assertTrue(directBuffer.cleaner() == null);
370         }
371     }
</pre>
<hr />
<pre>
427         }
428         ByteBuffer byteBuffer = leaked.asByteBuffer(); // ok
429         byteBuffer.get(); // should throw
430     }
431 
432     @Test(expectedExceptions = { UnsupportedOperationException.class,
433                                  IllegalArgumentException.class })
434     public void testTooBigForByteBuffer() {
435         try (MemorySegment segment = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L)) {
436             segment.asByteBuffer();
437         }
438     }
439 
440     @Test(dataProvider=&quot;resizeOps&quot;)
441     public void testCopyHeapToNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
442         checkByteArrayAlignment(seq.elementLayout());
443         int bytes = (int)seq.byteSize();
444         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
445              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
446             initializer.accept(heapArray.baseAddress());
<span class="line-modified">447             MemoryAddress.copy(heapArray.baseAddress(), nativeArray.baseAddress(), bytes);</span>
448             checker.accept(nativeArray.baseAddress());
449         }
450     }
451 
452     @Test(dataProvider=&quot;resizeOps&quot;)
453     public void testCopyNativeToHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
454         checkByteArrayAlignment(seq.elementLayout());
455         int bytes = (int)seq.byteSize();
456         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
457              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
458             initializer.accept(nativeArray.baseAddress());
<span class="line-modified">459             MemoryAddress.copy(nativeArray.baseAddress(), heapArray.baseAddress(), bytes);</span>
460             checker.accept(heapArray.baseAddress());
461         }
462     }
463 

464     @Test
465     public void testDefaultAccessModesOfBuffer() {
466         ByteBuffer rwBuffer = ByteBuffer.wrap(new byte[4]);
467         try (MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer)) {
468             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES));
469             assertEquals(segment.accessModes(), ALL_ACCESS_MODES);
470         }
471 
472         ByteBuffer roBuffer = rwBuffer.asReadOnlyBuffer();
473         try (MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer)) {
474             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES &amp; ~WRITE));
475             assertEquals(segment.accessModes(), ALL_ACCESS_MODES &amp; ~WRITE);
476         }
477     }
478 


479     @Test(dataProvider=&quot;bufferSources&quot;)
480     public void testBufferToSegment(ByteBuffer bb, Predicate&lt;MemorySegment&gt; segmentChecker) {
481         MemorySegment segment = MemorySegment.ofByteBuffer(bb);
482         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
483         assertTrue(segmentChecker.test(segment));
484         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
485         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
486         assertEquals(bb.capacity(), segment.byteSize());
487         //another round trip
488         segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());
489         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
490         assertTrue(segmentChecker.test(segment));
491         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
492         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
493         assertEquals(bb.capacity(), segment.byteSize());
494     }
495 
496     @Test
497     public void testRoundTripAccess() {
498         try(MemorySegment ms = MemorySegment.allocateNative(4)) {
</pre>
</td>
<td>
<hr />
<pre>
294     public void testScopedBuffer(Function&lt;ByteBuffer, Buffer&gt; bufferFactory, Map&lt;Method, Object[]&gt; members) {
295         Buffer bb;
296         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
297             MemoryAddress base = segment.baseAddress();
298             bb = bufferFactory.apply(segment.asByteBuffer());
299         }
300         //outside of scope!!
301         for (Map.Entry&lt;Method, Object[]&gt; e : members.entrySet()) {
302             if (!e.getKey().getName().contains(&quot;get&quot;) &amp;&amp;
303                             !e.getKey().getName().contains(&quot;put&quot;)) {
304                 //skip
305                 return;
306             }
307             try {
308                 e.getKey().invoke(bb, e.getValue());
309                 assertTrue(false);
310             } catch (InvocationTargetException ex) {
311                 Throwable cause = ex.getCause();
312                 if (cause instanceof IllegalStateException) {
313                     //all get/set buffer operation should fail because of the scope check
<span class="line-modified">314                     assertTrue(ex.getCause().getMessage().contains(&quot;already closed&quot;));</span>
315                 } else {
316                     //all other exceptions were unexpected - fail
317                     assertTrue(false);
318                 }
319             } catch (Throwable ex) {
320                 //unexpected exception - fail
321                 assertTrue(false);
322             }
323         }
324     }
325 
326     @Test(dataProvider = &quot;bufferHandleOps&quot;)
327     public void testScopedBufferAndVarHandle(VarHandle bufferHandle) {
328         ByteBuffer bb;
329         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
330             bb = segment.asByteBuffer();
331             for (Map.Entry&lt;MethodHandle, Object[]&gt; e : varHandleMembers(bb, bufferHandle).entrySet()) {
332                 MethodHandle handle = e.getKey().bindTo(bufferHandle)
333                         .asSpreader(Object[].class, e.getValue().length);
334                 try {
335                     handle.invoke(e.getValue());
336                 } catch (UnsupportedOperationException ex) {
337                     //skip
338                 } catch (Throwable ex) {
339                     //should not fail - segment is alive!
340                     fail();
341                 }
342             }
343         }
344         for (Map.Entry&lt;MethodHandle, Object[]&gt; e : varHandleMembers(bb, bufferHandle).entrySet()) {
345             try {
346                 MethodHandle handle = e.getKey().bindTo(bufferHandle)
347                         .asSpreader(Object[].class, e.getValue().length);
348                 handle.invoke(e.getValue());
349                 fail();
350             } catch (IllegalStateException ex) {
<span class="line-modified">351                 assertTrue(ex.getMessage().contains(&quot;already closed&quot;));</span>
352             } catch (UnsupportedOperationException ex) {
353                 //skip
354             } catch (Throwable ex) {
355                 fail();
356             }
357         }
358     }
359 
360     @Test(dataProvider = &quot;bufferOps&quot;)
361     public void testDirectBuffer(Function&lt;ByteBuffer, Buffer&gt; bufferFactory, Map&lt;Method, Object[]&gt; members) {
362         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
363             MemoryAddress base = segment.baseAddress();
364             Buffer bb = bufferFactory.apply(segment.asByteBuffer());
365             assertTrue(bb.isDirect());
366             DirectBuffer directBuffer = ((DirectBuffer)bb);
367             assertEquals(directBuffer.address(), ((MemoryAddressImpl)base).unsafeGetOffset());
368             assertTrue((directBuffer.attachment() == null) == (bb instanceof ByteBuffer));
369             assertTrue(directBuffer.cleaner() == null);
370         }
371     }
</pre>
<hr />
<pre>
427         }
428         ByteBuffer byteBuffer = leaked.asByteBuffer(); // ok
429         byteBuffer.get(); // should throw
430     }
431 
432     @Test(expectedExceptions = { UnsupportedOperationException.class,
433                                  IllegalArgumentException.class })
434     public void testTooBigForByteBuffer() {
435         try (MemorySegment segment = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L)) {
436             segment.asByteBuffer();
437         }
438     }
439 
440     @Test(dataProvider=&quot;resizeOps&quot;)
441     public void testCopyHeapToNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
442         checkByteArrayAlignment(seq.elementLayout());
443         int bytes = (int)seq.byteSize();
444         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
445              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
446             initializer.accept(heapArray.baseAddress());
<span class="line-modified">447             nativeArray.copyFrom(heapArray);</span>
448             checker.accept(nativeArray.baseAddress());
449         }
450     }
451 
452     @Test(dataProvider=&quot;resizeOps&quot;)
453     public void testCopyNativeToHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
454         checkByteArrayAlignment(seq.elementLayout());
455         int bytes = (int)seq.byteSize();
456         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
457              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
458             initializer.accept(nativeArray.baseAddress());
<span class="line-modified">459             heapArray.copyFrom(nativeArray);</span>
460             checker.accept(heapArray.baseAddress());
461         }
462     }
463 
<span class="line-added">464 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
465     @Test
466     public void testDefaultAccessModesOfBuffer() {
467         ByteBuffer rwBuffer = ByteBuffer.wrap(new byte[4]);
468         try (MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer)) {
469             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES));
470             assertEquals(segment.accessModes(), ALL_ACCESS_MODES);
471         }
472 
473         ByteBuffer roBuffer = rwBuffer.asReadOnlyBuffer();
474         try (MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer)) {
475             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES &amp; ~WRITE));
476             assertEquals(segment.accessModes(), ALL_ACCESS_MODES &amp; ~WRITE);
477         }
478     }
479 
<span class="line-added">480 =======</span>
<span class="line-added">481 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
482     @Test(dataProvider=&quot;bufferSources&quot;)
483     public void testBufferToSegment(ByteBuffer bb, Predicate&lt;MemorySegment&gt; segmentChecker) {
484         MemorySegment segment = MemorySegment.ofByteBuffer(bb);
485         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
486         assertTrue(segmentChecker.test(segment));
487         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
488         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
489         assertEquals(bb.capacity(), segment.byteSize());
490         //another round trip
491         segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());
492         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
493         assertTrue(segmentChecker.test(segment));
494         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
495         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
496         assertEquals(bb.capacity(), segment.byteSize());
497     }
498 
499     @Test
500     public void testRoundTripAccess() {
501         try(MemorySegment ms = MemorySegment.allocateNative(4)) {
</pre>
</td>
</tr>
</table>
<center><a href="TestAdaptVarHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestLayoutAttributes.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/test/jdk/java/foreign/TestByteBuffer.java b/test/jdk/java/foreign/TestByteBuffer.java
--- a/test/jdk/java/foreign/TestByteBuffer.java
+++ b/test/jdk/java/foreign/TestByteBuffer.java
@@ -309,11 +309,11 @@
                 assertTrue(false);
             } catch (InvocationTargetException ex) {
                 Throwable cause = ex.getCause();
                 if (cause instanceof IllegalStateException) {
                     //all get/set buffer operation should fail because of the scope check
-                    assertTrue(ex.getCause().getMessage().contains("not alive"));
+                    assertTrue(ex.getCause().getMessage().contains("already closed"));
                 } else {
                     //all other exceptions were unexpected - fail
                     assertTrue(false);
                 }
             } catch (Throwable ex) {
@@ -346,11 +346,11 @@
                 MethodHandle handle = e.getKey().bindTo(bufferHandle)
                         .asSpreader(Object[].class, e.getValue().length);
                 handle.invoke(e.getValue());
                 fail();
             } catch (IllegalStateException ex) {
-                assertTrue(ex.getMessage().contains("not alive"));
+                assertTrue(ex.getMessage().contains("already closed"));
             } catch (UnsupportedOperationException ex) {
                 //skip
             } catch (Throwable ex) {
                 fail();
             }
@@ -442,11 +442,11 @@
         checkByteArrayAlignment(seq.elementLayout());
         int bytes = (int)seq.byteSize();
         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
             initializer.accept(heapArray.baseAddress());
-            MemoryAddress.copy(heapArray.baseAddress(), nativeArray.baseAddress(), bytes);
+            nativeArray.copyFrom(heapArray);
             checker.accept(nativeArray.baseAddress());
         }
     }
 
     @Test(dataProvider="resizeOps")
@@ -454,15 +454,16 @@
         checkByteArrayAlignment(seq.elementLayout());
         int bytes = (int)seq.byteSize();
         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
             initializer.accept(nativeArray.baseAddress());
-            MemoryAddress.copy(nativeArray.baseAddress(), heapArray.baseAddress(), bytes);
+            heapArray.copyFrom(nativeArray);
             checker.accept(heapArray.baseAddress());
         }
     }
 
+<<<<<<< HEAD
     @Test
     public void testDefaultAccessModesOfBuffer() {
         ByteBuffer rwBuffer = ByteBuffer.wrap(new byte[4]);
         try (MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer)) {
             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES));
@@ -474,10 +475,12 @@
             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES & ~WRITE));
             assertEquals(segment.accessModes(), ALL_ACCESS_MODES & ~WRITE);
         }
     }
 
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     @Test(dataProvider="bufferSources")
     public void testBufferToSegment(ByteBuffer bb, Predicate<MemorySegment> segmentChecker) {
         MemorySegment segment = MemorySegment.ofByteBuffer(bb);
         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
         assertTrue(segmentChecker.test(segment));

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../incubator/foreign/SequenceLayout.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HeapMemorySegmentImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,16 ***</span>
<span class="line-new-header">--- 24,26 ---</span>
   */
  
  package jdk.internal.foreign;
  
  import jdk.incubator.foreign.MemoryAddress;
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
<span class="line-added">+ =======</span>
<span class="line-added">+ import jdk.incubator.foreign.MemoryLayout;</span>
<span class="line-added">+ import jdk.incubator.foreign.MemoryLayouts;</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
  import jdk.incubator.foreign.MemorySegment;
  import jdk.incubator.foreign.SequenceLayout;
  import jdk.internal.access.JavaNioAccess;
  import jdk.internal.access.SharedSecrets;
  import jdk.internal.access.foreign.MemorySegmentProxy;
  import jdk.internal.access.foreign.UnmapperProxy;
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
<span class="line-added">+ =======</span>
<span class="line-added">+ import jdk.internal.misc.Unsafe;</span>
<span class="line-added">+ import jdk.internal.util.ArraysSupport;</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
  import jdk.internal.vm.annotation.ForceInline;
  import sun.security.action.GetPropertyAction;
  
  import java.lang.invoke.VarHandle;
  import java.nio.ByteBuffer;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 53,10 ***</span>
<span class="line-new-header">--- 63,15 ---</span>
   * are defined for each memory segment kind, see {@link NativeMemorySegmentImpl}, {@link HeapMemorySegmentImpl} and
   * {@link MappedMemorySegmentImpl}.
   */
  public abstract class AbstractMemorySegmentImpl implements MemorySegment, MemorySegmentProxy {
  
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
<span class="line-added">+ =======</span>
<span class="line-added">+     private static final Unsafe UNSAFE = Unsafe.getUnsafe();</span>
<span class="line-added">+ </span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
      private static final boolean enableSmallSegments =
              Boolean.parseBoolean(GetPropertyAction.privilegedGetProperty(&quot;jdk.incubator.foreign.SmallSegments&quot;, &quot;true&quot;));
  
      final static int ACCESS_MASK = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;
      final static int FIRST_RESERVED_FLAG = 1 &lt;&lt; 16; // upper 16 bits are reserved
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,26 ***</span>
<span class="line-new-header">--- 81,39 ---</span>
  
      final static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
  
      final long length;
      final int mask;
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
      final Thread owner;
      final MemoryScope scope;
  
      @ForceInline
      AbstractMemorySegmentImpl(long length, int mask, Thread owner, MemoryScope scope) {
          this.length = length;
          this.mask = mask;
          this.owner = owner;
<span class="line-added">+ =======</span>
<span class="line-added">+     final MemoryScope scope;</span>
<span class="line-added">+ </span>
<span class="line-added">+     @ForceInline</span>
<span class="line-added">+     AbstractMemorySegmentImpl(long length, int mask, MemoryScope scope) {</span>
<span class="line-added">+         this.length = length;</span>
<span class="line-added">+         this.mask = mask;</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
          this.scope = scope;
      }
  
      abstract long min();
  
      abstract Object base();
  
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
      abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope);
<span class="line-added">+ =======</span>
<span class="line-added">+     abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope);</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
  
      abstract ByteBuffer makeByteBuffer();
  
      static int defaultAccessModes(long size) {
          return (enableSmallSegments &amp;&amp; size &lt; Integer.MAX_VALUE) ?
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,11 ***</span>
<span class="line-new-header">--- 126,15 ---</span>
          checkBounds(offset, newSize);
          return asSliceNoCheck(offset, newSize);
      }
  
      private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
          return dup(offset, newSize, mask, owner, scope);
<span class="line-added">+ =======</span>
<span class="line-added">+         return dup(offset, newSize, mask, scope);</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
      }
  
      @SuppressWarnings(&quot;unchecked&quot;)
      public static &lt;S extends MemorySegment&gt; Spliterator&lt;S&gt; spliterator(S segment, SequenceLayout sequenceLayout) {
          ((AbstractMemorySegmentImpl)segment).checkValidState();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,10 ***</span>
<span class="line-new-header">--- 144,66 ---</span>
          return (Spliterator&lt;S&gt;)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
                  (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() &amp; ~CLOSE));
      }
  
      @Override
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
<span class="line-added">+ =======</span>
<span class="line-added">+     public final MemorySegment fill(byte value){</span>
<span class="line-added">+         checkRange(0, length, true);</span>
<span class="line-added">+         UNSAFE.setMemory(base(), min(), length, value);</span>
<span class="line-added">+         return this;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public void copyFrom(MemorySegment src) {</span>
<span class="line-added">+         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;</span>
<span class="line-added">+         long size = that.byteSize();</span>
<span class="line-added">+         checkRange(0, size, true);</span>
<span class="line-added">+         that.checkRange(0, size, false);</span>
<span class="line-added">+         UNSAFE.copyMemory(</span>
<span class="line-added">+                 that.base(), that.min(),</span>
<span class="line-added">+                 base(), min(), size);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private final static VarHandle BYTE_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)</span>
<span class="line-added">+             .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public long mismatch(MemorySegment other) {</span>
<span class="line-added">+         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;</span>
<span class="line-added">+         final long thisSize = this.byteSize();</span>
<span class="line-added">+         final long thatSize = that.byteSize();</span>
<span class="line-added">+         final long length = Math.min(thisSize, thatSize);</span>
<span class="line-added">+         this.checkRange(0, length, false);</span>
<span class="line-added">+         that.checkRange(0, length, false);</span>
<span class="line-added">+         if (this == other) {</span>
<span class="line-added">+             return -1;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         long i = 0;</span>
<span class="line-added">+         if (length &gt; 7) {</span>
<span class="line-added">+             i = ArraysSupport.vectorizedMismatchLarge(</span>
<span class="line-added">+                     this.base(), this.min(),</span>
<span class="line-added">+                     that.base(), that.min(),</span>
<span class="line-added">+                     length, ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE);</span>
<span class="line-added">+             if (i &gt;= 0) {</span>
<span class="line-added">+                 return i;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             i = length - ~i;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         MemoryAddress thisAddress = this.baseAddress();</span>
<span class="line-added">+         MemoryAddress thatAddress = that.baseAddress();</span>
<span class="line-added">+         for (; i &lt; length; i++) {</span>
<span class="line-added">+             if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {</span>
<span class="line-added">+                 return i;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return thisSize != thatSize ? length : -1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
      @ForceInline
      public final MemoryAddress baseAddress() {
          return new MemoryAddressImpl(this, 0);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,25 ***</span>
<span class="line-new-header">--- 231,39 ---</span>
          return length;
      }
  
      @Override
      public final boolean isAlive() {
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
          return scope.isAliveThreadSafe();
<span class="line-added">+ =======</span>
<span class="line-added">+         return scope.isAlive();</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
      }
  
      @Override
      public Thread ownerThread() {
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
          return owner;
<span class="line-added">+ =======</span>
<span class="line-added">+         return scope.ownerThread();</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
      }
  
      @Override
      public AbstractMemorySegmentImpl withAccessModes(int accessModes) {
          checkAccessModes(accessModes);
          if ((~accessModes() &amp; accessModes) != 0) {
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
              throw new IllegalArgumentException(&quot;Cannot acquire more access modes&quot;);
          }
          return dup(0, length, (mask &amp; ~ACCESS_MASK) | accessModes, owner, scope);
<span class="line-added">+ =======</span>
<span class="line-added">+             throw new UnsupportedOperationException(&quot;Cannot acquire more access modes&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return dup(0, length, (mask &amp; ~ACCESS_MASK) | accessModes, scope);</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
      }
  
      @Override
      public boolean hasAccessModes(int accessModes) {
          checkAccessModes(accessModes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 175,10 ***</span>
<span class="line-new-header">--- 277,11 ---</span>
      }
  
      @Override
      public MemorySegment withOwnerThread(Thread newOwner) {
          Objects.requireNonNull(newOwner);
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
          checkValidState();
          if (!isSet(HANDOFF)) {
              throw unsupportedAccessMode(HANDOFF);
          }
          if (owner == newOwner) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 186,64 ***</span>
<span class="line-new-header">--- 289,99 ---</span>
          } else {
              try {
                  return dup(0L, length, mask, newOwner, scope.dup());
              } finally {
                  //flush read/writes to memory before returning the new segment
<span class="line-added">+ =======</span>
<span class="line-added">+         if (!isSet(HANDOFF)) {</span>
<span class="line-added">+             throw unsupportedAccessMode(HANDOFF);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (scope.ownerThread() == newOwner) {</span>
<span class="line-added">+             throw new IllegalArgumentException(&quot;Segment already owned by thread: &quot; + newOwner);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 return dup(0L, length, mask, scope.dup(newOwner));</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 //flush read/writes to segment memory before returning the new segment</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
                  VarHandle.fullFence();
              }
          }
      }
  
      @Override
      public final void close() {
          if (!isSet(CLOSE)) {
              throw unsupportedAccessMode(CLOSE);
          }
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
          checkValidState();
<span class="line-added">+ =======</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
          closeNoCheck();
      }
  
      private final void closeNoCheck() {
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
          scope.close(true);
<span class="line-added">+ =======</span>
<span class="line-added">+         scope.close();</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
      }
  
      final AbstractMemorySegmentImpl acquire() {
          if (Thread.currentThread() != ownerThread() &amp;&amp; !isSet(ACQUIRE)) {
              throw unsupportedAccessMode(ACQUIRE);
          }
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
          return dup(0, length, mask, Thread.currentThread(), scope.acquire());
<span class="line-added">+ =======</span>
<span class="line-added">+         return dup(0, length, mask, scope.acquire());</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
      }
  
      @Override
      public final byte[] toByteArray() {
          checkIntSize(&quot;byte[]&quot;);
          byte[] arr = new byte[(int)length];
          MemorySegment arrSegment = MemorySegment.ofArray(arr);
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
          MemoryAddress.copy(baseAddress(), arrSegment.baseAddress(), length);
<span class="line-added">+ =======</span>
<span class="line-added">+         arrSegment.copyFrom(this);</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
          return arr;
      }
  
      boolean isSmall() {
          return isSet(SMALL);
      }
  
      void checkRange(long offset, long length, boolean writeAccess) {
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
          checkValidState();
<span class="line-added">+ =======</span>
<span class="line-added">+         scope.checkValidState();</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
          if (writeAccess &amp;&amp; !isSet(WRITE)) {
              throw unsupportedAccessMode(WRITE);
          } else if (!writeAccess &amp;&amp; !isSet(READ)) {
              throw unsupportedAccessMode(READ);
          }
          checkBounds(offset, length);
      }
  
      @Override
      public final void checkValidState() {
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
          if (owner != null &amp;&amp; owner != Thread.currentThread()) {
              throw new IllegalStateException(&quot;Attempt to access segment outside owning thread&quot;);
          }
          scope.checkAliveConfined();
<span class="line-added">+ =======</span>
<span class="line-added">+         scope.checkValidState();</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
      }
  
      // Helper methods
  
      private boolean isSet(int mask) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 413,33 ***</span>
<span class="line-new-header">--- 551,56 ---</span>
          int size = limit - pos;
  
          AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl)nioAccess.bufferSegment(bb);
          final MemoryScope bufferScope;
          int modes;
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
          final Thread owner;
          if (bufferSegment != null) {
              bufferScope = bufferSegment.scope;
              modes = bufferSegment.mask;
              owner = bufferSegment.owner;
          } else {
              bufferScope = new MemoryScope(bb, null);
              modes = defaultAccessModes(size);
              owner = Thread.currentThread();
<span class="line-added">+ =======</span>
<span class="line-added">+         if (bufferSegment != null) {</span>
<span class="line-added">+             bufferScope = bufferSegment.scope;</span>
<span class="line-added">+             modes = bufferSegment.mask;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             bufferScope = MemoryScope.create(bb, null);</span>
<span class="line-added">+             modes = defaultAccessModes(size);</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
          }
          if (bb.isReadOnly()) {
              modes &amp;= ~WRITE;
          }
          if (base != null) {
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
              return new HeapMemorySegmentImpl&lt;&gt;(bbAddress + pos, () -&gt; (byte[])base, size, modes, owner, bufferScope);
          } else if (unmapper == null) {
              return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, owner, bufferScope);
          } else {
              return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, owner, bufferScope);
          }
      }
  
      public static AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(0, 0, null, MemoryScope.GLOBAL) {
<span class="line-added">+ =======</span>
<span class="line-added">+             return new HeapMemorySegmentImpl&lt;&gt;(bbAddress + pos, () -&gt; (byte[])base, size, modes, bufferScope);</span>
<span class="line-added">+         } else if (unmapper == null) {</span>
<span class="line-added">+             return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, bufferScope);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, bufferScope);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public static final AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(</span>
<span class="line-added">+         0, 0, MemoryScope.createUnchecked(null, null, null)</span>
<span class="line-added">+     ) {</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
          @Override
          ByteBuffer makeByteBuffer() {
              throw new UnsupportedOperationException();
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 452,10 ***</span>
<span class="line-new-header">--- 613,14 ---</span>
          Object base() {
              return null;
          }
  
          @Override
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
          AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
<span class="line-added">+ =======</span>
<span class="line-added">+         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
              throw new UnsupportedOperationException();
          }
      };
  }
</pre>
<center><a href="../../incubator/foreign/SequenceLayout.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HeapMemorySegmentImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
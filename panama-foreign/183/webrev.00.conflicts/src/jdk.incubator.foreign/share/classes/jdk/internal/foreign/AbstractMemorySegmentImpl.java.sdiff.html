<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../incubator/foreign/SequenceLayout.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HeapMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.foreign;
 27 
 28 import jdk.incubator.foreign.MemoryAddress;





 29 import jdk.incubator.foreign.MemorySegment;
 30 import jdk.incubator.foreign.SequenceLayout;
 31 import jdk.internal.access.JavaNioAccess;
 32 import jdk.internal.access.SharedSecrets;
 33 import jdk.internal.access.foreign.MemorySegmentProxy;
 34 import jdk.internal.access.foreign.UnmapperProxy;





 35 import jdk.internal.vm.annotation.ForceInline;
 36 import sun.security.action.GetPropertyAction;
 37 
 38 import java.lang.invoke.VarHandle;
 39 import java.nio.ByteBuffer;
 40 import java.util.ArrayList;
 41 import java.util.List;
 42 import java.util.Objects;
 43 import java.util.Random;
 44 import java.util.Spliterator;
 45 import java.util.function.Consumer;
 46 
 47 /**
 48  * This abstract class provides an immutable implementation for the {@code MemorySegment} interface. This class contains information
 49  * about the segment&#39;s spatial and temporal bounds; each memory segment implementation is associated with an owner thread which is set at creation time.
 50  * Access to certain sensitive operations on the memory segment will fail with {@code IllegalStateException} if the
 51  * segment is either in an invalid state (e.g. it has already been closed) or if access occurs from a thread other
 52  * than the owner thread. See {@link MemoryScope} for more details on management of temporal bounds. Subclasses
 53  * are defined for each memory segment kind, see {@link NativeMemorySegmentImpl}, {@link HeapMemorySegmentImpl} and
 54  * {@link MappedMemorySegmentImpl}.
 55  */
 56 public abstract class AbstractMemorySegmentImpl implements MemorySegment, MemorySegmentProxy {
 57 





 58     private static final boolean enableSmallSegments =
 59             Boolean.parseBoolean(GetPropertyAction.privilegedGetProperty(&quot;jdk.incubator.foreign.SmallSegments&quot;, &quot;true&quot;));
 60 
 61     final static int ACCESS_MASK = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;
 62     final static int FIRST_RESERVED_FLAG = 1 &lt;&lt; 16; // upper 16 bits are reserved
 63     final static int SMALL = FIRST_RESERVED_FLAG;
 64     final static long NONCE = new Random().nextLong();
 65     final static int DEFAULT_MASK = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;
 66 
 67     final static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
 68 
 69     final long length;
 70     final int mask;

 71     final Thread owner;
 72     final MemoryScope scope;
 73 
 74     @ForceInline
 75     AbstractMemorySegmentImpl(long length, int mask, Thread owner, MemoryScope scope) {
 76         this.length = length;
 77         this.mask = mask;
 78         this.owner = owner;








 79         this.scope = scope;
 80     }
 81 
 82     abstract long min();
 83 
 84     abstract Object base();
 85 

 86     abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope);



 87 
 88     abstract ByteBuffer makeByteBuffer();
 89 
 90     static int defaultAccessModes(long size) {
 91         return (enableSmallSegments &amp;&amp; size &lt; Integer.MAX_VALUE) ?
 92                 DEFAULT_MASK | SMALL :
 93                 DEFAULT_MASK;
 94     }
 95 
 96     @Override
 97     public AbstractMemorySegmentImpl asSlice(long offset, long newSize) {
 98         checkBounds(offset, newSize);
 99         return asSliceNoCheck(offset, newSize);
100     }
101 
102     private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {

103         return dup(offset, newSize, mask, owner, scope);



104     }
105 
106     @SuppressWarnings(&quot;unchecked&quot;)
107     public static &lt;S extends MemorySegment&gt; Spliterator&lt;S&gt; spliterator(S segment, SequenceLayout sequenceLayout) {
108         ((AbstractMemorySegmentImpl)segment).checkValidState();
109         if (sequenceLayout.byteSize() != segment.byteSize()) {
110             throw new IllegalArgumentException();
111         }
112         return (Spliterator&lt;S&gt;)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
113                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() &amp; ~CLOSE));
114     }
115 
116     @Override
























































117     @ForceInline
118     public final MemoryAddress baseAddress() {
119         return new MemoryAddressImpl(this, 0);
120     }
121 
122     @Override
123     public final ByteBuffer asByteBuffer() {
124         if (!isSet(READ)) {
125             throw unsupportedAccessMode(READ);
126         }
127         checkIntSize(&quot;ByteBuffer&quot;);
128         ByteBuffer _bb = makeByteBuffer();
129         if (!isSet(WRITE)) {
130             //scope is IMMUTABLE - obtain a RO byte buffer
131             _bb = _bb.asReadOnlyBuffer();
132         }
133         return _bb;
134     }
135 
136     @Override
137     public final int accessModes() {
138         return mask &amp; ACCESS_MASK;
139     }
140 
141     @Override
142     public final long byteSize() {
143         return length;
144     }
145 
146     @Override
147     public final boolean isAlive() {

148         return scope.isAliveThreadSafe();



149     }
150 
151     @Override
152     public Thread ownerThread() {

153         return owner;



154     }
155 
156     @Override
157     public AbstractMemorySegmentImpl withAccessModes(int accessModes) {
158         checkAccessModes(accessModes);
159         if ((~accessModes() &amp; accessModes) != 0) {

160             throw new IllegalArgumentException(&quot;Cannot acquire more access modes&quot;);
161         }
162         return dup(0, length, (mask &amp; ~ACCESS_MASK) | accessModes, owner, scope);





163     }
164 
165     @Override
166     public boolean hasAccessModes(int accessModes) {
167         checkAccessModes(accessModes);
168         return (accessModes() &amp; accessModes) == accessModes;
169     }
170 
171     private void checkAccessModes(int accessModes) {
172         if ((accessModes &amp; ~ACCESS_MASK) != 0) {
173             throw new IllegalArgumentException(&quot;Invalid access modes&quot;);
174         }
175     }
176 
177     @Override
178     public MemorySegment withOwnerThread(Thread newOwner) {
179         Objects.requireNonNull(newOwner);

180         checkValidState();
181         if (!isSet(HANDOFF)) {
182             throw unsupportedAccessMode(HANDOFF);
183         }
184         if (owner == newOwner) {
185             throw new IllegalArgumentException(&quot;Segment already owned by thread: &quot; + newOwner);
186         } else {
187             try {
188                 return dup(0L, length, mask, newOwner, scope.dup());
189             } finally {
190                 //flush read/writes to memory before returning the new segment












191                 VarHandle.fullFence();
192             }
193         }
194     }
195 
196     @Override
197     public final void close() {
198         if (!isSet(CLOSE)) {
199             throw unsupportedAccessMode(CLOSE);
200         }

201         checkValidState();


202         closeNoCheck();
203     }
204 
205     private final void closeNoCheck() {

206         scope.close(true);



207     }
208 
209     final AbstractMemorySegmentImpl acquire() {
210         if (Thread.currentThread() != ownerThread() &amp;&amp; !isSet(ACQUIRE)) {
211             throw unsupportedAccessMode(ACQUIRE);
212         }

213         return dup(0, length, mask, Thread.currentThread(), scope.acquire());



214     }
215 
216     @Override
217     public final byte[] toByteArray() {
218         checkIntSize(&quot;byte[]&quot;);
219         byte[] arr = new byte[(int)length];
220         MemorySegment arrSegment = MemorySegment.ofArray(arr);

221         MemoryAddress.copy(baseAddress(), arrSegment.baseAddress(), length);



222         return arr;
223     }
224 
225     boolean isSmall() {
226         return isSet(SMALL);
227     }
228 
229     void checkRange(long offset, long length, boolean writeAccess) {

230         checkValidState();



231         if (writeAccess &amp;&amp; !isSet(WRITE)) {
232             throw unsupportedAccessMode(WRITE);
233         } else if (!writeAccess &amp;&amp; !isSet(READ)) {
234             throw unsupportedAccessMode(READ);
235         }
236         checkBounds(offset, length);
237     }
238 
239     @Override
240     public final void checkValidState() {

241         if (owner != null &amp;&amp; owner != Thread.currentThread()) {
242             throw new IllegalStateException(&quot;Attempt to access segment outside owning thread&quot;);
243         }
244         scope.checkAliveConfined();



245     }
246 
247     // Helper methods
248 
249     private boolean isSet(int mask) {
250         return (this.mask &amp; mask) != 0;
251     }
252 
253     private void checkIntSize(String typeName) {
254         if (length &gt; (Integer.MAX_VALUE - 8)) { //conservative check
255             throw new UnsupportedOperationException(String.format(&quot;Segment is too large to wrap as %s. Size: %d&quot;, typeName, length));
256         }
257     }
258 
259     private void checkBounds(long offset, long length) {
260         if (isSmall()) {
261             checkBoundsSmall((int)offset, (int)length);
262         } else {
263             if (length &lt; 0 ||
264                     offset &lt; 0 ||
</pre>
<hr />
<pre>
398 
399     // Object methods
400 
401     @Override
402     public String toString() {
403         return &quot;MemorySegment{ id=0x&quot; + Long.toHexString(id()) + &quot; limit: &quot; + length + &quot; }&quot;;
404     }
405 
406     public static AbstractMemorySegmentImpl ofBuffer(ByteBuffer bb) {
407         long bbAddress = nioAccess.getBufferAddress(bb);
408         Object base = nioAccess.getBufferBase(bb);
409         UnmapperProxy unmapper = nioAccess.unmapper(bb);
410 
411         int pos = bb.position();
412         int limit = bb.limit();
413         int size = limit - pos;
414 
415         AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl)nioAccess.bufferSegment(bb);
416         final MemoryScope bufferScope;
417         int modes;

418         final Thread owner;
419         if (bufferSegment != null) {
420             bufferScope = bufferSegment.scope;
421             modes = bufferSegment.mask;
422             owner = bufferSegment.owner;
423         } else {
424             bufferScope = new MemoryScope(bb, null);
425             modes = defaultAccessModes(size);
426             owner = Thread.currentThread();








427         }
428         if (bb.isReadOnly()) {
429             modes &amp;= ~WRITE;
430         }
431         if (base != null) {

432             return new HeapMemorySegmentImpl&lt;&gt;(bbAddress + pos, () -&gt; (byte[])base, size, modes, owner, bufferScope);
433         } else if (unmapper == null) {
434             return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, owner, bufferScope);
435         } else {
436             return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, owner, bufferScope);
437         }
438     }
439 
440     public static AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(0, 0, null, MemoryScope.GLOBAL) {













441         @Override
442         ByteBuffer makeByteBuffer() {
443             throw new UnsupportedOperationException();
444         }
445 
446         @Override
447         long min() {
448             return 0;
449         }
450 
451         @Override
452         Object base() {
453             return null;
454         }
455 
456         @Override

457         AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {



458             throw new UnsupportedOperationException();
459         }
460     };
461 }
</pre>
</td>
<td>
<hr />
<pre>
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.foreign;
 27 
 28 import jdk.incubator.foreign.MemoryAddress;
<span class="line-added"> 29 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
<span class="line-added"> 30 =======</span>
<span class="line-added"> 31 import jdk.incubator.foreign.MemoryLayout;</span>
<span class="line-added"> 32 import jdk.incubator.foreign.MemoryLayouts;</span>
<span class="line-added"> 33 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
 34 import jdk.incubator.foreign.MemorySegment;
 35 import jdk.incubator.foreign.SequenceLayout;
 36 import jdk.internal.access.JavaNioAccess;
 37 import jdk.internal.access.SharedSecrets;
 38 import jdk.internal.access.foreign.MemorySegmentProxy;
 39 import jdk.internal.access.foreign.UnmapperProxy;
<span class="line-added"> 40 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
<span class="line-added"> 41 =======</span>
<span class="line-added"> 42 import jdk.internal.misc.Unsafe;</span>
<span class="line-added"> 43 import jdk.internal.util.ArraysSupport;</span>
<span class="line-added"> 44 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
 45 import jdk.internal.vm.annotation.ForceInline;
 46 import sun.security.action.GetPropertyAction;
 47 
 48 import java.lang.invoke.VarHandle;
 49 import java.nio.ByteBuffer;
 50 import java.util.ArrayList;
 51 import java.util.List;
 52 import java.util.Objects;
 53 import java.util.Random;
 54 import java.util.Spliterator;
 55 import java.util.function.Consumer;
 56 
 57 /**
 58  * This abstract class provides an immutable implementation for the {@code MemorySegment} interface. This class contains information
 59  * about the segment&#39;s spatial and temporal bounds; each memory segment implementation is associated with an owner thread which is set at creation time.
 60  * Access to certain sensitive operations on the memory segment will fail with {@code IllegalStateException} if the
 61  * segment is either in an invalid state (e.g. it has already been closed) or if access occurs from a thread other
 62  * than the owner thread. See {@link MemoryScope} for more details on management of temporal bounds. Subclasses
 63  * are defined for each memory segment kind, see {@link NativeMemorySegmentImpl}, {@link HeapMemorySegmentImpl} and
 64  * {@link MappedMemorySegmentImpl}.
 65  */
 66 public abstract class AbstractMemorySegmentImpl implements MemorySegment, MemorySegmentProxy {
 67 
<span class="line-added"> 68 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
<span class="line-added"> 69 =======</span>
<span class="line-added"> 70     private static final Unsafe UNSAFE = Unsafe.getUnsafe();</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
 73     private static final boolean enableSmallSegments =
 74             Boolean.parseBoolean(GetPropertyAction.privilegedGetProperty(&quot;jdk.incubator.foreign.SmallSegments&quot;, &quot;true&quot;));
 75 
 76     final static int ACCESS_MASK = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;
 77     final static int FIRST_RESERVED_FLAG = 1 &lt;&lt; 16; // upper 16 bits are reserved
 78     final static int SMALL = FIRST_RESERVED_FLAG;
 79     final static long NONCE = new Random().nextLong();
 80     final static int DEFAULT_MASK = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;
 81 
 82     final static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
 83 
 84     final long length;
 85     final int mask;
<span class="line-added"> 86 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
 87     final Thread owner;
 88     final MemoryScope scope;
 89 
 90     @ForceInline
 91     AbstractMemorySegmentImpl(long length, int mask, Thread owner, MemoryScope scope) {
 92         this.length = length;
 93         this.mask = mask;
 94         this.owner = owner;
<span class="line-added"> 95 =======</span>
<span class="line-added"> 96     final MemoryScope scope;</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98     @ForceInline</span>
<span class="line-added"> 99     AbstractMemorySegmentImpl(long length, int mask, MemoryScope scope) {</span>
<span class="line-added">100         this.length = length;</span>
<span class="line-added">101         this.mask = mask;</span>
<span class="line-added">102 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
103         this.scope = scope;
104     }
105 
106     abstract long min();
107 
108     abstract Object base();
109 
<span class="line-added">110 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
111     abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope);
<span class="line-added">112 =======</span>
<span class="line-added">113     abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope);</span>
<span class="line-added">114 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
115 
116     abstract ByteBuffer makeByteBuffer();
117 
118     static int defaultAccessModes(long size) {
119         return (enableSmallSegments &amp;&amp; size &lt; Integer.MAX_VALUE) ?
120                 DEFAULT_MASK | SMALL :
121                 DEFAULT_MASK;
122     }
123 
124     @Override
125     public AbstractMemorySegmentImpl asSlice(long offset, long newSize) {
126         checkBounds(offset, newSize);
127         return asSliceNoCheck(offset, newSize);
128     }
129 
130     private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
<span class="line-added">131 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
132         return dup(offset, newSize, mask, owner, scope);
<span class="line-added">133 =======</span>
<span class="line-added">134         return dup(offset, newSize, mask, scope);</span>
<span class="line-added">135 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
136     }
137 
138     @SuppressWarnings(&quot;unchecked&quot;)
139     public static &lt;S extends MemorySegment&gt; Spliterator&lt;S&gt; spliterator(S segment, SequenceLayout sequenceLayout) {
140         ((AbstractMemorySegmentImpl)segment).checkValidState();
141         if (sequenceLayout.byteSize() != segment.byteSize()) {
142             throw new IllegalArgumentException();
143         }
144         return (Spliterator&lt;S&gt;)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
145                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() &amp; ~CLOSE));
146     }
147 
148     @Override
<span class="line-added">149 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
<span class="line-added">150 =======</span>
<span class="line-added">151     public final MemorySegment fill(byte value){</span>
<span class="line-added">152         checkRange(0, length, true);</span>
<span class="line-added">153         UNSAFE.setMemory(base(), min(), length, value);</span>
<span class="line-added">154         return this;</span>
<span class="line-added">155     }</span>
<span class="line-added">156 </span>
<span class="line-added">157     public void copyFrom(MemorySegment src) {</span>
<span class="line-added">158         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;</span>
<span class="line-added">159         long size = that.byteSize();</span>
<span class="line-added">160         checkRange(0, size, true);</span>
<span class="line-added">161         that.checkRange(0, size, false);</span>
<span class="line-added">162         UNSAFE.copyMemory(</span>
<span class="line-added">163                 that.base(), that.min(),</span>
<span class="line-added">164                 base(), min(), size);</span>
<span class="line-added">165     }</span>
<span class="line-added">166 </span>
<span class="line-added">167     private final static VarHandle BYTE_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)</span>
<span class="line-added">168             .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());</span>
<span class="line-added">169 </span>
<span class="line-added">170     @Override</span>
<span class="line-added">171     public long mismatch(MemorySegment other) {</span>
<span class="line-added">172         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;</span>
<span class="line-added">173         final long thisSize = this.byteSize();</span>
<span class="line-added">174         final long thatSize = that.byteSize();</span>
<span class="line-added">175         final long length = Math.min(thisSize, thatSize);</span>
<span class="line-added">176         this.checkRange(0, length, false);</span>
<span class="line-added">177         that.checkRange(0, length, false);</span>
<span class="line-added">178         if (this == other) {</span>
<span class="line-added">179             return -1;</span>
<span class="line-added">180         }</span>
<span class="line-added">181 </span>
<span class="line-added">182         long i = 0;</span>
<span class="line-added">183         if (length &gt; 7) {</span>
<span class="line-added">184             i = ArraysSupport.vectorizedMismatchLarge(</span>
<span class="line-added">185                     this.base(), this.min(),</span>
<span class="line-added">186                     that.base(), that.min(),</span>
<span class="line-added">187                     length, ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE);</span>
<span class="line-added">188             if (i &gt;= 0) {</span>
<span class="line-added">189                 return i;</span>
<span class="line-added">190             }</span>
<span class="line-added">191             i = length - ~i;</span>
<span class="line-added">192         }</span>
<span class="line-added">193         MemoryAddress thisAddress = this.baseAddress();</span>
<span class="line-added">194         MemoryAddress thatAddress = that.baseAddress();</span>
<span class="line-added">195         for (; i &lt; length; i++) {</span>
<span class="line-added">196             if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {</span>
<span class="line-added">197                 return i;</span>
<span class="line-added">198             }</span>
<span class="line-added">199         }</span>
<span class="line-added">200         return thisSize != thatSize ? length : -1;</span>
<span class="line-added">201     }</span>
<span class="line-added">202 </span>
<span class="line-added">203     @Override</span>
<span class="line-added">204 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
205     @ForceInline
206     public final MemoryAddress baseAddress() {
207         return new MemoryAddressImpl(this, 0);
208     }
209 
210     @Override
211     public final ByteBuffer asByteBuffer() {
212         if (!isSet(READ)) {
213             throw unsupportedAccessMode(READ);
214         }
215         checkIntSize(&quot;ByteBuffer&quot;);
216         ByteBuffer _bb = makeByteBuffer();
217         if (!isSet(WRITE)) {
218             //scope is IMMUTABLE - obtain a RO byte buffer
219             _bb = _bb.asReadOnlyBuffer();
220         }
221         return _bb;
222     }
223 
224     @Override
225     public final int accessModes() {
226         return mask &amp; ACCESS_MASK;
227     }
228 
229     @Override
230     public final long byteSize() {
231         return length;
232     }
233 
234     @Override
235     public final boolean isAlive() {
<span class="line-added">236 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
237         return scope.isAliveThreadSafe();
<span class="line-added">238 =======</span>
<span class="line-added">239         return scope.isAlive();</span>
<span class="line-added">240 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
241     }
242 
243     @Override
244     public Thread ownerThread() {
<span class="line-added">245 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
246         return owner;
<span class="line-added">247 =======</span>
<span class="line-added">248         return scope.ownerThread();</span>
<span class="line-added">249 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
250     }
251 
252     @Override
253     public AbstractMemorySegmentImpl withAccessModes(int accessModes) {
254         checkAccessModes(accessModes);
255         if ((~accessModes() &amp; accessModes) != 0) {
<span class="line-added">256 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
257             throw new IllegalArgumentException(&quot;Cannot acquire more access modes&quot;);
258         }
259         return dup(0, length, (mask &amp; ~ACCESS_MASK) | accessModes, owner, scope);
<span class="line-added">260 =======</span>
<span class="line-added">261             throw new UnsupportedOperationException(&quot;Cannot acquire more access modes&quot;);</span>
<span class="line-added">262         }</span>
<span class="line-added">263         return dup(0, length, (mask &amp; ~ACCESS_MASK) | accessModes, scope);</span>
<span class="line-added">264 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
265     }
266 
267     @Override
268     public boolean hasAccessModes(int accessModes) {
269         checkAccessModes(accessModes);
270         return (accessModes() &amp; accessModes) == accessModes;
271     }
272 
273     private void checkAccessModes(int accessModes) {
274         if ((accessModes &amp; ~ACCESS_MASK) != 0) {
275             throw new IllegalArgumentException(&quot;Invalid access modes&quot;);
276         }
277     }
278 
279     @Override
280     public MemorySegment withOwnerThread(Thread newOwner) {
281         Objects.requireNonNull(newOwner);
<span class="line-added">282 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
283         checkValidState();
284         if (!isSet(HANDOFF)) {
285             throw unsupportedAccessMode(HANDOFF);
286         }
287         if (owner == newOwner) {
288             throw new IllegalArgumentException(&quot;Segment already owned by thread: &quot; + newOwner);
289         } else {
290             try {
291                 return dup(0L, length, mask, newOwner, scope.dup());
292             } finally {
293                 //flush read/writes to memory before returning the new segment
<span class="line-added">294 =======</span>
<span class="line-added">295         if (!isSet(HANDOFF)) {</span>
<span class="line-added">296             throw unsupportedAccessMode(HANDOFF);</span>
<span class="line-added">297         }</span>
<span class="line-added">298         if (scope.ownerThread() == newOwner) {</span>
<span class="line-added">299             throw new IllegalArgumentException(&quot;Segment already owned by thread: &quot; + newOwner);</span>
<span class="line-added">300         } else {</span>
<span class="line-added">301             try {</span>
<span class="line-added">302                 return dup(0L, length, mask, scope.dup(newOwner));</span>
<span class="line-added">303             } finally {</span>
<span class="line-added">304                 //flush read/writes to segment memory before returning the new segment</span>
<span class="line-added">305 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
306                 VarHandle.fullFence();
307             }
308         }
309     }
310 
311     @Override
312     public final void close() {
313         if (!isSet(CLOSE)) {
314             throw unsupportedAccessMode(CLOSE);
315         }
<span class="line-added">316 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
317         checkValidState();
<span class="line-added">318 =======</span>
<span class="line-added">319 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
320         closeNoCheck();
321     }
322 
323     private final void closeNoCheck() {
<span class="line-added">324 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
325         scope.close(true);
<span class="line-added">326 =======</span>
<span class="line-added">327         scope.close();</span>
<span class="line-added">328 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
329     }
330 
331     final AbstractMemorySegmentImpl acquire() {
332         if (Thread.currentThread() != ownerThread() &amp;&amp; !isSet(ACQUIRE)) {
333             throw unsupportedAccessMode(ACQUIRE);
334         }
<span class="line-added">335 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
336         return dup(0, length, mask, Thread.currentThread(), scope.acquire());
<span class="line-added">337 =======</span>
<span class="line-added">338         return dup(0, length, mask, scope.acquire());</span>
<span class="line-added">339 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
340     }
341 
342     @Override
343     public final byte[] toByteArray() {
344         checkIntSize(&quot;byte[]&quot;);
345         byte[] arr = new byte[(int)length];
346         MemorySegment arrSegment = MemorySegment.ofArray(arr);
<span class="line-added">347 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
348         MemoryAddress.copy(baseAddress(), arrSegment.baseAddress(), length);
<span class="line-added">349 =======</span>
<span class="line-added">350         arrSegment.copyFrom(this);</span>
<span class="line-added">351 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
352         return arr;
353     }
354 
355     boolean isSmall() {
356         return isSet(SMALL);
357     }
358 
359     void checkRange(long offset, long length, boolean writeAccess) {
<span class="line-added">360 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
361         checkValidState();
<span class="line-added">362 =======</span>
<span class="line-added">363         scope.checkValidState();</span>
<span class="line-added">364 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
365         if (writeAccess &amp;&amp; !isSet(WRITE)) {
366             throw unsupportedAccessMode(WRITE);
367         } else if (!writeAccess &amp;&amp; !isSet(READ)) {
368             throw unsupportedAccessMode(READ);
369         }
370         checkBounds(offset, length);
371     }
372 
373     @Override
374     public final void checkValidState() {
<span class="line-added">375 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
376         if (owner != null &amp;&amp; owner != Thread.currentThread()) {
377             throw new IllegalStateException(&quot;Attempt to access segment outside owning thread&quot;);
378         }
379         scope.checkAliveConfined();
<span class="line-added">380 =======</span>
<span class="line-added">381         scope.checkValidState();</span>
<span class="line-added">382 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
383     }
384 
385     // Helper methods
386 
387     private boolean isSet(int mask) {
388         return (this.mask &amp; mask) != 0;
389     }
390 
391     private void checkIntSize(String typeName) {
392         if (length &gt; (Integer.MAX_VALUE - 8)) { //conservative check
393             throw new UnsupportedOperationException(String.format(&quot;Segment is too large to wrap as %s. Size: %d&quot;, typeName, length));
394         }
395     }
396 
397     private void checkBounds(long offset, long length) {
398         if (isSmall()) {
399             checkBoundsSmall((int)offset, (int)length);
400         } else {
401             if (length &lt; 0 ||
402                     offset &lt; 0 ||
</pre>
<hr />
<pre>
536 
537     // Object methods
538 
539     @Override
540     public String toString() {
541         return &quot;MemorySegment{ id=0x&quot; + Long.toHexString(id()) + &quot; limit: &quot; + length + &quot; }&quot;;
542     }
543 
544     public static AbstractMemorySegmentImpl ofBuffer(ByteBuffer bb) {
545         long bbAddress = nioAccess.getBufferAddress(bb);
546         Object base = nioAccess.getBufferBase(bb);
547         UnmapperProxy unmapper = nioAccess.unmapper(bb);
548 
549         int pos = bb.position();
550         int limit = bb.limit();
551         int size = limit - pos;
552 
553         AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl)nioAccess.bufferSegment(bb);
554         final MemoryScope bufferScope;
555         int modes;
<span class="line-added">556 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
557         final Thread owner;
558         if (bufferSegment != null) {
559             bufferScope = bufferSegment.scope;
560             modes = bufferSegment.mask;
561             owner = bufferSegment.owner;
562         } else {
563             bufferScope = new MemoryScope(bb, null);
564             modes = defaultAccessModes(size);
565             owner = Thread.currentThread();
<span class="line-added">566 =======</span>
<span class="line-added">567         if (bufferSegment != null) {</span>
<span class="line-added">568             bufferScope = bufferSegment.scope;</span>
<span class="line-added">569             modes = bufferSegment.mask;</span>
<span class="line-added">570         } else {</span>
<span class="line-added">571             bufferScope = MemoryScope.create(bb, null);</span>
<span class="line-added">572             modes = defaultAccessModes(size);</span>
<span class="line-added">573 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
574         }
575         if (bb.isReadOnly()) {
576             modes &amp;= ~WRITE;
577         }
578         if (base != null) {
<span class="line-added">579 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
580             return new HeapMemorySegmentImpl&lt;&gt;(bbAddress + pos, () -&gt; (byte[])base, size, modes, owner, bufferScope);
581         } else if (unmapper == null) {
582             return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, owner, bufferScope);
583         } else {
584             return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, owner, bufferScope);
585         }
586     }
587 
588     public static AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(0, 0, null, MemoryScope.GLOBAL) {
<span class="line-added">589 =======</span>
<span class="line-added">590             return new HeapMemorySegmentImpl&lt;&gt;(bbAddress + pos, () -&gt; (byte[])base, size, modes, bufferScope);</span>
<span class="line-added">591         } else if (unmapper == null) {</span>
<span class="line-added">592             return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, bufferScope);</span>
<span class="line-added">593         } else {</span>
<span class="line-added">594             return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, bufferScope);</span>
<span class="line-added">595         }</span>
<span class="line-added">596     }</span>
<span class="line-added">597 </span>
<span class="line-added">598     public static final AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(</span>
<span class="line-added">599         0, 0, MemoryScope.createUnchecked(null, null, null)</span>
<span class="line-added">600     ) {</span>
<span class="line-added">601 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
602         @Override
603         ByteBuffer makeByteBuffer() {
604             throw new UnsupportedOperationException();
605         }
606 
607         @Override
608         long min() {
609             return 0;
610         }
611 
612         @Override
613         Object base() {
614             return null;
615         }
616 
617         @Override
<span class="line-added">618 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
619         AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
<span class="line-added">620 =======</span>
<span class="line-added">621         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {</span>
<span class="line-added">622 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
623             throw new UnsupportedOperationException();
624         }
625     };
626 }
</pre>
</td>
</tr>
</table>
<center><a href="../../incubator/foreign/SequenceLayout.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HeapMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
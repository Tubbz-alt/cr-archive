<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.foreign.LayoutPath;
 29 import jdk.internal.foreign.LayoutPath.PathElementImpl.PathKind;
 30 import jdk.internal.foreign.Utils;
 31 
 32 import java.lang.constant.Constable;
 33 import java.lang.constant.DynamicConstantDesc;
 34 import java.lang.invoke.VarHandle;
 35 import java.nio.ByteOrder;
 36 import java.util.EnumSet;
 37 import java.util.List;
 38 import java.util.Objects;
 39 import java.util.Optional;
 40 import java.util.OptionalLong;
 41 import java.util.Set;
 42 import java.util.function.Function;
 43 import java.util.function.UnaryOperator;
 44 import java.util.stream.Stream;
 45 
 46 /**
 47  * A memory layout can be used to describe the contents of a memory segment in a &lt;em&gt;language neutral&lt;/em&gt; fashion.
 48  * There are two leaves in the layout hierarchy, &lt;em&gt;value layouts&lt;/em&gt;, which are used to represent values of given size and kind (see
 49  * {@link ValueLayout}) and &lt;em&gt;padding layouts&lt;/em&gt; which are used, as the name suggests, to represent a portion of a memory
 50  * segment whose contents should be ignored, and which are primarily present for alignment reasons (see {@link MemoryLayout#ofPaddingBits(long)}).
 51  * Some common value layout constants are defined in the {@link MemoryLayouts} class.
 52  * &lt;p&gt;
 53  * More complex layouts can be derived from simpler ones: a &lt;em&gt;sequence layout&lt;/em&gt; denotes a repetition of one or more
 54  * element layout (see {@link SequenceLayout}); a &lt;em&gt;group layout&lt;/em&gt; denotes an aggregation of (typically) heterogeneous
 55  * member layouts (see {@link GroupLayout}).
 56  * &lt;p&gt;
 57  * All implementations of this interface must be &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;;
 58  * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on
 59  * instances of {@code MemoryLayout} may have unpredictable results and should be avoided. The {@code equals} method should
 60  * be used for comparisons.
 61  * &lt;p&gt;
 62  * Non-platform classes should not implement {@linkplain MemoryLayout} directly.
 63  *
 64  * &lt;h2&gt;&lt;a id = &quot;layout-align&quot;&gt;Size, alignment and byte order&lt;/a&gt;&lt;/h2&gt;
 65  *
 66  * All layouts have a size; layout size for value and padding layouts is always explicitly denoted; this means that a layout description
 67  * always has the same size in bits, regardless of the platform in which it is used. For derived layouts, the size is computed
 68  * as follows:
 69  * &lt;ul&gt;
 70  *     &lt;li&gt;for a &lt;em&gt;finite&lt;/em&gt; sequence layout &lt;em&gt;S&lt;/em&gt; whose element layout is &lt;em&gt;E&lt;/em&gt; and size is L,
 71  *     the size of &lt;em&gt;S&lt;/em&gt; is that of &lt;em&gt;E&lt;/em&gt;, multiplied by &lt;em&gt;L&lt;/em&gt;&lt;/li&gt;
 72  *     &lt;li&gt;the size of an &lt;em&gt;unbounded&lt;/em&gt; sequence layout is &lt;em&gt;unknown&lt;/em&gt;&lt;/li&gt;
 73  *     &lt;li&gt;for a group layout &lt;em&gt;G&lt;/em&gt; with member layouts &lt;em&gt;M1&lt;/em&gt;, &lt;em&gt;M2&lt;/em&gt;, ... &lt;em&gt;Mn&lt;/em&gt; whose sizes are
 74  *     &lt;em&gt;S1&lt;/em&gt;, &lt;em&gt;S2&lt;/em&gt;, ... &lt;em&gt;Sn&lt;/em&gt;, respectively, the size of &lt;em&gt;G&lt;/em&gt; is either &lt;em&gt;S1 + S2 + ... + Sn&lt;/em&gt; or
 75  *     &lt;em&gt;max(S1, S2, ... Sn)&lt;/em&gt; depending on whether the group is a &lt;em&gt;struct&lt;/em&gt; or an &lt;em&gt;union&lt;/em&gt;, respectively&lt;/li&gt;
 76  * &lt;/ul&gt;
 77  * &lt;p&gt;
 78  * Furthermore, all layouts feature a &lt;em&gt;natural alignment&lt;/em&gt; which can be inferred as follows:
 79  * &lt;ul&gt;
 80  *     &lt;li&gt;for a padding layout &lt;em&gt;L&lt;/em&gt;, the natural alignment is 1, regardless of its size; that is, in the absence
 81  *     of an explicit alignment constraint, a padding layout should not affect the alignment constraint of the group
 82  *     layout it is nested into&lt;/li&gt;
 83  *     &lt;li&gt;for a value layout &lt;em&gt;L&lt;/em&gt; whose size is &lt;em&gt;N&lt;/em&gt;, the natural alignment of &lt;em&gt;L&lt;/em&gt; is &lt;em&gt;N&lt;/em&gt;&lt;/li&gt;
 84  *     &lt;li&gt;for a sequence layout &lt;em&gt;S&lt;/em&gt; whose element layout is &lt;em&gt;E&lt;/em&gt;, the natural alignment of &lt;em&gt;S&lt;/em&gt; is that of &lt;em&gt;E&lt;/em&gt;&lt;/li&gt;
 85  *     &lt;li&gt;for a group layout &lt;em&gt;G&lt;/em&gt; with member layouts &lt;em&gt;M1&lt;/em&gt;, &lt;em&gt;M2&lt;/em&gt;, ... &lt;em&gt;Mn&lt;/em&gt; whose alignments are
 86  *     &lt;em&gt;A1&lt;/em&gt;, &lt;em&gt;A2&lt;/em&gt;, ... &lt;em&gt;An&lt;/em&gt;, respectively, the natural alignment of &lt;em&gt;G&lt;/em&gt; is &lt;em&gt;max(A1, A2 ... An)&lt;/em&gt;&lt;/li&gt;
 87  * &lt;/ul&gt;
 88  * A layout&#39;s natural alignment can be overridden if needed (see {@link MemoryLayout#withBitAlignment(long)}), which can be useful to describe
 89  * hyper-aligned layouts.
 90  * &lt;p&gt;
 91  * All value layouts have an &lt;em&gt;explicit&lt;/em&gt; byte order (see {@link java.nio.ByteOrder}) which is set when the layout is created.
 92  *
 93  * &lt;h2&gt;&lt;a id = &quot;layout-paths&quot;&gt;Layout paths&lt;/a&gt;&lt;/h2&gt;
 94  *
 95  * A &lt;em&gt;layout path&lt;/em&gt; originates from a &lt;em&gt;root&lt;/em&gt; layout (typically a group or a sequence layout) and terminates
 96  * at a layout nested within the root layout - this is the layout &lt;em&gt;selected&lt;/em&gt; by the layout path.
 97  * Layout paths are typically expressed as a sequence of one or more {@link PathElement} instances.
 98  * &lt;p&gt;
 99  * Layout paths are for example useful in order to obtain offsets of arbitrarily nested layouts inside another layout
<a name="1" id="anc1"></a><span class="line-modified">100  * (see {@link MemoryLayout#bitOffset(PathElement...)}), to quickly obtain a memory access handle corresponding to the selected</span>
101  * layout (see {@link MemoryLayout#varHandle(Class, PathElement...)}), to select an arbitrarily nested layout inside
102  * another layout (see {@link MemoryLayout#select(PathElement...)}, or to transform a nested layout element inside
103  * another layout (see {@link MemoryLayout#map(UnaryOperator, PathElement...)}).
104  * &lt;p&gt;
105  * Such &lt;em&gt;layout paths&lt;/em&gt; can be constructed programmatically using the methods in this class.
106  * For instance, given a layout constructed as follows:
107  * &lt;blockquote&gt;&lt;pre&gt;{@code
108 SequenceLayout seq = MemoryLayout.ofSequence(5,
109     MemoryLayout.ofStruct(
110         MemoryLayout.ofPaddingBits(32),
111         MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName(&quot;value&quot;)
112 ));
113  * }&lt;/pre&gt;&lt;/blockquote&gt;
114  *
<a name="2" id="anc2"></a><span class="line-modified">115  * We can obtain the offset, in bits, of the member layout named &lt;code&gt;value&lt;/code&gt; from &lt;code&gt;seq&lt;/code&gt;, as follows:</span>
116  * &lt;blockquote&gt;&lt;pre&gt;{@code
<a name="3" id="anc3"></a><span class="line-modified">117 long valueOffset = seq.bitOffset(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));</span>
<span class="line-added">118  * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">119  *</span>
<span class="line-added">120  * Similarly, we can select the member layout named {@code value}, as follows:</span>
<span class="line-added">121  * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">122 MemoryLayout value = seq.select(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));</span>
<span class="line-added">123  * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">124  *</span>
<span class="line-added">125  * And, we can also replace the layout named {@code value} with another layout, as follows:</span>
<span class="line-added">126  * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">127 MemoryLayout newSeq = seq.map(l -&gt; MemoryLayout.ofPadding(32), PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));</span>
<span class="line-added">128  * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">129  *</span>
<span class="line-added">130  * That is, the above declaration is identical to the following, more verbose one:</span>
<span class="line-added">131  * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">132 MemoryLayout newSeq = MemoryLayout.ofSequence(5,</span>
<span class="line-added">133     MemoryLayout.ofStruct(</span>
<span class="line-added">134         MemoryLayout.ofPaddingBits(32),</span>
<span class="line-added">135         MemoryLayout.ofPaddingBits(32)</span>
<span class="line-added">136 ));</span>
137  * }&lt;/pre&gt;&lt;/blockquote&gt;
138  *
139  * Similarly, we can select the member layout named {@code value}, as follows:
140  * &lt;blockquote&gt;&lt;pre&gt;{@code
141 MemoryLayout value = seq.select(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
142  * }&lt;/pre&gt;&lt;/blockquote&gt;
143  *
144  * And, we can also replace the layout named {@code value} with another layout, as follows:
145  * &lt;blockquote&gt;&lt;pre&gt;{@code
146 MemoryLayout newSeq = seq.map(l -&gt; MemoryLayout.ofPadding(32), PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
147  * }&lt;/pre&gt;&lt;/blockquote&gt;
148  *
149  * That is, the above declaration is identical to the following, more verbose one:
150  * &lt;blockquote&gt;&lt;pre&gt;{@code
151 MemoryLayout newSeq = MemoryLayout.ofSequence(5,
152     MemoryLayout.ofStruct(
153         MemoryLayout.ofPaddingBits(32),
154         MemoryLayout.ofPaddingBits(32)
155 ));
156  * }&lt;/pre&gt;&lt;/blockquote&gt;
157  *
158  * Similarly, we can select the member layout named {@code value}, as follows:
159  * &lt;blockquote&gt;&lt;pre&gt;{@code
160 MemoryLayout value = seq.select(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
161  * }&lt;/pre&gt;&lt;/blockquote&gt;
162  *
163  * And, we can also replace the layout named {@code value} with another layout, as follows:
164  * &lt;blockquote&gt;&lt;pre&gt;{@code
165 MemoryLayout newSeq = seq.map(l -&gt; MemoryLayout.ofPadding(32), PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
166  * }&lt;/pre&gt;&lt;/blockquote&gt;
167  *
168  * That is, the above declaration is identical to the following, more verbose one:
169  * &lt;blockquote&gt;&lt;pre&gt;{@code
170 MemoryLayout newSeq = MemoryLayout.ofSequence(5,
171     MemoryLayout.ofStruct(
172         MemoryLayout.ofPaddingBits(32),
173         MemoryLayout.ofPaddingBits(32)
174 ));
175  * }&lt;/pre&gt;&lt;/blockquote&gt;
176  *
177  * Layout paths can feature one or more &lt;em&gt;free dimensions&lt;/em&gt;. For instance, a layout path traversing
178  * an unspecified sequence element (that is, where one of the path component was obtained with the
179  * {@link PathElement#sequenceElement()} method) features an additional free dimension, which will have to be bound at runtime.
180  * This is important when obtaining memory access var handle from layouts, as in the following code:
181  *
182  * &lt;blockquote&gt;&lt;pre&gt;{@code
183 VarHandle valueHandle = seq.map(int.class, PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
184  * }&lt;/pre&gt;&lt;/blockquote&gt;
185  *
186  * Since the layout path {@code seq} constructed in the above example features exactly one free dimension,
187  * it follows that the memory access var handle {@code valueHandle} will feature an extra {@code long}
188  * access coordinate.
189  *
190  * &lt;h2&gt;Layout attributes&lt;/h2&gt;
191  *
192  * Layouts can be optionally associated with one or more &lt;em&gt;attributes&lt;/em&gt;. A layout attribute forms a &lt;em&gt;name/value&lt;/em&gt;
193  * pair, where the name is a {@link String} and the value is a {@link Constable}. The most common form of layout attribute
194  * is the &lt;em&gt;layout name&lt;/em&gt; (see {@link #LAYOUT_NAME}), a custom name that can be associated to memory layouts and that can be referred to when
195  * constructing &lt;a href=&quot;MemoryLayout.html#layout-paths&quot;&gt;&lt;em&gt;layout paths&lt;/em&gt;&lt;/a&gt;.
196  *
197  * @apiNote In the future, if the Java language permits, {@link MemoryLayout}
198  * may become a {@code sealed} interface, which would prohibit subclassing except by
199  * explicitly permitted types.
200  *
201  * @implSpec
202  * Implementations of this class are immutable and thread-safe.
203  */
204 public interface MemoryLayout extends Constable {
205 
206     /**
207      * Returns an {@link Optional} containing the nominal descriptor for this
208      * layout, if one can be constructed, or an empty {@link Optional}
209      * if one cannot be constructed.
210      *
211      * @return An {@link Optional} containing the resulting nominal descriptor,
212      * or an empty {@link Optional} if one cannot be constructed.
213      */
214     @Override
215     Optional&lt;? extends DynamicConstantDesc&lt;? extends MemoryLayout&gt;&gt; describeConstable();
216 
217     /**
218      * Does this layout have a specified size? A layout does not have a specified size if it is (or contains) a sequence layout whose
219      * size is unspecified (see {@link SequenceLayout#elementCount()}).
220      *
221      * Value layouts (see {@link ValueLayout}) and padding layouts (see {@link MemoryLayout#ofPaddingBits(long)})
222      * &lt;em&gt;always&lt;/em&gt; have a specified size, therefore this method always returns {@code true} in these cases.
223      *
224      * @return {@code true}, if this layout has a specified size.
225      */
226     boolean hasSize();
227 
228     /**
229      * Computes the layout size, in bits.
230      *
231      * @return the layout size, in bits.
232      * @throws UnsupportedOperationException if the layout is, or contains, a sequence layout with unspecified size (see {@link SequenceLayout}).
233      */
234     long bitSize();
235 
236     /**
237      * Computes the layout size, in bytes.
238      *
239      * @return the layout size, in bytes.
240      * @throws UnsupportedOperationException if the layout is, or contains, a sequence layout with unspecified size (see {@link SequenceLayout}),
241      * or if {@code bitSize()} is not a multiple of 8.
242      */
243     default long byteSize() {
244         return Utils.bitsToBytesOrThrow(bitSize(),
245                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte size; bit size is not a multiple of 8&quot;));
246     }
247 
248     /**
249      * Return the &lt;em&gt;name&lt;/em&gt; (if any) associated with this layout.
250      * &lt;p&gt;
251      * This is equivalent to the following code:
252      * &lt;blockquote&gt;&lt;pre&gt;{@code
253     attribute(LAYOUT_NAME).map(String.class::cast);
254      * }&lt;/pre&gt;&lt;/blockquote&gt;
255      *
256      * @return the layout &lt;em&gt;name&lt;/em&gt; (if any).
257      * @see MemoryLayout#withName(String)
258      */
259     Optional&lt;String&gt; name();
260 
261     /**
262      * Creates a new layout which features the desired layout &lt;em&gt;name&lt;/em&gt;.
263      * &lt;p&gt;
264      * This is equivalent to the following code:
265      * &lt;blockquote&gt;&lt;pre&gt;{@code
266     withAttribute(LAYOUT_NAME, name);
267      * }&lt;/pre&gt;&lt;/blockquote&gt;
268      *
269      * @param name the layout name.
270      * @return a new layout which is the same as this layout, except for the &lt;em&gt;name&lt;/em&gt; associated to it.
271      * @see MemoryLayout#name()
272      */
273     MemoryLayout withName(String name);
274 
275     /**
276      * Returns the alignment constraint associated with this layout, expressed in bits. Layout alignment defines a power
277      * of two {@code A} which is the bit-wise alignment of the layout. If {@code A &lt;= 8} then {@code A/8} is the number of
278      * bytes that must be aligned for any pointer that correctly points to this layout. Thus:
279      *
280      * &lt;ul&gt;
281      * &lt;li&gt;{@code A=8} means unaligned (in the usual sense), which is common in packets.&lt;/li&gt;
282      * &lt;li&gt;{@code A=64} means word aligned (on LP64), {@code A=32} int aligned, {@code A=16} short aligned, etc.&lt;/li&gt;
283      * &lt;li&gt;{@code A=512} is the most strict alignment required by the x86/SV ABI (for AVX-512 data).&lt;/li&gt;
284      * &lt;/ul&gt;
285      *
286      * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),
287      * then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bits) associated with this layout.
288      *
289      * @return the layout alignment constraint, in bits.
290      */
291     long bitAlignment();
292 
293     /**
294      * Returns the alignment constraint associated with this layout, expressed in bytes. Layout alignment defines a power
295      * of two {@code A} which is the byte-wise alignment of the layout, where {@code A} is the number of bytes that must be aligned
296      * for any pointer that correctly points to this layout. Thus:
297      *
298      * &lt;ul&gt;
299      * &lt;li&gt;{@code A=1} means unaligned (in the usual sense), which is common in packets.&lt;/li&gt;
300      * &lt;li&gt;{@code A=8} means word aligned (on LP64), {@code A=4} int aligned, {@code A=2} short aligned, etc.&lt;/li&gt;
301      * &lt;li&gt;{@code A=64} is the most strict alignment required by the x86/SV ABI (for AVX-512 data).&lt;/li&gt;
302      * &lt;/ul&gt;
303      *
304      * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),
305      * then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bytes) associated with this layout.
306      *
307      * @return the layout alignment constraint, in bytes.
308      * @throws UnsupportedOperationException if {@code bitAlignment()} is not a multiple of 8.
309      */
310     default long byteAlignment() {
311         return Utils.bitsToBytesOrThrow(bitAlignment(),
312                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte alignment; bit alignment is not a multiple of 8&quot;));
313     }
314 
315     /**
316      * Creates a new layout which features the desired alignment constraint.
317      *
318      * @param bitAlignment the layout alignment constraint, expressed in bits.
319      * @return a new layout which is the same as this layout, except for the alignment constraint associated to it.
320      * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it&#39;s less than than 8.
321      */
322     MemoryLayout withBitAlignment(long bitAlignment);
323 
324     /**
<a name="4" id="anc4"></a><span class="line-added">325 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
326      * Returns the attribute with the given name (if it exists).
327      *
328      * @param name the attribute name
329      * @return the attribute with the given name (if it exists).
<a name="5" id="anc5"></a><span class="line-added">330 =======</span>
<span class="line-added">331      * Returns the attribute with the given name if it exists, or an empty optional</span>
<span class="line-added">332      *</span>
<span class="line-added">333      * @param name the name of the attribute</span>
<span class="line-added">334      * @return the optional attribute</span>
<span class="line-added">335 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
336      */
337     Optional&lt;Constable&gt; attribute(String name);
338 
339     /**
<a name="6" id="anc6"></a><span class="line-added">340 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
341      * Returns a new memory layout which features the same attributes as this layout, plus the newly specified attribute.
342      * If this layout already contains an attribute with the same name, the existing attribute value is overwritten in the returned
343      * layout.
344      *
345      * @param name the attribute name.
346      * @param value the attribute value.
347      * @return a new memory layout which features the same attributes as this layout, plus the newly specified attribute.
<a name="7" id="anc7"></a><span class="line-added">348 =======</span>
<span class="line-added">349      * Returns a new MemoryLayout with the given additional attribute</span>
<span class="line-added">350      *</span>
<span class="line-added">351      * @param name the name of the attribute</span>
<span class="line-added">352      * @param value the value of the attribute</span>
<span class="line-added">353      * @return the new MemoryLayout</span>
<span class="line-added">354 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
355      */
356     MemoryLayout withAttribute(String name, Constable value);
357 
358     /**
<a name="8" id="anc8"></a><span class="line-added">359 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
360      * Returns a stream of the attribute names associated with this layout.
361      *
362      * @return a stream of the attribute names associated with this layout.
<a name="9" id="anc9"></a><span class="line-added">363 =======</span>
<span class="line-added">364      * Returns a stream of the names of the attributes of this layout</span>
<span class="line-added">365      *</span>
<span class="line-added">366      * @return the stream of names</span>
<span class="line-added">367 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
368      */
369     Stream&lt;String&gt; attributes();
370 
371     /**
372      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
373      * layout.
374      *
375      * @apiNote if the layout path has one (or more) free dimensions,
376      * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.
377      *
378      * @param elements the layout path elements.
379      * @return The offset, in bits, of the layout selected by the layout path in {@code elements}.
380      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the
381      * layout path contains one or more path elements that select multiple sequence element indices
382      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).
383      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.
384      */
<a name="10" id="anc10"></a><span class="line-modified">385     default long bitOffset(PathElement... elements) {</span>
386         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset, EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);
387     }
388 
<a name="11" id="anc11"></a><span class="line-added">389     /**</span>
<span class="line-added">390      * Computes the offset, in bytes, of the layout selected by a given layout path, where the path is considered rooted in this</span>
<span class="line-added">391      * layout.</span>
<span class="line-added">392      *</span>
<span class="line-added">393      * @apiNote if the layout path has one (or more) free dimensions,</span>
<span class="line-added">394      * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.</span>
<span class="line-added">395      *</span>
<span class="line-added">396      * @param elements the layout path elements.</span>
<span class="line-added">397      * @return The offset, in bytes, of the layout selected by the layout path in {@code elements}.</span>
<span class="line-added">398      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the</span>
<span class="line-added">399      * layout path contains one or more path elements that select multiple sequence element indices</span>
<span class="line-added">400      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).</span>
<span class="line-added">401      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size,</span>
<span class="line-added">402      * or if {@code bitOffset(elements)} is not a multiple of 8.</span>
<span class="line-added">403      */</span>
<span class="line-added">404     default long byteOffset(PathElement... elements) {</span>
<span class="line-added">405         return Utils.bitsToBytesOrThrow(bitOffset(elements),</span>
<span class="line-added">406                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte offset; bit offset is not a multiple of 8&quot;));</span>
<span class="line-added">407     }</span>
<span class="line-added">408 </span>
409     /**
410      * Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path,
411      * where the path is considered rooted in this layout.
412      *
413      * @apiNote the resulting var handle will feature an additional {@code long} access coordinate for every
414      * unspecified sequence access component contained in this layout path. Moreover, the resulting var handle
415      * features certain &lt;a href=&quot;MemoryHandles.html#memaccess-mode&quot;&gt;access mode restrictions&lt;/a&gt;, which are common to all memory access var handles.
416      *
417      * @param carrier the var handle carrier type.
418      * @param elements the layout path elements.
419      * @return a var handle which can be used to dereference memory at the (possibly nested) layout selected by the layout path in {@code elements}.
420      * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraints,
421      * or if one of the layouts traversed by the layout path has unspecified size.
422      * @throws IllegalArgumentException if the carrier does not represent a primitive type, if the carrier is {@code void},
423      * {@code boolean}, or if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}),
424      * or if the selected value layout has a size that that does not match that of the specified carrier type.
425      */
426     default VarHandle varHandle(Class&lt;?&gt; carrier, PathElement... elements) {
427         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), path -&gt; path.dereferenceHandle(carrier),
428                 Set.of(), elements);
429     }
430 
431     /**
432      * Selects the layout from a path rooted in this layout.
433      *
434      * @param elements the layout path elements.
435      * @return the layout selected by the layout path in {@code elements}.
436      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout,
437      * or if the layout path contains one or more path elements that select one or more sequence element indices
438      * (see {@link PathElement#sequenceElement(long)} and {@link PathElement#sequenceElement(long, long)}).
439      */
440     default MemoryLayout select(PathElement... elements) {
441         return computePathOp(LayoutPath.rootPath(this, l -&gt; 0L), LayoutPath::layout,
442                 EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE), elements);
443     }
444 
445     /**
446      * Creates a transformed copy of this layout where a selected layout, from a path rooted in this layout,
447      * is replaced with the result of applying the given operation.
448      *
449      * @param op the unary operation to be applied to the selected layout.
450      * @param elements the layout path elements.
451      * @return a new layout where the layout selected by the layout path in {@code elements},
452      * has been replaced by the result of applying {@code op} to the selected layout.
453      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout,
454      * or if the layout path contains one or more path elements that select one or more sequence element indices
455      * (see {@link PathElement#sequenceElement(long)} and {@link PathElement#sequenceElement(long, long)}).
456      */
457     default MemoryLayout map(UnaryOperator&lt;MemoryLayout&gt; op, PathElement... elements) {
458         return computePathOp(LayoutPath.rootPath(this, l -&gt; 0L), path -&gt; path.map(op),
459                 EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE), elements);
460     }
461 
462     private static &lt;Z&gt; Z computePathOp(LayoutPath path, Function&lt;LayoutPath, Z&gt; finalizer,
463                                        Set&lt;LayoutPath.PathElementImpl.PathKind&gt; badKinds, PathElement... elements) {
464         for (PathElement e : elements) {
465             LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)e;
466             if (badKinds.contains(pathElem.kind())) {
467                 throw new IllegalArgumentException(String.format(&quot;Invalid %s selection in layout path&quot;, pathElem.kind().description()));
468             }
469             path = pathElem.apply(path);
470         }
471         return finalizer.apply(path);
472     }
473 
474     /**
<a name="12" id="anc12"></a><span class="line-added">475 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
476      * Is this a padding layout (e.g. a layout created from {@link #ofPaddingBits(long)}) ?
<a name="13" id="anc13"></a><span class="line-added">477 =======</span>
<span class="line-added">478      * Is this a padding layout (e.g. a layout created from {@link #ofPaddingBits(long)} ?</span>
<span class="line-added">479 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
480      * @return true, if this layout is a padding layout.
481      */
482     boolean isPadding();
483 
484     /**
485      * Instances of this class are used to form &lt;a href=&quot;MemoryLayout.html#layout-paths&quot;&gt;&lt;em&gt;layout paths&lt;/em&gt;&lt;/a&gt;. There
486      * are two kinds of path elements: &lt;em&gt;group path elements&lt;/em&gt; and &lt;em&gt;sequence path elements&lt;/em&gt;. Group
487      * path elements are used to select a given named member layout within a {@link GroupLayout}. Sequence
488      * path elements are used to select a sequence element layout within a {@link SequenceLayout}; selection
489      * of sequence element layout can be &lt;em&gt;explicit&lt;/em&gt; (see {@link PathElement#sequenceElement(long)}) or
490      * &lt;em&gt;implicit&lt;/em&gt; (see {@link PathElement#sequenceElement()}). When a path uses one or more implicit
491      * sequence path elements, it acquires additional &lt;em&gt;free dimensions&lt;/em&gt;.
492      * &lt;p&gt;
493      * Non-platform classes should not implement {@linkplain PathElement} directly.
494      *
495      * @apiNote In the future, if the Java language permits, {@link PathElement}
496      * may become a {@code sealed} interface, which would prohibit subclassing except by
497      * explicitly permitted types.
498      *
499      * @implSpec
500      * Implementations of this interface are immutable and thread-safe.
501      */
502     interface PathElement {
503 
504         /**
505          * Returns a path element which selects a member layout with given name from a given group layout.
506          * The path element returned by this method does not alter the number of free dimensions of any path
507          * that is combined with such element.
508          *
509          * @implSpec in case multiple group elements with a matching name exist, the path element returned by this
510          * method will select the first one; that is, the group element with lowest offset from current path is selected.
511          *
512          * @param name the name of the group element to be selected.
513          * @return a path element which selects the group element with given name.
514          * @throws NullPointerException if the specified group element name is {@code null}.
515          */
516         static PathElement groupElement(String name) {
517             Objects.requireNonNull(name);
518             return new LayoutPath.PathElementImpl(LayoutPath.PathElementImpl.PathKind.GROUP_ELEMENT,
519                                                   path -&gt; path.groupElement(name));
520         }
521 
522         /**
523          * Returns a path element which selects the element layout at the specified position in a given the sequence layout.
524          * The path element returned by this method does not alter the number of free dimensions of any path
525          * that is combined with such element.
526          *
527          * @param index the index of the sequence element to be selected.
528          * @return a path element which selects the sequence element layout with given index.
529          * @throws IllegalArgumentException if {@code index &lt; 0}.
530          */
531         static PathElement sequenceElement(long index) {
532             if (index &lt; 0) {
533                 throw new IllegalArgumentException(&quot;Index must be positive: &quot; + index);
534             }
535             return new LayoutPath.PathElementImpl(LayoutPath.PathElementImpl.PathKind.SEQUENCE_ELEMENT_INDEX,
536                                                   path -&gt; path.sequenceElement(index));
537         }
538 
539         /**
540          * Returns a path element which selects the element layout in a &lt;em&gt;range&lt;/em&gt; of positions in a given the sequence layout,
541          * where the range is expressed as a pair of starting index (inclusive) {@code S} and step factor (which can also be negative)
542          * {@code F}.
543          * If a path with free dimensions {@code n} is combined with the path element returned by this method,
544          * the number of free dimensions of the resulting path will be {@code 1 + n}. If the free dimension associated
545          * with this path is bound by an index {@code I}, the resulting accessed offset can be obtained with the following
546          * formula:
547          * &lt;blockquote&gt;&lt;pre&gt;{@code
548 E * (S + I * F)
549          * }&lt;/pre&gt;&lt;/blockquote&gt;
550          * where {@code E} is the size (in bytes) of the sequence element layout.
551          *
552          * @param start the index of the first sequence element to be selected.
553          * @param step the step factor at which subsequence sequence elements are to be selected.
554          * @return a path element which selects the sequence element layout with given index.
555          * @throws IllegalArgumentException if {@code start &lt; 0}, or {@code step == 0}.
556          */
557         static PathElement sequenceElement(long start, long step) {
558             if (start &lt; 0) {
559                 throw new IllegalArgumentException(&quot;Start index must be positive: &quot; + start);
560             }
561             if (step == 0) {
562                 throw new IllegalArgumentException(&quot;Step must be != 0: &quot; + step);
563             }
564             return new LayoutPath.PathElementImpl(LayoutPath.PathElementImpl.PathKind.SEQUENCE_RANGE,
565                                                   path -&gt; path.sequenceElement(start, step));
566         }
567 
568         /**
569          * Returns a path element which selects an unspecified element layout from a given sequence layout.
570          * If a path with free dimensions {@code n} is combined with the path element returned by this method,
571          * the number of free dimensions of the resulting path will be {@code 1 + n}.
572          *
573          * @return a path element which selects an unspecified sequence element layout.
574          */
575         static PathElement sequenceElement() {
576             return new LayoutPath.PathElementImpl(LayoutPath.PathElementImpl.PathKind.SEQUENCE_ELEMENT,
577                                                   LayoutPath::sequenceElement);
578         }
579     }
580 
581     /**
582      * Compares the specified object with this layout for equality. Returns {@code true} if and only if the specified
583      * object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of
584      * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional
585      * conditions must be satisfied:
586      * &lt;ul&gt;
587      *     &lt;li&gt;two value layouts are considered equal if they have the same byte order (see {@link ValueLayout#order()})&lt;/li&gt;
588      *     &lt;li&gt;two sequence layouts are considered equal if they have the same element count (see {@link SequenceLayout#elementCount()}), and
589      *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal&lt;/li&gt;
590      *     &lt;li&gt;two group layouts are considered equal if they are of the same kind (see {@link GroupLayout#isStruct()},
591      *     {@link GroupLayout#isUnion()}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal&lt;/li&gt;
592      * &lt;/ul&gt;
593      *
594      * @param that the object to be compared for equality with this layout.
595      * @return {@code true} if the specified object is equal to this layout.
596      */
597     boolean equals(Object that);
598 
599     /**
600      * Returns the hash code value for this layout.
601      *
602      * @return the hash code value for this layout.
603      */
604     int hashCode();
605 
606     /**
607      * Returns a string representation of this layout.
608      *
609      * @return a string representation of this layout.
610      */
611     @Override
612     String toString();
613 
614     /**
615      * Create a new padding layout with given size.
616      *
617      * @param size the padding size in bits.
618      * @return the new selector layout.
619      * @throws IllegalArgumentException if {@code size &lt;= 0}.
620      */
621     static MemoryLayout ofPaddingBits(long size) {
622         AbstractLayout.checkSize(size);
623         return new PaddingLayout(size);
624     }
625 
626     /**
627      * Create a value layout of given byte order and size.
628      *
629      * @param size the value layout size.
630      * @param order the value layout&#39;s byte order.
631      * @return a new value layout.
632      * @throws IllegalArgumentException if {@code size &lt;= 0}.
633      */
634     static ValueLayout ofValueBits(long size, ByteOrder order) {
635         AbstractLayout.checkSize(size);
636         return new ValueLayout(order, size);
637     }
638 
639     /**
640      * Create a new sequence layout with given element layout and element count.
641      *
642      * @param elementCount the sequence element count.
643      * @param elementLayout the sequence element layout.
644      * @return the new sequence layout with given element layout and size.
645      * @throws IllegalArgumentException if {@code elementCount &lt; 0}.
646      */
647     static SequenceLayout ofSequence(long elementCount, MemoryLayout elementLayout) {
648         AbstractLayout.checkSize(elementCount, true);
649         OptionalLong size = OptionalLong.of(elementCount);
650         return new SequenceLayout(size, elementLayout);
651     }
652 
653     /**
654      * Create a new sequence layout, with unbounded element count and given element layout.
655      *
656      * @param elementLayout the element layout of the sequence layout.
657      * @return the new sequence layout with given element layout.
658      */
659     static SequenceLayout ofSequence(MemoryLayout elementLayout) {
660         return new SequenceLayout(OptionalLong.empty(), elementLayout);
661     }
662 
663     /**
664      * Create a new &lt;em&gt;struct&lt;/em&gt; group layout with given member layouts.
665      *
666      * @param elements The member layouts of the &lt;em&gt;struct&lt;/em&gt; group layout.
667      * @return a new &lt;em&gt;struct&lt;/em&gt; group layout with given member layouts.
668      */
669     static GroupLayout ofStruct(MemoryLayout... elements) {
670         return new GroupLayout(GroupLayout.Kind.STRUCT, List.of(elements));
671     }
672 
673     /**
674      * Create a new &lt;em&gt;union&lt;/em&gt; group layout with given member layouts.
675      *
676      * @param elements The member layouts of the &lt;em&gt;union&lt;/em&gt; layout.
677      * @return a new &lt;em&gt;union&lt;/em&gt; group layout with given member layouts.
678      */
679     static GroupLayout ofUnion(MemoryLayout... elements) {
680         return new GroupLayout(GroupLayout.Kind.UNION, List.of(elements));
681     }
682 
683     /**
684      * Attribute name used to specify the &lt;em&gt;name&lt;/em&gt; property of a memory layout (see {@link #name()} and {@link #withName(String)}).
685      */
686     String LAYOUT_NAME = &quot;layout/name&quot;;
687 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
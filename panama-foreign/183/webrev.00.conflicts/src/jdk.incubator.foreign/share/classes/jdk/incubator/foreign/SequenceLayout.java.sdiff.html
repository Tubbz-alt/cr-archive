<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SequenceLayout.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemorySegment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SequenceLayout.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 97     public OptionalLong elementCount() {
 98         return elemCount;
 99     }
100 
101     /**
102      * Obtains a new sequence layout with same element layout, alignment constraints and name as this sequence layout
103      * but with the new specified element count.
104      * @param elementCount the new element count.
105      * @return a new sequence with given element count.
106      * @throws IllegalArgumentException if {@code elementCount &lt; 0}.
107      */
108     public SequenceLayout withElementCount(long elementCount) {
109         AbstractLayout.checkSize(elementCount, true);
110         return new SequenceLayout(OptionalLong.of(elementCount), elementLayout, alignment, attributes);
111     }
112 
113     /**
114      * Returns a new sequence layout where element layouts in the flattened projection of this
115      * sequence layout (see {@link #flatten()}) are re-arranged into one or more nested sequence layouts
116      * according to the provided element counts. This transformation preserves the layout size;

117      * that is, multiplying the provided element counts must yield the same element count



118      * as the flattened projection of this sequence layout.
119      * &lt;p&gt;
120      * For instance, given a sequence layout of the kind:
121      * &lt;pre&gt;{@code
122     var seq = MemoryLayout.ofSequence(4, MemoryLayout.ofSequence(3, MemoryLayouts.JAVA_INT));
123      * }&lt;/pre&gt;
124      * calling {@code seq.reshape(2, 6)} will yield the following sequence layout:
125      * &lt;pre&gt;{@code
126     var reshapeSeq = MemoryLayout.ofSequence(2, MemoryLayout.ofSequence(6, MemoryLayouts.JAVA_INT));
127      * }&lt;/pre&gt;
128      * &lt;p&gt;
129      * If one of the provided element count is the special value {@code -1}, then the element
130      * count in that position will be inferred from the remaining element counts and the
131      * element count of the flattened projection of this layout. For instance, a layout equivalent to
132      * the above {@code reshapeSeq} can also be computed in the following ways:
133      * &lt;pre&gt;{@code
134     var reshapeSeqImplicit1 = seq.reshape(-1, 6);
135     var reshapeSeqImplicit2 = seq.reshape(2, -1);
136      * }&lt;/pre&gt;
137      * @param elementCounts an array of element counts, of which at most one can be {@code -1}.
</pre>
</td>
<td>
<hr />
<pre>
 97     public OptionalLong elementCount() {
 98         return elemCount;
 99     }
100 
101     /**
102      * Obtains a new sequence layout with same element layout, alignment constraints and name as this sequence layout
103      * but with the new specified element count.
104      * @param elementCount the new element count.
105      * @return a new sequence with given element count.
106      * @throws IllegalArgumentException if {@code elementCount &lt; 0}.
107      */
108     public SequenceLayout withElementCount(long elementCount) {
109         AbstractLayout.checkSize(elementCount, true);
110         return new SequenceLayout(OptionalLong.of(elementCount), elementLayout, alignment, attributes);
111     }
112 
113     /**
114      * Returns a new sequence layout where element layouts in the flattened projection of this
115      * sequence layout (see {@link #flatten()}) are re-arranged into one or more nested sequence layouts
116      * according to the provided element counts. This transformation preserves the layout size;
<span class="line-added">117 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
118      * that is, multiplying the provided element counts must yield the same element count
<span class="line-added">119 =======</span>
<span class="line-added">120      * that is, multiplying the provided element counts should yield the same element count</span>
<span class="line-added">121 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
122      * as the flattened projection of this sequence layout.
123      * &lt;p&gt;
124      * For instance, given a sequence layout of the kind:
125      * &lt;pre&gt;{@code
126     var seq = MemoryLayout.ofSequence(4, MemoryLayout.ofSequence(3, MemoryLayouts.JAVA_INT));
127      * }&lt;/pre&gt;
128      * calling {@code seq.reshape(2, 6)} will yield the following sequence layout:
129      * &lt;pre&gt;{@code
130     var reshapeSeq = MemoryLayout.ofSequence(2, MemoryLayout.ofSequence(6, MemoryLayouts.JAVA_INT));
131      * }&lt;/pre&gt;
132      * &lt;p&gt;
133      * If one of the provided element count is the special value {@code -1}, then the element
134      * count in that position will be inferred from the remaining element counts and the
135      * element count of the flattened projection of this layout. For instance, a layout equivalent to
136      * the above {@code reshapeSeq} can also be computed in the following ways:
137      * &lt;pre&gt;{@code
138     var reshapeSeqImplicit1 = seq.reshape(-1, 6);
139     var reshapeSeqImplicit2 = seq.reshape(2, -1);
140      * }&lt;/pre&gt;
141      * @param elementCounts an array of element counts, of which at most one can be {@code -1}.
</pre>
</td>
</tr>
</table>
<center><a href="MemorySegment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemoryHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemorySegment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 80  *     &lt;li&gt;for a padding layout &lt;em&gt;L&lt;/em&gt;, the natural alignment is 1, regardless of its size; that is, in the absence
 81  *     of an explicit alignment constraint, a padding layout should not affect the alignment constraint of the group
 82  *     layout it is nested into&lt;/li&gt;
 83  *     &lt;li&gt;for a value layout &lt;em&gt;L&lt;/em&gt; whose size is &lt;em&gt;N&lt;/em&gt;, the natural alignment of &lt;em&gt;L&lt;/em&gt; is &lt;em&gt;N&lt;/em&gt;&lt;/li&gt;
 84  *     &lt;li&gt;for a sequence layout &lt;em&gt;S&lt;/em&gt; whose element layout is &lt;em&gt;E&lt;/em&gt;, the natural alignment of &lt;em&gt;S&lt;/em&gt; is that of &lt;em&gt;E&lt;/em&gt;&lt;/li&gt;
 85  *     &lt;li&gt;for a group layout &lt;em&gt;G&lt;/em&gt; with member layouts &lt;em&gt;M1&lt;/em&gt;, &lt;em&gt;M2&lt;/em&gt;, ... &lt;em&gt;Mn&lt;/em&gt; whose alignments are
 86  *     &lt;em&gt;A1&lt;/em&gt;, &lt;em&gt;A2&lt;/em&gt;, ... &lt;em&gt;An&lt;/em&gt;, respectively, the natural alignment of &lt;em&gt;G&lt;/em&gt; is &lt;em&gt;max(A1, A2 ... An)&lt;/em&gt;&lt;/li&gt;
 87  * &lt;/ul&gt;
 88  * A layout&#39;s natural alignment can be overridden if needed (see {@link MemoryLayout#withBitAlignment(long)}), which can be useful to describe
 89  * hyper-aligned layouts.
 90  * &lt;p&gt;
 91  * All value layouts have an &lt;em&gt;explicit&lt;/em&gt; byte order (see {@link java.nio.ByteOrder}) which is set when the layout is created.
 92  *
 93  * &lt;h2&gt;&lt;a id = &quot;layout-paths&quot;&gt;Layout paths&lt;/a&gt;&lt;/h2&gt;
 94  *
 95  * A &lt;em&gt;layout path&lt;/em&gt; originates from a &lt;em&gt;root&lt;/em&gt; layout (typically a group or a sequence layout) and terminates
 96  * at a layout nested within the root layout - this is the layout &lt;em&gt;selected&lt;/em&gt; by the layout path.
 97  * Layout paths are typically expressed as a sequence of one or more {@link PathElement} instances.
 98  * &lt;p&gt;
 99  * Layout paths are for example useful in order to obtain offsets of arbitrarily nested layouts inside another layout
<span class="line-modified">100  * (see {@link MemoryLayout#offset(PathElement...)}), to quickly obtain a memory access handle corresponding to the selected</span>
101  * layout (see {@link MemoryLayout#varHandle(Class, PathElement...)}), to select an arbitrarily nested layout inside
102  * another layout (see {@link MemoryLayout#select(PathElement...)}, or to transform a nested layout element inside
103  * another layout (see {@link MemoryLayout#map(UnaryOperator, PathElement...)}).
104  * &lt;p&gt;
105  * Such &lt;em&gt;layout paths&lt;/em&gt; can be constructed programmatically using the methods in this class.
106  * For instance, given a layout constructed as follows:
107  * &lt;blockquote&gt;&lt;pre&gt;{@code
108 SequenceLayout seq = MemoryLayout.ofSequence(5,
109     MemoryLayout.ofStruct(
110         MemoryLayout.ofPaddingBits(32),
111         MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName(&quot;value&quot;)
112 ));
113  * }&lt;/pre&gt;&lt;/blockquote&gt;
114  *
<span class="line-modified">115  * We can obtain the offset of the member layout named &lt;code&gt;value&lt;/code&gt; from &lt;code&gt;seq&lt;/code&gt;, as follows:</span>
116  * &lt;blockquote&gt;&lt;pre&gt;{@code
<span class="line-modified">117 long valueOffset = seq.addOffset(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));</span>



















118  * }&lt;/pre&gt;&lt;/blockquote&gt;
119  *
120  * Similarly, we can select the member layout named {@code value}, as follows:
121  * &lt;blockquote&gt;&lt;pre&gt;{@code
122 MemoryLayout value = seq.select(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
123  * }&lt;/pre&gt;&lt;/blockquote&gt;
124  *
125  * And, we can also replace the layout named {@code value} with another layout, as follows:
126  * &lt;blockquote&gt;&lt;pre&gt;{@code
127 MemoryLayout newSeq = seq.map(l -&gt; MemoryLayout.ofPadding(32), PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
128  * }&lt;/pre&gt;&lt;/blockquote&gt;
129  *
130  * That is, the above declaration is identical to the following, more verbose one:
131  * &lt;blockquote&gt;&lt;pre&gt;{@code
132 MemoryLayout newSeq = MemoryLayout.ofSequence(5,
133     MemoryLayout.ofStruct(
134         MemoryLayout.ofPaddingBits(32),
135         MemoryLayout.ofPaddingBits(32)
136 ));
137  * }&lt;/pre&gt;&lt;/blockquote&gt;
</pre>
<hr />
<pre>
286      * then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bytes) associated with this layout.
287      *
288      * @return the layout alignment constraint, in bytes.
289      * @throws UnsupportedOperationException if {@code bitAlignment()} is not a multiple of 8.
290      */
291     default long byteAlignment() {
292         return Utils.bitsToBytesOrThrow(bitAlignment(),
293                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte alignment; bit alignment is not a multiple of 8&quot;));
294     }
295 
296     /**
297      * Creates a new layout which features the desired alignment constraint.
298      *
299      * @param bitAlignment the layout alignment constraint, expressed in bits.
300      * @return a new layout which is the same as this layout, except for the alignment constraint associated to it.
301      * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it&#39;s less than than 8.
302      */
303     MemoryLayout withBitAlignment(long bitAlignment);
304 
305     /**

306      * Returns the attribute with the given name (if it exists).
307      *
308      * @param name the attribute name
309      * @return the attribute with the given name (if it exists).






310      */
311     Optional&lt;Constable&gt; attribute(String name);
312 
313     /**

314      * Returns a new memory layout which features the same attributes as this layout, plus the newly specified attribute.
315      * If this layout already contains an attribute with the same name, the existing attribute value is overwritten in the returned
316      * layout.
317      *
318      * @param name the attribute name.
319      * @param value the attribute value.
320      * @return a new memory layout which features the same attributes as this layout, plus the newly specified attribute.







321      */
322     MemoryLayout withAttribute(String name, Constable value);
323 
324     /**

325      * Returns a stream of the attribute names associated with this layout.
326      *
327      * @return a stream of the attribute names associated with this layout.





328      */
329     Stream&lt;String&gt; attributes();
330 
331     /**
332      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
333      * layout.
334      *
335      * @apiNote if the layout path has one (or more) free dimensions,
336      * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.
337      *
338      * @param elements the layout path elements.
339      * @return The offset, in bits, of the layout selected by the layout path in {@code elements}.
340      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the
341      * layout path contains one or more path elements that select multiple sequence element indices
342      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).
343      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.
344      */
<span class="line-modified">345     default long offset(PathElement... elements) {</span>
346         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset, EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);
347     }
348 




















349     /**
350      * Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path,
351      * where the path is considered rooted in this layout.
352      *
353      * @apiNote the resulting var handle will feature an additional {@code long} access coordinate for every
354      * unspecified sequence access component contained in this layout path. Moreover, the resulting var handle
355      * features certain &lt;a href=&quot;MemoryHandles.html#memaccess-mode&quot;&gt;access mode restrictions&lt;/a&gt;, which are common to all memory access var handles.
356      *
357      * @param carrier the var handle carrier type.
358      * @param elements the layout path elements.
359      * @return a var handle which can be used to dereference memory at the (possibly nested) layout selected by the layout path in {@code elements}.
360      * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraints,
361      * or if one of the layouts traversed by the layout path has unspecified size.
362      * @throws IllegalArgumentException if the carrier does not represent a primitive type, if the carrier is {@code void},
363      * {@code boolean}, or if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}),
364      * or if the selected value layout has a size that that does not match that of the specified carrier type.
365      */
366     default VarHandle varHandle(Class&lt;?&gt; carrier, PathElement... elements) {
367         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), path -&gt; path.dereferenceHandle(carrier),
368                 Set.of(), elements);
</pre>
<hr />
<pre>
395      * (see {@link PathElement#sequenceElement(long)} and {@link PathElement#sequenceElement(long, long)}).
396      */
397     default MemoryLayout map(UnaryOperator&lt;MemoryLayout&gt; op, PathElement... elements) {
398         return computePathOp(LayoutPath.rootPath(this, l -&gt; 0L), path -&gt; path.map(op),
399                 EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE), elements);
400     }
401 
402     private static &lt;Z&gt; Z computePathOp(LayoutPath path, Function&lt;LayoutPath, Z&gt; finalizer,
403                                        Set&lt;LayoutPath.PathElementImpl.PathKind&gt; badKinds, PathElement... elements) {
404         for (PathElement e : elements) {
405             LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)e;
406             if (badKinds.contains(pathElem.kind())) {
407                 throw new IllegalArgumentException(String.format(&quot;Invalid %s selection in layout path&quot;, pathElem.kind().description()));
408             }
409             path = pathElem.apply(path);
410         }
411         return finalizer.apply(path);
412     }
413 
414     /**

415      * Is this a padding layout (e.g. a layout created from {@link #ofPaddingBits(long)}) ?



416      * @return true, if this layout is a padding layout.
417      */
418     boolean isPadding();
419 
420     /**
421      * Instances of this class are used to form &lt;a href=&quot;MemoryLayout.html#layout-paths&quot;&gt;&lt;em&gt;layout paths&lt;/em&gt;&lt;/a&gt;. There
422      * are two kinds of path elements: &lt;em&gt;group path elements&lt;/em&gt; and &lt;em&gt;sequence path elements&lt;/em&gt;. Group
423      * path elements are used to select a given named member layout within a {@link GroupLayout}. Sequence
424      * path elements are used to select a sequence element layout within a {@link SequenceLayout}; selection
425      * of sequence element layout can be &lt;em&gt;explicit&lt;/em&gt; (see {@link PathElement#sequenceElement(long)}) or
426      * &lt;em&gt;implicit&lt;/em&gt; (see {@link PathElement#sequenceElement()}). When a path uses one or more implicit
427      * sequence path elements, it acquires additional &lt;em&gt;free dimensions&lt;/em&gt;.
428      * &lt;p&gt;
429      * Non-platform classes should not implement {@linkplain PathElement} directly.
430      *
431      * @apiNote In the future, if the Java language permits, {@link PathElement}
432      * may become a {@code sealed} interface, which would prohibit subclassing except by
433      * explicitly permitted types.
434      *
435      * @implSpec
</pre>
</td>
<td>
<hr />
<pre>
 80  *     &lt;li&gt;for a padding layout &lt;em&gt;L&lt;/em&gt;, the natural alignment is 1, regardless of its size; that is, in the absence
 81  *     of an explicit alignment constraint, a padding layout should not affect the alignment constraint of the group
 82  *     layout it is nested into&lt;/li&gt;
 83  *     &lt;li&gt;for a value layout &lt;em&gt;L&lt;/em&gt; whose size is &lt;em&gt;N&lt;/em&gt;, the natural alignment of &lt;em&gt;L&lt;/em&gt; is &lt;em&gt;N&lt;/em&gt;&lt;/li&gt;
 84  *     &lt;li&gt;for a sequence layout &lt;em&gt;S&lt;/em&gt; whose element layout is &lt;em&gt;E&lt;/em&gt;, the natural alignment of &lt;em&gt;S&lt;/em&gt; is that of &lt;em&gt;E&lt;/em&gt;&lt;/li&gt;
 85  *     &lt;li&gt;for a group layout &lt;em&gt;G&lt;/em&gt; with member layouts &lt;em&gt;M1&lt;/em&gt;, &lt;em&gt;M2&lt;/em&gt;, ... &lt;em&gt;Mn&lt;/em&gt; whose alignments are
 86  *     &lt;em&gt;A1&lt;/em&gt;, &lt;em&gt;A2&lt;/em&gt;, ... &lt;em&gt;An&lt;/em&gt;, respectively, the natural alignment of &lt;em&gt;G&lt;/em&gt; is &lt;em&gt;max(A1, A2 ... An)&lt;/em&gt;&lt;/li&gt;
 87  * &lt;/ul&gt;
 88  * A layout&#39;s natural alignment can be overridden if needed (see {@link MemoryLayout#withBitAlignment(long)}), which can be useful to describe
 89  * hyper-aligned layouts.
 90  * &lt;p&gt;
 91  * All value layouts have an &lt;em&gt;explicit&lt;/em&gt; byte order (see {@link java.nio.ByteOrder}) which is set when the layout is created.
 92  *
 93  * &lt;h2&gt;&lt;a id = &quot;layout-paths&quot;&gt;Layout paths&lt;/a&gt;&lt;/h2&gt;
 94  *
 95  * A &lt;em&gt;layout path&lt;/em&gt; originates from a &lt;em&gt;root&lt;/em&gt; layout (typically a group or a sequence layout) and terminates
 96  * at a layout nested within the root layout - this is the layout &lt;em&gt;selected&lt;/em&gt; by the layout path.
 97  * Layout paths are typically expressed as a sequence of one or more {@link PathElement} instances.
 98  * &lt;p&gt;
 99  * Layout paths are for example useful in order to obtain offsets of arbitrarily nested layouts inside another layout
<span class="line-modified">100  * (see {@link MemoryLayout#bitOffset(PathElement...)}), to quickly obtain a memory access handle corresponding to the selected</span>
101  * layout (see {@link MemoryLayout#varHandle(Class, PathElement...)}), to select an arbitrarily nested layout inside
102  * another layout (see {@link MemoryLayout#select(PathElement...)}, or to transform a nested layout element inside
103  * another layout (see {@link MemoryLayout#map(UnaryOperator, PathElement...)}).
104  * &lt;p&gt;
105  * Such &lt;em&gt;layout paths&lt;/em&gt; can be constructed programmatically using the methods in this class.
106  * For instance, given a layout constructed as follows:
107  * &lt;blockquote&gt;&lt;pre&gt;{@code
108 SequenceLayout seq = MemoryLayout.ofSequence(5,
109     MemoryLayout.ofStruct(
110         MemoryLayout.ofPaddingBits(32),
111         MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName(&quot;value&quot;)
112 ));
113  * }&lt;/pre&gt;&lt;/blockquote&gt;
114  *
<span class="line-modified">115  * We can obtain the offset, in bits, of the member layout named &lt;code&gt;value&lt;/code&gt; from &lt;code&gt;seq&lt;/code&gt;, as follows:</span>
116  * &lt;blockquote&gt;&lt;pre&gt;{@code
<span class="line-modified">117 long valueOffset = seq.bitOffset(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));</span>
<span class="line-added">118  * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">119  *</span>
<span class="line-added">120  * Similarly, we can select the member layout named {@code value}, as follows:</span>
<span class="line-added">121  * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">122 MemoryLayout value = seq.select(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));</span>
<span class="line-added">123  * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">124  *</span>
<span class="line-added">125  * And, we can also replace the layout named {@code value} with another layout, as follows:</span>
<span class="line-added">126  * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">127 MemoryLayout newSeq = seq.map(l -&gt; MemoryLayout.ofPadding(32), PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));</span>
<span class="line-added">128  * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">129  *</span>
<span class="line-added">130  * That is, the above declaration is identical to the following, more verbose one:</span>
<span class="line-added">131  * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">132 MemoryLayout newSeq = MemoryLayout.ofSequence(5,</span>
<span class="line-added">133     MemoryLayout.ofStruct(</span>
<span class="line-added">134         MemoryLayout.ofPaddingBits(32),</span>
<span class="line-added">135         MemoryLayout.ofPaddingBits(32)</span>
<span class="line-added">136 ));</span>
137  * }&lt;/pre&gt;&lt;/blockquote&gt;
138  *
139  * Similarly, we can select the member layout named {@code value}, as follows:
140  * &lt;blockquote&gt;&lt;pre&gt;{@code
141 MemoryLayout value = seq.select(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
142  * }&lt;/pre&gt;&lt;/blockquote&gt;
143  *
144  * And, we can also replace the layout named {@code value} with another layout, as follows:
145  * &lt;blockquote&gt;&lt;pre&gt;{@code
146 MemoryLayout newSeq = seq.map(l -&gt; MemoryLayout.ofPadding(32), PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
147  * }&lt;/pre&gt;&lt;/blockquote&gt;
148  *
149  * That is, the above declaration is identical to the following, more verbose one:
150  * &lt;blockquote&gt;&lt;pre&gt;{@code
151 MemoryLayout newSeq = MemoryLayout.ofSequence(5,
152     MemoryLayout.ofStruct(
153         MemoryLayout.ofPaddingBits(32),
154         MemoryLayout.ofPaddingBits(32)
155 ));
156  * }&lt;/pre&gt;&lt;/blockquote&gt;
</pre>
<hr />
<pre>
305      * then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bytes) associated with this layout.
306      *
307      * @return the layout alignment constraint, in bytes.
308      * @throws UnsupportedOperationException if {@code bitAlignment()} is not a multiple of 8.
309      */
310     default long byteAlignment() {
311         return Utils.bitsToBytesOrThrow(bitAlignment(),
312                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte alignment; bit alignment is not a multiple of 8&quot;));
313     }
314 
315     /**
316      * Creates a new layout which features the desired alignment constraint.
317      *
318      * @param bitAlignment the layout alignment constraint, expressed in bits.
319      * @return a new layout which is the same as this layout, except for the alignment constraint associated to it.
320      * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it&#39;s less than than 8.
321      */
322     MemoryLayout withBitAlignment(long bitAlignment);
323 
324     /**
<span class="line-added">325 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
326      * Returns the attribute with the given name (if it exists).
327      *
328      * @param name the attribute name
329      * @return the attribute with the given name (if it exists).
<span class="line-added">330 =======</span>
<span class="line-added">331      * Returns the attribute with the given name if it exists, or an empty optional</span>
<span class="line-added">332      *</span>
<span class="line-added">333      * @param name the name of the attribute</span>
<span class="line-added">334      * @return the optional attribute</span>
<span class="line-added">335 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
336      */
337     Optional&lt;Constable&gt; attribute(String name);
338 
339     /**
<span class="line-added">340 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
341      * Returns a new memory layout which features the same attributes as this layout, plus the newly specified attribute.
342      * If this layout already contains an attribute with the same name, the existing attribute value is overwritten in the returned
343      * layout.
344      *
345      * @param name the attribute name.
346      * @param value the attribute value.
347      * @return a new memory layout which features the same attributes as this layout, plus the newly specified attribute.
<span class="line-added">348 =======</span>
<span class="line-added">349      * Returns a new MemoryLayout with the given additional attribute</span>
<span class="line-added">350      *</span>
<span class="line-added">351      * @param name the name of the attribute</span>
<span class="line-added">352      * @param value the value of the attribute</span>
<span class="line-added">353      * @return the new MemoryLayout</span>
<span class="line-added">354 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
355      */
356     MemoryLayout withAttribute(String name, Constable value);
357 
358     /**
<span class="line-added">359 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
360      * Returns a stream of the attribute names associated with this layout.
361      *
362      * @return a stream of the attribute names associated with this layout.
<span class="line-added">363 =======</span>
<span class="line-added">364      * Returns a stream of the names of the attributes of this layout</span>
<span class="line-added">365      *</span>
<span class="line-added">366      * @return the stream of names</span>
<span class="line-added">367 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
368      */
369     Stream&lt;String&gt; attributes();
370 
371     /**
372      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
373      * layout.
374      *
375      * @apiNote if the layout path has one (or more) free dimensions,
376      * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.
377      *
378      * @param elements the layout path elements.
379      * @return The offset, in bits, of the layout selected by the layout path in {@code elements}.
380      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the
381      * layout path contains one or more path elements that select multiple sequence element indices
382      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).
383      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.
384      */
<span class="line-modified">385     default long bitOffset(PathElement... elements) {</span>
386         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset, EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);
387     }
388 
<span class="line-added">389     /**</span>
<span class="line-added">390      * Computes the offset, in bytes, of the layout selected by a given layout path, where the path is considered rooted in this</span>
<span class="line-added">391      * layout.</span>
<span class="line-added">392      *</span>
<span class="line-added">393      * @apiNote if the layout path has one (or more) free dimensions,</span>
<span class="line-added">394      * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.</span>
<span class="line-added">395      *</span>
<span class="line-added">396      * @param elements the layout path elements.</span>
<span class="line-added">397      * @return The offset, in bytes, of the layout selected by the layout path in {@code elements}.</span>
<span class="line-added">398      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the</span>
<span class="line-added">399      * layout path contains one or more path elements that select multiple sequence element indices</span>
<span class="line-added">400      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).</span>
<span class="line-added">401      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size,</span>
<span class="line-added">402      * or if {@code bitOffset(elements)} is not a multiple of 8.</span>
<span class="line-added">403      */</span>
<span class="line-added">404     default long byteOffset(PathElement... elements) {</span>
<span class="line-added">405         return Utils.bitsToBytesOrThrow(bitOffset(elements),</span>
<span class="line-added">406                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte offset; bit offset is not a multiple of 8&quot;));</span>
<span class="line-added">407     }</span>
<span class="line-added">408 </span>
409     /**
410      * Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path,
411      * where the path is considered rooted in this layout.
412      *
413      * @apiNote the resulting var handle will feature an additional {@code long} access coordinate for every
414      * unspecified sequence access component contained in this layout path. Moreover, the resulting var handle
415      * features certain &lt;a href=&quot;MemoryHandles.html#memaccess-mode&quot;&gt;access mode restrictions&lt;/a&gt;, which are common to all memory access var handles.
416      *
417      * @param carrier the var handle carrier type.
418      * @param elements the layout path elements.
419      * @return a var handle which can be used to dereference memory at the (possibly nested) layout selected by the layout path in {@code elements}.
420      * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraints,
421      * or if one of the layouts traversed by the layout path has unspecified size.
422      * @throws IllegalArgumentException if the carrier does not represent a primitive type, if the carrier is {@code void},
423      * {@code boolean}, or if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}),
424      * or if the selected value layout has a size that that does not match that of the specified carrier type.
425      */
426     default VarHandle varHandle(Class&lt;?&gt; carrier, PathElement... elements) {
427         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), path -&gt; path.dereferenceHandle(carrier),
428                 Set.of(), elements);
</pre>
<hr />
<pre>
455      * (see {@link PathElement#sequenceElement(long)} and {@link PathElement#sequenceElement(long, long)}).
456      */
457     default MemoryLayout map(UnaryOperator&lt;MemoryLayout&gt; op, PathElement... elements) {
458         return computePathOp(LayoutPath.rootPath(this, l -&gt; 0L), path -&gt; path.map(op),
459                 EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE), elements);
460     }
461 
462     private static &lt;Z&gt; Z computePathOp(LayoutPath path, Function&lt;LayoutPath, Z&gt; finalizer,
463                                        Set&lt;LayoutPath.PathElementImpl.PathKind&gt; badKinds, PathElement... elements) {
464         for (PathElement e : elements) {
465             LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)e;
466             if (badKinds.contains(pathElem.kind())) {
467                 throw new IllegalArgumentException(String.format(&quot;Invalid %s selection in layout path&quot;, pathElem.kind().description()));
468             }
469             path = pathElem.apply(path);
470         }
471         return finalizer.apply(path);
472     }
473 
474     /**
<span class="line-added">475 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
476      * Is this a padding layout (e.g. a layout created from {@link #ofPaddingBits(long)}) ?
<span class="line-added">477 =======</span>
<span class="line-added">478      * Is this a padding layout (e.g. a layout created from {@link #ofPaddingBits(long)} ?</span>
<span class="line-added">479 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
480      * @return true, if this layout is a padding layout.
481      */
482     boolean isPadding();
483 
484     /**
485      * Instances of this class are used to form &lt;a href=&quot;MemoryLayout.html#layout-paths&quot;&gt;&lt;em&gt;layout paths&lt;/em&gt;&lt;/a&gt;. There
486      * are two kinds of path elements: &lt;em&gt;group path elements&lt;/em&gt; and &lt;em&gt;sequence path elements&lt;/em&gt;. Group
487      * path elements are used to select a given named member layout within a {@link GroupLayout}. Sequence
488      * path elements are used to select a sequence element layout within a {@link SequenceLayout}; selection
489      * of sequence element layout can be &lt;em&gt;explicit&lt;/em&gt; (see {@link PathElement#sequenceElement(long)}) or
490      * &lt;em&gt;implicit&lt;/em&gt; (see {@link PathElement#sequenceElement()}). When a path uses one or more implicit
491      * sequence path elements, it acquires additional &lt;em&gt;free dimensions&lt;/em&gt;.
492      * &lt;p&gt;
493      * Non-platform classes should not implement {@linkplain PathElement} directly.
494      *
495      * @apiNote In the future, if the Java language permits, {@link PathElement}
496      * may become a {@code sealed} interface, which would prohibit subclassing except by
497      * explicitly permitted types.
498      *
499      * @implSpec
</pre>
</td>
</tr>
</table>
<center><a href="MemoryHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemorySegment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
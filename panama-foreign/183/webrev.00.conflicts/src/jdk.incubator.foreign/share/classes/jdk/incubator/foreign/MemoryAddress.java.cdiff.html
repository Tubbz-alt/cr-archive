<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MappedMemorySegment.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemoryHandles.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 65,10 ***</span>
<span class="line-new-header">--- 65,11 ---</span>
      /**
       * Returns the offset of this memory address into the underlying segment (if any).
       * @return the offset of this memory address into the underlying segment (if any).
       * @throws UnsupportedOperationException if no segment is associated with this memory address,
       * e.g. if {@code segment() == null}.
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
       */
      long segmentOffset();
  
      /**
       * Returns the raw long value associated to this memory address.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 76,10 ***</span>
<span class="line-new-header">--- 77,23 ---</span>
       * @throws UnsupportedOperationException if this memory address is associated with an heap segment.
       */
      long toRawLongValue();
  
      /**
<span class="line-added">+ =======</span>
<span class="line-added">+      */</span>
<span class="line-added">+     long segmentOffset();</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the raw long value associated to this memory address.</span>
<span class="line-added">+      * @return The raw long value associated to this memory address.</span>
<span class="line-added">+      * @throws UnsupportedOperationException if this memory address is associated with an heap segment.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     long toRawLongValue();</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
       * Returns the memory segment (if any) this address belongs to.
       * @return The memory segment this address belongs to, or {@code null} if no such segment exists.
       */
      MemorySegment segment();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 114,10 ***</span>
<span class="line-new-header">--- 128,11 ---</span>
       */
      @Override
      int hashCode();
  
      /**
<span class="line-added">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
       * Perform bulk copy from source address to target address. More specifically, the bytes at addresses {@code src}
       * through {@code src.addOffset(bytes - 1)} are copied into addresses {@code dst} through {@code dst.addOffset(bytes - 1)}.
       * If the source and address ranges overlap, then the copying is performed as if the bytes at addresses {@code src}
       * through {@code src.addOffset(bytes - 1)} were first copied into a temporary segment with size {@code bytes},
       * and then the contents of the temporary segment were copied into the bytes at addresses {@code dst} through
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,13 ***</span>
       * @throws IllegalStateException if either the source address or the target address belong to memory segments
       * which have been already closed, or if access occurs from a thread other than the thread owning either segment.
       * @throws UnsupportedOperationException if either {@code src} or {@code dst} do not feature required access modes;
       * more specifically, {@code src} should be associated with a segment with {@link MemorySegment#READ} access mode,
       * while {@code dst} should be associated with a segment with {@link MemorySegment#WRITE} access mode.
       */
<span class="line-modified">!     static void copy(MemoryAddress src, MemoryAddress dst, long bytes) {</span>
<span class="line-modified">!         MemoryAddressImpl.copy((MemoryAddressImpl)src, (MemoryAddressImpl)dst, bytes);</span>
      }
  
      /**
       * The &lt;em&gt;unchecked&lt;/em&gt; memory address instance modelling the {@code NULL} address. This address is &lt;em&gt;not&lt;/em&gt; backed by
       * a memory segment and hence it cannot be dereferenced.
<span class="line-new-header">--- 150,27 ---</span>
       * @throws IllegalStateException if either the source address or the target address belong to memory segments
       * which have been already closed, or if access occurs from a thread other than the thread owning either segment.
       * @throws UnsupportedOperationException if either {@code src} or {@code dst} do not feature required access modes;
       * more specifically, {@code src} should be associated with a segment with {@link MemorySegment#READ} access mode,
       * while {@code dst} should be associated with a segment with {@link MemorySegment#WRITE} access mode.
<span class="line-added">+ =======</span>
<span class="line-added">+      * The &lt;em&gt;unchecked&lt;/em&gt; memory address instance modelling the {@code NULL} address. This address is &lt;em&gt;not&lt;/em&gt; backed by</span>
<span class="line-added">+      * a memory segment and hence it cannot be dereferenced.</span>
       */
<span class="line-modified">!     MemoryAddress NULL = new MemoryAddressImpl( 0L);</span>
<span class="line-modified">! </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Obtain a new &lt;em&gt;unchecked&lt;/em&gt; memory address instance from given long address. The returned address is &lt;em&gt;not&lt;/em&gt; backed by</span>
<span class="line-added">+      * a memory segment and hence it cannot be dereferenced.</span>
<span class="line-added">+      * @param value the long address.</span>
<span class="line-added">+      * @return the new memory address instance.</span>
<span class="line-added">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static MemoryAddress ofLong(long value) {</span>
<span class="line-added">+         return value == 0 ?</span>
<span class="line-added">+                 NULL :</span>
<span class="line-added">+                 new MemoryAddressImpl(value);</span>
      }
  
      /**
       * The &lt;em&gt;unchecked&lt;/em&gt; memory address instance modelling the {@code NULL} address. This address is &lt;em&gt;not&lt;/em&gt; backed by
       * a memory segment and hence it cannot be dereferenced.
</pre>
<center><a href="MappedMemorySegment.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemoryHandles.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java
@@ -46,24 +46,34 @@
  */
 public class MappedMemorySegmentImpl extends NativeMemorySegmentImpl implements MappedMemorySegment {
 
     private final UnmapperProxy unmapper;
 
+<<<<<<< HEAD
     MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, Thread owner, MemoryScope scope) {
         super(min, length, mask, owner, scope);
+=======
+    MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, MemoryScope scope) {
+        super(min, length, mask, scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         this.unmapper = unmapper;
     }
 
     @Override
     ByteBuffer makeByteBuffer() {
         JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
         return nioAccess.newMappedByteBuffer(unmapper, min, (int)length, null, this);
     }
 
     @Override
+<<<<<<< HEAD
     MappedMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
         return new MappedMemorySegmentImpl(min + offset, unmapper, size, mask, owner, scope);
+=======
+    MappedMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
+        return new MappedMemorySegmentImpl(min + offset, unmapper, size, mask, scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     // mapped segment methods
 
 
@@ -101,17 +111,23 @@
 
     public static MappedMemorySegment makeMappedSegment(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
         if (bytesSize <= 0) throw new IllegalArgumentException("Requested bytes size must be > 0.");
         try (FileChannelImpl channelImpl = (FileChannelImpl)FileChannel.open(path, openOptions(mapMode))) {
             UnmapperProxy unmapperProxy = channelImpl.mapInternal(mapMode, 0L, bytesSize);
+<<<<<<< HEAD
             MemoryScope scope = new MemoryScope(null, unmapperProxy::unmap);
             int modes = defaultAccessModes(bytesSize);
             if (mapMode == FileChannel.MapMode.READ_ONLY) {
                 modes &= ~WRITE;
             }
             return new MappedMemorySegmentImpl(unmapperProxy.address(), unmapperProxy, bytesSize,
                     modes, Thread.currentThread(), scope);
+=======
+            MemoryScope scope = MemoryScope.create(null, unmapperProxy::unmap);
+            return new MappedMemorySegmentImpl(unmapperProxy.address(), unmapperProxy, bytesSize,
+                    defaultAccessModes(bytesSize), scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         }
     }
 
     private static OpenOption[] openOptions(FileChannel.MapMode mapMode) {
         if (mapMode == FileChannel.MapMode.READ_ONLY) {

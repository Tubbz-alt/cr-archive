diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
@@ -65,10 +65,11 @@
     /**
      * Returns the offset of this memory address into the underlying segment (if any).
      * @return the offset of this memory address into the underlying segment (if any).
      * @throws UnsupportedOperationException if no segment is associated with this memory address,
      * e.g. if {@code segment() == null}.
+<<<<<<< HEAD
      */
     long segmentOffset();
 
     /**
      * Returns the raw long value associated to this memory address.
@@ -76,10 +77,23 @@
      * @throws UnsupportedOperationException if this memory address is associated with an heap segment.
      */
     long toRawLongValue();
 
     /**
+=======
+     */
+    long segmentOffset();
+
+    /**
+     * Returns the raw long value associated to this memory address.
+     * @return The raw long value associated to this memory address.
+     * @throws UnsupportedOperationException if this memory address is associated with an heap segment.
+     */
+    long toRawLongValue();
+
+    /**
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
      * Returns the memory segment (if any) this address belongs to.
      * @return The memory segment this address belongs to, or {@code null} if no such segment exists.
      */
     MemorySegment segment();
 
@@ -114,10 +128,11 @@
      */
     @Override
     int hashCode();
 
     /**
+<<<<<<< HEAD
      * Perform bulk copy from source address to target address. More specifically, the bytes at addresses {@code src}
      * through {@code src.addOffset(bytes - 1)} are copied into addresses {@code dst} through {@code dst.addOffset(bytes - 1)}.
      * If the source and address ranges overlap, then the copying is performed as if the bytes at addresses {@code src}
      * through {@code src.addOffset(bytes - 1)} were first copied into a temporary segment with size {@code bytes},
      * and then the contents of the temporary segment were copied into the bytes at addresses {@code dst} through
@@ -135,13 +150,27 @@
      * @throws IllegalStateException if either the source address or the target address belong to memory segments
      * which have been already closed, or if access occurs from a thread other than the thread owning either segment.
      * @throws UnsupportedOperationException if either {@code src} or {@code dst} do not feature required access modes;
      * more specifically, {@code src} should be associated with a segment with {@link MemorySegment#READ} access mode,
      * while {@code dst} should be associated with a segment with {@link MemorySegment#WRITE} access mode.
+=======
+     * The <em>unchecked</em> memory address instance modelling the {@code NULL} address. This address is <em>not</em> backed by
+     * a memory segment and hence it cannot be dereferenced.
      */
-    static void copy(MemoryAddress src, MemoryAddress dst, long bytes) {
-        MemoryAddressImpl.copy((MemoryAddressImpl)src, (MemoryAddressImpl)dst, bytes);
+    MemoryAddress NULL = new MemoryAddressImpl( 0L);
+
+    /**
+     * Obtain a new <em>unchecked</em> memory address instance from given long address. The returned address is <em>not</em> backed by
+     * a memory segment and hence it cannot be dereferenced.
+     * @param value the long address.
+     * @return the new memory address instance.
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
+     */
+    static MemoryAddress ofLong(long value) {
+        return value == 0 ?
+                NULL :
+                new MemoryAddressImpl(value);
     }
 
     /**
      * The <em>unchecked</em> memory address instance modelling the {@code NULL} address. This address is <em>not</em> backed by
      * a memory segment and hence it cannot be dereferenced.

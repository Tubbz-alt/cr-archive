diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -24,16 +24,26 @@
  */
 
 package jdk.internal.foreign;
 
 import jdk.incubator.foreign.MemoryAddress;
+<<<<<<< HEAD
+=======
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayouts;
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.internal.access.JavaNioAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.access.foreign.UnmapperProxy;
+<<<<<<< HEAD
+=======
+import jdk.internal.misc.Unsafe;
+import jdk.internal.util.ArraysSupport;
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 import jdk.internal.vm.annotation.ForceInline;
 import sun.security.action.GetPropertyAction;
 
 import java.lang.invoke.VarHandle;
 import java.nio.ByteBuffer;
@@ -53,10 +63,15 @@
  * are defined for each memory segment kind, see {@link NativeMemorySegmentImpl}, {@link HeapMemorySegmentImpl} and
  * {@link MappedMemorySegmentImpl}.
  */
 public abstract class AbstractMemorySegmentImpl implements MemorySegment, MemorySegmentProxy {
 
+<<<<<<< HEAD
+=======
+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     private static final boolean enableSmallSegments =
             Boolean.parseBoolean(GetPropertyAction.privilegedGetProperty("jdk.incubator.foreign.SmallSegments", "true"));
 
     final static int ACCESS_MASK = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;
     final static int FIRST_RESERVED_FLAG = 1 << 16; // upper 16 bits are reserved
@@ -66,26 +81,39 @@
 
     final static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
 
     final long length;
     final int mask;
+<<<<<<< HEAD
     final Thread owner;
     final MemoryScope scope;
 
     @ForceInline
     AbstractMemorySegmentImpl(long length, int mask, Thread owner, MemoryScope scope) {
         this.length = length;
         this.mask = mask;
         this.owner = owner;
+=======
+    final MemoryScope scope;
+
+    @ForceInline
+    AbstractMemorySegmentImpl(long length, int mask, MemoryScope scope) {
+        this.length = length;
+        this.mask = mask;
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         this.scope = scope;
     }
 
     abstract long min();
 
     abstract Object base();
 
+<<<<<<< HEAD
     abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope);
+=======
+    abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
 
     abstract ByteBuffer makeByteBuffer();
 
     static int defaultAccessModes(long size) {
         return (enableSmallSegments && size < Integer.MAX_VALUE) ?
@@ -98,11 +126,15 @@
         checkBounds(offset, newSize);
         return asSliceNoCheck(offset, newSize);
     }
 
     private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
+<<<<<<< HEAD
         return dup(offset, newSize, mask, owner, scope);
+=======
+        return dup(offset, newSize, mask, scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @SuppressWarnings("unchecked")
     public static <S extends MemorySegment> Spliterator<S> spliterator(S segment, SequenceLayout sequenceLayout) {
         ((AbstractMemorySegmentImpl)segment).checkValidState();
@@ -112,10 +144,66 @@
         return (Spliterator<S>)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() & ~CLOSE));
     }
 
     @Override
+<<<<<<< HEAD
+=======
+    public final MemorySegment fill(byte value){
+        checkRange(0, length, true);
+        UNSAFE.setMemory(base(), min(), length, value);
+        return this;
+    }
+
+    public void copyFrom(MemorySegment src) {
+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;
+        long size = that.byteSize();
+        checkRange(0, size, true);
+        that.checkRange(0, size, false);
+        UNSAFE.copyMemory(
+                that.base(), that.min(),
+                base(), min(), size);
+    }
+
+    private final static VarHandle BYTE_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
+            .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
+
+    @Override
+    public long mismatch(MemorySegment other) {
+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;
+        final long thisSize = this.byteSize();
+        final long thatSize = that.byteSize();
+        final long length = Math.min(thisSize, thatSize);
+        this.checkRange(0, length, false);
+        that.checkRange(0, length, false);
+        if (this == other) {
+            return -1;
+        }
+
+        long i = 0;
+        if (length > 7) {
+            i = ArraysSupport.vectorizedMismatchLarge(
+                    this.base(), this.min(),
+                    that.base(), that.min(),
+                    length, ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE);
+            if (i >= 0) {
+                return i;
+            }
+            i = length - ~i;
+        }
+        MemoryAddress thisAddress = this.baseAddress();
+        MemoryAddress thatAddress = that.baseAddress();
+        for (; i < length; i++) {
+            if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {
+                return i;
+            }
+        }
+        return thisSize != thatSize ? length : -1;
+    }
+
+    @Override
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     @ForceInline
     public final MemoryAddress baseAddress() {
         return new MemoryAddressImpl(this, 0);
     }
 
@@ -143,25 +231,39 @@
         return length;
     }
 
     @Override
     public final boolean isAlive() {
+<<<<<<< HEAD
         return scope.isAliveThreadSafe();
+=======
+        return scope.isAlive();
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @Override
     public Thread ownerThread() {
+<<<<<<< HEAD
         return owner;
+=======
+        return scope.ownerThread();
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @Override
     public AbstractMemorySegmentImpl withAccessModes(int accessModes) {
         checkAccessModes(accessModes);
         if ((~accessModes() & accessModes) != 0) {
+<<<<<<< HEAD
             throw new IllegalArgumentException("Cannot acquire more access modes");
         }
         return dup(0, length, (mask & ~ACCESS_MASK) | accessModes, owner, scope);
+=======
+            throw new UnsupportedOperationException("Cannot acquire more access modes");
+        }
+        return dup(0, length, (mask & ~ACCESS_MASK) | accessModes, scope);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @Override
     public boolean hasAccessModes(int accessModes) {
         checkAccessModes(accessModes);
@@ -175,10 +277,11 @@
     }
 
     @Override
     public MemorySegment withOwnerThread(Thread newOwner) {
         Objects.requireNonNull(newOwner);
+<<<<<<< HEAD
         checkValidState();
         if (!isSet(HANDOFF)) {
             throw unsupportedAccessMode(HANDOFF);
         }
         if (owner == newOwner) {
@@ -186,64 +289,99 @@
         } else {
             try {
                 return dup(0L, length, mask, newOwner, scope.dup());
             } finally {
                 //flush read/writes to memory before returning the new segment
+=======
+        if (!isSet(HANDOFF)) {
+            throw unsupportedAccessMode(HANDOFF);
+        }
+        if (scope.ownerThread() == newOwner) {
+            throw new IllegalArgumentException("Segment already owned by thread: " + newOwner);
+        } else {
+            try {
+                return dup(0L, length, mask, scope.dup(newOwner));
+            } finally {
+                //flush read/writes to segment memory before returning the new segment
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
                 VarHandle.fullFence();
             }
         }
     }
 
     @Override
     public final void close() {
         if (!isSet(CLOSE)) {
             throw unsupportedAccessMode(CLOSE);
         }
+<<<<<<< HEAD
         checkValidState();
+=======
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         closeNoCheck();
     }
 
     private final void closeNoCheck() {
+<<<<<<< HEAD
         scope.close(true);
+=======
+        scope.close();
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     final AbstractMemorySegmentImpl acquire() {
         if (Thread.currentThread() != ownerThread() && !isSet(ACQUIRE)) {
             throw unsupportedAccessMode(ACQUIRE);
         }
+<<<<<<< HEAD
         return dup(0, length, mask, Thread.currentThread(), scope.acquire());
+=======
+        return dup(0, length, mask, scope.acquire());
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     @Override
     public final byte[] toByteArray() {
         checkIntSize("byte[]");
         byte[] arr = new byte[(int)length];
         MemorySegment arrSegment = MemorySegment.ofArray(arr);
+<<<<<<< HEAD
         MemoryAddress.copy(baseAddress(), arrSegment.baseAddress(), length);
+=======
+        arrSegment.copyFrom(this);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         return arr;
     }
 
     boolean isSmall() {
         return isSet(SMALL);
     }
 
     void checkRange(long offset, long length, boolean writeAccess) {
+<<<<<<< HEAD
         checkValidState();
+=======
+        scope.checkValidState();
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         if (writeAccess && !isSet(WRITE)) {
             throw unsupportedAccessMode(WRITE);
         } else if (!writeAccess && !isSet(READ)) {
             throw unsupportedAccessMode(READ);
         }
         checkBounds(offset, length);
     }
 
     @Override
     public final void checkValidState() {
+<<<<<<< HEAD
         if (owner != null && owner != Thread.currentThread()) {
             throw new IllegalStateException("Attempt to access segment outside owning thread");
         }
         scope.checkAliveConfined();
+=======
+        scope.checkValidState();
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
     }
 
     // Helper methods
 
     private boolean isSet(int mask) {
@@ -413,33 +551,56 @@
         int size = limit - pos;
 
         AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl)nioAccess.bufferSegment(bb);
         final MemoryScope bufferScope;
         int modes;
+<<<<<<< HEAD
         final Thread owner;
         if (bufferSegment != null) {
             bufferScope = bufferSegment.scope;
             modes = bufferSegment.mask;
             owner = bufferSegment.owner;
         } else {
             bufferScope = new MemoryScope(bb, null);
             modes = defaultAccessModes(size);
             owner = Thread.currentThread();
+=======
+        if (bufferSegment != null) {
+            bufferScope = bufferSegment.scope;
+            modes = bufferSegment.mask;
+        } else {
+            bufferScope = MemoryScope.create(bb, null);
+            modes = defaultAccessModes(size);
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         }
         if (bb.isReadOnly()) {
             modes &= ~WRITE;
         }
         if (base != null) {
+<<<<<<< HEAD
             return new HeapMemorySegmentImpl<>(bbAddress + pos, () -> (byte[])base, size, modes, owner, bufferScope);
         } else if (unmapper == null) {
             return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, owner, bufferScope);
         } else {
             return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, owner, bufferScope);
         }
     }
 
     public static AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(0, 0, null, MemoryScope.GLOBAL) {
+=======
+            return new HeapMemorySegmentImpl<>(bbAddress + pos, () -> (byte[])base, size, modes, bufferScope);
+        } else if (unmapper == null) {
+            return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, bufferScope);
+        } else {
+            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, bufferScope);
+        }
+    }
+
+    public static final AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(
+        0, 0, MemoryScope.createUnchecked(null, null, null)
+    ) {
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
         @Override
         ByteBuffer makeByteBuffer() {
             throw new UnsupportedOperationException();
         }
 
@@ -452,10 +613,14 @@
         Object base() {
             return null;
         }
 
         @Override
+<<<<<<< HEAD
         AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
+=======
+        AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
+>>>>>>> cd397502f19f72fa8a926f4508d3913c8ace9059
             throw new UnsupportedOperationException();
         }
     };
 }

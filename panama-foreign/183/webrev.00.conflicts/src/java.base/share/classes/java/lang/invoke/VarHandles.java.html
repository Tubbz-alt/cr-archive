<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/lang/invoke/VarHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import sun.invoke.util.Wrapper;
 29 
 30 import java.lang.reflect.Constructor;
 31 import java.lang.reflect.Field;
 32 import java.lang.reflect.Method;
 33 import java.lang.reflect.Modifier;
 34 import java.nio.ByteOrder;
 35 import java.util.ArrayList;
 36 import java.util.List;
 37 import java.util.Map;
 38 import java.util.Objects;
 39 import java.util.concurrent.ConcurrentHashMap;
 40 import java.util.concurrent.ConcurrentMap;
 41 import java.util.stream.Stream;
 42 
 43 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 44 import static java.lang.invoke.MethodHandleStatics.VAR_HANDLE_IDENTITY_ADAPT;
 45 import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;
 46 
 47 final class VarHandles {
 48 
 49     static ClassValue&lt;ConcurrentMap&lt;Integer, MethodHandle&gt;&gt; ADDRESS_FACTORIES = new ClassValue&lt;&gt;() {
 50         @Override
 51         protected ConcurrentMap&lt;Integer, MethodHandle&gt; computeValue(Class&lt;?&gt; type) {
 52             return new ConcurrentHashMap&lt;&gt;();
 53         }
 54     };
 55 
 56     static VarHandle makeFieldHandle(MemberName f, Class&lt;?&gt; refc, Class&lt;?&gt; type, boolean isWriteAllowedOnFinalFields) {
 57         if (!f.isStatic()) {
 58             long foffset = MethodHandleNatives.objectFieldOffset(f);
 59             if (!type.isPrimitive()) {
 60                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 61                        ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type)
 62                        : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type));
 63             }
 64             else if (type == boolean.class) {
 65                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 66                        ? new VarHandleBooleans.FieldInstanceReadOnly(refc, foffset)
 67                        : new VarHandleBooleans.FieldInstanceReadWrite(refc, foffset));
 68             }
 69             else if (type == byte.class) {
 70                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 71                        ? new VarHandleBytes.FieldInstanceReadOnly(refc, foffset)
 72                        : new VarHandleBytes.FieldInstanceReadWrite(refc, foffset));
 73             }
 74             else if (type == short.class) {
 75                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 76                        ? new VarHandleShorts.FieldInstanceReadOnly(refc, foffset)
 77                        : new VarHandleShorts.FieldInstanceReadWrite(refc, foffset));
 78             }
 79             else if (type == char.class) {
 80                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 81                        ? new VarHandleChars.FieldInstanceReadOnly(refc, foffset)
 82                        : new VarHandleChars.FieldInstanceReadWrite(refc, foffset));
 83             }
 84             else if (type == int.class) {
 85                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 86                        ? new VarHandleInts.FieldInstanceReadOnly(refc, foffset)
 87                        : new VarHandleInts.FieldInstanceReadWrite(refc, foffset));
 88             }
 89             else if (type == long.class) {
 90                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 91                        ? new VarHandleLongs.FieldInstanceReadOnly(refc, foffset)
 92                        : new VarHandleLongs.FieldInstanceReadWrite(refc, foffset));
 93             }
 94             else if (type == float.class) {
 95                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 96                        ? new VarHandleFloats.FieldInstanceReadOnly(refc, foffset)
 97                        : new VarHandleFloats.FieldInstanceReadWrite(refc, foffset));
 98             }
 99             else if (type == double.class) {
100                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
101                        ? new VarHandleDoubles.FieldInstanceReadOnly(refc, foffset)
102                        : new VarHandleDoubles.FieldInstanceReadWrite(refc, foffset));
103             }
104             else {
105                 throw new UnsupportedOperationException();
106             }
107         }
108         else {
109             // TODO This is not lazy on first invocation
110             // and might cause some circular initialization issues
111 
112             // Replace with something similar to direct method handles
113             // where a barrier is used then elided after use
114 
115             if (UNSAFE.shouldBeInitialized(refc))
116                 UNSAFE.ensureClassInitialized(refc);
117 
118             Object base = MethodHandleNatives.staticFieldBase(f);
119             long foffset = MethodHandleNatives.staticFieldOffset(f);
120             if (!type.isPrimitive()) {
121                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
122                        ? new VarHandleReferences.FieldStaticReadOnly(base, foffset, type)
123                        : new VarHandleReferences.FieldStaticReadWrite(base, foffset, type));
124             }
125             else if (type == boolean.class) {
126                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
127                        ? new VarHandleBooleans.FieldStaticReadOnly(base, foffset)
128                        : new VarHandleBooleans.FieldStaticReadWrite(base, foffset));
129             }
130             else if (type == byte.class) {
131                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
132                        ? new VarHandleBytes.FieldStaticReadOnly(base, foffset)
133                        : new VarHandleBytes.FieldStaticReadWrite(base, foffset));
134             }
135             else if (type == short.class) {
136                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
137                        ? new VarHandleShorts.FieldStaticReadOnly(base, foffset)
138                        : new VarHandleShorts.FieldStaticReadWrite(base, foffset));
139             }
140             else if (type == char.class) {
141                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
142                        ? new VarHandleChars.FieldStaticReadOnly(base, foffset)
143                        : new VarHandleChars.FieldStaticReadWrite(base, foffset));
144             }
145             else if (type == int.class) {
146                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
147                        ? new VarHandleInts.FieldStaticReadOnly(base, foffset)
148                        : new VarHandleInts.FieldStaticReadWrite(base, foffset));
149             }
150             else if (type == long.class) {
151                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
152                        ? new VarHandleLongs.FieldStaticReadOnly(base, foffset)
153                        : new VarHandleLongs.FieldStaticReadWrite(base, foffset));
154             }
155             else if (type == float.class) {
156                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
157                        ? new VarHandleFloats.FieldStaticReadOnly(base, foffset)
158                        : new VarHandleFloats.FieldStaticReadWrite(base, foffset));
159             }
160             else if (type == double.class) {
161                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
162                        ? new VarHandleDoubles.FieldStaticReadOnly(base, foffset)
163                        : new VarHandleDoubles.FieldStaticReadWrite(base, foffset));
164             }
165             else {
166                 throw new UnsupportedOperationException();
167             }
168         }
169     }
170 
171     // Required by instance field handles
172     static Field getFieldFromReceiverAndOffset(Class&lt;?&gt; receiverType,
173                                                long offset,
174                                                Class&lt;?&gt; fieldType) {
175         for (Field f : receiverType.getDeclaredFields()) {
176             if (Modifier.isStatic(f.getModifiers())) continue;
177 
178             if (offset == UNSAFE.objectFieldOffset(f)) {
179                 assert f.getType() == fieldType;
180                 return f;
181             }
182         }
183         throw new InternalError(&quot;Field not found at offset&quot;);
184     }
185 
186     // Required by instance static field handles
187     static Field getStaticFieldFromBaseAndOffset(Object base,
188                                                  long offset,
189                                                  Class&lt;?&gt; fieldType) {
190         // @@@ This is a little fragile assuming the base is the class
191         Class&lt;?&gt; receiverType = (Class&lt;?&gt;) base;
192         for (Field f : receiverType.getDeclaredFields()) {
193             if (!Modifier.isStatic(f.getModifiers())) continue;
194 
195             if (offset == UNSAFE.staticFieldOffset(f)) {
196                 assert f.getType() == fieldType;
197                 return f;
198             }
199         }
200         throw new InternalError(&quot;Static field not found at offset&quot;);
201     }
202 
203     static VarHandle makeArrayElementHandle(Class&lt;?&gt; arrayClass) {
204         if (!arrayClass.isArray())
205             throw new IllegalArgumentException(&quot;not an array: &quot; + arrayClass);
206 
207         Class&lt;?&gt; componentType = arrayClass.getComponentType();
208 
209         int aoffset = UNSAFE.arrayBaseOffset(arrayClass);
210         int ascale = UNSAFE.arrayIndexScale(arrayClass);
211         int ashift = 31 - Integer.numberOfLeadingZeros(ascale);
212 
213         if (!componentType.isPrimitive()) {
214             return maybeAdapt(new VarHandleReferences.Array(aoffset, ashift, arrayClass));
215         }
216         else if (componentType == boolean.class) {
217             return maybeAdapt(new VarHandleBooleans.Array(aoffset, ashift));
218         }
219         else if (componentType == byte.class) {
220             return maybeAdapt(new VarHandleBytes.Array(aoffset, ashift));
221         }
222         else if (componentType == short.class) {
223             return maybeAdapt(new VarHandleShorts.Array(aoffset, ashift));
224         }
225         else if (componentType == char.class) {
226             return maybeAdapt(new VarHandleChars.Array(aoffset, ashift));
227         }
228         else if (componentType == int.class) {
229             return maybeAdapt(new VarHandleInts.Array(aoffset, ashift));
230         }
231         else if (componentType == long.class) {
232             return maybeAdapt(new VarHandleLongs.Array(aoffset, ashift));
233         }
234         else if (componentType == float.class) {
235             return maybeAdapt(new VarHandleFloats.Array(aoffset, ashift));
236         }
237         else if (componentType == double.class) {
238             return maybeAdapt(new VarHandleDoubles.Array(aoffset, ashift));
239         }
240         else {
241             throw new UnsupportedOperationException();
242         }
243     }
244 
245     static VarHandle byteArrayViewHandle(Class&lt;?&gt; viewArrayClass,
246                                          boolean be) {
247         if (!viewArrayClass.isArray())
248             throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
249 
250         Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
251 
252         if (viewComponentType == long.class) {
253             return maybeAdapt(new VarHandleByteArrayAsLongs.ArrayHandle(be));
254         }
255         else if (viewComponentType == int.class) {
256             return maybeAdapt(new VarHandleByteArrayAsInts.ArrayHandle(be));
257         }
258         else if (viewComponentType == short.class) {
259             return maybeAdapt(new VarHandleByteArrayAsShorts.ArrayHandle(be));
260         }
261         else if (viewComponentType == char.class) {
262             return maybeAdapt(new VarHandleByteArrayAsChars.ArrayHandle(be));
263         }
264         else if (viewComponentType == double.class) {
265             return maybeAdapt(new VarHandleByteArrayAsDoubles.ArrayHandle(be));
266         }
267         else if (viewComponentType == float.class) {
268             return maybeAdapt(new VarHandleByteArrayAsFloats.ArrayHandle(be));
269         }
270 
271         throw new UnsupportedOperationException();
272     }
273 
274     static VarHandle makeByteBufferViewHandle(Class&lt;?&gt; viewArrayClass,
275                                               boolean be) {
276         if (!viewArrayClass.isArray())
277             throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
278 
279         Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
280 
281         if (viewComponentType == long.class) {
282             return maybeAdapt(new VarHandleByteArrayAsLongs.ByteBufferHandle(be));
283         }
284         else if (viewComponentType == int.class) {
285             return maybeAdapt(new VarHandleByteArrayAsInts.ByteBufferHandle(be));
286         }
287         else if (viewComponentType == short.class) {
288             return maybeAdapt(new VarHandleByteArrayAsShorts.ByteBufferHandle(be));
289         }
290         else if (viewComponentType == char.class) {
291             return maybeAdapt(new VarHandleByteArrayAsChars.ByteBufferHandle(be));
292         }
293         else if (viewComponentType == double.class) {
294             return maybeAdapt(new VarHandleByteArrayAsDoubles.ByteBufferHandle(be));
295         }
296         else if (viewComponentType == float.class) {
297             return maybeAdapt(new VarHandleByteArrayAsFloats.ByteBufferHandle(be));
298         }
299 
300         throw new UnsupportedOperationException();
301     }
302 
303     /**
304      * Creates a memory access VarHandle.
305      *
306      * Resulting VarHandle will take a memory address as first argument,
307      * and a certain number of coordinate {@code long} parameters, depending on the length
308      * of the {@code strides} argument array.
309      *
310      * Coordinates are multiplied with corresponding scale factors ({@code strides}) and added
311      * to a single fixed offset to compute an effective offset from the given MemoryAddress for the access.
312      *
313      * @param carrier the Java carrier type.
314      * @param alignmentMask alignment requirement to be checked upon access. In bytes. Expressed as a mask.
315      * @param byteOrder the byte order.
316      * @param offset a constant offset for the access.
317      * @param strides the scale factors with which to multiply given access coordinates.
318      * @return the created VarHandle.
319      */
320     static VarHandle makeMemoryAddressViewHandle(Class&lt;?&gt; carrier, long alignmentMask,
321                                                  ByteOrder byteOrder, long offset, long[] strides) {
322         if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
323             throw new IllegalArgumentException(&quot;Invalid carrier: &quot; + carrier.getName());
324         }
325         long size = Wrapper.forPrimitiveType(carrier).bitWidth() / 8;
326         boolean be = byteOrder == ByteOrder.BIG_ENDIAN;
327 
328         Map&lt;Integer, MethodHandle&gt; carrierFactory = ADDRESS_FACTORIES.get(carrier);
329         MethodHandle fac = carrierFactory.computeIfAbsent(strides.length,
330                 dims -&gt; new MemoryAccessVarHandleGenerator(carrier, dims)
331                             .generateHandleFactory());
332 
333         try {
334             return maybeAdapt((VarHandle)fac.invoke(be, size, offset, alignmentMask, strides));
335         } catch (Throwable ex) {
336             throw new IllegalStateException(ex);
337         }
338     }
339 
340     private static VarHandle maybeAdapt(VarHandle target) {
341         if (!VAR_HANDLE_IDENTITY_ADAPT) return target;
342         target = filterValue(target,
343                         MethodHandles.identity(target.varType()), MethodHandles.identity(target.varType()));
344         MethodType mtype = target.accessModeType(VarHandle.AccessMode.GET).dropParameterTypes(0, 1);
345         for (int i = 0 ; i &lt; mtype.parameterCount() ; i++) {
346             target = filterCoordinates(target, i, MethodHandles.identity(mtype.parameterType(i)));
347         }
348         return target;
349     }
350 
351     public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {
352         Objects.nonNull(target);
353         Objects.nonNull(filterToTarget);
354         Objects.nonNull(filterFromTarget);
355         //check that from/to filters do not throw checked exceptions
356         noCheckedExceptions(filterToTarget);
357         noCheckedExceptions(filterFromTarget);
358 
359 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
360         //check that from/to filters have right signatures
361         if (filterFromTarget.type().parameterCount() != 1) {
362             throw newIllegalArgumentException(&quot;filterFromTarget filter type has wrong arity&quot;, filterFromTarget.type());
363         } else if (filterToTarget.type().parameterCount() != 1) {
364             throw newIllegalArgumentException(&quot;filterToTarget filter type has wrong arity&quot;, filterFromTarget.type());
365         } else if (filterFromTarget.type().parameterType(0) != filterToTarget.type().returnType() ||
366                 filterToTarget.type().parameterType(0) != filterFromTarget.type().returnType()) {
367             throw newIllegalArgumentException(&quot;filterFromTarget and filterToTarget filter types do not match&quot;, filterFromTarget.type(), filterToTarget.type());
368         } else if (target.varType() != filterFromTarget.type().parameterType(0)) {
369             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterFromTarget.type(), target.varType());
370         } else if (target.varType() != filterToTarget.type().returnType()) {
371             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterToTarget.type(), target.varType());
372         }
373 
374         return new IndirectVarHandle(target, filterFromTarget.type().returnType(), target.coordinateTypes().toArray(new Class&lt;?&gt;[0]),
375                 (mode, modeHandle) -&gt; {
376                     int lastParameterPos = modeHandle.type().parameterCount() - 1;
377                     return switch (mode.at) {
378                         case GET -&gt; MethodHandles.filterReturnValue(modeHandle, filterFromTarget);
379                         case SET -&gt; MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);
380                         case GET_AND_UPDATE -&gt; {
381                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);
382                             yield MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);
383                         }
384                         case COMPARE_AND_EXCHANGE -&gt; {
385                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);
386                             adapter = MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);
387                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);
388                         }
389                         case COMPARE_AND_SET -&gt; {
390                             MethodHandle adapter = MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);
391                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);
392 =======
393         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;();
394         List&lt;Class&lt;?&gt;&gt; additionalCoordinates = new ArrayList&lt;&gt;();
395         newCoordinates.addAll(target.coordinateTypes());
396 
397         //check that from/to filters have right signatures
398         if (filterFromTarget.type().parameterCount() != filterToTarget.type().parameterCount()) {
399             throw newIllegalArgumentException(&quot;filterFromTarget and filterToTarget have different arity&quot;, filterFromTarget.type(), filterToTarget.type());
400         } else if (filterFromTarget.type().parameterCount() &lt; 1) {
401             throw newIllegalArgumentException(&quot;filterFromTarget filter type has wrong arity&quot;, filterFromTarget.type());
402         } else if (filterToTarget.type().parameterCount() &lt; 1) {
403             throw newIllegalArgumentException(&quot;filterToTarget filter type has wrong arity&quot;, filterFromTarget.type());
404         } else if (filterFromTarget.type().lastParameterType() != filterToTarget.type().returnType() ||
405                 filterToTarget.type().lastParameterType() != filterFromTarget.type().returnType()) {
406             throw newIllegalArgumentException(&quot;filterFromTarget and filterToTarget filter types do not match&quot;, filterFromTarget.type(), filterToTarget.type());
407         } else if (target.varType() != filterFromTarget.type().lastParameterType()) {
408             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterFromTarget.type(), target.varType());
409         } else if (target.varType() != filterToTarget.type().returnType()) {
410             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterToTarget.type(), target.varType());
411         } else if (filterFromTarget.type().parameterCount() &gt; 1) {
412             for (int i = 0 ; i &lt; filterFromTarget.type().parameterCount() - 1 ; i++) {
413                 if (filterFromTarget.type().parameterType(i) != filterToTarget.type().parameterType(i)) {
414                     throw newIllegalArgumentException(&quot;filterFromTarget and filterToTarget filter types do not match&quot;, filterFromTarget.type(), filterToTarget.type());
415                 } else {
416                     newCoordinates.add(filterFromTarget.type().parameterType(i));
417                     additionalCoordinates.add((filterFromTarget.type().parameterType(i)));
418                 }
419             }
420         }
421 
422         return new IndirectVarHandle(target, filterFromTarget.type().returnType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
423                 (mode, modeHandle) -&gt; {
424                     int lastParameterPos = modeHandle.type().parameterCount() - 1;
425                     return switch (mode.at) {
426                         case GET -&gt; MethodHandles.collectReturnValue(modeHandle, filterFromTarget);
427                         case SET -&gt; MethodHandles.collectArguments(modeHandle, lastParameterPos, filterToTarget);
428                         case GET_AND_UPDATE -&gt; {
429                             MethodHandle adapter = MethodHandles.collectReturnValue(modeHandle, filterFromTarget);
430                             MethodHandle res = MethodHandles.collectArguments(adapter, lastParameterPos, filterToTarget);
431                             if (additionalCoordinates.size() &gt; 0) {
432                                 res = joinDuplicateArgs(res, lastParameterPos,
433                                         lastParameterPos + additionalCoordinates.size() + 1,
434                                         additionalCoordinates.size());
435                             }
436                             yield res;
437                         }
438                         case COMPARE_AND_EXCHANGE -&gt; {
439                             MethodHandle adapter = MethodHandles.collectReturnValue(modeHandle, filterFromTarget);
440                             adapter = MethodHandles.collectArguments(adapter, lastParameterPos, filterToTarget);
441                             if (additionalCoordinates.size() &gt; 0) {
442                                 adapter = joinDuplicateArgs(adapter, lastParameterPos,
443                                         lastParameterPos + additionalCoordinates.size() + 1,
444                                         additionalCoordinates.size());
445                             }
446                             MethodHandle res = MethodHandles.collectArguments(adapter, lastParameterPos - 1, filterToTarget);
447                             if (additionalCoordinates.size() &gt; 0) {
448                                 res = joinDuplicateArgs(res, lastParameterPos - 1,
449                                         lastParameterPos + additionalCoordinates.size(),
450                                         additionalCoordinates.size());
451                             }
452                             yield res;
453                         }
454                         case COMPARE_AND_SET -&gt; {
455                             MethodHandle adapter = MethodHandles.collectArguments(modeHandle, lastParameterPos, filterToTarget);
456                             MethodHandle res = MethodHandles.collectArguments(adapter, lastParameterPos - 1, filterToTarget);
457                             if (additionalCoordinates.size() &gt; 0) {
458                                 res = joinDuplicateArgs(res, lastParameterPos - 1,
459                                         lastParameterPos + additionalCoordinates.size(),
460                                         additionalCoordinates.size());
461                             }
462                             yield res;
463 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059
464                         }
465                     };
466                 });
467     }
468 
469 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
470 =======
471     private static MethodHandle joinDuplicateArgs(MethodHandle handle, int originalStart, int dropStart, int length) {
472         int[] perms = new int[handle.type().parameterCount()];
473         for (int i = 0 ; i &lt; dropStart; i++) {
474             perms[i] = i;
475         }
476         for (int i = 0 ; i &lt; length ; i++) {
477             perms[dropStart + i] = originalStart + i;
478         }
479         for (int i = dropStart + length ; i &lt; perms.length ; i++) {
480             perms[i] = i - length;
481         }
482         return MethodHandles.permuteArguments(handle,
483                 handle.type().dropParameterTypes(dropStart, dropStart + length),
484                 perms);
485     }
486 
487 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059
488     public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {
489         Objects.nonNull(target);
490         Objects.nonNull(filters);
491 
492         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();
493         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {
494             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);
495         } else if (pos + filters.length &gt; targetCoordinates.size()) {
496             throw new IllegalArgumentException(&quot;Too many filters&quot;);
497         }
498 
499         if (filters.length == 0) return target;
500 
501         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);
502         for (int i = 0 ; i &lt; filters.length ; i++) {
503             noCheckedExceptions(filters[i]);
504             MethodType filterType = filters[i].type();
505             if (filterType.parameterCount() != 1) {
506                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType);
507             } else if (newCoordinates.get(pos + i) != filterType.returnType()) {
508                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType + &quot; for coordinate type &quot; + newCoordinates.get(i));
509             }
510             newCoordinates.set(pos + i, filters[i].type().parameterType(0));
511         }
512 
513         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
514                 (mode, modeHandle) -&gt; MethodHandles.filterArguments(modeHandle, 1 + pos, filters));
515     }
516 
517     public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {
518         Objects.nonNull(target);
519         Objects.nonNull(values);
520 
521         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();
522         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {
523             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);
524         } else if (pos + values.length &gt; targetCoordinates.size()) {
525             throw new IllegalArgumentException(&quot;Too many values&quot;);
526         }
527 
528         if (values.length == 0) return target;
529 
530         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);
531         for (int i = 0 ; i &lt; values.length ; i++) {
532             Class&lt;?&gt; pt = newCoordinates.get(pos);
533             if (pt.isPrimitive()) {
534                 Wrapper w = Wrapper.forPrimitiveType(pt);
535                 w.convert(values[i], pt);
536             } else {
537                 pt.cast(values[i]);
538             }
539             newCoordinates.remove(pos);
540         }
541 
542         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
543                 (mode, modeHandle) -&gt; MethodHandles.insertArguments(modeHandle, 1 + pos, values));
544     }
545 
546     public static VarHandle permuteCoordinates(VarHandle target, List&lt;Class&lt;?&gt;&gt; newCoordinates, int... reorder) {
547         Objects.nonNull(target);
548         Objects.nonNull(newCoordinates);
549         Objects.nonNull(reorder);
550 
551         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();
552         MethodHandles.permuteArgumentChecks(reorder,
553                 MethodType.methodType(void.class, newCoordinates),
554                 MethodType.methodType(void.class, targetCoordinates));
555 
556         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
557                 (mode, modeHandle) -&gt;
558                         MethodHandles.permuteArguments(modeHandle,
559                                 methodTypeFor(mode.at, modeHandle.type(), targetCoordinates, newCoordinates),
560                                 reorderArrayFor(mode.at, newCoordinates, reorder)));
561     }
562 
563     private static int numTrailingArgs(VarHandle.AccessType at) {
564         return switch (at) {
565             case GET -&gt; 0;
566             case GET_AND_UPDATE, SET -&gt; 1;
567             case COMPARE_AND_SET, COMPARE_AND_EXCHANGE -&gt; 2;
568         };
569     }
570 
571     private static int[] reorderArrayFor(VarHandle.AccessType at, List&lt;Class&lt;?&gt;&gt; newCoordinates, int[] reorder) {
572         int numTrailingArgs = numTrailingArgs(at);
573         int[] adjustedReorder = new int[reorder.length + 1 + numTrailingArgs];
574         adjustedReorder[0] = 0;
575         for (int i = 0 ; i &lt; reorder.length ; i++) {
576             adjustedReorder[i + 1] = reorder[i] + 1;
577         }
578         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {
579             adjustedReorder[i + reorder.length + 1] = i + newCoordinates.size() + 1;
580         }
581         return adjustedReorder;
582     }
583 
584     private static MethodType methodTypeFor(VarHandle.AccessType at, MethodType oldType, List&lt;Class&lt;?&gt;&gt; oldCoordinates, List&lt;Class&lt;?&gt;&gt; newCoordinates) {
585         int numTrailingArgs = numTrailingArgs(at);
586         MethodType adjustedType = MethodType.methodType(oldType.returnType(), oldType.parameterType(0));
587         adjustedType = adjustedType.appendParameterTypes(newCoordinates);
588         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {
589             adjustedType = adjustedType.appendParameterTypes(oldType.parameterType(1 + oldCoordinates.size() + i));
590         }
591         return adjustedType;
592     }
593 
594     public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {
595         Objects.nonNull(target);
596         Objects.nonNull(filter);
597         noCheckedExceptions(filter);
598 
599         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();
600         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {
601             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);
602         } else if (filter.type().returnType() == void.class) {
603             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; ; filter cannot be void&quot;);
604         } else if (filter.type().returnType() != targetCoordinates.get(pos)) {
605             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; for coordinate type &quot; + targetCoordinates.get(pos));
606         }
607 
608         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);
609         newCoordinates.remove(pos);
610         newCoordinates.addAll(pos, filter.type().parameterList());
611 
612         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
613                 (mode, modeHandle) -&gt; MethodHandles.collectArguments(modeHandle, 1 + pos, filter));
614     }
615 
616     public static VarHandle dropCoordinates(VarHandle target, int pos, Class&lt;?&gt;... valueTypes) {
617         Objects.nonNull(target);
618         Objects.nonNull(valueTypes);
619 
620         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();
621         if (pos &lt; 0 || pos &gt; targetCoordinates.size()) {
622             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);
623         }
624 
625         if (valueTypes.length == 0) return target;
626 
627         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);
628         newCoordinates.addAll(pos, List.of(valueTypes));
629 
630         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
631                 (mode, modeHandle) -&gt; MethodHandles.dropArguments(modeHandle, 1 + pos, valueTypes));
632     }
633 
634     private static void noCheckedExceptions(MethodHandle handle) {
635         if (handle instanceof DirectMethodHandle) {
636             DirectMethodHandle directHandle = (DirectMethodHandle)handle;
637 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
638             MethodHandleInfo info = MethodHandles.Lookup.IMPL_LOOKUP.revealDirect(directHandle);
639             Class&lt;?&gt;[] exceptionTypes = switch (info.getReferenceKind()) {
640                 case MethodHandleInfo.REF_invokeInterface, MethodHandleInfo.REF_invokeSpecial,
641                         MethodHandleInfo.REF_invokeStatic, MethodHandleInfo.REF_invokeVirtual -&gt;
642                         info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP).getExceptionTypes();
643                 case MethodHandleInfo.REF_newInvokeSpecial -&gt;
644                         info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP).getExceptionTypes();
645                 case MethodHandleInfo.REF_getField, MethodHandleInfo.REF_getStatic,
646                         MethodHandleInfo.REF_putField, MethodHandleInfo.REF_putStatic -&gt; null;
647                 default -&gt; throw new AssertionError(&quot;Cannot get here&quot;);
648             };
649 =======
650             byte refKind = directHandle.member.getReferenceKind();
651             MethodHandleInfo info = new InfoFromMemberName(
652                     MethodHandles.Lookup.IMPL_LOOKUP,
653                     directHandle.member,
654                     refKind);
655             final Class&lt;?&gt;[] exceptionTypes;
656             if (MethodHandleNatives.refKindIsMethod(refKind)) {
657                 exceptionTypes = info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP)
658                         .getExceptionTypes();
659             } else if (MethodHandleNatives.refKindIsField(refKind)) {
660                 exceptionTypes = null;
661             } else if (MethodHandleNatives.refKindIsConstructor(refKind)) {
662                 exceptionTypes = info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP)
663                         .getExceptionTypes();
664             } else {
665                 throw new AssertionError(&quot;Cannot get here&quot;);
666             }
667 &gt;&gt;&gt;&gt;&gt;&gt;&gt; cd397502f19f72fa8a926f4508d3913c8ace9059
668             if (exceptionTypes != null) {
669                 if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {
670                     throw newIllegalArgumentException(&quot;Cannot adapt a var handle with a method handle which throws checked exceptions&quot;);
671                 }
672             }
673         } else if (handle instanceof DelegatingMethodHandle) {
674             noCheckedExceptions(((DelegatingMethodHandle)handle).getTarget());
675         } else {
676             //bound
677             BoundMethodHandle boundHandle = (BoundMethodHandle)handle;
678             for (int i = 0 ; i &lt; boundHandle.fieldCount() ; i++) {
679                 Object arg = boundHandle.arg(i);
680                 if (arg instanceof MethodHandle){
681                     noCheckedExceptions((MethodHandle) arg);
682                 }
683             }
684         }
685     }
686 
687     private static boolean isCheckedException(Class&lt;?&gt; clazz) {
688         return Throwable.class.isAssignableFrom(clazz) &amp;&amp;
689                 !RuntimeException.class.isAssignableFrom(clazz) &amp;&amp;
690                 !Error.class.isAssignableFrom(clazz);
691     }
692 
693 //    /**
694 //     * A helper program to generate the VarHandleGuards class with a set of
695 //     * static guard methods each of which corresponds to a particular shape and
696 //     * performs a type check of the symbolic type descriptor with the VarHandle
697 //     * type descriptor before linking/invoking to the underlying operation as
698 //     * characterized by the operation member name on the VarForm of the
699 //     * VarHandle.
700 //     * &lt;p&gt;
701 //     * The generated class essentially encapsulates pre-compiled LambdaForms,
702 //     * one for each method, for the most set of common method signatures.
703 //     * This reduces static initialization costs, footprint costs, and circular
704 //     * dependencies that may arise if a class is generated per LambdaForm.
705 //     * &lt;p&gt;
706 //     * A maximum of L*T*S methods will be generated where L is the number of
707 //     * access modes kinds (or unique operation signatures) and T is the number
708 //     * of variable types and S is the number of shapes (such as instance field,
709 //     * static field, or array access).
710 //     * If there are 4 unique operation signatures, 5 basic types (Object, int,
711 //     * long, float, double), and 3 shapes then a maximum of 60 methods will be
712 //     * generated.  However, the number is likely to be less since there
713 //     * be duplicate signatures.
714 //     * &lt;p&gt;
715 //     * Each method is annotated with @LambdaForm.Compiled to inform the runtime
716 //     * that such methods should be treated as if a method of a class that is the
717 //     * result of compiling a LambdaForm.  Annotation of such methods is
718 //     * important for correct evaluation of certain assertions and method return
719 //     * type profiling in HotSpot.
720 //     */
721 //    public static class GuardMethodGenerator {
722 //
723 //        static final String GUARD_METHOD_SIG_TEMPLATE = &quot;&lt;RETURN&gt; &lt;NAME&gt;_&lt;SIGNATURE&gt;(&lt;PARAMS&gt;)&quot;;
724 //
725 //        static final String GUARD_METHOD_TEMPLATE =
726 //                &quot;@ForceInline\n&quot; +
727 //                &quot;@LambdaForm.Compiled\n&quot; +
728 //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
729 //                &quot;    if (handle.isDirect() &amp;&amp; handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +
730 //                &quot;        &lt;RESULT_ERASED&gt;MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);&lt;RETURN_ERASED&gt;\n&quot; +
731 //                &quot;    }\n&quot; +
732 //                &quot;    else {\n&quot; +
733 //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
734 //                &quot;        &lt;RETURN&gt;mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
735 //                &quot;    }\n&quot; +
736 //                &quot;}&quot;;
737 //
738 //        static final String GUARD_METHOD_TEMPLATE_V =
739 //                &quot;@ForceInline\n&quot; +
740 //                &quot;@LambdaForm.Compiled\n&quot; +
741 //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
742 //                &quot;    if (handle.isDirect() &amp;&amp; handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +
743 //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
744 //                &quot;    }\n&quot; +
745 //                &quot;    else if (handle.isDirect() &amp;&amp; handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodType) {\n&quot; +
746 //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
747 //                &quot;    }\n&quot; +
748 //                &quot;    else {\n&quot; +
749 //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
750 //                &quot;        mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
751 //                &quot;    }\n&quot; +
752 //                &quot;}&quot;;
753 //
754 //        // A template for deriving the operations
755 //        // could be supported by annotating VarHandle directly with the
756 //        // operation kind and shape
757 //        interface VarHandleTemplate {
758 //            Object get();
759 //
760 //            void set(Object value);
761 //
762 //            boolean compareAndSet(Object actualValue, Object expectedValue);
763 //
764 //            Object compareAndExchange(Object actualValue, Object expectedValue);
765 //
766 //            Object getAndUpdate(Object value);
767 //        }
768 //
769 //        static class HandleType {
770 //            final Class&lt;?&gt; receiver;
771 //            final Class&lt;?&gt;[] intermediates;
772 //            final Class&lt;?&gt; value;
773 //
774 //            HandleType(Class&lt;?&gt; receiver, Class&lt;?&gt; value, Class&lt;?&gt;... intermediates) {
775 //                this.receiver = receiver;
776 //                this.intermediates = intermediates;
777 //                this.value = value;
778 //            }
779 //        }
780 //
781 //        /**
782 //         * @param args parameters
783 //         */
784 //        public static void main(String[] args) {
785 //            System.out.println(&quot;package java.lang.invoke;&quot;);
786 //            System.out.println();
787 //            System.out.println(&quot;import jdk.internal.vm.annotation.ForceInline;&quot;);
788 //            System.out.println();
789 //            System.out.println(&quot;// This class is auto-generated by &quot; +
790 //                               GuardMethodGenerator.class.getName() +
791 //                               &quot;. Do not edit.&quot;);
792 //            System.out.println(&quot;final class VarHandleGuards {&quot;);
793 //
794 //            System.out.println();
795 //
796 //            // Declare the stream of shapes
797 //            Stream&lt;HandleType&gt; hts = Stream.of(
798 //                    // Object-&gt;Object
799 //                    new HandleType(Object.class, Object.class),
800 //                    // Object-&gt;int
801 //                    new HandleType(Object.class, int.class),
802 //                    // Object-&gt;long
803 //                    new HandleType(Object.class, long.class),
804 //                    // Object-&gt;float
805 //                    new HandleType(Object.class, float.class),
806 //                    // Object-&gt;double
807 //                    new HandleType(Object.class, double.class),
808 //
809 //                    // &lt;static&gt;-&gt;Object
810 //                    new HandleType(null, Object.class),
811 //                    // &lt;static&gt;-&gt;int
812 //                    new HandleType(null, int.class),
813 //                    // &lt;static&gt;-&gt;long
814 //                    new HandleType(null, long.class),
815 //                    // &lt;static&gt;-&gt;float
816 //                    new HandleType(null, float.class),
817 //                    // &lt;static&gt;-&gt;double
818 //                    new HandleType(null, double.class),
819 //
820 //                    // Array[int]-&gt;Object
821 //                    new HandleType(Object.class, Object.class, int.class),
822 //                    // Array[int]-&gt;int
823 //                    new HandleType(Object.class, int.class, int.class),
824 //                    // Array[int]-&gt;long
825 //                    new HandleType(Object.class, long.class, int.class),
826 //                    // Array[int]-&gt;float
827 //                    new HandleType(Object.class, float.class, int.class),
828 //                    // Array[int]-&gt;double
829 //                    new HandleType(Object.class, double.class, int.class),
830 //
831 //                    // Array[long]-&gt;int
832 //                    new HandleType(Object.class, int.class, long.class),
833 //                    // Array[long]-&gt;long
834 //                    new HandleType(Object.class, long.class, long.class)
835 //            );
836 //
837 //            hts.flatMap(ht -&gt; Stream.of(VarHandleTemplate.class.getMethods()).
838 //                    map(m -&gt; generateMethodType(m, ht.receiver, ht.value, ht.intermediates))).
839 //                    distinct().
840 //                    map(mt -&gt; generateMethod(mt)).
841 //                    forEach(s -&gt; {
842 //                        System.out.println(s);
843 //                        System.out.println();
844 //                    });
845 //
846 //            System.out.println(&quot;}&quot;);
847 //        }
848 //
849 //        static MethodType generateMethodType(Method m, Class&lt;?&gt; receiver, Class&lt;?&gt; value, Class&lt;?&gt;... intermediates) {
850 //            Class&lt;?&gt; returnType = m.getReturnType() == Object.class
851 //                                  ? value : m.getReturnType();
852 //
853 //            List&lt;Class&lt;?&gt;&gt; params = new ArrayList&lt;&gt;();
854 //            if (receiver != null)
855 //                params.add(receiver);
856 //            for (int i = 0; i &lt; intermediates.length; i++) {
857 //                params.add(intermediates[i]);
858 //            }
859 //            for (Parameter p : m.getParameters()) {
860 //                params.add(value);
861 //            }
862 //            return MethodType.methodType(returnType, params);
863 //        }
864 //
865 //        static String generateMethod(MethodType mt) {
866 //            Class&lt;?&gt; returnType = mt.returnType();
867 //
868 //            LinkedHashMap&lt;String, Class&lt;?&gt;&gt; params = new LinkedHashMap&lt;&gt;();
869 //            params.put(&quot;handle&quot;, VarHandle.class);
870 //            for (int i = 0; i &lt; mt.parameterCount(); i++) {
871 //                params.put(&quot;arg&quot; + i, mt.parameterType(i));
872 //            }
873 //            params.put(&quot;ad&quot;, VarHandle.AccessDescriptor.class);
874 //
875 //            // Generate method signature line
876 //            String RETURN = className(returnType);
877 //            String NAME = &quot;guard&quot;;
878 //            String SIGNATURE = getSignature(mt);
879 //            String PARAMS = params.entrySet().stream().
880 //                    map(e -&gt; className(e.getValue()) + &quot; &quot; + e.getKey()).
881 //                    collect(joining(&quot;, &quot;));
882 //            String METHOD = GUARD_METHOD_SIG_TEMPLATE.
883 //                    replace(&quot;&lt;RETURN&gt;&quot;, RETURN).
884 //                    replace(&quot;&lt;NAME&gt;&quot;, NAME).
885 //                    replace(&quot;&lt;SIGNATURE&gt;&quot;, SIGNATURE).
886 //                    replace(&quot;&lt;PARAMS&gt;&quot;, PARAMS);
887 //
888 //            // Generate method
889 //            params.remove(&quot;ad&quot;);
890 //
891 //            List&lt;String&gt; LINK_TO_STATIC_ARGS = params.keySet().stream().
892 //                    collect(toList());
893 //            LINK_TO_STATIC_ARGS.add(&quot;handle.vform.getMemberName(ad.mode)&quot;);
894 //            List&lt;String&gt; LINK_TO_STATIC_ARGS_V = params.keySet().stream().
895 //                    collect(toList());
896 //            LINK_TO_STATIC_ARGS_V.add(&quot;handle.vform.getMemberName_V(ad.mode)&quot;);
897 //
898 //            List&lt;String&gt; LINK_TO_INVOKER_ARGS = params.keySet().stream().
899 //                    collect(toList());
900 //
901 //            RETURN = returnType == void.class
902 //                     ? &quot;&quot;
903 //                     : returnType == Object.class
904 //                       ? &quot;return &quot;
905 //                       : &quot;return (&quot; + returnType.getName() + &quot;) &quot;;
906 //
907 //            String RESULT_ERASED = returnType == void.class
908 //                                   ? &quot;&quot;
909 //                                   : returnType != Object.class
910 //                                     ? &quot;return (&quot; + returnType.getName() + &quot;) &quot;
911 //                                     : &quot;Object r = &quot;;
912 //
913 //            String RETURN_ERASED = returnType != Object.class
914 //                                   ? &quot;&quot;
915 //                                   : &quot; return ad.returnType.cast(r);&quot;;
916 //
917 //            String template = returnType == void.class
918 //                              ? GUARD_METHOD_TEMPLATE_V
919 //                              : GUARD_METHOD_TEMPLATE;
920 //            return template.
921 //                    replace(&quot;&lt;METHOD&gt;&quot;, METHOD).
922 //                    replace(&quot;&lt;NAME&gt;&quot;, NAME).
923 //                    replaceAll(&quot;&lt;RETURN&gt;&quot;, RETURN).
924 //                    replace(&quot;&lt;RESULT_ERASED&gt;&quot;, RESULT_ERASED).
925 //                    replace(&quot;&lt;RETURN_ERASED&gt;&quot;, RETURN_ERASED).
926 //                    replaceAll(&quot;&lt;LINK_TO_STATIC_ARGS&gt;&quot;, LINK_TO_STATIC_ARGS.stream().
927 //                            collect(joining(&quot;, &quot;))).
928 //                    replaceAll(&quot;&lt;LINK_TO_STATIC_ARGS_V&gt;&quot;, LINK_TO_STATIC_ARGS_V.stream().
929 //                            collect(joining(&quot;, &quot;))).
930 //                    replace(&quot;&lt;LINK_TO_INVOKER_ARGS&gt;&quot;, LINK_TO_INVOKER_ARGS.stream().
931 //                            collect(joining(&quot;, &quot;)))
932 //                    ;
933 //        }
934 //
935 //        static String className(Class&lt;?&gt; c) {
936 //            String n = c.getName();
937 //            if (n.startsWith(&quot;java.lang.&quot;)) {
938 //                n = n.replace(&quot;java.lang.&quot;, &quot;&quot;);
939 //                if (n.startsWith(&quot;invoke.&quot;)) {
940 //                    n = n.replace(&quot;invoke.&quot;, &quot;&quot;);
941 //                }
942 //            }
943 //            return n.replace(&#39;$&#39;, &#39;.&#39;);
944 //        }
945 //
946 //        static String getSignature(MethodType m) {
947 //            StringBuilder sb = new StringBuilder(m.parameterCount() + 1);
948 //
949 //            for (int i = 0; i &lt; m.parameterCount(); i++) {
950 //                Class&lt;?&gt; pt = m.parameterType(i);
951 //                sb.append(getCharType(pt));
952 //            }
953 //
954 //            sb.append(&#39;_&#39;).append(getCharType(m.returnType()));
955 //
956 //            return sb.toString();
957 //        }
958 //
959 //        static char getCharType(Class&lt;?&gt; pt) {
960 //            if (pt == void.class) {
961 //                return &#39;V&#39;;
962 //            }
963 //            else if (!pt.isPrimitive()) {
964 //                return &#39;L&#39;;
965 //            }
966 //            else if (pt == boolean.class) {
967 //                return &#39;Z&#39;;
968 //            }
969 //            else if (pt == int.class) {
970 //                return &#39;I&#39;;
971 //            }
972 //            else if (pt == long.class) {
973 //                return &#39;J&#39;;
974 //            }
975 //            else if (pt == float.class) {
976 //                return &#39;F&#39;;
977 //            }
978 //            else if (pt == double.class) {
979 //                return &#39;D&#39;;
980 //            }
981 //            else {
982 //                throw new IllegalStateException(pt.getName());
983 //            }
984 //        }
985 //    }
986 }
    </pre>
  </body>
</html>
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
@@ -113,11 +113,11 @@
 
     public void addMethodHandleGetter(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
         emitForwardGetter(constantHelper.addMethodHandle(javaName, nativeName, mtype, desc, varargs));
     }
 
-    public void addAddressGetter(String javaName, String nativeName, MemoryLayout layout) {
+    public void addAddressGetter(String javaName, String nativeName, MemoryLayout layout, MemoryLayout parentLayout) {
         emitForwardGetter(constantHelper.addAddress(javaName, nativeName, layout));
     }
 
     public void addConstantGetter(String javaName, Class<?> type, Object value) {
         emitForwardGetter(constantHelper.addConstant(javaName, type, value));
@@ -150,24 +150,10 @@
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
-    public void addAddressOf(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        DirectMethodHandleDesc desc = constantHelper.addAddress(javaName, nativeName, layout);
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + "MemoryAddress " + javaName + "$addressof() {\n");
-        incrAlign();
-        indent();
-        sb.append("return " + getCallString(desc) + ";\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
     // Utility
 
     protected void addPackagePrefix() {
         assert pkgName.indexOf('/') == -1 : "package name invalid: " + pkgName;
         sb.append("// Generated by jextract\n\n");
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
@@ -367,23 +367,23 @@
         boolean isSegment = clazz == MemorySegment.class;
         MemoryLayout treeLayout = tree.layout().orElseThrow();
         if (parent != null) { //struct field
             MemoryLayout parentLayout = parentLayout(parent);
             if (isSegment) {
-                structBuilder.addAddressOf(fieldName, tree.name(), treeLayout, clazz, parentLayout);
+                structBuilder.addAddressGetter(fieldName, tree.name(), treeLayout, parentLayout);
             } else {
                 structBuilder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
                 structBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
                 structBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
             }
         } else {
             if (isSegment) {
-                builder.addAddressOf(fieldName, tree.name(), treeLayout, clazz, null);
+                builder.addAddressGetter(fieldName, tree.name(), treeLayout, null);
             } else {
                 builder.addLayoutGetter(fieldName, layout);
                 builder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz,null);
-                builder.addAddressGetter(fieldName, tree.name(), treeLayout);
+                builder.addAddressGetter(fieldName, tree.name(), treeLayout, null);
                 builder.addGetter(fieldName, tree.name(), treeLayout, clazz, null);
                 builder.addSetter(fieldName, tree.name(), treeLayout, clazz, null);
             }
         }
 
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StructBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StructBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StructBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StructBuilder.java
@@ -110,14 +110,14 @@
 
         addIndexSetter(javaName, nativeName, layout, type, parentLayout);
     }
 
     @Override
-    public void addAddressOf(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+    public void addAddressGetter(String javaName, String nativeName, MemoryLayout layout, MemoryLayout parentLayout) {
         incrAlign();
         indent();
-        sb.append(PUB_MODS + "MemoryAddress " + javaName + "$addressof(MemoryAddress addr) {\n");
+        sb.append(PUB_MODS + "MemoryAddress " + javaName + "$ADDR(MemoryAddress addr) {\n");
         incrAlign();
         indent();
         sb.append("return addr.segment().asSlice(");
         sb.append(parentLayout.byteOffset(MemoryLayout.PathElement.groupElement(nativeName)));
         sb.append(", ");
diff a/test/jdk/tools/jextract/test8244938/Test8244938.java b/test/jdk/tools/jextract/test8244938/Test8244938.java
--- /dev/null
+++ b/test/jdk/tools/jextract/test8244938/Test8244938.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
+import static test.jextract.test8244938.test8244938_h.*;
+
+/*
+ * @test
+ * @bug 8244938
+ * @summary Crash in foreign ABI CallArranger class when a test native function returns a nested struct
+ * @library ..
+ * @modules jdk.incubator.jextract
+ * @run driver JtregJextract -l Test8244938 -t test.jextract.test8244938 -- test8244938.h
+ * @run testng/othervm -Dforeign.restricted=permit Test8244938
+ */
+public class Test8244938 {
+    @Test
+    public void testNestedStructReturn() {
+         var seg = func();
+         assertEquals(seg.byteSize(), CPoint.sizeof());
+         var addr = seg.baseAddress();
+         assertEquals(CPoint.k$get(addr), 44);
+         var point2dAddr = CPoint.point2d$ADDR(addr);
+         assertEquals(CPoint2D.i$get(point2dAddr), 567);
+         assertEquals(CPoint2D.j$get(point2dAddr), 33);
+    }
+}
diff a/test/jdk/tools/jextract/test8244938/libTest8244938.c b/test/jdk/tools/jextract/test8244938/libTest8244938.c
--- /dev/null
+++ b/test/jdk/tools/jextract/test8244938/libTest8244938.c
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "test8244938.h"
+
+static struct Point point = { 44, { 567, 33 } };
+EXPORT struct Point func(void) {
+    return point;
+}
diff a/test/jdk/tools/jextract/test8244938/test8244938.h b/test/jdk/tools/jextract/test8244938/test8244938.h
--- /dev/null
+++ b/test/jdk/tools/jextract/test8244938/test8244938.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif // __cplusplus
+
+#ifdef _WIN64
+#define EXPORT __declspec(dllexport)
+#else
+#define EXPORT
+#endif
+
+struct Point2D {
+   int i, j;
+};
+
+struct Point {
+  int k;
+  struct Point2D point2d;
+};
+
+EXPORT struct Point func(void);
+
+#ifdef __cplusplus
+}
+#endif // __cplusplus
diff a/test/jdk/tools/jextract/test8245003/Test8245003.java b/test/jdk/tools/jextract/test8245003/Test8245003.java
--- a/test/jdk/tools/jextract/test8245003/Test8245003.java
+++ b/test/jdk/tools/jextract/test8245003/Test8245003.java
@@ -36,39 +36,39 @@
  * @run testng/othervm -Dforeign.restricted=permit Test8245003
  */
 public class Test8245003 {
     @Test
     public void testStructAccessor() {
-        var addr = special_pt$addressof();
+        var addr = special_pt$ADDR();
         assertEquals(addr.segment().byteSize(), CPoint.sizeof());
         assertEquals(CPoint.x$get(addr), 56);
         assertEquals(CPoint.y$get(addr), 75);
 
-        addr = special_pt3d$addressof();
+        addr = special_pt3d$ADDR();
         assertEquals(addr.segment().byteSize(), CPoint3D.sizeof());
         assertEquals(CPoint3D.z$get(addr), 35);
-        var pointAddr = CPoint3D.p$addressof(addr);
+        var pointAddr = CPoint3D.p$ADDR(addr);
         assertEquals(pointAddr.segment().byteSize(), CPoint.sizeof());
         assertEquals(CPoint.x$get(pointAddr), 43);
         assertEquals(CPoint.y$get(pointAddr), 45);
     }
 
     @Test
     public void testArrayAccessor() {
-        var addr = iarr$addressof();
+        var addr = iarr$ADDR();
         assertEquals(addr.segment().byteSize(), Cint.sizeof()*5);
         int[] arr = Cint.toJavaArray(addr.segment());
         assertEquals(arr.length, 5);
         assertEquals(arr[0], 2);
         assertEquals(arr[1], -2);
         assertEquals(arr[2], 42);
         assertEquals(arr[3], -42);
         assertEquals(arr[4], 345);
 
-        addr = foo$addressof();
+        addr = foo$ADDR();
         assertEquals(addr.segment().byteSize(), CFoo.sizeof());
         assertEquals(CFoo.count$get(addr), 37);
-        var greeting = CFoo.greeting$addressof(addr);
+        var greeting = CFoo.greeting$ADDR(addr);
         byte[] barr = Cchar.toJavaArray(greeting.segment());
         assertEquals(new String(barr), "hello");
     }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/NativeMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
661      *
662      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
663      * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.
664      * @return a new native memory segment.
665      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}, {@code alignmentBytes &lt; 0}, or if {@code alignmentBytes}
666      * is not a power of 2.
667      */
668     static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {
669         if (bytesSize &lt;= 0) {
670             throw new IllegalArgumentException(&quot;Invalid allocation size : &quot; + bytesSize);
671         }
672 
673         if (alignmentBytes &lt; 0 ||
674                 ((alignmentBytes &amp; (alignmentBytes - 1)) != 0L)) {
675             throw new IllegalArgumentException(&quot;Invalid alignment constraint : &quot; + alignmentBytes);
676         }
677 
678         return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
679     }
680 























681     /**
682      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
683      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
684      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
685      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
686      * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
687      * (see {@link #ALL_ACCESS}).
688      * &lt;p&gt;
689      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted methods are unsafe, and, if used incorrectly, their use might crash
690      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
691      * restricted methods, and use safe and supported functionalities, where possible.
692      *
693      * @param addr the desired base address
694      * @param bytesSize the desired size.
695      * @param owner the desired owner thread. If {@code owner == null}, the returned segment is &lt;em&gt;not&lt;/em&gt; confined.
696      * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
697      *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
698      * @param attachment an object that must be kept alive by the returned segment; this can be useful when
699      *                   the returned segment depends on memory which could be released if a certain object
700      *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
</pre>
</td>
<td>
<hr />
<pre>
661      *
662      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
663      * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.
664      * @return a new native memory segment.
665      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}, {@code alignmentBytes &lt; 0}, or if {@code alignmentBytes}
666      * is not a power of 2.
667      */
668     static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {
669         if (bytesSize &lt;= 0) {
670             throw new IllegalArgumentException(&quot;Invalid allocation size : &quot; + bytesSize);
671         }
672 
673         if (alignmentBytes &lt; 0 ||
674                 ((alignmentBytes &amp; (alignmentBytes - 1)) != 0L)) {
675             throw new IllegalArgumentException(&quot;Invalid alignment constraint : &quot; + alignmentBytes);
676         }
677 
678         return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
679     }
680 
<span class="line-added">681     /**</span>
<span class="line-added">682      * Returns a native memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.</span>
<span class="line-added">683      * This method can be very useful when dereferencing memory addresses obtained when interacting with native libraries.</span>
<span class="line-added">684      * The segment will feature the {@link #READ} and {@link #WRITE} &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>
<span class="line-added">685      * Equivalent to (but likely more efficient than) the following code:</span>
<span class="line-added">686      * &lt;pre&gt;{@code</span>
<span class="line-added">687     MemorySegment.ofNativeRestricted(MemoryAddress.NULL, Long.MAX_VALUE, null, null, null)</span>
<span class="line-added">688                  .withAccessModes(READ | WRITE);</span>
<span class="line-added">689      * }&lt;/pre&gt;</span>
<span class="line-added">690      * &lt;p&gt;</span>
<span class="line-added">691      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted methods are unsafe, and, if used incorrectly, their use might crash</span>
<span class="line-added">692      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on</span>
<span class="line-added">693      * restricted methods, and use safe and supported functionalities, where possible.</span>
<span class="line-added">694      *</span>
<span class="line-added">695      * @return a memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.</span>
<span class="line-added">696      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either</span>
<span class="line-added">697      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).</span>
<span class="line-added">698      */</span>
<span class="line-added">699     static MemorySegment ofNativeRestricted() {</span>
<span class="line-added">700         Utils.checkRestrictedAccess(&quot;MemorySegment.ofNativeRestricted&quot;);</span>
<span class="line-added">701         return NativeMemorySegmentImpl.EVERYTHING;</span>
<span class="line-added">702     }</span>
<span class="line-added">703 </span>
704     /**
705      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
706      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
707      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
708      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
709      * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
710      * (see {@link #ALL_ACCESS}).
711      * &lt;p&gt;
712      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted methods are unsafe, and, if used incorrectly, their use might crash
713      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
714      * restricted methods, and use safe and supported functionalities, where possible.
715      *
716      * @param addr the desired base address
717      * @param bytesSize the desired size.
718      * @param owner the desired owner thread. If {@code owner == null}, the returned segment is &lt;em&gt;not&lt;/em&gt; confined.
719      * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
720      *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
721      * @param attachment an object that must be kept alive by the returned segment; this can be useful when
722      *                   the returned segment depends on memory which could be released if a certain object
723      *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/NativeMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
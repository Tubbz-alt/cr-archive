diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
@@ -24,12 +24,10 @@
  *
  */
 package jdk.incubator.foreign;
 
 import jdk.internal.foreign.AbstractMemorySegmentImpl;
-import jdk.internal.foreign.MemoryAddressImpl;
-import jdk.internal.foreign.NativeMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.SharedUtils;
 
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
@@ -565,11 +563,14 @@
          */
         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
     }
 
-    private final static VarHandle byteArrHandle =
+    /**
+     * Byte array handle to read byte array from C char*
+     */
+    public final static VarHandle byteArrHandle =
             MemoryLayout.ofSequence(C_CHAR).varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
 
     /**
      * Convert a Java string into a null-terminated C string, using the
      * platform's default charset, storing the result into a new native memory segment.
@@ -666,11 +667,11 @@
      * @throws NullPointerException if {@code addr == null}
      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
      */
     public static String toJavaStringRestricted(MemoryAddress addr) {
         Utils.checkRestrictedAccess("CSupport.toJavaStringRestricted");
-        return toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), Charset.defaultCharset());
+        return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), Charset.defaultCharset());
     }
 
     /**
      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
      * <p>
@@ -688,11 +689,11 @@
      * @throws NullPointerException if {@code addr == null}
      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
      */
     public static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {
         Utils.checkRestrictedAccess("CSupport.toJavaStringRestricted");
-        return toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), charset);
+        return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), charset);
     }
 
     /**
      * Convert a null-terminated C string stored at given address into a Java string, using the platform's default charset.
      * <p>
@@ -706,11 +707,11 @@
      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
      * associated with {@code addr}, or if {@code addr} is associated with a segment that is </em>not alive<em>.
      */
     public static String toJavaString(MemoryAddress addr) {
-        return toJavaStringInternal(addr, Charset.defaultCharset());
+        return SharedUtils.toJavaStringInternal(addr, Charset.defaultCharset());
     }
 
     /**
      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
      * <p>
@@ -725,30 +726,11 @@
      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
      * associated with {@code addr}, or if {@code addr} is associated with a segment that is </em>not alive<em>.
      */
     public static String toJavaString(MemoryAddress addr, Charset charset) {
-        return toJavaStringInternal(addr, charset);
-    }
-
-    private static String toJavaStringInternal(MemoryAddress addr, Charset charset) {
-        int len = strlen(addr);
-        byte[] bytes = new byte[len];
-        MemorySegment.ofArray(bytes)
-                .copyFrom(NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, len, null, null, null));
-        return new String(bytes, charset);
-    }
-
-    private static int strlen(MemoryAddress address) {
-        // iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)
-        for (int offset = 0; offset >= 0; offset++) {
-            byte curr = (byte) byteArrHandle.get(address, (long) offset);
-            if (curr == 0) {
-                return offset;
-            }
-        }
-        throw new IllegalArgumentException("String too large");
+        return SharedUtils.toJavaStringInternal(addr, charset);
     }
 
     private static void copy(MemoryAddress addr, byte[] bytes) {
         var heapSegment = MemorySegment.ofArray(bytes);
         addr.segment().copyFrom(heapSegment);
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
@@ -33,21 +33,22 @@
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.MemoryAddressImpl;
+import jdk.internal.foreign.NativeMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.aarch64.AArch64Linker;
-import jdk.internal.foreign.abi.x64.sysv.SysVVaList;
 import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;
 import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
+import java.nio.charset.Charset;
 import java.util.List;
 import java.util.function.Consumer;
 import java.util.stream.IntStream;
 
 import static java.lang.invoke.MethodHandles.collectArguments;
@@ -255,10 +256,30 @@
             return AArch64Linker.getInstance();
         }
         throw new UnsupportedOperationException("Unsupported os or arch: " + os + ", " + arch);
     }
 
+    public static String toJavaStringInternal(MemoryAddress addr, Charset charset) {
+        int len = strlen(addr);
+        byte[] bytes = new byte[len];
+        MemorySegment.ofArray(bytes)
+                .copyFrom(NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, len, null, null, null));
+        return new String(bytes, charset);
+    }
+
+    private static int strlen(MemoryAddress address) {
+        // iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)
+        for (int offset = 0; offset >= 0; offset++) {
+            byte curr = (byte) CSupport.byteArrHandle.get(address, (long) offset);
+            if (curr == 0) {
+                return offset;
+            }
+        }
+        throw new IllegalArgumentException("String too large");
+    }
+
+
     public static VaList newVaList(Consumer<VaList.Builder> actions) {
         String name = CSupport.getSystemLinker().name();
         return switch(name) {
             case Win64.NAME -> Windowsx64Linker.newVaList(actions);
             case SysV.NAME -> SysVx64Linker.newVaList(actions);

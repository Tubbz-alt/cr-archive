diff a/test/jdk/java/foreign/TestAddressHandle.java b/test/jdk/java/foreign/TestAddressHandle.java
--- a/test/jdk/java/foreign/TestAddressHandle.java
+++ b/test/jdk/java/foreign/TestAddressHandle.java
@@ -22,21 +22,45 @@
  *
  */
 
 /*
  * @test
- * @run testng TestAddressHandle
+ * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAddressHandle
+ * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAddressHandle
+ * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAddressHandle
+ * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAddressHandle
  */
 
 import java.lang.invoke.*;
 import java.nio.ByteOrder;
 import jdk.incubator.foreign.*;
 
 import org.testng.annotations.*;
 import static org.testng.Assert.*;
 
 public class TestAddressHandle {
+
+    static final MethodHandle INT_TO_BOOL;
+    static final MethodHandle BOOL_TO_INT;
+    static final MethodHandle INT_TO_STRING;
+    static final MethodHandle STRING_TO_INT;
+
+    static {
+        try {
+            INT_TO_BOOL = MethodHandles.lookup().findStatic(TestAddressHandle.class, "intToBool",
+                    MethodType.methodType(boolean.class, int.class));
+            BOOL_TO_INT = MethodHandles.lookup().findStatic(TestAddressHandle.class, "boolToInt",
+                    MethodType.methodType(int.class, boolean.class));
+            INT_TO_STRING = MethodHandles.lookup().findStatic(TestAddressHandle.class, "intToString",
+                    MethodType.methodType(String.class, int.class));
+            STRING_TO_INT = MethodHandles.lookup().findStatic(TestAddressHandle.class, "stringToInt",
+                    MethodType.methodType(int.class, String.class));
+        } catch (Throwable ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
+
     @Test(dataProvider = "addressHandles")
     public void testAddressHandle(VarHandle addrHandle) {
         VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
         try (MemorySegment segment = MemorySegment.allocateNative(8)) {
             longHandle.set(segment.baseAddress(), 42L);
@@ -62,14 +86,77 @@
             MemoryAddress address = (MemoryAddress)addrHandle.get(segment.baseAddress());
             assertTrue(address == MemoryAddress.NULL);
         }
     }
 
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadAdaptFloat() {
+        VarHandle floatHandle = MemoryHandles.varHandle(float.class, ByteOrder.nativeOrder());
+        MemoryHandles.asAddressVarHandle(floatHandle);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadAdaptDouble() {
+        VarHandle doubleHandle = MemoryHandles.varHandle(double.class, ByteOrder.nativeOrder());
+        MemoryHandles.asAddressVarHandle(doubleHandle);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadAdaptBoolean() {
+        VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle boolHandle = MethodHandles.filterValue(intHandle, BOOL_TO_INT, INT_TO_BOOL);
+        MemoryHandles.asAddressVarHandle(boolHandle);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadAdaptString() {
+        VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle stringHandle = MethodHandles.filterValue(intHandle, STRING_TO_INT, INT_TO_STRING);
+        MemoryHandles.asAddressVarHandle(stringHandle);
+    }
+
     @DataProvider(name = "addressHandles")
     static Object[][] addressHandles() {
         return new Object[][] {
-            { MemoryHandles.varHandle(MemoryAddress.class, ByteOrder.nativeOrder()) },
-            { MemoryHandles.withOffset(MemoryHandles.varHandle(MemoryAddress.class, ByteOrder.nativeOrder()), 0) },
-            { MemoryLayouts.JAVA_LONG.varHandle(MemoryAddress.class) }
+                // long
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_LONG.varHandle(long.class)) },
+
+                // int
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_INT.varHandle(int.class)) },
+
+                // short
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_SHORT.varHandle(short.class)) },
+
+                // char
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_CHAR.varHandle(char.class)) },
+
+                // byte
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_BYTE.varHandle(byte.class)) }
         };
     }
+
+    static int boolToInt(boolean value) {
+        return value ? 1 : 0;
+    }
+
+    static boolean intToBool(int value) {
+        return value != 0;
+    }
+
+    static int stringToInt(String value) {
+        return value.length();
+    }
+
+    static String intToString(int value) {
+        return String.valueOf(value);
+    }
 }

diff a/make/gensrc/GensrcVarHandles.gmk b/make/gensrc/GensrcVarHandles.gmk
--- a/make/gensrc/GensrcVarHandles.gmk
+++ b/make/gensrc/GensrcVarHandles.gmk
@@ -158,18 +158,18 @@
 endef
 
 ################################################################################
 
 ################################################################################
-# Setup a rule for generating a VarHandleMemoryAddress java class
+# Setup a rule for generating a memory access var handle helper classes
 # Param 1 - Variable declaration prefix
 # Param 2 - Type with first letter capitalized
-define GenerateVarHandleMemoryAddress
+define GenerateVarHandleMemoryAccess
 
   $1_Type := $2
 
-  $1_FILENAME := $(VARHANDLES_GENSRC_DIR)/VarHandleMemoryAddressAs$$($1_Type)s.java
+  $1_FILENAME := $(VARHANDLES_GENSRC_DIR)/MemoryAccessVarHandle$$($1_Type)Helper.java
 
   ifeq ($$($1_Type), Byte)
     $1_type := byte
     $1_BoxType := $$($1_Type)
 
@@ -246,11 +246,11 @@
 
     $1_ARGS += -KCAS
     $1_ARGS += -KfloatingPoint
   endif
 
-  $$($1_FILENAME): $(VARHANDLES_SRC_DIR)/X-VarHandleMemoryAddressView.java.template $(BUILD_TOOLS_JDK)
+  $$($1_FILENAME): $(VARHANDLES_SRC_DIR)/X-VarHandleMemoryAccess.java.template $(BUILD_TOOLS_JDK)
 	$$(call MakeDir, $$(@D))
 	$(RM) $$@
 	$(TOOL_SPP) -nel -K$$($1_type) \
 	    -Dtype=$$($1_type) -DType=$$($1_Type) -DBoxType=$$($1_BoxType) \
 	    -DrawType=$$($1_rawType) -DRawType=$$($1_RawType) -DRawBoxType=$$($1_RawBoxType) \
@@ -272,11 +272,11 @@
   $(eval $(call GenerateVarHandleByteArray,VAR_HANDLE_BYTE_ARRAY_$t,$t)))
 
 # List the types to generate source for, with capitalized first letter
 VARHANDLES_MEMORY_ADDRESS_TYPES := Byte Short Char Int Long Float Double
 $(foreach t, $(VARHANDLES_MEMORY_ADDRESS_TYPES), \
-  $(eval $(call GenerateVarHandleMemoryAddress,VAR_HANDLE_MEMORY_ADDRESS_$t,$t)))
+  $(eval $(call GenerateVarHandleMemoryAccess,VAR_HANDLE_MEMORY_ADDRESS_$t,$t)))
 
 GENSRC_JAVA_BASE += $(GENSRC_VARHANDLES)
 
 # Include custom extension post hook
 $(eval $(call IncludeCustomExtension, gensrc/GensrcVarHandles-post.gmk))
diff a/src/java.base/share/classes/java/lang/invoke/AddressVarHandleGenerator.java b/src/java.base/share/classes/java/lang/invoke/AddressVarHandleGenerator.java
--- a/src/java.base/share/classes/java/lang/invoke/AddressVarHandleGenerator.java
+++ /dev/null
@@ -1,531 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package java.lang.invoke;
-
-import jdk.internal.access.foreign.MemoryAddressProxy;
-import jdk.internal.misc.Unsafe;
-import jdk.internal.org.objectweb.asm.ClassReader;
-import jdk.internal.org.objectweb.asm.ClassWriter;
-import jdk.internal.org.objectweb.asm.MethodVisitor;
-import jdk.internal.org.objectweb.asm.Opcodes;
-import jdk.internal.org.objectweb.asm.Type;
-import jdk.internal.org.objectweb.asm.util.TraceClassVisitor;
-import jdk.internal.vm.annotation.ForceInline;
-import sun.security.action.GetBooleanAction;
-import sun.security.action.GetPropertyAction;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_FINAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PRIVATE;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_STATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_SUPER;
-import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;
-import static jdk.internal.org.objectweb.asm.Opcodes.BIPUSH;
-import static jdk.internal.org.objectweb.asm.Opcodes.CHECKCAST;
-import static jdk.internal.org.objectweb.asm.Opcodes.GETFIELD;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_0;
-import static jdk.internal.org.objectweb.asm.Opcodes.ILOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.LALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.LASTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.LLOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.NEWARRAY;
-import static jdk.internal.org.objectweb.asm.Opcodes.PUTFIELD;
-import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;
-import static jdk.internal.org.objectweb.asm.Opcodes.DUP;
-import static jdk.internal.org.objectweb.asm.Opcodes.SIPUSH;
-import static jdk.internal.org.objectweb.asm.Opcodes.T_LONG;
-
-class AddressVarHandleGenerator {
-    private static final String DEBUG_DUMP_CLASSES_DIR_PROPERTY = "jdk.internal.foreign.ClassGenerator.DEBUG_DUMP_CLASSES_DIR";
-
-    private static final boolean DEBUG =
-            GetBooleanAction.privilegedGetProperty("jdk.internal.foreign.ClassGenerator.DEBUG");
-
-    private static final Class<?> BASE_CLASS = VarHandleMemoryAddressBase.class;
-
-    private static final HashMap<Class<?>, Class<?>> helperClassCache;
-
-    private final static MethodType OFFSET_OP_TYPE;
-
-    private final static MethodHandle ADD_OFFSETS_HANDLE;
-    private final static MethodHandle MUL_OFFSETS_HANDLE;
-
-    static {
-        helperClassCache = new HashMap<>();
-        helperClassCache.put(byte.class, VarHandleMemoryAddressAsBytes.class);
-        helperClassCache.put(short.class, VarHandleMemoryAddressAsShorts.class);
-        helperClassCache.put(char.class, VarHandleMemoryAddressAsChars.class);
-        helperClassCache.put(int.class, VarHandleMemoryAddressAsInts.class);
-        helperClassCache.put(long.class, VarHandleMemoryAddressAsLongs.class);
-        helperClassCache.put(float.class, VarHandleMemoryAddressAsFloats.class);
-        helperClassCache.put(double.class, VarHandleMemoryAddressAsDoubles.class);
-        helperClassCache.put(MemoryAddressProxy.class, VarHandleMemoryAddressAsLongs.class);
-
-        OFFSET_OP_TYPE = MethodType.methodType(long.class, long.class, long.class, MemoryAddressProxy.class);
-
-        try {
-            ADD_OFFSETS_HANDLE = MethodHandles.Lookup.IMPL_LOOKUP.findStatic(MemoryAddressProxy.class, "addOffsets", OFFSET_OP_TYPE);
-            MUL_OFFSETS_HANDLE = MethodHandles.Lookup.IMPL_LOOKUP.findStatic(MemoryAddressProxy.class, "multiplyOffsets", OFFSET_OP_TYPE);
-        } catch (Throwable ex) {
-            throw new ExceptionInInitializerError(ex);
-        }
-    }
-
-    private static final File DEBUG_DUMP_CLASSES_DIR;
-
-    static {
-        String path = GetPropertyAction.privilegedGetProperty(DEBUG_DUMP_CLASSES_DIR_PROPERTY);
-        if (path == null) {
-            DEBUG_DUMP_CLASSES_DIR = null;
-        } else {
-            DEBUG_DUMP_CLASSES_DIR = new File(path);
-        }
-    }
-
-    private static final Unsafe U = Unsafe.getUnsafe();
-
-    private final String implClassName;
-    private final int dimensions;
-    private final Class<?> carrier;
-    private final Class<?> helperClass;
-    private final VarForm form;
-
-    AddressVarHandleGenerator(Class<?> carrier, int dims) {
-        this.dimensions = dims;
-        this.carrier = carrier;
-        Class<?>[] components = new Class<?>[dimensions];
-        Arrays.fill(components, long.class);
-        this.form = new VarForm(BASE_CLASS, MemoryAddressProxy.class, lower(carrier), components);
-        this.helperClass = helperClassCache.get(carrier);
-        this.implClassName = helperClass.getName().replace('.', '/') + dimensions;
-    }
-
-    static Class<?> lower(Class<?> type) {
-        return type == MemoryAddressProxy.class ?
-                long.class : type;
-    }
-
-    /*
-     * Generate a VarHandle memory access factory.
-     * The factory has type (ZJJ[J)VarHandle.
-     */
-    MethodHandle generateHandleFactory() {
-        Class<?> implCls = generateClass();
-        try {
-            Class<?>[] components = new Class<?>[dimensions];
-            Arrays.fill(components, long.class);
-
-            VarForm form = new VarForm(implCls, MemoryAddressProxy.class, lower(carrier), components);
-
-            MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);
-            MethodHandle constr = MethodHandles.Lookup.IMPL_LOOKUP.findConstructor(implCls, constrType);
-            constr = MethodHandles.insertArguments(constr, 0, form);
-            return constr;
-        } catch (Throwable ex) {
-            throw new AssertionError(ex);
-        }
-    }
-
-    /*
-     * Generate a specialized VarHandle class for given carrier
-     * and access coordinates.
-     */
-    Class<?> generateClass() {
-        BinderClassWriter cw = new BinderClassWriter();
-
-        if (DEBUG) {
-            System.out.println("Generating header implementation class");
-        }
-
-        cw.visit(52, ACC_PUBLIC | ACC_SUPER, implClassName, null, Type.getInternalName(BASE_CLASS), null);
-
-        //add dimension fields
-        for (int i = 0; i < dimensions; i++) {
-            cw.visitField(ACC_PRIVATE | ACC_FINAL, "dim" + i, "J", null, null);
-        }
-
-        addConstructor(cw);
-
-        addAccessModeTypeMethod(cw);
-
-        addStridesAccessor(cw);
-
-        addCarrierAccessor(cw);
-
-        for (VarHandle.AccessMode mode : VarHandle.AccessMode.values()) {
-            addAccessModeMethodIfNeeded(mode, cw);
-        }
-
-
-        cw.visitEnd();
-        byte[] classBytes = cw.toByteArray();
-        return defineClass(cw, classBytes);
-    }
-
-    void addConstructor(BinderClassWriter cw) {
-        MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);
-        MethodVisitor mv = cw.visitMethod(0, "<init>", constrType.toMethodDescriptorString(), null, null);
-        mv.visitCode();
-        //super call
-        mv.visitVarInsn(ALOAD, 0);
-        mv.visitVarInsn(ALOAD, 1);
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(VarForm.class));
-        mv.visitVarInsn(ILOAD, 2);
-        mv.visitVarInsn(LLOAD, 3);
-        mv.visitVarInsn(LLOAD, 5);
-        mv.visitVarInsn(LLOAD, 7);
-        mv.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(BASE_CLASS), "<init>",
-                MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class).toMethodDescriptorString(), false);
-        //init dimensions
-        for (int i = 0 ; i < dimensions ; i++) {
-            mv.visitVarInsn(ALOAD, 0);
-            mv.visitVarInsn(ALOAD, 9);
-            mv.visitLdcInsn(i);
-            mv.visitInsn(LALOAD);
-            mv.visitFieldInsn(PUTFIELD, implClassName, "dim" + i, "J");
-        }
-        mv.visitInsn(RETURN);
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    void addAccessModeTypeMethod(BinderClassWriter cw) {
-        MethodType modeMethType = MethodType.methodType(MethodType.class, VarHandle.AccessMode.class);
-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "accessModeTypeUncached", modeMethType.toMethodDescriptorString(), null, null);
-        mv.visitCode();
-        mv.visitVarInsn(ALOAD, 1);
-        mv.visitFieldInsn(GETFIELD, Type.getInternalName(VarHandle.AccessMode.class), "at", Type.getDescriptor(VarHandle.AccessType.class));
-        mv.visitLdcInsn(cw.makeConstantPoolPatch(MemoryAddressProxy.class));
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
-        mv.visitLdcInsn(cw.makeConstantPoolPatch(lower(carrier)));
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
-
-        Class<?>[] dims = new Class<?>[dimensions];
-        Arrays.fill(dims, long.class);
-        mv.visitLdcInsn(cw.makeConstantPoolPatch(dims));
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class[].class));
-
-        mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(VarHandle.AccessType.class),
-                "accessModeType", MethodType.methodType(MethodType.class, Class.class, Class.class, Class[].class).toMethodDescriptorString(), false);
-
-        mv.visitInsn(ARETURN);
-
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    void addAccessModeMethodIfNeeded(VarHandle.AccessMode mode, BinderClassWriter cw) {
-        String methName = mode.methodName();
-        MethodType methType = form.getMethodType(mode.at.ordinal())
-                .insertParameterTypes(0, VarHandle.class);
-
-        try {
-            MethodType helperType = methType.insertParameterTypes(2, long.class);
-            if (dimensions > 0) {
-                helperType = helperType.dropParameterTypes(3, 3 + dimensions);
-            }
-            //try to resolve...
-            String helperMethodName = methName + "0";
-            MethodHandles.Lookup.IMPL_LOOKUP
-                    .findStatic(helperClass,
-                            helperMethodName,
-                            helperType);
-
-
-            MethodVisitor mv = cw.visitMethod(ACC_STATIC, methName, methType.toMethodDescriptorString(), null, null);
-            mv.visitAnnotation(Type.getDescriptor(ForceInline.class), true);
-            mv.visitCode();
-
-            mv.visitVarInsn(ALOAD, 0); // handle impl
-            mv.visitVarInsn(ALOAD, 1); // receiver
-
-            // offset calculation
-            int slot = 2;
-            mv.visitVarInsn(ALOAD, 0); // load recv
-            mv.visitTypeInsn(CHECKCAST, Type.getInternalName(BASE_CLASS));
-            mv.visitFieldInsn(GETFIELD, Type.getInternalName(BASE_CLASS), "offset", "J");
-            for (int i = 0 ; i < dimensions ; i++) {
-                // load ADD MH
-                mv.visitLdcInsn(cw.makeConstantPoolPatch(ADD_OFFSETS_HANDLE));
-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
-
-                //fixup stack so that ADD MH ends up bottom
-                mv.visitInsn(Opcodes.DUP_X2);
-                mv.visitInsn(Opcodes.POP);
-
-                // load MUL MH
-                mv.visitLdcInsn(cw.makeConstantPoolPatch(MUL_OFFSETS_HANDLE));
-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
-
-                mv.visitVarInsn(ALOAD, 0); // load recv
-                mv.visitTypeInsn(CHECKCAST, implClassName);
-                mv.visitFieldInsn(GETFIELD, implClassName, "dim" + i, "J");
-                mv.visitVarInsn(LLOAD, slot);
-
-                mv.visitVarInsn(ALOAD, 1); // receiver
-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MemoryAddressProxy.class));
-
-                //MUL
-                mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(MethodHandle.class), "invokeExact",
-                        OFFSET_OP_TYPE.toMethodDescriptorString(), false);
-
-                mv.visitVarInsn(ALOAD, 1); // receiver
-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MemoryAddressProxy.class));
-
-                //ADD
-                mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(MethodHandle.class), "invokeExact",
-                        OFFSET_OP_TYPE.toMethodDescriptorString(), false);
-                slot += 2;
-            }
-
-            for (int i = 2 + dimensions; i < methType.parameterCount() ; i++) {
-                Class<?> param = methType.parameterType(i);
-                mv.visitVarInsn(loadInsn(param), slot); // load index
-                slot += getSlotsForType(param);
-            }
-
-            //call helper
-            mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(helperClass), helperMethodName,
-                    helperType.toMethodDescriptorString(), false);
-
-            mv.visitInsn(returnInsn(helperType.returnType()));
-
-            mv.visitMaxs(0, 0);
-            mv.visitEnd();
-        } catch (ReflectiveOperationException ex) {
-            //not found, skip
-        }
-    }
-
-    void addStridesAccessor(BinderClassWriter cw) {
-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "strides", "()[J", null, null);
-        mv.visitCode();
-        iConstInsn(mv, dimensions);
-        mv.visitIntInsn(NEWARRAY, T_LONG);
-
-        for (int i = 0 ; i < dimensions ; i++) {
-            mv.visitInsn(DUP);
-            iConstInsn(mv, i);
-            mv.visitVarInsn(ALOAD, 0);
-            mv.visitFieldInsn(GETFIELD, implClassName, "dim" + i, "J");
-            mv.visitInsn(LASTORE);
-        }
-
-        mv.visitInsn(ARETURN);
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    void addCarrierAccessor(BinderClassWriter cw) {
-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "carrier", "()Ljava/lang/Class;", null, null);
-        mv.visitCode();
-        mv.visitLdcInsn(cw.makeConstantPoolPatch(carrier));
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
-        mv.visitInsn(ARETURN);
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    //where
-    private Class<?> defineClass(BinderClassWriter cw, byte[] classBytes) {
-        try {
-            if (DEBUG_DUMP_CLASSES_DIR != null) {
-                debugWriteClassToFile(classBytes);
-            }
-            Object[] patches = cw.resolvePatches(classBytes);
-            Class<?> c = U.defineAnonymousClass(BASE_CLASS, classBytes, patches);
-            return c;
-        } catch (Throwable e) {
-            debugPrintClass(classBytes);
-            throw e;
-        }
-    }
-
-    // shared code generation helpers
-
-    private static int getSlotsForType(Class<?> c) {
-        if (c == long.class || c == double.class) {
-            return 2;
-        }
-        return 1;
-    }
-
-    /**
-     * Emits an actual return instruction conforming to the given return type.
-     */
-    private int returnInsn(Class<?> type) {
-        return switch (LambdaForm.BasicType.basicType(type)) {
-            case I_TYPE -> Opcodes.IRETURN;
-            case J_TYPE -> Opcodes.LRETURN;
-            case F_TYPE -> Opcodes.FRETURN;
-            case D_TYPE -> Opcodes.DRETURN;
-            case L_TYPE -> Opcodes.ARETURN;
-            case V_TYPE -> RETURN;
-        };
-    }
-
-    private int loadInsn(Class<?> type) {
-        return switch (LambdaForm.BasicType.basicType(type)) {
-            case I_TYPE -> Opcodes.ILOAD;
-            case J_TYPE -> LLOAD;
-            case F_TYPE -> Opcodes.FLOAD;
-            case D_TYPE -> Opcodes.DLOAD;
-            case L_TYPE -> Opcodes.ALOAD;
-            case V_TYPE -> throw new IllegalStateException("Cannot load void");
-        };
-    }
-
-    private static void iConstInsn(MethodVisitor mv, int i) {
-        switch (i) {
-            case -1, 0, 1, 2, 3, 4, 5:
-                mv.visitInsn(ICONST_0 + i);
-                break;
-            default:
-                if(i >= Byte.MIN_VALUE && i <= Byte.MAX_VALUE) {
-                    mv.visitIntInsn(BIPUSH, i);
-                } else if (i >= Short.MIN_VALUE && i <= Short.MAX_VALUE) {
-                    mv.visitIntInsn(SIPUSH, i);
-                } else {
-                    mv.visitLdcInsn(i);
-                }
-        }
-    }
-
-    // debug helpers
-
-    private static String debugPrintClass(byte[] classFile) {
-        ClassReader cr = new ClassReader(classFile);
-        StringWriter sw = new StringWriter();
-        cr.accept(new TraceClassVisitor(new PrintWriter(sw)), 0);
-        return sw.toString();
-    }
-
-    private void debugWriteClassToFile(byte[] classFile) {
-        File file = new File(DEBUG_DUMP_CLASSES_DIR, implClassName + ".class");
-
-        if (DEBUG) {
-            System.err.println("Dumping class " + implClassName + " to " + file);
-        }
-
-        try {
-            debugWriteDataToFile(classFile, file);
-        } catch (Exception e) {
-            throw new RuntimeException("Failed to write class " + implClassName + " to file " + file);
-        }
-    }
-
-    private void debugWriteDataToFile(byte[] data, File file) {
-        if (file.exists()) {
-            file.delete();
-        }
-        if (file.exists()) {
-            throw new RuntimeException("Failed to remove pre-existing file " + file);
-        }
-
-        File parent = file.getParentFile();
-        if (!parent.exists()) {
-            parent.mkdirs();
-        }
-        if (!parent.exists()) {
-            throw new RuntimeException("Failed to create " + parent);
-        }
-        if (!parent.isDirectory()) {
-            throw new RuntimeException(parent + " is not a directory");
-        }
-
-        try (FileOutputStream fos = new FileOutputStream(file)) {
-            fos.write(data);
-        } catch (IOException e) {
-            throw new RuntimeException("Failed to write class " + implClassName + " to file " + file);
-        }
-    }
-
-    static class BinderClassWriter extends ClassWriter {
-
-        private final ArrayList<ConstantPoolPatch> cpPatches = new ArrayList<>();
-        private int curUniquePatchIndex = 0;
-
-        BinderClassWriter() {
-            super(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
-        }
-
-        public String makeConstantPoolPatch(Object o) {
-            int myUniqueIndex = curUniquePatchIndex++;
-            String cpPlaceholder = "CONSTANT_PLACEHOLDER_" + myUniqueIndex;
-            int index = newConst(cpPlaceholder);
-            cpPatches.add(new ConstantPoolPatch(index, cpPlaceholder, o));
-            return cpPlaceholder;
-        }
-
-        public Object[] resolvePatches(byte[] classFile) {
-            if (cpPatches.isEmpty()) {
-                return null;
-            }
-
-            int size = ((classFile[8] & 0xFF) << 8) | (classFile[9] & 0xFF);
-
-            Object[] patches = new Object[size];
-            for (ConstantPoolPatch p : cpPatches) {
-                if (p.index >= size) {
-                    throw new InternalError("Failed to resolve constant pool patch entries");
-                }
-                patches[p.index] = p.value;
-            }
-
-            return patches;
-        }
-
-        static class ConstantPoolPatch {
-            final int index;
-            final String placeholder;
-            final Object value;
-
-            ConstantPoolPatch(int index, String placeholder, Object value) {
-                this.index = index;
-                this.placeholder = placeholder;
-                this.value = value;
-            }
-
-            @Override
-            public String toString() {
-                return "CpPatch/index="+index+",placeholder="+placeholder+",value="+value;
-            }
-        }
-    }
-}
diff a/src/java.base/share/classes/java/lang/invoke/IndirectVarHandle.java b/src/java.base/share/classes/java/lang/invoke/IndirectVarHandle.java
--- a/src/java.base/share/classes/java/lang/invoke/IndirectVarHandle.java
+++ b/src/java.base/share/classes/java/lang/invoke/IndirectVarHandle.java
@@ -84,10 +84,14 @@
     @Override
     VarHandle asDirect() {
         return directTarget;
     }
 
+    VarHandle target() {
+        return target;
+    }
+
     @Override
     @ForceInline
     MethodHandle getMethodHandle(int mode) {
         MethodHandle handle = handleMap[mode];
         if (handle == null) {
diff a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java
--- /dev/null
+++ b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang.invoke;
+
+/**
+ * Base class for memory access var handle implementations.
+ */
+abstract class MemoryAccessVarHandleBase extends VarHandle {
+
+    /** endianness **/
+    final boolean be;
+
+    /** access size (in bytes, computed from var handle carrier type) **/
+    final long length;
+
+    /** access offset (in bytes); must be compatible with {@code alignmentMask} **/
+    final long offset;
+
+    /** alignment constraint (in bytes, expressed as a bit mask) **/
+    final long alignmentMask;
+
+    MemoryAccessVarHandleBase(VarForm form, boolean be, long length, long offset, long alignmentMask) {
+        super(form);
+        this.be = be;
+        this.length = length;
+        this.offset = offset;
+        this.alignmentMask = alignmentMask;
+    }
+
+    static IllegalStateException newIllegalStateExceptionForMisalignedAccess(long address) {
+        return new IllegalStateException("Misaligned access at address: " + address);
+    }
+
+    /**
+     * Strides used for multi-dimensional access; each stride must be compatible with {@code alignmentMask}.
+     */
+    abstract long[] strides();
+
+    abstract Class<?> carrier();
+}
diff a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java
--- /dev/null
+++ b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java
@@ -0,0 +1,525 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang.invoke;
+
+import jdk.internal.access.foreign.MemoryAddressProxy;
+import jdk.internal.misc.Unsafe;
+import jdk.internal.org.objectweb.asm.ClassReader;
+import jdk.internal.org.objectweb.asm.ClassWriter;
+import jdk.internal.org.objectweb.asm.MethodVisitor;
+import jdk.internal.org.objectweb.asm.Opcodes;
+import jdk.internal.org.objectweb.asm.Type;
+import jdk.internal.org.objectweb.asm.util.TraceClassVisitor;
+import jdk.internal.vm.annotation.ForceInline;
+import sun.security.action.GetBooleanAction;
+import sun.security.action.GetPropertyAction;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+
+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_FINAL;
+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PRIVATE;
+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;
+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_STATIC;
+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_SUPER;
+import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;
+import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;
+import static jdk.internal.org.objectweb.asm.Opcodes.BIPUSH;
+import static jdk.internal.org.objectweb.asm.Opcodes.CHECKCAST;
+import static jdk.internal.org.objectweb.asm.Opcodes.GETFIELD;
+import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_0;
+import static jdk.internal.org.objectweb.asm.Opcodes.ILOAD;
+import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;
+import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESTATIC;
+import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
+import static jdk.internal.org.objectweb.asm.Opcodes.LALOAD;
+import static jdk.internal.org.objectweb.asm.Opcodes.LASTORE;
+import static jdk.internal.org.objectweb.asm.Opcodes.LLOAD;
+import static jdk.internal.org.objectweb.asm.Opcodes.NEWARRAY;
+import static jdk.internal.org.objectweb.asm.Opcodes.PUTFIELD;
+import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;
+import static jdk.internal.org.objectweb.asm.Opcodes.DUP;
+import static jdk.internal.org.objectweb.asm.Opcodes.SIPUSH;
+import static jdk.internal.org.objectweb.asm.Opcodes.T_LONG;
+
+class MemoryAccessVarHandleGenerator {
+    private static final String DEBUG_DUMP_CLASSES_DIR_PROPERTY = "jdk.internal.foreign.ClassGenerator.DEBUG_DUMP_CLASSES_DIR";
+
+    private static final boolean DEBUG =
+        GetBooleanAction.privilegedGetProperty("jdk.internal.foreign.ClassGenerator.DEBUG");
+
+    private static final Class<?> BASE_CLASS = MemoryAccessVarHandleBase.class;
+
+    private static final HashMap<Class<?>, Class<?>> helperClassCache;
+
+    private final static MethodType OFFSET_OP_TYPE;
+
+    private final static MethodHandle ADD_OFFSETS_HANDLE;
+    private final static MethodHandle MUL_OFFSETS_HANDLE;
+
+    static {
+        helperClassCache = new HashMap<>();
+        helperClassCache.put(byte.class, MemoryAccessVarHandleByteHelper.class);
+        helperClassCache.put(short.class, MemoryAccessVarHandleShortHelper.class);
+        helperClassCache.put(char.class, MemoryAccessVarHandleCharHelper.class);
+        helperClassCache.put(int.class, MemoryAccessVarHandleIntHelper.class);
+        helperClassCache.put(long.class, MemoryAccessVarHandleLongHelper.class);
+        helperClassCache.put(float.class, MemoryAccessVarHandleFloatHelper.class);
+        helperClassCache.put(double.class, MemoryAccessVarHandleDoubleHelper.class);
+
+        OFFSET_OP_TYPE = MethodType.methodType(long.class, long.class, long.class, MemoryAddressProxy.class);
+
+        try {
+            ADD_OFFSETS_HANDLE = MethodHandles.Lookup.IMPL_LOOKUP.findStatic(MemoryAddressProxy.class, "addOffsets", OFFSET_OP_TYPE);
+            MUL_OFFSETS_HANDLE = MethodHandles.Lookup.IMPL_LOOKUP.findStatic(MemoryAddressProxy.class, "multiplyOffsets", OFFSET_OP_TYPE);
+        } catch (Throwable ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
+
+    private static final File DEBUG_DUMP_CLASSES_DIR;
+
+    static {
+        String path = GetPropertyAction.privilegedGetProperty(DEBUG_DUMP_CLASSES_DIR_PROPERTY);
+        if (path == null) {
+            DEBUG_DUMP_CLASSES_DIR = null;
+        } else {
+            DEBUG_DUMP_CLASSES_DIR = new File(path);
+        }
+    }
+
+    private static final Unsafe U = Unsafe.getUnsafe();
+
+    private final String implClassName;
+    private final int dimensions;
+    private final Class<?> carrier;
+    private final Class<?> helperClass;
+    private final VarForm form;
+
+    MemoryAccessVarHandleGenerator(Class<?> carrier, int dims) {
+        this.dimensions = dims;
+        this.carrier = carrier;
+        Class<?>[] components = new Class<?>[dimensions];
+        Arrays.fill(components, long.class);
+        this.form = new VarForm(BASE_CLASS, MemoryAddressProxy.class, carrier, components);
+        this.helperClass = helperClassCache.get(carrier);
+        this.implClassName = helperClass.getName().replace('.', '/') + dimensions;
+    }
+
+    /*
+     * Generate a VarHandle memory access factory.
+     * The factory has type (ZJJ[J)VarHandle.
+     */
+    MethodHandle generateHandleFactory() {
+        Class<?> implCls = generateClass();
+        try {
+            Class<?>[] components = new Class<?>[dimensions];
+            Arrays.fill(components, long.class);
+
+            VarForm form = new VarForm(implCls, MemoryAddressProxy.class, carrier, components);
+
+            MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);
+            MethodHandle constr = MethodHandles.Lookup.IMPL_LOOKUP.findConstructor(implCls, constrType);
+            constr = MethodHandles.insertArguments(constr, 0, form);
+            return constr;
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+
+    /*
+     * Generate a specialized VarHandle class for given carrier
+     * and access coordinates.
+     */
+    Class<?> generateClass() {
+        BinderClassWriter cw = new BinderClassWriter();
+
+        if (DEBUG) {
+            System.out.println("Generating header implementation class");
+        }
+
+        cw.visit(52, ACC_PUBLIC | ACC_SUPER, implClassName, null, Type.getInternalName(BASE_CLASS), null);
+
+        //add dimension fields
+        for (int i = 0; i < dimensions; i++) {
+            cw.visitField(ACC_PRIVATE | ACC_FINAL, "dim" + i, "J", null, null);
+        }
+
+        addConstructor(cw);
+
+        addAccessModeTypeMethod(cw);
+
+        addStridesAccessor(cw);
+
+        addCarrierAccessor(cw);
+
+        for (VarHandle.AccessMode mode : VarHandle.AccessMode.values()) {
+            addAccessModeMethodIfNeeded(mode, cw);
+        }
+
+
+        cw.visitEnd();
+        byte[] classBytes = cw.toByteArray();
+        return defineClass(cw, classBytes);
+    }
+
+    void addConstructor(BinderClassWriter cw) {
+        MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);
+        MethodVisitor mv = cw.visitMethod(0, "<init>", constrType.toMethodDescriptorString(), null, null);
+        mv.visitCode();
+        //super call
+        mv.visitVarInsn(ALOAD, 0);
+        mv.visitVarInsn(ALOAD, 1);
+        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(VarForm.class));
+        mv.visitVarInsn(ILOAD, 2);
+        mv.visitVarInsn(LLOAD, 3);
+        mv.visitVarInsn(LLOAD, 5);
+        mv.visitVarInsn(LLOAD, 7);
+        mv.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(BASE_CLASS), "<init>",
+                MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class).toMethodDescriptorString(), false);
+        //init dimensions
+        for (int i = 0 ; i < dimensions ; i++) {
+            mv.visitVarInsn(ALOAD, 0);
+            mv.visitVarInsn(ALOAD, 9);
+            mv.visitLdcInsn(i);
+            mv.visitInsn(LALOAD);
+            mv.visitFieldInsn(PUTFIELD, implClassName, "dim" + i, "J");
+        }
+        mv.visitInsn(RETURN);
+        mv.visitMaxs(0, 0);
+        mv.visitEnd();
+    }
+
+    void addAccessModeTypeMethod(BinderClassWriter cw) {
+        MethodType modeMethType = MethodType.methodType(MethodType.class, VarHandle.AccessMode.class);
+        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "accessModeTypeUncached", modeMethType.toMethodDescriptorString(), null, null);
+        mv.visitCode();
+        mv.visitVarInsn(ALOAD, 1);
+        mv.visitFieldInsn(GETFIELD, Type.getInternalName(VarHandle.AccessMode.class), "at", Type.getDescriptor(VarHandle.AccessType.class));
+        mv.visitLdcInsn(cw.makeConstantPoolPatch(MemoryAddressProxy.class));
+        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
+        mv.visitLdcInsn(cw.makeConstantPoolPatch(carrier));
+        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
+
+        Class<?>[] dims = new Class<?>[dimensions];
+        Arrays.fill(dims, long.class);
+        mv.visitLdcInsn(cw.makeConstantPoolPatch(dims));
+        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class[].class));
+
+        mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(VarHandle.AccessType.class),
+                "accessModeType", MethodType.methodType(MethodType.class, Class.class, Class.class, Class[].class).toMethodDescriptorString(), false);
+
+        mv.visitInsn(ARETURN);
+
+        mv.visitMaxs(0, 0);
+        mv.visitEnd();
+    }
+
+    void addAccessModeMethodIfNeeded(VarHandle.AccessMode mode, BinderClassWriter cw) {
+        String methName = mode.methodName();
+        MethodType methType = form.getMethodType(mode.at.ordinal())
+                .insertParameterTypes(0, VarHandle.class);
+
+        try {
+            MethodType helperType = methType.insertParameterTypes(2, long.class);
+            if (dimensions > 0) {
+                helperType = helperType.dropParameterTypes(3, 3 + dimensions);
+            }
+            //try to resolve...
+            String helperMethodName = methName + "0";
+            MethodHandles.Lookup.IMPL_LOOKUP
+                    .findStatic(helperClass,
+                            helperMethodName,
+                            helperType);
+
+
+            MethodVisitor mv = cw.visitMethod(ACC_STATIC, methName, methType.toMethodDescriptorString(), null, null);
+            mv.visitAnnotation(Type.getDescriptor(ForceInline.class), true);
+            mv.visitCode();
+
+            mv.visitVarInsn(ALOAD, 0); // handle impl
+            mv.visitVarInsn(ALOAD, 1); // receiver
+
+            // offset calculation
+            int slot = 2;
+            mv.visitVarInsn(ALOAD, 0); // load recv
+            mv.visitTypeInsn(CHECKCAST, Type.getInternalName(BASE_CLASS));
+            mv.visitFieldInsn(GETFIELD, Type.getInternalName(BASE_CLASS), "offset", "J");
+            for (int i = 0 ; i < dimensions ; i++) {
+                // load ADD MH
+                mv.visitLdcInsn(cw.makeConstantPoolPatch(ADD_OFFSETS_HANDLE));
+                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
+
+                //fixup stack so that ADD MH ends up bottom
+                mv.visitInsn(Opcodes.DUP_X2);
+                mv.visitInsn(Opcodes.POP);
+
+                // load MUL MH
+                mv.visitLdcInsn(cw.makeConstantPoolPatch(MUL_OFFSETS_HANDLE));
+                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
+
+                mv.visitVarInsn(ALOAD, 0); // load recv
+                mv.visitTypeInsn(CHECKCAST, implClassName);
+                mv.visitFieldInsn(GETFIELD, implClassName, "dim" + i, "J");
+                mv.visitVarInsn(LLOAD, slot);
+
+                mv.visitVarInsn(ALOAD, 1); // receiver
+                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MemoryAddressProxy.class));
+
+                //MUL
+                mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(MethodHandle.class), "invokeExact",
+                        OFFSET_OP_TYPE.toMethodDescriptorString(), false);
+
+                mv.visitVarInsn(ALOAD, 1); // receiver
+                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MemoryAddressProxy.class));
+
+                //ADD
+                mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(MethodHandle.class), "invokeExact",
+                        OFFSET_OP_TYPE.toMethodDescriptorString(), false);
+                slot += 2;
+            }
+
+            for (int i = 2 + dimensions; i < methType.parameterCount() ; i++) {
+                Class<?> param = methType.parameterType(i);
+                mv.visitVarInsn(loadInsn(param), slot); // load index
+                slot += getSlotsForType(param);
+            }
+
+            //call helper
+            mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(helperClass), helperMethodName,
+                    helperType.toMethodDescriptorString(), false);
+
+            mv.visitInsn(returnInsn(helperType.returnType()));
+
+            mv.visitMaxs(0, 0);
+            mv.visitEnd();
+        } catch (ReflectiveOperationException ex) {
+            //not found, skip
+        }
+    }
+
+    void addStridesAccessor(BinderClassWriter cw) {
+        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "strides", "()[J", null, null);
+        mv.visitCode();
+        iConstInsn(mv, dimensions);
+        mv.visitIntInsn(NEWARRAY, T_LONG);
+
+        for (int i = 0 ; i < dimensions ; i++) {
+            mv.visitInsn(DUP);
+            iConstInsn(mv, i);
+            mv.visitVarInsn(ALOAD, 0);
+            mv.visitFieldInsn(GETFIELD, implClassName, "dim" + i, "J");
+            mv.visitInsn(LASTORE);
+        }
+
+        mv.visitInsn(ARETURN);
+        mv.visitMaxs(0, 0);
+        mv.visitEnd();
+    }
+
+    void addCarrierAccessor(BinderClassWriter cw) {
+        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "carrier", "()Ljava/lang/Class;", null, null);
+        mv.visitCode();
+        mv.visitLdcInsn(cw.makeConstantPoolPatch(carrier));
+        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
+        mv.visitInsn(ARETURN);
+        mv.visitMaxs(0, 0);
+        mv.visitEnd();
+    }
+
+    //where
+    private Class<?> defineClass(BinderClassWriter cw, byte[] classBytes) {
+        try {
+            if (DEBUG_DUMP_CLASSES_DIR != null) {
+                debugWriteClassToFile(classBytes);
+            }
+            Object[] patches = cw.resolvePatches(classBytes);
+            Class<?> c = U.defineAnonymousClass(BASE_CLASS, classBytes, patches);
+            return c;
+        } catch (Throwable e) {
+            debugPrintClass(classBytes);
+            throw e;
+        }
+    }
+
+    // shared code generation helpers
+
+    private static int getSlotsForType(Class<?> c) {
+        if (c == long.class || c == double.class) {
+            return 2;
+        }
+        return 1;
+    }
+
+    /**
+     * Emits an actual return instruction conforming to the given return type.
+     */
+    private int returnInsn(Class<?> type) {
+        return switch (LambdaForm.BasicType.basicType(type)) {
+            case I_TYPE -> Opcodes.IRETURN;
+            case J_TYPE -> Opcodes.LRETURN;
+            case F_TYPE -> Opcodes.FRETURN;
+            case D_TYPE -> Opcodes.DRETURN;
+            case L_TYPE -> Opcodes.ARETURN;
+            case V_TYPE -> RETURN;
+        };
+    }
+
+    private int loadInsn(Class<?> type) {
+        return switch (LambdaForm.BasicType.basicType(type)) {
+            case I_TYPE -> Opcodes.ILOAD;
+            case J_TYPE -> LLOAD;
+            case F_TYPE -> Opcodes.FLOAD;
+            case D_TYPE -> Opcodes.DLOAD;
+            case L_TYPE -> Opcodes.ALOAD;
+            case V_TYPE -> throw new IllegalStateException("Cannot load void");
+        };
+    }
+
+    private static void iConstInsn(MethodVisitor mv, int i) {
+        switch (i) {
+            case -1, 0, 1, 2, 3, 4, 5:
+                mv.visitInsn(ICONST_0 + i);
+                break;
+            default:
+                if(i >= Byte.MIN_VALUE && i <= Byte.MAX_VALUE) {
+                    mv.visitIntInsn(BIPUSH, i);
+                } else if (i >= Short.MIN_VALUE && i <= Short.MAX_VALUE) {
+                    mv.visitIntInsn(SIPUSH, i);
+                } else {
+                    mv.visitLdcInsn(i);
+                }
+        }
+    }
+
+    // debug helpers
+
+    private static String debugPrintClass(byte[] classFile) {
+        ClassReader cr = new ClassReader(classFile);
+        StringWriter sw = new StringWriter();
+        cr.accept(new TraceClassVisitor(new PrintWriter(sw)), 0);
+        return sw.toString();
+    }
+
+    private void debugWriteClassToFile(byte[] classFile) {
+        File file = new File(DEBUG_DUMP_CLASSES_DIR, implClassName + ".class");
+
+        if (DEBUG) {
+            System.err.println("Dumping class " + implClassName + " to " + file);
+        }
+
+        try {
+            debugWriteDataToFile(classFile, file);
+        } catch (Exception e) {
+            throw new RuntimeException("Failed to write class " + implClassName + " to file " + file);
+        }
+    }
+
+    private void debugWriteDataToFile(byte[] data, File file) {
+        if (file.exists()) {
+            file.delete();
+        }
+        if (file.exists()) {
+            throw new RuntimeException("Failed to remove pre-existing file " + file);
+        }
+
+        File parent = file.getParentFile();
+        if (!parent.exists()) {
+            parent.mkdirs();
+        }
+        if (!parent.exists()) {
+            throw new RuntimeException("Failed to create " + parent);
+        }
+        if (!parent.isDirectory()) {
+            throw new RuntimeException(parent + " is not a directory");
+        }
+
+        try (FileOutputStream fos = new FileOutputStream(file)) {
+            fos.write(data);
+        } catch (IOException e) {
+            throw new RuntimeException("Failed to write class " + implClassName + " to file " + file);
+        }
+    }
+
+    static class BinderClassWriter extends ClassWriter {
+
+        private final ArrayList<ConstantPoolPatch> cpPatches = new ArrayList<>();
+        private int curUniquePatchIndex = 0;
+
+        BinderClassWriter() {
+            super(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
+        }
+
+        public String makeConstantPoolPatch(Object o) {
+            int myUniqueIndex = curUniquePatchIndex++;
+            String cpPlaceholder = "CONSTANT_PLACEHOLDER_" + myUniqueIndex;
+            int index = newConst(cpPlaceholder);
+            cpPatches.add(new ConstantPoolPatch(index, cpPlaceholder, o));
+            return cpPlaceholder;
+        }
+
+        public Object[] resolvePatches(byte[] classFile) {
+            if (cpPatches.isEmpty()) {
+                return null;
+            }
+
+            int size = ((classFile[8] & 0xFF) << 8) | (classFile[9] & 0xFF);
+
+            Object[] patches = new Object[size];
+            for (ConstantPoolPatch p : cpPatches) {
+                if (p.index >= size) {
+                    throw new InternalError("Failed to resolve constant pool patch entries");
+                }
+                patches[p.index] = p.value;
+            }
+
+            return patches;
+        }
+
+        static class ConstantPoolPatch {
+            final int index;
+            final String placeholder;
+            final Object value;
+
+            ConstantPoolPatch(int index, String placeholder, Object value) {
+                this.index = index;
+                this.placeholder = placeholder;
+                this.value = value;
+            }
+
+            @Override
+            public String toString() {
+                return "CpPatch/index="+index+",placeholder="+placeholder+",value="+value;
+            }
+        }
+    }
+}
diff a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
@@ -1790,46 +1790,64 @@
                         .generateInvokersHolderClassBytes(className,
                                 invokerMethodTypes, callSiteMethodTypes);
             }
 
             @Override
-            public VarHandle memoryAddressViewVarHandle(Class<?> carrier, long size, long alignmentMask,
-                                                        ByteOrder order, long offset, long[] strides) {
-                return VarHandles.makeMemoryAddressViewHandle(carrier, size, alignmentMask, order, offset, strides);
+            public VarHandle memoryAccessVarHandle(Class<?> carrier, long alignmentMask,
+                                                   ByteOrder order, long offset, long[] strides) {
+                return VarHandles.makeMemoryAddressViewHandle(carrier, alignmentMask, order, offset, strides);
             }
 
             @Override
             public Class<?> memoryAddressCarrier(VarHandle handle) {
-                return checkMemAccessHandle(handle).carrier();
+                return checkMemoryAccessHandle(handle).carrier();
             }
 
             @Override
             public long memoryAddressAlignmentMask(VarHandle handle) {
-                return checkMemAccessHandle(handle).alignmentMask;
+                return checkMemoryAccessHandle(handle).alignmentMask;
             }
 
             @Override
             public ByteOrder memoryAddressByteOrder(VarHandle handle) {
-                return checkMemAccessHandle(handle).be ?
+                return checkMemoryAccessHandle(handle).be ?
                         ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
             }
 
             @Override
             public long memoryAddressOffset(VarHandle handle) {
-                return checkMemAccessHandle(handle).offset;
+                return checkMemoryAccessHandle(handle).offset;
             }
 
             @Override
             public long[] memoryAddressStrides(VarHandle handle) {
-                return checkMemAccessHandle(handle).strides();
+                return checkMemoryAccessHandle(handle).strides();
             }
 
-            private VarHandleMemoryAddressBase checkMemAccessHandle(VarHandle handle) {
-                if (!(handle.asDirect() instanceof VarHandleMemoryAddressBase)) {
+            @Override
+            public boolean isMemoryAccessVarHandle(VarHandle handle) {
+                return asMemoryAccessVarHandle(handle) != null;
+            }
+
+            private MemoryAccessVarHandleBase asMemoryAccessVarHandle(VarHandle handle) {
+                if (handle instanceof MemoryAccessVarHandleBase) {
+                    return (MemoryAccessVarHandleBase)handle;
+                } else if (handle.target() instanceof MemoryAccessVarHandleBase) {
+                    // skip first adaptation, since we have to step over MemoryAddressProxy
+                    // see JDK-8237349
+                    return (MemoryAccessVarHandleBase)handle.target();
+                } else {
+                    return null;
+                }
+            }
+
+            private MemoryAccessVarHandleBase checkMemoryAccessHandle(VarHandle handle) {
+                MemoryAccessVarHandleBase base = asMemoryAccessVarHandle(handle);
+                if (base == null) {
                     throw new IllegalArgumentException("Not a memory access varhandle: " + handle);
                 }
-                return (VarHandleMemoryAddressBase) handle.asDirect();
+                return base;
             }
         });
     }
 
     /** Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore(). */
diff a/src/java.base/share/classes/java/lang/invoke/MethodHandles.java b/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
@@ -5039,19 +5039,20 @@
      * available starting at {@code pos}.
      */
     public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {
         Objects.nonNull(target);
         Objects.nonNull(filters);
-        if (filters.length == 0) return target;
 
         List<Class<?>> targetCoordinates = target.coordinateTypes();
         if (pos < 0 || pos >= targetCoordinates.size()) {
             throw newIllegalArgumentException("Invalid position " + pos + " for coordinate types", targetCoordinates);
         } else if (pos + filters.length > targetCoordinates.size()) {
             throw new IllegalArgumentException("Too many filters");
         }
 
+        if (filters.length == 0) return target;
+
         List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
         for (int i = 0 ; i < filters.length ; i++) {
             noCheckedExceptions(filters[i]);
             MethodType filterType = filters[i].type();
             if (filterType.parameterCount() != 1) {
@@ -5093,19 +5094,20 @@
      * of the target var handle.
      */
     public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {
         Objects.nonNull(target);
         Objects.nonNull(values);
-        if (values.length == 0) return target;
 
         List<Class<?>> targetCoordinates = target.coordinateTypes();
         if (pos < 0 || pos >= targetCoordinates.size()) {
             throw newIllegalArgumentException("Invalid position " + pos + " for coordinate types", targetCoordinates);
         } else if (pos + values.length > targetCoordinates.size()) {
             throw new IllegalArgumentException("Too many values");
         }
 
+        if (values.length == 0) return target;
+
         List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
         for (int i = 0 ; i < values.length ; i++) {
             Class<?> pt = newCoordinates.get(pos);
             if (pt.isPrimitive()) {
                 Wrapper w = Wrapper.forPrimitiveType(pt);
@@ -5254,18 +5256,55 @@
         } else if (filter.type().returnType() != targetCoordinates.get(pos)) {
             throw newIllegalArgumentException("Invalid filter type " + filter.type() + " for coordinate type " + targetCoordinates.get(pos));
         }
 
         List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
-        for (Class<?> arg : filter.type().parameterList()) {
-            newCoordinates.add(pos, arg);
-        }
+        newCoordinates.remove(pos);
+        newCoordinates.addAll(pos, filter.type().parameterList());
 
         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class<?>[0]),
                 (mode, modeHandle) -> MethodHandles.collectArguments(modeHandle, 1 + pos, filter));
     }
 
+    /**
+     * Returns a var handle which will discard some dummy coordinates before delegating to the
+     * target var handle. As a consequence, the resulting var handle will feature more
+     * coordinate types than the target var handle.
+     * <p>
+     * The {@code pos} argument may range between zero and <i>N</i>, where <i>N</i> is the arity of the
+     * target var handle's coordinate types. If {@code pos} is zero, the dummy coordinates will precede
+     * the target's real arguments; if {@code pos} is <i>N</i> they will come after.
+     * <p>
+     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
+     * atomic access guarantees as those featured by the target var handle.
+     *
+     * @param target the var handle to invoke after the dummy coordinates are dropped
+     * @param pos position of first coordinate to drop (zero for the leftmost)
+     * @param valueTypes the type(s) of the coordinate(s) to drop
+     * @return an adapter var handle which drops some dummy coordinates,
+     *         before calling the target var handle
+     * @throws NullPointerException if either {@code target}, {@code valueTypes} are {@code == null}.
+     * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive.
+     */
+    public static VarHandle dropCoordinates(VarHandle target, int pos, Class<?>... valueTypes) {
+        Objects.nonNull(target);
+        Objects.nonNull(valueTypes);
+
+        List<Class<?>> targetCoordinates = target.coordinateTypes();
+        if (pos < 0 || pos > targetCoordinates.size()) {
+            throw newIllegalArgumentException("Invalid position " + pos + " for coordinate types", targetCoordinates);
+        }
+
+        if (valueTypes.length == 0) return target;
+
+        List<Class<?>> newCoordinates = new ArrayList<>(targetCoordinates);
+        newCoordinates.addAll(pos, List.of(valueTypes));
+
+        return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class<?>[0]),
+                (mode, modeHandle) -> MethodHandles.dropArguments(modeHandle, 1 + pos, valueTypes));
+    }
+
     private static void noCheckedExceptions(MethodHandle handle) {
         if (handle instanceof DirectMethodHandle) {
             DirectMethodHandle directHandle = (DirectMethodHandle)handle;
             MethodHandleInfo info = Lookup.IMPL_LOOKUP.revealDirect(directHandle);
             Class<?>[] exceptionTypes = switch (info.getReferenceKind()) {
diff a/src/java.base/share/classes/java/lang/invoke/VarHandle.java b/src/java.base/share/classes/java/lang/invoke/VarHandle.java
--- a/src/java.base/share/classes/java/lang/invoke/VarHandle.java
+++ b/src/java.base/share/classes/java/lang/invoke/VarHandle.java
@@ -461,10 +461,12 @@
 
     VarHandle asDirect() {
         return this;
     }
 
+    VarHandle target() { return null; }
+
     // Plain accessors
 
     /**
      * Returns the value of a variable, with memory semantics of reading as
      * if the variable was declared non-{@code volatile}.  Commonly referred to
diff a/src/java.base/share/classes/java/lang/invoke/VarHandleMemoryAddressBase.java b/src/java.base/share/classes/java/lang/invoke/VarHandleMemoryAddressBase.java
--- a/src/java.base/share/classes/java/lang/invoke/VarHandleMemoryAddressBase.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package java.lang.invoke;
-
-/**
- * Base class for memory access var handle implementations.
- */
-abstract class VarHandleMemoryAddressBase extends VarHandle {
-
-    /** endianness **/
-    final boolean be;
-
-    /** access size (in bytes, computed from var handle carrier type) **/
-    final long length;
-
-    /** access offset (in bytes); must be compatible with {@code alignmentMask} **/
-    final long offset;
-
-    /** alignment constraint (in bytes, expressed as a bit mask) **/
-    final long alignmentMask;
-
-    VarHandleMemoryAddressBase(VarForm form, boolean be, long length, long offset, long alignmentMask) {
-        super(form);
-        this.be = be;
-        this.length = length;
-        this.offset = offset;
-        this.alignmentMask = alignmentMask;
-    }
-
-    static IllegalStateException newIllegalStateExceptionForMisalignedAccess(long address) {
-        return new IllegalStateException("Misaligned access at address: " + address);
-    }
-
-    /**
-     * Strides used for multi-dimensional access; each stride must be compatible with {@code alignmentMask}.
-     */
-    abstract long[] strides();
-
-    abstract Class<?> carrier();
-}
diff a/src/java.base/share/classes/java/lang/invoke/VarHandles.java b/src/java.base/share/classes/java/lang/invoke/VarHandles.java
--- a/src/java.base/share/classes/java/lang/invoke/VarHandles.java
+++ b/src/java.base/share/classes/java/lang/invoke/VarHandles.java
@@ -308,17 +308,21 @@
      * @param byteOrder the byte order.
      * @param offset a constant offset for the access.
      * @param strides the scale factors with which to multiply given access coordinates.
      * @return the created VarHandle.
      */
-    static VarHandle makeMemoryAddressViewHandle(Class<?> carrier, long size, long alignmentMask,
+    static VarHandle makeMemoryAddressViewHandle(Class<?> carrier, long alignmentMask,
                                                  ByteOrder byteOrder, long offset, long[] strides) {
+        if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
+            throw new IllegalArgumentException("Invalid carrier: " + carrier.getName());
+        }
+        long size = Wrapper.forPrimitiveType(carrier).bitWidth() / 8;
         boolean be = byteOrder == ByteOrder.BIG_ENDIAN;
 
         Map<Integer, MethodHandle> carrierFactory = ADDRESS_FACTORIES.get(carrier);
         MethodHandle fac = carrierFactory.computeIfAbsent(strides.length,
-                dims -> new AddressVarHandleGenerator(carrier, dims)
+                dims -> new MemoryAccessVarHandleGenerator(carrier, dims)
                             .generateHandleFactory());
 
         try {
             return maybeAdapt((VarHandle)fac.invoke(be, size, offset, alignmentMask, strides));
         } catch (Throwable ex) {
diff a/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template b/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template
--- /dev/null
+++ b/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template
@@ -0,0 +1,543 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package java.lang.invoke;
+
+import jdk.internal.access.foreign.MemoryAddressProxy;
+import jdk.internal.vm.annotation.ForceInline;
+
+import java.util.Objects;
+
+import static java.lang.invoke.MethodHandleStatics.UNSAFE;
+
+#warn
+
+final class MemoryAccessVarHandle$Type$Helper {
+
+    static final boolean BE = UNSAFE.isBigEndian();
+
+    static final int VM_ALIGN = $BoxType$.BYTES - 1;
+
+#if[floatingPoint]
+    @ForceInline
+    static $rawType$ convEndian(boolean big, $type$ v) {
+        $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
+        return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
+    }
+
+    @ForceInline
+    static $type$ convEndian(boolean big, $rawType$ rv) {
+        rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);
+        return $Type$.$rawType$BitsTo$Type$(rv);
+    }
+#else[floatingPoint]
+#if[byte]
+    @ForceInline
+    static $type$ convEndian(boolean big, $type$ n) {
+        return n;
+    }
+#else[byte]
+    @ForceInline
+    static $type$ convEndian(boolean big, $type$ n) {
+        return big == BE ? n : $BoxType$.reverseBytes(n);
+    }
+#end[byte]
+#end[floatingPoint]
+
+    @ForceInline
+    static MemoryAddressProxy checkAddress(Object obb, long offset, long length, boolean ro) {
+        MemoryAddressProxy oo = (MemoryAddressProxy)Objects.requireNonNull(obb);
+        oo.checkAccess(offset, length, ro);
+        return oo;
+    }
+
+    @ForceInline
+    static long offset(MemoryAddressProxy bb, long offset, long alignmentMask) {
+        long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);
+        if ((address & VM_ALIGN) != 0) {
+            throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
+        }
+        return address;
+    }
+
+    @ForceInline
+    static long offsetNoVMAlignCheck(MemoryAddressProxy bb, long offset, long alignmentMask) {
+        long base = bb.unsafeGetOffset();
+        long address = base + offset;
+        //note: the offset portion has already been aligned-checked, by construction
+        if ((base & alignmentMask) != 0) {
+            throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
+        }
+        return address;
+    }
+
+    @ForceInline
+    static $type$ get0(VarHandle ob, Object obb, long base) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+#if[floatingPoint]
+        $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
+                bb.unsafeGetBase(),
+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                handle.be);
+        return $Type$.$rawType$BitsTo$Type$(rawValue);
+#else[floatingPoint]
+#if[byte]
+        return UNSAFE.get$Type$(
+                bb.unsafeGetBase(),
+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask));
+#else[byte]
+        return UNSAFE.get$Type$Unaligned(
+                bb.unsafeGetBase(),
+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                handle.be);
+#end[byte]
+#end[floatingPoint]
+    }
+
+    @ForceInline
+    static void set0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+#if[floatingPoint]
+        UNSAFE.put$RawType$Unaligned(
+                bb.unsafeGetBase(),
+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                $Type$.$type$ToRaw$RawType$Bits(value),
+                handle.be);
+#else[floatingPoint]
+#if[byte]
+        UNSAFE.put$Type$(
+                bb.unsafeGetBase(),
+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                value);
+#else[byte]
+        UNSAFE.put$Type$Unaligned(
+                bb.unsafeGetBase(),
+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                value,
+                handle.be);
+#end[byte]
+#end[floatingPoint]
+    }
+
+    @ForceInline
+    static $type$ getVolatile0(VarHandle ob, Object obb, long base) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+        return convEndian(handle.be,
+                          UNSAFE.get$RawType$Volatile(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask)));
+    }
+
+    @ForceInline
+    static void setVolatile0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        UNSAFE.put$RawType$Volatile(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, value));
+    }
+
+    @ForceInline
+    static $type$ getAcquire0(VarHandle ob, Object obb, long base) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+        return convEndian(handle.be,
+                          UNSAFE.get$RawType$Acquire(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask)));
+    }
+
+    @ForceInline
+    static void setRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        UNSAFE.put$RawType$Release(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, value));
+    }
+
+    @ForceInline
+    static $type$ getOpaque0(VarHandle ob, Object obb, long base) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+        return convEndian(handle.be,
+                          UNSAFE.get$RawType$Opaque(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask)));
+    }
+
+    @ForceInline
+    static void setOpaque0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        UNSAFE.put$RawType$Opaque(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, value));
+    }
+#if[CAS]
+
+    @ForceInline
+    static boolean compareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return UNSAFE.compareAndSet$RawType$(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, expected), convEndian(handle.be, value));
+    }
+
+    @ForceInline
+    static $type$ compareAndExchange0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return convEndian(handle.be,
+                          UNSAFE.compareAndExchange$RawType$(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask),
+                                  convEndian(handle.be, expected), convEndian(handle.be, value)));
+    }
+
+    @ForceInline
+    static $type$ compareAndExchangeAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return convEndian(handle.be,
+                          UNSAFE.compareAndExchange$RawType$Acquire(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask),
+                                  convEndian(handle.be, expected), convEndian(handle.be, value)));
+    }
+
+    @ForceInline
+    static $type$ compareAndExchangeRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return convEndian(handle.be,
+                          UNSAFE.compareAndExchange$RawType$Release(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask),
+                                  convEndian(handle.be, expected), convEndian(handle.be, value)));
+    }
+
+    @ForceInline
+    static boolean weakCompareAndSetPlain0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return UNSAFE.weakCompareAndSet$RawType$Plain(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, expected), convEndian(handle.be, value));
+    }
+
+    @ForceInline
+    static boolean weakCompareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return UNSAFE.weakCompareAndSet$RawType$(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, expected), convEndian(handle.be, value));
+    }
+
+    @ForceInline
+    static boolean weakCompareAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return UNSAFE.weakCompareAndSet$RawType$Acquire(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, expected), convEndian(handle.be, value));
+    }
+
+    @ForceInline
+    static boolean weakCompareAndSetRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return UNSAFE.weakCompareAndSet$RawType$Release(
+                bb.unsafeGetBase(),
+                offset(bb, base, handle.alignmentMask),
+                convEndian(handle.be, expected), convEndian(handle.be, value));
+    }
+
+    @ForceInline
+    static $type$ getAndSet0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return convEndian(handle.be,
+                          UNSAFE.getAndSet$RawType$(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask),
+                                  convEndian(handle.be, value)));
+    }
+
+    @ForceInline
+    static $type$ getAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return convEndian(handle.be,
+                          UNSAFE.getAndSet$RawType$Acquire(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask),
+                                  convEndian(handle.be, value)));
+    }
+
+    @ForceInline
+    static $type$ getAndSetRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        return convEndian(handle.be,
+                          UNSAFE.getAndSet$RawType$Release(
+                                  bb.unsafeGetBase(),
+                                  offset(bb, base, handle.alignmentMask),
+                                  convEndian(handle.be, value)));
+    }
+#end[CAS]
+#if[AtomicAdd]
+
+    @ForceInline
+    static $type$ getAndAdd0(VarHandle ob, Object obb, long base, $type$ delta) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndAdd$RawType$(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    delta);
+        } else {
+            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndAddAcquire0(VarHandle ob, Object obb, long base, $type$ delta) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndAdd$RawType$Acquire(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    delta);
+        } else {
+            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndAddRelease0(VarHandle ob, Object obb, long base, $type$ delta) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndAdd$RawType$Release(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    delta);
+        } else {
+            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndAddConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ delta) {
+        $type$ nativeExpectedValue, expectedValue;
+        Object base = bb.unsafeGetBase();
+        do {
+            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
+            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
+        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
+                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
+        return expectedValue;
+    }
+#end[AtomicAdd]
+#if[Bitwise]
+
+    @ForceInline
+    static $type$ getAndBitwiseOr0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseOr$RawType$(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseOrRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseOr$RawType$Release(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseOrAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseOr$RawType$Acquire(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseOrConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
+        $type$ nativeExpectedValue, expectedValue;
+        Object base = bb.unsafeGetBase();
+        do {
+            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
+            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
+        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
+                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
+        return expectedValue;
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseAnd0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseAnd$RawType$(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseAndRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseAnd$RawType$Release(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseAndAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseAndConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
+        $type$ nativeExpectedValue, expectedValue;
+        Object base = bb.unsafeGetBase();
+        do {
+            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
+            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
+        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
+                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue & value)));
+        return expectedValue;
+    }
+
+
+    @ForceInline
+    static $type$ getAndBitwiseXor0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseXor$RawType$(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseXorRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseXor$RawType$Release(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseXorAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
+        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        if (handle.be == BE) {
+            return UNSAFE.getAndBitwiseXor$RawType$Acquire(
+                    bb.unsafeGetBase(),
+                    offset(bb, base, handle.alignmentMask),
+                    value);
+        } else {
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+        }
+    }
+
+    @ForceInline
+    static $type$ getAndBitwiseXorConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
+        $type$ nativeExpectedValue, expectedValue;
+        Object base = bb.unsafeGetBase();
+        do {
+            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
+            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
+        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
+                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
+        return expectedValue;
+    }
+#end[Bitwise]
+}
diff a/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAddressView.java.template b/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAddressView.java.template
--- a/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAddressView.java.template
+++ /dev/null
@@ -1,543 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package java.lang.invoke;
-
-import jdk.internal.access.foreign.MemoryAddressProxy;
-import jdk.internal.vm.annotation.ForceInline;
-
-import java.util.Objects;
-
-import static java.lang.invoke.MethodHandleStatics.UNSAFE;
-
-#warn
-
-final class VarHandleMemoryAddressAs$Type$s {
-
-    static final boolean BE = UNSAFE.isBigEndian();
-
-    static final int VM_ALIGN = $BoxType$.BYTES - 1;
-
-#if[floatingPoint]
-    @ForceInline
-    static $rawType$ convEndian(boolean big, $type$ v) {
-        $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
-        return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
-    }
-
-    @ForceInline
-    static $type$ convEndian(boolean big, $rawType$ rv) {
-        rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);
-        return $Type$.$rawType$BitsTo$Type$(rv);
-    }
-#else[floatingPoint]
-#if[byte]
-    @ForceInline
-    static $type$ convEndian(boolean big, $type$ n) {
-        return n;
-    }
-#else[byte]
-    @ForceInline
-    static $type$ convEndian(boolean big, $type$ n) {
-        return big == BE ? n : $BoxType$.reverseBytes(n);
-    }
-#end[byte]
-#end[floatingPoint]
-
-    @ForceInline
-    static MemoryAddressProxy checkAddress(Object obb, long offset, long length, boolean ro) {
-        MemoryAddressProxy oo = (MemoryAddressProxy)Objects.requireNonNull(obb);
-        oo.checkAccess(offset, length, ro);
-        return oo;
-    }
-
-    @ForceInline
-    static long offset(MemoryAddressProxy bb, long offset, long alignmentMask) {
-        long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);
-        if ((address & VM_ALIGN) != 0) {
-            throw VarHandleMemoryAddressBase.newIllegalStateExceptionForMisalignedAccess(address);
-        }
-        return address;
-    }
-
-    @ForceInline
-    static long offsetNoVMAlignCheck(MemoryAddressProxy bb, long offset, long alignmentMask) {
-        long base = bb.unsafeGetOffset();
-        long address = base + offset;
-        //note: the offset portion has already been aligned-checked, by construction
-        if ((base & alignmentMask) != 0) {
-            throw VarHandleMemoryAddressBase.newIllegalStateExceptionForMisalignedAccess(address);
-        }
-        return address;
-    }
-
-    @ForceInline
-    static $type$ get0(VarHandle ob, Object obb, long base) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
-#if[floatingPoint]
-        $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
-                bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
-                handle.be);
-        return $Type$.$rawType$BitsTo$Type$(rawValue);
-#else[floatingPoint]
-#if[byte]
-        return UNSAFE.get$Type$(
-                bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask));
-#else[byte]
-        return UNSAFE.get$Type$Unaligned(
-                bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
-                handle.be);
-#end[byte]
-#end[floatingPoint]
-    }
-
-    @ForceInline
-    static void set0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-#if[floatingPoint]
-        UNSAFE.put$RawType$Unaligned(
-                bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
-                $Type$.$type$ToRaw$RawType$Bits(value),
-                handle.be);
-#else[floatingPoint]
-#if[byte]
-        UNSAFE.put$Type$(
-                bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
-                value);
-#else[byte]
-        UNSAFE.put$Type$Unaligned(
-                bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
-                value,
-                handle.be);
-#end[byte]
-#end[floatingPoint]
-    }
-
-    @ForceInline
-    static $type$ getVolatile0(VarHandle ob, Object obb, long base) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
-        return convEndian(handle.be,
-                          UNSAFE.get$RawType$Volatile(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask)));
-    }
-
-    @ForceInline
-    static void setVolatile0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        UNSAFE.put$RawType$Volatile(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, value));
-    }
-
-    @ForceInline
-    static $type$ getAcquire0(VarHandle ob, Object obb, long base) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
-        return convEndian(handle.be,
-                          UNSAFE.get$RawType$Acquire(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask)));
-    }
-
-    @ForceInline
-    static void setRelease0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        UNSAFE.put$RawType$Release(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, value));
-    }
-
-    @ForceInline
-    static $type$ getOpaque0(VarHandle ob, Object obb, long base) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
-        return convEndian(handle.be,
-                          UNSAFE.get$RawType$Opaque(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask)));
-    }
-
-    @ForceInline
-    static void setOpaque0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        UNSAFE.put$RawType$Opaque(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, value));
-    }
-#if[CAS]
-
-    @ForceInline
-    static boolean compareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return UNSAFE.compareAndSet$RawType$(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, expected), convEndian(handle.be, value));
-    }
-
-    @ForceInline
-    static $type$ compareAndExchange0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return convEndian(handle.be,
-                          UNSAFE.compareAndExchange$RawType$(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
-                                  convEndian(handle.be, expected), convEndian(handle.be, value)));
-    }
-
-    @ForceInline
-    static $type$ compareAndExchangeAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return convEndian(handle.be,
-                          UNSAFE.compareAndExchange$RawType$Acquire(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
-                                  convEndian(handle.be, expected), convEndian(handle.be, value)));
-    }
-
-    @ForceInline
-    static $type$ compareAndExchangeRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return convEndian(handle.be,
-                          UNSAFE.compareAndExchange$RawType$Release(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
-                                  convEndian(handle.be, expected), convEndian(handle.be, value)));
-    }
-
-    @ForceInline
-    static boolean weakCompareAndSetPlain0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return UNSAFE.weakCompareAndSet$RawType$Plain(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, expected), convEndian(handle.be, value));
-    }
-
-    @ForceInline
-    static boolean weakCompareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return UNSAFE.weakCompareAndSet$RawType$(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, expected), convEndian(handle.be, value));
-    }
-
-    @ForceInline
-    static boolean weakCompareAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return UNSAFE.weakCompareAndSet$RawType$Acquire(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, expected), convEndian(handle.be, value));
-    }
-
-    @ForceInline
-    static boolean weakCompareAndSetRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return UNSAFE.weakCompareAndSet$RawType$Release(
-                bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
-                convEndian(handle.be, expected), convEndian(handle.be, value));
-    }
-
-    @ForceInline
-    static $type$ getAndSet0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return convEndian(handle.be,
-                          UNSAFE.getAndSet$RawType$(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
-                                  convEndian(handle.be, value)));
-    }
-
-    @ForceInline
-    static $type$ getAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return convEndian(handle.be,
-                          UNSAFE.getAndSet$RawType$Acquire(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
-                                  convEndian(handle.be, value)));
-    }
-
-    @ForceInline
-    static $type$ getAndSetRelease0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        return convEndian(handle.be,
-                          UNSAFE.getAndSet$RawType$Release(
-                                  bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
-                                  convEndian(handle.be, value)));
-    }
-#end[CAS]
-#if[AtomicAdd]
-
-    @ForceInline
-    static $type$ getAndAdd0(VarHandle ob, Object obb, long base, $type$ delta) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndAdd$RawType$(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    delta);
-        } else {
-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndAddAcquire0(VarHandle ob, Object obb, long base, $type$ delta) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndAdd$RawType$Acquire(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    delta);
-        } else {
-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndAddRelease0(VarHandle ob, Object obb, long base, $type$ delta) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndAdd$RawType$Release(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    delta);
-        } else {
-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndAddConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ delta) {
-        $type$ nativeExpectedValue, expectedValue;
-        Object base = bb.unsafeGetBase();
-        do {
-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
-        return expectedValue;
-    }
-#end[AtomicAdd]
-#if[Bitwise]
-
-    @ForceInline
-    static $type$ getAndBitwiseOr0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseOr$RawType$(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseOrRelease0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseOr$RawType$Release(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseOrAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseOr$RawType$Acquire(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseOrConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
-        $type$ nativeExpectedValue, expectedValue;
-        Object base = bb.unsafeGetBase();
-        do {
-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
-        return expectedValue;
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseAnd0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseAnd$RawType$(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseAndRelease0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseAnd$RawType$Release(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseAndAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseAndConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
-        $type$ nativeExpectedValue, expectedValue;
-        Object base = bb.unsafeGetBase();
-        do {
-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue & value)));
-        return expectedValue;
-    }
-
-
-    @ForceInline
-    static $type$ getAndBitwiseXor0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseXor$RawType$(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseXorRelease0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseXor$RawType$Release(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseXorAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
-        VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
-        if (handle.be == BE) {
-            return UNSAFE.getAndBitwiseXor$RawType$Acquire(
-                    bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
-                    value);
-        } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
-        }
-    }
-
-    @ForceInline
-    static $type$ getAndBitwiseXorConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
-        $type$ nativeExpectedValue, expectedValue;
-        Object base = bb.unsafeGetBase();
-        do {
-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
-        return expectedValue;
-    }
-#end[Bitwise]
-}
diff a/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
--- a/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
@@ -111,12 +111,18 @@
     /**
      * Returns a var handle view of a given memory address.
      * Used by {@code jdk.internal.foreign.LayoutPath} and
      * {@code jdk.incubator.foreign.MemoryHandles}.
      */
-    VarHandle memoryAddressViewVarHandle(Class<?> carrier, long size, long alignmentMask,
-                                         ByteOrder order, long offset, long[] strides);
+    VarHandle memoryAccessVarHandle(Class<?> carrier, long alignmentMask,
+                                    ByteOrder order, long offset, long[] strides);
+
+    /**
+     * Is {@code handle} a memory access varhandle?
+     * Used by {@code jdk.incubator.foreign.MemoryHandles}.
+     */
+    boolean isMemoryAccessVarHandle(VarHandle handle);
 
     /**
      * Returns the carrier associated with a memory access var handle.
      * Used by {@code jdk.incubator.foreign.MemoryHandles}.
      */
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
@@ -166,10 +166,15 @@
 
     boolean hasNaturalAlignment() {
         return size.isPresent() && size.getAsLong() == alignment;
     }
 
+    @Override
+    public boolean isPadding() {
+        return this instanceof PaddingLayout;
+    }
+
     @Override
     public int hashCode() {
         return attributes.hashCode() << Long.hashCode(alignment);
     }
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AllocationScope.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AllocationScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AllocationScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AllocationScope.java
@@ -172,16 +172,26 @@
      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
      * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of an address value.
      */
     public MemoryAddress allocate(MemoryLayout layout, MemoryAddress value) {
-        VarHandle handle = layout.varHandle(MemoryAddress.class);
+        VarHandle handle = MemoryHandles.asAddressVarHandle(layout.varHandle(carrierForSize(layout.byteSize())));
         MemoryAddress addr = allocate(layout);
         handle.set(addr, value);
         return addr;
     }
 
+    private static Class<?> carrierForSize(long size) {
+        return switch ((int)size) {
+            case 1 -> byte.class;
+            case 2 -> short.class;
+            case 4 -> int.class;
+            case 8 -> long.class;
+            default -> throw new IllegalArgumentException("Bad layout size: " + size);
+        };
+    }
+
     /**
      * Allocate a block of memory in this allocation scope with given layout. The address returned by this method is
      * associated with a segment which cannot be closed. Moreover, the returned address must conform to the layout alignment constraints.
      * @param layout the layout of the block of memory to be allocated.
      * @return an address which points to the newly allocated memory block.
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Foreign.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Foreign.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Foreign.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Foreign.java
@@ -25,10 +25,11 @@
  */
 
 package jdk.incubator.foreign;
 
 import jdk.internal.foreign.InternalForeign;
+import jdk.internal.foreign.MemorySegmentImpl;
 
 /**
  * A class containing various methods relating to native interop.
  */
 public interface Foreign {
@@ -58,24 +59,10 @@
      */
     static Foreign getInstance() throws IllegalAccessError {
         return InternalForeign.getInstance();
     }
 
-    /**
-     * Returns the absolute address represented by the given off-heap memory address as a {@code long}.
-     * <p>
-     * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
-     * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
-     * restricted methods, and use safe and supported functionalities, where possible.
-     *
-     * @param address the address to turn into a {@code long}
-     * @return the address as a {@code long}
-     * @throws IllegalAccessError if the permission jkd.incubator.foreign.restrictedMethods is set to 'deny'
-     * @throws IllegalStateException if the given address is not an off-heap address
-     */
-    long asLong(MemoryAddress address) throws IllegalAccessError;
-
     /**
      * Returns a new memory address attached to a native memory segment with given base address and size. The segment
      * attached to the returned address has <em>no temporal bounds</em> and cannot be closed; as such,
      * the returned address is assumed to always be <em>alive</em>. Also, the segment attached to the returned address
      * has <em>no confinement thread</em>; this means that the returned address can be used by multiple threads.
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
@@ -59,18 +59,24 @@
      * @return a new memory address with given offset from current one.
      */
     MemoryAddress addOffset(long offset);
 
     /**
-     * The offset of this memory address into the underlying segment.
-     *
-     * @return the offset
+     * Returns the offset of this memory address into the underlying segment.
+     * @return the offset of this memory address into the underlying segment.
      */
     long offset();
 
     /**
-     * The memory segment this address belongs to.
+     * Returns the raw long value associated to this memory address.
+     * @return The raw long value associated to this memory address.
+     * @throws UnsupportedOperationException if this memory address is associated with an heap segment.
+     */
+    long toRawLongValue();
+
+    /**
+     * Returns the memory segment this address belongs to.
      * @return The memory segment this address belongs to.
      */
     MemorySegment segment();
 
     /**
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
@@ -25,21 +25,26 @@
  */
 package jdk.incubator.foreign;
 
 import jdk.internal.access.JavaLangInvokeAccess;
 import jdk.internal.access.SharedSecrets;
+import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.Utils;
+import sun.invoke.util.Wrapper;
 
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
 
 /**
  * This class defines several factory methods for constructing and combining memory access var handles.
  * To obtain a memory access var handle, clients must start from one of the <em>leaf</em> methods
  * (see {@link MemoryHandles#varHandle(Class, ByteOrder)},
  * {@link MemoryHandles#varHandle(Class, long, ByteOrder)}). This determines the variable type
- * (all primitive types but {@code void} and {@code boolean} are supported, along with {@code MemoryAddress}), as well as the alignment constraint and the
+ * (all primitive types but {@code void} and {@code boolean} are supported), as well as the alignment constraint and the
  * byte order associated to a memory access var handle. The resulting memory access var handle can then be combined in various ways
  * to emulate different addressing modes. The var handles created by this class feature a <em>mandatory</em> coordinate type
  * (of type {@link MemoryAddress}), and zero or more {@code long} coordinate types, which can be used to emulate
  * multi-dimensional array indexing.
  * <p>
@@ -120,10 +125,31 @@
 
     private MemoryHandles() {
         //sorry, just the one!
     }
 
+    private static final MethodHandle LONG_TO_ADDRESS;
+    private static final MethodHandle ADDRESS_TO_LONG;
+    private static final MethodHandle ADD_OFFSET;
+    private static final MethodHandle ADD_STRIDE;
+
+    static {
+        try {
+            LONG_TO_ADDRESS = MethodHandles.lookup().findStatic(MemoryHandles.class, "longToAddress",
+                    MethodType.methodType(MemoryAddress.class, long.class));
+            ADDRESS_TO_LONG = MethodHandles.lookup().findStatic(MemoryHandles.class, "addressToLong",
+                    MethodType.methodType(long.class, MemoryAddress.class));
+            ADD_OFFSET = MethodHandles.lookup().findStatic(MemoryHandles.class, "addOffset",
+                    MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class));
+
+            ADD_STRIDE = MethodHandles.lookup().findStatic(MemoryHandles.class, "addStride",
+                    MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class, long.class));
+        } catch (Throwable ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
+
     /**
      * Creates a memory access var handle with the given carrier type and byte order.
      *
      * The resulting memory access var handle features a single {@link MemoryAddress} access coordinate,
      * and its variable type is set by the given carrier type.
@@ -133,19 +159,19 @@
      *
      * @apiNote the resulting var handle features certain <a href="#memaccess-mode">access mode restrictions</a>,
      * which are common to all memory access var handles.
      *
      * @param carrier the carrier type. Valid carriers are {@code byte}, {@code short}, {@code char}, {@code int},
-     * {@code float}, {@code long}, {@code double} and {@code MemoryAddress}.
+     * {@code float}, {@code long}, and {@code double}.
      * @param byteOrder the required byte order.
      * @return the new memory access var handle.
      * @throws IllegalArgumentException when an illegal carrier type is used
      */
     public static VarHandle varHandle(Class<?> carrier, ByteOrder byteOrder) {
-        Utils.checkCarrier(carrier);
+        checkCarrier(carrier);
         return varHandle(carrier,
-                Utils.carrierSize(carrier),
+                carrierSize(carrier),
                 byteOrder);
     }
 
     /**
      * Creates a memory access var handle with the given carrier type, alignment constraint, and byte order.
@@ -157,102 +183,170 @@
      *
      * @apiNote the resulting var handle features certain <a href="#memaccess-mode">access mode restrictions</a>,
      * which are common to all memory access var handles.
      *
      * @param carrier the carrier type. Valid carriers are {@code byte}, {@code short}, {@code char}, {@code int},
-     * {@code float}, {@code long}, {@code double} and {@code MemoryAddress}.
+     * {@code float}, {@code long}, and {@code double}.
      * @param alignmentBytes the alignment constraint (in bytes). Must be a power of two.
      * @param byteOrder the required byte order.
      * @return the new memory access var handle.
      * @throws IllegalArgumentException if an illegal carrier type is used, or if {@code alignmentBytes} is not a power of two.
      */
     public static VarHandle varHandle(Class<?> carrier, long alignmentBytes, ByteOrder byteOrder) {
-        Utils.checkCarrier(carrier);
+        checkCarrier(carrier);
 
         if (alignmentBytes <= 0
                 || (alignmentBytes & (alignmentBytes - 1)) != 0) { // is power of 2?
             throw new IllegalArgumentException("Bad alignment: " + alignmentBytes);
         }
 
-        return Utils.fixUpVarHandle(JLI.memoryAddressViewVarHandle(Utils.adjustCarrier(carrier), Utils.carrierSize(carrier), alignmentBytes - 1, byteOrder, 0, new long[]{}));
+        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, alignmentBytes - 1, byteOrder, 0, new long[]{}));
     }
 
     /**
-     * Creates a memory access var handle with a fixed offset added to the accessed offset. That is,
-     * if the target memory access var handle accesses a memory location at offset <em>O</em>, the new memory access var
-     * handle will access a memory location at offset <em>O' + O</em>.
+     * Returns a var handle that adds a <em>fixed</em> offset to the incoming {@link MemoryAddress} coordinate
+     * and then propagates such value to the target var handle. That is,
+     * when the returned var handle receives a memory address coordinate pointing at a memory location at
+     * offset <em>O</em>, a memory address coordinate pointing at a memory location at offset <em>O' + O</em>
+     * is created, and then passed to the target var handle.
      *
-     * The resulting memory access var handle will feature the same access coordinates as the ones in the target memory access var handle.
-     *
-     * @apiNote the resulting var handle features certain <a href="#memaccess-mode">access mode restrictions</a>,
-     * which are common to all memory access var handles.
+     * The returned var handle will feature the same type and access coordinates as the target var handle.
      *
      * @param target the target memory access handle to access after the offset adjustment.
      * @param bytesOffset the offset, in bytes. Must be positive or zero.
-     * @return the new memory access var handle.
-     * @throws IllegalArgumentException when the target var handle is not a memory access var handle,
-     * or when {@code bytesOffset < 0}, or otherwise incompatible with the alignment constraint.
+     * @return the adapted var handle.
+     * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.
      */
     public static VarHandle withOffset(VarHandle target, long bytesOffset) {
-        if (bytesOffset < 0) {
-            throw new IllegalArgumentException("Illegal offset: " + bytesOffset);
+        if (bytesOffset == 0) {
+            return target; //nothing to do
         }
 
-        long alignMask = JLI.memoryAddressAlignmentMask(target);
+        checkAddressFirstCoordinate(target);
 
-        if ((bytesOffset & alignMask) != 0) {
-            throw new IllegalArgumentException("Offset " + bytesOffset + " does not conform to alignment " + (alignMask + 1));
+        if (JLI.isMemoryAccessVarHandle(target) &&
+                (bytesOffset & JLI.memoryAddressAlignmentMask(target)) == 0) {
+            //flatten
+            return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(
+                    JLI.memoryAddressCarrier(target),
+                    JLI.memoryAddressAlignmentMask(target),
+                    JLI.memoryAddressByteOrder(target),
+                    JLI.memoryAddressOffset(target) + bytesOffset,
+                    JLI.memoryAddressStrides(target)));
+        } else {
+            //slow path
+            VarHandle res = MethodHandles.collectCoordinates(target, 0, ADD_OFFSET);
+            return MethodHandles.insertCoordinates(res, 1, bytesOffset);
         }
-
-        return Utils.fixUpVarHandle(JLI.memoryAddressViewVarHandle(
-                JLI.memoryAddressCarrier(target),
-                Utils.carrierSize(JLI.memoryAddressCarrier(target)),
-                alignMask,
-                JLI.memoryAddressByteOrder(target),
-                JLI.memoryAddressOffset(target) + bytesOffset,
-                JLI.memoryAddressStrides(target)));
     }
 
     /**
-     * Creates a memory access var handle with a <em>variable</em> offset added to the accessed offset.
-     * That is, if the target memory access var handle accesses a memory location at offset <em>O</em>,
-     * the new memory access var handle will access a memory location at offset <em>(S * X) + O</em>, where <em>S</em>
-     * is a constant <em>stride</em>, whereas <em>X</em> is a dynamic value that will be provided as an additional access
-     * coordinate (of type {@code long}). The new access coordinate will be <em>prepended</em> to the ones available
-     * in the target memory access var handles (if any).
+     * Returns a var handle which adds a <em>variable</em> offset to the incoming {@link MemoryAddress}
+     * access coordinate value and then propagates such value to the target var handle.
+     * That is, when the returned var handle receives a memory address coordinate pointing at a memory location at
+     * offset <em>O</em>, a new memory address coordinate pointing at a memory location at offset <em>(S * X) + O</em>
+     * is created, and then passed to the target var handle,
+     * where <em>S</em> is a constant <em>stride</em>, whereas <em>X</em> is a dynamic value that will be
+     * provided as an additional access coordinate (of type {@code long}).
      *
-     * @apiNote the resulting var handle features certain <a href="#memaccess-mode">access mode restrictions</a>,
-     * which are common to all memory access var handles.
+     * The returned var handle will feature the same type as the target var handle; an additional access coordinate
+     * of type {@code long} will be added to the access coordinate types of the target var handle at the position
+     * immediately following the leading access coordinate of type {@link MemoryAddress}.
      *
      * @param target the target memory access handle to access after the scale adjustment.
      * @param bytesStride the stride, in bytes, by which to multiply the coordinate value. Must be greater than zero.
-     * @return the new memory access var handle.
-     * @throws IllegalArgumentException when the target var handle is not a memory access var handle,
-     * or if {@code bytesStride <= 0}, or otherwise incompatible with the alignment constraint.
+     * @return the adapted var handle.
+     * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.
      */
     public static VarHandle withStride(VarHandle target, long bytesStride) {
         if (bytesStride == 0) {
-            throw new IllegalArgumentException("Stride must be positive: " + bytesStride);
+            return MethodHandles.dropCoordinates(target, 1, long.class); // dummy coordinate
         }
 
-        long alignMask = JLI.memoryAddressAlignmentMask(target);
+        checkAddressFirstCoordinate(target);
+
+        if (JLI.isMemoryAccessVarHandle(target) &&
+                (bytesStride & JLI.memoryAddressAlignmentMask(target)) == 0) {
+            //flatten
+            long[] strides = JLI.memoryAddressStrides(target);
+            long[] newStrides = new long[strides.length + 1];
+            System.arraycopy(strides, 0, newStrides, 1, strides.length);
+            newStrides[0] = bytesStride;
 
-        if ((bytesStride & alignMask) != 0) {
-            throw new IllegalArgumentException("Stride " + bytesStride + " does not conform to alignment " + (alignMask + 1));
+            return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(
+                    JLI.memoryAddressCarrier(target),
+                    JLI.memoryAddressAlignmentMask(target),
+                    JLI.memoryAddressByteOrder(target),
+                    JLI.memoryAddressOffset(target),
+                    newStrides));
+        } else {
+            //slow path
+            VarHandle res = MethodHandles.collectCoordinates(target, 0, ADD_STRIDE);
+            return MethodHandles.insertCoordinates(res, 2, bytesStride);
         }
+    }
 
-        long offset = JLI.memoryAddressOffset(target);
+    /**
+     * Adapt an existing var handle into a new var handle whose carrier type is {@link MemoryAddress}.
+     * That is, when calling {@link VarHandle#get(Object...)} on the returned var handle,
+     * the read numeric value will be turned into a memory address (as if by calling {@link MemoryAddress#ofLong(long)});
+     * similarly, when calling {@link VarHandle#set(Object...)}, the memory address to be set will be converted
+     * into a numeric value, and then written into memory. The amount of bytes read (resp. written) from (resp. to)
+     * memory depends on the carrier of the original memory access var handle.
+     *
+     * @param target the memory access var handle to be adapted
+     * @return the adapted var handle.
+     * @throws IllegalArgumentException if the carrier type of {@code varHandle} is either {@code boolean},
+     * {@code float}, or {@code double}, or is not a primitive type.
+     */
+    public static VarHandle asAddressVarHandle(VarHandle target) {
+        Class<?> carrier = target.varType();
+        if (!carrier.isPrimitive() || carrier == boolean.class ||
+                carrier == float.class || carrier == double.class) {
+            throw new IllegalArgumentException("Unsupported carrier type: " + carrier.getName());
+        }
 
-        long[] strides = JLI.memoryAddressStrides(target);
-        long[] newStrides = new long[strides.length + 1];
-        System.arraycopy(strides, 0, newStrides, 1, strides.length);
-        newStrides[0] = bytesStride;
+        if (carrier != long.class) {
+            // slow-path, we need to adapt
+            return MethodHandles.filterValue(target,
+                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(carrier, MemoryAddress.class)),
+                    MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, carrier)));
+        } else {
+            // fast-path
+            return MethodHandles.filterValue(target, ADDRESS_TO_LONG, LONG_TO_ADDRESS);
+        }
+    }
+
+    private static void checkAddressFirstCoordinate(VarHandle handle) {
+        if (handle.coordinateTypes().size() < 1 ||
+                handle.coordinateTypes().get(0) != MemoryAddress.class) {
+            throw new IllegalArgumentException("Expected var handle with leading coordinate of type MemoryAddress");
+        }
+    }
+
+    private static void checkCarrier(Class<?> carrier) {
+        if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
+            throw new IllegalArgumentException("Illegal carrier: " + carrier.getSimpleName());
+        }
+    }
+
+    private static long carrierSize(Class<?> carrier) {
+        long bitsAlignment = Math.max(8, Wrapper.forPrimitiveType(carrier).bitWidth());
+        return Utils.bitsToBytesOrThrow(bitsAlignment, IllegalStateException::new);
+    }
+
+    private static MemoryAddress longToAddress(long value) {
+        return MemoryAddress.ofLong(value);
+    }
+
+    private static long addressToLong(MemoryAddress value) {
+        return value.toRawLongValue();
+    }
+
+    private static MemoryAddress addOffset(MemoryAddress address, long offset) {
+        return address.addOffset(offset);
+    }
 
-        return Utils.fixUpVarHandle(JLI.memoryAddressViewVarHandle(
-                JLI.memoryAddressCarrier(target),
-                Utils.carrierSize(JLI.memoryAddressCarrier(target)),
-                alignMask,
-                JLI.memoryAddressByteOrder(target),
-                offset,
-                newStrides));
+    private static MemoryAddress addStride(MemoryAddress address, long index, long stride) {
+        return address.addOffset(index * stride);
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
@@ -390,10 +390,16 @@
             path = pathElem.apply(path);
         }
         return finalizer.apply(path);
     }
 
+    /**
+     * Is this a padding layout (e.g. a layout created from {@link #ofPaddingBits(long)} ?
+     * @return true, if this layout is a padding layout.
+     */
+    boolean isPadding();
+
     /**
      * Instances of this class are used to form <a href="MemoryLayout.html#layout-paths"><em>layout paths</em></a>. There
      * are two kinds of path elements: <em>group path elements</em> and <em>sequence path elements</em>. Group
      * path elements are used to select a given named member layout within a {@link GroupLayout}. Sequence
      * path elements are used to select a sequence element layout within a {@link SequenceLayout}; selection
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
@@ -49,25 +49,19 @@
 
     public static InternalForeign getInstancePrivileged() {
         return INSTANCE;
     }
 
-    @Override
-    public long asLong(MemoryAddress address) throws IllegalAccessError {
-        return MemoryAddressImpl.addressof(address);
-    }
-
     @Override
     public MemoryAddress withSize(MemoryAddress base, long byteSize) throws IllegalAccessError {
-        return Utils.makeNativeSegmentUnchecked(asLong(base), byteSize, null, false)
+        return Utils.makeNativeSegmentUnchecked(base.toRawLongValue(), byteSize, null, false)
                 .baseAddress();
     }
 
     @Override
     public MemorySegment asMallocSegment(MemoryAddress base, long byteSize) throws IllegalAccessError {
-        long addr = asLong(base);
-        return Utils.makeNativeSegmentUnchecked(addr, byteSize, Thread.currentThread(), true);
+        return Utils.makeNativeSegmentUnchecked(base.toRawLongValue(), byteSize, Thread.currentThread(), true);
     }
 
     @Override
     public MemorySegment asUnconfined(MemorySegment segment) {
         return ((MemorySegmentImpl)segment).asUnconfined();
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
@@ -26,14 +26,16 @@
 package jdk.internal.foreign;
 
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.internal.access.JavaLangInvokeAccess;
 import jdk.internal.access.SharedSecrets;
+import sun.invoke.util.Wrapper;
 
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
+
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.function.ToLongFunction;
 import java.util.function.UnaryOperator;
@@ -130,23 +132,19 @@
     public VarHandle dereferenceHandle(Class<?> carrier) {
         if (!(layout instanceof ValueLayout)) {
             throw badLayoutPath("layout path does not select a value layout");
         }
 
-        Utils.checkCarrier(carrier);
-
-        long size = Utils.carrierSize(carrier);
-
-        if ((size * 8) != layout.bitSize()) { // carrier has the right size?
+        if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class // illegal carrier?
+                || Wrapper.forPrimitiveType(carrier).bitWidth() != layout.bitSize()) { // carrier has the right size?
             throw new IllegalArgumentException("Invalid carrier: " + carrier + ", for layout " + layout);
         }
 
         checkAlignment(this);
 
-        return Utils.fixUpVarHandle(JLI.memoryAddressViewVarHandle(
-                Utils.adjustCarrier(carrier),
-                size,
+        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(
+                carrier,
                 layout.byteAlignment() - 1, //mask
                 ((ValueLayout) layout).order(),
                 Utils.bitsToBytesOrThrow(offset, IllegalStateException::new),
                 LongStream.of(strides).map(s -> Utils.bitsToBytesOrThrow(s, IllegalStateException::new)).toArray()));
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
@@ -23,11 +23,10 @@
  *  questions.
  *
  */
 package jdk.internal.foreign;
 
-import jdk.incubator.foreign.Foreign;
 import jdk.internal.access.foreign.MemoryAddressProxy;
 import jdk.internal.misc.Unsafe;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
@@ -44,14 +43,10 @@
     private static final InternalForeign foreign = InternalForeign.getInstancePrivileged();
 
     private final MemorySegmentImpl segment;
     private final long offset;
 
-    public MemoryAddressImpl(MemorySegmentImpl segment) {
-        this(segment, 0);
-    }
-
     public MemoryAddressImpl(MemorySegmentImpl segment, long offset) {
         this.segment = Objects.requireNonNull(segment);
         this.offset = offset;
     }
 
@@ -71,10 +66,18 @@
     @Override
     public long offset() {
         return offset;
     }
 
+    @Override
+    public long toRawLongValue() {
+        if (unsafeGetBase() != null) {
+            throw new UnsupportedOperationException("Not a native address");
+        }
+        return unsafeGetOffset();
+    }
+
     @Override
     public MemorySegment segment() {
         return segment;
     }
 
@@ -133,20 +136,10 @@
     @Override
     public String toString() {
         return "MemoryAddress{ region: " + segment + " offset=0x" + Long.toHexString(offset) + " }";
     }
 
-    // helper methods
-
-    public static long addressof(MemoryAddress address) {
-        MemoryAddressImpl addressImpl = (MemoryAddressImpl)address;
-        if (addressImpl.unsafeGetBase() != null) {
-            throw new IllegalStateException("Heap address!");
-        }
-        return addressImpl.unsafeGetOffset();
-    }
-
     public static MemoryAddress ofLongUnchecked(long value) {
         return ofLongUnchecked(value, Long.MAX_VALUE);
     }
 
     public static MemoryAddress ofLongUnchecked(long value, long byteSize) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -25,71 +25,54 @@
  */
 
 package jdk.internal.foreign;
 
 import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.ValueLayout;
-import jdk.internal.access.JavaLangInvokeAccess;
 import jdk.internal.access.JavaNioAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.access.foreign.MemoryAddressProxy;
 import jdk.internal.access.foreign.UnmapperProxy;
 import jdk.internal.misc.Unsafe;
-import sun.invoke.util.Wrapper;
 import sun.nio.ch.FileChannelImpl;
 import sun.security.action.GetBooleanAction;
 
 import java.io.IOException;
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
-import java.lang.constant.Constable;
-import java.lang.reflect.Field;
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
 import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
 import java.nio.file.OpenOption;
 import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
-import java.util.Map;
 import java.util.function.Supplier;
 
 /**
  * This class contains misc helper functions to support creation of memory segments.
  */
 public final class Utils {
 
     private static final Unsafe unsafe = Unsafe.getUnsafe();
 
     private static final MethodHandle ADDRESS_FILTER;
-    private static final MethodHandle LONG_TO_ADDRESS;
-    private static final MethodHandle ADDRESS_TO_LONG;
 
     static {
         try {
             ADDRESS_FILTER = MethodHandles.lookup().findStatic(Utils.class, "filterAddress",
                     MethodType.methodType(MemoryAddressProxy.class, MemoryAddress.class));
-            LONG_TO_ADDRESS = MethodHandles.lookup().findStatic(Utils.class, "longToAddress",
-                    MethodType.methodType(MemoryAddress.class, long.class));
-            ADDRESS_TO_LONG = MethodHandles.lookup().findStatic(Utils.class, "addressToLong",
-                    MethodType.methodType(long.class, MemoryAddress.class));
         } catch (Throwable ex) {
             throw new ExceptionInInitializerError(ex);
         }
     }
 
     // The maximum alignment supported by malloc - typically 16 on
     // 64-bit platforms and 8 on 32-bit platforms.
     private final static long MAX_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;
 
-    // the memory address var handle assumes that addresses have same size as a Java long
-    private final static long POINTER_SIZE = 8;
-
     private static final JavaNioAccess javaNioAccess = SharedSecrets.getJavaNioAccess();
-    private static final JavaLangInvokeAccess javaLangInvokeAccess = SharedSecrets.getJavaLangInvokeAccess();
 
     private static final boolean skipZeroMemory = GetBooleanAction.privilegedGetProperty("jdk.internal.foreign.skipZeroMemory");
 
     public static long alignUp(long n, long alignment) {
         return (n + alignment - 1) & -alignment;
@@ -101,49 +84,10 @@
         } else {
             throw exFactory.get();
         }
     }
 
-    static final Class<?> PADDING_CLASS;
-
-    static {
-        try {
-            PADDING_CLASS = Class.forName("jdk.incubator.foreign.PaddingLayout");
-        } catch (ReflectiveOperationException ex) {
-            throw new IllegalStateException(ex);
-        }
-    }
-
-    public static boolean isPadding(MemoryLayout layout) {
-        return layout.getClass() == PADDING_CLASS;
-    }
-
-    public static void checkCarrier(Class<?> carrier) {
-        if (carrier == void.class || carrier == boolean.class ||
-                (!carrier.isPrimitive() && !isAddress(carrier))) {
-            throw new IllegalArgumentException("Illegal carrier: " + carrier.getSimpleName());
-        }
-    }
-
-    public static long carrierSize(Class<?> carrier) {
-        if (isAddress(carrier)) {
-            return POINTER_SIZE;
-        }
-        long bitsAlignment = Math.max(8, Wrapper.forPrimitiveType(carrier).bitWidth());
-        return Utils.bitsToBytesOrThrow(bitsAlignment, IllegalStateException::new);
-    }
-
-    public static boolean isAddress(Class<?> carrier) {
-        return MemoryAddress.class == carrier ||
-                MemoryAddressProxy.class == carrier;
-    }
-
-    public static Class<?> adjustCarrier(Class<?> carrier) {
-        return carrier == MemoryAddress.class ?
-                MemoryAddressProxy.class : carrier;
-    }
-
     // segment factories
 
     public static MemorySegment makeNativeSegment(long bytesSize, long alignmentBytes) {
         long alignedSize = bytesSize;
 
@@ -239,23 +183,12 @@
     }
 
     public static VarHandle fixUpVarHandle(VarHandle handle) {
         // This adaptation is required, otherwise the memory access var handle will have type MemoryAddressProxy,
         // and not MemoryAddress (which the user expects), which causes performance issues with asType() adaptations.
-        handle = MethodHandles.filterCoordinates(handle, 0, ADDRESS_FILTER);
-        return (javaLangInvokeAccess.memoryAddressCarrier(handle) == MemoryAddressProxy.class) ?
-                MethodHandles.filterValue(handle, ADDRESS_TO_LONG, LONG_TO_ADDRESS) :
-                handle;
+        return MethodHandles.filterCoordinates(handle, 0, ADDRESS_FILTER);
     }
 
     private static MemoryAddressProxy filterAddress(MemoryAddress addr) {
         return (MemoryAddressImpl)addr;
     }
-
-    private static MemoryAddress longToAddress(long value) {
-        return MemoryAddress.ofLong(value);
-    }
-
-    private static long addressToLong(MemoryAddress value) {
-        return ((MemoryAddressImpl)value).unsafeGetOffset();
-    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BindingInterpreter.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BindingInterpreter.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BindingInterpreter.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BindingInterpreter.java
@@ -75,11 +75,11 @@
                     stack.push(copy);
                 }
                 case ALLOC_BUFFER ->
                     throw new UnsupportedOperationException();
                 case CONVERT_ADDRESS ->
-                    stack.push(MemoryAddressImpl.addressof((MemoryAddress) stack.pop()));
+                    stack.push(((MemoryAddress) stack.pop()).toRawLongValue());
                 case BASE_ADDRESS ->
                     stack.push(((MemorySegment) stack.pop()).baseAddress());
                 case DUP ->
                     stack.push(stack.peekLast());
                 default -> throw new IllegalArgumentException("Unsupported tag: " + b);
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
@@ -109,11 +109,11 @@
                 stackArgs = MemoryAddressImpl.NULL;
             }
 
             VH_LONG.set(argsPtr.addOffset(layout.arguments_next_pc), addr);
             VH_LONG.set(argsPtr.addOffset(layout.stack_args_bytes), stackArgsBytes);
-            VH_LONG.set(argsPtr.addOffset(layout.stack_args), MemoryAddressImpl.addressof(stackArgs));
+            VH_LONG.set(argsPtr.addOffset(layout.stack_args), stackArgs.toRawLongValue());
 
             for (int i = 0; i < args.length; i++) {
                 Object arg = args[i];
                 jdk.internal.foreign.abi.BindingInterpreter.unbox(arg, callingSequence.argumentBindings(i),
                         s -> {
@@ -127,11 +127,11 @@
             if (DEBUG) {
                 System.err.println("Buffer state before:");
                 layout.dump(abi.arch, argsPtr, System.err);
             }
 
-            invokeNative(stubAddress, MemoryAddressImpl.addressof(argsPtr));
+            invokeNative(stubAddress, argsPtr.toRawLongValue());
 
             if (DEBUG) {
                 System.err.println("Buffer state after:");
                 layout.dump(abi.arch, argsPtr, System.err);
             }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
@@ -91,11 +91,11 @@
         } else if (t instanceof SequenceLayout) {
             // when array is used alone
             return alignmentOfArray((SequenceLayout) t, isVar);
         } else if (t instanceof GroupLayout) {
             return alignmentOfContainer((GroupLayout) t);
-        } else if (Utils.isPadding(t)) {
+        } else if (t.isPadding()) {
             return 1;
         } else {
             throw new IllegalArgumentException("Invalid type: " + t);
         }
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
@@ -53,11 +53,11 @@
         return instance;
     }
 
     @Override
     public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
-        return CallArranger.arrangeDowncall(MemoryAddressImpl.addressof(symbol), type, function);
+        return CallArranger.arrangeDowncall(symbol.toRawLongValue(), type, function);
     }
 
     @Override
     public MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function) {
         return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
@@ -538,11 +538,11 @@
 
         long offset = 0;
         final int count = type.memberLayouts().size();
         for (int idx = 0; idx < count; idx++) {
             MemoryLayout t = type.memberLayouts().get(idx);
-            if (Utils.isPadding(t)) {
+            if (t.isPadding()) {
                 continue;
             }
             // ignore zero-length array for now
             // TODO: handle zero length arrays here
             if (t instanceof SequenceLayout) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
@@ -57,11 +57,11 @@
         return instance;
     }
 
     @Override
     public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
-        return CallArranger.arrangeDowncall(MemoryAddressImpl.addressof(symbol), type, function);
+        return CallArranger.arrangeDowncall(symbol.toRawLongValue(), type, function);
     }
 
     @Override
     public MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function) {
         return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
@@ -62,11 +62,11 @@
         return instance;
     }
 
     @Override
     public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
-        return CallArranger.arrangeDowncall(MemoryAddressImpl.addressof(symbol), type, function);
+        return CallArranger.arrangeDowncall(symbol.toRawLongValue(), type, function);
     }
 
     @Override
     public MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function) {
         return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
diff a/test/jdk/java/foreign/CallGeneratorHelper.java b/test/jdk/java/foreign/CallGeneratorHelper.java
--- a/test/jdk/java/foreign/CallGeneratorHelper.java
+++ b/test/jdk/java/foreign/CallGeneratorHelper.java
@@ -20,17 +20,15 @@
  *  or visit www.oracle.com if you need additional information or have any
  *  questions.
  *
  */
 
-import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.ValueLayout;
-import jdk.internal.foreign.Utils;
 
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Stack;
@@ -384,16 +382,16 @@
         }
     }
 
     static void initStruct(MemorySegment str, GroupLayout g, List<Consumer<Object>> checks, boolean check) throws ReflectiveOperationException {
         for (MemoryLayout l : g.memberLayouts()) {
-            if (Utils.isPadding(l)) continue;
+            if (l.isPadding()) continue;
             VarHandle accessor = g.varHandle(structFieldCarrier(l), MemoryLayout.PathElement.groupElement(l.name().get()));
             List<Consumer<Object>> fieldsCheck = new ArrayList<>();
             Object value = makeArg(l, fieldsCheck, check);
             if (isPointer(l)) {
-                value = Foreign.getInstance().asLong((MemoryAddress)value);
+                value = ((MemoryAddress)value).toRawLongValue();
             }
             //set value
             accessor.set(str.baseAddress(), value);
             //add check
             if (check) {
diff a/test/jdk/java/foreign/TestAdaptVarHandles.java b/test/jdk/java/foreign/TestAdaptVarHandles.java
--- a/test/jdk/java/foreign/TestAdaptVarHandles.java
+++ b/test/jdk/java/foreign/TestAdaptVarHandles.java
@@ -392,10 +392,52 @@
     public void testBadCollectCoordinatesWrongFilterException() {
         VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MethodHandles.collectCoordinates(intHandle, 0, S2L_EX);
     }
 
+    @Test
+    public void testDropCoordinates() throws Throwable {
+        ValueLayout layout = MemoryLayouts.JAVA_INT;
+        MemorySegment segment = MemorySegment.allocateNative(layout);
+        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
+        VarHandle intHandle_dummy = MethodHandles.dropCoordinates(intHandle, 1, float.class, String.class);
+        intHandle_dummy.set(segment.baseAddress(), 1f, "hello", 0L, 1);
+        int oldValue = (int)intHandle_dummy.getAndAdd(segment.baseAddress(), 1f, "hello", 0L, 42);
+        assertEquals(oldValue, 1);
+        int value = (int)intHandle_dummy.get(segment.baseAddress(), 1f, "hello", 0L);
+        assertEquals(value, 43);
+        boolean swapped = (boolean)intHandle_dummy.compareAndSet(segment.baseAddress(), 1f, "hello", 0L, 43, 12);
+        assertTrue(swapped);
+        oldValue = (int)intHandle_dummy.compareAndExchange(segment.baseAddress(), 1f, "hello", 0L, 12, 42);
+        assertEquals(oldValue, 12);
+        value = (int)intHandle_dummy.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress(), 1f, "hello", 0L);
+        assertEquals(value, 42);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadDropCoordinatesNegativePos() {
+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
+        MethodHandles.dropCoordinates(intHandle, -1);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadDropCoordinatesPosTooBig() {
+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
+        MethodHandles.dropCoordinates(intHandle, 2);
+    }
+
+    @Test(expectedExceptions = NullPointerException.class)
+    public void testBadDropCoordinatesNullValueTypes() {
+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
+        MethodHandles.dropCoordinates(intHandle, 1, null);
+    }
+
+    @Test(expectedExceptions = NullPointerException.class)
+    public void testBadDropCoordinatesNullTarget() {
+        MethodHandles.dropCoordinates(null, 1);
+    }
+
     //helper methods
 
     static int stringToInt(String s) {
         return Integer.valueOf(s);
     }
diff a/test/jdk/java/foreign/TestAddressHandle.java b/test/jdk/java/foreign/TestAddressHandle.java
--- a/test/jdk/java/foreign/TestAddressHandle.java
+++ b/test/jdk/java/foreign/TestAddressHandle.java
@@ -22,21 +22,45 @@
  *
  */
 
 /*
  * @test
- * @run testng TestAddressHandle
+ * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAddressHandle
+ * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAddressHandle
+ * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAddressHandle
+ * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAddressHandle
  */
 
 import java.lang.invoke.*;
 import java.nio.ByteOrder;
 import jdk.incubator.foreign.*;
 
 import org.testng.annotations.*;
 import static org.testng.Assert.*;
 
 public class TestAddressHandle {
+
+    static final MethodHandle INT_TO_BOOL;
+    static final MethodHandle BOOL_TO_INT;
+    static final MethodHandle INT_TO_STRING;
+    static final MethodHandle STRING_TO_INT;
+
+    static {
+        try {
+            INT_TO_BOOL = MethodHandles.lookup().findStatic(TestAddressHandle.class, "intToBool",
+                    MethodType.methodType(boolean.class, int.class));
+            BOOL_TO_INT = MethodHandles.lookup().findStatic(TestAddressHandle.class, "boolToInt",
+                    MethodType.methodType(int.class, boolean.class));
+            INT_TO_STRING = MethodHandles.lookup().findStatic(TestAddressHandle.class, "intToString",
+                    MethodType.methodType(String.class, int.class));
+            STRING_TO_INT = MethodHandles.lookup().findStatic(TestAddressHandle.class, "stringToInt",
+                    MethodType.methodType(int.class, String.class));
+        } catch (Throwable ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
+
     @Test(dataProvider = "addressHandles")
     public void testAddressHandle(VarHandle addrHandle) {
         VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
         try (MemorySegment segment = MemorySegment.allocateNative(8)) {
             longHandle.set(segment.baseAddress(), 42L);
@@ -62,14 +86,77 @@
             MemoryAddress address = (MemoryAddress)addrHandle.get(segment.baseAddress());
             assertTrue(address == MemoryAddress.NULL);
         }
     }
 
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadAdaptFloat() {
+        VarHandle floatHandle = MemoryHandles.varHandle(float.class, ByteOrder.nativeOrder());
+        MemoryHandles.asAddressVarHandle(floatHandle);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadAdaptDouble() {
+        VarHandle doubleHandle = MemoryHandles.varHandle(double.class, ByteOrder.nativeOrder());
+        MemoryHandles.asAddressVarHandle(doubleHandle);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadAdaptBoolean() {
+        VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle boolHandle = MethodHandles.filterValue(intHandle, BOOL_TO_INT, INT_TO_BOOL);
+        MemoryHandles.asAddressVarHandle(boolHandle);
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadAdaptString() {
+        VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle stringHandle = MethodHandles.filterValue(intHandle, STRING_TO_INT, INT_TO_STRING);
+        MemoryHandles.asAddressVarHandle(stringHandle);
+    }
+
     @DataProvider(name = "addressHandles")
     static Object[][] addressHandles() {
         return new Object[][] {
-            { MemoryHandles.varHandle(MemoryAddress.class, ByteOrder.nativeOrder()) },
-            { MemoryHandles.withOffset(MemoryHandles.varHandle(MemoryAddress.class, ByteOrder.nativeOrder()), 0) },
-            { MemoryLayouts.JAVA_LONG.varHandle(MemoryAddress.class) }
+                // long
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_LONG.varHandle(long.class)) },
+
+                // int
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_INT.varHandle(int.class)) },
+
+                // short
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_SHORT.varHandle(short.class)) },
+
+                // char
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_CHAR.varHandle(char.class)) },
+
+                // byte
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder())) },
+                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder()), 0)) },
+                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_BYTE.varHandle(byte.class)) }
         };
     }
+
+    static int boolToInt(boolean value) {
+        return value ? 1 : 0;
+    }
+
+    static boolean intToBool(int value) {
+        return value != 0;
+    }
+
+    static int stringToInt(String value) {
+        return value.length();
+    }
+
+    static String intToString(int value) {
+        return String.valueOf(value);
+    }
 }
diff a/test/jdk/java/foreign/TestAllocationScope.java b/test/jdk/java/foreign/TestAllocationScope.java
--- a/test/jdk/java/foreign/TestAllocationScope.java
+++ b/test/jdk/java/foreign/TestAllocationScope.java
@@ -26,27 +26,30 @@
  * @test
  * @run testng TestAllocationScope
  */
 
 import jdk.incubator.foreign.AllocationScope;
+import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryAddress;
 
 import org.testng.annotations.*;
 
+import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.function.Function;
 
 import static org.testng.Assert.*;
 
 public class TestAllocationScope {
 
     final static int ELEMS = 128;
 
     @Test(dataProvider = "allocationScopes")
-    public <Z> void testAllocation(Z value, ScopeFactory scopeFactory, MemoryLayout layout, Class<?> carrier, AllocationFunction<Z> allocationFunction) {
+    public <Z> void testAllocation(Z value, ScopeFactory scopeFactory, MemoryLayout layout, Class<?> carrier, AllocationFunction<Z> allocationFunction, Function<MemoryLayout, VarHandle> handleFactory) {
         MemoryLayout[] layouts = {
                 layout,
                 layout.withBitAlignment(layout.bitAlignment() * 2),
                 layout.withBitAlignment(layout.bitAlignment() * 4),
                 layout.withBitAlignment(layout.bitAlignment() * 8)
@@ -57,11 +60,12 @@
             try (AllocationScope scope = scopeFactory.make((int)alignedLayout.byteSize() * ELEMS)) {
                 for (int i = 0 ; i < elems ; i++) {
                     MemoryAddress address = allocationFunction.allocate(scope, alignedLayout, value);
                     assertEquals(address.segment().byteSize(), alignedLayout.byteSize());
                     addressList.add(address);
-                    assertEquals(value, alignedLayout.varHandle(carrier).get(address));
+                    VarHandle handle = handleFactory.apply(alignedLayout);
+                    assertEquals(value, handle.get(address));
                     try {
                         address.segment().close();
                         fail();
                     } catch (UnsupportedOperationException uoe) {
                         //failure is expected
@@ -86,106 +90,193 @@
 
 
     @DataProvider(name = "allocationScopes")
     static Object[][] allocationScopes() {
         return new Object[][] {
-                { (byte)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_8_BE, byte.class, (AllocationFunction<Byte>)AllocationScope::allocate },
-                { (short)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_16_BE, short.class, (AllocationFunction<Short>)AllocationScope::allocate },
-                { 42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_32_BE, int.class, (AllocationFunction<Integer>)AllocationScope::allocate },
-                { 42f, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_32_BE, float.class, (AllocationFunction<Float>)AllocationScope::allocate },
-                { 42L, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_BE, long.class, (AllocationFunction<Long>)AllocationScope::allocate },
-                { 42d, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_BE, double.class, (AllocationFunction<Double>)AllocationScope::allocate },
-                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_BE, MemoryAddress.class, (AllocationFunction<MemoryAddress>)AllocationScope::allocate },
-                
-                { (byte)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_8_BE, byte.class, (AllocationFunction<Byte>)AllocationScope::allocate },
-                { (short)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_16_BE, short.class, (AllocationFunction<Short>)AllocationScope::allocate },
-                { 42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_32_BE, int.class, (AllocationFunction<Integer>)AllocationScope::allocate },
-                { 42f, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_32_BE, float.class, (AllocationFunction<Float>)AllocationScope::allocate },
-                { 42L, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_BE, long.class, (AllocationFunction<Long>)AllocationScope::allocate },
-                { 42d, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_BE, double.class, (AllocationFunction<Double>)AllocationScope::allocate },
-                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_BE, MemoryAddress.class, (AllocationFunction<MemoryAddress>)AllocationScope::allocate },
-                
-                { (byte)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_8_LE, byte.class, (AllocationFunction<Byte>)AllocationScope::allocate },
-                { (short)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_16_LE, short.class, (AllocationFunction<Short>)AllocationScope::allocate },
-                { 42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_32_LE, int.class, (AllocationFunction<Integer>)AllocationScope::allocate },
-                { 42f, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_32_LE, float.class, (AllocationFunction<Float>)AllocationScope::allocate },
-                { 42L, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_LE, long.class, (AllocationFunction<Long>)AllocationScope::allocate },
-                { 42d, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_LE, double.class, (AllocationFunction<Double>)AllocationScope::allocate },
-                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_LE, MemoryAddress.class, (AllocationFunction<MemoryAddress>)AllocationScope::allocate },
-                
-                { (byte)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_8_LE, byte.class, (AllocationFunction<Byte>)AllocationScope::allocate },
-                { (short)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_16_LE, short.class, (AllocationFunction<Short>)AllocationScope::allocate },
-                { 42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_32_LE, int.class, (AllocationFunction<Integer>)AllocationScope::allocate },
-                { 42f, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_32_LE, float.class, (AllocationFunction<Float>)AllocationScope::allocate },
-                { 42L, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_LE, long.class, (AllocationFunction<Long>)AllocationScope::allocate },
-                { 42d, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_LE, double.class, (AllocationFunction<Double>)AllocationScope::allocate },
-                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_LE, MemoryAddress.class, (AllocationFunction<MemoryAddress>)AllocationScope::allocate },
-
-                { (byte)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_8_BE, byte.class, (AllocationFunction<Byte>)AllocationScope::allocate },
-                { (short)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_16_BE, short.class, (AllocationFunction<Short>)AllocationScope::allocate },
-                { 42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_32_BE, int.class, (AllocationFunction<Integer>)AllocationScope::allocate },
-                { 42f, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_32_BE, float.class, (AllocationFunction<Float>)AllocationScope::allocate },
-                { 42L, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_BE, long.class, (AllocationFunction<Long>)AllocationScope::allocate },
-                { 42d, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_BE, double.class, (AllocationFunction<Double>)AllocationScope::allocate },
-                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_BE, MemoryAddress.class, (AllocationFunction<MemoryAddress>)AllocationScope::allocate },
-
-                { (byte)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_8_BE, byte.class, (AllocationFunction<Byte>)AllocationScope::allocate },
-                { (short)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_16_BE, short.class, (AllocationFunction<Short>)AllocationScope::allocate },
-                { 42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_32_BE, int.class, (AllocationFunction<Integer>)AllocationScope::allocate },
-                { 42f, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_32_BE, float.class, (AllocationFunction<Float>)AllocationScope::allocate },
-                { 42L, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_BE, long.class, (AllocationFunction<Long>)AllocationScope::allocate },
-                { 42d, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_BE, double.class, (AllocationFunction<Double>)AllocationScope::allocate },
-                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_BE, MemoryAddress.class, (AllocationFunction<MemoryAddress>)AllocationScope::allocate },
-
-                { (byte)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_8_LE, byte.class, (AllocationFunction<Byte>)AllocationScope::allocate },
-                { (short)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_16_LE, short.class, (AllocationFunction<Short>)AllocationScope::allocate },
-                { 42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_32_LE, int.class, (AllocationFunction<Integer>)AllocationScope::allocate },
-                { 42f, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_32_LE, float.class, (AllocationFunction<Float>)AllocationScope::allocate },
-                { 42L, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_LE, long.class, (AllocationFunction<Long>)AllocationScope::allocate },
-                { 42d, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_LE, double.class, (AllocationFunction<Double>)AllocationScope::allocate },
-                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_LE, MemoryAddress.class, (AllocationFunction<MemoryAddress>)AllocationScope::allocate },
-
-                { (byte)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_8_LE, byte.class, (AllocationFunction<Byte>)AllocationScope::allocate },
-                { (short)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_16_LE, short.class, (AllocationFunction<Short>)AllocationScope::allocate },
-                { 42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_32_LE, int.class, (AllocationFunction<Integer>)AllocationScope::allocate },
-                { 42f, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_32_LE, float.class, (AllocationFunction<Float>)AllocationScope::allocate },
-                { 42L, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_LE, long.class, (AllocationFunction<Long>)AllocationScope::allocate },
-                { 42d, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_LE, double.class, (AllocationFunction<Double>)AllocationScope::allocate },
-                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_LE, MemoryAddress.class, (AllocationFunction<MemoryAddress>)AllocationScope::allocate },
-
-
-                { (byte)42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_8_BE, byte.class, (AllocationFunction<Byte>)AllocationScope::allocate },
-                { (short)42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_16_BE, short.class, (AllocationFunction<Short>)AllocationScope::allocate },
-                { 42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_32_BE, int.class, (AllocationFunction<Integer>)AllocationScope::allocate },
-                { 42f, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_32_BE, float.class, (AllocationFunction<Float>)AllocationScope::allocate },
-                { 42L, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_BE, long.class, (AllocationFunction<Long>)AllocationScope::allocate },
-                { 42d, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_BE, double.class, (AllocationFunction<Double>)AllocationScope::allocate },
-                { MemoryAddress.ofLong(42), (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_BE, MemoryAddress.class, (AllocationFunction<MemoryAddress>)AllocationScope::allocate },
-
-                { (byte)42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_8_BE, byte.class, (AllocationFunction<Byte>)AllocationScope::allocate },
-                { (short)42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_16_BE, short.class, (AllocationFunction<Short>)AllocationScope::allocate },
-                { 42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_32_BE, int.class, (AllocationFunction<Integer>)AllocationScope::allocate },
-                { 42f, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_32_BE, float.class, (AllocationFunction<Float>)AllocationScope::allocate },
-                { 42L, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_BE, long.class, (AllocationFunction<Long>)AllocationScope::allocate },
-                { 42d, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_BE, double.class, (AllocationFunction<Double>)AllocationScope::allocate },
-                { MemoryAddress.ofLong(42), (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_BE, MemoryAddress.class, (AllocationFunction<MemoryAddress>)AllocationScope::allocate },
-
-                { (byte)42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_8_LE, byte.class, (AllocationFunction<Byte>)AllocationScope::allocate },
-                { (short)42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_16_LE, short.class, (AllocationFunction<Short>)AllocationScope::allocate },
-                { 42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_32_LE, int.class, (AllocationFunction<Integer>)AllocationScope::allocate },
-                { 42f, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_32_LE, float.class, (AllocationFunction<Float>)AllocationScope::allocate },
-                { 42L, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_LE, long.class, (AllocationFunction<Long>)AllocationScope::allocate },
-                { 42d, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_LE, double.class, (AllocationFunction<Double>)AllocationScope::allocate },
-                { MemoryAddress.ofLong(42), (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_LE, MemoryAddress.class, (AllocationFunction<MemoryAddress>)AllocationScope::allocate },
-
-                { (byte)42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_8_LE, byte.class, (AllocationFunction<Byte>)AllocationScope::allocate },
-                { (short)42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_16_LE, short.class, (AllocationFunction<Short>)AllocationScope::allocate },
-                { 42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_32_LE, int.class, (AllocationFunction<Integer>)AllocationScope::allocate },
-                { 42f, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_32_LE, float.class, (AllocationFunction<Float>)AllocationScope::allocate },
-                { 42L, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_LE, long.class, (AllocationFunction<Long>)AllocationScope::allocate },
-                { 42d, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_LE, double.class, (AllocationFunction<Double>)AllocationScope::allocate },
-                { MemoryAddress.ofLong(42), (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_LE, MemoryAddress.class, (AllocationFunction<MemoryAddress>)AllocationScope::allocate },
+                { (byte)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_8_BE, byte.class,
+                        (AllocationFunction<Byte>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
+                { (short)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_16_BE, short.class,
+                        (AllocationFunction<Short>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
+                { 42, (ScopeFactory)AllocationScope::boundedHeapScope,
+                        MemoryLayouts.BITS_32_BE, int.class,
+                        (AllocationFunction<Integer>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
+                { 42f, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_32_BE, float.class,
+                        (AllocationFunction<Float>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
+                { 42L, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_BE, long.class,
+                        (AllocationFunction<Long>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
+                { 42d, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_BE, double.class,
+                        (AllocationFunction<Double>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
+                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_BE, MemoryAddress.class,
+                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
+
+                { (byte)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_8_BE, byte.class,
+                        (AllocationFunction<Byte>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
+                { (short)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_16_BE, short.class,
+                        (AllocationFunction<Short>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
+                { 42, (ScopeFactory)AllocationScope::boundedNativeScope,
+                        MemoryLayouts.BITS_32_BE, int.class,
+                        (AllocationFunction<Integer>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
+                { 42f, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_32_BE, float.class,
+                        (AllocationFunction<Float>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
+                { 42L, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_BE, long.class,
+                        (AllocationFunction<Long>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
+                { 42d, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_BE, double.class,
+                        (AllocationFunction<Double>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
+                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_BE, MemoryAddress.class,
+                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
+
+                { (byte)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_8_LE, byte.class,
+                        (AllocationFunction<Byte>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
+                { (short)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_16_LE, short.class,
+                        (AllocationFunction<Short>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
+                { 42, (ScopeFactory)AllocationScope::boundedHeapScope,
+                        MemoryLayouts.BITS_32_LE, int.class,
+                        (AllocationFunction<Integer>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
+                { 42f, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_32_LE, float.class,
+                        (AllocationFunction<Float>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
+                { 42L, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_LE, long.class,
+                        (AllocationFunction<Long>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
+                { 42d, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_LE, double.class,
+                        (AllocationFunction<Double>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
+                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_LE, MemoryAddress.class,
+                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
+
+                { (byte)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_8_LE, byte.class,
+                        (AllocationFunction<Byte>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
+                { (short)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_16_LE, short.class,
+                        (AllocationFunction<Short>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
+                { 42, (ScopeFactory)AllocationScope::boundedNativeScope,
+                        MemoryLayouts.BITS_32_LE, int.class,
+                        (AllocationFunction<Integer>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
+                { 42f, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_32_LE, float.class,
+                        (AllocationFunction<Float>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
+                { 42L, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_LE, long.class,
+                        (AllocationFunction<Long>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
+                { 42d, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_LE, double.class,
+                        (AllocationFunction<Double>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
+                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_LE, MemoryAddress.class,
+                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
+
+                { (byte)42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_8_BE, byte.class,
+                        (AllocationFunction<Byte>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
+                { (short)42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_16_BE, short.class,
+                        (AllocationFunction<Short>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
+                { 42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(),
+                        MemoryLayouts.BITS_32_BE, int.class,
+                        (AllocationFunction<Integer>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
+                { 42f, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_32_BE, float.class,
+                        (AllocationFunction<Float>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
+                { 42L, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_BE, long.class,
+                        (AllocationFunction<Long>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
+                { 42d, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_BE, double.class,
+                        (AllocationFunction<Double>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
+                { MemoryAddress.ofLong(42), (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_BE, MemoryAddress.class,
+                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
+
+                { (byte)42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_8_BE, byte.class,
+                        (AllocationFunction<Byte>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
+                { (short)42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_16_BE, short.class,
+                        (AllocationFunction<Short>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
+                { 42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(),
+                        MemoryLayouts.BITS_32_BE, int.class,
+                        (AllocationFunction<Integer>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
+                { 42f, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_32_BE, float.class,
+                        (AllocationFunction<Float>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
+                { 42L, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_BE, long.class,
+                        (AllocationFunction<Long>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
+                { 42d, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_BE, double.class,
+                        (AllocationFunction<Double>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
+                { MemoryAddress.ofLong(42), (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_BE, MemoryAddress.class,
+                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
+
+                { (byte)42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_8_LE, byte.class,
+                        (AllocationFunction<Byte>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
+                { (short)42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_16_LE, short.class,
+                        (AllocationFunction<Short>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
+                { 42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(),
+                        MemoryLayouts.BITS_32_LE, int.class,
+                        (AllocationFunction<Integer>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
+                { 42f, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_32_LE, float.class,
+                        (AllocationFunction<Float>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
+                { 42L, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_LE, long.class,
+                        (AllocationFunction<Long>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
+                { 42d, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_LE, double.class,
+                        (AllocationFunction<Double>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
+                { MemoryAddress.ofLong(42), (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_LE, MemoryAddress.class,
+                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
+
+                { (byte)42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_8_LE, byte.class,
+                        (AllocationFunction<Byte>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
+                { (short)42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_16_LE, short.class,
+                        (AllocationFunction<Short>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
+                { 42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(),
+                        MemoryLayouts.BITS_32_LE, int.class,
+                        (AllocationFunction<Integer>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
+                { 42f, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_32_LE, float.class,
+                        (AllocationFunction<Float>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
+                { 42L, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_LE, long.class,
+                        (AllocationFunction<Long>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
+                { 42d, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_LE, double.class,
+                        (AllocationFunction<Double>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
+                { MemoryAddress.ofLong(42), (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_LE, MemoryAddress.class,
+                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
         };
     }
 
     interface AllocationFunction<X> {
         MemoryAddress allocate(AllocationScope scope, MemoryLayout layout, X value);
diff a/test/jdk/java/foreign/TestLayouts.java b/test/jdk/java/foreign/TestLayouts.java
--- a/test/jdk/java/foreign/TestLayouts.java
+++ b/test/jdk/java/foreign/TestLayouts.java
@@ -206,10 +206,15 @@
         );
         assertEquals(struct.byteSize(), 8);
         assertEquals(struct.byteAlignment(), 8);
     }
 
+    @Test(dataProvider = "layoutKinds")
+    public void testPadding(LayoutKind kind) {
+        assertEquals(kind == LayoutKind.PADDING, kind.layout.isPadding());
+    }
+
     @Test(dataProvider="layoutsAndAlignments")
     public void testAlignmentString(MemoryLayout layout, long bitAlign) {
         long[] alignments = { 8, 16, 32, 64, 128 };
         for (long a : alignments) {
             assertFalse(layout.toString().contains("%"));
@@ -254,10 +259,17 @@
             values[(i * 2) + 1] = new Object[] { layoutKinds[i].layout, 18 }; // not a power of 2
         }
         return values;
     }
 
+    @DataProvider(name = "layoutKinds")
+    public Object[][] layoutsKinds() {
+        return Stream.of(LayoutKind.values())
+                .map(lk -> new Object[] { lk })
+                .toArray(Object[][]::new);
+    }
+
     enum SizedLayoutFactory {
         VALUE_LE(size -> MemoryLayout.ofValueBits(size, ByteOrder.LITTLE_ENDIAN)),
         VALUE_BE(size -> MemoryLayout.ofValueBits(size, ByteOrder.BIG_ENDIAN)),
         PADDING(MemoryLayout::ofPaddingBits),
         SEQUENCE(size -> MemoryLayout.ofSequence(size, MemoryLayouts.PAD_8));
diff a/test/jdk/java/foreign/TestNative.java b/test/jdk/java/foreign/TestNative.java
--- a/test/jdk/java/foreign/TestNative.java
+++ b/test/jdk/java/foreign/TestNative.java
@@ -23,24 +23,23 @@
  */
 
 /*
  * @test
  * @modules java.base/jdk.internal.misc
- *          jdk.incubator.foreign/jdk.incubator.foreign.unsafe
- * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit TestNative
+ *          jdk.incubator.foreign
+ * @run testng TestNative
  */
 
-import jdk.incubator.foreign.Foreign;
-import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
-import jdk.internal.misc.Unsafe;
-import org.testng.annotations.*;
-
-import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
+import jdk.internal.misc.Unsafe;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
 
 import java.lang.invoke.VarHandle;
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -53,11 +52,11 @@
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import java.util.function.Function;
 
-import static org.testng.Assert.*;
+import static org.testng.Assert.assertEquals;
 
 public class TestNative {
 
     static Unsafe UNSAFE;
 
@@ -116,11 +115,11 @@
         ByteBuffer bb = base.segment().asSlice(base.offset(), (int)layout.byteSize()).asByteBuffer();
         Z z = bufferFactory.apply(bb);
         for (long i = 0 ; i < nelems ; i++) {
             Object handleValue = handleExtractor.apply(base, i);
             Object bufferValue = nativeBufferExtractor.apply(z, (int)i);
-            Object rawValue = nativeRawExtractor.apply(Foreign.getInstance().asLong(base), (int)i);
+            Object rawValue = nativeRawExtractor.apply(base.toRawLongValue(), (int)i);
             if (handleValue instanceof Number) {
                 assertEquals(((Number)handleValue).longValue(), i);
                 assertEquals(((Number)bufferValue).longValue(), i);
                 assertEquals(((Number)rawValue).longValue(), i);
             } else {
diff a/test/jdk/java/foreign/TestTypeAccess.java b/test/jdk/java/foreign/TestTypeAccess.java
--- a/test/jdk/java/foreign/TestTypeAccess.java
+++ b/test/jdk/java/foreign/TestTypeAccess.java
@@ -39,11 +39,11 @@
 
 public class TestTypeAccess {
 
     static final VarHandle INT_HANDLE = MemoryLayouts.JAVA_INT.varHandle(int.class);
 
-    static final VarHandle ADDR_HANDLE = MemoryHandles.varHandle(MemoryAddress .class, ByteOrder.nativeOrder());
+    static final VarHandle ADDR_HANDLE = MemoryHandles.asAddressVarHandle(INT_HANDLE);
 
     @Test(expectedExceptions=ClassCastException.class)
     public void testMemoryAddressCoordinateAsString() {
         try (MemorySegment s = MemorySegment.allocateNative(8)) {
             int v = (int)INT_HANDLE.get("string");
diff a/test/jdk/java/foreign/TestVarArgs.java b/test/jdk/java/foreign/TestVarArgs.java
--- a/test/jdk/java/foreign/TestVarArgs.java
+++ b/test/jdk/java/foreign/TestVarArgs.java
@@ -85,12 +85,12 @@
             MemorySegment callInfo = MemorySegment.allocateNative(ML_CallInfo);
             MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.ofSequence(args.size(), C_INT))) {
 
             MemoryAddress callInfoPtr = callInfo.baseAddress();
 
-            VH_CallInfo_writeback.set(callInfoPtr, MemoryAddressImpl.addressof(writeBack.baseAddress()));
-            VH_CallInfo_argIDs.set(callInfoPtr, MemoryAddressImpl.addressof(argIDs.baseAddress()));
+            VH_CallInfo_writeback.set(callInfoPtr, writeBack.baseAddress().toRawLongValue());
+            VH_CallInfo_argIDs.set(callInfoPtr, argIDs.baseAddress().toRawLongValue());
 
             for (int i = 0; i < args.size(); i++) {
                 VH_IntArray.set(argIDs.baseAddress(), (long) i, args.get(i).id.ordinal());
             }
 
diff a/test/jdk/java/foreign/TestVarHandleCombinators.java b/test/jdk/java/foreign/TestVarHandleCombinators.java
--- a/test/jdk/java/foreign/TestVarHandleCombinators.java
+++ b/test/jdk/java/foreign/TestVarHandleCombinators.java
@@ -32,10 +32,11 @@
 import org.testng.annotations.Test;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 
+import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
 
 import static org.testng.Assert.assertEquals;
 
@@ -51,20 +52,31 @@
         MemoryAddress addr = segment.baseAddress();
 
         assertEquals((byte) vh.get(addr, 2), (byte) -1);
     }
 
-    @Test(expectedExceptions = IllegalArgumentException.class)
+    @Test(expectedExceptions = IllegalStateException.class)
     public void testUnalignedElement() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());
-        MemoryHandles.withStride(vh, 2);
+        vh = MemoryHandles.withStride(vh, 2);
+        MemorySegment segment = MemorySegment.ofArray(new byte[4]);
+        vh.get(segment.baseAddress(), 1L); //should throw
     }
 
-    @Test(expectedExceptions = IllegalArgumentException.class)
-    public void testBadStrideElement() {
+    public void testZeroStrideElement() {
         VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
-        MemoryHandles.withStride(vh, 0); //scale factor cant be zero
+        VarHandle strided_vh = MemoryHandles.withStride(vh, 0);
+        MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
+        for (int i = 0 ; i < 100 ; i++) {
+            assertEquals((int)vh.get(segment.baseAddress()), strided_vh.get(segment.baseAddress(), (long)i));
+        }
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testStrideWrongHandle() {
+        VarHandle vh = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());
+        MemoryHandles.withStride(vh, 10);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testAlignNotPowerOf2() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 3, ByteOrder.nativeOrder());
@@ -84,31 +96,42 @@
 
         vh.set(address, (byte) 10); // fine, memory region is aligned
         assertEquals((byte) vh.get(address), (byte) 10);
     }
 
-    @Test(expectedExceptions = IllegalArgumentException.class)
+    @Test(expectedExceptions = IllegalStateException.class)
     public void testAlignBadAccess() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());
         vh = MemoryHandles.withOffset(vh, 1); // offset by 1 byte
 
         MemorySegment segment = MemorySegment.allocateNative(2, 2);
         MemoryAddress address = segment.baseAddress();
 
         vh.set(address, (byte) 10); // should be bad align
     }
 
-    @Test(expectedExceptions = IllegalArgumentException.class)
-    public void testOffsetNegative() {
-        VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
-        MemoryHandles.withOffset(vh, -1);
+    public void testZeroOffsetElement() {
+        VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle offset_vh = MemoryHandles.withOffset(vh, 0);
+        MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
+        for (int i = 0 ; i < 100 ; i++) {
+            assertEquals((int)vh.get(segment.baseAddress()), offset_vh.get(segment.baseAddress(), (long)i));
+        }
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testOffsetWrongHandle() {
+        VarHandle vh = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());
+        MemoryHandles.withOffset(vh, 1);
+    }
+
+    @Test(expectedExceptions = IllegalStateException.class)
     public void testUnalignedOffset() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());
-        MemoryHandles.withOffset(vh, 2);
+        vh = MemoryHandles.withOffset(vh, 2);
+        MemorySegment segment = MemorySegment.ofArray(new byte[4]);
+        vh.get(segment.baseAddress()); //should throw
     }
 
     @Test
     public void testOffset() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());

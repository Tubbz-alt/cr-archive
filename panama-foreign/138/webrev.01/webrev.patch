diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java
@@ -37,25 +37,11 @@
 class HeaderBuilder extends JavaSourceBuilder {
     HeaderBuilder(String className, String pkgName, ConstantHelper constantHelper) {
         super(className, pkgName, constantHelper);
     }
 
-    public void addFunctionalFactory(String className, MethodType mtype, FunctionDescriptor fDesc) {
-        incrAlign();
-        indent();
-        sb.append(PUB_MODS + "MemoryAddress " + className + "$make(" + className + " fi) {\n");
-        incrAlign();
-        indent();
-        sb.append("return RuntimeHelper.upcallStub(" + className + ".class, fi, " + functionGetCallString(className, fDesc) + ", " +
-                "\"" + mtype.toMethodDescriptorString() + "\");\n");
-        decrAlign();
-        indent();
-        sb.append("}\n");
-        decrAlign();
-    }
-
-    public void addFunctionalInterface(String name, MethodType mtype) {
+    public void addFunctionalInterface(String name, MethodType mtype,  FunctionDescriptor fDesc) {
         incrAlign();
         indent();
         sb.append("public interface " + name + " {\n");
         incrAlign();
         indent();
@@ -64,10 +50,11 @@
         for (int i = 0 ; i < mtype.parameterCount() ; i++) {
             sb.append(delim + mtype.parameterType(i).getName() + " x" + i);
             delim = ", ";
         }
         sb.append(");\n");
+        addFunctionalFactory(name, mtype, fDesc);
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
         indent();
@@ -119,6 +106,18 @@
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
+
+    private void addFunctionalFactory(String className, MethodType mtype, FunctionDescriptor fDesc) {
+        indent();
+        sb.append(PUB_MODS + "MemoryAddress allocate(" + className + " fi) {\n");
+        incrAlign();
+        indent();
+        sb.append("return RuntimeHelper.upcallStub(" + className + ".class, fi, " + functionGetCallString(className, fDesc) + ", " +
+                "\"" + mtype.toMethodDescriptorString() + "\");\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+    }
 }
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
@@ -39,11 +39,11 @@
 /**
  * Superclass for .java source generator classes.
  */
 abstract class JavaSourceBuilder {
     static final String PUB_CLS_MODS = "public final ";
-    static final String PUB_MODS = "public static final ";
+    static final String PUB_MODS = "public static ";
     protected final String className;
     protected final String pkgName;
     protected final ConstantHelper constantHelper;
     // buffer
     protected final StringBuffer sb;
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
@@ -282,13 +282,11 @@
             if (f != null) {
                 String name = funcTree.name() + "$" + (param.name().isEmpty() ? "x" + i : param.name());
                 name = Utils.javaSafeIdentifier(name);
                 //generate functional interface
                 MethodType fitype = typeTranslator.getMethodType(f);
-                builder.addFunctionalInterface(name, fitype);
-                //generate helper
-                builder.addFunctionalFactory(name, fitype, Type.descriptorFor(f).orElseThrow());
+                builder.addFunctionalInterface(name, fitype, Type.descriptorFor(f).orElseThrow());
                 i++;
             }
         }
         return null;
     }
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template
@@ -75,10 +75,14 @@
         } catch (Throwable ex) {
             throw new AssertionError(ex);
         }
     }
 
+    public static void freeUpcallStub(MemoryAddress addr) {
+        ABI.freeUpcallStub(addr);
+    }
+
     private static class VarargsInvoker {
         private static final MethodHandle INVOKE_MH;
         private final MemoryAddress symbol;
         private final MethodType varargs;
         private final FunctionDescriptor function;
diff a/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java b/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java
--- a/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java
+++ b/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java
@@ -216,11 +216,11 @@
     @Test(dataProvider = "functionalInterfaces")
     public void testFunctionalInterface(String name, MethodType type) {
         Class<?> fiClass = findNestedClass(cls, name);
         assertNotNull(fiClass);
         checkMethod(fiClass, "apply", type);
-        checkMethod(cls, name + "$make", MemoryAddress.class, fiClass);
+        checkMethod(fiClass, "allocate", MemoryAddress.class, fiClass);
     }
 
     @BeforeClass
     public void setup() {
         outputDir = getOutputFilePath("exmples_out");
diff a/test/jdk/tools/jextract/testFunctionPointer/LibFuncPtrTest.java b/test/jdk/tools/jextract/testFunctionPointer/LibFuncPtrTest.java
--- /dev/null
+++ b/test/jdk/tools/jextract/testFunctionPointer/LibFuncPtrTest.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import org.testng.annotations.Test;
+import test.jextract.fp.RuntimeHelper;
+
+import static org.testng.Assert.assertEquals;
+import static test.jextract.fp.funcPtr_h.*;
+
+/*
+ * @test
+ * @library ..
+ * @modules jdk.incubator.jextract
+ * @run driver JtregJextract -l FuncPtr -t test.jextract.fp -- funcPtr.h
+ * @run testng/othervm -Dforeign.restricted=permit LibFuncPtrTest
+ */
+public class LibFuncPtrTest {
+    @Test
+    public void test() {
+        var addr = func$f.allocate(x -> x*x);
+        assertEquals(func(addr, 35), 35*35 + 35);
+        RuntimeHelper.freeUpcallStub(addr);
+    }
+}
diff a/test/jdk/tools/jextract/testFunctionPointer/funcPtr.h b/test/jdk/tools/jextract/testFunctionPointer/funcPtr.h
--- /dev/null
+++ b/test/jdk/tools/jextract/testFunctionPointer/funcPtr.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif // __cplusplus
+
+#ifdef _WIN64
+#define EXPORT __declspec(dllexport)
+#else
+#define EXPORT
+#endif
+
+EXPORT int func(int (*f)(int), int);
+
+#ifdef __cplusplus
+}
+#endif // __cplusplus
diff a/test/jdk/tools/jextract/testFunctionPointer/libFuncPtr.c b/test/jdk/tools/jextract/testFunctionPointer/libFuncPtr.c
--- /dev/null
+++ b/test/jdk/tools/jextract/testFunctionPointer/libFuncPtr.c
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "funcPtr.h"
+
+EXPORT int func(int (*f)(int), int x) {
+    return x + f(x);
+}

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/graphKit.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="callGenerator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/hotspot/share/opto/graphKit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2611       const Type* type = call_type-&gt;range()-&gt;field_at(TypeFunc::Parms + vm_ret_pos);
2612       VMReg reg = type == Type::HALF
2613         ? VMRegImpl::Bad()
2614         : retRegs[java_ret_read_pos++];
2615 
2616       ret_regs.at_put(vm_ret_pos, reg);
2617       ret_types[vm_ret_pos] = type;
2618     }
2619   }
2620 
2621   const TypeFunc* new_call_type = TypeFunc::make(
2622     TypeTuple::make_func(n_filtered_args, arg_types),
2623     TypeTuple::make_func(n_returns, ret_types)
2624   );
2625 
2626   address call_addr = nep-&gt;entry_point();
2627   if (nep-&gt;need_transition()) {
2628     call_addr = SharedRuntime::make_native_invoker(call_addr,
2629                                                    nep-&gt;shadow_space(),
2630                                                    arg_regs, ret_regs);

2631     C-&gt;add_native_stub(call_addr);
2632   }
2633   assert(call_addr != NULL, &quot;sanity&quot;);
2634 
2635   CallNativeNode* call = new CallNativeNode(new_call_type, call_addr, nep-&gt;name(), TypePtr::BOTTOM,
2636                                             arg_regs,
2637                                             ret_regs,
2638                                             nep-&gt;shadow_space(),
2639                                             nep-&gt;need_transition());
2640 
2641   if (call-&gt;_need_transition) {
2642     add_safepoint_edges(call);
2643   }
2644 
2645   set_predefined_input_for_runtime_call(call);
2646 
2647   for (uint i = 0; i &lt; n_filtered_args; i++) {
2648     call-&gt;init_req(i + TypeFunc::Parms, argument_nodes[i]);
2649   }
2650 
</pre>
</td>
<td>
<hr />
<pre>
2611       const Type* type = call_type-&gt;range()-&gt;field_at(TypeFunc::Parms + vm_ret_pos);
2612       VMReg reg = type == Type::HALF
2613         ? VMRegImpl::Bad()
2614         : retRegs[java_ret_read_pos++];
2615 
2616       ret_regs.at_put(vm_ret_pos, reg);
2617       ret_types[vm_ret_pos] = type;
2618     }
2619   }
2620 
2621   const TypeFunc* new_call_type = TypeFunc::make(
2622     TypeTuple::make_func(n_filtered_args, arg_types),
2623     TypeTuple::make_func(n_returns, ret_types)
2624   );
2625 
2626   address call_addr = nep-&gt;entry_point();
2627   if (nep-&gt;need_transition()) {
2628     call_addr = SharedRuntime::make_native_invoker(call_addr,
2629                                                    nep-&gt;shadow_space(),
2630                                                    arg_regs, ret_regs);
<span class="line-added">2631     if (call_addr == NULL) return NULL;</span>
2632     C-&gt;add_native_stub(call_addr);
2633   }
2634   assert(call_addr != NULL, &quot;sanity&quot;);
2635 
2636   CallNativeNode* call = new CallNativeNode(new_call_type, call_addr, nep-&gt;name(), TypePtr::BOTTOM,
2637                                             arg_regs,
2638                                             ret_regs,
2639                                             nep-&gt;shadow_space(),
2640                                             nep-&gt;need_transition());
2641 
2642   if (call-&gt;_need_transition) {
2643     add_safepoint_edges(call);
2644   }
2645 
2646   set_predefined_input_for_runtime_call(call);
2647 
2648   for (uint i = 0; i &lt; n_filtered_args; i++) {
2649     call-&gt;init_req(i + TypeFunc::Parms, argument_nodes[i]);
2650   }
2651 
</pre>
</td>
</tr>
</table>
<center><a href="callGenerator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/vm_version_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_VM_VERSION_X86_HPP
  26 #define CPU_X86_VM_VERSION_X86_HPP
  27 
  28 #include &quot;memory/universe.hpp&quot;
  29 #include &quot;runtime/abstract_vm_version.hpp&quot;
  30 #include &quot;runtime/globals_extension.hpp&quot;
  31 
  32 class VM_Version : public Abstract_VM_Version {
  33   friend class VMStructs;
  34   friend class JVMCIVMStructs;
  35 
  36  public:
  37   // cpuid result register layouts.  These are all unions of a uint32_t
  38   // (in case anyone wants access to the register as a whole) and a bitfield.
  39 
  40   union StdCpuid1Eax {
  41     uint32_t value;
  42     struct {
  43       uint32_t stepping   : 4,
  44                model      : 4,
  45                family     : 4,
  46                proc_type  : 2,
  47                           : 2,
  48                ext_model  : 4,
  49                ext_family : 8,
  50                           : 4;
  51     } bits;
  52   };
  53 
  54   union StdCpuid1Ebx { // example, unused
  55     uint32_t value;
  56     struct {
  57       uint32_t brand_id         : 8,
  58                clflush_size     : 8,
  59                threads_per_cpu  : 8,
  60                apic_id          : 8;
  61     } bits;
  62   };
  63 
  64   union StdCpuid1Ecx {
  65     uint32_t value;
  66     struct {
  67       uint32_t sse3     : 1,
  68                clmul    : 1,
  69                         : 1,
  70                monitor  : 1,
  71                         : 1,
  72                vmx      : 1,
  73                         : 1,
  74                est      : 1,
  75                         : 1,
  76                ssse3    : 1,
  77                cid      : 1,
  78                         : 1,
  79                fma      : 1,
  80                cmpxchg16: 1,
  81                         : 4,
  82                dca      : 1,
  83                sse4_1   : 1,
  84                sse4_2   : 1,
  85                         : 2,
  86                popcnt   : 1,
  87                         : 1,
  88                aes      : 1,
  89                         : 1,
  90                osxsave  : 1,
  91                avx      : 1,
  92                         : 3;
  93     } bits;
  94   };
  95 
  96   union StdCpuid1Edx {
  97     uint32_t value;
  98     struct {
  99       uint32_t          : 4,
 100                tsc      : 1,
 101                         : 3,
 102                cmpxchg8 : 1,
 103                         : 6,
 104                cmov     : 1,
 105                         : 3,
 106                clflush  : 1,
 107                         : 3,
 108                mmx      : 1,
 109                fxsr     : 1,
 110                sse      : 1,
 111                sse2     : 1,
 112                         : 1,
 113                ht       : 1,
 114                         : 3;
 115     } bits;
 116   };
 117 
 118   union DcpCpuid4Eax {
 119     uint32_t value;
 120     struct {
 121       uint32_t cache_type    : 5,
 122                              : 21,
 123                cores_per_cpu : 6;
 124     } bits;
 125   };
 126 
 127   union DcpCpuid4Ebx {
 128     uint32_t value;
 129     struct {
 130       uint32_t L1_line_size  : 12,
 131                partitions    : 10,
 132                associativity : 10;
 133     } bits;
 134   };
 135 
 136   union TplCpuidBEbx {
 137     uint32_t value;
 138     struct {
 139       uint32_t logical_cpus : 16,
 140                             : 16;
 141     } bits;
 142   };
 143 
 144   union ExtCpuid1Ecx {
 145     uint32_t value;
 146     struct {
 147       uint32_t LahfSahf     : 1,
 148                CmpLegacy    : 1,
 149                             : 3,
 150                lzcnt_intel  : 1,
 151                lzcnt        : 1,
 152                sse4a        : 1,
 153                misalignsse  : 1,
 154                prefetchw    : 1,
 155                             : 22;
 156     } bits;
 157   };
 158 
 159   union ExtCpuid1Edx {
 160     uint32_t value;
 161     struct {
 162       uint32_t           : 22,
 163                mmx_amd   : 1,
 164                mmx       : 1,
 165                fxsr      : 1,
 166                          : 4,
 167                long_mode : 1,
 168                tdnow2    : 1,
 169                tdnow     : 1;
 170     } bits;
 171   };
 172 
 173   union ExtCpuid5Ex {
 174     uint32_t value;
 175     struct {
 176       uint32_t L1_line_size : 8,
 177                L1_tag_lines : 8,
 178                L1_assoc     : 8,
 179                L1_size      : 8;
 180     } bits;
 181   };
 182 
 183   union ExtCpuid7Edx {
 184     uint32_t value;
 185     struct {
 186       uint32_t               : 8,
 187               tsc_invariance : 1,
 188                              : 23;
 189     } bits;
 190   };
 191 
 192   union ExtCpuid8Ecx {
 193     uint32_t value;
 194     struct {
 195       uint32_t cores_per_cpu : 8,
 196                              : 24;
 197     } bits;
 198   };
 199 
 200   union SefCpuid7Eax {
 201     uint32_t value;
 202   };
 203 
 204   union SefCpuid7Ebx {
 205     uint32_t value;
 206     struct {
 207       uint32_t fsgsbase : 1,
 208                         : 2,
 209                    bmi1 : 1,
 210                         : 1,
 211                    avx2 : 1,
 212                         : 2,
 213                    bmi2 : 1,
 214                    erms : 1,
 215                         : 1,
 216                     rtm : 1,
 217                         : 4,
 218                 avx512f : 1,
 219                avx512dq : 1,
 220                         : 1,
 221                     adx : 1,
 222                         : 3,
 223              clflushopt : 1,
 224                    clwb : 1,
 225                         : 1,
 226                avx512pf : 1,
 227                avx512er : 1,
 228                avx512cd : 1,
 229                     sha : 1,
 230                avx512bw : 1,
 231                avx512vl : 1;
 232     } bits;
 233   };
 234 
 235   union SefCpuid7Ecx {
 236     uint32_t value;
 237     struct {
 238       uint32_t prefetchwt1 : 1,
 239                avx512_vbmi : 1,
 240                       umip : 1,
 241                        pku : 1,
 242                      ospke : 1,
 243                            : 1,
 244               avx512_vbmi2 : 1,
 245                            : 1,
 246                       gfni : 1,
 247                       vaes : 1,
 248          avx512_vpclmulqdq : 1,
 249                avx512_vnni : 1,
 250              avx512_bitalg : 1,
 251                            : 1,
 252           avx512_vpopcntdq : 1,
 253                            : 17;
 254     } bits;
 255   };
 256 
 257   union SefCpuid7Edx {
 258     uint32_t value;
 259     struct {
 260       uint32_t             : 2,
 261              avx512_4vnniw : 1,
 262              avx512_4fmaps : 1,
 263                            : 28;
 264     } bits;
 265   };
 266 
 267   union ExtCpuid1EEbx {
 268     uint32_t value;
 269     struct {
 270       uint32_t                  : 8,
 271                threads_per_core : 8,
 272                                 : 16;
 273     } bits;
 274   };
 275 
 276   union XemXcr0Eax {
 277     uint32_t value;
 278     struct {
 279       uint32_t x87     : 1,
 280                sse     : 1,
 281                ymm     : 1,
 282                bndregs : 1,
 283                bndcsr  : 1,
 284                opmask  : 1,
 285                zmm512  : 1,
 286                zmm32   : 1,
 287                        : 24;
 288     } bits;
 289   };
 290 
 291 protected:
 292   static int _cpu;
 293   static int _model;
 294   static int _stepping;
 295 
 296   static bool _has_intel_jcc_erratum;
 297 
 298   static address   _cpuinfo_segv_addr; // address of instruction which causes SEGV
 299   static address   _cpuinfo_cont_addr; // address of instruction after the one which causes SEGV
 300 
 301   enum Feature_Flag {
 302     CPU_CX8      = (1 &lt;&lt; 0), // next bits are from cpuid 1 (EDX)
 303     CPU_CMOV     = (1 &lt;&lt; 1),
 304     CPU_FXSR     = (1 &lt;&lt; 2),
 305     CPU_HT       = (1 &lt;&lt; 3),
 306     CPU_MMX      = (1 &lt;&lt; 4),
 307     CPU_3DNOW_PREFETCH = (1 &lt;&lt; 5), // Processor supports 3dnow prefetch and prefetchw instructions
 308                                    // may not necessarily support other 3dnow instructions
 309     CPU_SSE      = (1 &lt;&lt; 6),
 310     CPU_SSE2     = (1 &lt;&lt; 7),
 311     CPU_SSE3     = (1 &lt;&lt; 8),  // SSE3 comes from cpuid 1 (ECX)
 312     CPU_SSSE3    = (1 &lt;&lt; 9),
 313     CPU_SSE4A    = (1 &lt;&lt; 10),
 314     CPU_SSE4_1   = (1 &lt;&lt; 11),
 315     CPU_SSE4_2   = (1 &lt;&lt; 12),
 316     CPU_POPCNT   = (1 &lt;&lt; 13),
 317     CPU_LZCNT    = (1 &lt;&lt; 14),
 318     CPU_TSC      = (1 &lt;&lt; 15),
 319     CPU_TSCINV   = (1 &lt;&lt; 16),
 320     CPU_AVX      = (1 &lt;&lt; 17),
 321     CPU_AVX2     = (1 &lt;&lt; 18),
 322     CPU_AES      = (1 &lt;&lt; 19),
 323     CPU_ERMS     = (1 &lt;&lt; 20), // enhanced &#39;rep movsb/stosb&#39; instructions
 324     CPU_CLMUL    = (1 &lt;&lt; 21), // carryless multiply for CRC
 325     CPU_BMI1     = (1 &lt;&lt; 22),
 326     CPU_BMI2     = (1 &lt;&lt; 23),
 327     CPU_RTM      = (1 &lt;&lt; 24), // Restricted Transactional Memory instructions
 328     CPU_ADX      = (1 &lt;&lt; 25),
 329     CPU_AVX512F  = (1 &lt;&lt; 26), // AVX 512bit foundation instructions
 330     CPU_AVX512DQ = (1 &lt;&lt; 27),
 331     CPU_AVX512PF = (1 &lt;&lt; 28),
 332     CPU_AVX512ER = (1 &lt;&lt; 29),
 333     CPU_AVX512CD = (1 &lt;&lt; 30)
 334     // Keeping sign bit 31 unassigned.
 335   };
 336 
 337 #define CPU_AVX512BW ((uint64_t)UCONST64(0x100000000)) // enums are limited to 31 bit
 338 #define CPU_AVX512VL ((uint64_t)UCONST64(0x200000000)) // EVEX instructions with smaller vector length
 339 #define CPU_SHA ((uint64_t)UCONST64(0x400000000))      // SHA instructions
 340 #define CPU_FMA ((uint64_t)UCONST64(0x800000000))      // FMA instructions
<a name="1" id="anc1"></a><span class="line-modified"> 341 #define CPU_VZEROUPPER ((uint64_t)UCONST64(0x1000000000))       // Vzeroupper instruction</span>
<span class="line-modified"> 342 #define CPU_AVX512_VPOPCNTDQ ((uint64_t)UCONST64(0x2000000000)) // Vector popcount</span>
<span class="line-modified"> 343 #define CPU_AVX512_VPCLMULQDQ ((uint64_t)UCONST64(0x4000000000)) //Vector carryless multiplication</span>
<span class="line-modified"> 344 #define CPU_VAES ((uint64_t)UCONST64(0x8000000000))    // Vector AES instructions</span>
<span class="line-modified"> 345 #define CPU_VNNI ((uint64_t)UCONST64(0x10000000000))   // Vector Neural Network Instructions</span>

 346 
 347 #define CPU_FLUSH ((uint64_t)UCONST64(0x20000000000))  // flush instruction
 348 #define CPU_FLUSHOPT ((uint64_t)UCONST64(0x40000000000)) // flushopt instruction
 349 #define CPU_CLWB ((uint64_t)UCONST64(0x80000000000))   // clwb instruction
<a name="2" id="anc2"></a><span class="line-removed"> 350 #define CPU_VBMI2 ((uint64_t)UCONST64(0x100000000000))   // VBMI2 shift left double instructions</span>
 351 
<a name="3" id="anc3"></a>
 352 
 353 enum Extended_Family {
 354     // AMD
 355     CPU_FAMILY_AMD_11H       = 0x11,
 356     // ZX
 357     CPU_FAMILY_ZX_CORE_F6    = 6,
 358     CPU_FAMILY_ZX_CORE_F7    = 7,
 359     // Intel
 360     CPU_FAMILY_INTEL_CORE    = 6,
 361     CPU_MODEL_NEHALEM        = 0x1e,
 362     CPU_MODEL_NEHALEM_EP     = 0x1a,
 363     CPU_MODEL_NEHALEM_EX     = 0x2e,
 364     CPU_MODEL_WESTMERE       = 0x25,
 365     CPU_MODEL_WESTMERE_EP    = 0x2c,
 366     CPU_MODEL_WESTMERE_EX    = 0x2f,
 367     CPU_MODEL_SANDYBRIDGE    = 0x2a,
 368     CPU_MODEL_SANDYBRIDGE_EP = 0x2d,
 369     CPU_MODEL_IVYBRIDGE_EP   = 0x3a,
 370     CPU_MODEL_HASWELL_E3     = 0x3c,
 371     CPU_MODEL_HASWELL_E7     = 0x3f,
 372     CPU_MODEL_BROADWELL      = 0x3d,
 373     CPU_MODEL_SKYLAKE        = 0x55
 374   };
 375 
 376   // cpuid information block.  All info derived from executing cpuid with
 377   // various function numbers is stored here.  Intel and AMD info is
 378   // merged in this block: accessor methods disentangle it.
 379   //
 380   // The info block is laid out in subblocks of 4 dwords corresponding to
 381   // eax, ebx, ecx and edx, whether or not they contain anything useful.
 382   struct CpuidInfo {
 383     // cpuid function 0
 384     uint32_t std_max_function;
 385     uint32_t std_vendor_name_0;
 386     uint32_t std_vendor_name_1;
 387     uint32_t std_vendor_name_2;
 388 
 389     // cpuid function 1
 390     StdCpuid1Eax std_cpuid1_eax;
 391     StdCpuid1Ebx std_cpuid1_ebx;
 392     StdCpuid1Ecx std_cpuid1_ecx;
 393     StdCpuid1Edx std_cpuid1_edx;
 394 
 395     // cpuid function 4 (deterministic cache parameters)
 396     DcpCpuid4Eax dcp_cpuid4_eax;
 397     DcpCpuid4Ebx dcp_cpuid4_ebx;
 398     uint32_t     dcp_cpuid4_ecx; // unused currently
 399     uint32_t     dcp_cpuid4_edx; // unused currently
 400 
 401     // cpuid function 7 (structured extended features)
 402     SefCpuid7Eax sef_cpuid7_eax;
 403     SefCpuid7Ebx sef_cpuid7_ebx;
 404     SefCpuid7Ecx sef_cpuid7_ecx;
 405     SefCpuid7Edx sef_cpuid7_edx;
 406 
 407     // cpuid function 0xB (processor topology)
 408     // ecx = 0
 409     uint32_t     tpl_cpuidB0_eax;
 410     TplCpuidBEbx tpl_cpuidB0_ebx;
 411     uint32_t     tpl_cpuidB0_ecx; // unused currently
 412     uint32_t     tpl_cpuidB0_edx; // unused currently
 413 
 414     // ecx = 1
 415     uint32_t     tpl_cpuidB1_eax;
 416     TplCpuidBEbx tpl_cpuidB1_ebx;
 417     uint32_t     tpl_cpuidB1_ecx; // unused currently
 418     uint32_t     tpl_cpuidB1_edx; // unused currently
 419 
 420     // ecx = 2
 421     uint32_t     tpl_cpuidB2_eax;
 422     TplCpuidBEbx tpl_cpuidB2_ebx;
 423     uint32_t     tpl_cpuidB2_ecx; // unused currently
 424     uint32_t     tpl_cpuidB2_edx; // unused currently
 425 
 426     // cpuid function 0x80000000 // example, unused
 427     uint32_t ext_max_function;
 428     uint32_t ext_vendor_name_0;
 429     uint32_t ext_vendor_name_1;
 430     uint32_t ext_vendor_name_2;
 431 
 432     // cpuid function 0x80000001
 433     uint32_t     ext_cpuid1_eax; // reserved
 434     uint32_t     ext_cpuid1_ebx; // reserved
 435     ExtCpuid1Ecx ext_cpuid1_ecx;
 436     ExtCpuid1Edx ext_cpuid1_edx;
 437 
 438     // cpuid functions 0x80000002 thru 0x80000004: example, unused
 439     uint32_t proc_name_0, proc_name_1, proc_name_2, proc_name_3;
 440     uint32_t proc_name_4, proc_name_5, proc_name_6, proc_name_7;
 441     uint32_t proc_name_8, proc_name_9, proc_name_10,proc_name_11;
 442 
 443     // cpuid function 0x80000005 // AMD L1, Intel reserved
 444     uint32_t     ext_cpuid5_eax; // unused currently
 445     uint32_t     ext_cpuid5_ebx; // reserved
 446     ExtCpuid5Ex  ext_cpuid5_ecx; // L1 data cache info (AMD)
 447     ExtCpuid5Ex  ext_cpuid5_edx; // L1 instruction cache info (AMD)
 448 
 449     // cpuid function 0x80000007
 450     uint32_t     ext_cpuid7_eax; // reserved
 451     uint32_t     ext_cpuid7_ebx; // reserved
 452     uint32_t     ext_cpuid7_ecx; // reserved
 453     ExtCpuid7Edx ext_cpuid7_edx; // tscinv
 454 
 455     // cpuid function 0x80000008
 456     uint32_t     ext_cpuid8_eax; // unused currently
 457     uint32_t     ext_cpuid8_ebx; // reserved
 458     ExtCpuid8Ecx ext_cpuid8_ecx;
 459     uint32_t     ext_cpuid8_edx; // reserved
 460 
 461     // cpuid function 0x8000001E // AMD 17h
 462     uint32_t      ext_cpuid1E_eax;
 463     ExtCpuid1EEbx ext_cpuid1E_ebx; // threads per core (AMD17h)
 464     uint32_t      ext_cpuid1E_ecx;
 465     uint32_t      ext_cpuid1E_edx; // unused currently
 466 
 467     // extended control register XCR0 (the XFEATURE_ENABLED_MASK register)
 468     XemXcr0Eax   xem_xcr0_eax;
 469     uint32_t     xem_xcr0_edx; // reserved
 470 
 471     // Space to save ymm registers after signal handle
 472     int          ymm_save[8*4]; // Save ymm0, ymm7, ymm8, ymm15
 473 
 474     // Space to save zmm registers after signal handle
 475     int          zmm_save[16*4]; // Save zmm0, zmm7, zmm8, zmm31
 476   };
 477 
 478   // The actual cpuid info block
 479   static CpuidInfo _cpuid_info;
 480 
 481   // Extractors and predicates
 482   static uint32_t extended_cpu_family() {
 483     uint32_t result = _cpuid_info.std_cpuid1_eax.bits.family;
 484     result += _cpuid_info.std_cpuid1_eax.bits.ext_family;
 485     return result;
 486   }
 487 
 488   static uint32_t extended_cpu_model() {
 489     uint32_t result = _cpuid_info.std_cpuid1_eax.bits.model;
 490     result |= _cpuid_info.std_cpuid1_eax.bits.ext_model &lt;&lt; 4;
 491     return result;
 492   }
 493 
 494   static uint32_t cpu_stepping() {
 495     uint32_t result = _cpuid_info.std_cpuid1_eax.bits.stepping;
 496     return result;
 497   }
 498 
 499   static uint logical_processor_count() {
 500     uint result = threads_per_core();
 501     return result;
 502   }
 503 
 504   static bool compute_has_intel_jcc_erratum();
 505 
 506   static uint64_t feature_flags() {
 507     uint64_t result = 0;
 508     if (_cpuid_info.std_cpuid1_edx.bits.cmpxchg8 != 0)
 509       result |= CPU_CX8;
 510     if (_cpuid_info.std_cpuid1_edx.bits.cmov != 0)
 511       result |= CPU_CMOV;
 512     if (_cpuid_info.std_cpuid1_edx.bits.clflush != 0)
 513       result |= CPU_FLUSH;
 514 #ifdef _LP64
 515     // clflush should always be available on x86_64
 516     // if not we are in real trouble because we rely on it
 517     // to flush the code cache.
 518     assert ((result &amp; CPU_FLUSH) != 0, &quot;clflush should be available&quot;);
 519 #endif
 520     if (_cpuid_info.std_cpuid1_edx.bits.fxsr != 0 || (is_amd_family() &amp;&amp;
 521         _cpuid_info.ext_cpuid1_edx.bits.fxsr != 0))
 522       result |= CPU_FXSR;
 523     // HT flag is set for multi-core processors also.
 524     if (threads_per_core() &gt; 1)
 525       result |= CPU_HT;
 526     if (_cpuid_info.std_cpuid1_edx.bits.mmx != 0 || (is_amd_family() &amp;&amp;
 527         _cpuid_info.ext_cpuid1_edx.bits.mmx != 0))
 528       result |= CPU_MMX;
 529     if (_cpuid_info.std_cpuid1_edx.bits.sse != 0)
 530       result |= CPU_SSE;
 531     if (_cpuid_info.std_cpuid1_edx.bits.sse2 != 0)
 532       result |= CPU_SSE2;
 533     if (_cpuid_info.std_cpuid1_ecx.bits.sse3 != 0)
 534       result |= CPU_SSE3;
 535     if (_cpuid_info.std_cpuid1_ecx.bits.ssse3 != 0)
 536       result |= CPU_SSSE3;
 537     if (_cpuid_info.std_cpuid1_ecx.bits.sse4_1 != 0)
 538       result |= CPU_SSE4_1;
 539     if (_cpuid_info.std_cpuid1_ecx.bits.sse4_2 != 0)
 540       result |= CPU_SSE4_2;
 541     if (_cpuid_info.std_cpuid1_ecx.bits.popcnt != 0)
 542       result |= CPU_POPCNT;
 543     if (_cpuid_info.std_cpuid1_ecx.bits.avx != 0 &amp;&amp;
 544         _cpuid_info.std_cpuid1_ecx.bits.osxsave != 0 &amp;&amp;
 545         _cpuid_info.xem_xcr0_eax.bits.sse != 0 &amp;&amp;
 546         _cpuid_info.xem_xcr0_eax.bits.ymm != 0) {
 547       result |= CPU_AVX;
 548       result |= CPU_VZEROUPPER;
 549       if (_cpuid_info.sef_cpuid7_ebx.bits.avx2 != 0)
 550         result |= CPU_AVX2;
 551       if (_cpuid_info.sef_cpuid7_ebx.bits.avx512f != 0 &amp;&amp;
 552           _cpuid_info.xem_xcr0_eax.bits.opmask != 0 &amp;&amp;
 553           _cpuid_info.xem_xcr0_eax.bits.zmm512 != 0 &amp;&amp;
 554           _cpuid_info.xem_xcr0_eax.bits.zmm32 != 0) {
 555         result |= CPU_AVX512F;
 556         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512cd != 0)
 557           result |= CPU_AVX512CD;
 558         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512dq != 0)
 559           result |= CPU_AVX512DQ;
 560         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512pf != 0)
 561           result |= CPU_AVX512PF;
 562         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512er != 0)
 563           result |= CPU_AVX512ER;
 564         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512bw != 0)
 565           result |= CPU_AVX512BW;
 566         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512vl != 0)
 567           result |= CPU_AVX512VL;
 568         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vpopcntdq != 0)
 569           result |= CPU_AVX512_VPOPCNTDQ;
 570         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vpclmulqdq != 0)
 571           result |= CPU_AVX512_VPCLMULQDQ;
 572         if (_cpuid_info.sef_cpuid7_ecx.bits.vaes != 0)
<a name="4" id="anc4"></a><span class="line-modified"> 573           result |= CPU_VAES;</span>
 574         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vnni != 0)
<a name="5" id="anc5"></a><span class="line-modified"> 575           result |= CPU_VNNI;</span>
 576         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vbmi2 != 0)
<a name="6" id="anc6"></a><span class="line-modified"> 577           result |= CPU_VBMI2;</span>
 578       }
 579     }
 580     if (_cpuid_info.sef_cpuid7_ebx.bits.bmi1 != 0)
 581       result |= CPU_BMI1;
 582     if (_cpuid_info.std_cpuid1_edx.bits.tsc != 0)
 583       result |= CPU_TSC;
 584     if (_cpuid_info.ext_cpuid7_edx.bits.tsc_invariance != 0)
 585       result |= CPU_TSCINV;
 586     if (_cpuid_info.std_cpuid1_ecx.bits.aes != 0)
 587       result |= CPU_AES;
 588     if (_cpuid_info.sef_cpuid7_ebx.bits.erms != 0)
 589       result |= CPU_ERMS;
 590     if (_cpuid_info.std_cpuid1_ecx.bits.clmul != 0)
 591       result |= CPU_CLMUL;
 592     if (_cpuid_info.sef_cpuid7_ebx.bits.rtm != 0)
 593       result |= CPU_RTM;
 594     if (_cpuid_info.sef_cpuid7_ebx.bits.adx != 0)
 595        result |= CPU_ADX;
 596     if (_cpuid_info.sef_cpuid7_ebx.bits.bmi2 != 0)
 597       result |= CPU_BMI2;
 598     if (_cpuid_info.sef_cpuid7_ebx.bits.sha != 0)
 599       result |= CPU_SHA;
 600     if (_cpuid_info.std_cpuid1_ecx.bits.fma != 0)
 601       result |= CPU_FMA;
 602     if (_cpuid_info.sef_cpuid7_ebx.bits.clflushopt != 0)
 603       result |= CPU_FLUSHOPT;
 604 
 605     // AMD|Hygon features.
 606     if (is_amd_family()) {
 607       if ((_cpuid_info.ext_cpuid1_edx.bits.tdnow != 0) ||
 608           (_cpuid_info.ext_cpuid1_ecx.bits.prefetchw != 0))
 609         result |= CPU_3DNOW_PREFETCH;
 610       if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt != 0)
 611         result |= CPU_LZCNT;
 612       if (_cpuid_info.ext_cpuid1_ecx.bits.sse4a != 0)
 613         result |= CPU_SSE4A;
 614     }
 615     // Intel features.
 616     if (is_intel()) {
 617       if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)
 618         result |= CPU_LZCNT;
 619       // for Intel, ecx.bits.misalignsse bit (bit 8) indicates support for prefetchw
 620       if (_cpuid_info.ext_cpuid1_ecx.bits.misalignsse != 0) {
 621         result |= CPU_3DNOW_PREFETCH;
 622       }
 623       if (_cpuid_info.sef_cpuid7_ebx.bits.clwb != 0) {
 624         result |= CPU_CLWB;
 625       }
 626     }
 627 
 628     // ZX features.
 629     if (is_zx()) {
 630       if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)
 631         result |= CPU_LZCNT;
 632       // for ZX, ecx.bits.misalignsse bit (bit 8) indicates support for prefetchw
 633       if (_cpuid_info.ext_cpuid1_ecx.bits.misalignsse != 0) {
 634         result |= CPU_3DNOW_PREFETCH;
 635       }
 636     }
 637 
 638     return result;
 639   }
 640 
 641   static bool os_supports_avx_vectors() {
 642     bool retVal = false;
 643     int nreg = 2 LP64_ONLY(+2);
 644     if (supports_evex()) {
 645       // Verify that OS save/restore all bits of EVEX registers
 646       // during signal processing.
 647       retVal = true;
 648       for (int i = 0; i &lt; 16 * nreg; i++) { // 64 bytes per zmm register
 649         if (_cpuid_info.zmm_save[i] != ymm_test_value()) {
 650           retVal = false;
 651           break;
 652         }
 653       }
 654     } else if (supports_avx()) {
 655       // Verify that OS save/restore all bits of AVX registers
 656       // during signal processing.
 657       retVal = true;
 658       for (int i = 0; i &lt; 8 * nreg; i++) { // 32 bytes per ymm register
 659         if (_cpuid_info.ymm_save[i] != ymm_test_value()) {
 660           retVal = false;
 661           break;
 662         }
 663       }
 664       // zmm_save will be set on a EVEX enabled machine even if we choose AVX code gen
 665       if (retVal == false) {
 666         // Verify that OS save/restore all bits of EVEX registers
 667         // during signal processing.
 668         retVal = true;
 669         for (int i = 0; i &lt; 16 * nreg; i++) { // 64 bytes per zmm register
 670           if (_cpuid_info.zmm_save[i] != ymm_test_value()) {
 671             retVal = false;
 672             break;
 673           }
 674         }
 675       }
 676     }
 677     return retVal;
 678   }
 679 
 680   static void get_processor_features();
 681 
 682 public:
 683   // Offsets for cpuid asm stub
 684   static ByteSize std_cpuid0_offset() { return byte_offset_of(CpuidInfo, std_max_function); }
 685   static ByteSize std_cpuid1_offset() { return byte_offset_of(CpuidInfo, std_cpuid1_eax); }
 686   static ByteSize dcp_cpuid4_offset() { return byte_offset_of(CpuidInfo, dcp_cpuid4_eax); }
 687   static ByteSize sef_cpuid7_offset() { return byte_offset_of(CpuidInfo, sef_cpuid7_eax); }
 688   static ByteSize ext_cpuid1_offset() { return byte_offset_of(CpuidInfo, ext_cpuid1_eax); }
 689   static ByteSize ext_cpuid5_offset() { return byte_offset_of(CpuidInfo, ext_cpuid5_eax); }
 690   static ByteSize ext_cpuid7_offset() { return byte_offset_of(CpuidInfo, ext_cpuid7_eax); }
 691   static ByteSize ext_cpuid8_offset() { return byte_offset_of(CpuidInfo, ext_cpuid8_eax); }
 692   static ByteSize ext_cpuid1E_offset() { return byte_offset_of(CpuidInfo, ext_cpuid1E_eax); }
 693   static ByteSize tpl_cpuidB0_offset() { return byte_offset_of(CpuidInfo, tpl_cpuidB0_eax); }
 694   static ByteSize tpl_cpuidB1_offset() { return byte_offset_of(CpuidInfo, tpl_cpuidB1_eax); }
 695   static ByteSize tpl_cpuidB2_offset() { return byte_offset_of(CpuidInfo, tpl_cpuidB2_eax); }
 696   static ByteSize xem_xcr0_offset() { return byte_offset_of(CpuidInfo, xem_xcr0_eax); }
 697   static ByteSize ymm_save_offset() { return byte_offset_of(CpuidInfo, ymm_save); }
 698   static ByteSize zmm_save_offset() { return byte_offset_of(CpuidInfo, zmm_save); }
 699 
 700   // The value used to check ymm register after signal handle
 701   static int ymm_test_value()    { return 0xCAFEBABE; }
 702 
 703   static void get_cpu_info_wrapper();
 704   static void set_cpuinfo_segv_addr(address pc) { _cpuinfo_segv_addr = pc; }
 705   static bool  is_cpuinfo_segv_addr(address pc) { return _cpuinfo_segv_addr == pc; }
 706   static void set_cpuinfo_cont_addr(address pc) { _cpuinfo_cont_addr = pc; }
 707   static address  cpuinfo_cont_addr()           { return _cpuinfo_cont_addr; }
 708 
 709   static void clean_cpuFeatures()   { _features = 0; }
 710   static void set_avx_cpuFeatures() { _features = (CPU_SSE | CPU_SSE2 | CPU_AVX | CPU_VZEROUPPER ); }
 711   static void set_evex_cpuFeatures() { _features = (CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }
 712 
 713 
 714   // Initialization
 715   static void initialize();
 716 
 717   // Override Abstract_VM_Version implementation
 718   static void print_platform_virtualization_info(outputStream*);
 719 
 720   // Override Abstract_VM_Version implementation
 721   static bool use_biased_locking();
 722 
 723   // Asserts
 724   static void assert_is_initialized() {
 725     assert(_cpuid_info.std_cpuid1_eax.bits.family != 0, &quot;VM_Version not initialized&quot;);
 726   }
 727 
 728   //
 729   // Processor family:
 730   //       3   -  386
 731   //       4   -  486
 732   //       5   -  Pentium
 733   //       6   -  PentiumPro, Pentium II, Celeron, Xeon, Pentium III, Athlon,
 734   //              Pentium M, Core Solo, Core Duo, Core2 Duo
 735   //    family 6 model:   9,        13,       14,        15
 736   //    0x0f   -  Pentium 4, Opteron
 737   //
 738   // Note: The cpu family should be used to select between
 739   //       instruction sequences which are valid on all Intel
 740   //       processors.  Use the feature test functions below to
 741   //       determine whether a particular instruction is supported.
 742   //
 743   static int  cpu_family()        { return _cpu;}
 744   static bool is_P6()             { return cpu_family() &gt;= 6; }
 745   static bool is_amd()            { assert_is_initialized(); return _cpuid_info.std_vendor_name_0 == 0x68747541; } // &#39;htuA&#39;
 746   static bool is_hygon()          { assert_is_initialized(); return _cpuid_info.std_vendor_name_0 == 0x6F677948; } // &#39;ogyH&#39;
 747   static bool is_amd_family()     { return is_amd() || is_hygon(); }
 748   static bool is_intel()          { assert_is_initialized(); return _cpuid_info.std_vendor_name_0 == 0x756e6547; } // &#39;uneG&#39;
 749   static bool is_zx()             { assert_is_initialized(); return (_cpuid_info.std_vendor_name_0 == 0x746e6543) || (_cpuid_info.std_vendor_name_0 == 0x68532020); } // &#39;tneC&#39;||&#39;hS  &#39;
 750   static bool is_atom_family()    { return ((cpu_family() == 0x06) &amp;&amp; ((extended_cpu_model() == 0x36) || (extended_cpu_model() == 0x37) || (extended_cpu_model() == 0x4D))); } //Silvermont and Centerton
 751   static bool is_knights_family() { return ((cpu_family() == 0x06) &amp;&amp; ((extended_cpu_model() == 0x57) || (extended_cpu_model() == 0x85))); } // Xeon Phi 3200/5200/7200 and Future Xeon Phi
 752 
 753   static bool supports_processor_topology() {
 754     return (_cpuid_info.std_max_function &gt;= 0xB) &amp;&amp;
 755            // eax[4:0] | ebx[0:15] == 0 indicates invalid topology level.
 756            // Some cpus have max cpuid &gt;= 0xB but do not support processor topology.
 757            (((_cpuid_info.tpl_cpuidB0_eax &amp; 0x1f) | _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus) != 0);
 758   }
 759 
 760   static uint cores_per_cpu()  {
 761     uint result = 1;
 762     if (is_intel()) {
 763       bool supports_topology = supports_processor_topology();
 764       if (supports_topology) {
 765         result = _cpuid_info.tpl_cpuidB1_ebx.bits.logical_cpus /
 766                  _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 767       }
 768       if (!supports_topology || result == 0) {
 769         result = (_cpuid_info.dcp_cpuid4_eax.bits.cores_per_cpu + 1);
 770       }
 771     } else if (is_amd_family()) {
 772       result = (_cpuid_info.ext_cpuid8_ecx.bits.cores_per_cpu + 1);
 773     } else if (is_zx()) {
 774       bool supports_topology = supports_processor_topology();
 775       if (supports_topology) {
 776         result = _cpuid_info.tpl_cpuidB1_ebx.bits.logical_cpus /
 777                  _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 778       }
 779       if (!supports_topology || result == 0) {
 780         result = (_cpuid_info.dcp_cpuid4_eax.bits.cores_per_cpu + 1);
 781       }
 782     }
 783     return result;
 784   }
 785 
 786   static uint threads_per_core()  {
 787     uint result = 1;
 788     if (is_intel() &amp;&amp; supports_processor_topology()) {
 789       result = _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 790     } else if (is_zx() &amp;&amp; supports_processor_topology()) {
 791       result = _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 792     } else if (_cpuid_info.std_cpuid1_edx.bits.ht != 0) {
 793       if (cpu_family() &gt;= 0x17) {
 794         result = _cpuid_info.ext_cpuid1E_ebx.bits.threads_per_core + 1;
 795       } else {
 796         result = _cpuid_info.std_cpuid1_ebx.bits.threads_per_cpu /
 797                  cores_per_cpu();
 798       }
 799     }
 800     return (result == 0 ? 1 : result);
 801   }
 802 
 803   static intx L1_line_size()  {
 804     intx result = 0;
 805     if (is_intel()) {
 806       result = (_cpuid_info.dcp_cpuid4_ebx.bits.L1_line_size + 1);
 807     } else if (is_amd_family()) {
 808       result = _cpuid_info.ext_cpuid5_ecx.bits.L1_line_size;
 809     } else if (is_zx()) {
 810       result = (_cpuid_info.dcp_cpuid4_ebx.bits.L1_line_size + 1);
 811     }
 812     if (result &lt; 32) // not defined ?
 813       result = 32;   // 32 bytes by default on x86 and other x64
 814     return result;
 815   }
 816 
 817   static intx prefetch_data_size()  {
 818     return L1_line_size();
 819   }
 820 
 821   //
 822   // Feature identification
 823   //
 824   static bool supports_cpuid()    { return _features  != 0; }
 825   static bool supports_cmpxchg8() { return (_features &amp; CPU_CX8) != 0; }
 826   static bool supports_cmov()     { return (_features &amp; CPU_CMOV) != 0; }
 827   static bool supports_fxsr()     { return (_features &amp; CPU_FXSR) != 0; }
 828   static bool supports_ht()       { return (_features &amp; CPU_HT) != 0; }
 829   static bool supports_mmx()      { return (_features &amp; CPU_MMX) != 0; }
 830   static bool supports_sse()      { return (_features &amp; CPU_SSE) != 0; }
 831   static bool supports_sse2()     { return (_features &amp; CPU_SSE2) != 0; }
 832   static bool supports_sse3()     { return (_features &amp; CPU_SSE3) != 0; }
 833   static bool supports_ssse3()    { return (_features &amp; CPU_SSSE3)!= 0; }
 834   static bool supports_sse4_1()   { return (_features &amp; CPU_SSE4_1) != 0; }
 835   static bool supports_sse4_2()   { return (_features &amp; CPU_SSE4_2) != 0; }
 836   static bool supports_popcnt()   { return (_features &amp; CPU_POPCNT) != 0; }
 837   static bool supports_avx()      { return (_features &amp; CPU_AVX) != 0; }
 838   static bool supports_avx2()     { return (_features &amp; CPU_AVX2) != 0; }
 839   static bool supports_tsc()      { return (_features &amp; CPU_TSC)    != 0; }
 840   static bool supports_aes()      { return (_features &amp; CPU_AES) != 0; }
 841   static bool supports_erms()     { return (_features &amp; CPU_ERMS) != 0; }
 842   static bool supports_clmul()    { return (_features &amp; CPU_CLMUL) != 0; }
 843   static bool supports_rtm()      { return (_features &amp; CPU_RTM) != 0; }
 844   static bool supports_bmi1()     { return (_features &amp; CPU_BMI1) != 0; }
 845   static bool supports_bmi2()     { return (_features &amp; CPU_BMI2) != 0; }
 846   static bool supports_adx()      { return (_features &amp; CPU_ADX) != 0; }
 847   static bool supports_evex()     { return (_features &amp; CPU_AVX512F) != 0; }
 848   static bool supports_avx512dq() { return (_features &amp; CPU_AVX512DQ) != 0; }
 849   static bool supports_avx512pf() { return (_features &amp; CPU_AVX512PF) != 0; }
 850   static bool supports_avx512er() { return (_features &amp; CPU_AVX512ER) != 0; }
 851   static bool supports_avx512cd() { return (_features &amp; CPU_AVX512CD) != 0; }
 852   static bool supports_avx512bw() { return (_features &amp; CPU_AVX512BW) != 0; }
 853   static bool supports_avx512vl() { return (_features &amp; CPU_AVX512VL) != 0; }
 854   static bool supports_avx512vlbw() { return (supports_evex() &amp;&amp; supports_avx512bw() &amp;&amp; supports_avx512vl()); }
 855   static bool supports_avx512vldq() { return (supports_evex() &amp;&amp; supports_avx512dq() &amp;&amp; supports_avx512vl()); }
 856   static bool supports_avx512vlbwdq() { return (supports_evex() &amp;&amp; supports_avx512vl() &amp;&amp;
 857                                                 supports_avx512bw() &amp;&amp; supports_avx512dq()); }
 858   static bool supports_avx512novl() { return (supports_evex() &amp;&amp; !supports_avx512vl()); }
 859   static bool supports_avx512nobw() { return (supports_evex() &amp;&amp; !supports_avx512bw()); }
 860   static bool supports_avx256only() { return (supports_avx2() &amp;&amp; !supports_evex()); }
 861   static bool supports_avxonly()    { return ((supports_avx2() || supports_avx()) &amp;&amp; !supports_evex()); }
 862   static bool supports_sha()        { return (_features &amp; CPU_SHA) != 0; }
 863   static bool supports_fma()        { return (_features &amp; CPU_FMA) != 0 &amp;&amp; supports_avx(); }
 864   static bool supports_vzeroupper() { return (_features &amp; CPU_VZEROUPPER) != 0; }
<a name="7" id="anc7"></a><span class="line-modified"> 865   static bool supports_vpopcntdq()  { return (_features &amp; CPU_AVX512_VPOPCNTDQ) != 0; }</span>
 866   static bool supports_avx512_vpclmulqdq() { return (_features &amp; CPU_AVX512_VPCLMULQDQ) != 0; }
<a name="8" id="anc8"></a><span class="line-modified"> 867   static bool supports_vaes()       { return (_features &amp; CPU_VAES) != 0; }</span>
<span class="line-modified"> 868   static bool supports_vnni()       { return (_features &amp; CPU_VNNI) != 0; }</span>
<span class="line-modified"> 869   static bool supports_vbmi2()      { return (_features &amp; CPU_VBMI2) != 0; }</span>
 870 
 871   // Intel features
 872   static bool is_intel_family_core() { return is_intel() &amp;&amp;
 873                                        extended_cpu_family() == CPU_FAMILY_INTEL_CORE; }
 874 
 875   static bool is_intel_skylake() { return is_intel_family_core() &amp;&amp;
 876                                           extended_cpu_model() == CPU_MODEL_SKYLAKE; }
 877 
 878   static bool is_intel_tsc_synched_at_init()  {
 879     if (is_intel_family_core()) {
 880       uint32_t ext_model = extended_cpu_model();
 881       if (ext_model == CPU_MODEL_NEHALEM_EP     ||
 882           ext_model == CPU_MODEL_WESTMERE_EP    ||
 883           ext_model == CPU_MODEL_SANDYBRIDGE_EP ||
 884           ext_model == CPU_MODEL_IVYBRIDGE_EP) {
 885         // &lt;= 2-socket invariant tsc support. EX versions are usually used
 886         // in &gt; 2-socket systems and likely don&#39;t synchronize tscs at
 887         // initialization.
 888         // Code that uses tsc values must be prepared for them to arbitrarily
 889         // jump forward or backward.
 890         return true;
 891       }
 892     }
 893     return false;
 894   }
 895 
 896   // This checks if the JVM is potentially affected by an erratum on Intel CPUs (SKX102)
 897   // that causes unpredictable behaviour when jcc crosses 64 byte boundaries. Its microcode
 898   // mitigation causes regressions when jumps or fused conditional branches cross or end at
 899   // 32 byte boundaries.
 900   static bool has_intel_jcc_erratum() { return _has_intel_jcc_erratum; }
 901 
 902   // AMD features
 903   static bool supports_3dnow_prefetch()    { return (_features &amp; CPU_3DNOW_PREFETCH) != 0; }
 904   static bool supports_mmx_ext()  { return is_amd_family() &amp;&amp; _cpuid_info.ext_cpuid1_edx.bits.mmx_amd != 0; }
 905   static bool supports_lzcnt()    { return (_features &amp; CPU_LZCNT) != 0; }
 906   static bool supports_sse4a()    { return (_features &amp; CPU_SSE4A) != 0; }
 907 
 908   static bool is_amd_Barcelona()  { return is_amd() &amp;&amp;
 909                                            extended_cpu_family() == CPU_FAMILY_AMD_11H; }
 910 
 911   // Intel and AMD newer cores support fast timestamps well
 912   static bool supports_tscinv_bit() {
 913     return (_features &amp; CPU_TSCINV) != 0;
 914   }
 915   static bool supports_tscinv() {
 916     return supports_tscinv_bit() &amp;&amp;
 917       ((is_amd_family() &amp;&amp; !is_amd_Barcelona()) ||
 918         is_intel_tsc_synched_at_init());
 919   }
 920 
 921   // Intel Core and newer cpus have fast IDIV instruction (excluding Atom).
 922   static bool has_fast_idiv()     { return is_intel() &amp;&amp; cpu_family() == 6 &amp;&amp;
 923                                            supports_sse3() &amp;&amp; _model != 0x1C; }
 924 
 925   static bool supports_compare_and_exchange() { return true; }
 926 
 927   static intx allocate_prefetch_distance(bool use_watermark_prefetch) {
 928     // Hardware prefetching (distance/size in bytes):
 929     // Pentium 3 -  64 /  32
 930     // Pentium 4 - 256 / 128
 931     // Athlon    -  64 /  32 ????
 932     // Opteron   - 128 /  64 only when 2 sequential cache lines accessed
 933     // Core      - 128 /  64
 934     //
 935     // Software prefetching (distance in bytes / instruction with best score):
 936     // Pentium 3 - 128 / prefetchnta
 937     // Pentium 4 - 512 / prefetchnta
 938     // Athlon    - 128 / prefetchnta
 939     // Opteron   - 256 / prefetchnta
 940     // Core      - 256 / prefetchnta
 941     // It will be used only when AllocatePrefetchStyle &gt; 0
 942 
 943     if (is_amd_family()) { // AMD | Hygon
 944       if (supports_sse2()) {
 945         return 256; // Opteron
 946       } else {
 947         return 128; // Athlon
 948       }
 949     } else { // Intel
 950       if (supports_sse3() &amp;&amp; cpu_family() == 6) {
 951         if (supports_sse4_2() &amp;&amp; supports_ht()) { // Nehalem based cpus
 952           return 192;
 953         } else if (use_watermark_prefetch) { // watermark prefetching on Core
 954 #ifdef _LP64
 955           return 384;
 956 #else
 957           return 320;
 958 #endif
 959         }
 960       }
 961       if (supports_sse2()) {
 962         if (cpu_family() == 6) {
 963           return 256; // Pentium M, Core, Core2
 964         } else {
 965           return 512; // Pentium 4
 966         }
 967       } else {
 968         return 128; // Pentium 3 (and all other old CPUs)
 969       }
 970     }
 971   }
 972 
 973   // SSE2 and later processors implement a &#39;pause&#39; instruction
 974   // that can be used for efficient implementation of
 975   // the intrinsic for java.lang.Thread.onSpinWait()
 976   static bool supports_on_spin_wait() { return supports_sse2(); }
 977 
 978   // x86_64 supports fast class initialization checks for static methods.
 979   static bool supports_fast_class_init_checks() {
 980     return LP64_ONLY(true) NOT_LP64(false); // not implemented on x86_32
 981   }
 982 
 983   // there are several insns to force cache line sync to memory which
 984   // we can use to ensure mapped non-volatile memory is up to date with
 985   // pending in-cache changes.
 986   //
 987   // 64 bit cpus always support clflush which writes back and evicts
 988   // on 32 bit cpus support is recorded via a feature flag
 989   //
 990   // clflushopt is optional and acts like clflush except it does
 991   // not synchronize with other memory ops. it needs a preceding
 992   // and trailing StoreStore fence
 993   //
 994   // clwb is an optional, intel-specific instruction optional which
 995   // writes back without evicting the line. it also does not
 996   // synchronize with other memory ops. so, it also needs a preceding
 997   // and trailing StoreStore fence.
 998 
 999 #ifdef _LP64
1000   static bool supports_clflush() {
1001     // clflush should always be available on x86_64
1002     // if not we are in real trouble because we rely on it
1003     // to flush the code cache.
1004     // Unfortunately, Assembler::clflush is currently called as part
1005     // of generation of the code cache flush routine. This happens
1006     // under Universe::init before the processor features are set
1007     // up. Assembler::flush calls this routine to check that clflush
1008     // is allowed. So, we give the caller a free pass if Universe init
1009     // is still in progress.
1010     assert ((!Universe::is_fully_initialized() || (_features &amp; CPU_FLUSH) != 0), &quot;clflush should be available&quot;);
1011     return true;
1012   }
1013   static bool supports_clflushopt() { return ((_features &amp; CPU_FLUSHOPT) != 0); }
1014   static bool supports_clwb() { return ((_features &amp; CPU_CLWB) != 0); }
1015 #else
1016   static bool supports_clflush() { return  ((_features &amp; CPU_FLUSH) != 0); }
1017   static bool supports_clflushopt() { return false; }
1018   static bool supports_clwb() { return false; }
1019 #endif // _LP64
1020 
1021   // support functions for virtualization detection
1022  private:
1023   static void check_virt_cpuid(uint32_t idx, uint32_t *regs);
1024   static void check_virtualizations();
1025 };
1026 
1027 #endif // CPU_X86_VM_VERSION_X86_HPP
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
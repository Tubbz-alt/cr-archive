<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/assembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../sparc/vm_version_sparc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_x86.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/assembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1326,11 ***</span>
    emit_int8((unsigned char)0xDE);
    emit_int8(0xC0 | encode);
  }
  
  void Assembler::vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vaes(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8((unsigned char)0xDE);
    emit_int8((unsigned char)(0xC0 | encode));
<span class="line-new-header">--- 1326,11 ---</span>
    emit_int8((unsigned char)0xDE);
    emit_int8(0xC0 | encode);
  }
  
  void Assembler::vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vaes(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8((unsigned char)0xDE);
    emit_int8((unsigned char)(0xC0 | encode));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1353,11 ***</span>
    emit_int8((unsigned char)0xDF);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
  void Assembler::vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vaes(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8((unsigned char)0xDF);
    emit_int8((unsigned char)(0xC0 | encode));
<span class="line-new-header">--- 1353,11 ---</span>
    emit_int8((unsigned char)0xDF);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
  void Assembler::vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vaes(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8((unsigned char)0xDF);
    emit_int8((unsigned char)(0xC0 | encode));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1379,11 ***</span>
    emit_int8((unsigned char)0xDC);
    emit_int8(0xC0 | encode);
  }
  
  void Assembler::vaesenc(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vaes(), &quot;requires vaes support/enabling&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8((unsigned char)0xDC);
    emit_int8((unsigned char)(0xC0 | encode));
<span class="line-new-header">--- 1379,11 ---</span>
    emit_int8((unsigned char)0xDC);
    emit_int8(0xC0 | encode);
  }
  
  void Assembler::vaesenc(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vaes(), &quot;requires vaes support/enabling&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8((unsigned char)0xDC);
    emit_int8((unsigned char)(0xC0 | encode));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1405,11 ***</span>
    emit_int8((unsigned char)0xDD);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
  void Assembler::vaesenclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vaes(), &quot;requires vaes support/enabling&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8((unsigned char)0xDD);
    emit_int8((unsigned char)(0xC0 | encode));
<span class="line-new-header">--- 1405,11 ---</span>
    emit_int8((unsigned char)0xDD);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
  void Assembler::vaesenclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vaes(), &quot;requires vaes support/enabling&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8((unsigned char)0xDD);
    emit_int8((unsigned char)(0xC0 | encode));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4101,11 ***</span>
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
  void Assembler::evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
<span class="line-modified">!   assert(VM_Version::supports_vnni(), &quot;must support vnni&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x52);
    emit_int8((unsigned char)(0xC0 | encode));
<span class="line-new-header">--- 4101,11 ---</span>
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
  void Assembler::evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
<span class="line-modified">!   assert(VM_Version::supports_avx512_vnni(), &quot;must support vnni&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x52);
    emit_int8((unsigned char)(0xC0 | encode));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4135,11 ***</span>
    emit_int8((unsigned char)0xB8);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
  void Assembler::vpopcntd(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vpopcntdq(), &quot;must support vpopcntdq feature&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x55);
    emit_int8((unsigned char)(0xC0 | encode));
<span class="line-new-header">--- 4135,11 ---</span>
    emit_int8((unsigned char)0xB8);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
  void Assembler::vpopcntd(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vpopcntdq(), &quot;must support vpopcntdq feature&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x55);
    emit_int8((unsigned char)(0xC0 | encode));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6542,20 ***</span>
    emit_int8((unsigned char)0xDB);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
  void Assembler::vpshldvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vbmi2(), &quot;requires vbmi2&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x71);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
  void Assembler::vpshrdvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vbmi2(), &quot;requires vbmi2&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x73);
    emit_int8((unsigned char)(0xC0 | encode));
<span class="line-new-header">--- 6542,20 ---</span>
    emit_int8((unsigned char)0xDB);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
  void Assembler::vpshldvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vbmi2(), &quot;requires vbmi2&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x71);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
  void Assembler::vpshrdvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vbmi2(), &quot;requires vbmi2&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x73);
    emit_int8((unsigned char)(0xC0 | encode));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7158,11 ***</span>
  
  // scalar single/double precision replicate
  
  // duplicate single precision data from src into programmed locations in dest : requires AVX512VL
  void Assembler::vbroadcastss(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x18);
    emit_int8((unsigned char)(0xC0 | encode));
  }
<span class="line-new-header">--- 7158,11 ---</span>
  
  // scalar single/double precision replicate
  
  // duplicate single precision data from src into programmed locations in dest : requires AVX512VL
  void Assembler::vbroadcastss(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx2(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x18);
    emit_int8((unsigned char)(0xC0 | encode));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7179,20 ***</span>
    emit_operand(dst, src);
  }
  
  // duplicate double precision data from src into programmed locations in dest : requires AVX512VL
  void Assembler::vbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x19);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
  void Assembler::vbroadcastsd(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
    attributes.set_rex_vex_w_reverted();
<span class="line-new-header">--- 7179,22 ---</span>
    emit_operand(dst, src);
  }
  
  // duplicate double precision data from src into programmed locations in dest : requires AVX512VL
  void Assembler::vbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx2(), &quot;&quot;);</span>
<span class="line-added">+   assert(vector_len == AVX_256bit || vector_len == AVX_512bit, &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x19);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
  void Assembler::vbroadcastsd(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
<span class="line-added">+   assert(vector_len == AVX_256bit || vector_len == AVX_512bit, &quot;&quot;);</span>
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
    attributes.set_rex_vex_w_reverted();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7286,21 ***</span>
    emit_int8(0x44);
    emit_int8((unsigned char)(0xC0 | encode));
    emit_int8((unsigned char)mask);
  }
  
<span class="line-modified">! void Assembler::vzeroupper() {</span>
    if (VM_Version::supports_vzeroupper()) {
      InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
      (void)vex_prefix_and_encode(0, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
      emit_int8(0x77);
    }
  }
  
  #ifndef _LP64
  // 32bit only pieces of the assembler
  
  void Assembler::cmp_literal32(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
    // NO PREFIX AS NEVER 64BIT
    InstructionMark im(this);
    emit_int8((unsigned char)0x81);
    emit_int8((unsigned char)(0xF8 | src1-&gt;encoding()));
<span class="line-new-header">--- 7288,25 ---</span>
    emit_int8(0x44);
    emit_int8((unsigned char)(0xC0 | encode));
    emit_int8((unsigned char)mask);
  }
  
<span class="line-modified">! void Assembler::vzeroupper_uncached() {</span>
    if (VM_Version::supports_vzeroupper()) {
      InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
      (void)vex_prefix_and_encode(0, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
      emit_int8(0x77);
    }
  }
  
  #ifndef _LP64
  // 32bit only pieces of the assembler
  
<span class="line-added">+ void Assembler::vzeroupper() {</span>
<span class="line-added">+   vzeroupper_uncached();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::cmp_literal32(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
    // NO PREFIX AS NEVER 64BIT
    InstructionMark im(this);
    emit_int8((unsigned char)0x81);
    emit_int8((unsigned char)(0xF8 | src1-&gt;encoding()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9246,31 ***</span>
  void Assembler::orq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    emit_arith(0x0B, 0xC0, dst, src);
  }
  
<span class="line-removed">- void Assembler::popa() { // 64bit</span>
<span class="line-removed">-   movq(r15, Address(rsp, 0));</span>
<span class="line-removed">-   movq(r14, Address(rsp, wordSize));</span>
<span class="line-removed">-   movq(r13, Address(rsp, 2 * wordSize));</span>
<span class="line-removed">-   movq(r12, Address(rsp, 3 * wordSize));</span>
<span class="line-removed">-   movq(r11, Address(rsp, 4 * wordSize));</span>
<span class="line-removed">-   movq(r10, Address(rsp, 5 * wordSize));</span>
<span class="line-removed">-   movq(r9,  Address(rsp, 6 * wordSize));</span>
<span class="line-removed">-   movq(r8,  Address(rsp, 7 * wordSize));</span>
<span class="line-removed">-   movq(rdi, Address(rsp, 8 * wordSize));</span>
<span class="line-removed">-   movq(rsi, Address(rsp, 9 * wordSize));</span>
<span class="line-removed">-   movq(rbp, Address(rsp, 10 * wordSize));</span>
<span class="line-removed">-   // skip rsp</span>
<span class="line-removed">-   movq(rbx, Address(rsp, 12 * wordSize));</span>
<span class="line-removed">-   movq(rdx, Address(rsp, 13 * wordSize));</span>
<span class="line-removed">-   movq(rcx, Address(rsp, 14 * wordSize));</span>
<span class="line-removed">-   movq(rax, Address(rsp, 15 * wordSize));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   addq(rsp, 16 * wordSize);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void Assembler::popcntq(Register dst, Address src) {
    assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
    InstructionMark im(this);
    emit_int8((unsigned char)0xF3);
    prefixq(src, dst);
<span class="line-new-header">--- 9252,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9293,11 ***</span>
<span class="line-new-header">--- 9278,107 ---</span>
    prefixq(dst);
    emit_int8((unsigned char)0x8F);
    emit_operand(rax, dst);
  }
  
<span class="line-added">+ // Precomputable: popa, pusha, vzeroupper</span>
<span class="line-added">+ </span>
<span class="line-added">+ // The result of these routines are invariant from one invocation to another</span>
<span class="line-added">+ // invocation for the duration of a run. Caching the result on bootstrap</span>
<span class="line-added">+ // and copying it out on subsequent invocations can thus be beneficial</span>
<span class="line-added">+ static bool     precomputed = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static u_char* popa_code  = NULL;</span>
<span class="line-added">+ static int     popa_len   = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static u_char* pusha_code = NULL;</span>
<span class="line-added">+ static int     pusha_len  = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static u_char* vzup_code  = NULL;</span>
<span class="line-added">+ static int     vzup_len   = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::precompute_instructions() {</span>
<span class="line-added">+   assert(!Universe::is_fully_initialized(), &quot;must still be single threaded&quot;);</span>
<span class="line-added">+   guarantee(!precomputed, &quot;only once&quot;);</span>
<span class="line-added">+   precomputed = true;</span>
<span class="line-added">+   ResourceMark rm;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Make a temporary buffer big enough for the routines we&#39;re capturing</span>
<span class="line-added">+   int size = 256;</span>
<span class="line-added">+   char* tmp_code = NEW_RESOURCE_ARRAY(char, size);</span>
<span class="line-added">+   CodeBuffer buffer((address)tmp_code, size);</span>
<span class="line-added">+   MacroAssembler masm(&amp;buffer);</span>
<span class="line-added">+ </span>
<span class="line-added">+   address begin_popa  = masm.code_section()-&gt;end();</span>
<span class="line-added">+   masm.popa_uncached();</span>
<span class="line-added">+   address end_popa    = masm.code_section()-&gt;end();</span>
<span class="line-added">+   masm.pusha_uncached();</span>
<span class="line-added">+   address end_pusha   = masm.code_section()-&gt;end();</span>
<span class="line-added">+   masm.vzeroupper_uncached();</span>
<span class="line-added">+   address end_vzup    = masm.code_section()-&gt;end();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Save the instructions to permanent buffers.</span>
<span class="line-added">+   popa_len = (int)(end_popa - begin_popa);</span>
<span class="line-added">+   popa_code = NEW_C_HEAP_ARRAY(u_char, popa_len, mtInternal);</span>
<span class="line-added">+   memcpy(popa_code, begin_popa, popa_len);</span>
<span class="line-added">+ </span>
<span class="line-added">+   pusha_len = (int)(end_pusha - end_popa);</span>
<span class="line-added">+   pusha_code = NEW_C_HEAP_ARRAY(u_char, pusha_len, mtInternal);</span>
<span class="line-added">+   memcpy(pusha_code, end_popa, pusha_len);</span>
<span class="line-added">+ </span>
<span class="line-added">+   vzup_len = (int)(end_vzup - end_pusha);</span>
<span class="line-added">+   if (vzup_len &gt; 0) {</span>
<span class="line-added">+     vzup_code = NEW_C_HEAP_ARRAY(u_char, vzup_len, mtInternal);</span>
<span class="line-added">+     memcpy(vzup_code, end_pusha, vzup_len);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     vzup_code = pusha_code; // dummy</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(masm.code()-&gt;total_oop_size() == 0 &amp;&amp;</span>
<span class="line-added">+          masm.code()-&gt;total_metadata_size() == 0 &amp;&amp;</span>
<span class="line-added">+          masm.code()-&gt;total_relocation_size() == 0,</span>
<span class="line-added">+          &quot;pre-computed code can&#39;t reference oops, metadata or contain relocations&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void emit_copy(CodeSection* code_section, u_char* src, int src_len) {</span>
<span class="line-added">+   assert(src != NULL, &quot;code to copy must have been pre-computed&quot;);</span>
<span class="line-added">+   assert(code_section-&gt;limit() - code_section-&gt;end() &gt; src_len, &quot;code buffer not large enough&quot;);</span>
<span class="line-added">+   address end = code_section-&gt;end();</span>
<span class="line-added">+   memcpy(end, src, src_len);</span>
<span class="line-added">+   code_section-&gt;set_end(end + src_len);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::popa() { // 64bit</span>
<span class="line-added">+   emit_copy(code_section(), popa_code, popa_len);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::popa_uncached() { // 64bit</span>
<span class="line-added">+   movq(r15, Address(rsp, 0));</span>
<span class="line-added">+   movq(r14, Address(rsp, wordSize));</span>
<span class="line-added">+   movq(r13, Address(rsp, 2 * wordSize));</span>
<span class="line-added">+   movq(r12, Address(rsp, 3 * wordSize));</span>
<span class="line-added">+   movq(r11, Address(rsp, 4 * wordSize));</span>
<span class="line-added">+   movq(r10, Address(rsp, 5 * wordSize));</span>
<span class="line-added">+   movq(r9,  Address(rsp, 6 * wordSize));</span>
<span class="line-added">+   movq(r8,  Address(rsp, 7 * wordSize));</span>
<span class="line-added">+   movq(rdi, Address(rsp, 8 * wordSize));</span>
<span class="line-added">+   movq(rsi, Address(rsp, 9 * wordSize));</span>
<span class="line-added">+   movq(rbp, Address(rsp, 10 * wordSize));</span>
<span class="line-added">+   // skip rsp</span>
<span class="line-added">+   movq(rbx, Address(rsp, 12 * wordSize));</span>
<span class="line-added">+   movq(rdx, Address(rsp, 13 * wordSize));</span>
<span class="line-added">+   movq(rcx, Address(rsp, 14 * wordSize));</span>
<span class="line-added">+   movq(rax, Address(rsp, 15 * wordSize));</span>
<span class="line-added">+ </span>
<span class="line-added">+   addq(rsp, 16 * wordSize);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::pusha() { // 64bit
<span class="line-added">+   emit_copy(code_section(), pusha_code, pusha_len);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::pusha_uncached() { // 64bit</span>
    // we have to store original rsp.  ABI says that 128 bytes
    // below rsp are local scratch.
    movq(Address(rsp, -5 * wordSize), rsp);
  
    subq(rsp, 16 * wordSize);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9318,10 ***</span>
<span class="line-new-header">--- 9399,14 ---</span>
    movq(Address(rsp, 2 * wordSize), r13);
    movq(Address(rsp, wordSize), r14);
    movq(Address(rsp, 0), r15);
  }
  
<span class="line-added">+ void Assembler::vzeroupper() {</span>
<span class="line-added">+   emit_copy(code_section(), vzup_code, vzup_len);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::pushq(Address src) {
    InstructionMark im(this);
    prefixq(src);
    emit_int8((unsigned char)0xFF);
    emit_operand(rsi, src);
</pre>
<center><a href="../sparc/vm_version_sparc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_x86.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
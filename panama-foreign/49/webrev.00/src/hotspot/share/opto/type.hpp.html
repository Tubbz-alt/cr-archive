<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/type.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_TYPE_HPP
  26 #define SHARE_OPTO_TYPE_HPP
  27 
  28 #include &quot;opto/adlcVMDeps.hpp&quot;
  29 #include &quot;runtime/handles.hpp&quot;
  30 
  31 // Portions of code courtesy of Clifford Click
  32 
  33 // Optimization - Graph Style
  34 
  35 
  36 // This class defines a Type lattice.  The lattice is used in the constant
  37 // propagation algorithms, and for some type-checking of the iloc code.
  38 // Basic types include RSD&#39;s (lower bound, upper bound, stride for integers),
  39 // float &amp; double precision constants, sets of data-labels and code-labels.
  40 // The complete lattice is described below.  Subtypes have no relationship to
  41 // up or down in the lattice; that is entirely determined by the behavior of
  42 // the MEET/JOIN functions.
  43 
  44 class Dict;
  45 class Type;
  46 class   TypeD;
  47 class   TypeF;
  48 class   TypeInt;
  49 class   TypeLong;
  50 class   TypeNarrowPtr;
  51 class     TypeNarrowOop;
  52 class     TypeNarrowKlass;
  53 class   TypeAry;
  54 class   TypeTuple;
  55 class   TypeVect;
  56 class     TypeVectS;
  57 class     TypeVectD;
  58 class     TypeVectX;
  59 class     TypeVectY;
  60 class     TypeVectZ;
  61 class   TypePtr;
  62 class     TypeRawPtr;
  63 class     TypeOopPtr;
  64 class       TypeInstPtr;
  65 class       TypeAryPtr;
  66 class     TypeKlassPtr;
  67 class     TypeMetadataPtr;
  68 
  69 //------------------------------Type-------------------------------------------
  70 // Basic Type object, represents a set of primitive Values.
  71 // Types are hash-cons&#39;d into a private class dictionary, so only one of each
  72 // different kind of Type exists.  Types are never modified after creation, so
  73 // all their interesting fields are constant.
  74 class Type {
  75   friend class VMStructs;
  76 
  77 public:
  78   enum TYPES {
  79     Bad=0,                      // Type check
  80     Control,                    // Control of code (not in lattice)
  81     Top,                        // Top of the lattice
  82     Int,                        // Integer range (lo-hi)
  83     Long,                       // Long integer range (lo-hi)
  84     Half,                       // Placeholder half of doubleword
  85     NarrowOop,                  // Compressed oop pointer
  86     NarrowKlass,                // Compressed klass pointer
  87 
  88     Tuple,                      // Method signature or object layout
  89     Array,                      // Array types
  90     VectorS,                    //  32bit Vector types
  91     VectorD,                    //  64bit Vector types
  92     VectorX,                    // 128bit Vector types
  93     VectorY,                    // 256bit Vector types
  94     VectorZ,                    // 512bit Vector types
  95 
  96     AnyPtr,                     // Any old raw, klass, inst, or array pointer
  97     RawPtr,                     // Raw (non-oop) pointers
  98     OopPtr,                     // Any and all Java heap entities
  99     InstPtr,                    // Instance pointers (non-array objects)
 100     AryPtr,                     // Array pointers
 101     // (Ptr order matters:  See is_ptr, isa_ptr, is_oopptr, isa_oopptr.)
 102 
 103     MetadataPtr,                // Generic metadata
 104     KlassPtr,                   // Klass pointers
 105 
 106     Function,                   // Function signature
 107     Abio,                       // Abstract I/O
 108     Return_Address,             // Subroutine return address
 109     Memory,                     // Abstract store
 110     FloatTop,                   // No float value
 111     FloatCon,                   // Floating point constant
 112     FloatBot,                   // Any float value
 113     DoubleTop,                  // No double value
 114     DoubleCon,                  // Double precision constant
 115     DoubleBot,                  // Any double value
 116     Bottom,                     // Bottom of lattice
 117     lastype                     // Bogus ending type (not in lattice)
 118   };
 119 
 120   // Signal values for offsets from a base pointer
 121   enum OFFSET_SIGNALS {
 122     OffsetTop = -2000000000,    // undefined offset
 123     OffsetBot = -2000000001     // any possible offset
 124   };
 125 
 126   // Min and max WIDEN values.
 127   enum WIDEN {
 128     WidenMin = 0,
 129     WidenMax = 3
 130   };
 131 
 132 private:
 133   typedef struct {
 134     TYPES                dual_type;
 135     BasicType            basic_type;
 136     const char*          msg;
 137     bool                 isa_oop;
 138     uint                 ideal_reg;
 139     relocInfo::relocType reloc;
 140   } TypeInfo;
 141 
 142   // Dictionary of types shared among compilations.
 143   static Dict* _shared_type_dict;
 144   static const TypeInfo _type_info[];
 145 
 146   static int uhash( const Type *const t );
 147   // Structural equality check.  Assumes that cmp() has already compared
 148   // the _base types and thus knows it can cast &#39;t&#39; appropriately.
 149   virtual bool eq( const Type *t ) const;
 150 
 151   // Top-level hash-table of types
 152   static Dict *type_dict() {
 153     return Compile::current()-&gt;type_dict();
 154   }
 155 
 156   // DUAL operation: reflect around lattice centerline.  Used instead of
 157   // join to ensure my lattice is symmetric up and down.  Dual is computed
 158   // lazily, on demand, and cached in _dual.
 159   const Type *_dual;            // Cached dual value
 160   // Table for efficient dualing of base types
 161   static const TYPES dual_type[lastype];
 162 
 163 #ifdef ASSERT
 164   // One type is interface, the other is oop
 165   virtual bool interface_vs_oop_helper(const Type *t) const;
 166 #endif
 167 
 168   const Type *meet_helper(const Type *t, bool include_speculative) const;
 169 
 170 protected:
 171   // Each class of type is also identified by its base.
 172   const TYPES _base;            // Enum of Types type
 173 
 174   Type( TYPES t ) : _dual(NULL),  _base(t) {} // Simple types
 175   // ~Type();                   // Use fast deallocation
 176   const Type *hashcons();       // Hash-cons the type
 177   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 178   const Type *join_helper(const Type *t, bool include_speculative) const {
 179     return dual()-&gt;meet_helper(t-&gt;dual(), include_speculative)-&gt;dual();
 180   }
 181 
 182 public:
 183 
 184   inline void* operator new( size_t x ) throw() {
 185     Compile* compile = Compile::current();
 186     compile-&gt;set_type_last_size(x);
 187     return compile-&gt;type_arena()-&gt;Amalloc_D(x);
 188   }
 189   inline void operator delete( void* ptr ) {
 190     Compile* compile = Compile::current();
 191     compile-&gt;type_arena()-&gt;Afree(ptr,compile-&gt;type_last_size());
 192   }
 193 
 194   // Initialize the type system for a particular compilation.
 195   static void Initialize(Compile* compile);
 196 
 197   // Initialize the types shared by all compilations.
 198   static void Initialize_shared(Compile* compile);
 199 
 200   TYPES base() const {
 201     assert(_base &gt; Bad &amp;&amp; _base &lt; lastype, &quot;sanity&quot;);
 202     return _base;
 203   }
 204 
 205   // Create a new hash-consd type
 206   static const Type *make(enum TYPES);
 207   // Test for equivalence of types
 208   static int cmp( const Type *const t1, const Type *const t2 );
 209   // Test for higher or equal in lattice
 210   // Variant that drops the speculative part of the types
 211   bool higher_equal(const Type *t) const {
 212     return !cmp(meet(t),t-&gt;remove_speculative());
 213   }
 214   // Variant that keeps the speculative part of the types
 215   bool higher_equal_speculative(const Type *t) const {
 216     return !cmp(meet_speculative(t),t);
 217   }
 218 
 219   // MEET operation; lower in lattice.
 220   // Variant that drops the speculative part of the types
 221   const Type *meet(const Type *t) const {
 222     return meet_helper(t, false);
 223   }
 224   // Variant that keeps the speculative part of the types
 225   const Type *meet_speculative(const Type *t) const {
 226     return meet_helper(t, true)-&gt;cleanup_speculative();
 227   }
 228   // WIDEN: &#39;widens&#39; for Ints and other range types
 229   virtual const Type *widen( const Type *old, const Type* limit ) const { return this; }
 230   // NARROW: complement for widen, used by pessimistic phases
 231   virtual const Type *narrow( const Type *old ) const { return this; }
 232 
 233   // DUAL operation: reflect around lattice centerline.  Used instead of
 234   // join to ensure my lattice is symmetric up and down.
 235   const Type *dual() const { return _dual; }
 236 
 237   // Compute meet dependent on base type
 238   virtual const Type *xmeet( const Type *t ) const;
 239   virtual const Type *xdual() const;    // Compute dual right now.
 240 
 241   // JOIN operation; higher in lattice.  Done by finding the dual of the
 242   // meet of the dual of the 2 inputs.
 243   // Variant that drops the speculative part of the types
 244   const Type *join(const Type *t) const {
 245     return join_helper(t, false);
 246   }
 247   // Variant that keeps the speculative part of the types
 248   const Type *join_speculative(const Type *t) const {
 249     return join_helper(t, true)-&gt;cleanup_speculative();
 250   }
 251 
 252   // Modified version of JOIN adapted to the needs Node::Value.
 253   // Normalizes all empty values to TOP.  Does not kill _widen bits.
 254   // Currently, it also works around limitations involving interface types.
 255   // Variant that drops the speculative part of the types
 256   const Type *filter(const Type *kills) const {
 257     return filter_helper(kills, false);
 258   }
 259   // Variant that keeps the speculative part of the types
 260   const Type *filter_speculative(const Type *kills) const {
 261     return filter_helper(kills, true)-&gt;cleanup_speculative();
 262   }
 263 
 264 #ifdef ASSERT
 265   // One type is interface, the other is oop
 266   virtual bool interface_vs_oop(const Type *t) const;
 267 #endif
 268 
 269   // Returns true if this pointer points at memory which contains a
 270   // compressed oop references.
 271   bool is_ptr_to_narrowoop() const;
 272   bool is_ptr_to_narrowklass() const;
 273 
 274   bool is_ptr_to_boxing_obj() const;
 275 
 276 
 277   // Convenience access
 278   float getf() const;
 279   double getd() const;
 280 
 281   const TypeInt    *is_int() const;
 282   const TypeInt    *isa_int() const;             // Returns NULL if not an Int
 283   const TypeLong   *is_long() const;
 284   const TypeLong   *isa_long() const;            // Returns NULL if not a Long
 285   const TypeD      *isa_double() const;          // Returns NULL if not a Double{Top,Con,Bot}
 286   const TypeD      *is_double_constant() const;  // Asserts it is a DoubleCon
 287   const TypeD      *isa_double_constant() const; // Returns NULL if not a DoubleCon
 288   const TypeF      *isa_float() const;           // Returns NULL if not a Float{Top,Con,Bot}
 289   const TypeF      *is_float_constant() const;   // Asserts it is a FloatCon
 290   const TypeF      *isa_float_constant() const;  // Returns NULL if not a FloatCon
 291   const TypeTuple  *is_tuple() const;            // Collection of fields, NOT a pointer
 292   const TypeAry    *is_ary() const;              // Array, NOT array pointer
 293   const TypeAry    *isa_ary() const;             // Returns NULL of not ary
 294   const TypeVect   *is_vect() const;             // Vector
 295   const TypeVect   *isa_vect() const;            // Returns NULL if not a Vector
 296   const TypePtr    *is_ptr() const;              // Asserts it is a ptr type
 297   const TypePtr    *isa_ptr() const;             // Returns NULL if not ptr type
 298   const TypeRawPtr *isa_rawptr() const;          // NOT Java oop
 299   const TypeRawPtr *is_rawptr() const;           // Asserts is rawptr
 300   const TypeNarrowOop  *is_narrowoop() const;    // Java-style GC&#39;d pointer
 301   const TypeNarrowOop  *isa_narrowoop() const;   // Returns NULL if not oop ptr type
 302   const TypeNarrowKlass *is_narrowklass() const; // compressed klass pointer
 303   const TypeNarrowKlass *isa_narrowklass() const;// Returns NULL if not oop ptr type
 304   const TypeOopPtr   *isa_oopptr() const;        // Returns NULL if not oop ptr type
 305   const TypeOopPtr   *is_oopptr() const;         // Java-style GC&#39;d pointer
 306   const TypeInstPtr  *isa_instptr() const;       // Returns NULL if not InstPtr
 307   const TypeInstPtr  *is_instptr() const;        // Instance
 308   const TypeAryPtr   *isa_aryptr() const;        // Returns NULL if not AryPtr
 309   const TypeAryPtr   *is_aryptr() const;         // Array oop
 310 
 311   const TypeMetadataPtr   *isa_metadataptr() const;   // Returns NULL if not oop ptr type
 312   const TypeMetadataPtr   *is_metadataptr() const;    // Java-style GC&#39;d pointer
 313   const TypeKlassPtr      *isa_klassptr() const;      // Returns NULL if not KlassPtr
 314   const TypeKlassPtr      *is_klassptr() const;       // assert if not KlassPtr
 315 
 316   virtual bool      is_finite() const;           // Has a finite value
 317   virtual bool      is_nan()    const;           // Is not a number (NaN)
 318 
 319   // Returns this ptr type or the equivalent ptr type for this compressed pointer.
 320   const TypePtr* make_ptr() const;
 321 
 322   // Returns this oopptr type or the equivalent oopptr type for this compressed pointer.
 323   // Asserts if the underlying type is not an oopptr or narrowoop.
 324   const TypeOopPtr* make_oopptr() const;
 325 
 326   // Returns this compressed pointer or the equivalent compressed version
 327   // of this pointer type.
 328   const TypeNarrowOop* make_narrowoop() const;
 329 
 330   // Returns this compressed klass pointer or the equivalent
 331   // compressed version of this pointer type.
 332   const TypeNarrowKlass* make_narrowklass() const;
 333 
 334   // Special test for register pressure heuristic
 335   bool is_floatingpoint() const;        // True if Float or Double base type
 336 
 337   // Do you have memory, directly or through a tuple?
 338   bool has_memory( ) const;
 339 
 340   // TRUE if type is a singleton
 341   virtual bool singleton(void) const;
 342 
 343   // TRUE if type is above the lattice centerline, and is therefore vacuous
 344   virtual bool empty(void) const;
 345 
 346   // Return a hash for this type.  The hash function is public so ConNode
 347   // (constants) can hash on their constant, which is represented by a Type.
 348   virtual int hash() const;
 349 
 350   // Map ideal registers (machine types) to ideal types
 351   static const Type *mreg2type[];
 352 
 353   // Printing, statistics
 354 #ifndef PRODUCT
 355   void         dump_on(outputStream *st) const;
 356   void         dump() const {
 357     dump_on(tty);
 358   }
 359   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 360   static  void dump_stats();
 361 
 362   static const char* str(const Type* t);
 363 #endif
 364   void typerr(const Type *t) const; // Mixing types error
 365 
 366   // Create basic type
 367   static const Type* get_const_basic_type(BasicType type) {
 368     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _const_basic_type[type] != NULL, &quot;bad type&quot;);
 369     return _const_basic_type[type];
 370   }
 371 
 372   // For two instance arrays of same dimension, return the base element types.
 373   // Otherwise or if the arrays have different dimensions, return NULL.
 374   static void get_arrays_base_elements(const Type *a1, const Type *a2,
 375                                        const TypeInstPtr **e1, const TypeInstPtr **e2);
 376 
 377   // Mapping to the array element&#39;s basic type.
 378   BasicType array_element_basic_type() const;
 379 
 380   // Create standard type for a ciType:
 381   static const Type* get_const_type(ciType* type);
 382 
 383   // Create standard zero value:
 384   static const Type* get_zero_type(BasicType type) {
 385     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _zero_type[type] != NULL, &quot;bad type&quot;);
 386     return _zero_type[type];
 387   }
 388 
 389   // Report if this is a zero value (not top).
 390   bool is_zero_type() const {
 391     BasicType type = basic_type();
 392     if (type == T_VOID || type &gt;= T_CONFLICT)
 393       return false;
 394     else
 395       return (this == _zero_type[type]);
 396   }
 397 
 398   // Convenience common pre-built types.
 399   static const Type *ABIO;
 400   static const Type *BOTTOM;
 401   static const Type *CONTROL;
 402   static const Type *DOUBLE;
 403   static const Type *FLOAT;
 404   static const Type *HALF;
 405   static const Type *MEMORY;
 406   static const Type *MULTI;
 407   static const Type *RETURN_ADDRESS;
 408   static const Type *TOP;
 409 
 410   // Mapping from compiler type to VM BasicType
 411   BasicType basic_type() const       { return _type_info[_base].basic_type; }
 412   uint ideal_reg() const             { return _type_info[_base].ideal_reg; }
 413   const char* msg() const            { return _type_info[_base].msg; }
 414   bool isa_oop_ptr() const           { return _type_info[_base].isa_oop; }
 415   relocInfo::relocType reloc() const { return _type_info[_base].reloc; }
 416 
 417   // Mapping from CI type system to compiler type:
 418   static const Type* get_typeflow_type(ciType* type);
 419 
 420   static const Type* make_from_constant(ciConstant constant,
 421                                         bool require_constant = false,
 422                                         int stable_dimension = 0,
 423                                         bool is_narrow = false,
 424                                         bool is_autobox_cache = false);
 425 
 426   static const Type* make_constant_from_field(ciInstance* holder,
 427                                               int off,
 428                                               bool is_unsigned_load,
 429                                               BasicType loadbt);
 430 
 431   static const Type* make_constant_from_field(ciField* field,
 432                                               ciInstance* holder,
 433                                               BasicType loadbt,
 434                                               bool is_unsigned_load);
 435 
 436   static const Type* make_constant_from_array_element(ciArray* array,
 437                                                       int off,
 438                                                       int stable_dimension,
 439                                                       BasicType loadbt,
 440                                                       bool is_unsigned_load);
 441 
 442   // Speculative type helper methods. See TypePtr.
 443   virtual const TypePtr* speculative() const                                  { return NULL; }
 444   virtual ciKlass* speculative_type() const                                   { return NULL; }
 445   virtual ciKlass* speculative_type_not_null() const                          { return NULL; }
 446   virtual bool speculative_maybe_null() const                                 { return true; }
 447   virtual bool speculative_always_null() const                                { return true; }
 448   virtual const Type* remove_speculative() const                              { return this; }
 449   virtual const Type* cleanup_speculative() const                             { return this; }
 450   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }
 451   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return ptr_kind == ProfileAlwaysNull || ptr_kind == ProfileNeverNull; }
 452   const Type* maybe_remove_speculative(bool include_speculative) const;
 453 
 454   virtual bool maybe_null() const { return true; }
 455 
 456 private:
 457   // support arrays
 458   static const Type*        _zero_type[T_CONFLICT+1];
 459   static const Type* _const_basic_type[T_CONFLICT+1];
 460 };
 461 
 462 //------------------------------TypeF------------------------------------------
 463 // Class of Float-Constant Types.
 464 class TypeF : public Type {
 465   TypeF( float f ) : Type(FloatCon), _f(f) {};
 466 public:
 467   virtual bool eq( const Type *t ) const;
 468   virtual int  hash() const;             // Type specific hashing
 469   virtual bool singleton(void) const;    // TRUE if type is a singleton
 470   virtual bool empty(void) const;        // TRUE if type is vacuous
 471 public:
 472   const float _f;               // Float constant
 473 
 474   static const TypeF *make(float f);
 475 
 476   virtual bool        is_finite() const;  // Has a finite value
 477   virtual bool        is_nan()    const;  // Is not a number (NaN)
 478 
 479   virtual const Type *xmeet( const Type *t ) const;
 480   virtual const Type *xdual() const;    // Compute dual right now.
 481   // Convenience common pre-built types.
 482   static const TypeF *ZERO; // positive zero only
 483   static const TypeF *ONE;
 484   static const TypeF *POS_INF;
 485   static const TypeF *NEG_INF;
 486 #ifndef PRODUCT
 487   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 488 #endif
 489 };
 490 
 491 //------------------------------TypeD------------------------------------------
 492 // Class of Double-Constant Types.
 493 class TypeD : public Type {
 494   TypeD( double d ) : Type(DoubleCon), _d(d) {};
 495 public:
 496   virtual bool eq( const Type *t ) const;
 497   virtual int  hash() const;             // Type specific hashing
 498   virtual bool singleton(void) const;    // TRUE if type is a singleton
 499   virtual bool empty(void) const;        // TRUE if type is vacuous
 500 public:
 501   const double _d;              // Double constant
 502 
 503   static const TypeD *make(double d);
 504 
 505   virtual bool        is_finite() const;  // Has a finite value
 506   virtual bool        is_nan()    const;  // Is not a number (NaN)
 507 
 508   virtual const Type *xmeet( const Type *t ) const;
 509   virtual const Type *xdual() const;    // Compute dual right now.
 510   // Convenience common pre-built types.
 511   static const TypeD *ZERO; // positive zero only
 512   static const TypeD *ONE;
 513   static const TypeD *POS_INF;
 514   static const TypeD *NEG_INF;
 515 #ifndef PRODUCT
 516   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 517 #endif
 518 };
 519 
 520 //------------------------------TypeInt----------------------------------------
 521 // Class of integer ranges, the set of integers between a lower bound and an
 522 // upper bound, inclusive.
 523 class TypeInt : public Type {
 524   TypeInt( jint lo, jint hi, int w );
 525 protected:
 526   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 527 
 528 public:
 529   typedef jint NativeType;
 530   virtual bool eq( const Type *t ) const;
 531   virtual int  hash() const;             // Type specific hashing
 532   virtual bool singleton(void) const;    // TRUE if type is a singleton
 533   virtual bool empty(void) const;        // TRUE if type is vacuous
 534   const jint _lo, _hi;          // Lower bound, upper bound
 535   const short _widen;           // Limit on times we widen this sucker
 536 
 537   static const TypeInt *make(jint lo);
 538   // must always specify w
 539   static const TypeInt *make(jint lo, jint hi, int w);
 540 
 541   // Check for single integer
 542   int is_con() const { return _lo==_hi; }
 543   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 544   jint get_con() const { assert( is_con(), &quot;&quot; );  return _lo; }
 545 
 546   virtual bool        is_finite() const;  // Has a finite value
 547 
 548   virtual const Type *xmeet( const Type *t ) const;
 549   virtual const Type *xdual() const;    // Compute dual right now.
 550   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 551   virtual const Type *narrow( const Type *t ) const;
 552   // Do not kill _widen bits.
 553   // Convenience common pre-built types.
 554   static const TypeInt *MINUS_1;
 555   static const TypeInt *ZERO;
 556   static const TypeInt *ONE;
 557   static const TypeInt *BOOL;
 558   static const TypeInt *CC;
 559   static const TypeInt *CC_LT;  // [-1]  == MINUS_1
 560   static const TypeInt *CC_GT;  // [1]   == ONE
 561   static const TypeInt *CC_EQ;  // [0]   == ZERO
 562   static const TypeInt *CC_LE;  // [-1,0]
 563   static const TypeInt *CC_GE;  // [0,1] == BOOL (!)
 564   static const TypeInt *BYTE;
 565   static const TypeInt *UBYTE;
 566   static const TypeInt *CHAR;
 567   static const TypeInt *SHORT;
 568   static const TypeInt *POS;
 569   static const TypeInt *POS1;
 570   static const TypeInt *INT;
 571   static const TypeInt *SYMINT; // symmetric range [-max_jint..max_jint]
 572   static const TypeInt *TYPE_DOMAIN; // alias for TypeInt::INT
 573 
 574   static const TypeInt *as_self(const Type *t) { return t-&gt;is_int(); }
 575 #ifndef PRODUCT
 576   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 577 #endif
 578 };
 579 
 580 
 581 //------------------------------TypeLong---------------------------------------
 582 // Class of long integer ranges, the set of integers between a lower bound and
 583 // an upper bound, inclusive.
 584 class TypeLong : public Type {
 585   TypeLong( jlong lo, jlong hi, int w );
 586 protected:
 587   // Do not kill _widen bits.
 588   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 589 public:
 590   typedef jlong NativeType;
 591   virtual bool eq( const Type *t ) const;
 592   virtual int  hash() const;             // Type specific hashing
 593   virtual bool singleton(void) const;    // TRUE if type is a singleton
 594   virtual bool empty(void) const;        // TRUE if type is vacuous
 595 public:
 596   const jlong _lo, _hi;         // Lower bound, upper bound
 597   const short _widen;           // Limit on times we widen this sucker
 598 
 599   static const TypeLong *make(jlong lo);
 600   // must always specify w
 601   static const TypeLong *make(jlong lo, jlong hi, int w);
 602 
 603   // Check for single integer
 604   int is_con() const { return _lo==_hi; }
 605   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 606   jlong get_con() const { assert( is_con(), &quot;&quot; ); return _lo; }
 607 
 608   // Check for positive 32-bit value.
 609   int is_positive_int() const { return _lo &gt;= 0 &amp;&amp; _hi &lt;= (jlong)max_jint; }
 610 
 611   virtual bool        is_finite() const;  // Has a finite value
 612 
 613 
 614   virtual const Type *xmeet( const Type *t ) const;
 615   virtual const Type *xdual() const;    // Compute dual right now.
 616   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 617   virtual const Type *narrow( const Type *t ) const;
 618   // Convenience common pre-built types.
 619   static const TypeLong *MINUS_1;
 620   static const TypeLong *ZERO;
 621   static const TypeLong *ONE;
 622   static const TypeLong *POS;
 623   static const TypeLong *LONG;
 624   static const TypeLong *INT;    // 32-bit subrange [min_jint..max_jint]
 625   static const TypeLong *UINT;   // 32-bit unsigned [0..max_juint]
 626   static const TypeLong *TYPE_DOMAIN; // alias for TypeLong::LONG
 627 
 628   // static convenience methods.
 629   static const TypeLong *as_self(const Type *t) { return t-&gt;is_long(); }
 630 
 631 #ifndef PRODUCT
 632   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const;// Specialized per-Type dumping
 633 #endif
 634 };
 635 
 636 //------------------------------TypeTuple--------------------------------------
 637 // Class of Tuple Types, essentially type collections for function signatures
 638 // and class layouts.  It happens to also be a fast cache for the HotSpot
 639 // signature types.
 640 class TypeTuple : public Type {
 641   TypeTuple( uint cnt, const Type **fields ) : Type(Tuple), _cnt(cnt), _fields(fields) { }
 642 
 643   const uint          _cnt;              // Count of fields
 644   const Type ** const _fields;           // Array of field types
 645 
 646 public:
 647   virtual bool eq( const Type *t ) const;
 648   virtual int  hash() const;             // Type specific hashing
 649   virtual bool singleton(void) const;    // TRUE if type is a singleton
 650   virtual bool empty(void) const;        // TRUE if type is vacuous
 651 
 652   // Accessors:
 653   uint cnt() const { return _cnt; }
 654   const Type* field_at(uint i) const {
 655     assert(i &lt; _cnt, &quot;oob&quot;);
 656     return _fields[i];
 657   }
 658   void set_field_at(uint i, const Type* t) {
 659     assert(i &lt; _cnt, &quot;oob&quot;);
 660     _fields[i] = t;
 661   }
 662 
 663   static const TypeTuple *make( uint cnt, const Type **fields );
 664   static const TypeTuple *make_range(ciSignature *sig);
 665   static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig);
 666 
 667   // Subroutine call type with space allocated for argument types
 668   // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
 669   static const Type **fields( uint arg_cnt );
 670 
 671   virtual const Type *xmeet( const Type *t ) const;
 672   virtual const Type *xdual() const;    // Compute dual right now.
 673   // Convenience common pre-built types.
 674   static const TypeTuple *IFBOTH;
 675   static const TypeTuple *IFFALSE;
 676   static const TypeTuple *IFTRUE;
 677   static const TypeTuple *IFNEITHER;
 678   static const TypeTuple *LOOPBODY;
 679   static const TypeTuple *MEMBAR;
 680   static const TypeTuple *STORECONDITIONAL;
 681   static const TypeTuple *START_I2C;
 682   static const TypeTuple *INT_PAIR;
 683   static const TypeTuple *LONG_PAIR;
 684   static const TypeTuple *INT_CC_PAIR;
 685   static const TypeTuple *LONG_CC_PAIR;
 686 #ifndef PRODUCT
 687   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 688 #endif
 689 };
 690 
 691 //------------------------------TypeAry----------------------------------------
 692 // Class of Array Types
 693 class TypeAry : public Type {
 694   TypeAry(const Type* elem, const TypeInt* size, bool stable) : Type(Array),
 695       _elem(elem), _size(size), _stable(stable) {}
 696 public:
 697   virtual bool eq( const Type *t ) const;
 698   virtual int  hash() const;             // Type specific hashing
 699   virtual bool singleton(void) const;    // TRUE if type is a singleton
 700   virtual bool empty(void) const;        // TRUE if type is vacuous
 701 
 702 private:
 703   const Type *_elem;            // Element type of array
 704   const TypeInt *_size;         // Elements in array
 705   const bool _stable;           // Are elements @Stable?
 706   friend class TypeAryPtr;
 707 
 708 public:
 709   static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false);
 710 
 711   virtual const Type *xmeet( const Type *t ) const;
 712   virtual const Type *xdual() const;    // Compute dual right now.
 713   bool ary_must_be_exact() const;  // true if arrays of such are never generic
 714   virtual const Type* remove_speculative() const;
 715   virtual const Type* cleanup_speculative() const;
 716 #ifdef ASSERT
 717   // One type is interface, the other is oop
 718   virtual bool interface_vs_oop(const Type *t) const;
 719 #endif
 720 #ifndef PRODUCT
 721   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 722 #endif
 723 };
 724 
 725 //------------------------------TypeVect---------------------------------------
 726 // Class of Vector Types
 727 class TypeVect : public Type {
 728   const Type*   _elem;  // Vector&#39;s element type
 729   const uint  _length;  // Elements in vector (power of 2)
 730 
 731 protected:
 732   TypeVect(TYPES t, const Type* elem, uint length) : Type(t),
 733     _elem(elem), _length(length) {}
 734 
 735 public:
 736   const Type* element_type() const { return _elem; }
 737   BasicType element_basic_type() const { return _elem-&gt;array_element_basic_type(); }
 738   uint length() const { return _length; }
 739   uint length_in_bytes() const {
 740    return _length * type2aelembytes(element_basic_type());
 741   }
 742 
 743   virtual bool eq(const Type *t) const;
 744   virtual int  hash() const;             // Type specific hashing
 745   virtual bool singleton(void) const;    // TRUE if type is a singleton
 746   virtual bool empty(void) const;        // TRUE if type is vacuous
 747 
 748   static const TypeVect *make(const BasicType elem_bt, uint length) {
 749     // Use bottom primitive type.
 750     return make(get_const_basic_type(elem_bt), length);
 751   }
 752   // Used directly by Replicate nodes to construct singleton vector.
 753   static const TypeVect *make(const Type* elem, uint length);
 754 
 755   virtual const Type *xmeet( const Type *t) const;
 756   virtual const Type *xdual() const;     // Compute dual right now.
 757 
 758   static const TypeVect *VECTS;
 759   static const TypeVect *VECTD;
 760   static const TypeVect *VECTX;
 761   static const TypeVect *VECTY;
 762   static const TypeVect *VECTZ;
 763 
 764 #ifndef PRODUCT
 765   virtual void dump2(Dict &amp;d, uint, outputStream *st) const; // Specialized per-Type dumping
 766 #endif
 767 };
 768 
 769 class TypeVectS : public TypeVect {
 770   friend class TypeVect;
 771   TypeVectS(const Type* elem, uint length) : TypeVect(VectorS, elem, length) {}
 772 };
 773 
 774 class TypeVectD : public TypeVect {
 775   friend class TypeVect;
 776   TypeVectD(const Type* elem, uint length) : TypeVect(VectorD, elem, length) {}
 777 };
 778 
 779 class TypeVectX : public TypeVect {
 780   friend class TypeVect;
 781   TypeVectX(const Type* elem, uint length) : TypeVect(VectorX, elem, length) {}
 782 };
 783 
 784 class TypeVectY : public TypeVect {
 785   friend class TypeVect;
 786   TypeVectY(const Type* elem, uint length) : TypeVect(VectorY, elem, length) {}
 787 };
 788 
 789 class TypeVectZ : public TypeVect {
 790   friend class TypeVect;
 791   TypeVectZ(const Type* elem, uint length) : TypeVect(VectorZ, elem, length) {}
 792 };
 793 
 794 //------------------------------TypePtr----------------------------------------
 795 // Class of machine Pointer Types: raw data, instances or arrays.
 796 // If the _base enum is AnyPtr, then this refers to all of the above.
 797 // Otherwise the _base will indicate which subset of pointers is affected,
 798 // and the class will be inherited from.
 799 class TypePtr : public Type {
 800   friend class TypeNarrowPtr;
 801 public:
 802   enum PTR { TopPTR, AnyNull, Constant, Null, NotNull, BotPTR, lastPTR };
 803 protected:
 804   TypePtr(TYPES t, PTR ptr, int offset,
 805           const TypePtr* speculative = NULL,
 806           int inline_depth = InlineDepthBottom) :
 807     Type(t), _speculative(speculative), _inline_depth(inline_depth), _offset(offset),
 808     _ptr(ptr) {}
 809   static const PTR ptr_meet[lastPTR][lastPTR];
 810   static const PTR ptr_dual[lastPTR];
 811   static const char * const ptr_msg[lastPTR];
 812 
 813   enum {
 814     InlineDepthBottom = INT_MAX,
 815     InlineDepthTop = -InlineDepthBottom
 816   };
 817 
 818   // Extra type information profiling gave us. We propagate it the
 819   // same way the rest of the type info is propagated. If we want to
 820   // use it, then we have to emit a guard: this part of the type is
 821   // not something we know but something we speculate about the type.
 822   const TypePtr*   _speculative;
 823   // For speculative types, we record at what inlining depth the
 824   // profiling point that provided the data is. We want to favor
 825   // profile data coming from outer scopes which are likely better for
 826   // the current compilation.
 827   int _inline_depth;
 828 
 829   // utility methods to work on the speculative part of the type
 830   const TypePtr* dual_speculative() const;
 831   const TypePtr* xmeet_speculative(const TypePtr* other) const;
 832   bool eq_speculative(const TypePtr* other) const;
 833   int hash_speculative() const;
 834   const TypePtr* add_offset_speculative(intptr_t offset) const;
 835 #ifndef PRODUCT
 836   void dump_speculative(outputStream *st) const;
 837 #endif
 838 
 839   // utility methods to work on the inline depth of the type
 840   int dual_inline_depth() const;
 841   int meet_inline_depth(int depth) const;
 842 #ifndef PRODUCT
 843   void dump_inline_depth(outputStream *st) const;
 844 #endif
 845 
 846 public:
 847   const int _offset;            // Offset into oop, with TOP &amp; BOT
 848   const PTR _ptr;               // Pointer equivalence class
 849 
 850   const int offset() const { return _offset; }
 851   const PTR ptr()    const { return _ptr; }
 852 
 853   static const TypePtr *make(TYPES t, PTR ptr, int offset,
 854                              const TypePtr* speculative = NULL,
 855                              int inline_depth = InlineDepthBottom);
 856 
 857   // Return a &#39;ptr&#39; version of this type
 858   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 859 
 860   virtual intptr_t get_con() const;
 861 
 862   int xadd_offset( intptr_t offset ) const;
 863   virtual const TypePtr *add_offset( intptr_t offset ) const;
 864   virtual bool eq(const Type *t) const;
 865   virtual int  hash() const;             // Type specific hashing
 866 
 867   virtual bool singleton(void) const;    // TRUE if type is a singleton
 868   virtual bool empty(void) const;        // TRUE if type is vacuous
 869   virtual const Type *xmeet( const Type *t ) const;
 870   virtual const Type *xmeet_helper( const Type *t ) const;
 871   int meet_offset( int offset ) const;
 872   int dual_offset( ) const;
 873   virtual const Type *xdual() const;    // Compute dual right now.
 874 
 875   // meet, dual and join over pointer equivalence sets
 876   PTR meet_ptr( const PTR in_ptr ) const { return ptr_meet[in_ptr][ptr()]; }
 877   PTR dual_ptr()                   const { return ptr_dual[ptr()];      }
 878 
 879   // This is textually confusing unless one recalls that
 880   // join(t) == dual()-&gt;meet(t-&gt;dual())-&gt;dual().
 881   PTR join_ptr( const PTR in_ptr ) const {
 882     return ptr_dual[ ptr_meet[ ptr_dual[in_ptr] ] [ dual_ptr() ] ];
 883   }
 884 
 885   // Speculative type helper methods.
 886   virtual const TypePtr* speculative() const { return _speculative; }
 887   int inline_depth() const                   { return _inline_depth; }
 888   virtual ciKlass* speculative_type() const;
 889   virtual ciKlass* speculative_type_not_null() const;
 890   virtual bool speculative_maybe_null() const;
 891   virtual bool speculative_always_null() const;
 892   virtual const Type* remove_speculative() const;
 893   virtual const Type* cleanup_speculative() const;
 894   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
 895   virtual bool would_improve_ptr(ProfilePtrKind maybe_null) const;
 896   virtual const TypePtr* with_inline_depth(int depth) const;
 897 
 898   virtual bool maybe_null() const { return meet_ptr(Null) == ptr(); }
 899 
 900   // Tests for relation to centerline of type lattice:
 901   static bool above_centerline(PTR ptr) { return (ptr &lt;= AnyNull); }
 902   static bool below_centerline(PTR ptr) { return (ptr &gt;= NotNull); }
 903   // Convenience common pre-built types.
 904   static const TypePtr *NULL_PTR;
 905   static const TypePtr *NOTNULL;
 906   static const TypePtr *BOTTOM;
 907 #ifndef PRODUCT
 908   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 909 #endif
 910 };
 911 
 912 //------------------------------TypeRawPtr-------------------------------------
 913 // Class of raw pointers, pointers to things other than Oops.  Examples
 914 // include the stack pointer, top of heap, card-marking area, handles, etc.
 915 class TypeRawPtr : public TypePtr {
 916 protected:
 917   TypeRawPtr( PTR ptr, address bits ) : TypePtr(RawPtr,ptr,0), _bits(bits){}
 918 public:
 919   virtual bool eq( const Type *t ) const;
 920   virtual int  hash() const;     // Type specific hashing
 921 
 922   const address _bits;          // Constant value, if applicable
 923 
 924   static const TypeRawPtr *make( PTR ptr );
 925   static const TypeRawPtr *make( address bits );
 926 
 927   // Return a &#39;ptr&#39; version of this type
 928   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 929 
 930   virtual intptr_t get_con() const;
 931 
 932   virtual const TypePtr *add_offset( intptr_t offset ) const;
 933 
 934   virtual const Type *xmeet( const Type *t ) const;
 935   virtual const Type *xdual() const;    // Compute dual right now.
 936   // Convenience common pre-built types.
 937   static const TypeRawPtr *BOTTOM;
 938   static const TypeRawPtr *NOTNULL;
 939 #ifndef PRODUCT
 940   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 941 #endif
 942 };
 943 
 944 //------------------------------TypeOopPtr-------------------------------------
 945 // Some kind of oop (Java pointer), either instance or array.
 946 class TypeOopPtr : public TypePtr {
 947 protected:
 948   TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,
 949              const TypePtr* speculative, int inline_depth);
 950 public:
 951   virtual bool eq( const Type *t ) const;
 952   virtual int  hash() const;             // Type specific hashing
 953   virtual bool singleton(void) const;    // TRUE if type is a singleton
 954   enum {
 955    InstanceTop = -1,   // undefined instance
 956    InstanceBot = 0     // any possible instance
 957   };
 958 protected:
 959 
 960   // Oop is NULL, unless this is a constant oop.
 961   ciObject*     _const_oop;   // Constant oop
 962   // If _klass is NULL, then so is _sig.  This is an unloaded klass.
 963   ciKlass*      _klass;       // Klass object
 964   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
 965   bool          _klass_is_exact;
 966   bool          _is_ptr_to_narrowoop;
 967   bool          _is_ptr_to_narrowklass;
 968   bool          _is_ptr_to_boxed_value;
 969 
 970   // If not InstanceTop or InstanceBot, indicates that this is
 971   // a particular instance of this type which is distinct.
 972   // This is the node index of the allocation node creating this instance.
 973   int           _instance_id;
 974 
 975   static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);
 976 
 977   int dual_instance_id() const;
 978   int meet_instance_id(int uid) const;
 979 
 980   // Do not allow interface-vs.-noninterface joins to collapse to top.
 981   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 982 
 983 public:
 984   // Creates a type given a klass. Correctly handles multi-dimensional arrays
 985   // Respects UseUniqueSubclasses.
 986   // If the klass is final, the resulting type will be exact.
 987   static const TypeOopPtr* make_from_klass(ciKlass* klass) {
 988     return make_from_klass_common(klass, true, false);
 989   }
 990   // Same as before, but will produce an exact type, even if
 991   // the klass is not final, as long as it has exactly one implementation.
 992   static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {
 993     return make_from_klass_common(klass, true, true);
 994   }
 995   // Same as before, but does not respects UseUniqueSubclasses.
 996   // Use this only for creating array element types.
 997   static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {
 998     return make_from_klass_common(klass, false, false);
 999   }
1000   // Creates a singleton type given an object.
1001   // If the object cannot be rendered as a constant,
1002   // may return a non-singleton type.
1003   // If require_constant, produce a NULL if a singleton is not possible.
1004   static const TypeOopPtr* make_from_constant(ciObject* o,
1005                                               bool require_constant = false);
1006 
1007   // Make a generic (unclassed) pointer to an oop.
1008   static const TypeOopPtr* make(PTR ptr, int offset, int instance_id,
1009                                 const TypePtr* speculative = NULL,
1010                                 int inline_depth = InlineDepthBottom);
1011 
1012   ciObject* const_oop()    const { return _const_oop; }
1013   virtual ciKlass* klass() const { return _klass;     }
1014   bool klass_is_exact()    const { return _klass_is_exact; }
1015 
1016   // Returns true if this pointer points at memory which contains a
1017   // compressed oop references.
1018   bool is_ptr_to_narrowoop_nv() const { return _is_ptr_to_narrowoop; }
1019   bool is_ptr_to_narrowklass_nv() const { return _is_ptr_to_narrowklass; }
1020   bool is_ptr_to_boxed_value()   const { return _is_ptr_to_boxed_value; }
1021   bool is_known_instance()       const { return _instance_id &gt; 0; }
1022   int  instance_id()             const { return _instance_id; }
1023   bool is_known_instance_field() const { return is_known_instance() &amp;&amp; _offset &gt;= 0; }
1024 
1025   virtual intptr_t get_con() const;
1026 
1027   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1028 
1029   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1030 
1031   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1032 
1033   // corresponding pointer to klass, for a given instance
1034   const TypeKlassPtr* as_klass_type() const;
1035 
1036   virtual const TypePtr *add_offset( intptr_t offset ) const;
1037 
1038   // Speculative type helper methods.
1039   virtual const Type* remove_speculative() const;
1040   virtual const Type* cleanup_speculative() const;
1041   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
1042   virtual const TypePtr* with_inline_depth(int depth) const;
1043 
1044   virtual const TypePtr* with_instance_id(int instance_id) const;
1045 
1046   virtual const Type *xdual() const;    // Compute dual right now.
1047   // the core of the computation of the meet for TypeOopPtr and for its subclasses
1048   virtual const Type *xmeet_helper(const Type *t) const;
1049 
1050   // Convenience common pre-built type.
1051   static const TypeOopPtr *BOTTOM;
1052 #ifndef PRODUCT
1053   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1054 #endif
1055 };
1056 
1057 //------------------------------TypeInstPtr------------------------------------
1058 // Class of Java object pointers, pointing either to non-array Java instances
1059 // or to a Klass* (including array klasses).
1060 class TypeInstPtr : public TypeOopPtr {
1061   TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,
1062               const TypePtr* speculative, int inline_depth);
1063   virtual bool eq( const Type *t ) const;
1064   virtual int  hash() const;             // Type specific hashing
1065 
1066   ciSymbol*  _name;        // class name
1067 
1068  public:
1069   ciSymbol* name()         const { return _name; }
1070 
1071   bool  is_loaded() const { return _klass-&gt;is_loaded(); }
1072 
1073   // Make a pointer to a constant oop.
1074   static const TypeInstPtr *make(ciObject* o) {
1075     return make(TypePtr::Constant, o-&gt;klass(), true, o, 0, InstanceBot);
1076   }
1077   // Make a pointer to a constant oop with offset.
1078   static const TypeInstPtr *make(ciObject* o, int offset) {
1079     return make(TypePtr::Constant, o-&gt;klass(), true, o, offset, InstanceBot);
1080   }
1081 
1082   // Make a pointer to some value of type klass.
1083   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
1084     return make(ptr, klass, false, NULL, 0, InstanceBot);
1085   }
1086 
1087   // Make a pointer to some non-polymorphic value of exactly type klass.
1088   static const TypeInstPtr *make_exact(PTR ptr, ciKlass* klass) {
1089     return make(ptr, klass, true, NULL, 0, InstanceBot);
1090   }
1091 
1092   // Make a pointer to some value of type klass with offset.
1093   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, int offset) {
1094     return make(ptr, klass, false, NULL, offset, InstanceBot);
1095   }
1096 
1097   // Make a pointer to an oop.
1098   static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,
1099                                  int instance_id = InstanceBot,
1100                                  const TypePtr* speculative = NULL,
1101                                  int inline_depth = InlineDepthBottom);
1102 
1103   /** Create constant type for a constant boxed value */
1104   const Type* get_const_boxed_value() const;
1105 
1106   // If this is a java.lang.Class constant, return the type for it or NULL.
1107   // Pass to Type::get_const_type to turn it to a type, which will usually
1108   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
1109   ciType* java_mirror_type() const;
1110 
1111   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1112 
1113   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1114 
1115   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1116 
1117   virtual const TypePtr *add_offset( intptr_t offset ) const;
1118 
1119   // Speculative type helper methods.
1120   virtual const Type* remove_speculative() const;
1121   virtual const TypePtr* with_inline_depth(int depth) const;
1122   virtual const TypePtr* with_instance_id(int instance_id) const;
1123 
1124   // the core of the computation of the meet of 2 types
1125   virtual const Type *xmeet_helper(const Type *t) const;
1126   virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;
1127   virtual const Type *xdual() const;    // Compute dual right now.
1128 
1129   // Convenience common pre-built types.
1130   static const TypeInstPtr *NOTNULL;
1131   static const TypeInstPtr *BOTTOM;
1132   static const TypeInstPtr *MIRROR;
1133   static const TypeInstPtr *MARK;
1134   static const TypeInstPtr *KLASS;
1135 #ifndef PRODUCT
1136   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1137 #endif
1138 };
1139 
1140 //------------------------------TypeAryPtr-------------------------------------
1141 // Class of Java array pointers
1142 class TypeAryPtr : public TypeOopPtr {
1143   TypeAryPtr( PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk,
1144               int offset, int instance_id, bool is_autobox_cache,
1145               const TypePtr* speculative, int inline_depth)
1146     : TypeOopPtr(AryPtr,ptr,k,xk,o,offset, instance_id, speculative, inline_depth),
1147     _ary(ary),
1148     _is_autobox_cache(is_autobox_cache)
1149  {
1150 #ifdef ASSERT
1151     if (k != NULL) {
1152       // Verify that specified klass and TypeAryPtr::klass() follow the same rules.
1153       ciKlass* ck = compute_klass(true);
1154       if (k != ck) {
1155         this-&gt;dump(); tty-&gt;cr();
1156         tty-&gt;print(&quot; k: &quot;);
1157         k-&gt;print(); tty-&gt;cr();
1158         tty-&gt;print(&quot;ck: &quot;);
1159         if (ck != NULL) ck-&gt;print();
1160         else tty-&gt;print(&quot;&lt;NULL&gt;&quot;);
1161         tty-&gt;cr();
1162         assert(false, &quot;unexpected TypeAryPtr::_klass&quot;);
1163       }
1164     }
1165 #endif
1166   }
1167   virtual bool eq( const Type *t ) const;
1168   virtual int hash() const;     // Type specific hashing
1169   const TypeAry *_ary;          // Array we point into
1170   const bool     _is_autobox_cache;
1171 
1172   ciKlass* compute_klass(DEBUG_ONLY(bool verify = false)) const;
1173 
1174 public:
1175   // Accessors
1176   ciKlass* klass() const;
1177   const TypeAry* ary() const  { return _ary; }
1178   const Type*    elem() const { return _ary-&gt;_elem; }
1179   const TypeInt* size() const { return _ary-&gt;_size; }
1180   bool      is_stable() const { return _ary-&gt;_stable; }
1181 
1182   bool is_autobox_cache() const { return _is_autobox_cache; }
1183 
1184   static const TypeAryPtr *make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,
1185                                 int instance_id = InstanceBot,
1186                                 const TypePtr* speculative = NULL,
1187                                 int inline_depth = InlineDepthBottom);
1188   // Constant pointer to array
1189   static const TypeAryPtr *make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,
1190                                 int instance_id = InstanceBot,
1191                                 const TypePtr* speculative = NULL,
1192                                 int inline_depth = InlineDepthBottom, bool is_autobox_cache = false);
1193 
1194   // Return a &#39;ptr&#39; version of this type
1195   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1196 
1197   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1198 
1199   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1200 
1201   virtual const TypeAryPtr* cast_to_size(const TypeInt* size) const;
1202   virtual const TypeInt* narrow_size_type(const TypeInt* size) const;
1203 
1204   virtual bool empty(void) const;        // TRUE if type is vacuous
1205   virtual const TypePtr *add_offset( intptr_t offset ) const;
1206 
1207   // Speculative type helper methods.
1208   virtual const Type* remove_speculative() const;
1209   virtual const TypePtr* with_inline_depth(int depth) const;
1210   virtual const TypePtr* with_instance_id(int instance_id) const;
1211 
1212   // the core of the computation of the meet of 2 types
1213   virtual const Type *xmeet_helper(const Type *t) const;
1214   virtual const Type *xdual() const;    // Compute dual right now.
1215 
1216   const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
1217   int stable_dimension() const;
1218 
1219   const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
1220 
1221   static jint max_array_length(BasicType etype) ;
1222 
1223   // Convenience common pre-built types.
1224   static const TypeAryPtr *RANGE;
1225   static const TypeAryPtr *OOPS;
1226   static const TypeAryPtr *NARROWOOPS;
1227   static const TypeAryPtr *BYTES;
1228   static const TypeAryPtr *SHORTS;
1229   static const TypeAryPtr *CHARS;
1230   static const TypeAryPtr *INTS;
1231   static const TypeAryPtr *LONGS;
1232   static const TypeAryPtr *FLOATS;
1233   static const TypeAryPtr *DOUBLES;
1234   // selects one of the above:
1235   static const TypeAryPtr *get_array_body_type(BasicType elem) {
1236     assert((uint)elem &lt;= T_CONFLICT &amp;&amp; _array_body_type[elem] != NULL, &quot;bad elem type&quot;);
1237     return _array_body_type[elem];
1238   }
1239   static const TypeAryPtr *_array_body_type[T_CONFLICT+1];
1240   // sharpen the type of an int which is used as an array size
1241 #ifdef ASSERT
1242   // One type is interface, the other is oop
1243   virtual bool interface_vs_oop(const Type *t) const;
1244 #endif
1245 #ifndef PRODUCT
1246   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1247 #endif
1248 };
1249 
1250 //------------------------------TypeMetadataPtr-------------------------------------
1251 // Some kind of metadata, either Method*, MethodData* or CPCacheOop
1252 class TypeMetadataPtr : public TypePtr {
1253 protected:
1254   TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset);
1255   // Do not allow interface-vs.-noninterface joins to collapse to top.
1256   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1257 public:
1258   virtual bool eq( const Type *t ) const;
1259   virtual int  hash() const;             // Type specific hashing
1260   virtual bool singleton(void) const;    // TRUE if type is a singleton
1261 
1262 private:
1263   ciMetadata*   _metadata;
1264 
1265 public:
1266   static const TypeMetadataPtr* make(PTR ptr, ciMetadata* m, int offset);
1267 
1268   static const TypeMetadataPtr* make(ciMethod* m);
1269   static const TypeMetadataPtr* make(ciMethodData* m);
1270 
1271   ciMetadata* metadata() const { return _metadata; }
1272 
1273   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1274 
1275   virtual const TypePtr *add_offset( intptr_t offset ) const;
1276 
1277   virtual const Type *xmeet( const Type *t ) const;
1278   virtual const Type *xdual() const;    // Compute dual right now.
1279 
1280   virtual intptr_t get_con() const;
1281 
1282   // Convenience common pre-built types.
1283   static const TypeMetadataPtr *BOTTOM;
1284 
1285 #ifndef PRODUCT
1286   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1287 #endif
1288 };
1289 
1290 //------------------------------TypeKlassPtr-----------------------------------
1291 // Class of Java Klass pointers
1292 class TypeKlassPtr : public TypePtr {
1293   TypeKlassPtr( PTR ptr, ciKlass* klass, int offset );
1294 
1295 protected:
1296   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1297  public:
1298   virtual bool eq( const Type *t ) const;
1299   virtual int hash() const;             // Type specific hashing
1300   virtual bool singleton(void) const;    // TRUE if type is a singleton
1301  private:
1302 
1303   static const TypeKlassPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);
1304 
1305   ciKlass* _klass;
1306 
1307   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
1308   bool          _klass_is_exact;
1309 
1310 public:
1311   ciSymbol* name()  const { return klass()-&gt;name(); }
1312 
1313   ciKlass* klass() const { return  _klass; }
1314   bool klass_is_exact()    const { return _klass_is_exact; }
1315 
1316   bool  is_loaded() const { return klass()-&gt;is_loaded(); }
1317 
1318   // Creates a type given a klass. Correctly handles multi-dimensional arrays
1319   // Respects UseUniqueSubclasses.
1320   // If the klass is final, the resulting type will be exact.
1321   static const TypeKlassPtr* make_from_klass(ciKlass* klass) {
1322     return make_from_klass_common(klass, true, false);
1323   }
1324   // Same as before, but will produce an exact type, even if
1325   // the klass is not final, as long as it has exactly one implementation.
1326   static const TypeKlassPtr* make_from_klass_unique(ciKlass* klass) {
1327     return make_from_klass_common(klass, true, true);
1328   }
1329   // Same as before, but does not respects UseUniqueSubclasses.
1330   // Use this only for creating array element types.
1331   static const TypeKlassPtr* make_from_klass_raw(ciKlass* klass) {
1332     return make_from_klass_common(klass, false, false);
1333   }
1334 
1335   // Make a generic (unclassed) pointer to metadata.
1336   static const TypeKlassPtr* make(PTR ptr, int offset);
1337 
1338   // ptr to klass &#39;k&#39;
1339   static const TypeKlassPtr *make( ciKlass* k ) { return make( TypePtr::Constant, k, 0); }
1340   // ptr to klass &#39;k&#39; with offset
1341   static const TypeKlassPtr *make( ciKlass* k, int offset ) { return make( TypePtr::Constant, k, offset); }
1342   // ptr to klass &#39;k&#39; or sub-klass
1343   static const TypeKlassPtr *make( PTR ptr, ciKlass* k, int offset);
1344 
1345   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1346 
1347   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1348 
1349   // corresponding pointer to instance, for a given class
1350   const TypeOopPtr* as_instance_type() const;
1351 
1352   virtual const TypePtr *add_offset( intptr_t offset ) const;
1353   virtual const Type    *xmeet( const Type *t ) const;
1354   virtual const Type    *xdual() const;      // Compute dual right now.
1355 
1356   virtual intptr_t get_con() const;
1357 
1358   // Convenience common pre-built types.
1359   static const TypeKlassPtr* OBJECT; // Not-null object klass or below
1360   static const TypeKlassPtr* OBJECT_OR_NULL; // Maybe-null version of same
1361 #ifndef PRODUCT
1362   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1363 #endif
1364 };
1365 
1366 class TypeNarrowPtr : public Type {
1367 protected:
1368   const TypePtr* _ptrtype; // Could be TypePtr::NULL_PTR
1369 
1370   TypeNarrowPtr(TYPES t, const TypePtr* ptrtype): Type(t),
1371                                                   _ptrtype(ptrtype) {
1372     assert(ptrtype-&gt;offset() == 0 ||
1373            ptrtype-&gt;offset() == OffsetBot ||
1374            ptrtype-&gt;offset() == OffsetTop, &quot;no real offsets&quot;);
1375   }
1376 
1377   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const = 0;
1378   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const = 0;
1379   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const = 0;
1380   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const = 0;
1381   // Do not allow interface-vs.-noninterface joins to collapse to top.
1382   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1383 public:
1384   virtual bool eq( const Type *t ) const;
1385   virtual int  hash() const;             // Type specific hashing
1386   virtual bool singleton(void) const;    // TRUE if type is a singleton
1387 
1388   virtual const Type *xmeet( const Type *t ) const;
1389   virtual const Type *xdual() const;    // Compute dual right now.
1390 
1391   virtual intptr_t get_con() const;
1392 
1393   virtual bool empty(void) const;        // TRUE if type is vacuous
1394 
1395   // returns the equivalent ptr type for this compressed pointer
1396   const TypePtr *get_ptrtype() const {
1397     return _ptrtype;
1398   }
1399 
1400 #ifndef PRODUCT
1401   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1402 #endif
1403 };
1404 
1405 //------------------------------TypeNarrowOop----------------------------------
1406 // A compressed reference to some kind of Oop.  This type wraps around
1407 // a preexisting TypeOopPtr and forwards most of it&#39;s operations to
1408 // the underlying type.  It&#39;s only real purpose is to track the
1409 // oopness of the compressed oop value when we expose the conversion
1410 // between the normal and the compressed form.
1411 class TypeNarrowOop : public TypeNarrowPtr {
1412 protected:
1413   TypeNarrowOop( const TypePtr* ptrtype): TypeNarrowPtr(NarrowOop, ptrtype) {
1414   }
1415 
1416   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1417     return t-&gt;isa_narrowoop();
1418   }
1419 
1420   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1421     return t-&gt;is_narrowoop();
1422   }
1423 
1424   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1425     return new TypeNarrowOop(t);
1426   }
1427 
1428   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1429     return (const TypeNarrowPtr*)((new TypeNarrowOop(t))-&gt;hashcons());
1430   }
1431 
1432 public:
1433 
1434   static const TypeNarrowOop *make( const TypePtr* type);
1435 
1436   static const TypeNarrowOop* make_from_constant(ciObject* con, bool require_constant = false) {
1437     return make(TypeOopPtr::make_from_constant(con, require_constant));
1438   }
1439 
1440   static const TypeNarrowOop *BOTTOM;
1441   static const TypeNarrowOop *NULL_PTR;
1442 
1443   virtual const Type* remove_speculative() const;
1444   virtual const Type* cleanup_speculative() const;
1445 
1446 #ifndef PRODUCT
1447   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1448 #endif
1449 };
1450 
1451 //------------------------------TypeNarrowKlass----------------------------------
1452 // A compressed reference to klass pointer.  This type wraps around a
1453 // preexisting TypeKlassPtr and forwards most of it&#39;s operations to
1454 // the underlying type.
1455 class TypeNarrowKlass : public TypeNarrowPtr {
1456 protected:
1457   TypeNarrowKlass( const TypePtr* ptrtype): TypeNarrowPtr(NarrowKlass, ptrtype) {
1458   }
1459 
1460   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1461     return t-&gt;isa_narrowklass();
1462   }
1463 
1464   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1465     return t-&gt;is_narrowklass();
1466   }
1467 
1468   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1469     return new TypeNarrowKlass(t);
1470   }
1471 
1472   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1473     return (const TypeNarrowPtr*)((new TypeNarrowKlass(t))-&gt;hashcons());
1474   }
1475 
1476 public:
1477   static const TypeNarrowKlass *make( const TypePtr* type);
1478 
1479   // static const TypeNarrowKlass *BOTTOM;
1480   static const TypeNarrowKlass *NULL_PTR;
1481 
1482 #ifndef PRODUCT
1483   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1484 #endif
1485 };
1486 
1487 //------------------------------TypeFunc---------------------------------------
1488 // Class of Array Types
1489 class TypeFunc : public Type {
1490   TypeFunc( const TypeTuple *domain, const TypeTuple *range ) : Type(Function),  _domain(domain), _range(range) {}
1491   virtual bool eq( const Type *t ) const;
1492   virtual int  hash() const;             // Type specific hashing
1493   virtual bool singleton(void) const;    // TRUE if type is a singleton
1494   virtual bool empty(void) const;        // TRUE if type is vacuous
1495 
1496   const TypeTuple* const _domain;     // Domain of inputs
1497   const TypeTuple* const _range;      // Range of results
1498 
1499 public:
1500   // Constants are shared among ADLC and VM
1501   enum { Control    = AdlcVMDeps::Control,
1502          I_O        = AdlcVMDeps::I_O,
1503          Memory     = AdlcVMDeps::Memory,
1504          FramePtr   = AdlcVMDeps::FramePtr,
1505          ReturnAdr  = AdlcVMDeps::ReturnAdr,
1506          Parms      = AdlcVMDeps::Parms
1507   };
1508 
1509 
1510   // Accessors:
1511   const TypeTuple* domain() const { return _domain; }
1512   const TypeTuple* range()  const { return _range; }
1513 
1514   static const TypeFunc *make(ciMethod* method);
1515   static const TypeFunc *make(ciSignature signature, const Type* extra);
1516   static const TypeFunc *make(const TypeTuple* domain, const TypeTuple* range);
1517 
1518   virtual const Type *xmeet( const Type *t ) const;
1519   virtual const Type *xdual() const;    // Compute dual right now.
1520 
1521   BasicType return_type() const;
1522 
1523 #ifndef PRODUCT
1524   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1525 #endif
1526   // Convenience common pre-built types.
1527 };
1528 
1529 //------------------------------accessors--------------------------------------
1530 inline bool Type::is_ptr_to_narrowoop() const {
1531 #ifdef _LP64
1532   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowoop_nv());
1533 #else
1534   return false;
1535 #endif
1536 }
1537 
1538 inline bool Type::is_ptr_to_narrowklass() const {
1539 #ifdef _LP64
1540   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowklass_nv());
1541 #else
1542   return false;
1543 #endif
1544 }
1545 
1546 inline float Type::getf() const {
1547   assert( _base == FloatCon, &quot;Not a FloatCon&quot; );
1548   return ((TypeF*)this)-&gt;_f;
1549 }
1550 
1551 inline double Type::getd() const {
1552   assert( _base == DoubleCon, &quot;Not a DoubleCon&quot; );
1553   return ((TypeD*)this)-&gt;_d;
1554 }
1555 
1556 inline const TypeInt *Type::is_int() const {
1557   assert( _base == Int, &quot;Not an Int&quot; );
1558   return (TypeInt*)this;
1559 }
1560 
1561 inline const TypeInt *Type::isa_int() const {
1562   return ( _base == Int ? (TypeInt*)this : NULL);
1563 }
1564 
1565 inline const TypeLong *Type::is_long() const {
1566   assert( _base == Long, &quot;Not a Long&quot; );
1567   return (TypeLong*)this;
1568 }
1569 
1570 inline const TypeLong *Type::isa_long() const {
1571   return ( _base == Long ? (TypeLong*)this : NULL);
1572 }
1573 
1574 inline const TypeF *Type::isa_float() const {
1575   return ((_base == FloatTop ||
1576            _base == FloatCon ||
1577            _base == FloatBot) ? (TypeF*)this : NULL);
1578 }
1579 
1580 inline const TypeF *Type::is_float_constant() const {
1581   assert( _base == FloatCon, &quot;Not a Float&quot; );
1582   return (TypeF*)this;
1583 }
1584 
1585 inline const TypeF *Type::isa_float_constant() const {
1586   return ( _base == FloatCon ? (TypeF*)this : NULL);
1587 }
1588 
1589 inline const TypeD *Type::isa_double() const {
1590   return ((_base == DoubleTop ||
1591            _base == DoubleCon ||
1592            _base == DoubleBot) ? (TypeD*)this : NULL);
1593 }
1594 
1595 inline const TypeD *Type::is_double_constant() const {
1596   assert( _base == DoubleCon, &quot;Not a Double&quot; );
1597   return (TypeD*)this;
1598 }
1599 
1600 inline const TypeD *Type::isa_double_constant() const {
1601   return ( _base == DoubleCon ? (TypeD*)this : NULL);
1602 }
1603 
1604 inline const TypeTuple *Type::is_tuple() const {
1605   assert( _base == Tuple, &quot;Not a Tuple&quot; );
1606   return (TypeTuple*)this;
1607 }
1608 
1609 inline const TypeAry *Type::is_ary() const {
1610   assert( _base == Array , &quot;Not an Array&quot; );
1611   return (TypeAry*)this;
1612 }
1613 
1614 inline const TypeAry *Type::isa_ary() const {
1615   return ((_base == Array) ? (TypeAry*)this : NULL);
1616 }
1617 
1618 inline const TypeVect *Type::is_vect() const {
1619   assert( _base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ, &quot;Not a Vector&quot; );
1620   return (TypeVect*)this;
1621 }
1622 
1623 inline const TypeVect *Type::isa_vect() const {
1624   return (_base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ) ? (TypeVect*)this : NULL;
1625 }
1626 
1627 inline const TypePtr *Type::is_ptr() const {
1628   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1629   assert(_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr, &quot;Not a pointer&quot;);
1630   return (TypePtr*)this;
1631 }
1632 
1633 inline const TypePtr *Type::isa_ptr() const {
1634   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1635   return (_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr) ? (TypePtr*)this : NULL;
1636 }
1637 
1638 inline const TypeOopPtr *Type::is_oopptr() const {
1639   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1640   assert(_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr, &quot;Not a Java pointer&quot; ) ;
1641   return (TypeOopPtr*)this;
1642 }
1643 
1644 inline const TypeOopPtr *Type::isa_oopptr() const {
1645   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1646   return (_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr) ? (TypeOopPtr*)this : NULL;
1647 }
1648 
1649 inline const TypeRawPtr *Type::isa_rawptr() const {
1650   return (_base == RawPtr) ? (TypeRawPtr*)this : NULL;
1651 }
1652 
1653 inline const TypeRawPtr *Type::is_rawptr() const {
1654   assert( _base == RawPtr, &quot;Not a raw pointer&quot; );
1655   return (TypeRawPtr*)this;
1656 }
1657 
1658 inline const TypeInstPtr *Type::isa_instptr() const {
1659   return (_base == InstPtr) ? (TypeInstPtr*)this : NULL;
1660 }
1661 
1662 inline const TypeInstPtr *Type::is_instptr() const {
1663   assert( _base == InstPtr, &quot;Not an object pointer&quot; );
1664   return (TypeInstPtr*)this;
1665 }
1666 
1667 inline const TypeAryPtr *Type::isa_aryptr() const {
1668   return (_base == AryPtr) ? (TypeAryPtr*)this : NULL;
1669 }
1670 
1671 inline const TypeAryPtr *Type::is_aryptr() const {
1672   assert( _base == AryPtr, &quot;Not an array pointer&quot; );
1673   return (TypeAryPtr*)this;
1674 }
1675 
1676 inline const TypeNarrowOop *Type::is_narrowoop() const {
1677   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1678   assert(_base == NarrowOop, &quot;Not a narrow oop&quot; ) ;
1679   return (TypeNarrowOop*)this;
1680 }
1681 
1682 inline const TypeNarrowOop *Type::isa_narrowoop() const {
1683   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1684   return (_base == NarrowOop) ? (TypeNarrowOop*)this : NULL;
1685 }
1686 
1687 inline const TypeNarrowKlass *Type::is_narrowklass() const {
1688   assert(_base == NarrowKlass, &quot;Not a narrow oop&quot; ) ;
1689   return (TypeNarrowKlass*)this;
1690 }
1691 
1692 inline const TypeNarrowKlass *Type::isa_narrowklass() const {
1693   return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : NULL;
1694 }
1695 
1696 inline const TypeMetadataPtr *Type::is_metadataptr() const {
1697   // MetadataPtr is the first and CPCachePtr the last
1698   assert(_base == MetadataPtr, &quot;Not a metadata pointer&quot; ) ;
1699   return (TypeMetadataPtr*)this;
1700 }
1701 
1702 inline const TypeMetadataPtr *Type::isa_metadataptr() const {
1703   return (_base == MetadataPtr) ? (TypeMetadataPtr*)this : NULL;
1704 }
1705 
1706 inline const TypeKlassPtr *Type::isa_klassptr() const {
1707   return (_base == KlassPtr) ? (TypeKlassPtr*)this : NULL;
1708 }
1709 
1710 inline const TypeKlassPtr *Type::is_klassptr() const {
1711   assert( _base == KlassPtr, &quot;Not a klass pointer&quot; );
1712   return (TypeKlassPtr*)this;
1713 }
1714 
1715 inline const TypePtr* Type::make_ptr() const {
1716   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype() :
1717                               ((_base == NarrowKlass) ? is_narrowklass()-&gt;get_ptrtype() :
1718                                                        isa_ptr());
1719 }
1720 
1721 inline const TypeOopPtr* Type::make_oopptr() const {
1722   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype()-&gt;isa_oopptr() : isa_oopptr();
1723 }
1724 
1725 inline const TypeNarrowOop* Type::make_narrowoop() const {
1726   return (_base == NarrowOop) ? is_narrowoop() :
1727                                 (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : NULL);
1728 }
1729 
1730 inline const TypeNarrowKlass* Type::make_narrowklass() const {
1731   return (_base == NarrowKlass) ? is_narrowklass() :
1732                                   (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : NULL);
1733 }
1734 
1735 inline bool Type::is_floatingpoint() const {
1736   if( (_base == FloatCon)  || (_base == FloatBot) ||
1737       (_base == DoubleCon) || (_base == DoubleBot) )
1738     return true;
1739   return false;
1740 }
1741 
1742 inline bool Type::is_ptr_to_boxing_obj() const {
1743   const TypeInstPtr* tp = isa_instptr();
1744   return (tp != NULL) &amp;&amp; (tp-&gt;offset() == 0) &amp;&amp;
1745          tp-&gt;klass()-&gt;is_instance_klass()  &amp;&amp;
1746          tp-&gt;klass()-&gt;as_instance_klass()-&gt;is_box_klass();
1747 }
1748 
1749 
1750 // ===============================================================
1751 // Things that need to be 64-bits in the 64-bit build but
1752 // 32-bits in the 32-bit build.  Done this way to get full
1753 // optimization AND strong typing.
1754 #ifdef _LP64
1755 
1756 // For type queries and asserts
1757 #define is_intptr_t  is_long
1758 #define isa_intptr_t isa_long
1759 #define find_intptr_t_type find_long_type
1760 #define find_intptr_t_con  find_long_con
1761 #define TypeX        TypeLong
1762 #define Type_X       Type::Long
1763 #define TypeX_X      TypeLong::LONG
1764 #define TypeX_ZERO   TypeLong::ZERO
1765 // For &#39;ideal_reg&#39; machine registers
1766 #define Op_RegX      Op_RegL
1767 // For phase-&gt;intcon variants
1768 #define MakeConX     longcon
1769 #define ConXNode     ConLNode
1770 // For array index arithmetic
1771 #define MulXNode     MulLNode
1772 #define AndXNode     AndLNode
1773 #define OrXNode      OrLNode
1774 #define CmpXNode     CmpLNode
1775 #define SubXNode     SubLNode
1776 #define LShiftXNode  LShiftLNode
1777 // For object size computation:
1778 #define AddXNode     AddLNode
1779 #define RShiftXNode  RShiftLNode
1780 // For card marks and hashcodes
1781 #define URShiftXNode URShiftLNode
1782 // UseOptoBiasInlining
1783 #define XorXNode     XorLNode
1784 #define StoreXConditionalNode StoreLConditionalNode
1785 #define LoadXNode    LoadLNode
1786 #define StoreXNode   StoreLNode
1787 // Opcodes
1788 #define Op_LShiftX   Op_LShiftL
1789 #define Op_AndX      Op_AndL
1790 #define Op_AddX      Op_AddL
1791 #define Op_SubX      Op_SubL
1792 #define Op_XorX      Op_XorL
1793 #define Op_URShiftX  Op_URShiftL
1794 #define Op_LoadX     Op_LoadL
1795 // conversions
1796 #define ConvI2X(x)   ConvI2L(x)
1797 #define ConvL2X(x)   (x)
1798 #define ConvX2I(x)   ConvL2I(x)
1799 #define ConvX2L(x)   (x)
1800 #define ConvX2UL(x)  (x)
1801 
1802 #else
1803 
1804 // For type queries and asserts
1805 #define is_intptr_t  is_int
1806 #define isa_intptr_t isa_int
1807 #define find_intptr_t_type find_int_type
1808 #define find_intptr_t_con  find_int_con
1809 #define TypeX        TypeInt
1810 #define Type_X       Type::Int
1811 #define TypeX_X      TypeInt::INT
1812 #define TypeX_ZERO   TypeInt::ZERO
1813 // For &#39;ideal_reg&#39; machine registers
1814 #define Op_RegX      Op_RegI
1815 // For phase-&gt;intcon variants
1816 #define MakeConX     intcon
1817 #define ConXNode     ConINode
1818 // For array index arithmetic
1819 #define MulXNode     MulINode
1820 #define AndXNode     AndINode
1821 #define OrXNode      OrINode
1822 #define CmpXNode     CmpINode
1823 #define SubXNode     SubINode
1824 #define LShiftXNode  LShiftINode
1825 // For object size computation:
1826 #define AddXNode     AddINode
1827 #define RShiftXNode  RShiftINode
1828 // For card marks and hashcodes
1829 #define URShiftXNode URShiftINode
1830 // UseOptoBiasInlining
1831 #define XorXNode     XorINode
1832 #define StoreXConditionalNode StoreIConditionalNode
1833 #define LoadXNode    LoadINode
1834 #define StoreXNode   StoreINode
1835 // Opcodes
1836 #define Op_LShiftX   Op_LShiftI
1837 #define Op_AndX      Op_AndI
1838 #define Op_AddX      Op_AddI
1839 #define Op_SubX      Op_SubI
1840 #define Op_XorX      Op_XorI
1841 #define Op_URShiftX  Op_URShiftI
1842 #define Op_LoadX     Op_LoadI
1843 // conversions
1844 #define ConvI2X(x)   (x)
1845 #define ConvL2X(x)   ConvL2I(x)
1846 #define ConvX2I(x)   (x)
1847 #define ConvX2L(x)   ConvI2L(x)
1848 #define ConvX2UL(x)  ConvI2UL(x)
1849 
1850 #endif
1851 
1852 #endif // SHARE_OPTO_TYPE_HPP
    </pre>
  </body>
</html>
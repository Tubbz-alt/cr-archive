<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/runtime_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ppc.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/runtime_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 91   // Push a C frame for the exception blob. It is needed for the C call later on.
 92   __ push_frame_reg_args(0, R11_scratch1);
 93 
 94   // This call does all the hard work. It checks if an exception handler
 95   // exists in the method.
 96   // If so, it returns the handler address.
 97   // If not, it prepares for stack-unwinding, restoring the callee-save
 98   // registers of the frame being removed.
 99   __ set_last_Java_frame(/*sp=*/R1_SP, noreg);
100 
101   __ mr(R3_ARG1, R16_thread);
102 #if defined(ABI_ELFv2)
103   __ call_c((address) OptoRuntime::handle_exception_C, relocInfo::none);
104 #else
105   __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, OptoRuntime::handle_exception_C),
106             relocInfo::none);
107 #endif
108   address calls_return_pc = __ last_calls_return_pc();
109 # ifdef ASSERT
110   __ cmpdi(CCR0, R3_RET, 0);
<span class="line-modified">111   __ asm_assert_ne(&quot;handle_exception_C must not return NULL&quot;, 0x601);</span>
112 # endif
113 
114   // Set an oopmap for the call site. This oopmap will only be used if we
115   // are unwinding the stack. Hence, all locations will be dead.
116   // Callee-saved registers will be the same as the frame above (i.e.,
117   // handle_exception_stub), since they were restored when we got the
118   // exception.
119   OopMapSet* oop_maps = new OopMapSet();
120   oop_maps-&gt;add_gc_map(calls_return_pc - start, map);
121 
122   __ mtctr(R3_RET); // Move address of exception handler to SR_CTR.
123   __ reset_last_Java_frame();
124   __ pop_frame();
125 
126   // We have a handler in register SR_CTR (could be deopt blob).
127 
128   // Get the exception oop.
129   __ ld(R3_ARG1, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
130 
131   // Get the exception pc in case we are deoptimized.
</pre>
</td>
<td>
<hr />
<pre>
 91   // Push a C frame for the exception blob. It is needed for the C call later on.
 92   __ push_frame_reg_args(0, R11_scratch1);
 93 
 94   // This call does all the hard work. It checks if an exception handler
 95   // exists in the method.
 96   // If so, it returns the handler address.
 97   // If not, it prepares for stack-unwinding, restoring the callee-save
 98   // registers of the frame being removed.
 99   __ set_last_Java_frame(/*sp=*/R1_SP, noreg);
100 
101   __ mr(R3_ARG1, R16_thread);
102 #if defined(ABI_ELFv2)
103   __ call_c((address) OptoRuntime::handle_exception_C, relocInfo::none);
104 #else
105   __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, OptoRuntime::handle_exception_C),
106             relocInfo::none);
107 #endif
108   address calls_return_pc = __ last_calls_return_pc();
109 # ifdef ASSERT
110   __ cmpdi(CCR0, R3_RET, 0);
<span class="line-modified">111   __ asm_assert_ne(&quot;handle_exception_C must not return NULL&quot;);</span>
112 # endif
113 
114   // Set an oopmap for the call site. This oopmap will only be used if we
115   // are unwinding the stack. Hence, all locations will be dead.
116   // Callee-saved registers will be the same as the frame above (i.e.,
117   // handle_exception_stub), since they were restored when we got the
118   // exception.
119   OopMapSet* oop_maps = new OopMapSet();
120   oop_maps-&gt;add_gc_map(calls_return_pc - start, map);
121 
122   __ mtctr(R3_RET); // Move address of exception handler to SR_CTR.
123   __ reset_last_Java_frame();
124   __ pop_frame();
125 
126   // We have a handler in register SR_CTR (could be deopt blob).
127 
128   // Get the exception oop.
129   __ ld(R3_ARG1, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
130 
131   // Get the exception pc in case we are deoptimized.
</pre>
</td>
</tr>
</table>
<center><a href="ppc.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
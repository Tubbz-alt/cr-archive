<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/methodHandles_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_ppc.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/methodHandles_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
466       __ load_const_optimized(temp1, StubRoutines::throw_IncompatibleClassChangeError_entry());
467       __ mtctr(temp1);
468       __ bctr();
469     }
470   }
471 }
472 
473 #ifndef PRODUCT
474 void trace_method_handle_stub(const char* adaptername,
475                               oopDesc* mh,
476                               intptr_t* entry_sp,
477                               intptr_t* saved_regs) {
478 
479   bool has_mh = (strstr(adaptername, &quot;/static&quot;) == NULL &amp;&amp;
480                  strstr(adaptername, &quot;linkTo&quot;) == NULL);    // static linkers don&#39;t have MH
481   const char* mh_reg_name = has_mh ? &quot;R23_method_handle&quot; : &quot;G23&quot;;
482   tty-&gt;print_cr(&quot;MH %s %s=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT,
483                 adaptername, mh_reg_name, p2i(mh), p2i(entry_sp));
484 
485   if (Verbose) {

486     tty-&gt;print_cr(&quot;Registers:&quot;);
487     const int abi_offset = frame::abi_reg_args_size / 8;
488     for (int i = R3-&gt;encoding(); i &lt;= R12-&gt;encoding(); i++) {
489       Register r = as_Register(i);
490       int count = i - R3-&gt;encoding();
491       // The registers are stored in reverse order on the stack (by save_volatile_gprs(R1_SP, abi_reg_args_size)).
492       tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), saved_regs[abi_offset + count]);
493       if ((count + 1) % 4 == 0) {
494         tty-&gt;cr();
495       } else {
496         tty-&gt;print(&quot;, &quot;);
497       }
498     }
499     tty-&gt;cr();
500 
501     {
502       // dumping last frame with frame::describe
503 
504       JavaThread* p = JavaThread::active();
505 
<span class="line-removed">506       ResourceMark rm;</span>
507       PRESERVE_EXCEPTION_MARK; // may not be needed by safer and unexpensive here
508       FrameValues values;
509 
510       // Note: We want to allow trace_method_handle from any call site.
511       // While trace_method_handle creates a frame, it may be entered
512       // without a PC on the stack top (e.g. not just after a call).
513       // Walking that frame could lead to failures due to that invalid PC.
514       // =&gt; carefully detect that frame when doing the stack walking
515 
516       // Current C frame
517       frame cur_frame = os::current_frame();
518 
519       // Robust search of trace_calling_frame (independant of inlining).
520       assert(cur_frame.sp() &lt;= saved_regs, &quot;registers not saved on stack ?&quot;);
521       frame trace_calling_frame = os::get_sender_for_C_frame(&amp;cur_frame);
522       while (trace_calling_frame.fp() &lt; saved_regs) {
523         trace_calling_frame = os::get_sender_for_C_frame(&amp;trace_calling_frame);
524       }
525 
526       // Safely create a frame and call frame::describe.
527       intptr_t *dump_sp = trace_calling_frame.sender_sp();
528 
529       frame dump_frame = frame(dump_sp);
530       dump_frame.describe(values, 1);
531 
532       values.describe(-1, saved_regs, &quot;raw top of stack&quot;);
533 
534       tty-&gt;print_cr(&quot;Stack layout:&quot;);
535       values.print(p);
536     }
537 
538     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
539       mh-&gt;print();
540       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
<span class="line-modified">541         if (java_lang_invoke_MethodHandle::form_offset_in_bytes() != 0)</span>
542           java_lang_invoke_MethodHandle::form(mh)-&gt;print();

543       }
544     }
545   }
546 }
547 
548 void MethodHandles::trace_method_handle(MacroAssembler* _masm, const char* adaptername) {
549   if (!log_is_enabled(Info, methodhandles)) return;
550 
551   BLOCK_COMMENT(&quot;trace_method_handle {&quot;);
552 
553   const Register tmp = R11; // Will be preserved.
554   const int nbytes_save = MacroAssembler::num_volatile_regs * 8;
555   __ save_volatile_gprs(R1_SP, -nbytes_save); // except R0
556   __ save_LR_CR(tmp); // save in old frame
557 
558   __ mr(R5_ARG3, R1_SP);     // saved_sp
559   __ push_frame_reg_args(nbytes_save, tmp);
560 
561   __ load_const_optimized(R3_ARG1, (address)adaptername, tmp);
562   __ mr(R4_ARG2, R23_method_handle);
</pre>
</td>
<td>
<hr />
<pre>
466       __ load_const_optimized(temp1, StubRoutines::throw_IncompatibleClassChangeError_entry());
467       __ mtctr(temp1);
468       __ bctr();
469     }
470   }
471 }
472 
473 #ifndef PRODUCT
474 void trace_method_handle_stub(const char* adaptername,
475                               oopDesc* mh,
476                               intptr_t* entry_sp,
477                               intptr_t* saved_regs) {
478 
479   bool has_mh = (strstr(adaptername, &quot;/static&quot;) == NULL &amp;&amp;
480                  strstr(adaptername, &quot;linkTo&quot;) == NULL);    // static linkers don&#39;t have MH
481   const char* mh_reg_name = has_mh ? &quot;R23_method_handle&quot; : &quot;G23&quot;;
482   tty-&gt;print_cr(&quot;MH %s %s=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT,
483                 adaptername, mh_reg_name, p2i(mh), p2i(entry_sp));
484 
485   if (Verbose) {
<span class="line-added">486     ResourceMark rm;</span>
487     tty-&gt;print_cr(&quot;Registers:&quot;);
488     const int abi_offset = frame::abi_reg_args_size / 8;
489     for (int i = R3-&gt;encoding(); i &lt;= R12-&gt;encoding(); i++) {
490       Register r = as_Register(i);
491       int count = i - R3-&gt;encoding();
492       // The registers are stored in reverse order on the stack (by save_volatile_gprs(R1_SP, abi_reg_args_size)).
493       tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), saved_regs[abi_offset + count]);
494       if ((count + 1) % 4 == 0) {
495         tty-&gt;cr();
496       } else {
497         tty-&gt;print(&quot;, &quot;);
498       }
499     }
500     tty-&gt;cr();
501 
502     {
503       // dumping last frame with frame::describe
504 
505       JavaThread* p = JavaThread::active();
506 

507       PRESERVE_EXCEPTION_MARK; // may not be needed by safer and unexpensive here
508       FrameValues values;
509 
510       // Note: We want to allow trace_method_handle from any call site.
511       // While trace_method_handle creates a frame, it may be entered
512       // without a PC on the stack top (e.g. not just after a call).
513       // Walking that frame could lead to failures due to that invalid PC.
514       // =&gt; carefully detect that frame when doing the stack walking
515 
516       // Current C frame
517       frame cur_frame = os::current_frame();
518 
519       // Robust search of trace_calling_frame (independant of inlining).
520       assert(cur_frame.sp() &lt;= saved_regs, &quot;registers not saved on stack ?&quot;);
521       frame trace_calling_frame = os::get_sender_for_C_frame(&amp;cur_frame);
522       while (trace_calling_frame.fp() &lt; saved_regs) {
523         trace_calling_frame = os::get_sender_for_C_frame(&amp;trace_calling_frame);
524       }
525 
526       // Safely create a frame and call frame::describe.
527       intptr_t *dump_sp = trace_calling_frame.sender_sp();
528 
529       frame dump_frame = frame(dump_sp);
530       dump_frame.describe(values, 1);
531 
532       values.describe(-1, saved_regs, &quot;raw top of stack&quot;);
533 
534       tty-&gt;print_cr(&quot;Stack layout:&quot;);
535       values.print(p);
536     }
537 
538     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
539       mh-&gt;print();
540       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
<span class="line-modified">541         if (java_lang_invoke_MethodHandle::form_offset_in_bytes() != 0) {</span>
542           java_lang_invoke_MethodHandle::form(mh)-&gt;print();
<span class="line-added">543         }</span>
544       }
545     }
546   }
547 }
548 
549 void MethodHandles::trace_method_handle(MacroAssembler* _masm, const char* adaptername) {
550   if (!log_is_enabled(Info, methodhandles)) return;
551 
552   BLOCK_COMMENT(&quot;trace_method_handle {&quot;);
553 
554   const Register tmp = R11; // Will be preserved.
555   const int nbytes_save = MacroAssembler::num_volatile_regs * 8;
556   __ save_volatile_gprs(R1_SP, -nbytes_save); // except R0
557   __ save_LR_CR(tmp); // save in old frame
558 
559   __ mr(R5_ARG3, R1_SP);     // saved_sp
560   __ push_frame_reg_args(nbytes_save, tmp);
561 
562   __ load_const_optimized(R3_ARG1, (address)adaptername, tmp);
563   __ mr(R4_ARG2, R23_method_handle);
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_ppc.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
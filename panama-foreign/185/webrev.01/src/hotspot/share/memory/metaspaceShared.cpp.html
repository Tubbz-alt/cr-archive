<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/memory/metaspaceShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classListParser.hpp&quot;
  29 #include &quot;classfile/classLoaderExt.hpp&quot;
  30 #include &quot;classfile/dictionary.hpp&quot;
  31 #include &quot;classfile/loaderConstraints.hpp&quot;
  32 #include &quot;classfile/javaClasses.inline.hpp&quot;
  33 #include &quot;classfile/placeholders.hpp&quot;
  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;classfile/stringTable.hpp&quot;
  36 #include &quot;classfile/systemDictionary.hpp&quot;
  37 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  38 #include &quot;code/codeCache.hpp&quot;
  39 #include &quot;gc/shared/softRefPolicy.hpp&quot;
  40 #include &quot;interpreter/bytecodeStream.hpp&quot;
  41 #include &quot;interpreter/bytecodes.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logMessage.hpp&quot;
  44 #include &quot;memory/archiveUtils.inline.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;memory/heapShared.inline.hpp&quot;
  48 #include &quot;memory/metaspace.hpp&quot;
  49 #include &quot;memory/metaspaceClosure.hpp&quot;
  50 #include &quot;memory/metaspaceShared.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
  52 #include &quot;memory/universe.hpp&quot;
  53 #include &quot;oops/compressedOops.inline.hpp&quot;
  54 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  55 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  56 #include &quot;oops/instanceRefKlass.hpp&quot;
  57 #include &quot;oops/methodData.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;oops/typeArrayKlass.hpp&quot;
  62 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  63 #include &quot;runtime/handles.inline.hpp&quot;
  64 #include &quot;runtime/os.hpp&quot;
  65 #include &quot;runtime/safepointVerifiers.hpp&quot;
  66 #include &quot;runtime/signature.hpp&quot;
  67 #include &quot;runtime/timerTrace.hpp&quot;
  68 #include &quot;runtime/vmThread.hpp&quot;
  69 #include &quot;runtime/vmOperations.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/bitMap.inline.hpp&quot;
  72 #include &quot;utilities/ostream.hpp&quot;
  73 #include &quot;utilities/defaultStream.hpp&quot;
  74 #include &quot;utilities/hashtable.inline.hpp&quot;
  75 #if INCLUDE_G1GC
  76 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  77 #endif
  78 
  79 ReservedSpace MetaspaceShared::_shared_rs;
  80 VirtualSpace MetaspaceShared::_shared_vs;
  81 ReservedSpace MetaspaceShared::_symbol_rs;
  82 VirtualSpace MetaspaceShared::_symbol_vs;
  83 MetaspaceSharedStats MetaspaceShared::_stats;
  84 bool MetaspaceShared::_has_error_classes;
  85 bool MetaspaceShared::_archive_loading_failed = false;
  86 bool MetaspaceShared::_remapped_readwrite = false;
  87 address MetaspaceShared::_i2i_entry_code_buffers = NULL;
  88 size_t MetaspaceShared::_i2i_entry_code_buffers_size = 0;
  89 void* MetaspaceShared::_shared_metaspace_static_top = NULL;
  90 intx MetaspaceShared::_relocation_delta;
  91 
  92 // The CDS archive is divided into the following regions:
  93 //     mc  - misc code (the method entry trampolines, c++ vtables)
  94 //     rw  - read-write metadata
  95 //     ro  - read-only metadata and read-only tables
  96 //
  97 //     ca0 - closed archive heap space #0
  98 //     ca1 - closed archive heap space #1 (may be empty)
  99 //     oa0 - open archive heap space #0
 100 //     oa1 - open archive heap space #1 (may be empty)
 101 //
 102 // The mc, rw, and ro regions are linearly allocated, starting from
 103 // SharedBaseAddress, in the order of mc-&gt;rw-&gt;ro. The size of these 3 regions
 104 // are page-aligned, and there&#39;s no gap between any consecutive regions.
 105 //
 106 // These 3 regions are populated in the following steps:
 107 // [1] All classes are loaded in MetaspaceShared::preload_classes(). All metadata are
 108 //     temporarily allocated outside of the shared regions. Only the method entry
 109 //     trampolines are written into the mc region.
 110 // [2] C++ vtables are copied into the mc region.
 111 // [3] ArchiveCompactor copies RW metadata into the rw region.
 112 // [4] ArchiveCompactor copies RO metadata into the ro region.
 113 // [5] SymbolTable, StringTable, SystemDictionary, and a few other read-only data
 114 //     are copied into the ro region as read-only tables.
 115 //
 116 // The s0/s1 and oa0/oa1 regions are populated inside HeapShared::archive_java_heap_objects.
 117 // Their layout is independent of the other 4 regions.
 118 
 119 char* DumpRegion::expand_top_to(char* newtop) {
 120   assert(is_allocatable(), &quot;must be initialized and not packed&quot;);
 121   assert(newtop &gt;= _top, &quot;must not grow backwards&quot;);
 122   if (newtop &gt; _end) {
 123     MetaspaceShared::report_out_of_space(_name, newtop - _top);
 124     ShouldNotReachHere();
 125   }
 126 
 127   if (_rs == MetaspaceShared::shared_rs()) {
 128     uintx delta;
 129     if (DynamicDumpSharedSpaces) {
 130       delta = DynamicArchive::object_delta_uintx(newtop);
 131     } else {
 132       delta = MetaspaceShared::object_delta_uintx(newtop);
 133     }
 134     if (delta &gt; MAX_SHARED_DELTA) {
 135       // This is just a sanity check and should not appear in any real world usage. This
 136       // happens only if you allocate more than 2GB of shared objects and would require
 137       // millions of shared classes.
 138       vm_exit_during_initialization(&quot;Out of memory in the CDS archive&quot;,
 139                                     &quot;Please reduce the number of shared classes.&quot;);
 140     }
 141   }
 142 
 143   MetaspaceShared::commit_to(_rs, _vs, newtop);
 144   _top = newtop;
 145   return _top;
 146 }
 147 
 148 char* DumpRegion::allocate(size_t num_bytes, size_t alignment) {
 149   char* p = (char*)align_up(_top, alignment);
 150   char* newtop = p + align_up(num_bytes, alignment);
 151   expand_top_to(newtop);
 152   memset(p, 0, newtop - p);
 153   return p;
 154 }
 155 
 156 void DumpRegion::append_intptr_t(intptr_t n, bool need_to_mark) {
 157   assert(is_aligned(_top, sizeof(intptr_t)), &quot;bad alignment&quot;);
 158   intptr_t *p = (intptr_t*)_top;
 159   char* newtop = _top + sizeof(intptr_t);
 160   expand_top_to(newtop);
 161   *p = n;
 162   if (need_to_mark) {
 163     ArchivePtrMarker::mark_pointer(p);
 164   }
 165 }
 166 
 167 void DumpRegion::print(size_t total_bytes) const {
 168   log_debug(cds)(&quot;%-3s space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used] at &quot; INTPTR_FORMAT,
 169                  _name, used(), percent_of(used(), total_bytes), reserved(), percent_of(used(), reserved()),
 170                  p2i(_base + MetaspaceShared::final_delta()));
 171 }
 172 
 173 void DumpRegion::print_out_of_space_msg(const char* failing_region, size_t needed_bytes) {
 174   log_error(cds)(&quot;[%-8s] &quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot; capacity =%9d, allocated =%9d&quot;,
 175                  _name, p2i(_base), p2i(_top), int(_end - _base), int(_top - _base));
 176   if (strcmp(_name, failing_region) == 0) {
 177     log_error(cds)(&quot; required = %d&quot;, int(needed_bytes));
 178   }
 179 }
 180 
 181 void DumpRegion::init(ReservedSpace* rs, VirtualSpace* vs) {
 182   _rs = rs;
 183   _vs = vs;
 184   // Start with 0 committed bytes. The memory will be committed as needed by
 185   // MetaspaceShared::commit_to().
 186   if (!_vs-&gt;initialize(*_rs, 0)) {
 187     fatal(&quot;Unable to allocate memory for shared space&quot;);
 188   }
 189   _base = _top = _rs-&gt;base();
 190   _end = _rs-&gt;end();
 191 }
 192 
 193 void DumpRegion::pack(DumpRegion* next) {
 194   assert(!is_packed(), &quot;sanity&quot;);
 195   _end = (char*)align_up(_top, MetaspaceShared::reserved_space_alignment());
 196   _is_packed = true;
 197   if (next != NULL) {
 198     next-&gt;_rs = _rs;
 199     next-&gt;_vs = _vs;
 200     next-&gt;_base = next-&gt;_top = this-&gt;_end;
 201     next-&gt;_end = _rs-&gt;end();
 202   }
 203 }
 204 
 205 static DumpRegion _mc_region(&quot;mc&quot;), _ro_region(&quot;ro&quot;), _rw_region(&quot;rw&quot;), _symbol_region(&quot;symbols&quot;);
 206 static size_t _total_closed_archive_region_size = 0, _total_open_archive_region_size = 0;
 207 
 208 void MetaspaceShared::init_shared_dump_space(DumpRegion* first_space) {
 209   first_space-&gt;init(&amp;_shared_rs, &amp;_shared_vs);
 210 }
 211 
 212 DumpRegion* MetaspaceShared::misc_code_dump_space() {
 213   return &amp;_mc_region;
 214 }
 215 
 216 DumpRegion* MetaspaceShared::read_write_dump_space() {
 217   return &amp;_rw_region;
 218 }
 219 
 220 DumpRegion* MetaspaceShared::read_only_dump_space() {
 221   return &amp;_ro_region;
 222 }
 223 
 224 void MetaspaceShared::pack_dump_space(DumpRegion* current, DumpRegion* next,
 225                                       ReservedSpace* rs) {
 226   current-&gt;pack(next);
 227 }
 228 
 229 char* MetaspaceShared::symbol_space_alloc(size_t num_bytes) {
 230   return _symbol_region.allocate(num_bytes);
 231 }
 232 
 233 char* MetaspaceShared::misc_code_space_alloc(size_t num_bytes) {
 234   return _mc_region.allocate(num_bytes);
 235 }
 236 
 237 char* MetaspaceShared::read_only_space_alloc(size_t num_bytes) {
 238   return _ro_region.allocate(num_bytes);
 239 }
 240 
 241 size_t MetaspaceShared::reserved_space_alignment() { return os::vm_allocation_granularity(); }
 242 
 243 #ifdef _LP64
 244 // Check SharedBaseAddress for validity. At this point, os::init() must
 245 //  have been ran.
 246 static void check_SharedBaseAddress() {
 247   SharedBaseAddress = align_up(SharedBaseAddress,
 248                                MetaspaceShared::reserved_space_alignment());
 249   if (!CompressedKlassPointers::is_valid_base((address)SharedBaseAddress)) {
 250     log_warning(cds)(&quot;SharedBaseAddress=&quot; PTR_FORMAT &quot; is invalid for this &quot;
 251                      &quot;platform, option will be ignored.&quot;,
 252                      p2i((address)SharedBaseAddress));
 253     SharedBaseAddress = Arguments::default_SharedBaseAddress();
 254   }
 255 }
 256 #endif
 257 
 258 void MetaspaceShared::initialize_dumptime_shared_and_meta_spaces() {
 259   assert(DumpSharedSpaces, &quot;should be called for dump time only&quot;);
 260 
 261 #ifdef _LP64
 262   check_SharedBaseAddress();
 263 #endif
 264 
 265   const size_t reserve_alignment = MetaspaceShared::reserved_space_alignment();
 266   char* shared_base = (char*)align_up((char*)SharedBaseAddress, reserve_alignment);
 267 
 268 #ifdef _LP64
 269   assert(CompressedKlassPointers::is_valid_base((address)shared_base), &quot;Sanity&quot;);
 270   // On 64-bit VM we reserve a 4G range and, if UseCompressedClassPointers=1,
 271   //  will use that to house both the archives and the ccs. See below for
 272   //  details.
 273   const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);
 274   const size_t cds_total = align_down(UnscaledClassSpaceMax, reserve_alignment);
 275 #else
 276   // We don&#39;t support archives larger than 256MB on 32-bit due to limited
 277   //  virtual address space.
 278   size_t cds_total = align_down(256*M, reserve_alignment);
 279 #endif
 280 
 281   // Whether to use SharedBaseAddress as attach address.
 282   bool use_requested_base = true;
 283 
 284   if (shared_base == NULL) {
 285     use_requested_base = false;
 286   }
 287 
 288   if (ArchiveRelocationMode == 1) {
 289     log_info(cds)(&quot;ArchiveRelocationMode == 1: always allocate class space at an alternative address&quot;);
 290     use_requested_base = false;
 291   }
 292 
 293   // First try to reserve the space at the specified SharedBaseAddress.
 294   assert(!_shared_rs.is_reserved(), &quot;must be&quot;);
 295   if (use_requested_base) {
 296     _shared_rs = ReservedSpace(cds_total, reserve_alignment,
 297                                false /* large */, (char*)shared_base);
 298     if (_shared_rs.is_reserved()) {
 299       assert(_shared_rs.base() == shared_base, &quot;should match&quot;);
 300     } else {
 301       log_info(cds)(&quot;dumptime space reservation: failed to map at &quot;
 302                     &quot;SharedBaseAddress &quot; PTR_FORMAT, p2i(shared_base));
 303     }
 304   }
 305   if (!_shared_rs.is_reserved()) {
 306     // Get a reserved space anywhere if attaching at the SharedBaseAddress
 307     //  fails:
 308     if (UseCompressedClassPointers) {
 309       // If we need to reserve class space as well, let the platform handle
 310       //  the reservation.
 311       LP64_ONLY(_shared_rs =
 312                 Metaspace::reserve_address_space_for_compressed_classes(cds_total);)
 313       NOT_LP64(ShouldNotReachHere();)
 314     } else {
 315       // anywhere is fine.
 316       _shared_rs = ReservedSpace(cds_total, reserve_alignment,
 317                                  false /* large */, (char*)NULL);
 318     }
 319   }
 320 
 321   if (!_shared_rs.is_reserved()) {
 322     vm_exit_during_initialization(&quot;Unable to reserve memory for shared space&quot;,
 323                                   err_msg(SIZE_FORMAT &quot; bytes.&quot;, cds_total));
 324   }
 325 
 326 #ifdef _LP64
 327 
 328   if (UseCompressedClassPointers) {
 329 
 330     assert(CompressedKlassPointers::is_valid_base((address)_shared_rs.base()), &quot;Sanity&quot;);
 331 
 332     // On 64-bit VM, if UseCompressedClassPointers=1, the compressed class space
 333     //  must be allocated near the cds such as that the compressed Klass pointer
 334     //  encoding can be used to en/decode pointers from both cds and ccs. Since
 335     //  Metaspace cannot do this (it knows nothing about cds), we do it for
 336     //  Metaspace here and pass it the space to use for ccs.
 337     //
 338     // We do this by reserving space for the ccs behind the archives. Note
 339     //  however that ccs follows a different alignment
 340     //  (Metaspace::reserve_alignment), so there may be a gap between ccs and
 341     //  cds.
 342     // We use a similar layout at runtime, see reserve_address_space_for_archives().
 343     //
 344     //                              +-- SharedBaseAddress (default = 0x800000000)
 345     //                              v
 346     // +-..---------+---------+ ... +----+----+----+--------+-----------------+
 347     // |    Heap    | Archive |     | MC | RW | RO | [gap]  |    class space  |
 348     // +-..---------+---------+ ... +----+----+----+--------+-----------------+
 349     // |&lt;--   MaxHeapSize  --&gt;|     |&lt;-- UnscaledClassSpaceMax = 4GB --&gt;|
 350     //
 351     // Note: ccs must follow the archives, and the archives must start at the
 352     //  encoding base. However, the exact placement of ccs does not matter as
 353     //  long as it it resides in the encoding range of CompressedKlassPointers
 354     //  and comes after the archive.
 355     //
 356     // We do this by splitting up the allocated 4G into 3G of archive space,
 357     //  followed by 1G for the ccs:
 358     // + The upper 1 GB is used as the &quot;temporary compressed class space&quot;
 359     //   -- preload_classes() will store Klasses into this space.
 360     // + The lower 3 GB is used for the archive -- when preload_classes()
 361     //   is done, ArchiveCompactor will copy the class metadata into this
 362     //   space, first the RW parts, then the RO parts.
 363 
 364     // Starting address of ccs must be aligned to Metaspace::reserve_alignment()...
 365     size_t class_space_size = align_down(_shared_rs.size() / 4, Metaspace::reserve_alignment());
 366     address class_space_start = (address)align_down(_shared_rs.end() - class_space_size, Metaspace::reserve_alignment());
 367     size_t archive_size = class_space_start - (address)_shared_rs.base();
 368 
 369     ReservedSpace tmp_class_space = _shared_rs.last_part(archive_size);
 370     _shared_rs = _shared_rs.first_part(archive_size);
 371 
 372     // ... as does the size of ccs.
 373     tmp_class_space = tmp_class_space.first_part(class_space_size);
 374     CompressedClassSpaceSize = class_space_size;
 375 
 376     // Let Metaspace initialize ccs
 377     Metaspace::initialize_class_space(tmp_class_space);
 378 
 379     // and set up CompressedKlassPointers encoding.
 380     CompressedKlassPointers::initialize((address)_shared_rs.base(), cds_total);
 381 
 382     log_info(cds)(&quot;narrow_klass_base = &quot; PTR_FORMAT &quot;, narrow_klass_shift = %d&quot;,
 383                   p2i(CompressedKlassPointers::base()), CompressedKlassPointers::shift());
 384 
 385     log_info(cds)(&quot;Allocated temporary class space: &quot; SIZE_FORMAT &quot; bytes at &quot; PTR_FORMAT,
 386                   CompressedClassSpaceSize, p2i(tmp_class_space.base()));
 387 
 388     assert(_shared_rs.end() == tmp_class_space.base() &amp;&amp;
 389            is_aligned(_shared_rs.base(), MetaspaceShared::reserved_space_alignment()) &amp;&amp;
 390            is_aligned(tmp_class_space.base(), Metaspace::reserve_alignment()) &amp;&amp;
 391            is_aligned(tmp_class_space.size(), Metaspace::reserve_alignment()), &quot;Sanity&quot;);
 392   }
 393 
 394 #endif
 395 
 396   init_shared_dump_space(&amp;_mc_region);
 397   SharedBaseAddress = (size_t)_shared_rs.base();
 398   log_info(cds)(&quot;Allocated shared space: &quot; SIZE_FORMAT &quot; bytes at &quot; PTR_FORMAT,
 399                 _shared_rs.size(), p2i(_shared_rs.base()));
 400 
 401   size_t symbol_rs_size = LP64_ONLY(3 * G) NOT_LP64(128 * M);
 402   _symbol_rs = ReservedSpace(symbol_rs_size);
 403   if (!_symbol_rs.is_reserved()) {
 404     vm_exit_during_initialization(&quot;Unable to reserve memory for symbols&quot;,
 405                                   err_msg(SIZE_FORMAT &quot; bytes.&quot;, symbol_rs_size));
 406   }
 407   _symbol_region.init(&amp;_symbol_rs, &amp;_symbol_vs);
 408 }
 409 
 410 // Called by universe_post_init()
 411 void MetaspaceShared::post_initialize(TRAPS) {
 412   if (UseSharedSpaces) {
 413     int size = FileMapInfo::get_number_of_shared_paths();
 414     if (size &gt; 0) {
 415       SystemDictionaryShared::allocate_shared_data_arrays(size, THREAD);
 416       if (!DynamicDumpSharedSpaces) {
 417         FileMapInfo* info;
 418         if (FileMapInfo::dynamic_info() == NULL) {
 419           info = FileMapInfo::current_info();
 420         } else {
 421           info = FileMapInfo::dynamic_info();
 422         }
 423         ClassLoaderExt::init_paths_start_index(info-&gt;app_class_paths_start_index());
 424         ClassLoaderExt::init_app_module_paths_start_index(info-&gt;app_module_paths_start_index());
 425       }
 426     }
 427   }
 428 }
 429 
 430 static GrowableArray&lt;Handle&gt;* _extra_interned_strings = NULL;
 431 
 432 void MetaspaceShared::read_extra_data(const char* filename, TRAPS) {
 433   _extra_interned_strings = new (ResourceObj::C_HEAP, mtInternal)GrowableArray&lt;Handle&gt;(10000, true);
 434 
 435   HashtableTextDump reader(filename);
 436   reader.check_version(&quot;VERSION: 1.0&quot;);
 437 
 438   while (reader.remain() &gt; 0) {
 439     int utf8_length;
 440     int prefix_type = reader.scan_prefix(&amp;utf8_length);
 441     ResourceMark rm(THREAD);
 442     if (utf8_length == 0x7fffffff) {
 443       // buf_len will overflown 32-bit value.
 444       vm_exit_during_initialization(err_msg(&quot;string length too large: %d&quot;, utf8_length));
 445     }
 446     int buf_len = utf8_length+1;
 447     char* utf8_buffer = NEW_RESOURCE_ARRAY(char, buf_len);
 448     reader.get_utf8(utf8_buffer, utf8_length);
 449     utf8_buffer[utf8_length] = &#39;\0&#39;;
 450 
 451     if (prefix_type == HashtableTextDump::SymbolPrefix) {
 452       SymbolTable::new_permanent_symbol(utf8_buffer);
 453     } else{
 454       assert(prefix_type == HashtableTextDump::StringPrefix, &quot;Sanity&quot;);
 455       oop s = StringTable::intern(utf8_buffer, THREAD);
 456 
 457       if (HAS_PENDING_EXCEPTION) {
 458         log_warning(cds, heap)(&quot;[line %d] extra interned string allocation failed; size too large: %d&quot;,
 459                                reader.last_line_no(), utf8_length);
 460         CLEAR_PENDING_EXCEPTION;
 461       } else {
 462 #if INCLUDE_G1GC
 463         if (UseG1GC) {
 464           typeArrayOop body = java_lang_String::value(s);
 465           const HeapRegion* hr = G1CollectedHeap::heap()-&gt;heap_region_containing(body);
 466           if (hr-&gt;is_humongous()) {
 467             // Don&#39;t keep it alive, so it will be GC&#39;ed before we dump the strings, in order
 468             // to maximize free heap space and minimize fragmentation.
 469             log_warning(cds, heap)(&quot;[line %d] extra interned string ignored; size too large: %d&quot;,
 470                                 reader.last_line_no(), utf8_length);
 471             continue;
 472           }
 473         }
 474 #endif
 475         // Interned strings are GC&#39;ed if there are no references to it, so let&#39;s
 476         // add a reference to keep this string alive.
 477         assert(s != NULL, &quot;must succeed&quot;);
 478         Handle h(THREAD, s);
 479         _extra_interned_strings-&gt;append(h);
 480       }
 481     }
 482   }
 483 }
 484 
 485 void MetaspaceShared::commit_to(ReservedSpace* rs, VirtualSpace* vs, char* newtop) {
 486   Arguments::assert_is_dumping_archive();
 487   char* base = rs-&gt;base();
 488   size_t need_committed_size = newtop - base;
 489   size_t has_committed_size = vs-&gt;committed_size();
 490   if (need_committed_size &lt; has_committed_size) {
 491     return;
 492   }
 493 
 494   size_t min_bytes = need_committed_size - has_committed_size;
 495   size_t preferred_bytes = 1 * M;
 496   size_t uncommitted = vs-&gt;reserved_size() - has_committed_size;
 497 
 498   size_t commit =MAX2(min_bytes, preferred_bytes);
 499   commit = MIN2(commit, uncommitted);
 500   assert(commit &lt;= uncommitted, &quot;sanity&quot;);
 501 
 502   bool result = vs-&gt;expand_by(commit, false);
 503   if (rs == &amp;_shared_rs) {
 504     ArchivePtrMarker::expand_ptr_end((address*)vs-&gt;high());
 505   }
 506 
 507   if (!result) {
 508     vm_exit_during_initialization(err_msg(&quot;Failed to expand shared space to &quot; SIZE_FORMAT &quot; bytes&quot;,
 509                                           need_committed_size));
 510   }
 511 
 512   assert(rs == &amp;_shared_rs || rs == &amp;_symbol_rs, &quot;must be&quot;);
 513   const char* which = (rs == &amp;_shared_rs) ? &quot;shared&quot; : &quot;symbol&quot;;
 514   log_debug(cds)(&quot;Expanding %s spaces by &quot; SIZE_FORMAT_W(7) &quot; bytes [total &quot; SIZE_FORMAT_W(9)  &quot; bytes ending at %p]&quot;,
 515                  which, commit, vs-&gt;actual_committed_size(), vs-&gt;high());
 516 }
 517 
 518 void MetaspaceShared::initialize_ptr_marker(CHeapBitMap* ptrmap) {
 519   ArchivePtrMarker::initialize(ptrmap, (address*)_shared_vs.low(), (address*)_shared_vs.high());
 520 }
 521 
 522 // Read/write a data stream for restoring/preserving metadata pointers and
 523 // miscellaneous data from/to the shared archive file.
 524 
 525 void MetaspaceShared::serialize(SerializeClosure* soc) {
 526   int tag = 0;
 527   soc-&gt;do_tag(--tag);
 528 
 529   // Verify the sizes of various metadata in the system.
 530   soc-&gt;do_tag(sizeof(Method));
 531   soc-&gt;do_tag(sizeof(ConstMethod));
 532   soc-&gt;do_tag(arrayOopDesc::base_offset_in_bytes(T_BYTE));
 533   soc-&gt;do_tag(sizeof(ConstantPool));
 534   soc-&gt;do_tag(sizeof(ConstantPoolCache));
 535   soc-&gt;do_tag(objArrayOopDesc::base_offset_in_bytes());
 536   soc-&gt;do_tag(typeArrayOopDesc::base_offset_in_bytes(T_BYTE));
 537   soc-&gt;do_tag(sizeof(Symbol));
 538 
 539   // Dump/restore miscellaneous metadata.
 540   JavaClasses::serialize_offsets(soc);
 541   Universe::serialize(soc);
 542   soc-&gt;do_tag(--tag);
 543 
 544   // Dump/restore references to commonly used names and signatures.
 545   vmSymbols::serialize(soc);
 546   soc-&gt;do_tag(--tag);
 547 
 548   // Dump/restore the symbol/string/subgraph_info tables
 549   SymbolTable::serialize_shared_table_header(soc);
 550   StringTable::serialize_shared_table_header(soc);
 551   HeapShared::serialize_subgraph_info_table_header(soc);
 552   SystemDictionaryShared::serialize_dictionary_headers(soc);
 553 
 554   InstanceMirrorKlass::serialize_offsets(soc);
 555 
 556   // Dump/restore well known classes (pointers)
 557   SystemDictionaryShared::serialize_well_known_klasses(soc);
 558   soc-&gt;do_tag(--tag);
 559 
 560   serialize_cloned_cpp_vtptrs(soc);
 561   soc-&gt;do_tag(--tag);
 562 
 563   soc-&gt;do_tag(666);
 564 }
 565 
 566 address MetaspaceShared::i2i_entry_code_buffers(size_t total_size) {
 567   if (DumpSharedSpaces) {
 568     if (_i2i_entry_code_buffers == NULL) {
 569       _i2i_entry_code_buffers = (address)misc_code_space_alloc(total_size);
 570       _i2i_entry_code_buffers_size = total_size;
 571     }
 572   } else if (UseSharedSpaces) {
 573     assert(_i2i_entry_code_buffers != NULL, &quot;must already been initialized&quot;);
 574   } else {
 575     return NULL;
 576   }
 577 
 578   assert(_i2i_entry_code_buffers_size == total_size, &quot;must not change&quot;);
 579   return _i2i_entry_code_buffers;
 580 }
 581 
 582 uintx MetaspaceShared::object_delta_uintx(void* obj) {
 583   Arguments::assert_is_dumping_archive();
 584   if (DumpSharedSpaces) {
 585     assert(shared_rs()-&gt;contains(obj), &quot;must be&quot;);
 586   } else {
 587     assert(is_in_shared_metaspace(obj) || DynamicArchive::is_in_target_space(obj), &quot;must be&quot;);
 588   }
 589   address base_address = address(SharedBaseAddress);
 590   uintx deltax = address(obj) - base_address;
 591   return deltax;
 592 }
 593 
 594 // Global object for holding classes that have been loaded.  Since this
 595 // is run at a safepoint just before exit, this is the entire set of classes.
 596 static GrowableArray&lt;Klass*&gt;* _global_klass_objects;
 597 
 598 static int global_klass_compare(Klass** a, Klass **b) {
 599   return a[0]-&gt;name()-&gt;fast_compare(b[0]-&gt;name());
 600 }
 601 
 602 GrowableArray&lt;Klass*&gt;* MetaspaceShared::collected_klasses() {
 603   return _global_klass_objects;
 604 }
 605 
 606 static void collect_array_classes(Klass* k) {
 607   _global_klass_objects-&gt;append_if_missing(k);
 608   if (k-&gt;is_array_klass()) {
 609     // Add in the array classes too
 610     ArrayKlass* ak = ArrayKlass::cast(k);
 611     Klass* h = ak-&gt;higher_dimension();
 612     if (h != NULL) {
 613       h-&gt;array_klasses_do(collect_array_classes);
 614     }
 615   }
 616 }
 617 
 618 class CollectClassesClosure : public KlassClosure {
 619   void do_klass(Klass* k) {
 620     if (k-&gt;is_instance_klass() &amp;&amp;
 621         SystemDictionaryShared::is_excluded_class(InstanceKlass::cast(k))) {
 622       // Don&#39;t add to the _global_klass_objects
 623     } else {
 624       _global_klass_objects-&gt;append_if_missing(k);
 625     }
 626     if (k-&gt;is_array_klass()) {
 627       // Add in the array classes too
 628       ArrayKlass* ak = ArrayKlass::cast(k);
 629       Klass* h = ak-&gt;higher_dimension();
 630       if (h != NULL) {
 631         h-&gt;array_klasses_do(collect_array_classes);
 632       }
 633     }
 634   }
 635 };
 636 
 637 static void remove_unshareable_in_classes() {
 638   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 639     Klass* k = _global_klass_objects-&gt;at(i);
 640     if (!k-&gt;is_objArray_klass()) {
 641       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 642       // on their array classes.
 643       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 644       k-&gt;remove_unshareable_info();
 645     }
 646   }
 647 }
 648 
 649 static void remove_java_mirror_in_classes() {
 650   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 651     Klass* k = _global_klass_objects-&gt;at(i);
 652     if (!k-&gt;is_objArray_klass()) {
 653       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 654       // on their array classes.
 655       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 656       k-&gt;remove_java_mirror();
 657     }
 658   }
 659 }
 660 
 661 static void clear_basic_type_mirrors() {
 662   assert(!HeapShared::is_heap_object_archiving_allowed(), &quot;Sanity&quot;);
 663   Universe::set_int_mirror(NULL);
 664   Universe::set_float_mirror(NULL);
 665   Universe::set_double_mirror(NULL);
 666   Universe::set_byte_mirror(NULL);
 667   Universe::set_bool_mirror(NULL);
 668   Universe::set_char_mirror(NULL);
 669   Universe::set_long_mirror(NULL);
 670   Universe::set_short_mirror(NULL);
 671   Universe::set_void_mirror(NULL);
 672 }
 673 
 674 static void rewrite_nofast_bytecode(const methodHandle&amp; method) {
 675   BytecodeStream bcs(method);
 676   while (!bcs.is_last_bytecode()) {
 677     Bytecodes::Code opcode = bcs.next();
 678     switch (opcode) {
 679     case Bytecodes::_getfield:      *bcs.bcp() = Bytecodes::_nofast_getfield;      break;
 680     case Bytecodes::_putfield:      *bcs.bcp() = Bytecodes::_nofast_putfield;      break;
 681     case Bytecodes::_aload_0:       *bcs.bcp() = Bytecodes::_nofast_aload_0;       break;
 682     case Bytecodes::_iload: {
 683       if (!bcs.is_wide()) {
 684         *bcs.bcp() = Bytecodes::_nofast_iload;
 685       }
 686       break;
 687     }
 688     default: break;
 689     }
 690   }
 691 }
 692 
 693 // Walk all methods in the class list to ensure that they won&#39;t be modified at
 694 // run time. This includes:
 695 // [1] Rewrite all bytecodes as needed, so that the ConstMethod* will not be modified
 696 //     at run time by RewriteBytecodes/RewriteFrequentPairs
 697 // [2] Assign a fingerprint, so one doesn&#39;t need to be assigned at run-time.
 698 static void rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread) {
 699   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 700     Klass* k = _global_klass_objects-&gt;at(i);
 701     if (k-&gt;is_instance_klass()) {
 702       InstanceKlass* ik = InstanceKlass::cast(k);
 703       MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(thread, ik);
 704     }
 705   }
 706 }
 707 
 708 void MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik) {
 709   for (int i = 0; i &lt; ik-&gt;methods()-&gt;length(); i++) {
 710     methodHandle m(thread, ik-&gt;methods()-&gt;at(i));
 711     rewrite_nofast_bytecode(m);
 712     Fingerprinter fp(m);
 713     // The side effect of this call sets method&#39;s fingerprint field.
 714     fp.fingerprint();
 715   }
 716 }
 717 
 718 // Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.
 719 // (In GCC this is the field &lt;Type&gt;::_vptr, i.e., first word in the object.)
 720 //
 721 // Addresses of the vtables and the methods may be different across JVM runs,
 722 // if libjvm.so is dynamically loaded at a different base address.
 723 //
 724 // To ensure that the Metadata objects in the CDS archive always have the correct vtable:
 725 //
 726 // + at dump time:  we redirect the _vptr to point to our own vtables inside
 727 //                  the CDS image
 728 // + at run time:   we clone the actual contents of the vtables from libjvm.so
 729 //                  into our own tables.
 730 
 731 // Currently, the archive contain ONLY the following types of objects that have C++ vtables.
 732 #define CPP_VTABLE_PATCH_TYPES_DO(f) \
 733   f(ConstantPool) \
 734   f(InstanceKlass) \
 735   f(InstanceClassLoaderKlass) \
 736   f(InstanceMirrorKlass) \
 737   f(InstanceRefKlass) \
 738   f(Method) \
 739   f(ObjArrayKlass) \
 740   f(TypeArrayKlass)
 741 
 742 class CppVtableInfo {
 743   intptr_t _vtable_size;
 744   intptr_t _cloned_vtable[1];
 745 public:
 746   static int num_slots(int vtable_size) {
 747     return 1 + vtable_size; // Need to add the space occupied by _vtable_size;
 748   }
 749   int vtable_size()           { return int(uintx(_vtable_size)); }
 750   void set_vtable_size(int n) { _vtable_size = intptr_t(n); }
 751   intptr_t* cloned_vtable()   { return &amp;_cloned_vtable[0]; }
 752   void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }
 753   // Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo
 754   static size_t byte_size(int vtable_size) {
 755     CppVtableInfo i;
 756     return pointer_delta(&amp;i._cloned_vtable[vtable_size], &amp;i, sizeof(u1));
 757   }
 758 };
 759 
 760 template &lt;class T&gt; class CppVtableCloner : public T {
 761   static intptr_t* vtable_of(Metadata&amp; m) {
 762     return *((intptr_t**)&amp;m);
 763   }
 764   static CppVtableInfo* _info;
 765 
 766   static int get_vtable_length(const char* name);
 767 
 768 public:
 769   // Allocate and initialize the C++ vtable, starting from top, but do not go past end.
 770   static intptr_t* allocate(const char* name);
 771 
 772   // Clone the vtable to ...
 773   static intptr_t* clone_vtable(const char* name, CppVtableInfo* info);
 774 
 775   static void zero_vtable_clone() {
 776     assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 777     _info-&gt;zero();
 778   }
 779 
 780   static bool is_valid_shared_object(const T* obj) {
 781     intptr_t* vptr = *(intptr_t**)obj;
 782     return vptr == _info-&gt;cloned_vtable();
 783   }
 784 };
 785 
 786 template &lt;class T&gt; CppVtableInfo* CppVtableCloner&lt;T&gt;::_info = NULL;
 787 
 788 template &lt;class T&gt;
 789 intptr_t* CppVtableCloner&lt;T&gt;::allocate(const char* name) {
 790   assert(is_aligned(_mc_region.top(), sizeof(intptr_t)), &quot;bad alignment&quot;);
 791   int n = get_vtable_length(name);
 792   _info = (CppVtableInfo*)_mc_region.allocate(CppVtableInfo::byte_size(n), sizeof(intptr_t));
 793   _info-&gt;set_vtable_size(n);
 794 
 795   intptr_t* p = clone_vtable(name, _info);
 796   assert((char*)p == _mc_region.top(), &quot;must be&quot;);
 797 
 798   return _info-&gt;cloned_vtable();
 799 }
 800 
 801 template &lt;class T&gt;
 802 intptr_t* CppVtableCloner&lt;T&gt;::clone_vtable(const char* name, CppVtableInfo* info) {
 803   if (!DumpSharedSpaces) {
 804     assert(_info == 0, &quot;_info is initialized only at dump time&quot;);
 805     _info = info; // Remember it -- it will be used by MetaspaceShared::is_valid_shared_method()
 806   }
 807   T tmp; // Allocate temporary dummy metadata object to get to the original vtable.
 808   int n = info-&gt;vtable_size();
 809   intptr_t* srcvtable = vtable_of(tmp);
 810   intptr_t* dstvtable = info-&gt;cloned_vtable();
 811 
 812   // We already checked (and, if necessary, adjusted n) when the vtables were allocated, so we are
 813   // safe to do memcpy.
 814   log_debug(cds, vtables)(&quot;Copying %3d vtable entries for %s&quot;, n, name);
 815   memcpy(dstvtable, srcvtable, sizeof(intptr_t) * n);
 816   return dstvtable + n;
 817 }
 818 
 819 // To determine the size of the vtable for each type, we use the following
 820 // trick by declaring 2 subclasses:
 821 //
 822 //   class CppVtableTesterA: public InstanceKlass {virtual int   last_virtual_method() {return 1;}    };
 823 //   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };
 824 //
 825 // CppVtableTesterA and CppVtableTesterB&#39;s vtables have the following properties:
 826 // - Their size (N+1) is exactly one more than the size of InstanceKlass&#39;s vtable (N)
 827 // - The first N entries have are exactly the same as in InstanceKlass&#39;s vtable.
 828 // - Their last entry is different.
 829 //
 830 // So to determine the value of N, we just walk CppVtableTesterA and CppVtableTesterB&#39;s tables
 831 // and find the first entry that&#39;s different.
 832 //
 833 // This works on all C++ compilers supported by Oracle, but you may need to tweak it for more
 834 // esoteric compilers.
 835 
 836 template &lt;class T&gt; class CppVtableTesterB: public T {
 837 public:
 838   virtual int last_virtual_method() {return 1;}
 839 };
 840 
 841 template &lt;class T&gt; class CppVtableTesterA : public T {
 842 public:
 843   virtual void* last_virtual_method() {
 844     // Make this different than CppVtableTesterB::last_virtual_method so the C++
 845     // compiler/linker won&#39;t alias the two functions.
 846     return NULL;
 847   }
 848 };
 849 
 850 template &lt;class T&gt;
 851 int CppVtableCloner&lt;T&gt;::get_vtable_length(const char* name) {
 852   CppVtableTesterA&lt;T&gt; a;
 853   CppVtableTesterB&lt;T&gt; b;
 854 
 855   intptr_t* avtable = vtable_of(a);
 856   intptr_t* bvtable = vtable_of(b);
 857 
 858   // Start at slot 1, because slot 0 may be RTTI (on Solaris/Sparc)
 859   int vtable_len = 1;
 860   for (; ; vtable_len++) {
 861     if (avtable[vtable_len] != bvtable[vtable_len]) {
 862       break;
 863     }
 864   }
 865   log_debug(cds, vtables)(&quot;Found   %3d vtable entries for %s&quot;, vtable_len, name);
 866 
 867   return vtable_len;
 868 }
 869 
 870 #define ALLOC_CPP_VTABLE_CLONE(c) \
 871   _cloned_cpp_vtptrs[c##_Kind] = CppVtableCloner&lt;c&gt;::allocate(#c); \
 872   ArchivePtrMarker::mark_pointer(&amp;_cloned_cpp_vtptrs[c##_Kind]);
 873 
 874 #define CLONE_CPP_VTABLE(c) \
 875   p = CppVtableCloner&lt;c&gt;::clone_vtable(#c, (CppVtableInfo*)p);
 876 
 877 #define ZERO_CPP_VTABLE(c) \
 878  CppVtableCloner&lt;c&gt;::zero_vtable_clone();
 879 
 880 //------------------------------ for DynamicDumpSharedSpaces - start
 881 #define DECLARE_CLONED_VTABLE_KIND(c) c ## _Kind,
 882 
 883 enum {
 884   // E.g., ConstantPool_Kind == 0, InstanceKlass == 1, etc.
 885   CPP_VTABLE_PATCH_TYPES_DO(DECLARE_CLONED_VTABLE_KIND)
 886   _num_cloned_vtable_kinds
 887 };
 888 
 889 // This is the index of all the cloned vtables. E.g., for
 890 //     ConstantPool* cp = ....; // an archived constant pool
 891 //     InstanceKlass* ik = ....;// an archived class
 892 // the following holds true:
 893 //     _cloned_cpp_vtptrs[ConstantPool_Kind]  == ((intptr_t**)cp)[0]
 894 //     _cloned_cpp_vtptrs[InstanceKlass_Kind] == ((intptr_t**)ik)[0]
 895 static intptr_t** _cloned_cpp_vtptrs = NULL;
 896 
 897 void MetaspaceShared::allocate_cloned_cpp_vtptrs() {
 898   assert(DumpSharedSpaces, &quot;must&quot;);
 899   size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(intptr_t*);
 900   _cloned_cpp_vtptrs = (intptr_t**)_mc_region.allocate(vtptrs_bytes, sizeof(intptr_t*));
 901 }
 902 
 903 void MetaspaceShared::serialize_cloned_cpp_vtptrs(SerializeClosure* soc) {
 904   soc-&gt;do_ptr((void**)&amp;_cloned_cpp_vtptrs);
 905 }
 906 
 907 intptr_t* MetaspaceShared::fix_cpp_vtable_for_dynamic_archive(MetaspaceObj::Type msotype, address obj) {
 908   Arguments::assert_is_dumping_archive();
 909   int kind = -1;
 910   switch (msotype) {
 911   case MetaspaceObj::SymbolType:
 912   case MetaspaceObj::TypeArrayU1Type:
 913   case MetaspaceObj::TypeArrayU2Type:
 914   case MetaspaceObj::TypeArrayU4Type:
 915   case MetaspaceObj::TypeArrayU8Type:
 916   case MetaspaceObj::TypeArrayOtherType:
 917   case MetaspaceObj::ConstMethodType:
 918   case MetaspaceObj::ConstantPoolCacheType:
 919   case MetaspaceObj::AnnotationsType:
 920   case MetaspaceObj::MethodCountersType:
 921   case MetaspaceObj::RecordComponentType:
 922     // These have no vtables.
 923     break;
 924   case MetaspaceObj::ClassType:
 925     {
 926       Klass* k = (Klass*)obj;
 927       assert(k-&gt;is_klass(), &quot;must be&quot;);
 928       if (k-&gt;is_instance_klass()) {
 929         InstanceKlass* ik = InstanceKlass::cast(k);
 930         if (ik-&gt;is_class_loader_instance_klass()) {
 931           kind = InstanceClassLoaderKlass_Kind;
 932         } else if (ik-&gt;is_reference_instance_klass()) {
 933           kind = InstanceRefKlass_Kind;
 934         } else if (ik-&gt;is_mirror_instance_klass()) {
 935           kind = InstanceMirrorKlass_Kind;
 936         } else {
 937           kind = InstanceKlass_Kind;
 938         }
 939       } else if (k-&gt;is_typeArray_klass()) {
 940         kind = TypeArrayKlass_Kind;
 941       } else {
 942         assert(k-&gt;is_objArray_klass(), &quot;must be&quot;);
 943         kind = ObjArrayKlass_Kind;
 944       }
 945     }
 946     break;
 947 
 948   case MetaspaceObj::MethodType:
 949     {
 950       Method* m = (Method*)obj;
 951       assert(m-&gt;is_method(), &quot;must be&quot;);
 952       kind = Method_Kind;
 953     }
 954     break;
 955 
 956   case MetaspaceObj::MethodDataType:
 957     // We don&#39;t archive MethodData &lt;-- should have been removed in removed_unsharable_info
 958     ShouldNotReachHere();
 959     break;
 960 
 961   case MetaspaceObj::ConstantPoolType:
 962     {
 963       ConstantPool *cp = (ConstantPool*)obj;
 964       assert(cp-&gt;is_constantPool(), &quot;must be&quot;);
 965       kind = ConstantPool_Kind;
 966     }
 967     break;
 968 
 969   default:
 970     ShouldNotReachHere();
 971   }
 972 
 973   if (kind &gt;= 0) {
 974     assert(kind &lt; _num_cloned_vtable_kinds, &quot;must be&quot;);
 975     return _cloned_cpp_vtptrs[kind];
 976   } else {
 977     return NULL;
 978   }
 979 }
 980 
 981 //------------------------------ for DynamicDumpSharedSpaces - end
 982 
 983 // This can be called at both dump time and run time:
 984 // - clone the contents of the c++ vtables into the space
 985 //   allocated by allocate_cpp_vtable_clones()
 986 void MetaspaceShared::clone_cpp_vtables(intptr_t* p) {
 987   assert(DumpSharedSpaces || UseSharedSpaces, &quot;sanity&quot;);
 988   CPP_VTABLE_PATCH_TYPES_DO(CLONE_CPP_VTABLE);
 989 }
 990 
 991 void MetaspaceShared::zero_cpp_vtable_clones_for_writing() {
 992   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 993   CPP_VTABLE_PATCH_TYPES_DO(ZERO_CPP_VTABLE);
 994 }
 995 
 996 // Allocate and initialize the C++ vtables, starting from top, but do not go past end.
 997 char* MetaspaceShared::allocate_cpp_vtable_clones() {
 998   char* cloned_vtables = _mc_region.top(); // This is the beginning of all the cloned vtables
 999 
1000   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
1001   // Layout (each slot is a intptr_t):
1002   //   [number of slots in the first vtable = n1]
1003   //   [ &lt;n1&gt; slots for the first vtable]
1004   //   [number of slots in the first second = n2]
1005   //   [ &lt;n2&gt; slots for the second vtable]
1006   //   ...
1007   // The order of the vtables is the same as the CPP_VTAB_PATCH_TYPES_DO macro.
1008   CPP_VTABLE_PATCH_TYPES_DO(ALLOC_CPP_VTABLE_CLONE);
1009 
1010   return cloned_vtables;
1011 }
1012 
1013 bool MetaspaceShared::is_valid_shared_method(const Method* m) {
1014   assert(is_in_shared_metaspace(m), &quot;must be&quot;);
1015   return CppVtableCloner&lt;Method&gt;::is_valid_shared_object(m);
1016 }
1017 
1018 void WriteClosure::do_oop(oop* o) {
1019   if (*o == NULL) {
1020     _dump_region-&gt;append_intptr_t(0);
1021   } else {
1022     assert(HeapShared::is_heap_object_archiving_allowed(),
1023            &quot;Archiving heap object is not allowed&quot;);
1024     _dump_region-&gt;append_intptr_t(
1025       (intptr_t)CompressedOops::encode_not_null(*o));
1026   }
1027 }
1028 
1029 void WriteClosure::do_region(u_char* start, size_t size) {
1030   assert((intptr_t)start % sizeof(intptr_t) == 0, &quot;bad alignment&quot;);
1031   assert(size % sizeof(intptr_t) == 0, &quot;bad size&quot;);
1032   do_tag((int)size);
1033   while (size &gt; 0) {
1034     _dump_region-&gt;append_intptr_t(*(intptr_t*)start, true);
1035     start += sizeof(intptr_t);
1036     size -= sizeof(intptr_t);
1037   }
1038 }
1039 
1040 // This is for dumping detailed statistics for the allocations
1041 // in the shared spaces.
1042 class DumpAllocStats : public ResourceObj {
1043 public:
1044 
1045   // Here&#39;s poor man&#39;s enum inheritance
1046 #define SHAREDSPACE_OBJ_TYPES_DO(f) \
1047   METASPACE_OBJ_TYPES_DO(f) \
1048   f(SymbolHashentry) \
1049   f(SymbolBucket) \
1050   f(StringHashentry) \
1051   f(StringBucket) \
1052   f(Other)
1053 
1054   enum Type {
1055     // Types are MetaspaceObj::ClassType, MetaspaceObj::SymbolType, etc
1056     SHAREDSPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_DECLARE)
1057     _number_of_types
1058   };
1059 
1060   static const char * type_name(Type type) {
1061     switch(type) {
1062     SHAREDSPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_NAME_CASE)
1063     default:
1064       ShouldNotReachHere();
1065       return NULL;
1066     }
1067   }
1068 
1069 public:
1070   enum { RO = 0, RW = 1 };
1071 
1072   int _counts[2][_number_of_types];
1073   int _bytes [2][_number_of_types];
1074 
1075   DumpAllocStats() {
1076     memset(_counts, 0, sizeof(_counts));
1077     memset(_bytes,  0, sizeof(_bytes));
1078   };
1079 
1080   void record(MetaspaceObj::Type type, int byte_size, bool read_only) {
1081     assert(int(type) &gt;= 0 &amp;&amp; type &lt; MetaspaceObj::_number_of_types, &quot;sanity&quot;);
1082     int which = (read_only) ? RO : RW;
1083     _counts[which][type] ++;
1084     _bytes [which][type] += byte_size;
1085   }
1086 
1087   void record_other_type(int byte_size, bool read_only) {
1088     int which = (read_only) ? RO : RW;
1089     _bytes [which][OtherType] += byte_size;
1090   }
1091   void print_stats(int ro_all, int rw_all, int mc_all);
1092 };
1093 
1094 void DumpAllocStats::print_stats(int ro_all, int rw_all, int mc_all) {
1095   // Calculate size of data that was not allocated by Metaspace::allocate()
1096   MetaspaceSharedStats *stats = MetaspaceShared::stats();
1097 
1098   // symbols
1099   _counts[RO][SymbolHashentryType] = stats-&gt;symbol.hashentry_count;
1100   _bytes [RO][SymbolHashentryType] = stats-&gt;symbol.hashentry_bytes;
1101 
1102   _counts[RO][SymbolBucketType] = stats-&gt;symbol.bucket_count;
1103   _bytes [RO][SymbolBucketType] = stats-&gt;symbol.bucket_bytes;
1104 
1105   // strings
1106   _counts[RO][StringHashentryType] = stats-&gt;string.hashentry_count;
1107   _bytes [RO][StringHashentryType] = stats-&gt;string.hashentry_bytes;
1108 
1109   _counts[RO][StringBucketType] = stats-&gt;string.bucket_count;
1110   _bytes [RO][StringBucketType] = stats-&gt;string.bucket_bytes;
1111 
1112   // TODO: count things like dictionary, vtable, etc
1113   _bytes[RW][OtherType] += mc_all;
1114   rw_all += mc_all; // mc is mapped Read/Write
1115 
1116   // prevent divide-by-zero
1117   if (ro_all &lt; 1) {
1118     ro_all = 1;
1119   }
1120   if (rw_all &lt; 1) {
1121     rw_all = 1;
1122   }
1123 
1124   int all_ro_count = 0;
1125   int all_ro_bytes = 0;
1126   int all_rw_count = 0;
1127   int all_rw_bytes = 0;
1128 
1129 // To make fmt_stats be a syntactic constant (for format warnings), use #define.
1130 #define fmt_stats &quot;%-20s: %8d %10d %5.1f | %8d %10d %5.1f | %8d %10d %5.1f&quot;
1131   const char *sep = &quot;--------------------+---------------------------+---------------------------+--------------------------&quot;;
1132   const char *hdr = &quot;                        ro_cnt   ro_bytes     % |   rw_cnt   rw_bytes     % |  all_cnt  all_bytes     %&quot;;
1133 
1134   LogMessage(cds) msg;
1135 
1136   msg.debug(&quot;Detailed metadata info (excluding st regions; rw stats include mc regions):&quot;);
1137   msg.debug(&quot;%s&quot;, hdr);
1138   msg.debug(&quot;%s&quot;, sep);
1139   for (int type = 0; type &lt; int(_number_of_types); type ++) {
1140     const char *name = type_name((Type)type);
1141     int ro_count = _counts[RO][type];
1142     int ro_bytes = _bytes [RO][type];
1143     int rw_count = _counts[RW][type];
1144     int rw_bytes = _bytes [RW][type];
1145     int count = ro_count + rw_count;
1146     int bytes = ro_bytes + rw_bytes;
1147 
1148     double ro_perc = percent_of(ro_bytes, ro_all);
1149     double rw_perc = percent_of(rw_bytes, rw_all);
1150     double perc    = percent_of(bytes, ro_all + rw_all);
1151 
1152     msg.debug(fmt_stats, name,
1153                          ro_count, ro_bytes, ro_perc,
1154                          rw_count, rw_bytes, rw_perc,
1155                          count, bytes, perc);
1156 
1157     all_ro_count += ro_count;
1158     all_ro_bytes += ro_bytes;
1159     all_rw_count += rw_count;
1160     all_rw_bytes += rw_bytes;
1161   }
1162 
1163   int all_count = all_ro_count + all_rw_count;
1164   int all_bytes = all_ro_bytes + all_rw_bytes;
1165 
1166   double all_ro_perc = percent_of(all_ro_bytes, ro_all);
1167   double all_rw_perc = percent_of(all_rw_bytes, rw_all);
1168   double all_perc    = percent_of(all_bytes, ro_all + rw_all);
1169 
1170   msg.debug(&quot;%s&quot;, sep);
1171   msg.debug(fmt_stats, &quot;Total&quot;,
1172                        all_ro_count, all_ro_bytes, all_ro_perc,
1173                        all_rw_count, all_rw_bytes, all_rw_perc,
1174                        all_count, all_bytes, all_perc);
1175 
1176   assert(all_ro_bytes == ro_all, &quot;everything should have been counted&quot;);
1177   assert(all_rw_bytes == rw_all, &quot;everything should have been counted&quot;);
1178 
1179 #undef fmt_stats
1180 }
1181 
1182 // Populate the shared space.
1183 
1184 class VM_PopulateDumpSharedSpace: public VM_Operation {
1185 private:
1186   GrowableArray&lt;MemRegion&gt; *_closed_archive_heap_regions;
1187   GrowableArray&lt;MemRegion&gt; *_open_archive_heap_regions;
1188 
1189   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_closed_archive_heap_oopmaps;
1190   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_open_archive_heap_oopmaps;
1191 
1192   void dump_java_heap_objects() NOT_CDS_JAVA_HEAP_RETURN;
1193   void dump_archive_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;
1194   void dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1195                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps);
1196   void dump_symbols();
1197   char* dump_read_only_tables();
1198   void print_class_stats();
1199   void print_region_stats(FileMapInfo* map_info);
1200   void print_bitmap_region_stats(size_t size, size_t total_size);
1201   void print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1202                                const char *name, size_t total_size);
1203   void relocate_to_default_base_address(CHeapBitMap* ptrmap);
1204 
1205 public:
1206 
1207   VMOp_Type type() const { return VMOp_PopulateDumpSharedSpace; }
1208   void doit();   // outline because gdb sucks
1209   bool allow_nested_vm_operations() const { return true; }
1210 }; // class VM_PopulateDumpSharedSpace
1211 
1212 class SortedSymbolClosure: public SymbolClosure {
1213   GrowableArray&lt;Symbol*&gt; _symbols;
1214   virtual void do_symbol(Symbol** sym) {
1215     assert((*sym)-&gt;is_permanent(), &quot;archived symbols must be permanent&quot;);
1216     _symbols.append(*sym);
1217   }
1218   static int compare_symbols_by_address(Symbol** a, Symbol** b) {
1219     if (a[0] &lt; b[0]) {
1220       return -1;
1221     } else if (a[0] == b[0]) {
1222       return 0;
1223     } else {
1224       return 1;
1225     }
1226   }
1227 
1228 public:
1229   SortedSymbolClosure() {
1230     SymbolTable::symbols_do(this);
1231     _symbols.sort(compare_symbols_by_address);
1232   }
1233   GrowableArray&lt;Symbol*&gt;* get_sorted_symbols() {
1234     return &amp;_symbols;
1235   }
1236 };
1237 
1238 // ArchiveCompactor --
1239 //
1240 // This class is the central piece of shared archive compaction -- all metaspace data are
1241 // initially allocated outside of the shared regions. ArchiveCompactor copies the
1242 // metaspace data into their final location in the shared regions.
1243 
1244 class ArchiveCompactor : AllStatic {
1245   static const int INITIAL_TABLE_SIZE = 8087;
1246   static const int MAX_TABLE_SIZE     = 1000000;
1247 
1248   static DumpAllocStats* _alloc_stats;
1249   static SortedSymbolClosure* _ssc;
1250 
1251   typedef KVHashtable&lt;address, address, mtInternal&gt; RelocationTable;
1252   static RelocationTable* _new_loc_table;
1253 
1254 public:
1255   static void initialize() {
1256     _alloc_stats = new(ResourceObj::C_HEAP, mtInternal)DumpAllocStats;
1257     _new_loc_table = new RelocationTable(INITIAL_TABLE_SIZE);
1258   }
1259   static DumpAllocStats* alloc_stats() {
1260     return _alloc_stats;
1261   }
1262 
1263   // Use this when you allocate space with MetaspaceShare::read_only_space_alloc()
1264   // outside of ArchiveCompactor::allocate(). These are usually for misc tables
1265   // that are allocated in the RO space.
1266   class OtherROAllocMark {
1267     char* _oldtop;
1268   public:
1269     OtherROAllocMark() {
1270       _oldtop = _ro_region.top();
1271     }
1272     ~OtherROAllocMark() {
1273       char* newtop = _ro_region.top();
1274       ArchiveCompactor::alloc_stats()-&gt;record_other_type(int(newtop - _oldtop), true);
1275     }
1276   };
1277 
1278   static void allocate(MetaspaceClosure::Ref* ref, bool read_only) {
1279     address obj = ref-&gt;obj();
1280     int bytes = ref-&gt;size() * BytesPerWord;
1281     char* p;
1282     size_t alignment = BytesPerWord;
1283     char* oldtop;
1284     char* newtop;
1285 
1286     if (read_only) {
1287       oldtop = _ro_region.top();
1288       p = _ro_region.allocate(bytes, alignment);
1289       newtop = _ro_region.top();
1290     } else {
1291       oldtop = _rw_region.top();
1292       if (ref-&gt;msotype() == MetaspaceObj::ClassType) {
1293         // Save a pointer immediate in front of an InstanceKlass, so
1294         // we can do a quick lookup from InstanceKlass* -&gt; RunTimeSharedClassInfo*
1295         // without building another hashtable. See RunTimeSharedClassInfo::get_for()
1296         // in systemDictionaryShared.cpp.
1297         Klass* klass = (Klass*)obj;
1298         if (klass-&gt;is_instance_klass()) {
1299           SystemDictionaryShared::validate_before_archiving(InstanceKlass::cast(klass));
1300           _rw_region.allocate(sizeof(address), BytesPerWord);
1301         }
1302       }
1303       p = _rw_region.allocate(bytes, alignment);
1304       newtop = _rw_region.top();
1305     }
1306     memcpy(p, obj, bytes);
1307 
1308     intptr_t* cloned_vtable = MetaspaceShared::fix_cpp_vtable_for_dynamic_archive(ref-&gt;msotype(), (address)p);
1309     if (cloned_vtable != NULL) {
1310       *(address*)p = (address)cloned_vtable;
1311       ArchivePtrMarker::mark_pointer((address*)p);
1312     }
1313 
1314     assert(_new_loc_table-&gt;lookup(obj) == NULL, &quot;each object can be relocated at most once&quot;);
1315     _new_loc_table-&gt;add(obj, (address)p);
1316     log_trace(cds)(&quot;Copy: &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT &quot; %d&quot;, p2i(obj), p2i(p), bytes);
1317     if (_new_loc_table-&gt;maybe_grow(MAX_TABLE_SIZE)) {
1318       log_info(cds, hashtables)(&quot;Expanded _new_loc_table to %d&quot;, _new_loc_table-&gt;table_size());
1319     }
1320     _alloc_stats-&gt;record(ref-&gt;msotype(), int(newtop - oldtop), read_only);
1321   }
1322 
1323   static address get_new_loc(MetaspaceClosure::Ref* ref) {
1324     address* pp = _new_loc_table-&gt;lookup(ref-&gt;obj());
1325     assert(pp != NULL, &quot;must be&quot;);
1326     return *pp;
1327   }
1328 
1329 private:
1330   // Makes a shallow copy of visited MetaspaceObj&#39;s
1331   class ShallowCopier: public UniqueMetaspaceClosure {
1332     bool _read_only;
1333   public:
1334     ShallowCopier(bool read_only) : _read_only(read_only) {}
1335 
1336     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1337       if (read_only == _read_only) {
1338         allocate(ref, read_only);
1339       }
1340       return true; // recurse into ref.obj()
1341     }
1342   };
1343 
1344   // Relocate embedded pointers within a MetaspaceObj&#39;s shallow copy
1345   class ShallowCopyEmbeddedRefRelocator: public UniqueMetaspaceClosure {
1346   public:
1347     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1348       address new_loc = get_new_loc(ref);
1349       RefRelocator refer;
1350       ref-&gt;metaspace_pointers_do_at(&amp;refer, new_loc);
1351       return true; // recurse into ref.obj()
1352     }
1353     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
1354       assert(type == _method_entry_ref, &quot;only special type allowed for now&quot;);
1355       address obj = ref-&gt;obj();
1356       address new_obj = get_new_loc(ref);
1357       size_t offset = pointer_delta(p, obj,  sizeof(u1));
1358       intptr_t* new_p = (intptr_t*)(new_obj + offset);
1359       assert(*p == *new_p, &quot;must be a copy&quot;);
1360       ArchivePtrMarker::mark_pointer((address*)new_p);
1361     }
1362   };
1363 
1364   // Relocate a reference to point to its shallow copy
1365   class RefRelocator: public MetaspaceClosure {
1366   public:
1367     virtual bool do_ref(Ref* ref, bool read_only) {
1368       if (ref-&gt;not_null()) {
1369         ref-&gt;update(get_new_loc(ref));
1370         ArchivePtrMarker::mark_pointer(ref-&gt;addr());
1371       }
1372       return false; // Do not recurse.
1373     }
1374   };
1375 
1376 #ifdef ASSERT
1377   class IsRefInArchiveChecker: public MetaspaceClosure {
1378   public:
1379     virtual bool do_ref(Ref* ref, bool read_only) {
1380       if (ref-&gt;not_null()) {
1381         char* obj = (char*)ref-&gt;obj();
1382         assert(_ro_region.contains(obj) || _rw_region.contains(obj),
1383                &quot;must be relocated to point to CDS archive&quot;);
1384       }
1385       return false; // Do not recurse.
1386     }
1387   };
1388 #endif
1389 
1390 public:
1391   static void copy_and_compact() {
1392     ResourceMark rm;
1393     SortedSymbolClosure the_ssc; // StackObj
1394     _ssc = &amp;the_ssc;
1395 
1396     log_info(cds)(&quot;Scanning all metaspace objects ... &quot;);
1397     {
1398       // allocate and shallow-copy RW objects, immediately following the MC region
1399       log_info(cds)(&quot;Allocating RW objects ... &quot;);
1400       _mc_region.pack(&amp;_rw_region);
1401 
1402       ResourceMark rm;
1403       ShallowCopier rw_copier(false);
1404       iterate_roots(&amp;rw_copier);
1405     }
1406     {
1407       // allocate and shallow-copy of RO object, immediately following the RW region
1408       log_info(cds)(&quot;Allocating RO objects ... &quot;);
1409       _rw_region.pack(&amp;_ro_region);
1410 
1411       ResourceMark rm;
1412       ShallowCopier ro_copier(true);
1413       iterate_roots(&amp;ro_copier);
1414     }
1415     {
1416       log_info(cds)(&quot;Relocating embedded pointers ... &quot;);
1417       ResourceMark rm;
1418       ShallowCopyEmbeddedRefRelocator emb_reloc;
1419       iterate_roots(&amp;emb_reloc);
1420     }
1421     {
1422       log_info(cds)(&quot;Relocating external roots ... &quot;);
1423       ResourceMark rm;
1424       RefRelocator ext_reloc;
1425       iterate_roots(&amp;ext_reloc);
1426     }
1427     {
1428       log_info(cds)(&quot;Fixing symbol identity hash ... &quot;);
1429       os::init_random(0x12345678);
1430       GrowableArray&lt;Symbol*&gt;* symbols = _ssc-&gt;get_sorted_symbols();
1431       for (int i=0; i&lt;symbols-&gt;length(); i++) {
1432         symbols-&gt;at(i)-&gt;update_identity_hash();
1433       }
1434     }
1435 #ifdef ASSERT
1436     {
1437       log_info(cds)(&quot;Verifying external roots ... &quot;);
1438       ResourceMark rm;
1439       IsRefInArchiveChecker checker;
1440       iterate_roots(&amp;checker);
1441     }
1442 #endif
1443 
1444 
1445     // cleanup
1446     _ssc = NULL;
1447   }
1448 
1449   // We must relocate the System::_well_known_klasses only after we have copied the
1450   // java objects in during dump_java_heap_objects(): during the object copy, we operate on
1451   // old objects which assert that their klass is the original klass.
1452   static void relocate_well_known_klasses() {
1453     {
1454       log_info(cds)(&quot;Relocating SystemDictionary::_well_known_klasses[] ... &quot;);
1455       ResourceMark rm;
1456       RefRelocator ext_reloc;
1457       SystemDictionary::well_known_klasses_do(&amp;ext_reloc);
1458     }
1459     // NOTE: after this point, we shouldn&#39;t have any globals that can reach the old
1460     // objects.
1461 
1462     // We cannot use any of the objects in the heap anymore (except for the
1463     // shared strings) because their headers no longer point to valid Klasses.
1464   }
1465 
1466   static void iterate_roots(MetaspaceClosure* it) {
1467     // To ensure deterministic contents in the archive, we just need to ensure that
1468     // we iterate the MetsapceObjs in a deterministic order. It doesn&#39;t matter where
1469     // the MetsapceObjs are located originally, as they are copied sequentially into
1470     // the archive during the iteration.
1471     //
1472     // The only issue here is that the symbol table and the system directories may be
1473     // randomly ordered, so we copy the symbols and klasses into two arrays and sort
1474     // them deterministically.
1475     //
1476     // During -Xshare:dump, the order of Symbol creation is strictly determined by
1477     // the SharedClassListFile (class loading is done in a single thread and the JIT
1478     // is disabled). Also, Symbols are allocated in monotonically increasing addresses
1479     // (see Symbol::operator new(size_t, int)). So if we iterate the Symbols by
1480     // ascending address order, we ensure that all Symbols are copied into deterministic
1481     // locations in the archive.
1482     GrowableArray&lt;Symbol*&gt;* symbols = _ssc-&gt;get_sorted_symbols();
1483     for (int i=0; i&lt;symbols-&gt;length(); i++) {
1484       it-&gt;push(symbols-&gt;adr_at(i));
1485     }
1486     if (_global_klass_objects != NULL) {
1487       // Need to fix up the pointers
1488       for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1489         // NOTE -- this requires that the vtable is NOT yet patched, or else we are hosed.
1490         it-&gt;push(_global_klass_objects-&gt;adr_at(i));
1491       }
1492     }
1493     FileMapInfo::metaspace_pointers_do(it, false);
1494     SystemDictionaryShared::dumptime_classes_do(it);
1495     Universe::metaspace_pointers_do(it);
1496     SymbolTable::metaspace_pointers_do(it);
1497     vmSymbols::metaspace_pointers_do(it);
1498 
1499     it-&gt;finish();
1500   }
1501 
1502   static Klass* get_relocated_klass(Klass* orig_klass) {
1503     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1504     address* pp = _new_loc_table-&gt;lookup((address)orig_klass);
1505     assert(pp != NULL, &quot;must be&quot;);
1506     Klass* klass = (Klass*)(*pp);
1507     assert(klass-&gt;is_klass(), &quot;must be&quot;);
1508     return klass;
1509   }
1510 };
1511 
1512 DumpAllocStats* ArchiveCompactor::_alloc_stats;
1513 SortedSymbolClosure* ArchiveCompactor::_ssc;
1514 ArchiveCompactor::RelocationTable* ArchiveCompactor::_new_loc_table;
1515 
1516 void VM_PopulateDumpSharedSpace::dump_symbols() {
1517   log_info(cds)(&quot;Dumping symbol table ...&quot;);
1518 
1519   NOT_PRODUCT(SymbolTable::verify());
1520   SymbolTable::write_to_archive();
1521 }
1522 
1523 char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {
1524   ArchiveCompactor::OtherROAllocMark mark;
1525 
1526   log_info(cds)(&quot;Removing java_mirror ... &quot;);
1527   if (!HeapShared::is_heap_object_archiving_allowed()) {
1528     clear_basic_type_mirrors();
1529   }
1530   remove_java_mirror_in_classes();
1531   log_info(cds)(&quot;done. &quot;);
1532 
1533   SystemDictionaryShared::write_to_archive();
1534 
1535   // Write the other data to the output array.
1536   char* start = _ro_region.top();
1537   WriteClosure wc(&amp;_ro_region);
1538   MetaspaceShared::serialize(&amp;wc);
1539 
1540   // Write the bitmaps for patching the archive heap regions
1541   _closed_archive_heap_oopmaps = NULL;
1542   _open_archive_heap_oopmaps = NULL;
1543   dump_archive_heap_oopmaps();
1544 
1545   return start;
1546 }
1547 
1548 void VM_PopulateDumpSharedSpace::print_class_stats() {
1549   log_info(cds)(&quot;Number of classes %d&quot;, _global_klass_objects-&gt;length());
1550   {
1551     int num_type_array = 0, num_obj_array = 0, num_inst = 0;
1552     for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1553       Klass* k = _global_klass_objects-&gt;at(i);
1554       if (k-&gt;is_instance_klass()) {
1555         num_inst ++;
1556       } else if (k-&gt;is_objArray_klass()) {
1557         num_obj_array ++;
1558       } else {
1559         assert(k-&gt;is_typeArray_klass(), &quot;sanity&quot;);
1560         num_type_array ++;
1561       }
1562     }
1563     log_info(cds)(&quot;    instance classes   = %5d&quot;, num_inst);
1564     log_info(cds)(&quot;    obj array classes  = %5d&quot;, num_obj_array);
1565     log_info(cds)(&quot;    type array classes = %5d&quot;, num_type_array);
1566   }
1567 }
1568 
1569 void VM_PopulateDumpSharedSpace::relocate_to_default_base_address(CHeapBitMap* ptrmap) {
1570   intx addr_delta = MetaspaceShared::final_delta();
1571   if (addr_delta == 0) {
1572     ArchivePtrMarker::compact((address)SharedBaseAddress, (address)_ro_region.top());
1573   } else {
1574     // We are not able to reserve space at Arguments::default_SharedBaseAddress() (due to ASLR).
1575     // This means that the current content of the archive is based on a random
1576     // address. Let&#39;s relocate all the pointers, so that it can be mapped to
1577     // Arguments::default_SharedBaseAddress() without runtime relocation.
1578     //
1579     // Note: both the base and dynamic archive are written with
1580     // FileMapHeader::_shared_base_address == Arguments::default_SharedBaseAddress()
1581 
1582     // Patch all pointers that are marked by ptrmap within this region,
1583     // where we have just dumped all the metaspace data.
1584     address patch_base = (address)SharedBaseAddress;
1585     address patch_end  = (address)_ro_region.top();
1586     size_t size = patch_end - patch_base;
1587 
1588     // the current value of the pointers to be patched must be within this
1589     // range (i.e., must point to valid metaspace objects)
1590     address valid_old_base = patch_base;
1591     address valid_old_end  = patch_end;
1592 
1593     // after patching, the pointers must point inside this range
1594     // (the requested location of the archive, as mapped at runtime).
1595     address valid_new_base = (address)Arguments::default_SharedBaseAddress();
1596     address valid_new_end  = valid_new_base + size;
1597 
1598     log_debug(cds)(&quot;Relocating archive from [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; ] to &quot;
1599                    &quot;[&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; ]&quot;, p2i(patch_base), p2i(patch_end),
1600                    p2i(valid_new_base), p2i(valid_new_end));
1601 
1602     SharedDataRelocator&lt;true&gt; patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,
1603                                       valid_new_base, valid_new_end, addr_delta, ptrmap);
1604     ptrmap-&gt;iterate(&amp;patcher);
1605     ArchivePtrMarker::compact(patcher.max_non_null_offset());
1606   }
1607 }
1608 
1609 void VM_PopulateDumpSharedSpace::doit() {
1610   CHeapBitMap ptrmap;
1611   MetaspaceShared::initialize_ptr_marker(&amp;ptrmap);
1612 
1613   // We should no longer allocate anything from the metaspace, so that:
1614   //
1615   // (1) Metaspace::allocate might trigger GC if we have run out of
1616   //     committed metaspace, but we can&#39;t GC because we&#39;re running
1617   //     in the VM thread.
1618   // (2) ArchiveCompactor needs to work with a stable set of MetaspaceObjs.
1619   Metaspace::freeze();
1620   DEBUG_ONLY(SystemDictionaryShared::NoClassLoadingMark nclm);
1621 
1622   Thread* THREAD = VMThread::vm_thread();
1623 
1624   FileMapInfo::check_nonempty_dir_in_shared_path_table();
1625 
1626   NOT_PRODUCT(SystemDictionary::verify();)
1627   // The following guarantee is meant to ensure that no loader constraints
1628   // exist yet, since the constraints table is not shared.  This becomes
1629   // more important now that we don&#39;t re-initialize vtables/itables for
1630   // shared classes at runtime, where constraints were previously created.
1631   guarantee(SystemDictionary::constraints()-&gt;number_of_entries() == 0,
1632             &quot;loader constraints are not saved&quot;);
1633   guarantee(SystemDictionary::placeholders()-&gt;number_of_entries() == 0,
1634           &quot;placeholders are not saved&quot;);
1635 
1636   // At this point, many classes have been loaded.
1637   // Gather systemDictionary classes in a global array and do everything to
1638   // that so we don&#39;t have to walk the SystemDictionary again.
1639   SystemDictionaryShared::check_excluded_classes();
1640   _global_klass_objects = new GrowableArray&lt;Klass*&gt;(1000);
1641   CollectClassesClosure collect_classes;
1642   ClassLoaderDataGraph::loaded_classes_do(&amp;collect_classes);
1643   _global_klass_objects-&gt;sort(global_klass_compare);
1644 
1645   print_class_stats();
1646 
1647   // Ensure the ConstMethods won&#39;t be modified at run-time
1648   log_info(cds)(&quot;Updating ConstMethods ... &quot;);
1649   rewrite_nofast_bytecodes_and_calculate_fingerprints(THREAD);
1650   log_info(cds)(&quot;done. &quot;);
1651 
1652   // Remove all references outside the metadata
1653   log_info(cds)(&quot;Removing unshareable information ... &quot;);
1654   remove_unshareable_in_classes();
1655   log_info(cds)(&quot;done. &quot;);
1656 
1657   MetaspaceShared::allocate_cloned_cpp_vtptrs();
1658   char* cloned_vtables = _mc_region.top();
1659   MetaspaceShared::allocate_cpp_vtable_clones();
1660 
1661   ArchiveCompactor::initialize();
1662   ArchiveCompactor::copy_and_compact();
1663 
1664   dump_symbols();
1665 
1666   // Dump supported java heap objects
1667   _closed_archive_heap_regions = NULL;
1668   _open_archive_heap_regions = NULL;
1669   dump_java_heap_objects();
1670 
1671   ArchiveCompactor::relocate_well_known_klasses();
1672 
1673   char* serialized_data = dump_read_only_tables();
1674   _ro_region.pack();
1675 
1676   // The vtable clones contain addresses of the current process.
1677   // We don&#39;t want to write these addresses into the archive. Same for i2i buffer.
1678   MetaspaceShared::zero_cpp_vtable_clones_for_writing();
1679   memset(MetaspaceShared::i2i_entry_code_buffers(), 0,
1680          MetaspaceShared::i2i_entry_code_buffers_size());
1681 
1682   // relocate the data so that it can be mapped to Arguments::default_SharedBaseAddress()
1683   // without runtime relocation.
1684   relocate_to_default_base_address(&amp;ptrmap);
1685 
1686   // Create and write the archive file that maps the shared spaces.
1687 
1688   FileMapInfo* mapinfo = new FileMapInfo(true);
1689   mapinfo-&gt;populate_header(os::vm_allocation_granularity());
1690   mapinfo-&gt;set_serialized_data(serialized_data);
1691   mapinfo-&gt;set_cloned_vtables(cloned_vtables);
1692   mapinfo-&gt;set_i2i_entry_code_buffers(MetaspaceShared::i2i_entry_code_buffers(),
1693                                       MetaspaceShared::i2i_entry_code_buffers_size());
1694   mapinfo-&gt;open_for_write();
1695   MetaspaceShared::write_core_archive_regions(mapinfo, _closed_archive_heap_oopmaps, _open_archive_heap_oopmaps);
1696   _total_closed_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1697                                         _closed_archive_heap_regions,
1698                                         _closed_archive_heap_oopmaps,
1699                                         MetaspaceShared::first_closed_archive_heap_region,
1700                                         MetaspaceShared::max_closed_archive_heap_region);
1701   _total_open_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1702                                         _open_archive_heap_regions,
1703                                         _open_archive_heap_oopmaps,
1704                                         MetaspaceShared::first_open_archive_heap_region,
1705                                         MetaspaceShared::max_open_archive_heap_region);
1706 
1707   mapinfo-&gt;set_final_requested_base((char*)Arguments::default_SharedBaseAddress());
1708   mapinfo-&gt;set_header_crc(mapinfo-&gt;compute_header_crc());
1709   mapinfo-&gt;write_header();
1710   print_region_stats(mapinfo);
1711   mapinfo-&gt;close();
1712 
1713   if (log_is_enabled(Info, cds)) {
1714     ArchiveCompactor::alloc_stats()-&gt;print_stats(int(_ro_region.used()), int(_rw_region.used()),
1715                                                  int(_mc_region.used()));
1716   }
1717 
1718   if (PrintSystemDictionaryAtExit) {
1719     SystemDictionary::print();
1720   }
1721 
1722   if (AllowArchivingWithJavaAgent) {
1723     warning(&quot;This archive was created with AllowArchivingWithJavaAgent. It should be used &quot;
1724             &quot;for testing purposes only and should not be used in a production environment&quot;);
1725   }
1726 
1727   // There may be other pending VM operations that operate on the InstanceKlasses,
1728   // which will fail because InstanceKlasses::remove_unshareable_info()
1729   // has been called. Forget these operations and exit the VM directly.
1730   vm_direct_exit(0);
1731 }
1732 
1733 void VM_PopulateDumpSharedSpace::print_region_stats(FileMapInfo *map_info) {
1734   // Print statistics of all the regions
1735   const size_t bitmap_used = map_info-&gt;space_at(MetaspaceShared::bm)-&gt;used();
1736   const size_t bitmap_reserved = map_info-&gt;space_at(MetaspaceShared::bm)-&gt;used_aligned();
1737   const size_t total_reserved = _ro_region.reserved()  + _rw_region.reserved() +
1738                                 _mc_region.reserved()  +
1739                                 bitmap_reserved +
1740                                 _total_closed_archive_region_size +
1741                                 _total_open_archive_region_size;
1742   const size_t total_bytes = _ro_region.used()  + _rw_region.used() +
1743                              _mc_region.used()  +
1744                              bitmap_used +
1745                              _total_closed_archive_region_size +
1746                              _total_open_archive_region_size;
1747   const double total_u_perc = percent_of(total_bytes, total_reserved);
1748 
1749   _mc_region.print(total_reserved);
1750   _rw_region.print(total_reserved);
1751   _ro_region.print(total_reserved);
1752   print_bitmap_region_stats(bitmap_used, total_reserved);
1753   print_heap_region_stats(_closed_archive_heap_regions, &quot;ca&quot;, total_reserved);
1754   print_heap_region_stats(_open_archive_heap_regions, &quot;oa&quot;, total_reserved);
1755 
1756   log_debug(cds)(&quot;total    : &quot; SIZE_FORMAT_W(9) &quot; [100.0%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used]&quot;,
1757                  total_bytes, total_reserved, total_u_perc);
1758 }
1759 
1760 void VM_PopulateDumpSharedSpace::print_bitmap_region_stats(size_t size, size_t total_size) {
1761   log_debug(cds)(&quot;bm  space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used]&quot;,
1762                  size, size/double(total_size)*100.0, size);
1763 }
1764 
1765 void VM_PopulateDumpSharedSpace::print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1766                                                          const char *name, size_t total_size) {
1767   int arr_len = heap_mem == NULL ? 0 : heap_mem-&gt;length();
1768   for (int i = 0; i &lt; arr_len; i++) {
1769       char* start = (char*)heap_mem-&gt;at(i).start();
1770       size_t size = heap_mem-&gt;at(i).byte_size();
1771       char* top = start + size;
1772       log_debug(cds)(&quot;%s%d space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,
1773                      name, i, size, size/double(total_size)*100.0, size, p2i(start));
1774 
1775   }
1776 }
1777 
1778 void MetaspaceShared::write_core_archive_regions(FileMapInfo* mapinfo,
1779                                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* closed_oopmaps,
1780                                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* open_oopmaps) {
1781   // Make sure NUM_CDS_REGIONS (exported in cds.h) agrees with
1782   // MetaspaceShared::n_regions (internal to hotspot).
1783   assert(NUM_CDS_REGIONS == MetaspaceShared::n_regions, &quot;sanity&quot;);
1784 
1785   // mc contains the trampoline code for method entries, which are patched at run time,
1786   // so it needs to be read/write.
1787   write_region(mapinfo, mc, &amp;_mc_region, /*read_only=*/false,/*allow_exec=*/true);
1788   write_region(mapinfo, rw, &amp;_rw_region, /*read_only=*/false,/*allow_exec=*/false);
1789   write_region(mapinfo, ro, &amp;_ro_region, /*read_only=*/true, /*allow_exec=*/false);
1790   mapinfo-&gt;write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_oopmaps, open_oopmaps);
1791 }
1792 
1793 void MetaspaceShared::write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region, bool read_only,  bool allow_exec) {
1794   mapinfo-&gt;write_region(region_idx, dump_region-&gt;base(), dump_region-&gt;used(), read_only, allow_exec);
1795 }
1796 
1797 // Update a Java object to point its Klass* to the new location after
1798 // shared archive has been compacted.
1799 void MetaspaceShared::relocate_klass_ptr(oop o) {
1800   assert(DumpSharedSpaces, &quot;sanity&quot;);
1801   Klass* k = ArchiveCompactor::get_relocated_klass(o-&gt;klass());
1802   o-&gt;set_klass(k);
1803 }
1804 
1805 Klass* MetaspaceShared::get_relocated_klass(Klass *k, bool is_final) {
1806   assert(DumpSharedSpaces, &quot;sanity&quot;);
1807   k = ArchiveCompactor::get_relocated_klass(k);
1808   if (is_final) {
1809     k = (Klass*)(address(k) + final_delta());
1810   }
1811   return k;
1812 }
1813 
1814 class LinkSharedClassesClosure : public KlassClosure {
1815   Thread* THREAD;
1816   bool    _made_progress;
1817  public:
1818   LinkSharedClassesClosure(Thread* thread) : THREAD(thread), _made_progress(false) {}
1819 
1820   void reset()               { _made_progress = false; }
1821   bool made_progress() const { return _made_progress; }
1822 
1823   void do_klass(Klass* k) {
1824     if (k-&gt;is_instance_klass()) {
1825       InstanceKlass* ik = InstanceKlass::cast(k);
1826       // For dynamic CDS dump, only link classes loaded by the builtin class loaders.
1827       bool do_linking = DumpSharedSpaces ? true : !ik-&gt;is_shared_unregistered_class();
1828       if (do_linking) {
1829         // Link the class to cause the bytecodes to be rewritten and the
1830         // cpcache to be created. Class verification is done according
1831         // to -Xverify setting.
1832         _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);
1833         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1834 
1835         if (DumpSharedSpaces) {
1836           // The following function is used to resolve all Strings in the statically
1837           // dumped classes to archive all the Strings. The archive heap is not supported
1838           // for the dynamic archive.
1839           ik-&gt;constants()-&gt;resolve_class_constants(THREAD);
1840         }
1841       }
1842     }
1843   }
1844 };
1845 
1846 void MetaspaceShared::link_and_cleanup_shared_classes(TRAPS) {
1847   // We need to iterate because verification may cause additional classes
1848   // to be loaded.
1849   LinkSharedClassesClosure link_closure(THREAD);
1850   do {
1851     link_closure.reset();
1852     ClassLoaderDataGraph::unlocked_loaded_classes_do(&amp;link_closure);
1853     guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1854   } while (link_closure.made_progress());
1855 }
1856 
1857 void MetaspaceShared::prepare_for_dumping() {
1858   Arguments::check_unsupported_dumping_properties();
1859   ClassLoader::initialize_shared_path();
1860 }
1861 
1862 // Preload classes from a list, populate the shared spaces and dump to a
1863 // file.
1864 void MetaspaceShared::preload_and_dump(TRAPS) {
1865   { TraceTime timer(&quot;Dump Shared Spaces&quot;, TRACETIME_LOG(Info, startuptime));
1866     ResourceMark rm(THREAD);
1867     char class_list_path_str[JVM_MAXPATHLEN];
1868     // Preload classes to be shared.
1869     const char* class_list_path;
1870     if (SharedClassListFile == NULL) {
1871       // Construct the path to the class list (in jre/lib)
1872       // Walk up two directories from the location of the VM and
1873       // optionally tack on &quot;lib&quot; (depending on platform)
1874       os::jvm_path(class_list_path_str, sizeof(class_list_path_str));
1875       for (int i = 0; i &lt; 3; i++) {
1876         char *end = strrchr(class_list_path_str, *os::file_separator());
1877         if (end != NULL) *end = &#39;\0&#39;;
1878       }
1879       int class_list_path_len = (int)strlen(class_list_path_str);
1880       if (class_list_path_len &gt;= 3) {
1881         if (strcmp(class_list_path_str + class_list_path_len - 3, &quot;lib&quot;) != 0) {
1882           if (class_list_path_len &lt; JVM_MAXPATHLEN - 4) {
1883             jio_snprintf(class_list_path_str + class_list_path_len,
1884                          sizeof(class_list_path_str) - class_list_path_len,
1885                          &quot;%slib&quot;, os::file_separator());
1886             class_list_path_len += 4;
1887           }
1888         }
1889       }
1890       if (class_list_path_len &lt; JVM_MAXPATHLEN - 10) {
1891         jio_snprintf(class_list_path_str + class_list_path_len,
1892                      sizeof(class_list_path_str) - class_list_path_len,
1893                      &quot;%sclasslist&quot;, os::file_separator());
1894       }
1895       class_list_path = class_list_path_str;
1896     } else {
1897       class_list_path = SharedClassListFile;
1898     }
1899 
1900     log_info(cds)(&quot;Loading classes to share ...&quot;);
1901     _has_error_classes = false;
1902     int class_count = preload_classes(class_list_path, THREAD);
1903     if (ExtraSharedClassListFile) {
1904       class_count += preload_classes(ExtraSharedClassListFile, THREAD);
1905     }
1906     log_info(cds)(&quot;Loading classes to share: done.&quot;);
1907 
1908     log_info(cds)(&quot;Shared spaces: preloaded %d classes&quot;, class_count);
1909 
1910     if (SharedArchiveConfigFile) {
1911       log_info(cds)(&quot;Reading extra data from %s ...&quot;, SharedArchiveConfigFile);
1912       read_extra_data(SharedArchiveConfigFile, THREAD);
1913     }
1914     log_info(cds)(&quot;Reading extra data: done.&quot;);
1915 
1916     HeapShared::init_subgraph_entry_fields(THREAD);
1917 
1918     // Rewrite and link classes
1919     log_info(cds)(&quot;Rewriting and linking classes ...&quot;);
1920 
1921     // Link any classes which got missed. This would happen if we have loaded classes that
1922     // were not explicitly specified in the classlist. E.g., if an interface implemented by class K
1923     // fails verification, all other interfaces that were not specified in the classlist but
1924     // are implemented by K are not verified.
1925     link_and_cleanup_shared_classes(CATCH);
1926     log_info(cds)(&quot;Rewriting and linking classes: done&quot;);
1927 
1928     if (HeapShared::is_heap_object_archiving_allowed()) {
1929       // Avoid fragmentation while archiving heap objects.
1930       Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1931       Universe::heap()-&gt;collect(GCCause::_archive_time_gc);
1932       Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1933     }
1934 
1935     VM_PopulateDumpSharedSpace op;
1936     VMThread::execute(&amp;op);
1937   }
1938 }
1939 
1940 
1941 int MetaspaceShared::preload_classes(const char* class_list_path, TRAPS) {
1942   ClassListParser parser(class_list_path);
1943   int class_count = 0;
1944 
1945   while (parser.parse_one_line()) {
1946     Klass* klass = parser.load_current_class(THREAD);
1947     if (HAS_PENDING_EXCEPTION) {
1948       if (klass == NULL &amp;&amp;
1949           (PENDING_EXCEPTION-&gt;klass()-&gt;name() == vmSymbols::java_lang_ClassNotFoundException())) {
1950         // print a warning only when the pending exception is class not found
1951         log_warning(cds)(&quot;Preload Warning: Cannot find %s&quot;, parser.current_class_name());
1952       }
1953       CLEAR_PENDING_EXCEPTION;
1954     }
1955     if (klass != NULL) {
1956       if (log_is_enabled(Trace, cds)) {
1957         ResourceMark rm(THREAD);
1958         log_trace(cds)(&quot;Shared spaces preloaded: %s&quot;, klass-&gt;external_name());
1959       }
1960 
1961       if (klass-&gt;is_instance_klass()) {
1962         InstanceKlass* ik = InstanceKlass::cast(klass);
1963 
1964         // Link the class to cause the bytecodes to be rewritten and the
1965         // cpcache to be created. The linking is done as soon as classes
1966         // are loaded in order that the related data structures (klass and
1967         // cpCache) are located together.
1968         try_link_class(ik, THREAD);
1969         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1970       }
1971 
1972       class_count++;
1973     }
1974   }
1975 
1976   return class_count;
1977 }
1978 
1979 // Returns true if the class&#39;s status has changed
1980 bool MetaspaceShared::try_link_class(InstanceKlass* ik, TRAPS) {
1981   Arguments::assert_is_dumping_archive();
1982   if (ik-&gt;init_state() &lt; InstanceKlass::linked &amp;&amp;
1983       !SystemDictionaryShared::has_class_failed_verification(ik)) {
1984     bool saved = BytecodeVerificationLocal;
1985     if (ik-&gt;is_shared_unregistered_class() &amp;&amp; ik-&gt;class_loader() == NULL) {
1986       // The verification decision is based on BytecodeVerificationRemote
1987       // for non-system classes. Since we are using the NULL classloader
1988       // to load non-system classes for customized class loaders during dumping,
1989       // we need to temporarily change BytecodeVerificationLocal to be the same as
1990       // BytecodeVerificationRemote. Note this can cause the parent system
1991       // classes also being verified. The extra overhead is acceptable during
1992       // dumping.
1993       BytecodeVerificationLocal = BytecodeVerificationRemote;
1994     }
1995     ik-&gt;link_class(THREAD);
1996     if (HAS_PENDING_EXCEPTION) {
1997       ResourceMark rm(THREAD);
1998       log_warning(cds)(&quot;Preload Warning: Verification failed for %s&quot;,
1999                     ik-&gt;external_name());
2000       CLEAR_PENDING_EXCEPTION;
2001       SystemDictionaryShared::set_class_has_failed_verification(ik);
2002       _has_error_classes = true;
2003     }
2004     BytecodeVerificationLocal = saved;
2005     return true;
2006   } else {
2007     return false;
2008   }
2009 }
2010 
2011 #if INCLUDE_CDS_JAVA_HEAP
2012 void VM_PopulateDumpSharedSpace::dump_java_heap_objects() {
2013   // The closed and open archive heap space has maximum two regions.
2014   // See FileMapInfo::write_archive_heap_regions() for details.
2015   _closed_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
2016   _open_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
2017   HeapShared::archive_java_heap_objects(_closed_archive_heap_regions,
2018                                         _open_archive_heap_regions);
2019   ArchiveCompactor::OtherROAllocMark mark;
2020   HeapShared::write_subgraph_info_table();
2021 }
2022 
2023 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps() {
2024   if (HeapShared::is_heap_object_archiving_allowed()) {
2025     _closed_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
2026     dump_archive_heap_oopmaps(_closed_archive_heap_regions, _closed_archive_heap_oopmaps);
2027 
2028     _open_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
2029     dump_archive_heap_oopmaps(_open_archive_heap_regions, _open_archive_heap_oopmaps);
2030   }
2031 }
2032 
2033 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
2034                                                            GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps) {
2035   for (int i=0; i&lt;regions-&gt;length(); i++) {
2036     ResourceBitMap oopmap = HeapShared::calculate_oopmap(regions-&gt;at(i));
2037     size_t size_in_bits = oopmap.size();
2038     size_t size_in_bytes = oopmap.size_in_bytes();
2039     uintptr_t* buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);
2040     oopmap.write_to(buffer, size_in_bytes);
2041     log_info(cds, heap)(&quot;Oopmap = &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(6) &quot; bytes) for heap region &quot;
2042                         INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(8) &quot; bytes)&quot;,
2043                         p2i(buffer), size_in_bytes,
2044                         p2i(regions-&gt;at(i).start()), regions-&gt;at(i).byte_size());
2045 
2046     ArchiveHeapOopmapInfo info;
2047     info._oopmap = (address)buffer;
2048     info._oopmap_size_in_bits = size_in_bits;
2049     info._oopmap_size_in_bytes = size_in_bytes;
2050     oopmaps-&gt;append(info);
2051   }
2052 }
2053 #endif // INCLUDE_CDS_JAVA_HEAP
2054 
2055 void ReadClosure::do_ptr(void** p) {
2056   assert(*p == NULL, &quot;initializing previous initialized pointer.&quot;);
2057   intptr_t obj = nextPtr();
2058   assert((intptr_t)obj &gt;= 0 || (intptr_t)obj &lt; -100,
2059          &quot;hit tag while initializing ptrs.&quot;);
2060   *p = (void*)obj;
2061 }
2062 
2063 void ReadClosure::do_u4(u4* p) {
2064   intptr_t obj = nextPtr();
2065   *p = (u4)(uintx(obj));
2066 }
2067 
2068 void ReadClosure::do_bool(bool* p) {
2069   intptr_t obj = nextPtr();
2070   *p = (bool)(uintx(obj));
2071 }
2072 
2073 void ReadClosure::do_tag(int tag) {
2074   int old_tag;
2075   old_tag = (int)(intptr_t)nextPtr();
2076   // do_int(&amp;old_tag);
2077   assert(tag == old_tag, &quot;old tag doesn&#39;t match&quot;);
2078   FileMapInfo::assert_mark(tag == old_tag);
2079 }
2080 
2081 void ReadClosure::do_oop(oop *p) {
2082   narrowOop o = (narrowOop)nextPtr();
2083   if (o == 0 || !HeapShared::open_archive_heap_region_mapped()) {
2084     p = NULL;
2085   } else {
2086     assert(HeapShared::is_heap_object_archiving_allowed(),
2087            &quot;Archived heap object is not allowed&quot;);
2088     assert(HeapShared::open_archive_heap_region_mapped(),
2089            &quot;Open archive heap region is not mapped&quot;);
2090     *p = HeapShared::decode_from_archive(o);
2091   }
2092 }
2093 
2094 void ReadClosure::do_region(u_char* start, size_t size) {
2095   assert((intptr_t)start % sizeof(intptr_t) == 0, &quot;bad alignment&quot;);
2096   assert(size % sizeof(intptr_t) == 0, &quot;bad size&quot;);
2097   do_tag((int)size);
2098   while (size &gt; 0) {
2099     *(intptr_t*)start = nextPtr();
2100     start += sizeof(intptr_t);
2101     size -= sizeof(intptr_t);
2102   }
2103 }
2104 
2105 void MetaspaceShared::set_shared_metaspace_range(void* base, void *static_top, void* top) {
2106   assert(base &lt;= static_top &amp;&amp; static_top &lt;= top, &quot;must be&quot;);
2107   _shared_metaspace_static_top = static_top;
2108   MetaspaceObj::set_shared_metaspace_range(base, top);
2109 }
2110 
2111 // Return true if given address is in the misc data region
2112 bool MetaspaceShared::is_in_shared_region(const void* p, int idx) {
2113   return UseSharedSpaces &amp;&amp; FileMapInfo::current_info()-&gt;is_in_shared_region(p, idx);
2114 }
2115 
2116 bool MetaspaceShared::is_in_trampoline_frame(address addr) {
2117   if (UseSharedSpaces &amp;&amp; is_in_shared_region(addr, MetaspaceShared::mc)) {
2118     return true;
2119   }
2120   return false;
2121 }
2122 
2123 bool MetaspaceShared::is_shared_dynamic(void* p) {
2124   if ((p &lt; MetaspaceObj::shared_metaspace_top()) &amp;&amp;
2125       (p &gt;= _shared_metaspace_static_top)) {
2126     return true;
2127   } else {
2128     return false;
2129   }
2130 }
2131 
2132 void MetaspaceShared::initialize_runtime_shared_and_meta_spaces() {
2133   assert(UseSharedSpaces, &quot;Must be called when UseSharedSpaces is enabled&quot;);
2134   MapArchiveResult result = MAP_ARCHIVE_OTHER_FAILURE;
2135 
2136   FileMapInfo* static_mapinfo = open_static_archive();
2137   FileMapInfo* dynamic_mapinfo = NULL;
2138 
2139   if (static_mapinfo != NULL) {
2140     dynamic_mapinfo = open_dynamic_archive();
2141 
2142     // First try to map at the requested address
2143     result = map_archives(static_mapinfo, dynamic_mapinfo, true);
2144     if (result == MAP_ARCHIVE_MMAP_FAILURE) {
2145       // Mapping has failed (probably due to ASLR). Let&#39;s map at an address chosen
2146       // by the OS.
2147       log_info(cds)(&quot;Try to map archive(s) at an alternative address&quot;);
2148       result = map_archives(static_mapinfo, dynamic_mapinfo, false);
2149     }
2150   }
2151 
2152   if (result == MAP_ARCHIVE_SUCCESS) {
2153     bool dynamic_mapped = (dynamic_mapinfo != NULL &amp;&amp; dynamic_mapinfo-&gt;is_mapped());
2154     char* cds_base = static_mapinfo-&gt;mapped_base();
2155     char* cds_end =  dynamic_mapped ? dynamic_mapinfo-&gt;mapped_end() : static_mapinfo-&gt;mapped_end();
2156     set_shared_metaspace_range(cds_base, static_mapinfo-&gt;mapped_end(), cds_end);
2157     _relocation_delta = static_mapinfo-&gt;relocation_delta();
2158     if (dynamic_mapped) {
2159       FileMapInfo::set_shared_path_table(dynamic_mapinfo);
2160     } else {
2161       FileMapInfo::set_shared_path_table(static_mapinfo);
2162     }
2163   } else {
2164     set_shared_metaspace_range(NULL, NULL, NULL);
2165     UseSharedSpaces = false;
2166     FileMapInfo::fail_continue(&quot;Unable to map shared spaces&quot;);
2167     if (PrintSharedArchiveAndExit) {
2168       vm_exit_during_initialization(&quot;Unable to use shared archive.&quot;);
2169     }
2170   }
2171 
2172   if (static_mapinfo != NULL &amp;&amp; !static_mapinfo-&gt;is_mapped()) {
2173     delete static_mapinfo;
2174   }
2175   if (dynamic_mapinfo != NULL &amp;&amp; !dynamic_mapinfo-&gt;is_mapped()) {
2176     delete dynamic_mapinfo;
2177   }
2178 }
2179 
2180 FileMapInfo* MetaspaceShared::open_static_archive() {
2181   FileMapInfo* mapinfo = new FileMapInfo(true);
2182   if (!mapinfo-&gt;initialize()) {
2183     delete(mapinfo);
2184     return NULL;
2185   }
2186   return mapinfo;
2187 }
2188 
2189 FileMapInfo* MetaspaceShared::open_dynamic_archive() {
2190   if (DynamicDumpSharedSpaces) {
2191     return NULL;
2192   }
2193   if (Arguments::GetSharedDynamicArchivePath() == NULL) {
2194     return NULL;
2195   }
2196 
2197   FileMapInfo* mapinfo = new FileMapInfo(false);
2198   if (!mapinfo-&gt;initialize()) {
2199     delete(mapinfo);
2200     return NULL;
2201   }
2202   return mapinfo;
2203 }
2204 
2205 // use_requested_addr:
2206 //  true  = map at FileMapHeader::_requested_base_address
2207 //  false = map at an alternative address picked by OS.
2208 MapArchiveResult MetaspaceShared::map_archives(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo,
2209                                                bool use_requested_addr) {
2210   PRODUCT_ONLY(if (ArchiveRelocationMode == 1 &amp;&amp; use_requested_addr) {
2211       // For product build only -- this is for benchmarking the cost of doing relocation.
2212       // For debug builds, the check is done below, after reserving the space, for better test coverage
2213       // (see comment below).
2214       log_info(cds)(&quot;ArchiveRelocationMode == 1: always map archive(s) at an alternative address&quot;);
2215       return MAP_ARCHIVE_MMAP_FAILURE;
2216     });
2217 
2218   if (ArchiveRelocationMode == 2 &amp;&amp; !use_requested_addr) {
2219     log_info(cds)(&quot;ArchiveRelocationMode == 2: never map archive(s) at an alternative address&quot;);
2220     return MAP_ARCHIVE_MMAP_FAILURE;
2221   };
2222 
2223   if (dynamic_mapinfo != NULL) {
2224     // Ensure that the OS won&#39;t be able to allocate new memory spaces between the two
2225     // archives, or else it would mess up the simple comparision in MetaspaceObj::is_shared().
2226     assert(static_mapinfo-&gt;mapping_end_offset() == dynamic_mapinfo-&gt;mapping_base_offset(), &quot;no gap&quot;);
2227   }
2228 
2229   ReservedSpace archive_space_rs, class_space_rs;
2230   MapArchiveResult result = MAP_ARCHIVE_OTHER_FAILURE;
2231   char* mapped_base_address = reserve_address_space_for_archives(static_mapinfo, dynamic_mapinfo,
2232                                                                  use_requested_addr, archive_space_rs,
2233                                                                  class_space_rs);
2234   if (mapped_base_address == NULL) {
2235     result = MAP_ARCHIVE_MMAP_FAILURE;
2236   } else {
2237 
2238 #ifdef ASSERT
2239     // Some sanity checks after reserving address spaces for archives
2240     //  and class space.
2241     assert(archive_space_rs.is_reserved(), &quot;Sanity&quot;);
2242     if (Metaspace::using_class_space()) {
2243       // Class space must closely follow the archive space. Both spaces
2244       //  must be aligned correctly.
2245       assert(class_space_rs.is_reserved(),
2246              &quot;A class space should have been reserved&quot;);
2247       assert(class_space_rs.base() &gt;= archive_space_rs.end(),
2248              &quot;class space should follow the cds archive space&quot;);
2249       assert(is_aligned(archive_space_rs.base(),
2250                         MetaspaceShared::reserved_space_alignment()),
2251              &quot;Archive space misaligned&quot;);
2252       assert(is_aligned(class_space_rs.base(),
2253                         Metaspace::reserve_alignment()),
2254              &quot;class space misaligned&quot;);
2255     }
2256 #endif // ASSERT
2257 
2258     log_debug(cds)(&quot;Reserved archive_space_rs     [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;] (&quot; SIZE_FORMAT &quot;) bytes&quot;,
2259                    p2i(archive_space_rs.base()), p2i(archive_space_rs.end()), archive_space_rs.size());
2260     log_debug(cds)(&quot;Reserved class_space_rs [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;] (&quot; SIZE_FORMAT &quot;) bytes&quot;,
2261                    p2i(class_space_rs.base()), p2i(class_space_rs.end()), class_space_rs.size());
2262 
2263     if (MetaspaceShared::use_windows_memory_mapping()) {
2264       // We have now reserved address space for the archives, and will map in
2265       //  the archive files into this space.
2266       //
2267       // Special handling for Windows: on Windows we cannot map a file view
2268       //  into an existing memory mapping. So, we unmap the address range we
2269       //  just reserved again, which will make it available for mapping the
2270       //  archives.
2271       // Reserving this range has not been for naught however since it makes
2272       //  us reasonably sure the address range is available.
2273       //
2274       // But still it may fail, since between unmapping the range and mapping
2275       //  in the archive someone else may grab the address space. Therefore
2276       //  there is a fallback in FileMap::map_region() where we just read in
2277       //  the archive files sequentially instead of mapping it in. We couple
2278       //  this with use_requested_addr, since we&#39;re going to patch all the
2279       //  pointers anyway so there&#39;s no benefit to mmap.
2280       if (use_requested_addr) {
2281         log_info(cds)(&quot;Windows mmap workaround: releasing archive space.&quot;);
2282         archive_space_rs.release();
2283       }
2284     }
2285     MapArchiveResult static_result = map_archive(static_mapinfo, mapped_base_address, archive_space_rs);
2286     MapArchiveResult dynamic_result = (static_result == MAP_ARCHIVE_SUCCESS) ?
2287                                      map_archive(dynamic_mapinfo, mapped_base_address, archive_space_rs) : MAP_ARCHIVE_OTHER_FAILURE;
2288 
2289     DEBUG_ONLY(if (ArchiveRelocationMode == 1 &amp;&amp; use_requested_addr) {
2290       // This is for simulating mmap failures at the requested address. In
2291       //  debug builds, we do it here (after all archives have possibly been
2292       //  mapped), so we can thoroughly test the code for failure handling
2293       //  (releasing all allocated resource, etc).
2294       log_info(cds)(&quot;ArchiveRelocationMode == 1: always map archive(s) at an alternative address&quot;);
2295       if (static_result == MAP_ARCHIVE_SUCCESS) {
2296         static_result = MAP_ARCHIVE_MMAP_FAILURE;
2297       }
2298       if (dynamic_result == MAP_ARCHIVE_SUCCESS) {
2299         dynamic_result = MAP_ARCHIVE_MMAP_FAILURE;
2300       }
2301     });
2302 
2303     if (static_result == MAP_ARCHIVE_SUCCESS) {
2304       if (dynamic_result == MAP_ARCHIVE_SUCCESS) {
2305         result = MAP_ARCHIVE_SUCCESS;
2306       } else if (dynamic_result == MAP_ARCHIVE_OTHER_FAILURE) {
2307         assert(dynamic_mapinfo != NULL &amp;&amp; !dynamic_mapinfo-&gt;is_mapped(), &quot;must have failed&quot;);
2308         // No need to retry mapping the dynamic archive again, as it will never succeed
2309         // (bad file, etc) -- just keep the base archive.
2310         log_warning(cds, dynamic)(&quot;Unable to use shared archive. The top archive failed to load: %s&quot;,
2311                                   dynamic_mapinfo-&gt;full_path());
2312         result = MAP_ARCHIVE_SUCCESS;
2313         // TODO, we can give the unused space for the dynamic archive to class_space_rs, but there&#39;s no
2314         // easy API to do that right now.
2315       } else {
2316         result = MAP_ARCHIVE_MMAP_FAILURE;
2317       }
2318     } else if (static_result == MAP_ARCHIVE_OTHER_FAILURE) {
2319       result = MAP_ARCHIVE_OTHER_FAILURE;
2320     } else {
2321       result = MAP_ARCHIVE_MMAP_FAILURE;
2322     }
2323   }
2324 
2325   if (result == MAP_ARCHIVE_SUCCESS) {
2326     SharedBaseAddress = (size_t)mapped_base_address;
2327     LP64_ONLY({
2328         if (Metaspace::using_class_space()) {
2329           // Set up ccs in metaspace.
2330           Metaspace::initialize_class_space(class_space_rs);
2331 
2332           // Set up compressed Klass pointer encoding: the encoding range must
2333           //  cover both archive and class space.
2334           address cds_base = (address)static_mapinfo-&gt;mapped_base();
2335           address ccs_end = (address)class_space_rs.end();
2336           CompressedKlassPointers::initialize(cds_base, ccs_end - cds_base);
2337 
2338           // map_heap_regions() compares the current narrow oop and klass encodings
2339           // with the archived ones, so it must be done after all encodings are determined.
2340           static_mapinfo-&gt;map_heap_regions();
2341         }
2342       });
2343   } else {
2344     unmap_archive(static_mapinfo);
2345     unmap_archive(dynamic_mapinfo);
2346     release_reserved_spaces(archive_space_rs, class_space_rs);
2347   }
2348 
2349   return result;
2350 }
2351 
2352 
2353 // This will reserve two address spaces suitable to house Klass structures, one
2354 //  for the cds archives (static archive and optionally dynamic archive) and
2355 //  optionally one move for ccs.
2356 //
2357 // Since both spaces must fall within the compressed class pointer encoding
2358 //  range, they are allocated close to each other.
2359 //
2360 // Space for archives will be reserved first, followed by a potential gap,
2361 //  followed by the space for ccs:
2362 //
2363 // +-- Base address             A        B                     End
2364 // |                            |        |                      |
2365 // v                            v        v                      v
2366 // +-------------+--------------+        +----------------------+
2367 // | static arc  | [dyn. arch]  | [gap]  | compr. class space   |
2368 // +-------------+--------------+        +----------------------+
2369 //
2370 // (The gap may result from different alignment requirements between metaspace
2371 //  and CDS)
2372 //
2373 // If UseCompressedClassPointers is disabled, only one address space will be
2374 //  reserved:
2375 //
2376 // +-- Base address             End
2377 // |                            |
2378 // v                            v
2379 // +-------------+--------------+
2380 // | static arc  | [dyn. arch]  |
2381 // +-------------+--------------+
2382 //
2383 // Base address: If use_archive_base_addr address is true, the Base address is
2384 //  determined by the address stored in the static archive. If
2385 //  use_archive_base_addr address is false, this base address is determined
2386 //  by the platform.
2387 //
2388 // If UseCompressedClassPointers=1, the range encompassing both spaces will be
2389 //  suitable to en/decode narrow Klass pointers: the base will be valid for
2390 //  encoding, the range [Base, End) not surpass KlassEncodingMetaspaceMax.
2391 //
2392 // Return:
2393 //
2394 // - On success:
2395 //    - archive_space_rs will be reserved and large enough to host static and
2396 //      if needed dynamic archive: [Base, A).
2397 //      archive_space_rs.base and size will be aligned to CDS reserve
2398 //      granularity.
2399 //    - class_space_rs: If UseCompressedClassPointers=1, class_space_rs will
2400 //      be reserved. Its start address will be aligned to metaspace reserve
2401 //      alignment, which may differ from CDS alignment. It will follow the cds
2402 //      archive space, close enough such that narrow class pointer encoding
2403 //      covers both spaces.
2404 //      If UseCompressedClassPointers=0, class_space_rs remains unreserved.
2405 // - On error: NULL is returned and the spaces remain unreserved.
2406 char* MetaspaceShared::reserve_address_space_for_archives(FileMapInfo* static_mapinfo,
2407                                                           FileMapInfo* dynamic_mapinfo,
2408                                                           bool use_archive_base_addr,
2409                                                           ReservedSpace&amp; archive_space_rs,
2410                                                           ReservedSpace&amp; class_space_rs) {
2411 
2412   address const base_address = (address) (use_archive_base_addr ? static_mapinfo-&gt;requested_base_address() : NULL);
2413   const size_t archive_space_alignment = MetaspaceShared::reserved_space_alignment();
2414 
2415   // Size and requested location of the archive_space_rs (for both static and dynamic archives)
2416   assert(static_mapinfo-&gt;mapping_base_offset() == 0, &quot;Must be&quot;);
2417   size_t archive_end_offset  = (dynamic_mapinfo == NULL) ? static_mapinfo-&gt;mapping_end_offset() : dynamic_mapinfo-&gt;mapping_end_offset();
2418   size_t archive_space_size = align_up(archive_end_offset, archive_space_alignment);
2419 
2420   // If a base address is given, it must have valid alignment and be suitable as encoding base.
2421   if (base_address != NULL) {
2422     assert(is_aligned(base_address, archive_space_alignment),
2423            &quot;Archive base address invalid: &quot; PTR_FORMAT &quot;.&quot;, p2i(base_address));
2424     if (Metaspace::using_class_space()) {
2425       assert(CompressedKlassPointers::is_valid_base(base_address),
2426              &quot;Archive base address invalid: &quot; PTR_FORMAT &quot;.&quot;, p2i(base_address));
2427     }
2428   }
2429 
2430   if (!Metaspace::using_class_space()) {
2431     // Get the simple case out of the way first:
2432     // no compressed class space, simple allocation.
2433     archive_space_rs = ReservedSpace(archive_space_size, archive_space_alignment,
2434                                      false /* bool large */, (char*)base_address);
2435     if (archive_space_rs.is_reserved()) {
2436       assert(base_address == NULL ||
2437              (address)archive_space_rs.base() == base_address, &quot;Sanity&quot;);
2438       return archive_space_rs.base();
2439     }
2440     return NULL;
2441   }
2442 
2443 #ifdef _LP64
2444 
2445   // Complex case: two spaces adjacent to each other, both to be addressable
2446   //  with narrow class pointers.
2447   // We reserve the whole range spanning both spaces, then split that range up.
2448 
2449   const size_t class_space_alignment = Metaspace::reserve_alignment();
2450 
2451   // To simplify matters, lets assume that metaspace alignment will always be
2452   //  equal or a multiple of archive alignment.
2453   assert(is_power_of_2(class_space_alignment) &amp;&amp;
2454                        is_power_of_2(archive_space_alignment) &amp;&amp;
2455                        class_space_alignment &gt;= archive_space_alignment,
2456                        &quot;Sanity&quot;);
2457 
2458   const size_t class_space_size = CompressedClassSpaceSize;
2459   assert(CompressedClassSpaceSize &gt; 0 &amp;&amp;
2460          is_aligned(CompressedClassSpaceSize, class_space_alignment),
2461          &quot;CompressedClassSpaceSize malformed: &quot;
2462          SIZE_FORMAT, CompressedClassSpaceSize);
2463 
2464   const size_t ccs_begin_offset = align_up(archive_space_size,
2465                                            class_space_alignment);
2466   const size_t gap_size = ccs_begin_offset - archive_space_size;
2467 
2468   const size_t total_range_size =
2469       align_up(archive_space_size + gap_size + class_space_size,
2470                os::vm_allocation_granularity());
2471 
2472   ReservedSpace total_rs;
2473   if (base_address != NULL) {
2474     // Reserve at the given archive base address, or not at all.
2475     total_rs = ReservedSpace(total_range_size, archive_space_alignment,
2476                              false /* bool large */, (char*) base_address);
2477   } else {
2478     // Reserve at any address, but leave it up to the platform to choose a good one.
2479     total_rs = Metaspace::reserve_address_space_for_compressed_classes(total_range_size);
2480   }
2481 
2482   if (!total_rs.is_reserved()) {
2483     return NULL;
2484   }
2485 
2486   // Paranoid checks:
2487   assert(base_address == NULL || (address)total_rs.base() == base_address,
2488          &quot;Sanity (&quot; PTR_FORMAT &quot; vs &quot; PTR_FORMAT &quot;)&quot;, p2i(base_address), p2i(total_rs.base()));
2489   assert(is_aligned(total_rs.base(), archive_space_alignment), &quot;Sanity&quot;);
2490   assert(total_rs.size() == total_range_size, &quot;Sanity&quot;);
2491   assert(CompressedKlassPointers::is_valid_base((address)total_rs.base()), &quot;Sanity&quot;);
2492 
2493   // Now split up the space into ccs and cds archive. For simplicity, just leave
2494   //  the gap reserved at the end of the archive space.
2495   archive_space_rs = total_rs.first_part(ccs_begin_offset,
2496                                          (size_t)os::vm_allocation_granularity(),
2497                                          /*split=*/true);
2498   class_space_rs = total_rs.last_part(ccs_begin_offset);
2499 
2500   assert(is_aligned(archive_space_rs.base(), archive_space_alignment), &quot;Sanity&quot;);
2501   assert(is_aligned(archive_space_rs.size(), archive_space_alignment), &quot;Sanity&quot;);
2502   assert(is_aligned(class_space_rs.base(), class_space_alignment), &quot;Sanity&quot;);
2503   assert(is_aligned(class_space_rs.size(), class_space_alignment), &quot;Sanity&quot;);
2504 
2505   return archive_space_rs.base();
2506 
2507 #else
2508   ShouldNotReachHere();
2509   return NULL;
2510 #endif
2511 
2512 }
2513 
2514 void MetaspaceShared::release_reserved_spaces(ReservedSpace&amp; archive_space_rs,
2515                                               ReservedSpace&amp; class_space_rs) {
2516   if (archive_space_rs.is_reserved()) {
2517     log_debug(cds)(&quot;Released shared space (archive) &quot; INTPTR_FORMAT, p2i(archive_space_rs.base()));
2518     archive_space_rs.release();
2519   }
2520   if (class_space_rs.is_reserved()) {
2521     log_debug(cds)(&quot;Released shared space (classes) &quot; INTPTR_FORMAT, p2i(class_space_rs.base()));
2522     class_space_rs.release();
2523   }
2524 }
2525 
2526 static int archive_regions[]  = {MetaspaceShared::mc,
2527                                  MetaspaceShared::rw,
2528                                  MetaspaceShared::ro};
2529 static int archive_regions_count  = 3;
2530 
2531 MapArchiveResult MetaspaceShared::map_archive(FileMapInfo* mapinfo, char* mapped_base_address, ReservedSpace rs) {
2532   assert(UseSharedSpaces, &quot;must be runtime&quot;);
2533   if (mapinfo == NULL) {
2534     return MAP_ARCHIVE_SUCCESS; // The dynamic archive has not been specified. No error has happened -- trivially succeeded.
2535   }
2536 
2537   mapinfo-&gt;set_is_mapped(false);
2538 
2539   if (mapinfo-&gt;alignment() != (size_t)os::vm_allocation_granularity()) {
2540     log_error(cds)(&quot;Unable to map CDS archive -- os::vm_allocation_granularity() expected: &quot; SIZE_FORMAT
2541                    &quot; actual: %d&quot;, mapinfo-&gt;alignment(), os::vm_allocation_granularity());
2542     return MAP_ARCHIVE_OTHER_FAILURE;
2543   }
2544 
2545   MapArchiveResult result =
2546     mapinfo-&gt;map_regions(archive_regions, archive_regions_count, mapped_base_address, rs);
2547 
2548   if (result != MAP_ARCHIVE_SUCCESS) {
2549     unmap_archive(mapinfo);
2550     return result;
2551   }
2552 
2553   if (mapinfo-&gt;is_static()) {
2554     if (!mapinfo-&gt;validate_shared_path_table()) {
2555       unmap_archive(mapinfo);
2556       return MAP_ARCHIVE_OTHER_FAILURE;
2557     }
2558   } else {
2559     if (!DynamicArchive::validate(mapinfo)) {
2560       unmap_archive(mapinfo);
2561       return MAP_ARCHIVE_OTHER_FAILURE;
2562     }
2563   }
2564 
2565   mapinfo-&gt;set_is_mapped(true);
2566   return MAP_ARCHIVE_SUCCESS;
2567 }
2568 
2569 void MetaspaceShared::unmap_archive(FileMapInfo* mapinfo) {
2570   assert(UseSharedSpaces, &quot;must be runtime&quot;);
2571   if (mapinfo != NULL) {
2572     mapinfo-&gt;unmap_regions(archive_regions, archive_regions_count);
2573     mapinfo-&gt;set_is_mapped(false);
2574   }
2575 }
2576 
2577 // Read the miscellaneous data from the shared file, and
2578 // serialize it out to its various destinations.
2579 
2580 void MetaspaceShared::initialize_shared_spaces() {
2581   FileMapInfo *static_mapinfo = FileMapInfo::current_info();
2582   _i2i_entry_code_buffers = static_mapinfo-&gt;i2i_entry_code_buffers();
2583   _i2i_entry_code_buffers_size = static_mapinfo-&gt;i2i_entry_code_buffers_size();
2584   char* buffer = static_mapinfo-&gt;cloned_vtables();
2585   clone_cpp_vtables((intptr_t*)buffer);
2586 
2587   // Verify various attributes of the archive, plus initialize the
2588   // shared string/symbol tables
2589   buffer = static_mapinfo-&gt;serialized_data();
2590   intptr_t* array = (intptr_t*)buffer;
2591   ReadClosure rc(&amp;array);
2592   serialize(&amp;rc);
2593 
2594   // Initialize the run-time symbol table.
2595   SymbolTable::create_table();
2596 
2597   static_mapinfo-&gt;patch_archived_heap_embedded_pointers();
2598 
2599   // Close the mapinfo file
2600   static_mapinfo-&gt;close();
2601 
2602   static_mapinfo-&gt;unmap_region(MetaspaceShared::bm);
2603 
2604   FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();
2605   if (dynamic_mapinfo != NULL) {
2606     intptr_t* buffer = (intptr_t*)dynamic_mapinfo-&gt;serialized_data();
2607     ReadClosure rc(&amp;buffer);
2608     SymbolTable::serialize_shared_table_header(&amp;rc, false);
2609     SystemDictionaryShared::serialize_dictionary_headers(&amp;rc, false);
2610     dynamic_mapinfo-&gt;close();
2611   }
2612 
2613   if (PrintSharedArchiveAndExit) {
2614     if (PrintSharedDictionary) {
2615       tty-&gt;print_cr(&quot;\nShared classes:\n&quot;);
2616       SystemDictionaryShared::print_on(tty);
2617     }
2618     if (FileMapInfo::current_info() == NULL || _archive_loading_failed) {
2619       tty-&gt;print_cr(&quot;archive is invalid&quot;);
2620       vm_exit(1);
2621     } else {
2622       tty-&gt;print_cr(&quot;archive is valid&quot;);
2623       vm_exit(0);
2624     }
2625   }
2626 }
2627 
2628 // JVM/TI RedefineClasses() support:
2629 bool MetaspaceShared::remap_shared_readonly_as_readwrite() {
2630   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
2631 
2632   if (UseSharedSpaces) {
2633     // remap the shared readonly space to shared readwrite, private
2634     FileMapInfo* mapinfo = FileMapInfo::current_info();
2635     if (!mapinfo-&gt;remap_shared_readonly_as_readwrite()) {
2636       return false;
2637     }
2638     if (FileMapInfo::dynamic_info() != NULL) {
2639       mapinfo = FileMapInfo::dynamic_info();
2640       if (!mapinfo-&gt;remap_shared_readonly_as_readwrite()) {
2641         return false;
2642       }
2643     }
2644     _remapped_readwrite = true;
2645   }
2646   return true;
2647 }
2648 
2649 void MetaspaceShared::report_out_of_space(const char* name, size_t needed_bytes) {
2650   // This is highly unlikely to happen on 64-bits because we have reserved a 4GB space.
2651   // On 32-bit we reserve only 256MB so you could run out of space with 100,000 classes
2652   // or so.
2653   _mc_region.print_out_of_space_msg(name, needed_bytes);
2654   _rw_region.print_out_of_space_msg(name, needed_bytes);
2655   _ro_region.print_out_of_space_msg(name, needed_bytes);
2656 
2657   vm_exit_during_initialization(err_msg(&quot;Unable to allocate from &#39;%s&#39; region&quot;, name),
2658                                 &quot;Please reduce the number of shared classes.&quot;);
2659 }
2660 
2661 // This is used to relocate the pointers so that the archive can be mapped at
2662 // Arguments::default_SharedBaseAddress() without runtime relocation.
2663 intx MetaspaceShared::final_delta() {
2664   return intx(Arguments::default_SharedBaseAddress())  // We want the archive to be mapped to here at runtime
2665        - intx(SharedBaseAddress);                      // .. but the archive is mapped at here at dump time
2666 }
2667 
2668 void MetaspaceShared::print_on(outputStream* st) {
2669   if (UseSharedSpaces || DumpSharedSpaces) {
2670     st-&gt;print(&quot;CDS archive(s) mapped at: &quot;);
2671     address base;
2672     address top;
2673     if (UseSharedSpaces) { // Runtime
2674       base = (address)MetaspaceObj::shared_metaspace_base();
2675       address static_top = (address)_shared_metaspace_static_top;
2676       top = (address)MetaspaceObj::shared_metaspace_top();
2677       st-&gt;print(&quot;[&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot;), &quot;, p2i(base), p2i(static_top), p2i(top));
2678     } else if (DumpSharedSpaces) { // Dump Time
2679       base = (address)_shared_rs.base();
2680       top = (address)_shared_rs.end();
2681       st-&gt;print(&quot;[&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot;), &quot;, p2i(base), p2i(top));
2682     }
2683     st-&gt;print(&quot;size &quot; SIZE_FORMAT &quot;, &quot;, top - base);
2684     st-&gt;print(&quot;SharedBaseAddress: &quot; PTR_FORMAT &quot;, ArchiveRelocationMode: %d.&quot;, SharedBaseAddress, (int)ArchiveRelocationMode);
2685   } else {
2686     st-&gt;print(&quot;CDS disabled.&quot;);
2687   }
2688   st-&gt;cr();
2689 }
2690 
2691 
2692 
2693 
2694 
    </pre>
  </body>
</html>
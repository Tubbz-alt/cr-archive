<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jniCheck.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jni.h&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;logging/log.hpp&quot;
  32 #include &quot;logging/logTag.hpp&quot;
  33 #include &quot;memory/allocation.inline.hpp&quot;
  34 #include &quot;memory/guardedMemory.hpp&quot;
  35 #include &quot;oops/instanceKlass.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;oops/symbol.hpp&quot;
  38 #include &quot;prims/jniCheck.hpp&quot;
  39 #include &quot;prims/jvm_misc.hpp&quot;
  40 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  41 #include &quot;runtime/handles.inline.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  44 #include &quot;runtime/jniHandles.inline.hpp&quot;
  45 #include &quot;runtime/thread.inline.hpp&quot;
<a name="2" id="anc2"></a>
  46 
  47 // Complain every extra number of unplanned local refs
  48 #define CHECK_JNI_LOCAL_REF_CAP_WARN_THRESHOLD 32
  49 
  50 // Heap objects are allowed to be directly referenced only in VM code,
  51 // not in native code.
  52 
  53 #define ASSERT_OOPS_ALLOWED                                          \
  54     assert(JavaThread::current()-&gt;thread_state() == _thread_in_vm,   \
  55            &quot;jniCheck examining oops in bad state.&quot;)
  56 
  57 
  58 // Execute the given block of source code with the thread in VM state.
  59 // To do this, transition from the NATIVE state to the VM state, execute
  60 // the code, and transtition back.  The ThreadInVMfromNative constructor
  61 // performs the transition to VM state, its destructor restores the
  62 // NATIVE state.
  63 
  64 #define IN_VM(source_code)   {                                         \
  65     {                                                                  \
  66       ThreadInVMfromNative __tiv(thr);                                 \
  67       source_code                                                      \
  68     }                                                                  \
  69   }
  70 
  71 
  72 /*
  73  * DECLARATIONS
  74  */
  75 
  76 static struct JNINativeInterface_ * unchecked_jni_NativeInterface;
  77 
  78 
  79 /*
  80  * MACRO DEFINITIONS
  81  */
  82 
  83 // All JNI checked functions here use JNI_ENTRY_CHECKED() instead of the
  84 // QUICK_ENTRY or LEAF variants found in jni.cpp.  This allows handles
  85 // to be created if a fatal error should occur.
  86 
  87 // Check for thread not attached to VM;  need to catch this before
  88 // assertions in the wrapper routines might fire
  89 
  90 // Check for env being the one value appropriate for this thread.
  91 
  92 #define JNI_ENTRY_CHECKED(result_type, header)                           \
  93 extern &quot;C&quot; {                                                             \
  94   result_type JNICALL header {                                           \
  95     JavaThread* thr = (JavaThread*) Thread::current_or_null();           \
  96     if (thr == NULL || !thr-&gt;is_Java_thread()) {                         \
  97       tty-&gt;print_cr(&quot;%s&quot;, fatal_using_jnienv_in_nonjava);                \
  98       os::abort(true);                                                   \
  99     }                                                                    \
 100     JNIEnv* xenv = thr-&gt;jni_environment();                               \
 101     if (env != xenv) {                                                   \
 102       NativeReportJNIFatalError(thr, warn_wrong_jnienv);                 \
 103     }                                                                    \
 104     VM_ENTRY_BASE(result_type, header, thr)
 105 
 106 
 107 #define UNCHECKED() (unchecked_jni_NativeInterface)
 108 
 109 static const char * warn_wrong_jnienv = &quot;Using JNIEnv in the wrong thread&quot;;
 110 static const char * warn_bad_class_descriptor1 = &quot;JNI FindClass received a bad class descriptor \&quot;&quot;;
 111 static const char * warn_bad_class_descriptor2 = &quot;\&quot;.  A correct class descriptor &quot; \
 112   &quot;has no leading \&quot;L\&quot; or trailing \&quot;;\&quot;.  Incorrect descriptors will not be accepted in future releases.&quot;;
 113 static const char * fatal_using_jnienv_in_nonjava = &quot;FATAL ERROR in native method: Using JNIEnv in non-Java thread&quot;;
 114 static const char * warn_other_function_in_critical = &quot;Warning: Calling other JNI functions in the scope of &quot; \
 115   &quot;Get/ReleasePrimitiveArrayCritical or Get/ReleaseStringCritical&quot;;
 116 static const char * fatal_bad_ref_to_jni = &quot;Bad global or local ref passed to JNI&quot;;
 117 static const char * fatal_received_null_class = &quot;JNI received a null class&quot;;
 118 static const char * fatal_class_not_a_class = &quot;JNI received a class argument that is not a class&quot;;
 119 static const char * fatal_class_not_a_throwable_class = &quot;JNI Throw or ThrowNew received a class argument that is not a Throwable or Throwable subclass&quot;;
 120 static const char * fatal_wrong_class_or_method = &quot;Wrong object class or methodID passed to JNI call&quot;;
 121 static const char * fatal_non_weak_method = &quot;non-weak methodID passed to JNI call&quot;;
 122 static const char * fatal_unknown_array_object = &quot;Unknown array object passed to JNI array operations&quot;;
 123 static const char * fatal_object_array_expected = &quot;Object array expected but not received for JNI array operation&quot;;
 124 static const char * fatal_prim_type_array_expected = &quot;Primitive type array expected but not received for JNI array operation&quot;;
 125 static const char * fatal_non_array  = &quot;Non-array passed to JNI array operations&quot;;
 126 static const char * fatal_element_type_mismatch = &quot;Array element type mismatch in JNI&quot;;
 127 static const char * fatal_should_be_static = &quot;Non-static field ID passed to JNI&quot;;
 128 static const char * fatal_wrong_static_field = &quot;Wrong static field ID passed to JNI&quot;;
 129 static const char * fatal_static_field_not_found = &quot;Static field not found in JNI get/set field operations&quot;;
 130 static const char * fatal_static_field_mismatch = &quot;Field type (static) mismatch in JNI get/set field operations&quot;;
 131 static const char * fatal_should_be_nonstatic = &quot;Static field ID passed to JNI&quot;;
 132 static const char * fatal_null_object = &quot;Null object passed to JNI&quot;;
 133 static const char * fatal_wrong_field = &quot;Wrong field ID passed to JNI&quot;;
 134 static const char * fatal_instance_field_not_found = &quot;Instance field not found in JNI get/set field operations&quot;;
 135 static const char * fatal_instance_field_mismatch = &quot;Field type (instance) mismatch in JNI get/set field operations&quot;;
 136 static const char * fatal_non_string = &quot;JNI string operation received a non-string&quot;;
<a name="3" id="anc3"></a>

 137 
 138 
 139 // When in VM state:
 140 static void ReportJNIWarning(JavaThread* thr, const char *msg) {
 141   tty-&gt;print_cr(&quot;WARNING in native method: %s&quot;, msg);
 142   thr-&gt;print_stack();
 143 }
 144 
 145 // When in NATIVE state:
 146 static void NativeReportJNIFatalError(JavaThread* thr, const char *msg) {
 147   IN_VM(
 148     ReportJNIFatalError(thr, msg);
 149   )
 150 }
 151 
 152 static void NativeReportJNIWarning(JavaThread* thr, const char *msg) {
 153   IN_VM(
 154     ReportJNIWarning(thr, msg);
 155   )
 156 }
 157 
 158 
 159 
 160 
 161 /*
 162  * SUPPORT FUNCTIONS
 163  */
 164 
 165 /**
 166  * Check whether or not a programmer has actually checked for exceptions. According
 167  * to the JNI Specification (&quot;jni/spec/design.html#java_exceptions&quot;):
 168  *
 169  * There are two cases where the programmer needs to check for exceptions without
 170  * being able to first check an error code:
 171  *
 172  * - The JNI functions that invoke a Java method return the result of the Java method.
 173  * The programmer must call ExceptionOccurred() to check for possible exceptions
 174  * that occurred during the execution of the Java method.
 175  *
 176  * - Some of the JNI array access functions do not return an error code, but may
 177  * throw an ArrayIndexOutOfBoundsException or ArrayStoreException.
 178  *
 179  * In all other cases, a non-error return value guarantees that no exceptions have been thrown.
 180  *
 181  * Programmers often defend against ArrayIndexOutOfBoundsException, so warning
 182  * for these functions would be pedantic.
 183  */
 184 static inline void
 185 check_pending_exception(JavaThread* thr) {
 186   if (thr-&gt;has_pending_exception()) {
 187     NativeReportJNIWarning(thr, &quot;JNI call made with exception pending&quot;);
 188   }
 189   if (thr-&gt;is_pending_jni_exception_check()) {
 190     IN_VM(
 191       tty-&gt;print_cr(&quot;WARNING in native method: JNI call made without checking exceptions when required to from %s&quot;,
 192         thr-&gt;get_pending_jni_exception_check());
 193       thr-&gt;print_stack();
 194     )
 195     thr-&gt;clear_pending_jni_exception_check(); // Just complain once
 196   }
 197 }
 198 
 199 /**
 200  * Add to the planned number of handles. I.e. plus current live &amp; warning threshold
 201  */
 202 static inline void
 203 add_planned_handle_capacity(JNIHandleBlock* handles, size_t capacity) {
 204   handles-&gt;set_planned_capacity(capacity +
 205                                 handles-&gt;get_number_of_live_handles() +
 206                                 CHECK_JNI_LOCAL_REF_CAP_WARN_THRESHOLD);
 207 }
 208 
 209 
 210 static inline void
 211 functionEnterCritical(JavaThread* thr)
 212 {
 213   check_pending_exception(thr);
 214 }
 215 
 216 static inline void
 217 functionEnterCriticalExceptionAllowed(JavaThread* thr)
 218 {
 219 }
 220 
 221 static inline void
 222 functionEnter(JavaThread* thr)
 223 {
 224   if (thr-&gt;in_critical()) {
 225     tty-&gt;print_cr(&quot;%s&quot;, warn_other_function_in_critical);
 226   }
 227   check_pending_exception(thr);
 228 }
 229 
 230 static inline void
 231 functionEnterExceptionAllowed(JavaThread* thr)
 232 {
 233   if (thr-&gt;in_critical()) {
 234     tty-&gt;print_cr(&quot;%s&quot;, warn_other_function_in_critical);
 235   }
 236 }
 237 
 238 static inline void
 239 functionExit(JavaThread* thr)
 240 {
 241   JNIHandleBlock* handles = thr-&gt;active_handles();
 242   size_t planned_capacity = handles-&gt;get_planned_capacity();
 243   size_t live_handles = handles-&gt;get_number_of_live_handles();
 244   if (live_handles &gt; planned_capacity) {
 245     IN_VM(
 246       tty-&gt;print_cr(&quot;WARNING: JNI local refs: &quot; SIZE_FORMAT &quot;, exceeds capacity: &quot; SIZE_FORMAT,
 247                     live_handles, planned_capacity);
 248       thr-&gt;print_stack();
 249     )
 250     // Complain just the once, reset to current + warn threshold
 251     add_planned_handle_capacity(handles, 0);
 252   }
 253 }
 254 
 255 static inline void
 256 checkStaticFieldID(JavaThread* thr, jfieldID fid, jclass cls, int ftype)
 257 {
 258   fieldDescriptor fd;
 259 
 260   /* make sure it is a static field */
 261   if (!jfieldIDWorkaround::is_static_jfieldID(fid))
 262     ReportJNIFatalError(thr, fatal_should_be_static);
 263 
 264   /* validate the class being passed */
 265   ASSERT_OOPS_ALLOWED;
 266   Klass* k_oop = jniCheck::validate_class(thr, cls, false);
 267 
 268   /* check for proper subclass hierarchy */
 269   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fid);
 270   Klass* f_oop = id-&gt;holder();
 271   if (!k_oop-&gt;is_subtype_of(f_oop))
 272     ReportJNIFatalError(thr, fatal_wrong_static_field);
 273 
 274   /* check for proper field type */
 275   if (!id-&gt;find_local_field(&amp;fd))
 276     ReportJNIFatalError(thr, fatal_static_field_not_found);
 277   if ((fd.field_type() != ftype) &amp;&amp;
 278       !(fd.field_type() == T_ARRAY &amp;&amp; ftype == T_OBJECT)) {
 279     ReportJNIFatalError(thr, fatal_static_field_mismatch);
 280   }
 281 }
 282 
 283 static inline void
 284 checkInstanceFieldID(JavaThread* thr, jfieldID fid, jobject obj, int ftype)
 285 {
 286   fieldDescriptor fd;
 287 
 288   /* make sure it is an instance field */
 289   if (jfieldIDWorkaround::is_static_jfieldID(fid))
 290     ReportJNIFatalError(thr, fatal_should_be_nonstatic);
 291 
 292   /* validate the object being passed and then get its class */
 293   ASSERT_OOPS_ALLOWED;
 294   oop oopObj = jniCheck::validate_object(thr, obj);
 295   if (oopObj == NULL) {
 296     ReportJNIFatalError(thr, fatal_null_object);
 297   }
 298   Klass* k_oop = oopObj-&gt;klass();
 299 
 300   if (!jfieldIDWorkaround::is_valid_jfieldID(k_oop, fid)) {
 301     ReportJNIFatalError(thr, fatal_wrong_field);
 302   }
 303 
 304   /* make sure the field exists */
 305   int offset = jfieldIDWorkaround::from_instance_jfieldID(k_oop, fid);
 306   if (!InstanceKlass::cast(k_oop)-&gt;contains_field_offset(offset))
 307     ReportJNIFatalError(thr, fatal_wrong_field);
 308 
 309   /* check for proper field type */
 310   if (!InstanceKlass::cast(k_oop)-&gt;find_field_from_offset(offset,
 311                                                               false, &amp;fd))
 312     ReportJNIFatalError(thr, fatal_instance_field_not_found);
 313 
 314   if ((fd.field_type() != ftype) &amp;&amp;
 315       !(fd.field_type() == T_ARRAY &amp;&amp; ftype == T_OBJECT)) {
 316     ReportJNIFatalError(thr, fatal_instance_field_mismatch);
 317   }
 318 }
 319 
 320 static inline void
 321 checkString(JavaThread* thr, jstring js)
 322 {
 323   ASSERT_OOPS_ALLOWED;
 324   oop s = jniCheck::validate_object(thr, js);
 325   if ((s == NULL) || !java_lang_String::is_instance(s))
 326     ReportJNIFatalError(thr, fatal_non_string);
 327 }
 328 
 329 static inline arrayOop
 330 check_is_array(JavaThread* thr, jarray jArray)
 331 {
 332   ASSERT_OOPS_ALLOWED;
 333   arrayOop aOop;
 334 
 335   aOop = (arrayOop)jniCheck::validate_object(thr, jArray);
 336   if (aOop == NULL || !aOop-&gt;is_array()) {
 337     ReportJNIFatalError(thr, fatal_non_array);
 338   }
 339   return aOop;
 340 }
 341 
 342 static inline arrayOop
 343 check_is_primitive_array(JavaThread* thr, jarray jArray) {
 344   arrayOop aOop = check_is_array(thr, jArray);
 345 
 346   if (!aOop-&gt;is_typeArray()) {
 347      ReportJNIFatalError(thr, fatal_prim_type_array_expected);
 348   }
 349   return aOop;
 350 }
 351 
 352 static inline void
 353 check_primitive_array_type(JavaThread* thr, jarray jArray, BasicType elementType)
 354 {
 355   BasicType array_type;
 356   arrayOop aOop;
 357 
 358   aOop = check_is_primitive_array(thr, jArray);
 359   array_type = TypeArrayKlass::cast(aOop-&gt;klass())-&gt;element_type();
 360   if (array_type != elementType) {
 361     ReportJNIFatalError(thr, fatal_element_type_mismatch);
 362   }
 363 }
 364 
 365 static inline void
 366 check_is_obj_array(JavaThread* thr, jarray jArray) {
 367   arrayOop aOop = check_is_array(thr, jArray);
 368   if (!aOop-&gt;is_objArray()) {
 369     ReportJNIFatalError(thr, fatal_object_array_expected);
 370   }
 371 }
 372 
 373 /*
 374  * Copy and wrap array elements for bounds checking.
 375  * Remember the original elements (GuardedMemory::get_tag())
 376  */
 377 static void* check_jni_wrap_copy_array(JavaThread* thr, jarray array,
 378     void* orig_elements) {
 379   void* result;
 380   IN_VM(
 381     oop a = JNIHandles::resolve_non_null(array);
 382     size_t len = arrayOop(a)-&gt;length() &lt;&lt;
 383         TypeArrayKlass::cast(a-&gt;klass())-&gt;log2_element_size();
 384     result = GuardedMemory::wrap_copy(orig_elements, len, orig_elements);
 385   )
 386   return result;
 387 }
 388 
 389 static void* check_wrapped_array(JavaThread* thr, const char* fn_name,
 390     void* obj, void* carray, size_t* rsz) {
 391   if (carray == NULL) {
 392     tty-&gt;print_cr(&quot;%s: elements vector NULL&quot; PTR_FORMAT, fn_name, p2i(obj));
 393     NativeReportJNIFatalError(thr, &quot;Elements vector NULL&quot;);
 394   }
 395   GuardedMemory guarded(carray);
 396   void* orig_result = guarded.get_tag();
 397   if (!guarded.verify_guards()) {
 398     tty-&gt;print_cr(&quot;ReleasePrimitiveArrayCritical: release array failed bounds &quot;
 399         &quot;check, incorrect pointer returned ? array: &quot; PTR_FORMAT &quot; carray: &quot;
 400         PTR_FORMAT, p2i(obj), p2i(carray));
 401     guarded.print_on(tty);
 402     NativeReportJNIFatalError(thr, &quot;ReleasePrimitiveArrayCritical: &quot;
 403         &quot;failed bounds check&quot;);
 404   }
 405   if (orig_result == NULL) {
 406     tty-&gt;print_cr(&quot;ReleasePrimitiveArrayCritical: unrecognized elements. array: &quot;
 407         PTR_FORMAT &quot; carray: &quot; PTR_FORMAT, p2i(obj), p2i(carray));
 408     guarded.print_on(tty);
 409     NativeReportJNIFatalError(thr, &quot;ReleasePrimitiveArrayCritical: &quot;
 410         &quot;unrecognized elements&quot;);
 411   }
 412   if (rsz != NULL) {
 413     *rsz = guarded.get_user_size();
 414   }
 415   return orig_result;
 416 }
 417 
 418 static void* check_wrapped_array_release(JavaThread* thr, const char* fn_name,
 419     void* obj, void* carray, jint mode) {
 420   size_t sz;
 421   void* orig_result = check_wrapped_array(thr, fn_name, obj, carray, &amp;sz);
 422   switch (mode) {
 423   // As we never make copies, mode 0 and JNI_COMMIT are the same.
 424   case 0:
 425   case JNI_COMMIT:
 426     memcpy(orig_result, carray, sz);
 427     break;
 428   case JNI_ABORT:
 429     break;
 430   default:
 431     tty-&gt;print_cr(&quot;%s: Unrecognized mode %i releasing array &quot;
 432         PTR_FORMAT &quot; elements &quot; PTR_FORMAT, fn_name, mode, p2i(obj), p2i(carray));
 433     NativeReportJNIFatalError(thr, &quot;Unrecognized array release mode&quot;);
 434   }
 435   // We always need to release the copy we made with GuardedMemory
 436   GuardedMemory::free_copy(carray);
 437   return orig_result;
 438 }
 439 
 440 oop jniCheck::validate_handle(JavaThread* thr, jobject obj) {
 441   if ((obj != NULL) &amp;&amp; (JNIHandles::handle_type(thr, obj) != JNIInvalidRefType)) {
 442     ASSERT_OOPS_ALLOWED;
 443     return JNIHandles::resolve_external_guard(obj);
 444   }
 445   ReportJNIFatalError(thr, fatal_bad_ref_to_jni);
 446   return NULL;
 447 }
 448 
 449 
 450 Method* jniCheck::validate_jmethod_id(JavaThread* thr, jmethodID method_id) {
 451   ASSERT_OOPS_ALLOWED;
 452   // do the fast jmethodID check first
 453   Method* m = Method::checked_resolve_jmethod_id(method_id);
 454   if (m == NULL) {
 455     ReportJNIFatalError(thr, fatal_wrong_class_or_method);
 456   }
 457   // jmethodIDs are handles in the class loader data,
 458   // but that can be expensive so check it last
 459   else if (!Method::is_method_id(method_id)) {
 460     ReportJNIFatalError(thr, fatal_non_weak_method);
 461   }
 462   return m;
 463 }
 464 
 465 
 466 oop jniCheck::validate_object(JavaThread* thr, jobject obj) {
 467   if (obj == NULL) return NULL;
 468   ASSERT_OOPS_ALLOWED;
 469   oop oopObj = jniCheck::validate_handle(thr, obj);
 470   if (oopObj == NULL) {
 471     ReportJNIFatalError(thr, fatal_bad_ref_to_jni);
 472   }
 473   return oopObj;
 474 }
 475 
 476 // Warn if a class descriptor is in decorated form; class descriptors
 477 // passed to JNI findClass should not be decorated unless they are
 478 // array descriptors.
 479 void jniCheck::validate_class_descriptor(JavaThread* thr, const char* name) {
 480   if (name == NULL) return;  // implementation accepts NULL so just return
 481 
 482   size_t len = strlen(name);
 483 
 484   if (len &gt;= 2 &amp;&amp;
 485       name[0] == JVM_SIGNATURE_CLASS &amp;&amp;            // &#39;L&#39;
 486       name[len-1] == JVM_SIGNATURE_ENDCLASS ) {    // &#39;;&#39;
 487     char msg[JVM_MAXPATHLEN];
 488     jio_snprintf(msg, JVM_MAXPATHLEN, &quot;%s%s%s&quot;,
 489                  warn_bad_class_descriptor1, name, warn_bad_class_descriptor2);
 490     ReportJNIWarning(thr, msg);
 491   }
<a name="4" id="anc4"></a>






 492 }
 493 
 494 Klass* jniCheck::validate_class(JavaThread* thr, jclass clazz, bool allow_primitive) {
 495   ASSERT_OOPS_ALLOWED;
 496   oop mirror = jniCheck::validate_handle(thr, clazz);
 497   if (mirror == NULL) {
 498     ReportJNIFatalError(thr, fatal_received_null_class);
 499   }
 500 
 501   if (mirror-&gt;klass() != SystemDictionary::Class_klass()) {
 502     ReportJNIFatalError(thr, fatal_class_not_a_class);
 503   }
 504 
 505   Klass* k = java_lang_Class::as_Klass(mirror);
 506   // Make allowances for primitive classes ...
 507   if (!(k != NULL || (allow_primitive &amp;&amp; java_lang_Class::is_primitive(mirror)))) {
 508     ReportJNIFatalError(thr, fatal_class_not_a_class);
 509   }
 510   return k;
 511 }
 512 
 513 void jniCheck::validate_throwable_klass(JavaThread* thr, Klass* klass) {
 514   ASSERT_OOPS_ALLOWED;
 515   assert(klass != NULL, &quot;klass argument must have a value&quot;);
 516 
 517   if (!klass-&gt;is_instance_klass() ||
 518       !klass-&gt;is_subclass_of(SystemDictionary::Throwable_klass())) {
 519     ReportJNIFatalError(thr, fatal_class_not_a_throwable_class);
 520   }
 521 }
 522 
 523 void jniCheck::validate_call(JavaThread* thr, jclass clazz, jmethodID method_id, jobject obj) {
 524   ASSERT_OOPS_ALLOWED;
 525   Method* m = jniCheck::validate_jmethod_id(thr, method_id);
 526   InstanceKlass* holder = m-&gt;method_holder();
 527 
 528   if (clazz != NULL) {
 529     Klass* k = jniCheck::validate_class(thr, clazz, false);
 530     // Check that method is in the class, must be InstanceKlass
 531     if (!InstanceKlass::cast(k)-&gt;is_subtype_of(holder)) {
 532       ReportJNIFatalError(thr, fatal_wrong_class_or_method);
 533     }
 534   }
 535 
 536   if (obj != NULL) {
 537     oop recv = jniCheck::validate_object(thr, obj);
 538     assert(recv != NULL, &quot;validate_object checks that&quot;);
 539     Klass* rk = recv-&gt;klass();
 540 
 541     // Check that the object is a subtype of method holder too.
 542     if (!rk-&gt;is_subtype_of(holder)) {
 543       ReportJNIFatalError(thr, fatal_wrong_class_or_method);
 544     }
 545   }
 546 }
 547 
 548 
 549 /*
 550  * IMPLEMENTATION OF FUNCTIONS IN CHECKED TABLE
 551  */
 552 
 553 JNI_ENTRY_CHECKED(jclass,
 554   checked_jni_DefineClass(JNIEnv *env,
 555                           const char *name,
 556                           jobject loader,
 557                           const jbyte *buf,
 558                           jsize len))
 559     functionEnter(thr);
 560     IN_VM(
 561       jniCheck::validate_object(thr, loader);
 562     )
 563     jclass result = UNCHECKED()-&gt;DefineClass(env, name, loader, buf, len);
 564     functionExit(thr);
 565     return result;
 566 JNI_END
 567 
 568 JNI_ENTRY_CHECKED(jclass,
 569   checked_jni_FindClass(JNIEnv *env,
 570                         const char *name))
 571     functionEnter(thr);
 572     IN_VM(
 573       jniCheck::validate_class_descriptor(thr, name);
 574     )
 575     jclass result = UNCHECKED()-&gt;FindClass(env, name);
 576     functionExit(thr);
 577     return result;
 578 JNI_END
 579 
 580 JNI_ENTRY_CHECKED(jmethodID,
 581   checked_jni_FromReflectedMethod(JNIEnv *env,
 582                                   jobject method))
 583     functionEnter(thr);
 584     IN_VM(
 585       jniCheck::validate_object(thr, method);
 586     )
 587     jmethodID result = UNCHECKED()-&gt;FromReflectedMethod(env, method);
 588     functionExit(thr);
 589     return result;
 590 JNI_END
 591 
 592 JNI_ENTRY_CHECKED(jfieldID,
 593   checked_jni_FromReflectedField(JNIEnv *env,
 594                                  jobject field))
 595     functionEnter(thr);
 596     IN_VM(
 597       jniCheck::validate_object(thr, field);
 598     )
 599     jfieldID result = UNCHECKED()-&gt;FromReflectedField(env, field);
 600     functionExit(thr);
 601     return result;
 602 JNI_END
 603 
 604 JNI_ENTRY_CHECKED(jobject,
 605   checked_jni_ToReflectedMethod(JNIEnv *env,
 606                                 jclass cls,
 607                                 jmethodID methodID,
 608                                 jboolean isStatic))
 609     functionEnter(thr);
 610     IN_VM(
 611       jniCheck::validate_call(thr, cls, methodID);
 612     )
 613     jobject result = UNCHECKED()-&gt;ToReflectedMethod(env, cls, methodID,
 614                                                     isStatic);
 615     functionExit(thr);
 616     return result;
 617 JNI_END
 618 
 619 JNI_ENTRY_CHECKED(jclass,
 620   checked_jni_GetSuperclass(JNIEnv *env,
 621                             jclass sub))
 622     functionEnter(thr);
 623     IN_VM(
 624       jniCheck::validate_class(thr, sub, true);
 625     )
 626     jclass result = UNCHECKED()-&gt;GetSuperclass(env, sub);
 627     functionExit(thr);
 628     return result;
 629 JNI_END
 630 
 631 JNI_ENTRY_CHECKED(jboolean,
 632   checked_jni_IsAssignableFrom(JNIEnv *env,
 633                                jclass sub,
 634                                jclass sup))
 635     functionEnter(thr);
 636     IN_VM(
 637       jniCheck::validate_class(thr, sub, true);
 638       jniCheck::validate_class(thr, sup, true);
 639     )
 640     jboolean result = UNCHECKED()-&gt;IsAssignableFrom(env, sub, sup);
 641     functionExit(thr);
 642     return result;
 643 JNI_END
 644 
 645 JNI_ENTRY_CHECKED(jobject,
 646   checked_jni_ToReflectedField(JNIEnv *env,
 647                                jclass cls,
 648                                jfieldID fieldID,
 649                                jboolean isStatic))
 650     functionEnter(thr);
 651     IN_VM(
 652       jniCheck::validate_class(thr, cls, false);
 653     )
 654     jobject result = UNCHECKED()-&gt;ToReflectedField(env, cls, fieldID,
 655                                                    isStatic);
 656     functionExit(thr);
 657     return result;
 658 JNI_END
 659 
 660 JNI_ENTRY_CHECKED(jint,
 661   checked_jni_Throw(JNIEnv *env,
 662                     jthrowable obj))
 663     functionEnter(thr);
 664     IN_VM(
 665       oop oopObj = jniCheck::validate_object(thr, obj);
 666       if (oopObj == NULL) {
 667         // Unchecked Throw tolerates a NULL obj, so just warn
 668         ReportJNIWarning(thr, &quot;JNI Throw called with NULL throwable&quot;);
 669       } else {
 670         jniCheck::validate_throwable_klass(thr, oopObj-&gt;klass());
 671       }
 672     )
 673     jint result = UNCHECKED()-&gt;Throw(env, obj);
 674     functionExit(thr);
 675     return result;
 676 JNI_END
 677 
 678 JNI_ENTRY_CHECKED(jint,
 679   checked_jni_ThrowNew(JNIEnv *env,
 680                        jclass clazz,
 681                        const char *msg))
 682     functionEnter(thr);
 683     IN_VM(
 684       Klass* k = jniCheck::validate_class(thr, clazz, false);
 685       assert(k != NULL, &quot;validate_class shouldn&#39;t return NULL Klass*&quot;);
 686       jniCheck::validate_throwable_klass(thr, k);
 687     )
 688     jint result = UNCHECKED()-&gt;ThrowNew(env, clazz, msg);
 689     functionExit(thr);
 690     return result;
 691 JNI_END
 692 
 693 JNI_ENTRY_CHECKED(jthrowable,
 694   checked_jni_ExceptionOccurred(JNIEnv *env))
 695     thr-&gt;clear_pending_jni_exception_check();
 696     functionEnterExceptionAllowed(thr);
 697     jthrowable result = UNCHECKED()-&gt;ExceptionOccurred(env);
 698     functionExit(thr);
 699     return result;
 700 JNI_END
 701 
 702 JNI_ENTRY_CHECKED(void,
 703   checked_jni_ExceptionDescribe(JNIEnv *env))
 704     functionEnterExceptionAllowed(thr);
 705     UNCHECKED()-&gt;ExceptionDescribe(env);
 706     functionExit(thr);
 707 JNI_END
 708 
 709 JNI_ENTRY_CHECKED(void,
 710   checked_jni_ExceptionClear(JNIEnv *env))
 711     thr-&gt;clear_pending_jni_exception_check();
 712     functionEnterExceptionAllowed(thr);
 713     UNCHECKED()-&gt;ExceptionClear(env);
 714     functionExit(thr);
 715 JNI_END
 716 
 717 JNI_ENTRY_CHECKED(void,
 718   checked_jni_FatalError(JNIEnv *env,
 719                          const char *msg))
 720     thr-&gt;clear_pending_jni_exception_check();
 721     functionEnter(thr);
 722     UNCHECKED()-&gt;FatalError(env, msg);
 723     functionExit(thr);
 724 JNI_END
 725 
 726 JNI_ENTRY_CHECKED(jint,
 727   checked_jni_PushLocalFrame(JNIEnv *env,
 728                              jint capacity))
 729     functionEnterExceptionAllowed(thr);
 730     if (capacity &lt; 0)
 731       NativeReportJNIFatalError(thr, &quot;negative capacity&quot;);
 732     jint result = UNCHECKED()-&gt;PushLocalFrame(env, capacity);
 733     if (result == JNI_OK) {
 734       add_planned_handle_capacity(thr-&gt;active_handles(), capacity);
 735     }
 736     functionExit(thr);
 737     return result;
 738 JNI_END
 739 
 740 JNI_ENTRY_CHECKED(jobject,
 741   checked_jni_PopLocalFrame(JNIEnv *env,
 742                             jobject result))
 743     functionEnterExceptionAllowed(thr);
 744     jobject res = UNCHECKED()-&gt;PopLocalFrame(env, result);
 745     functionExit(thr);
 746     return res;
 747 JNI_END
 748 
 749 JNI_ENTRY_CHECKED(jobject,
 750   checked_jni_NewGlobalRef(JNIEnv *env,
 751                            jobject lobj))
 752     functionEnter(thr);
 753     IN_VM(
 754       if (lobj != NULL) {
 755         jniCheck::validate_handle(thr, lobj);
 756       }
 757     )
 758     jobject result = UNCHECKED()-&gt;NewGlobalRef(env,lobj);
 759     functionExit(thr);
 760     return result;
 761 JNI_END
 762 
 763 JNI_ENTRY_CHECKED(void,
 764   checked_jni_DeleteGlobalRef(JNIEnv *env,
 765                               jobject gref))
 766     functionEnterExceptionAllowed(thr);
 767     IN_VM(
 768       jniCheck::validate_object(thr, gref);
 769       if (gref &amp;&amp; !JNIHandles::is_global_handle(gref)) {
 770         ReportJNIFatalError(thr,
 771             &quot;Invalid global JNI handle passed to DeleteGlobalRef&quot;);
 772       }
 773     )
 774     UNCHECKED()-&gt;DeleteGlobalRef(env,gref);
 775     functionExit(thr);
 776 JNI_END
 777 
 778 JNI_ENTRY_CHECKED(void,
 779   checked_jni_DeleteLocalRef(JNIEnv *env,
 780                              jobject obj))
 781     functionEnterExceptionAllowed(thr);
 782     IN_VM(
 783       jniCheck::validate_object(thr, obj);
 784       if (obj &amp;&amp; !(JNIHandles::is_local_handle(thr, obj) ||
 785                    JNIHandles::is_frame_handle(thr, obj)))
 786         ReportJNIFatalError(thr,
 787             &quot;Invalid local JNI handle passed to DeleteLocalRef&quot;);
 788     )
 789     UNCHECKED()-&gt;DeleteLocalRef(env, obj);
 790     functionExit(thr);
 791 JNI_END
 792 
 793 JNI_ENTRY_CHECKED(jboolean,
 794   checked_jni_IsSameObject(JNIEnv *env,
 795                            jobject obj1,
 796                            jobject obj2))
 797     functionEnterExceptionAllowed(thr);
 798     IN_VM(
 799       /* This JNI function can be used to compare weak global references
 800        * to NULL objects. If the handles are valid, but contain NULL,
 801        * then don&#39;t attempt to validate the object.
 802        */
 803       if (obj1 != NULL &amp;&amp; jniCheck::validate_handle(thr, obj1) != NULL) {
 804         jniCheck::validate_object(thr, obj1);
 805       }
 806       if (obj2 != NULL &amp;&amp; jniCheck::validate_handle(thr, obj2) != NULL) {
 807         jniCheck::validate_object(thr, obj2);
 808       }
 809     )
 810     jboolean result = UNCHECKED()-&gt;IsSameObject(env,obj1,obj2);
 811     functionExit(thr);
 812     return result;
 813 JNI_END
 814 
 815 JNI_ENTRY_CHECKED(jobject,
 816   checked_jni_NewLocalRef(JNIEnv *env,
 817                           jobject ref))
 818     functionEnter(thr);
 819     IN_VM(
 820       if (ref != NULL) {
 821         jniCheck::validate_handle(thr, ref);
 822       }
 823     )
 824     jobject result = UNCHECKED()-&gt;NewLocalRef(env, ref);
 825     functionExit(thr);
 826     return result;
 827 JNI_END
 828 
 829 JNI_ENTRY_CHECKED(jint,
 830   checked_jni_EnsureLocalCapacity(JNIEnv *env,
 831                                   jint capacity))
 832     functionEnter(thr);
 833     if (capacity &lt; 0) {
 834       NativeReportJNIFatalError(thr, &quot;negative capacity&quot;);
 835     }
 836     jint result = UNCHECKED()-&gt;EnsureLocalCapacity(env, capacity);
 837     if (result == JNI_OK) {
 838       // increase local ref capacity if needed
 839       if ((size_t)capacity &gt; thr-&gt;active_handles()-&gt;get_planned_capacity()) {
 840         add_planned_handle_capacity(thr-&gt;active_handles(), capacity);
 841       }
 842     }
 843     functionExit(thr);
 844     return result;
 845 JNI_END
 846 
 847 JNI_ENTRY_CHECKED(jobject,
 848   checked_jni_AllocObject(JNIEnv *env,
 849                           jclass clazz))
 850     functionEnter(thr);
 851     IN_VM(
 852       jniCheck::validate_class(thr, clazz, false);
 853     )
 854     jobject result = UNCHECKED()-&gt;AllocObject(env,clazz);
 855     functionExit(thr);
 856     return result;
 857 JNI_END
 858 
 859 JNI_ENTRY_CHECKED(jobject,
 860   checked_jni_NewObject(JNIEnv *env,
 861                         jclass clazz,
 862                         jmethodID methodID,
 863                         ...))
 864     functionEnter(thr);
 865     va_list args;
 866     IN_VM(
 867       jniCheck::validate_call(thr, clazz, methodID);
 868     )
 869     va_start(args, methodID);
 870     jobject result = UNCHECKED()-&gt;NewObjectV(env,clazz,methodID,args);
 871     va_end(args);
 872     functionExit(thr);
 873     return result;
 874 JNI_END
 875 
 876 JNI_ENTRY_CHECKED(jobject,
 877   checked_jni_NewObjectV(JNIEnv *env,
 878                          jclass clazz,
 879                          jmethodID methodID,
 880                          va_list args))
 881     functionEnter(thr);
 882     IN_VM(
 883       jniCheck::validate_call(thr, clazz, methodID);
 884     )
 885     jobject result = UNCHECKED()-&gt;NewObjectV(env,clazz,methodID,args);
 886     functionExit(thr);
 887     return result;
 888 JNI_END
 889 
 890 JNI_ENTRY_CHECKED(jobject,
 891   checked_jni_NewObjectA(JNIEnv *env,
 892                          jclass clazz,
 893                          jmethodID methodID,
 894                          const jvalue *args))
 895     functionEnter(thr);
 896     IN_VM(
 897       jniCheck::validate_call(thr, clazz, methodID);
 898     )
 899     jobject result = UNCHECKED()-&gt;NewObjectA(env,clazz,methodID,args);
 900     functionExit(thr);
 901     return result;
 902 JNI_END
 903 
 904 JNI_ENTRY_CHECKED(jclass,
 905   checked_jni_GetObjectClass(JNIEnv *env,
 906                              jobject obj))
 907     functionEnter(thr);
 908     IN_VM(
 909       jniCheck::validate_object(thr, obj);
 910     )
 911     jclass result = UNCHECKED()-&gt;GetObjectClass(env,obj);
 912     functionExit(thr);
 913     return result;
 914 JNI_END
 915 
 916 JNI_ENTRY_CHECKED(jboolean,
 917   checked_jni_IsInstanceOf(JNIEnv *env,
 918                            jobject obj,
 919                            jclass clazz))
 920     functionEnter(thr);
 921     IN_VM(
 922       jniCheck::validate_object(thr, obj);
 923       jniCheck::validate_class(thr, clazz, true);
 924     )
 925     jboolean result = UNCHECKED()-&gt;IsInstanceOf(env,obj,clazz);
 926     functionExit(thr);
 927     return result;
 928 JNI_END
 929 
 930 JNI_ENTRY_CHECKED(jmethodID,
 931   checked_jni_GetMethodID(JNIEnv *env,
 932                           jclass clazz,
 933                           const char *name,
 934                           const char *sig))
 935     functionEnter(thr);
 936     IN_VM(
 937       jniCheck::validate_class(thr, clazz, false);
 938     )
 939     jmethodID result = UNCHECKED()-&gt;GetMethodID(env,clazz,name,sig);
 940     functionExit(thr);
 941     return result;
 942 JNI_END
 943 
 944 #define WRAPPER_CallMethod(ResultType, Result) \
 945 JNI_ENTRY_CHECKED(ResultType,  \
 946   checked_jni_Call##Result##Method(JNIEnv *env, \
 947                                    jobject obj, \
 948                                    jmethodID methodID, \
 949                                    ...)) \
 950     functionEnter(thr); \
 951     va_list args; \
 952     IN_VM( \
 953       jniCheck::validate_call(thr, NULL, methodID, obj); \
 954     ) \
 955     va_start(args,methodID); \
 956     ResultType result =UNCHECKED()-&gt;Call##Result##MethodV(env, obj, methodID, \
 957                                                           args); \
 958     va_end(args); \
 959     thr-&gt;set_pending_jni_exception_check(&quot;Call&quot;#Result&quot;Method&quot;); \
 960     functionExit(thr); \
 961     return result; \
 962 JNI_END \
 963 \
 964 JNI_ENTRY_CHECKED(ResultType,  \
 965   checked_jni_Call##Result##MethodV(JNIEnv *env, \
 966                                     jobject obj, \
 967                                     jmethodID methodID, \
 968                                     va_list args)) \
 969     functionEnter(thr); \
 970     IN_VM(\
 971       jniCheck::validate_call(thr, NULL, methodID, obj); \
 972     ) \
 973     ResultType result = UNCHECKED()-&gt;Call##Result##MethodV(env, obj, methodID,\
 974                                                            args); \
 975     thr-&gt;set_pending_jni_exception_check(&quot;Call&quot;#Result&quot;MethodV&quot;); \
 976     functionExit(thr); \
 977     return result; \
 978 JNI_END \
 979 \
 980 JNI_ENTRY_CHECKED(ResultType,  \
 981   checked_jni_Call##Result##MethodA(JNIEnv *env, \
 982                                     jobject obj, \
 983                                     jmethodID methodID, \
 984                                     const jvalue * args)) \
 985     functionEnter(thr); \
 986     IN_VM( \
 987       jniCheck::validate_call(thr, NULL, methodID, obj); \
 988     ) \
 989     ResultType result = UNCHECKED()-&gt;Call##Result##MethodA(env, obj, methodID,\
 990                                                            args); \
 991     thr-&gt;set_pending_jni_exception_check(&quot;Call&quot;#Result&quot;MethodA&quot;); \
 992     functionExit(thr); \
 993     return result; \
 994 JNI_END
 995 
 996 WRAPPER_CallMethod(jobject,Object)
 997 WRAPPER_CallMethod(jboolean,Boolean)
 998 WRAPPER_CallMethod(jbyte,Byte)
 999 WRAPPER_CallMethod(jshort,Short)
1000 WRAPPER_CallMethod(jchar,Char)
1001 WRAPPER_CallMethod(jint,Int)
1002 WRAPPER_CallMethod(jlong,Long)
1003 WRAPPER_CallMethod(jfloat,Float)
1004 WRAPPER_CallMethod(jdouble,Double)
1005 
1006 JNI_ENTRY_CHECKED(void,
1007   checked_jni_CallVoidMethod(JNIEnv *env, \
1008                              jobject obj, \
1009                              jmethodID methodID, \
1010                              ...))
1011     functionEnter(thr);
1012     va_list args;
1013     IN_VM(
1014       jniCheck::validate_call(thr, NULL, methodID, obj);
1015     )
1016     va_start(args,methodID);
1017     UNCHECKED()-&gt;CallVoidMethodV(env,obj,methodID,args);
1018     va_end(args);
1019     thr-&gt;set_pending_jni_exception_check(&quot;CallVoidMethod&quot;);
1020     functionExit(thr);
1021 JNI_END
1022 
1023 JNI_ENTRY_CHECKED(void,
1024   checked_jni_CallVoidMethodV(JNIEnv *env,
1025                               jobject obj,
1026                               jmethodID methodID,
1027                               va_list args))
1028     functionEnter(thr);
1029     IN_VM(
1030       jniCheck::validate_call(thr, NULL, methodID, obj);
1031     )
1032     UNCHECKED()-&gt;CallVoidMethodV(env,obj,methodID,args);
1033     thr-&gt;set_pending_jni_exception_check(&quot;CallVoidMethodV&quot;);
1034     functionExit(thr);
1035 JNI_END
1036 
1037 JNI_ENTRY_CHECKED(void,
1038   checked_jni_CallVoidMethodA(JNIEnv *env,
1039                               jobject obj,
1040                               jmethodID methodID,
1041                               const jvalue * args))
1042     functionEnter(thr);
1043     IN_VM(
1044       jniCheck::validate_call(thr, NULL, methodID, obj);
1045     )
1046     UNCHECKED()-&gt;CallVoidMethodA(env,obj,methodID,args);
1047     thr-&gt;set_pending_jni_exception_check(&quot;CallVoidMethodA&quot;);
1048     functionExit(thr);
1049 JNI_END
1050 
1051 #define WRAPPER_CallNonvirtualMethod(ResultType, Result) \
1052 JNI_ENTRY_CHECKED(ResultType,  \
1053   checked_jni_CallNonvirtual##Result##Method(JNIEnv *env, \
1054                                              jobject obj, \
1055                                              jclass clazz, \
1056                                              jmethodID methodID, \
1057                                              ...)) \
1058     functionEnter(thr); \
1059     va_list args; \
1060     IN_VM( \
1061       jniCheck::validate_call(thr, clazz, methodID, obj); \
1062     ) \
1063     va_start(args,methodID); \
1064     ResultType result = UNCHECKED()-&gt;CallNonvirtual##Result##MethodV(env, \
1065                                                                      obj, \
1066                                                                      clazz, \
1067                                                                      methodID,\
1068                                                                      args); \
1069     va_end(args); \
1070     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtual&quot;#Result&quot;Method&quot;); \
1071     functionExit(thr); \
1072     return result; \
1073 JNI_END \
1074 \
1075 JNI_ENTRY_CHECKED(ResultType,  \
1076   checked_jni_CallNonvirtual##Result##MethodV(JNIEnv *env, \
1077                                               jobject obj, \
1078                                               jclass clazz, \
1079                                               jmethodID methodID, \
1080                                               va_list args)) \
1081     functionEnter(thr); \
1082     IN_VM( \
1083       jniCheck::validate_call(thr, clazz, methodID, obj); \
1084     ) \
1085     ResultType result = UNCHECKED()-&gt;CallNonvirtual##Result##MethodV(env, \
1086                                                                      obj, \
1087                                                                      clazz, \
1088                                                                      methodID,\
1089                                                                      args); \
1090     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtual&quot;#Result&quot;MethodV&quot;); \
1091     functionExit(thr); \
1092     return result; \
1093 JNI_END \
1094 \
1095 JNI_ENTRY_CHECKED(ResultType,  \
1096   checked_jni_CallNonvirtual##Result##MethodA(JNIEnv *env, \
1097                                               jobject obj, \
1098                                               jclass clazz, \
1099                                               jmethodID methodID, \
1100                                               const jvalue * args)) \
1101     functionEnter(thr); \
1102     IN_VM( \
1103       jniCheck::validate_call(thr, clazz, methodID, obj); \
1104     ) \
1105     ResultType result = UNCHECKED()-&gt;CallNonvirtual##Result##MethodA(env, \
1106                                                                      obj, \
1107                                                                      clazz, \
1108                                                                      methodID,\
1109                                                                      args); \
1110     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtual&quot;#Result&quot;MethodA&quot;); \
1111     functionExit(thr); \
1112     return result; \
1113 JNI_END
1114 
1115 WRAPPER_CallNonvirtualMethod(jobject,Object)
1116 WRAPPER_CallNonvirtualMethod(jboolean,Boolean)
1117 WRAPPER_CallNonvirtualMethod(jbyte,Byte)
1118 WRAPPER_CallNonvirtualMethod(jshort,Short)
1119 WRAPPER_CallNonvirtualMethod(jchar,Char)
1120 WRAPPER_CallNonvirtualMethod(jint,Int)
1121 WRAPPER_CallNonvirtualMethod(jlong,Long)
1122 WRAPPER_CallNonvirtualMethod(jfloat,Float)
1123 WRAPPER_CallNonvirtualMethod(jdouble,Double)
1124 
1125 JNI_ENTRY_CHECKED(void,
1126   checked_jni_CallNonvirtualVoidMethod(JNIEnv *env,
1127                                        jobject obj,
1128                                        jclass clazz,
1129                                        jmethodID methodID,
1130                                        ...))
1131     functionEnter(thr);
1132     va_list args;
1133     IN_VM(
1134       jniCheck::validate_call(thr, clazz, methodID, obj);
1135     )
1136     va_start(args,methodID);
1137     UNCHECKED()-&gt;CallNonvirtualVoidMethodV(env,obj,clazz,methodID,args);
1138     va_end(args);
1139     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtualVoidMethod&quot;);
1140     functionExit(thr);
1141 JNI_END
1142 
1143 JNI_ENTRY_CHECKED(void,
1144   checked_jni_CallNonvirtualVoidMethodV(JNIEnv *env,
1145                                         jobject obj,
1146                                         jclass clazz,
1147                                         jmethodID methodID,
1148                                         va_list args))
1149     functionEnter(thr);
1150     IN_VM(
1151       jniCheck::validate_call(thr, clazz, methodID, obj);
1152     )
1153     UNCHECKED()-&gt;CallNonvirtualVoidMethodV(env,obj,clazz,methodID,args);
1154     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtualVoidMethodV&quot;);
1155     functionExit(thr);
1156 JNI_END
1157 
1158 JNI_ENTRY_CHECKED(void,
1159   checked_jni_CallNonvirtualVoidMethodA(JNIEnv *env,
1160                                         jobject obj,
1161                                         jclass clazz,
1162                                         jmethodID methodID,
1163                                         const jvalue * args))
1164     functionEnter(thr);
1165     IN_VM(
1166       jniCheck::validate_call(thr, clazz, methodID, obj);
1167     )
1168     UNCHECKED()-&gt;CallNonvirtualVoidMethodA(env,obj,clazz,methodID,args);
1169     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtualVoidMethodA&quot;);
1170     functionExit(thr);
1171 JNI_END
1172 
1173 JNI_ENTRY_CHECKED(jfieldID,
1174   checked_jni_GetFieldID(JNIEnv *env,
1175                          jclass clazz,
1176                          const char *name,
1177                          const char *sig))
1178     functionEnter(thr);
1179     IN_VM(
1180       jniCheck::validate_class(thr, clazz, false);
1181     )
1182     jfieldID result = UNCHECKED()-&gt;GetFieldID(env,clazz,name,sig);
1183     functionExit(thr);
1184     return result;
1185 JNI_END
1186 
1187 #define WRAPPER_GetField(ReturnType,Result,FieldType) \
1188 JNI_ENTRY_CHECKED(ReturnType,  \
1189   checked_jni_Get##Result##Field(JNIEnv *env, \
1190                                  jobject obj, \
1191                                  jfieldID fieldID)) \
1192     functionEnter(thr); \
1193     IN_VM( \
1194       checkInstanceFieldID(thr, fieldID, obj, FieldType); \
1195     ) \
1196     ReturnType result = UNCHECKED()-&gt;Get##Result##Field(env,obj,fieldID); \
1197     functionExit(thr); \
1198     return result; \
1199 JNI_END
1200 
1201 WRAPPER_GetField(jobject,  Object,  T_OBJECT)
1202 WRAPPER_GetField(jboolean, Boolean, T_BOOLEAN)
1203 WRAPPER_GetField(jbyte,    Byte,    T_BYTE)
1204 WRAPPER_GetField(jshort,   Short,   T_SHORT)
1205 WRAPPER_GetField(jchar,    Char,    T_CHAR)
1206 WRAPPER_GetField(jint,     Int,     T_INT)
1207 WRAPPER_GetField(jlong,    Long,    T_LONG)
1208 WRAPPER_GetField(jfloat,   Float,   T_FLOAT)
1209 WRAPPER_GetField(jdouble,  Double,  T_DOUBLE)
1210 
1211 #define WRAPPER_SetField(ValueType,Result,FieldType) \
1212 JNI_ENTRY_CHECKED(void,  \
1213   checked_jni_Set##Result##Field(JNIEnv *env, \
1214                                  jobject obj, \
1215                                  jfieldID fieldID, \
1216                                  ValueType val)) \
1217     functionEnter(thr); \
1218     IN_VM( \
1219       checkInstanceFieldID(thr, fieldID, obj, FieldType); \
1220     ) \
1221     UNCHECKED()-&gt;Set##Result##Field(env,obj,fieldID,val); \
1222     functionExit(thr); \
1223 JNI_END
1224 
1225 WRAPPER_SetField(jobject,  Object,  T_OBJECT)
1226 WRAPPER_SetField(jboolean, Boolean, T_BOOLEAN)
1227 WRAPPER_SetField(jbyte,    Byte,    T_BYTE)
1228 WRAPPER_SetField(jshort,   Short,   T_SHORT)
1229 WRAPPER_SetField(jchar,    Char,    T_CHAR)
1230 WRAPPER_SetField(jint,     Int,     T_INT)
1231 WRAPPER_SetField(jlong,    Long,    T_LONG)
1232 WRAPPER_SetField(jfloat,   Float,   T_FLOAT)
1233 WRAPPER_SetField(jdouble,  Double,  T_DOUBLE)
1234 
1235 
1236 JNI_ENTRY_CHECKED(jmethodID,
1237   checked_jni_GetStaticMethodID(JNIEnv *env,
1238                                 jclass clazz,
1239                                 const char *name,
1240                                 const char *sig))
1241     functionEnter(thr);
1242     IN_VM(
1243       jniCheck::validate_class(thr, clazz, false);
1244     )
1245     jmethodID result = UNCHECKED()-&gt;GetStaticMethodID(env,clazz,name,sig);
1246     functionExit(thr);
1247     return result;
1248 JNI_END
1249 
1250 #define WRAPPER_CallStaticMethod(ReturnType,Result) \
1251 JNI_ENTRY_CHECKED(ReturnType,  \
1252   checked_jni_CallStatic##Result##Method(JNIEnv *env, \
1253                                          jclass clazz, \
1254                                          jmethodID methodID, \
1255                                          ...)) \
1256     functionEnter(thr); \
1257     va_list args; \
1258     IN_VM( \
1259       jniCheck::validate_call(thr, clazz, methodID); \
1260     ) \
1261     va_start(args,methodID); \
1262     ReturnType result = UNCHECKED()-&gt;CallStatic##Result##MethodV(env, \
1263                                                                  clazz, \
1264                                                                  methodID, \
1265                                                                  args); \
1266     va_end(args); \
1267     thr-&gt;set_pending_jni_exception_check(&quot;CallStatic&quot;#Result&quot;Method&quot;); \
1268     functionExit(thr); \
1269     return result; \
1270 JNI_END \
1271 \
1272 JNI_ENTRY_CHECKED(ReturnType,  \
1273   checked_jni_CallStatic##Result##MethodV(JNIEnv *env, \
1274                                           jclass clazz, \
1275                                           jmethodID methodID,\
1276                                           va_list args)) \
1277     functionEnter(thr); \
1278     IN_VM( \
1279       jniCheck::validate_call(thr, clazz, methodID); \
1280     ) \
1281     ReturnType result = UNCHECKED()-&gt;CallStatic##Result##MethodV(env, \
1282                                                                  clazz, \
1283                                                                  methodID, \
1284                                                                  args); \
1285     thr-&gt;set_pending_jni_exception_check(&quot;CallStatic&quot;#Result&quot;MethodV&quot;); \
1286     functionExit(thr); \
1287     return result; \
1288 JNI_END \
1289 \
1290 JNI_ENTRY_CHECKED(ReturnType,  \
1291   checked_jni_CallStatic##Result##MethodA(JNIEnv *env, \
1292                                           jclass clazz, \
1293                                           jmethodID methodID, \
1294                                           const jvalue *args)) \
1295     functionEnter(thr); \
1296     IN_VM( \
1297       jniCheck::validate_call(thr, clazz, methodID); \
1298     ) \
1299     ReturnType result = UNCHECKED()-&gt;CallStatic##Result##MethodA(env, \
1300                                                                  clazz, \
1301                                                                  methodID, \
1302                                                                  args); \
1303     thr-&gt;set_pending_jni_exception_check(&quot;CallStatic&quot;#Result&quot;MethodA&quot;); \
1304     functionExit(thr); \
1305     return result; \
1306 JNI_END
1307 
1308 WRAPPER_CallStaticMethod(jobject,Object)
1309 WRAPPER_CallStaticMethod(jboolean,Boolean)
1310 WRAPPER_CallStaticMethod(jbyte,Byte)
1311 WRAPPER_CallStaticMethod(jshort,Short)
1312 WRAPPER_CallStaticMethod(jchar,Char)
1313 WRAPPER_CallStaticMethod(jint,Int)
1314 WRAPPER_CallStaticMethod(jlong,Long)
1315 WRAPPER_CallStaticMethod(jfloat,Float)
1316 WRAPPER_CallStaticMethod(jdouble,Double)
1317 
1318 JNI_ENTRY_CHECKED(void,
1319   checked_jni_CallStaticVoidMethod(JNIEnv *env,
1320                                    jclass cls,
1321                                    jmethodID methodID,
1322                                    ...))
1323     functionEnter(thr);
1324     va_list args;
1325     IN_VM(
1326       jniCheck::validate_call(thr, cls, methodID);
1327     )
1328     va_start(args,methodID);
1329     UNCHECKED()-&gt;CallStaticVoidMethodV(env,cls,methodID,args);
1330     va_end(args);
1331     thr-&gt;set_pending_jni_exception_check(&quot;CallStaticVoidMethod&quot;);
1332     functionExit(thr);
1333 JNI_END
1334 
1335 JNI_ENTRY_CHECKED(void,
1336   checked_jni_CallStaticVoidMethodV(JNIEnv *env,
1337                                     jclass cls,
1338                                     jmethodID methodID,
1339                                     va_list args))
1340     functionEnter(thr);
1341     IN_VM(
1342       jniCheck::validate_call(thr, cls, methodID);
1343     )
1344     UNCHECKED()-&gt;CallStaticVoidMethodV(env,cls,methodID,args);
1345     thr-&gt;set_pending_jni_exception_check(&quot;CallStaticVoidMethodV&quot;);
1346     functionExit(thr);
1347 JNI_END
1348 
1349 JNI_ENTRY_CHECKED(void,
1350   checked_jni_CallStaticVoidMethodA(JNIEnv *env,
1351                                     jclass cls,
1352                                     jmethodID methodID,
1353                                     const jvalue * args))
1354     functionEnter(thr);
1355     IN_VM(
1356       jniCheck::validate_call(thr, cls, methodID);
1357     )
1358     UNCHECKED()-&gt;CallStaticVoidMethodA(env,cls,methodID,args);
1359     thr-&gt;set_pending_jni_exception_check(&quot;CallStaticVoidMethodA&quot;);
1360     functionExit(thr);
1361 JNI_END
1362 
1363 JNI_ENTRY_CHECKED(jfieldID,
1364   checked_jni_GetStaticFieldID(JNIEnv *env,
1365                                jclass clazz,
1366                                const char *name,
1367                                const char *sig))
1368     functionEnter(thr);
1369     IN_VM(
1370       jniCheck::validate_class(thr, clazz, false);
1371     )
1372     jfieldID result = UNCHECKED()-&gt;GetStaticFieldID(env,clazz,name,sig);
1373     functionExit(thr);
1374     return result;
1375 JNI_END
1376 
1377 #define WRAPPER_GetStaticField(ReturnType,Result,FieldType) \
1378 JNI_ENTRY_CHECKED(ReturnType,  \
1379   checked_jni_GetStatic##Result##Field(JNIEnv *env, \
1380                                        jclass clazz, \
1381                                        jfieldID fieldID)) \
1382     functionEnter(thr); \
1383     IN_VM( \
1384       jniCheck::validate_class(thr, clazz, false); \
1385       checkStaticFieldID(thr, fieldID, clazz, FieldType); \
1386     ) \
1387     ReturnType result = UNCHECKED()-&gt;GetStatic##Result##Field(env, \
1388                                                               clazz, \
1389                                                               fieldID); \
1390     functionExit(thr); \
1391     return result; \
1392 JNI_END
1393 
1394 WRAPPER_GetStaticField(jobject,  Object,  T_OBJECT)
1395 WRAPPER_GetStaticField(jboolean, Boolean, T_BOOLEAN)
1396 WRAPPER_GetStaticField(jbyte,    Byte,    T_BYTE)
1397 WRAPPER_GetStaticField(jshort,   Short,   T_SHORT)
1398 WRAPPER_GetStaticField(jchar,    Char,    T_CHAR)
1399 WRAPPER_GetStaticField(jint,     Int,     T_INT)
1400 WRAPPER_GetStaticField(jlong,    Long,    T_LONG)
1401 WRAPPER_GetStaticField(jfloat,   Float,   T_FLOAT)
1402 WRAPPER_GetStaticField(jdouble,  Double,  T_DOUBLE)
1403 
1404 #define WRAPPER_SetStaticField(ValueType,Result,FieldType) \
1405 JNI_ENTRY_CHECKED(void,  \
1406   checked_jni_SetStatic##Result##Field(JNIEnv *env, \
1407                                        jclass clazz, \
1408                                        jfieldID fieldID, \
1409                                        ValueType value)) \
1410     functionEnter(thr); \
1411     IN_VM( \
1412       jniCheck::validate_class(thr, clazz, false); \
1413       checkStaticFieldID(thr, fieldID, clazz, FieldType); \
1414     ) \
1415     UNCHECKED()-&gt;SetStatic##Result##Field(env,clazz,fieldID,value); \
1416     functionExit(thr); \
1417 JNI_END
1418 
1419 WRAPPER_SetStaticField(jobject,  Object,  T_OBJECT)
1420 WRAPPER_SetStaticField(jboolean, Boolean, T_BOOLEAN)
1421 WRAPPER_SetStaticField(jbyte,    Byte,    T_BYTE)
1422 WRAPPER_SetStaticField(jshort,   Short,   T_SHORT)
1423 WRAPPER_SetStaticField(jchar,    Char,    T_CHAR)
1424 WRAPPER_SetStaticField(jint,     Int,     T_INT)
1425 WRAPPER_SetStaticField(jlong,    Long,    T_LONG)
1426 WRAPPER_SetStaticField(jfloat,   Float,   T_FLOAT)
1427 WRAPPER_SetStaticField(jdouble,  Double,  T_DOUBLE)
1428 
1429 
1430 JNI_ENTRY_CHECKED(jstring,
1431   checked_jni_NewString(JNIEnv *env,
1432                         const jchar *unicode,
1433                         jsize len))
1434     functionEnter(thr);
1435     jstring result = UNCHECKED()-&gt;NewString(env,unicode,len);
1436     functionExit(thr);
1437     return result;
1438 JNI_END
1439 
1440 JNI_ENTRY_CHECKED(jsize,
1441   checked_jni_GetStringLength(JNIEnv *env,
1442                               jstring str))
1443     functionEnter(thr);
1444     IN_VM(
1445       checkString(thr, str);
1446     )
1447     jsize result = UNCHECKED()-&gt;GetStringLength(env,str);
1448     functionExit(thr);
1449     return result;
1450 JNI_END
1451 
1452 // Arbitrary (but well-known) tag
1453 const void* STRING_TAG = (void*)0x47114711;
1454 
1455 JNI_ENTRY_CHECKED(const jchar *,
1456   checked_jni_GetStringChars(JNIEnv *env,
1457                              jstring str,
1458                              jboolean *isCopy))
1459     functionEnter(thr);
1460     IN_VM(
1461       checkString(thr, str);
1462     )
1463     jchar* new_result = NULL;
1464     const jchar *result = UNCHECKED()-&gt;GetStringChars(env,str,isCopy);
1465     assert (isCopy == NULL || *isCopy == JNI_TRUE, &quot;GetStringChars didn&#39;t return a copy as expected&quot;);
1466     if (result != NULL) {
1467       size_t len = UNCHECKED()-&gt;GetStringLength(env,str) + 1; // + 1 for NULL termination
1468       len *= sizeof(jchar);
1469       new_result = (jchar*) GuardedMemory::wrap_copy(result, len, STRING_TAG);
1470       if (new_result == NULL) {
1471         vm_exit_out_of_memory(len, OOM_MALLOC_ERROR, &quot;checked_jni_GetStringChars&quot;);
1472       }
1473       // Avoiding call to UNCHECKED()-&gt;ReleaseStringChars() since that will fire unexpected dtrace probes
1474       // Note that the dtrace arguments for the allocated memory will not match up with this solution.
1475       FreeHeap((char*)result);
1476     }
1477     functionExit(thr);
1478     return new_result;
1479 JNI_END
1480 
1481 JNI_ENTRY_CHECKED(void,
1482   checked_jni_ReleaseStringChars(JNIEnv *env,
1483                                  jstring str,
1484                                  const jchar *chars))
1485     functionEnterExceptionAllowed(thr);
1486     IN_VM(
1487       checkString(thr, str);
1488     )
1489     if (chars == NULL) {
1490        // still do the unchecked call to allow dtrace probes
1491        UNCHECKED()-&gt;ReleaseStringChars(env,str,chars);
1492     }
1493     else {
1494       GuardedMemory guarded((void*)chars);
1495       if (!guarded.verify_guards()) {
1496         tty-&gt;print_cr(&quot;ReleaseStringChars: release chars failed bounds check. &quot;
1497             &quot;string: &quot; PTR_FORMAT &quot; chars: &quot; PTR_FORMAT, p2i(str), p2i(chars));
1498         guarded.print_on(tty);
1499         NativeReportJNIFatalError(thr, &quot;ReleaseStringChars: &quot;
1500             &quot;release chars failed bounds check.&quot;);
1501       }
1502       if (guarded.get_tag() != STRING_TAG) {
1503         tty-&gt;print_cr(&quot;ReleaseStringChars: called on something not allocated &quot;
1504             &quot;by GetStringChars. string: &quot; PTR_FORMAT &quot; chars: &quot; PTR_FORMAT,
1505             p2i(str), p2i(chars));
1506         NativeReportJNIFatalError(thr, &quot;ReleaseStringChars called on something &quot;
1507             &quot;not allocated by GetStringChars&quot;);
1508       }
1509        UNCHECKED()-&gt;ReleaseStringChars(env, str,
1510            (const jchar*) guarded.release_for_freeing());
1511     }
1512     functionExit(thr);
1513 JNI_END
1514 
1515 JNI_ENTRY_CHECKED(jstring,
1516   checked_jni_NewStringUTF(JNIEnv *env,
1517                            const char *utf))
1518     functionEnter(thr);
1519     jstring result = UNCHECKED()-&gt;NewStringUTF(env,utf);
1520     functionExit(thr);
1521     return result;
1522 JNI_END
1523 
1524 JNI_ENTRY_CHECKED(jsize,
1525   checked_jni_GetStringUTFLength(JNIEnv *env,
1526                                  jstring str))
1527     functionEnter(thr);
1528     IN_VM(
1529       checkString(thr, str);
1530     )
1531     jsize result = UNCHECKED()-&gt;GetStringUTFLength(env,str);
1532     functionExit(thr);
1533     return result;
1534 JNI_END
1535 
1536 // Arbitrary (but well-known) tag - different than GetStringChars
1537 const void* STRING_UTF_TAG = (void*) 0x48124812;
1538 
1539 JNI_ENTRY_CHECKED(const char *,
1540   checked_jni_GetStringUTFChars(JNIEnv *env,
1541                                 jstring str,
1542                                 jboolean *isCopy))
1543     functionEnter(thr);
1544     IN_VM(
1545       checkString(thr, str);
1546     )
1547     char* new_result = NULL;
1548     const char *result = UNCHECKED()-&gt;GetStringUTFChars(env,str,isCopy);
1549     assert (isCopy == NULL || *isCopy == JNI_TRUE, &quot;GetStringUTFChars didn&#39;t return a copy as expected&quot;);
1550     if (result != NULL) {
1551       size_t len = strlen(result) + 1; // + 1 for NULL termination
1552       new_result = (char*) GuardedMemory::wrap_copy(result, len, STRING_UTF_TAG);
1553       if (new_result == NULL) {
1554         vm_exit_out_of_memory(len, OOM_MALLOC_ERROR, &quot;checked_jni_GetStringUTFChars&quot;);
1555       }
1556       // Avoiding call to UNCHECKED()-&gt;ReleaseStringUTFChars() since that will fire unexpected dtrace probes
1557       // Note that the dtrace arguments for the allocated memory will not match up with this solution.
1558       FreeHeap((char*)result);
1559     }
1560     functionExit(thr);
1561     return new_result;
1562 JNI_END
1563 
1564 JNI_ENTRY_CHECKED(void,
1565   checked_jni_ReleaseStringUTFChars(JNIEnv *env,
1566                                     jstring str,
1567                                     const char* chars))
1568     functionEnterExceptionAllowed(thr);
1569     IN_VM(
1570       checkString(thr, str);
1571     )
1572     if (chars == NULL) {
1573        // still do the unchecked call to allow dtrace probes
1574        UNCHECKED()-&gt;ReleaseStringUTFChars(env,str,chars);
1575     }
1576     else {
1577       GuardedMemory guarded((void*)chars);
1578       if (!guarded.verify_guards()) {
1579         tty-&gt;print_cr(&quot;ReleaseStringUTFChars: release chars failed bounds check. &quot;
1580             &quot;string: &quot; PTR_FORMAT &quot; chars: &quot; PTR_FORMAT, p2i(str), p2i(chars));
1581         guarded.print_on(tty);
1582         NativeReportJNIFatalError(thr, &quot;ReleaseStringUTFChars: &quot;
1583             &quot;release chars failed bounds check.&quot;);
1584       }
1585       if (guarded.get_tag() != STRING_UTF_TAG) {
1586         tty-&gt;print_cr(&quot;ReleaseStringUTFChars: called on something not &quot;
1587             &quot;allocated by GetStringUTFChars. string: &quot; PTR_FORMAT &quot; chars: &quot;
1588             PTR_FORMAT, p2i(str), p2i(chars));
1589         NativeReportJNIFatalError(thr, &quot;ReleaseStringUTFChars &quot;
1590             &quot;called on something not allocated by GetStringUTFChars&quot;);
1591       }
1592       UNCHECKED()-&gt;ReleaseStringUTFChars(env, str,
1593           (const char*) guarded.release_for_freeing());
1594     }
1595     functionExit(thr);
1596 JNI_END
1597 
1598 JNI_ENTRY_CHECKED(jsize,
1599   checked_jni_GetArrayLength(JNIEnv *env,
1600                              jarray array))
1601     functionEnter(thr);
1602     IN_VM(
1603       check_is_array(thr, array);
1604     )
1605     jsize result = UNCHECKED()-&gt;GetArrayLength(env,array);
1606     functionExit(thr);
1607     return result;
1608 JNI_END
1609 
1610 JNI_ENTRY_CHECKED(jobjectArray,
1611   checked_jni_NewObjectArray(JNIEnv *env,
1612                              jsize len,
1613                              jclass clazz,
1614                              jobject init))
1615     functionEnter(thr);
1616     jobjectArray result = UNCHECKED()-&gt;NewObjectArray(env,len,clazz,init);
1617     functionExit(thr);
1618     return result;
1619 JNI_END
1620 
1621 JNI_ENTRY_CHECKED(jobject,
1622   checked_jni_GetObjectArrayElement(JNIEnv *env,
1623                                     jobjectArray array,
1624                                     jsize index))
1625     functionEnter(thr);
1626     IN_VM(
1627       check_is_obj_array(thr, array);
1628     )
1629     jobject result = UNCHECKED()-&gt;GetObjectArrayElement(env,array,index);
1630     functionExit(thr);
1631     return result;
1632 JNI_END
1633 
1634 JNI_ENTRY_CHECKED(void,
1635   checked_jni_SetObjectArrayElement(JNIEnv *env,
1636                                     jobjectArray array,
1637                                     jsize index,
1638                                     jobject val))
1639     functionEnter(thr);
1640     IN_VM(
1641       check_is_obj_array(thr, array);
1642     )
1643     UNCHECKED()-&gt;SetObjectArrayElement(env,array,index,val);
1644     functionExit(thr);
1645 JNI_END
1646 
1647 #define WRAPPER_NewScalarArray(Return, Result) \
1648 JNI_ENTRY_CHECKED(Return, \
1649   checked_jni_New##Result##Array(JNIEnv *env, \
1650                                  jsize len)) \
1651     functionEnter(thr); \
1652     Return result = UNCHECKED()-&gt;New##Result##Array(env,len); \
1653     functionExit(thr); \
1654     return (Return) result; \
1655 JNI_END
1656 
1657 WRAPPER_NewScalarArray(jbooleanArray, Boolean)
1658 WRAPPER_NewScalarArray(jbyteArray, Byte)
1659 WRAPPER_NewScalarArray(jshortArray, Short)
1660 WRAPPER_NewScalarArray(jcharArray, Char)
1661 WRAPPER_NewScalarArray(jintArray, Int)
1662 WRAPPER_NewScalarArray(jlongArray, Long)
1663 WRAPPER_NewScalarArray(jfloatArray, Float)
1664 WRAPPER_NewScalarArray(jdoubleArray, Double)
1665 
1666 #define WRAPPER_GetScalarArrayElements(ElementTag,ElementType,Result) \
1667 JNI_ENTRY_CHECKED(ElementType *,  \
1668   checked_jni_Get##Result##ArrayElements(JNIEnv *env, \
1669                                          ElementType##Array array, \
1670                                          jboolean *isCopy)) \
1671     functionEnter(thr); \
1672     IN_VM( \
1673       check_primitive_array_type(thr, array, ElementTag); \
1674     ) \
1675     ElementType *result = UNCHECKED()-&gt;Get##Result##ArrayElements(env, \
1676                                                                   array, \
1677                                                                   isCopy); \
1678     if (result != NULL) { \
1679       result = (ElementType *) check_jni_wrap_copy_array(thr, array, result); \
1680     } \
1681     functionExit(thr); \
1682     return result; \
1683 JNI_END
1684 
1685 WRAPPER_GetScalarArrayElements(T_BOOLEAN, jboolean, Boolean)
1686 WRAPPER_GetScalarArrayElements(T_BYTE,    jbyte,    Byte)
1687 WRAPPER_GetScalarArrayElements(T_SHORT,   jshort,   Short)
1688 WRAPPER_GetScalarArrayElements(T_CHAR,    jchar,    Char)
1689 WRAPPER_GetScalarArrayElements(T_INT,     jint,     Int)
1690 WRAPPER_GetScalarArrayElements(T_LONG,    jlong,    Long)
1691 WRAPPER_GetScalarArrayElements(T_FLOAT,   jfloat,   Float)
1692 WRAPPER_GetScalarArrayElements(T_DOUBLE,  jdouble,  Double)
1693 
1694 #define WRAPPER_ReleaseScalarArrayElements(ElementTag,ElementType,Result,Tag) \
1695 JNI_ENTRY_CHECKED(void,  \
1696   checked_jni_Release##Result##ArrayElements(JNIEnv *env, \
1697                                              ElementType##Array array, \
1698                                              ElementType *elems, \
1699                                              jint mode)) \
1700     functionEnterExceptionAllowed(thr); \
1701     IN_VM( \
1702       check_primitive_array_type(thr, array, ElementTag); \
1703       ASSERT_OOPS_ALLOWED; \
1704       typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
1705     ) \
1706     ElementType* orig_result = (ElementType *) check_wrapped_array_release( \
1707         thr, &quot;checked_jni_Release&quot;#Result&quot;ArrayElements&quot;, array, elems, mode); \
1708     UNCHECKED()-&gt;Release##Result##ArrayElements(env, array, orig_result, mode); \
1709     functionExit(thr); \
1710 JNI_END
1711 
1712 WRAPPER_ReleaseScalarArrayElements(T_BOOLEAN,jboolean, Boolean, bool)
1713 WRAPPER_ReleaseScalarArrayElements(T_BYTE,   jbyte,    Byte,    byte)
1714 WRAPPER_ReleaseScalarArrayElements(T_SHORT,  jshort,   Short,   short)
1715 WRAPPER_ReleaseScalarArrayElements(T_CHAR,   jchar,    Char,    char)
1716 WRAPPER_ReleaseScalarArrayElements(T_INT,    jint,     Int,     int)
1717 WRAPPER_ReleaseScalarArrayElements(T_LONG,   jlong,    Long,    long)
1718 WRAPPER_ReleaseScalarArrayElements(T_FLOAT,  jfloat,   Float,   float)
1719 WRAPPER_ReleaseScalarArrayElements(T_DOUBLE, jdouble,  Double,  double)
1720 
1721 #define WRAPPER_GetScalarArrayRegion(ElementTag,ElementType,Result) \
1722 JNI_ENTRY_CHECKED(void,  \
1723   checked_jni_Get##Result##ArrayRegion(JNIEnv *env, \
1724                                        ElementType##Array array, \
1725                                        jsize start, \
1726                                        jsize len, \
1727                                        ElementType *buf)) \
1728     functionEnter(thr); \
1729     IN_VM( \
1730       check_primitive_array_type(thr, array, ElementTag); \
1731     ) \
1732     UNCHECKED()-&gt;Get##Result##ArrayRegion(env,array,start,len,buf); \
1733     functionExit(thr); \
1734 JNI_END
1735 
1736 WRAPPER_GetScalarArrayRegion(T_BOOLEAN, jboolean, Boolean)
1737 WRAPPER_GetScalarArrayRegion(T_BYTE,    jbyte,    Byte)
1738 WRAPPER_GetScalarArrayRegion(T_SHORT,   jshort,   Short)
1739 WRAPPER_GetScalarArrayRegion(T_CHAR,    jchar,    Char)
1740 WRAPPER_GetScalarArrayRegion(T_INT,     jint,     Int)
1741 WRAPPER_GetScalarArrayRegion(T_LONG,    jlong,    Long)
1742 WRAPPER_GetScalarArrayRegion(T_FLOAT,   jfloat,   Float)
1743 WRAPPER_GetScalarArrayRegion(T_DOUBLE,  jdouble,  Double)
1744 
1745 #define WRAPPER_SetScalarArrayRegion(ElementTag,ElementType,Result) \
1746 JNI_ENTRY_CHECKED(void,  \
1747   checked_jni_Set##Result##ArrayRegion(JNIEnv *env, \
1748                                        ElementType##Array array, \
1749                                        jsize start, \
1750                                        jsize len, \
1751                                        const ElementType *buf)) \
1752     functionEnter(thr); \
1753     IN_VM( \
1754       check_primitive_array_type(thr, array, ElementTag); \
1755     ) \
1756     UNCHECKED()-&gt;Set##Result##ArrayRegion(env,array,start,len,buf); \
1757     functionExit(thr); \
1758 JNI_END
1759 
1760 WRAPPER_SetScalarArrayRegion(T_BOOLEAN, jboolean, Boolean)
1761 WRAPPER_SetScalarArrayRegion(T_BYTE,    jbyte,    Byte)
1762 WRAPPER_SetScalarArrayRegion(T_SHORT,   jshort,   Short)
1763 WRAPPER_SetScalarArrayRegion(T_CHAR,    jchar,    Char)
1764 WRAPPER_SetScalarArrayRegion(T_INT,     jint,     Int)
1765 WRAPPER_SetScalarArrayRegion(T_LONG,    jlong,    Long)
1766 WRAPPER_SetScalarArrayRegion(T_FLOAT,   jfloat,   Float)
1767 WRAPPER_SetScalarArrayRegion(T_DOUBLE,  jdouble,  Double)
1768 
1769 JNI_ENTRY_CHECKED(jint,
1770   checked_jni_RegisterNatives(JNIEnv *env,
1771                               jclass clazz,
1772                               const JNINativeMethod *methods,
1773                               jint nMethods))
1774     functionEnter(thr);
1775     jint result = UNCHECKED()-&gt;RegisterNatives(env,clazz,methods,nMethods);
1776     functionExit(thr);
1777     return result;
1778 JNI_END
1779 
1780 JNI_ENTRY_CHECKED(jint,
1781   checked_jni_UnregisterNatives(JNIEnv *env,
1782                                 jclass clazz))
1783     functionEnter(thr);
1784     jint result = UNCHECKED()-&gt;UnregisterNatives(env,clazz);
1785     functionExit(thr);
1786     return result;
1787 JNI_END
1788 
1789 JNI_ENTRY_CHECKED(jint,
1790   checked_jni_MonitorEnter(JNIEnv *env,
1791                            jobject obj))
1792     functionEnter(thr);
1793     IN_VM(
1794       jniCheck::validate_object(thr, obj);
1795     )
1796     jint result = UNCHECKED()-&gt;MonitorEnter(env,obj);
1797     functionExit(thr);
1798     return result;
1799 JNI_END
1800 
1801 JNI_ENTRY_CHECKED(jint,
1802   checked_jni_MonitorExit(JNIEnv *env,
1803                           jobject obj))
1804     functionEnterExceptionAllowed(thr);
1805     IN_VM(
1806       jniCheck::validate_object(thr, obj);
1807     )
1808     jint result = UNCHECKED()-&gt;MonitorExit(env,obj);
1809     functionExit(thr);
1810     return result;
1811 JNI_END
1812 
1813 JNI_ENTRY_CHECKED(jint,
1814   checked_jni_GetJavaVM(JNIEnv *env,
1815                         JavaVM **vm))
1816     functionEnter(thr);
1817     jint result = UNCHECKED()-&gt;GetJavaVM(env,vm);
1818     functionExit(thr);
1819     return result;
1820 JNI_END
1821 
1822 JNI_ENTRY_CHECKED(void,
1823   checked_jni_GetStringRegion(JNIEnv *env,
1824                               jstring str,
1825                               jsize start,
1826                               jsize len,
1827                               jchar *buf))
1828     functionEnter(thr);
1829     IN_VM(
1830       checkString(thr, str);
1831     )
1832     UNCHECKED()-&gt;GetStringRegion(env, str, start, len, buf);
1833     functionExit(thr);
1834 JNI_END
1835 
1836 JNI_ENTRY_CHECKED(void,
1837   checked_jni_GetStringUTFRegion(JNIEnv *env,
1838                                  jstring str,
1839                                  jsize start,
1840                                  jsize len,
1841                                  char *buf))
1842     functionEnter(thr);
1843     IN_VM(
1844       checkString(thr, str);
1845     )
1846     UNCHECKED()-&gt;GetStringUTFRegion(env, str, start, len, buf);
1847     functionExit(thr);
1848 JNI_END
1849 
1850 JNI_ENTRY_CHECKED(void *,
1851   checked_jni_GetPrimitiveArrayCritical(JNIEnv *env,
1852                                         jarray array,
1853                                         jboolean *isCopy))
1854     functionEnterCritical(thr);
1855     IN_VM(
1856       check_is_primitive_array(thr, array);
1857     )
1858     void *result = UNCHECKED()-&gt;GetPrimitiveArrayCritical(env, array, isCopy);
1859     if (result != NULL) {
1860       result = check_jni_wrap_copy_array(thr, array, result);
1861     }
1862     functionExit(thr);
1863     return result;
1864 JNI_END
1865 
1866 JNI_ENTRY_CHECKED(void,
1867   checked_jni_ReleasePrimitiveArrayCritical(JNIEnv *env,
1868                                             jarray array,
1869                                             void *carray,
1870                                             jint mode))
1871     functionEnterCriticalExceptionAllowed(thr);
1872     IN_VM(
1873       check_is_primitive_array(thr, array);
1874     )
1875     // Check the element array...
1876     void* orig_result = check_wrapped_array_release(thr, &quot;ReleasePrimitiveArrayCritical&quot;, array, carray, mode);
1877     UNCHECKED()-&gt;ReleasePrimitiveArrayCritical(env, array, orig_result, mode);
1878     functionExit(thr);
1879 JNI_END
1880 
1881 JNI_ENTRY_CHECKED(const jchar*,
1882   checked_jni_GetStringCritical(JNIEnv *env,
1883                                 jstring string,
1884                                 jboolean *isCopy))
1885     functionEnterCritical(thr);
1886     IN_VM(
1887       checkString(thr, string);
1888     )
1889     const jchar *result = UNCHECKED()-&gt;GetStringCritical(env, string, isCopy);
1890     functionExit(thr);
1891     return result;
1892 JNI_END
1893 
1894 JNI_ENTRY_CHECKED(void,
1895   checked_jni_ReleaseStringCritical(JNIEnv *env,
1896                                     jstring str,
1897                                     const jchar *chars))
1898     functionEnterCriticalExceptionAllowed(thr);
1899     IN_VM(
1900       checkString(thr, str);
1901     )
1902     /* The Hotspot JNI code does not use the parameters, so just check the
1903      * string parameter as a minor sanity check
1904      */
1905     UNCHECKED()-&gt;ReleaseStringCritical(env, str, chars);
1906     functionExit(thr);
1907 JNI_END
1908 
1909 JNI_ENTRY_CHECKED(jweak,
1910   checked_jni_NewWeakGlobalRef(JNIEnv *env,
1911                                jobject obj))
1912     functionEnter(thr);
1913     IN_VM(
1914       if (obj != NULL) {
1915         jniCheck::validate_handle(thr, obj);
1916       }
1917     )
1918     jweak result = UNCHECKED()-&gt;NewWeakGlobalRef(env, obj);
1919     functionExit(thr);
1920     return result;
1921 JNI_END
1922 
1923 JNI_ENTRY_CHECKED(void,
1924   checked_jni_DeleteWeakGlobalRef(JNIEnv *env,
1925                                   jweak ref))
1926     functionEnterExceptionAllowed(thr);
1927     IN_VM(
1928       if (ref &amp;&amp; !JNIHandles::is_weak_global_handle(ref)) {
1929         ReportJNIFatalError(thr,
1930              &quot;Invalid weak global JNI handle passed to DeleteWeakGlobalRef&quot;);
1931       }
1932     )
1933     UNCHECKED()-&gt;DeleteWeakGlobalRef(env, ref);
1934     functionExit(thr);
1935 JNI_END
1936 
1937 JNI_ENTRY_CHECKED(jboolean,
1938   checked_jni_ExceptionCheck(JNIEnv *env))
1939     thr-&gt;clear_pending_jni_exception_check();
1940     functionEnterExceptionAllowed(thr);
1941     jboolean result = UNCHECKED()-&gt;ExceptionCheck(env);
1942     functionExit(thr);
1943     return result;
1944 JNI_END
1945 
1946 JNI_ENTRY_CHECKED(jobject,
1947   checked_jni_NewDirectByteBuffer(JNIEnv *env,
1948                                   void *address,
1949                                   jlong capacity))
1950     functionEnter(thr);
1951     jobject result = UNCHECKED()-&gt;NewDirectByteBuffer(env, address, capacity);
1952     functionExit(thr);
1953     return result;
1954 JNI_END
1955 
1956 JNI_ENTRY_CHECKED(void *,
1957   checked_jni_GetDirectBufferAddress(JNIEnv *env,
1958                                      jobject buf))
1959     functionEnter(thr);
1960     void* result = UNCHECKED()-&gt;GetDirectBufferAddress(env, buf);
1961     functionExit(thr);
1962     return result;
1963 JNI_END
1964 
1965 JNI_ENTRY_CHECKED(jlong,
1966   checked_jni_GetDirectBufferCapacity(JNIEnv *env,
1967                                       jobject buf))
1968     functionEnter(thr);
1969     jlong result = UNCHECKED()-&gt;GetDirectBufferCapacity(env, buf);
1970     functionExit(thr);
1971     return result;
1972 JNI_END
1973 
1974 JNI_ENTRY_CHECKED(jobjectRefType,
1975   checked_jni_GetObjectRefType(JNIEnv *env,
1976                                jobject obj))
1977     functionEnter(thr);
1978     /* validate the object being passed */
1979     IN_VM(
1980       jniCheck::validate_object(thr, obj);
1981     )
1982     jobjectRefType result = UNCHECKED()-&gt;GetObjectRefType(env, obj);
1983     functionExit(thr);
1984     return result;
1985 JNI_END
1986 
1987 
1988 JNI_ENTRY_CHECKED(jint,
1989   checked_jni_GetVersion(JNIEnv *env))
1990     functionEnter(thr);
1991     jint result = UNCHECKED()-&gt;GetVersion(env);
1992     functionExit(thr);
1993     return result;
1994 JNI_END
1995 
1996 JNI_ENTRY_CHECKED(jobject,
1997   checked_jni_GetModule(JNIEnv *env,
1998                         jclass clazz))
1999     functionEnter(thr);
2000     jobject result = UNCHECKED()-&gt;GetModule(env,clazz);
2001     functionExit(thr);
2002     return result;
2003 JNI_END
2004 
2005 /*
2006  * Structure containing all checked jni functions
2007  */
2008 struct JNINativeInterface_  checked_jni_NativeInterface = {
2009     NULL,
2010     NULL,
2011     NULL,
2012 
2013     NULL,
2014 
2015     checked_jni_GetVersion,
2016 
2017     checked_jni_DefineClass,
2018     checked_jni_FindClass,
2019 
2020     checked_jni_FromReflectedMethod,
2021     checked_jni_FromReflectedField,
2022 
2023     checked_jni_ToReflectedMethod,
2024 
2025     checked_jni_GetSuperclass,
2026     checked_jni_IsAssignableFrom,
2027 
2028     checked_jni_ToReflectedField,
2029 
2030     checked_jni_Throw,
2031     checked_jni_ThrowNew,
2032     checked_jni_ExceptionOccurred,
2033     checked_jni_ExceptionDescribe,
2034     checked_jni_ExceptionClear,
2035     checked_jni_FatalError,
2036 
2037     checked_jni_PushLocalFrame,
2038     checked_jni_PopLocalFrame,
2039 
2040     checked_jni_NewGlobalRef,
2041     checked_jni_DeleteGlobalRef,
2042     checked_jni_DeleteLocalRef,
2043     checked_jni_IsSameObject,
2044 
2045     checked_jni_NewLocalRef,
2046     checked_jni_EnsureLocalCapacity,
2047 
2048     checked_jni_AllocObject,
2049     checked_jni_NewObject,
2050     checked_jni_NewObjectV,
2051     checked_jni_NewObjectA,
2052 
2053     checked_jni_GetObjectClass,
2054     checked_jni_IsInstanceOf,
2055 
2056     checked_jni_GetMethodID,
2057 
2058     checked_jni_CallObjectMethod,
2059     checked_jni_CallObjectMethodV,
2060     checked_jni_CallObjectMethodA,
2061     checked_jni_CallBooleanMethod,
2062     checked_jni_CallBooleanMethodV,
2063     checked_jni_CallBooleanMethodA,
2064     checked_jni_CallByteMethod,
2065     checked_jni_CallByteMethodV,
2066     checked_jni_CallByteMethodA,
2067     checked_jni_CallCharMethod,
2068     checked_jni_CallCharMethodV,
2069     checked_jni_CallCharMethodA,
2070     checked_jni_CallShortMethod,
2071     checked_jni_CallShortMethodV,
2072     checked_jni_CallShortMethodA,
2073     checked_jni_CallIntMethod,
2074     checked_jni_CallIntMethodV,
2075     checked_jni_CallIntMethodA,
2076     checked_jni_CallLongMethod,
2077     checked_jni_CallLongMethodV,
2078     checked_jni_CallLongMethodA,
2079     checked_jni_CallFloatMethod,
2080     checked_jni_CallFloatMethodV,
2081     checked_jni_CallFloatMethodA,
2082     checked_jni_CallDoubleMethod,
2083     checked_jni_CallDoubleMethodV,
2084     checked_jni_CallDoubleMethodA,
2085     checked_jni_CallVoidMethod,
2086     checked_jni_CallVoidMethodV,
2087     checked_jni_CallVoidMethodA,
2088 
2089     checked_jni_CallNonvirtualObjectMethod,
2090     checked_jni_CallNonvirtualObjectMethodV,
2091     checked_jni_CallNonvirtualObjectMethodA,
2092     checked_jni_CallNonvirtualBooleanMethod,
2093     checked_jni_CallNonvirtualBooleanMethodV,
2094     checked_jni_CallNonvirtualBooleanMethodA,
2095     checked_jni_CallNonvirtualByteMethod,
2096     checked_jni_CallNonvirtualByteMethodV,
2097     checked_jni_CallNonvirtualByteMethodA,
2098     checked_jni_CallNonvirtualCharMethod,
2099     checked_jni_CallNonvirtualCharMethodV,
2100     checked_jni_CallNonvirtualCharMethodA,
2101     checked_jni_CallNonvirtualShortMethod,
2102     checked_jni_CallNonvirtualShortMethodV,
2103     checked_jni_CallNonvirtualShortMethodA,
2104     checked_jni_CallNonvirtualIntMethod,
2105     checked_jni_CallNonvirtualIntMethodV,
2106     checked_jni_CallNonvirtualIntMethodA,
2107     checked_jni_CallNonvirtualLongMethod,
2108     checked_jni_CallNonvirtualLongMethodV,
2109     checked_jni_CallNonvirtualLongMethodA,
2110     checked_jni_CallNonvirtualFloatMethod,
2111     checked_jni_CallNonvirtualFloatMethodV,
2112     checked_jni_CallNonvirtualFloatMethodA,
2113     checked_jni_CallNonvirtualDoubleMethod,
2114     checked_jni_CallNonvirtualDoubleMethodV,
2115     checked_jni_CallNonvirtualDoubleMethodA,
2116     checked_jni_CallNonvirtualVoidMethod,
2117     checked_jni_CallNonvirtualVoidMethodV,
2118     checked_jni_CallNonvirtualVoidMethodA,
2119 
2120     checked_jni_GetFieldID,
2121 
2122     checked_jni_GetObjectField,
2123     checked_jni_GetBooleanField,
2124     checked_jni_GetByteField,
2125     checked_jni_GetCharField,
2126     checked_jni_GetShortField,
2127     checked_jni_GetIntField,
2128     checked_jni_GetLongField,
2129     checked_jni_GetFloatField,
2130     checked_jni_GetDoubleField,
2131 
2132     checked_jni_SetObjectField,
2133     checked_jni_SetBooleanField,
2134     checked_jni_SetByteField,
2135     checked_jni_SetCharField,
2136     checked_jni_SetShortField,
2137     checked_jni_SetIntField,
2138     checked_jni_SetLongField,
2139     checked_jni_SetFloatField,
2140     checked_jni_SetDoubleField,
2141 
2142     checked_jni_GetStaticMethodID,
2143 
2144     checked_jni_CallStaticObjectMethod,
2145     checked_jni_CallStaticObjectMethodV,
2146     checked_jni_CallStaticObjectMethodA,
2147     checked_jni_CallStaticBooleanMethod,
2148     checked_jni_CallStaticBooleanMethodV,
2149     checked_jni_CallStaticBooleanMethodA,
2150     checked_jni_CallStaticByteMethod,
2151     checked_jni_CallStaticByteMethodV,
2152     checked_jni_CallStaticByteMethodA,
2153     checked_jni_CallStaticCharMethod,
2154     checked_jni_CallStaticCharMethodV,
2155     checked_jni_CallStaticCharMethodA,
2156     checked_jni_CallStaticShortMethod,
2157     checked_jni_CallStaticShortMethodV,
2158     checked_jni_CallStaticShortMethodA,
2159     checked_jni_CallStaticIntMethod,
2160     checked_jni_CallStaticIntMethodV,
2161     checked_jni_CallStaticIntMethodA,
2162     checked_jni_CallStaticLongMethod,
2163     checked_jni_CallStaticLongMethodV,
2164     checked_jni_CallStaticLongMethodA,
2165     checked_jni_CallStaticFloatMethod,
2166     checked_jni_CallStaticFloatMethodV,
2167     checked_jni_CallStaticFloatMethodA,
2168     checked_jni_CallStaticDoubleMethod,
2169     checked_jni_CallStaticDoubleMethodV,
2170     checked_jni_CallStaticDoubleMethodA,
2171     checked_jni_CallStaticVoidMethod,
2172     checked_jni_CallStaticVoidMethodV,
2173     checked_jni_CallStaticVoidMethodA,
2174 
2175     checked_jni_GetStaticFieldID,
2176 
2177     checked_jni_GetStaticObjectField,
2178     checked_jni_GetStaticBooleanField,
2179     checked_jni_GetStaticByteField,
2180     checked_jni_GetStaticCharField,
2181     checked_jni_GetStaticShortField,
2182     checked_jni_GetStaticIntField,
2183     checked_jni_GetStaticLongField,
2184     checked_jni_GetStaticFloatField,
2185     checked_jni_GetStaticDoubleField,
2186 
2187     checked_jni_SetStaticObjectField,
2188     checked_jni_SetStaticBooleanField,
2189     checked_jni_SetStaticByteField,
2190     checked_jni_SetStaticCharField,
2191     checked_jni_SetStaticShortField,
2192     checked_jni_SetStaticIntField,
2193     checked_jni_SetStaticLongField,
2194     checked_jni_SetStaticFloatField,
2195     checked_jni_SetStaticDoubleField,
2196 
2197     checked_jni_NewString,
2198     checked_jni_GetStringLength,
2199     checked_jni_GetStringChars,
2200     checked_jni_ReleaseStringChars,
2201 
2202     checked_jni_NewStringUTF,
2203     checked_jni_GetStringUTFLength,
2204     checked_jni_GetStringUTFChars,
2205     checked_jni_ReleaseStringUTFChars,
2206 
2207     checked_jni_GetArrayLength,
2208 
2209     checked_jni_NewObjectArray,
2210     checked_jni_GetObjectArrayElement,
2211     checked_jni_SetObjectArrayElement,
2212 
2213     checked_jni_NewBooleanArray,
2214     checked_jni_NewByteArray,
2215     checked_jni_NewCharArray,
2216     checked_jni_NewShortArray,
2217     checked_jni_NewIntArray,
2218     checked_jni_NewLongArray,
2219     checked_jni_NewFloatArray,
2220     checked_jni_NewDoubleArray,
2221 
2222     checked_jni_GetBooleanArrayElements,
2223     checked_jni_GetByteArrayElements,
2224     checked_jni_GetCharArrayElements,
2225     checked_jni_GetShortArrayElements,
2226     checked_jni_GetIntArrayElements,
2227     checked_jni_GetLongArrayElements,
2228     checked_jni_GetFloatArrayElements,
2229     checked_jni_GetDoubleArrayElements,
2230 
2231     checked_jni_ReleaseBooleanArrayElements,
2232     checked_jni_ReleaseByteArrayElements,
2233     checked_jni_ReleaseCharArrayElements,
2234     checked_jni_ReleaseShortArrayElements,
2235     checked_jni_ReleaseIntArrayElements,
2236     checked_jni_ReleaseLongArrayElements,
2237     checked_jni_ReleaseFloatArrayElements,
2238     checked_jni_ReleaseDoubleArrayElements,
2239 
2240     checked_jni_GetBooleanArrayRegion,
2241     checked_jni_GetByteArrayRegion,
2242     checked_jni_GetCharArrayRegion,
2243     checked_jni_GetShortArrayRegion,
2244     checked_jni_GetIntArrayRegion,
2245     checked_jni_GetLongArrayRegion,
2246     checked_jni_GetFloatArrayRegion,
2247     checked_jni_GetDoubleArrayRegion,
2248 
2249     checked_jni_SetBooleanArrayRegion,
2250     checked_jni_SetByteArrayRegion,
2251     checked_jni_SetCharArrayRegion,
2252     checked_jni_SetShortArrayRegion,
2253     checked_jni_SetIntArrayRegion,
2254     checked_jni_SetLongArrayRegion,
2255     checked_jni_SetFloatArrayRegion,
2256     checked_jni_SetDoubleArrayRegion,
2257 
2258     checked_jni_RegisterNatives,
2259     checked_jni_UnregisterNatives,
2260 
2261     checked_jni_MonitorEnter,
2262     checked_jni_MonitorExit,
2263 
2264     checked_jni_GetJavaVM,
2265 
2266     checked_jni_GetStringRegion,
2267     checked_jni_GetStringUTFRegion,
2268 
2269     checked_jni_GetPrimitiveArrayCritical,
2270     checked_jni_ReleasePrimitiveArrayCritical,
2271 
2272     checked_jni_GetStringCritical,
2273     checked_jni_ReleaseStringCritical,
2274 
2275     checked_jni_NewWeakGlobalRef,
2276     checked_jni_DeleteWeakGlobalRef,
2277 
2278     checked_jni_ExceptionCheck,
2279 
2280     checked_jni_NewDirectByteBuffer,
2281     checked_jni_GetDirectBufferAddress,
2282     checked_jni_GetDirectBufferCapacity,
2283 
2284     // New 1.6 Features
2285 
2286     checked_jni_GetObjectRefType,
2287 
2288     // Module Features
2289 
2290     checked_jni_GetModule
2291 };
2292 
2293 
2294 // Returns the function structure
2295 struct JNINativeInterface_* jni_functions_check() {
2296 
2297   unchecked_jni_NativeInterface = jni_functions_nocheck();
2298 
2299   // make sure the last pointer in the checked table is not null, indicating
2300   // an addition to the JNINativeInterface_ structure without initializing
2301   // it in the checked table.
2302   debug_only(int *lastPtr = (int *)((char *)&amp;checked_jni_NativeInterface + \
2303              sizeof(*unchecked_jni_NativeInterface) - sizeof(char *));)
2304   assert(*lastPtr != 0,
2305          &quot;Mismatched JNINativeInterface tables, check for new entries&quot;);
2306 
2307   // with -verbose:jni this message will print
2308   log_debug(jni, resolve)(&quot;Checked JNI functions are being used to validate JNI usage&quot;);
2309 
2310   return &amp;checked_jni_NativeInterface;
2311 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
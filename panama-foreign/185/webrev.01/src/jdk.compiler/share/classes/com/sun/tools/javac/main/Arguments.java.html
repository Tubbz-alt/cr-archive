<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/main/Arguments.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.main;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Files;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.util.Arrays;
 33 import java.util.Collections;
 34 import java.util.EnumSet;
 35 import java.util.HashSet;
 36 import java.util.Iterator;
 37 import java.util.LinkedHashMap;
 38 import java.util.LinkedHashSet;
 39 import java.util.Map;
 40 import java.util.Set;
 41 import java.util.function.Predicate;
 42 import java.util.regex.Matcher;
 43 import java.util.regex.Pattern;
 44 import java.util.stream.Stream;
 45 
 46 import javax.lang.model.SourceVersion;
 47 import javax.tools.JavaFileManager;
 48 import javax.tools.JavaFileManager.Location;
 49 import javax.tools.JavaFileObject;
 50 import javax.tools.JavaFileObject.Kind;
 51 import javax.tools.StandardJavaFileManager;
 52 import javax.tools.StandardLocation;
 53 
 54 import com.sun.tools.doclint.DocLint;
 55 import com.sun.tools.javac.code.Lint.LintCategory;
 56 import com.sun.tools.javac.code.Source;
 57 import com.sun.tools.javac.file.BaseFileManager;
 58 import com.sun.tools.javac.file.JavacFileManager;
 59 import com.sun.tools.javac.jvm.Profile;
 60 import com.sun.tools.javac.jvm.Target;
 61 import com.sun.tools.javac.main.OptionHelper.GrumpyHelper;
 62 import com.sun.tools.javac.platform.PlatformDescription;
 63 import com.sun.tools.javac.platform.PlatformUtils;
 64 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 65 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
 66 import com.sun.tools.javac.util.Context;
 67 import com.sun.tools.javac.util.JCDiagnostic;
 68 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticInfo;
 69 import com.sun.tools.javac.util.List;
 70 import com.sun.tools.javac.util.ListBuffer;
 71 import com.sun.tools.javac.util.Log;
 72 import com.sun.tools.javac.util.Log.PrefixKind;
 73 import com.sun.tools.javac.util.Log.WriterKind;
 74 import com.sun.tools.javac.util.Options;
 75 import com.sun.tools.javac.util.PropagatedException;
 76 
 77 /**
 78  * Shared option and argument handling for command line and API usage of javac.
 79  */
 80 public class Arguments {
 81 
 82     /**
 83      * The context key for the arguments.
 84      */
 85     public static final Context.Key&lt;Arguments&gt; argsKey = new Context.Key&lt;&gt;();
 86 
 87     private String ownName;
 88     private Set&lt;String&gt; classNames;
 89     private Set&lt;Path&gt; files;
 90     private Map&lt;Option, String&gt; deferredFileManagerOptions;
 91     private Set&lt;JavaFileObject&gt; fileObjects;
 92     private boolean emptyAllowed;
 93     private final Options options;
 94 
 95     private JavaFileManager fileManager;
 96     private final Log log;
 97     private final Context context;
 98 
 99     private enum ErrorMode { ILLEGAL_ARGUMENT, ILLEGAL_STATE, LOG };
100     private ErrorMode errorMode;
101     private boolean errors;
102 
103     /**
104      * Gets the Arguments instance for this context.
105      *
106      * @param context the content
107      * @return the Arguments instance for this context.
108      */
109     public static Arguments instance(Context context) {
110         Arguments instance = context.get(argsKey);
111         if (instance == null) {
112             instance = new Arguments(context);
113         }
114         return instance;
115     }
116 
117     protected Arguments(Context context) {
118         context.put(argsKey, this);
119         options = Options.instance(context);
120         log = Log.instance(context);
121         this.context = context;
122 
123         // Ideally, we could init this here and update/configure it as
124         // needed, but right now, initializing a file manager triggers
125         // initialization of other items in the context, such as Lint
126         // and FSInfo, which should not be initialized until after
127         // processArgs
128         //        fileManager = context.get(JavaFileManager.class);
129     }
130 
131     private final OptionHelper cmdLineHelper = new OptionHelper() {
132         @Override
133         public String get(Option option) {
134             return options.get(option);
135         }
136 
137         @Override
138         public void put(String name, String value) {
139             options.put(name, value);
140         }
141 
142         @Override
143         public void remove(String name) {
144             options.remove(name);
145         }
146 
147         @Override
148         public boolean handleFileManagerOption(Option option, String value) {
149             options.put(option, value);
150             deferredFileManagerOptions.put(option, value);
151             return true;
152         }
153 
154         @Override
155         public Log getLog() {
156             return log;
157         }
158 
159         @Override
160         public String getOwnName() {
161             return ownName;
162         }
163 
164         @Override
165         public void addFile(Path p) {
166             files.add(p);
167         }
168 
169         @Override
170         public void addClassName(String s) {
171             classNames.add(s);
172         }
173 
174     };
175 
176     /**
177      * Initializes this Args instance with a set of command line args.
178      * The args will be processed in conjunction with the full set of
179      * command line options, including -help, -version etc.
180      * The args may also contain class names and filenames.
181      * Any errors during this call, and later during validate, will be reported
182      * to the log.
183      * @param ownName the name of this tool; used to prefix messages
184      * @param args the args to be processed
185      */
186     public void init(String ownName, Iterable&lt;String&gt; args) {
187         this.ownName = ownName;
188         errorMode = ErrorMode.LOG;
189         files = new LinkedHashSet&lt;&gt;();
190         deferredFileManagerOptions = new LinkedHashMap&lt;&gt;();
191         fileObjects = null;
192         classNames = new LinkedHashSet&lt;&gt;();
193         processArgs(args, Option.getJavaCompilerOptions(), cmdLineHelper, true, false);
194         if (errors) {
195             log.printLines(PrefixKind.JAVAC, &quot;msg.usage&quot;, ownName);
196         }
197     }
198 
199     private final OptionHelper apiHelper = new GrumpyHelper(null) {
200         @Override
201         public String get(Option option) {
202             return options.get(option);
203         }
204 
205         @Override
206         public void put(String name, String value) {
207             options.put(name, value);
208         }
209 
210         @Override
211         public void remove(String name) {
212             options.remove(name);
213         }
214 
215         @Override
216         public Log getLog() {
217             return Arguments.this.log;
218         }
219     };
220 
221     /**
222      * Initializes this Args instance with the parameters for a JavacTask.
223      * The options will be processed in conjunction with the restricted set
224      * of tool options, which does not include -help, -version, etc,
225      * nor does it include classes and filenames, which should be specified
226      * separately.
227      * File manager options are handled directly by the file manager.
228      * Any errors found while processing individual args will be reported
229      * via IllegalArgumentException.
230      * Any subsequent errors during validate will be reported via IllegalStateException.
231      * @param ownName the name of this tool; used to prefix messages
232      * @param options the options to be processed
233      * @param classNames the classes to be subject to annotation processing
234      * @param files the files to be compiled
235      */
236     public void init(String ownName,
237             Iterable&lt;String&gt; options,
238             Iterable&lt;String&gt; classNames,
239             Iterable&lt;? extends JavaFileObject&gt; files) {
240         this.ownName = ownName;
241         this.classNames = toSet(classNames);
242         this.fileObjects = toSet(files);
243         this.files = null;
244         errorMode = ErrorMode.ILLEGAL_ARGUMENT;
245         if (options != null) {
246             processArgs(toList(options), Option.getJavacToolOptions(), apiHelper, false, true);
247         }
248         errorMode = ErrorMode.ILLEGAL_STATE;
249     }
250 
251     /**
252      * Minimal initialization for tools, like javadoc,
253      * to be able to process javac options for themselves,
254      * and then call validate.
255      * @param ownName  the name of this tool; used to prefix messages
256      */
257     public void init(String ownName) {
258         this.ownName = ownName;
259         errorMode = ErrorMode.LOG;
260     }
261 
262     /**
263      * Gets the files to be compiled.
264      * @return the files to be compiled
265      */
266     public Set&lt;JavaFileObject&gt; getFileObjects() {
267         if (fileObjects == null) {
268             fileObjects = new LinkedHashSet&lt;&gt;();
269         }
270         if (files != null) {
271             JavacFileManager jfm = (JavacFileManager) getFileManager();
272             for (JavaFileObject fo: jfm.getJavaFileObjectsFromPaths(files))
273                 fileObjects.add(fo);
274         }
275         return fileObjects;
276     }
277 
278     /**
279      * Gets the classes to be subject to annotation processing.
280      * @return the classes to be subject to annotation processing
281      */
282     public Set&lt;String&gt; getClassNames() {
283         return classNames;
284     }
285 
286     /**
287      * Handles the {@code --release} option.
288      *
289      * @param additionalOptions a predicate to handle additional options implied by the
290      * {@code --release} option. The predicate should return true if all the additional
291      * options were processed successfully.
292      * @return true if successful, false otherwise
293      */
294     public boolean handleReleaseOptions(Predicate&lt;Iterable&lt;String&gt;&gt; additionalOptions) {
295         String platformString = options.get(Option.RELEASE);
296 
297         checkOptionAllowed(platformString == null,
298                 option -&gt; reportDiag(Errors.ReleaseBootclasspathConflict(option)),
299                 Option.BOOT_CLASS_PATH, Option.XBOOTCLASSPATH, Option.XBOOTCLASSPATH_APPEND,
300                 Option.XBOOTCLASSPATH_PREPEND,
301                 Option.ENDORSEDDIRS, Option.DJAVA_ENDORSED_DIRS,
302                 Option.EXTDIRS, Option.DJAVA_EXT_DIRS,
303                 Option.SOURCE, Option.TARGET,
304                 Option.SYSTEM, Option.UPGRADE_MODULE_PATH);
305 
306         if (platformString != null) {
307             PlatformDescription platformDescription =
308                     PlatformUtils.lookupPlatformDescription(platformString);
309 
310             if (platformDescription == null) {
311                 reportDiag(Errors.UnsupportedReleaseVersion(platformString));
312                 return false;
313             }
314 
315             options.put(Option.SOURCE, platformDescription.getSourceVersion());
316             options.put(Option.TARGET, platformDescription.getTargetVersion());
317 
318             context.put(PlatformDescription.class, platformDescription);
319 
320             if (!additionalOptions.test(platformDescription.getAdditionalOptions()))
321                 return false;
322 
323             JavaFileManager platformFM = platformDescription.getFileManager();
324             DelegatingJavaFileManager.installReleaseFileManager(context,
325                                                                 platformFM,
326                                                                 getFileManager());
327         }
328 
329         return true;
330     }
331 
332     /**
333      * Processes strings containing options and operands.
334      * @param args the strings to be processed
335      * @param allowableOpts the set of option declarations that are applicable
336      * @param helper a help for use by Option.process
337      * @param allowOperands whether or not to check for files and classes
338      * @param checkFileManager whether or not to check if the file manager can handle
339      *      options which are not recognized by any of allowableOpts
340      * @return true if all the strings were successfully processed; false otherwise
341      * @throws IllegalArgumentException if a problem occurs and errorMode is set to
342      *      ILLEGAL_ARGUMENT
343      */
344     private boolean processArgs(Iterable&lt;String&gt; args,
345             Set&lt;Option&gt; allowableOpts, OptionHelper helper,
346             boolean allowOperands, boolean checkFileManager) {
347         if (!doProcessArgs(args, allowableOpts, helper, allowOperands, checkFileManager))
348             return false;
349 
350         if (!handleReleaseOptions(extra -&gt; doProcessArgs(extra, allowableOpts, helper, allowOperands, checkFileManager)))
351             return false;
352 
353         options.notifyListeners();
354 
355         return true;
356     }
357 
358     private boolean doProcessArgs(Iterable&lt;String&gt; args,
359             Set&lt;Option&gt; allowableOpts, OptionHelper helper,
360             boolean allowOperands, boolean checkFileManager) {
361         JavaFileManager fm = checkFileManager ? getFileManager() : null;
362         Iterator&lt;String&gt; argIter = args.iterator();
363         while (argIter.hasNext()) {
364             String arg = argIter.next();
365             if (arg.isEmpty()) {
366                 reportDiag(Errors.InvalidFlag(arg));
367                 return false;
368             }
369 
370             Option option = null;
371 
372             // first, check the provided set of javac options
373             if (arg.startsWith(&quot;-&quot;)) {
374                 option = Option.lookup(arg, allowableOpts);
375             } else if (allowOperands &amp;&amp; Option.SOURCEFILE.matches(arg)) {
376                 option = Option.SOURCEFILE;
377             }
378 
379             if (option != null) {
380                 try {
381                     option.handleOption(helper, arg, argIter);
382                 } catch (Option.InvalidValueException e) {
383                     error(e);
384                     return false;
385                 }
386                 continue;
387             }
388 
389             // check file manager option
390             if (fm != null &amp;&amp; fm.handleOption(arg, argIter)) {
391                 continue;
392             }
393 
394             // none of the above
395             reportDiag(Errors.InvalidFlag(arg));
396             return false;
397         }
398 
399         return true;
400     }
401 
402     /**
403      * Validates the overall consistency of the options and operands
404      * processed by processOptions.
405      * @return true if all args are successfully validated; false otherwise.
406      * @throws IllegalStateException if a problem is found and errorMode is set to
407      *      ILLEGAL_STATE
408      */
409     public boolean validate() {
410         JavaFileManager fm = getFileManager();
411         if (options.isSet(Option.MODULE)) {
412             if (!fm.hasLocation(StandardLocation.CLASS_OUTPUT)) {
413                 log.error(Errors.OutputDirMustBeSpecifiedWithDashMOption);
414             } else if (!fm.hasLocation(StandardLocation.MODULE_SOURCE_PATH)) {
415                 log.error(Errors.ModulesourcepathMustBeSpecifiedWithDashMOption);
416             } else {
417                 java.util.List&lt;String&gt; modules = Arrays.asList(options.get(Option.MODULE).split(&quot;,&quot;));
418                 try {
419                     for (String module : modules) {
420                         Location sourceLoc = fm.getLocationForModule(StandardLocation.MODULE_SOURCE_PATH, module);
421                         if (sourceLoc == null) {
422                             log.error(Errors.ModuleNotFoundInModuleSourcePath(module));
423                         } else {
424                             Location classLoc = fm.getLocationForModule(StandardLocation.CLASS_OUTPUT, module);
425 
426                             for (JavaFileObject file : fm.list(sourceLoc, &quot;&quot;, EnumSet.of(JavaFileObject.Kind.SOURCE), true)) {
427                                 String className = fm.inferBinaryName(sourceLoc, file);
428                                 JavaFileObject classFile = fm.getJavaFileForInput(classLoc, className, Kind.CLASS);
429 
430                                 if (classFile == null || classFile.getLastModified() &lt; file.getLastModified()) {
431                                     if (fileObjects == null)
432                                         fileObjects = new HashSet&lt;&gt;();
433                                     fileObjects.add(file);
434                                 }
435                             }
436                         }
437                     }
438                 } catch (IOException ex) {
439                     log.printLines(PrefixKind.JAVAC, &quot;msg.io&quot;);
440                     ex.printStackTrace(log.getWriter(WriterKind.NOTICE));
441                     return false;
442                 }
443             }
444         }
445 
446         if (isEmpty()) {
447             // It is allowed to compile nothing if just asking for help or version info.
448             // But also note that none of these options are supported in API mode.
449             if (options.isSet(Option.HELP)
450                     || options.isSet(Option.X)
451                     || options.isSet(Option.VERSION)
452                     || options.isSet(Option.FULLVERSION)
453                     || options.isSet(Option.MODULE)) {
454                 return true;
455             }
456 
457             if (!emptyAllowed) {
458                 if (!errors) {
459                     if (JavaCompiler.explicitAnnotationProcessingRequested(options)) {
460                         reportDiag(Errors.NoSourceFilesClasses);
461                     } else {
462                         reportDiag(Errors.NoSourceFiles);
463                     }
464                 }
465                 return false;
466             }
467         }
468 
469         if (!checkDirectory(Option.D)) {
470             return false;
471         }
472         if (!checkDirectory(Option.S)) {
473             return false;
474         }
475         if (!checkDirectory(Option.H)) {
476             return false;
477         }
478 
479         // The following checks are to help avoid accidental confusion between
480         // directories of modules and exploded module directories.
481         if (fm instanceof StandardJavaFileManager) {
482             StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;
483             if (sfm.hasLocation(StandardLocation.CLASS_OUTPUT)) {
484                 Path outDir = sfm.getLocationAsPaths(StandardLocation.CLASS_OUTPUT).iterator().next();
485                 if (sfm.hasLocation(StandardLocation.MODULE_SOURCE_PATH)) {
486                     // multi-module mode
487                     if (Files.exists(outDir.resolve(&quot;module-info.class&quot;))) {
488                         log.error(Errors.MultiModuleOutdirCannotBeExplodedModule(outDir));
489                     }
490                 } else {
491                     // single-module or legacy mode
492                     boolean lintPaths = options.isUnset(Option.XLINT_CUSTOM,
493                             &quot;-&quot; + LintCategory.PATH.option);
494                     if (lintPaths) {
495                         Path outDirParent = outDir.getParent();
496                         if (outDirParent != null &amp;&amp; Files.exists(outDirParent.resolve(&quot;module-info.class&quot;))) {
497                             log.warning(LintCategory.PATH, Warnings.OutdirIsInExplodedModule(outDir));
498                         }
499                     }
500                 }
501             }
502         }
503 
504 
505         String sourceString = options.get(Option.SOURCE);
506         Source source = (sourceString != null)
507                 ? Source.lookup(sourceString)
508                 : Source.DEFAULT;
509         String targetString = options.get(Option.TARGET);
510         Target target = (targetString != null)
511                 ? Target.lookup(targetString)
512                 : Target.DEFAULT;
513 
514         // We don&#39;t check source/target consistency for CLDC, as J2ME
515         // profiles are not aligned with J2SE targets; moreover, a
516         // single CLDC target may have many profiles.  In addition,
517         // this is needed for the continued functioning of the JSR14
518         // prototype.
519         if (Character.isDigit(target.name.charAt(0))) {
520             if (target.compareTo(source.requiredTarget()) &lt; 0) {
521                 if (targetString != null) {
522                     if (sourceString == null) {
523                         reportDiag(Warnings.TargetDefaultSourceConflict(targetString, source.requiredTarget()));
524                     } else {
525                         reportDiag(Warnings.SourceTargetConflict(sourceString, source.requiredTarget()));
526                     }
527                     return false;
528                 } else {
529                     target = source.requiredTarget();
530                     options.put(&quot;-target&quot;, target.name);
531                 }
532             }
533         }
534 
535         if (options.isSet(Option.PREVIEW)) {
536             if (sourceString == null) {
537                 //enable-preview must be used with explicit -source or --release
538                 report(Errors.PreviewWithoutSourceOrRelease);
539                 return false;
540             } else if (source != Source.DEFAULT) {
541                 //enable-preview must be used with latest source version
542                 report(Errors.PreviewNotLatest(sourceString, Source.DEFAULT));
543                 return false;
544             }
545         }
546 
547         String profileString = options.get(Option.PROFILE);
548         if (profileString != null) {
549             Profile profile = Profile.lookup(profileString);
550             if (target.compareTo(Target.JDK1_8) &lt;= 0 &amp;&amp; !profile.isValid(target)) {
551                 // note: -profile not permitted for target &gt;= 9, so error (below) not warning (here)
552                 reportDiag(Warnings.ProfileTargetConflict(profile, target));
553             }
554 
555             // This check is only effective in command line mode,
556             // where the file manager options are added to options
557             if (options.get(Option.BOOT_CLASS_PATH) != null) {
558                 reportDiag(Errors.ProfileBootclasspathConflict);
559             }
560         }
561 
562         if (options.isSet(Option.SOURCE_PATH) &amp;&amp; options.isSet(Option.MODULE_SOURCE_PATH)) {
563             reportDiag(Errors.SourcepathModulesourcepathConflict);
564         }
565 
566         boolean lintOptions = options.isUnset(Option.XLINT_CUSTOM, &quot;-&quot; + LintCategory.OPTIONS.option);
567         if (lintOptions &amp;&amp; source.compareTo(Source.DEFAULT) &lt; 0 &amp;&amp; !options.isSet(Option.RELEASE)) {
568             if (fm instanceof BaseFileManager) {
569                 if (source.compareTo(Source.JDK8) &lt;= 0) {
570                     if (((BaseFileManager) fm).isDefaultBootClassPath())
571                         log.warning(LintCategory.OPTIONS, Warnings.SourceNoBootclasspath(source.name));
572                 } else {
573                     if (((BaseFileManager) fm).isDefaultSystemModulesPath())
574                         log.warning(LintCategory.OPTIONS, Warnings.SourceNoSystemModulesPath(source.name));
575                 }
576             }
577         }
578 
579         boolean obsoleteOptionFound = false;
580 
581         if (source.compareTo(Source.MIN) &lt; 0) {
582             log.error(Errors.OptionRemovedSource(source.name, Source.MIN.name));
583         } else if (source == Source.MIN &amp;&amp; lintOptions) {
584             log.warning(LintCategory.OPTIONS, Warnings.OptionObsoleteSource(source.name));
585             obsoleteOptionFound = true;
586         }
587 
588         if (target.compareTo(Target.MIN) &lt; 0) {
589             log.error(Errors.OptionRemovedTarget(target, Target.MIN));
590         } else if (target == Target.MIN &amp;&amp; lintOptions) {
591             log.warning(LintCategory.OPTIONS, Warnings.OptionObsoleteTarget(target));
592             obsoleteOptionFound = true;
593         }
594 
595         final Target t = target;
596         checkOptionAllowed(t.compareTo(Target.JDK1_8) &lt;= 0,
597                 option -&gt; reportDiag(Errors.OptionNotAllowedWithTarget(option, t)),
598                 Option.BOOT_CLASS_PATH,
599                 Option.XBOOTCLASSPATH_PREPEND, Option.XBOOTCLASSPATH, Option.XBOOTCLASSPATH_APPEND,
600                 Option.ENDORSEDDIRS, Option.DJAVA_ENDORSED_DIRS,
601                 Option.EXTDIRS, Option.DJAVA_EXT_DIRS,
602                 Option.PROFILE);
603 
604         checkOptionAllowed(t.compareTo(Target.JDK1_9) &gt;= 0,
605                 option -&gt; reportDiag(Errors.OptionNotAllowedWithTarget(option, t)),
606                 Option.MODULE_SOURCE_PATH, Option.UPGRADE_MODULE_PATH,
607                 Option.SYSTEM, Option.MODULE_PATH, Option.ADD_MODULES,
608                 Option.ADD_EXPORTS, Option.ADD_OPENS, Option.ADD_READS,
609                 Option.LIMIT_MODULES,
610                 Option.PATCH_MODULE);
611 
612         if (lintOptions &amp;&amp; options.isSet(Option.PARAMETERS) &amp;&amp; !target.hasMethodParameters()) {
613             log.warning(Warnings.OptionParametersUnsupported(target, Target.JDK1_8));
614         }
615 
616         if (fm.hasLocation(StandardLocation.MODULE_SOURCE_PATH)) {
617             if (!options.isSet(Option.PROC, &quot;only&quot;)
618                     &amp;&amp; !fm.hasLocation(StandardLocation.CLASS_OUTPUT)) {
619                 log.error(Errors.NoOutputDir);
620             }
621         }
622 
623         if (fm.hasLocation(StandardLocation.ANNOTATION_PROCESSOR_MODULE_PATH) &amp;&amp;
624             fm.hasLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH)) {
625             log.error(Errors.ProcessorpathNoProcessormodulepath);
626         }
627 
628         if (obsoleteOptionFound &amp;&amp; lintOptions) {
629             log.warning(LintCategory.OPTIONS, Warnings.OptionObsoleteSuppression);
630         }
631 
632         SourceVersion sv = Source.toSourceVersion(source);
633         validateAddExports(sv);
634         validateAddModules(sv);
635         validateAddReads(sv);
636         validateLimitModules(sv);
637         validateDefaultModuleForCreatedFiles(sv);
638 
639         if (lintOptions &amp;&amp; options.isSet(Option.ADD_OPENS)) {
640             log.warning(LintCategory.OPTIONS, Warnings.AddopensIgnored);
641         }
642 
643         return !errors &amp;&amp; (log.nerrors == 0);
644     }
645 
646     private void validateAddExports(SourceVersion sv) {
647         String addExports = options.get(Option.ADD_EXPORTS);
648         if (addExports != null) {
649             // Each entry must be of the form sourceModule/sourcePackage=target-list where
650             // target-list is a comma separated list of module or ALL-UNNAMED.
651             // Empty items in the target-list are ignored.
652             // There must be at least one item in the list; this is handled in Option.ADD_EXPORTS.
653             Pattern p = Option.ADD_EXPORTS.getPattern();
654             for (String e : addExports.split(&quot;\0&quot;)) {
655                 Matcher m = p.matcher(e);
656                 if (m.matches()) {
657                     String sourceModuleName = m.group(1);
658                     if (!SourceVersion.isName(sourceModuleName, sv)) {
659                         // syntactically invalid source name:  e.g. --add-exports m!/p1=m2
660                         log.warning(Warnings.BadNameForOption(Option.ADD_EXPORTS, sourceModuleName));
661                     }
662                     String sourcePackageName = m.group(2);
663                     if (!SourceVersion.isName(sourcePackageName, sv)) {
664                         // syntactically invalid source name:  e.g. --add-exports m1/p!=m2
665                         log.warning(Warnings.BadNameForOption(Option.ADD_EXPORTS, sourcePackageName));
666                     }
667 
668                     String targetNames = m.group(3);
669                     for (String targetName : targetNames.split(&quot;,&quot;)) {
670                         switch (targetName) {
671                             case &quot;&quot;:
672                             case &quot;ALL-UNNAMED&quot;:
673                                 break;
674 
675                             default:
676                                 if (!SourceVersion.isName(targetName, sv)) {
677                                     // syntactically invalid target name:  e.g. --add-exports m1/p1=m!
678                                     log.warning(Warnings.BadNameForOption(Option.ADD_EXPORTS, targetName));
679                                 }
680                                 break;
681                         }
682                     }
683                 }
684             }
685         }
686     }
687 
688     private void validateAddReads(SourceVersion sv) {
689         String addReads = options.get(Option.ADD_READS);
690         if (addReads != null) {
691             // Each entry must be of the form source=target-list where target-list is a
692             // comma-separated list of module or ALL-UNNAMED.
693             // Empty items in the target list are ignored.
694             // There must be at least one item in the list; this is handled in Option.ADD_READS.
695             Pattern p = Option.ADD_READS.getPattern();
696             for (String e : addReads.split(&quot;\0&quot;)) {
697                 Matcher m = p.matcher(e);
698                 if (m.matches()) {
699                     String sourceName = m.group(1);
700                     if (!SourceVersion.isName(sourceName, sv)) {
701                         // syntactically invalid source name:  e.g. --add-reads m!=m2
702                         log.warning(Warnings.BadNameForOption(Option.ADD_READS, sourceName));
703                     }
704 
705                     String targetNames = m.group(2);
706                     for (String targetName : targetNames.split(&quot;,&quot;, -1)) {
707                         switch (targetName) {
708                             case &quot;&quot;:
709                             case &quot;ALL-UNNAMED&quot;:
710                                 break;
711 
712                             default:
713                                 if (!SourceVersion.isName(targetName, sv)) {
714                                     // syntactically invalid target name:  e.g. --add-reads m1=m!
715                                     log.warning(Warnings.BadNameForOption(Option.ADD_READS, targetName));
716                                 }
717                                 break;
718                         }
719                     }
720                 }
721             }
722         }
723     }
724 
725     private void validateAddModules(SourceVersion sv) {
726         String addModules = options.get(Option.ADD_MODULES);
727         if (addModules != null) {
728             // Each entry must be of the form target-list where target-list is a
729             // comma separated list of module names, or ALL-DEFAULT, ALL-SYSTEM,
730             // or ALL-MODULE_PATH.
731             // Empty items in the target list are ignored.
732             // There must be at least one item in the list; this is handled in Option.ADD_MODULES.
733             for (String moduleName : addModules.split(&quot;,&quot;)) {
734                 switch (moduleName) {
735                     case &quot;&quot;:
736                     case &quot;ALL-SYSTEM&quot;:
737                     case &quot;ALL-MODULE-PATH&quot;:
738                         break;
739 
740                     default:
741                         if (!SourceVersion.isName(moduleName, sv)) {
742                             // syntactically invalid module name:  e.g. --add-modules m1,m!
743                             log.error(Errors.BadNameForOption(Option.ADD_MODULES, moduleName));
744                         }
745                         break;
746                 }
747             }
748         }
749     }
750 
751     private void validateLimitModules(SourceVersion sv) {
752         String limitModules = options.get(Option.LIMIT_MODULES);
753         if (limitModules != null) {
754             // Each entry must be of the form target-list where target-list is a
755             // comma separated list of module names, or ALL-DEFAULT, ALL-SYSTEM,
756             // or ALL-MODULE_PATH.
757             // Empty items in the target list are ignored.
758             // There must be at least one item in the list; this is handled in Option.LIMIT_EXPORTS.
759             for (String moduleName : limitModules.split(&quot;,&quot;)) {
760                 switch (moduleName) {
761                     case &quot;&quot;:
762                         break;
763 
764                     default:
765                         if (!SourceVersion.isName(moduleName, sv)) {
766                             // syntactically invalid module name:  e.g. --limit-modules m1,m!
767                             log.error(Errors.BadNameForOption(Option.LIMIT_MODULES, moduleName));
768                         }
769                         break;
770                 }
771             }
772         }
773     }
774 
775     private void validateDefaultModuleForCreatedFiles(SourceVersion sv) {
776         String moduleName = options.get(Option.DEFAULT_MODULE_FOR_CREATED_FILES);
777         if (moduleName != null) {
778             if (!SourceVersion.isName(moduleName, sv)) {
779                 // syntactically invalid module name:  e.g. --default-module-for-created-files m!
780                 log.error(Errors.BadNameForOption(Option.DEFAULT_MODULE_FOR_CREATED_FILES,
781                                                   moduleName));
782             }
783         }
784     }
785 
786     /**
787      * Returns true if there are no files or classes specified for use.
788      * @return true if there are no files or classes specified for use
789      */
790     public boolean isEmpty() {
791         return ((files == null) || files.isEmpty())
792                 &amp;&amp; ((fileObjects == null) || fileObjects.isEmpty())
793                 &amp;&amp; (classNames == null || classNames.isEmpty());
794     }
795 
796     public void allowEmpty() {
797         this.emptyAllowed = true;
798     }
799 
800     /**
801      * Gets the file manager options which may have been deferred
802      * during processArgs.
803      * @return the deferred file manager options
804      */
805     public Map&lt;Option, String&gt; getDeferredFileManagerOptions() {
806         return deferredFileManagerOptions;
807     }
808 
809     /**
810      * Gets any options specifying plugins to be run.
811      * @return options for plugins
812      */
813     public Set&lt;List&lt;String&gt;&gt; getPluginOpts() {
814         String plugins = options.get(Option.PLUGIN);
815         if (plugins == null)
816             return Collections.emptySet();
817 
818         Set&lt;List&lt;String&gt;&gt; pluginOpts = new LinkedHashSet&lt;&gt;();
819         for (String plugin: plugins.split(&quot;\\x00&quot;)) {
820             pluginOpts.add(List.from(plugin.split(&quot;\\s+&quot;)));
821         }
822         return Collections.unmodifiableSet(pluginOpts);
823     }
824 
825     /**
826      * Gets any options specifying how doclint should be run.
827      * An empty list is returned if no doclint options are specified
828      * or if the only doclint option is -Xdoclint:none.
829      * @return options for doclint
830      */
831     public List&lt;String&gt; getDocLintOpts() {
832         String xdoclint = options.get(Option.XDOCLINT);
833         String xdoclintCustom = options.get(Option.XDOCLINT_CUSTOM);
834         if (xdoclint == null &amp;&amp; xdoclintCustom == null)
835             return List.nil();
836 
837         Set&lt;String&gt; doclintOpts = new LinkedHashSet&lt;&gt;();
838         if (xdoclint != null)
839             doclintOpts.add(DocLint.XMSGS_OPTION);
840         if (xdoclintCustom != null) {
841             for (String s: xdoclintCustom.split(&quot;\\s+&quot;)) {
842                 if (s.isEmpty())
843                     continue;
844                 doclintOpts.add(DocLint.XMSGS_CUSTOM_PREFIX + s);
845             }
846         }
847 
848         if (doclintOpts.equals(Collections.singleton(DocLint.XMSGS_CUSTOM_PREFIX + &quot;none&quot;)))
849             return List.nil();
850 
851         String checkPackages = options.get(Option.XDOCLINT_PACKAGE);
852         if (checkPackages != null) {
853             doclintOpts.add(DocLint.XCHECK_PACKAGE + checkPackages);
854         }
855 
856         String format = options.get(Option.DOCLINT_FORMAT);
857         if (format != null) {
858             doclintOpts.add(DocLint.XHTML_VERSION_PREFIX + format);
859         }
860 
861         return List.from(doclintOpts.toArray(new String[doclintOpts.size()]));
862     }
863 
864     private boolean checkDirectory(Option option) {
865         String value = options.get(option);
866         if (value == null) {
867             return true;
868         }
869         Path file = Paths.get(value);
870         if (Files.exists(file) &amp;&amp; !Files.isDirectory(file)) {
871             reportDiag(Errors.FileNotDirectory(value));
872             return false;
873         }
874         return true;
875     }
876 
877     private interface ErrorReporter {
878         void report(Option o);
879     }
880 
881     void checkOptionAllowed(boolean allowed, ErrorReporter r, Option... opts) {
882         if (!allowed) {
883             Stream.of(opts)
884                   .filter(options :: isSet)
885                   .forEach(r :: report);
886         }
887     }
888 
889     void reportDiag(DiagnosticInfo diag) {
890         errors = true;
891         switch (errorMode) {
892             case ILLEGAL_ARGUMENT: {
893                 String msg = log.localize(diag);
894                 throw new PropagatedException(new IllegalArgumentException(msg));
895             }
896             case ILLEGAL_STATE: {
897                 String msg = log.localize(diag);
898                 throw new PropagatedException(new IllegalStateException(msg));
899             }
900             case LOG:
901                 report(diag);
902         }
903     }
904 
905     void error(Option.InvalidValueException f) {
906         String msg = f.getMessage();
907         errors = true;
908         switch (errorMode) {
909             case ILLEGAL_ARGUMENT: {
910                 throw new PropagatedException(new IllegalArgumentException(msg, f.getCause()));
911             }
912             case ILLEGAL_STATE: {
913                 throw new PropagatedException(new IllegalStateException(msg, f.getCause()));
914             }
915             case LOG:
916                 log.printRawLines(msg);
917         }
918     }
919 
920     private void report(DiagnosticInfo diag) {
921         // Would be good to have support for -XDrawDiagnostics here
922         if (diag instanceof JCDiagnostic.Error) {
923             log.error((JCDiagnostic.Error)diag);
924         } else if (diag instanceof JCDiagnostic.Warning){
925             log.warning((JCDiagnostic.Warning)diag);
926         }
927     }
928 
929     private JavaFileManager getFileManager() {
930         if (fileManager == null)
931             fileManager = context.get(JavaFileManager.class);
932         return fileManager;
933     }
934 
935     &lt;T&gt; ListBuffer&lt;T&gt; toList(Iterable&lt;? extends T&gt; items) {
936         ListBuffer&lt;T&gt; list = new ListBuffer&lt;&gt;();
937         if (items != null) {
938             for (T item : items) {
939                 list.add(item);
940             }
941         }
942         return list;
943     }
944 
945     &lt;T&gt; Set&lt;T&gt; toSet(Iterable&lt;? extends T&gt; items) {
946         Set&lt;T&gt; set = new LinkedHashSet&lt;&gt;();
947         if (items != null) {
948             for (T item : items) {
949                 set.add(item);
950             }
951         }
952         return set;
953     }
954 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.logging/share/classes/java/util/logging/Logger.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../java.instrument/share/classes/java/lang/instrument/Instrumentation.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.logging/share/classes/java/util/logging/Logger.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 430 
 431     }
 432 
 433     // The logger configuration data. Ideally, this should be final
 434     // for system loggers, and replace-once for application loggers.
 435     // When an application requests a logger by name, we do not know a-priori
 436     // whether that corresponds to a system logger name or not.
 437     // So if no system logger by that name already exists, we simply return an
 438     // application logger.
 439     // If a system class later requests a system logger of the same name, then
 440     // the application logger and system logger configurations will be merged
 441     // in a single instance of ConfigurationData that both loggers will share.
 442     private volatile ConfigurationData config;
 443 
 444     private volatile LogManager manager;
 445     private String name;
 446     private volatile LoggerBundle loggerBundle = NO_RESOURCE_BUNDLE;
 447     private boolean anonymous;
 448 
 449     // Cache to speed up behavior of findResourceBundle:
<span class="line-modified"> 450     private ResourceBundle catalog;     // Cached resource bundle</span>
 451     private String catalogName;         // name associated with catalog
 452     private Locale catalogLocale;       // locale associated with catalog
 453 
 454     // The fields relating to parent-child relationships and levels
 455     // are managed under a separate lock, the treeLock.
 456     private static final Object treeLock = new Object();
 457     // We keep weak references from parents to children, but strong
 458     // references from children to parents.
 459     private volatile Logger parent;    // our nearest parent.
 460     private ArrayList&lt;LogManager.LoggerWeakRef&gt; kids;   // WeakReferences to loggers that have us as parent
 461     private WeakReference&lt;Module&gt; callerModuleRef;
 462     private final boolean isSystemLogger;
 463 
 464     /**
 465      * GLOBAL_LOGGER_NAME is a name for the global logger.
 466      *
 467      * @since 1.6
 468      */
 469     public static final String GLOBAL_LOGGER_NAME = &quot;global&quot;;
 470 
</pre>
<hr />
<pre>
2105      *          logger&#39;s parent.
2106      * @throws  SecurityException if a security manager exists,
2107      *          this logger is not anonymous, and the caller
2108      *          does not have LoggingPermission(&quot;control&quot;).
2109      */
2110     public void setUseParentHandlers(boolean useParentHandlers) {
2111         checkPermission();
2112         config.setUseParentHandlers(useParentHandlers);
2113     }
2114 
2115     /**
2116      * Discover whether or not this logger is sending its output
2117      * to its parent logger.
2118      *
2119      * @return  true if output is to be sent to the logger&#39;s parent
2120      */
2121     public boolean getUseParentHandlers() {
2122         return config.useParentHandlers;
2123     }
2124 





2125     /**
2126      * Private utility method to map a resource bundle name to an
2127      * actual resource bundle, using a simple one-entry cache.
2128      * Returns null for a null name.
2129      * May also return null if we can&#39;t find the resource bundle and
2130      * there is no suitable previous cached value.
2131      *
2132      * @param name the ResourceBundle to locate
2133      * @param useCallersModule if true search using the caller&#39;s module.
2134      * @return ResourceBundle specified by name or null if not found
2135      */
2136     private synchronized ResourceBundle findResourceBundle(String name,
2137                                                            boolean useCallersModule) {
2138         // When this method is called from logrb, useCallersModule==false, and
2139         // the resource bundle &#39;name&#39; is the argument provided to logrb.
2140         // It may, or may not be, equal to lb.resourceBundleName.
2141         // Otherwise, useCallersModule==true, and name is the resource bundle
2142         // name that is set (or will be set) in this logger.
2143         //
2144         // When useCallersModule is false, or when the caller&#39;s module is
2145         // null, or when the caller&#39;s module is an unnamed module, we look
2146         // first in the TCCL (or the System ClassLoader if the TCCL is null)
2147         // to locate the resource bundle.
2148         //
2149         // Otherwise, if useCallersModule is true, and the caller&#39;s module is not
2150         // null, and the caller&#39;s module is named, we look in the caller&#39;s module
2151         // to locate the resource bundle.
2152         //
2153         // Finally, if the caller&#39;s module is not null and is unnamed, and
2154         // useCallersModule is true, we look in the caller&#39;s module class loader
2155         // (unless we already looked there in step 1).
2156 
2157         // Return a null bundle for a null name.
2158         if (name == null) {
2159             return null;
2160         }
2161 
2162         Locale currentLocale = Locale.getDefault();
2163         final LoggerBundle lb = loggerBundle;

2164 
2165         // Normally we should hit on our simple one entry cache.
2166         if (lb.userBundle != null &amp;&amp;
2167                 name.equals(lb.resourceBundleName)) {
2168             return lb.userBundle;
2169         } else if (catalog != null &amp;&amp; currentLocale.equals(catalogLocale)
<span class="line-modified">2170                 &amp;&amp; name.equals(catalogName)) {</span>
2171             return catalog;
2172         }
2173 
2174         // Use the thread&#39;s context ClassLoader.  If there isn&#39;t one, use the
2175         // {@linkplain java.lang.ClassLoader#getSystemClassLoader() system ClassLoader}.
2176         ClassLoader cl = Thread.currentThread().getContextClassLoader();
2177         if (cl == null) {
2178             cl = ClassLoader.getSystemClassLoader();
2179         }
2180 
2181         final Module callerModule = getCallerModule();
2182 
2183         // If useCallersModule is false, we are called by logrb, with a name
2184         // that is provided by the user. In that case we will look in the TCCL.
2185         // We also look in the TCCL if callerModule is null or unnamed.
2186         if (!useCallersModule || callerModule == null || !callerModule.isNamed()) {
2187             try {
2188                 Module mod = cl.getUnnamedModule();
2189                 catalog = RbAccess.RB_ACCESS.getBundle(name, currentLocale, mod);

2190                 catalogName = name;
2191                 catalogLocale = currentLocale;
2192                 return catalog;
2193             } catch (MissingResourceException ex) {
2194                 // We can&#39;t find the ResourceBundle in the default
2195                 // ClassLoader.  Drop through.
2196                 if (useCallersModule &amp;&amp; callerModule != null) {
2197                     try {
2198                         // We are called by an unnamed module: try with the
2199                         // unnamed module class loader:
2200                         PrivilegedAction&lt;ClassLoader&gt; getModuleClassLoader =
2201                                 () -&gt; callerModule.getClassLoader();
2202                         ClassLoader moduleCL =
2203                                 AccessController.doPrivileged(getModuleClassLoader);
2204                         // moduleCL can be null if the logger is created by a class
2205                         // appended to the bootclasspath.
2206                         // If moduleCL is null we would use cl, but we already tried
2207                         // that above (we first looked in the TCCL for unnamed
2208                         // caller modules) - so there no point in trying again: we
2209                         // won&#39;t find anything more this second time.
2210                         // In this case just return null.
2211                         if (moduleCL == cl || moduleCL == null) return null;
2212 
2213                         // we already tried the TCCL and found nothing - so try
2214                         // with the module&#39;s loader this time.
2215                         catalog = ResourceBundle.getBundle(name, currentLocale,
2216                                                            moduleCL);

2217                         catalogName = name;
2218                         catalogLocale = currentLocale;
2219                         return catalog;
2220                     } catch (MissingResourceException x) {
2221                         return null; // no luck
2222                     }
2223                 } else {
2224                     return null;
2225                 }
2226             }
2227         } else {
2228             // we should have:
2229             //  useCallersModule &amp;&amp; callerModule != null &amp;&amp; callerModule.isNamed();
2230             // Try with the caller&#39;s module
2231             try {
2232                 // Use the caller&#39;s module
2233                 catalog = RbAccess.RB_ACCESS.getBundle(name, currentLocale, callerModule);

2234                 catalogName = name;
2235                 catalogLocale = currentLocale;
2236                 return catalog;
2237             } catch (MissingResourceException ex) {
2238                 return null; // no luck
2239             }
2240         }
2241     }
2242 
2243     private void setupResourceInfo(String name, Class&lt;?&gt; caller) {
2244         final Module module = caller == null ? null : caller.getModule();
2245         setupResourceInfo(name, module);
2246     }
2247 
2248     // Private utility method to initialize our one entry
2249     // resource bundle name cache and the callers Module
2250     // Note: for consistency reasons, we are careful to check
2251     // that a suitable ResourceBundle exists before setting the
2252     // resourceBundleName field.
2253     // Synchronized to prevent races in setting the fields.
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 430 
 431     }
 432 
 433     // The logger configuration data. Ideally, this should be final
 434     // for system loggers, and replace-once for application loggers.
 435     // When an application requests a logger by name, we do not know a-priori
 436     // whether that corresponds to a system logger name or not.
 437     // So if no system logger by that name already exists, we simply return an
 438     // application logger.
 439     // If a system class later requests a system logger of the same name, then
 440     // the application logger and system logger configurations will be merged
 441     // in a single instance of ConfigurationData that both loggers will share.
 442     private volatile ConfigurationData config;
 443 
 444     private volatile LogManager manager;
 445     private String name;
 446     private volatile LoggerBundle loggerBundle = NO_RESOURCE_BUNDLE;
 447     private boolean anonymous;
 448 
 449     // Cache to speed up behavior of findResourceBundle:
<span class="line-modified"> 450     private WeakReference&lt;ResourceBundle&gt; catalogRef;  // Cached resource bundle</span>
 451     private String catalogName;         // name associated with catalog
 452     private Locale catalogLocale;       // locale associated with catalog
 453 
 454     // The fields relating to parent-child relationships and levels
 455     // are managed under a separate lock, the treeLock.
 456     private static final Object treeLock = new Object();
 457     // We keep weak references from parents to children, but strong
 458     // references from children to parents.
 459     private volatile Logger parent;    // our nearest parent.
 460     private ArrayList&lt;LogManager.LoggerWeakRef&gt; kids;   // WeakReferences to loggers that have us as parent
 461     private WeakReference&lt;Module&gt; callerModuleRef;
 462     private final boolean isSystemLogger;
 463 
 464     /**
 465      * GLOBAL_LOGGER_NAME is a name for the global logger.
 466      *
 467      * @since 1.6
 468      */
 469     public static final String GLOBAL_LOGGER_NAME = &quot;global&quot;;
 470 
</pre>
<hr />
<pre>
2105      *          logger&#39;s parent.
2106      * @throws  SecurityException if a security manager exists,
2107      *          this logger is not anonymous, and the caller
2108      *          does not have LoggingPermission(&quot;control&quot;).
2109      */
2110     public void setUseParentHandlers(boolean useParentHandlers) {
2111         checkPermission();
2112         config.setUseParentHandlers(useParentHandlers);
2113     }
2114 
2115     /**
2116      * Discover whether or not this logger is sending its output
2117      * to its parent logger.
2118      *
2119      * @return  true if output is to be sent to the logger&#39;s parent
2120      */
2121     public boolean getUseParentHandlers() {
2122         return config.useParentHandlers;
2123     }
2124 
<span class="line-added">2125     private ResourceBundle catalog() {</span>
<span class="line-added">2126         WeakReference&lt;ResourceBundle&gt; ref = catalogRef;</span>
<span class="line-added">2127         return ref == null ? null : ref.get();</span>
<span class="line-added">2128     }</span>
<span class="line-added">2129 </span>
2130     /**
2131      * Private utility method to map a resource bundle name to an
2132      * actual resource bundle, using a simple one-entry cache.
2133      * Returns null for a null name.
2134      * May also return null if we can&#39;t find the resource bundle and
2135      * there is no suitable previous cached value.
2136      *
2137      * @param name the ResourceBundle to locate
2138      * @param useCallersModule if true search using the caller&#39;s module.
2139      * @return ResourceBundle specified by name or null if not found
2140      */
2141     private synchronized ResourceBundle findResourceBundle(String name,
2142                                                            boolean useCallersModule) {
2143         // When this method is called from logrb, useCallersModule==false, and
2144         // the resource bundle &#39;name&#39; is the argument provided to logrb.
2145         // It may, or may not be, equal to lb.resourceBundleName.
2146         // Otherwise, useCallersModule==true, and name is the resource bundle
2147         // name that is set (or will be set) in this logger.
2148         //
2149         // When useCallersModule is false, or when the caller&#39;s module is
2150         // null, or when the caller&#39;s module is an unnamed module, we look
2151         // first in the TCCL (or the System ClassLoader if the TCCL is null)
2152         // to locate the resource bundle.
2153         //
2154         // Otherwise, if useCallersModule is true, and the caller&#39;s module is not
2155         // null, and the caller&#39;s module is named, we look in the caller&#39;s module
2156         // to locate the resource bundle.
2157         //
2158         // Finally, if the caller&#39;s module is not null and is unnamed, and
2159         // useCallersModule is true, we look in the caller&#39;s module class loader
2160         // (unless we already looked there in step 1).
2161 
2162         // Return a null bundle for a null name.
2163         if (name == null) {
2164             return null;
2165         }
2166 
2167         Locale currentLocale = Locale.getDefault();
2168         final LoggerBundle lb = loggerBundle;
<span class="line-added">2169         ResourceBundle catalog = catalog();</span>
2170 
2171         // Normally we should hit on our simple one entry cache.
2172         if (lb.userBundle != null &amp;&amp;
2173                 name.equals(lb.resourceBundleName)) {
2174             return lb.userBundle;
2175         } else if (catalog != null &amp;&amp; currentLocale.equals(catalogLocale)
<span class="line-modified">2176                     &amp;&amp; name.equals(catalogName)) {</span>
2177             return catalog;
2178         }
2179 
2180         // Use the thread&#39;s context ClassLoader.  If there isn&#39;t one, use the
2181         // {@linkplain java.lang.ClassLoader#getSystemClassLoader() system ClassLoader}.
2182         ClassLoader cl = Thread.currentThread().getContextClassLoader();
2183         if (cl == null) {
2184             cl = ClassLoader.getSystemClassLoader();
2185         }
2186 
2187         final Module callerModule = getCallerModule();
2188 
2189         // If useCallersModule is false, we are called by logrb, with a name
2190         // that is provided by the user. In that case we will look in the TCCL.
2191         // We also look in the TCCL if callerModule is null or unnamed.
2192         if (!useCallersModule || callerModule == null || !callerModule.isNamed()) {
2193             try {
2194                 Module mod = cl.getUnnamedModule();
2195                 catalog = RbAccess.RB_ACCESS.getBundle(name, currentLocale, mod);
<span class="line-added">2196                 catalogRef = new WeakReference&lt;&gt;(catalog);</span>
2197                 catalogName = name;
2198                 catalogLocale = currentLocale;
2199                 return catalog;
2200             } catch (MissingResourceException ex) {
2201                 // We can&#39;t find the ResourceBundle in the default
2202                 // ClassLoader.  Drop through.
2203                 if (useCallersModule &amp;&amp; callerModule != null) {
2204                     try {
2205                         // We are called by an unnamed module: try with the
2206                         // unnamed module class loader:
2207                         PrivilegedAction&lt;ClassLoader&gt; getModuleClassLoader =
2208                                 () -&gt; callerModule.getClassLoader();
2209                         ClassLoader moduleCL =
2210                                 AccessController.doPrivileged(getModuleClassLoader);
2211                         // moduleCL can be null if the logger is created by a class
2212                         // appended to the bootclasspath.
2213                         // If moduleCL is null we would use cl, but we already tried
2214                         // that above (we first looked in the TCCL for unnamed
2215                         // caller modules) - so there no point in trying again: we
2216                         // won&#39;t find anything more this second time.
2217                         // In this case just return null.
2218                         if (moduleCL == cl || moduleCL == null) return null;
2219 
2220                         // we already tried the TCCL and found nothing - so try
2221                         // with the module&#39;s loader this time.
2222                         catalog = ResourceBundle.getBundle(name, currentLocale,
2223                                                            moduleCL);
<span class="line-added">2224                         catalogRef = new WeakReference&lt;&gt;(catalog);</span>
2225                         catalogName = name;
2226                         catalogLocale = currentLocale;
2227                         return catalog;
2228                     } catch (MissingResourceException x) {
2229                         return null; // no luck
2230                     }
2231                 } else {
2232                     return null;
2233                 }
2234             }
2235         } else {
2236             // we should have:
2237             //  useCallersModule &amp;&amp; callerModule != null &amp;&amp; callerModule.isNamed();
2238             // Try with the caller&#39;s module
2239             try {
2240                 // Use the caller&#39;s module
2241                 catalog = RbAccess.RB_ACCESS.getBundle(name, currentLocale, callerModule);
<span class="line-added">2242                 catalogRef = new WeakReference&lt;&gt;(catalog);</span>
2243                 catalogName = name;
2244                 catalogLocale = currentLocale;
2245                 return catalog;
2246             } catch (MissingResourceException ex) {
2247                 return null; // no luck
2248             }
2249         }
2250     }
2251 
2252     private void setupResourceInfo(String name, Class&lt;?&gt; caller) {
2253         final Module module = caller == null ? null : caller.getModule();
2254         setupResourceInfo(name, module);
2255     }
2256 
2257     // Private utility method to initialize our one entry
2258     // resource bundle name cache and the callers Module
2259     // Note: for consistency reasons, we are careful to check
2260     // that a suitable ResourceBundle exists before setting the
2261     // resourceBundleName field.
2262     // Synchronized to prevent races in setting the fields.
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../java.instrument/share/classes/java/lang/instrument/Instrumentation.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/native/libjli/java.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * Shared source for &#39;java&#39; command line tool.
  28  *
  29  * If JAVA_ARGS is defined, then acts as a launcher for applications. For
  30  * instance, the JDK command line tools such as javac and javadoc (see
  31  * makefiles for more details) are built with this program.  Any arguments
  32  * prefixed with &#39;-J&#39; will be passed directly to the &#39;java&#39; command.
  33  */
  34 
  35 /*
  36  * One job of the launcher is to remove command line options which the
  37  * vm does not understand and will not process.  These options include
  38  * options which select which style of vm is run (e.g. -client and
  39  * -server) as well as options which select the data model to use.
  40  * Additionally, for tools which invoke an underlying vm &quot;-J-foo&quot;
  41  * options are turned into &quot;-foo&quot; options to the vm.  This option
  42  * filtering is handled in a number of places in the launcher, some of
  43  * it in machine-dependent code.  In this file, the function
  44  * CheckJvmType removes vm style options and TranslateApplicationArgs
  45  * removes &quot;-J&quot; prefixes.  The CreateExecutionEnvironment function processes
  46  * and removes -d&lt;n&gt; options. On unix, there is a possibility that the running
  47  * data model may not match to the desired data model, in this case an exec is
  48  * required to start the desired model. If the data models match, then
  49  * ParseArguments will remove the -d&lt;n&gt; flags. If the data models do not match
  50  * the CreateExecutionEnviroment will remove the -d&lt;n&gt; flags.
  51  */
  52 
  53 
  54 #include &quot;java.h&quot;
  55 #include &quot;jni.h&quot;
  56 
  57 /*
  58  * A NOTE TO DEVELOPERS: For performance reasons it is important that
  59  * the program image remain relatively small until after SelectVersion
  60  * CreateExecutionEnvironment have finished their possibly recursive
  61  * processing. Watch everything, but resist all temptations to use Java
  62  * interfaces.
  63  */
  64 
  65 #define USE_STDERR JNI_TRUE     /* we usually print to stderr */
  66 #define USE_STDOUT JNI_FALSE
  67 
  68 static jboolean printVersion = JNI_FALSE; /* print and exit */
  69 static jboolean showVersion = JNI_FALSE;  /* print but continue */
  70 static jboolean printUsage = JNI_FALSE;   /* print and exit*/
  71 static jboolean printTo = USE_STDERR;     /* where to print version/usage */
  72 static jboolean printXUsage = JNI_FALSE;  /* print and exit*/
  73 static jboolean dryRun = JNI_FALSE;       /* initialize VM and exit */
  74 static char     *showSettings = NULL;     /* print but continue */
  75 static jboolean showResolvedModules = JNI_FALSE;
  76 static jboolean listModules = JNI_FALSE;
  77 static char     *describeModule = NULL;
  78 static jboolean validateModules = JNI_FALSE;
  79 
  80 static const char *_program_name;
  81 static const char *_launcher_name;
  82 static jboolean _is_java_args = JNI_FALSE;
  83 static jboolean _have_classpath = JNI_FALSE;
  84 static const char *_fVersion;
  85 static jboolean _wc_enabled = JNI_FALSE;
  86 
  87 /*
  88  * Entries for splash screen environment variables.
  89  * putenv is performed in SelectVersion. We need
  90  * them in memory until UnsetEnv, so they are made static
  91  * global instead of auto local.
  92  */
  93 static char* splash_file_entry = NULL;
  94 static char* splash_jar_entry = NULL;
  95 
  96 /*
  97  * List of VM options to be specified when the VM is created.
  98  */
  99 static JavaVMOption *options;
 100 static int numOptions, maxOptions;
 101 
 102 /*
 103  * Prototypes for functions internal to launcher.
 104  */
 105 static const char* GetFullVersion();
 106 static jboolean IsJavaArgs();
 107 static void SetJavaLauncherProp();
 108 static void SetClassPath(const char *s);
 109 static void SetMainModule(const char *s);
 110 static void SelectVersion(int argc, char **argv, char **main_class);
 111 static void SetJvmEnvironment(int argc, char **argv);
 112 static jboolean ParseArguments(int *pargc, char ***pargv,
 113                                int *pmode, char **pwhat,
 114                                int *pret, const char *jrepath);
 115 static jboolean InitializeJVM(JavaVM **pvm, JNIEnv **penv,
 116                               InvocationFunctions *ifn);
 117 static jstring NewPlatformString(JNIEnv *env, char *s);
 118 static jclass LoadMainClass(JNIEnv *env, int mode, char *name);
 119 static jclass GetApplicationClass(JNIEnv *env);
 120 
 121 static void TranslateApplicationArgs(int jargc, const char **jargv, int *pargc, char ***pargv);
 122 static jboolean AddApplicationOptions(int cpathc, const char **cpathv);
 123 static void SetApplicationClassPath(const char**);
 124 
 125 static void PrintJavaVersion(JNIEnv *env, jboolean extraLF);
 126 static void PrintUsage(JNIEnv* env, jboolean doXUsage);
 127 static void ShowSettings(JNIEnv* env, char *optString);
 128 static void ShowResolvedModules(JNIEnv* env);
 129 static void ListModules(JNIEnv* env);
 130 static void DescribeModule(JNIEnv* env, char* optString);
 131 static jboolean ValidateModules(JNIEnv* env);
 132 
 133 static void SetPaths(int argc, char **argv);
 134 
 135 static void DumpState();
 136 
 137 enum OptionKind {
 138     LAUNCHER_OPTION = 0,
 139     LAUNCHER_OPTION_WITH_ARGUMENT,
 140     LAUNCHER_MAIN_OPTION,
 141     VM_LONG_OPTION,
 142     VM_LONG_OPTION_WITH_ARGUMENT,
 143     VM_OPTION
 144 };
 145 
 146 static int GetOpt(int *pargc, char ***pargv, char **poption, char **pvalue);
 147 static jboolean IsOptionWithArgument(int argc, char **argv);
 148 
 149 /* Maximum supported entries from jvm.cfg. */
 150 #define INIT_MAX_KNOWN_VMS      10
 151 
 152 /* Values for vmdesc.flag */
 153 enum vmdesc_flag {
 154     VM_UNKNOWN = -1,
 155     VM_KNOWN,
 156     VM_ALIASED_TO,
 157     VM_WARN,
 158     VM_ERROR,
 159     VM_IF_SERVER_CLASS,
 160     VM_IGNORE
 161 };
 162 
 163 struct vmdesc {
 164     char *name;
 165     int flag;
 166     char *alias;
 167     char *server_class;
 168 };
 169 static struct vmdesc *knownVMs = NULL;
 170 static int knownVMsCount = 0;
 171 static int knownVMsLimit = 0;
 172 
 173 static void GrowKnownVMs(int minimum);
 174 static int  KnownVMIndex(const char* name);
 175 static void FreeKnownVMs();
 176 static jboolean IsWildCardEnabled();
 177 
 178 
 179 #define SOURCE_LAUNCHER_MAIN_ENTRY &quot;jdk.compiler/com.sun.tools.javac.launcher.Main&quot;
 180 
 181 /*
 182  * This reports error.  VM will not be created and no usage is printed.
 183  */
 184 #define REPORT_ERROR(AC_ok, AC_failure_message, AC_questionable_arg) \
 185     do { \
 186         if (!AC_ok) { \
 187             JLI_ReportErrorMessage(AC_failure_message, AC_questionable_arg); \
 188             printUsage = JNI_FALSE; \
 189             *pret = 1; \
 190             return JNI_FALSE; \
 191         } \
 192     } while (JNI_FALSE)
 193 
 194 #define ARG_CHECK(AC_arg_count, AC_failure_message, AC_questionable_arg) \
 195     do { \
 196         if (AC_arg_count &lt; 1) { \
 197             JLI_ReportErrorMessage(AC_failure_message, AC_questionable_arg); \
 198             printUsage = JNI_TRUE; \
 199             *pret = 1; \
 200             return JNI_TRUE; \
 201         } \
 202     } while (JNI_FALSE)
 203 
 204 /*
 205  * Running Java code in primordial thread caused many problems. We will
 206  * create a new thread to invoke JVM. See 6316197 for more information.
 207  */
 208 static jlong threadStackSize    = 0;  /* stack size of the new thread */
 209 static jlong maxHeapSize        = 0;  /* max heap size */
 210 static jlong initialHeapSize    = 0;  /* initial heap size */
 211 
 212 /*
 213  * A minimum initial-thread stack size suitable for most platforms.
 214  * This is the minimum amount of stack needed to load the JVM such
 215  * that it can reject a too small -Xss value. If this is too small
 216  * JVM initialization would cause a StackOverflowError.
 217   */
 218 #ifndef STACK_SIZE_MINIMUM
 219 #define STACK_SIZE_MINIMUM (64 * KB)
 220 #endif
 221 
 222 /*
 223  * Entry point.
 224  */
 225 JNIEXPORT int JNICALL
 226 JLI_Launch(int argc, char ** argv,              /* main argc, argv */
 227         int jargc, const char** jargv,          /* java args */
 228         int appclassc, const char** appclassv,  /* app classpath */
 229         const char* fullversion,                /* full version defined */
 230         const char* dotversion,                 /* UNUSED dot version defined */
 231         const char* pname,                      /* program name */
 232         const char* lname,                      /* launcher name */
 233         jboolean javaargs,                      /* JAVA_ARGS */
 234         jboolean cpwildcard,                    /* classpath wildcard*/
 235         jboolean javaw,                         /* windows-only javaw */
 236         jint ergo                               /* unused */
 237 )
 238 {
 239     int mode = LM_UNKNOWN;
 240     char *what = NULL;
 241     char *main_class = NULL;
 242     int ret;
 243     InvocationFunctions ifn;
 244     jlong start = 0, end = 0;
 245     char jvmpath[MAXPATHLEN];
 246     char jrepath[MAXPATHLEN];
 247     char jvmcfg[MAXPATHLEN];
 248 
 249     _fVersion = fullversion;
 250     _launcher_name = lname;
 251     _program_name = pname;
 252     _is_java_args = javaargs;
 253     _wc_enabled = cpwildcard;
 254 
 255     InitLauncher(javaw);
 256     DumpState();
 257     if (JLI_IsTraceLauncher()) {
 258         int i;
 259         printf(&quot;Java args:\n&quot;);
 260         for (i = 0; i &lt; jargc ; i++) {
 261             printf(&quot;jargv[%d] = %s\n&quot;, i, jargv[i]);
 262         }
 263         printf(&quot;Command line args:\n&quot;);
 264         for (i = 0; i &lt; argc ; i++) {
 265             printf(&quot;argv[%d] = %s\n&quot;, i, argv[i]);
 266         }
 267         AddOption(&quot;-Dsun.java.launcher.diag=true&quot;, NULL);
 268     }
 269 
 270     /*
 271      * SelectVersion() has several responsibilities:
 272      *
 273      *  1) Disallow specification of another JRE.  With 1.9, another
 274      *     version of the JRE cannot be invoked.
 275      *  2) Allow for a JRE version to invoke JDK 1.9 or later.  Since
 276      *     all mJRE directives have been stripped from the request but
 277      *     the pre 1.9 JRE [ 1.6 thru 1.8 ], it is as if 1.9+ has been
 278      *     invoked from the command line.
 279      */
 280     SelectVersion(argc, argv, &amp;main_class);
 281 
 282     CreateExecutionEnvironment(&amp;argc, &amp;argv,
 283                                jrepath, sizeof(jrepath),
 284                                jvmpath, sizeof(jvmpath),
 285                                jvmcfg,  sizeof(jvmcfg));
 286 
 287     if (!IsJavaArgs()) {
 288         SetJvmEnvironment(argc,argv);
 289     }
 290 
 291     ifn.CreateJavaVM = 0;
 292     ifn.GetDefaultJavaVMInitArgs = 0;
 293 
 294     if (JLI_IsTraceLauncher()) {
<a name="1" id="anc1"></a><span class="line-modified"> 295         start = CurrentTimeMicros();</span>
 296     }
 297 
 298     if (!LoadJavaVM(jvmpath, &amp;ifn)) {
 299         return(6);
 300     }
 301 
 302     if (JLI_IsTraceLauncher()) {
<a name="2" id="anc2"></a><span class="line-modified"> 303         end   = CurrentTimeMicros();</span>
 304     }
 305 
<a name="3" id="anc3"></a><span class="line-modified"> 306     JLI_TraceLauncher(&quot;%ld micro seconds to LoadJavaVM\n&quot;, (long)(end-start));</span>

 307 
 308     ++argv;
 309     --argc;
 310 
 311     if (IsJavaArgs()) {
 312         /* Preprocess wrapper arguments */
 313         TranslateApplicationArgs(jargc, jargv, &amp;argc, &amp;argv);
 314         if (!AddApplicationOptions(appclassc, appclassv)) {
 315             return(1);
 316         }
 317     } else {
 318         /* Set default CLASSPATH */
 319         char* cpath = getenv(&quot;CLASSPATH&quot;);
 320         if (cpath != NULL) {
 321             SetClassPath(cpath);
 322         }
 323     }
 324 
 325     /* Parse command line options; if the return value of
 326      * ParseArguments is false, the program should exit.
 327      */
 328     if (!ParseArguments(&amp;argc, &amp;argv, &amp;mode, &amp;what, &amp;ret, jrepath)) {
 329         return(ret);
 330     }
 331 
 332     /* Override class path if -jar flag was specified */
 333     if (mode == LM_JAR) {
 334         SetClassPath(what);     /* Override class path */
 335     }
 336 
 337     /* set the -Dsun.java.command pseudo property */
 338     SetJavaCommandLineProp(what, argc, argv);
 339 
 340     /* Set the -Dsun.java.launcher pseudo property */
 341     SetJavaLauncherProp();
 342 
 343     return JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);
 344 }
 345 /*
 346  * Always detach the main thread so that it appears to have ended when
 347  * the application&#39;s main method exits.  This will invoke the
 348  * uncaught exception handler machinery if main threw an
 349  * exception.  An uncaught exception handler cannot change the
 350  * launcher&#39;s return code except by calling System.exit.
 351  *
 352  * Wait for all non-daemon threads to end, then destroy the VM.
 353  * This will actually create a trivial new Java waiter thread
 354  * named &quot;DestroyJavaVM&quot;, but this will be seen as a different
 355  * thread from the one that executed main, even though they are
 356  * the same C thread.  This allows mainThread.join() and
 357  * mainThread.isAlive() to work as expected.
 358  */
 359 #define LEAVE() \
 360     do { \
 361         if ((*vm)-&gt;DetachCurrentThread(vm) != JNI_OK) { \
 362             JLI_ReportErrorMessage(JVM_ERROR2); \
 363             ret = 1; \
 364         } \
 365         if (JNI_TRUE) { \
 366             (*vm)-&gt;DestroyJavaVM(vm); \
 367             return ret; \
 368         } \
 369     } while (JNI_FALSE)
 370 
 371 #define CHECK_EXCEPTION_NULL_LEAVE(CENL_exception) \
 372     do { \
 373         if ((*env)-&gt;ExceptionOccurred(env)) { \
 374             JLI_ReportExceptionDescription(env); \
 375             LEAVE(); \
 376         } \
 377         if ((CENL_exception) == NULL) { \
 378             JLI_ReportErrorMessage(JNI_ERROR); \
 379             LEAVE(); \
 380         } \
 381     } while (JNI_FALSE)
 382 
 383 #define CHECK_EXCEPTION_LEAVE(CEL_return_value) \
 384     do { \
 385         if ((*env)-&gt;ExceptionOccurred(env)) { \
 386             JLI_ReportExceptionDescription(env); \
 387             ret = (CEL_return_value); \
 388             LEAVE(); \
 389         } \
 390     } while (JNI_FALSE)
 391 
 392 
 393 int
 394 JavaMain(void* _args)
 395 {
 396     JavaMainArgs *args = (JavaMainArgs *)_args;
 397     int argc = args-&gt;argc;
 398     char **argv = args-&gt;argv;
 399     int mode = args-&gt;mode;
 400     char *what = args-&gt;what;
 401     InvocationFunctions ifn = args-&gt;ifn;
 402 
 403     JavaVM *vm = 0;
 404     JNIEnv *env = 0;
 405     jclass mainClass = NULL;
 406     jclass appClass = NULL; // actual application class being launched
 407     jmethodID mainID;
 408     jobjectArray mainArgs;
 409     int ret = 0;
 410     jlong start = 0, end = 0;
 411 
 412     RegisterThread();
 413 
 414     /* Initialize the virtual machine */
<a name="4" id="anc4"></a><span class="line-modified"> 415     start = CurrentTimeMicros();</span>
 416     if (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) {
 417         JLI_ReportErrorMessage(JVM_ERROR1);
 418         exit(1);
 419     }
 420 
 421     if (showSettings != NULL) {
 422         ShowSettings(env, showSettings);
 423         CHECK_EXCEPTION_LEAVE(1);
 424     }
 425 
 426     // show resolved modules and continue
 427     if (showResolvedModules) {
 428         ShowResolvedModules(env);
 429         CHECK_EXCEPTION_LEAVE(1);
 430     }
 431 
 432     // list observable modules, then exit
 433     if (listModules) {
 434         ListModules(env);
 435         CHECK_EXCEPTION_LEAVE(1);
 436         LEAVE();
 437     }
 438 
 439     // describe a module, then exit
 440     if (describeModule != NULL) {
 441         DescribeModule(env, describeModule);
 442         CHECK_EXCEPTION_LEAVE(1);
 443         LEAVE();
 444     }
 445 
 446     if (printVersion || showVersion) {
 447         PrintJavaVersion(env, showVersion);
 448         CHECK_EXCEPTION_LEAVE(0);
 449         if (printVersion) {
 450             LEAVE();
 451         }
 452     }
 453 
 454     // modules have been validated at startup so exit
 455     if (validateModules) {
 456         LEAVE();
 457     }
 458 
 459     /* If the user specified neither a class name nor a JAR file */
 460     if (printXUsage || printUsage || what == 0 || mode == LM_UNKNOWN) {
 461         PrintUsage(env, printXUsage);
 462         CHECK_EXCEPTION_LEAVE(1);
 463         LEAVE();
 464     }
 465 
 466     FreeKnownVMs(); /* after last possible PrintUsage */
 467 
 468     if (JLI_IsTraceLauncher()) {
<a name="5" id="anc5"></a><span class="line-modified"> 469         end = CurrentTimeMicros();</span>
<span class="line-modified"> 470         JLI_TraceLauncher(&quot;%ld micro seconds to InitializeJVM\n&quot;, (long)(end-start));</span>

 471     }
 472 
 473     /* At this stage, argc/argv have the application&#39;s arguments */
 474     if (JLI_IsTraceLauncher()){
 475         int i;
 476         printf(&quot;%s is &#39;%s&#39;\n&quot;, launchModeNames[mode], what);
 477         printf(&quot;App&#39;s argc is %d\n&quot;, argc);
 478         for (i=0; i &lt; argc; i++) {
 479             printf(&quot;    argv[%2d] = &#39;%s&#39;\n&quot;, i, argv[i]);
 480         }
 481     }
 482 
 483     ret = 1;
 484 
 485     /*
 486      * Get the application&#39;s main class. It also checks if the main
 487      * method exists.
 488      *
 489      * See bugid 5030265.  The Main-Class name has already been parsed
 490      * from the manifest, but not parsed properly for UTF-8 support.
 491      * Hence the code here ignores the value previously extracted and
 492      * uses the pre-existing code to reextract the value.  This is
 493      * possibly an end of release cycle expedient.  However, it has
 494      * also been discovered that passing some character sets through
 495      * the environment has &quot;strange&quot; behavior on some variants of
 496      * Windows.  Hence, maybe the manifest parsing code local to the
 497      * launcher should never be enhanced.
 498      *
 499      * Hence, future work should either:
 500      *     1)   Correct the local parsing code and verify that the
 501      *          Main-Class attribute gets properly passed through
 502      *          all environments,
 503      *     2)   Remove the vestages of maintaining main_class through
 504      *          the environment (and remove these comments).
 505      *
 506      * This method also correctly handles launching existing JavaFX
 507      * applications that may or may not have a Main-Class manifest entry.
 508      */
 509     mainClass = LoadMainClass(env, mode, what);
 510     CHECK_EXCEPTION_NULL_LEAVE(mainClass);
 511     /*
 512      * In some cases when launching an application that needs a helper, e.g., a
 513      * JavaFX application with no main method, the mainClass will not be the
 514      * applications own main class but rather a helper class. To keep things
 515      * consistent in the UI we need to track and report the application main class.
 516      */
 517     appClass = GetApplicationClass(env);
 518     NULL_CHECK_RETURN_VALUE(appClass, -1);
 519 
 520     /* Build platform specific argument array */
 521     mainArgs = CreateApplicationArgs(env, argv, argc);
 522     CHECK_EXCEPTION_NULL_LEAVE(mainArgs);
 523 
 524     if (dryRun) {
 525         ret = 0;
 526         LEAVE();
 527     }
 528 
 529     /*
 530      * PostJVMInit uses the class name as the application name for GUI purposes,
 531      * for example, on OSX this sets the application name in the menu bar for
 532      * both SWT and JavaFX. So we&#39;ll pass the actual application class here
 533      * instead of mainClass as that may be a launcher or helper class instead
 534      * of the application class.
 535      */
 536     PostJVMInit(env, appClass, vm);
 537     CHECK_EXCEPTION_LEAVE(1);
 538 
 539     /*
 540      * The LoadMainClass not only loads the main class, it will also ensure
 541      * that the main method&#39;s signature is correct, therefore further checking
 542      * is not required. The main method is invoked here so that extraneous java
 543      * stacks are not in the application stack trace.
 544      */
 545     mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, &quot;main&quot;,
 546                                        &quot;([Ljava/lang/String;)V&quot;);
 547     CHECK_EXCEPTION_NULL_LEAVE(mainID);
 548 
 549     /* Invoke main method. */
 550     (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);
 551 
 552     /*
 553      * The launcher&#39;s exit code (in the absence of calls to
 554      * System.exit) will be non-zero if main threw an exception.
 555      */
 556     ret = (*env)-&gt;ExceptionOccurred(env) == NULL ? 0 : 1;
 557 
 558     LEAVE();
 559 }
 560 
 561 /*
 562  * Test if the given name is one of the class path options.
 563  */
 564 static jboolean
 565 IsClassPathOption(const char* name) {
 566     return JLI_StrCmp(name, &quot;-classpath&quot;) == 0 ||
 567            JLI_StrCmp(name, &quot;-cp&quot;) == 0 ||
 568            JLI_StrCmp(name, &quot;--class-path&quot;) == 0;
 569 }
 570 
 571 /*
 572  * Test if the given name is a launcher option taking the main entry point.
 573  */
 574 static jboolean
 575 IsLauncherMainOption(const char* name) {
 576     return JLI_StrCmp(name, &quot;--module&quot;) == 0 ||
 577            JLI_StrCmp(name, &quot;-m&quot;) == 0;
 578 }
 579 
 580 /*
 581  * Test if the given name is a white-space launcher option.
 582  */
 583 static jboolean
 584 IsLauncherOption(const char* name) {
 585     return IsClassPathOption(name) ||
 586            IsLauncherMainOption(name) ||
 587            JLI_StrCmp(name, &quot;--describe-module&quot;) == 0 ||
 588            JLI_StrCmp(name, &quot;-d&quot;) == 0 ||
 589            JLI_StrCmp(name, &quot;--source&quot;) == 0;
 590 }
 591 
 592 /*
 593  * Test if the given name is a module-system white-space option that
 594  * will be passed to the VM with its corresponding long-form option
 595  * name and &quot;=&quot; delimiter.
 596  */
 597 static jboolean
 598 IsModuleOption(const char* name) {
 599     return JLI_StrCmp(name, &quot;--module-path&quot;) == 0 ||
 600            JLI_StrCmp(name, &quot;-p&quot;) == 0 ||
 601            JLI_StrCmp(name, &quot;--upgrade-module-path&quot;) == 0 ||
 602            JLI_StrCmp(name, &quot;--add-modules&quot;) == 0 ||
 603            JLI_StrCmp(name, &quot;--limit-modules&quot;) == 0 ||
 604            JLI_StrCmp(name, &quot;--add-exports&quot;) == 0 ||
 605            JLI_StrCmp(name, &quot;--add-opens&quot;) == 0 ||
 606            JLI_StrCmp(name, &quot;--add-reads&quot;) == 0 ||
 607            JLI_StrCmp(name, &quot;--patch-module&quot;) == 0;
 608 }
 609 
 610 static jboolean
 611 IsLongFormModuleOption(const char* name) {
 612     return JLI_StrCCmp(name, &quot;--module-path=&quot;) == 0 ||
 613            JLI_StrCCmp(name, &quot;--upgrade-module-path=&quot;) == 0 ||
 614            JLI_StrCCmp(name, &quot;--add-modules=&quot;) == 0 ||
 615            JLI_StrCCmp(name, &quot;--limit-modules=&quot;) == 0 ||
 616            JLI_StrCCmp(name, &quot;--add-exports=&quot;) == 0 ||
 617            JLI_StrCCmp(name, &quot;--add-reads=&quot;) == 0 ||
 618            JLI_StrCCmp(name, &quot;--patch-module=&quot;) == 0;
 619 }
 620 
 621 /*
 622  * Test if the given name has a white space option.
 623  */
 624 jboolean
 625 IsWhiteSpaceOption(const char* name) {
 626     return IsModuleOption(name) ||
 627            IsLauncherOption(name);
 628 }
 629 
 630 /*
 631  * Check if it is OK to set the mode.
 632  * If the mode was previously set, and should not be changed,
 633  * a fatal error is reported.
 634  */
 635 static int
 636 checkMode(int mode, int newMode, const char *arg) {
 637     if (mode == LM_SOURCE) {
 638         JLI_ReportErrorMessage(ARG_ERROR14, arg);
 639         exit(1);
 640     }
 641     return newMode;
 642 }
 643 
 644 /*
 645  * Test if an arg identifies a source file.
 646  */
 647 static jboolean IsSourceFile(const char *arg) {
 648     struct stat st;
 649     return (JLI_HasSuffix(arg, &quot;.java&quot;) &amp;&amp; stat(arg, &amp;st) == 0);
 650 }
 651 
 652 /*
 653  * Checks the command line options to find which JVM type was
 654  * specified.  If no command line option was given for the JVM type,
 655  * the default type is used.  The environment variable
 656  * JDK_ALTERNATE_VM and the command line option -XXaltjvm= are also
 657  * checked as ways of specifying which JVM type to invoke.
 658  */
 659 char *
 660 CheckJvmType(int *pargc, char ***argv, jboolean speculative) {
 661     int i, argi;
 662     int argc;
 663     char **newArgv;
 664     int newArgvIdx = 0;
 665     int isVMType;
 666     int jvmidx = -1;
 667     char *jvmtype = getenv(&quot;JDK_ALTERNATE_VM&quot;);
 668 
 669     argc = *pargc;
 670 
 671     /* To make things simpler we always copy the argv array */
 672     newArgv = JLI_MemAlloc((argc + 1) * sizeof(char *));
 673 
 674     /* The program name is always present */
 675     newArgv[newArgvIdx++] = (*argv)[0];
 676 
 677     for (argi = 1; argi &lt; argc; argi++) {
 678         char *arg = (*argv)[argi];
 679         isVMType = 0;
 680 
 681         if (IsJavaArgs()) {
 682             if (arg[0] != &#39;-&#39;) {
 683                 newArgv[newArgvIdx++] = arg;
 684                 continue;
 685             }
 686         } else {
 687             if (IsWhiteSpaceOption(arg)) {
 688                 newArgv[newArgvIdx++] = arg;
 689                 argi++;
 690                 if (argi &lt; argc) {
 691                     newArgv[newArgvIdx++] = (*argv)[argi];
 692                 }
 693                 continue;
 694             }
 695             if (arg[0] != &#39;-&#39;) break;
 696         }
 697 
 698         /* Did the user pass an explicit VM type? */
 699         i = KnownVMIndex(arg);
 700         if (i &gt;= 0) {
 701             jvmtype = knownVMs[jvmidx = i].name + 1; /* skip the - */
 702             isVMType = 1;
 703             *pargc = *pargc - 1;
 704         }
 705 
 706         /* Did the user specify an &quot;alternate&quot; VM? */
 707         else if (JLI_StrCCmp(arg, &quot;-XXaltjvm=&quot;) == 0 || JLI_StrCCmp(arg, &quot;-J-XXaltjvm=&quot;) == 0) {
 708             isVMType = 1;
 709             jvmtype = arg+((arg[1]==&#39;X&#39;)? 10 : 12);
 710             jvmidx = -1;
 711         }
 712 
 713         if (!isVMType) {
 714             newArgv[newArgvIdx++] = arg;
 715         }
 716     }
 717 
 718     /*
 719      * Finish copying the arguments if we aborted the above loop.
 720      * NOTE that if we aborted via &quot;break&quot; then we did NOT copy the
 721      * last argument above, and in addition argi will be less than
 722      * argc.
 723      */
 724     while (argi &lt; argc) {
 725         newArgv[newArgvIdx++] = (*argv)[argi];
 726         argi++;
 727     }
 728 
 729     /* argv is null-terminated */
 730     newArgv[newArgvIdx] = 0;
 731 
 732     /* Copy back argv */
 733     *argv = newArgv;
 734     *pargc = newArgvIdx;
 735 
 736     /* use the default VM type if not specified (no alias processing) */
 737     if (jvmtype == NULL) {
 738       char* result = knownVMs[0].name+1;
 739       JLI_TraceLauncher(&quot;Default VM: %s\n&quot;, result);
 740       return result;
 741     }
 742 
 743     /* if using an alternate VM, no alias processing */
 744     if (jvmidx &lt; 0)
 745       return jvmtype;
 746 
 747     /* Resolve aliases first */
 748     {
 749       int loopCount = 0;
 750       while (knownVMs[jvmidx].flag == VM_ALIASED_TO) {
 751         int nextIdx = KnownVMIndex(knownVMs[jvmidx].alias);
 752 
 753         if (loopCount &gt; knownVMsCount) {
 754           if (!speculative) {
 755             JLI_ReportErrorMessage(CFG_ERROR1);
 756             exit(1);
 757           } else {
 758             return &quot;ERROR&quot;;
 759             /* break; */
 760           }
 761         }
 762 
 763         if (nextIdx &lt; 0) {
 764           if (!speculative) {
 765             JLI_ReportErrorMessage(CFG_ERROR2, knownVMs[jvmidx].alias);
 766             exit(1);
 767           } else {
 768             return &quot;ERROR&quot;;
 769           }
 770         }
 771         jvmidx = nextIdx;
 772         jvmtype = knownVMs[jvmidx].name+1;
 773         loopCount++;
 774       }
 775     }
 776 
 777     switch (knownVMs[jvmidx].flag) {
 778     case VM_WARN:
 779         if (!speculative) {
 780             JLI_ReportErrorMessage(CFG_WARN1, jvmtype, knownVMs[0].name + 1);
 781         }
 782         /* fall through */
 783     case VM_IGNORE:
 784         jvmtype = knownVMs[jvmidx=0].name + 1;
 785         /* fall through */
 786     case VM_KNOWN:
 787         break;
 788     case VM_ERROR:
 789         if (!speculative) {
 790             JLI_ReportErrorMessage(CFG_ERROR3, jvmtype);
 791             exit(1);
 792         } else {
 793             return &quot;ERROR&quot;;
 794         }
 795     }
 796 
 797     return jvmtype;
 798 }
 799 
 800 /*
 801  * This method must be called before the VM is loaded, primarily
 802  * used to parse and set any VM related options or env variables.
 803  * This function is non-destructive leaving the argument list intact.
 804  */
 805 static void
 806 SetJvmEnvironment(int argc, char **argv) {
 807 
 808     static const char*  NMT_Env_Name    = &quot;NMT_LEVEL_&quot;;
 809     int i;
 810     /* process only the launcher arguments */
 811     for (i = 0; i &lt; argc; i++) {
 812         char *arg = argv[i];
 813         /*
 814          * Since this must be a VM flag we stop processing once we see
 815          * an argument the launcher would not have processed beyond (such
 816          * as -version or -h), or an argument that indicates the following
 817          * arguments are for the application (i.e. the main class name, or
 818          * the -jar argument).
 819          */
 820         if (i &gt; 0) {
 821             char *prev = argv[i - 1];
 822             // skip non-dash arg preceded by class path specifiers
 823             if (*arg != &#39;-&#39; &amp;&amp; IsWhiteSpaceOption(prev)) {
 824                 continue;
 825             }
 826 
 827             if (*arg != &#39;-&#39; || isTerminalOpt(arg)) {
 828                 return;
 829             }
 830         }
 831         /*
 832          * The following case checks for &quot;-XX:NativeMemoryTracking=value&quot;.
 833          * If value is non null, an environmental variable set to this value
 834          * will be created to be used by the JVM.
 835          * The argument is passed to the JVM, which will check validity.
 836          * The JVM is responsible for removing the env variable.
 837          */
 838         if (JLI_StrCCmp(arg, &quot;-XX:NativeMemoryTracking=&quot;) == 0) {
 839             int retval;
 840             // get what follows this parameter, include &quot;=&quot;
 841             size_t pnlen = JLI_StrLen(&quot;-XX:NativeMemoryTracking=&quot;);
 842             if (JLI_StrLen(arg) &gt; pnlen) {
 843                 char* value = arg + pnlen;
 844                 size_t pbuflen = pnlen + JLI_StrLen(value) + 10; // 10 max pid digits
 845 
 846                 /*
 847                  * ensures that malloc successful
 848                  * DONT JLI_MemFree() pbuf.  JLI_PutEnv() uses system call
 849                  *   that could store the address.
 850                  */
 851                 char * pbuf = (char*)JLI_MemAlloc(pbuflen);
 852 
 853                 JLI_Snprintf(pbuf, pbuflen, &quot;%s%d=%s&quot;, NMT_Env_Name, JLI_GetPid(), value);
 854                 retval = JLI_PutEnv(pbuf);
 855                 if (JLI_IsTraceLauncher()) {
 856                     char* envName;
 857                     char* envBuf;
 858 
 859                     // ensures that malloc successful
 860                     envName = (char*)JLI_MemAlloc(pbuflen);
 861                     JLI_Snprintf(envName, pbuflen, &quot;%s%d&quot;, NMT_Env_Name, JLI_GetPid());
 862 
 863                     printf(&quot;TRACER_MARKER: NativeMemoryTracking: env var is %s\n&quot;,envName);
 864                     printf(&quot;TRACER_MARKER: NativeMemoryTracking: putenv arg %s\n&quot;,pbuf);
 865                     envBuf = getenv(envName);
 866                     printf(&quot;TRACER_MARKER: NativeMemoryTracking: got value %s\n&quot;,envBuf);
 867                     free(envName);
 868                 }
 869             }
 870         }
 871     }
 872 }
 873 
 874 /* copied from HotSpot function &quot;atomll()&quot; */
 875 static int
 876 parse_size(const char *s, jlong *result) {
 877   jlong n = 0;
 878   int args_read = sscanf(s, JLONG_FORMAT_SPECIFIER, &amp;n);
 879   if (args_read != 1) {
 880     return 0;
 881   }
 882   while (*s != &#39;\0&#39; &amp;&amp; *s &gt;= &#39;0&#39; &amp;&amp; *s &lt;= &#39;9&#39;) {
 883     s++;
 884   }
 885   // 4705540: illegal if more characters are found after the first non-digit
 886   if (JLI_StrLen(s) &gt; 1) {
 887     return 0;
 888   }
 889   switch (*s) {
 890     case &#39;T&#39;: case &#39;t&#39;:
 891       *result = n * GB * KB;
 892       return 1;
 893     case &#39;G&#39;: case &#39;g&#39;:
 894       *result = n * GB;
 895       return 1;
 896     case &#39;M&#39;: case &#39;m&#39;:
 897       *result = n * MB;
 898       return 1;
 899     case &#39;K&#39;: case &#39;k&#39;:
 900       *result = n * KB;
 901       return 1;
 902     case &#39;\0&#39;:
 903       *result = n;
 904       return 1;
 905     default:
 906       /* Create JVM with default stack and let VM handle malformed -Xss string*/
 907       return 0;
 908   }
 909 }
 910 
 911 /*
 912  * Adds a new VM option with the given name and value.
 913  */
 914 void
 915 AddOption(char *str, void *info)
 916 {
 917     /*
 918      * Expand options array if needed to accommodate at least one more
 919      * VM option.
 920      */
 921     if (numOptions &gt;= maxOptions) {
 922         if (options == 0) {
 923             maxOptions = 4;
 924             options = JLI_MemAlloc(maxOptions * sizeof(JavaVMOption));
 925         } else {
 926             JavaVMOption *tmp;
 927             maxOptions *= 2;
 928             tmp = JLI_MemAlloc(maxOptions * sizeof(JavaVMOption));
 929             memcpy(tmp, options, numOptions * sizeof(JavaVMOption));
 930             JLI_MemFree(options);
 931             options = tmp;
 932         }
 933     }
 934     options[numOptions].optionString = str;
 935     options[numOptions++].extraInfo = info;
 936 
 937     /*
 938      * -Xss is used both by the JVM and here to establish the stack size of the thread
 939      * created to launch the JVM. In the latter case we need to ensure we don&#39;t go
 940      * below the minimum stack size allowed. If -Xss is zero that tells the JVM to use
 941      * &#39;default&#39; sizes (either from JVM or system configuration, e.g. &#39;ulimit -s&#39; on linux),
 942      * and is not itself a small stack size that will be rejected. So we ignore -Xss0 here.
 943      */
 944     if (JLI_StrCCmp(str, &quot;-Xss&quot;) == 0) {
 945         jlong tmp;
 946         if (parse_size(str + 4, &amp;tmp)) {
 947             threadStackSize = tmp;
 948             if (threadStackSize &gt; 0 &amp;&amp; threadStackSize &lt; (jlong)STACK_SIZE_MINIMUM) {
 949                 threadStackSize = STACK_SIZE_MINIMUM;
 950             }
 951         }
 952     }
 953 
 954     if (JLI_StrCCmp(str, &quot;-Xmx&quot;) == 0) {
 955         jlong tmp;
 956         if (parse_size(str + 4, &amp;tmp)) {
 957             maxHeapSize = tmp;
 958         }
 959     }
 960 
 961     if (JLI_StrCCmp(str, &quot;-Xms&quot;) == 0) {
 962         jlong tmp;
 963         if (parse_size(str + 4, &amp;tmp)) {
 964            initialHeapSize = tmp;
 965         }
 966     }
 967 }
 968 
 969 static void
 970 SetClassPath(const char *s)
 971 {
 972     char *def;
 973     const char *orig = s;
 974     static const char format[] = &quot;-Djava.class.path=%s&quot;;
 975     /*
 976      * usually we should not get a null pointer, but there are cases where
 977      * we might just get one, in which case we simply ignore it, and let the
 978      * caller deal with it
 979      */
 980     if (s == NULL)
 981         return;
 982     s = JLI_WildcardExpandClasspath(s);
 983     if (sizeof(format) - 2 + JLI_StrLen(s) &lt; JLI_StrLen(s))
 984         // s is became corrupted after expanding wildcards
 985         return;
 986     def = JLI_MemAlloc(sizeof(format)
 987                        - 2 /* strlen(&quot;%s&quot;) */
 988                        + JLI_StrLen(s));
 989     sprintf(def, format, s);
 990     AddOption(def, NULL);
 991     if (s != orig)
 992         JLI_MemFree((char *) s);
 993     _have_classpath = JNI_TRUE;
 994 }
 995 
 996 static void
 997 AddLongFormOption(const char *option, const char *arg)
 998 {
 999     static const char format[] = &quot;%s=%s&quot;;
1000     char *def;
1001     size_t def_len;
1002 
1003     def_len = JLI_StrLen(option) + 1 + JLI_StrLen(arg) + 1;
1004     def = JLI_MemAlloc(def_len);
1005     JLI_Snprintf(def, def_len, format, option, arg);
1006     AddOption(def, NULL);
1007 }
1008 
1009 static void
1010 SetMainModule(const char *s)
1011 {
1012     static const char format[] = &quot;-Djdk.module.main=%s&quot;;
1013     char* slash = JLI_StrChr(s, &#39;/&#39;);
1014     size_t s_len, def_len;
1015     char *def;
1016 
1017     /* value may be &lt;module&gt; or &lt;module&gt;/&lt;mainclass&gt; */
1018     if (slash == NULL) {
1019         s_len = JLI_StrLen(s);
1020     } else {
1021         s_len = (size_t) (slash - s);
1022     }
1023     def_len = sizeof(format)
1024                - 2 /* strlen(&quot;%s&quot;) */
1025                + s_len;
1026     def = JLI_MemAlloc(def_len);
1027     JLI_Snprintf(def, def_len, format, s);
1028     AddOption(def, NULL);
1029 }
1030 
1031 /*
1032  * The SelectVersion() routine ensures that an appropriate version of
1033  * the JRE is running.  The specification for the appropriate version
1034  * is obtained from either the manifest of a jar file (preferred) or
1035  * from command line options.
1036  * The routine also parses splash screen command line options and
1037  * passes on their values in private environment variables.
1038  */
1039 static void
1040 SelectVersion(int argc, char **argv, char **main_class)
1041 {
1042     char    *arg;
1043     char    *operand;
1044     char    *version = NULL;
1045     char    *jre = NULL;
1046     int     jarflag = 0;
1047     int     headlessflag = 0;
1048     int     restrict_search = -1;               /* -1 implies not known */
1049     manifest_info info;
1050     char    env_entry[MAXNAMELEN + 24] = ENV_ENTRY &quot;=&quot;;
1051     char    *splash_file_name = NULL;
1052     char    *splash_jar_name = NULL;
1053     char    *env_in;
1054     int     res;
1055     jboolean has_arg;
1056 
1057     /*
1058      * If the version has already been selected, set *main_class
1059      * with the value passed through the environment (if any) and
1060      * simply return.
1061      */
1062 
1063     /*
1064      * This environmental variable can be set by mJRE capable JREs
1065      * [ 1.5 thru 1.8 ].  All other aspects of mJRE processing have been
1066      * stripped by those JREs.  This environmental variable allows 1.9+
1067      * JREs to be started by these mJRE capable JREs.
1068      * Note that mJRE directives in the jar manifest file would have been
1069      * ignored for a JRE started by another JRE...
1070      * .. skipped for JRE 1.5 and beyond.
1071      * .. not even checked for pre 1.5.
1072      */
1073     if ((env_in = getenv(ENV_ENTRY)) != NULL) {
1074         if (*env_in != &#39;\0&#39;)
1075             *main_class = JLI_StringDup(env_in);
1076         return;
1077     }
1078 
1079     /*
1080      * Scan through the arguments for options relevant to multiple JRE
1081      * support.  Multiple JRE support existed in JRE versions 1.5 thru 1.8.
1082      *
1083      * This capability is no longer available with JRE versions 1.9 and later.
1084      * These command line options are reported as errors.
1085      */
1086 
1087     argc--;
1088     argv++;
1089     while ((arg = *argv) != 0 &amp;&amp; *arg == &#39;-&#39;) {
1090         has_arg = IsOptionWithArgument(argc, argv);
1091         if (JLI_StrCCmp(arg, &quot;-version:&quot;) == 0) {
1092             JLI_ReportErrorMessage(SPC_ERROR1);
1093         } else if (JLI_StrCmp(arg, &quot;-jre-restrict-search&quot;) == 0) {
1094             JLI_ReportErrorMessage(SPC_ERROR2);
1095         } else if (JLI_StrCmp(arg, &quot;-jre-no-restrict-search&quot;) == 0) {
1096             JLI_ReportErrorMessage(SPC_ERROR2);
1097         } else {
1098             if (JLI_StrCmp(arg, &quot;-jar&quot;) == 0)
1099                 jarflag = 1;
1100             if (IsWhiteSpaceOption(arg)) {
1101                 if (has_arg) {
1102                     argc--;
1103                     argv++;
1104                     arg = *argv;
1105                 }
1106             }
1107 
1108             /*
1109              * Checking for headless toolkit option in the some way as AWT does:
1110              * &quot;true&quot; means true and any other value means false
1111              */
1112             if (JLI_StrCmp(arg, &quot;-Djava.awt.headless=true&quot;) == 0) {
1113                 headlessflag = 1;
1114             } else if (JLI_StrCCmp(arg, &quot;-Djava.awt.headless=&quot;) == 0) {
1115                 headlessflag = 0;
1116             } else if (JLI_StrCCmp(arg, &quot;-splash:&quot;) == 0) {
1117                 splash_file_name = arg+8;
1118             }
1119         }
1120         argc--;
1121         argv++;
1122     }
1123     if (argc &lt;= 0) {    /* No operand? Possibly legit with -[full]version */
1124         operand = NULL;
1125     } else {
1126         argc--;
1127         operand = *argv++;
1128     }
1129 
1130     /*
1131      * If there is a jar file, read the manifest. If the jarfile can&#39;t be
1132      * read, the manifest can&#39;t be read from the jar file, or the manifest
1133      * is corrupt, issue the appropriate error messages and exit.
1134      *
1135      * Even if there isn&#39;t a jar file, construct a manifest_info structure
1136      * containing the command line information.  It&#39;s a convenient way to carry
1137      * this data around.
1138      */
1139     if (jarflag &amp;&amp; operand) {
1140         if ((res = JLI_ParseManifest(operand, &amp;info)) != 0) {
1141             if (res == -1)
1142                 JLI_ReportErrorMessage(JAR_ERROR2, operand);
1143             else
1144                 JLI_ReportErrorMessage(JAR_ERROR3, operand);
1145             exit(1);
1146         }
1147 
1148         /*
1149          * Command line splash screen option should have precedence
1150          * over the manifest, so the manifest data is used only if
1151          * splash_file_name has not been initialized above during command
1152          * line parsing
1153          */
1154         if (!headlessflag &amp;&amp; !splash_file_name &amp;&amp; info.splashscreen_image_file_name) {
1155             splash_file_name = info.splashscreen_image_file_name;
1156             splash_jar_name = operand;
1157         }
1158     } else {
1159         info.manifest_version = NULL;
1160         info.main_class = NULL;
1161         info.jre_version = NULL;
1162         info.jre_restrict_search = 0;
1163     }
1164 
1165     /*
1166      * Passing on splash screen info in environment variables
1167      */
1168     if (splash_file_name &amp;&amp; !headlessflag) {
1169         splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY &quot;=&quot;)+JLI_StrLen(splash_file_name)+1);
1170         JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY &quot;=&quot;);
1171         JLI_StrCat(splash_file_entry, splash_file_name);
1172         putenv(splash_file_entry);
1173     }
1174     if (splash_jar_name &amp;&amp; !headlessflag) {
1175         splash_jar_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_JAR_ENV_ENTRY &quot;=&quot;)+JLI_StrLen(splash_jar_name)+1);
1176         JLI_StrCpy(splash_jar_entry, SPLASH_JAR_ENV_ENTRY &quot;=&quot;);
1177         JLI_StrCat(splash_jar_entry, splash_jar_name);
1178         putenv(splash_jar_entry);
1179     }
1180 
1181 
1182     /*
1183      * &quot;Valid&quot; returns (other than unrecoverable errors) follow.  Set
1184      * main_class as a side-effect of this routine.
1185      */
1186     if (info.main_class != NULL)
1187         *main_class = JLI_StringDup(info.main_class);
1188 
1189     if (info.jre_version == NULL) {
1190         JLI_FreeManifest();
1191         return;
1192     }
1193 
1194 }
1195 
1196 /*
1197  * Test if the current argv is an option, i.e. with a leading `-`
1198  * and followed with an argument without a leading `-`.
1199  */
1200 static jboolean
1201 IsOptionWithArgument(int argc, char** argv) {
1202     char* option;
1203     char* arg;
1204 
1205     if (argc &lt;= 1)
1206         return JNI_FALSE;
1207 
1208     option = *argv;
1209     arg = *(argv+1);
1210     return *option == &#39;-&#39; &amp;&amp; *arg != &#39;-&#39;;
1211 }
1212 
1213 /*
1214  * Gets the option, and its argument if the option has an argument.
1215  * It will update *pargc, **pargv to the next option.
1216  */
1217 static int
1218 GetOpt(int *pargc, char ***pargv, char **poption, char **pvalue) {
1219     int argc = *pargc;
1220     char** argv = *pargv;
1221     char* arg = *argv;
1222 
1223     char* option = arg;
1224     char* value = NULL;
1225     char* equals = NULL;
1226     int kind = LAUNCHER_OPTION;
1227     jboolean has_arg = JNI_FALSE;
1228 
1229     // check if this option may be a white-space option with an argument
1230     has_arg = IsOptionWithArgument(argc, argv);
1231 
1232     argv++; --argc;
1233     if (IsLauncherOption(arg)) {
1234         if (has_arg) {
1235             value = *argv;
1236             argv++; --argc;
1237         }
1238         kind = IsLauncherMainOption(arg) ? LAUNCHER_MAIN_OPTION
1239                                          : LAUNCHER_OPTION_WITH_ARGUMENT;
1240     } else if (IsModuleOption(arg)) {
1241         kind = VM_LONG_OPTION_WITH_ARGUMENT;
1242         if (has_arg) {
1243             value = *argv;
1244             argv++; --argc;
1245         }
1246 
1247         /*
1248          * Support short form alias
1249          */
1250         if (JLI_StrCmp(arg, &quot;-p&quot;) == 0) {
1251             option = &quot;--module-path&quot;;
1252         }
1253 
1254     } else if (JLI_StrCCmp(arg, &quot;--&quot;) == 0 &amp;&amp; (equals = JLI_StrChr(arg, &#39;=&#39;)) != NULL) {
1255         value = equals+1;
1256         if (JLI_StrCCmp(arg, &quot;--describe-module=&quot;) == 0 ||
1257             JLI_StrCCmp(arg, &quot;--module=&quot;) == 0 ||
1258             JLI_StrCCmp(arg, &quot;--class-path=&quot;) == 0||
1259             JLI_StrCCmp(arg, &quot;--source=&quot;) == 0) {
1260             kind = LAUNCHER_OPTION_WITH_ARGUMENT;
1261         } else {
1262             kind = VM_LONG_OPTION;
1263         }
1264     }
1265 
1266     *pargc = argc;
1267     *pargv = argv;
1268     *poption = option;
1269     *pvalue = value;
1270     return kind;
1271 }
1272 
1273 /*
1274  * Parses command line arguments.  Returns JNI_FALSE if launcher
1275  * should exit without starting vm, returns JNI_TRUE if vm needs
1276  * to be started to process given options.  *pret (the launcher
1277  * process return value) is set to 0 for a normal exit.
1278  */
1279 static jboolean
1280 ParseArguments(int *pargc, char ***pargv,
1281                int *pmode, char **pwhat,
1282                int *pret, const char *jrepath)
1283 {
1284     int argc = *pargc;
1285     char **argv = *pargv;
1286     int mode = LM_UNKNOWN;
1287     char *arg;
1288 
1289     *pret = 0;
1290 
1291     while ((arg = *argv) != 0 &amp;&amp; *arg == &#39;-&#39;) {
1292         char *option = NULL;
1293         char *value = NULL;
1294         int kind = GetOpt(&amp;argc, &amp;argv, &amp;option, &amp;value);
1295         jboolean has_arg = value != NULL &amp;&amp; JLI_StrLen(value) &gt; 0;
1296         jboolean has_arg_any_len = value != NULL;
1297 
1298 /*
1299  * Option to set main entry point
1300  */
1301         if (JLI_StrCmp(arg, &quot;-jar&quot;) == 0) {
1302             ARG_CHECK(argc, ARG_ERROR2, arg);
1303             mode = checkMode(mode, LM_JAR, arg);
1304         } else if (JLI_StrCmp(arg, &quot;--module&quot;) == 0 ||
1305                    JLI_StrCCmp(arg, &quot;--module=&quot;) == 0 ||
1306                    JLI_StrCmp(arg, &quot;-m&quot;) == 0) {
1307             REPORT_ERROR (has_arg, ARG_ERROR5, arg);
1308             SetMainModule(value);
1309             mode = checkMode(mode, LM_MODULE, arg);
1310             if (has_arg) {
1311                *pwhat = value;
1312                 break;
1313             }
1314         } else if (JLI_StrCmp(arg, &quot;--source&quot;) == 0 ||
1315                    JLI_StrCCmp(arg, &quot;--source=&quot;) == 0) {
1316             REPORT_ERROR (has_arg, ARG_ERROR13, arg);
1317             mode = LM_SOURCE;
1318             if (has_arg) {
1319                 const char *prop = &quot;-Djdk.internal.javac.source=&quot;;
1320                 size_t size = JLI_StrLen(prop) + JLI_StrLen(value) + 1;
1321                 char *propValue = (char *)JLI_MemAlloc(size);
1322                 JLI_Snprintf(propValue, size, &quot;%s%s&quot;, prop, value);
1323                 AddOption(propValue, NULL);
1324             }
1325         } else if (JLI_StrCmp(arg, &quot;--class-path&quot;) == 0 ||
1326                    JLI_StrCCmp(arg, &quot;--class-path=&quot;) == 0 ||
1327                    JLI_StrCmp(arg, &quot;-classpath&quot;) == 0 ||
1328                    JLI_StrCmp(arg, &quot;-cp&quot;) == 0) {
1329             REPORT_ERROR (has_arg_any_len, ARG_ERROR1, arg);
1330             SetClassPath(value);
1331             if (mode != LM_SOURCE) {
1332                 mode = LM_CLASS;
1333             }
1334         } else if (JLI_StrCmp(arg, &quot;--list-modules&quot;) == 0) {
1335             listModules = JNI_TRUE;
1336         } else if (JLI_StrCmp(arg, &quot;--show-resolved-modules&quot;) == 0) {
1337             showResolvedModules = JNI_TRUE;
1338         } else if (JLI_StrCmp(arg, &quot;--validate-modules&quot;) == 0) {
1339             AddOption(&quot;-Djdk.module.validation=true&quot;, NULL);
1340             validateModules = JNI_TRUE;
1341         } else if (JLI_StrCmp(arg, &quot;--describe-module&quot;) == 0 ||
1342                    JLI_StrCCmp(arg, &quot;--describe-module=&quot;) == 0 ||
1343                    JLI_StrCmp(arg, &quot;-d&quot;) == 0) {
1344             REPORT_ERROR (has_arg_any_len, ARG_ERROR12, arg);
1345             describeModule = value;
1346 /*
1347  * Parse white-space options
1348  */
1349         } else if (has_arg) {
1350             if (kind == VM_LONG_OPTION) {
1351                 AddOption(option, NULL);
1352             } else if (kind == VM_LONG_OPTION_WITH_ARGUMENT) {
1353                 AddLongFormOption(option, value);
1354             }
1355 /*
1356  * Error missing argument
1357  */
1358         } else if (!has_arg &amp;&amp; (JLI_StrCmp(arg, &quot;--module-path&quot;) == 0 ||
1359                                 JLI_StrCmp(arg, &quot;-p&quot;) == 0 ||
1360                                 JLI_StrCmp(arg, &quot;--upgrade-module-path&quot;) == 0)) {
1361             REPORT_ERROR (has_arg, ARG_ERROR4, arg);
1362 
1363         } else if (!has_arg &amp;&amp; (IsModuleOption(arg) || IsLongFormModuleOption(arg))) {
1364             REPORT_ERROR (has_arg, ARG_ERROR6, arg);
1365 /*
1366  * The following cases will cause the argument parsing to stop
1367  */
1368         } else if (JLI_StrCmp(arg, &quot;-help&quot;) == 0 ||
1369                    JLI_StrCmp(arg, &quot;-h&quot;) == 0 ||
1370                    JLI_StrCmp(arg, &quot;-?&quot;) == 0) {
1371             printUsage = JNI_TRUE;
1372             return JNI_TRUE;
1373         } else if (JLI_StrCmp(arg, &quot;--help&quot;) == 0) {
1374             printUsage = JNI_TRUE;
1375             printTo = USE_STDOUT;
1376             return JNI_TRUE;
1377         } else if (JLI_StrCmp(arg, &quot;-version&quot;) == 0) {
1378             printVersion = JNI_TRUE;
1379             return JNI_TRUE;
1380         } else if (JLI_StrCmp(arg, &quot;--version&quot;) == 0) {
1381             printVersion = JNI_TRUE;
1382             printTo = USE_STDOUT;
1383             return JNI_TRUE;
1384         } else if (JLI_StrCmp(arg, &quot;-showversion&quot;) == 0) {
1385             showVersion = JNI_TRUE;
1386         } else if (JLI_StrCmp(arg, &quot;--show-version&quot;) == 0) {
1387             showVersion = JNI_TRUE;
1388             printTo = USE_STDOUT;
1389         } else if (JLI_StrCmp(arg, &quot;--dry-run&quot;) == 0) {
1390             dryRun = JNI_TRUE;
1391         } else if (JLI_StrCmp(arg, &quot;-X&quot;) == 0) {
1392             printXUsage = JNI_TRUE;
1393             return JNI_TRUE;
1394         } else if (JLI_StrCmp(arg, &quot;--help-extra&quot;) == 0) {
1395             printXUsage = JNI_TRUE;
1396             printTo = USE_STDOUT;
1397             return JNI_TRUE;
1398 /*
1399  * The following case checks for -XshowSettings OR -XshowSetting:SUBOPT.
1400  * In the latter case, any SUBOPT value not recognized will default to &quot;all&quot;
1401  */
1402         } else if (JLI_StrCmp(arg, &quot;-XshowSettings&quot;) == 0 ||
1403                    JLI_StrCCmp(arg, &quot;-XshowSettings:&quot;) == 0) {
1404             showSettings = arg;
1405         } else if (JLI_StrCmp(arg, &quot;-Xdiag&quot;) == 0) {
1406             AddOption(&quot;-Dsun.java.launcher.diag=true&quot;, NULL);
1407         } else if (JLI_StrCmp(arg, &quot;--show-module-resolution&quot;) == 0) {
1408             AddOption(&quot;-Djdk.module.showModuleResolution=true&quot;, NULL);
1409 /*
1410  * The following case provide backward compatibility with old-style
1411  * command line options.
1412  */
1413         } else if (JLI_StrCmp(arg, &quot;-fullversion&quot;) == 0) {
1414             JLI_ReportMessage(&quot;%s full version \&quot;%s\&quot;&quot;, _launcher_name, GetFullVersion());
1415             return JNI_FALSE;
1416         } else if (JLI_StrCmp(arg, &quot;--full-version&quot;) == 0) {
1417             JLI_ShowMessage(&quot;%s %s&quot;, _launcher_name, GetFullVersion());
1418             return JNI_FALSE;
1419         } else if (JLI_StrCmp(arg, &quot;-verbosegc&quot;) == 0) {
1420             AddOption(&quot;-verbose:gc&quot;, NULL);
1421         } else if (JLI_StrCmp(arg, &quot;-t&quot;) == 0) {
1422             AddOption(&quot;-Xt&quot;, NULL);
1423         } else if (JLI_StrCmp(arg, &quot;-tm&quot;) == 0) {
1424             AddOption(&quot;-Xtm&quot;, NULL);
1425         } else if (JLI_StrCmp(arg, &quot;-debug&quot;) == 0) {
1426             AddOption(&quot;-Xdebug&quot;, NULL);
1427         } else if (JLI_StrCmp(arg, &quot;-noclassgc&quot;) == 0) {
1428             AddOption(&quot;-Xnoclassgc&quot;, NULL);
1429         } else if (JLI_StrCmp(arg, &quot;-Xfuture&quot;) == 0) {
1430             JLI_ReportErrorMessage(ARG_DEPRECATED, &quot;-Xfuture&quot;);
1431             AddOption(&quot;-Xverify:all&quot;, NULL);
1432         } else if (JLI_StrCmp(arg, &quot;-verify&quot;) == 0) {
1433             AddOption(&quot;-Xverify:all&quot;, NULL);
1434         } else if (JLI_StrCmp(arg, &quot;-verifyremote&quot;) == 0) {
1435             AddOption(&quot;-Xverify:remote&quot;, NULL);
1436         } else if (JLI_StrCmp(arg, &quot;-noverify&quot;) == 0) {
1437             /*
1438              * Note that no &#39;deprecated&#39; message is needed here because the VM
1439              * issues &#39;deprecated&#39; messages for -noverify and -Xverify:none.
1440              */
1441             AddOption(&quot;-Xverify:none&quot;, NULL);
1442         } else if (JLI_StrCCmp(arg, &quot;-ss&quot;) == 0 ||
1443                    JLI_StrCCmp(arg, &quot;-oss&quot;) == 0 ||
1444                    JLI_StrCCmp(arg, &quot;-ms&quot;) == 0 ||
1445                    JLI_StrCCmp(arg, &quot;-mx&quot;) == 0) {
1446             char *tmp = JLI_MemAlloc(JLI_StrLen(arg) + 6);
1447             sprintf(tmp, &quot;-X%s&quot;, arg + 1); /* skip &#39;-&#39; */
1448             AddOption(tmp, NULL);
1449         } else if (JLI_StrCmp(arg, &quot;-checksource&quot;) == 0 ||
1450                    JLI_StrCmp(arg, &quot;-cs&quot;) == 0 ||
1451                    JLI_StrCmp(arg, &quot;-noasyncgc&quot;) == 0) {
1452             /* No longer supported */
1453             JLI_ReportErrorMessage(ARG_WARN, arg);
1454         } else if (JLI_StrCCmp(arg, &quot;-splash:&quot;) == 0) {
1455             ; /* Ignore machine independent options already handled */
1456         } else if (ProcessPlatformOption(arg)) {
1457             ; /* Processing of platform dependent options */
1458         } else {
1459             /* java.class.path set on the command line */
1460             if (JLI_StrCCmp(arg, &quot;-Djava.class.path=&quot;) == 0) {
1461                 _have_classpath = JNI_TRUE;
1462             }
1463             AddOption(arg, NULL);
1464         }
1465     }
1466 
1467     if (*pwhat == NULL &amp;&amp; --argc &gt;= 0) {
1468         *pwhat = *argv++;
1469     }
1470 
1471     if (*pwhat == NULL) {
1472         /* LM_UNKNOWN okay for options that exit */
1473         if (!listModules &amp;&amp; !describeModule &amp;&amp; !validateModules) {
1474             *pret = 1;
1475         }
1476     } else if (mode == LM_UNKNOWN) {
1477         /* default to LM_CLASS if -m, -jar and -cp options are
1478          * not specified */
1479         if (!_have_classpath) {
1480             SetClassPath(&quot;.&quot;);
1481         }
1482         mode = IsSourceFile(arg) ? LM_SOURCE : LM_CLASS;
1483     } else if (mode == LM_CLASS &amp;&amp; IsSourceFile(arg)) {
1484         /* override LM_CLASS mode if given a source file */
1485         mode = LM_SOURCE;
1486     }
1487 
1488     if (mode == LM_SOURCE) {
1489         AddOption(&quot;--add-modules=ALL-DEFAULT&quot;, NULL);
1490         *pwhat = SOURCE_LAUNCHER_MAIN_ENTRY;
1491         // adjust (argc, argv) so that the name of the source file
1492         // is included in the args passed to the source launcher
1493         // main entry class
1494         *pargc = argc + 1;
1495         *pargv = argv - 1;
1496     } else {
1497         if (argc &gt;= 0) {
1498             *pargc = argc;
1499             *pargv = argv;
1500         }
1501     }
1502 
1503     *pmode = mode;
1504 
1505     return JNI_TRUE;
1506 }
1507 
1508 /*
1509  * Initializes the Java Virtual Machine. Also frees options array when
1510  * finished.
1511  */
1512 static jboolean
1513 InitializeJVM(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)
1514 {
1515     JavaVMInitArgs args;
1516     jint r;
1517 
1518     memset(&amp;args, 0, sizeof(args));
1519     args.version  = JNI_VERSION_1_2;
1520     args.nOptions = numOptions;
1521     args.options  = options;
1522     args.ignoreUnrecognized = JNI_FALSE;
1523 
1524     if (JLI_IsTraceLauncher()) {
1525         int i = 0;
1526         printf(&quot;JavaVM args:\n    &quot;);
1527         printf(&quot;version 0x%08lx, &quot;, (long)args.version);
1528         printf(&quot;ignoreUnrecognized is %s, &quot;,
1529                args.ignoreUnrecognized ? &quot;JNI_TRUE&quot; : &quot;JNI_FALSE&quot;);
1530         printf(&quot;nOptions is %ld\n&quot;, (long)args.nOptions);
1531         for (i = 0; i &lt; numOptions; i++)
1532             printf(&quot;    option[%2d] = &#39;%s&#39;\n&quot;,
1533                    i, args.options[i].optionString);
1534     }
1535 
1536     r = ifn-&gt;CreateJavaVM(pvm, (void **)penv, &amp;args);
1537     JLI_MemFree(options);
1538     return r == JNI_OK;
1539 }
1540 
1541 static jclass helperClass = NULL;
1542 
1543 jclass
1544 GetLauncherHelperClass(JNIEnv *env)
1545 {
1546     if (helperClass == NULL) {
1547         NULL_CHECK0(helperClass = FindBootStrapClass(env,
1548                 &quot;sun/launcher/LauncherHelper&quot;));
1549     }
1550     return helperClass;
1551 }
1552 
1553 static jmethodID makePlatformStringMID = NULL;
1554 /*
1555  * Returns a new Java string object for the specified platform string.
1556  */
1557 static jstring
1558 NewPlatformString(JNIEnv *env, char *s)
1559 {
1560     int len = (int)JLI_StrLen(s);
1561     jbyteArray ary;
1562     jclass cls = GetLauncherHelperClass(env);
1563     NULL_CHECK0(cls);
1564     if (s == NULL)
1565         return 0;
1566 
1567     ary = (*env)-&gt;NewByteArray(env, len);
1568     if (ary != 0) {
1569         jstring str = 0;
1570         (*env)-&gt;SetByteArrayRegion(env, ary, 0, len, (jbyte *)s);
1571         if (!(*env)-&gt;ExceptionOccurred(env)) {
1572             if (makePlatformStringMID == NULL) {
1573                 NULL_CHECK0(makePlatformStringMID = (*env)-&gt;GetStaticMethodID(env,
1574                         cls, &quot;makePlatformString&quot;, &quot;(Z[B)Ljava/lang/String;&quot;));
1575             }
1576             str = (*env)-&gt;CallStaticObjectMethod(env, cls,
1577                     makePlatformStringMID, USE_STDERR, ary);
1578             CHECK_EXCEPTION_RETURN_VALUE(0);
1579             (*env)-&gt;DeleteLocalRef(env, ary);
1580             return str;
1581         }
1582     }
1583     return 0;
1584 }
1585 
1586 /*
1587  * Returns a new array of Java string objects for the specified
1588  * array of platform strings.
1589  */
1590 jobjectArray
1591 NewPlatformStringArray(JNIEnv *env, char **strv, int strc)
1592 {
1593     jarray cls;
1594     jarray ary;
1595     int i;
1596 
1597     NULL_CHECK0(cls = FindBootStrapClass(env, &quot;java/lang/String&quot;));
1598     NULL_CHECK0(ary = (*env)-&gt;NewObjectArray(env, strc, cls, 0));
1599     CHECK_EXCEPTION_RETURN_VALUE(0);
1600     for (i = 0; i &lt; strc; i++) {
1601         jstring str = NewPlatformString(env, *strv++);
1602         NULL_CHECK0(str);
1603         (*env)-&gt;SetObjectArrayElement(env, ary, i, str);
1604         (*env)-&gt;DeleteLocalRef(env, str);
1605     }
1606     return ary;
1607 }
1608 
1609 /*
1610  * Loads a class and verifies that the main class is present and it is ok to
1611  * call it for more details refer to the java implementation.
1612  */
1613 static jclass
1614 LoadMainClass(JNIEnv *env, int mode, char *name)
1615 {
1616     jmethodID mid;
1617     jstring str;
1618     jobject result;
1619     jlong start = 0, end = 0;
1620     jclass cls = GetLauncherHelperClass(env);
1621     NULL_CHECK0(cls);
1622     if (JLI_IsTraceLauncher()) {
<a name="6" id="anc6"></a><span class="line-modified">1623         start = CurrentTimeMicros();</span>
1624     }
1625     NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls,
1626                 &quot;checkAndLoadMain&quot;,
1627                 &quot;(ZILjava/lang/String;)Ljava/lang/Class;&quot;));
1628 
1629     NULL_CHECK0(str = NewPlatformString(env, name));
1630     NULL_CHECK0(result = (*env)-&gt;CallStaticObjectMethod(env, cls, mid,
1631                                                         USE_STDERR, mode, str));
1632 
1633     if (JLI_IsTraceLauncher()) {
<a name="7" id="anc7"></a><span class="line-modified">1634         end = CurrentTimeMicros();</span>
<span class="line-modified">1635         printf(&quot;%ld micro seconds to load main class\n&quot;, (long)(end-start));</span>

1636         printf(&quot;----%s----\n&quot;, JLDEBUG_ENV_ENTRY);
1637     }
1638 
1639     return (jclass)result;
1640 }
1641 
1642 static jclass
1643 GetApplicationClass(JNIEnv *env)
1644 {
1645     jmethodID mid;
1646     jclass appClass;
1647     jclass cls = GetLauncherHelperClass(env);
1648     NULL_CHECK0(cls);
1649     NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls,
1650                 &quot;getApplicationClass&quot;,
1651                 &quot;()Ljava/lang/Class;&quot;));
1652 
1653     appClass = (*env)-&gt;CallStaticObjectMethod(env, cls, mid);
1654     CHECK_EXCEPTION_RETURN_VALUE(0);
1655     return appClass;
1656 }
1657 
1658 static char* expandWildcardOnLongOpt(char* arg) {
1659     char *p, *value;
1660     size_t optLen, valueLen;
1661     p = JLI_StrChr(arg, &#39;=&#39;);
1662 
1663     if (p == NULL || p[1] == &#39;\0&#39;) {
1664         JLI_ReportErrorMessage(ARG_ERROR1, arg);
1665         exit(1);
1666     }
1667     p++;
1668     value = (char *) JLI_WildcardExpandClasspath(p);
1669     if (p == value) {
1670         // no wildcard
1671         return arg;
1672     }
1673 
1674     optLen = p - arg;
1675     valueLen = JLI_StrLen(value);
1676     p = JLI_MemAlloc(optLen + valueLen + 1);
1677     memcpy(p, arg, optLen);
1678     memcpy(p + optLen, value, valueLen);
1679     p[optLen + valueLen] = &#39;\0&#39;;
1680     return p;
1681 }
1682 
1683 /*
1684  * For tools, convert command line args thus:
1685  *   javac -cp foo:foo/&quot;*&quot; -J-ms32m ...
1686  *   java -ms32m -cp JLI_WildcardExpandClasspath(foo:foo/&quot;*&quot;) ...
1687  *
1688  * Takes 4 parameters, and returns the populated arguments
1689  */
1690 static void
1691 TranslateApplicationArgs(int jargc, const char **jargv, int *pargc, char ***pargv)
1692 {
1693     int argc = *pargc;
1694     char **argv = *pargv;
1695     int nargc = argc + jargc;
1696     char **nargv = JLI_MemAlloc((nargc + 1) * sizeof(char *));
1697     int i;
1698 
1699     *pargc = nargc;
1700     *pargv = nargv;
1701 
1702     /* Copy the VM arguments (i.e. prefixed with -J) */
1703     for (i = 0; i &lt; jargc; i++) {
1704         const char *arg = jargv[i];
1705         if (arg[0] == &#39;-&#39; &amp;&amp; arg[1] == &#39;J&#39;) {
1706             *nargv++ = ((arg + 2) == NULL) ? NULL : JLI_StringDup(arg + 2);
1707         }
1708     }
1709 
1710     for (i = 0; i &lt; argc; i++) {
1711         char *arg = argv[i];
1712         if (arg[0] == &#39;-&#39; &amp;&amp; arg[1] == &#39;J&#39;) {
1713             if (arg[2] == &#39;\0&#39;) {
1714                 JLI_ReportErrorMessage(ARG_ERROR3);
1715                 exit(1);
1716             }
1717             *nargv++ = arg + 2;
1718         }
1719     }
1720 
1721     /* Copy the rest of the arguments */
1722     for (i = 0; i &lt; jargc ; i++) {
1723         const char *arg = jargv[i];
1724         if (arg[0] != &#39;-&#39; || arg[1] != &#39;J&#39;) {
1725             *nargv++ = (arg == NULL) ? NULL : JLI_StringDup(arg);
1726         }
1727     }
1728     for (i = 0; i &lt; argc; i++) {
1729         char *arg = argv[i];
1730         if (arg[0] == &#39;-&#39;) {
1731             if (arg[1] == &#39;J&#39;)
1732                 continue;
1733             if (IsWildCardEnabled()) {
1734                 if (IsClassPathOption(arg) &amp;&amp; i &lt; argc - 1) {
1735                     *nargv++ = arg;
1736                     *nargv++ = (char *) JLI_WildcardExpandClasspath(argv[i+1]);
1737                     i++;
1738                     continue;
1739                 }
1740                 if (JLI_StrCCmp(arg, &quot;--class-path=&quot;) == 0) {
1741                     *nargv++ = expandWildcardOnLongOpt(arg);
1742                     continue;
1743                 }
1744             }
1745         }
1746         *nargv++ = arg;
1747     }
1748     *nargv = 0;
1749 }
1750 
1751 /*
1752  * For our tools, we try to add 3 VM options:
1753  *      -Denv.class.path=&lt;envcp&gt;
1754  *      -Dapplication.home=&lt;apphome&gt;
1755  *      -Djava.class.path=&lt;appcp&gt;
1756  * &lt;envcp&gt;   is the user&#39;s setting of CLASSPATH -- for instance the user
1757  *           tells javac where to find binary classes through this environment
1758  *           variable.  Notice that users will be able to compile against our
1759  *           tools classes (sun.tools.javac.Main) only if they explicitly add
1760  *           tools.jar to CLASSPATH.
1761  * &lt;apphome&gt; is the directory where the application is installed.
1762  * &lt;appcp&gt;   is the classpath to where our apps&#39; classfiles are.
1763  */
1764 static jboolean
1765 AddApplicationOptions(int cpathc, const char **cpathv)
1766 {
1767     char *envcp, *appcp, *apphome;
1768     char home[MAXPATHLEN]; /* application home */
1769     char separator[] = { PATH_SEPARATOR, &#39;\0&#39; };
1770     int size, i;
1771 
1772     {
1773         const char *s = getenv(&quot;CLASSPATH&quot;);
1774         if (s) {
1775             s = (char *) JLI_WildcardExpandClasspath(s);
1776             /* 40 for -Denv.class.path= */
1777             if (JLI_StrLen(s) + 40 &gt; JLI_StrLen(s)) { // Safeguard from overflow
1778                 envcp = (char *)JLI_MemAlloc(JLI_StrLen(s) + 40);
1779                 sprintf(envcp, &quot;-Denv.class.path=%s&quot;, s);
1780                 AddOption(envcp, NULL);
1781             }
1782         }
1783     }
1784 
1785     if (!GetApplicationHome(home, sizeof(home))) {
1786         JLI_ReportErrorMessage(CFG_ERROR5);
1787         return JNI_FALSE;
1788     }
1789 
1790     /* 40 for &#39;-Dapplication.home=&#39; */
1791     apphome = (char *)JLI_MemAlloc(JLI_StrLen(home) + 40);
1792     sprintf(apphome, &quot;-Dapplication.home=%s&quot;, home);
1793     AddOption(apphome, NULL);
1794 
1795     /* How big is the application&#39;s classpath? */
1796     if (cpathc &gt; 0) {
1797         size = 40;                                 /* 40: &quot;-Djava.class.path=&quot; */
1798         for (i = 0; i &lt; cpathc; i++) {
1799             size += (int)JLI_StrLen(home) + (int)JLI_StrLen(cpathv[i]) + 1; /* 1: separator */
1800         }
1801         appcp = (char *)JLI_MemAlloc(size + 1);
1802         JLI_StrCpy(appcp, &quot;-Djava.class.path=&quot;);
1803         for (i = 0; i &lt; cpathc; i++) {
1804             JLI_StrCat(appcp, home);                        /* c:\program files\myapp */
1805             JLI_StrCat(appcp, cpathv[i]);           /* \lib\myapp.jar         */
1806             JLI_StrCat(appcp, separator);           /* ;                      */
1807         }
1808         appcp[JLI_StrLen(appcp)-1] = &#39;\0&#39;;  /* remove trailing path separator */
1809         AddOption(appcp, NULL);
1810     }
1811     return JNI_TRUE;
1812 }
1813 
1814 /*
1815  * inject the -Dsun.java.command pseudo property into the args structure
1816  * this pseudo property is used in the HotSpot VM to expose the
1817  * Java class name and arguments to the main method to the VM. The
1818  * HotSpot VM uses this pseudo property to store the Java class name
1819  * (or jar file name) and the arguments to the class&#39;s main method
1820  * to the instrumentation memory region. The sun.java.command pseudo
1821  * property is not exported by HotSpot to the Java layer.
1822  */
1823 void
1824 SetJavaCommandLineProp(char *what, int argc, char **argv)
1825 {
1826 
1827     int i = 0;
1828     size_t len = 0;
1829     char* javaCommand = NULL;
1830     char* dashDstr = &quot;-Dsun.java.command=&quot;;
1831 
1832     if (what == NULL) {
1833         /* unexpected, one of these should be set. just return without
1834          * setting the property
1835          */
1836         return;
1837     }
1838 
1839     /* determine the amount of memory to allocate assuming
1840      * the individual components will be space separated
1841      */
1842     len = JLI_StrLen(what);
1843     for (i = 0; i &lt; argc; i++) {
1844         len += JLI_StrLen(argv[i]) + 1;
1845     }
1846 
1847     /* allocate the memory */
1848     javaCommand = (char*) JLI_MemAlloc(len + JLI_StrLen(dashDstr) + 1);
1849 
1850     /* build the -D string */
1851     *javaCommand = &#39;\0&#39;;
1852     JLI_StrCat(javaCommand, dashDstr);
1853     JLI_StrCat(javaCommand, what);
1854 
1855     for (i = 0; i &lt; argc; i++) {
1856         /* the components of the string are space separated. In
1857          * the case of embedded white space, the relationship of
1858          * the white space separated components to their true
1859          * positional arguments will be ambiguous. This issue may
1860          * be addressed in a future release.
1861          */
1862         JLI_StrCat(javaCommand, &quot; &quot;);
1863         JLI_StrCat(javaCommand, argv[i]);
1864     }
1865 
1866     AddOption(javaCommand, NULL);
1867 }
1868 
1869 /*
1870  * JVM would like to know if it&#39;s created by a standard Sun launcher, or by
1871  * user native application, the following property indicates the former.
1872  */
1873 static void SetJavaLauncherProp() {
1874   AddOption(&quot;-Dsun.java.launcher=SUN_STANDARD&quot;, NULL);
1875 }
1876 
1877 /*
1878  * Prints the version information from the java.version and other properties.
1879  */
1880 static void
1881 PrintJavaVersion(JNIEnv *env, jboolean extraLF)
1882 {
1883     jclass ver;
1884     jmethodID print;
1885 
1886     NULL_CHECK(ver = FindBootStrapClass(env, &quot;java/lang/VersionProps&quot;));
1887     NULL_CHECK(print = (*env)-&gt;GetStaticMethodID(env,
1888                                                  ver,
1889                                                  (extraLF == JNI_TRUE) ? &quot;println&quot; : &quot;print&quot;,
1890                                                  &quot;(Z)V&quot;
1891                                                  )
1892               );
1893 
1894     (*env)-&gt;CallStaticVoidMethod(env, ver, print, printTo);
1895 }
1896 
1897 /*
1898  * Prints all the Java settings, see the java implementation for more details.
1899  */
1900 static void
1901 ShowSettings(JNIEnv *env, char *optString)
1902 {
1903     jmethodID showSettingsID;
1904     jstring joptString;
1905     jclass cls = GetLauncherHelperClass(env);
1906     NULL_CHECK(cls);
1907     NULL_CHECK(showSettingsID = (*env)-&gt;GetStaticMethodID(env, cls,
1908             &quot;showSettings&quot;, &quot;(ZLjava/lang/String;JJJ)V&quot;));
1909     NULL_CHECK(joptString = (*env)-&gt;NewStringUTF(env, optString));
1910     (*env)-&gt;CallStaticVoidMethod(env, cls, showSettingsID,
1911                                  USE_STDERR,
1912                                  joptString,
1913                                  (jlong)initialHeapSize,
1914                                  (jlong)maxHeapSize,
1915                                  (jlong)threadStackSize);
1916 }
1917 
1918 /**
1919  * Show resolved modules
1920  */
1921 static void
1922 ShowResolvedModules(JNIEnv *env)
1923 {
1924     jmethodID showResolvedModulesID;
1925     jclass cls = GetLauncherHelperClass(env);
1926     NULL_CHECK(cls);
1927     NULL_CHECK(showResolvedModulesID = (*env)-&gt;GetStaticMethodID(env, cls,
1928             &quot;showResolvedModules&quot;, &quot;()V&quot;));
1929     (*env)-&gt;CallStaticVoidMethod(env, cls, showResolvedModulesID);
1930 }
1931 
1932 /**
1933  * List observable modules
1934  */
1935 static void
1936 ListModules(JNIEnv *env)
1937 {
1938     jmethodID listModulesID;
1939     jclass cls = GetLauncherHelperClass(env);
1940     NULL_CHECK(cls);
1941     NULL_CHECK(listModulesID = (*env)-&gt;GetStaticMethodID(env, cls,
1942             &quot;listModules&quot;, &quot;()V&quot;));
1943     (*env)-&gt;CallStaticVoidMethod(env, cls, listModulesID);
1944 }
1945 
1946 /**
1947  * Describe a module
1948  */
1949 static void
1950 DescribeModule(JNIEnv *env, char *optString)
1951 {
1952     jmethodID describeModuleID;
1953     jstring joptString = NULL;
1954     jclass cls = GetLauncherHelperClass(env);
1955     NULL_CHECK(cls);
1956     NULL_CHECK(describeModuleID = (*env)-&gt;GetStaticMethodID(env, cls,
1957             &quot;describeModule&quot;, &quot;(Ljava/lang/String;)V&quot;));
1958     NULL_CHECK(joptString = NewPlatformString(env, optString));
1959     (*env)-&gt;CallStaticVoidMethod(env, cls, describeModuleID, joptString);
1960 }
1961 
1962 /*
1963  * Prints default usage or the Xusage message, see sun.launcher.LauncherHelper.java
1964  */
1965 static void
1966 PrintUsage(JNIEnv* env, jboolean doXUsage)
1967 {
1968   jmethodID initHelp, vmSelect, vmSynonym, printHelp, printXUsageMessage;
1969   jstring jprogname, vm1, vm2;
1970   int i;
1971   jclass cls = GetLauncherHelperClass(env);
1972   NULL_CHECK(cls);
1973   if (doXUsage) {
1974     NULL_CHECK(printXUsageMessage = (*env)-&gt;GetStaticMethodID(env, cls,
1975                                         &quot;printXUsageMessage&quot;, &quot;(Z)V&quot;));
1976     (*env)-&gt;CallStaticVoidMethod(env, cls, printXUsageMessage, printTo);
1977   } else {
1978     NULL_CHECK(initHelp = (*env)-&gt;GetStaticMethodID(env, cls,
1979                                         &quot;initHelpMessage&quot;, &quot;(Ljava/lang/String;)V&quot;));
1980 
1981     NULL_CHECK(vmSelect = (*env)-&gt;GetStaticMethodID(env, cls, &quot;appendVmSelectMessage&quot;,
1982                                         &quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;));
1983 
1984     NULL_CHECK(vmSynonym = (*env)-&gt;GetStaticMethodID(env, cls,
1985                                         &quot;appendVmSynonymMessage&quot;,
1986                                         &quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;));
1987 
1988     NULL_CHECK(printHelp = (*env)-&gt;GetStaticMethodID(env, cls,
1989                                         &quot;printHelpMessage&quot;, &quot;(Z)V&quot;));
1990 
1991     NULL_CHECK(jprogname = (*env)-&gt;NewStringUTF(env, _program_name));
1992 
1993     /* Initialize the usage message with the usual preamble */
1994     (*env)-&gt;CallStaticVoidMethod(env, cls, initHelp, jprogname);
1995     CHECK_EXCEPTION_RETURN();
1996 
1997 
1998     /* Assemble the other variant part of the usage */
1999     for (i=1; i&lt;knownVMsCount; i++) {
2000       if (knownVMs[i].flag == VM_KNOWN) {
2001         NULL_CHECK(vm1 =  (*env)-&gt;NewStringUTF(env, knownVMs[i].name));
2002         NULL_CHECK(vm2 =  (*env)-&gt;NewStringUTF(env, knownVMs[i].name+1));
2003         (*env)-&gt;CallStaticVoidMethod(env, cls, vmSelect, vm1, vm2);
2004         CHECK_EXCEPTION_RETURN();
2005       }
2006     }
2007     for (i=1; i&lt;knownVMsCount; i++) {
2008       if (knownVMs[i].flag == VM_ALIASED_TO) {
2009         NULL_CHECK(vm1 =  (*env)-&gt;NewStringUTF(env, knownVMs[i].name));
2010         NULL_CHECK(vm2 =  (*env)-&gt;NewStringUTF(env, knownVMs[i].alias+1));
2011         (*env)-&gt;CallStaticVoidMethod(env, cls, vmSynonym, vm1, vm2);
2012         CHECK_EXCEPTION_RETURN();
2013       }
2014     }
2015 
2016     /* Complete the usage message and print to stderr*/
2017     (*env)-&gt;CallStaticVoidMethod(env, cls, printHelp, printTo);
2018   }
2019   return;
2020 }
2021 
2022 /*
2023  * Read the jvm.cfg file and fill the knownJVMs[] array.
2024  *
2025  * The functionality of the jvm.cfg file is subject to change without
2026  * notice and the mechanism will be removed in the future.
2027  *
2028  * The lexical structure of the jvm.cfg file is as follows:
2029  *
2030  *     jvmcfg         :=  { vmLine }
2031  *     vmLine         :=  knownLine
2032  *                    |   aliasLine
2033  *                    |   warnLine
2034  *                    |   ignoreLine
2035  *                    |   errorLine
2036  *                    |   predicateLine
2037  *                    |   commentLine
2038  *     knownLine      :=  flag  &quot;KNOWN&quot;                  EOL
2039  *     warnLine       :=  flag  &quot;WARN&quot;                   EOL
2040  *     ignoreLine     :=  flag  &quot;IGNORE&quot;                 EOL
2041  *     errorLine      :=  flag  &quot;ERROR&quot;                  EOL
2042  *     aliasLine      :=  flag  &quot;ALIASED_TO&quot;       flag  EOL
2043  *     predicateLine  :=  flag  &quot;IF_SERVER_CLASS&quot;  flag  EOL
2044  *     commentLine    :=  &quot;#&quot; text                       EOL
2045  *     flag           :=  &quot;-&quot; identifier
2046  *
2047  * The semantics are that when someone specifies a flag on the command line:
2048  * - if the flag appears on a knownLine, then the identifier is used as
2049  *   the name of the directory holding the JVM library (the name of the JVM).
2050  * - if the flag appears as the first flag on an aliasLine, the identifier
2051  *   of the second flag is used as the name of the JVM.
2052  * - if the flag appears on a warnLine, the identifier is used as the
2053  *   name of the JVM, but a warning is generated.
2054  * - if the flag appears on an ignoreLine, the identifier is recognized as the
2055  *   name of a JVM, but the identifier is ignored and the default vm used
2056  * - if the flag appears on an errorLine, an error is generated.
2057  * - if the flag appears as the first flag on a predicateLine, and
2058  *   the machine on which you are running passes the predicate indicated,
2059  *   then the identifier of the second flag is used as the name of the JVM,
2060  *   otherwise the identifier of the first flag is used as the name of the JVM.
2061  * If no flag is given on the command line, the first vmLine of the jvm.cfg
2062  * file determines the name of the JVM.
2063  * PredicateLines are only interpreted on first vmLine of a jvm.cfg file,
2064  * since they only make sense if someone hasn&#39;t specified the name of the
2065  * JVM on the command line.
2066  *
2067  * The intent of the jvm.cfg file is to allow several JVM libraries to
2068  * be installed in different subdirectories of a single JRE installation,
2069  * for space-savings and convenience in testing.
2070  * The intent is explicitly not to provide a full aliasing or predicate
2071  * mechanism.
2072  */
2073 jint
2074 ReadKnownVMs(const char *jvmCfgName, jboolean speculative)
2075 {
2076     FILE *jvmCfg;
2077     char line[MAXPATHLEN+20];
2078     int cnt = 0;
2079     int lineno = 0;
2080     jlong start = 0, end = 0;
2081     int vmType;
2082     char *tmpPtr;
2083     char *altVMName = NULL;
2084     char *serverClassVMName = NULL;
2085     static char *whiteSpace = &quot; \t&quot;;
2086     if (JLI_IsTraceLauncher()) {
<a name="8" id="anc8"></a><span class="line-modified">2087         start = CurrentTimeMicros();</span>
2088     }
2089 
2090     jvmCfg = fopen(jvmCfgName, &quot;r&quot;);
2091     if (jvmCfg == NULL) {
2092       if (!speculative) {
2093         JLI_ReportErrorMessage(CFG_ERROR6, jvmCfgName);
2094         exit(1);
2095       } else {
2096         return -1;
2097       }
2098     }
2099     while (fgets(line, sizeof(line), jvmCfg) != NULL) {
2100         vmType = VM_UNKNOWN;
2101         lineno++;
2102         if (line[0] == &#39;#&#39;)
2103             continue;
2104         if (line[0] != &#39;-&#39;) {
2105             JLI_ReportErrorMessage(CFG_WARN2, lineno, jvmCfgName);
2106         }
2107         if (cnt &gt;= knownVMsLimit) {
2108             GrowKnownVMs(cnt);
2109         }
2110         line[JLI_StrLen(line)-1] = &#39;\0&#39;; /* remove trailing newline */
2111         tmpPtr = line + JLI_StrCSpn(line, whiteSpace);
2112         if (*tmpPtr == 0) {
2113             JLI_ReportErrorMessage(CFG_WARN3, lineno, jvmCfgName);
2114         } else {
2115             /* Null-terminate this string for JLI_StringDup below */
2116             *tmpPtr++ = 0;
2117             tmpPtr += JLI_StrSpn(tmpPtr, whiteSpace);
2118             if (*tmpPtr == 0) {
2119                 JLI_ReportErrorMessage(CFG_WARN3, lineno, jvmCfgName);
2120             } else {
2121                 if (!JLI_StrCCmp(tmpPtr, &quot;KNOWN&quot;)) {
2122                     vmType = VM_KNOWN;
2123                 } else if (!JLI_StrCCmp(tmpPtr, &quot;ALIASED_TO&quot;)) {
2124                     tmpPtr += JLI_StrCSpn(tmpPtr, whiteSpace);
2125                     if (*tmpPtr != 0) {
2126                         tmpPtr += JLI_StrSpn(tmpPtr, whiteSpace);
2127                     }
2128                     if (*tmpPtr == 0) {
2129                         JLI_ReportErrorMessage(CFG_WARN3, lineno, jvmCfgName);
2130                     } else {
2131                         /* Null terminate altVMName */
2132                         altVMName = tmpPtr;
2133                         tmpPtr += JLI_StrCSpn(tmpPtr, whiteSpace);
2134                         *tmpPtr = 0;
2135                         vmType = VM_ALIASED_TO;
2136                     }
2137                 } else if (!JLI_StrCCmp(tmpPtr, &quot;WARN&quot;)) {
2138                     vmType = VM_WARN;
2139                 } else if (!JLI_StrCCmp(tmpPtr, &quot;IGNORE&quot;)) {
2140                     vmType = VM_IGNORE;
2141                 } else if (!JLI_StrCCmp(tmpPtr, &quot;ERROR&quot;)) {
2142                     vmType = VM_ERROR;
2143                 } else if (!JLI_StrCCmp(tmpPtr, &quot;IF_SERVER_CLASS&quot;)) {
2144                     /* ignored */
2145                 } else {
2146                     JLI_ReportErrorMessage(CFG_WARN5, lineno, &amp;jvmCfgName[0]);
2147                     vmType = VM_KNOWN;
2148                 }
2149             }
2150         }
2151 
2152         JLI_TraceLauncher(&quot;jvm.cfg[%d] = -&gt;%s&lt;-\n&quot;, cnt, line);
2153         if (vmType != VM_UNKNOWN) {
2154             knownVMs[cnt].name = JLI_StringDup(line);
2155             knownVMs[cnt].flag = vmType;
2156             switch (vmType) {
2157             default:
2158                 break;
2159             case VM_ALIASED_TO:
2160                 knownVMs[cnt].alias = JLI_StringDup(altVMName);
2161                 JLI_TraceLauncher(&quot;    name: %s  vmType: %s  alias: %s\n&quot;,
2162                    knownVMs[cnt].name, &quot;VM_ALIASED_TO&quot;, knownVMs[cnt].alias);
2163                 break;
2164             }
2165             cnt++;
2166         }
2167     }
2168     fclose(jvmCfg);
2169     knownVMsCount = cnt;
2170 
2171     if (JLI_IsTraceLauncher()) {
<a name="9" id="anc9"></a><span class="line-modified">2172         end = CurrentTimeMicros();</span>
<span class="line-modified">2173         printf(&quot;%ld micro seconds to parse jvm.cfg\n&quot;, (long)(end-start));</span>

2174     }
2175 
2176     return cnt;
2177 }
2178 
2179 
2180 static void
2181 GrowKnownVMs(int minimum)
2182 {
2183     struct vmdesc* newKnownVMs;
2184     int newMax;
2185 
2186     newMax = (knownVMsLimit == 0 ? INIT_MAX_KNOWN_VMS : (2 * knownVMsLimit));
2187     if (newMax &lt;= minimum) {
2188         newMax = minimum;
2189     }
2190     newKnownVMs = (struct vmdesc*) JLI_MemAlloc(newMax * sizeof(struct vmdesc));
2191     if (knownVMs != NULL) {
2192         memcpy(newKnownVMs, knownVMs, knownVMsLimit * sizeof(struct vmdesc));
2193     }
2194     JLI_MemFree(knownVMs);
2195     knownVMs = newKnownVMs;
2196     knownVMsLimit = newMax;
2197 }
2198 
2199 
2200 /* Returns index of VM or -1 if not found */
2201 static int
2202 KnownVMIndex(const char* name)
2203 {
2204     int i;
2205     if (JLI_StrCCmp(name, &quot;-J&quot;) == 0) name += 2;
2206     for (i = 0; i &lt; knownVMsCount; i++) {
2207         if (!JLI_StrCmp(name, knownVMs[i].name)) {
2208             return i;
2209         }
2210     }
2211     return -1;
2212 }
2213 
2214 static void
2215 FreeKnownVMs()
2216 {
2217     int i;
2218     for (i = 0; i &lt; knownVMsCount; i++) {
2219         JLI_MemFree(knownVMs[i].name);
2220         knownVMs[i].name = NULL;
2221     }
2222     JLI_MemFree(knownVMs);
2223 }
2224 
2225 /*
2226  * Displays the splash screen according to the jar file name
2227  * and image file names stored in environment variables
2228  */
2229 void
2230 ShowSplashScreen()
2231 {
2232     const char *jar_name = getenv(SPLASH_JAR_ENV_ENTRY);
2233     const char *file_name = getenv(SPLASH_FILE_ENV_ENTRY);
2234     int data_size;
2235     void *image_data = NULL;
2236     float scale_factor = 1;
2237     char *scaled_splash_name = NULL;
2238     jboolean isImageScaled = JNI_FALSE;
2239     size_t maxScaledImgNameLength = 0;
2240     if (file_name == NULL){
2241         return;
2242     }
2243 
2244     if (!DoSplashInit()) {
2245         goto exit;
2246     }
2247 
2248     maxScaledImgNameLength = DoSplashGetScaledImgNameMaxPstfixLen(file_name);
2249 
2250     scaled_splash_name = JLI_MemAlloc(
2251                             maxScaledImgNameLength * sizeof(char));
2252     isImageScaled = DoSplashGetScaledImageName(jar_name, file_name,
2253                             &amp;scale_factor,
2254                             scaled_splash_name, maxScaledImgNameLength);
2255     if (jar_name) {
2256 
2257         if (isImageScaled) {
2258             image_data = JLI_JarUnpackFile(
2259                     jar_name, scaled_splash_name, &amp;data_size);
2260         }
2261 
2262         if (!image_data) {
2263             scale_factor = 1;
2264             image_data = JLI_JarUnpackFile(
2265                             jar_name, file_name, &amp;data_size);
2266         }
2267         if (image_data) {
2268             DoSplashSetScaleFactor(scale_factor);
2269             DoSplashLoadMemory(image_data, data_size);
2270             JLI_MemFree(image_data);
2271         } else {
2272             DoSplashClose();
2273         }
2274     } else {
2275         if (isImageScaled) {
2276             DoSplashSetScaleFactor(scale_factor);
2277             DoSplashLoadFile(scaled_splash_name);
2278         } else {
2279             DoSplashLoadFile(file_name);
2280         }
2281     }
2282     JLI_MemFree(scaled_splash_name);
2283 
2284     DoSplashSetFileJarName(file_name, jar_name);
2285 
2286     exit:
2287     /*
2288      * Done with all command line processing and potential re-execs so
2289      * clean up the environment.
2290      */
2291     (void)UnsetEnv(ENV_ENTRY);
2292     (void)UnsetEnv(SPLASH_FILE_ENV_ENTRY);
2293     (void)UnsetEnv(SPLASH_JAR_ENV_ENTRY);
2294 
2295     JLI_MemFree(splash_jar_entry);
2296     JLI_MemFree(splash_file_entry);
2297 
2298 }
2299 
2300 static const char* GetFullVersion()
2301 {
2302     return _fVersion;
2303 }
2304 
2305 static const char* GetProgramName()
2306 {
2307     return _program_name;
2308 }
2309 
2310 static const char* GetLauncherName()
2311 {
2312     return _launcher_name;
2313 }
2314 
2315 static jboolean IsJavaArgs()
2316 {
2317     return _is_java_args;
2318 }
2319 
2320 static jboolean
2321 IsWildCardEnabled()
2322 {
2323     return _wc_enabled;
2324 }
2325 
2326 int
2327 ContinueInNewThread(InvocationFunctions* ifn, jlong threadStackSize,
2328                     int argc, char **argv,
2329                     int mode, char *what, int ret)
2330 {
2331     if (threadStackSize == 0) {
2332         /*
2333          * If the user hasn&#39;t specified a non-zero stack size ask the JVM for its default.
2334          * A returned 0 means &#39;use the system default&#39; for a platform, e.g., Windows.
2335          * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will
2336          * return its default stack size through the init args structure.
2337          */
2338         struct JDK1_1InitArgs args1_1;
2339         memset((void*)&amp;args1_1, 0, sizeof(args1_1));
2340         args1_1.version = JNI_VERSION_1_1;
2341         ifn-&gt;GetDefaultJavaVMInitArgs(&amp;args1_1);  /* ignore return value */
2342         if (args1_1.javaStackSize &gt; 0) {
2343             threadStackSize = args1_1.javaStackSize;
2344         }
2345     }
2346 
2347     { /* Create a new thread to create JVM and invoke main method */
2348         JavaMainArgs args;
2349         int rslt;
2350 
2351         args.argc = argc;
2352         args.argv = argv;
2353         args.mode = mode;
2354         args.what = what;
2355         args.ifn = *ifn;
2356 
2357         rslt = CallJavaMainInNewThread(threadStackSize, (void*)&amp;args);
2358         /* If the caller has deemed there is an error we
2359          * simply return that, otherwise we return the value of
2360          * the callee
2361          */
2362         return (ret != 0) ? ret : rslt;
2363     }
2364 }
2365 
2366 static void
2367 DumpState()
2368 {
2369     if (!JLI_IsTraceLauncher()) return ;
2370     printf(&quot;Launcher state:\n&quot;);
2371     printf(&quot;\tFirst application arg index: %d\n&quot;, JLI_GetAppArgIndex());
2372     printf(&quot;\tdebug:%s\n&quot;, (JLI_IsTraceLauncher() == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2373     printf(&quot;\tjavargs:%s\n&quot;, (_is_java_args == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2374     printf(&quot;\tprogram name:%s\n&quot;, GetProgramName());
2375     printf(&quot;\tlauncher name:%s\n&quot;, GetLauncherName());
2376     printf(&quot;\tjavaw:%s\n&quot;, (IsJavaw() == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2377     printf(&quot;\tfullversion:%s\n&quot;, GetFullVersion());
2378 }
2379 
2380 /*
2381  * A utility procedure to always print to stderr
2382  */
2383 JNIEXPORT void JNICALL
2384 JLI_ReportMessage(const char* fmt, ...)
2385 {
2386     va_list vl;
2387     va_start(vl, fmt);
2388     vfprintf(stderr, fmt, vl);
2389     fprintf(stderr, &quot;\n&quot;);
2390     va_end(vl);
2391 }
2392 
2393 /*
2394  * A utility procedure to always print to stdout
2395  */
2396 void
2397 JLI_ShowMessage(const char* fmt, ...)
2398 {
2399     va_list vl;
2400     va_start(vl, fmt);
2401     vfprintf(stdout, fmt, vl);
2402     fprintf(stdout, &quot;\n&quot;);
2403     va_end(vl);
2404 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
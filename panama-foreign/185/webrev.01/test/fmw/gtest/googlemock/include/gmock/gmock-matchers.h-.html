<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/googlemock/include/gmock/gmock-matchers.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Copyright 2007, Google Inc.
   2 // All rights reserved.
   3 //
   4 // Redistribution and use in source and binary forms, with or without
   5 // modification, are permitted provided that the following conditions are
   6 // met:
   7 //
   8 //     * Redistributions of source code must retain the above copyright
   9 // notice, this list of conditions and the following disclaimer.
  10 //     * Redistributions in binary form must reproduce the above
  11 // copyright notice, this list of conditions and the following disclaimer
  12 // in the documentation and/or other materials provided with the
  13 // distribution.
  14 //     * Neither the name of Google Inc. nor the names of its
  15 // contributors may be used to endorse or promote products derived from
  16 // this software without specific prior written permission.
  17 //
  18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29 
  30 
  31 // Google Mock - a framework for writing C++ mock classes.
  32 //
  33 // This file implements some commonly used argument matchers.  More
  34 // matchers can be defined by the user implementing the
  35 // MatcherInterface&lt;T&gt; interface if necessary.
  36 
  37 // GOOGLETEST_CM0002 DO NOT DELETE
  38 
  39 #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_
  40 #define GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_
  41 
  42 #include &lt;math.h&gt;
  43 #include &lt;algorithm&gt;
  44 #include &lt;iterator&gt;
  45 #include &lt;limits&gt;
  46 #include &lt;ostream&gt;  // NOLINT
  47 #include &lt;sstream&gt;
  48 #include &lt;string&gt;
  49 #include &lt;utility&gt;
  50 #include &lt;vector&gt;
  51 #include &quot;gtest/gtest.h&quot;
  52 #include &quot;gmock/internal/gmock-internal-utils.h&quot;
  53 #include &quot;gmock/internal/gmock-port.h&quot;
  54 
  55 #if GTEST_HAS_STD_INITIALIZER_LIST_
  56 # include &lt;initializer_list&gt;  // NOLINT -- must be after gtest.h
  57 #endif
  58 
  59 #if _MSC_VER &gt;= 1900
  60 GTEST_DISABLE_MSC_WARNINGS_PUSH_(
  61     4251 5046 /* class A needs to have dll-interface to be used by clients of
  62                  class B */
  63     /* Symbol involving type with internal linkage not defined */)
  64 #else //Pragma 5046 doesn&#39;t exist in version of MSC prior to 1900
  65 GTEST_DISABLE_MSC_WARNINGS_PUSH_(
  66     4251 /* class A needs to have dll-interface to be used by clients of
  67                  class B */
  68     /* Symbol involving type with internal linkage not defined */)
  69 #endif
  70 namespace testing {
  71 
  72 // To implement a matcher Foo for type T, define:
  73 //   1. a class FooMatcherImpl that implements the
  74 //      MatcherInterface&lt;T&gt; interface, and
  75 //   2. a factory function that creates a Matcher&lt;T&gt; object from a
  76 //      FooMatcherImpl*.
  77 //
  78 // The two-level delegation design makes it possible to allow a user
  79 // to write &quot;v&quot; instead of &quot;Eq(v)&quot; where a Matcher is expected, which
  80 // is impossible if we pass matchers by pointers.  It also eases
  81 // ownership management as Matcher objects can now be copied like
  82 // plain values.
  83 
  84 // MatchResultListener is an abstract class.  Its &lt;&lt; operator can be
  85 // used by a matcher to explain why a value matches or doesn&#39;t match.
  86 //
  87 // FIXME: add method
  88 //   bool InterestedInWhy(bool result) const;
  89 // to indicate whether the listener is interested in why the match
  90 // result is &#39;result&#39;.
  91 class MatchResultListener {
  92  public:
  93   // Creates a listener object with the given underlying ostream.  The
  94   // listener does not own the ostream, and does not dereference it
  95   // in the constructor or destructor.
  96   explicit MatchResultListener(::std::ostream* os) : stream_(os) {}
  97   virtual ~MatchResultListener() = 0;  // Makes this class abstract.
  98 
  99   // Streams x to the underlying ostream; does nothing if the ostream
 100   // is NULL.
 101   template &lt;typename T&gt;
 102   MatchResultListener&amp; operator&lt;&lt;(const T&amp; x) {
 103     if (stream_ != NULL)
 104       *stream_ &lt;&lt; x;
 105     return *this;
 106   }
 107 
 108   // Returns the underlying ostream.
 109   ::std::ostream* stream() { return stream_; }
 110 
 111   // Returns true iff the listener is interested in an explanation of
 112   // the match result.  A matcher&#39;s MatchAndExplain() method can use
 113   // this information to avoid generating the explanation when no one
 114   // intends to hear it.
 115   bool IsInterested() const { return stream_ != NULL; }
 116 
 117  private:
 118   ::std::ostream* const stream_;
 119 
 120   GTEST_DISALLOW_COPY_AND_ASSIGN_(MatchResultListener);
 121 };
 122 
 123 inline MatchResultListener::~MatchResultListener() {
 124 }
 125 
 126 // An instance of a subclass of this knows how to describe itself as a
 127 // matcher.
 128 class MatcherDescriberInterface {
 129  public:
 130   virtual ~MatcherDescriberInterface() {}
 131 
 132   // Describes this matcher to an ostream.  The function should print
 133   // a verb phrase that describes the property a value matching this
 134   // matcher should have.  The subject of the verb phrase is the value
 135   // being matched.  For example, the DescribeTo() method of the Gt(7)
 136   // matcher prints &quot;is greater than 7&quot;.
 137   virtual void DescribeTo(::std::ostream* os) const = 0;
 138 
 139   // Describes the negation of this matcher to an ostream.  For
 140   // example, if the description of this matcher is &quot;is greater than
 141   // 7&quot;, the negated description could be &quot;is not greater than 7&quot;.
 142   // You are not required to override this when implementing
 143   // MatcherInterface, but it is highly advised so that your matcher
 144   // can produce good error messages.
 145   virtual void DescribeNegationTo(::std::ostream* os) const {
 146     *os &lt;&lt; &quot;not (&quot;;
 147     DescribeTo(os);
 148     *os &lt;&lt; &quot;)&quot;;
 149   }
 150 };
 151 
 152 // The implementation of a matcher.
 153 template &lt;typename T&gt;
 154 class MatcherInterface : public MatcherDescriberInterface {
 155  public:
 156   // Returns true iff the matcher matches x; also explains the match
 157   // result to &#39;listener&#39; if necessary (see the next paragraph), in
 158   // the form of a non-restrictive relative clause (&quot;which ...&quot;,
 159   // &quot;whose ...&quot;, etc) that describes x.  For example, the
 160   // MatchAndExplain() method of the Pointee(...) matcher should
 161   // generate an explanation like &quot;which points to ...&quot;.
 162   //
 163   // Implementations of MatchAndExplain() should add an explanation of
 164   // the match result *if and only if* they can provide additional
 165   // information that&#39;s not already present (or not obvious) in the
 166   // print-out of x and the matcher&#39;s description.  Whether the match
 167   // succeeds is not a factor in deciding whether an explanation is
 168   // needed, as sometimes the caller needs to print a failure message
 169   // when the match succeeds (e.g. when the matcher is used inside
 170   // Not()).
 171   //
 172   // For example, a &quot;has at least 10 elements&quot; matcher should explain
 173   // what the actual element count is, regardless of the match result,
 174   // as it is useful information to the reader; on the other hand, an
 175   // &quot;is empty&quot; matcher probably only needs to explain what the actual
 176   // size is when the match fails, as it&#39;s redundant to say that the
 177   // size is 0 when the value is already known to be empty.
 178   //
 179   // You should override this method when defining a new matcher.
 180   //
 181   // It&#39;s the responsibility of the caller (Google Mock) to guarantee
 182   // that &#39;listener&#39; is not NULL.  This helps to simplify a matcher&#39;s
 183   // implementation when it doesn&#39;t care about the performance, as it
 184   // can talk to &#39;listener&#39; without checking its validity first.
 185   // However, in order to implement dummy listeners efficiently,
 186   // listener-&gt;stream() may be NULL.
 187   virtual bool MatchAndExplain(T x, MatchResultListener* listener) const = 0;
 188 
 189   // Inherits these methods from MatcherDescriberInterface:
 190   //   virtual void DescribeTo(::std::ostream* os) const = 0;
 191   //   virtual void DescribeNegationTo(::std::ostream* os) const;
 192 };
 193 
 194 namespace internal {
 195 
 196 // Converts a MatcherInterface&lt;T&gt; to a MatcherInterface&lt;const T&amp;&gt;.
 197 template &lt;typename T&gt;
 198 class MatcherInterfaceAdapter : public MatcherInterface&lt;const T&amp;&gt; {
 199  public:
 200   explicit MatcherInterfaceAdapter(const MatcherInterface&lt;T&gt;* impl)
 201       : impl_(impl) {}
 202   virtual ~MatcherInterfaceAdapter() { delete impl_; }
 203 
 204   virtual void DescribeTo(::std::ostream* os) const { impl_-&gt;DescribeTo(os); }
 205 
 206   virtual void DescribeNegationTo(::std::ostream* os) const {
 207     impl_-&gt;DescribeNegationTo(os);
 208   }
 209 
 210   virtual bool MatchAndExplain(const T&amp; x,
 211                                MatchResultListener* listener) const {
 212     return impl_-&gt;MatchAndExplain(x, listener);
 213   }
 214 
 215  private:
 216   const MatcherInterface&lt;T&gt;* const impl_;
 217 
 218   GTEST_DISALLOW_COPY_AND_ASSIGN_(MatcherInterfaceAdapter);
 219 };
 220 
 221 }  // namespace internal
 222 
 223 // A match result listener that stores the explanation in a string.
 224 class StringMatchResultListener : public MatchResultListener {
 225  public:
 226   StringMatchResultListener() : MatchResultListener(&amp;ss_) {}
 227 
 228   // Returns the explanation accumulated so far.
 229   std::string str() const { return ss_.str(); }
 230 
 231   // Clears the explanation accumulated so far.
 232   void Clear() { ss_.str(&quot;&quot;); }
 233 
 234  private:
 235   ::std::stringstream ss_;
 236 
 237   GTEST_DISALLOW_COPY_AND_ASSIGN_(StringMatchResultListener);
 238 };
 239 
 240 namespace internal {
 241 
 242 struct AnyEq {
 243   template &lt;typename A, typename B&gt;
 244   bool operator()(const A&amp; a, const B&amp; b) const { return a == b; }
 245 };
 246 struct AnyNe {
 247   template &lt;typename A, typename B&gt;
 248   bool operator()(const A&amp; a, const B&amp; b) const { return a != b; }
 249 };
 250 struct AnyLt {
 251   template &lt;typename A, typename B&gt;
 252   bool operator()(const A&amp; a, const B&amp; b) const { return a &lt; b; }
 253 };
 254 struct AnyGt {
 255   template &lt;typename A, typename B&gt;
 256   bool operator()(const A&amp; a, const B&amp; b) const { return a &gt; b; }
 257 };
 258 struct AnyLe {
 259   template &lt;typename A, typename B&gt;
 260   bool operator()(const A&amp; a, const B&amp; b) const { return a &lt;= b; }
 261 };
 262 struct AnyGe {
 263   template &lt;typename A, typename B&gt;
 264   bool operator()(const A&amp; a, const B&amp; b) const { return a &gt;= b; }
 265 };
 266 
 267 // A match result listener that ignores the explanation.
 268 class DummyMatchResultListener : public MatchResultListener {
 269  public:
 270   DummyMatchResultListener() : MatchResultListener(NULL) {}
 271 
 272  private:
 273   GTEST_DISALLOW_COPY_AND_ASSIGN_(DummyMatchResultListener);
 274 };
 275 
 276 // A match result listener that forwards the explanation to a given
 277 // ostream.  The difference between this and MatchResultListener is
 278 // that the former is concrete.
 279 class StreamMatchResultListener : public MatchResultListener {
 280  public:
 281   explicit StreamMatchResultListener(::std::ostream* os)
 282       : MatchResultListener(os) {}
 283 
 284  private:
 285   GTEST_DISALLOW_COPY_AND_ASSIGN_(StreamMatchResultListener);
 286 };
 287 
 288 // An internal class for implementing Matcher&lt;T&gt;, which will derive
 289 // from it.  We put functionalities common to all Matcher&lt;T&gt;
 290 // specializations here to avoid code duplication.
 291 template &lt;typename T&gt;
 292 class MatcherBase {
 293  public:
 294   // Returns true iff the matcher matches x; also explains the match
 295   // result to &#39;listener&#39;.
 296   bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(T) x,
 297                        MatchResultListener* listener) const {
 298     return impl_-&gt;MatchAndExplain(x, listener);
 299   }
 300 
 301   // Returns true iff this matcher matches x.
 302   bool Matches(GTEST_REFERENCE_TO_CONST_(T) x) const {
 303     DummyMatchResultListener dummy;
 304     return MatchAndExplain(x, &amp;dummy);
 305   }
 306 
 307   // Describes this matcher to an ostream.
 308   void DescribeTo(::std::ostream* os) const { impl_-&gt;DescribeTo(os); }
 309 
 310   // Describes the negation of this matcher to an ostream.
 311   void DescribeNegationTo(::std::ostream* os) const {
 312     impl_-&gt;DescribeNegationTo(os);
 313   }
 314 
 315   // Explains why x matches, or doesn&#39;t match, the matcher.
 316   void ExplainMatchResultTo(GTEST_REFERENCE_TO_CONST_(T) x,
 317                             ::std::ostream* os) const {
 318     StreamMatchResultListener listener(os);
 319     MatchAndExplain(x, &amp;listener);
 320   }
 321 
 322   // Returns the describer for this matcher object; retains ownership
 323   // of the describer, which is only guaranteed to be alive when
 324   // this matcher object is alive.
 325   const MatcherDescriberInterface* GetDescriber() const {
 326     return impl_.get();
 327   }
 328 
 329  protected:
 330   MatcherBase() {}
 331 
 332   // Constructs a matcher from its implementation.
 333   explicit MatcherBase(
 334       const MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(T)&gt;* impl)
 335       : impl_(impl) {}
 336 
 337   template &lt;typename U&gt;
 338   explicit MatcherBase(
 339       const MatcherInterface&lt;U&gt;* impl,
 340       typename internal::EnableIf&lt;
 341           !internal::IsSame&lt;U, GTEST_REFERENCE_TO_CONST_(U)&gt;::value&gt;::type* =
 342           NULL)
 343       : impl_(new internal::MatcherInterfaceAdapter&lt;U&gt;(impl)) {}
 344 
 345   virtual ~MatcherBase() {}
 346 
 347  private:
 348   // shared_ptr (util/gtl/shared_ptr.h) and linked_ptr have similar
 349   // interfaces.  The former dynamically allocates a chunk of memory
 350   // to hold the reference count, while the latter tracks all
 351   // references using a circular linked list without allocating
 352   // memory.  It has been observed that linked_ptr performs better in
 353   // typical scenarios.  However, shared_ptr can out-perform
 354   // linked_ptr when there are many more uses of the copy constructor
 355   // than the default constructor.
 356   //
 357   // If performance becomes a problem, we should see if using
 358   // shared_ptr helps.
 359   ::testing::internal::linked_ptr&lt;
 360       const MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(T)&gt; &gt;
 361       impl_;
 362 };
 363 
 364 }  // namespace internal
 365 
 366 // A Matcher&lt;T&gt; is a copyable and IMMUTABLE (except by assignment)
 367 // object that can check whether a value of type T matches.  The
 368 // implementation of Matcher&lt;T&gt; is just a linked_ptr to const
 369 // MatcherInterface&lt;T&gt;, so copying is fairly cheap.  Don&#39;t inherit
 370 // from Matcher!
 371 template &lt;typename T&gt;
 372 class Matcher : public internal::MatcherBase&lt;T&gt; {
 373  public:
 374   // Constructs a null matcher.  Needed for storing Matcher objects in STL
 375   // containers.  A default-constructed matcher is not yet initialized.  You
 376   // cannot use it until a valid value has been assigned to it.
 377   explicit Matcher() {}  // NOLINT
 378 
 379   // Constructs a matcher from its implementation.
 380   explicit Matcher(const MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(T)&gt;* impl)
 381       : internal::MatcherBase&lt;T&gt;(impl) {}
 382 
 383   template &lt;typename U&gt;
 384   explicit Matcher(const MatcherInterface&lt;U&gt;* impl,
 385                    typename internal::EnableIf&lt;!internal::IsSame&lt;
 386                        U, GTEST_REFERENCE_TO_CONST_(U)&gt;::value&gt;::type* = NULL)
 387       : internal::MatcherBase&lt;T&gt;(impl) {}
 388 
 389   // Implicit constructor here allows people to write
 390   // EXPECT_CALL(foo, Bar(5)) instead of EXPECT_CALL(foo, Bar(Eq(5))) sometimes
 391   Matcher(T value);  // NOLINT
 392 };
 393 
 394 // The following two specializations allow the user to write str
 395 // instead of Eq(str) and &quot;foo&quot; instead of Eq(&quot;foo&quot;) when a std::string
 396 // matcher is expected.
 397 template &lt;&gt;
 398 class GTEST_API_ Matcher&lt;const std::string&amp;&gt;
 399     : public internal::MatcherBase&lt;const std::string&amp;&gt; {
 400  public:
 401   Matcher() {}
 402 
 403   explicit Matcher(const MatcherInterface&lt;const std::string&amp;&gt;* impl)
 404       : internal::MatcherBase&lt;const std::string&amp;&gt;(impl) {}
 405 
 406   // Allows the user to write str instead of Eq(str) sometimes, where
 407   // str is a std::string object.
 408   Matcher(const std::string&amp; s);  // NOLINT
 409 
 410 #if GTEST_HAS_GLOBAL_STRING
 411   // Allows the user to write str instead of Eq(str) sometimes, where
 412   // str is a ::string object.
 413   Matcher(const ::string&amp; s);  // NOLINT
 414 #endif                         // GTEST_HAS_GLOBAL_STRING
 415 
 416   // Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.
 417   Matcher(const char* s);  // NOLINT
 418 };
 419 
 420 template &lt;&gt;
 421 class GTEST_API_ Matcher&lt;std::string&gt;
 422     : public internal::MatcherBase&lt;std::string&gt; {
 423  public:
 424   Matcher() {}
 425 
 426   explicit Matcher(const MatcherInterface&lt;const std::string&amp;&gt;* impl)
 427       : internal::MatcherBase&lt;std::string&gt;(impl) {}
 428   explicit Matcher(const MatcherInterface&lt;std::string&gt;* impl)
 429       : internal::MatcherBase&lt;std::string&gt;(impl) {}
 430 
 431   // Allows the user to write str instead of Eq(str) sometimes, where
 432   // str is a string object.
 433   Matcher(const std::string&amp; s);  // NOLINT
 434 
 435 #if GTEST_HAS_GLOBAL_STRING
 436   // Allows the user to write str instead of Eq(str) sometimes, where
 437   // str is a ::string object.
 438   Matcher(const ::string&amp; s);  // NOLINT
 439 #endif                         // GTEST_HAS_GLOBAL_STRING
 440 
 441   // Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.
 442   Matcher(const char* s);  // NOLINT
 443 };
 444 
 445 #if GTEST_HAS_GLOBAL_STRING
 446 // The following two specializations allow the user to write str
 447 // instead of Eq(str) and &quot;foo&quot; instead of Eq(&quot;foo&quot;) when a ::string
 448 // matcher is expected.
 449 template &lt;&gt;
 450 class GTEST_API_ Matcher&lt;const ::string&amp;&gt;
 451     : public internal::MatcherBase&lt;const ::string&amp;&gt; {
 452  public:
 453   Matcher() {}
 454 
 455   explicit Matcher(const MatcherInterface&lt;const ::string&amp;&gt;* impl)
 456       : internal::MatcherBase&lt;const ::string&amp;&gt;(impl) {}
 457 
 458   // Allows the user to write str instead of Eq(str) sometimes, where
 459   // str is a std::string object.
 460   Matcher(const std::string&amp; s);  // NOLINT
 461 
 462   // Allows the user to write str instead of Eq(str) sometimes, where
 463   // str is a ::string object.
 464   Matcher(const ::string&amp; s);  // NOLINT
 465 
 466   // Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.
 467   Matcher(const char* s);  // NOLINT
 468 };
 469 
 470 template &lt;&gt;
 471 class GTEST_API_ Matcher&lt; ::string&gt;
 472     : public internal::MatcherBase&lt; ::string&gt; {
 473  public:
 474   Matcher() {}
 475 
 476   explicit Matcher(const MatcherInterface&lt;const ::string&amp;&gt;* impl)
 477       : internal::MatcherBase&lt; ::string&gt;(impl) {}
 478   explicit Matcher(const MatcherInterface&lt; ::string&gt;* impl)
 479       : internal::MatcherBase&lt; ::string&gt;(impl) {}
 480 
 481   // Allows the user to write str instead of Eq(str) sometimes, where
 482   // str is a std::string object.
 483   Matcher(const std::string&amp; s);  // NOLINT
 484 
 485   // Allows the user to write str instead of Eq(str) sometimes, where
 486   // str is a ::string object.
 487   Matcher(const ::string&amp; s);  // NOLINT
 488 
 489   // Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.
 490   Matcher(const char* s);  // NOLINT
 491 };
 492 #endif  // GTEST_HAS_GLOBAL_STRING
 493 
 494 #if GTEST_HAS_ABSL
 495 // The following two specializations allow the user to write str
 496 // instead of Eq(str) and &quot;foo&quot; instead of Eq(&quot;foo&quot;) when a absl::string_view
 497 // matcher is expected.
 498 template &lt;&gt;
 499 class GTEST_API_ Matcher&lt;const absl::string_view&amp;&gt;
 500     : public internal::MatcherBase&lt;const absl::string_view&amp;&gt; {
 501  public:
 502   Matcher() {}
 503 
 504   explicit Matcher(const MatcherInterface&lt;const absl::string_view&amp;&gt;* impl)
 505       : internal::MatcherBase&lt;const absl::string_view&amp;&gt;(impl) {}
 506 
 507   // Allows the user to write str instead of Eq(str) sometimes, where
 508   // str is a std::string object.
 509   Matcher(const std::string&amp; s);  // NOLINT
 510 
 511 #if GTEST_HAS_GLOBAL_STRING
 512   // Allows the user to write str instead of Eq(str) sometimes, where
 513   // str is a ::string object.
 514   Matcher(const ::string&amp; s);  // NOLINT
 515 #endif                         // GTEST_HAS_GLOBAL_STRING
 516 
 517   // Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.
 518   Matcher(const char* s);  // NOLINT
 519 
 520   // Allows the user to pass absl::string_views directly.
 521   Matcher(absl::string_view s);  // NOLINT
 522 };
 523 
 524 template &lt;&gt;
 525 class GTEST_API_ Matcher&lt;absl::string_view&gt;
 526     : public internal::MatcherBase&lt;absl::string_view&gt; {
 527  public:
 528   Matcher() {}
 529 
 530   explicit Matcher(const MatcherInterface&lt;const absl::string_view&amp;&gt;* impl)
 531       : internal::MatcherBase&lt;absl::string_view&gt;(impl) {}
 532   explicit Matcher(const MatcherInterface&lt;absl::string_view&gt;* impl)
 533       : internal::MatcherBase&lt;absl::string_view&gt;(impl) {}
 534 
 535   // Allows the user to write str instead of Eq(str) sometimes, where
 536   // str is a std::string object.
 537   Matcher(const std::string&amp; s);  // NOLINT
 538 
 539 #if GTEST_HAS_GLOBAL_STRING
 540   // Allows the user to write str instead of Eq(str) sometimes, where
 541   // str is a ::string object.
 542   Matcher(const ::string&amp; s);  // NOLINT
 543 #endif                         // GTEST_HAS_GLOBAL_STRING
 544 
 545   // Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.
 546   Matcher(const char* s);  // NOLINT
 547 
 548   // Allows the user to pass absl::string_views directly.
 549   Matcher(absl::string_view s);  // NOLINT
 550 };
 551 #endif  // GTEST_HAS_ABSL
 552 
 553 // Prints a matcher in a human-readable format.
 554 template &lt;typename T&gt;
 555 std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matcher&lt;T&gt;&amp; matcher) {
 556   matcher.DescribeTo(&amp;os);
 557   return os;
 558 }
 559 
 560 // The PolymorphicMatcher class template makes it easy to implement a
 561 // polymorphic matcher (i.e. a matcher that can match values of more
 562 // than one type, e.g. Eq(n) and NotNull()).
 563 //
 564 // To define a polymorphic matcher, a user should provide an Impl
 565 // class that has a DescribeTo() method and a DescribeNegationTo()
 566 // method, and define a member function (or member function template)
 567 //
 568 //   bool MatchAndExplain(const Value&amp; value,
 569 //                        MatchResultListener* listener) const;
 570 //
 571 // See the definition of NotNull() for a complete example.
 572 template &lt;class Impl&gt;
 573 class PolymorphicMatcher {
 574  public:
 575   explicit PolymorphicMatcher(const Impl&amp; an_impl) : impl_(an_impl) {}
 576 
 577   // Returns a mutable reference to the underlying matcher
 578   // implementation object.
 579   Impl&amp; mutable_impl() { return impl_; }
 580 
 581   // Returns an immutable reference to the underlying matcher
 582   // implementation object.
 583   const Impl&amp; impl() const { return impl_; }
 584 
 585   template &lt;typename T&gt;
 586   operator Matcher&lt;T&gt;() const {
 587     return Matcher&lt;T&gt;(new MonomorphicImpl&lt;GTEST_REFERENCE_TO_CONST_(T)&gt;(impl_));
 588   }
 589 
 590  private:
 591   template &lt;typename T&gt;
 592   class MonomorphicImpl : public MatcherInterface&lt;T&gt; {
 593    public:
 594     explicit MonomorphicImpl(const Impl&amp; impl) : impl_(impl) {}
 595 
 596     virtual void DescribeTo(::std::ostream* os) const {
 597       impl_.DescribeTo(os);
 598     }
 599 
 600     virtual void DescribeNegationTo(::std::ostream* os) const {
 601       impl_.DescribeNegationTo(os);
 602     }
 603 
 604     virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {
 605       return impl_.MatchAndExplain(x, listener);
 606     }
 607 
 608    private:
 609     const Impl impl_;
 610 
 611     GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);
 612   };
 613 
 614   Impl impl_;
 615 
 616   GTEST_DISALLOW_ASSIGN_(PolymorphicMatcher);
 617 };
 618 
 619 // Creates a matcher from its implementation.  This is easier to use
 620 // than the Matcher&lt;T&gt; constructor as it doesn&#39;t require you to
 621 // explicitly write the template argument, e.g.
 622 //
 623 //   MakeMatcher(foo);
 624 // vs
 625 //   Matcher&lt;const string&amp;&gt;(foo);
 626 template &lt;typename T&gt;
 627 inline Matcher&lt;T&gt; MakeMatcher(const MatcherInterface&lt;T&gt;* impl) {
 628   return Matcher&lt;T&gt;(impl);
 629 }
 630 
 631 // Creates a polymorphic matcher from its implementation.  This is
 632 // easier to use than the PolymorphicMatcher&lt;Impl&gt; constructor as it
 633 // doesn&#39;t require you to explicitly write the template argument, e.g.
 634 //
 635 //   MakePolymorphicMatcher(foo);
 636 // vs
 637 //   PolymorphicMatcher&lt;TypeOfFoo&gt;(foo);
 638 template &lt;class Impl&gt;
 639 inline PolymorphicMatcher&lt;Impl&gt; MakePolymorphicMatcher(const Impl&amp; impl) {
 640   return PolymorphicMatcher&lt;Impl&gt;(impl);
 641 }
 642 
 643 // Anything inside the &#39;internal&#39; namespace IS INTERNAL IMPLEMENTATION
 644 // and MUST NOT BE USED IN USER CODE!!!
 645 namespace internal {
 646 
 647 // The MatcherCastImpl class template is a helper for implementing
 648 // MatcherCast().  We need this helper in order to partially
 649 // specialize the implementation of MatcherCast() (C++ allows
 650 // class/struct templates to be partially specialized, but not
 651 // function templates.).
 652 
 653 // This general version is used when MatcherCast()&#39;s argument is a
 654 // polymorphic matcher (i.e. something that can be converted to a
 655 // Matcher but is not one yet; for example, Eq(value)) or a value (for
 656 // example, &quot;hello&quot;).
 657 template &lt;typename T, typename M&gt;
 658 class MatcherCastImpl {
 659  public:
 660   static Matcher&lt;T&gt; Cast(const M&amp; polymorphic_matcher_or_value) {
 661     // M can be a polymorphic matcher, in which case we want to use
 662     // its conversion operator to create Matcher&lt;T&gt;.  Or it can be a value
 663     // that should be passed to the Matcher&lt;T&gt;&#39;s constructor.
 664     //
 665     // We can&#39;t call Matcher&lt;T&gt;(polymorphic_matcher_or_value) when M is a
 666     // polymorphic matcher because it&#39;ll be ambiguous if T has an implicit
 667     // constructor from M (this usually happens when T has an implicit
 668     // constructor from any type).
 669     //
 670     // It won&#39;t work to unconditionally implict_cast
 671     // polymorphic_matcher_or_value to Matcher&lt;T&gt; because it won&#39;t trigger
 672     // a user-defined conversion from M to T if one exists (assuming M is
 673     // a value).
 674     return CastImpl(
 675         polymorphic_matcher_or_value,
 676         BooleanConstant&lt;
 677             internal::ImplicitlyConvertible&lt;M, Matcher&lt;T&gt; &gt;::value&gt;(),
 678         BooleanConstant&lt;
 679             internal::ImplicitlyConvertible&lt;M, T&gt;::value&gt;());
 680   }
 681 
 682  private:
 683   template &lt;bool Ignore&gt;
 684   static Matcher&lt;T&gt; CastImpl(const M&amp; polymorphic_matcher_or_value,
 685                              BooleanConstant&lt;true&gt; /* convertible_to_matcher */,
 686                              BooleanConstant&lt;Ignore&gt;) {
 687     // M is implicitly convertible to Matcher&lt;T&gt;, which means that either
 688     // M is a polymorphic matcher or Matcher&lt;T&gt; has an implicit constructor
 689     // from M.  In both cases using the implicit conversion will produce a
 690     // matcher.
 691     //
 692     // Even if T has an implicit constructor from M, it won&#39;t be called because
 693     // creating Matcher&lt;T&gt; would require a chain of two user-defined conversions
 694     // (first to create T from M and then to create Matcher&lt;T&gt; from T).
 695     return polymorphic_matcher_or_value;
 696   }
 697 
 698   // M can&#39;t be implicitly converted to Matcher&lt;T&gt;, so M isn&#39;t a polymorphic
 699   // matcher. It&#39;s a value of a type implicitly convertible to T. Use direct
 700   // initialization to create a matcher.
 701   static Matcher&lt;T&gt; CastImpl(
 702       const M&amp; value, BooleanConstant&lt;false&gt; /* convertible_to_matcher */,
 703       BooleanConstant&lt;true&gt; /* convertible_to_T */) {
 704     return Matcher&lt;T&gt;(ImplicitCast_&lt;T&gt;(value));
 705   }
 706 
 707   // M can&#39;t be implicitly converted to either Matcher&lt;T&gt; or T. Attempt to use
 708   // polymorphic matcher Eq(value) in this case.
 709   //
 710   // Note that we first attempt to perform an implicit cast on the value and
 711   // only fall back to the polymorphic Eq() matcher afterwards because the
 712   // latter calls bool operator==(const Lhs&amp; lhs, const Rhs&amp; rhs) in the end
 713   // which might be undefined even when Rhs is implicitly convertible to Lhs
 714   // (e.g. std::pair&lt;const int, int&gt; vs. std::pair&lt;int, int&gt;).
 715   //
 716   // We don&#39;t define this method inline as we need the declaration of Eq().
 717   static Matcher&lt;T&gt; CastImpl(
 718       const M&amp; value, BooleanConstant&lt;false&gt; /* convertible_to_matcher */,
 719       BooleanConstant&lt;false&gt; /* convertible_to_T */);
 720 };
 721 
 722 // This more specialized version is used when MatcherCast()&#39;s argument
 723 // is already a Matcher.  This only compiles when type T can be
 724 // statically converted to type U.
 725 template &lt;typename T, typename U&gt;
 726 class MatcherCastImpl&lt;T, Matcher&lt;U&gt; &gt; {
 727  public:
 728   static Matcher&lt;T&gt; Cast(const Matcher&lt;U&gt;&amp; source_matcher) {
 729     return Matcher&lt;T&gt;(new Impl(source_matcher));
 730   }
 731 
 732  private:
 733   class Impl : public MatcherInterface&lt;T&gt; {
 734    public:
 735     explicit Impl(const Matcher&lt;U&gt;&amp; source_matcher)
 736         : source_matcher_(source_matcher) {}
 737 
 738     // We delegate the matching logic to the source matcher.
 739     virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {
 740 #if GTEST_LANG_CXX11
 741       using FromType = typename std::remove_cv&lt;typename std::remove_pointer&lt;
 742           typename std::remove_reference&lt;T&gt;::type&gt;::type&gt;::type;
 743       using ToType = typename std::remove_cv&lt;typename std::remove_pointer&lt;
 744           typename std::remove_reference&lt;U&gt;::type&gt;::type&gt;::type;
 745       // Do not allow implicitly converting base*/&amp; to derived*/&amp;.
 746       static_assert(
 747           // Do not trigger if only one of them is a pointer. That implies a
 748           // regular conversion and not a down_cast.
 749           (std::is_pointer&lt;typename std::remove_reference&lt;T&gt;::type&gt;::value !=
 750            std::is_pointer&lt;typename std::remove_reference&lt;U&gt;::type&gt;::value) ||
 751               std::is_same&lt;FromType, ToType&gt;::value ||
 752               !std::is_base_of&lt;FromType, ToType&gt;::value,
 753           &quot;Can&#39;t implicitly convert from &lt;base&gt; to &lt;derived&gt;&quot;);
 754 #endif  // GTEST_LANG_CXX11
 755 
 756       return source_matcher_.MatchAndExplain(static_cast&lt;U&gt;(x), listener);
 757     }
 758 
 759     virtual void DescribeTo(::std::ostream* os) const {
 760       source_matcher_.DescribeTo(os);
 761     }
 762 
 763     virtual void DescribeNegationTo(::std::ostream* os) const {
 764       source_matcher_.DescribeNegationTo(os);
 765     }
 766 
 767    private:
 768     const Matcher&lt;U&gt; source_matcher_;
 769 
 770     GTEST_DISALLOW_ASSIGN_(Impl);
 771   };
 772 };
 773 
 774 // This even more specialized version is used for efficiently casting
 775 // a matcher to its own type.
 776 template &lt;typename T&gt;
 777 class MatcherCastImpl&lt;T, Matcher&lt;T&gt; &gt; {
 778  public:
 779   static Matcher&lt;T&gt; Cast(const Matcher&lt;T&gt;&amp; matcher) { return matcher; }
 780 };
 781 
 782 }  // namespace internal
 783 
 784 // In order to be safe and clear, casting between different matcher
 785 // types is done explicitly via MatcherCast&lt;T&gt;(m), which takes a
 786 // matcher m and returns a Matcher&lt;T&gt;.  It compiles only when T can be
 787 // statically converted to the argument type of m.
 788 template &lt;typename T, typename M&gt;
 789 inline Matcher&lt;T&gt; MatcherCast(const M&amp; matcher) {
 790   return internal::MatcherCastImpl&lt;T, M&gt;::Cast(matcher);
 791 }
 792 
 793 // Implements SafeMatcherCast().
 794 //
 795 // We use an intermediate class to do the actual safe casting as Nokia&#39;s
 796 // Symbian compiler cannot decide between
 797 // template &lt;T, M&gt; ... (M) and
 798 // template &lt;T, U&gt; ... (const Matcher&lt;U&gt;&amp;)
 799 // for function templates but can for member function templates.
 800 template &lt;typename T&gt;
 801 class SafeMatcherCastImpl {
 802  public:
 803   // This overload handles polymorphic matchers and values only since
 804   // monomorphic matchers are handled by the next one.
 805   template &lt;typename M&gt;
 806   static inline Matcher&lt;T&gt; Cast(const M&amp; polymorphic_matcher_or_value) {
 807     return internal::MatcherCastImpl&lt;T, M&gt;::Cast(polymorphic_matcher_or_value);
 808   }
 809 
 810   // This overload handles monomorphic matchers.
 811   //
 812   // In general, if type T can be implicitly converted to type U, we can
 813   // safely convert a Matcher&lt;U&gt; to a Matcher&lt;T&gt; (i.e. Matcher is
 814   // contravariant): just keep a copy of the original Matcher&lt;U&gt;, convert the
 815   // argument from type T to U, and then pass it to the underlying Matcher&lt;U&gt;.
 816   // The only exception is when U is a reference and T is not, as the
 817   // underlying Matcher&lt;U&gt; may be interested in the argument&#39;s address, which
 818   // is not preserved in the conversion from T to U.
 819   template &lt;typename U&gt;
 820   static inline Matcher&lt;T&gt; Cast(const Matcher&lt;U&gt;&amp; matcher) {
 821     // Enforce that T can be implicitly converted to U.
 822     GTEST_COMPILE_ASSERT_((internal::ImplicitlyConvertible&lt;T, U&gt;::value),
 823                           T_must_be_implicitly_convertible_to_U);
 824     // Enforce that we are not converting a non-reference type T to a reference
 825     // type U.
 826     GTEST_COMPILE_ASSERT_(
 827         internal::is_reference&lt;T&gt;::value || !internal::is_reference&lt;U&gt;::value,
 828         cannot_convert_non_reference_arg_to_reference);
 829     // In case both T and U are arithmetic types, enforce that the
 830     // conversion is not lossy.
 831     typedef GTEST_REMOVE_REFERENCE_AND_CONST_(T) RawT;
 832     typedef GTEST_REMOVE_REFERENCE_AND_CONST_(U) RawU;
 833     const bool kTIsOther = GMOCK_KIND_OF_(RawT) == internal::kOther;
 834     const bool kUIsOther = GMOCK_KIND_OF_(RawU) == internal::kOther;
 835     GTEST_COMPILE_ASSERT_(
 836         kTIsOther || kUIsOther ||
 837         (internal::LosslessArithmeticConvertible&lt;RawT, RawU&gt;::value),
 838         conversion_of_arithmetic_types_must_be_lossless);
 839     return MatcherCast&lt;T&gt;(matcher);
 840   }
 841 };
 842 
 843 template &lt;typename T, typename M&gt;
 844 inline Matcher&lt;T&gt; SafeMatcherCast(const M&amp; polymorphic_matcher) {
 845   return SafeMatcherCastImpl&lt;T&gt;::Cast(polymorphic_matcher);
 846 }
 847 
 848 // A&lt;T&gt;() returns a matcher that matches any value of type T.
 849 template &lt;typename T&gt;
 850 Matcher&lt;T&gt; A();
 851 
 852 // Anything inside the &#39;internal&#39; namespace IS INTERNAL IMPLEMENTATION
 853 // and MUST NOT BE USED IN USER CODE!!!
 854 namespace internal {
 855 
 856 // If the explanation is not empty, prints it to the ostream.
 857 inline void PrintIfNotEmpty(const std::string&amp; explanation,
 858                             ::std::ostream* os) {
 859   if (explanation != &quot;&quot; &amp;&amp; os != NULL) {
 860     *os &lt;&lt; &quot;, &quot; &lt;&lt; explanation;
 861   }
 862 }
 863 
 864 // Returns true if the given type name is easy to read by a human.
 865 // This is used to decide whether printing the type of a value might
 866 // be helpful.
 867 inline bool IsReadableTypeName(const std::string&amp; type_name) {
 868   // We consider a type name readable if it&#39;s short or doesn&#39;t contain
 869   // a template or function type.
 870   return (type_name.length() &lt;= 20 ||
 871           type_name.find_first_of(&quot;&lt;(&quot;) == std::string::npos);
 872 }
 873 
 874 // Matches the value against the given matcher, prints the value and explains
 875 // the match result to the listener. Returns the match result.
 876 // &#39;listener&#39; must not be NULL.
 877 // Value cannot be passed by const reference, because some matchers take a
 878 // non-const argument.
 879 template &lt;typename Value, typename T&gt;
 880 bool MatchPrintAndExplain(Value&amp; value, const Matcher&lt;T&gt;&amp; matcher,
 881                           MatchResultListener* listener) {
 882   if (!listener-&gt;IsInterested()) {
 883     // If the listener is not interested, we do not need to construct the
 884     // inner explanation.
 885     return matcher.Matches(value);
 886   }
 887 
 888   StringMatchResultListener inner_listener;
 889   const bool match = matcher.MatchAndExplain(value, &amp;inner_listener);
 890 
 891   UniversalPrint(value, listener-&gt;stream());
 892 #if GTEST_HAS_RTTI
 893   const std::string&amp; type_name = GetTypeName&lt;Value&gt;();
 894   if (IsReadableTypeName(type_name))
 895     *listener-&gt;stream() &lt;&lt; &quot; (of type &quot; &lt;&lt; type_name &lt;&lt; &quot;)&quot;;
 896 #endif
 897   PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
 898 
 899   return match;
 900 }
 901 
 902 // An internal helper class for doing compile-time loop on a tuple&#39;s
 903 // fields.
 904 template &lt;size_t N&gt;
 905 class TuplePrefix {
 906  public:
 907   // TuplePrefix&lt;N&gt;::Matches(matcher_tuple, value_tuple) returns true
 908   // iff the first N fields of matcher_tuple matches the first N
 909   // fields of value_tuple, respectively.
 910   template &lt;typename MatcherTuple, typename ValueTuple&gt;
 911   static bool Matches(const MatcherTuple&amp; matcher_tuple,
 912                       const ValueTuple&amp; value_tuple) {
 913     return TuplePrefix&lt;N - 1&gt;::Matches(matcher_tuple, value_tuple)
 914         &amp;&amp; get&lt;N - 1&gt;(matcher_tuple).Matches(get&lt;N - 1&gt;(value_tuple));
 915   }
 916 
 917   // TuplePrefix&lt;N&gt;::ExplainMatchFailuresTo(matchers, values, os)
 918   // describes failures in matching the first N fields of matchers
 919   // against the first N fields of values.  If there is no failure,
 920   // nothing will be streamed to os.
 921   template &lt;typename MatcherTuple, typename ValueTuple&gt;
 922   static void ExplainMatchFailuresTo(const MatcherTuple&amp; matchers,
 923                                      const ValueTuple&amp; values,
 924                                      ::std::ostream* os) {
 925     // First, describes failures in the first N - 1 fields.
 926     TuplePrefix&lt;N - 1&gt;::ExplainMatchFailuresTo(matchers, values, os);
 927 
 928     // Then describes the failure (if any) in the (N - 1)-th (0-based)
 929     // field.
 930     typename tuple_element&lt;N - 1, MatcherTuple&gt;::type matcher =
 931         get&lt;N - 1&gt;(matchers);
 932     typedef typename tuple_element&lt;N - 1, ValueTuple&gt;::type Value;
 933     GTEST_REFERENCE_TO_CONST_(Value) value = get&lt;N - 1&gt;(values);
 934     StringMatchResultListener listener;
 935     if (!matcher.MatchAndExplain(value, &amp;listener)) {
 936       // FIXME: include in the message the name of the parameter
 937       // as used in MOCK_METHOD*() when possible.
 938       *os &lt;&lt; &quot;  Expected arg #&quot; &lt;&lt; N - 1 &lt;&lt; &quot;: &quot;;
 939       get&lt;N - 1&gt;(matchers).DescribeTo(os);
 940       *os &lt;&lt; &quot;\n           Actual: &quot;;
 941       // We remove the reference in type Value to prevent the
 942       // universal printer from printing the address of value, which
 943       // isn&#39;t interesting to the user most of the time.  The
 944       // matcher&#39;s MatchAndExplain() method handles the case when
 945       // the address is interesting.
 946       internal::UniversalPrint(value, os);
 947       PrintIfNotEmpty(listener.str(), os);
 948       *os &lt;&lt; &quot;\n&quot;;
 949     }
 950   }
 951 };
 952 
 953 // The base case.
 954 template &lt;&gt;
 955 class TuplePrefix&lt;0&gt; {
 956  public:
 957   template &lt;typename MatcherTuple, typename ValueTuple&gt;
 958   static bool Matches(const MatcherTuple&amp; /* matcher_tuple */,
 959                       const ValueTuple&amp; /* value_tuple */) {
 960     return true;
 961   }
 962 
 963   template &lt;typename MatcherTuple, typename ValueTuple&gt;
 964   static void ExplainMatchFailuresTo(const MatcherTuple&amp; /* matchers */,
 965                                      const ValueTuple&amp; /* values */,
 966                                      ::std::ostream* /* os */) {}
 967 };
 968 
 969 // TupleMatches(matcher_tuple, value_tuple) returns true iff all
 970 // matchers in matcher_tuple match the corresponding fields in
 971 // value_tuple.  It is a compiler error if matcher_tuple and
 972 // value_tuple have different number of fields or incompatible field
 973 // types.
 974 template &lt;typename MatcherTuple, typename ValueTuple&gt;
 975 bool TupleMatches(const MatcherTuple&amp; matcher_tuple,
 976                   const ValueTuple&amp; value_tuple) {
 977   // Makes sure that matcher_tuple and value_tuple have the same
 978   // number of fields.
 979   GTEST_COMPILE_ASSERT_(tuple_size&lt;MatcherTuple&gt;::value ==
 980                         tuple_size&lt;ValueTuple&gt;::value,
 981                         matcher_and_value_have_different_numbers_of_fields);
 982   return TuplePrefix&lt;tuple_size&lt;ValueTuple&gt;::value&gt;::
 983       Matches(matcher_tuple, value_tuple);
 984 }
 985 
 986 // Describes failures in matching matchers against values.  If there
 987 // is no failure, nothing will be streamed to os.
 988 template &lt;typename MatcherTuple, typename ValueTuple&gt;
 989 void ExplainMatchFailureTupleTo(const MatcherTuple&amp; matchers,
 990                                 const ValueTuple&amp; values,
 991                                 ::std::ostream* os) {
 992   TuplePrefix&lt;tuple_size&lt;MatcherTuple&gt;::value&gt;::ExplainMatchFailuresTo(
 993       matchers, values, os);
 994 }
 995 
 996 // TransformTupleValues and its helper.
 997 //
 998 // TransformTupleValuesHelper hides the internal machinery that
 999 // TransformTupleValues uses to implement a tuple traversal.
1000 template &lt;typename Tuple, typename Func, typename OutIter&gt;
1001 class TransformTupleValuesHelper {
1002  private:
1003   typedef ::testing::tuple_size&lt;Tuple&gt; TupleSize;
1004 
1005  public:
1006   // For each member of tuple &#39;t&#39;, taken in order, evaluates &#39;*out++ = f(t)&#39;.
1007   // Returns the final value of &#39;out&#39; in case the caller needs it.
1008   static OutIter Run(Func f, const Tuple&amp; t, OutIter out) {
1009     return IterateOverTuple&lt;Tuple, TupleSize::value&gt;()(f, t, out);
1010   }
1011 
1012  private:
1013   template &lt;typename Tup, size_t kRemainingSize&gt;
1014   struct IterateOverTuple {
1015     OutIter operator() (Func f, const Tup&amp; t, OutIter out) const {
1016       *out++ = f(::testing::get&lt;TupleSize::value - kRemainingSize&gt;(t));
1017       return IterateOverTuple&lt;Tup, kRemainingSize - 1&gt;()(f, t, out);
1018     }
1019   };
1020   template &lt;typename Tup&gt;
1021   struct IterateOverTuple&lt;Tup, 0&gt; {
1022     OutIter operator() (Func /* f */, const Tup&amp; /* t */, OutIter out) const {
1023       return out;
1024     }
1025   };
1026 };
1027 
1028 // Successively invokes &#39;f(element)&#39; on each element of the tuple &#39;t&#39;,
1029 // appending each result to the &#39;out&#39; iterator. Returns the final value
1030 // of &#39;out&#39;.
1031 template &lt;typename Tuple, typename Func, typename OutIter&gt;
1032 OutIter TransformTupleValues(Func f, const Tuple&amp; t, OutIter out) {
1033   return TransformTupleValuesHelper&lt;Tuple, Func, OutIter&gt;::Run(f, t, out);
1034 }
1035 
1036 // Implements A&lt;T&gt;().
1037 template &lt;typename T&gt;
1038 class AnyMatcherImpl : public MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(T)&gt; {
1039  public:
1040   virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(T) /* x */,
1041                                MatchResultListener* /* listener */) const {
1042     return true;
1043   }
1044   virtual void DescribeTo(::std::ostream* os) const { *os &lt;&lt; &quot;is anything&quot;; }
1045   virtual void DescribeNegationTo(::std::ostream* os) const {
1046     // This is mostly for completeness&#39; safe, as it&#39;s not very useful
1047     // to write Not(A&lt;bool&gt;()).  However we cannot completely rule out
1048     // such a possibility, and it doesn&#39;t hurt to be prepared.
1049     *os &lt;&lt; &quot;never matches&quot;;
1050   }
1051 };
1052 
1053 // Implements _, a matcher that matches any value of any
1054 // type.  This is a polymorphic matcher, so we need a template type
1055 // conversion operator to make it appearing as a Matcher&lt;T&gt; for any
1056 // type T.
1057 class AnythingMatcher {
1058  public:
1059   template &lt;typename T&gt;
1060   operator Matcher&lt;T&gt;() const { return A&lt;T&gt;(); }
1061 };
1062 
1063 // Implements a matcher that compares a given value with a
1064 // pre-supplied value using one of the ==, &lt;=, &lt;, etc, operators.  The
1065 // two values being compared don&#39;t have to have the same type.
1066 //
1067 // The matcher defined here is polymorphic (for example, Eq(5) can be
1068 // used to match an int, a short, a double, etc).  Therefore we use
1069 // a template type conversion operator in the implementation.
1070 //
1071 // The following template definition assumes that the Rhs parameter is
1072 // a &quot;bare&quot; type (i.e. neither &#39;const T&#39; nor &#39;T&amp;&#39;).
1073 template &lt;typename D, typename Rhs, typename Op&gt;
1074 class ComparisonBase {
1075  public:
1076   explicit ComparisonBase(const Rhs&amp; rhs) : rhs_(rhs) {}
1077   template &lt;typename Lhs&gt;
1078   operator Matcher&lt;Lhs&gt;() const {
1079     return MakeMatcher(new Impl&lt;Lhs&gt;(rhs_));
1080   }
1081 
1082  private:
1083   template &lt;typename Lhs&gt;
1084   class Impl : public MatcherInterface&lt;Lhs&gt; {
1085    public:
1086     explicit Impl(const Rhs&amp; rhs) : rhs_(rhs) {}
1087     virtual bool MatchAndExplain(
1088         Lhs lhs, MatchResultListener* /* listener */) const {
1089       return Op()(lhs, rhs_);
1090     }
1091     virtual void DescribeTo(::std::ostream* os) const {
1092       *os &lt;&lt; D::Desc() &lt;&lt; &quot; &quot;;
1093       UniversalPrint(rhs_, os);
1094     }
1095     virtual void DescribeNegationTo(::std::ostream* os) const {
1096       *os &lt;&lt; D::NegatedDesc() &lt;&lt;  &quot; &quot;;
1097       UniversalPrint(rhs_, os);
1098     }
1099    private:
1100     Rhs rhs_;
1101     GTEST_DISALLOW_ASSIGN_(Impl);
1102   };
1103   Rhs rhs_;
1104   GTEST_DISALLOW_ASSIGN_(ComparisonBase);
1105 };
1106 
1107 template &lt;typename Rhs&gt;
1108 class EqMatcher : public ComparisonBase&lt;EqMatcher&lt;Rhs&gt;, Rhs, AnyEq&gt; {
1109  public:
1110   explicit EqMatcher(const Rhs&amp; rhs)
1111       : ComparisonBase&lt;EqMatcher&lt;Rhs&gt;, Rhs, AnyEq&gt;(rhs) { }
1112   static const char* Desc() { return &quot;is equal to&quot;; }
1113   static const char* NegatedDesc() { return &quot;isn&#39;t equal to&quot;; }
1114 };
1115 template &lt;typename Rhs&gt;
1116 class NeMatcher : public ComparisonBase&lt;NeMatcher&lt;Rhs&gt;, Rhs, AnyNe&gt; {
1117  public:
1118   explicit NeMatcher(const Rhs&amp; rhs)
1119       : ComparisonBase&lt;NeMatcher&lt;Rhs&gt;, Rhs, AnyNe&gt;(rhs) { }
1120   static const char* Desc() { return &quot;isn&#39;t equal to&quot;; }
1121   static const char* NegatedDesc() { return &quot;is equal to&quot;; }
1122 };
1123 template &lt;typename Rhs&gt;
1124 class LtMatcher : public ComparisonBase&lt;LtMatcher&lt;Rhs&gt;, Rhs, AnyLt&gt; {
1125  public:
1126   explicit LtMatcher(const Rhs&amp; rhs)
1127       : ComparisonBase&lt;LtMatcher&lt;Rhs&gt;, Rhs, AnyLt&gt;(rhs) { }
1128   static const char* Desc() { return &quot;is &lt;&quot;; }
1129   static const char* NegatedDesc() { return &quot;isn&#39;t &lt;&quot;; }
1130 };
1131 template &lt;typename Rhs&gt;
1132 class GtMatcher : public ComparisonBase&lt;GtMatcher&lt;Rhs&gt;, Rhs, AnyGt&gt; {
1133  public:
1134   explicit GtMatcher(const Rhs&amp; rhs)
1135       : ComparisonBase&lt;GtMatcher&lt;Rhs&gt;, Rhs, AnyGt&gt;(rhs) { }
1136   static const char* Desc() { return &quot;is &gt;&quot;; }
1137   static const char* NegatedDesc() { return &quot;isn&#39;t &gt;&quot;; }
1138 };
1139 template &lt;typename Rhs&gt;
1140 class LeMatcher : public ComparisonBase&lt;LeMatcher&lt;Rhs&gt;, Rhs, AnyLe&gt; {
1141  public:
1142   explicit LeMatcher(const Rhs&amp; rhs)
1143       : ComparisonBase&lt;LeMatcher&lt;Rhs&gt;, Rhs, AnyLe&gt;(rhs) { }
1144   static const char* Desc() { return &quot;is &lt;=&quot;; }
1145   static const char* NegatedDesc() { return &quot;isn&#39;t &lt;=&quot;; }
1146 };
1147 template &lt;typename Rhs&gt;
1148 class GeMatcher : public ComparisonBase&lt;GeMatcher&lt;Rhs&gt;, Rhs, AnyGe&gt; {
1149  public:
1150   explicit GeMatcher(const Rhs&amp; rhs)
1151       : ComparisonBase&lt;GeMatcher&lt;Rhs&gt;, Rhs, AnyGe&gt;(rhs) { }
1152   static const char* Desc() { return &quot;is &gt;=&quot;; }
1153   static const char* NegatedDesc() { return &quot;isn&#39;t &gt;=&quot;; }
1154 };
1155 
1156 // Implements the polymorphic IsNull() matcher, which matches any raw or smart
1157 // pointer that is NULL.
1158 class IsNullMatcher {
1159  public:
1160   template &lt;typename Pointer&gt;
1161   bool MatchAndExplain(const Pointer&amp; p,
1162                        MatchResultListener* /* listener */) const {
1163 #if GTEST_LANG_CXX11
1164     return p == nullptr;
1165 #else  // GTEST_LANG_CXX11
1166     return GetRawPointer(p) == NULL;
1167 #endif  // GTEST_LANG_CXX11
1168   }
1169 
1170   void DescribeTo(::std::ostream* os) const { *os &lt;&lt; &quot;is NULL&quot;; }
1171   void DescribeNegationTo(::std::ostream* os) const {
1172     *os &lt;&lt; &quot;isn&#39;t NULL&quot;;
1173   }
1174 };
1175 
1176 // Implements the polymorphic NotNull() matcher, which matches any raw or smart
1177 // pointer that is not NULL.
1178 class NotNullMatcher {
1179  public:
1180   template &lt;typename Pointer&gt;
1181   bool MatchAndExplain(const Pointer&amp; p,
1182                        MatchResultListener* /* listener */) const {
1183 #if GTEST_LANG_CXX11
1184     return p != nullptr;
1185 #else  // GTEST_LANG_CXX11
1186     return GetRawPointer(p) != NULL;
1187 #endif  // GTEST_LANG_CXX11
1188   }
1189 
1190   void DescribeTo(::std::ostream* os) const { *os &lt;&lt; &quot;isn&#39;t NULL&quot;; }
1191   void DescribeNegationTo(::std::ostream* os) const {
1192     *os &lt;&lt; &quot;is NULL&quot;;
1193   }
1194 };
1195 
1196 // Ref(variable) matches any argument that is a reference to
1197 // &#39;variable&#39;.  This matcher is polymorphic as it can match any
1198 // super type of the type of &#39;variable&#39;.
1199 //
1200 // The RefMatcher template class implements Ref(variable).  It can
1201 // only be instantiated with a reference type.  This prevents a user
1202 // from mistakenly using Ref(x) to match a non-reference function
1203 // argument.  For example, the following will righteously cause a
1204 // compiler error:
1205 //
1206 //   int n;
1207 //   Matcher&lt;int&gt; m1 = Ref(n);   // This won&#39;t compile.
1208 //   Matcher&lt;int&amp;&gt; m2 = Ref(n);  // This will compile.
1209 template &lt;typename T&gt;
1210 class RefMatcher;
1211 
1212 template &lt;typename T&gt;
1213 class RefMatcher&lt;T&amp;&gt; {
1214   // Google Mock is a generic framework and thus needs to support
1215   // mocking any function types, including those that take non-const
1216   // reference arguments.  Therefore the template parameter T (and
1217   // Super below) can be instantiated to either a const type or a
1218   // non-const type.
1219  public:
1220   // RefMatcher() takes a T&amp; instead of const T&amp;, as we want the
1221   // compiler to catch using Ref(const_value) as a matcher for a
1222   // non-const reference.
1223   explicit RefMatcher(T&amp; x) : object_(x) {}  // NOLINT
1224 
1225   template &lt;typename Super&gt;
1226   operator Matcher&lt;Super&amp;&gt;() const {
1227     // By passing object_ (type T&amp;) to Impl(), which expects a Super&amp;,
1228     // we make sure that Super is a super type of T.  In particular,
1229     // this catches using Ref(const_value) as a matcher for a
1230     // non-const reference, as you cannot implicitly convert a const
1231     // reference to a non-const reference.
1232     return MakeMatcher(new Impl&lt;Super&gt;(object_));
1233   }
1234 
1235  private:
1236   template &lt;typename Super&gt;
1237   class Impl : public MatcherInterface&lt;Super&amp;&gt; {
1238    public:
1239     explicit Impl(Super&amp; x) : object_(x) {}  // NOLINT
1240 
1241     // MatchAndExplain() takes a Super&amp; (as opposed to const Super&amp;)
1242     // in order to match the interface MatcherInterface&lt;Super&amp;&gt;.
1243     virtual bool MatchAndExplain(
1244         Super&amp; x, MatchResultListener* listener) const {
1245       *listener &lt;&lt; &quot;which is located @&quot; &lt;&lt; static_cast&lt;const void*&gt;(&amp;x);
1246       return &amp;x == &amp;object_;
1247     }
1248 
1249     virtual void DescribeTo(::std::ostream* os) const {
1250       *os &lt;&lt; &quot;references the variable &quot;;
1251       UniversalPrinter&lt;Super&amp;&gt;::Print(object_, os);
1252     }
1253 
1254     virtual void DescribeNegationTo(::std::ostream* os) const {
1255       *os &lt;&lt; &quot;does not reference the variable &quot;;
1256       UniversalPrinter&lt;Super&amp;&gt;::Print(object_, os);
1257     }
1258 
1259    private:
1260     const Super&amp; object_;
1261 
1262     GTEST_DISALLOW_ASSIGN_(Impl);
1263   };
1264 
1265   T&amp; object_;
1266 
1267   GTEST_DISALLOW_ASSIGN_(RefMatcher);
1268 };
1269 
1270 // Polymorphic helper functions for narrow and wide string matchers.
1271 inline bool CaseInsensitiveCStringEquals(const char* lhs, const char* rhs) {
1272   return String::CaseInsensitiveCStringEquals(lhs, rhs);
1273 }
1274 
1275 inline bool CaseInsensitiveCStringEquals(const wchar_t* lhs,
1276                                          const wchar_t* rhs) {
1277   return String::CaseInsensitiveWideCStringEquals(lhs, rhs);
1278 }
1279 
1280 // String comparison for narrow or wide strings that can have embedded NUL
1281 // characters.
1282 template &lt;typename StringType&gt;
1283 bool CaseInsensitiveStringEquals(const StringType&amp; s1,
1284                                  const StringType&amp; s2) {
1285   // Are the heads equal?
1286   if (!CaseInsensitiveCStringEquals(s1.c_str(), s2.c_str())) {
1287     return false;
1288   }
1289 
1290   // Skip the equal heads.
1291   const typename StringType::value_type nul = 0;
1292   const size_t i1 = s1.find(nul), i2 = s2.find(nul);
1293 
1294   // Are we at the end of either s1 or s2?
1295   if (i1 == StringType::npos || i2 == StringType::npos) {
1296     return i1 == i2;
1297   }
1298 
1299   // Are the tails equal?
1300   return CaseInsensitiveStringEquals(s1.substr(i1 + 1), s2.substr(i2 + 1));
1301 }
1302 
1303 // String matchers.
1304 
1305 // Implements equality-based string matchers like StrEq, StrCaseNe, and etc.
1306 template &lt;typename StringType&gt;
1307 class StrEqualityMatcher {
1308  public:
1309   StrEqualityMatcher(const StringType&amp; str, bool expect_eq,
1310                      bool case_sensitive)
1311       : string_(str), expect_eq_(expect_eq), case_sensitive_(case_sensitive) {}
1312 
1313 #if GTEST_HAS_ABSL
1314   bool MatchAndExplain(const absl::string_view&amp; s,
1315                        MatchResultListener* listener) const {
1316     if (s.data() == NULL) {
1317       return !expect_eq_;
1318     }
1319     // This should fail to compile if absl::string_view is used with wide
1320     // strings.
1321     const StringType&amp; str = string(s);
1322     return MatchAndExplain(str, listener);
1323   }
1324 #endif  // GTEST_HAS_ABSL
1325 
1326   // Accepts pointer types, particularly:
1327   //   const char*
1328   //   char*
1329   //   const wchar_t*
1330   //   wchar_t*
1331   template &lt;typename CharType&gt;
1332   bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
1333     if (s == NULL) {
1334       return !expect_eq_;
1335     }
1336     return MatchAndExplain(StringType(s), listener);
1337   }
1338 
1339   // Matches anything that can convert to StringType.
1340   //
1341   // This is a template, not just a plain function with const StringType&amp;,
1342   // because absl::string_view has some interfering non-explicit constructors.
1343   template &lt;typename MatcheeStringType&gt;
1344   bool MatchAndExplain(const MatcheeStringType&amp; s,
1345                        MatchResultListener* /* listener */) const {
1346     const StringType&amp; s2(s);
1347     const bool eq = case_sensitive_ ? s2 == string_ :
1348         CaseInsensitiveStringEquals(s2, string_);
1349     return expect_eq_ == eq;
1350   }
1351 
1352   void DescribeTo(::std::ostream* os) const {
1353     DescribeToHelper(expect_eq_, os);
1354   }
1355 
1356   void DescribeNegationTo(::std::ostream* os) const {
1357     DescribeToHelper(!expect_eq_, os);
1358   }
1359 
1360  private:
1361   void DescribeToHelper(bool expect_eq, ::std::ostream* os) const {
1362     *os &lt;&lt; (expect_eq ? &quot;is &quot; : &quot;isn&#39;t &quot;);
1363     *os &lt;&lt; &quot;equal to &quot;;
1364     if (!case_sensitive_) {
1365       *os &lt;&lt; &quot;(ignoring case) &quot;;
1366     }
1367     UniversalPrint(string_, os);
1368   }
1369 
1370   const StringType string_;
1371   const bool expect_eq_;
1372   const bool case_sensitive_;
1373 
1374   GTEST_DISALLOW_ASSIGN_(StrEqualityMatcher);
1375 };
1376 
1377 // Implements the polymorphic HasSubstr(substring) matcher, which
1378 // can be used as a Matcher&lt;T&gt; as long as T can be converted to a
1379 // string.
1380 template &lt;typename StringType&gt;
1381 class HasSubstrMatcher {
1382  public:
1383   explicit HasSubstrMatcher(const StringType&amp; substring)
1384       : substring_(substring) {}
1385 
1386 #if GTEST_HAS_ABSL
1387   bool MatchAndExplain(const absl::string_view&amp; s,
1388                        MatchResultListener* listener) const {
1389     if (s.data() == NULL) {
1390       return false;
1391     }
1392     // This should fail to compile if absl::string_view is used with wide
1393     // strings.
1394     const StringType&amp; str = string(s);
1395     return MatchAndExplain(str, listener);
1396   }
1397 #endif  // GTEST_HAS_ABSL
1398 
1399   // Accepts pointer types, particularly:
1400   //   const char*
1401   //   char*
1402   //   const wchar_t*
1403   //   wchar_t*
1404   template &lt;typename CharType&gt;
1405   bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
1406     return s != NULL &amp;&amp; MatchAndExplain(StringType(s), listener);
1407   }
1408 
1409   // Matches anything that can convert to StringType.
1410   //
1411   // This is a template, not just a plain function with const StringType&amp;,
1412   // because absl::string_view has some interfering non-explicit constructors.
1413   template &lt;typename MatcheeStringType&gt;
1414   bool MatchAndExplain(const MatcheeStringType&amp; s,
1415                        MatchResultListener* /* listener */) const {
1416     const StringType&amp; s2(s);
1417     return s2.find(substring_) != StringType::npos;
1418   }
1419 
1420   // Describes what this matcher matches.
1421   void DescribeTo(::std::ostream* os) const {
1422     *os &lt;&lt; &quot;has substring &quot;;
1423     UniversalPrint(substring_, os);
1424   }
1425 
1426   void DescribeNegationTo(::std::ostream* os) const {
1427     *os &lt;&lt; &quot;has no substring &quot;;
1428     UniversalPrint(substring_, os);
1429   }
1430 
1431  private:
1432   const StringType substring_;
1433 
1434   GTEST_DISALLOW_ASSIGN_(HasSubstrMatcher);
1435 };
1436 
1437 // Implements the polymorphic StartsWith(substring) matcher, which
1438 // can be used as a Matcher&lt;T&gt; as long as T can be converted to a
1439 // string.
1440 template &lt;typename StringType&gt;
1441 class StartsWithMatcher {
1442  public:
1443   explicit StartsWithMatcher(const StringType&amp; prefix) : prefix_(prefix) {
1444   }
1445 
1446 #if GTEST_HAS_ABSL
1447   bool MatchAndExplain(const absl::string_view&amp; s,
1448                        MatchResultListener* listener) const {
1449     if (s.data() == NULL) {
1450       return false;
1451     }
1452     // This should fail to compile if absl::string_view is used with wide
1453     // strings.
1454     const StringType&amp; str = string(s);
1455     return MatchAndExplain(str, listener);
1456   }
1457 #endif  // GTEST_HAS_ABSL
1458 
1459   // Accepts pointer types, particularly:
1460   //   const char*
1461   //   char*
1462   //   const wchar_t*
1463   //   wchar_t*
1464   template &lt;typename CharType&gt;
1465   bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
1466     return s != NULL &amp;&amp; MatchAndExplain(StringType(s), listener);
1467   }
1468 
1469   // Matches anything that can convert to StringType.
1470   //
1471   // This is a template, not just a plain function with const StringType&amp;,
1472   // because absl::string_view has some interfering non-explicit constructors.
1473   template &lt;typename MatcheeStringType&gt;
1474   bool MatchAndExplain(const MatcheeStringType&amp; s,
1475                        MatchResultListener* /* listener */) const {
1476     const StringType&amp; s2(s);
1477     return s2.length() &gt;= prefix_.length() &amp;&amp;
1478         s2.substr(0, prefix_.length()) == prefix_;
1479   }
1480 
1481   void DescribeTo(::std::ostream* os) const {
1482     *os &lt;&lt; &quot;starts with &quot;;
1483     UniversalPrint(prefix_, os);
1484   }
1485 
1486   void DescribeNegationTo(::std::ostream* os) const {
1487     *os &lt;&lt; &quot;doesn&#39;t start with &quot;;
1488     UniversalPrint(prefix_, os);
1489   }
1490 
1491  private:
1492   const StringType prefix_;
1493 
1494   GTEST_DISALLOW_ASSIGN_(StartsWithMatcher);
1495 };
1496 
1497 // Implements the polymorphic EndsWith(substring) matcher, which
1498 // can be used as a Matcher&lt;T&gt; as long as T can be converted to a
1499 // string.
1500 template &lt;typename StringType&gt;
1501 class EndsWithMatcher {
1502  public:
1503   explicit EndsWithMatcher(const StringType&amp; suffix) : suffix_(suffix) {}
1504 
1505 #if GTEST_HAS_ABSL
1506   bool MatchAndExplain(const absl::string_view&amp; s,
1507                        MatchResultListener* listener) const {
1508     if (s.data() == NULL) {
1509       return false;
1510     }
1511     // This should fail to compile if absl::string_view is used with wide
1512     // strings.
1513     const StringType&amp; str = string(s);
1514     return MatchAndExplain(str, listener);
1515   }
1516 #endif  // GTEST_HAS_ABSL
1517 
1518   // Accepts pointer types, particularly:
1519   //   const char*
1520   //   char*
1521   //   const wchar_t*
1522   //   wchar_t*
1523   template &lt;typename CharType&gt;
1524   bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
1525     return s != NULL &amp;&amp; MatchAndExplain(StringType(s), listener);
1526   }
1527 
1528   // Matches anything that can convert to StringType.
1529   //
1530   // This is a template, not just a plain function with const StringType&amp;,
1531   // because absl::string_view has some interfering non-explicit constructors.
1532   template &lt;typename MatcheeStringType&gt;
1533   bool MatchAndExplain(const MatcheeStringType&amp; s,
1534                        MatchResultListener* /* listener */) const {
1535     const StringType&amp; s2(s);
1536     return s2.length() &gt;= suffix_.length() &amp;&amp;
1537         s2.substr(s2.length() - suffix_.length()) == suffix_;
1538   }
1539 
1540   void DescribeTo(::std::ostream* os) const {
1541     *os &lt;&lt; &quot;ends with &quot;;
1542     UniversalPrint(suffix_, os);
1543   }
1544 
1545   void DescribeNegationTo(::std::ostream* os) const {
1546     *os &lt;&lt; &quot;doesn&#39;t end with &quot;;
1547     UniversalPrint(suffix_, os);
1548   }
1549 
1550  private:
1551   const StringType suffix_;
1552 
1553   GTEST_DISALLOW_ASSIGN_(EndsWithMatcher);
1554 };
1555 
1556 // Implements polymorphic matchers MatchesRegex(regex) and
1557 // ContainsRegex(regex), which can be used as a Matcher&lt;T&gt; as long as
1558 // T can be converted to a string.
1559 class MatchesRegexMatcher {
1560  public:
1561   MatchesRegexMatcher(const RE* regex, bool full_match)
1562       : regex_(regex), full_match_(full_match) {}
1563 
1564 #if GTEST_HAS_ABSL
1565   bool MatchAndExplain(const absl::string_view&amp; s,
1566                        MatchResultListener* listener) const {
1567     return s.data() &amp;&amp; MatchAndExplain(string(s), listener);
1568   }
1569 #endif  // GTEST_HAS_ABSL
1570 
1571   // Accepts pointer types, particularly:
1572   //   const char*
1573   //   char*
1574   //   const wchar_t*
1575   //   wchar_t*
1576   template &lt;typename CharType&gt;
1577   bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
1578     return s != NULL &amp;&amp; MatchAndExplain(std::string(s), listener);
1579   }
1580 
1581   // Matches anything that can convert to std::string.
1582   //
1583   // This is a template, not just a plain function with const std::string&amp;,
1584   // because absl::string_view has some interfering non-explicit constructors.
1585   template &lt;class MatcheeStringType&gt;
1586   bool MatchAndExplain(const MatcheeStringType&amp; s,
1587                        MatchResultListener* /* listener */) const {
1588     const std::string&amp; s2(s);
1589     return full_match_ ? RE::FullMatch(s2, *regex_) :
1590         RE::PartialMatch(s2, *regex_);
1591   }
1592 
1593   void DescribeTo(::std::ostream* os) const {
1594     *os &lt;&lt; (full_match_ ? &quot;matches&quot; : &quot;contains&quot;)
1595         &lt;&lt; &quot; regular expression &quot;;
1596     UniversalPrinter&lt;std::string&gt;::Print(regex_-&gt;pattern(), os);
1597   }
1598 
1599   void DescribeNegationTo(::std::ostream* os) const {
1600     *os &lt;&lt; &quot;doesn&#39;t &quot; &lt;&lt; (full_match_ ? &quot;match&quot; : &quot;contain&quot;)
1601         &lt;&lt; &quot; regular expression &quot;;
1602     UniversalPrinter&lt;std::string&gt;::Print(regex_-&gt;pattern(), os);
1603   }
1604 
1605  private:
1606   const internal::linked_ptr&lt;const RE&gt; regex_;
1607   const bool full_match_;
1608 
1609   GTEST_DISALLOW_ASSIGN_(MatchesRegexMatcher);
1610 };
1611 
1612 // Implements a matcher that compares the two fields of a 2-tuple
1613 // using one of the ==, &lt;=, &lt;, etc, operators.  The two fields being
1614 // compared don&#39;t have to have the same type.
1615 //
1616 // The matcher defined here is polymorphic (for example, Eq() can be
1617 // used to match a tuple&lt;int, short&gt;, a tuple&lt;const long&amp;, double&gt;,
1618 // etc).  Therefore we use a template type conversion operator in the
1619 // implementation.
1620 template &lt;typename D, typename Op&gt;
1621 class PairMatchBase {
1622  public:
1623   template &lt;typename T1, typename T2&gt;
1624   operator Matcher&lt; ::testing::tuple&lt;T1, T2&gt; &gt;() const {
1625     return MakeMatcher(new Impl&lt; ::testing::tuple&lt;T1, T2&gt; &gt;);
1626   }
1627   template &lt;typename T1, typename T2&gt;
1628   operator Matcher&lt;const ::testing::tuple&lt;T1, T2&gt;&amp;&gt;() const {
1629     return MakeMatcher(new Impl&lt;const ::testing::tuple&lt;T1, T2&gt;&amp;&gt;);
1630   }
1631 
1632  private:
1633   static ::std::ostream&amp; GetDesc(::std::ostream&amp; os) {  // NOLINT
1634     return os &lt;&lt; D::Desc();
1635   }
1636 
1637   template &lt;typename Tuple&gt;
1638   class Impl : public MatcherInterface&lt;Tuple&gt; {
1639    public:
1640     virtual bool MatchAndExplain(
1641         Tuple args,
1642         MatchResultListener* /* listener */) const {
1643       return Op()(::testing::get&lt;0&gt;(args), ::testing::get&lt;1&gt;(args));
1644     }
1645     virtual void DescribeTo(::std::ostream* os) const {
1646       *os &lt;&lt; &quot;are &quot; &lt;&lt; GetDesc;
1647     }
1648     virtual void DescribeNegationTo(::std::ostream* os) const {
1649       *os &lt;&lt; &quot;aren&#39;t &quot; &lt;&lt; GetDesc;
1650     }
1651   };
1652 };
1653 
1654 class Eq2Matcher : public PairMatchBase&lt;Eq2Matcher, AnyEq&gt; {
1655  public:
1656   static const char* Desc() { return &quot;an equal pair&quot;; }
1657 };
1658 class Ne2Matcher : public PairMatchBase&lt;Ne2Matcher, AnyNe&gt; {
1659  public:
1660   static const char* Desc() { return &quot;an unequal pair&quot;; }
1661 };
1662 class Lt2Matcher : public PairMatchBase&lt;Lt2Matcher, AnyLt&gt; {
1663  public:
1664   static const char* Desc() { return &quot;a pair where the first &lt; the second&quot;; }
1665 };
1666 class Gt2Matcher : public PairMatchBase&lt;Gt2Matcher, AnyGt&gt; {
1667  public:
1668   static const char* Desc() { return &quot;a pair where the first &gt; the second&quot;; }
1669 };
1670 class Le2Matcher : public PairMatchBase&lt;Le2Matcher, AnyLe&gt; {
1671  public:
1672   static const char* Desc() { return &quot;a pair where the first &lt;= the second&quot;; }
1673 };
1674 class Ge2Matcher : public PairMatchBase&lt;Ge2Matcher, AnyGe&gt; {
1675  public:
1676   static const char* Desc() { return &quot;a pair where the first &gt;= the second&quot;; }
1677 };
1678 
1679 // Implements the Not(...) matcher for a particular argument type T.
1680 // We do not nest it inside the NotMatcher class template, as that
1681 // will prevent different instantiations of NotMatcher from sharing
1682 // the same NotMatcherImpl&lt;T&gt; class.
1683 template &lt;typename T&gt;
1684 class NotMatcherImpl : public MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(T)&gt; {
1685  public:
1686   explicit NotMatcherImpl(const Matcher&lt;T&gt;&amp; matcher)
1687       : matcher_(matcher) {}
1688 
1689   virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(T) x,
1690                                MatchResultListener* listener) const {
1691     return !matcher_.MatchAndExplain(x, listener);
1692   }
1693 
1694   virtual void DescribeTo(::std::ostream* os) const {
1695     matcher_.DescribeNegationTo(os);
1696   }
1697 
1698   virtual void DescribeNegationTo(::std::ostream* os) const {
1699     matcher_.DescribeTo(os);
1700   }
1701 
1702  private:
1703   const Matcher&lt;T&gt; matcher_;
1704 
1705   GTEST_DISALLOW_ASSIGN_(NotMatcherImpl);
1706 };
1707 
1708 // Implements the Not(m) matcher, which matches a value that doesn&#39;t
1709 // match matcher m.
1710 template &lt;typename InnerMatcher&gt;
1711 class NotMatcher {
1712  public:
1713   explicit NotMatcher(InnerMatcher matcher) : matcher_(matcher) {}
1714 
1715   // This template type conversion operator allows Not(m) to be used
1716   // to match any type m can match.
1717   template &lt;typename T&gt;
1718   operator Matcher&lt;T&gt;() const {
1719     return Matcher&lt;T&gt;(new NotMatcherImpl&lt;T&gt;(SafeMatcherCast&lt;T&gt;(matcher_)));
1720   }
1721 
1722  private:
1723   InnerMatcher matcher_;
1724 
1725   GTEST_DISALLOW_ASSIGN_(NotMatcher);
1726 };
1727 
1728 // Implements the AllOf(m1, m2) matcher for a particular argument type
1729 // T. We do not nest it inside the BothOfMatcher class template, as
1730 // that will prevent different instantiations of BothOfMatcher from
1731 // sharing the same BothOfMatcherImpl&lt;T&gt; class.
1732 template &lt;typename T&gt;
1733 class AllOfMatcherImpl
1734     : public MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(T)&gt; {
1735  public:
1736   explicit AllOfMatcherImpl(std::vector&lt;Matcher&lt;T&gt; &gt; matchers)
1737       : matchers_(internal::move(matchers)) {}
1738 
1739   virtual void DescribeTo(::std::ostream* os) const {
1740     *os &lt;&lt; &quot;(&quot;;
1741     for (size_t i = 0; i &lt; matchers_.size(); ++i) {
1742       if (i != 0) *os &lt;&lt; &quot;) and (&quot;;
1743       matchers_[i].DescribeTo(os);
1744     }
1745     *os &lt;&lt; &quot;)&quot;;
1746   }
1747 
1748   virtual void DescribeNegationTo(::std::ostream* os) const {
1749     *os &lt;&lt; &quot;(&quot;;
1750     for (size_t i = 0; i &lt; matchers_.size(); ++i) {
1751       if (i != 0) *os &lt;&lt; &quot;) or (&quot;;
1752       matchers_[i].DescribeNegationTo(os);
1753     }
1754     *os &lt;&lt; &quot;)&quot;;
1755   }
1756 
1757   virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(T) x,
1758                                MatchResultListener* listener) const {
1759     // If either matcher1_ or matcher2_ doesn&#39;t match x, we only need
1760     // to explain why one of them fails.
1761     std::string all_match_result;
1762 
1763     for (size_t i = 0; i &lt; matchers_.size(); ++i) {
1764       StringMatchResultListener slistener;
1765       if (matchers_[i].MatchAndExplain(x, &amp;slistener)) {
1766         if (all_match_result.empty()) {
1767           all_match_result = slistener.str();
1768         } else {
1769           std::string result = slistener.str();
1770           if (!result.empty()) {
1771             all_match_result += &quot;, and &quot;;
1772             all_match_result += result;
1773           }
1774         }
1775       } else {
1776         *listener &lt;&lt; slistener.str();
1777         return false;
1778       }
1779     }
1780 
1781     // Otherwise we need to explain why *both* of them match.
1782     *listener &lt;&lt; all_match_result;
1783     return true;
1784   }
1785 
1786  private:
1787   const std::vector&lt;Matcher&lt;T&gt; &gt; matchers_;
1788 
1789   GTEST_DISALLOW_ASSIGN_(AllOfMatcherImpl);
1790 };
1791 
1792 #if GTEST_LANG_CXX11
1793 // VariadicMatcher is used for the variadic implementation of
1794 // AllOf(m_1, m_2, ...) and AnyOf(m_1, m_2, ...).
1795 // CombiningMatcher&lt;T&gt; is used to recursively combine the provided matchers
1796 // (of type Args...).
1797 template &lt;template &lt;typename T&gt; class CombiningMatcher, typename... Args&gt;
1798 class VariadicMatcher {
1799  public:
1800   VariadicMatcher(const Args&amp;... matchers)  // NOLINT
1801       : matchers_(matchers...) {
1802     static_assert(sizeof...(Args) &gt; 0, &quot;Must have at least one matcher.&quot;);
1803   }
1804 
1805   // This template type conversion operator allows an
1806   // VariadicMatcher&lt;Matcher1, Matcher2...&gt; object to match any type that
1807   // all of the provided matchers (Matcher1, Matcher2, ...) can match.
1808   template &lt;typename T&gt;
1809   operator Matcher&lt;T&gt;() const {
1810     std::vector&lt;Matcher&lt;T&gt; &gt; values;
1811     CreateVariadicMatcher&lt;T&gt;(&amp;values, std::integral_constant&lt;size_t, 0&gt;());
1812     return Matcher&lt;T&gt;(new CombiningMatcher&lt;T&gt;(internal::move(values)));
1813   }
1814 
1815  private:
1816   template &lt;typename T, size_t I&gt;
1817   void CreateVariadicMatcher(std::vector&lt;Matcher&lt;T&gt; &gt;* values,
1818                              std::integral_constant&lt;size_t, I&gt;) const {
1819     values-&gt;push_back(SafeMatcherCast&lt;T&gt;(std::get&lt;I&gt;(matchers_)));
1820     CreateVariadicMatcher&lt;T&gt;(values, std::integral_constant&lt;size_t, I + 1&gt;());
1821   }
1822 
1823   template &lt;typename T&gt;
1824   void CreateVariadicMatcher(
1825       std::vector&lt;Matcher&lt;T&gt; &gt;*,
1826       std::integral_constant&lt;size_t, sizeof...(Args)&gt;) const {}
1827 
1828   tuple&lt;Args...&gt; matchers_;
1829 
1830   GTEST_DISALLOW_ASSIGN_(VariadicMatcher);
1831 };
1832 
1833 template &lt;typename... Args&gt;
1834 using AllOfMatcher = VariadicMatcher&lt;AllOfMatcherImpl, Args...&gt;;
1835 
1836 #endif  // GTEST_LANG_CXX11
1837 
1838 // Used for implementing the AllOf(m_1, ..., m_n) matcher, which
1839 // matches a value that matches all of the matchers m_1, ..., and m_n.
1840 template &lt;typename Matcher1, typename Matcher2&gt;
1841 class BothOfMatcher {
1842  public:
1843   BothOfMatcher(Matcher1 matcher1, Matcher2 matcher2)
1844       : matcher1_(matcher1), matcher2_(matcher2) {}
1845 
1846   // This template type conversion operator allows a
1847   // BothOfMatcher&lt;Matcher1, Matcher2&gt; object to match any type that
1848   // both Matcher1 and Matcher2 can match.
1849   template &lt;typename T&gt;
1850   operator Matcher&lt;T&gt;() const {
1851     std::vector&lt;Matcher&lt;T&gt; &gt; values;
1852     values.push_back(SafeMatcherCast&lt;T&gt;(matcher1_));
1853     values.push_back(SafeMatcherCast&lt;T&gt;(matcher2_));
1854     return Matcher&lt;T&gt;(new AllOfMatcherImpl&lt;T&gt;(internal::move(values)));
1855   }
1856 
1857  private:
1858   Matcher1 matcher1_;
1859   Matcher2 matcher2_;
1860 
1861   GTEST_DISALLOW_ASSIGN_(BothOfMatcher);
1862 };
1863 
1864 // Implements the AnyOf(m1, m2) matcher for a particular argument type
1865 // T.  We do not nest it inside the AnyOfMatcher class template, as
1866 // that will prevent different instantiations of AnyOfMatcher from
1867 // sharing the same EitherOfMatcherImpl&lt;T&gt; class.
1868 template &lt;typename T&gt;
1869 class AnyOfMatcherImpl
1870     : public MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(T)&gt; {
1871  public:
1872   explicit AnyOfMatcherImpl(std::vector&lt;Matcher&lt;T&gt; &gt; matchers)
1873       : matchers_(internal::move(matchers)) {}
1874 
1875   virtual void DescribeTo(::std::ostream* os) const {
1876     *os &lt;&lt; &quot;(&quot;;
1877     for (size_t i = 0; i &lt; matchers_.size(); ++i) {
1878       if (i != 0) *os &lt;&lt; &quot;) or (&quot;;
1879       matchers_[i].DescribeTo(os);
1880     }
1881     *os &lt;&lt; &quot;)&quot;;
1882   }
1883 
1884   virtual void DescribeNegationTo(::std::ostream* os) const {
1885     *os &lt;&lt; &quot;(&quot;;
1886     for (size_t i = 0; i &lt; matchers_.size(); ++i) {
1887       if (i != 0) *os &lt;&lt; &quot;) and (&quot;;
1888       matchers_[i].DescribeNegationTo(os);
1889     }
1890     *os &lt;&lt; &quot;)&quot;;
1891   }
1892 
1893   virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(T) x,
1894                                MatchResultListener* listener) const {
1895     std::string no_match_result;
1896 
1897     // If either matcher1_ or matcher2_ matches x, we just need to
1898     // explain why *one* of them matches.
1899     for (size_t i = 0; i &lt; matchers_.size(); ++i) {
1900       StringMatchResultListener slistener;
1901       if (matchers_[i].MatchAndExplain(x, &amp;slistener)) {
1902         *listener &lt;&lt; slistener.str();
1903         return true;
1904       } else {
1905         if (no_match_result.empty()) {
1906           no_match_result = slistener.str();
1907         } else {
1908           std::string result = slistener.str();
1909           if (!result.empty()) {
1910             no_match_result += &quot;, and &quot;;
1911             no_match_result += result;
1912           }
1913         }
1914       }
1915     }
1916 
1917     // Otherwise we need to explain why *both* of them fail.
1918     *listener &lt;&lt; no_match_result;
1919     return false;
1920   }
1921 
1922  private:
1923   const std::vector&lt;Matcher&lt;T&gt; &gt; matchers_;
1924 
1925   GTEST_DISALLOW_ASSIGN_(AnyOfMatcherImpl);
1926 };
1927 
1928 #if GTEST_LANG_CXX11
1929 // AnyOfMatcher is used for the variadic implementation of AnyOf(m_1, m_2, ...).
1930 template &lt;typename... Args&gt;
1931 using AnyOfMatcher = VariadicMatcher&lt;AnyOfMatcherImpl, Args...&gt;;
1932 
1933 #endif  // GTEST_LANG_CXX11
1934 
1935 // Used for implementing the AnyOf(m_1, ..., m_n) matcher, which
1936 // matches a value that matches at least one of the matchers m_1, ...,
1937 // and m_n.
1938 template &lt;typename Matcher1, typename Matcher2&gt;
1939 class EitherOfMatcher {
1940  public:
1941   EitherOfMatcher(Matcher1 matcher1, Matcher2 matcher2)
1942       : matcher1_(matcher1), matcher2_(matcher2) {}
1943 
1944   // This template type conversion operator allows a
1945   // EitherOfMatcher&lt;Matcher1, Matcher2&gt; object to match any type that
1946   // both Matcher1 and Matcher2 can match.
1947   template &lt;typename T&gt;
1948   operator Matcher&lt;T&gt;() const {
1949     std::vector&lt;Matcher&lt;T&gt; &gt; values;
1950     values.push_back(SafeMatcherCast&lt;T&gt;(matcher1_));
1951     values.push_back(SafeMatcherCast&lt;T&gt;(matcher2_));
1952     return Matcher&lt;T&gt;(new AnyOfMatcherImpl&lt;T&gt;(internal::move(values)));
1953   }
1954 
1955  private:
1956   Matcher1 matcher1_;
1957   Matcher2 matcher2_;
1958 
1959   GTEST_DISALLOW_ASSIGN_(EitherOfMatcher);
1960 };
1961 
1962 // Used for implementing Truly(pred), which turns a predicate into a
1963 // matcher.
1964 template &lt;typename Predicate&gt;
1965 class TrulyMatcher {
1966  public:
1967   explicit TrulyMatcher(Predicate pred) : predicate_(pred) {}
1968 
1969   // This method template allows Truly(pred) to be used as a matcher
1970   // for type T where T is the argument type of predicate &#39;pred&#39;.  The
1971   // argument is passed by reference as the predicate may be
1972   // interested in the address of the argument.
1973   template &lt;typename T&gt;
1974   bool MatchAndExplain(T&amp; x,  // NOLINT
1975                        MatchResultListener* /* listener */) const {
1976     // Without the if-statement, MSVC sometimes warns about converting
1977     // a value to bool (warning 4800).
1978     //
1979     // We cannot write &#39;return !!predicate_(x);&#39; as that doesn&#39;t work
1980     // when predicate_(x) returns a class convertible to bool but
1981     // having no operator!().
1982     if (predicate_(x))
1983       return true;
1984     return false;
1985   }
1986 
1987   void DescribeTo(::std::ostream* os) const {
1988     *os &lt;&lt; &quot;satisfies the given predicate&quot;;
1989   }
1990 
1991   void DescribeNegationTo(::std::ostream* os) const {
1992     *os &lt;&lt; &quot;doesn&#39;t satisfy the given predicate&quot;;
1993   }
1994 
1995  private:
1996   Predicate predicate_;
1997 
1998   GTEST_DISALLOW_ASSIGN_(TrulyMatcher);
1999 };
2000 
2001 // Used for implementing Matches(matcher), which turns a matcher into
2002 // a predicate.
2003 template &lt;typename M&gt;
2004 class MatcherAsPredicate {
2005  public:
2006   explicit MatcherAsPredicate(M matcher) : matcher_(matcher) {}
2007 
2008   // This template operator() allows Matches(m) to be used as a
2009   // predicate on type T where m is a matcher on type T.
2010   //
2011   // The argument x is passed by reference instead of by value, as
2012   // some matcher may be interested in its address (e.g. as in
2013   // Matches(Ref(n))(x)).
2014   template &lt;typename T&gt;
2015   bool operator()(const T&amp; x) const {
2016     // We let matcher_ commit to a particular type here instead of
2017     // when the MatcherAsPredicate object was constructed.  This
2018     // allows us to write Matches(m) where m is a polymorphic matcher
2019     // (e.g. Eq(5)).
2020     //
2021     // If we write Matcher&lt;T&gt;(matcher_).Matches(x) here, it won&#39;t
2022     // compile when matcher_ has type Matcher&lt;const T&amp;&gt;; if we write
2023     // Matcher&lt;const T&amp;&gt;(matcher_).Matches(x) here, it won&#39;t compile
2024     // when matcher_ has type Matcher&lt;T&gt;; if we just write
2025     // matcher_.Matches(x), it won&#39;t compile when matcher_ is
2026     // polymorphic, e.g. Eq(5).
2027     //
2028     // MatcherCast&lt;const T&amp;&gt;() is necessary for making the code work
2029     // in all of the above situations.
2030     return MatcherCast&lt;const T&amp;&gt;(matcher_).Matches(x);
2031   }
2032 
2033  private:
2034   M matcher_;
2035 
2036   GTEST_DISALLOW_ASSIGN_(MatcherAsPredicate);
2037 };
2038 
2039 // For implementing ASSERT_THAT() and EXPECT_THAT().  The template
2040 // argument M must be a type that can be converted to a matcher.
2041 template &lt;typename M&gt;
2042 class PredicateFormatterFromMatcher {
2043  public:
2044   explicit PredicateFormatterFromMatcher(M m) : matcher_(internal::move(m)) {}
2045 
2046   // This template () operator allows a PredicateFormatterFromMatcher
2047   // object to act as a predicate-formatter suitable for using with
2048   // Google Test&#39;s EXPECT_PRED_FORMAT1() macro.
2049   template &lt;typename T&gt;
2050   AssertionResult operator()(const char* value_text, const T&amp; x) const {
2051     // We convert matcher_ to a Matcher&lt;const T&amp;&gt; *now* instead of
2052     // when the PredicateFormatterFromMatcher object was constructed,
2053     // as matcher_ may be polymorphic (e.g. NotNull()) and we won&#39;t
2054     // know which type to instantiate it to until we actually see the
2055     // type of x here.
2056     //
2057     // We write SafeMatcherCast&lt;const T&amp;&gt;(matcher_) instead of
2058     // Matcher&lt;const T&amp;&gt;(matcher_), as the latter won&#39;t compile when
2059     // matcher_ has type Matcher&lt;T&gt; (e.g. An&lt;int&gt;()).
2060     // We don&#39;t write MatcherCast&lt;const T&amp;&gt; either, as that allows
2061     // potentially unsafe downcasting of the matcher argument.
2062     const Matcher&lt;const T&amp;&gt; matcher = SafeMatcherCast&lt;const T&amp;&gt;(matcher_);
2063     StringMatchResultListener listener;
2064     if (MatchPrintAndExplain(x, matcher, &amp;listener))
2065       return AssertionSuccess();
2066 
2067     ::std::stringstream ss;
2068     ss &lt;&lt; &quot;Value of: &quot; &lt;&lt; value_text &lt;&lt; &quot;\n&quot;
2069        &lt;&lt; &quot;Expected: &quot;;
2070     matcher.DescribeTo(&amp;ss);
2071     ss &lt;&lt; &quot;\n  Actual: &quot; &lt;&lt; listener.str();
2072     return AssertionFailure() &lt;&lt; ss.str();
2073   }
2074 
2075  private:
2076   const M matcher_;
2077 
2078   GTEST_DISALLOW_ASSIGN_(PredicateFormatterFromMatcher);
2079 };
2080 
2081 // A helper function for converting a matcher to a predicate-formatter
2082 // without the user needing to explicitly write the type.  This is
2083 // used for implementing ASSERT_THAT() and EXPECT_THAT().
2084 // Implementation detail: &#39;matcher&#39; is received by-value to force decaying.
2085 template &lt;typename M&gt;
2086 inline PredicateFormatterFromMatcher&lt;M&gt;
2087 MakePredicateFormatterFromMatcher(M matcher) {
2088   return PredicateFormatterFromMatcher&lt;M&gt;(internal::move(matcher));
2089 }
2090 
2091 // Implements the polymorphic floating point equality matcher, which matches
2092 // two float values using ULP-based approximation or, optionally, a
2093 // user-specified epsilon.  The template is meant to be instantiated with
2094 // FloatType being either float or double.
2095 template &lt;typename FloatType&gt;
2096 class FloatingEqMatcher {
2097  public:
2098   // Constructor for FloatingEqMatcher.
2099   // The matcher&#39;s input will be compared with expected.  The matcher treats two
2100   // NANs as equal if nan_eq_nan is true.  Otherwise, under IEEE standards,
2101   // equality comparisons between NANs will always return false.  We specify a
2102   // negative max_abs_error_ term to indicate that ULP-based approximation will
2103   // be used for comparison.
2104   FloatingEqMatcher(FloatType expected, bool nan_eq_nan) :
2105     expected_(expected), nan_eq_nan_(nan_eq_nan), max_abs_error_(-1) {
2106   }
2107 
2108   // Constructor that supports a user-specified max_abs_error that will be used
2109   // for comparison instead of ULP-based approximation.  The max absolute
2110   // should be non-negative.
2111   FloatingEqMatcher(FloatType expected, bool nan_eq_nan,
2112                     FloatType max_abs_error)
2113       : expected_(expected),
2114         nan_eq_nan_(nan_eq_nan),
2115         max_abs_error_(max_abs_error) {
2116     GTEST_CHECK_(max_abs_error &gt;= 0)
2117         &lt;&lt; &quot;, where max_abs_error is&quot; &lt;&lt; max_abs_error;
2118   }
2119 
2120   // Implements floating point equality matcher as a Matcher&lt;T&gt;.
2121   template &lt;typename T&gt;
2122   class Impl : public MatcherInterface&lt;T&gt; {
2123    public:
2124     Impl(FloatType expected, bool nan_eq_nan, FloatType max_abs_error)
2125         : expected_(expected),
2126           nan_eq_nan_(nan_eq_nan),
2127           max_abs_error_(max_abs_error) {}
2128 
2129     virtual bool MatchAndExplain(T value,
2130                                  MatchResultListener* listener) const {
2131       const FloatingPoint&lt;FloatType&gt; actual(value), expected(expected_);
2132 
2133       // Compares NaNs first, if nan_eq_nan_ is true.
2134       if (actual.is_nan() || expected.is_nan()) {
2135         if (actual.is_nan() &amp;&amp; expected.is_nan()) {
2136           return nan_eq_nan_;
2137         }
2138         // One is nan; the other is not nan.
2139         return false;
2140       }
2141       if (HasMaxAbsError()) {
2142         // We perform an equality check so that inf will match inf, regardless
2143         // of error bounds.  If the result of value - expected_ would result in
2144         // overflow or if either value is inf, the default result is infinity,
2145         // which should only match if max_abs_error_ is also infinity.
2146         if (value == expected_) {
2147           return true;
2148         }
2149 
2150         const FloatType diff = value - expected_;
2151         if (fabs(diff) &lt;= max_abs_error_) {
2152           return true;
2153         }
2154 
2155         if (listener-&gt;IsInterested()) {
2156           *listener &lt;&lt; &quot;which is &quot; &lt;&lt; diff &lt;&lt; &quot; from &quot; &lt;&lt; expected_;
2157         }
2158         return false;
2159       } else {
2160         return actual.AlmostEquals(expected);
2161       }
2162     }
2163 
2164     virtual void DescribeTo(::std::ostream* os) const {
2165       // os-&gt;precision() returns the previously set precision, which we
2166       // store to restore the ostream to its original configuration
2167       // after outputting.
2168       const ::std::streamsize old_precision = os-&gt;precision(
2169           ::std::numeric_limits&lt;FloatType&gt;::digits10 + 2);
2170       if (FloatingPoint&lt;FloatType&gt;(expected_).is_nan()) {
2171         if (nan_eq_nan_) {
2172           *os &lt;&lt; &quot;is NaN&quot;;
2173         } else {
2174           *os &lt;&lt; &quot;never matches&quot;;
2175         }
2176       } else {
2177         *os &lt;&lt; &quot;is approximately &quot; &lt;&lt; expected_;
2178         if (HasMaxAbsError()) {
2179           *os &lt;&lt; &quot; (absolute error &lt;= &quot; &lt;&lt; max_abs_error_ &lt;&lt; &quot;)&quot;;
2180         }
2181       }
2182       os-&gt;precision(old_precision);
2183     }
2184 
2185     virtual void DescribeNegationTo(::std::ostream* os) const {
2186       // As before, get original precision.
2187       const ::std::streamsize old_precision = os-&gt;precision(
2188           ::std::numeric_limits&lt;FloatType&gt;::digits10 + 2);
2189       if (FloatingPoint&lt;FloatType&gt;(expected_).is_nan()) {
2190         if (nan_eq_nan_) {
2191           *os &lt;&lt; &quot;isn&#39;t NaN&quot;;
2192         } else {
2193           *os &lt;&lt; &quot;is anything&quot;;
2194         }
2195       } else {
2196         *os &lt;&lt; &quot;isn&#39;t approximately &quot; &lt;&lt; expected_;
2197         if (HasMaxAbsError()) {
2198           *os &lt;&lt; &quot; (absolute error &gt; &quot; &lt;&lt; max_abs_error_ &lt;&lt; &quot;)&quot;;
2199         }
2200       }
2201       // Restore original precision.
2202       os-&gt;precision(old_precision);
2203     }
2204 
2205    private:
2206     bool HasMaxAbsError() const {
2207       return max_abs_error_ &gt;= 0;
2208     }
2209 
2210     const FloatType expected_;
2211     const bool nan_eq_nan_;
2212     // max_abs_error will be used for value comparison when &gt;= 0.
2213     const FloatType max_abs_error_;
2214 
2215     GTEST_DISALLOW_ASSIGN_(Impl);
2216   };
2217 
2218   // The following 3 type conversion operators allow FloatEq(expected) and
2219   // NanSensitiveFloatEq(expected) to be used as a Matcher&lt;float&gt;, a
2220   // Matcher&lt;const float&amp;&gt;, or a Matcher&lt;float&amp;&gt;, but nothing else.
2221   // (While Google&#39;s C++ coding style doesn&#39;t allow arguments passed
2222   // by non-const reference, we may see them in code not conforming to
2223   // the style.  Therefore Google Mock needs to support them.)
2224   operator Matcher&lt;FloatType&gt;() const {
2225     return MakeMatcher(
2226         new Impl&lt;FloatType&gt;(expected_, nan_eq_nan_, max_abs_error_));
2227   }
2228 
2229   operator Matcher&lt;const FloatType&amp;&gt;() const {
2230     return MakeMatcher(
2231         new Impl&lt;const FloatType&amp;&gt;(expected_, nan_eq_nan_, max_abs_error_));
2232   }
2233 
2234   operator Matcher&lt;FloatType&amp;&gt;() const {
2235     return MakeMatcher(
2236         new Impl&lt;FloatType&amp;&gt;(expected_, nan_eq_nan_, max_abs_error_));
2237   }
2238 
2239  private:
2240   const FloatType expected_;
2241   const bool nan_eq_nan_;
2242   // max_abs_error will be used for value comparison when &gt;= 0.
2243   const FloatType max_abs_error_;
2244 
2245   GTEST_DISALLOW_ASSIGN_(FloatingEqMatcher);
2246 };
2247 
2248 // A 2-tuple (&quot;binary&quot;) wrapper around FloatingEqMatcher:
2249 // FloatingEq2Matcher() matches (x, y) by matching FloatingEqMatcher(x, false)
2250 // against y, and FloatingEq2Matcher(e) matches FloatingEqMatcher(x, false, e)
2251 // against y. The former implements &quot;Eq&quot;, the latter &quot;Near&quot;. At present, there
2252 // is no version that compares NaNs as equal.
2253 template &lt;typename FloatType&gt;
2254 class FloatingEq2Matcher {
2255  public:
2256   FloatingEq2Matcher() { Init(-1, false); }
2257 
2258   explicit FloatingEq2Matcher(bool nan_eq_nan) { Init(-1, nan_eq_nan); }
2259 
2260   explicit FloatingEq2Matcher(FloatType max_abs_error) {
2261     Init(max_abs_error, false);
2262   }
2263 
2264   FloatingEq2Matcher(FloatType max_abs_error, bool nan_eq_nan) {
2265     Init(max_abs_error, nan_eq_nan);
2266   }
2267 
2268   template &lt;typename T1, typename T2&gt;
2269   operator Matcher&lt; ::testing::tuple&lt;T1, T2&gt; &gt;() const {
2270     return MakeMatcher(
2271         new Impl&lt; ::testing::tuple&lt;T1, T2&gt; &gt;(max_abs_error_, nan_eq_nan_));
2272   }
2273   template &lt;typename T1, typename T2&gt;
2274   operator Matcher&lt;const ::testing::tuple&lt;T1, T2&gt;&amp;&gt;() const {
2275     return MakeMatcher(
2276         new Impl&lt;const ::testing::tuple&lt;T1, T2&gt;&amp;&gt;(max_abs_error_, nan_eq_nan_));
2277   }
2278 
2279  private:
2280   static ::std::ostream&amp; GetDesc(::std::ostream&amp; os) {  // NOLINT
2281     return os &lt;&lt; &quot;an almost-equal pair&quot;;
2282   }
2283 
2284   template &lt;typename Tuple&gt;
2285   class Impl : public MatcherInterface&lt;Tuple&gt; {
2286    public:
2287     Impl(FloatType max_abs_error, bool nan_eq_nan) :
2288         max_abs_error_(max_abs_error),
2289         nan_eq_nan_(nan_eq_nan) {}
2290 
2291     virtual bool MatchAndExplain(Tuple args,
2292                                  MatchResultListener* listener) const {
2293       if (max_abs_error_ == -1) {
2294         FloatingEqMatcher&lt;FloatType&gt; fm(::testing::get&lt;0&gt;(args), nan_eq_nan_);
2295         return static_cast&lt;Matcher&lt;FloatType&gt; &gt;(fm).MatchAndExplain(
2296             ::testing::get&lt;1&gt;(args), listener);
2297       } else {
2298         FloatingEqMatcher&lt;FloatType&gt; fm(::testing::get&lt;0&gt;(args), nan_eq_nan_,
2299                                         max_abs_error_);
2300         return static_cast&lt;Matcher&lt;FloatType&gt; &gt;(fm).MatchAndExplain(
2301             ::testing::get&lt;1&gt;(args), listener);
2302       }
2303     }
2304     virtual void DescribeTo(::std::ostream* os) const {
2305       *os &lt;&lt; &quot;are &quot; &lt;&lt; GetDesc;
2306     }
2307     virtual void DescribeNegationTo(::std::ostream* os) const {
2308       *os &lt;&lt; &quot;aren&#39;t &quot; &lt;&lt; GetDesc;
2309     }
2310 
2311    private:
2312     FloatType max_abs_error_;
2313     const bool nan_eq_nan_;
2314   };
2315 
2316   void Init(FloatType max_abs_error_val, bool nan_eq_nan_val) {
2317     max_abs_error_ = max_abs_error_val;
2318     nan_eq_nan_ = nan_eq_nan_val;
2319   }
2320   FloatType max_abs_error_;
2321   bool nan_eq_nan_;
2322 };
2323 
2324 // Implements the Pointee(m) matcher for matching a pointer whose
2325 // pointee matches matcher m.  The pointer can be either raw or smart.
2326 template &lt;typename InnerMatcher&gt;
2327 class PointeeMatcher {
2328  public:
2329   explicit PointeeMatcher(const InnerMatcher&amp; matcher) : matcher_(matcher) {}
2330 
2331   // This type conversion operator template allows Pointee(m) to be
2332   // used as a matcher for any pointer type whose pointee type is
2333   // compatible with the inner matcher, where type Pointer can be
2334   // either a raw pointer or a smart pointer.
2335   //
2336   // The reason we do this instead of relying on
2337   // MakePolymorphicMatcher() is that the latter is not flexible
2338   // enough for implementing the DescribeTo() method of Pointee().
2339   template &lt;typename Pointer&gt;
2340   operator Matcher&lt;Pointer&gt;() const {
2341     return Matcher&lt;Pointer&gt;(
2342         new Impl&lt;GTEST_REFERENCE_TO_CONST_(Pointer)&gt;(matcher_));
2343   }
2344 
2345  private:
2346   // The monomorphic implementation that works for a particular pointer type.
2347   template &lt;typename Pointer&gt;
2348   class Impl : public MatcherInterface&lt;Pointer&gt; {
2349    public:
2350     typedef typename PointeeOf&lt;GTEST_REMOVE_CONST_(  // NOLINT
2351         GTEST_REMOVE_REFERENCE_(Pointer))&gt;::type Pointee;
2352 
2353     explicit Impl(const InnerMatcher&amp; matcher)
2354         : matcher_(MatcherCast&lt;const Pointee&amp;&gt;(matcher)) {}
2355 
2356     virtual void DescribeTo(::std::ostream* os) const {
2357       *os &lt;&lt; &quot;points to a value that &quot;;
2358       matcher_.DescribeTo(os);
2359     }
2360 
2361     virtual void DescribeNegationTo(::std::ostream* os) const {
2362       *os &lt;&lt; &quot;does not point to a value that &quot;;
2363       matcher_.DescribeTo(os);
2364     }
2365 
2366     virtual bool MatchAndExplain(Pointer pointer,
2367                                  MatchResultListener* listener) const {
2368       if (GetRawPointer(pointer) == NULL)
2369         return false;
2370 
2371       *listener &lt;&lt; &quot;which points to &quot;;
2372       return MatchPrintAndExplain(*pointer, matcher_, listener);
2373     }
2374 
2375    private:
2376     const Matcher&lt;const Pointee&amp;&gt; matcher_;
2377 
2378     GTEST_DISALLOW_ASSIGN_(Impl);
2379   };
2380 
2381   const InnerMatcher matcher_;
2382 
2383   GTEST_DISALLOW_ASSIGN_(PointeeMatcher);
2384 };
2385 
2386 #if GTEST_HAS_RTTI
2387 // Implements the WhenDynamicCastTo&lt;T&gt;(m) matcher that matches a pointer or
2388 // reference that matches inner_matcher when dynamic_cast&lt;T&gt; is applied.
2389 // The result of dynamic_cast&lt;To&gt; is forwarded to the inner matcher.
2390 // If To is a pointer and the cast fails, the inner matcher will receive NULL.
2391 // If To is a reference and the cast fails, this matcher returns false
2392 // immediately.
2393 template &lt;typename To&gt;
2394 class WhenDynamicCastToMatcherBase {
2395  public:
2396   explicit WhenDynamicCastToMatcherBase(const Matcher&lt;To&gt;&amp; matcher)
2397       : matcher_(matcher) {}
2398 
2399   void DescribeTo(::std::ostream* os) const {
2400     GetCastTypeDescription(os);
2401     matcher_.DescribeTo(os);
2402   }
2403 
2404   void DescribeNegationTo(::std::ostream* os) const {
2405     GetCastTypeDescription(os);
2406     matcher_.DescribeNegationTo(os);
2407   }
2408 
2409  protected:
2410   const Matcher&lt;To&gt; matcher_;
2411 
2412   static std::string GetToName() {
2413     return GetTypeName&lt;To&gt;();
2414   }
2415 
2416  private:
2417   static void GetCastTypeDescription(::std::ostream* os) {
2418     *os &lt;&lt; &quot;when dynamic_cast to &quot; &lt;&lt; GetToName() &lt;&lt; &quot;, &quot;;
2419   }
2420 
2421   GTEST_DISALLOW_ASSIGN_(WhenDynamicCastToMatcherBase);
2422 };
2423 
2424 // Primary template.
2425 // To is a pointer. Cast and forward the result.
2426 template &lt;typename To&gt;
2427 class WhenDynamicCastToMatcher : public WhenDynamicCastToMatcherBase&lt;To&gt; {
2428  public:
2429   explicit WhenDynamicCastToMatcher(const Matcher&lt;To&gt;&amp; matcher)
2430       : WhenDynamicCastToMatcherBase&lt;To&gt;(matcher) {}
2431 
2432   template &lt;typename From&gt;
2433   bool MatchAndExplain(From from, MatchResultListener* listener) const {
2434     // FIXME: Add more detail on failures. ie did the dyn_cast fail?
2435     To to = dynamic_cast&lt;To&gt;(from);
2436     return MatchPrintAndExplain(to, this-&gt;matcher_, listener);
2437   }
2438 };
2439 
2440 // Specialize for references.
2441 // In this case we return false if the dynamic_cast fails.
2442 template &lt;typename To&gt;
2443 class WhenDynamicCastToMatcher&lt;To&amp;&gt; : public WhenDynamicCastToMatcherBase&lt;To&amp;&gt; {
2444  public:
2445   explicit WhenDynamicCastToMatcher(const Matcher&lt;To&amp;&gt;&amp; matcher)
2446       : WhenDynamicCastToMatcherBase&lt;To&amp;&gt;(matcher) {}
2447 
2448   template &lt;typename From&gt;
2449   bool MatchAndExplain(From&amp; from, MatchResultListener* listener) const {
2450     // We don&#39;t want an std::bad_cast here, so do the cast with pointers.
2451     To* to = dynamic_cast&lt;To*&gt;(&amp;from);
2452     if (to == NULL) {
2453       *listener &lt;&lt; &quot;which cannot be dynamic_cast to &quot; &lt;&lt; this-&gt;GetToName();
2454       return false;
2455     }
2456     return MatchPrintAndExplain(*to, this-&gt;matcher_, listener);
2457   }
2458 };
2459 #endif  // GTEST_HAS_RTTI
2460 
2461 // Implements the Field() matcher for matching a field (i.e. member
2462 // variable) of an object.
2463 template &lt;typename Class, typename FieldType&gt;
2464 class FieldMatcher {
2465  public:
2466   FieldMatcher(FieldType Class::*field,
2467                const Matcher&lt;const FieldType&amp;&gt;&amp; matcher)
2468       : field_(field), matcher_(matcher), whose_field_(&quot;whose given field &quot;) {}
2469 
2470   FieldMatcher(const std::string&amp; field_name, FieldType Class::*field,
2471                const Matcher&lt;const FieldType&amp;&gt;&amp; matcher)
2472       : field_(field),
2473         matcher_(matcher),
2474         whose_field_(&quot;whose field `&quot; + field_name + &quot;` &quot;) {}
2475 
2476   void DescribeTo(::std::ostream* os) const {
2477     *os &lt;&lt; &quot;is an object &quot; &lt;&lt; whose_field_;
2478     matcher_.DescribeTo(os);
2479   }
2480 
2481   void DescribeNegationTo(::std::ostream* os) const {
2482     *os &lt;&lt; &quot;is an object &quot; &lt;&lt; whose_field_;
2483     matcher_.DescribeNegationTo(os);
2484   }
2485 
2486   template &lt;typename T&gt;
2487   bool MatchAndExplain(const T&amp; value, MatchResultListener* listener) const {
2488     return MatchAndExplainImpl(
2489         typename ::testing::internal::
2490             is_pointer&lt;GTEST_REMOVE_CONST_(T)&gt;::type(),
2491         value, listener);
2492   }
2493 
2494  private:
2495   // The first argument of MatchAndExplainImpl() is needed to help
2496   // Symbian&#39;s C++ compiler choose which overload to use.  Its type is
2497   // true_type iff the Field() matcher is used to match a pointer.
2498   bool MatchAndExplainImpl(false_type /* is_not_pointer */, const Class&amp; obj,
2499                            MatchResultListener* listener) const {
2500     *listener &lt;&lt; whose_field_ &lt;&lt; &quot;is &quot;;
2501     return MatchPrintAndExplain(obj.*field_, matcher_, listener);
2502   }
2503 
2504   bool MatchAndExplainImpl(true_type /* is_pointer */, const Class* p,
2505                            MatchResultListener* listener) const {
2506     if (p == NULL)
2507       return false;
2508 
2509     *listener &lt;&lt; &quot;which points to an object &quot;;
2510     // Since *p has a field, it must be a class/struct/union type and
2511     // thus cannot be a pointer.  Therefore we pass false_type() as
2512     // the first argument.
2513     return MatchAndExplainImpl(false_type(), *p, listener);
2514   }
2515 
2516   const FieldType Class::*field_;
2517   const Matcher&lt;const FieldType&amp;&gt; matcher_;
2518 
2519   // Contains either &quot;whose given field &quot; if the name of the field is unknown
2520   // or &quot;whose field `name_of_field` &quot; if the name is known.
2521   const std::string whose_field_;
2522 
2523   GTEST_DISALLOW_ASSIGN_(FieldMatcher);
2524 };
2525 
2526 // Implements the Property() matcher for matching a property
2527 // (i.e. return value of a getter method) of an object.
2528 //
2529 // Property is a const-qualified member function of Class returning
2530 // PropertyType.
2531 template &lt;typename Class, typename PropertyType, typename Property&gt;
2532 class PropertyMatcher {
2533  public:
2534   // The property may have a reference type, so &#39;const PropertyType&amp;&#39;
2535   // may cause double references and fail to compile.  That&#39;s why we
2536   // need GTEST_REFERENCE_TO_CONST, which works regardless of
2537   // PropertyType being a reference or not.
2538   typedef GTEST_REFERENCE_TO_CONST_(PropertyType) RefToConstProperty;
2539 
2540   PropertyMatcher(Property property, const Matcher&lt;RefToConstProperty&gt;&amp; matcher)
2541       : property_(property),
2542         matcher_(matcher),
2543         whose_property_(&quot;whose given property &quot;) {}
2544 
2545   PropertyMatcher(const std::string&amp; property_name, Property property,
2546                   const Matcher&lt;RefToConstProperty&gt;&amp; matcher)
2547       : property_(property),
2548         matcher_(matcher),
2549         whose_property_(&quot;whose property `&quot; + property_name + &quot;` &quot;) {}
2550 
2551   void DescribeTo(::std::ostream* os) const {
2552     *os &lt;&lt; &quot;is an object &quot; &lt;&lt; whose_property_;
2553     matcher_.DescribeTo(os);
2554   }
2555 
2556   void DescribeNegationTo(::std::ostream* os) const {
2557     *os &lt;&lt; &quot;is an object &quot; &lt;&lt; whose_property_;
2558     matcher_.DescribeNegationTo(os);
2559   }
2560 
2561   template &lt;typename T&gt;
2562   bool MatchAndExplain(const T&amp;value, MatchResultListener* listener) const {
2563     return MatchAndExplainImpl(
2564         typename ::testing::internal::
2565             is_pointer&lt;GTEST_REMOVE_CONST_(T)&gt;::type(),
2566         value, listener);
2567   }
2568 
2569  private:
2570   // The first argument of MatchAndExplainImpl() is needed to help
2571   // Symbian&#39;s C++ compiler choose which overload to use.  Its type is
2572   // true_type iff the Property() matcher is used to match a pointer.
2573   bool MatchAndExplainImpl(false_type /* is_not_pointer */, const Class&amp; obj,
2574                            MatchResultListener* listener) const {
2575     *listener &lt;&lt; whose_property_ &lt;&lt; &quot;is &quot;;
2576     // Cannot pass the return value (for example, int) to MatchPrintAndExplain,
2577     // which takes a non-const reference as argument.
2578 #if defined(_PREFAST_ ) &amp;&amp; _MSC_VER == 1800
2579     // Workaround bug in VC++ 2013&#39;s /analyze parser.
2580     // https://connect.microsoft.com/VisualStudio/feedback/details/1106363/internal-compiler-error-with-analyze-due-to-failure-to-infer-move
2581     posix::Abort();  // To make sure it is never run.
2582     return false;
2583 #else
2584     RefToConstProperty result = (obj.*property_)();
2585     return MatchPrintAndExplain(result, matcher_, listener);
2586 #endif
2587   }
2588 
2589   bool MatchAndExplainImpl(true_type /* is_pointer */, const Class* p,
2590                            MatchResultListener* listener) const {
2591     if (p == NULL)
2592       return false;
2593 
2594     *listener &lt;&lt; &quot;which points to an object &quot;;
2595     // Since *p has a property method, it must be a class/struct/union
2596     // type and thus cannot be a pointer.  Therefore we pass
2597     // false_type() as the first argument.
2598     return MatchAndExplainImpl(false_type(), *p, listener);
2599   }
2600 
2601   Property property_;
2602   const Matcher&lt;RefToConstProperty&gt; matcher_;
2603 
2604   // Contains either &quot;whose given property &quot; if the name of the property is
2605   // unknown or &quot;whose property `name_of_property` &quot; if the name is known.
2606   const std::string whose_property_;
2607 
2608   GTEST_DISALLOW_ASSIGN_(PropertyMatcher);
2609 };
2610 
2611 // Type traits specifying various features of different functors for ResultOf.
2612 // The default template specifies features for functor objects.
2613 template &lt;typename Functor&gt;
2614 struct CallableTraits {
2615   typedef Functor StorageType;
2616 
2617   static void CheckIsValid(Functor /* functor */) {}
2618 
2619 #if GTEST_LANG_CXX11
2620   template &lt;typename T&gt;
2621   static auto Invoke(Functor f, T arg) -&gt; decltype(f(arg)) { return f(arg); }
2622 #else
2623   typedef typename Functor::result_type ResultType;
2624   template &lt;typename T&gt;
2625   static ResultType Invoke(Functor f, T arg) { return f(arg); }
2626 #endif
2627 };
2628 
2629 // Specialization for function pointers.
2630 template &lt;typename ArgType, typename ResType&gt;
2631 struct CallableTraits&lt;ResType(*)(ArgType)&gt; {
2632   typedef ResType ResultType;
2633   typedef ResType(*StorageType)(ArgType);
2634 
2635   static void CheckIsValid(ResType(*f)(ArgType)) {
2636     GTEST_CHECK_(f != NULL)
2637         &lt;&lt; &quot;NULL function pointer is passed into ResultOf().&quot;;
2638   }
2639   template &lt;typename T&gt;
2640   static ResType Invoke(ResType(*f)(ArgType), T arg) {
2641     return (*f)(arg);
2642   }
2643 };
2644 
2645 // Implements the ResultOf() matcher for matching a return value of a
2646 // unary function of an object.
2647 template &lt;typename Callable, typename InnerMatcher&gt;
2648 class ResultOfMatcher {
2649  public:
2650   ResultOfMatcher(Callable callable, InnerMatcher matcher)
2651       : callable_(internal::move(callable)), matcher_(internal::move(matcher)) {
2652     CallableTraits&lt;Callable&gt;::CheckIsValid(callable_);
2653   }
2654 
2655   template &lt;typename T&gt;
2656   operator Matcher&lt;T&gt;() const {
2657     return Matcher&lt;T&gt;(new Impl&lt;T&gt;(callable_, matcher_));
2658   }
2659 
2660  private:
2661   typedef typename CallableTraits&lt;Callable&gt;::StorageType CallableStorageType;
2662 
2663   template &lt;typename T&gt;
2664   class Impl : public MatcherInterface&lt;T&gt; {
2665 #if GTEST_LANG_CXX11
2666     using ResultType = decltype(CallableTraits&lt;Callable&gt;::template Invoke&lt;T&gt;(
2667         std::declval&lt;CallableStorageType&gt;(), std::declval&lt;T&gt;()));
2668 #else
2669     typedef typename CallableTraits&lt;Callable&gt;::ResultType ResultType;
2670 #endif
2671 
2672    public:
2673     template &lt;typename M&gt;
2674     Impl(const CallableStorageType&amp; callable, const M&amp; matcher)
2675         : callable_(callable), matcher_(MatcherCast&lt;ResultType&gt;(matcher)) {}
2676 
2677     virtual void DescribeTo(::std::ostream* os) const {
2678       *os &lt;&lt; &quot;is mapped by the given callable to a value that &quot;;
2679       matcher_.DescribeTo(os);
2680     }
2681 
2682     virtual void DescribeNegationTo(::std::ostream* os) const {
2683       *os &lt;&lt; &quot;is mapped by the given callable to a value that &quot;;
2684       matcher_.DescribeNegationTo(os);
2685     }
2686 
2687     virtual bool MatchAndExplain(T obj, MatchResultListener* listener) const {
2688       *listener &lt;&lt; &quot;which is mapped by the given callable to &quot;;
2689       // Cannot pass the return value directly to MatchPrintAndExplain, which
2690       // takes a non-const reference as argument.
2691       // Also, specifying template argument explicitly is needed because T could
2692       // be a non-const reference (e.g. Matcher&lt;Uncopyable&amp;&gt;).
2693       ResultType result =
2694           CallableTraits&lt;Callable&gt;::template Invoke&lt;T&gt;(callable_, obj);
2695       return MatchPrintAndExplain(result, matcher_, listener);
2696     }
2697 
2698    private:
2699     // Functors often define operator() as non-const method even though
2700     // they are actually stateless. But we need to use them even when
2701     // &#39;this&#39; is a const pointer. It&#39;s the user&#39;s responsibility not to
2702     // use stateful callables with ResultOf(), which doesn&#39;t guarantee
2703     // how many times the callable will be invoked.
2704     mutable CallableStorageType callable_;
2705     const Matcher&lt;ResultType&gt; matcher_;
2706 
2707     GTEST_DISALLOW_ASSIGN_(Impl);
2708   };  // class Impl
2709 
2710   const CallableStorageType callable_;
2711   const InnerMatcher matcher_;
2712 
2713   GTEST_DISALLOW_ASSIGN_(ResultOfMatcher);
2714 };
2715 
2716 // Implements a matcher that checks the size of an STL-style container.
2717 template &lt;typename SizeMatcher&gt;
2718 class SizeIsMatcher {
2719  public:
2720   explicit SizeIsMatcher(const SizeMatcher&amp; size_matcher)
2721        : size_matcher_(size_matcher) {
2722   }
2723 
2724   template &lt;typename Container&gt;
2725   operator Matcher&lt;Container&gt;() const {
2726     return MakeMatcher(new Impl&lt;Container&gt;(size_matcher_));
2727   }
2728 
2729   template &lt;typename Container&gt;
2730   class Impl : public MatcherInterface&lt;Container&gt; {
2731    public:
2732     typedef internal::StlContainerView&lt;
2733          GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt; ContainerView;
2734     typedef typename ContainerView::type::size_type SizeType;
2735     explicit Impl(const SizeMatcher&amp; size_matcher)
2736         : size_matcher_(MatcherCast&lt;SizeType&gt;(size_matcher)) {}
2737 
2738     virtual void DescribeTo(::std::ostream* os) const {
2739       *os &lt;&lt; &quot;size &quot;;
2740       size_matcher_.DescribeTo(os);
2741     }
2742     virtual void DescribeNegationTo(::std::ostream* os) const {
2743       *os &lt;&lt; &quot;size &quot;;
2744       size_matcher_.DescribeNegationTo(os);
2745     }
2746 
2747     virtual bool MatchAndExplain(Container container,
2748                                  MatchResultListener* listener) const {
2749       SizeType size = container.size();
2750       StringMatchResultListener size_listener;
2751       const bool result = size_matcher_.MatchAndExplain(size, &amp;size_listener);
2752       *listener
2753           &lt;&lt; &quot;whose size &quot; &lt;&lt; size &lt;&lt; (result ? &quot; matches&quot; : &quot; doesn&#39;t match&quot;);
2754       PrintIfNotEmpty(size_listener.str(), listener-&gt;stream());
2755       return result;
2756     }
2757 
2758    private:
2759     const Matcher&lt;SizeType&gt; size_matcher_;
2760     GTEST_DISALLOW_ASSIGN_(Impl);
2761   };
2762 
2763  private:
2764   const SizeMatcher size_matcher_;
2765   GTEST_DISALLOW_ASSIGN_(SizeIsMatcher);
2766 };
2767 
2768 // Implements a matcher that checks the begin()..end() distance of an STL-style
2769 // container.
2770 template &lt;typename DistanceMatcher&gt;
2771 class BeginEndDistanceIsMatcher {
2772  public:
2773   explicit BeginEndDistanceIsMatcher(const DistanceMatcher&amp; distance_matcher)
2774       : distance_matcher_(distance_matcher) {}
2775 
2776   template &lt;typename Container&gt;
2777   operator Matcher&lt;Container&gt;() const {
2778     return MakeMatcher(new Impl&lt;Container&gt;(distance_matcher_));
2779   }
2780 
2781   template &lt;typename Container&gt;
2782   class Impl : public MatcherInterface&lt;Container&gt; {
2783    public:
2784     typedef internal::StlContainerView&lt;
2785         GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt; ContainerView;
2786     typedef typename std::iterator_traits&lt;
2787         typename ContainerView::type::const_iterator&gt;::difference_type
2788         DistanceType;
2789     explicit Impl(const DistanceMatcher&amp; distance_matcher)
2790         : distance_matcher_(MatcherCast&lt;DistanceType&gt;(distance_matcher)) {}
2791 
2792     virtual void DescribeTo(::std::ostream* os) const {
2793       *os &lt;&lt; &quot;distance between begin() and end() &quot;;
2794       distance_matcher_.DescribeTo(os);
2795     }
2796     virtual void DescribeNegationTo(::std::ostream* os) const {
2797       *os &lt;&lt; &quot;distance between begin() and end() &quot;;
2798       distance_matcher_.DescribeNegationTo(os);
2799     }
2800 
2801     virtual bool MatchAndExplain(Container container,
2802                                  MatchResultListener* listener) const {
2803 #if GTEST_HAS_STD_BEGIN_AND_END_
2804       using std::begin;
2805       using std::end;
2806       DistanceType distance = std::distance(begin(container), end(container));
2807 #else
2808       DistanceType distance = std::distance(container.begin(), container.end());
2809 #endif
2810       StringMatchResultListener distance_listener;
2811       const bool result =
2812           distance_matcher_.MatchAndExplain(distance, &amp;distance_listener);
2813       *listener &lt;&lt; &quot;whose distance between begin() and end() &quot; &lt;&lt; distance
2814                 &lt;&lt; (result ? &quot; matches&quot; : &quot; doesn&#39;t match&quot;);
2815       PrintIfNotEmpty(distance_listener.str(), listener-&gt;stream());
2816       return result;
2817     }
2818 
2819    private:
2820     const Matcher&lt;DistanceType&gt; distance_matcher_;
2821     GTEST_DISALLOW_ASSIGN_(Impl);
2822   };
2823 
2824  private:
2825   const DistanceMatcher distance_matcher_;
2826   GTEST_DISALLOW_ASSIGN_(BeginEndDistanceIsMatcher);
2827 };
2828 
2829 // Implements an equality matcher for any STL-style container whose elements
2830 // support ==. This matcher is like Eq(), but its failure explanations provide
2831 // more detailed information that is useful when the container is used as a set.
2832 // The failure message reports elements that are in one of the operands but not
2833 // the other. The failure messages do not report duplicate or out-of-order
2834 // elements in the containers (which don&#39;t properly matter to sets, but can
2835 // occur if the containers are vectors or lists, for example).
2836 //
2837 // Uses the container&#39;s const_iterator, value_type, operator ==,
2838 // begin(), and end().
2839 template &lt;typename Container&gt;
2840 class ContainerEqMatcher {
2841  public:
2842   typedef internal::StlContainerView&lt;Container&gt; View;
2843   typedef typename View::type StlContainer;
2844   typedef typename View::const_reference StlContainerReference;
2845 
2846   // We make a copy of expected in case the elements in it are modified
2847   // after this matcher is created.
2848   explicit ContainerEqMatcher(const Container&amp; expected)
2849       : expected_(View::Copy(expected)) {
2850     // Makes sure the user doesn&#39;t instantiate this class template
2851     // with a const or reference type.
2852     (void)testing::StaticAssertTypeEq&lt;Container,
2853         GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt;();
2854   }
2855 
2856   void DescribeTo(::std::ostream* os) const {
2857     *os &lt;&lt; &quot;equals &quot;;
2858     UniversalPrint(expected_, os);
2859   }
2860   void DescribeNegationTo(::std::ostream* os) const {
2861     *os &lt;&lt; &quot;does not equal &quot;;
2862     UniversalPrint(expected_, os);
2863   }
2864 
2865   template &lt;typename LhsContainer&gt;
2866   bool MatchAndExplain(const LhsContainer&amp; lhs,
2867                        MatchResultListener* listener) const {
2868     // GTEST_REMOVE_CONST_() is needed to work around an MSVC 8.0 bug
2869     // that causes LhsContainer to be a const type sometimes.
2870     typedef internal::StlContainerView&lt;GTEST_REMOVE_CONST_(LhsContainer)&gt;
2871         LhsView;
2872     typedef typename LhsView::type LhsStlContainer;
2873     StlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
2874     if (lhs_stl_container == expected_)
2875       return true;
2876 
2877     ::std::ostream* const os = listener-&gt;stream();
2878     if (os != NULL) {
2879       // Something is different. Check for extra values first.
2880       bool printed_header = false;
2881       for (typename LhsStlContainer::const_iterator it =
2882                lhs_stl_container.begin();
2883            it != lhs_stl_container.end(); ++it) {
2884         if (internal::ArrayAwareFind(expected_.begin(), expected_.end(), *it) ==
2885             expected_.end()) {
2886           if (printed_header) {
2887             *os &lt;&lt; &quot;, &quot;;
2888           } else {
2889             *os &lt;&lt; &quot;which has these unexpected elements: &quot;;
2890             printed_header = true;
2891           }
2892           UniversalPrint(*it, os);
2893         }
2894       }
2895 
2896       // Now check for missing values.
2897       bool printed_header2 = false;
2898       for (typename StlContainer::const_iterator it = expected_.begin();
2899            it != expected_.end(); ++it) {
2900         if (internal::ArrayAwareFind(
2901                 lhs_stl_container.begin(), lhs_stl_container.end(), *it) ==
2902             lhs_stl_container.end()) {
2903           if (printed_header2) {
2904             *os &lt;&lt; &quot;, &quot;;
2905           } else {
2906             *os &lt;&lt; (printed_header ? &quot;,\nand&quot; : &quot;which&quot;)
2907                 &lt;&lt; &quot; doesn&#39;t have these expected elements: &quot;;
2908             printed_header2 = true;
2909           }
2910           UniversalPrint(*it, os);
2911         }
2912       }
2913     }
2914 
2915     return false;
2916   }
2917 
2918  private:
2919   const StlContainer expected_;
2920 
2921   GTEST_DISALLOW_ASSIGN_(ContainerEqMatcher);
2922 };
2923 
2924 // A comparator functor that uses the &lt; operator to compare two values.
2925 struct LessComparator {
2926   template &lt;typename T, typename U&gt;
2927   bool operator()(const T&amp; lhs, const U&amp; rhs) const { return lhs &lt; rhs; }
2928 };
2929 
2930 // Implements WhenSortedBy(comparator, container_matcher).
2931 template &lt;typename Comparator, typename ContainerMatcher&gt;
2932 class WhenSortedByMatcher {
2933  public:
2934   WhenSortedByMatcher(const Comparator&amp; comparator,
2935                       const ContainerMatcher&amp; matcher)
2936       : comparator_(comparator), matcher_(matcher) {}
2937 
2938   template &lt;typename LhsContainer&gt;
2939   operator Matcher&lt;LhsContainer&gt;() const {
2940     return MakeMatcher(new Impl&lt;LhsContainer&gt;(comparator_, matcher_));
2941   }
2942 
2943   template &lt;typename LhsContainer&gt;
2944   class Impl : public MatcherInterface&lt;LhsContainer&gt; {
2945    public:
2946     typedef internal::StlContainerView&lt;
2947          GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)&gt; LhsView;
2948     typedef typename LhsView::type LhsStlContainer;
2949     typedef typename LhsView::const_reference LhsStlContainerReference;
2950     // Transforms std::pair&lt;const Key, Value&gt; into std::pair&lt;Key, Value&gt;
2951     // so that we can match associative containers.
2952     typedef typename RemoveConstFromKey&lt;
2953         typename LhsStlContainer::value_type&gt;::type LhsValue;
2954 
2955     Impl(const Comparator&amp; comparator, const ContainerMatcher&amp; matcher)
2956         : comparator_(comparator), matcher_(matcher) {}
2957 
2958     virtual void DescribeTo(::std::ostream* os) const {
2959       *os &lt;&lt; &quot;(when sorted) &quot;;
2960       matcher_.DescribeTo(os);
2961     }
2962 
2963     virtual void DescribeNegationTo(::std::ostream* os) const {
2964       *os &lt;&lt; &quot;(when sorted) &quot;;
2965       matcher_.DescribeNegationTo(os);
2966     }
2967 
2968     virtual bool MatchAndExplain(LhsContainer lhs,
2969                                  MatchResultListener* listener) const {
2970       LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
2971       ::std::vector&lt;LhsValue&gt; sorted_container(lhs_stl_container.begin(),
2972                                                lhs_stl_container.end());
2973       ::std::sort(
2974            sorted_container.begin(), sorted_container.end(), comparator_);
2975 
2976       if (!listener-&gt;IsInterested()) {
2977         // If the listener is not interested, we do not need to
2978         // construct the inner explanation.
2979         return matcher_.Matches(sorted_container);
2980       }
2981 
2982       *listener &lt;&lt; &quot;which is &quot;;
2983       UniversalPrint(sorted_container, listener-&gt;stream());
2984       *listener &lt;&lt; &quot; when sorted&quot;;
2985 
2986       StringMatchResultListener inner_listener;
2987       const bool match = matcher_.MatchAndExplain(sorted_container,
2988                                                   &amp;inner_listener);
2989       PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
2990       return match;
2991     }
2992 
2993    private:
2994     const Comparator comparator_;
2995     const Matcher&lt;const ::std::vector&lt;LhsValue&gt;&amp;&gt; matcher_;
2996 
2997     GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);
2998   };
2999 
3000  private:
3001   const Comparator comparator_;
3002   const ContainerMatcher matcher_;
3003 
3004   GTEST_DISALLOW_ASSIGN_(WhenSortedByMatcher);
3005 };
3006 
3007 // Implements Pointwise(tuple_matcher, rhs_container).  tuple_matcher
3008 // must be able to be safely cast to Matcher&lt;tuple&lt;const T1&amp;, const
3009 // T2&amp;&gt; &gt;, where T1 and T2 are the types of elements in the LHS
3010 // container and the RHS container respectively.
3011 template &lt;typename TupleMatcher, typename RhsContainer&gt;
3012 class PointwiseMatcher {
3013   GTEST_COMPILE_ASSERT_(
3014       !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(RhsContainer)&gt;::value,
3015       use_UnorderedPointwise_with_hash_tables);
3016 
3017  public:
3018   typedef internal::StlContainerView&lt;RhsContainer&gt; RhsView;
3019   typedef typename RhsView::type RhsStlContainer;
3020   typedef typename RhsStlContainer::value_type RhsValue;
3021 
3022   // Like ContainerEq, we make a copy of rhs in case the elements in
3023   // it are modified after this matcher is created.
3024   PointwiseMatcher(const TupleMatcher&amp; tuple_matcher, const RhsContainer&amp; rhs)
3025       : tuple_matcher_(tuple_matcher), rhs_(RhsView::Copy(rhs)) {
3026     // Makes sure the user doesn&#39;t instantiate this class template
3027     // with a const or reference type.
3028     (void)testing::StaticAssertTypeEq&lt;RhsContainer,
3029         GTEST_REMOVE_REFERENCE_AND_CONST_(RhsContainer)&gt;();
3030   }
3031 
3032   template &lt;typename LhsContainer&gt;
3033   operator Matcher&lt;LhsContainer&gt;() const {
3034     GTEST_COMPILE_ASSERT_(
3035         !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)&gt;::value,
3036         use_UnorderedPointwise_with_hash_tables_);
3037 
3038     return MakeMatcher(new Impl&lt;LhsContainer&gt;(tuple_matcher_, rhs_));
3039   }
3040 
3041   template &lt;typename LhsContainer&gt;
3042   class Impl : public MatcherInterface&lt;LhsContainer&gt; {
3043    public:
3044     typedef internal::StlContainerView&lt;
3045          GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)&gt; LhsView;
3046     typedef typename LhsView::type LhsStlContainer;
3047     typedef typename LhsView::const_reference LhsStlContainerReference;
3048     typedef typename LhsStlContainer::value_type LhsValue;
3049     // We pass the LHS value and the RHS value to the inner matcher by
3050     // reference, as they may be expensive to copy.  We must use tuple
3051     // instead of pair here, as a pair cannot hold references (C++ 98,
3052     // 20.2.2 [lib.pairs]).
3053     typedef ::testing::tuple&lt;const LhsValue&amp;, const RhsValue&amp;&gt; InnerMatcherArg;
3054 
3055     Impl(const TupleMatcher&amp; tuple_matcher, const RhsStlContainer&amp; rhs)
3056         // mono_tuple_matcher_ holds a monomorphic version of the tuple matcher.
3057         : mono_tuple_matcher_(SafeMatcherCast&lt;InnerMatcherArg&gt;(tuple_matcher)),
3058           rhs_(rhs) {}
3059 
3060     virtual void DescribeTo(::std::ostream* os) const {
3061       *os &lt;&lt; &quot;contains &quot; &lt;&lt; rhs_.size()
3062           &lt;&lt; &quot; values, where each value and its corresponding value in &quot;;
3063       UniversalPrinter&lt;RhsStlContainer&gt;::Print(rhs_, os);
3064       *os &lt;&lt; &quot; &quot;;
3065       mono_tuple_matcher_.DescribeTo(os);
3066     }
3067     virtual void DescribeNegationTo(::std::ostream* os) const {
3068       *os &lt;&lt; &quot;doesn&#39;t contain exactly &quot; &lt;&lt; rhs_.size()
3069           &lt;&lt; &quot; values, or contains a value x at some index i&quot;
3070           &lt;&lt; &quot; where x and the i-th value of &quot;;
3071       UniversalPrint(rhs_, os);
3072       *os &lt;&lt; &quot; &quot;;
3073       mono_tuple_matcher_.DescribeNegationTo(os);
3074     }
3075 
3076     virtual bool MatchAndExplain(LhsContainer lhs,
3077                                  MatchResultListener* listener) const {
3078       LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
3079       const size_t actual_size = lhs_stl_container.size();
3080       if (actual_size != rhs_.size()) {
3081         *listener &lt;&lt; &quot;which contains &quot; &lt;&lt; actual_size &lt;&lt; &quot; values&quot;;
3082         return false;
3083       }
3084 
3085       typename LhsStlContainer::const_iterator left = lhs_stl_container.begin();
3086       typename RhsStlContainer::const_iterator right = rhs_.begin();
3087       for (size_t i = 0; i != actual_size; ++i, ++left, ++right) {
3088         if (listener-&gt;IsInterested()) {
3089           StringMatchResultListener inner_listener;
3090           // Create InnerMatcherArg as a temporarily object to avoid it outlives
3091           // *left and *right. Dereference or the conversion to `const T&amp;` may
3092           // return temp objects, e.g for vector&lt;bool&gt;.
3093           if (!mono_tuple_matcher_.MatchAndExplain(
3094                   InnerMatcherArg(ImplicitCast_&lt;const LhsValue&amp;&gt;(*left),
3095                                   ImplicitCast_&lt;const RhsValue&amp;&gt;(*right)),
3096                   &amp;inner_listener)) {
3097             *listener &lt;&lt; &quot;where the value pair (&quot;;
3098             UniversalPrint(*left, listener-&gt;stream());
3099             *listener &lt;&lt; &quot;, &quot;;
3100             UniversalPrint(*right, listener-&gt;stream());
3101             *listener &lt;&lt; &quot;) at index #&quot; &lt;&lt; i &lt;&lt; &quot; don&#39;t match&quot;;
3102             PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
3103             return false;
3104           }
3105         } else {
3106           if (!mono_tuple_matcher_.Matches(
3107                   InnerMatcherArg(ImplicitCast_&lt;const LhsValue&amp;&gt;(*left),
3108                                   ImplicitCast_&lt;const RhsValue&amp;&gt;(*right))))
3109             return false;
3110         }
3111       }
3112 
3113       return true;
3114     }
3115 
3116    private:
3117     const Matcher&lt;InnerMatcherArg&gt; mono_tuple_matcher_;
3118     const RhsStlContainer rhs_;
3119 
3120     GTEST_DISALLOW_ASSIGN_(Impl);
3121   };
3122 
3123  private:
3124   const TupleMatcher tuple_matcher_;
3125   const RhsStlContainer rhs_;
3126 
3127   GTEST_DISALLOW_ASSIGN_(PointwiseMatcher);
3128 };
3129 
3130 // Holds the logic common to ContainsMatcherImpl and EachMatcherImpl.
3131 template &lt;typename Container&gt;
3132 class QuantifierMatcherImpl : public MatcherInterface&lt;Container&gt; {
3133  public:
3134   typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
3135   typedef StlContainerView&lt;RawContainer&gt; View;
3136   typedef typename View::type StlContainer;
3137   typedef typename View::const_reference StlContainerReference;
3138   typedef typename StlContainer::value_type Element;
3139 
3140   template &lt;typename InnerMatcher&gt;
3141   explicit QuantifierMatcherImpl(InnerMatcher inner_matcher)
3142       : inner_matcher_(
3143            testing::SafeMatcherCast&lt;const Element&amp;&gt;(inner_matcher)) {}
3144 
3145   // Checks whether:
3146   // * All elements in the container match, if all_elements_should_match.
3147   // * Any element in the container matches, if !all_elements_should_match.
3148   bool MatchAndExplainImpl(bool all_elements_should_match,
3149                            Container container,
3150                            MatchResultListener* listener) const {
3151     StlContainerReference stl_container = View::ConstReference(container);
3152     size_t i = 0;
3153     for (typename StlContainer::const_iterator it = stl_container.begin();
3154          it != stl_container.end(); ++it, ++i) {
3155       StringMatchResultListener inner_listener;
3156       const bool matches = inner_matcher_.MatchAndExplain(*it, &amp;inner_listener);
3157 
3158       if (matches != all_elements_should_match) {
3159         *listener &lt;&lt; &quot;whose element #&quot; &lt;&lt; i
3160                   &lt;&lt; (matches ? &quot; matches&quot; : &quot; doesn&#39;t match&quot;);
3161         PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
3162         return !all_elements_should_match;
3163       }
3164     }
3165     return all_elements_should_match;
3166   }
3167 
3168  protected:
3169   const Matcher&lt;const Element&amp;&gt; inner_matcher_;
3170 
3171   GTEST_DISALLOW_ASSIGN_(QuantifierMatcherImpl);
3172 };
3173 
3174 // Implements Contains(element_matcher) for the given argument type Container.
3175 // Symmetric to EachMatcherImpl.
3176 template &lt;typename Container&gt;
3177 class ContainsMatcherImpl : public QuantifierMatcherImpl&lt;Container&gt; {
3178  public:
3179   template &lt;typename InnerMatcher&gt;
3180   explicit ContainsMatcherImpl(InnerMatcher inner_matcher)
3181       : QuantifierMatcherImpl&lt;Container&gt;(inner_matcher) {}
3182 
3183   // Describes what this matcher does.
3184   virtual void DescribeTo(::std::ostream* os) const {
3185     *os &lt;&lt; &quot;contains at least one element that &quot;;
3186     this-&gt;inner_matcher_.DescribeTo(os);
3187   }
3188 
3189   virtual void DescribeNegationTo(::std::ostream* os) const {
3190     *os &lt;&lt; &quot;doesn&#39;t contain any element that &quot;;
3191     this-&gt;inner_matcher_.DescribeTo(os);
3192   }
3193 
3194   virtual bool MatchAndExplain(Container container,
3195                                MatchResultListener* listener) const {
3196     return this-&gt;MatchAndExplainImpl(false, container, listener);
3197   }
3198 
3199  private:
3200   GTEST_DISALLOW_ASSIGN_(ContainsMatcherImpl);
3201 };
3202 
3203 // Implements Each(element_matcher) for the given argument type Container.
3204 // Symmetric to ContainsMatcherImpl.
3205 template &lt;typename Container&gt;
3206 class EachMatcherImpl : public QuantifierMatcherImpl&lt;Container&gt; {
3207  public:
3208   template &lt;typename InnerMatcher&gt;
3209   explicit EachMatcherImpl(InnerMatcher inner_matcher)
3210       : QuantifierMatcherImpl&lt;Container&gt;(inner_matcher) {}
3211 
3212   // Describes what this matcher does.
3213   virtual void DescribeTo(::std::ostream* os) const {
3214     *os &lt;&lt; &quot;only contains elements that &quot;;
3215     this-&gt;inner_matcher_.DescribeTo(os);
3216   }
3217 
3218   virtual void DescribeNegationTo(::std::ostream* os) const {
3219     *os &lt;&lt; &quot;contains some element that &quot;;
3220     this-&gt;inner_matcher_.DescribeNegationTo(os);
3221   }
3222 
3223   virtual bool MatchAndExplain(Container container,
3224                                MatchResultListener* listener) const {
3225     return this-&gt;MatchAndExplainImpl(true, container, listener);
3226   }
3227 
3228  private:
3229   GTEST_DISALLOW_ASSIGN_(EachMatcherImpl);
3230 };
3231 
3232 // Implements polymorphic Contains(element_matcher).
3233 template &lt;typename M&gt;
3234 class ContainsMatcher {
3235  public:
3236   explicit ContainsMatcher(M m) : inner_matcher_(m) {}
3237 
3238   template &lt;typename Container&gt;
3239   operator Matcher&lt;Container&gt;() const {
3240     return MakeMatcher(new ContainsMatcherImpl&lt;Container&gt;(inner_matcher_));
3241   }
3242 
3243  private:
3244   const M inner_matcher_;
3245 
3246   GTEST_DISALLOW_ASSIGN_(ContainsMatcher);
3247 };
3248 
3249 // Implements polymorphic Each(element_matcher).
3250 template &lt;typename M&gt;
3251 class EachMatcher {
3252  public:
3253   explicit EachMatcher(M m) : inner_matcher_(m) {}
3254 
3255   template &lt;typename Container&gt;
3256   operator Matcher&lt;Container&gt;() const {
3257     return MakeMatcher(new EachMatcherImpl&lt;Container&gt;(inner_matcher_));
3258   }
3259 
3260  private:
3261   const M inner_matcher_;
3262 
3263   GTEST_DISALLOW_ASSIGN_(EachMatcher);
3264 };
3265 
3266 struct Rank1 {};
3267 struct Rank0 : Rank1 {};
3268 
3269 namespace pair_getters {
3270 #if GTEST_LANG_CXX11
3271 using std::get;
3272 template &lt;typename T&gt;
3273 auto First(T&amp; x, Rank1) -&gt; decltype(get&lt;0&gt;(x)) {  // NOLINT
3274   return get&lt;0&gt;(x);
3275 }
3276 template &lt;typename T&gt;
3277 auto First(T&amp; x, Rank0) -&gt; decltype((x.first)) {  // NOLINT
3278   return x.first;
3279 }
3280 
3281 template &lt;typename T&gt;
3282 auto Second(T&amp; x, Rank1) -&gt; decltype(get&lt;1&gt;(x)) {  // NOLINT
3283   return get&lt;1&gt;(x);
3284 }
3285 template &lt;typename T&gt;
3286 auto Second(T&amp; x, Rank0) -&gt; decltype((x.second)) {  // NOLINT
3287   return x.second;
3288 }
3289 #else
3290 template &lt;typename T&gt;
3291 typename T::first_type&amp; First(T&amp; x, Rank0) {  // NOLINT
3292   return x.first;
3293 }
3294 template &lt;typename T&gt;
3295 const typename T::first_type&amp; First(const T&amp; x, Rank0) {
3296   return x.first;
3297 }
3298 
3299 template &lt;typename T&gt;
3300 typename T::second_type&amp; Second(T&amp; x, Rank0) {  // NOLINT
3301   return x.second;
3302 }
3303 template &lt;typename T&gt;
3304 const typename T::second_type&amp; Second(const T&amp; x, Rank0) {
3305   return x.second;
3306 }
3307 #endif  // GTEST_LANG_CXX11
3308 }  // namespace pair_getters
3309 
3310 // Implements Key(inner_matcher) for the given argument pair type.
3311 // Key(inner_matcher) matches an std::pair whose &#39;first&#39; field matches
3312 // inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an
3313 // std::map that contains at least one element whose key is &gt;= 5.
3314 template &lt;typename PairType&gt;
3315 class KeyMatcherImpl : public MatcherInterface&lt;PairType&gt; {
3316  public:
3317   typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;
3318   typedef typename RawPairType::first_type KeyType;
3319 
3320   template &lt;typename InnerMatcher&gt;
3321   explicit KeyMatcherImpl(InnerMatcher inner_matcher)
3322       : inner_matcher_(
3323           testing::SafeMatcherCast&lt;const KeyType&amp;&gt;(inner_matcher)) {
3324   }
3325 
3326   // Returns true iff &#39;key_value.first&#39; (the key) matches the inner matcher.
3327   virtual bool MatchAndExplain(PairType key_value,
3328                                MatchResultListener* listener) const {
3329     StringMatchResultListener inner_listener;
3330     const bool match = inner_matcher_.MatchAndExplain(
3331         pair_getters::First(key_value, Rank0()), &amp;inner_listener);
3332     const std::string explanation = inner_listener.str();
3333     if (explanation != &quot;&quot;) {
3334       *listener &lt;&lt; &quot;whose first field is a value &quot; &lt;&lt; explanation;
3335     }
3336     return match;
3337   }
3338 
3339   // Describes what this matcher does.
3340   virtual void DescribeTo(::std::ostream* os) const {
3341     *os &lt;&lt; &quot;has a key that &quot;;
3342     inner_matcher_.DescribeTo(os);
3343   }
3344 
3345   // Describes what the negation of this matcher does.
3346   virtual void DescribeNegationTo(::std::ostream* os) const {
3347     *os &lt;&lt; &quot;doesn&#39;t have a key that &quot;;
3348     inner_matcher_.DescribeTo(os);
3349   }
3350 
3351  private:
3352   const Matcher&lt;const KeyType&amp;&gt; inner_matcher_;
3353 
3354   GTEST_DISALLOW_ASSIGN_(KeyMatcherImpl);
3355 };
3356 
3357 // Implements polymorphic Key(matcher_for_key).
3358 template &lt;typename M&gt;
3359 class KeyMatcher {
3360  public:
3361   explicit KeyMatcher(M m) : matcher_for_key_(m) {}
3362 
3363   template &lt;typename PairType&gt;
3364   operator Matcher&lt;PairType&gt;() const {
3365     return MakeMatcher(new KeyMatcherImpl&lt;PairType&gt;(matcher_for_key_));
3366   }
3367 
3368  private:
3369   const M matcher_for_key_;
3370 
3371   GTEST_DISALLOW_ASSIGN_(KeyMatcher);
3372 };
3373 
3374 // Implements Pair(first_matcher, second_matcher) for the given argument pair
3375 // type with its two matchers. See Pair() function below.
3376 template &lt;typename PairType&gt;
3377 class PairMatcherImpl : public MatcherInterface&lt;PairType&gt; {
3378  public:
3379   typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;
3380   typedef typename RawPairType::first_type FirstType;
3381   typedef typename RawPairType::second_type SecondType;
3382 
3383   template &lt;typename FirstMatcher, typename SecondMatcher&gt;
3384   PairMatcherImpl(FirstMatcher first_matcher, SecondMatcher second_matcher)
3385       : first_matcher_(
3386             testing::SafeMatcherCast&lt;const FirstType&amp;&gt;(first_matcher)),
3387         second_matcher_(
3388             testing::SafeMatcherCast&lt;const SecondType&amp;&gt;(second_matcher)) {
3389   }
3390 
3391   // Describes what this matcher does.
3392   virtual void DescribeTo(::std::ostream* os) const {
3393     *os &lt;&lt; &quot;has a first field that &quot;;
3394     first_matcher_.DescribeTo(os);
3395     *os &lt;&lt; &quot;, and has a second field that &quot;;
3396     second_matcher_.DescribeTo(os);
3397   }
3398 
3399   // Describes what the negation of this matcher does.
3400   virtual void DescribeNegationTo(::std::ostream* os) const {
3401     *os &lt;&lt; &quot;has a first field that &quot;;
3402     first_matcher_.DescribeNegationTo(os);
3403     *os &lt;&lt; &quot;, or has a second field that &quot;;
3404     second_matcher_.DescribeNegationTo(os);
3405   }
3406 
3407   // Returns true iff &#39;a_pair.first&#39; matches first_matcher and &#39;a_pair.second&#39;
3408   // matches second_matcher.
3409   virtual bool MatchAndExplain(PairType a_pair,
3410                                MatchResultListener* listener) const {
3411     if (!listener-&gt;IsInterested()) {
3412       // If the listener is not interested, we don&#39;t need to construct the
3413       // explanation.
3414       return first_matcher_.Matches(pair_getters::First(a_pair, Rank0())) &amp;&amp;
3415              second_matcher_.Matches(pair_getters::Second(a_pair, Rank0()));
3416     }
3417     StringMatchResultListener first_inner_listener;
3418     if (!first_matcher_.MatchAndExplain(pair_getters::First(a_pair, Rank0()),
3419                                         &amp;first_inner_listener)) {
3420       *listener &lt;&lt; &quot;whose first field does not match&quot;;
3421       PrintIfNotEmpty(first_inner_listener.str(), listener-&gt;stream());
3422       return false;
3423     }
3424     StringMatchResultListener second_inner_listener;
3425     if (!second_matcher_.MatchAndExplain(pair_getters::Second(a_pair, Rank0()),
3426                                          &amp;second_inner_listener)) {
3427       *listener &lt;&lt; &quot;whose second field does not match&quot;;
3428       PrintIfNotEmpty(second_inner_listener.str(), listener-&gt;stream());
3429       return false;
3430     }
3431     ExplainSuccess(first_inner_listener.str(), second_inner_listener.str(),
3432                    listener);
3433     return true;
3434   }
3435 
3436  private:
3437   void ExplainSuccess(const std::string&amp; first_explanation,
3438                       const std::string&amp; second_explanation,
3439                       MatchResultListener* listener) const {
3440     *listener &lt;&lt; &quot;whose both fields match&quot;;
3441     if (first_explanation != &quot;&quot;) {
3442       *listener &lt;&lt; &quot;, where the first field is a value &quot; &lt;&lt; first_explanation;
3443     }
3444     if (second_explanation != &quot;&quot;) {
3445       *listener &lt;&lt; &quot;, &quot;;
3446       if (first_explanation != &quot;&quot;) {
3447         *listener &lt;&lt; &quot;and &quot;;
3448       } else {
3449         *listener &lt;&lt; &quot;where &quot;;
3450       }
3451       *listener &lt;&lt; &quot;the second field is a value &quot; &lt;&lt; second_explanation;
3452     }
3453   }
3454 
3455   const Matcher&lt;const FirstType&amp;&gt; first_matcher_;
3456   const Matcher&lt;const SecondType&amp;&gt; second_matcher_;
3457 
3458   GTEST_DISALLOW_ASSIGN_(PairMatcherImpl);
3459 };
3460 
3461 // Implements polymorphic Pair(first_matcher, second_matcher).
3462 template &lt;typename FirstMatcher, typename SecondMatcher&gt;
3463 class PairMatcher {
3464  public:
3465   PairMatcher(FirstMatcher first_matcher, SecondMatcher second_matcher)
3466       : first_matcher_(first_matcher), second_matcher_(second_matcher) {}
3467 
3468   template &lt;typename PairType&gt;
3469   operator Matcher&lt;PairType&gt; () const {
3470     return MakeMatcher(
3471         new PairMatcherImpl&lt;PairType&gt;(
3472             first_matcher_, second_matcher_));
3473   }
3474 
3475  private:
3476   const FirstMatcher first_matcher_;
3477   const SecondMatcher second_matcher_;
3478 
3479   GTEST_DISALLOW_ASSIGN_(PairMatcher);
3480 };
3481 
3482 // Implements ElementsAre() and ElementsAreArray().
3483 template &lt;typename Container&gt;
3484 class ElementsAreMatcherImpl : public MatcherInterface&lt;Container&gt; {
3485  public:
3486   typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
3487   typedef internal::StlContainerView&lt;RawContainer&gt; View;
3488   typedef typename View::type StlContainer;
3489   typedef typename View::const_reference StlContainerReference;
3490   typedef typename StlContainer::value_type Element;
3491 
3492   // Constructs the matcher from a sequence of element values or
3493   // element matchers.
3494   template &lt;typename InputIter&gt;
3495   ElementsAreMatcherImpl(InputIter first, InputIter last) {
3496     while (first != last) {
3497       matchers_.push_back(MatcherCast&lt;const Element&amp;&gt;(*first++));
3498     }
3499   }
3500 
3501   // Describes what this matcher does.
3502   virtual void DescribeTo(::std::ostream* os) const {
3503     if (count() == 0) {
3504       *os &lt;&lt; &quot;is empty&quot;;
3505     } else if (count() == 1) {
3506       *os &lt;&lt; &quot;has 1 element that &quot;;
3507       matchers_[0].DescribeTo(os);
3508     } else {
3509       *os &lt;&lt; &quot;has &quot; &lt;&lt; Elements(count()) &lt;&lt; &quot; where\n&quot;;
3510       for (size_t i = 0; i != count(); ++i) {
3511         *os &lt;&lt; &quot;element #&quot; &lt;&lt; i &lt;&lt; &quot; &quot;;
3512         matchers_[i].DescribeTo(os);
3513         if (i + 1 &lt; count()) {
3514           *os &lt;&lt; &quot;,\n&quot;;
3515         }
3516       }
3517     }
3518   }
3519 
3520   // Describes what the negation of this matcher does.
3521   virtual void DescribeNegationTo(::std::ostream* os) const {
3522     if (count() == 0) {
3523       *os &lt;&lt; &quot;isn&#39;t empty&quot;;
3524       return;
3525     }
3526 
3527     *os &lt;&lt; &quot;doesn&#39;t have &quot; &lt;&lt; Elements(count()) &lt;&lt; &quot;, or\n&quot;;
3528     for (size_t i = 0; i != count(); ++i) {
3529       *os &lt;&lt; &quot;element #&quot; &lt;&lt; i &lt;&lt; &quot; &quot;;
3530       matchers_[i].DescribeNegationTo(os);
3531       if (i + 1 &lt; count()) {
3532         *os &lt;&lt; &quot;, or\n&quot;;
3533       }
3534     }
3535   }
3536 
3537   virtual bool MatchAndExplain(Container container,
3538                                MatchResultListener* listener) const {
3539     // To work with stream-like &quot;containers&quot;, we must only walk
3540     // through the elements in one pass.
3541 
3542     const bool listener_interested = listener-&gt;IsInterested();
3543 
3544     // explanations[i] is the explanation of the element at index i.
3545     ::std::vector&lt;std::string&gt; explanations(count());
3546     StlContainerReference stl_container = View::ConstReference(container);
3547     typename StlContainer::const_iterator it = stl_container.begin();
3548     size_t exam_pos = 0;
3549     bool mismatch_found = false;  // Have we found a mismatched element yet?
3550 
3551     // Go through the elements and matchers in pairs, until we reach
3552     // the end of either the elements or the matchers, or until we find a
3553     // mismatch.
3554     for (; it != stl_container.end() &amp;&amp; exam_pos != count(); ++it, ++exam_pos) {
3555       bool match;  // Does the current element match the current matcher?
3556       if (listener_interested) {
3557         StringMatchResultListener s;
3558         match = matchers_[exam_pos].MatchAndExplain(*it, &amp;s);
3559         explanations[exam_pos] = s.str();
3560       } else {
3561         match = matchers_[exam_pos].Matches(*it);
3562       }
3563 
3564       if (!match) {
3565         mismatch_found = true;
3566         break;
3567       }
3568     }
3569     // If mismatch_found is true, &#39;exam_pos&#39; is the index of the mismatch.
3570 
3571     // Find how many elements the actual container has.  We avoid
3572     // calling size() s.t. this code works for stream-like &quot;containers&quot;
3573     // that don&#39;t define size().
3574     size_t actual_count = exam_pos;
3575     for (; it != stl_container.end(); ++it) {
3576       ++actual_count;
3577     }
3578 
3579     if (actual_count != count()) {
3580       // The element count doesn&#39;t match.  If the container is empty,
3581       // there&#39;s no need to explain anything as Google Mock already
3582       // prints the empty container.  Otherwise we just need to show
3583       // how many elements there actually are.
3584       if (listener_interested &amp;&amp; (actual_count != 0)) {
3585         *listener &lt;&lt; &quot;which has &quot; &lt;&lt; Elements(actual_count);
3586       }
3587       return false;
3588     }
3589 
3590     if (mismatch_found) {
3591       // The element count matches, but the exam_pos-th element doesn&#39;t match.
3592       if (listener_interested) {
3593         *listener &lt;&lt; &quot;whose element #&quot; &lt;&lt; exam_pos &lt;&lt; &quot; doesn&#39;t match&quot;;
3594         PrintIfNotEmpty(explanations[exam_pos], listener-&gt;stream());
3595       }
3596       return false;
3597     }
3598 
3599     // Every element matches its expectation.  We need to explain why
3600     // (the obvious ones can be skipped).
3601     if (listener_interested) {
3602       bool reason_printed = false;
3603       for (size_t i = 0; i != count(); ++i) {
3604         const std::string&amp; s = explanations[i];
3605         if (!s.empty()) {
3606           if (reason_printed) {
3607             *listener &lt;&lt; &quot;,\nand &quot;;
3608           }
3609           *listener &lt;&lt; &quot;whose element #&quot; &lt;&lt; i &lt;&lt; &quot; matches, &quot; &lt;&lt; s;
3610           reason_printed = true;
3611         }
3612       }
3613     }
3614     return true;
3615   }
3616 
3617  private:
3618   static Message Elements(size_t count) {
3619     return Message() &lt;&lt; count &lt;&lt; (count == 1 ? &quot; element&quot; : &quot; elements&quot;);
3620   }
3621 
3622   size_t count() const { return matchers_.size(); }
3623 
3624   ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; matchers_;
3625 
3626   GTEST_DISALLOW_ASSIGN_(ElementsAreMatcherImpl);
3627 };
3628 
3629 // Connectivity matrix of (elements X matchers), in element-major order.
3630 // Initially, there are no edges.
3631 // Use NextGraph() to iterate over all possible edge configurations.
3632 // Use Randomize() to generate a random edge configuration.
3633 class GTEST_API_ MatchMatrix {
3634  public:
3635   MatchMatrix(size_t num_elements, size_t num_matchers)
3636       : num_elements_(num_elements),
3637         num_matchers_(num_matchers),
3638         matched_(num_elements_* num_matchers_, 0) {
3639   }
3640 
3641   size_t LhsSize() const { return num_elements_; }
3642   size_t RhsSize() const { return num_matchers_; }
3643   bool HasEdge(size_t ilhs, size_t irhs) const {
3644     return matched_[SpaceIndex(ilhs, irhs)] == 1;
3645   }
3646   void SetEdge(size_t ilhs, size_t irhs, bool b) {
3647     matched_[SpaceIndex(ilhs, irhs)] = b ? 1 : 0;
3648   }
3649 
3650   // Treating the connectivity matrix as a (LhsSize()*RhsSize())-bit number,
3651   // adds 1 to that number; returns false if incrementing the graph left it
3652   // empty.
3653   bool NextGraph();
3654 
3655   void Randomize();
3656 
3657   std::string DebugString() const;
3658 
3659  private:
3660   size_t SpaceIndex(size_t ilhs, size_t irhs) const {
3661     return ilhs * num_matchers_ + irhs;
3662   }
3663 
3664   size_t num_elements_;
3665   size_t num_matchers_;
3666 
3667   // Each element is a char interpreted as bool. They are stored as a
3668   // flattened array in lhs-major order, use &#39;SpaceIndex()&#39; to translate
3669   // a (ilhs, irhs) matrix coordinate into an offset.
3670   ::std::vector&lt;char&gt; matched_;
3671 };
3672 
3673 typedef ::std::pair&lt;size_t, size_t&gt; ElementMatcherPair;
3674 typedef ::std::vector&lt;ElementMatcherPair&gt; ElementMatcherPairs;
3675 
3676 // Returns a maximum bipartite matching for the specified graph &#39;g&#39;.
3677 // The matching is represented as a vector of {element, matcher} pairs.
3678 GTEST_API_ ElementMatcherPairs
3679 FindMaxBipartiteMatching(const MatchMatrix&amp; g);
3680 
3681 struct UnorderedMatcherRequire {
3682   enum Flags {
3683     Superset = 1 &lt;&lt; 0,
3684     Subset = 1 &lt;&lt; 1,
3685     ExactMatch = Superset | Subset,
3686   };
3687 };
3688 
3689 // Untyped base class for implementing UnorderedElementsAre.  By
3690 // putting logic that&#39;s not specific to the element type here, we
3691 // reduce binary bloat and increase compilation speed.
3692 class GTEST_API_ UnorderedElementsAreMatcherImplBase {
3693  protected:
3694   explicit UnorderedElementsAreMatcherImplBase(
3695       UnorderedMatcherRequire::Flags matcher_flags)
3696       : match_flags_(matcher_flags) {}
3697 
3698   // A vector of matcher describers, one for each element matcher.
3699   // Does not own the describers (and thus can be used only when the
3700   // element matchers are alive).
3701   typedef ::std::vector&lt;const MatcherDescriberInterface*&gt; MatcherDescriberVec;
3702 
3703   // Describes this UnorderedElementsAre matcher.
3704   void DescribeToImpl(::std::ostream* os) const;
3705 
3706   // Describes the negation of this UnorderedElementsAre matcher.
3707   void DescribeNegationToImpl(::std::ostream* os) const;
3708 
3709   bool VerifyMatchMatrix(const ::std::vector&lt;std::string&gt;&amp; element_printouts,
3710                          const MatchMatrix&amp; matrix,
3711                          MatchResultListener* listener) const;
3712 
3713   bool FindPairing(const MatchMatrix&amp; matrix,
3714                    MatchResultListener* listener) const;
3715 
3716   MatcherDescriberVec&amp; matcher_describers() {
3717     return matcher_describers_;
3718   }
3719 
3720   static Message Elements(size_t n) {
3721     return Message() &lt;&lt; n &lt;&lt; &quot; element&quot; &lt;&lt; (n == 1 ? &quot;&quot; : &quot;s&quot;);
3722   }
3723 
3724   UnorderedMatcherRequire::Flags match_flags() const { return match_flags_; }
3725 
3726  private:
3727   UnorderedMatcherRequire::Flags match_flags_;
3728   MatcherDescriberVec matcher_describers_;
3729 
3730   GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImplBase);
3731 };
3732 
3733 // Implements UnorderedElementsAre, UnorderedElementsAreArray, IsSubsetOf, and
3734 // IsSupersetOf.
3735 template &lt;typename Container&gt;
3736 class UnorderedElementsAreMatcherImpl
3737     : public MatcherInterface&lt;Container&gt;,
3738       public UnorderedElementsAreMatcherImplBase {
3739  public:
3740   typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
3741   typedef internal::StlContainerView&lt;RawContainer&gt; View;
3742   typedef typename View::type StlContainer;
3743   typedef typename View::const_reference StlContainerReference;
3744   typedef typename StlContainer::const_iterator StlContainerConstIterator;
3745   typedef typename StlContainer::value_type Element;
3746 
3747   template &lt;typename InputIter&gt;
3748   UnorderedElementsAreMatcherImpl(UnorderedMatcherRequire::Flags matcher_flags,
3749                                   InputIter first, InputIter last)
3750       : UnorderedElementsAreMatcherImplBase(matcher_flags) {
3751     for (; first != last; ++first) {
3752       matchers_.push_back(MatcherCast&lt;const Element&amp;&gt;(*first));
3753       matcher_describers().push_back(matchers_.back().GetDescriber());
3754     }
3755   }
3756 
3757   // Describes what this matcher does.
3758   virtual void DescribeTo(::std::ostream* os) const {
3759     return UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);
3760   }
3761 
3762   // Describes what the negation of this matcher does.
3763   virtual void DescribeNegationTo(::std::ostream* os) const {
3764     return UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);
3765   }
3766 
3767   virtual bool MatchAndExplain(Container container,
3768                                MatchResultListener* listener) const {
3769     StlContainerReference stl_container = View::ConstReference(container);
3770     ::std::vector&lt;std::string&gt; element_printouts;
3771     MatchMatrix matrix =
3772         AnalyzeElements(stl_container.begin(), stl_container.end(),
3773                         &amp;element_printouts, listener);
3774 
3775     if (matrix.LhsSize() == 0 &amp;&amp; matrix.RhsSize() == 0) {
3776       return true;
3777     }
3778 
3779     if (match_flags() == UnorderedMatcherRequire::ExactMatch) {
3780       if (matrix.LhsSize() != matrix.RhsSize()) {
3781         // The element count doesn&#39;t match.  If the container is empty,
3782         // there&#39;s no need to explain anything as Google Mock already
3783         // prints the empty container. Otherwise we just need to show
3784         // how many elements there actually are.
3785         if (matrix.LhsSize() != 0 &amp;&amp; listener-&gt;IsInterested()) {
3786           *listener &lt;&lt; &quot;which has &quot; &lt;&lt; Elements(matrix.LhsSize());
3787         }
3788         return false;
3789       }
3790     }
3791 
3792     return VerifyMatchMatrix(element_printouts, matrix, listener) &amp;&amp;
3793            FindPairing(matrix, listener);
3794   }
3795 
3796  private:
3797   template &lt;typename ElementIter&gt;
3798   MatchMatrix AnalyzeElements(ElementIter elem_first, ElementIter elem_last,
3799                               ::std::vector&lt;std::string&gt;* element_printouts,
3800                               MatchResultListener* listener) const {
3801     element_printouts-&gt;clear();
3802     ::std::vector&lt;char&gt; did_match;
3803     size_t num_elements = 0;
3804     for (; elem_first != elem_last; ++num_elements, ++elem_first) {
3805       if (listener-&gt;IsInterested()) {
3806         element_printouts-&gt;push_back(PrintToString(*elem_first));
3807       }
3808       for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {
3809         did_match.push_back(Matches(matchers_[irhs])(*elem_first));
3810       }
3811     }
3812 
3813     MatchMatrix matrix(num_elements, matchers_.size());
3814     ::std::vector&lt;char&gt;::const_iterator did_match_iter = did_match.begin();
3815     for (size_t ilhs = 0; ilhs != num_elements; ++ilhs) {
3816       for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {
3817         matrix.SetEdge(ilhs, irhs, *did_match_iter++ != 0);
3818       }
3819     }
3820     return matrix;
3821   }
3822 
3823   ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; matchers_;
3824 
3825   GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImpl);
3826 };
3827 
3828 // Functor for use in TransformTuple.
3829 // Performs MatcherCast&lt;Target&gt; on an input argument of any type.
3830 template &lt;typename Target&gt;
3831 struct CastAndAppendTransform {
3832   template &lt;typename Arg&gt;
3833   Matcher&lt;Target&gt; operator()(const Arg&amp; a) const {
3834     return MatcherCast&lt;Target&gt;(a);
3835   }
3836 };
3837 
3838 // Implements UnorderedElementsAre.
3839 template &lt;typename MatcherTuple&gt;
3840 class UnorderedElementsAreMatcher {
3841  public:
3842   explicit UnorderedElementsAreMatcher(const MatcherTuple&amp; args)
3843       : matchers_(args) {}
3844 
3845   template &lt;typename Container&gt;
3846   operator Matcher&lt;Container&gt;() const {
3847     typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
3848     typedef typename internal::StlContainerView&lt;RawContainer&gt;::type View;
3849     typedef typename View::value_type Element;
3850     typedef ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; MatcherVec;
3851     MatcherVec matchers;
3852     matchers.reserve(::testing::tuple_size&lt;MatcherTuple&gt;::value);
3853     TransformTupleValues(CastAndAppendTransform&lt;const Element&amp;&gt;(), matchers_,
3854                          ::std::back_inserter(matchers));
3855     return MakeMatcher(new UnorderedElementsAreMatcherImpl&lt;Container&gt;(
3856         UnorderedMatcherRequire::ExactMatch, matchers.begin(), matchers.end()));
3857   }
3858 
3859  private:
3860   const MatcherTuple matchers_;
3861   GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcher);
3862 };
3863 
3864 // Implements ElementsAre.
3865 template &lt;typename MatcherTuple&gt;
3866 class ElementsAreMatcher {
3867  public:
3868   explicit ElementsAreMatcher(const MatcherTuple&amp; args) : matchers_(args) {}
3869 
3870   template &lt;typename Container&gt;
3871   operator Matcher&lt;Container&gt;() const {
3872     GTEST_COMPILE_ASSERT_(
3873         !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt;::value ||
3874             ::testing::tuple_size&lt;MatcherTuple&gt;::value &lt; 2,
3875         use_UnorderedElementsAre_with_hash_tables);
3876 
3877     typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
3878     typedef typename internal::StlContainerView&lt;RawContainer&gt;::type View;
3879     typedef typename View::value_type Element;
3880     typedef ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; MatcherVec;
3881     MatcherVec matchers;
3882     matchers.reserve(::testing::tuple_size&lt;MatcherTuple&gt;::value);
3883     TransformTupleValues(CastAndAppendTransform&lt;const Element&amp;&gt;(), matchers_,
3884                          ::std::back_inserter(matchers));
3885     return MakeMatcher(new ElementsAreMatcherImpl&lt;Container&gt;(
3886                            matchers.begin(), matchers.end()));
3887   }
3888 
3889  private:
3890   const MatcherTuple matchers_;
3891   GTEST_DISALLOW_ASSIGN_(ElementsAreMatcher);
3892 };
3893 
3894 // Implements UnorderedElementsAreArray(), IsSubsetOf(), and IsSupersetOf().
3895 template &lt;typename T&gt;
3896 class UnorderedElementsAreArrayMatcher {
3897  public:
3898   template &lt;typename Iter&gt;
3899   UnorderedElementsAreArrayMatcher(UnorderedMatcherRequire::Flags match_flags,
3900                                    Iter first, Iter last)
3901       : match_flags_(match_flags), matchers_(first, last) {}
3902 
3903   template &lt;typename Container&gt;
3904   operator Matcher&lt;Container&gt;() const {
3905     return MakeMatcher(new UnorderedElementsAreMatcherImpl&lt;Container&gt;(
3906         match_flags_, matchers_.begin(), matchers_.end()));
3907   }
3908 
3909  private:
3910   UnorderedMatcherRequire::Flags match_flags_;
3911   ::std::vector&lt;T&gt; matchers_;
3912 
3913   GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreArrayMatcher);
3914 };
3915 
3916 // Implements ElementsAreArray().
3917 template &lt;typename T&gt;
3918 class ElementsAreArrayMatcher {
3919  public:
3920   template &lt;typename Iter&gt;
3921   ElementsAreArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}
3922 
3923   template &lt;typename Container&gt;
3924   operator Matcher&lt;Container&gt;() const {
3925     GTEST_COMPILE_ASSERT_(
3926         !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt;::value,
3927         use_UnorderedElementsAreArray_with_hash_tables);
3928 
3929     return MakeMatcher(new ElementsAreMatcherImpl&lt;Container&gt;(
3930         matchers_.begin(), matchers_.end()));
3931   }
3932 
3933  private:
3934   const ::std::vector&lt;T&gt; matchers_;
3935 
3936   GTEST_DISALLOW_ASSIGN_(ElementsAreArrayMatcher);
3937 };
3938 
3939 // Given a 2-tuple matcher tm of type Tuple2Matcher and a value second
3940 // of type Second, BoundSecondMatcher&lt;Tuple2Matcher, Second&gt;(tm,
3941 // second) is a polymorphic matcher that matches a value x iff tm
3942 // matches tuple (x, second).  Useful for implementing
3943 // UnorderedPointwise() in terms of UnorderedElementsAreArray().
3944 //
3945 // BoundSecondMatcher is copyable and assignable, as we need to put
3946 // instances of this class in a vector when implementing
3947 // UnorderedPointwise().
3948 template &lt;typename Tuple2Matcher, typename Second&gt;
3949 class BoundSecondMatcher {
3950  public:
3951   BoundSecondMatcher(const Tuple2Matcher&amp; tm, const Second&amp; second)
3952       : tuple2_matcher_(tm), second_value_(second) {}
3953 
3954   template &lt;typename T&gt;
3955   operator Matcher&lt;T&gt;() const {
3956     return MakeMatcher(new Impl&lt;T&gt;(tuple2_matcher_, second_value_));
3957   }
3958 
3959   // We have to define this for UnorderedPointwise() to compile in
3960   // C++98 mode, as it puts BoundSecondMatcher instances in a vector,
3961   // which requires the elements to be assignable in C++98.  The
3962   // compiler cannot generate the operator= for us, as Tuple2Matcher
3963   // and Second may not be assignable.
3964   //
3965   // However, this should never be called, so the implementation just
3966   // need to assert.
3967   void operator=(const BoundSecondMatcher&amp; /*rhs*/) {
3968     GTEST_LOG_(FATAL) &lt;&lt; &quot;BoundSecondMatcher should never be assigned.&quot;;
3969   }
3970 
3971  private:
3972   template &lt;typename T&gt;
3973   class Impl : public MatcherInterface&lt;T&gt; {
3974    public:
3975     typedef ::testing::tuple&lt;T, Second&gt; ArgTuple;
3976 
3977     Impl(const Tuple2Matcher&amp; tm, const Second&amp; second)
3978         : mono_tuple2_matcher_(SafeMatcherCast&lt;const ArgTuple&amp;&gt;(tm)),
3979           second_value_(second) {}
3980 
3981     virtual void DescribeTo(::std::ostream* os) const {
3982       *os &lt;&lt; &quot;and &quot;;
3983       UniversalPrint(second_value_, os);
3984       *os &lt;&lt; &quot; &quot;;
3985       mono_tuple2_matcher_.DescribeTo(os);
3986     }
3987 
3988     virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {
3989       return mono_tuple2_matcher_.MatchAndExplain(ArgTuple(x, second_value_),
3990                                                   listener);
3991     }
3992 
3993    private:
3994     const Matcher&lt;const ArgTuple&amp;&gt; mono_tuple2_matcher_;
3995     const Second second_value_;
3996 
3997     GTEST_DISALLOW_ASSIGN_(Impl);
3998   };
3999 
4000   const Tuple2Matcher tuple2_matcher_;
4001   const Second second_value_;
4002 };
4003 
4004 // Given a 2-tuple matcher tm and a value second,
4005 // MatcherBindSecond(tm, second) returns a matcher that matches a
4006 // value x iff tm matches tuple (x, second).  Useful for implementing
4007 // UnorderedPointwise() in terms of UnorderedElementsAreArray().
4008 template &lt;typename Tuple2Matcher, typename Second&gt;
4009 BoundSecondMatcher&lt;Tuple2Matcher, Second&gt; MatcherBindSecond(
4010     const Tuple2Matcher&amp; tm, const Second&amp; second) {
4011   return BoundSecondMatcher&lt;Tuple2Matcher, Second&gt;(tm, second);
4012 }
4013 
4014 // Returns the description for a matcher defined using the MATCHER*()
4015 // macro where the user-supplied description string is &quot;&quot;, if
4016 // &#39;negation&#39; is false; otherwise returns the description of the
4017 // negation of the matcher.  &#39;param_values&#39; contains a list of strings
4018 // that are the print-out of the matcher&#39;s parameters.
4019 GTEST_API_ std::string FormatMatcherDescription(bool negation,
4020                                                 const char* matcher_name,
4021                                                 const Strings&amp; param_values);
4022 
4023 // Implements a matcher that checks the value of a optional&lt;&gt; type variable.
4024 template &lt;typename ValueMatcher&gt;
4025 class OptionalMatcher {
4026  public:
4027   explicit OptionalMatcher(const ValueMatcher&amp; value_matcher)
4028       : value_matcher_(value_matcher) {}
4029 
4030   template &lt;typename Optional&gt;
4031   operator Matcher&lt;Optional&gt;() const {
4032     return MakeMatcher(new Impl&lt;Optional&gt;(value_matcher_));
4033   }
4034 
4035   template &lt;typename Optional&gt;
4036   class Impl : public MatcherInterface&lt;Optional&gt; {
4037    public:
4038     typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Optional) OptionalView;
4039     typedef typename OptionalView::value_type ValueType;
4040     explicit Impl(const ValueMatcher&amp; value_matcher)
4041         : value_matcher_(MatcherCast&lt;ValueType&gt;(value_matcher)) {}
4042 
4043     virtual void DescribeTo(::std::ostream* os) const {
4044       *os &lt;&lt; &quot;value &quot;;
4045       value_matcher_.DescribeTo(os);
4046     }
4047 
4048     virtual void DescribeNegationTo(::std::ostream* os) const {
4049       *os &lt;&lt; &quot;value &quot;;
4050       value_matcher_.DescribeNegationTo(os);
4051     }
4052 
4053     virtual bool MatchAndExplain(Optional optional,
4054                                  MatchResultListener* listener) const {
4055       if (!optional) {
4056         *listener &lt;&lt; &quot;which is not engaged&quot;;
4057         return false;
4058       }
4059       const ValueType&amp; value = *optional;
4060       StringMatchResultListener value_listener;
4061       const bool match = value_matcher_.MatchAndExplain(value, &amp;value_listener);
4062       *listener &lt;&lt; &quot;whose value &quot; &lt;&lt; PrintToString(value)
4063                 &lt;&lt; (match ? &quot; matches&quot; : &quot; doesn&#39;t match&quot;);
4064       PrintIfNotEmpty(value_listener.str(), listener-&gt;stream());
4065       return match;
4066     }
4067 
4068    private:
4069     const Matcher&lt;ValueType&gt; value_matcher_;
4070     GTEST_DISALLOW_ASSIGN_(Impl);
4071   };
4072 
4073  private:
4074   const ValueMatcher value_matcher_;
4075   GTEST_DISALLOW_ASSIGN_(OptionalMatcher);
4076 };
4077 
4078 namespace variant_matcher {
4079 // Overloads to allow VariantMatcher to do proper ADL lookup.
4080 template &lt;typename T&gt;
4081 void holds_alternative() {}
4082 template &lt;typename T&gt;
4083 void get() {}
4084 
4085 // Implements a matcher that checks the value of a variant&lt;&gt; type variable.
4086 template &lt;typename T&gt;
4087 class VariantMatcher {
4088  public:
4089   explicit VariantMatcher(::testing::Matcher&lt;const T&amp;&gt; matcher)
4090       : matcher_(internal::move(matcher)) {}
4091 
4092   template &lt;typename Variant&gt;
4093   bool MatchAndExplain(const Variant&amp; value,
4094                        ::testing::MatchResultListener* listener) const {
4095     if (!listener-&gt;IsInterested()) {
4096       return holds_alternative&lt;T&gt;(value) &amp;&amp; matcher_.Matches(get&lt;T&gt;(value));
4097     }
4098 
4099     if (!holds_alternative&lt;T&gt;(value)) {
4100       *listener &lt;&lt; &quot;whose value is not of type &#39;&quot; &lt;&lt; GetTypeName() &lt;&lt; &quot;&#39;&quot;;
4101       return false;
4102     }
4103 
4104     const T&amp; elem = get&lt;T&gt;(value);
4105     StringMatchResultListener elem_listener;
4106     const bool match = matcher_.MatchAndExplain(elem, &amp;elem_listener);
4107     *listener &lt;&lt; &quot;whose value &quot; &lt;&lt; PrintToString(elem)
4108               &lt;&lt; (match ? &quot; matches&quot; : &quot; doesn&#39;t match&quot;);
4109     PrintIfNotEmpty(elem_listener.str(), listener-&gt;stream());
4110     return match;
4111   }
4112 
4113   void DescribeTo(std::ostream* os) const {
4114     *os &lt;&lt; &quot;is a variant&lt;&gt; with value of type &#39;&quot; &lt;&lt; GetTypeName()
4115         &lt;&lt; &quot;&#39; and the value &quot;;
4116     matcher_.DescribeTo(os);
4117   }
4118 
4119   void DescribeNegationTo(std::ostream* os) const {
4120     *os &lt;&lt; &quot;is a variant&lt;&gt; with value of type other than &#39;&quot; &lt;&lt; GetTypeName()
4121         &lt;&lt; &quot;&#39; or the value &quot;;
4122     matcher_.DescribeNegationTo(os);
4123   }
4124 
4125  private:
4126   static std::string GetTypeName() {
4127 #if GTEST_HAS_RTTI
4128     GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(
4129         return internal::GetTypeName&lt;T&gt;());
4130 #endif
4131     return &quot;the element type&quot;;
4132   }
4133 
4134   const ::testing::Matcher&lt;const T&amp;&gt; matcher_;
4135 };
4136 
4137 }  // namespace variant_matcher
4138 
4139 namespace any_cast_matcher {
4140 
4141 // Overloads to allow AnyCastMatcher to do proper ADL lookup.
4142 template &lt;typename T&gt;
4143 void any_cast() {}
4144 
4145 // Implements a matcher that any_casts the value.
4146 template &lt;typename T&gt;
4147 class AnyCastMatcher {
4148  public:
4149   explicit AnyCastMatcher(const ::testing::Matcher&lt;const T&amp;&gt;&amp; matcher)
4150       : matcher_(matcher) {}
4151 
4152   template &lt;typename AnyType&gt;
4153   bool MatchAndExplain(const AnyType&amp; value,
4154                        ::testing::MatchResultListener* listener) const {
4155     if (!listener-&gt;IsInterested()) {
4156       const T* ptr = any_cast&lt;T&gt;(&amp;value);
4157       return ptr != NULL &amp;&amp; matcher_.Matches(*ptr);
4158     }
4159 
4160     const T* elem = any_cast&lt;T&gt;(&amp;value);
4161     if (elem == NULL) {
4162       *listener &lt;&lt; &quot;whose value is not of type &#39;&quot; &lt;&lt; GetTypeName() &lt;&lt; &quot;&#39;&quot;;
4163       return false;
4164     }
4165 
4166     StringMatchResultListener elem_listener;
4167     const bool match = matcher_.MatchAndExplain(*elem, &amp;elem_listener);
4168     *listener &lt;&lt; &quot;whose value &quot; &lt;&lt; PrintToString(*elem)
4169               &lt;&lt; (match ? &quot; matches&quot; : &quot; doesn&#39;t match&quot;);
4170     PrintIfNotEmpty(elem_listener.str(), listener-&gt;stream());
4171     return match;
4172   }
4173 
4174   void DescribeTo(std::ostream* os) const {
4175     *os &lt;&lt; &quot;is an &#39;any&#39; type with value of type &#39;&quot; &lt;&lt; GetTypeName()
4176         &lt;&lt; &quot;&#39; and the value &quot;;
4177     matcher_.DescribeTo(os);
4178   }
4179 
4180   void DescribeNegationTo(std::ostream* os) const {
4181     *os &lt;&lt; &quot;is an &#39;any&#39; type with value of type other than &#39;&quot; &lt;&lt; GetTypeName()
4182         &lt;&lt; &quot;&#39; or the value &quot;;
4183     matcher_.DescribeNegationTo(os);
4184   }
4185 
4186  private:
4187   static std::string GetTypeName() {
4188 #if GTEST_HAS_RTTI
4189     GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(
4190         return internal::GetTypeName&lt;T&gt;());
4191 #endif
4192     return &quot;the element type&quot;;
4193   }
4194 
4195   const ::testing::Matcher&lt;const T&amp;&gt; matcher_;
4196 };
4197 
4198 }  // namespace any_cast_matcher
4199 }  // namespace internal
4200 
4201 // ElementsAreArray(iterator_first, iterator_last)
4202 // ElementsAreArray(pointer, count)
4203 // ElementsAreArray(array)
4204 // ElementsAreArray(container)
4205 // ElementsAreArray({ e1, e2, ..., en })
4206 //
4207 // The ElementsAreArray() functions are like ElementsAre(...), except
4208 // that they are given a homogeneous sequence rather than taking each
4209 // element as a function argument. The sequence can be specified as an
4210 // array, a pointer and count, a vector, an initializer list, or an
4211 // STL iterator range. In each of these cases, the underlying sequence
4212 // can be either a sequence of values or a sequence of matchers.
4213 //
4214 // All forms of ElementsAreArray() make a copy of the input matcher sequence.
4215 
4216 template &lt;typename Iter&gt;
4217 inline internal::ElementsAreArrayMatcher&lt;
4218     typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
4219 ElementsAreArray(Iter first, Iter last) {
4220   typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
4221   return internal::ElementsAreArrayMatcher&lt;T&gt;(first, last);
4222 }
4223 
4224 template &lt;typename T&gt;
4225 inline internal::ElementsAreArrayMatcher&lt;T&gt; ElementsAreArray(
4226     const T* pointer, size_t count) {
4227   return ElementsAreArray(pointer, pointer + count);
4228 }
4229 
4230 template &lt;typename T, size_t N&gt;
4231 inline internal::ElementsAreArrayMatcher&lt;T&gt; ElementsAreArray(
4232     const T (&amp;array)[N]) {
4233   return ElementsAreArray(array, N);
4234 }
4235 
4236 template &lt;typename Container&gt;
4237 inline internal::ElementsAreArrayMatcher&lt;typename Container::value_type&gt;
4238 ElementsAreArray(const Container&amp; container) {
4239   return ElementsAreArray(container.begin(), container.end());
4240 }
4241 
4242 #if GTEST_HAS_STD_INITIALIZER_LIST_
4243 template &lt;typename T&gt;
4244 inline internal::ElementsAreArrayMatcher&lt;T&gt;
4245 ElementsAreArray(::std::initializer_list&lt;T&gt; xs) {
4246   return ElementsAreArray(xs.begin(), xs.end());
4247 }
4248 #endif
4249 
4250 // UnorderedElementsAreArray(iterator_first, iterator_last)
4251 // UnorderedElementsAreArray(pointer, count)
4252 // UnorderedElementsAreArray(array)
4253 // UnorderedElementsAreArray(container)
4254 // UnorderedElementsAreArray({ e1, e2, ..., en })
4255 //
4256 // UnorderedElementsAreArray() verifies that a bijective mapping onto a
4257 // collection of matchers exists.
4258 //
4259 // The matchers can be specified as an array, a pointer and count, a container,
4260 // an initializer list, or an STL iterator range. In each of these cases, the
4261 // underlying matchers can be either values or matchers.
4262 
4263 template &lt;typename Iter&gt;
4264 inline internal::UnorderedElementsAreArrayMatcher&lt;
4265     typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
4266 UnorderedElementsAreArray(Iter first, Iter last) {
4267   typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
4268   return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(
4269       internal::UnorderedMatcherRequire::ExactMatch, first, last);
4270 }
4271 
4272 template &lt;typename T&gt;
4273 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt;
4274 UnorderedElementsAreArray(const T* pointer, size_t count) {
4275   return UnorderedElementsAreArray(pointer, pointer + count);
4276 }
4277 
4278 template &lt;typename T, size_t N&gt;
4279 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt;
4280 UnorderedElementsAreArray(const T (&amp;array)[N]) {
4281   return UnorderedElementsAreArray(array, N);
4282 }
4283 
4284 template &lt;typename Container&gt;
4285 inline internal::UnorderedElementsAreArrayMatcher&lt;
4286     typename Container::value_type&gt;
4287 UnorderedElementsAreArray(const Container&amp; container) {
4288   return UnorderedElementsAreArray(container.begin(), container.end());
4289 }
4290 
4291 #if GTEST_HAS_STD_INITIALIZER_LIST_
4292 template &lt;typename T&gt;
4293 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt;
4294 UnorderedElementsAreArray(::std::initializer_list&lt;T&gt; xs) {
4295   return UnorderedElementsAreArray(xs.begin(), xs.end());
4296 }
4297 #endif
4298 
4299 // _ is a matcher that matches anything of any type.
4300 //
4301 // This definition is fine as:
4302 //
4303 //   1. The C++ standard permits using the name _ in a namespace that
4304 //      is not the global namespace or ::std.
4305 //   2. The AnythingMatcher class has no data member or constructor,
4306 //      so it&#39;s OK to create global variables of this type.
4307 //   3. c-style has approved of using _ in this case.
4308 const internal::AnythingMatcher _ = {};
4309 // Creates a matcher that matches any value of the given type T.
4310 template &lt;typename T&gt;
4311 inline Matcher&lt;T&gt; A() {
4312   return Matcher&lt;T&gt;(new internal::AnyMatcherImpl&lt;T&gt;());
4313 }
4314 
4315 // Creates a matcher that matches any value of the given type T.
4316 template &lt;typename T&gt;
4317 inline Matcher&lt;T&gt; An() { return A&lt;T&gt;(); }
4318 
4319 // Creates a polymorphic matcher that matches anything equal to x.
4320 // Note: if the parameter of Eq() were declared as const T&amp;, Eq(&quot;foo&quot;)
4321 // wouldn&#39;t compile.
4322 template &lt;typename T&gt;
4323 inline internal::EqMatcher&lt;T&gt; Eq(T x) { return internal::EqMatcher&lt;T&gt;(x); }
4324 
4325 // Constructs a Matcher&lt;T&gt; from a &#39;value&#39; of type T.  The constructed
4326 // matcher matches any value that&#39;s equal to &#39;value&#39;.
4327 template &lt;typename T&gt;
4328 Matcher&lt;T&gt;::Matcher(T value) { *this = Eq(value); }
4329 
4330 template &lt;typename T, typename M&gt;
4331 Matcher&lt;T&gt; internal::MatcherCastImpl&lt;T, M&gt;::CastImpl(
4332     const M&amp; value,
4333     internal::BooleanConstant&lt;false&gt; /* convertible_to_matcher */,
4334     internal::BooleanConstant&lt;false&gt; /* convertible_to_T */) {
4335   return Eq(value);
4336 }
4337 
4338 // Creates a monomorphic matcher that matches anything with type Lhs
4339 // and equal to rhs.  A user may need to use this instead of Eq(...)
4340 // in order to resolve an overloading ambiguity.
4341 //
4342 // TypedEq&lt;T&gt;(x) is just a convenient short-hand for Matcher&lt;T&gt;(Eq(x))
4343 // or Matcher&lt;T&gt;(x), but more readable than the latter.
4344 //
4345 // We could define similar monomorphic matchers for other comparison
4346 // operations (e.g. TypedLt, TypedGe, and etc), but decided not to do
4347 // it yet as those are used much less than Eq() in practice.  A user
4348 // can always write Matcher&lt;T&gt;(Lt(5)) to be explicit about the type,
4349 // for example.
4350 template &lt;typename Lhs, typename Rhs&gt;
4351 inline Matcher&lt;Lhs&gt; TypedEq(const Rhs&amp; rhs) { return Eq(rhs); }
4352 
4353 // Creates a polymorphic matcher that matches anything &gt;= x.
4354 template &lt;typename Rhs&gt;
4355 inline internal::GeMatcher&lt;Rhs&gt; Ge(Rhs x) {
4356   return internal::GeMatcher&lt;Rhs&gt;(x);
4357 }
4358 
4359 // Creates a polymorphic matcher that matches anything &gt; x.
4360 template &lt;typename Rhs&gt;
4361 inline internal::GtMatcher&lt;Rhs&gt; Gt(Rhs x) {
4362   return internal::GtMatcher&lt;Rhs&gt;(x);
4363 }
4364 
4365 // Creates a polymorphic matcher that matches anything &lt;= x.
4366 template &lt;typename Rhs&gt;
4367 inline internal::LeMatcher&lt;Rhs&gt; Le(Rhs x) {
4368   return internal::LeMatcher&lt;Rhs&gt;(x);
4369 }
4370 
4371 // Creates a polymorphic matcher that matches anything &lt; x.
4372 template &lt;typename Rhs&gt;
4373 inline internal::LtMatcher&lt;Rhs&gt; Lt(Rhs x) {
4374   return internal::LtMatcher&lt;Rhs&gt;(x);
4375 }
4376 
4377 // Creates a polymorphic matcher that matches anything != x.
4378 template &lt;typename Rhs&gt;
4379 inline internal::NeMatcher&lt;Rhs&gt; Ne(Rhs x) {
4380   return internal::NeMatcher&lt;Rhs&gt;(x);
4381 }
4382 
4383 // Creates a polymorphic matcher that matches any NULL pointer.
4384 inline PolymorphicMatcher&lt;internal::IsNullMatcher &gt; IsNull() {
4385   return MakePolymorphicMatcher(internal::IsNullMatcher());
4386 }
4387 
4388 // Creates a polymorphic matcher that matches any non-NULL pointer.
4389 // This is convenient as Not(NULL) doesn&#39;t compile (the compiler
4390 // thinks that that expression is comparing a pointer with an integer).
4391 inline PolymorphicMatcher&lt;internal::NotNullMatcher &gt; NotNull() {
4392   return MakePolymorphicMatcher(internal::NotNullMatcher());
4393 }
4394 
4395 // Creates a polymorphic matcher that matches any argument that
4396 // references variable x.
4397 template &lt;typename T&gt;
4398 inline internal::RefMatcher&lt;T&amp;&gt; Ref(T&amp; x) {  // NOLINT
4399   return internal::RefMatcher&lt;T&amp;&gt;(x);
4400 }
4401 
4402 // Creates a matcher that matches any double argument approximately
4403 // equal to rhs, where two NANs are considered unequal.
4404 inline internal::FloatingEqMatcher&lt;double&gt; DoubleEq(double rhs) {
4405   return internal::FloatingEqMatcher&lt;double&gt;(rhs, false);
4406 }
4407 
4408 // Creates a matcher that matches any double argument approximately
4409 // equal to rhs, including NaN values when rhs is NaN.
4410 inline internal::FloatingEqMatcher&lt;double&gt; NanSensitiveDoubleEq(double rhs) {
4411   return internal::FloatingEqMatcher&lt;double&gt;(rhs, true);
4412 }
4413 
4414 // Creates a matcher that matches any double argument approximately equal to
4415 // rhs, up to the specified max absolute error bound, where two NANs are
4416 // considered unequal.  The max absolute error bound must be non-negative.
4417 inline internal::FloatingEqMatcher&lt;double&gt; DoubleNear(
4418     double rhs, double max_abs_error) {
4419   return internal::FloatingEqMatcher&lt;double&gt;(rhs, false, max_abs_error);
4420 }
4421 
4422 // Creates a matcher that matches any double argument approximately equal to
4423 // rhs, up to the specified max absolute error bound, including NaN values when
4424 // rhs is NaN.  The max absolute error bound must be non-negative.
4425 inline internal::FloatingEqMatcher&lt;double&gt; NanSensitiveDoubleNear(
4426     double rhs, double max_abs_error) {
4427   return internal::FloatingEqMatcher&lt;double&gt;(rhs, true, max_abs_error);
4428 }
4429 
4430 // Creates a matcher that matches any float argument approximately
4431 // equal to rhs, where two NANs are considered unequal.
4432 inline internal::FloatingEqMatcher&lt;float&gt; FloatEq(float rhs) {
4433   return internal::FloatingEqMatcher&lt;float&gt;(rhs, false);
4434 }
4435 
4436 // Creates a matcher that matches any float argument approximately
4437 // equal to rhs, including NaN values when rhs is NaN.
4438 inline internal::FloatingEqMatcher&lt;float&gt; NanSensitiveFloatEq(float rhs) {
4439   return internal::FloatingEqMatcher&lt;float&gt;(rhs, true);
4440 }
4441 
4442 // Creates a matcher that matches any float argument approximately equal to
4443 // rhs, up to the specified max absolute error bound, where two NANs are
4444 // considered unequal.  The max absolute error bound must be non-negative.
4445 inline internal::FloatingEqMatcher&lt;float&gt; FloatNear(
4446     float rhs, float max_abs_error) {
4447   return internal::FloatingEqMatcher&lt;float&gt;(rhs, false, max_abs_error);
4448 }
4449 
4450 // Creates a matcher that matches any float argument approximately equal to
4451 // rhs, up to the specified max absolute error bound, including NaN values when
4452 // rhs is NaN.  The max absolute error bound must be non-negative.
4453 inline internal::FloatingEqMatcher&lt;float&gt; NanSensitiveFloatNear(
4454     float rhs, float max_abs_error) {
4455   return internal::FloatingEqMatcher&lt;float&gt;(rhs, true, max_abs_error);
4456 }
4457 
4458 // Creates a matcher that matches a pointer (raw or smart) that points
4459 // to a value that matches inner_matcher.
4460 template &lt;typename InnerMatcher&gt;
4461 inline internal::PointeeMatcher&lt;InnerMatcher&gt; Pointee(
4462     const InnerMatcher&amp; inner_matcher) {
4463   return internal::PointeeMatcher&lt;InnerMatcher&gt;(inner_matcher);
4464 }
4465 
4466 #if GTEST_HAS_RTTI
4467 // Creates a matcher that matches a pointer or reference that matches
4468 // inner_matcher when dynamic_cast&lt;To&gt; is applied.
4469 // The result of dynamic_cast&lt;To&gt; is forwarded to the inner matcher.
4470 // If To is a pointer and the cast fails, the inner matcher will receive NULL.
4471 // If To is a reference and the cast fails, this matcher returns false
4472 // immediately.
4473 template &lt;typename To&gt;
4474 inline PolymorphicMatcher&lt;internal::WhenDynamicCastToMatcher&lt;To&gt; &gt;
4475 WhenDynamicCastTo(const Matcher&lt;To&gt;&amp; inner_matcher) {
4476   return MakePolymorphicMatcher(
4477       internal::WhenDynamicCastToMatcher&lt;To&gt;(inner_matcher));
4478 }
4479 #endif  // GTEST_HAS_RTTI
4480 
4481 // Creates a matcher that matches an object whose given field matches
4482 // &#39;matcher&#39;.  For example,
4483 //   Field(&amp;Foo::number, Ge(5))
4484 // matches a Foo object x iff x.number &gt;= 5.
4485 template &lt;typename Class, typename FieldType, typename FieldMatcher&gt;
4486 inline PolymorphicMatcher&lt;
4487   internal::FieldMatcher&lt;Class, FieldType&gt; &gt; Field(
4488     FieldType Class::*field, const FieldMatcher&amp; matcher) {
4489   return MakePolymorphicMatcher(
4490       internal::FieldMatcher&lt;Class, FieldType&gt;(
4491           field, MatcherCast&lt;const FieldType&amp;&gt;(matcher)));
4492   // The call to MatcherCast() is required for supporting inner
4493   // matchers of compatible types.  For example, it allows
4494   //   Field(&amp;Foo::bar, m)
4495   // to compile where bar is an int32 and m is a matcher for int64.
4496 }
4497 
4498 // Same as Field() but also takes the name of the field to provide better error
4499 // messages.
4500 template &lt;typename Class, typename FieldType, typename FieldMatcher&gt;
4501 inline PolymorphicMatcher&lt;internal::FieldMatcher&lt;Class, FieldType&gt; &gt; Field(
4502     const std::string&amp; field_name, FieldType Class::*field,
4503     const FieldMatcher&amp; matcher) {
4504   return MakePolymorphicMatcher(internal::FieldMatcher&lt;Class, FieldType&gt;(
4505       field_name, field, MatcherCast&lt;const FieldType&amp;&gt;(matcher)));
4506 }
4507 
4508 // Creates a matcher that matches an object whose given property
4509 // matches &#39;matcher&#39;.  For example,
4510 //   Property(&amp;Foo::str, StartsWith(&quot;hi&quot;))
4511 // matches a Foo object x iff x.str() starts with &quot;hi&quot;.
4512 template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
4513 inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
4514     Class, PropertyType, PropertyType (Class::*)() const&gt; &gt;
4515 Property(PropertyType (Class::*property)() const,
4516          const PropertyMatcher&amp; matcher) {
4517   return MakePolymorphicMatcher(
4518       internal::PropertyMatcher&lt;Class, PropertyType,
4519                                 PropertyType (Class::*)() const&gt;(
4520           property,
4521           MatcherCast&lt;GTEST_REFERENCE_TO_CONST_(PropertyType)&gt;(matcher)));
4522   // The call to MatcherCast() is required for supporting inner
4523   // matchers of compatible types.  For example, it allows
4524   //   Property(&amp;Foo::bar, m)
4525   // to compile where bar() returns an int32 and m is a matcher for int64.
4526 }
4527 
4528 // Same as Property() above, but also takes the name of the property to provide
4529 // better error messages.
4530 template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
4531 inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
4532     Class, PropertyType, PropertyType (Class::*)() const&gt; &gt;
4533 Property(const std::string&amp; property_name,
4534          PropertyType (Class::*property)() const,
4535          const PropertyMatcher&amp; matcher) {
4536   return MakePolymorphicMatcher(
4537       internal::PropertyMatcher&lt;Class, PropertyType,
4538                                 PropertyType (Class::*)() const&gt;(
4539           property_name, property,
4540           MatcherCast&lt;GTEST_REFERENCE_TO_CONST_(PropertyType)&gt;(matcher)));
4541 }
4542 
4543 #if GTEST_LANG_CXX11
4544 // The same as above but for reference-qualified member functions.
4545 template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
4546 inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
4547     Class, PropertyType, PropertyType (Class::*)() const &amp;&gt; &gt;
4548 Property(PropertyType (Class::*property)() const &amp;,
4549          const PropertyMatcher&amp; matcher) {
4550   return MakePolymorphicMatcher(
4551       internal::PropertyMatcher&lt;Class, PropertyType,
4552                                 PropertyType (Class::*)() const &amp;&gt;(
4553           property,
4554           MatcherCast&lt;GTEST_REFERENCE_TO_CONST_(PropertyType)&gt;(matcher)));
4555 }
4556 
4557 // Three-argument form for reference-qualified member functions.
4558 template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
4559 inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
4560     Class, PropertyType, PropertyType (Class::*)() const &amp;&gt; &gt;
4561 Property(const std::string&amp; property_name,
4562          PropertyType (Class::*property)() const &amp;,
4563          const PropertyMatcher&amp; matcher) {
4564   return MakePolymorphicMatcher(
4565       internal::PropertyMatcher&lt;Class, PropertyType,
4566                                 PropertyType (Class::*)() const &amp;&gt;(
4567           property_name, property,
4568           MatcherCast&lt;GTEST_REFERENCE_TO_CONST_(PropertyType)&gt;(matcher)));
4569 }
4570 #endif
4571 
4572 // Creates a matcher that matches an object iff the result of applying
4573 // a callable to x matches &#39;matcher&#39;.
4574 // For example,
4575 //   ResultOf(f, StartsWith(&quot;hi&quot;))
4576 // matches a Foo object x iff f(x) starts with &quot;hi&quot;.
4577 // `callable` parameter can be a function, function pointer, or a functor. It is
4578 // required to keep no state affecting the results of the calls on it and make
4579 // no assumptions about how many calls will be made. Any state it keeps must be
4580 // protected from the concurrent access.
4581 template &lt;typename Callable, typename InnerMatcher&gt;
4582 internal::ResultOfMatcher&lt;Callable, InnerMatcher&gt; ResultOf(
4583     Callable callable, InnerMatcher matcher) {
4584   return internal::ResultOfMatcher&lt;Callable, InnerMatcher&gt;(
4585       internal::move(callable), internal::move(matcher));
4586 }
4587 
4588 // String matchers.
4589 
4590 // Matches a string equal to str.
4591 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrEq(
4592     const std::string&amp; str) {
4593   return MakePolymorphicMatcher(
4594       internal::StrEqualityMatcher&lt;std::string&gt;(str, true, true));
4595 }
4596 
4597 // Matches a string not equal to str.
4598 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrNe(
4599     const std::string&amp; str) {
4600   return MakePolymorphicMatcher(
4601       internal::StrEqualityMatcher&lt;std::string&gt;(str, false, true));
4602 }
4603 
4604 // Matches a string equal to str, ignoring case.
4605 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrCaseEq(
4606     const std::string&amp; str) {
4607   return MakePolymorphicMatcher(
4608       internal::StrEqualityMatcher&lt;std::string&gt;(str, true, false));
4609 }
4610 
4611 // Matches a string not equal to str, ignoring case.
4612 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrCaseNe(
4613     const std::string&amp; str) {
4614   return MakePolymorphicMatcher(
4615       internal::StrEqualityMatcher&lt;std::string&gt;(str, false, false));
4616 }
4617 
4618 // Creates a matcher that matches any string, std::string, or C string
4619 // that contains the given substring.
4620 inline PolymorphicMatcher&lt;internal::HasSubstrMatcher&lt;std::string&gt; &gt; HasSubstr(
4621     const std::string&amp; substring) {
4622   return MakePolymorphicMatcher(
4623       internal::HasSubstrMatcher&lt;std::string&gt;(substring));
4624 }
4625 
4626 // Matches a string that starts with &#39;prefix&#39; (case-sensitive).
4627 inline PolymorphicMatcher&lt;internal::StartsWithMatcher&lt;std::string&gt; &gt; StartsWith(
4628     const std::string&amp; prefix) {
4629   return MakePolymorphicMatcher(
4630       internal::StartsWithMatcher&lt;std::string&gt;(prefix));
4631 }
4632 
4633 // Matches a string that ends with &#39;suffix&#39; (case-sensitive).
4634 inline PolymorphicMatcher&lt;internal::EndsWithMatcher&lt;std::string&gt; &gt; EndsWith(
4635     const std::string&amp; suffix) {
4636   return MakePolymorphicMatcher(internal::EndsWithMatcher&lt;std::string&gt;(suffix));
4637 }
4638 
4639 // Matches a string that fully matches regular expression &#39;regex&#39;.
4640 // The matcher takes ownership of &#39;regex&#39;.
4641 inline PolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; MatchesRegex(
4642     const internal::RE* regex) {
4643   return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, true));
4644 }
4645 inline PolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; MatchesRegex(
4646     const std::string&amp; regex) {
4647   return MatchesRegex(new internal::RE(regex));
4648 }
4649 
4650 // Matches a string that contains regular expression &#39;regex&#39;.
4651 // The matcher takes ownership of &#39;regex&#39;.
4652 inline PolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; ContainsRegex(
4653     const internal::RE* regex) {
4654   return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, false));
4655 }
4656 inline PolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; ContainsRegex(
4657     const std::string&amp; regex) {
4658   return ContainsRegex(new internal::RE(regex));
4659 }
4660 
4661 #if GTEST_HAS_GLOBAL_WSTRING || GTEST_HAS_STD_WSTRING
4662 // Wide string matchers.
4663 
4664 // Matches a string equal to str.
4665 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt; StrEq(
4666     const std::wstring&amp; str) {
4667   return MakePolymorphicMatcher(
4668       internal::StrEqualityMatcher&lt;std::wstring&gt;(str, true, true));
4669 }
4670 
4671 // Matches a string not equal to str.
4672 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt; StrNe(
4673     const std::wstring&amp; str) {
4674   return MakePolymorphicMatcher(
4675       internal::StrEqualityMatcher&lt;std::wstring&gt;(str, false, true));
4676 }
4677 
4678 // Matches a string equal to str, ignoring case.
4679 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt;
4680 StrCaseEq(const std::wstring&amp; str) {
4681   return MakePolymorphicMatcher(
4682       internal::StrEqualityMatcher&lt;std::wstring&gt;(str, true, false));
4683 }
4684 
4685 // Matches a string not equal to str, ignoring case.
4686 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt;
4687 StrCaseNe(const std::wstring&amp; str) {
4688   return MakePolymorphicMatcher(
4689       internal::StrEqualityMatcher&lt;std::wstring&gt;(str, false, false));
4690 }
4691 
4692 // Creates a matcher that matches any ::wstring, std::wstring, or C wide string
4693 // that contains the given substring.
4694 inline PolymorphicMatcher&lt;internal::HasSubstrMatcher&lt;std::wstring&gt; &gt; HasSubstr(
4695     const std::wstring&amp; substring) {
4696   return MakePolymorphicMatcher(
4697       internal::HasSubstrMatcher&lt;std::wstring&gt;(substring));
4698 }
4699 
4700 // Matches a string that starts with &#39;prefix&#39; (case-sensitive).
4701 inline PolymorphicMatcher&lt;internal::StartsWithMatcher&lt;std::wstring&gt; &gt;
4702 StartsWith(const std::wstring&amp; prefix) {
4703   return MakePolymorphicMatcher(
4704       internal::StartsWithMatcher&lt;std::wstring&gt;(prefix));
4705 }
4706 
4707 // Matches a string that ends with &#39;suffix&#39; (case-sensitive).
4708 inline PolymorphicMatcher&lt;internal::EndsWithMatcher&lt;std::wstring&gt; &gt; EndsWith(
4709     const std::wstring&amp; suffix) {
4710   return MakePolymorphicMatcher(
4711       internal::EndsWithMatcher&lt;std::wstring&gt;(suffix));
4712 }
4713 
4714 #endif  // GTEST_HAS_GLOBAL_WSTRING || GTEST_HAS_STD_WSTRING
4715 
4716 // Creates a polymorphic matcher that matches a 2-tuple where the
4717 // first field == the second field.
4718 inline internal::Eq2Matcher Eq() { return internal::Eq2Matcher(); }
4719 
4720 // Creates a polymorphic matcher that matches a 2-tuple where the
4721 // first field &gt;= the second field.
4722 inline internal::Ge2Matcher Ge() { return internal::Ge2Matcher(); }
4723 
4724 // Creates a polymorphic matcher that matches a 2-tuple where the
4725 // first field &gt; the second field.
4726 inline internal::Gt2Matcher Gt() { return internal::Gt2Matcher(); }
4727 
4728 // Creates a polymorphic matcher that matches a 2-tuple where the
4729 // first field &lt;= the second field.
4730 inline internal::Le2Matcher Le() { return internal::Le2Matcher(); }
4731 
4732 // Creates a polymorphic matcher that matches a 2-tuple where the
4733 // first field &lt; the second field.
4734 inline internal::Lt2Matcher Lt() { return internal::Lt2Matcher(); }
4735 
4736 // Creates a polymorphic matcher that matches a 2-tuple where the
4737 // first field != the second field.
4738 inline internal::Ne2Matcher Ne() { return internal::Ne2Matcher(); }
4739 
4740 // Creates a polymorphic matcher that matches a 2-tuple where
4741 // FloatEq(first field) matches the second field.
4742 inline internal::FloatingEq2Matcher&lt;float&gt; FloatEq() {
4743   return internal::FloatingEq2Matcher&lt;float&gt;();
4744 }
4745 
4746 // Creates a polymorphic matcher that matches a 2-tuple where
4747 // DoubleEq(first field) matches the second field.
4748 inline internal::FloatingEq2Matcher&lt;double&gt; DoubleEq() {
4749   return internal::FloatingEq2Matcher&lt;double&gt;();
4750 }
4751 
4752 // Creates a polymorphic matcher that matches a 2-tuple where
4753 // FloatEq(first field) matches the second field with NaN equality.
4754 inline internal::FloatingEq2Matcher&lt;float&gt; NanSensitiveFloatEq() {
4755   return internal::FloatingEq2Matcher&lt;float&gt;(true);
4756 }
4757 
4758 // Creates a polymorphic matcher that matches a 2-tuple where
4759 // DoubleEq(first field) matches the second field with NaN equality.
4760 inline internal::FloatingEq2Matcher&lt;double&gt; NanSensitiveDoubleEq() {
4761   return internal::FloatingEq2Matcher&lt;double&gt;(true);
4762 }
4763 
4764 // Creates a polymorphic matcher that matches a 2-tuple where
4765 // FloatNear(first field, max_abs_error) matches the second field.
4766 inline internal::FloatingEq2Matcher&lt;float&gt; FloatNear(float max_abs_error) {
4767   return internal::FloatingEq2Matcher&lt;float&gt;(max_abs_error);
4768 }
4769 
4770 // Creates a polymorphic matcher that matches a 2-tuple where
4771 // DoubleNear(first field, max_abs_error) matches the second field.
4772 inline internal::FloatingEq2Matcher&lt;double&gt; DoubleNear(double max_abs_error) {
4773   return internal::FloatingEq2Matcher&lt;double&gt;(max_abs_error);
4774 }
4775 
4776 // Creates a polymorphic matcher that matches a 2-tuple where
4777 // FloatNear(first field, max_abs_error) matches the second field with NaN
4778 // equality.
4779 inline internal::FloatingEq2Matcher&lt;float&gt; NanSensitiveFloatNear(
4780     float max_abs_error) {
4781   return internal::FloatingEq2Matcher&lt;float&gt;(max_abs_error, true);
4782 }
4783 
4784 // Creates a polymorphic matcher that matches a 2-tuple where
4785 // DoubleNear(first field, max_abs_error) matches the second field with NaN
4786 // equality.
4787 inline internal::FloatingEq2Matcher&lt;double&gt; NanSensitiveDoubleNear(
4788     double max_abs_error) {
4789   return internal::FloatingEq2Matcher&lt;double&gt;(max_abs_error, true);
4790 }
4791 
4792 // Creates a matcher that matches any value of type T that m doesn&#39;t
4793 // match.
4794 template &lt;typename InnerMatcher&gt;
4795 inline internal::NotMatcher&lt;InnerMatcher&gt; Not(InnerMatcher m) {
4796   return internal::NotMatcher&lt;InnerMatcher&gt;(m);
4797 }
4798 
4799 // Returns a matcher that matches anything that satisfies the given
4800 // predicate.  The predicate can be any unary function or functor
4801 // whose return type can be implicitly converted to bool.
4802 template &lt;typename Predicate&gt;
4803 inline PolymorphicMatcher&lt;internal::TrulyMatcher&lt;Predicate&gt; &gt;
4804 Truly(Predicate pred) {
4805   return MakePolymorphicMatcher(internal::TrulyMatcher&lt;Predicate&gt;(pred));
4806 }
4807 
4808 // Returns a matcher that matches the container size. The container must
4809 // support both size() and size_type which all STL-like containers provide.
4810 // Note that the parameter &#39;size&#39; can be a value of type size_type as well as
4811 // matcher. For instance:
4812 //   EXPECT_THAT(container, SizeIs(2));     // Checks container has 2 elements.
4813 //   EXPECT_THAT(container, SizeIs(Le(2));  // Checks container has at most 2.
4814 template &lt;typename SizeMatcher&gt;
4815 inline internal::SizeIsMatcher&lt;SizeMatcher&gt;
4816 SizeIs(const SizeMatcher&amp; size_matcher) {
4817   return internal::SizeIsMatcher&lt;SizeMatcher&gt;(size_matcher);
4818 }
4819 
4820 // Returns a matcher that matches the distance between the container&#39;s begin()
4821 // iterator and its end() iterator, i.e. the size of the container. This matcher
4822 // can be used instead of SizeIs with containers such as std::forward_list which
4823 // do not implement size(). The container must provide const_iterator (with
4824 // valid iterator_traits), begin() and end().
4825 template &lt;typename DistanceMatcher&gt;
4826 inline internal::BeginEndDistanceIsMatcher&lt;DistanceMatcher&gt;
4827 BeginEndDistanceIs(const DistanceMatcher&amp; distance_matcher) {
4828   return internal::BeginEndDistanceIsMatcher&lt;DistanceMatcher&gt;(distance_matcher);
4829 }
4830 
4831 // Returns a matcher that matches an equal container.
4832 // This matcher behaves like Eq(), but in the event of mismatch lists the
4833 // values that are included in one container but not the other. (Duplicate
4834 // values and order differences are not explained.)
4835 template &lt;typename Container&gt;
4836 inline PolymorphicMatcher&lt;internal::ContainerEqMatcher&lt;  // NOLINT
4837                             GTEST_REMOVE_CONST_(Container)&gt; &gt;
4838     ContainerEq(const Container&amp; rhs) {
4839   // This following line is for working around a bug in MSVC 8.0,
4840   // which causes Container to be a const type sometimes.
4841   typedef GTEST_REMOVE_CONST_(Container) RawContainer;
4842   return MakePolymorphicMatcher(
4843       internal::ContainerEqMatcher&lt;RawContainer&gt;(rhs));
4844 }
4845 
4846 // Returns a matcher that matches a container that, when sorted using
4847 // the given comparator, matches container_matcher.
4848 template &lt;typename Comparator, typename ContainerMatcher&gt;
4849 inline internal::WhenSortedByMatcher&lt;Comparator, ContainerMatcher&gt;
4850 WhenSortedBy(const Comparator&amp; comparator,
4851              const ContainerMatcher&amp; container_matcher) {
4852   return internal::WhenSortedByMatcher&lt;Comparator, ContainerMatcher&gt;(
4853       comparator, container_matcher);
4854 }
4855 
4856 // Returns a matcher that matches a container that, when sorted using
4857 // the &lt; operator, matches container_matcher.
4858 template &lt;typename ContainerMatcher&gt;
4859 inline internal::WhenSortedByMatcher&lt;internal::LessComparator, ContainerMatcher&gt;
4860 WhenSorted(const ContainerMatcher&amp; container_matcher) {
4861   return
4862       internal::WhenSortedByMatcher&lt;internal::LessComparator, ContainerMatcher&gt;(
4863           internal::LessComparator(), container_matcher);
4864 }
4865 
4866 // Matches an STL-style container or a native array that contains the
4867 // same number of elements as in rhs, where its i-th element and rhs&#39;s
4868 // i-th element (as a pair) satisfy the given pair matcher, for all i.
4869 // TupleMatcher must be able to be safely cast to Matcher&lt;tuple&lt;const
4870 // T1&amp;, const T2&amp;&gt; &gt;, where T1 and T2 are the types of elements in the
4871 // LHS container and the RHS container respectively.
4872 template &lt;typename TupleMatcher, typename Container&gt;
4873 inline internal::PointwiseMatcher&lt;TupleMatcher,
4874                                   GTEST_REMOVE_CONST_(Container)&gt;
4875 Pointwise(const TupleMatcher&amp; tuple_matcher, const Container&amp; rhs) {
4876   // This following line is for working around a bug in MSVC 8.0,
4877   // which causes Container to be a const type sometimes (e.g. when
4878   // rhs is a const int[])..
4879   typedef GTEST_REMOVE_CONST_(Container) RawContainer;
4880   return internal::PointwiseMatcher&lt;TupleMatcher, RawContainer&gt;(
4881       tuple_matcher, rhs);
4882 }
4883 
4884 #if GTEST_HAS_STD_INITIALIZER_LIST_
4885 
4886 // Supports the Pointwise(m, {a, b, c}) syntax.
4887 template &lt;typename TupleMatcher, typename T&gt;
4888 inline internal::PointwiseMatcher&lt;TupleMatcher, std::vector&lt;T&gt; &gt; Pointwise(
4889     const TupleMatcher&amp; tuple_matcher, std::initializer_list&lt;T&gt; rhs) {
4890   return Pointwise(tuple_matcher, std::vector&lt;T&gt;(rhs));
4891 }
4892 
4893 #endif  // GTEST_HAS_STD_INITIALIZER_LIST_
4894 
4895 // UnorderedPointwise(pair_matcher, rhs) matches an STL-style
4896 // container or a native array that contains the same number of
4897 // elements as in rhs, where in some permutation of the container, its
4898 // i-th element and rhs&#39;s i-th element (as a pair) satisfy the given
4899 // pair matcher, for all i.  Tuple2Matcher must be able to be safely
4900 // cast to Matcher&lt;tuple&lt;const T1&amp;, const T2&amp;&gt; &gt;, where T1 and T2 are
4901 // the types of elements in the LHS container and the RHS container
4902 // respectively.
4903 //
4904 // This is like Pointwise(pair_matcher, rhs), except that the element
4905 // order doesn&#39;t matter.
4906 template &lt;typename Tuple2Matcher, typename RhsContainer&gt;
4907 inline internal::UnorderedElementsAreArrayMatcher&lt;
4908     typename internal::BoundSecondMatcher&lt;
4909         Tuple2Matcher, typename internal::StlContainerView&lt;GTEST_REMOVE_CONST_(
4910                            RhsContainer)&gt;::type::value_type&gt; &gt;
4911 UnorderedPointwise(const Tuple2Matcher&amp; tuple2_matcher,
4912                    const RhsContainer&amp; rhs_container) {
4913   // This following line is for working around a bug in MSVC 8.0,
4914   // which causes RhsContainer to be a const type sometimes (e.g. when
4915   // rhs_container is a const int[]).
4916   typedef GTEST_REMOVE_CONST_(RhsContainer) RawRhsContainer;
4917 
4918   // RhsView allows the same code to handle RhsContainer being a
4919   // STL-style container and it being a native C-style array.
4920   typedef typename internal::StlContainerView&lt;RawRhsContainer&gt; RhsView;
4921   typedef typename RhsView::type RhsStlContainer;
4922   typedef typename RhsStlContainer::value_type Second;
4923   const RhsStlContainer&amp; rhs_stl_container =
4924       RhsView::ConstReference(rhs_container);
4925 
4926   // Create a matcher for each element in rhs_container.
4927   ::std::vector&lt;internal::BoundSecondMatcher&lt;Tuple2Matcher, Second&gt; &gt; matchers;
4928   for (typename RhsStlContainer::const_iterator it = rhs_stl_container.begin();
4929        it != rhs_stl_container.end(); ++it) {
4930     matchers.push_back(
4931         internal::MatcherBindSecond(tuple2_matcher, *it));
4932   }
4933 
4934   // Delegate the work to UnorderedElementsAreArray().
4935   return UnorderedElementsAreArray(matchers);
4936 }
4937 
4938 #if GTEST_HAS_STD_INITIALIZER_LIST_
4939 
4940 // Supports the UnorderedPointwise(m, {a, b, c}) syntax.
4941 template &lt;typename Tuple2Matcher, typename T&gt;
4942 inline internal::UnorderedElementsAreArrayMatcher&lt;
4943     typename internal::BoundSecondMatcher&lt;Tuple2Matcher, T&gt; &gt;
4944 UnorderedPointwise(const Tuple2Matcher&amp; tuple2_matcher,
4945                    std::initializer_list&lt;T&gt; rhs) {
4946   return UnorderedPointwise(tuple2_matcher, std::vector&lt;T&gt;(rhs));
4947 }
4948 
4949 #endif  // GTEST_HAS_STD_INITIALIZER_LIST_
4950 
4951 // Matches an STL-style container or a native array that contains at
4952 // least one element matching the given value or matcher.
4953 //
4954 // Examples:
4955 //   ::std::set&lt;int&gt; page_ids;
4956 //   page_ids.insert(3);
4957 //   page_ids.insert(1);
4958 //   EXPECT_THAT(page_ids, Contains(1));
4959 //   EXPECT_THAT(page_ids, Contains(Gt(2)));
4960 //   EXPECT_THAT(page_ids, Not(Contains(4)));
4961 //
4962 //   ::std::map&lt;int, size_t&gt; page_lengths;
4963 //   page_lengths[1] = 100;
4964 //   EXPECT_THAT(page_lengths,
4965 //               Contains(::std::pair&lt;const int, size_t&gt;(1, 100)));
4966 //
4967 //   const char* user_ids[] = { &quot;joe&quot;, &quot;mike&quot;, &quot;tom&quot; };
4968 //   EXPECT_THAT(user_ids, Contains(Eq(::std::string(&quot;tom&quot;))));
4969 template &lt;typename M&gt;
4970 inline internal::ContainsMatcher&lt;M&gt; Contains(M matcher) {
4971   return internal::ContainsMatcher&lt;M&gt;(matcher);
4972 }
4973 
4974 // IsSupersetOf(iterator_first, iterator_last)
4975 // IsSupersetOf(pointer, count)
4976 // IsSupersetOf(array)
4977 // IsSupersetOf(container)
4978 // IsSupersetOf({e1, e2, ..., en})
4979 //
4980 // IsSupersetOf() verifies that a surjective partial mapping onto a collection
4981 // of matchers exists. In other words, a container matches
4982 // IsSupersetOf({e1, ..., en}) if and only if there is a permutation
4983 // {y1, ..., yn} of some of the container&#39;s elements where y1 matches e1,
4984 // ..., and yn matches en. Obviously, the size of the container must be &gt;= n
4985 // in order to have a match. Examples:
4986 //
4987 // - {1, 2, 3} matches IsSupersetOf({Ge(3), Ne(0)}), as 3 matches Ge(3) and
4988 //   1 matches Ne(0).
4989 // - {1, 2} doesn&#39;t match IsSupersetOf({Eq(1), Lt(2)}), even though 1 matches
4990 //   both Eq(1) and Lt(2). The reason is that different matchers must be used
4991 //   for elements in different slots of the container.
4992 // - {1, 1, 2} matches IsSupersetOf({Eq(1), Lt(2)}), as (the first) 1 matches
4993 //   Eq(1) and (the second) 1 matches Lt(2).
4994 // - {1, 2, 3} matches IsSupersetOf(Gt(1), Gt(1)), as 2 matches (the first)
4995 //   Gt(1) and 3 matches (the second) Gt(1).
4996 //
4997 // The matchers can be specified as an array, a pointer and count, a container,
4998 // an initializer list, or an STL iterator range. In each of these cases, the
4999 // underlying matchers can be either values or matchers.
5000 
5001 template &lt;typename Iter&gt;
5002 inline internal::UnorderedElementsAreArrayMatcher&lt;
5003     typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
5004 IsSupersetOf(Iter first, Iter last) {
5005   typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
5006   return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(
5007       internal::UnorderedMatcherRequire::Superset, first, last);
5008 }
5009 
5010 template &lt;typename T&gt;
5011 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(
5012     const T* pointer, size_t count) {
5013   return IsSupersetOf(pointer, pointer + count);
5014 }
5015 
5016 template &lt;typename T, size_t N&gt;
5017 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(
5018     const T (&amp;array)[N]) {
5019   return IsSupersetOf(array, N);
5020 }
5021 
5022 template &lt;typename Container&gt;
5023 inline internal::UnorderedElementsAreArrayMatcher&lt;
5024     typename Container::value_type&gt;
5025 IsSupersetOf(const Container&amp; container) {
5026   return IsSupersetOf(container.begin(), container.end());
5027 }
5028 
5029 #if GTEST_HAS_STD_INITIALIZER_LIST_
5030 template &lt;typename T&gt;
5031 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(
5032     ::std::initializer_list&lt;T&gt; xs) {
5033   return IsSupersetOf(xs.begin(), xs.end());
5034 }
5035 #endif
5036 
5037 // IsSubsetOf(iterator_first, iterator_last)
5038 // IsSubsetOf(pointer, count)
5039 // IsSubsetOf(array)
5040 // IsSubsetOf(container)
5041 // IsSubsetOf({e1, e2, ..., en})
5042 //
5043 // IsSubsetOf() verifies that an injective mapping onto a collection of matchers
5044 // exists.  In other words, a container matches IsSubsetOf({e1, ..., en}) if and
5045 // only if there is a subset of matchers {m1, ..., mk} which would match the
5046 // container using UnorderedElementsAre.  Obviously, the size of the container
5047 // must be &lt;= n in order to have a match. Examples:
5048 //
5049 // - {1} matches IsSubsetOf({Gt(0), Lt(0)}), as 1 matches Gt(0).
5050 // - {1, -1} matches IsSubsetOf({Lt(0), Gt(0)}), as 1 matches Gt(0) and -1
5051 //   matches Lt(0).
5052 // - {1, 2} doesn&#39;t matches IsSubsetOf({Gt(0), Lt(0)}), even though 1 and 2 both
5053 //   match Gt(0). The reason is that different matchers must be used for
5054 //   elements in different slots of the container.
5055 //
5056 // The matchers can be specified as an array, a pointer and count, a container,
5057 // an initializer list, or an STL iterator range. In each of these cases, the
5058 // underlying matchers can be either values or matchers.
5059 
5060 template &lt;typename Iter&gt;
5061 inline internal::UnorderedElementsAreArrayMatcher&lt;
5062     typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
5063 IsSubsetOf(Iter first, Iter last) {
5064   typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
5065   return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(
5066       internal::UnorderedMatcherRequire::Subset, first, last);
5067 }
5068 
5069 template &lt;typename T&gt;
5070 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(
5071     const T* pointer, size_t count) {
5072   return IsSubsetOf(pointer, pointer + count);
5073 }
5074 
5075 template &lt;typename T, size_t N&gt;
5076 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(
5077     const T (&amp;array)[N]) {
5078   return IsSubsetOf(array, N);
5079 }
5080 
5081 template &lt;typename Container&gt;
5082 inline internal::UnorderedElementsAreArrayMatcher&lt;
5083     typename Container::value_type&gt;
5084 IsSubsetOf(const Container&amp; container) {
5085   return IsSubsetOf(container.begin(), container.end());
5086 }
5087 
5088 #if GTEST_HAS_STD_INITIALIZER_LIST_
5089 template &lt;typename T&gt;
5090 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(
5091     ::std::initializer_list&lt;T&gt; xs) {
5092   return IsSubsetOf(xs.begin(), xs.end());
5093 }
5094 #endif
5095 
5096 // Matches an STL-style container or a native array that contains only
5097 // elements matching the given value or matcher.
5098 //
5099 // Each(m) is semantically equivalent to Not(Contains(Not(m))). Only
5100 // the messages are different.
5101 //
5102 // Examples:
5103 //   ::std::set&lt;int&gt; page_ids;
5104 //   // Each(m) matches an empty container, regardless of what m is.
5105 //   EXPECT_THAT(page_ids, Each(Eq(1)));
5106 //   EXPECT_THAT(page_ids, Each(Eq(77)));
5107 //
5108 //   page_ids.insert(3);
5109 //   EXPECT_THAT(page_ids, Each(Gt(0)));
5110 //   EXPECT_THAT(page_ids, Not(Each(Gt(4))));
5111 //   page_ids.insert(1);
5112 //   EXPECT_THAT(page_ids, Not(Each(Lt(2))));
5113 //
5114 //   ::std::map&lt;int, size_t&gt; page_lengths;
5115 //   page_lengths[1] = 100;
5116 //   page_lengths[2] = 200;
5117 //   page_lengths[3] = 300;
5118 //   EXPECT_THAT(page_lengths, Not(Each(Pair(1, 100))));
5119 //   EXPECT_THAT(page_lengths, Each(Key(Le(3))));
5120 //
5121 //   const char* user_ids[] = { &quot;joe&quot;, &quot;mike&quot;, &quot;tom&quot; };
5122 //   EXPECT_THAT(user_ids, Not(Each(Eq(::std::string(&quot;tom&quot;)))));
5123 template &lt;typename M&gt;
5124 inline internal::EachMatcher&lt;M&gt; Each(M matcher) {
5125   return internal::EachMatcher&lt;M&gt;(matcher);
5126 }
5127 
5128 // Key(inner_matcher) matches an std::pair whose &#39;first&#39; field matches
5129 // inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an
5130 // std::map that contains at least one element whose key is &gt;= 5.
5131 template &lt;typename M&gt;
5132 inline internal::KeyMatcher&lt;M&gt; Key(M inner_matcher) {
5133   return internal::KeyMatcher&lt;M&gt;(inner_matcher);
5134 }
5135 
5136 // Pair(first_matcher, second_matcher) matches a std::pair whose &#39;first&#39; field
5137 // matches first_matcher and whose &#39;second&#39; field matches second_matcher.  For
5138 // example, EXPECT_THAT(map_type, ElementsAre(Pair(Ge(5), &quot;foo&quot;))) can be used
5139 // to match a std::map&lt;int, string&gt; that contains exactly one element whose key
5140 // is &gt;= 5 and whose value equals &quot;foo&quot;.
5141 template &lt;typename FirstMatcher, typename SecondMatcher&gt;
5142 inline internal::PairMatcher&lt;FirstMatcher, SecondMatcher&gt;
5143 Pair(FirstMatcher first_matcher, SecondMatcher second_matcher) {
5144   return internal::PairMatcher&lt;FirstMatcher, SecondMatcher&gt;(
5145       first_matcher, second_matcher);
5146 }
5147 
5148 // Returns a predicate that is satisfied by anything that matches the
5149 // given matcher.
5150 template &lt;typename M&gt;
5151 inline internal::MatcherAsPredicate&lt;M&gt; Matches(M matcher) {
5152   return internal::MatcherAsPredicate&lt;M&gt;(matcher);
5153 }
5154 
5155 // Returns true iff the value matches the matcher.
5156 template &lt;typename T, typename M&gt;
5157 inline bool Value(const T&amp; value, M matcher) {
5158   return testing::Matches(matcher)(value);
5159 }
5160 
5161 // Matches the value against the given matcher and explains the match
5162 // result to listener.
5163 template &lt;typename T, typename M&gt;
5164 inline bool ExplainMatchResult(
5165     M matcher, const T&amp; value, MatchResultListener* listener) {
5166   return SafeMatcherCast&lt;const T&amp;&gt;(matcher).MatchAndExplain(value, listener);
5167 }
5168 
5169 // Returns a string representation of the given matcher.  Useful for description
5170 // strings of matchers defined using MATCHER_P* macros that accept matchers as
5171 // their arguments.  For example:
5172 //
5173 // MATCHER_P(XAndYThat, matcher,
5174 //           &quot;X that &quot; + DescribeMatcher&lt;int&gt;(matcher, negation) +
5175 //               &quot; and Y that &quot; + DescribeMatcher&lt;double&gt;(matcher, negation)) {
5176 //   return ExplainMatchResult(matcher, arg.x(), result_listener) &amp;&amp;
5177 //          ExplainMatchResult(matcher, arg.y(), result_listener);
5178 // }
5179 template &lt;typename T, typename M&gt;
5180 std::string DescribeMatcher(const M&amp; matcher, bool negation = false) {
5181   ::std::stringstream ss;
5182   Matcher&lt;T&gt; monomorphic_matcher = SafeMatcherCast&lt;T&gt;(matcher);
5183   if (negation) {
5184     monomorphic_matcher.DescribeNegationTo(&amp;ss);
5185   } else {
5186     monomorphic_matcher.DescribeTo(&amp;ss);
5187   }
5188   return ss.str();
5189 }
5190 
5191 #if GTEST_LANG_CXX11
5192 // Define variadic matcher versions. They are overloaded in
5193 // gmock-generated-matchers.h for the cases supported by pre C++11 compilers.
5194 template &lt;typename... Args&gt;
5195 internal::AllOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt; AllOf(
5196     const Args&amp;... matchers) {
5197   return internal::AllOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;(
5198       matchers...);
5199 }
5200 
5201 template &lt;typename... Args&gt;
5202 internal::AnyOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt; AnyOf(
5203     const Args&amp;... matchers) {
5204   return internal::AnyOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;(
5205       matchers...);
5206 }
5207 
5208 template &lt;typename... Args&gt;
5209 internal::ElementsAreMatcher&lt;tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;
5210 ElementsAre(const Args&amp;... matchers) {
5211   return internal::ElementsAreMatcher&lt;
5212       tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;(
5213       make_tuple(matchers...));
5214 }
5215 
5216 template &lt;typename... Args&gt;
5217 internal::UnorderedElementsAreMatcher&lt;
5218     tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;
5219 UnorderedElementsAre(const Args&amp;... matchers) {
5220   return internal::UnorderedElementsAreMatcher&lt;
5221       tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;(
5222       make_tuple(matchers...));
5223 }
5224 
5225 #endif  // GTEST_LANG_CXX11
5226 
5227 // AllArgs(m) is a synonym of m.  This is useful in
5228 //
5229 //   EXPECT_CALL(foo, Bar(_, _)).With(AllArgs(Eq()));
5230 //
5231 // which is easier to read than
5232 //
5233 //   EXPECT_CALL(foo, Bar(_, _)).With(Eq());
5234 template &lt;typename InnerMatcher&gt;
5235 inline InnerMatcher AllArgs(const InnerMatcher&amp; matcher) { return matcher; }
5236 
5237 // Returns a matcher that matches the value of an optional&lt;&gt; type variable.
5238 // The matcher implementation only uses &#39;!arg&#39; and requires that the optional&lt;&gt;
5239 // type has a &#39;value_type&#39; member type and that &#39;*arg&#39; is of type &#39;value_type&#39;
5240 // and is printable using &#39;PrintToString&#39;. It is compatible with
5241 // std::optional/std::experimental::optional.
5242 // Note that to compare an optional type variable against nullopt you should
5243 // use Eq(nullopt) and not Optional(Eq(nullopt)). The latter implies that the
5244 // optional value contains an optional itself.
5245 template &lt;typename ValueMatcher&gt;
5246 inline internal::OptionalMatcher&lt;ValueMatcher&gt; Optional(
5247     const ValueMatcher&amp; value_matcher) {
5248   return internal::OptionalMatcher&lt;ValueMatcher&gt;(value_matcher);
5249 }
5250 
5251 // Returns a matcher that matches the value of a absl::any type variable.
5252 template &lt;typename T&gt;
5253 PolymorphicMatcher&lt;internal::any_cast_matcher::AnyCastMatcher&lt;T&gt; &gt; AnyWith(
5254     const Matcher&lt;const T&amp;&gt;&amp; matcher) {
5255   return MakePolymorphicMatcher(
5256       internal::any_cast_matcher::AnyCastMatcher&lt;T&gt;(matcher));
5257 }
5258 
5259 // Returns a matcher that matches the value of a variant&lt;&gt; type variable.
5260 // The matcher implementation uses ADL to find the holds_alternative and get
5261 // functions.
5262 // It is compatible with std::variant.
5263 template &lt;typename T&gt;
5264 PolymorphicMatcher&lt;internal::variant_matcher::VariantMatcher&lt;T&gt; &gt; VariantWith(
5265     const Matcher&lt;const T&amp;&gt;&amp; matcher) {
5266   return MakePolymorphicMatcher(
5267       internal::variant_matcher::VariantMatcher&lt;T&gt;(matcher));
5268 }
5269 
5270 // These macros allow using matchers to check values in Google Test
5271 // tests.  ASSERT_THAT(value, matcher) and EXPECT_THAT(value, matcher)
5272 // succeed iff the value matches the matcher.  If the assertion fails,
5273 // the value and the description of the matcher will be printed.
5274 #define ASSERT_THAT(value, matcher) ASSERT_PRED_FORMAT1(\
5275     ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)
5276 #define EXPECT_THAT(value, matcher) EXPECT_PRED_FORMAT1(\
5277     ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)
5278 
5279 }  // namespace testing
5280 
5281 GTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251 5046
5282 
5283 // Include any custom callback matchers added by the local installation.
5284 // We must include this header at the end to make sure it can use the
5285 // declarations from this file.
5286 #include &quot;gmock/internal/custom/gmock-matchers.h&quot;
5287 
5288 #endif  // GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_
    </pre>
  </body>
</html>
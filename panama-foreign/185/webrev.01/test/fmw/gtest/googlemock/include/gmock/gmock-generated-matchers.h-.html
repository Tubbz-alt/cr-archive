<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/googlemock/include/gmock/gmock-generated-matchers.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // This file was GENERATED by command:
   2 //     pump.py gmock-generated-matchers.h.pump
   3 // DO NOT EDIT BY HAND!!!
   4 
   5 // Copyright 2008, Google Inc.
   6 // All rights reserved.
   7 //
   8 // Redistribution and use in source and binary forms, with or without
   9 // modification, are permitted provided that the following conditions are
  10 // met:
  11 //
  12 //     * Redistributions of source code must retain the above copyright
  13 // notice, this list of conditions and the following disclaimer.
  14 //     * Redistributions in binary form must reproduce the above
  15 // copyright notice, this list of conditions and the following disclaimer
  16 // in the documentation and/or other materials provided with the
  17 // distribution.
  18 //     * Neither the name of Google Inc. nor the names of its
  19 // contributors may be used to endorse or promote products derived from
  20 // this software without specific prior written permission.
  21 //
  22 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  23 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  24 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  25 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  26 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  27 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  28 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  29 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  30 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  32 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33 
  34 // Google Mock - a framework for writing C++ mock classes.
  35 //
  36 // This file implements some commonly used variadic matchers.
  37 
  38 // GOOGLETEST_CM0002 DO NOT DELETE
  39 
  40 #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_
  41 #define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_
  42 
  43 #include &lt;iterator&gt;
  44 #include &lt;sstream&gt;
  45 #include &lt;string&gt;
  46 #include &lt;vector&gt;
  47 #include &quot;gmock/gmock-matchers.h&quot;
  48 
  49 namespace testing {
  50 namespace internal {
  51 
  52 // The type of the i-th (0-based) field of Tuple.
  53 #define GMOCK_FIELD_TYPE_(Tuple, i) \
  54     typename ::testing::tuple_element&lt;i, Tuple&gt;::type
  55 
  56 // TupleFields&lt;Tuple, k0, ..., kn&gt; is for selecting fields from a
  57 // tuple of type Tuple.  It has two members:
  58 //
  59 //   type: a tuple type whose i-th field is the ki-th field of Tuple.
  60 //   GetSelectedFields(t): returns fields k0, ..., and kn of t as a tuple.
  61 //
  62 // For example, in class TupleFields&lt;tuple&lt;bool, char, int&gt;, 2, 0&gt;, we have:
  63 //
  64 //   type is tuple&lt;int, bool&gt;, and
  65 //   GetSelectedFields(make_tuple(true, &#39;a&#39;, 42)) is (42, true).
  66 
  67 template &lt;class Tuple, int k0 = -1, int k1 = -1, int k2 = -1, int k3 = -1,
  68     int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1, int k8 = -1,
  69     int k9 = -1&gt;
  70 class TupleFields;
  71 
  72 // This generic version is used when there are 10 selectors.
  73 template &lt;class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,
  74     int k7, int k8, int k9&gt;
  75 class TupleFields {
  76  public:
  77   typedef ::testing::tuple&lt;GMOCK_FIELD_TYPE_(Tuple, k0),
  78       GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),
  79       GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),
  80       GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),
  81       GMOCK_FIELD_TYPE_(Tuple, k7), GMOCK_FIELD_TYPE_(Tuple, k8),
  82       GMOCK_FIELD_TYPE_(Tuple, k9)&gt; type;
  83   static type GetSelectedFields(const Tuple&amp; t) {
  84     return type(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t), get&lt;k3&gt;(t), get&lt;k4&gt;(t),
  85         get&lt;k5&gt;(t), get&lt;k6&gt;(t), get&lt;k7&gt;(t), get&lt;k8&gt;(t), get&lt;k9&gt;(t));
  86   }
  87 };
  88 
  89 // The following specialization is used for 0 ~ 9 selectors.
  90 
  91 template &lt;class Tuple&gt;
  92 class TupleFields&lt;Tuple, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1&gt; {
  93  public:
  94   typedef ::testing::tuple&lt;&gt; type;
  95   static type GetSelectedFields(const Tuple&amp; /* t */) {
  96     return type();
  97   }
  98 };
  99 
 100 template &lt;class Tuple, int k0&gt;
 101 class TupleFields&lt;Tuple, k0, -1, -1, -1, -1, -1, -1, -1, -1, -1&gt; {
 102  public:
 103   typedef ::testing::tuple&lt;GMOCK_FIELD_TYPE_(Tuple, k0)&gt; type;
 104   static type GetSelectedFields(const Tuple&amp; t) {
 105     return type(get&lt;k0&gt;(t));
 106   }
 107 };
 108 
 109 template &lt;class Tuple, int k0, int k1&gt;
 110 class TupleFields&lt;Tuple, k0, k1, -1, -1, -1, -1, -1, -1, -1, -1&gt; {
 111  public:
 112   typedef ::testing::tuple&lt;GMOCK_FIELD_TYPE_(Tuple, k0),
 113       GMOCK_FIELD_TYPE_(Tuple, k1)&gt; type;
 114   static type GetSelectedFields(const Tuple&amp; t) {
 115     return type(get&lt;k0&gt;(t), get&lt;k1&gt;(t));
 116   }
 117 };
 118 
 119 template &lt;class Tuple, int k0, int k1, int k2&gt;
 120 class TupleFields&lt;Tuple, k0, k1, k2, -1, -1, -1, -1, -1, -1, -1&gt; {
 121  public:
 122   typedef ::testing::tuple&lt;GMOCK_FIELD_TYPE_(Tuple, k0),
 123       GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2)&gt; type;
 124   static type GetSelectedFields(const Tuple&amp; t) {
 125     return type(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t));
 126   }
 127 };
 128 
 129 template &lt;class Tuple, int k0, int k1, int k2, int k3&gt;
 130 class TupleFields&lt;Tuple, k0, k1, k2, k3, -1, -1, -1, -1, -1, -1&gt; {
 131  public:
 132   typedef ::testing::tuple&lt;GMOCK_FIELD_TYPE_(Tuple, k0),
 133       GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),
 134       GMOCK_FIELD_TYPE_(Tuple, k3)&gt; type;
 135   static type GetSelectedFields(const Tuple&amp; t) {
 136     return type(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t), get&lt;k3&gt;(t));
 137   }
 138 };
 139 
 140 template &lt;class Tuple, int k0, int k1, int k2, int k3, int k4&gt;
 141 class TupleFields&lt;Tuple, k0, k1, k2, k3, k4, -1, -1, -1, -1, -1&gt; {
 142  public:
 143   typedef ::testing::tuple&lt;GMOCK_FIELD_TYPE_(Tuple, k0),
 144       GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),
 145       GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4)&gt; type;
 146   static type GetSelectedFields(const Tuple&amp; t) {
 147     return type(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t), get&lt;k3&gt;(t), get&lt;k4&gt;(t));
 148   }
 149 };
 150 
 151 template &lt;class Tuple, int k0, int k1, int k2, int k3, int k4, int k5&gt;
 152 class TupleFields&lt;Tuple, k0, k1, k2, k3, k4, k5, -1, -1, -1, -1&gt; {
 153  public:
 154   typedef ::testing::tuple&lt;GMOCK_FIELD_TYPE_(Tuple, k0),
 155       GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),
 156       GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),
 157       GMOCK_FIELD_TYPE_(Tuple, k5)&gt; type;
 158   static type GetSelectedFields(const Tuple&amp; t) {
 159     return type(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t), get&lt;k3&gt;(t), get&lt;k4&gt;(t),
 160         get&lt;k5&gt;(t));
 161   }
 162 };
 163 
 164 template &lt;class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6&gt;
 165 class TupleFields&lt;Tuple, k0, k1, k2, k3, k4, k5, k6, -1, -1, -1&gt; {
 166  public:
 167   typedef ::testing::tuple&lt;GMOCK_FIELD_TYPE_(Tuple, k0),
 168       GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),
 169       GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),
 170       GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6)&gt; type;
 171   static type GetSelectedFields(const Tuple&amp; t) {
 172     return type(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t), get&lt;k3&gt;(t), get&lt;k4&gt;(t),
 173         get&lt;k5&gt;(t), get&lt;k6&gt;(t));
 174   }
 175 };
 176 
 177 template &lt;class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,
 178     int k7&gt;
 179 class TupleFields&lt;Tuple, k0, k1, k2, k3, k4, k5, k6, k7, -1, -1&gt; {
 180  public:
 181   typedef ::testing::tuple&lt;GMOCK_FIELD_TYPE_(Tuple, k0),
 182       GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),
 183       GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),
 184       GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),
 185       GMOCK_FIELD_TYPE_(Tuple, k7)&gt; type;
 186   static type GetSelectedFields(const Tuple&amp; t) {
 187     return type(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t), get&lt;k3&gt;(t), get&lt;k4&gt;(t),
 188         get&lt;k5&gt;(t), get&lt;k6&gt;(t), get&lt;k7&gt;(t));
 189   }
 190 };
 191 
 192 template &lt;class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,
 193     int k7, int k8&gt;
 194 class TupleFields&lt;Tuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, -1&gt; {
 195  public:
 196   typedef ::testing::tuple&lt;GMOCK_FIELD_TYPE_(Tuple, k0),
 197       GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),
 198       GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),
 199       GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),
 200       GMOCK_FIELD_TYPE_(Tuple, k7), GMOCK_FIELD_TYPE_(Tuple, k8)&gt; type;
 201   static type GetSelectedFields(const Tuple&amp; t) {
 202     return type(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t), get&lt;k3&gt;(t), get&lt;k4&gt;(t),
 203         get&lt;k5&gt;(t), get&lt;k6&gt;(t), get&lt;k7&gt;(t), get&lt;k8&gt;(t));
 204   }
 205 };
 206 
 207 #undef GMOCK_FIELD_TYPE_
 208 
 209 // Implements the Args() matcher.
 210 template &lt;class ArgsTuple, int k0 = -1, int k1 = -1, int k2 = -1, int k3 = -1,
 211     int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1, int k8 = -1,
 212     int k9 = -1&gt;
 213 class ArgsMatcherImpl : public MatcherInterface&lt;ArgsTuple&gt; {
 214  public:
 215   // ArgsTuple may have top-level const or reference modifiers.
 216   typedef GTEST_REMOVE_REFERENCE_AND_CONST_(ArgsTuple) RawArgsTuple;
 217   typedef typename internal::TupleFields&lt;RawArgsTuple, k0, k1, k2, k3, k4, k5,
 218       k6, k7, k8, k9&gt;::type SelectedArgs;
 219   typedef Matcher&lt;const SelectedArgs&amp;&gt; MonomorphicInnerMatcher;
 220 
 221   template &lt;typename InnerMatcher&gt;
 222   explicit ArgsMatcherImpl(const InnerMatcher&amp; inner_matcher)
 223       : inner_matcher_(SafeMatcherCast&lt;const SelectedArgs&amp;&gt;(inner_matcher)) {}
 224 
 225   virtual bool MatchAndExplain(ArgsTuple args,
 226                                MatchResultListener* listener) const {
 227     const SelectedArgs&amp; selected_args = GetSelectedArgs(args);
 228     if (!listener-&gt;IsInterested())
 229       return inner_matcher_.Matches(selected_args);
 230 
 231     PrintIndices(listener-&gt;stream());
 232     *listener &lt;&lt; &quot;are &quot; &lt;&lt; PrintToString(selected_args);
 233 
 234     StringMatchResultListener inner_listener;
 235     const bool match = inner_matcher_.MatchAndExplain(selected_args,
 236                                                       &amp;inner_listener);
 237     PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
 238     return match;
 239   }
 240 
 241   virtual void DescribeTo(::std::ostream* os) const {
 242     *os &lt;&lt; &quot;are a tuple &quot;;
 243     PrintIndices(os);
 244     inner_matcher_.DescribeTo(os);
 245   }
 246 
 247   virtual void DescribeNegationTo(::std::ostream* os) const {
 248     *os &lt;&lt; &quot;are a tuple &quot;;
 249     PrintIndices(os);
 250     inner_matcher_.DescribeNegationTo(os);
 251   }
 252 
 253  private:
 254   static SelectedArgs GetSelectedArgs(ArgsTuple args) {
 255     return TupleFields&lt;RawArgsTuple, k0, k1, k2, k3, k4, k5, k6, k7, k8,
 256         k9&gt;::GetSelectedFields(args);
 257   }
 258 
 259   // Prints the indices of the selected fields.
 260   static void PrintIndices(::std::ostream* os) {
 261     *os &lt;&lt; &quot;whose fields (&quot;;
 262     const int indices[10] = { k0, k1, k2, k3, k4, k5, k6, k7, k8, k9 };
 263     for (int i = 0; i &lt; 10; i++) {
 264       if (indices[i] &lt; 0)
 265         break;
 266 
 267       if (i &gt;= 1)
 268         *os &lt;&lt; &quot;, &quot;;
 269 
 270       *os &lt;&lt; &quot;#&quot; &lt;&lt; indices[i];
 271     }
 272     *os &lt;&lt; &quot;) &quot;;
 273   }
 274 
 275   const MonomorphicInnerMatcher inner_matcher_;
 276 
 277   GTEST_DISALLOW_ASSIGN_(ArgsMatcherImpl);
 278 };
 279 
 280 template &lt;class InnerMatcher, int k0 = -1, int k1 = -1, int k2 = -1,
 281     int k3 = -1, int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1,
 282     int k8 = -1, int k9 = -1&gt;
 283 class ArgsMatcher {
 284  public:
 285   explicit ArgsMatcher(const InnerMatcher&amp; inner_matcher)
 286       : inner_matcher_(inner_matcher) {}
 287 
 288   template &lt;typename ArgsTuple&gt;
 289   operator Matcher&lt;ArgsTuple&gt;() const {
 290     return MakeMatcher(new ArgsMatcherImpl&lt;ArgsTuple, k0, k1, k2, k3, k4, k5,
 291         k6, k7, k8, k9&gt;(inner_matcher_));
 292   }
 293 
 294  private:
 295   const InnerMatcher inner_matcher_;
 296 
 297   GTEST_DISALLOW_ASSIGN_(ArgsMatcher);
 298 };
 299 
 300 // A set of metafunctions for computing the result type of AllOf.
 301 // AllOf(m1, ..., mN) returns
 302 // AllOfResultN&lt;decltype(m1), ..., decltype(mN)&gt;::type.
 303 
 304 // Although AllOf isn&#39;t defined for one argument, AllOfResult1 is defined
 305 // to simplify the implementation.
 306 template &lt;typename M1&gt;
 307 struct AllOfResult1 {
 308   typedef M1 type;
 309 };
 310 
 311 template &lt;typename M1, typename M2&gt;
 312 struct AllOfResult2 {
 313   typedef BothOfMatcher&lt;
 314       typename AllOfResult1&lt;M1&gt;::type,
 315       typename AllOfResult1&lt;M2&gt;::type
 316   &gt; type;
 317 };
 318 
 319 template &lt;typename M1, typename M2, typename M3&gt;
 320 struct AllOfResult3 {
 321   typedef BothOfMatcher&lt;
 322       typename AllOfResult1&lt;M1&gt;::type,
 323       typename AllOfResult2&lt;M2, M3&gt;::type
 324   &gt; type;
 325 };
 326 
 327 template &lt;typename M1, typename M2, typename M3, typename M4&gt;
 328 struct AllOfResult4 {
 329   typedef BothOfMatcher&lt;
 330       typename AllOfResult2&lt;M1, M2&gt;::type,
 331       typename AllOfResult2&lt;M3, M4&gt;::type
 332   &gt; type;
 333 };
 334 
 335 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5&gt;
 336 struct AllOfResult5 {
 337   typedef BothOfMatcher&lt;
 338       typename AllOfResult2&lt;M1, M2&gt;::type,
 339       typename AllOfResult3&lt;M3, M4, M5&gt;::type
 340   &gt; type;
 341 };
 342 
 343 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
 344     typename M6&gt;
 345 struct AllOfResult6 {
 346   typedef BothOfMatcher&lt;
 347       typename AllOfResult3&lt;M1, M2, M3&gt;::type,
 348       typename AllOfResult3&lt;M4, M5, M6&gt;::type
 349   &gt; type;
 350 };
 351 
 352 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
 353     typename M6, typename M7&gt;
 354 struct AllOfResult7 {
 355   typedef BothOfMatcher&lt;
 356       typename AllOfResult3&lt;M1, M2, M3&gt;::type,
 357       typename AllOfResult4&lt;M4, M5, M6, M7&gt;::type
 358   &gt; type;
 359 };
 360 
 361 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
 362     typename M6, typename M7, typename M8&gt;
 363 struct AllOfResult8 {
 364   typedef BothOfMatcher&lt;
 365       typename AllOfResult4&lt;M1, M2, M3, M4&gt;::type,
 366       typename AllOfResult4&lt;M5, M6, M7, M8&gt;::type
 367   &gt; type;
 368 };
 369 
 370 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
 371     typename M6, typename M7, typename M8, typename M9&gt;
 372 struct AllOfResult9 {
 373   typedef BothOfMatcher&lt;
 374       typename AllOfResult4&lt;M1, M2, M3, M4&gt;::type,
 375       typename AllOfResult5&lt;M5, M6, M7, M8, M9&gt;::type
 376   &gt; type;
 377 };
 378 
 379 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
 380     typename M6, typename M7, typename M8, typename M9, typename M10&gt;
 381 struct AllOfResult10 {
 382   typedef BothOfMatcher&lt;
 383       typename AllOfResult5&lt;M1, M2, M3, M4, M5&gt;::type,
 384       typename AllOfResult5&lt;M6, M7, M8, M9, M10&gt;::type
 385   &gt; type;
 386 };
 387 
 388 // A set of metafunctions for computing the result type of AnyOf.
 389 // AnyOf(m1, ..., mN) returns
 390 // AnyOfResultN&lt;decltype(m1), ..., decltype(mN)&gt;::type.
 391 
 392 // Although AnyOf isn&#39;t defined for one argument, AnyOfResult1 is defined
 393 // to simplify the implementation.
 394 template &lt;typename M1&gt;
 395 struct AnyOfResult1 {
 396   typedef M1 type;
 397 };
 398 
 399 template &lt;typename M1, typename M2&gt;
 400 struct AnyOfResult2 {
 401   typedef EitherOfMatcher&lt;
 402       typename AnyOfResult1&lt;M1&gt;::type,
 403       typename AnyOfResult1&lt;M2&gt;::type
 404   &gt; type;
 405 };
 406 
 407 template &lt;typename M1, typename M2, typename M3&gt;
 408 struct AnyOfResult3 {
 409   typedef EitherOfMatcher&lt;
 410       typename AnyOfResult1&lt;M1&gt;::type,
 411       typename AnyOfResult2&lt;M2, M3&gt;::type
 412   &gt; type;
 413 };
 414 
 415 template &lt;typename M1, typename M2, typename M3, typename M4&gt;
 416 struct AnyOfResult4 {
 417   typedef EitherOfMatcher&lt;
 418       typename AnyOfResult2&lt;M1, M2&gt;::type,
 419       typename AnyOfResult2&lt;M3, M4&gt;::type
 420   &gt; type;
 421 };
 422 
 423 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5&gt;
 424 struct AnyOfResult5 {
 425   typedef EitherOfMatcher&lt;
 426       typename AnyOfResult2&lt;M1, M2&gt;::type,
 427       typename AnyOfResult3&lt;M3, M4, M5&gt;::type
 428   &gt; type;
 429 };
 430 
 431 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
 432     typename M6&gt;
 433 struct AnyOfResult6 {
 434   typedef EitherOfMatcher&lt;
 435       typename AnyOfResult3&lt;M1, M2, M3&gt;::type,
 436       typename AnyOfResult3&lt;M4, M5, M6&gt;::type
 437   &gt; type;
 438 };
 439 
 440 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
 441     typename M6, typename M7&gt;
 442 struct AnyOfResult7 {
 443   typedef EitherOfMatcher&lt;
 444       typename AnyOfResult3&lt;M1, M2, M3&gt;::type,
 445       typename AnyOfResult4&lt;M4, M5, M6, M7&gt;::type
 446   &gt; type;
 447 };
 448 
 449 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
 450     typename M6, typename M7, typename M8&gt;
 451 struct AnyOfResult8 {
 452   typedef EitherOfMatcher&lt;
 453       typename AnyOfResult4&lt;M1, M2, M3, M4&gt;::type,
 454       typename AnyOfResult4&lt;M5, M6, M7, M8&gt;::type
 455   &gt; type;
 456 };
 457 
 458 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
 459     typename M6, typename M7, typename M8, typename M9&gt;
 460 struct AnyOfResult9 {
 461   typedef EitherOfMatcher&lt;
 462       typename AnyOfResult4&lt;M1, M2, M3, M4&gt;::type,
 463       typename AnyOfResult5&lt;M5, M6, M7, M8, M9&gt;::type
 464   &gt; type;
 465 };
 466 
 467 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
 468     typename M6, typename M7, typename M8, typename M9, typename M10&gt;
 469 struct AnyOfResult10 {
 470   typedef EitherOfMatcher&lt;
 471       typename AnyOfResult5&lt;M1, M2, M3, M4, M5&gt;::type,
 472       typename AnyOfResult5&lt;M6, M7, M8, M9, M10&gt;::type
 473   &gt; type;
 474 };
 475 
 476 }  // namespace internal
 477 
 478 // Args&lt;N1, N2, ..., Nk&gt;(a_matcher) matches a tuple if the selected
 479 // fields of it matches a_matcher.  C++ doesn&#39;t support default
 480 // arguments for function templates, so we have to overload it.
 481 template &lt;typename InnerMatcher&gt;
 482 inline internal::ArgsMatcher&lt;InnerMatcher&gt;
 483 Args(const InnerMatcher&amp; matcher) {
 484   return internal::ArgsMatcher&lt;InnerMatcher&gt;(matcher);
 485 }
 486 
 487 template &lt;int k1, typename InnerMatcher&gt;
 488 inline internal::ArgsMatcher&lt;InnerMatcher, k1&gt;
 489 Args(const InnerMatcher&amp; matcher) {
 490   return internal::ArgsMatcher&lt;InnerMatcher, k1&gt;(matcher);
 491 }
 492 
 493 template &lt;int k1, int k2, typename InnerMatcher&gt;
 494 inline internal::ArgsMatcher&lt;InnerMatcher, k1, k2&gt;
 495 Args(const InnerMatcher&amp; matcher) {
 496   return internal::ArgsMatcher&lt;InnerMatcher, k1, k2&gt;(matcher);
 497 }
 498 
 499 template &lt;int k1, int k2, int k3, typename InnerMatcher&gt;
 500 inline internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3&gt;
 501 Args(const InnerMatcher&amp; matcher) {
 502   return internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3&gt;(matcher);
 503 }
 504 
 505 template &lt;int k1, int k2, int k3, int k4, typename InnerMatcher&gt;
 506 inline internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4&gt;
 507 Args(const InnerMatcher&amp; matcher) {
 508   return internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4&gt;(matcher);
 509 }
 510 
 511 template &lt;int k1, int k2, int k3, int k4, int k5, typename InnerMatcher&gt;
 512 inline internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5&gt;
 513 Args(const InnerMatcher&amp; matcher) {
 514   return internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5&gt;(matcher);
 515 }
 516 
 517 template &lt;int k1, int k2, int k3, int k4, int k5, int k6, typename InnerMatcher&gt;
 518 inline internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6&gt;
 519 Args(const InnerMatcher&amp; matcher) {
 520   return internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6&gt;(matcher);
 521 }
 522 
 523 template &lt;int k1, int k2, int k3, int k4, int k5, int k6, int k7,
 524     typename InnerMatcher&gt;
 525 inline internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6, k7&gt;
 526 Args(const InnerMatcher&amp; matcher) {
 527   return internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6,
 528       k7&gt;(matcher);
 529 }
 530 
 531 template &lt;int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,
 532     typename InnerMatcher&gt;
 533 inline internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8&gt;
 534 Args(const InnerMatcher&amp; matcher) {
 535   return internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6, k7,
 536       k8&gt;(matcher);
 537 }
 538 
 539 template &lt;int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,
 540     int k9, typename InnerMatcher&gt;
 541 inline internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8, k9&gt;
 542 Args(const InnerMatcher&amp; matcher) {
 543   return internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8,
 544       k9&gt;(matcher);
 545 }
 546 
 547 template &lt;int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,
 548     int k9, int k10, typename InnerMatcher&gt;
 549 inline internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8, k9,
 550     k10&gt;
 551 Args(const InnerMatcher&amp; matcher) {
 552   return internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8,
 553       k9, k10&gt;(matcher);
 554 }
 555 
 556 // ElementsAre(e_1, e_2, ... e_n) matches an STL-style container with
 557 // n elements, where the i-th element in the container must
 558 // match the i-th argument in the list.  Each argument of
 559 // ElementsAre() can be either a value or a matcher.  We support up to
 560 // 10 arguments.
 561 //
 562 // The use of DecayArray in the implementation allows ElementsAre()
 563 // to accept string literals, whose type is const char[N], but we
 564 // want to treat them as const char*.
 565 //
 566 // NOTE: Since ElementsAre() cares about the order of the elements, it
 567 // must not be used with containers whose elements&#39;s order is
 568 // undefined (e.g. hash_map).
 569 
 570 inline internal::ElementsAreMatcher&lt;
 571     ::testing::tuple&lt;&gt; &gt;
 572 ElementsAre() {
 573   typedef ::testing::tuple&lt;&gt; Args;
 574   return internal::ElementsAreMatcher&lt;Args&gt;(Args());
 575 }
 576 
 577 template &lt;typename T1&gt;
 578 inline internal::ElementsAreMatcher&lt;
 579     ::testing::tuple&lt;
 580         typename internal::DecayArray&lt;T1&gt;::type&gt; &gt;
 581 ElementsAre(const T1&amp; e1) {
 582   typedef ::testing::tuple&lt;
 583       typename internal::DecayArray&lt;T1&gt;::type&gt; Args;
 584   return internal::ElementsAreMatcher&lt;Args&gt;(Args(e1));
 585 }
 586 
 587 template &lt;typename T1, typename T2&gt;
 588 inline internal::ElementsAreMatcher&lt;
 589     ::testing::tuple&lt;
 590         typename internal::DecayArray&lt;T1&gt;::type,
 591         typename internal::DecayArray&lt;T2&gt;::type&gt; &gt;
 592 ElementsAre(const T1&amp; e1, const T2&amp; e2) {
 593   typedef ::testing::tuple&lt;
 594       typename internal::DecayArray&lt;T1&gt;::type,
 595       typename internal::DecayArray&lt;T2&gt;::type&gt; Args;
 596   return internal::ElementsAreMatcher&lt;Args&gt;(Args(e1, e2));
 597 }
 598 
 599 template &lt;typename T1, typename T2, typename T3&gt;
 600 inline internal::ElementsAreMatcher&lt;
 601     ::testing::tuple&lt;
 602         typename internal::DecayArray&lt;T1&gt;::type,
 603         typename internal::DecayArray&lt;T2&gt;::type,
 604         typename internal::DecayArray&lt;T3&gt;::type&gt; &gt;
 605 ElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3) {
 606   typedef ::testing::tuple&lt;
 607       typename internal::DecayArray&lt;T1&gt;::type,
 608       typename internal::DecayArray&lt;T2&gt;::type,
 609       typename internal::DecayArray&lt;T3&gt;::type&gt; Args;
 610   return internal::ElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3));
 611 }
 612 
 613 template &lt;typename T1, typename T2, typename T3, typename T4&gt;
 614 inline internal::ElementsAreMatcher&lt;
 615     ::testing::tuple&lt;
 616         typename internal::DecayArray&lt;T1&gt;::type,
 617         typename internal::DecayArray&lt;T2&gt;::type,
 618         typename internal::DecayArray&lt;T3&gt;::type,
 619         typename internal::DecayArray&lt;T4&gt;::type&gt; &gt;
 620 ElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3, const T4&amp; e4) {
 621   typedef ::testing::tuple&lt;
 622       typename internal::DecayArray&lt;T1&gt;::type,
 623       typename internal::DecayArray&lt;T2&gt;::type,
 624       typename internal::DecayArray&lt;T3&gt;::type,
 625       typename internal::DecayArray&lt;T4&gt;::type&gt; Args;
 626   return internal::ElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3, e4));
 627 }
 628 
 629 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5&gt;
 630 inline internal::ElementsAreMatcher&lt;
 631     ::testing::tuple&lt;
 632         typename internal::DecayArray&lt;T1&gt;::type,
 633         typename internal::DecayArray&lt;T2&gt;::type,
 634         typename internal::DecayArray&lt;T3&gt;::type,
 635         typename internal::DecayArray&lt;T4&gt;::type,
 636         typename internal::DecayArray&lt;T5&gt;::type&gt; &gt;
 637 ElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3, const T4&amp; e4,
 638     const T5&amp; e5) {
 639   typedef ::testing::tuple&lt;
 640       typename internal::DecayArray&lt;T1&gt;::type,
 641       typename internal::DecayArray&lt;T2&gt;::type,
 642       typename internal::DecayArray&lt;T3&gt;::type,
 643       typename internal::DecayArray&lt;T4&gt;::type,
 644       typename internal::DecayArray&lt;T5&gt;::type&gt; Args;
 645   return internal::ElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3, e4, e5));
 646 }
 647 
 648 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
 649     typename T6&gt;
 650 inline internal::ElementsAreMatcher&lt;
 651     ::testing::tuple&lt;
 652         typename internal::DecayArray&lt;T1&gt;::type,
 653         typename internal::DecayArray&lt;T2&gt;::type,
 654         typename internal::DecayArray&lt;T3&gt;::type,
 655         typename internal::DecayArray&lt;T4&gt;::type,
 656         typename internal::DecayArray&lt;T5&gt;::type,
 657         typename internal::DecayArray&lt;T6&gt;::type&gt; &gt;
 658 ElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3, const T4&amp; e4,
 659     const T5&amp; e5, const T6&amp; e6) {
 660   typedef ::testing::tuple&lt;
 661       typename internal::DecayArray&lt;T1&gt;::type,
 662       typename internal::DecayArray&lt;T2&gt;::type,
 663       typename internal::DecayArray&lt;T3&gt;::type,
 664       typename internal::DecayArray&lt;T4&gt;::type,
 665       typename internal::DecayArray&lt;T5&gt;::type,
 666       typename internal::DecayArray&lt;T6&gt;::type&gt; Args;
 667   return internal::ElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3, e4, e5, e6));
 668 }
 669 
 670 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
 671     typename T6, typename T7&gt;
 672 inline internal::ElementsAreMatcher&lt;
 673     ::testing::tuple&lt;
 674         typename internal::DecayArray&lt;T1&gt;::type,
 675         typename internal::DecayArray&lt;T2&gt;::type,
 676         typename internal::DecayArray&lt;T3&gt;::type,
 677         typename internal::DecayArray&lt;T4&gt;::type,
 678         typename internal::DecayArray&lt;T5&gt;::type,
 679         typename internal::DecayArray&lt;T6&gt;::type,
 680         typename internal::DecayArray&lt;T7&gt;::type&gt; &gt;
 681 ElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3, const T4&amp; e4,
 682     const T5&amp; e5, const T6&amp; e6, const T7&amp; e7) {
 683   typedef ::testing::tuple&lt;
 684       typename internal::DecayArray&lt;T1&gt;::type,
 685       typename internal::DecayArray&lt;T2&gt;::type,
 686       typename internal::DecayArray&lt;T3&gt;::type,
 687       typename internal::DecayArray&lt;T4&gt;::type,
 688       typename internal::DecayArray&lt;T5&gt;::type,
 689       typename internal::DecayArray&lt;T6&gt;::type,
 690       typename internal::DecayArray&lt;T7&gt;::type&gt; Args;
 691   return internal::ElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3, e4, e5, e6, e7));
 692 }
 693 
 694 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
 695     typename T6, typename T7, typename T8&gt;
 696 inline internal::ElementsAreMatcher&lt;
 697     ::testing::tuple&lt;
 698         typename internal::DecayArray&lt;T1&gt;::type,
 699         typename internal::DecayArray&lt;T2&gt;::type,
 700         typename internal::DecayArray&lt;T3&gt;::type,
 701         typename internal::DecayArray&lt;T4&gt;::type,
 702         typename internal::DecayArray&lt;T5&gt;::type,
 703         typename internal::DecayArray&lt;T6&gt;::type,
 704         typename internal::DecayArray&lt;T7&gt;::type,
 705         typename internal::DecayArray&lt;T8&gt;::type&gt; &gt;
 706 ElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3, const T4&amp; e4,
 707     const T5&amp; e5, const T6&amp; e6, const T7&amp; e7, const T8&amp; e8) {
 708   typedef ::testing::tuple&lt;
 709       typename internal::DecayArray&lt;T1&gt;::type,
 710       typename internal::DecayArray&lt;T2&gt;::type,
 711       typename internal::DecayArray&lt;T3&gt;::type,
 712       typename internal::DecayArray&lt;T4&gt;::type,
 713       typename internal::DecayArray&lt;T5&gt;::type,
 714       typename internal::DecayArray&lt;T6&gt;::type,
 715       typename internal::DecayArray&lt;T7&gt;::type,
 716       typename internal::DecayArray&lt;T8&gt;::type&gt; Args;
 717   return internal::ElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3, e4, e5, e6, e7,
 718       e8));
 719 }
 720 
 721 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
 722     typename T6, typename T7, typename T8, typename T9&gt;
 723 inline internal::ElementsAreMatcher&lt;
 724     ::testing::tuple&lt;
 725         typename internal::DecayArray&lt;T1&gt;::type,
 726         typename internal::DecayArray&lt;T2&gt;::type,
 727         typename internal::DecayArray&lt;T3&gt;::type,
 728         typename internal::DecayArray&lt;T4&gt;::type,
 729         typename internal::DecayArray&lt;T5&gt;::type,
 730         typename internal::DecayArray&lt;T6&gt;::type,
 731         typename internal::DecayArray&lt;T7&gt;::type,
 732         typename internal::DecayArray&lt;T8&gt;::type,
 733         typename internal::DecayArray&lt;T9&gt;::type&gt; &gt;
 734 ElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3, const T4&amp; e4,
 735     const T5&amp; e5, const T6&amp; e6, const T7&amp; e7, const T8&amp; e8, const T9&amp; e9) {
 736   typedef ::testing::tuple&lt;
 737       typename internal::DecayArray&lt;T1&gt;::type,
 738       typename internal::DecayArray&lt;T2&gt;::type,
 739       typename internal::DecayArray&lt;T3&gt;::type,
 740       typename internal::DecayArray&lt;T4&gt;::type,
 741       typename internal::DecayArray&lt;T5&gt;::type,
 742       typename internal::DecayArray&lt;T6&gt;::type,
 743       typename internal::DecayArray&lt;T7&gt;::type,
 744       typename internal::DecayArray&lt;T8&gt;::type,
 745       typename internal::DecayArray&lt;T9&gt;::type&gt; Args;
 746   return internal::ElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3, e4, e5, e6, e7,
 747       e8, e9));
 748 }
 749 
 750 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
 751     typename T6, typename T7, typename T8, typename T9, typename T10&gt;
 752 inline internal::ElementsAreMatcher&lt;
 753     ::testing::tuple&lt;
 754         typename internal::DecayArray&lt;T1&gt;::type,
 755         typename internal::DecayArray&lt;T2&gt;::type,
 756         typename internal::DecayArray&lt;T3&gt;::type,
 757         typename internal::DecayArray&lt;T4&gt;::type,
 758         typename internal::DecayArray&lt;T5&gt;::type,
 759         typename internal::DecayArray&lt;T6&gt;::type,
 760         typename internal::DecayArray&lt;T7&gt;::type,
 761         typename internal::DecayArray&lt;T8&gt;::type,
 762         typename internal::DecayArray&lt;T9&gt;::type,
 763         typename internal::DecayArray&lt;T10&gt;::type&gt; &gt;
 764 ElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3, const T4&amp; e4,
 765     const T5&amp; e5, const T6&amp; e6, const T7&amp; e7, const T8&amp; e8, const T9&amp; e9,
 766     const T10&amp; e10) {
 767   typedef ::testing::tuple&lt;
 768       typename internal::DecayArray&lt;T1&gt;::type,
 769       typename internal::DecayArray&lt;T2&gt;::type,
 770       typename internal::DecayArray&lt;T3&gt;::type,
 771       typename internal::DecayArray&lt;T4&gt;::type,
 772       typename internal::DecayArray&lt;T5&gt;::type,
 773       typename internal::DecayArray&lt;T6&gt;::type,
 774       typename internal::DecayArray&lt;T7&gt;::type,
 775       typename internal::DecayArray&lt;T8&gt;::type,
 776       typename internal::DecayArray&lt;T9&gt;::type,
 777       typename internal::DecayArray&lt;T10&gt;::type&gt; Args;
 778   return internal::ElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3, e4, e5, e6, e7,
 779       e8, e9, e10));
 780 }
 781 
 782 // UnorderedElementsAre(e_1, e_2, ..., e_n) is an ElementsAre extension
 783 // that matches n elements in any order.  We support up to n=10 arguments.
 784 //
 785 // If you have &gt;10 elements, consider UnorderedElementsAreArray() or
 786 // UnorderedPointwise() instead.
 787 
 788 inline internal::UnorderedElementsAreMatcher&lt;
 789     ::testing::tuple&lt;&gt; &gt;
 790 UnorderedElementsAre() {
 791   typedef ::testing::tuple&lt;&gt; Args;
 792   return internal::UnorderedElementsAreMatcher&lt;Args&gt;(Args());
 793 }
 794 
 795 template &lt;typename T1&gt;
 796 inline internal::UnorderedElementsAreMatcher&lt;
 797     ::testing::tuple&lt;
 798         typename internal::DecayArray&lt;T1&gt;::type&gt; &gt;
 799 UnorderedElementsAre(const T1&amp; e1) {
 800   typedef ::testing::tuple&lt;
 801       typename internal::DecayArray&lt;T1&gt;::type&gt; Args;
 802   return internal::UnorderedElementsAreMatcher&lt;Args&gt;(Args(e1));
 803 }
 804 
 805 template &lt;typename T1, typename T2&gt;
 806 inline internal::UnorderedElementsAreMatcher&lt;
 807     ::testing::tuple&lt;
 808         typename internal::DecayArray&lt;T1&gt;::type,
 809         typename internal::DecayArray&lt;T2&gt;::type&gt; &gt;
 810 UnorderedElementsAre(const T1&amp; e1, const T2&amp; e2) {
 811   typedef ::testing::tuple&lt;
 812       typename internal::DecayArray&lt;T1&gt;::type,
 813       typename internal::DecayArray&lt;T2&gt;::type&gt; Args;
 814   return internal::UnorderedElementsAreMatcher&lt;Args&gt;(Args(e1, e2));
 815 }
 816 
 817 template &lt;typename T1, typename T2, typename T3&gt;
 818 inline internal::UnorderedElementsAreMatcher&lt;
 819     ::testing::tuple&lt;
 820         typename internal::DecayArray&lt;T1&gt;::type,
 821         typename internal::DecayArray&lt;T2&gt;::type,
 822         typename internal::DecayArray&lt;T3&gt;::type&gt; &gt;
 823 UnorderedElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3) {
 824   typedef ::testing::tuple&lt;
 825       typename internal::DecayArray&lt;T1&gt;::type,
 826       typename internal::DecayArray&lt;T2&gt;::type,
 827       typename internal::DecayArray&lt;T3&gt;::type&gt; Args;
 828   return internal::UnorderedElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3));
 829 }
 830 
 831 template &lt;typename T1, typename T2, typename T3, typename T4&gt;
 832 inline internal::UnorderedElementsAreMatcher&lt;
 833     ::testing::tuple&lt;
 834         typename internal::DecayArray&lt;T1&gt;::type,
 835         typename internal::DecayArray&lt;T2&gt;::type,
 836         typename internal::DecayArray&lt;T3&gt;::type,
 837         typename internal::DecayArray&lt;T4&gt;::type&gt; &gt;
 838 UnorderedElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3, const T4&amp; e4) {
 839   typedef ::testing::tuple&lt;
 840       typename internal::DecayArray&lt;T1&gt;::type,
 841       typename internal::DecayArray&lt;T2&gt;::type,
 842       typename internal::DecayArray&lt;T3&gt;::type,
 843       typename internal::DecayArray&lt;T4&gt;::type&gt; Args;
 844   return internal::UnorderedElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3, e4));
 845 }
 846 
 847 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5&gt;
 848 inline internal::UnorderedElementsAreMatcher&lt;
 849     ::testing::tuple&lt;
 850         typename internal::DecayArray&lt;T1&gt;::type,
 851         typename internal::DecayArray&lt;T2&gt;::type,
 852         typename internal::DecayArray&lt;T3&gt;::type,
 853         typename internal::DecayArray&lt;T4&gt;::type,
 854         typename internal::DecayArray&lt;T5&gt;::type&gt; &gt;
 855 UnorderedElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3, const T4&amp; e4,
 856     const T5&amp; e5) {
 857   typedef ::testing::tuple&lt;
 858       typename internal::DecayArray&lt;T1&gt;::type,
 859       typename internal::DecayArray&lt;T2&gt;::type,
 860       typename internal::DecayArray&lt;T3&gt;::type,
 861       typename internal::DecayArray&lt;T4&gt;::type,
 862       typename internal::DecayArray&lt;T5&gt;::type&gt; Args;
 863   return internal::UnorderedElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3, e4, e5));
 864 }
 865 
 866 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
 867     typename T6&gt;
 868 inline internal::UnorderedElementsAreMatcher&lt;
 869     ::testing::tuple&lt;
 870         typename internal::DecayArray&lt;T1&gt;::type,
 871         typename internal::DecayArray&lt;T2&gt;::type,
 872         typename internal::DecayArray&lt;T3&gt;::type,
 873         typename internal::DecayArray&lt;T4&gt;::type,
 874         typename internal::DecayArray&lt;T5&gt;::type,
 875         typename internal::DecayArray&lt;T6&gt;::type&gt; &gt;
 876 UnorderedElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3, const T4&amp; e4,
 877     const T5&amp; e5, const T6&amp; e6) {
 878   typedef ::testing::tuple&lt;
 879       typename internal::DecayArray&lt;T1&gt;::type,
 880       typename internal::DecayArray&lt;T2&gt;::type,
 881       typename internal::DecayArray&lt;T3&gt;::type,
 882       typename internal::DecayArray&lt;T4&gt;::type,
 883       typename internal::DecayArray&lt;T5&gt;::type,
 884       typename internal::DecayArray&lt;T6&gt;::type&gt; Args;
 885   return internal::UnorderedElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3, e4, e5,
 886       e6));
 887 }
 888 
 889 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
 890     typename T6, typename T7&gt;
 891 inline internal::UnorderedElementsAreMatcher&lt;
 892     ::testing::tuple&lt;
 893         typename internal::DecayArray&lt;T1&gt;::type,
 894         typename internal::DecayArray&lt;T2&gt;::type,
 895         typename internal::DecayArray&lt;T3&gt;::type,
 896         typename internal::DecayArray&lt;T4&gt;::type,
 897         typename internal::DecayArray&lt;T5&gt;::type,
 898         typename internal::DecayArray&lt;T6&gt;::type,
 899         typename internal::DecayArray&lt;T7&gt;::type&gt; &gt;
 900 UnorderedElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3, const T4&amp; e4,
 901     const T5&amp; e5, const T6&amp; e6, const T7&amp; e7) {
 902   typedef ::testing::tuple&lt;
 903       typename internal::DecayArray&lt;T1&gt;::type,
 904       typename internal::DecayArray&lt;T2&gt;::type,
 905       typename internal::DecayArray&lt;T3&gt;::type,
 906       typename internal::DecayArray&lt;T4&gt;::type,
 907       typename internal::DecayArray&lt;T5&gt;::type,
 908       typename internal::DecayArray&lt;T6&gt;::type,
 909       typename internal::DecayArray&lt;T7&gt;::type&gt; Args;
 910   return internal::UnorderedElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3, e4, e5,
 911       e6, e7));
 912 }
 913 
 914 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
 915     typename T6, typename T7, typename T8&gt;
 916 inline internal::UnorderedElementsAreMatcher&lt;
 917     ::testing::tuple&lt;
 918         typename internal::DecayArray&lt;T1&gt;::type,
 919         typename internal::DecayArray&lt;T2&gt;::type,
 920         typename internal::DecayArray&lt;T3&gt;::type,
 921         typename internal::DecayArray&lt;T4&gt;::type,
 922         typename internal::DecayArray&lt;T5&gt;::type,
 923         typename internal::DecayArray&lt;T6&gt;::type,
 924         typename internal::DecayArray&lt;T7&gt;::type,
 925         typename internal::DecayArray&lt;T8&gt;::type&gt; &gt;
 926 UnorderedElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3, const T4&amp; e4,
 927     const T5&amp; e5, const T6&amp; e6, const T7&amp; e7, const T8&amp; e8) {
 928   typedef ::testing::tuple&lt;
 929       typename internal::DecayArray&lt;T1&gt;::type,
 930       typename internal::DecayArray&lt;T2&gt;::type,
 931       typename internal::DecayArray&lt;T3&gt;::type,
 932       typename internal::DecayArray&lt;T4&gt;::type,
 933       typename internal::DecayArray&lt;T5&gt;::type,
 934       typename internal::DecayArray&lt;T6&gt;::type,
 935       typename internal::DecayArray&lt;T7&gt;::type,
 936       typename internal::DecayArray&lt;T8&gt;::type&gt; Args;
 937   return internal::UnorderedElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3, e4, e5,
 938       e6, e7, e8));
 939 }
 940 
 941 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
 942     typename T6, typename T7, typename T8, typename T9&gt;
 943 inline internal::UnorderedElementsAreMatcher&lt;
 944     ::testing::tuple&lt;
 945         typename internal::DecayArray&lt;T1&gt;::type,
 946         typename internal::DecayArray&lt;T2&gt;::type,
 947         typename internal::DecayArray&lt;T3&gt;::type,
 948         typename internal::DecayArray&lt;T4&gt;::type,
 949         typename internal::DecayArray&lt;T5&gt;::type,
 950         typename internal::DecayArray&lt;T6&gt;::type,
 951         typename internal::DecayArray&lt;T7&gt;::type,
 952         typename internal::DecayArray&lt;T8&gt;::type,
 953         typename internal::DecayArray&lt;T9&gt;::type&gt; &gt;
 954 UnorderedElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3, const T4&amp; e4,
 955     const T5&amp; e5, const T6&amp; e6, const T7&amp; e7, const T8&amp; e8, const T9&amp; e9) {
 956   typedef ::testing::tuple&lt;
 957       typename internal::DecayArray&lt;T1&gt;::type,
 958       typename internal::DecayArray&lt;T2&gt;::type,
 959       typename internal::DecayArray&lt;T3&gt;::type,
 960       typename internal::DecayArray&lt;T4&gt;::type,
 961       typename internal::DecayArray&lt;T5&gt;::type,
 962       typename internal::DecayArray&lt;T6&gt;::type,
 963       typename internal::DecayArray&lt;T7&gt;::type,
 964       typename internal::DecayArray&lt;T8&gt;::type,
 965       typename internal::DecayArray&lt;T9&gt;::type&gt; Args;
 966   return internal::UnorderedElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3, e4, e5,
 967       e6, e7, e8, e9));
 968 }
 969 
 970 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
 971     typename T6, typename T7, typename T8, typename T9, typename T10&gt;
 972 inline internal::UnorderedElementsAreMatcher&lt;
 973     ::testing::tuple&lt;
 974         typename internal::DecayArray&lt;T1&gt;::type,
 975         typename internal::DecayArray&lt;T2&gt;::type,
 976         typename internal::DecayArray&lt;T3&gt;::type,
 977         typename internal::DecayArray&lt;T4&gt;::type,
 978         typename internal::DecayArray&lt;T5&gt;::type,
 979         typename internal::DecayArray&lt;T6&gt;::type,
 980         typename internal::DecayArray&lt;T7&gt;::type,
 981         typename internal::DecayArray&lt;T8&gt;::type,
 982         typename internal::DecayArray&lt;T9&gt;::type,
 983         typename internal::DecayArray&lt;T10&gt;::type&gt; &gt;
 984 UnorderedElementsAre(const T1&amp; e1, const T2&amp; e2, const T3&amp; e3, const T4&amp; e4,
 985     const T5&amp; e5, const T6&amp; e6, const T7&amp; e7, const T8&amp; e8, const T9&amp; e9,
 986     const T10&amp; e10) {
 987   typedef ::testing::tuple&lt;
 988       typename internal::DecayArray&lt;T1&gt;::type,
 989       typename internal::DecayArray&lt;T2&gt;::type,
 990       typename internal::DecayArray&lt;T3&gt;::type,
 991       typename internal::DecayArray&lt;T4&gt;::type,
 992       typename internal::DecayArray&lt;T5&gt;::type,
 993       typename internal::DecayArray&lt;T6&gt;::type,
 994       typename internal::DecayArray&lt;T7&gt;::type,
 995       typename internal::DecayArray&lt;T8&gt;::type,
 996       typename internal::DecayArray&lt;T9&gt;::type,
 997       typename internal::DecayArray&lt;T10&gt;::type&gt; Args;
 998   return internal::UnorderedElementsAreMatcher&lt;Args&gt;(Args(e1, e2, e3, e4, e5,
 999       e6, e7, e8, e9, e10));
1000 }
1001 
1002 // AllOf(m1, m2, ..., mk) matches any value that matches all of the given
1003 // sub-matchers.  AllOf is called fully qualified to prevent ADL from firing.
1004 
1005 template &lt;typename M1, typename M2&gt;
1006 inline typename internal::AllOfResult2&lt;M1, M2&gt;::type
1007 AllOf(M1 m1, M2 m2) {
1008   return typename internal::AllOfResult2&lt;M1, M2&gt;::type(
1009       m1,
1010       m2);
1011 }
1012 
1013 template &lt;typename M1, typename M2, typename M3&gt;
1014 inline typename internal::AllOfResult3&lt;M1, M2, M3&gt;::type
1015 AllOf(M1 m1, M2 m2, M3 m3) {
1016   return typename internal::AllOfResult3&lt;M1, M2, M3&gt;::type(
1017       m1,
1018       ::testing::AllOf(m2, m3));
1019 }
1020 
1021 template &lt;typename M1, typename M2, typename M3, typename M4&gt;
1022 inline typename internal::AllOfResult4&lt;M1, M2, M3, M4&gt;::type
1023 AllOf(M1 m1, M2 m2, M3 m3, M4 m4) {
1024   return typename internal::AllOfResult4&lt;M1, M2, M3, M4&gt;::type(
1025       ::testing::AllOf(m1, m2),
1026       ::testing::AllOf(m3, m4));
1027 }
1028 
1029 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5&gt;
1030 inline typename internal::AllOfResult5&lt;M1, M2, M3, M4, M5&gt;::type
1031 AllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5) {
1032   return typename internal::AllOfResult5&lt;M1, M2, M3, M4, M5&gt;::type(
1033       ::testing::AllOf(m1, m2),
1034       ::testing::AllOf(m3, m4, m5));
1035 }
1036 
1037 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
1038     typename M6&gt;
1039 inline typename internal::AllOfResult6&lt;M1, M2, M3, M4, M5, M6&gt;::type
1040 AllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6) {
1041   return typename internal::AllOfResult6&lt;M1, M2, M3, M4, M5, M6&gt;::type(
1042       ::testing::AllOf(m1, m2, m3),
1043       ::testing::AllOf(m4, m5, m6));
1044 }
1045 
1046 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
1047     typename M6, typename M7&gt;
1048 inline typename internal::AllOfResult7&lt;M1, M2, M3, M4, M5, M6, M7&gt;::type
1049 AllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7) {
1050   return typename internal::AllOfResult7&lt;M1, M2, M3, M4, M5, M6, M7&gt;::type(
1051       ::testing::AllOf(m1, m2, m3),
1052       ::testing::AllOf(m4, m5, m6, m7));
1053 }
1054 
1055 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
1056     typename M6, typename M7, typename M8&gt;
1057 inline typename internal::AllOfResult8&lt;M1, M2, M3, M4, M5, M6, M7, M8&gt;::type
1058 AllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8) {
1059   return typename internal::AllOfResult8&lt;M1, M2, M3, M4, M5, M6, M7, M8&gt;::type(
1060       ::testing::AllOf(m1, m2, m3, m4),
1061       ::testing::AllOf(m5, m6, m7, m8));
1062 }
1063 
1064 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
1065     typename M6, typename M7, typename M8, typename M9&gt;
1066 inline typename internal::AllOfResult9&lt;M1, M2, M3, M4, M5, M6, M7, M8, M9&gt;::type
1067 AllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9) {
1068   return typename internal::AllOfResult9&lt;M1, M2, M3, M4, M5, M6, M7, M8,
1069       M9&gt;::type(
1070       ::testing::AllOf(m1, m2, m3, m4),
1071       ::testing::AllOf(m5, m6, m7, m8, m9));
1072 }
1073 
1074 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
1075     typename M6, typename M7, typename M8, typename M9, typename M10&gt;
1076 inline typename internal::AllOfResult10&lt;M1, M2, M3, M4, M5, M6, M7, M8, M9,
1077     M10&gt;::type
1078 AllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9, M10 m10) {
1079   return typename internal::AllOfResult10&lt;M1, M2, M3, M4, M5, M6, M7, M8, M9,
1080       M10&gt;::type(
1081       ::testing::AllOf(m1, m2, m3, m4, m5),
1082       ::testing::AllOf(m6, m7, m8, m9, m10));
1083 }
1084 
1085 // AnyOf(m1, m2, ..., mk) matches any value that matches any of the given
1086 // sub-matchers.  AnyOf is called fully qualified to prevent ADL from firing.
1087 
1088 template &lt;typename M1, typename M2&gt;
1089 inline typename internal::AnyOfResult2&lt;M1, M2&gt;::type
1090 AnyOf(M1 m1, M2 m2) {
1091   return typename internal::AnyOfResult2&lt;M1, M2&gt;::type(
1092       m1,
1093       m2);
1094 }
1095 
1096 template &lt;typename M1, typename M2, typename M3&gt;
1097 inline typename internal::AnyOfResult3&lt;M1, M2, M3&gt;::type
1098 AnyOf(M1 m1, M2 m2, M3 m3) {
1099   return typename internal::AnyOfResult3&lt;M1, M2, M3&gt;::type(
1100       m1,
1101       ::testing::AnyOf(m2, m3));
1102 }
1103 
1104 template &lt;typename M1, typename M2, typename M3, typename M4&gt;
1105 inline typename internal::AnyOfResult4&lt;M1, M2, M3, M4&gt;::type
1106 AnyOf(M1 m1, M2 m2, M3 m3, M4 m4) {
1107   return typename internal::AnyOfResult4&lt;M1, M2, M3, M4&gt;::type(
1108       ::testing::AnyOf(m1, m2),
1109       ::testing::AnyOf(m3, m4));
1110 }
1111 
1112 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5&gt;
1113 inline typename internal::AnyOfResult5&lt;M1, M2, M3, M4, M5&gt;::type
1114 AnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5) {
1115   return typename internal::AnyOfResult5&lt;M1, M2, M3, M4, M5&gt;::type(
1116       ::testing::AnyOf(m1, m2),
1117       ::testing::AnyOf(m3, m4, m5));
1118 }
1119 
1120 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
1121     typename M6&gt;
1122 inline typename internal::AnyOfResult6&lt;M1, M2, M3, M4, M5, M6&gt;::type
1123 AnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6) {
1124   return typename internal::AnyOfResult6&lt;M1, M2, M3, M4, M5, M6&gt;::type(
1125       ::testing::AnyOf(m1, m2, m3),
1126       ::testing::AnyOf(m4, m5, m6));
1127 }
1128 
1129 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
1130     typename M6, typename M7&gt;
1131 inline typename internal::AnyOfResult7&lt;M1, M2, M3, M4, M5, M6, M7&gt;::type
1132 AnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7) {
1133   return typename internal::AnyOfResult7&lt;M1, M2, M3, M4, M5, M6, M7&gt;::type(
1134       ::testing::AnyOf(m1, m2, m3),
1135       ::testing::AnyOf(m4, m5, m6, m7));
1136 }
1137 
1138 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
1139     typename M6, typename M7, typename M8&gt;
1140 inline typename internal::AnyOfResult8&lt;M1, M2, M3, M4, M5, M6, M7, M8&gt;::type
1141 AnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8) {
1142   return typename internal::AnyOfResult8&lt;M1, M2, M3, M4, M5, M6, M7, M8&gt;::type(
1143       ::testing::AnyOf(m1, m2, m3, m4),
1144       ::testing::AnyOf(m5, m6, m7, m8));
1145 }
1146 
1147 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
1148     typename M6, typename M7, typename M8, typename M9&gt;
1149 inline typename internal::AnyOfResult9&lt;M1, M2, M3, M4, M5, M6, M7, M8, M9&gt;::type
1150 AnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9) {
1151   return typename internal::AnyOfResult9&lt;M1, M2, M3, M4, M5, M6, M7, M8,
1152       M9&gt;::type(
1153       ::testing::AnyOf(m1, m2, m3, m4),
1154       ::testing::AnyOf(m5, m6, m7, m8, m9));
1155 }
1156 
1157 template &lt;typename M1, typename M2, typename M3, typename M4, typename M5,
1158     typename M6, typename M7, typename M8, typename M9, typename M10&gt;
1159 inline typename internal::AnyOfResult10&lt;M1, M2, M3, M4, M5, M6, M7, M8, M9,
1160     M10&gt;::type
1161 AnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9, M10 m10) {
1162   return typename internal::AnyOfResult10&lt;M1, M2, M3, M4, M5, M6, M7, M8, M9,
1163       M10&gt;::type(
1164       ::testing::AnyOf(m1, m2, m3, m4, m5),
1165       ::testing::AnyOf(m6, m7, m8, m9, m10));
1166 }
1167 
1168 }  // namespace testing
1169 
1170 
1171 // The MATCHER* family of macros can be used in a namespace scope to
1172 // define custom matchers easily.
1173 //
1174 // Basic Usage
1175 // ===========
1176 //
1177 // The syntax
1178 //
1179 //   MATCHER(name, description_string) { statements; }
1180 //
1181 // defines a matcher with the given name that executes the statements,
1182 // which must return a bool to indicate if the match succeeds.  Inside
1183 // the statements, you can refer to the value being matched by &#39;arg&#39;,
1184 // and refer to its type by &#39;arg_type&#39;.
1185 //
1186 // The description string documents what the matcher does, and is used
1187 // to generate the failure message when the match fails.  Since a
1188 // MATCHER() is usually defined in a header file shared by multiple
1189 // C++ source files, we require the description to be a C-string
1190 // literal to avoid possible side effects.  It can be empty, in which
1191 // case we&#39;ll use the sequence of words in the matcher name as the
1192 // description.
1193 //
1194 // For example:
1195 //
1196 //   MATCHER(IsEven, &quot;&quot;) { return (arg % 2) == 0; }
1197 //
1198 // allows you to write
1199 //
1200 //   // Expects mock_foo.Bar(n) to be called where n is even.
1201 //   EXPECT_CALL(mock_foo, Bar(IsEven()));
1202 //
1203 // or,
1204 //
1205 //   // Verifies that the value of some_expression is even.
1206 //   EXPECT_THAT(some_expression, IsEven());
1207 //
1208 // If the above assertion fails, it will print something like:
1209 //
1210 //   Value of: some_expression
1211 //   Expected: is even
1212 //     Actual: 7
1213 //
1214 // where the description &quot;is even&quot; is automatically calculated from the
1215 // matcher name IsEven.
1216 //
1217 // Argument Type
1218 // =============
1219 //
1220 // Note that the type of the value being matched (arg_type) is
1221 // determined by the context in which you use the matcher and is
1222 // supplied to you by the compiler, so you don&#39;t need to worry about
1223 // declaring it (nor can you).  This allows the matcher to be
1224 // polymorphic.  For example, IsEven() can be used to match any type
1225 // where the value of &quot;(arg % 2) == 0&quot; can be implicitly converted to
1226 // a bool.  In the &quot;Bar(IsEven())&quot; example above, if method Bar()
1227 // takes an int, &#39;arg_type&#39; will be int; if it takes an unsigned long,
1228 // &#39;arg_type&#39; will be unsigned long; and so on.
1229 //
1230 // Parameterizing Matchers
1231 // =======================
1232 //
1233 // Sometimes you&#39;ll want to parameterize the matcher.  For that you
1234 // can use another macro:
1235 //
1236 //   MATCHER_P(name, param_name, description_string) { statements; }
1237 //
1238 // For example:
1239 //
1240 //   MATCHER_P(HasAbsoluteValue, value, &quot;&quot;) { return abs(arg) == value; }
1241 //
1242 // will allow you to write:
1243 //
1244 //   EXPECT_THAT(Blah(&quot;a&quot;), HasAbsoluteValue(n));
1245 //
1246 // which may lead to this message (assuming n is 10):
1247 //
1248 //   Value of: Blah(&quot;a&quot;)
1249 //   Expected: has absolute value 10
1250 //     Actual: -9
1251 //
1252 // Note that both the matcher description and its parameter are
1253 // printed, making the message human-friendly.
1254 //
1255 // In the matcher definition body, you can write &#39;foo_type&#39; to
1256 // reference the type of a parameter named &#39;foo&#39;.  For example, in the
1257 // body of MATCHER_P(HasAbsoluteValue, value) above, you can write
1258 // &#39;value_type&#39; to refer to the type of &#39;value&#39;.
1259 //
1260 // We also provide MATCHER_P2, MATCHER_P3, ..., up to MATCHER_P10 to
1261 // support multi-parameter matchers.
1262 //
1263 // Describing Parameterized Matchers
1264 // =================================
1265 //
1266 // The last argument to MATCHER*() is a string-typed expression.  The
1267 // expression can reference all of the matcher&#39;s parameters and a
1268 // special bool-typed variable named &#39;negation&#39;.  When &#39;negation&#39; is
1269 // false, the expression should evaluate to the matcher&#39;s description;
1270 // otherwise it should evaluate to the description of the negation of
1271 // the matcher.  For example,
1272 //
1273 //   using testing::PrintToString;
1274 //
1275 //   MATCHER_P2(InClosedRange, low, hi,
1276 //       std::string(negation ? &quot;is not&quot; : &quot;is&quot;) + &quot; in range [&quot; +
1277 //       PrintToString(low) + &quot;, &quot; + PrintToString(hi) + &quot;]&quot;) {
1278 //     return low &lt;= arg &amp;&amp; arg &lt;= hi;
1279 //   }
1280 //   ...
1281 //   EXPECT_THAT(3, InClosedRange(4, 6));
1282 //   EXPECT_THAT(3, Not(InClosedRange(2, 4)));
1283 //
1284 // would generate two failures that contain the text:
1285 //
1286 //   Expected: is in range [4, 6]
1287 //   ...
1288 //   Expected: is not in range [2, 4]
1289 //
1290 // If you specify &quot;&quot; as the description, the failure message will
1291 // contain the sequence of words in the matcher name followed by the
1292 // parameter values printed as a tuple.  For example,
1293 //
1294 //   MATCHER_P2(InClosedRange, low, hi, &quot;&quot;) { ... }
1295 //   ...
1296 //   EXPECT_THAT(3, InClosedRange(4, 6));
1297 //   EXPECT_THAT(3, Not(InClosedRange(2, 4)));
1298 //
1299 // would generate two failures that contain the text:
1300 //
1301 //   Expected: in closed range (4, 6)
1302 //   ...
1303 //   Expected: not (in closed range (2, 4))
1304 //
1305 // Types of Matcher Parameters
1306 // ===========================
1307 //
1308 // For the purpose of typing, you can view
1309 //
1310 //   MATCHER_Pk(Foo, p1, ..., pk, description_string) { ... }
1311 //
1312 // as shorthand for
1313 //
1314 //   template &lt;typename p1_type, ..., typename pk_type&gt;
1315 //   FooMatcherPk&lt;p1_type, ..., pk_type&gt;
1316 //   Foo(p1_type p1, ..., pk_type pk) { ... }
1317 //
1318 // When you write Foo(v1, ..., vk), the compiler infers the types of
1319 // the parameters v1, ..., and vk for you.  If you are not happy with
1320 // the result of the type inference, you can specify the types by
1321 // explicitly instantiating the template, as in Foo&lt;long, bool&gt;(5,
1322 // false).  As said earlier, you don&#39;t get to (or need to) specify
1323 // &#39;arg_type&#39; as that&#39;s determined by the context in which the matcher
1324 // is used.  You can assign the result of expression Foo(p1, ..., pk)
1325 // to a variable of type FooMatcherPk&lt;p1_type, ..., pk_type&gt;.  This
1326 // can be useful when composing matchers.
1327 //
1328 // While you can instantiate a matcher template with reference types,
1329 // passing the parameters by pointer usually makes your code more
1330 // readable.  If, however, you still want to pass a parameter by
1331 // reference, be aware that in the failure message generated by the
1332 // matcher you will see the value of the referenced object but not its
1333 // address.
1334 //
1335 // Explaining Match Results
1336 // ========================
1337 //
1338 // Sometimes the matcher description alone isn&#39;t enough to explain why
1339 // the match has failed or succeeded.  For example, when expecting a
1340 // long string, it can be very helpful to also print the diff between
1341 // the expected string and the actual one.  To achieve that, you can
1342 // optionally stream additional information to a special variable
1343 // named result_listener, whose type is a pointer to class
1344 // MatchResultListener:
1345 //
1346 //   MATCHER_P(EqualsLongString, str, &quot;&quot;) {
1347 //     if (arg == str) return true;
1348 //
1349 //     *result_listener &lt;&lt; &quot;the difference: &quot;
1350 ///                     &lt;&lt; DiffStrings(str, arg);
1351 //     return false;
1352 //   }
1353 //
1354 // Overloading Matchers
1355 // ====================
1356 //
1357 // You can overload matchers with different numbers of parameters:
1358 //
1359 //   MATCHER_P(Blah, a, description_string1) { ... }
1360 //   MATCHER_P2(Blah, a, b, description_string2) { ... }
1361 //
1362 // Caveats
1363 // =======
1364 //
1365 // When defining a new matcher, you should also consider implementing
1366 // MatcherInterface or using MakePolymorphicMatcher().  These
1367 // approaches require more work than the MATCHER* macros, but also
1368 // give you more control on the types of the value being matched and
1369 // the matcher parameters, which may leads to better compiler error
1370 // messages when the matcher is used wrong.  They also allow
1371 // overloading matchers based on parameter types (as opposed to just
1372 // based on the number of parameters).
1373 //
1374 // MATCHER*() can only be used in a namespace scope.  The reason is
1375 // that C++ doesn&#39;t yet allow function-local types to be used to
1376 // instantiate templates.  The up-coming C++0x standard will fix this.
1377 // Once that&#39;s done, we&#39;ll consider supporting using MATCHER*() inside
1378 // a function.
1379 //
1380 // More Information
1381 // ================
1382 //
1383 // To learn more about using these macros, please search for &#39;MATCHER&#39;
1384 // on
1385 // https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md
1386 
1387 #define MATCHER(name, description)\
1388   class name##Matcher {\
1389    public:\
1390     template &lt;typename arg_type&gt;\
1391     class gmock_Impl : public ::testing::MatcherInterface&lt;\
1392         GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {\
1393      public:\
1394       gmock_Impl()\
1395            {}\
1396       virtual bool MatchAndExplain(\
1397           GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1398           ::testing::MatchResultListener* result_listener) const;\
1399       virtual void DescribeTo(::std::ostream* gmock_os) const {\
1400         *gmock_os &lt;&lt; FormatDescription(false);\
1401       }\
1402       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\
1403         *gmock_os &lt;&lt; FormatDescription(true);\
1404       }\
1405      private:\
1406       ::std::string FormatDescription(bool negation) const {\
1407         ::std::string gmock_description = (description);\
1408         if (!gmock_description.empty()) {\
1409           return gmock_description;\
1410         }\
1411         return ::testing::internal::FormatMatcherDescription(\
1412             negation, #name, \
1413             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\
1414                 ::testing::tuple&lt;&gt;()));\
1415       }\
1416     };\
1417     template &lt;typename arg_type&gt;\
1418     operator ::testing::Matcher&lt;arg_type&gt;() const {\
1419       return ::testing::Matcher&lt;arg_type&gt;(\
1420           new gmock_Impl&lt;arg_type&gt;());\
1421     }\
1422     name##Matcher() {\
1423     }\
1424    private:\
1425   };\
1426   inline name##Matcher name() {\
1427     return name##Matcher();\
1428   }\
1429   template &lt;typename arg_type&gt;\
1430   bool name##Matcher::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\
1431       GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1432       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\
1433           const
1434 
1435 #define MATCHER_P(name, p0, description)\
1436   template &lt;typename p0##_type&gt;\
1437   class name##MatcherP {\
1438    public:\
1439     template &lt;typename arg_type&gt;\
1440     class gmock_Impl : public ::testing::MatcherInterface&lt;\
1441         GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {\
1442      public:\
1443       explicit gmock_Impl(p0##_type gmock_p0)\
1444            : p0(::testing::internal::move(gmock_p0)) {}\
1445       virtual bool MatchAndExplain(\
1446           GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1447           ::testing::MatchResultListener* result_listener) const;\
1448       virtual void DescribeTo(::std::ostream* gmock_os) const {\
1449         *gmock_os &lt;&lt; FormatDescription(false);\
1450       }\
1451       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\
1452         *gmock_os &lt;&lt; FormatDescription(true);\
1453       }\
1454       p0##_type const p0;\
1455      private:\
1456       ::std::string FormatDescription(bool negation) const {\
1457         ::std::string gmock_description = (description);\
1458         if (!gmock_description.empty()) {\
1459           return gmock_description;\
1460         }\
1461         return ::testing::internal::FormatMatcherDescription(\
1462             negation, #name, \
1463             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\
1464                 ::testing::tuple&lt;p0##_type&gt;(p0)));\
1465       }\
1466     };\
1467     template &lt;typename arg_type&gt;\
1468     operator ::testing::Matcher&lt;arg_type&gt;() const {\
1469       return ::testing::Matcher&lt;arg_type&gt;(\
1470           new gmock_Impl&lt;arg_type&gt;(p0));\
1471     }\
1472     explicit name##MatcherP(p0##_type gmock_p0) : \
1473         p0(::testing::internal::move(gmock_p0)) {\
1474     }\
1475     p0##_type const p0;\
1476    private:\
1477   };\
1478   template &lt;typename p0##_type&gt;\
1479   inline name##MatcherP&lt;p0##_type&gt; name(p0##_type p0) {\
1480     return name##MatcherP&lt;p0##_type&gt;(p0);\
1481   }\
1482   template &lt;typename p0##_type&gt;\
1483   template &lt;typename arg_type&gt;\
1484   bool name##MatcherP&lt;p0##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\
1485       GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1486       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\
1487           const
1488 
1489 #define MATCHER_P2(name, p0, p1, description)\
1490   template &lt;typename p0##_type, typename p1##_type&gt;\
1491   class name##MatcherP2 {\
1492    public:\
1493     template &lt;typename arg_type&gt;\
1494     class gmock_Impl : public ::testing::MatcherInterface&lt;\
1495         GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {\
1496      public:\
1497       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1)\
1498            : p0(::testing::internal::move(gmock_p0)), \
1499                p1(::testing::internal::move(gmock_p1)) {}\
1500       virtual bool MatchAndExplain(\
1501           GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1502           ::testing::MatchResultListener* result_listener) const;\
1503       virtual void DescribeTo(::std::ostream* gmock_os) const {\
1504         *gmock_os &lt;&lt; FormatDescription(false);\
1505       }\
1506       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\
1507         *gmock_os &lt;&lt; FormatDescription(true);\
1508       }\
1509       p0##_type const p0;\
1510       p1##_type const p1;\
1511      private:\
1512       ::std::string FormatDescription(bool negation) const {\
1513         ::std::string gmock_description = (description);\
1514         if (!gmock_description.empty()) {\
1515           return gmock_description;\
1516         }\
1517         return ::testing::internal::FormatMatcherDescription(\
1518             negation, #name, \
1519             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\
1520                 ::testing::tuple&lt;p0##_type, p1##_type&gt;(p0, p1)));\
1521       }\
1522     };\
1523     template &lt;typename arg_type&gt;\
1524     operator ::testing::Matcher&lt;arg_type&gt;() const {\
1525       return ::testing::Matcher&lt;arg_type&gt;(\
1526           new gmock_Impl&lt;arg_type&gt;(p0, p1));\
1527     }\
1528     name##MatcherP2(p0##_type gmock_p0, \
1529         p1##_type gmock_p1) : p0(::testing::internal::move(gmock_p0)), \
1530         p1(::testing::internal::move(gmock_p1)) {\
1531     }\
1532     p0##_type const p0;\
1533     p1##_type const p1;\
1534    private:\
1535   };\
1536   template &lt;typename p0##_type, typename p1##_type&gt;\
1537   inline name##MatcherP2&lt;p0##_type, p1##_type&gt; name(p0##_type p0, \
1538       p1##_type p1) {\
1539     return name##MatcherP2&lt;p0##_type, p1##_type&gt;(p0, p1);\
1540   }\
1541   template &lt;typename p0##_type, typename p1##_type&gt;\
1542   template &lt;typename arg_type&gt;\
1543   bool name##MatcherP2&lt;p0##_type, \
1544       p1##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\
1545       GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1546       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\
1547           const
1548 
1549 #define MATCHER_P3(name, p0, p1, p2, description)\
1550   template &lt;typename p0##_type, typename p1##_type, typename p2##_type&gt;\
1551   class name##MatcherP3 {\
1552    public:\
1553     template &lt;typename arg_type&gt;\
1554     class gmock_Impl : public ::testing::MatcherInterface&lt;\
1555         GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {\
1556      public:\
1557       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2)\
1558            : p0(::testing::internal::move(gmock_p0)), \
1559                p1(::testing::internal::move(gmock_p1)), \
1560                p2(::testing::internal::move(gmock_p2)) {}\
1561       virtual bool MatchAndExplain(\
1562           GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1563           ::testing::MatchResultListener* result_listener) const;\
1564       virtual void DescribeTo(::std::ostream* gmock_os) const {\
1565         *gmock_os &lt;&lt; FormatDescription(false);\
1566       }\
1567       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\
1568         *gmock_os &lt;&lt; FormatDescription(true);\
1569       }\
1570       p0##_type const p0;\
1571       p1##_type const p1;\
1572       p2##_type const p2;\
1573      private:\
1574       ::std::string FormatDescription(bool negation) const {\
1575         ::std::string gmock_description = (description);\
1576         if (!gmock_description.empty()) {\
1577           return gmock_description;\
1578         }\
1579         return ::testing::internal::FormatMatcherDescription(\
1580             negation, #name, \
1581             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\
1582                 ::testing::tuple&lt;p0##_type, p1##_type, p2##_type&gt;(p0, p1, \
1583                     p2)));\
1584       }\
1585     };\
1586     template &lt;typename arg_type&gt;\
1587     operator ::testing::Matcher&lt;arg_type&gt;() const {\
1588       return ::testing::Matcher&lt;arg_type&gt;(\
1589           new gmock_Impl&lt;arg_type&gt;(p0, p1, p2));\
1590     }\
1591     name##MatcherP3(p0##_type gmock_p0, p1##_type gmock_p1, \
1592         p2##_type gmock_p2) : p0(::testing::internal::move(gmock_p0)), \
1593         p1(::testing::internal::move(gmock_p1)), \
1594         p2(::testing::internal::move(gmock_p2)) {\
1595     }\
1596     p0##_type const p0;\
1597     p1##_type const p1;\
1598     p2##_type const p2;\
1599    private:\
1600   };\
1601   template &lt;typename p0##_type, typename p1##_type, typename p2##_type&gt;\
1602   inline name##MatcherP3&lt;p0##_type, p1##_type, p2##_type&gt; name(p0##_type p0, \
1603       p1##_type p1, p2##_type p2) {\
1604     return name##MatcherP3&lt;p0##_type, p1##_type, p2##_type&gt;(p0, p1, p2);\
1605   }\
1606   template &lt;typename p0##_type, typename p1##_type, typename p2##_type&gt;\
1607   template &lt;typename arg_type&gt;\
1608   bool name##MatcherP3&lt;p0##_type, p1##_type, \
1609       p2##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\
1610       GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1611       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\
1612           const
1613 
1614 #define MATCHER_P4(name, p0, p1, p2, p3, description)\
1615   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
1616       typename p3##_type&gt;\
1617   class name##MatcherP4 {\
1618    public:\
1619     template &lt;typename arg_type&gt;\
1620     class gmock_Impl : public ::testing::MatcherInterface&lt;\
1621         GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {\
1622      public:\
1623       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
1624           p3##_type gmock_p3)\
1625            : p0(::testing::internal::move(gmock_p0)), \
1626                p1(::testing::internal::move(gmock_p1)), \
1627                p2(::testing::internal::move(gmock_p2)), \
1628                p3(::testing::internal::move(gmock_p3)) {}\
1629       virtual bool MatchAndExplain(\
1630           GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1631           ::testing::MatchResultListener* result_listener) const;\
1632       virtual void DescribeTo(::std::ostream* gmock_os) const {\
1633         *gmock_os &lt;&lt; FormatDescription(false);\
1634       }\
1635       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\
1636         *gmock_os &lt;&lt; FormatDescription(true);\
1637       }\
1638       p0##_type const p0;\
1639       p1##_type const p1;\
1640       p2##_type const p2;\
1641       p3##_type const p3;\
1642      private:\
1643       ::std::string FormatDescription(bool negation) const {\
1644         ::std::string gmock_description = (description);\
1645         if (!gmock_description.empty()) {\
1646           return gmock_description;\
1647         }\
1648         return ::testing::internal::FormatMatcherDescription(\
1649             negation, #name, \
1650             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\
1651                 ::testing::tuple&lt;p0##_type, p1##_type, p2##_type, \
1652                     p3##_type&gt;(p0, p1, p2, p3)));\
1653       }\
1654     };\
1655     template &lt;typename arg_type&gt;\
1656     operator ::testing::Matcher&lt;arg_type&gt;() const {\
1657       return ::testing::Matcher&lt;arg_type&gt;(\
1658           new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3));\
1659     }\
1660     name##MatcherP4(p0##_type gmock_p0, p1##_type gmock_p1, \
1661         p2##_type gmock_p2, \
1662         p3##_type gmock_p3) : p0(::testing::internal::move(gmock_p0)), \
1663         p1(::testing::internal::move(gmock_p1)), \
1664         p2(::testing::internal::move(gmock_p2)), \
1665         p3(::testing::internal::move(gmock_p3)) {\
1666     }\
1667     p0##_type const p0;\
1668     p1##_type const p1;\
1669     p2##_type const p2;\
1670     p3##_type const p3;\
1671    private:\
1672   };\
1673   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
1674       typename p3##_type&gt;\
1675   inline name##MatcherP4&lt;p0##_type, p1##_type, p2##_type, \
1676       p3##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, \
1677       p3##_type p3) {\
1678     return name##MatcherP4&lt;p0##_type, p1##_type, p2##_type, p3##_type&gt;(p0, \
1679         p1, p2, p3);\
1680   }\
1681   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
1682       typename p3##_type&gt;\
1683   template &lt;typename arg_type&gt;\
1684   bool name##MatcherP4&lt;p0##_type, p1##_type, p2##_type, \
1685       p3##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\
1686       GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1687       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\
1688           const
1689 
1690 #define MATCHER_P5(name, p0, p1, p2, p3, p4, description)\
1691   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
1692       typename p3##_type, typename p4##_type&gt;\
1693   class name##MatcherP5 {\
1694    public:\
1695     template &lt;typename arg_type&gt;\
1696     class gmock_Impl : public ::testing::MatcherInterface&lt;\
1697         GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {\
1698      public:\
1699       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
1700           p3##_type gmock_p3, p4##_type gmock_p4)\
1701            : p0(::testing::internal::move(gmock_p0)), \
1702                p1(::testing::internal::move(gmock_p1)), \
1703                p2(::testing::internal::move(gmock_p2)), \
1704                p3(::testing::internal::move(gmock_p3)), \
1705                p4(::testing::internal::move(gmock_p4)) {}\
1706       virtual bool MatchAndExplain(\
1707           GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1708           ::testing::MatchResultListener* result_listener) const;\
1709       virtual void DescribeTo(::std::ostream* gmock_os) const {\
1710         *gmock_os &lt;&lt; FormatDescription(false);\
1711       }\
1712       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\
1713         *gmock_os &lt;&lt; FormatDescription(true);\
1714       }\
1715       p0##_type const p0;\
1716       p1##_type const p1;\
1717       p2##_type const p2;\
1718       p3##_type const p3;\
1719       p4##_type const p4;\
1720      private:\
1721       ::std::string FormatDescription(bool negation) const {\
1722         ::std::string gmock_description = (description);\
1723         if (!gmock_description.empty()) {\
1724           return gmock_description;\
1725         }\
1726         return ::testing::internal::FormatMatcherDescription(\
1727             negation, #name, \
1728             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\
1729                 ::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
1730                     p4##_type&gt;(p0, p1, p2, p3, p4)));\
1731       }\
1732     };\
1733     template &lt;typename arg_type&gt;\
1734     operator ::testing::Matcher&lt;arg_type&gt;() const {\
1735       return ::testing::Matcher&lt;arg_type&gt;(\
1736           new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4));\
1737     }\
1738     name##MatcherP5(p0##_type gmock_p0, p1##_type gmock_p1, \
1739         p2##_type gmock_p2, p3##_type gmock_p3, \
1740         p4##_type gmock_p4) : p0(::testing::internal::move(gmock_p0)), \
1741         p1(::testing::internal::move(gmock_p1)), \
1742         p2(::testing::internal::move(gmock_p2)), \
1743         p3(::testing::internal::move(gmock_p3)), \
1744         p4(::testing::internal::move(gmock_p4)) {\
1745     }\
1746     p0##_type const p0;\
1747     p1##_type const p1;\
1748     p2##_type const p2;\
1749     p3##_type const p3;\
1750     p4##_type const p4;\
1751    private:\
1752   };\
1753   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
1754       typename p3##_type, typename p4##_type&gt;\
1755   inline name##MatcherP5&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
1756       p4##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \
1757       p4##_type p4) {\
1758     return name##MatcherP5&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
1759         p4##_type&gt;(p0, p1, p2, p3, p4);\
1760   }\
1761   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
1762       typename p3##_type, typename p4##_type&gt;\
1763   template &lt;typename arg_type&gt;\
1764   bool name##MatcherP5&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
1765       p4##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\
1766       GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1767       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\
1768           const
1769 
1770 #define MATCHER_P6(name, p0, p1, p2, p3, p4, p5, description)\
1771   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
1772       typename p3##_type, typename p4##_type, typename p5##_type&gt;\
1773   class name##MatcherP6 {\
1774    public:\
1775     template &lt;typename arg_type&gt;\
1776     class gmock_Impl : public ::testing::MatcherInterface&lt;\
1777         GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {\
1778      public:\
1779       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
1780           p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5)\
1781            : p0(::testing::internal::move(gmock_p0)), \
1782                p1(::testing::internal::move(gmock_p1)), \
1783                p2(::testing::internal::move(gmock_p2)), \
1784                p3(::testing::internal::move(gmock_p3)), \
1785                p4(::testing::internal::move(gmock_p4)), \
1786                p5(::testing::internal::move(gmock_p5)) {}\
1787       virtual bool MatchAndExplain(\
1788           GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1789           ::testing::MatchResultListener* result_listener) const;\
1790       virtual void DescribeTo(::std::ostream* gmock_os) const {\
1791         *gmock_os &lt;&lt; FormatDescription(false);\
1792       }\
1793       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\
1794         *gmock_os &lt;&lt; FormatDescription(true);\
1795       }\
1796       p0##_type const p0;\
1797       p1##_type const p1;\
1798       p2##_type const p2;\
1799       p3##_type const p3;\
1800       p4##_type const p4;\
1801       p5##_type const p5;\
1802      private:\
1803       ::std::string FormatDescription(bool negation) const {\
1804         ::std::string gmock_description = (description);\
1805         if (!gmock_description.empty()) {\
1806           return gmock_description;\
1807         }\
1808         return ::testing::internal::FormatMatcherDescription(\
1809             negation, #name, \
1810             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\
1811                 ::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
1812                     p4##_type, p5##_type&gt;(p0, p1, p2, p3, p4, p5)));\
1813       }\
1814     };\
1815     template &lt;typename arg_type&gt;\
1816     operator ::testing::Matcher&lt;arg_type&gt;() const {\
1817       return ::testing::Matcher&lt;arg_type&gt;(\
1818           new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5));\
1819     }\
1820     name##MatcherP6(p0##_type gmock_p0, p1##_type gmock_p1, \
1821         p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \
1822         p5##_type gmock_p5) : p0(::testing::internal::move(gmock_p0)), \
1823         p1(::testing::internal::move(gmock_p1)), \
1824         p2(::testing::internal::move(gmock_p2)), \
1825         p3(::testing::internal::move(gmock_p3)), \
1826         p4(::testing::internal::move(gmock_p4)), \
1827         p5(::testing::internal::move(gmock_p5)) {\
1828     }\
1829     p0##_type const p0;\
1830     p1##_type const p1;\
1831     p2##_type const p2;\
1832     p3##_type const p3;\
1833     p4##_type const p4;\
1834     p5##_type const p5;\
1835    private:\
1836   };\
1837   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
1838       typename p3##_type, typename p4##_type, typename p5##_type&gt;\
1839   inline name##MatcherP6&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
1840       p4##_type, p5##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, \
1841       p3##_type p3, p4##_type p4, p5##_type p5) {\
1842     return name##MatcherP6&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
1843         p4##_type, p5##_type&gt;(p0, p1, p2, p3, p4, p5);\
1844   }\
1845   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
1846       typename p3##_type, typename p4##_type, typename p5##_type&gt;\
1847   template &lt;typename arg_type&gt;\
1848   bool name##MatcherP6&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \
1849       p5##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\
1850       GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1851       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\
1852           const
1853 
1854 #define MATCHER_P7(name, p0, p1, p2, p3, p4, p5, p6, description)\
1855   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
1856       typename p3##_type, typename p4##_type, typename p5##_type, \
1857       typename p6##_type&gt;\
1858   class name##MatcherP7 {\
1859    public:\
1860     template &lt;typename arg_type&gt;\
1861     class gmock_Impl : public ::testing::MatcherInterface&lt;\
1862         GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {\
1863      public:\
1864       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
1865           p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \
1866           p6##_type gmock_p6)\
1867            : p0(::testing::internal::move(gmock_p0)), \
1868                p1(::testing::internal::move(gmock_p1)), \
1869                p2(::testing::internal::move(gmock_p2)), \
1870                p3(::testing::internal::move(gmock_p3)), \
1871                p4(::testing::internal::move(gmock_p4)), \
1872                p5(::testing::internal::move(gmock_p5)), \
1873                p6(::testing::internal::move(gmock_p6)) {}\
1874       virtual bool MatchAndExplain(\
1875           GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1876           ::testing::MatchResultListener* result_listener) const;\
1877       virtual void DescribeTo(::std::ostream* gmock_os) const {\
1878         *gmock_os &lt;&lt; FormatDescription(false);\
1879       }\
1880       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\
1881         *gmock_os &lt;&lt; FormatDescription(true);\
1882       }\
1883       p0##_type const p0;\
1884       p1##_type const p1;\
1885       p2##_type const p2;\
1886       p3##_type const p3;\
1887       p4##_type const p4;\
1888       p5##_type const p5;\
1889       p6##_type const p6;\
1890      private:\
1891       ::std::string FormatDescription(bool negation) const {\
1892         ::std::string gmock_description = (description);\
1893         if (!gmock_description.empty()) {\
1894           return gmock_description;\
1895         }\
1896         return ::testing::internal::FormatMatcherDescription(\
1897             negation, #name, \
1898             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\
1899                 ::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
1900                     p4##_type, p5##_type, p6##_type&gt;(p0, p1, p2, p3, p4, p5, \
1901                     p6)));\
1902       }\
1903     };\
1904     template &lt;typename arg_type&gt;\
1905     operator ::testing::Matcher&lt;arg_type&gt;() const {\
1906       return ::testing::Matcher&lt;arg_type&gt;(\
1907           new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5, p6));\
1908     }\
1909     name##MatcherP7(p0##_type gmock_p0, p1##_type gmock_p1, \
1910         p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \
1911         p5##_type gmock_p5, \
1912         p6##_type gmock_p6) : p0(::testing::internal::move(gmock_p0)), \
1913         p1(::testing::internal::move(gmock_p1)), \
1914         p2(::testing::internal::move(gmock_p2)), \
1915         p3(::testing::internal::move(gmock_p3)), \
1916         p4(::testing::internal::move(gmock_p4)), \
1917         p5(::testing::internal::move(gmock_p5)), \
1918         p6(::testing::internal::move(gmock_p6)) {\
1919     }\
1920     p0##_type const p0;\
1921     p1##_type const p1;\
1922     p2##_type const p2;\
1923     p3##_type const p3;\
1924     p4##_type const p4;\
1925     p5##_type const p5;\
1926     p6##_type const p6;\
1927    private:\
1928   };\
1929   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
1930       typename p3##_type, typename p4##_type, typename p5##_type, \
1931       typename p6##_type&gt;\
1932   inline name##MatcherP7&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
1933       p4##_type, p5##_type, p6##_type&gt; name(p0##_type p0, p1##_type p1, \
1934       p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \
1935       p6##_type p6) {\
1936     return name##MatcherP7&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
1937         p4##_type, p5##_type, p6##_type&gt;(p0, p1, p2, p3, p4, p5, p6);\
1938   }\
1939   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
1940       typename p3##_type, typename p4##_type, typename p5##_type, \
1941       typename p6##_type&gt;\
1942   template &lt;typename arg_type&gt;\
1943   bool name##MatcherP7&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \
1944       p5##_type, p6##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\
1945       GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1946       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\
1947           const
1948 
1949 #define MATCHER_P8(name, p0, p1, p2, p3, p4, p5, p6, p7, description)\
1950   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
1951       typename p3##_type, typename p4##_type, typename p5##_type, \
1952       typename p6##_type, typename p7##_type&gt;\
1953   class name##MatcherP8 {\
1954    public:\
1955     template &lt;typename arg_type&gt;\
1956     class gmock_Impl : public ::testing::MatcherInterface&lt;\
1957         GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {\
1958      public:\
1959       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
1960           p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \
1961           p6##_type gmock_p6, p7##_type gmock_p7)\
1962            : p0(::testing::internal::move(gmock_p0)), \
1963                p1(::testing::internal::move(gmock_p1)), \
1964                p2(::testing::internal::move(gmock_p2)), \
1965                p3(::testing::internal::move(gmock_p3)), \
1966                p4(::testing::internal::move(gmock_p4)), \
1967                p5(::testing::internal::move(gmock_p5)), \
1968                p6(::testing::internal::move(gmock_p6)), \
1969                p7(::testing::internal::move(gmock_p7)) {}\
1970       virtual bool MatchAndExplain(\
1971           GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
1972           ::testing::MatchResultListener* result_listener) const;\
1973       virtual void DescribeTo(::std::ostream* gmock_os) const {\
1974         *gmock_os &lt;&lt; FormatDescription(false);\
1975       }\
1976       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\
1977         *gmock_os &lt;&lt; FormatDescription(true);\
1978       }\
1979       p0##_type const p0;\
1980       p1##_type const p1;\
1981       p2##_type const p2;\
1982       p3##_type const p3;\
1983       p4##_type const p4;\
1984       p5##_type const p5;\
1985       p6##_type const p6;\
1986       p7##_type const p7;\
1987      private:\
1988       ::std::string FormatDescription(bool negation) const {\
1989         ::std::string gmock_description = (description);\
1990         if (!gmock_description.empty()) {\
1991           return gmock_description;\
1992         }\
1993         return ::testing::internal::FormatMatcherDescription(\
1994             negation, #name, \
1995             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\
1996                 ::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
1997                     p4##_type, p5##_type, p6##_type, p7##_type&gt;(p0, p1, p2, \
1998                     p3, p4, p5, p6, p7)));\
1999       }\
2000     };\
2001     template &lt;typename arg_type&gt;\
2002     operator ::testing::Matcher&lt;arg_type&gt;() const {\
2003       return ::testing::Matcher&lt;arg_type&gt;(\
2004           new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7));\
2005     }\
2006     name##MatcherP8(p0##_type gmock_p0, p1##_type gmock_p1, \
2007         p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \
2008         p5##_type gmock_p5, p6##_type gmock_p6, \
2009         p7##_type gmock_p7) : p0(::testing::internal::move(gmock_p0)), \
2010         p1(::testing::internal::move(gmock_p1)), \
2011         p2(::testing::internal::move(gmock_p2)), \
2012         p3(::testing::internal::move(gmock_p3)), \
2013         p4(::testing::internal::move(gmock_p4)), \
2014         p5(::testing::internal::move(gmock_p5)), \
2015         p6(::testing::internal::move(gmock_p6)), \
2016         p7(::testing::internal::move(gmock_p7)) {\
2017     }\
2018     p0##_type const p0;\
2019     p1##_type const p1;\
2020     p2##_type const p2;\
2021     p3##_type const p3;\
2022     p4##_type const p4;\
2023     p5##_type const p5;\
2024     p6##_type const p6;\
2025     p7##_type const p7;\
2026    private:\
2027   };\
2028   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
2029       typename p3##_type, typename p4##_type, typename p5##_type, \
2030       typename p6##_type, typename p7##_type&gt;\
2031   inline name##MatcherP8&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
2032       p4##_type, p5##_type, p6##_type, p7##_type&gt; name(p0##_type p0, \
2033       p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \
2034       p6##_type p6, p7##_type p7) {\
2035     return name##MatcherP8&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
2036         p4##_type, p5##_type, p6##_type, p7##_type&gt;(p0, p1, p2, p3, p4, p5, \
2037         p6, p7);\
2038   }\
2039   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
2040       typename p3##_type, typename p4##_type, typename p5##_type, \
2041       typename p6##_type, typename p7##_type&gt;\
2042   template &lt;typename arg_type&gt;\
2043   bool name##MatcherP8&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \
2044       p5##_type, p6##_type, \
2045       p7##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\
2046       GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
2047       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\
2048           const
2049 
2050 #define MATCHER_P9(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, description)\
2051   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
2052       typename p3##_type, typename p4##_type, typename p5##_type, \
2053       typename p6##_type, typename p7##_type, typename p8##_type&gt;\
2054   class name##MatcherP9 {\
2055    public:\
2056     template &lt;typename arg_type&gt;\
2057     class gmock_Impl : public ::testing::MatcherInterface&lt;\
2058         GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {\
2059      public:\
2060       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
2061           p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \
2062           p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8)\
2063            : p0(::testing::internal::move(gmock_p0)), \
2064                p1(::testing::internal::move(gmock_p1)), \
2065                p2(::testing::internal::move(gmock_p2)), \
2066                p3(::testing::internal::move(gmock_p3)), \
2067                p4(::testing::internal::move(gmock_p4)), \
2068                p5(::testing::internal::move(gmock_p5)), \
2069                p6(::testing::internal::move(gmock_p6)), \
2070                p7(::testing::internal::move(gmock_p7)), \
2071                p8(::testing::internal::move(gmock_p8)) {}\
2072       virtual bool MatchAndExplain(\
2073           GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
2074           ::testing::MatchResultListener* result_listener) const;\
2075       virtual void DescribeTo(::std::ostream* gmock_os) const {\
2076         *gmock_os &lt;&lt; FormatDescription(false);\
2077       }\
2078       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\
2079         *gmock_os &lt;&lt; FormatDescription(true);\
2080       }\
2081       p0##_type const p0;\
2082       p1##_type const p1;\
2083       p2##_type const p2;\
2084       p3##_type const p3;\
2085       p4##_type const p4;\
2086       p5##_type const p5;\
2087       p6##_type const p6;\
2088       p7##_type const p7;\
2089       p8##_type const p8;\
2090      private:\
2091       ::std::string FormatDescription(bool negation) const {\
2092         ::std::string gmock_description = (description);\
2093         if (!gmock_description.empty()) {\
2094           return gmock_description;\
2095         }\
2096         return ::testing::internal::FormatMatcherDescription(\
2097             negation, #name, \
2098             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\
2099                 ::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
2100                     p4##_type, p5##_type, p6##_type, p7##_type, \
2101                     p8##_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7, p8)));\
2102       }\
2103     };\
2104     template &lt;typename arg_type&gt;\
2105     operator ::testing::Matcher&lt;arg_type&gt;() const {\
2106       return ::testing::Matcher&lt;arg_type&gt;(\
2107           new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7, p8));\
2108     }\
2109     name##MatcherP9(p0##_type gmock_p0, p1##_type gmock_p1, \
2110         p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \
2111         p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \
2112         p8##_type gmock_p8) : p0(::testing::internal::move(gmock_p0)), \
2113         p1(::testing::internal::move(gmock_p1)), \
2114         p2(::testing::internal::move(gmock_p2)), \
2115         p3(::testing::internal::move(gmock_p3)), \
2116         p4(::testing::internal::move(gmock_p4)), \
2117         p5(::testing::internal::move(gmock_p5)), \
2118         p6(::testing::internal::move(gmock_p6)), \
2119         p7(::testing::internal::move(gmock_p7)), \
2120         p8(::testing::internal::move(gmock_p8)) {\
2121     }\
2122     p0##_type const p0;\
2123     p1##_type const p1;\
2124     p2##_type const p2;\
2125     p3##_type const p3;\
2126     p4##_type const p4;\
2127     p5##_type const p5;\
2128     p6##_type const p6;\
2129     p7##_type const p7;\
2130     p8##_type const p8;\
2131    private:\
2132   };\
2133   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
2134       typename p3##_type, typename p4##_type, typename p5##_type, \
2135       typename p6##_type, typename p7##_type, typename p8##_type&gt;\
2136   inline name##MatcherP9&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
2137       p4##_type, p5##_type, p6##_type, p7##_type, \
2138       p8##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \
2139       p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, \
2140       p8##_type p8) {\
2141     return name##MatcherP9&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
2142         p4##_type, p5##_type, p6##_type, p7##_type, p8##_type&gt;(p0, p1, p2, \
2143         p3, p4, p5, p6, p7, p8);\
2144   }\
2145   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
2146       typename p3##_type, typename p4##_type, typename p5##_type, \
2147       typename p6##_type, typename p7##_type, typename p8##_type&gt;\
2148   template &lt;typename arg_type&gt;\
2149   bool name##MatcherP9&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \
2150       p5##_type, p6##_type, p7##_type, \
2151       p8##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\
2152       GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
2153       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\
2154           const
2155 
2156 #define MATCHER_P10(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, description)\
2157   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
2158       typename p3##_type, typename p4##_type, typename p5##_type, \
2159       typename p6##_type, typename p7##_type, typename p8##_type, \
2160       typename p9##_type&gt;\
2161   class name##MatcherP10 {\
2162    public:\
2163     template &lt;typename arg_type&gt;\
2164     class gmock_Impl : public ::testing::MatcherInterface&lt;\
2165         GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {\
2166      public:\
2167       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
2168           p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \
2169           p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \
2170           p9##_type gmock_p9)\
2171            : p0(::testing::internal::move(gmock_p0)), \
2172                p1(::testing::internal::move(gmock_p1)), \
2173                p2(::testing::internal::move(gmock_p2)), \
2174                p3(::testing::internal::move(gmock_p3)), \
2175                p4(::testing::internal::move(gmock_p4)), \
2176                p5(::testing::internal::move(gmock_p5)), \
2177                p6(::testing::internal::move(gmock_p6)), \
2178                p7(::testing::internal::move(gmock_p7)), \
2179                p8(::testing::internal::move(gmock_p8)), \
2180                p9(::testing::internal::move(gmock_p9)) {}\
2181       virtual bool MatchAndExplain(\
2182           GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
2183           ::testing::MatchResultListener* result_listener) const;\
2184       virtual void DescribeTo(::std::ostream* gmock_os) const {\
2185         *gmock_os &lt;&lt; FormatDescription(false);\
2186       }\
2187       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\
2188         *gmock_os &lt;&lt; FormatDescription(true);\
2189       }\
2190       p0##_type const p0;\
2191       p1##_type const p1;\
2192       p2##_type const p2;\
2193       p3##_type const p3;\
2194       p4##_type const p4;\
2195       p5##_type const p5;\
2196       p6##_type const p6;\
2197       p7##_type const p7;\
2198       p8##_type const p8;\
2199       p9##_type const p9;\
2200      private:\
2201       ::std::string FormatDescription(bool negation) const {\
2202         ::std::string gmock_description = (description);\
2203         if (!gmock_description.empty()) {\
2204           return gmock_description;\
2205         }\
2206         return ::testing::internal::FormatMatcherDescription(\
2207             negation, #name, \
2208             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\
2209                 ::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
2210                     p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \
2211                     p9##_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)));\
2212       }\
2213     };\
2214     template &lt;typename arg_type&gt;\
2215     operator ::testing::Matcher&lt;arg_type&gt;() const {\
2216       return ::testing::Matcher&lt;arg_type&gt;(\
2217           new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9));\
2218     }\
2219     name##MatcherP10(p0##_type gmock_p0, p1##_type gmock_p1, \
2220         p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \
2221         p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \
2222         p8##_type gmock_p8, \
2223         p9##_type gmock_p9) : p0(::testing::internal::move(gmock_p0)), \
2224         p1(::testing::internal::move(gmock_p1)), \
2225         p2(::testing::internal::move(gmock_p2)), \
2226         p3(::testing::internal::move(gmock_p3)), \
2227         p4(::testing::internal::move(gmock_p4)), \
2228         p5(::testing::internal::move(gmock_p5)), \
2229         p6(::testing::internal::move(gmock_p6)), \
2230         p7(::testing::internal::move(gmock_p7)), \
2231         p8(::testing::internal::move(gmock_p8)), \
2232         p9(::testing::internal::move(gmock_p9)) {\
2233     }\
2234     p0##_type const p0;\
2235     p1##_type const p1;\
2236     p2##_type const p2;\
2237     p3##_type const p3;\
2238     p4##_type const p4;\
2239     p5##_type const p5;\
2240     p6##_type const p6;\
2241     p7##_type const p7;\
2242     p8##_type const p8;\
2243     p9##_type const p9;\
2244    private:\
2245   };\
2246   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
2247       typename p3##_type, typename p4##_type, typename p5##_type, \
2248       typename p6##_type, typename p7##_type, typename p8##_type, \
2249       typename p9##_type&gt;\
2250   inline name##MatcherP10&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
2251       p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \
2252       p9##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \
2253       p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \
2254       p9##_type p9) {\
2255     return name##MatcherP10&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
2256         p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type&gt;(p0, \
2257         p1, p2, p3, p4, p5, p6, p7, p8, p9);\
2258   }\
2259   template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \
2260       typename p3##_type, typename p4##_type, typename p5##_type, \
2261       typename p6##_type, typename p7##_type, typename p8##_type, \
2262       typename p9##_type&gt;\
2263   template &lt;typename arg_type&gt;\
2264   bool name##MatcherP10&lt;p0##_type, p1##_type, p2##_type, p3##_type, \
2265       p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \
2266       p9##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\
2267       GTEST_REFERENCE_TO_CONST_(arg_type) arg,\
2268       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\
2269           const
2270 
2271 #endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_
    </pre>
  </body>
</html>
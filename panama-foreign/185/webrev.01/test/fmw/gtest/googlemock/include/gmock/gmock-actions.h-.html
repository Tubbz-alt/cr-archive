<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/googlemock/include/gmock/gmock-actions.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Copyright 2007, Google Inc.
   2 // All rights reserved.
   3 //
   4 // Redistribution and use in source and binary forms, with or without
   5 // modification, are permitted provided that the following conditions are
   6 // met:
   7 //
   8 //     * Redistributions of source code must retain the above copyright
   9 // notice, this list of conditions and the following disclaimer.
  10 //     * Redistributions in binary form must reproduce the above
  11 // copyright notice, this list of conditions and the following disclaimer
  12 // in the documentation and/or other materials provided with the
  13 // distribution.
  14 //     * Neither the name of Google Inc. nor the names of its
  15 // contributors may be used to endorse or promote products derived from
  16 // this software without specific prior written permission.
  17 //
  18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29 
  30 
  31 // Google Mock - a framework for writing C++ mock classes.
  32 //
  33 // This file implements some commonly used actions.
  34 
  35 // GOOGLETEST_CM0002 DO NOT DELETE
  36 
  37 #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
  38 #define GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
  39 
  40 #ifndef _WIN32_WCE
  41 # include &lt;errno.h&gt;
  42 #endif
  43 
  44 #include &lt;algorithm&gt;
  45 #include &lt;string&gt;
  46 
  47 #include &quot;gmock/internal/gmock-internal-utils.h&quot;
  48 #include &quot;gmock/internal/gmock-port.h&quot;
  49 
  50 #if GTEST_LANG_CXX11  // Defined by gtest-port.h via gmock-port.h.
  51 #include &lt;functional&gt;
  52 #include &lt;type_traits&gt;
  53 #endif  // GTEST_LANG_CXX11
  54 
  55 namespace testing {
  56 
  57 // To implement an action Foo, define:
  58 //   1. a class FooAction that implements the ActionInterface interface, and
  59 //   2. a factory function that creates an Action object from a
  60 //      const FooAction*.
  61 //
  62 // The two-level delegation design follows that of Matcher, providing
  63 // consistency for extension developers.  It also eases ownership
  64 // management as Action objects can now be copied like plain values.
  65 
  66 namespace internal {
  67 
  68 template &lt;typename F1, typename F2&gt;
  69 class ActionAdaptor;
  70 
  71 // BuiltInDefaultValueGetter&lt;T, true&gt;::Get() returns a
  72 // default-constructed T value.  BuiltInDefaultValueGetter&lt;T,
  73 // false&gt;::Get() crashes with an error.
  74 //
  75 // This primary template is used when kDefaultConstructible is true.
  76 template &lt;typename T, bool kDefaultConstructible&gt;
  77 struct BuiltInDefaultValueGetter {
  78   static T Get() { return T(); }
  79 };
  80 template &lt;typename T&gt;
  81 struct BuiltInDefaultValueGetter&lt;T, false&gt; {
  82   static T Get() {
  83     Assert(false, __FILE__, __LINE__,
  84            &quot;Default action undefined for the function return type.&quot;);
  85     return internal::Invalid&lt;T&gt;();
  86     // The above statement will never be reached, but is required in
  87     // order for this function to compile.
  88   }
  89 };
  90 
  91 // BuiltInDefaultValue&lt;T&gt;::Get() returns the &quot;built-in&quot; default value
  92 // for type T, which is NULL when T is a raw pointer type, 0 when T is
  93 // a numeric type, false when T is bool, or &quot;&quot; when T is string or
  94 // std::string.  In addition, in C++11 and above, it turns a
  95 // default-constructed T value if T is default constructible.  For any
  96 // other type T, the built-in default T value is undefined, and the
  97 // function will abort the process.
  98 template &lt;typename T&gt;
  99 class BuiltInDefaultValue {
 100  public:
 101 #if GTEST_LANG_CXX11
 102   // This function returns true iff type T has a built-in default value.
 103   static bool Exists() {
 104     return ::std::is_default_constructible&lt;T&gt;::value;
 105   }
 106 
 107   static T Get() {
 108     return BuiltInDefaultValueGetter&lt;
 109         T, ::std::is_default_constructible&lt;T&gt;::value&gt;::Get();
 110   }
 111 
 112 #else  // GTEST_LANG_CXX11
 113   // This function returns true iff type T has a built-in default value.
 114   static bool Exists() {
 115     return false;
 116   }
 117 
 118   static T Get() {
 119     return BuiltInDefaultValueGetter&lt;T, false&gt;::Get();
 120   }
 121 
 122 #endif  // GTEST_LANG_CXX11
 123 };
 124 
 125 // This partial specialization says that we use the same built-in
 126 // default value for T and const T.
 127 template &lt;typename T&gt;
 128 class BuiltInDefaultValue&lt;const T&gt; {
 129  public:
 130   static bool Exists() { return BuiltInDefaultValue&lt;T&gt;::Exists(); }
 131   static T Get() { return BuiltInDefaultValue&lt;T&gt;::Get(); }
 132 };
 133 
 134 // This partial specialization defines the default values for pointer
 135 // types.
 136 template &lt;typename T&gt;
 137 class BuiltInDefaultValue&lt;T*&gt; {
 138  public:
 139   static bool Exists() { return true; }
 140   static T* Get() { return NULL; }
 141 };
 142 
 143 // The following specializations define the default values for
 144 // specific types we care about.
 145 #define GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(type, value) \
 146   template &lt;&gt; \
 147   class BuiltInDefaultValue&lt;type&gt; { \
 148    public: \
 149     static bool Exists() { return true; } \
 150     static type Get() { return value; } \
 151   }
 152 
 153 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(void, );  // NOLINT
 154 #if GTEST_HAS_GLOBAL_STRING
 155 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::string, &quot;&quot;);
 156 #endif  // GTEST_HAS_GLOBAL_STRING
 157 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::std::string, &quot;&quot;);
 158 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(bool, false);
 159 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned char, &#39;\0&#39;);
 160 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed char, &#39;\0&#39;);
 161 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(char, &#39;\0&#39;);
 162 
 163 // There&#39;s no need for a default action for signed wchar_t, as that
 164 // type is the same as wchar_t for gcc, and invalid for MSVC.
 165 //
 166 // There&#39;s also no need for a default action for unsigned wchar_t, as
 167 // that type is the same as unsigned int for gcc, and invalid for
 168 // MSVC.
 169 #if GMOCK_WCHAR_T_IS_NATIVE_
 170 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(wchar_t, 0U);  // NOLINT
 171 #endif
 172 
 173 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned short, 0U);  // NOLINT
 174 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed short, 0);     // NOLINT
 175 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned int, 0U);
 176 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed int, 0);
 177 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned long, 0UL);  // NOLINT
 178 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed long, 0L);     // NOLINT
 179 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(UInt64, 0);
 180 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(Int64, 0);
 181 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(float, 0);
 182 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(double, 0);
 183 
 184 #undef GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_
 185 
 186 }  // namespace internal
 187 
 188 // When an unexpected function call is encountered, Google Mock will
 189 // let it return a default value if the user has specified one for its
 190 // return type, or if the return type has a built-in default value;
 191 // otherwise Google Mock won&#39;t know what value to return and will have
 192 // to abort the process.
 193 //
 194 // The DefaultValue&lt;T&gt; class allows a user to specify the
 195 // default value for a type T that is both copyable and publicly
 196 // destructible (i.e. anything that can be used as a function return
 197 // type).  The usage is:
 198 //
 199 //   // Sets the default value for type T to be foo.
 200 //   DefaultValue&lt;T&gt;::Set(foo);
 201 template &lt;typename T&gt;
 202 class DefaultValue {
 203  public:
 204   // Sets the default value for type T; requires T to be
 205   // copy-constructable and have a public destructor.
 206   static void Set(T x) {
 207     delete producer_;
 208     producer_ = new FixedValueProducer(x);
 209   }
 210 
 211   // Provides a factory function to be called to generate the default value.
 212   // This method can be used even if T is only move-constructible, but it is not
 213   // limited to that case.
 214   typedef T (*FactoryFunction)();
 215   static void SetFactory(FactoryFunction factory) {
 216     delete producer_;
 217     producer_ = new FactoryValueProducer(factory);
 218   }
 219 
 220   // Unsets the default value for type T.
 221   static void Clear() {
 222     delete producer_;
 223     producer_ = NULL;
 224   }
 225 
 226   // Returns true iff the user has set the default value for type T.
 227   static bool IsSet() { return producer_ != NULL; }
 228 
 229   // Returns true if T has a default return value set by the user or there
 230   // exists a built-in default value.
 231   static bool Exists() {
 232     return IsSet() || internal::BuiltInDefaultValue&lt;T&gt;::Exists();
 233   }
 234 
 235   // Returns the default value for type T if the user has set one;
 236   // otherwise returns the built-in default value. Requires that Exists()
 237   // is true, which ensures that the return value is well-defined.
 238   static T Get() {
 239     return producer_ == NULL ?
 240         internal::BuiltInDefaultValue&lt;T&gt;::Get() : producer_-&gt;Produce();
 241   }
 242 
 243  private:
 244   class ValueProducer {
 245    public:
 246     virtual ~ValueProducer() {}
 247     virtual T Produce() = 0;
 248   };
 249 
 250   class FixedValueProducer : public ValueProducer {
 251    public:
 252     explicit FixedValueProducer(T value) : value_(value) {}
 253     virtual T Produce() { return value_; }
 254 
 255    private:
 256     const T value_;
 257     GTEST_DISALLOW_COPY_AND_ASSIGN_(FixedValueProducer);
 258   };
 259 
 260   class FactoryValueProducer : public ValueProducer {
 261    public:
 262     explicit FactoryValueProducer(FactoryFunction factory)
 263         : factory_(factory) {}
 264     virtual T Produce() { return factory_(); }
 265 
 266    private:
 267     const FactoryFunction factory_;
 268     GTEST_DISALLOW_COPY_AND_ASSIGN_(FactoryValueProducer);
 269   };
 270 
 271   static ValueProducer* producer_;
 272 };
 273 
 274 // This partial specialization allows a user to set default values for
 275 // reference types.
 276 template &lt;typename T&gt;
 277 class DefaultValue&lt;T&amp;&gt; {
 278  public:
 279   // Sets the default value for type T&amp;.
 280   static void Set(T&amp; x) {  // NOLINT
 281     address_ = &amp;x;
 282   }
 283 
 284   // Unsets the default value for type T&amp;.
 285   static void Clear() {
 286     address_ = NULL;
 287   }
 288 
 289   // Returns true iff the user has set the default value for type T&amp;.
 290   static bool IsSet() { return address_ != NULL; }
 291 
 292   // Returns true if T has a default return value set by the user or there
 293   // exists a built-in default value.
 294   static bool Exists() {
 295     return IsSet() || internal::BuiltInDefaultValue&lt;T&amp;&gt;::Exists();
 296   }
 297 
 298   // Returns the default value for type T&amp; if the user has set one;
 299   // otherwise returns the built-in default value if there is one;
 300   // otherwise aborts the process.
 301   static T&amp; Get() {
 302     return address_ == NULL ?
 303         internal::BuiltInDefaultValue&lt;T&amp;&gt;::Get() : *address_;
 304   }
 305 
 306  private:
 307   static T* address_;
 308 };
 309 
 310 // This specialization allows DefaultValue&lt;void&gt;::Get() to
 311 // compile.
 312 template &lt;&gt;
 313 class DefaultValue&lt;void&gt; {
 314  public:
 315   static bool Exists() { return true; }
 316   static void Get() {}
 317 };
 318 
 319 // Points to the user-set default value for type T.
 320 template &lt;typename T&gt;
 321 typename DefaultValue&lt;T&gt;::ValueProducer* DefaultValue&lt;T&gt;::producer_ = NULL;
 322 
 323 // Points to the user-set default value for type T&amp;.
 324 template &lt;typename T&gt;
 325 T* DefaultValue&lt;T&amp;&gt;::address_ = NULL;
 326 
 327 // Implement this interface to define an action for function type F.
 328 template &lt;typename F&gt;
 329 class ActionInterface {
 330  public:
 331   typedef typename internal::Function&lt;F&gt;::Result Result;
 332   typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
 333 
 334   ActionInterface() {}
 335   virtual ~ActionInterface() {}
 336 
 337   // Performs the action.  This method is not const, as in general an
 338   // action can have side effects and be stateful.  For example, a
 339   // get-the-next-element-from-the-collection action will need to
 340   // remember the current element.
 341   virtual Result Perform(const ArgumentTuple&amp; args) = 0;
 342 
 343  private:
 344   GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionInterface);
 345 };
 346 
 347 // An Action&lt;F&gt; is a copyable and IMMUTABLE (except by assignment)
 348 // object that represents an action to be taken when a mock function
 349 // of type F is called.  The implementation of Action&lt;T&gt; is just a
 350 // linked_ptr to const ActionInterface&lt;T&gt;, so copying is fairly cheap.
 351 // Don&#39;t inherit from Action!
 352 //
 353 // You can view an object implementing ActionInterface&lt;F&gt; as a
 354 // concrete action (including its current state), and an Action&lt;F&gt;
 355 // object as a handle to it.
 356 template &lt;typename F&gt;
 357 class Action {
 358  public:
 359   typedef typename internal::Function&lt;F&gt;::Result Result;
 360   typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
 361 
 362   // Constructs a null Action.  Needed for storing Action objects in
 363   // STL containers.
 364   Action() {}
 365 
 366 #if GTEST_LANG_CXX11
 367   // Construct an Action from a specified callable.
 368   // This cannot take std::function directly, because then Action would not be
 369   // directly constructible from lambda (it would require two conversions).
 370   template &lt;typename G,
 371             typename = typename ::std::enable_if&lt;
 372                 ::std::is_constructible&lt;::std::function&lt;F&gt;, G&gt;::value&gt;::type&gt;
 373   Action(G&amp;&amp; fun) : fun_(::std::forward&lt;G&gt;(fun)) {}  // NOLINT
 374 #endif
 375 
 376   // Constructs an Action from its implementation.
 377   explicit Action(ActionInterface&lt;F&gt;* impl) : impl_(impl) {}
 378 
 379   // This constructor allows us to turn an Action&lt;Func&gt; object into an
 380   // Action&lt;F&gt;, as long as F&#39;s arguments can be implicitly converted
 381   // to Func&#39;s and Func&#39;s return type can be implicitly converted to
 382   // F&#39;s.
 383   template &lt;typename Func&gt;
 384   explicit Action(const Action&lt;Func&gt;&amp; action);
 385 
 386   // Returns true iff this is the DoDefault() action.
 387   bool IsDoDefault() const {
 388 #if GTEST_LANG_CXX11
 389     return impl_ == nullptr &amp;&amp; fun_ == nullptr;
 390 #else
 391     return impl_ == NULL;
 392 #endif
 393   }
 394 
 395   // Performs the action.  Note that this method is const even though
 396   // the corresponding method in ActionInterface is not.  The reason
 397   // is that a const Action&lt;F&gt; means that it cannot be re-bound to
 398   // another concrete action, not that the concrete action it binds to
 399   // cannot change state.  (Think of the difference between a const
 400   // pointer and a pointer to const.)
 401   Result Perform(ArgumentTuple args) const {
 402     if (IsDoDefault()) {
 403       internal::IllegalDoDefault(__FILE__, __LINE__);
 404     }
 405 #if GTEST_LANG_CXX11
 406     if (fun_ != nullptr) {
 407       return internal::Apply(fun_, ::std::move(args));
 408     }
 409 #endif
 410     return impl_-&gt;Perform(args);
 411   }
 412 
 413  private:
 414   template &lt;typename F1, typename F2&gt;
 415   friend class internal::ActionAdaptor;
 416 
 417   template &lt;typename G&gt;
 418   friend class Action;
 419 
 420   // In C++11, Action can be implemented either as a generic functor (through
 421   // std::function), or legacy ActionInterface. In C++98, only ActionInterface
 422   // is available. The invariants are as follows:
 423   // * in C++98, impl_ is null iff this is the default action
 424   // * in C++11, at most one of fun_ &amp; impl_ may be nonnull; both are null iff
 425   //   this is the default action
 426 #if GTEST_LANG_CXX11
 427   ::std::function&lt;F&gt; fun_;
 428 #endif
 429   internal::linked_ptr&lt;ActionInterface&lt;F&gt; &gt; impl_;
 430 };
 431 
 432 // The PolymorphicAction class template makes it easy to implement a
 433 // polymorphic action (i.e. an action that can be used in mock
 434 // functions of than one type, e.g. Return()).
 435 //
 436 // To define a polymorphic action, a user first provides a COPYABLE
 437 // implementation class that has a Perform() method template:
 438 //
 439 //   class FooAction {
 440 //    public:
 441 //     template &lt;typename Result, typename ArgumentTuple&gt;
 442 //     Result Perform(const ArgumentTuple&amp; args) const {
 443 //       // Processes the arguments and returns a result, using
 444 //       // tr1::get&lt;N&gt;(args) to get the N-th (0-based) argument in the tuple.
 445 //     }
 446 //     ...
 447 //   };
 448 //
 449 // Then the user creates the polymorphic action using
 450 // MakePolymorphicAction(object) where object has type FooAction.  See
 451 // the definition of Return(void) and SetArgumentPointee&lt;N&gt;(value) for
 452 // complete examples.
 453 template &lt;typename Impl&gt;
 454 class PolymorphicAction {
 455  public:
 456   explicit PolymorphicAction(const Impl&amp; impl) : impl_(impl) {}
 457 
 458   template &lt;typename F&gt;
 459   operator Action&lt;F&gt;() const {
 460     return Action&lt;F&gt;(new MonomorphicImpl&lt;F&gt;(impl_));
 461   }
 462 
 463  private:
 464   template &lt;typename F&gt;
 465   class MonomorphicImpl : public ActionInterface&lt;F&gt; {
 466    public:
 467     typedef typename internal::Function&lt;F&gt;::Result Result;
 468     typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
 469 
 470     explicit MonomorphicImpl(const Impl&amp; impl) : impl_(impl) {}
 471 
 472     virtual Result Perform(const ArgumentTuple&amp; args) {
 473       return impl_.template Perform&lt;Result&gt;(args);
 474     }
 475 
 476    private:
 477     Impl impl_;
 478 
 479     GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);
 480   };
 481 
 482   Impl impl_;
 483 
 484   GTEST_DISALLOW_ASSIGN_(PolymorphicAction);
 485 };
 486 
 487 // Creates an Action from its implementation and returns it.  The
 488 // created Action object owns the implementation.
 489 template &lt;typename F&gt;
 490 Action&lt;F&gt; MakeAction(ActionInterface&lt;F&gt;* impl) {
 491   return Action&lt;F&gt;(impl);
 492 }
 493 
 494 // Creates a polymorphic action from its implementation.  This is
 495 // easier to use than the PolymorphicAction&lt;Impl&gt; constructor as it
 496 // doesn&#39;t require you to explicitly write the template argument, e.g.
 497 //
 498 //   MakePolymorphicAction(foo);
 499 // vs
 500 //   PolymorphicAction&lt;TypeOfFoo&gt;(foo);
 501 template &lt;typename Impl&gt;
 502 inline PolymorphicAction&lt;Impl&gt; MakePolymorphicAction(const Impl&amp; impl) {
 503   return PolymorphicAction&lt;Impl&gt;(impl);
 504 }
 505 
 506 namespace internal {
 507 
 508 // Allows an Action&lt;F2&gt; object to pose as an Action&lt;F1&gt;, as long as F2
 509 // and F1 are compatible.
 510 template &lt;typename F1, typename F2&gt;
 511 class ActionAdaptor : public ActionInterface&lt;F1&gt; {
 512  public:
 513   typedef typename internal::Function&lt;F1&gt;::Result Result;
 514   typedef typename internal::Function&lt;F1&gt;::ArgumentTuple ArgumentTuple;
 515 
 516   explicit ActionAdaptor(const Action&lt;F2&gt;&amp; from) : impl_(from.impl_) {}
 517 
 518   virtual Result Perform(const ArgumentTuple&amp; args) {
 519     return impl_-&gt;Perform(args);
 520   }
 521 
 522  private:
 523   const internal::linked_ptr&lt;ActionInterface&lt;F2&gt; &gt; impl_;
 524 
 525   GTEST_DISALLOW_ASSIGN_(ActionAdaptor);
 526 };
 527 
 528 // Helper struct to specialize ReturnAction to execute a move instead of a copy
 529 // on return. Useful for move-only types, but could be used on any type.
 530 template &lt;typename T&gt;
 531 struct ByMoveWrapper {
 532   explicit ByMoveWrapper(T value) : payload(internal::move(value)) {}
 533   T payload;
 534 };
 535 
 536 // Implements the polymorphic Return(x) action, which can be used in
 537 // any function that returns the type of x, regardless of the argument
 538 // types.
 539 //
 540 // Note: The value passed into Return must be converted into
 541 // Function&lt;F&gt;::Result when this action is cast to Action&lt;F&gt; rather than
 542 // when that action is performed. This is important in scenarios like
 543 //
 544 // MOCK_METHOD1(Method, T(U));
 545 // ...
 546 // {
 547 //   Foo foo;
 548 //   X x(&amp;foo);
 549 //   EXPECT_CALL(mock, Method(_)).WillOnce(Return(x));
 550 // }
 551 //
 552 // In the example above the variable x holds reference to foo which leaves
 553 // scope and gets destroyed.  If copying X just copies a reference to foo,
 554 // that copy will be left with a hanging reference.  If conversion to T
 555 // makes a copy of foo, the above code is safe. To support that scenario, we
 556 // need to make sure that the type conversion happens inside the EXPECT_CALL
 557 // statement, and conversion of the result of Return to Action&lt;T(U)&gt; is a
 558 // good place for that.
 559 //
 560 // The real life example of the above scenario happens when an invocation
 561 // of gtl::Container() is passed into Return.
 562 //
 563 template &lt;typename R&gt;
 564 class ReturnAction {
 565  public:
 566   // Constructs a ReturnAction object from the value to be returned.
 567   // &#39;value&#39; is passed by value instead of by const reference in order
 568   // to allow Return(&quot;string literal&quot;) to compile.
 569   explicit ReturnAction(R value) : value_(new R(internal::move(value))) {}
 570 
 571   // This template type conversion operator allows Return(x) to be
 572   // used in ANY function that returns x&#39;s type.
 573   template &lt;typename F&gt;
 574   operator Action&lt;F&gt;() const {
 575     // Assert statement belongs here because this is the best place to verify
 576     // conditions on F. It produces the clearest error messages
 577     // in most compilers.
 578     // Impl really belongs in this scope as a local class but can&#39;t
 579     // because MSVC produces duplicate symbols in different translation units
 580     // in this case. Until MS fixes that bug we put Impl into the class scope
 581     // and put the typedef both here (for use in assert statement) and
 582     // in the Impl class. But both definitions must be the same.
 583     typedef typename Function&lt;F&gt;::Result Result;
 584     GTEST_COMPILE_ASSERT_(
 585         !is_reference&lt;Result&gt;::value,
 586         use_ReturnRef_instead_of_Return_to_return_a_reference);
 587     return Action&lt;F&gt;(new Impl&lt;R, F&gt;(value_));
 588   }
 589 
 590  private:
 591   // Implements the Return(x) action for a particular function type F.
 592   template &lt;typename R_, typename F&gt;
 593   class Impl : public ActionInterface&lt;F&gt; {
 594    public:
 595     typedef typename Function&lt;F&gt;::Result Result;
 596     typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
 597 
 598     // The implicit cast is necessary when Result has more than one
 599     // single-argument constructor (e.g. Result is std::vector&lt;int&gt;) and R
 600     // has a type conversion operator template.  In that case, value_(value)
 601     // won&#39;t compile as the compiler doesn&#39;t known which constructor of
 602     // Result to call.  ImplicitCast_ forces the compiler to convert R to
 603     // Result without considering explicit constructors, thus resolving the
 604     // ambiguity. value_ is then initialized using its copy constructor.
 605     explicit Impl(const linked_ptr&lt;R&gt;&amp; value)
 606         : value_before_cast_(*value),
 607           value_(ImplicitCast_&lt;Result&gt;(value_before_cast_)) {}
 608 
 609     virtual Result Perform(const ArgumentTuple&amp;) { return value_; }
 610 
 611    private:
 612     GTEST_COMPILE_ASSERT_(!is_reference&lt;Result&gt;::value,
 613                           Result_cannot_be_a_reference_type);
 614     // We save the value before casting just in case it is being cast to a
 615     // wrapper type.
 616     R value_before_cast_;
 617     Result value_;
 618 
 619     GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);
 620   };
 621 
 622   // Partially specialize for ByMoveWrapper. This version of ReturnAction will
 623   // move its contents instead.
 624   template &lt;typename R_, typename F&gt;
 625   class Impl&lt;ByMoveWrapper&lt;R_&gt;, F&gt; : public ActionInterface&lt;F&gt; {
 626    public:
 627     typedef typename Function&lt;F&gt;::Result Result;
 628     typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
 629 
 630     explicit Impl(const linked_ptr&lt;R&gt;&amp; wrapper)
 631         : performed_(false), wrapper_(wrapper) {}
 632 
 633     virtual Result Perform(const ArgumentTuple&amp;) {
 634       GTEST_CHECK_(!performed_)
 635           &lt;&lt; &quot;A ByMove() action should only be performed once.&quot;;
 636       performed_ = true;
 637       return internal::move(wrapper_-&gt;payload);
 638     }
 639 
 640    private:
 641     bool performed_;
 642     const linked_ptr&lt;R&gt; wrapper_;
 643 
 644     GTEST_DISALLOW_ASSIGN_(Impl);
 645   };
 646 
 647   const linked_ptr&lt;R&gt; value_;
 648 
 649   GTEST_DISALLOW_ASSIGN_(ReturnAction);
 650 };
 651 
 652 // Implements the ReturnNull() action.
 653 class ReturnNullAction {
 654  public:
 655   // Allows ReturnNull() to be used in any pointer-returning function. In C++11
 656   // this is enforced by returning nullptr, and in non-C++11 by asserting a
 657   // pointer type on compile time.
 658   template &lt;typename Result, typename ArgumentTuple&gt;
 659   static Result Perform(const ArgumentTuple&amp;) {
 660 #if GTEST_LANG_CXX11
 661     return nullptr;
 662 #else
 663     GTEST_COMPILE_ASSERT_(internal::is_pointer&lt;Result&gt;::value,
 664                           ReturnNull_can_be_used_to_return_a_pointer_only);
 665     return NULL;
 666 #endif  // GTEST_LANG_CXX11
 667   }
 668 };
 669 
 670 // Implements the Return() action.
 671 class ReturnVoidAction {
 672  public:
 673   // Allows Return() to be used in any void-returning function.
 674   template &lt;typename Result, typename ArgumentTuple&gt;
 675   static void Perform(const ArgumentTuple&amp;) {
 676     CompileAssertTypesEqual&lt;void, Result&gt;();
 677   }
 678 };
 679 
 680 // Implements the polymorphic ReturnRef(x) action, which can be used
 681 // in any function that returns a reference to the type of x,
 682 // regardless of the argument types.
 683 template &lt;typename T&gt;
 684 class ReturnRefAction {
 685  public:
 686   // Constructs a ReturnRefAction object from the reference to be returned.
 687   explicit ReturnRefAction(T&amp; ref) : ref_(ref) {}  // NOLINT
 688 
 689   // This template type conversion operator allows ReturnRef(x) to be
 690   // used in ANY function that returns a reference to x&#39;s type.
 691   template &lt;typename F&gt;
 692   operator Action&lt;F&gt;() const {
 693     typedef typename Function&lt;F&gt;::Result Result;
 694     // Asserts that the function return type is a reference.  This
 695     // catches the user error of using ReturnRef(x) when Return(x)
 696     // should be used, and generates some helpful error message.
 697     GTEST_COMPILE_ASSERT_(internal::is_reference&lt;Result&gt;::value,
 698                           use_Return_instead_of_ReturnRef_to_return_a_value);
 699     return Action&lt;F&gt;(new Impl&lt;F&gt;(ref_));
 700   }
 701 
 702  private:
 703   // Implements the ReturnRef(x) action for a particular function type F.
 704   template &lt;typename F&gt;
 705   class Impl : public ActionInterface&lt;F&gt; {
 706    public:
 707     typedef typename Function&lt;F&gt;::Result Result;
 708     typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
 709 
 710     explicit Impl(T&amp; ref) : ref_(ref) {}  // NOLINT
 711 
 712     virtual Result Perform(const ArgumentTuple&amp;) {
 713       return ref_;
 714     }
 715 
 716    private:
 717     T&amp; ref_;
 718 
 719     GTEST_DISALLOW_ASSIGN_(Impl);
 720   };
 721 
 722   T&amp; ref_;
 723 
 724   GTEST_DISALLOW_ASSIGN_(ReturnRefAction);
 725 };
 726 
 727 // Implements the polymorphic ReturnRefOfCopy(x) action, which can be
 728 // used in any function that returns a reference to the type of x,
 729 // regardless of the argument types.
 730 template &lt;typename T&gt;
 731 class ReturnRefOfCopyAction {
 732  public:
 733   // Constructs a ReturnRefOfCopyAction object from the reference to
 734   // be returned.
 735   explicit ReturnRefOfCopyAction(const T&amp; value) : value_(value) {}  // NOLINT
 736 
 737   // This template type conversion operator allows ReturnRefOfCopy(x) to be
 738   // used in ANY function that returns a reference to x&#39;s type.
 739   template &lt;typename F&gt;
 740   operator Action&lt;F&gt;() const {
 741     typedef typename Function&lt;F&gt;::Result Result;
 742     // Asserts that the function return type is a reference.  This
 743     // catches the user error of using ReturnRefOfCopy(x) when Return(x)
 744     // should be used, and generates some helpful error message.
 745     GTEST_COMPILE_ASSERT_(
 746         internal::is_reference&lt;Result&gt;::value,
 747         use_Return_instead_of_ReturnRefOfCopy_to_return_a_value);
 748     return Action&lt;F&gt;(new Impl&lt;F&gt;(value_));
 749   }
 750 
 751  private:
 752   // Implements the ReturnRefOfCopy(x) action for a particular function type F.
 753   template &lt;typename F&gt;
 754   class Impl : public ActionInterface&lt;F&gt; {
 755    public:
 756     typedef typename Function&lt;F&gt;::Result Result;
 757     typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
 758 
 759     explicit Impl(const T&amp; value) : value_(value) {}  // NOLINT
 760 
 761     virtual Result Perform(const ArgumentTuple&amp;) {
 762       return value_;
 763     }
 764 
 765    private:
 766     T value_;
 767 
 768     GTEST_DISALLOW_ASSIGN_(Impl);
 769   };
 770 
 771   const T value_;
 772 
 773   GTEST_DISALLOW_ASSIGN_(ReturnRefOfCopyAction);
 774 };
 775 
 776 // Implements the polymorphic DoDefault() action.
 777 class DoDefaultAction {
 778  public:
 779   // This template type conversion operator allows DoDefault() to be
 780   // used in any function.
 781   template &lt;typename F&gt;
 782   operator Action&lt;F&gt;() const { return Action&lt;F&gt;(); }  // NOLINT
 783 };
 784 
 785 // Implements the Assign action to set a given pointer referent to a
 786 // particular value.
 787 template &lt;typename T1, typename T2&gt;
 788 class AssignAction {
 789  public:
 790   AssignAction(T1* ptr, T2 value) : ptr_(ptr), value_(value) {}
 791 
 792   template &lt;typename Result, typename ArgumentTuple&gt;
 793   void Perform(const ArgumentTuple&amp; /* args */) const {
 794     *ptr_ = value_;
 795   }
 796 
 797  private:
 798   T1* const ptr_;
 799   const T2 value_;
 800 
 801   GTEST_DISALLOW_ASSIGN_(AssignAction);
 802 };
 803 
 804 #if !GTEST_OS_WINDOWS_MOBILE
 805 
 806 // Implements the SetErrnoAndReturn action to simulate return from
 807 // various system calls and libc functions.
 808 template &lt;typename T&gt;
 809 class SetErrnoAndReturnAction {
 810  public:
 811   SetErrnoAndReturnAction(int errno_value, T result)
 812       : errno_(errno_value),
 813         result_(result) {}
 814   template &lt;typename Result, typename ArgumentTuple&gt;
 815   Result Perform(const ArgumentTuple&amp; /* args */) const {
 816     errno = errno_;
 817     return result_;
 818   }
 819 
 820  private:
 821   const int errno_;
 822   const T result_;
 823 
 824   GTEST_DISALLOW_ASSIGN_(SetErrnoAndReturnAction);
 825 };
 826 
 827 #endif  // !GTEST_OS_WINDOWS_MOBILE
 828 
 829 // Implements the SetArgumentPointee&lt;N&gt;(x) action for any function
 830 // whose N-th argument (0-based) is a pointer to x&#39;s type.  The
 831 // template parameter kIsProto is true iff type A is ProtocolMessage,
 832 // proto2::Message, or a sub-class of those.
 833 template &lt;size_t N, typename A, bool kIsProto&gt;
 834 class SetArgumentPointeeAction {
 835  public:
 836   // Constructs an action that sets the variable pointed to by the
 837   // N-th function argument to &#39;value&#39;.
 838   explicit SetArgumentPointeeAction(const A&amp; value) : value_(value) {}
 839 
 840   template &lt;typename Result, typename ArgumentTuple&gt;
 841   void Perform(const ArgumentTuple&amp; args) const {
 842     CompileAssertTypesEqual&lt;void, Result&gt;();
 843     *::testing::get&lt;N&gt;(args) = value_;
 844   }
 845 
 846  private:
 847   const A value_;
 848 
 849   GTEST_DISALLOW_ASSIGN_(SetArgumentPointeeAction);
 850 };
 851 
 852 template &lt;size_t N, typename Proto&gt;
 853 class SetArgumentPointeeAction&lt;N, Proto, true&gt; {
 854  public:
 855   // Constructs an action that sets the variable pointed to by the
 856   // N-th function argument to &#39;proto&#39;.  Both ProtocolMessage and
 857   // proto2::Message have the CopyFrom() method, so the same
 858   // implementation works for both.
 859   explicit SetArgumentPointeeAction(const Proto&amp; proto) : proto_(new Proto) {
 860     proto_-&gt;CopyFrom(proto);
 861   }
 862 
 863   template &lt;typename Result, typename ArgumentTuple&gt;
 864   void Perform(const ArgumentTuple&amp; args) const {
 865     CompileAssertTypesEqual&lt;void, Result&gt;();
 866     ::testing::get&lt;N&gt;(args)-&gt;CopyFrom(*proto_);
 867   }
 868 
 869  private:
 870   const internal::linked_ptr&lt;Proto&gt; proto_;
 871 
 872   GTEST_DISALLOW_ASSIGN_(SetArgumentPointeeAction);
 873 };
 874 
 875 // Implements the InvokeWithoutArgs(f) action.  The template argument
 876 // FunctionImpl is the implementation type of f, which can be either a
 877 // function pointer or a functor.  InvokeWithoutArgs(f) can be used as an
 878 // Action&lt;F&gt; as long as f&#39;s type is compatible with F (i.e. f can be
 879 // assigned to a tr1::function&lt;F&gt;).
 880 template &lt;typename FunctionImpl&gt;
 881 class InvokeWithoutArgsAction {
 882  public:
 883   // The c&#39;tor makes a copy of function_impl (either a function
 884   // pointer or a functor).
 885   explicit InvokeWithoutArgsAction(FunctionImpl function_impl)
 886       : function_impl_(function_impl) {}
 887 
 888   // Allows InvokeWithoutArgs(f) to be used as any action whose type is
 889   // compatible with f.
 890   template &lt;typename Result, typename ArgumentTuple&gt;
 891   Result Perform(const ArgumentTuple&amp;) { return function_impl_(); }
 892 
 893  private:
 894   FunctionImpl function_impl_;
 895 
 896   GTEST_DISALLOW_ASSIGN_(InvokeWithoutArgsAction);
 897 };
 898 
 899 // Implements the InvokeWithoutArgs(object_ptr, &amp;Class::Method) action.
 900 template &lt;class Class, typename MethodPtr&gt;
 901 class InvokeMethodWithoutArgsAction {
 902  public:
 903   InvokeMethodWithoutArgsAction(Class* obj_ptr, MethodPtr method_ptr)
 904       : obj_ptr_(obj_ptr), method_ptr_(method_ptr) {}
 905 
 906   template &lt;typename Result, typename ArgumentTuple&gt;
 907   Result Perform(const ArgumentTuple&amp;) const {
 908     return (obj_ptr_-&gt;*method_ptr_)();
 909   }
 910 
 911  private:
 912   Class* const obj_ptr_;
 913   const MethodPtr method_ptr_;
 914 
 915   GTEST_DISALLOW_ASSIGN_(InvokeMethodWithoutArgsAction);
 916 };
 917 
 918 // Implements the InvokeWithoutArgs(callback) action.
 919 template &lt;typename CallbackType&gt;
 920 class InvokeCallbackWithoutArgsAction {
 921  public:
 922   // The c&#39;tor takes ownership of the callback.
 923   explicit InvokeCallbackWithoutArgsAction(CallbackType* callback)
 924       : callback_(callback) {
 925     callback-&gt;CheckIsRepeatable();  // Makes sure the callback is permanent.
 926   }
 927 
 928   // This type conversion operator template allows Invoke(callback) to
 929   // be used wherever the callback&#39;s return type can be implicitly
 930   // converted to that of the mock function.
 931   template &lt;typename Result, typename ArgumentTuple&gt;
 932   Result Perform(const ArgumentTuple&amp;) const { return callback_-&gt;Run(); }
 933 
 934  private:
 935   const internal::linked_ptr&lt;CallbackType&gt; callback_;
 936 
 937   GTEST_DISALLOW_ASSIGN_(InvokeCallbackWithoutArgsAction);
 938 };
 939 
 940 // Implements the IgnoreResult(action) action.
 941 template &lt;typename A&gt;
 942 class IgnoreResultAction {
 943  public:
 944   explicit IgnoreResultAction(const A&amp; action) : action_(action) {}
 945 
 946   template &lt;typename F&gt;
 947   operator Action&lt;F&gt;() const {
 948     // Assert statement belongs here because this is the best place to verify
 949     // conditions on F. It produces the clearest error messages
 950     // in most compilers.
 951     // Impl really belongs in this scope as a local class but can&#39;t
 952     // because MSVC produces duplicate symbols in different translation units
 953     // in this case. Until MS fixes that bug we put Impl into the class scope
 954     // and put the typedef both here (for use in assert statement) and
 955     // in the Impl class. But both definitions must be the same.
 956     typedef typename internal::Function&lt;F&gt;::Result Result;
 957 
 958     // Asserts at compile time that F returns void.
 959     CompileAssertTypesEqual&lt;void, Result&gt;();
 960 
 961     return Action&lt;F&gt;(new Impl&lt;F&gt;(action_));
 962   }
 963 
 964  private:
 965   template &lt;typename F&gt;
 966   class Impl : public ActionInterface&lt;F&gt; {
 967    public:
 968     typedef typename internal::Function&lt;F&gt;::Result Result;
 969     typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
 970 
 971     explicit Impl(const A&amp; action) : action_(action) {}
 972 
 973     virtual void Perform(const ArgumentTuple&amp; args) {
 974       // Performs the action and ignores its result.
 975       action_.Perform(args);
 976     }
 977 
 978    private:
 979     // Type OriginalFunction is the same as F except that its return
 980     // type is IgnoredValue.
 981     typedef typename internal::Function&lt;F&gt;::MakeResultIgnoredValue
 982         OriginalFunction;
 983 
 984     const Action&lt;OriginalFunction&gt; action_;
 985 
 986     GTEST_DISALLOW_ASSIGN_(Impl);
 987   };
 988 
 989   const A action_;
 990 
 991   GTEST_DISALLOW_ASSIGN_(IgnoreResultAction);
 992 };
 993 
 994 // A ReferenceWrapper&lt;T&gt; object represents a reference to type T,
 995 // which can be either const or not.  It can be explicitly converted
 996 // from, and implicitly converted to, a T&amp;.  Unlike a reference,
 997 // ReferenceWrapper&lt;T&gt; can be copied and can survive template type
 998 // inference.  This is used to support by-reference arguments in the
 999 // InvokeArgument&lt;N&gt;(...) action.  The idea was from &quot;reference
1000 // wrappers&quot; in tr1, which we don&#39;t have in our source tree yet.
1001 template &lt;typename T&gt;
1002 class ReferenceWrapper {
1003  public:
1004   // Constructs a ReferenceWrapper&lt;T&gt; object from a T&amp;.
1005   explicit ReferenceWrapper(T&amp; l_value) : pointer_(&amp;l_value) {}  // NOLINT
1006 
1007   // Allows a ReferenceWrapper&lt;T&gt; object to be implicitly converted to
1008   // a T&amp;.
1009   operator T&amp;() const { return *pointer_; }
1010  private:
1011   T* pointer_;
1012 };
1013 
1014 // Allows the expression ByRef(x) to be printed as a reference to x.
1015 template &lt;typename T&gt;
1016 void PrintTo(const ReferenceWrapper&lt;T&gt;&amp; ref, ::std::ostream* os) {
1017   T&amp; value = ref;
1018   UniversalPrinter&lt;T&amp;&gt;::Print(value, os);
1019 }
1020 
1021 // Does two actions sequentially.  Used for implementing the DoAll(a1,
1022 // a2, ...) action.
1023 template &lt;typename Action1, typename Action2&gt;
1024 class DoBothAction {
1025  public:
1026   DoBothAction(Action1 action1, Action2 action2)
1027       : action1_(action1), action2_(action2) {}
1028 
1029   // This template type conversion operator allows DoAll(a1, ..., a_n)
1030   // to be used in ANY function of compatible type.
1031   template &lt;typename F&gt;
1032   operator Action&lt;F&gt;() const {
1033     return Action&lt;F&gt;(new Impl&lt;F&gt;(action1_, action2_));
1034   }
1035 
1036  private:
1037   // Implements the DoAll(...) action for a particular function type F.
1038   template &lt;typename F&gt;
1039   class Impl : public ActionInterface&lt;F&gt; {
1040    public:
1041     typedef typename Function&lt;F&gt;::Result Result;
1042     typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
1043     typedef typename Function&lt;F&gt;::MakeResultVoid VoidResult;
1044 
1045     Impl(const Action&lt;VoidResult&gt;&amp; action1, const Action&lt;F&gt;&amp; action2)
1046         : action1_(action1), action2_(action2) {}
1047 
1048     virtual Result Perform(const ArgumentTuple&amp; args) {
1049       action1_.Perform(args);
1050       return action2_.Perform(args);
1051     }
1052 
1053    private:
1054     const Action&lt;VoidResult&gt; action1_;
1055     const Action&lt;F&gt; action2_;
1056 
1057     GTEST_DISALLOW_ASSIGN_(Impl);
1058   };
1059 
1060   Action1 action1_;
1061   Action2 action2_;
1062 
1063   GTEST_DISALLOW_ASSIGN_(DoBothAction);
1064 };
1065 
1066 }  // namespace internal
1067 
1068 // An Unused object can be implicitly constructed from ANY value.
1069 // This is handy when defining actions that ignore some or all of the
1070 // mock function arguments.  For example, given
1071 //
1072 //   MOCK_METHOD3(Foo, double(const string&amp; label, double x, double y));
1073 //   MOCK_METHOD3(Bar, double(int index, double x, double y));
1074 //
1075 // instead of
1076 //
1077 //   double DistanceToOriginWithLabel(const string&amp; label, double x, double y) {
1078 //     return sqrt(x*x + y*y);
1079 //   }
1080 //   double DistanceToOriginWithIndex(int index, double x, double y) {
1081 //     return sqrt(x*x + y*y);
1082 //   }
1083 //   ...
1084 //   EXPECT_CALL(mock, Foo(&quot;abc&quot;, _, _))
1085 //       .WillOnce(Invoke(DistanceToOriginWithLabel));
1086 //   EXPECT_CALL(mock, Bar(5, _, _))
1087 //       .WillOnce(Invoke(DistanceToOriginWithIndex));
1088 //
1089 // you could write
1090 //
1091 //   // We can declare any uninteresting argument as Unused.
1092 //   double DistanceToOrigin(Unused, double x, double y) {
1093 //     return sqrt(x*x + y*y);
1094 //   }
1095 //   ...
1096 //   EXPECT_CALL(mock, Foo(&quot;abc&quot;, _, _)).WillOnce(Invoke(DistanceToOrigin));
1097 //   EXPECT_CALL(mock, Bar(5, _, _)).WillOnce(Invoke(DistanceToOrigin));
1098 typedef internal::IgnoredValue Unused;
1099 
1100 // This constructor allows us to turn an Action&lt;From&gt; object into an
1101 // Action&lt;To&gt;, as long as To&#39;s arguments can be implicitly converted
1102 // to From&#39;s and From&#39;s return type cann be implicitly converted to
1103 // To&#39;s.
1104 template &lt;typename To&gt;
1105 template &lt;typename From&gt;
1106 Action&lt;To&gt;::Action(const Action&lt;From&gt;&amp; from)
1107     :
1108 #if GTEST_LANG_CXX11
1109       fun_(from.fun_),
1110 #endif
1111       impl_(from.impl_ == NULL ? NULL
1112                                : new internal::ActionAdaptor&lt;To, From&gt;(from)) {
1113 }
1114 
1115 // Creates an action that returns &#39;value&#39;.  &#39;value&#39; is passed by value
1116 // instead of const reference - otherwise Return(&quot;string literal&quot;)
1117 // will trigger a compiler error about using array as initializer.
1118 template &lt;typename R&gt;
1119 internal::ReturnAction&lt;R&gt; Return(R value) {
1120   return internal::ReturnAction&lt;R&gt;(internal::move(value));
1121 }
1122 
1123 // Creates an action that returns NULL.
1124 inline PolymorphicAction&lt;internal::ReturnNullAction&gt; ReturnNull() {
1125   return MakePolymorphicAction(internal::ReturnNullAction());
1126 }
1127 
1128 // Creates an action that returns from a void function.
1129 inline PolymorphicAction&lt;internal::ReturnVoidAction&gt; Return() {
1130   return MakePolymorphicAction(internal::ReturnVoidAction());
1131 }
1132 
1133 // Creates an action that returns the reference to a variable.
1134 template &lt;typename R&gt;
1135 inline internal::ReturnRefAction&lt;R&gt; ReturnRef(R&amp; x) {  // NOLINT
1136   return internal::ReturnRefAction&lt;R&gt;(x);
1137 }
1138 
1139 // Creates an action that returns the reference to a copy of the
1140 // argument.  The copy is created when the action is constructed and
1141 // lives as long as the action.
1142 template &lt;typename R&gt;
1143 inline internal::ReturnRefOfCopyAction&lt;R&gt; ReturnRefOfCopy(const R&amp; x) {
1144   return internal::ReturnRefOfCopyAction&lt;R&gt;(x);
1145 }
1146 
1147 // Modifies the parent action (a Return() action) to perform a move of the
1148 // argument instead of a copy.
1149 // Return(ByMove()) actions can only be executed once and will assert this
1150 // invariant.
1151 template &lt;typename R&gt;
1152 internal::ByMoveWrapper&lt;R&gt; ByMove(R x) {
1153   return internal::ByMoveWrapper&lt;R&gt;(internal::move(x));
1154 }
1155 
1156 // Creates an action that does the default action for the give mock function.
1157 inline internal::DoDefaultAction DoDefault() {
1158   return internal::DoDefaultAction();
1159 }
1160 
1161 // Creates an action that sets the variable pointed by the N-th
1162 // (0-based) function argument to &#39;value&#39;.
1163 template &lt;size_t N, typename T&gt;
1164 PolymorphicAction&lt;
1165   internal::SetArgumentPointeeAction&lt;
1166     N, T, internal::IsAProtocolMessage&lt;T&gt;::value&gt; &gt;
1167 SetArgPointee(const T&amp; x) {
1168   return MakePolymorphicAction(internal::SetArgumentPointeeAction&lt;
1169       N, T, internal::IsAProtocolMessage&lt;T&gt;::value&gt;(x));
1170 }
1171 
1172 #if !((GTEST_GCC_VER_ &amp;&amp; GTEST_GCC_VER_ &lt; 40000) || GTEST_OS_SYMBIAN)
1173 // This overload allows SetArgPointee() to accept a string literal.
1174 // GCC prior to the version 4.0 and Symbian C++ compiler cannot distinguish
1175 // this overload from the templated version and emit a compile error.
1176 template &lt;size_t N&gt;
1177 PolymorphicAction&lt;
1178   internal::SetArgumentPointeeAction&lt;N, const char*, false&gt; &gt;
1179 SetArgPointee(const char* p) {
1180   return MakePolymorphicAction(internal::SetArgumentPointeeAction&lt;
1181       N, const char*, false&gt;(p));
1182 }
1183 
1184 template &lt;size_t N&gt;
1185 PolymorphicAction&lt;
1186   internal::SetArgumentPointeeAction&lt;N, const wchar_t*, false&gt; &gt;
1187 SetArgPointee(const wchar_t* p) {
1188   return MakePolymorphicAction(internal::SetArgumentPointeeAction&lt;
1189       N, const wchar_t*, false&gt;(p));
1190 }
1191 #endif
1192 
1193 // The following version is DEPRECATED.
1194 template &lt;size_t N, typename T&gt;
1195 PolymorphicAction&lt;
1196   internal::SetArgumentPointeeAction&lt;
1197     N, T, internal::IsAProtocolMessage&lt;T&gt;::value&gt; &gt;
1198 SetArgumentPointee(const T&amp; x) {
1199   return MakePolymorphicAction(internal::SetArgumentPointeeAction&lt;
1200       N, T, internal::IsAProtocolMessage&lt;T&gt;::value&gt;(x));
1201 }
1202 
1203 // Creates an action that sets a pointer referent to a given value.
1204 template &lt;typename T1, typename T2&gt;
1205 PolymorphicAction&lt;internal::AssignAction&lt;T1, T2&gt; &gt; Assign(T1* ptr, T2 val) {
1206   return MakePolymorphicAction(internal::AssignAction&lt;T1, T2&gt;(ptr, val));
1207 }
1208 
1209 #if !GTEST_OS_WINDOWS_MOBILE
1210 
1211 // Creates an action that sets errno and returns the appropriate error.
1212 template &lt;typename T&gt;
1213 PolymorphicAction&lt;internal::SetErrnoAndReturnAction&lt;T&gt; &gt;
1214 SetErrnoAndReturn(int errval, T result) {
1215   return MakePolymorphicAction(
1216       internal::SetErrnoAndReturnAction&lt;T&gt;(errval, result));
1217 }
1218 
1219 #endif  // !GTEST_OS_WINDOWS_MOBILE
1220 
1221 // Various overloads for InvokeWithoutArgs().
1222 
1223 // Creates an action that invokes &#39;function_impl&#39; with no argument.
1224 template &lt;typename FunctionImpl&gt;
1225 PolymorphicAction&lt;internal::InvokeWithoutArgsAction&lt;FunctionImpl&gt; &gt;
1226 InvokeWithoutArgs(FunctionImpl function_impl) {
1227   return MakePolymorphicAction(
1228       internal::InvokeWithoutArgsAction&lt;FunctionImpl&gt;(function_impl));
1229 }
1230 
1231 // Creates an action that invokes the given method on the given object
1232 // with no argument.
1233 template &lt;class Class, typename MethodPtr&gt;
1234 PolymorphicAction&lt;internal::InvokeMethodWithoutArgsAction&lt;Class, MethodPtr&gt; &gt;
1235 InvokeWithoutArgs(Class* obj_ptr, MethodPtr method_ptr) {
1236   return MakePolymorphicAction(
1237       internal::InvokeMethodWithoutArgsAction&lt;Class, MethodPtr&gt;(
1238           obj_ptr, method_ptr));
1239 }
1240 
1241 // Creates an action that performs an_action and throws away its
1242 // result.  In other words, it changes the return type of an_action to
1243 // void.  an_action MUST NOT return void, or the code won&#39;t compile.
1244 template &lt;typename A&gt;
1245 inline internal::IgnoreResultAction&lt;A&gt; IgnoreResult(const A&amp; an_action) {
1246   return internal::IgnoreResultAction&lt;A&gt;(an_action);
1247 }
1248 
1249 // Creates a reference wrapper for the given L-value.  If necessary,
1250 // you can explicitly specify the type of the reference.  For example,
1251 // suppose &#39;derived&#39; is an object of type Derived, ByRef(derived)
1252 // would wrap a Derived&amp;.  If you want to wrap a const Base&amp; instead,
1253 // where Base is a base class of Derived, just write:
1254 //
1255 //   ByRef&lt;const Base&gt;(derived)
1256 template &lt;typename T&gt;
1257 inline internal::ReferenceWrapper&lt;T&gt; ByRef(T&amp; l_value) {  // NOLINT
1258   return internal::ReferenceWrapper&lt;T&gt;(l_value);
1259 }
1260 
1261 }  // namespace testing
1262 
1263 #endif  // GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
    </pre>
  </body>
</html>
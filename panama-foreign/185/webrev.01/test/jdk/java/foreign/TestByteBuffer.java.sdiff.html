<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/TestByteBuffer.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../ProblemList.txt.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestLayoutAttributes.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/TestByteBuffer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 59 import java.nio.channels.FileChannel;
 60 import java.nio.file.Files;
 61 import java.nio.file.Path;
 62 import java.nio.file.StandardOpenOption;
 63 import java.util.HashMap;
 64 import java.util.Map;
 65 import java.util.function.BiConsumer;
 66 import java.util.function.BiFunction;
 67 import java.util.function.Consumer;
 68 import java.util.function.Function;
 69 import java.util.function.Predicate;
 70 import java.util.stream.Stream;
 71 
 72 import jdk.internal.foreign.HeapMemorySegmentImpl;
 73 import jdk.internal.foreign.MappedMemorySegmentImpl;
 74 import jdk.internal.foreign.MemoryAddressImpl;
 75 import jdk.internal.foreign.NativeMemorySegmentImpl;
 76 import org.testng.SkipException;
 77 import org.testng.annotations.*;
 78 import sun.nio.ch.DirectBuffer;
<span class="line-modified"> 79 </span>
 80 import static org.testng.Assert.*;
 81 
 82 public class TestByteBuffer {
 83 
 84     static Path tempPath;
 85 
 86     static {
 87         try {
 88             File file = File.createTempFile(&quot;buffer&quot;, &quot;txt&quot;);
 89             file.deleteOnExit();
 90             tempPath = file.toPath();
 91             Files.write(file.toPath(), new byte[256], StandardOpenOption.WRITE);
 92 
 93         } catch (IOException ex) {
 94             throw new ExceptionInInitializerError(ex);
 95         }
 96     }
 97 
 98     static SequenceLayout tuples = MemoryLayout.ofSequence(500,
 99             MemoryLayout.ofStruct(
</pre>
<hr />
<pre>
217         //write to channel
218         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
219             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -&gt; {
220                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
221                 MemoryAddress base = segment.baseAddress();
222                 initTuples(base);
223                 mbb.force();
224             });
225         }
226 
227         //read from channel
228         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
229             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -&gt; {
230                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
231                 MemoryAddress base = segment.baseAddress();
232                 checkTuples(base, mbb);
233             });
234         }
235     }
236 















237     @Test
238     public void testMappedSegment() throws Throwable {
239         File f = new File(&quot;test2.out&quot;);
240         f.createNewFile();
241         f.deleteOnExit();
242 
243         //write to channel
244         try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
245             MemoryAddress base = segment.baseAddress();
246             initTuples(base);
247             segment.force();
248         }
249 
250         //read from channel
251         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
252             MemoryAddress base = segment.baseAddress();
253             checkTuples(base, segment.asByteBuffer());
254         }
255     }
256 
</pre>
<hr />
<pre>
427         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
428              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
429             initializer.accept(heapArray.baseAddress());
430             nativeArray.copyFrom(heapArray);
431             checker.accept(nativeArray.baseAddress());
432         }
433     }
434 
435     @Test(dataProvider=&quot;resizeOps&quot;)
436     public void testCopyNativeToHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
437         checkByteArrayAlignment(seq.elementLayout());
438         int bytes = (int)seq.byteSize();
439         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
440              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
441             initializer.accept(nativeArray.baseAddress());
442             heapArray.copyFrom(nativeArray);
443             checker.accept(heapArray.baseAddress());
444         }
445     }
446 















447     @Test(dataProvider=&quot;bufferSources&quot;)
448     public void testBufferToSegment(ByteBuffer bb, Predicate&lt;MemorySegment&gt; segmentChecker) {
449         MemorySegment segment = MemorySegment.ofByteBuffer(bb);
450         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
451         assertTrue(segmentChecker.test(segment));
452         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
453         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
454         assertEquals(bb.capacity(), segment.byteSize());
455         //another round trip
456         segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());
457         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
458         assertTrue(segmentChecker.test(segment));
459         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
460         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
461         assertEquals(bb.capacity(), segment.byteSize());
462     }
463 
464     @Test
465     public void testRoundTripAccess() {
466         try(MemorySegment ms = MemorySegment.allocateNative(4)) {
</pre>
</td>
<td>
<hr />
<pre>
 59 import java.nio.channels.FileChannel;
 60 import java.nio.file.Files;
 61 import java.nio.file.Path;
 62 import java.nio.file.StandardOpenOption;
 63 import java.util.HashMap;
 64 import java.util.Map;
 65 import java.util.function.BiConsumer;
 66 import java.util.function.BiFunction;
 67 import java.util.function.Consumer;
 68 import java.util.function.Function;
 69 import java.util.function.Predicate;
 70 import java.util.stream.Stream;
 71 
 72 import jdk.internal.foreign.HeapMemorySegmentImpl;
 73 import jdk.internal.foreign.MappedMemorySegmentImpl;
 74 import jdk.internal.foreign.MemoryAddressImpl;
 75 import jdk.internal.foreign.NativeMemorySegmentImpl;
 76 import org.testng.SkipException;
 77 import org.testng.annotations.*;
 78 import sun.nio.ch.DirectBuffer;
<span class="line-modified"> 79 import static jdk.incubator.foreign.MemorySegment.*;</span>
 80 import static org.testng.Assert.*;
 81 
 82 public class TestByteBuffer {
 83 
 84     static Path tempPath;
 85 
 86     static {
 87         try {
 88             File file = File.createTempFile(&quot;buffer&quot;, &quot;txt&quot;);
 89             file.deleteOnExit();
 90             tempPath = file.toPath();
 91             Files.write(file.toPath(), new byte[256], StandardOpenOption.WRITE);
 92 
 93         } catch (IOException ex) {
 94             throw new ExceptionInInitializerError(ex);
 95         }
 96     }
 97 
 98     static SequenceLayout tuples = MemoryLayout.ofSequence(500,
 99             MemoryLayout.ofStruct(
</pre>
<hr />
<pre>
217         //write to channel
218         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
219             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -&gt; {
220                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
221                 MemoryAddress base = segment.baseAddress();
222                 initTuples(base);
223                 mbb.force();
224             });
225         }
226 
227         //read from channel
228         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
229             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -&gt; {
230                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
231                 MemoryAddress base = segment.baseAddress();
232                 checkTuples(base, mbb);
233             });
234         }
235     }
236 
<span class="line-added">237     static final int ALL_ACCESS_MODES = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;</span>
<span class="line-added">238 </span>
<span class="line-added">239     @Test</span>
<span class="line-added">240     public void testDefaultAccessModesMappedSegment() throws Throwable {</span>
<span class="line-added">241         try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 8, FileChannel.MapMode.READ_WRITE)) {</span>
<span class="line-added">242             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES));</span>
<span class="line-added">243             assertEquals(segment.accessModes(), ALL_ACCESS_MODES);</span>
<span class="line-added">244         }</span>
<span class="line-added">245 </span>
<span class="line-added">246         try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 8, FileChannel.MapMode.READ_ONLY)) {</span>
<span class="line-added">247             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES &amp; ~WRITE));</span>
<span class="line-added">248             assertEquals(segment.accessModes(), ALL_ACCESS_MODES&amp; ~WRITE);</span>
<span class="line-added">249         }</span>
<span class="line-added">250     }</span>
<span class="line-added">251 </span>
252     @Test
253     public void testMappedSegment() throws Throwable {
254         File f = new File(&quot;test2.out&quot;);
255         f.createNewFile();
256         f.deleteOnExit();
257 
258         //write to channel
259         try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
260             MemoryAddress base = segment.baseAddress();
261             initTuples(base);
262             segment.force();
263         }
264 
265         //read from channel
266         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
267             MemoryAddress base = segment.baseAddress();
268             checkTuples(base, segment.asByteBuffer());
269         }
270     }
271 
</pre>
<hr />
<pre>
442         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
443              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
444             initializer.accept(heapArray.baseAddress());
445             nativeArray.copyFrom(heapArray);
446             checker.accept(nativeArray.baseAddress());
447         }
448     }
449 
450     @Test(dataProvider=&quot;resizeOps&quot;)
451     public void testCopyNativeToHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
452         checkByteArrayAlignment(seq.elementLayout());
453         int bytes = (int)seq.byteSize();
454         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
455              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
456             initializer.accept(nativeArray.baseAddress());
457             heapArray.copyFrom(nativeArray);
458             checker.accept(heapArray.baseAddress());
459         }
460     }
461 
<span class="line-added">462     @Test</span>
<span class="line-added">463     public void testDefaultAccessModesOfBuffer() {</span>
<span class="line-added">464         ByteBuffer rwBuffer = ByteBuffer.wrap(new byte[4]);</span>
<span class="line-added">465         try (MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer)) {</span>
<span class="line-added">466             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES));</span>
<span class="line-added">467             assertEquals(segment.accessModes(), ALL_ACCESS_MODES);</span>
<span class="line-added">468         }</span>
<span class="line-added">469 </span>
<span class="line-added">470         ByteBuffer roBuffer = rwBuffer.asReadOnlyBuffer();</span>
<span class="line-added">471         try (MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer)) {</span>
<span class="line-added">472             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES &amp; ~WRITE));</span>
<span class="line-added">473             assertEquals(segment.accessModes(), ALL_ACCESS_MODES &amp; ~WRITE);</span>
<span class="line-added">474         }</span>
<span class="line-added">475     }</span>
<span class="line-added">476 </span>
477     @Test(dataProvider=&quot;bufferSources&quot;)
478     public void testBufferToSegment(ByteBuffer bb, Predicate&lt;MemorySegment&gt; segmentChecker) {
479         MemorySegment segment = MemorySegment.ofByteBuffer(bb);
480         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
481         assertTrue(segmentChecker.test(segment));
482         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
483         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
484         assertEquals(bb.capacity(), segment.byteSize());
485         //another round trip
486         segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());
487         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
488         assertTrue(segmentChecker.test(segment));
489         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
490         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
491         assertEquals(bb.capacity(), segment.byteSize());
492     }
493 
494     @Test
495     public void testRoundTripAccess() {
496         try(MemorySegment ms = MemorySegment.allocateNative(4)) {
</pre>
</td>
</tr>
</table>
<center><a href="../../ProblemList.txt.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestLayoutAttributes.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
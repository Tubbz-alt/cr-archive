diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
@@ -78,11 +78,11 @@
      *
      * @apiNote two addresses might be considered equal despite their associated segments differ. This
      * can happen, for instance, if the segment associated with one address is a <em>slice</em>
      * (see {@link MemorySegment#asSlice(long, long)}) of the segment associated with the other address. Moreover,
      * two addresses might be considered equals despite differences in the temporal bounds associated with their
-     * corresponding segments (this is possible, for example, as a result of calls to {@link MemorySegment#acquire()}).
+     * corresponding segments.
      *
      * @param that the object to be compared for equality with this address.
      * @return {@code true} if the specified object is equal to this address.
      */
     @Override
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -31,10 +31,12 @@
 import jdk.internal.foreign.Utils;
 
 import java.io.IOException;
 import java.nio.channels.FileChannel;
 import java.nio.file.Path;
+import java.util.Spliterator;
+import java.util.function.Consumer;
 
 /**
  * A memory segment models a contiguous region of memory. A memory segment is associated with both spatial
  * and temporal bounds. Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location
  * which falls <em>outside</em> the boundaries of the memory segment being accessed. Temporal checks ensure that memory access
@@ -75,12 +77,10 @@
  * resources associated with it are released; this has different meanings depending on the kind of memory segment being
  * considered:
  * <ul>
  *     <li>closing a native memory segment results in <em>freeing</em> the native memory associated with it</li>
  *     <li>closing a mapped memory segment results in the backing memory-mapped file to be unmapped</li>
- *     <li>closing an acquired memory segment <b>does not</b> result in the release of resources
- *     (see the section on <a href="#thread-confinement">thread confinement</a> for more details)</li>
  *     <li>closing a buffer, or a heap segment does not have any side-effect, other than marking the segment
  *     as <em>not alive</em> (see {@link MemorySegment#isAlive()}). Also, since the buffer and heap segments might keep
  *     strong references to the original buffer or array instance, it is the responsibility of clients to ensure that
  *     these segments are discarded in a timely manner, so as not to prevent garbage collection to reclaim the underlying
  *     objects.</li>
@@ -92,17 +92,22 @@
  * typically the thread which initiated the creation operation. After creation, only the owner thread will be allowed
  * to directly manipulate the memory segment (e.g. close the memory segment) or access the underlying memory associated with
  * the segment using a memory access var handle. Any attempt to perform such operations from a thread other than the
  * owner thread will result in a runtime failure.
  * <p>
- * If a memory segment S owned by thread A needs to be used by thread B, B needs to explicitly <em>acquire</em> S,
- * which will create a so called <em>acquired</em> memory segment owned by B (see {@link #acquire()}) backed by the same resources
- * as S. A memory segment can be acquired multiple times by one or more threads; in that case, a memory segment S cannot
- * be closed until all the acquired memory segments derived from S have been closed. Furthermore, closing an acquired
- * memory segment does <em>not</em> trigger any deallocation action. It is therefore important that clients remember to
- * explicitly close the original segment from which the acquired memory segments have been obtained in order to truly
- * ensure that off-heap resources associated with the memory segment are released.
+ * In some cases, it might be useful for multiple threads to process the contents of the same memory segment concurrently
+ * (e.g. in the case of parallel processing); while memory segments provide strong confinement guarantees, it is possible
+ * to obtain a {@link Spliterator} from a segment, which can be used to slice the segment and allow multiple thread to
+ * work in parallel on disjoint segment slices (this assumes that the access mode {@link #ACQUIRE} is set).
+ * For instance, the following code can be used to sum all int values in a memory segment in parallel:
+ * <blockquote><pre>{@code
+SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
+VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);
+int sum = StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)
+            .mapToInt(segment -> (int)VH_int.get(segment.baseAddress))
+            .sum();
+ * }</pre></blockquote>
  *
  * <h2><a id = "access-modes">Access modes</a></h2>
  *
  * Memory segments supports zero or more <em>access modes</em>. Supported access modes are {@link #READ},
  * {@link #WRITE}, {@link #CLOSE} and {@link #ACQUIRE}. The set of access modes supported by a segment alters the
@@ -150,18 +155,31 @@
      * @return The base memory address.
      */
     MemoryAddress baseAddress();
 
     /**
-     * Obtains an <a href="#thread-confinement">acquired</a> memory segment which can be used to access memory associated
-     * with this segment from the current thread. As a side-effect, this segment cannot be closed until the acquired
-     * view has been closed too (see {@link #close()}).
-     * @return an <a href="#thread-confinement">acquired</a> memory segment which can be used to access memory associated
-     * with this segment from the current thread.
-     * @throws IllegalStateException if this segment has been closed.
+     * Returns a spliterator for this memory segment. The returned spliterator reports {@link Spliterator#SIZED},
+     * {@link Spliterator#SUBSIZED}, {@link Spliterator#IMMUTABLE}, {@link Spliterator#NONNULL} and {@link Spliterator#ORDERED}
+     * characteristics.
+     * <p>
+     * The returned spliterator splits the segment according to the specified sequence layout; that is,
+     * if the supplied layout is a sequence layout whose element count is {@code N}, then calling {@link Spliterator#trySplit()}
+     * will result in a spliterator serving approximatively {@code N/2} elements (depending on whether N is even or not).
+     * As such, splitting is possible as long as {@code N >= 2}.
+     * <p>
+     * The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then
+     * be processed in parallel by multiple threads (if the access mode {@link #ACQUIRE} is set).
+     * While closing the segment (see {@link #close()}) during pending concurrent execution will generally
+     * fail with an exception, it is possible to close a segment when a spliterator has been obtained but not thread
+     * is actively working on it using {@link Spliterator#tryAdvance(Consumer)}; in such cases, any subsequent call
+     * to {@link Spliterator#tryAdvance(Consumer)} will fail with an exception.
+     * @param layout the layout to be used for splitting.
+     * @return the element spliterator for this segment
+     * @throws IllegalStateException if this segment is not <em>alive</em>, or if access occurs from a thread other than the
+     * thread owning this segment
      */
-    MemorySegment acquire();
+    Spliterator<MemorySegment> spliterator(SequenceLayout layout);
 
     /**
      * The thread owning this segment.
      * @return the thread owning this segment.
      */
@@ -186,11 +204,11 @@
     MemorySegment withAccessModes(int accessModes);
 
     /**
      * Does this segment support a given set of access modes?
      * @param accessModes an ORed mask of zero or more access modes.
-     * @return true, if the access modes in {@accessModes} are stricter than the ones supported by this segment.
+     * @return true, if the access modes in {@code accessModes} are stricter than the ones supported by this segment.
      */
     boolean hasAccessModes(int accessModes);
 
     /**
      * Returns the <a href="#access-modes">access modes</a> associated with this segment; the result is represented as ORed values from
@@ -220,11 +238,12 @@
      * Closes this memory segment. Once a memory segment has been closed, any attempt to use the memory segment,
      * or to access the memory associated with the segment will fail with {@link IllegalStateException}. Depending on
      * the kind of memory segment being closed, calling this method further trigger deallocation of all the resources
      * associated with the memory segment.
      * @throws IllegalStateException if this segment is not <em>alive</em>, or if access occurs from a thread other than the
-     * thread owning this segment.
+     * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different
+     * thread (see {@link #spliterator(SequenceLayout)}).
      * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.
      */
     void close();
 
     /**
@@ -471,11 +490,12 @@
      * @see MemorySegment#withAccessModes(int)
      */
     int CLOSE = WRITE << 1;
 
     /**
-     * Acquire access mode; calling {@link #acquire()} is supported by a segment which supports this access mode.
+     * Acquire access mode; this segment support sharing with threads other than the owner thread, via spliterator
+     * (see {@link #spliterator(SequenceLayout)}).
      * @see MemorySegment#accessModes()
      * @see MemorySegment#withAccessModes(int)
      */
     int ACQUIRE = CLOSE << 1;
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
@@ -80,11 +80,10 @@
  * the segment it belongs to has not been closed prematurely. We call this guarantee <em>temporal safety</em>. Note that,
  * in the general case, guaranteeing temporal safety can be hard, as multiple threads could attempt to access and/or close
  * the same memory segment concurrently. The memory access API addresses this problem by imposing strong
  * <a href="MemorySegment.html#thread-confinement"><em>thread-confinement</em></a> guarantees on memory segments: each
  * memory segment is associated with an owner thread, which is the only thread that can either access or close the segment.
- * A thread other than the owner thread will have to explicitly <em>acquire</em> a segment in order to be able to use it.
  * <p>
  * Together, spatial and temporal safety ensure that each memory access operation either succeeds - and accesses a valid
  * memory location - or fails.
  */
 package jdk.incubator.foreign;
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
@@ -26,10 +26,11 @@
 
 package jdk.internal.foreign;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SequenceLayout;
 import jdk.internal.access.JavaNioAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.misc.Unsafe;
 import jdk.internal.vm.annotation.ForceInline;
@@ -37,10 +38,12 @@
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
 import java.util.Random;
+import java.util.Spliterator;
+import java.util.function.Consumer;
 
 /**
  * This class provides an immutable implementation for the {@code MemorySegment} interface. This class contains information
  * about the segment's spatial and temporal bounds, as well as the addressing coordinates (base + offset) which allows
  * unsafe access; each memory segment implementation is associated with an owner thread which is set at creation time.
@@ -70,10 +73,11 @@
 
     public MemorySegmentImpl(long min, Object base, long length, Thread owner, MemoryScope scope) {
         this(min, base, length, DEFAULT_MASK, owner, scope);
     }
 
+    @ForceInline
     private MemorySegmentImpl(long min, Object base, long length, int mask, Thread owner, MemoryScope scope) {
         this.length = length;
         this.mask = length > Integer.MAX_VALUE ? mask : (mask | SMALL);
         this.min = min;
         this.base = base;
@@ -82,21 +86,28 @@
     }
 
     // MemorySegment methods
 
     @Override
-    public final MemorySegmentImpl asSlice(long offset, long newSize) {
+    public final MemorySegment asSlice(long offset, long newSize) {
         checkBounds(offset, newSize);
+        return asSliceNoCheck(offset, newSize);
+    }
+
+    @ForceInline
+    private MemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
         return new MemorySegmentImpl(min + offset, base, newSize, mask, owner, scope);
     }
 
     @Override
-    public MemorySegment acquire() {
-        if (!isSet(ACQUIRE)) {
-            throw unsupportedAccessMode(ACQUIRE);
+    public Spliterator<MemorySegment> spliterator(SequenceLayout sequenceLayout) {
+        checkValidState();
+        if (sequenceLayout.byteSize() != byteSize()) {
+            throw new IllegalArgumentException();
         }
-        return new MemorySegmentImpl(min, base, length, mask, Thread.currentThread(), scope.acquire());
+        return new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
+                this.withAccessModes(accessModes() & ~CLOSE));
     }
 
     @Override
     @ForceInline
     public final MemoryAddress baseAddress() {
@@ -122,10 +133,14 @@
     public final void close() {
         if (!isSet(CLOSE)) {
             throw unsupportedAccessMode(CLOSE);
         }
         checkValidState();
+        closeNoCheck();
+    }
+
+    private void closeNoCheck() {
         scope.close();
     }
 
     @Override
     public ByteBuffer asByteBuffer() {
@@ -149,11 +164,11 @@
         }
         return _bb;
     }
 
     @Override
-    public MemorySegment withAccessModes(int accessModes) {
+    public MemorySegmentImpl withAccessModes(int accessModes) {
         checkAccessModes(accessModes);
         if ((~accessModes() & accessModes) != 0) {
             throw new UnsupportedOperationException("Cannot acquire more access modes");
         }
         return new MemorySegmentImpl(min, base, length, accessModes, owner, scope);
@@ -206,10 +221,17 @@
         return "MemorySegment{ id=0x" + Long.toHexString(id()) + " limit: " + byteSize() + " }";
     }
 
     // Helper methods
 
+    private MemorySegmentImpl acquire() {
+        if (Thread.currentThread() != owner && !isSet(ACQUIRE)) {
+            throw unsupportedAccessMode(ACQUIRE);
+        }
+        return new MemorySegmentImpl(min, base, length, mask, Thread.currentThread(), scope.acquire());
+    }
+
     void checkRange(long offset, long length, boolean writeAccess) {
         checkValidState();
         if (writeAccess && !isSet(WRITE)) {
             throw unsupportedAccessMode(WRITE);
         } else if (!writeAccess && !isSet(READ)) {
@@ -283,6 +305,90 @@
     private int id() {
         //compute a stable and random id for this memory segment
         return Math.abs(Objects.hash(base, min, NONCE));
     }
 
+    static class SegmentSplitter implements Spliterator<MemorySegment> {
+        MemorySegmentImpl segment;
+        long elemCount;
+        final long elementSize;
+        long currentIndex;
+
+        SegmentSplitter(long elementSize, long elemCount, MemorySegmentImpl segment) {
+            this.segment = segment;
+            this.elementSize = elementSize;
+            this.elemCount = elemCount;
+        }
+
+        @Override
+        public SegmentSplitter trySplit() {
+            if (currentIndex == 0 && elemCount > 1) {
+                MemorySegmentImpl parent = segment;
+                long rem = elemCount % 2;
+                long split = elemCount / 2;
+                long lobound = split * elementSize;
+                long hibound = lobound + (rem * elementSize);
+                elemCount  = split + rem;
+                segment = parent.asSliceNoCheck(lobound, hibound);
+                return new SegmentSplitter(elementSize, split, parent.asSliceNoCheck(0, lobound));
+            } else {
+                return null;
+            }
+        }
+
+        @Override
+        public boolean tryAdvance(Consumer<? super MemorySegment> action) {
+            Objects.requireNonNull(action);
+            if (currentIndex < elemCount) {
+                MemorySegmentImpl acquired = segment.acquire();
+                try {
+                    action.accept(acquired.asSliceNoCheck(currentIndex * elementSize, elementSize));
+                } finally {
+                    acquired.closeNoCheck();
+                    currentIndex++;
+                    if (currentIndex == elemCount) {
+                        segment = null;
+                    }
+                }
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        @Override
+        public void forEachRemaining(Consumer<? super MemorySegment> action) {
+            Objects.requireNonNull(action);
+            if (currentIndex < elemCount) {
+                MemorySegmentImpl acquired = segment.acquire();
+                try {
+                    if (acquired.isSmall()) {
+                        int index = (int) currentIndex;
+                        int limit = (int) elemCount;
+                        int elemSize = (int) elementSize;
+                        for (; index < limit; index++) {
+                            action.accept(acquired.asSliceNoCheck(index * elemSize, elemSize));
+                        }
+                    } else {
+                        for (long i = currentIndex ; i < elemCount ; i++) {
+                            action.accept(acquired.asSliceNoCheck(i * elementSize, elementSize));
+                        }
+                    }
+                } finally {
+                    acquired.closeNoCheck();
+                    currentIndex = elemCount;
+                    segment = null;
+                }
+            }
+        }
+
+        @Override
+        public long estimateSize() {
+            return elemCount;
+        }
+
+        @Override
+        public int characteristics() {
+            return NONNULL | SUBSIZED | SIZED | IMMUTABLE | ORDERED;
+        }
+    }
 }
diff a/test/jdk/java/foreign/TestSegments.java b/test/jdk/java/foreign/TestSegments.java
--- a/test/jdk/java/foreign/TestSegments.java
+++ b/test/jdk/java/foreign/TestSegments.java
@@ -35,11 +35,13 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.nio.ByteOrder;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Spliterator;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 import java.util.function.LongFunction;
 import java.util.stream.Stream;
 
 import org.testng.annotations.*;
@@ -208,10 +210,11 @@
         final Method method;
         final Object[] params;
 
         final static List<String> CONFINED_NAMES = List.of(
                 "close",
+                "spliterator",
                 "toByteArray"
         );
 
         public SegmentMember(Method method, Object[] params) {
             this.method = method;
@@ -266,11 +269,31 @@
 
     enum AccessActions {
         ACQUIRE(MemorySegment.ACQUIRE) {
             @Override
             void run(MemorySegment segment) {
-                segment.acquire();
+                Spliterator<MemorySegment> spliterator =
+                        segment.spliterator(MemoryLayout.ofSequence(segment.byteSize(), MemoryLayouts.JAVA_BYTE));
+                AtomicReference<RuntimeException> exception = new AtomicReference<>();
+                Runnable action = () -> {
+                    try {
+                        spliterator.tryAdvance(s -> { });
+                    } catch (RuntimeException e) {
+                        exception.set(e);
+                    }
+                };
+                Thread thread = new Thread(action);
+                thread.start();
+                try {
+                    thread.join();
+                } catch (InterruptedException ex) {
+                    throw new AssertionError(ex);
+                }
+                RuntimeException e = exception.get();
+                if (e != null) {
+                    throw e;
+                }
             }
         },
         CLOSE(MemorySegment.CLOSE) {
             @Override
             void run(MemorySegment segment) {
diff a/test/jdk/java/foreign/TestSharedAccess.java b/test/jdk/java/foreign/TestSharedAccess.java
--- a/test/jdk/java/foreign/TestSharedAccess.java
+++ b/test/jdk/java/foreign/TestSharedAccess.java
@@ -25,58 +25,93 @@
 /*
  * @test
  * @run testng TestSharedAccess
  */
 
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.SequenceLayout;
 import org.testng.annotations.*;
 
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Spliterator;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import static org.testng.Assert.*;
 
 public class TestSharedAccess {
 
     static final VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
 
     @Test
     public void testShared() throws Throwable {
-        try (MemorySegment s = MemorySegment.allocateNative(4)) {
-            setInt(s, 42);
-            assertEquals(getInt(s), 42);
+        SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
+        try (MemorySegment s = MemorySegment.allocateNative(layout)) {
+            for (int i = 0 ; i < layout.elementCount().getAsLong() ; i++) {
+                setInt(s.baseAddress().addOffset(i * 4), 42);
+            }
             List<Thread> threads = new ArrayList<>();
-            for (int i = 0 ; i < 1000 ; i++) {
-                threads.add(new Thread(() -> {
-                    try (MemorySegment local = s.acquire()) {
-                        assertEquals(getInt(local), 42);
+            List<Spliterator<MemorySegment>> spliterators = new ArrayList<>();
+            spliterators.add(s.spliterator(layout));
+            while (true) {
+                boolean progress = false;
+                List<Spliterator<MemorySegment>> newSpliterators = new ArrayList<>();
+                for (Spliterator<MemorySegment> spliterator : spliterators) {
+                    Spliterator<MemorySegment> sub = spliterator.trySplit();
+                    if (sub != null) {
+                        progress = true;
+                        newSpliterators.add(sub);
                     }
+                }
+                spliterators.addAll(newSpliterators);
+                if (!progress) break;
+            }
+
+            AtomicInteger accessCount = new AtomicInteger();
+            for (Spliterator<MemorySegment> spliterator : spliterators) {
+                threads.add(new Thread(() -> {
+                    spliterator.tryAdvance(local -> {
+                        assertEquals(getInt(local.baseAddress()), 42);
+                        accessCount.incrementAndGet();
+                    });
                 }));
             }
             threads.forEach(Thread::start);
             threads.forEach(t -> {
                 try {
                     t.join();
                 } catch (Throwable e) {
                     throw new IllegalStateException(e);
                 }
             });
+            assertEquals(accessCount.get(), 1024);
         }
     }
 
     @Test(expectedExceptions=IllegalStateException.class)
-    public void testBadCloseWithPendingAcquire() {
-        try (MemorySegment segment = MemorySegment.allocateNative(8)) {
-            segment.acquire();
+    public void testBadCloseWithPendingAcquire() throws InterruptedException {
+        try (MemorySegment segment = MemorySegment.allocateNative(16)) {
+            Spliterator<MemorySegment> spliterator = segment.spliterator(MemoryLayout.ofSequence(16, MemoryLayouts.JAVA_BYTE));
+            Runnable r = () -> spliterator.forEachRemaining(s -> {
+                try {
+                    Thread.sleep(5000 * 100);
+                } catch (InterruptedException ex) {
+                    throw new AssertionError(ex);
+                }
+            });
+            new Thread(r).start();
+            Thread.sleep(5000);
         } //should fail here!
     }
 
-    static int getInt(MemorySegment handle) {
-        return (int)intHandle.getVolatile(handle.baseAddress());
+    static int getInt(MemoryAddress address) {
+        return (int)intHandle.getVolatile(address);
     }
 
-    static void setInt(MemorySegment handle, int value) {
-        intHandle.setVolatile(handle.baseAddress(), value);
+    static void setInt(MemoryAddress address, int value) {
+        intHandle.setVolatile(address, value);
     }
 }
diff a/test/jdk/java/foreign/TestSpliterator.java b/test/jdk/java/foreign/TestSpliterator.java
--- /dev/null
+++ b/test/jdk/java/foreign/TestSpliterator.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @run testng TestSpliterator
+ */
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SequenceLayout;
+
+import java.lang.invoke.VarHandle;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Spliterator;
+import java.util.concurrent.CountedCompleter;
+import java.util.concurrent.RecursiveTask;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.LongStream;
+import java.util.stream.StreamSupport;
+
+import org.testng.annotations.*;
+import static org.testng.Assert.*;
+
+public class TestSpliterator {
+
+    static final VarHandle INT_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)
+            .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());
+
+    final static int CARRIER_SIZE = 4;
+
+    @Test(dataProvider = "splits")
+    public void testSum(int size, int threshold) {
+        SequenceLayout layout = MemoryLayout.ofSequence(size, MemoryLayouts.JAVA_INT);
+
+        //setup
+        MemorySegment segment = MemorySegment.allocateNative(layout);
+        for (int i = 0; i < layout.elementCount().getAsLong(); i++) {
+            INT_HANDLE.set(segment.baseAddress(), (long) i, i);
+        }
+        long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
+        //serial
+        long serial = sum(0, segment);
+        assertEquals(serial, expected);
+        //parallel counted completer
+        long parallelCounted = new SumSegmentCounted(null, segment.spliterator(layout), threshold).invoke();
+        assertEquals(parallelCounted, expected);
+        //parallel recursive action
+        long parallelRecursive = new SumSegmentRecursive(segment.spliterator(layout), threshold).invoke();
+        assertEquals(parallelRecursive, expected);
+        //parallel stream
+        long streamParallel = StreamSupport.stream(segment.spliterator(layout), true)
+                .reduce(0L, TestSpliterator::sumSingle, Long::sum);
+        assertEquals(streamParallel, expected);
+        segment.close();
+    }
+
+    public void testSumSameThread() {
+        SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
+
+        //setup
+        MemorySegment segment = MemorySegment.allocateNative(layout);
+        for (int i = 0; i < layout.elementCount().getAsLong(); i++) {
+            INT_HANDLE.set(segment.baseAddress(), (long) i, i);
+        }
+        long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
+
+        //check that a segment w/o ACQUIRE access mode can still be used from same thread
+        AtomicLong spliteratorSum = new AtomicLong();
+        segment.withAccessModes(MemorySegment.READ)
+                .spliterator(layout).forEachRemaining(s -> spliteratorSum.addAndGet(sumSingle(0L, s)));
+        assertEquals(spliteratorSum.get(), expected);
+    }
+
+    static long sumSingle(long acc, MemorySegment segment) {
+        return acc + (int)INT_HANDLE.get(segment.baseAddress(), 0L);
+    }
+
+    static long sum(long start, MemorySegment segment) {
+        long sum = start;
+        MemoryAddress base = segment.baseAddress();
+        int length = (int)segment.byteSize();
+        for (int i = 0 ; i < length / CARRIER_SIZE ; i++) {
+            sum += (int)INT_HANDLE.get(base, (long)i);
+        }
+        return sum;
+    }
+
+    static class SumSegmentCounted extends CountedCompleter<Long> {
+
+        final long threshold;
+        long localSum = 0;
+        List<SumSegmentCounted> children = new LinkedList<>();
+
+        private Spliterator<MemorySegment> segmentSplitter;
+
+        SumSegmentCounted(SumSegmentCounted parent, Spliterator<MemorySegment> segmentSplitter, long threshold) {
+            super(parent);
+            this.segmentSplitter = segmentSplitter;
+            this.threshold = threshold;
+        }
+
+        @Override
+        public void compute() {
+            Spliterator<MemorySegment> sub;
+            while (segmentSplitter.estimateSize() > threshold &&
+                    (sub = segmentSplitter.trySplit()) != null) {
+                addToPendingCount(1);
+                SumSegmentCounted child = new SumSegmentCounted(this, sub, threshold);
+                children.add(child);
+                child.fork();
+            }
+            segmentSplitter.forEachRemaining(slice -> {
+                localSum += sumSingle(0, slice);
+            });
+            tryComplete();
+        }
+
+        @Override
+        public Long getRawResult() {
+            long sum = localSum;
+            for (SumSegmentCounted c : children) {
+                sum += c.getRawResult();
+            }
+            return sum;
+        }
+     }
+
+    static class SumSegmentRecursive extends RecursiveTask<Long> {
+
+        final long threshold;
+        private final Spliterator<MemorySegment> splitter;
+        private long result;
+
+        SumSegmentRecursive(Spliterator<MemorySegment> splitter, long threshold) {
+            this.splitter = splitter;
+            this.threshold = threshold;
+        }
+
+        @Override
+        protected Long compute() {
+            if (splitter.estimateSize() > threshold) {
+                SumSegmentRecursive sub = new SumSegmentRecursive(splitter.trySplit(), threshold);
+                sub.fork();
+                return compute() + sub.join();
+            } else {
+                splitter.forEachRemaining(slice -> {
+                    result += sumSingle(0, slice);
+                });
+                return result;
+            }
+        }
+    }
+
+    @DataProvider(name = "splits")
+    public Object[][] splits() {
+        return new Object[][] {
+                { 10, 1 },
+                { 100, 1 },
+                { 1000, 1 },
+                { 10000, 1 },
+                { 10, 10 },
+                { 100, 10 },
+                { 1000, 10 },
+                { 10000, 10 },
+                { 10, 100 },
+                { 100, 100 },
+                { 1000, 100 },
+                { 10000, 100 },
+                { 10, 1000 },
+                { 100, 1000 },
+                { 1000, 1000 },
+                { 10000, 1000 },
+                { 10, 10000 },
+                { 100, 10000 },
+                { 1000, 10000 },
+                { 10000, 10000 },
+        };
+    }
+}
diff a/test/jdk/java/util/stream/boottest/TEST.properties b/test/jdk/java/util/stream/boottest/TEST.properties
--- a/test/jdk/java/util/stream/boottest/TEST.properties
+++ b/test/jdk/java/util/stream/boottest/TEST.properties
@@ -1,4 +1,4 @@
 # This file identifies root(s) of the test-ng hierarchy.
 
 TestNG.dirs = .
-lib.dirs = /lib/testlibrary/bootlib
+lib.dirs = /lib/testlibrary/bootlib
diff a/test/jdk/java/util/stream/test/TEST.properties b/test/jdk/java/util/stream/test/TEST.properties
--- a/test/jdk/java/util/stream/test/TEST.properties
+++ b/test/jdk/java/util/stream/test/TEST.properties
@@ -4,5 +4,8 @@
 
 lib.dirs = /lib/testlibrary/bootlib
 
 # Tests that must run in othervm mode
 othervm.dirs= /java/util/stream
+
+# To help out with foreign memory access Spliterator tests
+modules = jdk.incubator.foreign
diff a/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java b/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java
--- /dev/null
+++ b/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package org.openjdk.tests.java.util.stream;
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.MemorySegment;
+
+import java.lang.invoke.VarHandle;
+import java.util.Collection;
+import java.util.List;
+import java.util.SpliteratorTestHelper;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import org.testng.annotations.DataProvider;
+
+public class SegmentTestDataProvider {
+
+    static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);
+    static VarHandle CHAR_HANDLE = MemoryLayouts.JAVA_CHAR.varHandle(char.class);
+    static VarHandle SHORT_HANDLE = MemoryLayouts.JAVA_SHORT.varHandle(short.class);
+    static VarHandle INT_HANDLE = MemoryLayouts.JAVA_INT.varHandle(int.class);
+    static VarHandle LONG_HANDLE = MemoryLayouts.JAVA_LONG.varHandle(long.class);
+    static VarHandle FLOAT_HANDLE = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);
+    static VarHandle DOUBLE_HANDLE = MemoryLayouts.JAVA_DOUBLE.varHandle(double.class);
+
+    static boolean compareSegmentsByte(Collection<MemorySegment> segments1, Collection<MemorySegment> segments2, boolean isOrdered) {
+        Function<MemorySegment, Byte> mapper = segment -> (byte)BYTE_HANDLE.get(segment.baseAddress());
+        List<Byte> list1 = segments1.stream()
+                .map(mapper)
+                .collect(Collectors.toList());
+        List<Byte> list2 = segments2.stream()
+                .map(mapper)
+                .collect(Collectors.toList());
+        return list1.equals(list2);
+    }
+
+    static boolean compareSegmentsChar(Collection<MemorySegment> segments1, Collection<MemorySegment> segments2, boolean isOrdered) {
+        Function<MemorySegment, Character> mapper = segment -> (char)CHAR_HANDLE.get(segment.baseAddress());
+        List<Character> list1 = segments1.stream()
+                .map(mapper)
+                .collect(Collectors.toList());
+        List<Character> list2 = segments2.stream()
+                .map(mapper)
+                .collect(Collectors.toList());
+        return list1.equals(list2);
+    }
+
+    static boolean compareSegmentsShort(Collection<MemorySegment> segments1, Collection<MemorySegment> segments2, boolean isOrdered) {
+        Function<MemorySegment, Short> mapper = segment -> (short)SHORT_HANDLE.get(segment.baseAddress());
+        List<Short> list1 = segments1.stream()
+                .map(mapper)
+                .collect(Collectors.toList());
+        List<Short> list2 = segments2.stream()
+                .map(mapper)
+                .collect(Collectors.toList());
+        return list1.equals(list2);
+    }
+
+    static boolean compareSegmentsInt(Collection<MemorySegment> segments1, Collection<MemorySegment> segments2, boolean isOrdered) {
+        Function<MemorySegment, Integer> mapper = segment -> (int)INT_HANDLE.get(segment.baseAddress());
+        List<Integer> list1 = segments1.stream()
+                .map(mapper)
+                .collect(Collectors.toList());
+        List<Integer> list2 = segments2.stream()
+                .map(mapper)
+                .collect(Collectors.toList());
+        return list1.equals(list2);
+    }
+
+    static boolean compareSegmentsLong(Collection<MemorySegment> segments1, Collection<MemorySegment> segments2, boolean isOrdered) {
+        Function<MemorySegment, Long> mapper = segment -> (long)LONG_HANDLE.get(segment.baseAddress());
+        List<Long> list1 = segments1.stream()
+                .map(mapper)
+                .collect(Collectors.toList());
+        List<Long> list2 = segments2.stream()
+                .map(mapper)
+                .collect(Collectors.toList());
+        return list1.equals(list2);
+    }
+
+    static boolean compareSegmentsFloat(Collection<MemorySegment> segments1, Collection<MemorySegment> segments2, boolean isOrdered) {
+        Function<MemorySegment, Float> mapper = segment -> (float)FLOAT_HANDLE.get(segment.baseAddress());
+        List<Float> list1 = segments1.stream()
+                .map(mapper)
+                .collect(Collectors.toList());
+        List<Float> list2 = segments2.stream()
+                .map(mapper)
+                .collect(Collectors.toList());
+        return list1.equals(list2);
+    }
+
+    static Consumer<MemorySegment> segmentCopier(Consumer<MemorySegment> input) {
+        return segment -> {
+            MemorySegment copy = MemorySegment.ofArray(new byte[(int)segment.byteSize()]);
+            MemoryAddress.copy(segment.baseAddress(), copy.baseAddress(), segment.byteSize());
+            input.accept(copy);
+        };
+    }
+
+    static boolean compareSegmentsDouble(Collection<MemorySegment> segments1, Collection<MemorySegment> segments2, boolean isOrdered) {
+        Function<MemorySegment, Double> mapper = segment -> (double)DOUBLE_HANDLE.get(segment.baseAddress());
+        List<Double> list1 = segments1.stream()
+                .map(mapper)
+                .collect(Collectors.toList());
+        List<Double> list2 = segments2.stream()
+                .map(mapper)
+                .collect(Collectors.toList());
+        return list1.equals(list2);
+    }
+
+    static void initSegment(MemorySegment segment) {
+        for (int i = 0 ; i < segment.byteSize() ; i++) {
+            BYTE_HANDLE.set(segment.baseAddress(), (byte)i);
+        }
+    }
+
+    static Object[][] spliteratorTestData = {
+            { "bytes", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_BYTE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsByte },
+            { "chars", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_CHAR), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsChar },
+            { "shorts", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_SHORT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsShort },
+            { "ints", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsInt },
+            { "longs", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_LONG), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsLong },
+            { "floats", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_FLOAT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsFloat },
+            { "doubles", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_DOUBLE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsDouble },
+    };
+
+    // returns an array of (String name, Supplier<Spliterator<MemorySegment>>, ContentAsserter<MemorySegment>)
+    @DataProvider(name = "SegmentSpliterator")
+    public static Object[][] spliteratorProvider() {
+        return spliteratorTestData;
+    }
+}
diff a/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java b/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java
--- a/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java
+++ b/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java
@@ -20,15 +20,14 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package org.openjdk.tests.java.util.stream;
 
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SequenceLayout;
 import org.testng.annotations.Test;
 
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
 import java.util.function.Supplier;
 import java.util.Spliterator;
 import java.util.SpliteratorTestHelper;
 import java.util.stream.*;
 
@@ -60,6 +59,15 @@
 
     @Test(dataProvider = "DoubleSpliterator", dataProviderClass = DoubleStreamTestDataProvider.class )
     public void testDoubleSpliterator(String name, Supplier<Spliterator.OfDouble> supplier) {
         SpliteratorTestHelper.testDoubleSpliterator(supplier);
     }
+
+    @Test(dataProvider = "SegmentSpliterator", dataProviderClass = SegmentTestDataProvider.class )
+    public void testSegmentSpliterator(String name, SequenceLayout layout, SpliteratorTestHelper.ContentAsserter<MemorySegment> contentAsserter) {
+        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
+            SegmentTestDataProvider.initSegment(segment);
+            SpliteratorTestHelper.testSpliterator(() -> segment.spliterator(layout),
+                    SegmentTestDataProvider::segmentCopier, contentAsserter);
+        }
+    }
 }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
@@ -25,14 +25,15 @@
  */
 
 package org.openjdk.bench.jdk.incubator.foreign;
 
 import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.SequenceLayout;
 import sun.misc.Unsafe;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
-import org.openjdk.jmh.annotations.CompilerControl;
 import org.openjdk.jmh.annotations.Fork;
 import org.openjdk.jmh.annotations.Measurement;
 import org.openjdk.jmh.annotations.Mode;
 import org.openjdk.jmh.annotations.OutputTimeUnit;
 import org.openjdk.jmh.annotations.Setup;
@@ -41,14 +42,18 @@
 import org.openjdk.jmh.annotations.Warmup;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 import java.lang.invoke.VarHandle;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ForkJoinPool;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Spliterator;
+import java.util.concurrent.CountedCompleter;
 import java.util.concurrent.RecursiveTask;
 import java.util.concurrent.TimeUnit;
+import java.util.function.ToIntFunction;
+import java.util.stream.StreamSupport;
 
 import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;
 import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;
 
 @BenchmarkMode(Mode.AverageTime)
@@ -62,18 +67,19 @@
     final static int CARRIER_SIZE = 4;
     final static int ALLOC_SIZE = CARRIER_SIZE * 1024 * 1024 * 256;
     final static int ELEM_SIZE = ALLOC_SIZE / CARRIER_SIZE;
     static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());
 
+    final static SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(ELEM_SIZE, MemoryLayouts.JAVA_INT);
+    final static int BULK_FACTOR = 512;
+    final static SequenceLayout SEQUENCE_LAYOUT_BULK = MemoryLayout.ofSequence(ELEM_SIZE / BULK_FACTOR, MemoryLayout.ofSequence(BULK_FACTOR, MemoryLayouts.JAVA_INT));
+
     static final Unsafe unsafe = Utils.unsafe;
 
     MemorySegment segment;
     long address;
 
-    ForkJoinPool pool = (ForkJoinPool) Executors.newWorkStealingPool();
-
-
     @Setup
     public void setup() {
         address = unsafe.allocateMemory(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
             unsafe.putInt(address + (i * CARRIER_SIZE), i);
@@ -86,12 +92,10 @@
 
     @TearDown
     public void tearDown() throws Throwable {
         unsafe.freeMemory(address);
         segment.close();
-        pool.shutdown();
-        pool.awaitTermination(60, TimeUnit.SECONDS);
     }
 
     @Benchmark
     public int segment_serial() {
         int res = 0;
@@ -111,48 +115,46 @@
         return res;
     }
 
     @Benchmark
     public int segment_parallel() {
-        return pool.invoke(new SumSegment(segment));
+        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT), ParallelSum::segmentToInt).invoke();
     }
 
     @Benchmark
-    public int unsafe_parallel() {
-        return pool.invoke(new SumUnsafe(address, 0, ALLOC_SIZE));
+    public int segment_parallel_bulk() {
+        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT_BULK), ParallelSum::segmentToIntBulk).invoke();
     }
 
-    static class SumSegment extends RecursiveTask<Integer> {
+    @Benchmark
+    public int segment_stream_parallel() {
+        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)
+                .mapToInt(ParallelSum::segmentToInt).sum();
+    }
 
-        final static int SPLIT_THRESHOLD = 4 * 1024 * 8;
+    @Benchmark
+    public int segment_stream_parallel_bulk() {
+        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), true)
+                .mapToInt(ParallelSum::segmentToIntBulk).sum();
+    }
 
-        private final MemorySegment segment;
+    static int segmentToInt(MemorySegment slice) {
+        return (int) VH_int.get(slice.baseAddress(), 0L);
+    }
 
-        SumSegment(MemorySegment segment) {
-            this.segment = segment;
+    static int segmentToIntBulk(MemorySegment slice) {
+        int res = 0;
+        MemoryAddress base = slice.baseAddress();
+        for (int i = 0; i < BULK_FACTOR ; i++) {
+            res += (int)VH_int.get(base, (long) i);
         }
+        return res;
+    }
 
-        @Override
-        protected Integer compute() {
-            try (MemorySegment segment = this.segment.acquire()) {
-                int length = (int)segment.byteSize();
-                if (length > SPLIT_THRESHOLD) {
-                    SumSegment s1 = new SumSegment(segment.asSlice(0, length / 2));
-                    SumSegment s2 = new SumSegment(segment.asSlice(length / 2, length / 2));
-                    s1.fork();
-                    s2.fork();
-                    return s1.join() + s2.join();
-                } else {
-                    int sum = 0;
-                    MemoryAddress base = segment.baseAddress();
-                    for (int i = 0 ; i < length / CARRIER_SIZE ; i++) {
-                        sum += (int)VH_int.get(base, (long)i);
-                    }
-                    return sum;
-                }
-            }
-        }
+    @Benchmark
+    public int unsafe_parallel() {
+        return new SumUnsafe(address, 0, ALLOC_SIZE).invoke();
     }
 
     static class SumUnsafe extends RecursiveTask<Integer> {
 
         final static int SPLIT_THRESHOLD = 4 * 1024 * 8;
@@ -181,6 +183,34 @@
                 }
                 return res;
             }
         }
     }
+
+    static class SumSegment extends RecursiveTask<Integer> {
+
+        final static int SPLIT_THRESHOLD = 1024 * 8;
+
+        private final Spliterator<MemorySegment> splitter;
+        private final ToIntFunction<MemorySegment> mapper;
+        int result;
+
+        SumSegment(Spliterator<MemorySegment> splitter, ToIntFunction<MemorySegment> mapper) {
+            this.splitter = splitter;
+            this.mapper = mapper;
+        }
+
+        @Override
+        protected Integer compute() {
+            if (splitter.estimateSize() > SPLIT_THRESHOLD) {
+                SumSegment sub = new SumSegment(splitter.trySplit(), mapper);
+                sub.fork();
+                return compute() + sub.join();
+            } else {
+                splitter.forEachRemaining(s -> {
+                    result += mapper.applyAsInt(s);
+                });
+                return result;
+            }
+        }
+    }
 }

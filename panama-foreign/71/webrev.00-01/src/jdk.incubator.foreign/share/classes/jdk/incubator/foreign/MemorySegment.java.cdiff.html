<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/MemorySegmentImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 93,11 ***</span>
   * to directly manipulate the memory segment (e.g. close the memory segment) or access the underlying memory associated with
   * the segment using a memory access var handle. Any attempt to perform such operations from a thread other than the
   * owner thread will result in a runtime failure.
   * &lt;p&gt;
   * In some cases, it might be useful for multiple threads to process the contents of the same memory segment concurrently
<span class="line-modified">!  * (e.g. in the case of parallel processing); while memory segments provide string confinement guarantees, it is possible</span>
   * to obtain a {@link Spliterator} from a segment, which can be used to slice the segment and allow multiple thread to
   * work in parallel on disjoint segment slices (this assumes that the access mode {@link #ACQUIRE} is set).
   * For instance, the following code can be used to sum all int values in a memory segment in parallel:
   * &lt;blockquote&gt;&lt;pre&gt;{@code
  SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
<span class="line-new-header">--- 93,11 ---</span>
   * to directly manipulate the memory segment (e.g. close the memory segment) or access the underlying memory associated with
   * the segment using a memory access var handle. Any attempt to perform such operations from a thread other than the
   * owner thread will result in a runtime failure.
   * &lt;p&gt;
   * In some cases, it might be useful for multiple threads to process the contents of the same memory segment concurrently
<span class="line-modified">!  * (e.g. in the case of parallel processing); while memory segments provide strong confinement guarantees, it is possible</span>
   * to obtain a {@link Spliterator} from a segment, which can be used to slice the segment and allow multiple thread to
   * work in parallel on disjoint segment slices (this assumes that the access mode {@link #ACQUIRE} is set).
   * For instance, the following code can be used to sum all int values in a memory segment in parallel:
   * &lt;blockquote&gt;&lt;pre&gt;{@code
  SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,15 ***</span>
       * @return The base memory address.
       */
      MemoryAddress baseAddress();
  
      /**
<span class="line-modified">!      * Returns a spliterator for this memory segment. The returned spliterator must feature the</span>
<span class="line-modified">!      * {@link Spliterator#SIZED}, {@link Spliterator#SUBSIZED}, {@link Spliterator#IMMUTABLE} and {@link Spliterator#NONNULL}</span>
       * characteristics.
       * &lt;p&gt;
<span class="line-modified">!      * The returned spliterator should split the segment according to the specified sequence layout; that is,</span>
       * if the supplied layout is a sequence layout whose element count is {@code N}, then calling {@link Spliterator#trySplit()}
       * will result in a spliterator serving approximatively {@code N/2} elements (depending on whether N is even or not).
       * As such, splitting is possible as long as {@code N &gt;= 2}.
       * &lt;p&gt;
       * The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then
<span class="line-new-header">--- 155,15 ---</span>
       * @return The base memory address.
       */
      MemoryAddress baseAddress();
  
      /**
<span class="line-modified">!      * Returns a spliterator for this memory segment. The returned spliterator reports {@link Spliterator#SIZED},</span>
<span class="line-modified">!      * {@link Spliterator#SUBSIZED}, {@link Spliterator#IMMUTABLE}, {@link Spliterator#NONNULL} and {@link Spliterator#ORDERED}</span>
       * characteristics.
       * &lt;p&gt;
<span class="line-modified">!      * The returned spliterator splits the segment according to the specified sequence layout; that is,</span>
       * if the supplied layout is a sequence layout whose element count is {@code N}, then calling {@link Spliterator#trySplit()}
       * will result in a spliterator serving approximatively {@code N/2} elements (depending on whether N is even or not).
       * As such, splitting is possible as long as {@code N &gt;= 2}.
       * &lt;p&gt;
       * The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then
</pre>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/MemorySegmentImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -93,11 +93,11 @@
  * to directly manipulate the memory segment (e.g. close the memory segment) or access the underlying memory associated with
  * the segment using a memory access var handle. Any attempt to perform such operations from a thread other than the
  * owner thread will result in a runtime failure.
  * <p>
  * In some cases, it might be useful for multiple threads to process the contents of the same memory segment concurrently
- * (e.g. in the case of parallel processing); while memory segments provide string confinement guarantees, it is possible
+ * (e.g. in the case of parallel processing); while memory segments provide strong confinement guarantees, it is possible
  * to obtain a {@link Spliterator} from a segment, which can be used to slice the segment and allow multiple thread to
  * work in parallel on disjoint segment slices (this assumes that the access mode {@link #ACQUIRE} is set).
  * For instance, the following code can be used to sum all int values in a memory segment in parallel:
  * <blockquote><pre>{@code
 SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
@@ -155,15 +155,15 @@
      * @return The base memory address.
      */
     MemoryAddress baseAddress();
 
     /**
-     * Returns a spliterator for this memory segment. The returned spliterator must feature the
-     * {@link Spliterator#SIZED}, {@link Spliterator#SUBSIZED}, {@link Spliterator#IMMUTABLE} and {@link Spliterator#NONNULL}
+     * Returns a spliterator for this memory segment. The returned spliterator reports {@link Spliterator#SIZED},
+     * {@link Spliterator#SUBSIZED}, {@link Spliterator#IMMUTABLE}, {@link Spliterator#NONNULL} and {@link Spliterator#ORDERED}
      * characteristics.
      * <p>
-     * The returned spliterator should split the segment according to the specified sequence layout; that is,
+     * The returned spliterator splits the segment according to the specified sequence layout; that is,
      * if the supplied layout is a sequence layout whose element count is {@code N}, then calling {@link Spliterator#trySplit()}
      * will result in a spliterator serving approximatively {@code N/2} elements (depending on whether N is even or not).
      * As such, splitting is possible as long as {@code N >= 2}.
      * <p>
      * The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
@@ -29,11 +29,10 @@
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.internal.access.JavaNioAccess;
 import jdk.internal.access.SharedSecrets;
-import jdk.internal.access.foreign.MemoryAddressProxy;
 import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.misc.Unsafe;
 import jdk.internal.vm.annotation.ForceInline;
 
 import java.nio.ByteBuffer;
@@ -321,17 +320,18 @@
         }
 
         @Override
         public SegmentSplitter trySplit() {
             if (currentIndex == 0 && elemCount > 1) {
-                MemorySegmentImpl old = segment;
+                MemorySegmentImpl parent = segment;
                 long rem = elemCount % 2;
-                elemCount  = elemCount / 2;
-                long lobound = elemCount * elementSize;
+                long split = elemCount / 2;
+                long lobound = split * elementSize;
                 long hibound = lobound + (rem * elementSize);
-                segment = old.asSliceNoCheck(0, lobound);
-                return new SegmentSplitter(elementSize, elemCount + rem, old.asSliceNoCheck(lobound, hibound));
+                elemCount  = split + rem;
+                segment = parent.asSliceNoCheck(lobound, hibound);
+                return new SegmentSplitter(elementSize, split, parent.asSliceNoCheck(0, lobound));
             } else {
                 return null;
             }
         }
 
@@ -342,14 +342,14 @@
                 MemorySegmentImpl acquired = segment.acquire();
                 try {
                     action.accept(acquired.asSliceNoCheck(currentIndex * elementSize, elementSize));
                 } finally {
                     acquired.closeNoCheck();
-                }
-                currentIndex++;
-                if (currentIndex == elemCount) {
-                    segment = null;
+                    currentIndex++;
+                    if (currentIndex == elemCount) {
+                        segment = null;
+                    }
                 }
                 return true;
             } else {
                 return false;
             }
@@ -366,19 +366,18 @@
                         int limit = (int) elemCount;
                         int elemSize = (int) elementSize;
                         for (; index < limit; index++) {
                             action.accept(acquired.asSliceNoCheck(index * elemSize, elemSize));
                         }
-                        currentIndex = index;
                     } else {
-                        while (currentIndex < elemCount) {
-                            action.accept(acquired.asSliceNoCheck(currentIndex * elementSize, elementSize));
-                            currentIndex++;
+                        for (long i = currentIndex ; i < elemCount ; i++) {
+                            action.accept(acquired.asSliceNoCheck(i * elementSize, elementSize));
                         }
                     }
                 } finally {
                     acquired.closeNoCheck();
+                    currentIndex = elemCount;
                     segment = null;
                 }
             }
         }
 
@@ -387,9 +386,9 @@
             return elemCount;
         }
 
         @Override
         public int characteristics() {
-            return NONNULL | SUBSIZED | SIZED | IMMUTABLE;
+            return NONNULL | SUBSIZED | SIZED | IMMUTABLE | ORDERED;
         }
     }
 }

diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
@@ -26,15 +26,19 @@
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.SystemABI;
+import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.abi.*;
+import jdk.internal.foreign.abi.x64.ArgumentClassImpl;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
-import java.util.Optional;
+import java.util.*;
+
+import static jdk.incubator.foreign.MemoryLayouts.SysV.*;
 
 /**
  * ABI implementation based on System V ABI AMD64 supplement v.0.99.6
  */
 public class SysVx64ABI implements SystemABI {
@@ -63,22 +67,45 @@
         return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
     }
 
     @Override
     public String name() {
-        return SysV.NAME;
+        return SystemABI.ABI_SYSV;
+    }
+
+    @Override
+    public Optional<MemoryLayout> layoutFor(Type type) {
+        return switch (Objects.requireNonNull(type)) {
+            case BOOL -> Optional.of(C_BOOL);
+            case UNSIGNED_CHAR -> Optional.of(C_UCHAR);
+            case SIGNED_CHAR -> Optional.of(C_SCHAR);
+            case CHAR -> Optional.of(C_CHAR);
+            case SHORT -> Optional.of(C_SHORT);
+            case UNSIGNED_SHORT -> Optional.of(C_USHORT);
+            case INT -> Optional.of(C_INT);
+            case UNSIGNED_INT -> Optional.of(C_UINT);
+            case LONG -> Optional.of(C_LONG);
+            case UNSIGNED_LONG -> Optional.of(C_ULONG);
+            case LONG_LONG -> Optional.of(C_LONGLONG);
+            case UNSIGNED_LONG_LONG -> Optional.of(C_ULONGLONG);
+            case FLOAT -> Optional.of(C_FLOAT);
+            case DOUBLE -> Optional.of(C_DOUBLE);
+            case LONG_DOUBLE -> Optional.of(C_LONGDOUBLE);
+            case COMPLEX_LONG_DOUBLE -> Optional.of(C_COMPLEX_LONGDOUBLE);
+            case POINTER -> Optional.of(C_POINTER);
+            default -> Optional.empty();
+        };
     }
 
-    static Optional<ArgumentClassImpl> argumentClassFor(MemoryLayout layout) {
-        @SuppressWarnings({"unchecked", "rawtypes"})
-        Optional<SysV.ArgumentClass> argClassOpt =
-                (Optional<SysV.ArgumentClass>)(Optional)layout.attribute(SysV.CLASS_ATTRIBUTE_NAME);
-        return argClassOpt.map(argClass -> switch (argClass) {
-            case INTEGER -> ArgumentClassImpl.INTEGER;
-            case SSE -> ArgumentClassImpl.SSE;
-            case X87 -> ArgumentClassImpl.X87;
-            case COMPLEX_87 -> ArgumentClassImpl.COMPLEX_X87;
+    static ArgumentClassImpl argumentClassFor(Type type) {
+        return switch (Objects.requireNonNull(type)) {
+            case BOOL, UNSIGNED_CHAR, SIGNED_CHAR, CHAR, SHORT, UNSIGNED_SHORT,
+                INT, UNSIGNED_INT, LONG, UNSIGNED_LONG, LONG_LONG, UNSIGNED_LONG_LONG ->
+                    ArgumentClassImpl.INTEGER;
+            case FLOAT, DOUBLE -> ArgumentClassImpl.SSE;
+            case LONG_DOUBLE -> ArgumentClassImpl.X87;
+            case COMPLEX_LONG_DOUBLE -> ArgumentClassImpl.COMPLEX_X87;
             case POINTER -> ArgumentClassImpl.POINTER;
             default -> null;
-        });
+        };
     }
 }

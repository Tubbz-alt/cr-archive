<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractIndexWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.formats.html;
 27 
 28 import java.io.IOException;
 29 import java.io.Writer;
<a name="1" id="anc1"></a><span class="line-added"> 30 import java.util.HashMap;</span>
 31 import java.util.Iterator;
 32 import java.util.List;
 33 import java.util.Map;
 34 import java.util.stream.Collectors;
 35 import java.util.stream.Stream;
 36 
 37 import javax.lang.model.element.Element;
 38 import javax.lang.model.element.ElementKind;
 39 import javax.lang.model.element.ExecutableElement;
 40 import javax.lang.model.element.ModuleElement;
 41 import javax.lang.model.element.PackageElement;
 42 import javax.lang.model.element.TypeElement;
 43 
 44 import com.sun.source.doctree.DocTree;
 45 import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem.Category;
 46 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
 47 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
 48 import jdk.javadoc.internal.doclets.formats.html.markup.TagName;
 49 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
 50 import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;
 51 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
 52 import jdk.javadoc.internal.doclets.toolkit.Content;
 53 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
 54 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 55 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 56 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
 57 import jdk.javadoc.internal.doclets.toolkit.util.IndexBuilder;
 58 import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;
 59 
 60 /**
 61  * Generate Index for all the Member Names with Indexing in
 62  * Unicode Order. This class is a base class for {@link SingleIndexWriter} and
 63  * {@link SplitIndexWriter}. It uses the functionality from
 64  * {@link HtmlDocletWriter} to generate the Index Contents.
 65  *
 66  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 67  *  If you write code that depends on this, you do so at your own risk.
 68  *  This code and its internal interfaces are subject to change or
 69  *  deletion without notice.&lt;/b&gt;
 70  *
 71  * @see    IndexBuilder
 72  */
 73 public class AbstractIndexWriter extends HtmlDocletWriter {
 74 
 75     /**
 76      * The index of all the members with unicode character.
 77      */
 78     protected IndexBuilder indexBuilder;
 79 
 80     protected Navigation navBar;
 81 
 82     protected final Map&lt;Character, List&lt;SearchIndexItem&gt;&gt; tagSearchIndexMap;
 83 
 84     /**
 85      * This constructor will be used by {@link SplitIndexWriter}. Initializes
 86      * path to this file and relative path from this file.
 87      *
 88      * @param configuration  The current configuration
 89      * @param path       Path to the file which is getting generated.
 90      * @param indexBuilder Unicode based Index from {@link IndexBuilder}
 91      */
 92     protected AbstractIndexWriter(HtmlConfiguration configuration,
 93                                   DocPath path,
 94                                   IndexBuilder indexBuilder) {
 95         super(configuration, path);
 96         this.indexBuilder = indexBuilder;
 97         this.navBar = new Navigation(null, configuration, PageMode.INDEX, path);
 98         Stream&lt;SearchIndexItem&gt; items =
 99                 searchItems.itemsOfCategories(Category.INDEX, Category.SYSTEM_PROPERTY)
100                         .sorted(comparators.makeGenericSearchIndexComparator());
101         this.tagSearchIndexMap = buildSearchTagIndex(items);
102     }
103 
104     protected void addContents(Character uc, List&lt;IndexItem&gt; memberlist,
105             Content contentTree) {
106         addHeading(uc, contentTree);
107 
108         HtmlTree dl = HtmlTree.DL(HtmlStyle.index);
<a name="2" id="anc2"></a><span class="line-added">109         Map&lt;String,Integer&gt; duplicateLabelCheck = new HashMap&lt;&gt;();</span>
<span class="line-added">110         memberlist.forEach(e -&gt; duplicateLabelCheck.compute(e.getFullyQualifiedLabel(utils),</span>
<span class="line-added">111                 (k, v) -&gt; v == null ? 1 : v + 1));</span>
112         for (IndexItem indexItem : memberlist) {
<a name="3" id="anc3"></a><span class="line-modified">113             addDescription(indexItem, dl,</span>
<span class="line-added">114                     duplicateLabelCheck.get(indexItem.getFullyQualifiedLabel(utils)) &gt; 1);</span>
115         }
116         contentTree.add(dl);
117     }
118 
119     protected void addHeading(Character uc, Content contentTree) {
120         String unicode = uc.toString();
121         Content headContent = new StringContent(unicode);
122         HtmlTree heading = HtmlTree.HEADING(Headings.CONTENT_HEADING,
123                 HtmlStyle.title, headContent);
124         heading.setId(getNameForIndex(unicode));
125         contentTree.add(heading);
126     }
127 
<a name="4" id="anc4"></a><span class="line-modified">128     protected void addDescription(IndexItem indexItem, Content dl, boolean addModuleInfo) {</span>
129         SearchIndexItem si = indexItem.getSearchTag();
130         if (si != null) {
131             addDescription(si, dl);
132         } else {
133             si = new SearchIndexItem();
134             si.setLabel(indexItem.getLabel());
<a name="5" id="anc5"></a><span class="line-modified">135             addElementDescription(indexItem, dl, si, addModuleInfo);</span>
136             searchItems.add(si);
137         }
138     }
139 
140     /**
141      * Add one line summary comment for the element.
142      *
143      * @param indexItem the element to be documented
144      * @param dlTree the content tree to which the description will be added
145      * @param si the search index item
<a name="6" id="anc6"></a><span class="line-added">146      * @param addModuleInfo whether to include module information</span>
147      */
<a name="7" id="anc7"></a><span class="line-modified">148     protected void addElementDescription(IndexItem indexItem, Content dlTree, SearchIndexItem si,</span>
<span class="line-added">149                                          boolean addModuleInfo) {</span>
150         Content dt;
151         Element element = indexItem.getElement();
152         String label = indexItem.getLabel();
153         switch (element.getKind()) {
154             case MODULE:
155                 dt = HtmlTree.DT(getModuleLink((ModuleElement)element, new StringContent(label)));
156                 si.setCategory(Category.MODULES);
157                 dt.add(&quot; - &quot;).add(contents.module_).add(&quot; &quot; + label);
158                 break;
159             case PACKAGE:
160                 dt = HtmlTree.DT(getPackageLink((PackageElement)element, new StringContent(label)));
161                 if (configuration.showModules) {
162                     si.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));
163                 }
164                 si.setCategory(Category.PACKAGES);
165                 dt.add(&quot; - &quot;).add(contents.package_).add(&quot; &quot; + label);
166                 break;
167             case CLASS:
168             case ENUM:
169             case RECORD:
170             case ANNOTATION_TYPE:
171             case INTERFACE:
172                 dt = HtmlTree.DT(getLink(new LinkInfoImpl(configuration,
173                         LinkInfoImpl.Kind.INDEX, (TypeElement)element).strong(true)));
174                 si.setContainingPackage(utils.getPackageName(utils.containingPackage(element)));
<a name="8" id="anc8"></a><span class="line-added">175                 if (configuration.showModules &amp;&amp; addModuleInfo) {</span>
<span class="line-added">176                     si.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));</span>
<span class="line-added">177                 }</span>
178                 si.setCategory(Category.TYPES);
179                 dt.add(&quot; - &quot;);
180                 addClassInfo((TypeElement)element, dt);
181                 break;
182             default:
183                 TypeElement containingType = indexItem.getTypeElement();
184                 dt = HtmlTree.DT(HtmlTree.SPAN(HtmlStyle.memberNameLink,
185                         getDocLink(LinkInfoImpl.Kind.INDEX, containingType, element, new StringContent(label))));
186                 si.setContainingPackage(utils.getPackageName(utils.containingPackage(element)));
187                 si.setContainingClass(utils.getSimpleName(containingType));
<a name="9" id="anc9"></a><span class="line-added">188                 if (configuration.showModules &amp;&amp; addModuleInfo) {</span>
<span class="line-added">189                     si.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));</span>
<span class="line-added">190                 }</span>
191                 if (utils.isExecutableElement(element)) {
192                     String url = HtmlTree.encodeURL(links.getName(getAnchor((ExecutableElement)element)));
193                     if (!label.equals(url)) {
194                         si.setUrl(url);
195                     }
196                 }
197                 si.setCategory(Category.MEMBERS);
198                 dt.add(&quot; - &quot;);
199                 addMemberDesc(element, containingType, dt);
200                 break;
201         }
202         dlTree.add(dt);
203         Content dd = new HtmlTree(TagName.DD);
204         if (element.getKind() == ElementKind.MODULE || element.getKind() == ElementKind.PACKAGE) {
205             addSummaryComment(element, dd);
206         } else {
207             addComment(element, dd);
208         }
209         dlTree.add(dd);
210     }
211 
212     /**
213      * Add the classkind (class, interface, exception), error of the class
214      * passed.
215      *
216      * @param te the class being documented
217      * @param contentTree the content tree to which the class info will be added
218      */
219     protected void addClassInfo(TypeElement te, Content contentTree) {
220         contentTree.add(contents.getContent(&quot;doclet.in&quot;,
221                 utils.getTypeElementName(te, false),
222                 getPackageLink(utils.containingPackage(te),
223                     utils.getPackageName(utils.containingPackage(te)))
224                 ));
225     }
226 
227     protected void addDescription(SearchIndexItem sii, Content dlTree) {
228         String siiPath = pathToRoot.isEmpty() ? &quot;&quot; : pathToRoot.getPath() + &quot;/&quot;;
229         siiPath += sii.getUrl();
230         HtmlTree labelLink = HtmlTree.A(siiPath, new StringContent(sii.getLabel()));
231         Content dt = HtmlTree.DT(HtmlTree.SPAN(HtmlStyle.searchTagLink, labelLink));
232         dt.add(&quot; - &quot;);
233         dt.add(contents.getContent(&quot;doclet.Search_tag_in&quot;, sii.getHolder()));
234         dlTree.add(dt);
235         Content dd = new HtmlTree(TagName.DD);
236         if (sii.getDescription().isEmpty()) {
237             dd.add(Entity.NO_BREAK_SPACE);
238         } else {
239             dd.add(sii.getDescription());
240         }
241         dlTree.add(dd);
242     }
243 
244     /**
245      * Add comment for each element in the index. If the element is deprecated
246      * and it has a @deprecated tag, use that comment. Else if the containing
247      * class for this element is deprecated, then add the word &quot;Deprecated.&quot; at
248      * the start and then print the normal comment.
249      *
250      * @param element Index element
251      * @param contentTree the content tree to which the comment will be added
252      */
253     protected void addComment(Element element, Content contentTree) {
254         List&lt;? extends DocTree&gt; tags;
255         Content span = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(element));
256         HtmlTree div = new HtmlTree(TagName.DIV);
257         div.setStyle(HtmlStyle.deprecationBlock);
258         if (utils.isDeprecated(element)) {
259             div.add(span);
260             tags = utils.getBlockTags(element, DocTree.Kind.DEPRECATED);
261             if (!tags.isEmpty())
262                 addInlineDeprecatedComment(element, tags.get(0), div);
263             contentTree.add(div);
264         } else {
265             TypeElement encl = utils.getEnclosingTypeElement(element);
266             while (encl != null) {
267                 if (utils.isDeprecated(encl)) {
268                     div.add(span);
269                     contentTree.add(div);
270                     break;
271                 }
272                 encl = utils.getEnclosingTypeElement(encl);
273             }
274             addSummaryComment(element, contentTree);
275         }
276     }
277 
278     /**
279      * Add description about the Static Variable/Method/Constructor for a
280      * member.
281      *
282      * @param member element for the member
283      * @param enclosing the enclosing type element
284      * @param contentTree the content tree to which the member description will be added
285      */
286     protected void addMemberDesc(Element member, TypeElement enclosing, Content contentTree) {
287         String classdesc = utils.getTypeElementName(enclosing, true) + &quot; &quot;;
288         if (utils.isField(member)) {
289             Content resource = contents.getContent(utils.isStatic(member)
290                     ? &quot;doclet.Static_variable_in&quot;
291                     : &quot;doclet.Variable_in&quot;, classdesc);
292             contentTree.add(resource);
293         } else if (utils.isConstructor(member)) {
294             contentTree.add(
295                     contents.getContent(&quot;doclet.Constructor_for&quot;, classdesc));
296         } else if (utils.isMethod(member)) {
297             Content resource = contents.getContent(utils.isStatic(member)
298                     ? &quot;doclet.Static_method_in&quot;
299                     : &quot;doclet.Method_in&quot;, classdesc);
300             contentTree.add(resource);
301         }
302         addPreQualifiedClassLink(LinkInfoImpl.Kind.INDEX, enclosing,
303                 false, contentTree);
304     }
305 
306     /**
307      * Generate a valid HTML name for member index page.
308      *
309      * @param unicode the string that needs to be converted to valid HTML name.
310      * @return a valid HTML name string.
311      */
312     public String getNameForIndex(String unicode) {
313         return &quot;I:&quot; + links.getName(unicode);
314     }
315 
316     /**
317      * @throws DocFileIOException if there is a problem creating any of the search index files
318      */
319     protected void createSearchIndexFiles() throws DocFileIOException {
320         if (configuration.showModules) {
321             createSearchIndexFile(DocPaths.MODULE_SEARCH_INDEX_JS,
322                                   searchItems.itemsOfCategories(Category.MODULES),
323                                   &quot;moduleSearchIndex&quot;);
324         }
325         if (!configuration.packages.isEmpty()) {
326             SearchIndexItem si = new SearchIndexItem();
327             si.setCategory(Category.PACKAGES);
328             si.setLabel(resources.getText(&quot;doclet.All_Packages&quot;));
329             si.setUrl(DocPaths.ALLPACKAGES_INDEX.getPath());
330             searchItems.add(si);
331         }
332         createSearchIndexFile(DocPaths.PACKAGE_SEARCH_INDEX_JS,
333                               searchItems.itemsOfCategories(Category.PACKAGES),
334                               &quot;packageSearchIndex&quot;);
335         SearchIndexItem si = new SearchIndexItem();
336         si.setCategory(Category.TYPES);
337         si.setLabel(resources.getText(&quot;doclet.All_Classes&quot;));
338         si.setUrl(DocPaths.ALLCLASSES_INDEX.getPath());
339         searchItems.add(si);
340         createSearchIndexFile(DocPaths.TYPE_SEARCH_INDEX_JS,
341                               searchItems.itemsOfCategories(Category.TYPES),
342                               &quot;typeSearchIndex&quot;);
343         createSearchIndexFile(DocPaths.MEMBER_SEARCH_INDEX_JS,
344                               searchItems.itemsOfCategories(Category.MEMBERS),
345                               &quot;memberSearchIndex&quot;);
346         createSearchIndexFile(DocPaths.TAG_SEARCH_INDEX_JS,
347                               searchItems.itemsOfCategories(Category.INDEX, Category.SYSTEM_PROPERTY),
348                               &quot;tagSearchIndex&quot;);
349     }
350 
351     /**
352      * Creates a search index file.
353      *
354      * @param searchIndexJS     the file for the JavaScript to be generated
355      * @param searchIndex       the search index items
356      * @param varName           the variable name to write in the JavaScript file
357      * @throws DocFileIOException if there is a problem creating the search index file
358      */
359     protected void createSearchIndexFile(DocPath searchIndexJS,
360                                          Stream&lt;SearchIndexItem&gt; searchIndex,
361                                          String varName)
362             throws DocFileIOException
363     {
364         // The file needs to be created even if there are no searchIndex items
365         // File could be written straight-through, without an intermediate StringBuilder
366         Iterator&lt;SearchIndexItem&gt; index = searchIndex.iterator();
367         if (index.hasNext()) {
368             StringBuilder searchVar = new StringBuilder(&quot;[&quot;);
369             boolean first = true;
370             while (index.hasNext()) {
371                 SearchIndexItem item = index.next();
372                 if (first) {
373                     searchVar.append(item.toString());
374                     first = false;
375                 } else {
376                     searchVar.append(&quot;,&quot;).append(item.toString());
377                 }
378             }
379             searchVar.append(&quot;]&quot;);
380             DocFile jsFile = DocFile.createFileForOutput(configuration, searchIndexJS);
381             try (Writer wr = jsFile.openWriter()) {
382                 wr.write(varName);
383                 wr.write(&quot; = &quot;);
384                 wr.write(searchVar.toString());
385             } catch (IOException ie) {
386                 throw new DocFileIOException(jsFile, DocFileIOException.Mode.WRITE, ie);
387             }
388         }
389     }
390 
391     private static Map&lt;Character, List&lt;SearchIndexItem&gt;&gt; buildSearchTagIndex(
392             Stream&lt;? extends SearchIndexItem&gt; searchItems)
393     {
394         return searchItems.collect(Collectors.groupingBy(i -&gt; keyCharacter(i.getLabel())));
395     }
396 
397     protected static Character keyCharacter(String s) {
398         return s.isEmpty() ? &#39;*&#39; : Character.toUpperCase(s.charAt(0));
399     }
400 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
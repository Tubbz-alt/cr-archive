<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/abstractInterpreter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../gc/z/zRootsIterator.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="abstractInterpreter.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/abstractInterpreter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.hpp&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;compiler/disassembler.hpp&quot;
 29 #include &quot;interpreter/bytecodeHistogram.hpp&quot;
<span class="line-removed"> 30 #include &quot;interpreter/bytecodeInterpreter.hpp&quot;</span>
 31 #include &quot;interpreter/bytecodeStream.hpp&quot;
 32 #include &quot;interpreter/interpreter.hpp&quot;
 33 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 34 #include &quot;interpreter/interp_masm.hpp&quot;
 35 #include &quot;interpreter/templateTable.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;memory/metaspaceShared.hpp&quot;
 38 #include &quot;memory/resourceArea.hpp&quot;
 39 #include &quot;oops/arrayOop.hpp&quot;
 40 #include &quot;oops/constantPool.hpp&quot;
 41 #include &quot;oops/cpCache.inline.hpp&quot;
 42 #include &quot;oops/methodData.hpp&quot;
 43 #include &quot;oops/method.hpp&quot;
 44 #include &quot;oops/oop.inline.hpp&quot;
 45 #include &quot;prims/forte.hpp&quot;
 46 #include &quot;prims/jvmtiExport.hpp&quot;
 47 #include &quot;prims/methodHandles.hpp&quot;
 48 #include &quot;runtime/handles.inline.hpp&quot;
 49 #include &quot;runtime/sharedRuntime.hpp&quot;
 50 #include &quot;runtime/stubRoutines.hpp&quot;
</pre>
<hr />
<pre>
104 }
105 
106 
107 //------------------------------------------------------------------------------------------------------------------------
108 // Entry points
109 
110 AbstractInterpreter::MethodKind AbstractInterpreter::method_kind(const methodHandle&amp; m) {
111   // Abstract method?
112   if (m-&gt;is_abstract()) return abstract;
113 
114   // Method handle primitive?
115   if (m-&gt;is_method_handle_intrinsic()) {
116     vmIntrinsics::ID id = m-&gt;intrinsic_id();
117     assert(MethodHandles::is_signature_polymorphic(id), &quot;must match an intrinsic&quot;);
118     MethodKind kind = (MethodKind)( method_handle_invoke_FIRST +
119                                     ((int)id - vmIntrinsics::FIRST_MH_SIG_POLY) );
120     assert(kind &lt;= method_handle_invoke_LAST, &quot;parallel enum ranges&quot;);
121     return kind;
122   }
123 
<span class="line-modified">124 #ifndef CC_INTERP</span>
125   switch (m-&gt;intrinsic_id()) {
126     // Use optimized stub code for CRC32 native methods.
127     case vmIntrinsics::_updateCRC32            : return java_util_zip_CRC32_update;
128     case vmIntrinsics::_updateBytesCRC32       : return java_util_zip_CRC32_updateBytes;
129     case vmIntrinsics::_updateByteBufferCRC32  : return java_util_zip_CRC32_updateByteBuffer;
130     // Use optimized stub code for CRC32C methods.
131     case vmIntrinsics::_updateBytesCRC32C             : return java_util_zip_CRC32C_updateBytes;
132     case vmIntrinsics::_updateDirectByteBufferCRC32C  : return java_util_zip_CRC32C_updateDirectByteBuffer;
133     case vmIntrinsics::_intBitsToFloat:      return java_lang_Float_intBitsToFloat;
134     case vmIntrinsics::_floatToRawIntBits:   return java_lang_Float_floatToRawIntBits;
135     case vmIntrinsics::_longBitsToDouble:    return java_lang_Double_longBitsToDouble;
136     case vmIntrinsics::_doubleToRawLongBits: return java_lang_Double_doubleToRawLongBits;
137     default:                                 break;
138   }
<span class="line-modified">139 #endif // CC_INTERP</span>
140 
141   // Native method?
142   // Note: This test must come _before_ the test for intrinsic
143   //       methods. See also comments below.
144   if (m-&gt;is_native()) {
145     assert(!m-&gt;is_method_handle_intrinsic(), &quot;overlapping bits here, watch out&quot;);
146     return m-&gt;is_synchronized() ? native_synchronized : native;
147   }
148 
149   // Synchronized?
150   if (m-&gt;is_synchronized()) {
151     return zerolocals_synchronized;
152   }
153 
154   if (RegisterFinalizersAtInit &amp;&amp; m-&gt;code_size() == 1 &amp;&amp;
155       m-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
156     // We need to execute the special return bytecode to check for
157     // finalizer registration so create a normal frame.
158     return zerolocals;
159   }
</pre>
<hr />
<pre>
172     case vmIntrinsics::_dsin  : return java_lang_math_sin  ;
173     case vmIntrinsics::_dcos  : return java_lang_math_cos  ;
174     case vmIntrinsics::_dtan  : return java_lang_math_tan  ;
175     case vmIntrinsics::_dabs  : return java_lang_math_abs  ;
176     case vmIntrinsics::_dsqrt : return java_lang_math_sqrt ;
177     case vmIntrinsics::_dlog  : return java_lang_math_log  ;
178     case vmIntrinsics::_dlog10: return java_lang_math_log10;
179     case vmIntrinsics::_dpow  : return java_lang_math_pow  ;
180     case vmIntrinsics::_dexp  : return java_lang_math_exp  ;
181     case vmIntrinsics::_fmaD  : return java_lang_math_fmaD ;
182     case vmIntrinsics::_fmaF  : return java_lang_math_fmaF ;
183 
184     case vmIntrinsics::_Reference_get
185                               : return java_lang_ref_reference_get;
186     default                   : break;
187   }
188 
189   // Accessor method?
190   if (m-&gt;is_getter()) {
191     // TODO: We should have used ::is_accessor above, but fast accessors in Zero expect only getters.
<span class="line-modified">192     // See CppInterpreter::accessor_entry in cppInterpreter_zero.cpp. This should be fixed in Zero,</span>
193     // then the call above updated to ::is_accessor
194     assert(m-&gt;size_of_parameters() == 1, &quot;fast code for accessors assumes parameter size = 1&quot;);
195     return accessor;
196   }
197 
198   // Note: for now: zero locals for all non-empty methods
199   return zerolocals;
200 }
201 
202 #if INCLUDE_CDS
203 
204 address AbstractInterpreter::get_trampoline_code_buffer(AbstractInterpreter::MethodKind kind) {
205   const size_t trampoline_size = SharedRuntime::trampoline_size();
206   address addr = MetaspaceShared::i2i_entry_code_buffers((size_t)(AbstractInterpreter::number_of_method_entries) * trampoline_size);
207   addr += (size_t)(kind) * trampoline_size;
208 
209   return addr;
210 }
211 
212 void AbstractInterpreter::update_cds_entry_table(AbstractInterpreter::MethodKind kind) {
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.hpp&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;compiler/disassembler.hpp&quot;
 29 #include &quot;interpreter/bytecodeHistogram.hpp&quot;

 30 #include &quot;interpreter/bytecodeStream.hpp&quot;
 31 #include &quot;interpreter/interpreter.hpp&quot;
 32 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 33 #include &quot;interpreter/interp_masm.hpp&quot;
 34 #include &quot;interpreter/templateTable.hpp&quot;
 35 #include &quot;memory/allocation.inline.hpp&quot;
 36 #include &quot;memory/metaspaceShared.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;
 38 #include &quot;oops/arrayOop.hpp&quot;
 39 #include &quot;oops/constantPool.hpp&quot;
 40 #include &quot;oops/cpCache.inline.hpp&quot;
 41 #include &quot;oops/methodData.hpp&quot;
 42 #include &quot;oops/method.hpp&quot;
 43 #include &quot;oops/oop.inline.hpp&quot;
 44 #include &quot;prims/forte.hpp&quot;
 45 #include &quot;prims/jvmtiExport.hpp&quot;
 46 #include &quot;prims/methodHandles.hpp&quot;
 47 #include &quot;runtime/handles.inline.hpp&quot;
 48 #include &quot;runtime/sharedRuntime.hpp&quot;
 49 #include &quot;runtime/stubRoutines.hpp&quot;
</pre>
<hr />
<pre>
103 }
104 
105 
106 //------------------------------------------------------------------------------------------------------------------------
107 // Entry points
108 
109 AbstractInterpreter::MethodKind AbstractInterpreter::method_kind(const methodHandle&amp; m) {
110   // Abstract method?
111   if (m-&gt;is_abstract()) return abstract;
112 
113   // Method handle primitive?
114   if (m-&gt;is_method_handle_intrinsic()) {
115     vmIntrinsics::ID id = m-&gt;intrinsic_id();
116     assert(MethodHandles::is_signature_polymorphic(id), &quot;must match an intrinsic&quot;);
117     MethodKind kind = (MethodKind)( method_handle_invoke_FIRST +
118                                     ((int)id - vmIntrinsics::FIRST_MH_SIG_POLY) );
119     assert(kind &lt;= method_handle_invoke_LAST, &quot;parallel enum ranges&quot;);
120     return kind;
121   }
122 
<span class="line-modified">123 #ifndef ZERO</span>
124   switch (m-&gt;intrinsic_id()) {
125     // Use optimized stub code for CRC32 native methods.
126     case vmIntrinsics::_updateCRC32            : return java_util_zip_CRC32_update;
127     case vmIntrinsics::_updateBytesCRC32       : return java_util_zip_CRC32_updateBytes;
128     case vmIntrinsics::_updateByteBufferCRC32  : return java_util_zip_CRC32_updateByteBuffer;
129     // Use optimized stub code for CRC32C methods.
130     case vmIntrinsics::_updateBytesCRC32C             : return java_util_zip_CRC32C_updateBytes;
131     case vmIntrinsics::_updateDirectByteBufferCRC32C  : return java_util_zip_CRC32C_updateDirectByteBuffer;
132     case vmIntrinsics::_intBitsToFloat:      return java_lang_Float_intBitsToFloat;
133     case vmIntrinsics::_floatToRawIntBits:   return java_lang_Float_floatToRawIntBits;
134     case vmIntrinsics::_longBitsToDouble:    return java_lang_Double_longBitsToDouble;
135     case vmIntrinsics::_doubleToRawLongBits: return java_lang_Double_doubleToRawLongBits;
136     default:                                 break;
137   }
<span class="line-modified">138 #endif // ZERO</span>
139 
140   // Native method?
141   // Note: This test must come _before_ the test for intrinsic
142   //       methods. See also comments below.
143   if (m-&gt;is_native()) {
144     assert(!m-&gt;is_method_handle_intrinsic(), &quot;overlapping bits here, watch out&quot;);
145     return m-&gt;is_synchronized() ? native_synchronized : native;
146   }
147 
148   // Synchronized?
149   if (m-&gt;is_synchronized()) {
150     return zerolocals_synchronized;
151   }
152 
153   if (RegisterFinalizersAtInit &amp;&amp; m-&gt;code_size() == 1 &amp;&amp;
154       m-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
155     // We need to execute the special return bytecode to check for
156     // finalizer registration so create a normal frame.
157     return zerolocals;
158   }
</pre>
<hr />
<pre>
171     case vmIntrinsics::_dsin  : return java_lang_math_sin  ;
172     case vmIntrinsics::_dcos  : return java_lang_math_cos  ;
173     case vmIntrinsics::_dtan  : return java_lang_math_tan  ;
174     case vmIntrinsics::_dabs  : return java_lang_math_abs  ;
175     case vmIntrinsics::_dsqrt : return java_lang_math_sqrt ;
176     case vmIntrinsics::_dlog  : return java_lang_math_log  ;
177     case vmIntrinsics::_dlog10: return java_lang_math_log10;
178     case vmIntrinsics::_dpow  : return java_lang_math_pow  ;
179     case vmIntrinsics::_dexp  : return java_lang_math_exp  ;
180     case vmIntrinsics::_fmaD  : return java_lang_math_fmaD ;
181     case vmIntrinsics::_fmaF  : return java_lang_math_fmaF ;
182 
183     case vmIntrinsics::_Reference_get
184                               : return java_lang_ref_reference_get;
185     default                   : break;
186   }
187 
188   // Accessor method?
189   if (m-&gt;is_getter()) {
190     // TODO: We should have used ::is_accessor above, but fast accessors in Zero expect only getters.
<span class="line-modified">191     // See ZeroInterpreter::accessor_entry in zeroInterpreter_zero.cpp. This should be fixed in Zero,</span>
192     // then the call above updated to ::is_accessor
193     assert(m-&gt;size_of_parameters() == 1, &quot;fast code for accessors assumes parameter size = 1&quot;);
194     return accessor;
195   }
196 
197   // Note: for now: zero locals for all non-empty methods
198   return zerolocals;
199 }
200 
201 #if INCLUDE_CDS
202 
203 address AbstractInterpreter::get_trampoline_code_buffer(AbstractInterpreter::MethodKind kind) {
204   const size_t trampoline_size = SharedRuntime::trampoline_size();
205   address addr = MetaspaceShared::i2i_entry_code_buffers((size_t)(AbstractInterpreter::number_of_method_entries) * trampoline_size);
206   addr += (size_t)(kind) * trampoline_size;
207 
208   return addr;
209 }
210 
211 void AbstractInterpreter::update_cds_entry_table(AbstractInterpreter::MethodKind kind) {
</pre>
</td>
</tr>
</table>
<center><a href="../gc/z/zRootsIterator.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="abstractInterpreter.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
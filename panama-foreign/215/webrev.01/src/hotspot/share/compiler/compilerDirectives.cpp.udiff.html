<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/compiler/compilerDirectives.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../code/nmethod.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compilerDirectives.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/compilerDirectives.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -31,13 +31,13 @@</span>
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  
  CompilerDirectives::CompilerDirectives() : _next(NULL), _match(NULL), _ref_count(0) {
    _c1_store = new DirectiveSet(this);
<span class="udiff-line-modified-removed">-   _c1_store-&gt;init_disableintrinsic();</span>
<span class="udiff-line-modified-added">+   _c1_store-&gt;init_control_intrinsic();</span>
    _c2_store = new DirectiveSet(this);
<span class="udiff-line-modified-removed">-   _c2_store-&gt;init_disableintrinsic();</span>
<span class="udiff-line-modified-added">+   _c2_store-&gt;init_control_intrinsic();</span>
  };
  
  CompilerDirectives::~CompilerDirectives() {
    if (_c1_store != NULL) {
      delete _c1_store;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -177,18 +177,18 @@</span>
      assert(comp-&gt;is_c1() || comp-&gt;is_jvmci(), &quot;&quot;);
      return _c1_store;
    }
  }
  
<span class="udiff-line-modified-removed">- // In the list of disabled intrinsics, the ID of the disabled intrinsics can separated:</span>
<span class="udiff-line-modified-removed">- // - by &#39;,&#39; (if -XX:DisableIntrinsic is used once when invoking the VM) or</span>
<span class="udiff-line-modified-removed">- // - by &#39;\n&#39; (if -XX:DisableIntrinsic is used multiple times when invoking the VM) or</span>
<span class="udiff-line-modified-removed">- // - by &#39; &#39; (if DisableIntrinsic is used on a per-method level, e.g., with CompileCommand).</span>
<span class="udiff-line-modified-added">+ // In the list of Control/disabled intrinsics, the ID of the control intrinsics can separated:</span>
<span class="udiff-line-modified-added">+ // - by &#39;,&#39; (if -XX:Control/DisableIntrinsic is used once when invoking the VM) or</span>
<span class="udiff-line-modified-added">+ // - by &#39;\n&#39; (if -XX:Control/DisableIntrinsic is used multiple times when invoking the VM) or</span>
<span class="udiff-line-modified-added">+ // - by &#39; &#39; (if Control/DisableIntrinsic is used on a per-method level, e.g., with CompileCommand).</span>
  //
<span class="udiff-line-modified-removed">- // To simplify the processing of the list, the canonicalize_disableintrinsic() method</span>
<span class="udiff-line-modified-added">+ // To simplify the processing of the list, the canonicalize_control_intrinsic() method</span>
  // returns a new copy of the list in which &#39;\n&#39; and &#39; &#39; is replaced with &#39;,&#39;.
<span class="udiff-line-modified-removed">- ccstrlist DirectiveSet::canonicalize_disableintrinsic(ccstrlist option_value) {</span>
<span class="udiff-line-modified-added">+ ccstrlist DirectiveSet::canonicalize_control_intrinsic(ccstrlist option_value) {</span>
    char* canonicalized_list = NEW_C_HEAP_ARRAY(char, strlen(option_value) + 1, mtCompiler);
    int i = 0;
    char current;
    while ((current = option_value[i]) != &#39;\0&#39;) {
      if (current == &#39;\n&#39; || current == &#39; &#39;) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -200,37 +200,80 @@</span>
    }
    canonicalized_list[i] = &#39;\0&#39;;
    return canonicalized_list;
  }
  
<span class="udiff-line-modified-removed">- void DirectiveSet::init_disableintrinsic() {</span>
<span class="udiff-line-modified-removed">-   // Canonicalize DisableIntrinsic to contain only &#39;,&#39; as a separator.</span>
<span class="udiff-line-modified-removed">-   this-&gt;DisableIntrinsicOption = canonicalize_disableintrinsic(DisableIntrinsic);</span>
<span class="udiff-line-modified-added">+ ControlIntrinsicIter::ControlIntrinsicIter(ccstrlist option_value, bool disable_all)</span>
<span class="udiff-line-modified-added">+   : _disableIntrinsic(disable_all) {</span>
<span class="udiff-line-modified-added">+   _list = (char*)DirectiveSet::canonicalize_control_intrinsic(option_value);</span>
<span class="udiff-line-added">+   _saved_ptr = _list;</span>
<span class="udiff-line-added">+   _enabled = false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   _token = strtok_r(_saved_ptr, &quot;,&quot;, &amp;_saved_ptr);</span>
<span class="udiff-line-added">+   next_token();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ControlIntrinsicIter::~ControlIntrinsicIter() {</span>
<span class="udiff-line-added">+   FREE_C_HEAP_ARRAY(char, _list);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // pre-increment</span>
<span class="udiff-line-added">+ ControlIntrinsicIter&amp; ControlIntrinsicIter::operator++() {</span>
<span class="udiff-line-added">+   _token = strtok_r(NULL, &quot;,&quot;, &amp;_saved_ptr);</span>
<span class="udiff-line-added">+   next_token();</span>
<span class="udiff-line-added">+   return *this;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ControlIntrinsicIter::next_token() {</span>
<span class="udiff-line-added">+   if (_token &amp;&amp; !_disableIntrinsic) {</span>
<span class="udiff-line-added">+     char ch = _token[0];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (ch != &#39;+&#39; &amp;&amp; ch != &#39;-&#39;) {</span>
<span class="udiff-line-added">+       warning(&quot;failed to parse %s. must start with +/-!&quot;, _token);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       _enabled = ch == &#39;+&#39;;</span>
<span class="udiff-line-added">+       _token++;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void DirectiveSet::init_control_intrinsic() {</span>
<span class="udiff-line-added">+   for (ControlIntrinsicIter iter(ControlIntrinsic); *iter != NULL; ++iter) {</span>
<span class="udiff-line-added">+     vmIntrinsics::ID id = vmIntrinsics::find_id(*iter);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (id != vmIntrinsics::_none) {</span>
<span class="udiff-line-added">+       _intrinsic_control_words[id] = iter.is_enabled();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Order matters, DisableIntrinsic can overwrite ControlIntrinsic</span>
<span class="udiff-line-added">+   for (ControlIntrinsicIter iter(DisableIntrinsic, true/*disable_all*/); *iter != NULL; ++iter) {</span>
<span class="udiff-line-added">+     vmIntrinsics::ID id = vmIntrinsics::find_id(*iter);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (id != vmIntrinsics::_none) {</span>
<span class="udiff-line-added">+       _intrinsic_control_words[id] = false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  }
  
  DirectiveSet::DirectiveSet(CompilerDirectives* d) :_inlinematchers(NULL), _directive(d) {
  #define init_defaults_definition(name, type, dvalue, compiler) this-&gt;name##Option = dvalue;
    compilerdirectives_common_flags(init_defaults_definition)
    compilerdirectives_c2_flags(init_defaults_definition)
    compilerdirectives_c1_flags(init_defaults_definition)
    memset(_modified, 0, sizeof(_modified));
<span class="udiff-line-added">+   _intrinsic_control_words.fill_in(/*default value*/TriBool());</span>
  }
  
  DirectiveSet::~DirectiveSet() {
    // remove all linked methodmatchers
    InlineMatcher* tmp = _inlinematchers;
    while (tmp != NULL) {
      InlineMatcher* next = tmp-&gt;next();
      delete tmp;
      tmp = next;
    }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // When constructed, DirectiveSet canonicalizes the DisableIntrinsic flag</span>
<span class="udiff-line-removed">-   // into a new string. Therefore, that string is deallocated when</span>
<span class="udiff-line-removed">-   // the DirectiveSet is destroyed.</span>
<span class="udiff-line-removed">-   assert(this-&gt;DisableIntrinsicOption != NULL, &quot;&quot;);</span>
<span class="udiff-line-removed">-   FREE_C_HEAP_ARRAY(char, (void *)this-&gt;DisableIntrinsicOption);</span>
  }
  
  // Backward compatibility for CompileCommands
  // Breaks the abstraction and causes lots of extra complexity
  // - if some option is changed we need to copy directiveset since it no longer can be shared
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -278,27 +321,57 @@</span>
          set-&gt;ExcludeOption = true;
          changed = true;
        }
      }
  
<span class="udiff-line-removed">-     // Read old value of DisableIntrinsicOption, in case we need to free it</span>
<span class="udiff-line-removed">-     // and overwrite it with a new value.</span>
<span class="udiff-line-removed">-     ccstrlist old_disable_intrinsic_value = set-&gt;DisableIntrinsicOption;</span>
<span class="udiff-line-removed">- </span>
      // inline and dontinline (including exclude) are implemented in the directiveset accessors
  #define init_default_cc(name, type, dvalue, cc_flag) { type v; if (!_modified[name##Index] &amp;&amp; CompilerOracle::has_option_value(method, #cc_flag, v) &amp;&amp; v != this-&gt;name##Option) { set-&gt;name##Option = v; changed = true;} }
      compilerdirectives_common_flags(init_default_cc)
      compilerdirectives_c2_flags(init_default_cc)
      compilerdirectives_c1_flags(init_default_cc)
  
      // Canonicalize DisableIntrinsic to contain only &#39;,&#39; as a separator.
      ccstrlist option_value;
<span class="udiff-line-added">+     bool need_reset = true; // if Control/DisableIntrinsic redefined, only need to reset control_words once</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!_modified[ControlIntrinsicIndex] &amp;&amp;</span>
<span class="udiff-line-added">+         CompilerOracle::has_option_value(method, &quot;ControlIntrinsic&quot;, option_value)) {</span>
<span class="udiff-line-added">+       ControlIntrinsicIter iter(option_value);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (need_reset) {</span>
<span class="udiff-line-added">+         set-&gt;_intrinsic_control_words.fill_in(TriBool());</span>
<span class="udiff-line-added">+         need_reset = false;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       while (*iter != NULL) {</span>
<span class="udiff-line-added">+         vmIntrinsics::ID id = vmIntrinsics::find_id(*iter);</span>
<span class="udiff-line-added">+         if (id != vmIntrinsics::_none) {</span>
<span class="udiff-line-added">+           set-&gt;_intrinsic_control_words[id] = iter.is_enabled();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ++iter;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
      if (!_modified[DisableIntrinsicIndex] &amp;&amp;
          CompilerOracle::has_option_value(method, &quot;DisableIntrinsic&quot;, option_value)) {
<span class="udiff-line-modified-removed">-       set-&gt;DisableIntrinsicOption = canonicalize_disableintrinsic(option_value);</span>
<span class="udiff-line-modified-removed">-       assert(old_disable_intrinsic_value != NULL, &quot;&quot;);</span>
<span class="udiff-line-modified-removed">-       FREE_C_HEAP_ARRAY(char, (void *)old_disable_intrinsic_value);</span>
<span class="udiff-line-modified-added">+       ControlIntrinsicIter iter(option_value, true/*disable_all*/);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       if (need_reset) {</span>
<span class="udiff-line-added">+         set-&gt;_intrinsic_control_words.fill_in(TriBool());</span>
<span class="udiff-line-added">+         need_reset = false;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       while (*iter != NULL) {</span>
<span class="udiff-line-added">+         vmIntrinsics::ID id = vmIntrinsics::find_id(*iter);</span>
<span class="udiff-line-added">+         if (id != vmIntrinsics::_none) {</span>
<span class="udiff-line-added">+           set-&gt;_intrinsic_control_words[id] = false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ++iter;</span>
<span class="udiff-line-added">+       }</span>
      }
  
  
      if (!changed) {
        // We didn&#39;t actually update anything, discard.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -395,42 +468,27 @@</span>
    }
  }
  
  bool DirectiveSet::is_intrinsic_disabled(const methodHandle&amp; method) {
    vmIntrinsics::ID id = method-&gt;intrinsic_id();
<span class="udiff-line-modified-removed">-   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   ResourceMark rm;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Create a copy of the string that contains the list of disabled</span>
<span class="udiff-line-removed">-   // intrinsics. The copy is created because the string</span>
<span class="udiff-line-removed">-   // will be modified by strtok(). Then, the list is tokenized with</span>
<span class="udiff-line-removed">-   // &#39;,&#39; as a separator.</span>
<span class="udiff-line-removed">-   size_t length = strlen(DisableIntrinsicOption);</span>
<span class="udiff-line-removed">-   char* local_list = NEW_RESOURCE_ARRAY(char, length + 1);</span>
<span class="udiff-line-removed">-   strncpy(local_list, DisableIntrinsicOption, length + 1);</span>
<span class="udiff-line-removed">-   char* save_ptr;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   char* token = strtok_r(local_list, &quot;,&quot;, &amp;save_ptr);</span>
<span class="udiff-line-removed">-   while (token != NULL) {</span>
<span class="udiff-line-removed">-     if (strcmp(token, vmIntrinsics::name_at(id)) == 0) {</span>
<span class="udiff-line-removed">-       return true;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       token = strtok_r(NULL, &quot;,&quot;, &amp;save_ptr);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   assert(id &gt; vmIntrinsics::_none &amp;&amp; id &lt; vmIntrinsics::ID_LIMIT, &quot;invalid intrinsic_id!&quot;);</span>
  
<span class="udiff-line-modified-removed">-   return false;</span>
<span class="udiff-line-modified-added">+   TriBool b = _intrinsic_control_words[id];</span>
<span class="udiff-line-added">+   if (b.is_default()) {</span>
<span class="udiff-line-added">+     return false; // if unset, every intrinsic is enabled.</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     return !b;</span>
<span class="udiff-line-added">+   }</span>
  }
  
  DirectiveSet* DirectiveSet::clone(DirectiveSet const* src) {
    DirectiveSet* set = new DirectiveSet(NULL);
<span class="udiff-line-modified-removed">-   // Ordinary allocations of DirectiveSet would call init_disableintrinsic()</span>
<span class="udiff-line-modified-removed">-   // immediately to create a new copy for set-&gt;DisableIntrinsicOption.</span>
<span class="udiff-line-modified-added">+   // Ordinary allocations of DirectiveSet would call init_control_intrinsic()</span>
<span class="udiff-line-modified-added">+   // immediately to create a new copy for set-&gt;Control/DisableIntrinsicOption.</span>
    // However, here it does not need to because the code below creates
<span class="udiff-line-modified-removed">-   // a copy of src-&gt;DisableIntrinsicOption that initializes</span>
<span class="udiff-line-modified-removed">-   // set-&gt;DisableIntrinsicOption.</span>
<span class="udiff-line-modified-added">+   // a copy of src-&gt;Control/DisableIntrinsicOption that initializes</span>
<span class="udiff-line-modified-added">+   // set-&gt;Control/DisableIntrinsicOption.</span>
  
    memcpy(set-&gt;_modified, src-&gt;_modified, sizeof(src-&gt;_modified));
  
    InlineMatcher* tmp = src-&gt;_inlinematchers;
    while (tmp != NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -441,17 +499,11 @@</span>
    #define copy_members_definition(name, type, dvalue, cc_flag) set-&gt;name##Option = src-&gt;name##Option;
      compilerdirectives_common_flags(copy_members_definition)
      compilerdirectives_c2_flags(copy_members_definition)
      compilerdirectives_c1_flags(copy_members_definition)
  
<span class="udiff-line-modified-removed">-   // Create a local copy of the DisableIntrinsicOption.</span>
<span class="udiff-line-removed">-   assert(src-&gt;DisableIntrinsicOption != NULL, &quot;&quot;);</span>
<span class="udiff-line-removed">-   size_t len = strlen(src-&gt;DisableIntrinsicOption) + 1;</span>
<span class="udiff-line-removed">-   char* s = NEW_C_HEAP_ARRAY(char, len, mtCompiler);</span>
<span class="udiff-line-removed">-   strncpy(s, src-&gt;DisableIntrinsicOption, len);</span>
<span class="udiff-line-removed">-   assert(s[len-1] == &#39;\0&#39;, &quot;&quot;);</span>
<span class="udiff-line-removed">-   set-&gt;DisableIntrinsicOption = s;</span>
<span class="udiff-line-modified-added">+   set-&gt;_intrinsic_control_words = src-&gt;_intrinsic_control_words;</span>
    return set;
  }
  
  // Create a new dirstack and push a default directive
  void DirectivesStack::init() {
</pre>
<center><a href="../code/nmethod.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compilerDirectives.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/z/zCollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
 26 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 27 #include &quot;gc/z/zCollectedHeap.hpp&quot;
 28 #include &quot;gc/z/zDirector.hpp&quot;
 29 #include &quot;gc/z/zDriver.hpp&quot;
 30 #include &quot;gc/z/zGlobals.hpp&quot;
 31 #include &quot;gc/z/zHeap.inline.hpp&quot;
 32 #include &quot;gc/z/zNMethod.hpp&quot;
 33 #include &quot;gc/z/zObjArrayAllocator.hpp&quot;
 34 #include &quot;gc/z/zOop.inline.hpp&quot;
 35 #include &quot;gc/z/zServiceability.hpp&quot;
 36 #include &quot;gc/z/zStat.hpp&quot;
 37 #include &quot;gc/z/zUtils.inline.hpp&quot;
 38 #include &quot;memory/iterator.hpp&quot;
 39 #include &quot;memory/universe.hpp&quot;
 40 #include &quot;runtime/mutexLocker.hpp&quot;
 41 #include &quot;utilities/align.hpp&quot;
 42 
 43 ZCollectedHeap* ZCollectedHeap::heap() {
 44   CollectedHeap* heap = Universe::heap();
 45   assert(heap != NULL, &quot;Uninitialized access to ZCollectedHeap::heap()&quot;);
 46   assert(heap-&gt;kind() == CollectedHeap::Z, &quot;Invalid name&quot;);
 47   return (ZCollectedHeap*)heap;
 48 }
 49 
 50 ZCollectedHeap::ZCollectedHeap() :
 51     _soft_ref_policy(),
 52     _barrier_set(),
 53     _initialize(&amp;_barrier_set),
 54     _heap(),
 55     _director(new ZDirector()),
 56     _driver(new ZDriver()),
 57     _stat(new ZStat()),
 58     _runtime_workers() {}
 59 
 60 CollectedHeap::Name ZCollectedHeap::kind() const {
 61   return CollectedHeap::Z;
 62 }
 63 
 64 const char* ZCollectedHeap::name() const {
 65   return ZName;
 66 }
 67 
 68 jint ZCollectedHeap::initialize() {
 69   if (!_heap.is_initialized()) {
 70     return JNI_ENOMEM;
 71   }
 72 
 73   Universe::calculate_verify_data((HeapWord*)0, (HeapWord*)UINTPTR_MAX);
 74 
 75   return JNI_OK;
 76 }
 77 
 78 void ZCollectedHeap::initialize_serviceability() {
 79   _heap.serviceability_initialize();
 80 }
 81 
 82 class ZStopConcurrentGCThreadClosure : public ThreadClosure {
 83 public:
 84   virtual void do_thread(Thread* thread) {
 85     if (thread-&gt;is_ConcurrentGC_thread() &amp;&amp;
 86         !thread-&gt;is_GC_task_thread()) {
 87       static_cast&lt;ConcurrentGCThread*&gt;(thread)-&gt;stop();
 88     }
 89   }
 90 };
 91 
 92 void ZCollectedHeap::stop() {
 93   ZStopConcurrentGCThreadClosure cl;
 94   gc_threads_do(&amp;cl);
 95 }
 96 
 97 SoftRefPolicy* ZCollectedHeap::soft_ref_policy() {
 98   return &amp;_soft_ref_policy;
 99 }
100 
101 size_t ZCollectedHeap::max_capacity() const {
102   return _heap.max_capacity();
103 }
104 
105 size_t ZCollectedHeap::capacity() const {
106   return _heap.capacity();
107 }
108 
109 size_t ZCollectedHeap::used() const {
110   return _heap.used();
111 }
112 
113 size_t ZCollectedHeap::unused() const {
114   return _heap.unused();
115 }
116 
117 bool ZCollectedHeap::is_maximal_no_gc() const {
118   // Not supported
119   ShouldNotReachHere();
120   return false;
121 }
122 
123 bool ZCollectedHeap::is_in(const void* p) const {
124   return _heap.is_in((uintptr_t)p);
125 }
126 
127 uint32_t ZCollectedHeap::hash_oop(oop obj) const {
128   return _heap.hash_oop(ZOop::to_address(obj));
129 }
130 
131 HeapWord* ZCollectedHeap::allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size) {
132   const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(requested_size));
133   const uintptr_t addr = _heap.alloc_tlab(size_in_bytes);
134 
135   if (addr != 0) {
136     *actual_size = requested_size;
137   }
138 
139   return (HeapWord*)addr;
140 }
141 
142 oop ZCollectedHeap::array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS) {
143   if (!do_zero) {
144     return CollectedHeap::array_allocate(klass, size, length, false /* do_zero */, THREAD);
145   }
146 
147   ZObjArrayAllocator allocator(klass, size, length, THREAD);
148   return allocator.allocate();
149 }
150 
151 HeapWord* ZCollectedHeap::mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) {
152   const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(size));
153   return (HeapWord*)_heap.alloc_object(size_in_bytes);
154 }
155 
156 MetaWord* ZCollectedHeap::satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
157                                                              size_t size,
158                                                              Metaspace::MetadataType mdtype) {
159   MetaWord* result;
160 
161   // Start asynchronous GC
162   collect(GCCause::_metadata_GC_threshold);
163 
164   // Expand and retry allocation
165   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
166   if (result != NULL) {
167     return result;
168   }
169 
170   // Start synchronous GC
171   collect(GCCause::_metadata_GC_clear_soft_refs);
172 
173   // Retry allocation
174   result = loader_data-&gt;metaspace_non_null()-&gt;allocate(size, mdtype);
175   if (result != NULL) {
176     return result;
177   }
178 
179   // Expand and retry allocation
180   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
181   if (result != NULL) {
182     return result;
183   }
184 
185   // Out of memory
186   return NULL;
187 }
188 
189 void ZCollectedHeap::collect(GCCause::Cause cause) {
190   _driver-&gt;collect(cause);
191 }
192 
193 void ZCollectedHeap::collect_as_vm_thread(GCCause::Cause cause) {
194   // These collection requests are ignored since ZGC can&#39;t run a synchronous
195   // GC cycle from within the VM thread. This is considered benign, since the
196   // only GC causes coming in here should be heap dumper and heap inspector.
197   // However, neither the heap dumper nor the heap inspector really need a GC
198   // to happen, but the result of their heap iterations might in that case be
199   // less accurate since they might include objects that would otherwise have
200   // been collected by a GC.
201   assert(Thread::current()-&gt;is_VM_thread(), &quot;Should be the VM thread&quot;);
202   guarantee(cause == GCCause::_heap_dump ||
203             cause == GCCause::_heap_inspection, &quot;Invalid cause&quot;);
204 }
205 
206 void ZCollectedHeap::do_full_collection(bool clear_all_soft_refs) {
207   // Not supported
208   ShouldNotReachHere();
209 }
210 
211 bool ZCollectedHeap::supports_tlab_allocation() const {
212   return true;
213 }
214 
215 size_t ZCollectedHeap::tlab_capacity(Thread* ignored) const {
216   return _heap.tlab_capacity();
217 }
218 
219 size_t ZCollectedHeap::tlab_used(Thread* ignored) const {
220   return _heap.tlab_used();
221 }
222 
223 size_t ZCollectedHeap::max_tlab_size() const {
224   return _heap.max_tlab_size();
225 }
226 
227 size_t ZCollectedHeap::unsafe_max_tlab_alloc(Thread* ignored) const {
228   return _heap.unsafe_max_tlab_alloc();
229 }
230 
231 bool ZCollectedHeap::can_elide_tlab_store_barriers() const {
232   return false;
233 }
234 
235 bool ZCollectedHeap::can_elide_initializing_store_barrier(oop new_obj) {
236   // Not supported
237   ShouldNotReachHere();
238   return true;
239 }
240 
241 bool ZCollectedHeap::card_mark_must_follow_store() const {
242   // Not supported
243   ShouldNotReachHere();
244   return false;
245 }
246 
247 GrowableArray&lt;GCMemoryManager*&gt; ZCollectedHeap::memory_managers() {
248   return GrowableArray&lt;GCMemoryManager*&gt;(1, 1, _heap.serviceability_memory_manager());
249 }
250 
251 GrowableArray&lt;MemoryPool*&gt; ZCollectedHeap::memory_pools() {
252   return GrowableArray&lt;MemoryPool*&gt;(1, 1, _heap.serviceability_memory_pool());
253 }
254 
255 void ZCollectedHeap::object_iterate(ObjectClosure* cl) {
256   _heap.object_iterate(cl, true /* visit_weaks */);
257 }
258 
259 void ZCollectedHeap::keep_alive(oop obj) {
260   _heap.keep_alive(obj);
261 }
262 
263 void ZCollectedHeap::register_nmethod(nmethod* nm) {
264   ZNMethod::register_nmethod(nm);
265 }
266 
267 void ZCollectedHeap::unregister_nmethod(nmethod* nm) {
268   ZNMethod::unregister_nmethod(nm);
269 }
270 
271 void ZCollectedHeap::flush_nmethod(nmethod* nm) {
272   ZNMethod::flush_nmethod(nm);
273 }
274 
275 void ZCollectedHeap::verify_nmethod(nmethod* nm) {
276   // Does nothing
277 }
278 
279 WorkGang* ZCollectedHeap::get_safepoint_workers() {
280   return _runtime_workers.workers();
281 }
282 
283 jlong ZCollectedHeap::millis_since_last_gc() {
284   return ZStatCycle::time_since_last() / MILLIUNITS;
285 }
286 
287 void ZCollectedHeap::gc_threads_do(ThreadClosure* tc) const {
288   tc-&gt;do_thread(_director);
289   tc-&gt;do_thread(_driver);
290   tc-&gt;do_thread(_stat);
291   _heap.threads_do(tc);
292   _runtime_workers.threads_do(tc);
293 }
294 
295 VirtualSpaceSummary ZCollectedHeap::create_heap_space_summary() {
296   return VirtualSpaceSummary((HeapWord*)0, (HeapWord*)capacity(), (HeapWord*)max_capacity());
297 }
298 
299 void ZCollectedHeap::safepoint_synchronize_begin() {
300   SuspendibleThreadSet::synchronize();
301 }
302 
303 void ZCollectedHeap::safepoint_synchronize_end() {
304   SuspendibleThreadSet::desynchronize();
305 }
306 
307 void ZCollectedHeap::prepare_for_verify() {
308   // Does nothing
309 }
310 
311 void ZCollectedHeap::print_on(outputStream* st) const {
312   _heap.print_on(st);
313 }
314 
315 void ZCollectedHeap::print_on_error(outputStream* st) const {
316   st-&gt;print_cr(&quot;ZGC Globals:&quot;);
317   st-&gt;print_cr(&quot; GlobalPhase:       %u (%s)&quot;, ZGlobalPhase, ZGlobalPhaseToString());
318   st-&gt;print_cr(&quot; GlobalSeqNum:      %u&quot;, ZGlobalSeqNum);
319   st-&gt;print_cr(&quot; Offset Max:        &quot; SIZE_FORMAT &quot;%s (&quot; PTR_FORMAT &quot;)&quot;,
320                byte_size_in_exact_unit(ZAddressOffsetMax),
321                exact_unit_for_byte_size(ZAddressOffsetMax),
322                ZAddressOffsetMax);
323   st-&gt;print_cr(&quot; Page Size Small:   &quot; SIZE_FORMAT &quot;M&quot;, ZPageSizeSmall / M);
324   st-&gt;print_cr(&quot; Page Size Medium:  &quot; SIZE_FORMAT &quot;M&quot;, ZPageSizeMedium / M);
325   st-&gt;cr();
326   st-&gt;print_cr(&quot;ZGC Metadata Bits:&quot;);
327   st-&gt;print_cr(&quot; Good:              &quot; PTR_FORMAT, ZAddressGoodMask);
328   st-&gt;print_cr(&quot; Bad:               &quot; PTR_FORMAT, ZAddressBadMask);
329   st-&gt;print_cr(&quot; WeakBad:           &quot; PTR_FORMAT, ZAddressWeakBadMask);
330   st-&gt;print_cr(&quot; Marked:            &quot; PTR_FORMAT, ZAddressMetadataMarked);
331   st-&gt;print_cr(&quot; Remapped:          &quot; PTR_FORMAT, ZAddressMetadataRemapped);
332   st-&gt;cr();
333   CollectedHeap::print_on_error(st);
334 }
335 
336 void ZCollectedHeap::print_extended_on(outputStream* st) const {
337   _heap.print_extended_on(st);
338 }
339 
340 void ZCollectedHeap::print_tracing_info() const {
341   // Does nothing
342 }
343 
344 bool ZCollectedHeap::print_location(outputStream* st, void* addr) const {
345   return _heap.print_location(st, (uintptr_t)addr);
346 }
347 
348 void ZCollectedHeap::verify(VerifyOption option /* ignored */) {
349   _heap.verify();
350 }
351 
352 bool ZCollectedHeap::is_oop(oop object) const {
353   return _heap.is_oop(ZOop::to_address(object));
354 }
355 
356 bool ZCollectedHeap::supports_concurrent_gc_breakpoints() const {
357   return true;
358 }
    </pre>
  </body>
</html>
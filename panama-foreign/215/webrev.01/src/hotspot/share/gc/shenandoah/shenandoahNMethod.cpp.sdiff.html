<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahMarkCompact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahNMethod.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
190   if (heap-&gt;is_concurrent_mark_in_progress()) {
191     if (heap-&gt;has_forwarded_objects()) {
192       ShenandoahKeepNMethodMetadataAliveClosure&lt;true&gt; cl;
193       data-&gt;oops_do(&amp;cl);
194     } else {
195       ShenandoahKeepNMethodMetadataAliveClosure&lt;false&gt; cl;
196       data-&gt;oops_do(&amp;cl);
197     }
198   } else if (heap-&gt;is_concurrent_weak_root_in_progress()) {
199     ShenandoahEvacOOMScope evac_scope;
200     heal_nmethod_metadata(data);
201   } else {
202     // There is possibility that GC is cancelled when it arrives final mark.
203     // In this case, concurrent root phase is skipped and degenerated GC should be
204     // followed, where nmethods are disarmed.
205     assert(heap-&gt;cancelled_gc(), &quot;What else?&quot;);
206   }
207 }
208 
209 #ifdef ASSERT
<span class="line-modified">210 void ShenandoahNMethod::assert_alive_and_correct() {</span>
<span class="line-removed">211   assert(_nm-&gt;is_alive(), &quot;only alive nmethods here&quot;);</span>
212   ShenandoahHeap* heap = ShenandoahHeap::heap();
213   for (int c = 0; c &lt; _oops_count; c++) {
214     oop *loc = _oops[c];
215     assert(_nm-&gt;code_contains((address) loc) || _nm-&gt;oops_contains(loc), &quot;nmethod should contain the oop*&quot;);
216     oop o = RawAccess&lt;&gt;::oop_load(loc);
217     shenandoah_assert_correct_except(loc, o, o == NULL || heap-&gt;is_full_gc_move_in_progress());
218   }
219 
220   oop* const begin = _nm-&gt;oops_begin();
221   oop* const end = _nm-&gt;oops_end();
222   for (oop* p = begin; p &lt; end; p++) {
223     if (*p != Universe::non_oop_word()) {
224       oop o = RawAccess&lt;&gt;::oop_load(p);
225       shenandoah_assert_correct_except(p, o, o == NULL || heap-&gt;is_full_gc_move_in_progress());
226     }
227   }
228 }
229 
230 class ShenandoahNMethodOopDetector : public OopClosure {
231 private:
</pre>
<hr />
<pre>
473   }
474 
475   ResourceMark rm;
476   log.print(&quot;Unregister NMethod: %s.%s [&quot; PTR_FORMAT &quot;]&quot;,
477             nm-&gt;method()-&gt;method_holder()-&gt;external_name(),
478             nm-&gt;method()-&gt;name()-&gt;as_C_string(),
479             p2i(nm));
480 }
481 
482 void ShenandoahNMethodTable::log_flush_nmethod(nmethod* nm) {
483   LogTarget(Debug, gc, nmethod) log;
484   if (!log.is_enabled()) {
485     return;
486   }
487 
488   ResourceMark rm;
489   log.print(&quot;Flush NMethod: (&quot; PTR_FORMAT &quot;)&quot;, p2i(nm));
490 }
491 
492 #ifdef ASSERT
<span class="line-modified">493 void ShenandoahNMethodTable::assert_nmethods_alive_and_correct() {</span>
494   assert_locked_or_safepoint(CodeCache_lock);
495 
496   for (int index = 0; index &lt; length(); index ++) {
497     ShenandoahNMethod* m = _list-&gt;at(index);
498     // Concurrent unloading may have dead nmethods to be cleaned by sweeper
499     if (m-&gt;is_unregistered()) continue;
<span class="line-modified">500     m-&gt;assert_alive_and_correct();</span>
501   }
502 }
503 #endif
504 
505 
506 ShenandoahNMethodList::ShenandoahNMethodList(int size) :
507   _size(size), _ref_count(1) {
508   _list = NEW_C_HEAP_ARRAY(ShenandoahNMethod*, size, mtGC);
509 }
510 
511 ShenandoahNMethodList::~ShenandoahNMethodList() {
512   assert(_list != NULL, &quot;Sanity&quot;);
513   assert(_ref_count == 0, &quot;Must be&quot;);
514   FREE_C_HEAP_ARRAY(ShenandoahNMethod*, _list);
515 }
516 
517 void ShenandoahNMethodList::transfer(ShenandoahNMethodList* const list, int limit) {
518   assert(limit &lt;= size(), &quot;Sanity&quot;);
519   ShenandoahNMethod** old_list = list-&gt;list();
520   for (int index = 0; index &lt; limit; index++) {
</pre>
<hr />
<pre>
546 
547 void ShenandoahNMethodTableSnapshot::parallel_blobs_do(CodeBlobClosure *f) {
548   size_t stride = 256; // educated guess
549 
550   ShenandoahNMethod** const list = _list-&gt;list();
551 
552   size_t max = (size_t)_limit;
553   while (_claimed &lt; max) {
554     size_t cur = Atomic::fetch_and_add(&amp;_claimed, stride);
555     size_t start = cur;
556     size_t end = MIN2(cur + stride, max);
557     if (start &gt;= max) break;
558 
559     for (size_t idx = start; idx &lt; end; idx++) {
560       ShenandoahNMethod* nmr = list[idx];
561       assert(nmr != NULL, &quot;Sanity&quot;);
562       if (nmr-&gt;is_unregistered()) {
563         continue;
564       }
565 
<span class="line-modified">566       nmr-&gt;assert_alive_and_correct();</span>
<span class="line-modified">567       f-&gt;do_code_blob(nmr-&gt;nm());</span>



568     }
569   }
570 }
571 
572 void ShenandoahNMethodTableSnapshot::concurrent_nmethods_do(NMethodClosure* cl) {
573   size_t stride = 256; // educated guess
574 
575   ShenandoahNMethod** list = _list-&gt;list();
576   size_t max = (size_t)_limit;
577   while (_claimed &lt; max) {
578     size_t cur = Atomic::fetch_and_add(&amp;_claimed, stride);
579     size_t start = cur;
580     size_t end = MIN2(cur + stride, max);
581     if (start &gt;= max) break;
582 
583     for (size_t idx = start; idx &lt; end; idx++) {
584       ShenandoahNMethod* data = list[idx];
585       assert(data != NULL, &quot;Should not be NULL&quot;);
586       if (!data-&gt;is_unregistered()) {
587         cl-&gt;do_nmethod(data-&gt;nm());
</pre>
</td>
<td>
<hr />
<pre>
190   if (heap-&gt;is_concurrent_mark_in_progress()) {
191     if (heap-&gt;has_forwarded_objects()) {
192       ShenandoahKeepNMethodMetadataAliveClosure&lt;true&gt; cl;
193       data-&gt;oops_do(&amp;cl);
194     } else {
195       ShenandoahKeepNMethodMetadataAliveClosure&lt;false&gt; cl;
196       data-&gt;oops_do(&amp;cl);
197     }
198   } else if (heap-&gt;is_concurrent_weak_root_in_progress()) {
199     ShenandoahEvacOOMScope evac_scope;
200     heal_nmethod_metadata(data);
201   } else {
202     // There is possibility that GC is cancelled when it arrives final mark.
203     // In this case, concurrent root phase is skipped and degenerated GC should be
204     // followed, where nmethods are disarmed.
205     assert(heap-&gt;cancelled_gc(), &quot;What else?&quot;);
206   }
207 }
208 
209 #ifdef ASSERT
<span class="line-modified">210 void ShenandoahNMethod::assert_correct() {</span>

211   ShenandoahHeap* heap = ShenandoahHeap::heap();
212   for (int c = 0; c &lt; _oops_count; c++) {
213     oop *loc = _oops[c];
214     assert(_nm-&gt;code_contains((address) loc) || _nm-&gt;oops_contains(loc), &quot;nmethod should contain the oop*&quot;);
215     oop o = RawAccess&lt;&gt;::oop_load(loc);
216     shenandoah_assert_correct_except(loc, o, o == NULL || heap-&gt;is_full_gc_move_in_progress());
217   }
218 
219   oop* const begin = _nm-&gt;oops_begin();
220   oop* const end = _nm-&gt;oops_end();
221   for (oop* p = begin; p &lt; end; p++) {
222     if (*p != Universe::non_oop_word()) {
223       oop o = RawAccess&lt;&gt;::oop_load(p);
224       shenandoah_assert_correct_except(p, o, o == NULL || heap-&gt;is_full_gc_move_in_progress());
225     }
226   }
227 }
228 
229 class ShenandoahNMethodOopDetector : public OopClosure {
230 private:
</pre>
<hr />
<pre>
472   }
473 
474   ResourceMark rm;
475   log.print(&quot;Unregister NMethod: %s.%s [&quot; PTR_FORMAT &quot;]&quot;,
476             nm-&gt;method()-&gt;method_holder()-&gt;external_name(),
477             nm-&gt;method()-&gt;name()-&gt;as_C_string(),
478             p2i(nm));
479 }
480 
481 void ShenandoahNMethodTable::log_flush_nmethod(nmethod* nm) {
482   LogTarget(Debug, gc, nmethod) log;
483   if (!log.is_enabled()) {
484     return;
485   }
486 
487   ResourceMark rm;
488   log.print(&quot;Flush NMethod: (&quot; PTR_FORMAT &quot;)&quot;, p2i(nm));
489 }
490 
491 #ifdef ASSERT
<span class="line-modified">492 void ShenandoahNMethodTable::assert_nmethods_correct() {</span>
493   assert_locked_or_safepoint(CodeCache_lock);
494 
495   for (int index = 0; index &lt; length(); index ++) {
496     ShenandoahNMethod* m = _list-&gt;at(index);
497     // Concurrent unloading may have dead nmethods to be cleaned by sweeper
498     if (m-&gt;is_unregistered()) continue;
<span class="line-modified">499     m-&gt;assert_correct();</span>
500   }
501 }
502 #endif
503 
504 
505 ShenandoahNMethodList::ShenandoahNMethodList(int size) :
506   _size(size), _ref_count(1) {
507   _list = NEW_C_HEAP_ARRAY(ShenandoahNMethod*, size, mtGC);
508 }
509 
510 ShenandoahNMethodList::~ShenandoahNMethodList() {
511   assert(_list != NULL, &quot;Sanity&quot;);
512   assert(_ref_count == 0, &quot;Must be&quot;);
513   FREE_C_HEAP_ARRAY(ShenandoahNMethod*, _list);
514 }
515 
516 void ShenandoahNMethodList::transfer(ShenandoahNMethodList* const list, int limit) {
517   assert(limit &lt;= size(), &quot;Sanity&quot;);
518   ShenandoahNMethod** old_list = list-&gt;list();
519   for (int index = 0; index &lt; limit; index++) {
</pre>
<hr />
<pre>
545 
546 void ShenandoahNMethodTableSnapshot::parallel_blobs_do(CodeBlobClosure *f) {
547   size_t stride = 256; // educated guess
548 
549   ShenandoahNMethod** const list = _list-&gt;list();
550 
551   size_t max = (size_t)_limit;
552   while (_claimed &lt; max) {
553     size_t cur = Atomic::fetch_and_add(&amp;_claimed, stride);
554     size_t start = cur;
555     size_t end = MIN2(cur + stride, max);
556     if (start &gt;= max) break;
557 
558     for (size_t idx = start; idx &lt; end; idx++) {
559       ShenandoahNMethod* nmr = list[idx];
560       assert(nmr != NULL, &quot;Sanity&quot;);
561       if (nmr-&gt;is_unregistered()) {
562         continue;
563       }
564 
<span class="line-modified">565       // A nmethod can become a zombie before it is unregistered.</span>
<span class="line-modified">566       if (nmr-&gt;nm()-&gt;is_alive()) {</span>
<span class="line-added">567         nmr-&gt;assert_correct();</span>
<span class="line-added">568         f-&gt;do_code_blob(nmr-&gt;nm());</span>
<span class="line-added">569       }</span>
570     }
571   }
572 }
573 
574 void ShenandoahNMethodTableSnapshot::concurrent_nmethods_do(NMethodClosure* cl) {
575   size_t stride = 256; // educated guess
576 
577   ShenandoahNMethod** list = _list-&gt;list();
578   size_t max = (size_t)_limit;
579   while (_claimed &lt; max) {
580     size_t cur = Atomic::fetch_and_add(&amp;_claimed, stride);
581     size_t start = cur;
582     size_t end = MIN2(cur + stride, max);
583     if (start &gt;= max) break;
584 
585     for (size_t idx = start; idx &lt; end; idx++) {
586       ShenandoahNMethod* data = list[idx];
587       assert(data != NULL, &quot;Should not be NULL&quot;);
588       if (!data-&gt;is_unregistered()) {
589         cl-&gt;do_nmethod(data-&gt;nm());
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahMarkCompact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahNMethod.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
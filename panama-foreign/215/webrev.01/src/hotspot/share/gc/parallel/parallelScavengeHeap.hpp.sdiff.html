<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/parallelScavengeHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="parallelScavengeHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psParallelCompact.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/parallelScavengeHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
109   virtual Name kind() const {
110     return CollectedHeap::Parallel;
111   }
112 
113   virtual const char* name() const {
114     return &quot;Parallel&quot;;
115   }
116 
117   virtual SoftRefPolicy* soft_ref_policy() { return &amp;_soft_ref_policy; }
118 
119   virtual GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
120   virtual GrowableArray&lt;MemoryPool*&gt; memory_pools();
121 
122   static PSYoungGen* young_gen() { return _young_gen; }
123   static PSOldGen* old_gen()     { return _old_gen; }
124 
125   virtual PSAdaptiveSizePolicy* size_policy() { return _size_policy; }
126 
127   static PSGCAdaptivePolicyCounters* gc_policy_counters() { return _gc_policy_counters; }
128 
<span class="line-modified">129   static ParallelScavengeHeap* heap();</span>


130 
131   CardTableBarrierSet* barrier_set();
132   PSCardTable* card_table();
133 
134   // Returns JNI_OK on success
135   virtual jint initialize();
136 
137   void post_initialize();
138   void update_counters();
139 
140   size_t capacity() const;
141   size_t used() const;
142 
143   // Return &quot;true&quot; if all generations have reached the
144   // maximal committed limit that they can reach, without a garbage
145   // collection.
146   virtual bool is_maximal_no_gc() const;
147 
148   virtual void register_nmethod(nmethod* nm);
149   virtual void unregister_nmethod(nmethod* nm);
</pre>
</td>
<td>
<hr />
<pre>
109   virtual Name kind() const {
110     return CollectedHeap::Parallel;
111   }
112 
113   virtual const char* name() const {
114     return &quot;Parallel&quot;;
115   }
116 
117   virtual SoftRefPolicy* soft_ref_policy() { return &amp;_soft_ref_policy; }
118 
119   virtual GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
120   virtual GrowableArray&lt;MemoryPool*&gt; memory_pools();
121 
122   static PSYoungGen* young_gen() { return _young_gen; }
123   static PSOldGen* old_gen()     { return _old_gen; }
124 
125   virtual PSAdaptiveSizePolicy* size_policy() { return _size_policy; }
126 
127   static PSGCAdaptivePolicyCounters* gc_policy_counters() { return _gc_policy_counters; }
128 
<span class="line-modified">129   static ParallelScavengeHeap* heap() {</span>
<span class="line-added">130     return named_heap&lt;ParallelScavengeHeap&gt;(CollectedHeap::Parallel);</span>
<span class="line-added">131   }</span>
132 
133   CardTableBarrierSet* barrier_set();
134   PSCardTable* card_table();
135 
136   // Returns JNI_OK on success
137   virtual jint initialize();
138 
139   void post_initialize();
140   void update_counters();
141 
142   size_t capacity() const;
143   size_t used() const;
144 
145   // Return &quot;true&quot; if all generations have reached the
146   // maximal committed limit that they can reach, without a garbage
147   // collection.
148   virtual bool is_maximal_no_gc() const;
149 
150   virtual void register_nmethod(nmethod* nm);
151   virtual void unregister_nmethod(nmethod* nm);
</pre>
</td>
</tr>
</table>
<center><a href="parallelScavengeHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psParallelCompact.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
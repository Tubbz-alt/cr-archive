<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1Policy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1CollectedHeap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Policy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 44,10 ***</span>
<span class="line-new-header">--- 44,11 ---</span>
  #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;
  #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
<span class="line-added">+ #include &quot;runtime/globals.hpp&quot;</span>
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  #include &quot;utilities/pair.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,12 ***</span>
    _mmu_tracker(new G1MMUTrackerQueue(GCPauseIntervalMillis / 1000.0, MaxGCPauseMillis / 1000.0)),
    _ihop_control(create_ihop_control(&amp;_predictor)),
    _policy_counters(new GCPolicyCounters(&quot;GarbageFirst&quot;, 1, 2)),
    _full_collection_start_sec(0.0),
    _collection_pause_end_millis(os::javaTimeNanos() / NANOSECS_PER_MILLISEC),
    _young_list_target_length(0),
<span class="line-removed">-   _young_list_fixed_length(0),</span>
    _young_list_max_length(0),
    _eden_surv_rate_group(new G1SurvRateGroup()),
    _survivor_surv_rate_group(new G1SurvRateGroup()),
    _reserve_factor((double) G1ReservePercent / 100.0),
    _reserve_regions(0),
<span class="line-new-header">--- 60,12 ---</span>
    _mmu_tracker(new G1MMUTrackerQueue(GCPauseIntervalMillis / 1000.0, MaxGCPauseMillis / 1000.0)),
    _ihop_control(create_ihop_control(&amp;_predictor)),
    _policy_counters(new GCPolicyCounters(&quot;GarbageFirst&quot;, 1, 2)),
    _full_collection_start_sec(0.0),
    _collection_pause_end_millis(os::javaTimeNanos() / NANOSECS_PER_MILLISEC),
<span class="line-added">+   _young_list_desired_length(0),</span>
    _young_list_target_length(0),
    _young_list_max_length(0),
    _eden_surv_rate_group(new G1SurvRateGroup()),
    _survivor_surv_rate_group(new G1SurvRateGroup()),
    _reserve_factor((double) G1ReservePercent / 100.0),
    _reserve_regions(0),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,18 ***</span>
    _g1h = g1h;
    _collection_set = collection_set;
  
    assert(Heap_lock-&gt;owned_by_self(), &quot;Locking discipline.&quot;);
  
<span class="line-removed">-   if (!use_adaptive_young_list_length()) {</span>
<span class="line-removed">-     _young_list_fixed_length = _young_gen_sizer-&gt;min_desired_young_length();</span>
<span class="line-removed">-   }</span>
    _young_gen_sizer-&gt;adjust_max_new_size(_g1h-&gt;max_expandable_regions());
  
    _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
  
<span class="line-modified">!   update_young_list_max_and_target_length();</span>
    // We may immediately start allocating regions and placing them on the
    // collection set list. Initialize the per-collection set info
    _collection_set-&gt;start_incremental_building();
  }
  
<span class="line-new-header">--- 106,15 ---</span>
    _g1h = g1h;
    _collection_set = collection_set;
  
    assert(Heap_lock-&gt;owned_by_self(), &quot;Locking discipline.&quot;);
  
    _young_gen_sizer-&gt;adjust_max_new_size(_g1h-&gt;max_expandable_regions());
  
    _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
  
<span class="line-modified">!   update_young_length_bounds();</span>
    // We may immediately start allocating regions and placing them on the
    // collection set list. Initialize the per-collection set info
    _collection_set-&gt;start_incremental_building();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,162 ***</span>
    _young_gen_sizer-&gt;heap_size_changed(new_number_of_regions);
  
    _ihop_control-&gt;update_target_occupancy(new_number_of_regions * HeapRegion::GrainBytes);
  }
  
<span class="line-modified">! uint G1Policy::calculate_young_list_desired_min_length(uint base_min_length) const {</span>
    uint desired_min_length = 0;
    if (use_adaptive_young_list_length()) {
<span class="line-modified">!     if (_analytics-&gt;num_alloc_rate_ms() &gt; 3) {</span>
<span class="line-modified">!       double now_sec = os::elapsedTime();</span>
<span class="line-modified">!       double when_ms = _mmu_tracker-&gt;when_max_gc_sec(now_sec) * 1000.0;</span>
<span class="line-modified">!       double alloc_rate_ms = _analytics-&gt;predict_alloc_rate_ms();</span>
<span class="line-removed">-       desired_min_length = (uint) ceil(alloc_rate_ms * when_ms);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       // otherwise we don&#39;t have enough info to make the prediction</span>
<span class="line-removed">-     }</span>
    }
<span class="line-modified">!   desired_min_length += base_min_length;</span>
<span class="line-modified">!   // make sure we don&#39;t go below any user-defined minimum bound</span>
<span class="line-modified">!   return MAX2(_young_gen_sizer-&gt;min_desired_young_length(), desired_min_length);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! uint G1Policy::calculate_young_list_desired_max_length() const {</span>
<span class="line-modified">!   // Here, we might want to also take into account any additional</span>
<span class="line-modified">!   // constraints (i.e., user-defined minimum bound). Currently, we</span>
<span class="line-modified">!   // effectively don&#39;t set this bound.</span>
<span class="line-modified">!   return _young_gen_sizer-&gt;max_desired_young_length();</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! uint G1Policy::update_young_list_max_and_target_length() {</span>
<span class="line-modified">!   return update_young_list_max_and_target_length(_analytics-&gt;predict_rs_length());</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! uint G1Policy::update_young_list_max_and_target_length(size_t rs_length) {</span>
<span class="line-modified">!   uint unbounded_target_length = update_young_list_target_length(rs_length);</span>
<span class="line-modified">!   update_max_gc_locker_expansion();</span>
<span class="line-modified">!   return unbounded_target_length;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! uint G1Policy::update_young_list_target_length(size_t rs_length) {</span>
<span class="line-modified">!   YoungTargetLengths young_lengths = young_list_target_lengths(rs_length);</span>
<span class="line-modified">!   _young_list_target_length = young_lengths.first;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   return young_lengths.second;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! G1Policy::YoungTargetLengths G1Policy::young_list_target_lengths(size_t rs_length) const {</span>
<span class="line-modified">!   YoungTargetLengths result;</span>
  
    // Calculate the absolute and desired min bounds first.
  
<span class="line-modified">!   // This is how many young regions we already have (currently: the survivors).</span>
<span class="line-modified">!   const uint base_min_length = _g1h-&gt;survivor_regions_count();</span>
<span class="line-modified">!   uint desired_min_length = calculate_young_list_desired_min_length(base_min_length);</span>
<span class="line-modified">!   // This is the absolute minimum young length. Ensure that we</span>
<span class="line-modified">!   // will at least have one eden region available for allocation.</span>
<span class="line-modified">!   uint absolute_min_length = base_min_length + MAX2(_g1h-&gt;eden_regions_count(), (uint)1);</span>
<span class="line-modified">!   // If we shrank the young list target it should not shrink below the current size.</span>
<span class="line-modified">!   desired_min_length = MAX2(desired_min_length, absolute_min_length);</span>
<span class="line-modified">!   // Calculate the absolute and desired max bounds.</span>
  
<span class="line-modified">!   uint desired_max_length = calculate_young_list_desired_max_length();</span>
  
<span class="line-modified">!   uint young_list_target_length = 0;</span>
<span class="line-modified">!   if (use_adaptive_young_list_length()) {</span>
<span class="line-modified">!     if (collector_state()-&gt;in_young_only_phase()) {</span>
<span class="line-modified">!       young_list_target_length =</span>
<span class="line-modified">!                         calculate_young_list_target_length(rs_length,</span>
<span class="line-removed">-                                                            base_min_length,</span>
<span class="line-removed">-                                                            desired_min_length,</span>
<span class="line-removed">-                                                            desired_max_length);</span>
      } else {
<span class="line-modified">!       // Don&#39;t calculate anything and let the code below bound it to</span>
<span class="line-modified">!       // the desired_min_length, i.e., do the next GC as soon as</span>
<span class="line-modified">!       // possible to maximize how many old regions we can add to it.</span>
      }
    } else {
      // The user asked for a fixed young gen so we&#39;ll fix the young gen
      // whether the next GC is young or mixed.
<span class="line-modified">!     young_list_target_length = _young_list_fixed_length;</span>
    }
<span class="line-modified">! </span>
<span class="line-modified">!   result.second = young_list_target_length;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // We will try our best not to &quot;eat&quot; into the reserve.</span>
<span class="line-modified">!   uint absolute_max_length = 0;</span>
<span class="line-modified">!   if (_free_regions_at_end_of_collection &gt; _reserve_regions) {</span>
<span class="line-modified">!     absolute_max_length = _free_regions_at_end_of_collection - _reserve_regions;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (desired_max_length &gt; absolute_max_length) {</span>
<span class="line-modified">!     desired_max_length = absolute_max_length;</span>
    }
  
<span class="line-modified">!   // Make sure we don&#39;t go over the desired max length, nor under the</span>
<span class="line-removed">-   // desired min length. In case they clash, desired_min_length wins</span>
<span class="line-removed">-   // which is why that test is second.</span>
<span class="line-removed">-   if (young_list_target_length &gt; desired_max_length) {</span>
<span class="line-removed">-     young_list_target_length = desired_max_length;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (young_list_target_length &lt; desired_min_length) {</span>
<span class="line-removed">-     young_list_target_length = desired_min_length;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   assert(young_list_target_length &gt; base_min_length,</span>
<span class="line-removed">-          &quot;we should be able to allocate at least one eden region&quot;);</span>
<span class="line-removed">-   assert(young_list_target_length &gt;= absolute_min_length, &quot;post-condition&quot;);</span>
  
<span class="line-modified">!   result.first = young_list_target_length;</span>
<span class="line-modified">!   return result;</span>
  }
  
<span class="line-modified">! uint G1Policy::calculate_young_list_target_length(size_t rs_length,</span>
<span class="line-modified">!                                                   uint base_min_length,</span>
<span class="line-modified">!                                                   uint desired_min_length,</span>
<span class="line-removed">-                                                   uint desired_max_length) const {</span>
    assert(use_adaptive_young_list_length(), &quot;pre-condition&quot;);
<span class="line-removed">-   assert(collector_state()-&gt;in_young_only_phase(), &quot;only call this for young GCs&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // In case some edge-condition makes the desired max length too small...</span>
<span class="line-removed">-   if (desired_max_length &lt;= desired_min_length) {</span>
<span class="line-removed">-     return desired_min_length;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   // We&#39;ll adjust min_young_length and max_young_length not to include</span>
<span class="line-removed">-   // the already allocated young regions (i.e., so they reflect the</span>
<span class="line-removed">-   // min and max eden regions we&#39;ll allocate). The base_min_length</span>
<span class="line-removed">-   // will be reflected in the predictions by the</span>
<span class="line-removed">-   // survivor_regions_evac_time prediction.</span>
<span class="line-removed">-   assert(desired_min_length &gt; base_min_length, &quot;invariant&quot;);</span>
<span class="line-removed">-   uint min_young_length = desired_min_length - base_min_length;</span>
<span class="line-removed">-   assert(desired_max_length &gt; base_min_length, &quot;invariant&quot;);</span>
<span class="line-removed">-   uint max_young_length = desired_max_length - base_min_length;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   const double target_pause_time_ms = _mmu_tracker-&gt;max_gc_time() * 1000.0;</span>
<span class="line-removed">-   const size_t pending_cards = _analytics-&gt;predict_pending_cards();</span>
<span class="line-removed">-   const double base_time_ms = predict_base_elapsed_time_ms(pending_cards, rs_length);</span>
<span class="line-removed">-   const uint available_free_regions = _free_regions_at_end_of_collection;</span>
<span class="line-removed">-   const uint base_free_regions =</span>
<span class="line-removed">-     available_free_regions &gt; _reserve_regions ? available_free_regions - _reserve_regions : 0;</span>
  
    // Here, we will make sure that the shortest young length that
    // makes sense fits within the target pause time.
  
    G1YoungLengthPredictor p(base_time_ms,
<span class="line-modified">!                            base_free_regions,</span>
<span class="line-modified">!                            target_pause_time_ms,</span>
                             this);
<span class="line-modified">!   if (p.will_fit(min_young_length)) {</span>
      // The shortest young length will fit into the target pause time;
      // we&#39;ll now check whether the absolute maximum number of young
      // regions will fit in the target pause time. If not, we&#39;ll do
      // a binary search between min_young_length and max_young_length.
<span class="line-modified">!     if (p.will_fit(max_young_length)) {</span>
        // The maximum young length will fit into the target pause time.
        // We are done so set min young length to the maximum length (as
        // the result is assumed to be returned in min_young_length).
<span class="line-modified">!       min_young_length = max_young_length;</span>
      } else {
        // The maximum possible number of young regions will not fit within
        // the target pause time so we&#39;ll search for the optimal
        // length. The loop invariants are:
        //
<span class="line-new-header">--- 185,258 ---</span>
    _young_gen_sizer-&gt;heap_size_changed(new_number_of_regions);
  
    _ihop_control-&gt;update_target_occupancy(new_number_of_regions * HeapRegion::GrainBytes);
  }
  
<span class="line-modified">! uint G1Policy::calculate_desired_eden_length_by_mmu() const {</span>
<span class="line-added">+   // One could argue that any useful eden length to keep any MMU would be 1, but</span>
<span class="line-added">+   // in theory this is possible. Other constraints enforce a minimum eden of 1</span>
<span class="line-added">+   // anyway.</span>
    uint desired_min_length = 0;
    if (use_adaptive_young_list_length()) {
<span class="line-modified">!     double now_sec = os::elapsedTime();</span>
<span class="line-modified">!     double when_ms = _mmu_tracker-&gt;when_max_gc_sec(now_sec) * 1000.0;</span>
<span class="line-modified">!     double alloc_rate_ms = _analytics-&gt;predict_alloc_rate_ms();</span>
<span class="line-modified">!     desired_min_length = (uint) ceil(alloc_rate_ms * when_ms);</span>
    }
<span class="line-modified">!   return desired_min_length;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void G1Policy::update_young_length_bounds() {</span>
<span class="line-modified">!   update_young_length_bounds(_analytics-&gt;predict_rs_length());</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void G1Policy::update_young_length_bounds(size_t rs_length) {</span>
<span class="line-modified">!   _young_list_desired_length = calculate_young_desired_length(rs_length);</span>
<span class="line-modified">!   _young_list_target_length = calculate_young_target_length(_young_list_desired_length);</span>
<span class="line-modified">!   _young_list_max_length = calculate_young_max_length(_young_list_target_length);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   log_debug(gc,ergo,heap)(&quot;Young list lengths: desired: %u, target: %u, max: %u&quot;,</span>
<span class="line-modified">!                           _young_list_desired_length,</span>
<span class="line-modified">!                           _young_list_target_length,</span>
<span class="line-modified">!                           _young_list_max_length);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! // Calculates desired young gen length. It is calculated from:</span>
<span class="line-modified">! //</span>
<span class="line-modified">! // - sizer min/max bounds on young gen</span>
<span class="line-modified">! // - pause time goal for whole young gen evacuation</span>
<span class="line-modified">! // - MMU goal influencing eden to make GCs spaced apart.</span>
<span class="line-modified">! // - a minimum one eden region length.</span>
<span class="line-modified">! //</span>
<span class="line-modified">! // We may enter with already allocated eden and survivor regions, that may be</span>
<span class="line-modified">! // higher than the maximum, or the above goals may result in a desired value</span>
<span class="line-modified">! // smaller than are already allocated.</span>
<span class="line-modified">! // The main reason is revising young length, with our without the GCLocker being</span>
<span class="line-modified">! // active.</span>
<span class="line-modified">! //</span>
<span class="line-added">+ uint G1Policy::calculate_young_desired_length(size_t rs_length) const {</span>
<span class="line-added">+   uint min_young_length_by_sizer = _young_gen_sizer-&gt;min_desired_young_length();</span>
<span class="line-added">+   uint max_young_length_by_sizer = _young_gen_sizer-&gt;max_desired_young_length();</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(min_young_length_by_sizer &gt;= 1, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(max_young_length_by_sizer &gt;= min_young_length_by_sizer, &quot;invariant&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Absolute minimum eden length.</span>
<span class="line-added">+   // Enforcing a minimum eden length helps at startup when the predictors are not</span>
<span class="line-added">+   // yet trained on the application to avoid unnecessary (but very short) full gcs</span>
<span class="line-added">+   // on very small (initial) heaps.</span>
<span class="line-added">+   uint const MinDesiredEdenLength = 1;</span>
  
    // Calculate the absolute and desired min bounds first.
  
<span class="line-modified">!   // This is how many survivor regions we already have.</span>
<span class="line-modified">!   const uint survivor_length = _g1h-&gt;survivor_regions_count();</span>
<span class="line-modified">!   // Size of the already allocated young gen.</span>
<span class="line-modified">!   const uint allocated_young_length = _g1h-&gt;young_regions_count();</span>
<span class="line-modified">!   // This is the absolute minimum young length that we can return. Ensure that we</span>
<span class="line-modified">!   // don&#39;t go below any user-defined minimum bound; but we might have already</span>
<span class="line-modified">!   // allocated more than that for reasons. In this case, use that.</span>
<span class="line-modified">!   uint absolute_min_young_length = MAX2(allocated_young_length, min_young_length_by_sizer);</span>
<span class="line-modified">!   // Calculate the absolute max bounds. After evac failure or when revising the</span>
<span class="line-added">+   // young length we might have exceeded absolute min length or absolute_max_length,</span>
<span class="line-added">+   // so adjust the result accordingly.</span>
<span class="line-added">+   uint absolute_max_young_length = MAX2(max_young_length_by_sizer, absolute_min_young_length);</span>
<span class="line-added">+ </span>
<span class="line-added">+   uint desired_eden_length_by_mmu = 0;</span>
<span class="line-added">+   uint desired_eden_length_by_pause = 0;</span>
<span class="line-added">+   uint desired_eden_length_before_mixed = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+   uint desired_young_length = 0;</span>
<span class="line-added">+   if (use_adaptive_young_list_length()) {</span>
<span class="line-added">+     desired_eden_length_by_mmu = calculate_desired_eden_length_by_mmu();</span>
  
<span class="line-modified">!     const size_t pending_cards = _analytics-&gt;predict_pending_cards();</span>
<span class="line-added">+     double survivor_base_time_ms = predict_base_elapsed_time_ms(pending_cards, rs_length);</span>
  
<span class="line-modified">!     if (!next_gc_should_be_mixed(NULL, NULL)) {</span>
<span class="line-modified">!       desired_eden_length_by_pause =</span>
<span class="line-modified">!         calculate_desired_eden_length_by_pause(survivor_base_time_ms,</span>
<span class="line-modified">!                                                absolute_min_young_length - survivor_length,</span>
<span class="line-modified">!                                                absolute_max_young_length - survivor_length);</span>
      } else {
<span class="line-modified">!       desired_eden_length_before_mixed =</span>
<span class="line-modified">!         calculate_desired_eden_length_before_mixed(survivor_base_time_ms,</span>
<span class="line-modified">!                                                    absolute_min_young_length - survivor_length,</span>
<span class="line-added">+                                                    absolute_max_young_length - survivor_length);</span>
      }
<span class="line-added">+     // Above either sets desired_eden_length_by_pause or desired_eden_length_before_mixed,</span>
<span class="line-added">+     // the other is zero. Use the one that has been set below.</span>
<span class="line-added">+     uint desired_eden_length = MAX2(desired_eden_length_by_pause,</span>
<span class="line-added">+                                     desired_eden_length_before_mixed);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Finally incorporate MMU concerns; assume that it overrides the pause time</span>
<span class="line-added">+     // goal, as the default value has been chosen to effectively disable it.</span>
<span class="line-added">+     // Also request at least one eden region, see above for reasons.</span>
<span class="line-added">+     desired_eden_length = MAX3(desired_eden_length,</span>
<span class="line-added">+                                desired_eden_length_by_mmu,</span>
<span class="line-added">+                                MinDesiredEdenLength);</span>
<span class="line-added">+ </span>
<span class="line-added">+     desired_young_length = desired_eden_length + survivor_length;</span>
    } else {
      // The user asked for a fixed young gen so we&#39;ll fix the young gen
      // whether the next GC is young or mixed.
<span class="line-modified">!     desired_young_length = min_young_length_by_sizer;</span>
    }
<span class="line-modified">!   // Clamp to absolute min/max after we determined desired lengths.</span>
<span class="line-modified">!   desired_young_length = clamp(desired_young_length, absolute_min_young_length, absolute_max_young_length);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   log_trace(gc, ergo, heap)(&quot;Young desired length %u &quot;</span>
<span class="line-modified">!                             &quot;survivor length %u &quot;</span>
<span class="line-modified">!                             &quot;allocated young length %u &quot;</span>
<span class="line-modified">!                             &quot;absolute min young length %u &quot;</span>
<span class="line-modified">!                             &quot;absolute max young length %u &quot;</span>
<span class="line-modified">!                             &quot;desired eden length by mmu %u &quot;</span>
<span class="line-modified">!                             &quot;desired eden length by pause %u &quot;</span>
<span class="line-added">+                             &quot;desired eden length before mixed %u&quot;</span>
<span class="line-added">+                             &quot;desired eden length by default %u&quot;,</span>
<span class="line-added">+                             desired_young_length, survivor_length,</span>
<span class="line-added">+                             allocated_young_length, absolute_min_young_length,</span>
<span class="line-added">+                             absolute_max_young_length, desired_eden_length_by_mmu,</span>
<span class="line-added">+                             desired_eden_length_by_pause,</span>
<span class="line-added">+                             desired_eden_length_before_mixed,</span>
<span class="line-added">+                             MinDesiredEdenLength);</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(desired_young_length &gt;= allocated_young_length, &quot;must be&quot;);</span>
<span class="line-added">+   return desired_young_length;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Limit the desired (wished) young length by current free regions. If the request</span>
<span class="line-added">+ // can be satisfied without using up reserve regions, do so, otherwise eat into</span>
<span class="line-added">+ // the reserve, giving away at most what the heap sizer allows.</span>
<span class="line-added">+ uint G1Policy::calculate_young_target_length(uint desired_young_length) const {</span>
<span class="line-added">+   uint allocated_young_length = _g1h-&gt;young_regions_count();</span>
<span class="line-added">+ </span>
<span class="line-added">+   uint receiving_additional_eden;</span>
<span class="line-added">+   if (allocated_young_length &gt;= desired_young_length) {</span>
<span class="line-added">+     // Already used up all we actually want (may happen as G1 revises the</span>
<span class="line-added">+     // young list length concurrently, or caused by gclocker). Do not allow more,</span>
<span class="line-added">+     // potentially resulting in GC.</span>
<span class="line-added">+     receiving_additional_eden = 0;</span>
<span class="line-added">+     log_trace(gc, ergo, heap)(&quot;Young target length: Already used up desired young %u allocated %u&quot;,</span>
<span class="line-added">+                               desired_young_length,</span>
<span class="line-added">+                               allocated_young_length);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // Now look at how many free regions are there currently, and the heap reserve.</span>
<span class="line-added">+     // We will try our best not to &quot;eat&quot; into the reserve as long as we can. If we</span>
<span class="line-added">+     // do, we at most eat the sizer&#39;s minimum regions into the reserve or half the</span>
<span class="line-added">+     // reserve rounded up (if possible; this is an arbitrary value).</span>
<span class="line-added">+ </span>
<span class="line-added">+     uint max_to_eat_into_reserve = MIN2(_young_gen_sizer-&gt;min_desired_young_length(),</span>
<span class="line-added">+                                         (_reserve_regions + 1) / 2);</span>
<span class="line-added">+ </span>
<span class="line-added">+     log_trace(gc, ergo, heap)(&quot;Young target length: Common &quot;</span>
<span class="line-added">+                               &quot;free regions at end of collection %u &quot;</span>
<span class="line-added">+                               &quot;desired young length %u &quot;</span>
<span class="line-added">+                               &quot;reserve region %u &quot;</span>
<span class="line-added">+                               &quot;max to eat into reserve %u&quot;,</span>
<span class="line-added">+                               _free_regions_at_end_of_collection,</span>
<span class="line-added">+                               desired_young_length,</span>
<span class="line-added">+                               _reserve_regions,</span>
<span class="line-added">+                               max_to_eat_into_reserve);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (_free_regions_at_end_of_collection &lt;= _reserve_regions) {</span>
<span class="line-added">+       // Fully eat (or already eating) into the reserve, hand back at most absolute_min_length regions.</span>
<span class="line-added">+       uint receiving_young = MIN3(_free_regions_at_end_of_collection,</span>
<span class="line-added">+                                   desired_young_length,</span>
<span class="line-added">+                                   max_to_eat_into_reserve);</span>
<span class="line-added">+       // We could already have allocated more regions than what we could get</span>
<span class="line-added">+       // above.</span>
<span class="line-added">+       receiving_additional_eden = allocated_young_length &lt; receiving_young ?</span>
<span class="line-added">+                                   receiving_young - allocated_young_length : 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+       log_trace(gc, ergo, heap)(&quot;Young target length: Fully eat into reserve &quot;</span>
<span class="line-added">+                                 &quot;receiving young %u receiving additional eden %u&quot;,</span>
<span class="line-added">+                                 receiving_young,</span>
<span class="line-added">+                                 receiving_additional_eden);</span>
<span class="line-added">+     } else if (_free_regions_at_end_of_collection &lt; (desired_young_length + _reserve_regions)) {</span>
<span class="line-added">+       // Partially eat into the reserve, at most max_to_eat_into_reserve regions.</span>
<span class="line-added">+       uint free_outside_reserve = _free_regions_at_end_of_collection - _reserve_regions;</span>
<span class="line-added">+       assert(free_outside_reserve &lt; desired_young_length,</span>
<span class="line-added">+              &quot;must be %u %u&quot;,</span>
<span class="line-added">+              free_outside_reserve, desired_young_length);</span>
<span class="line-added">+ </span>
<span class="line-added">+       uint receiving_within_reserve = MIN2(desired_young_length - free_outside_reserve,</span>
<span class="line-added">+                                            max_to_eat_into_reserve);</span>
<span class="line-added">+       uint receiving_young = free_outside_reserve + receiving_within_reserve;</span>
<span class="line-added">+       // Again, we could have already allocated more than we could get.</span>
<span class="line-added">+       receiving_additional_eden = allocated_young_length &lt; receiving_young ?</span>
<span class="line-added">+                                   receiving_young - allocated_young_length : 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+       log_trace(gc, ergo, heap)(&quot;Young target length: Partially eat into reserve &quot;</span>
<span class="line-added">+                                 &quot;free outside reserve %u &quot;</span>
<span class="line-added">+                                 &quot;receiving within reserve %u &quot;</span>
<span class="line-added">+                                 &quot;receiving young %u &quot;</span>
<span class="line-added">+                                 &quot;receiving additional eden %u&quot;,</span>
<span class="line-added">+                                 free_outside_reserve, receiving_within_reserve,</span>
<span class="line-added">+                                 receiving_young, receiving_additional_eden);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       // No need to use the reserve.</span>
<span class="line-added">+       receiving_additional_eden = desired_young_length - allocated_young_length;</span>
<span class="line-added">+       log_trace(gc, ergo, heap)(&quot;Young target length: No need to use reserve &quot;</span>
<span class="line-added">+                                 &quot;receiving additional eden %u&quot;,</span>
<span class="line-added">+                                 receiving_additional_eden);</span>
<span class="line-added">+     }</span>
    }
  
<span class="line-modified">!   uint target_young_length = allocated_young_length + receiving_additional_eden;</span>
  
<span class="line-modified">!   assert(target_young_length &gt;= allocated_young_length, &quot;must be&quot;);</span>
  
<span class="line-modified">!   log_trace(gc, ergo, heap)(&quot;Young target length: &quot;</span>
<span class="line-modified">!                             &quot;young target length %u &quot;</span>
<span class="line-added">+                             &quot;allocated young length %u &quot;</span>
<span class="line-added">+                             &quot;received additional eden %u&quot;,</span>
<span class="line-added">+                             target_young_length, allocated_young_length,</span>
<span class="line-added">+                             receiving_additional_eden);</span>
<span class="line-added">+   return target_young_length;</span>
  }
  
<span class="line-modified">! uint G1Policy::calculate_desired_eden_length_by_pause(double base_time_ms,</span>
<span class="line-modified">!                                                       uint min_eden_length,</span>
<span class="line-modified">!                                                       uint max_eden_length) const {</span>
    assert(use_adaptive_young_list_length(), &quot;pre-condition&quot;);
  
<span class="line-modified">!   assert(min_eden_length &lt;= max_eden_length, &quot;must be %u %u&quot;, min_eden_length, max_eden_length);</span>
  
    // Here, we will make sure that the shortest young length that
    // makes sense fits within the target pause time.
  
    G1YoungLengthPredictor p(base_time_ms,
<span class="line-modified">!                            _free_regions_at_end_of_collection,</span>
<span class="line-modified">!                            _mmu_tracker-&gt;max_gc_time() * 1000.0,</span>
                             this);
<span class="line-modified">!   if (p.will_fit(min_eden_length)) {</span>
      // The shortest young length will fit into the target pause time;
      // we&#39;ll now check whether the absolute maximum number of young
      // regions will fit in the target pause time. If not, we&#39;ll do
      // a binary search between min_young_length and max_young_length.
<span class="line-modified">!     if (p.will_fit(max_eden_length)) {</span>
        // The maximum young length will fit into the target pause time.
        // We are done so set min young length to the maximum length (as
        // the result is assumed to be returned in min_young_length).
<span class="line-modified">!       min_eden_length = max_eden_length;</span>
      } else {
        // The maximum possible number of young regions will not fit within
        // the target pause time so we&#39;ll search for the optimal
        // length. The loop invariants are:
        //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 355,41 ***</span>
        // the middle value between min_young_length and
        // max_young_length fits into the target pause time. If it
        // does, it becomes the new min. If it doesn&#39;t, it becomes
        // the new max. This way we maintain the loop invariants.
  
<span class="line-modified">!       assert(min_young_length &lt; max_young_length, &quot;invariant&quot;);</span>
<span class="line-modified">!       uint diff = (max_young_length - min_young_length) / 2;</span>
        while (diff &gt; 0) {
<span class="line-modified">!         uint young_length = min_young_length + diff;</span>
<span class="line-modified">!         if (p.will_fit(young_length)) {</span>
<span class="line-modified">!           min_young_length = young_length;</span>
          } else {
<span class="line-modified">!           max_young_length = young_length;</span>
          }
<span class="line-modified">!         assert(min_young_length &lt;  max_young_length, &quot;invariant&quot;);</span>
<span class="line-modified">!         diff = (max_young_length - min_young_length) / 2;</span>
        }
        // The results is min_young_length which, according to the
        // loop invariants, should fit within the target pause time.
  
        // These are the post-conditions of the binary search above:
<span class="line-modified">!       assert(min_young_length &lt; max_young_length,</span>
<span class="line-modified">!              &quot;otherwise we should have discovered that max_young_length &quot;</span>
               &quot;fits into the pause target and not done the binary search&quot;);
<span class="line-modified">!       assert(p.will_fit(min_young_length),</span>
<span class="line-modified">!              &quot;min_young_length, the result of the binary search, should &quot;</span>
               &quot;fit into the pause target&quot;);
<span class="line-modified">!       assert(!p.will_fit(min_young_length + 1),</span>
<span class="line-modified">!              &quot;min_young_length, the result of the binary search, should be &quot;</span>
               &quot;optimal, so no larger length should fit into the pause target&quot;);
      }
    } else {
      // Even the minimum length doesn&#39;t fit into the pause time
      // target, return it as the result nevertheless.
    }
<span class="line-modified">!   return base_min_length + min_young_length;</span>
  }
  
  double G1Policy::predict_survivor_regions_evac_time() const {
    double survivor_regions_evac_time = 0.0;
    const GrowableArray&lt;HeapRegion*&gt;* survivor_regions = _g1h-&gt;survivor()-&gt;regions();
<span class="line-new-header">--- 449,60 ---</span>
        // the middle value between min_young_length and
        // max_young_length fits into the target pause time. If it
        // does, it becomes the new min. If it doesn&#39;t, it becomes
        // the new max. This way we maintain the loop invariants.
  
<span class="line-modified">!       assert(min_eden_length &lt; max_eden_length, &quot;invariant&quot;);</span>
<span class="line-modified">!       uint diff = (max_eden_length - min_eden_length) / 2;</span>
        while (diff &gt; 0) {
<span class="line-modified">!         uint eden_length = min_eden_length + diff;</span>
<span class="line-modified">!         if (p.will_fit(eden_length)) {</span>
<span class="line-modified">!           min_eden_length = eden_length;</span>
          } else {
<span class="line-modified">!           max_eden_length = eden_length;</span>
          }
<span class="line-modified">!         assert(min_eden_length &lt;  max_eden_length, &quot;invariant&quot;);</span>
<span class="line-modified">!         diff = (max_eden_length - min_eden_length) / 2;</span>
        }
        // The results is min_young_length which, according to the
        // loop invariants, should fit within the target pause time.
  
        // These are the post-conditions of the binary search above:
<span class="line-modified">!       assert(min_eden_length &lt; max_eden_length,</span>
<span class="line-modified">!              &quot;otherwise we should have discovered that max_eden_length &quot;</span>
               &quot;fits into the pause target and not done the binary search&quot;);
<span class="line-modified">!       assert(p.will_fit(min_eden_length),</span>
<span class="line-modified">!              &quot;min_eden_length, the result of the binary search, should &quot;</span>
               &quot;fit into the pause target&quot;);
<span class="line-modified">!       assert(!p.will_fit(min_eden_length + 1),</span>
<span class="line-modified">!              &quot;min_eden_length, the result of the binary search, should be &quot;</span>
               &quot;optimal, so no larger length should fit into the pause target&quot;);
      }
    } else {
      // Even the minimum length doesn&#39;t fit into the pause time
      // target, return it as the result nevertheless.
    }
<span class="line-modified">!   return min_eden_length;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ uint G1Policy::calculate_desired_eden_length_before_mixed(double survivor_base_time_ms,</span>
<span class="line-added">+                                                           uint min_eden_length,</span>
<span class="line-added">+                                                           uint max_eden_length) const {</span>
<span class="line-added">+   G1CollectionSetCandidates* candidates = _collection_set-&gt;candidates();</span>
<span class="line-added">+ </span>
<span class="line-added">+   uint min_old_regions_end = MIN2(candidates-&gt;cur_idx() + calc_min_old_cset_length(), candidates-&gt;num_regions());</span>
<span class="line-added">+   double predicted_region_evac_time_ms = survivor_base_time_ms;</span>
<span class="line-added">+   for (uint i = candidates-&gt;cur_idx(); i &lt; min_old_regions_end; i++) {</span>
<span class="line-added">+     HeapRegion* r = candidates-&gt;at(i);</span>
<span class="line-added">+     predicted_region_evac_time_ms += predict_region_total_time_ms(r, false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   uint desired_eden_length_by_min_cset_length =</span>
<span class="line-added">+      calculate_desired_eden_length_by_pause(predicted_region_evac_time_ms,</span>
<span class="line-added">+                                             min_eden_length,</span>
<span class="line-added">+                                             max_eden_length);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return desired_eden_length_by_min_cset_length;</span>
  }
  
  double G1Policy::predict_survivor_regions_evac_time() const {
    double survivor_regions_evac_time = 0.0;
    const GrowableArray&lt;HeapRegion*&gt;* survivor_regions = _g1h-&gt;survivor()-&gt;regions();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 406,12 ***</span>
  
    if (rs_length &gt; _rs_length_prediction) {
      // add 10% to avoid having to recalculate often
      size_t rs_length_prediction = rs_length * 1100 / 1000;
      update_rs_length_prediction(rs_length_prediction);
<span class="line-modified">! </span>
<span class="line-removed">-     update_young_list_max_and_target_length(rs_length_prediction);</span>
    }
  }
  
  void G1Policy::update_rs_length_prediction() {
    update_rs_length_prediction(_analytics-&gt;predict_rs_length());
<span class="line-new-header">--- 519,11 ---</span>
  
    if (rs_length &gt; _rs_length_prediction) {
      // add 10% to avoid having to recalculate often
      size_t rs_length_prediction = rs_length * 1100 / 1000;
      update_rs_length_prediction(rs_length_prediction);
<span class="line-modified">!     update_young_length_bounds(rs_length_prediction);</span>
    }
  }
  
  void G1Policy::update_rs_length_prediction() {
    update_rs_length_prediction(_analytics-&gt;predict_rs_length());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 455,11 ***</span>
    _eden_surv_rate_group-&gt;start_adding_regions();
    // also call this on any additional surv rate groups
  
    _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
    _survivor_surv_rate_group-&gt;reset();
<span class="line-modified">!   update_young_list_max_and_target_length();</span>
    update_rs_length_prediction();
  
    _old_gen_alloc_tracker.reset_after_full_gc();
  
    record_pause(FullGC, _full_collection_start_sec, end_sec);
<span class="line-new-header">--- 567,11 ---</span>
    _eden_surv_rate_group-&gt;start_adding_regions();
    // also call this on any additional surv rate groups
  
    _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
    _survivor_surv_rate_group-&gt;reset();
<span class="line-modified">!   update_young_length_bounds();</span>
    update_rs_length_prediction();
  
    _old_gen_alloc_tracker.reset_after_full_gc();
  
    record_pause(FullGC, _full_collection_start_sec, end_sec);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 667,14 ***</span>
      // place we can safely ignore them here.
      uint regions_allocated = _collection_set-&gt;eden_region_length();
      double alloc_rate_ms = (double) regions_allocated / app_time_ms;
      _analytics-&gt;report_alloc_rate_ms(alloc_rate_ms);
  
<span class="line-modified">!     double interval_ms =</span>
<span class="line-removed">-       (end_time_sec - _analytics-&gt;last_known_gc_end_time_sec()) * 1000.0;</span>
      _analytics-&gt;update_recent_gc_times(end_time_sec, pause_time_ms);
<span class="line-removed">-     _analytics-&gt;compute_pause_time_ratio(interval_ms, pause_time_ms);</span>
    }
  
    if (collector_state()-&gt;in_young_gc_before_mixed()) {
      assert(!this_pause_included_initial_mark, &quot;The young GC before mixed is not allowed to be an initial mark GC&quot;);
      // This has been the young GC before we start doing mixed GCs. We already
<span class="line-new-header">--- 779,12 ---</span>
      // place we can safely ignore them here.
      uint regions_allocated = _collection_set-&gt;eden_region_length();
      double alloc_rate_ms = (double) regions_allocated / app_time_ms;
      _analytics-&gt;report_alloc_rate_ms(alloc_rate_ms);
  
<span class="line-modified">!     _analytics-&gt;compute_pause_time_ratios(end_time_sec, pause_time_ms);</span>
      _analytics-&gt;update_recent_gc_times(end_time_sec, pause_time_ms);
    }
  
    if (collector_state()-&gt;in_young_gc_before_mixed()) {
      assert(!this_pause_included_initial_mark, &quot;The young GC before mixed is not allowed to be an initial mark GC&quot;);
      // This has been the young GC before we start doing mixed GCs. We already
</pre>
<hr />
<pre>
<span class="line-old-header">*** 787,20 ***</span>
    update_rs_length_prediction();
  
    // Do not update dynamic IHOP due to G1 periodic collection as it is highly likely
    // that in this case we are not running in a &quot;normal&quot; operating mode.
    if (_g1h-&gt;gc_cause() != GCCause::_g1_periodic_collection) {
<span class="line-modified">!     // IHOP control wants to know the expected young gen length if it were not</span>
<span class="line-removed">-     // restrained by the heap reserve. Using the actual length would make the</span>
<span class="line-removed">-     // prediction too small and the limit the young gen every time we get to the</span>
<span class="line-removed">-     // predicted target occupancy.</span>
<span class="line-removed">-     size_t last_unrestrained_young_length = update_young_list_max_and_target_length();</span>
  
      _old_gen_alloc_tracker.reset_after_young_gc(app_time_ms / 1000.0);
      update_ihop_prediction(_old_gen_alloc_tracker.last_cycle_duration(),
                             _old_gen_alloc_tracker.last_cycle_old_bytes(),
<span class="line-removed">-                            last_unrestrained_young_length * HeapRegion::GrainBytes,</span>
                             this_pause_was_young_only);
  
      _ihop_control-&gt;send_trace_event(_g1h-&gt;gc_tracer_stw());
    } else {
      // Any garbage collection triggered as periodic collection resets the time-to-mixed
<span class="line-new-header">--- 897,15 ---</span>
    update_rs_length_prediction();
  
    // Do not update dynamic IHOP due to G1 periodic collection as it is highly likely
    // that in this case we are not running in a &quot;normal&quot; operating mode.
    if (_g1h-&gt;gc_cause() != GCCause::_g1_periodic_collection) {
<span class="line-modified">!     update_young_length_bounds();</span>
  
      _old_gen_alloc_tracker.reset_after_young_gc(app_time_ms / 1000.0);
      update_ihop_prediction(_old_gen_alloc_tracker.last_cycle_duration(),
                             _old_gen_alloc_tracker.last_cycle_old_bytes(),
                             this_pause_was_young_only);
  
      _ihop_control-&gt;send_trace_event(_g1h-&gt;gc_tracer_stw());
    } else {
      // Any garbage collection triggered as periodic collection resets the time-to-mixed
</pre>
<hr />
<pre>
<span class="line-old-header">*** 846,11 ***</span>
    }
  }
  
  void G1Policy::update_ihop_prediction(double mutator_time_s,
                                        size_t mutator_alloc_bytes,
<span class="line-removed">-                                       size_t young_gen_size,</span>
                                        bool this_gc_was_young_only) {
    // Always try to update IHOP prediction. Even evacuation failures give information
    // about e.g. whether to start IHOP earlier next time.
  
    // Avoid using really small application times that might create samples with
<span class="line-new-header">--- 951,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 874,10 ***</span>
<span class="line-new-header">--- 978,15 ---</span>
    // As an approximation for the young gc promotion rates during marking we use
    // all of them. In many applications there are only a few if any young gcs during
    // marking, which makes any prediction useless. This increases the accuracy of the
    // prediction.
    if (this_gc_was_young_only &amp;&amp; mutator_time_s &gt; min_valid_time) {
<span class="line-added">+     // IHOP control wants to know the expected young gen length if it were not</span>
<span class="line-added">+     // restrained by the heap reserve. Using the actual length would make the</span>
<span class="line-added">+     // prediction too small and the limit the young gen every time we get to the</span>
<span class="line-added">+     // predicted target occupancy.</span>
<span class="line-added">+     size_t young_gen_size = young_list_desired_length() * HeapRegion::GrainBytes;</span>
      _ihop_control-&gt;update_allocation_info(mutator_time_s, mutator_alloc_bytes, young_gen_size);
      report = true;
    }
  
    if (report) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 980,23 ***</span>
  
  void G1Policy::print_age_table() {
    _survivors_age_table.print_age_table(_tenuring_threshold);
  }
  
<span class="line-modified">! void G1Policy::update_max_gc_locker_expansion() {</span>
    uint expansion_region_num = 0;
    if (GCLockerEdenExpansionPercent &gt; 0) {
      double perc = (double) GCLockerEdenExpansionPercent / 100.0;
      double expansion_region_num_d = perc * (double) _young_list_target_length;
      // We use ceiling so that if expansion_region_num_d is &gt; 0.0 (but
      // less than 1.0) we&#39;ll get 1.
      expansion_region_num = (uint) ceil(expansion_region_num_d);
    } else {
      assert(expansion_region_num == 0, &quot;sanity&quot;);
    }
<span class="line-modified">!   _young_list_max_length = _young_list_target_length + expansion_region_num;</span>
<span class="line-modified">!   assert(_young_list_target_length &lt;= _young_list_max_length, &quot;post-condition&quot;);</span>
  }
  
  // Calculates survivor space parameters.
  void G1Policy::update_survivors_policy() {
    double max_survivor_regions_d =
<span class="line-new-header">--- 1089,24 ---</span>
  
  void G1Policy::print_age_table() {
    _survivors_age_table.print_age_table(_tenuring_threshold);
  }
  
<span class="line-modified">! uint G1Policy::calculate_young_max_length(uint target_young_length) const {</span>
    uint expansion_region_num = 0;
    if (GCLockerEdenExpansionPercent &gt; 0) {
      double perc = (double) GCLockerEdenExpansionPercent / 100.0;
      double expansion_region_num_d = perc * (double) _young_list_target_length;
      // We use ceiling so that if expansion_region_num_d is &gt; 0.0 (but
      // less than 1.0) we&#39;ll get 1.
      expansion_region_num = (uint) ceil(expansion_region_num_d);
    } else {
      assert(expansion_region_num == 0, &quot;sanity&quot;);
    }
<span class="line-modified">!   uint max_length = target_young_length + expansion_region_num;</span>
<span class="line-modified">!   assert(target_young_length &lt;= max_length, &quot;post-condition&quot;);</span>
<span class="line-added">+   return max_length;</span>
  }
  
  // Calculates survivor space parameters.
  void G1Policy::update_survivors_policy() {
    double max_survivor_regions_d =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1201,26 ***</span>
  
  bool G1Policy::next_gc_should_be_mixed(const char* true_action_str,
                                         const char* false_action_str) const {
    G1CollectionSetCandidates* candidates = _collection_set-&gt;candidates();
  
<span class="line-modified">!   if (candidates-&gt;is_empty()) {</span>
<span class="line-modified">!     log_debug(gc, ergo)(&quot;%s (candidate old regions not available)&quot;, false_action_str);</span>
      return false;
    }
  
    // Is the amount of uncollected reclaimable space above G1HeapWastePercent?
    size_t reclaimable_bytes = candidates-&gt;remaining_reclaimable_bytes();
    double reclaimable_percent = reclaimable_bytes_percent(reclaimable_bytes);
    double threshold = (double) G1HeapWastePercent;
    if (reclaimable_percent &lt;= threshold) {
<span class="line-modified">!     log_debug(gc, ergo)(&quot;%s (reclaimable percentage not over threshold). candidate old regions: %u reclaimable: &quot; SIZE_FORMAT &quot; (%1.2f) threshold: &quot; UINTX_FORMAT,</span>
<span class="line-modified">!                         false_action_str, candidates-&gt;num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);</span>
      return false;
    }
<span class="line-modified">!   log_debug(gc, ergo)(&quot;%s (candidate old regions available). candidate old regions: %u reclaimable: &quot; SIZE_FORMAT &quot; (%1.2f) threshold: &quot; UINTX_FORMAT,</span>
<span class="line-modified">!                       true_action_str, candidates-&gt;num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);</span>
    return true;
  }
  
  uint G1Policy::calc_min_old_cset_length() const {
    // The min old CSet region bound is based on the maximum desired
<span class="line-new-header">--- 1311,32 ---</span>
  
  bool G1Policy::next_gc_should_be_mixed(const char* true_action_str,
                                         const char* false_action_str) const {
    G1CollectionSetCandidates* candidates = _collection_set-&gt;candidates();
  
<span class="line-modified">!   if (candidates == NULL || candidates-&gt;is_empty()) {</span>
<span class="line-modified">!     if (false_action_str != NULL) {</span>
<span class="line-added">+       log_debug(gc, ergo)(&quot;%s (candidate old regions not available)&quot;, false_action_str);</span>
<span class="line-added">+     }</span>
      return false;
    }
  
    // Is the amount of uncollected reclaimable space above G1HeapWastePercent?
    size_t reclaimable_bytes = candidates-&gt;remaining_reclaimable_bytes();
    double reclaimable_percent = reclaimable_bytes_percent(reclaimable_bytes);
    double threshold = (double) G1HeapWastePercent;
    if (reclaimable_percent &lt;= threshold) {
<span class="line-modified">!     if (false_action_str != NULL) {</span>
<span class="line-modified">!       log_debug(gc, ergo)(&quot;%s (reclaimable percentage not over threshold). candidate old regions: %u reclaimable: &quot; SIZE_FORMAT &quot; (%1.2f) threshold: &quot; UINTX_FORMAT,</span>
<span class="line-added">+                           false_action_str, candidates-&gt;num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);</span>
<span class="line-added">+     }</span>
      return false;
    }
<span class="line-modified">!   if (true_action_str != NULL) {</span>
<span class="line-modified">!     log_debug(gc, ergo)(&quot;%s (candidate old regions available). candidate old regions: %u reclaimable: &quot; SIZE_FORMAT &quot; (%1.2f) threshold: &quot; UINTX_FORMAT,</span>
<span class="line-added">+                         true_action_str, candidates-&gt;num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);</span>
<span class="line-added">+   }</span>
    return true;
  }
  
  uint G1Policy::calc_min_old_cset_length() const {
    // The min old CSet region bound is based on the maximum desired
</pre>
<center><a href="g1CollectedHeap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
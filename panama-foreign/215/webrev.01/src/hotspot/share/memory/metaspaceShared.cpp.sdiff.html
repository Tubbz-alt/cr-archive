<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspaceShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="iterator.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspaceShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 439 // Called by universe_post_init()
 440 void MetaspaceShared::post_initialize(TRAPS) {
 441   if (UseSharedSpaces) {
 442     int size = FileMapInfo::get_number_of_shared_paths();
 443     if (size &gt; 0) {
 444       SystemDictionaryShared::allocate_shared_data_arrays(size, THREAD);
 445       if (!DynamicDumpSharedSpaces) {
 446         FileMapInfo* info;
 447         if (FileMapInfo::dynamic_info() == NULL) {
 448           info = FileMapInfo::current_info();
 449         } else {
 450           info = FileMapInfo::dynamic_info();
 451         }
 452         ClassLoaderExt::init_paths_start_index(info-&gt;app_class_paths_start_index());
 453         ClassLoaderExt::init_app_module_paths_start_index(info-&gt;app_module_paths_start_index());
 454       }
 455     }
 456   }
 457 }
 458 
<span class="line-modified"> 459 static GrowableArray&lt;Handle&gt;* _extra_interned_strings = NULL;</span>
 460 
 461 void MetaspaceShared::read_extra_data(const char* filename, TRAPS) {
<span class="line-modified"> 462   _extra_interned_strings = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray&lt;Handle&gt;(10000, mtClassShared);</span>
 463 
 464   HashtableTextDump reader(filename);
 465   reader.check_version(&quot;VERSION: 1.0&quot;);
 466 
 467   while (reader.remain() &gt; 0) {
 468     int utf8_length;
 469     int prefix_type = reader.scan_prefix(&amp;utf8_length);
 470     ResourceMark rm(THREAD);
 471     if (utf8_length == 0x7fffffff) {
 472       // buf_len will overflown 32-bit value.
 473       vm_exit_during_initialization(err_msg(&quot;string length too large: %d&quot;, utf8_length));
 474     }
 475     int buf_len = utf8_length+1;
 476     char* utf8_buffer = NEW_RESOURCE_ARRAY(char, buf_len);
 477     reader.get_utf8(utf8_buffer, utf8_length);
 478     utf8_buffer[utf8_length] = &#39;\0&#39;;
 479 
 480     if (prefix_type == HashtableTextDump::SymbolPrefix) {
 481       SymbolTable::new_permanent_symbol(utf8_buffer);
 482     } else{
</pre>
<hr />
<pre>
 646 
 647 class CollectClassesClosure : public KlassClosure {
 648   void do_klass(Klass* k) {
 649     if (k-&gt;is_instance_klass() &amp;&amp;
 650         SystemDictionaryShared::is_excluded_class(InstanceKlass::cast(k))) {
 651       // Don&#39;t add to the _global_klass_objects
 652     } else {
 653       _global_klass_objects-&gt;append_if_missing(k);
 654     }
 655     if (k-&gt;is_array_klass()) {
 656       // Add in the array classes too
 657       ArrayKlass* ak = ArrayKlass::cast(k);
 658       Klass* h = ak-&gt;higher_dimension();
 659       if (h != NULL) {
 660         h-&gt;array_klasses_do(collect_array_classes);
 661       }
 662     }
 663   }
 664 };
 665 



























 666 static void remove_unshareable_in_classes() {
 667   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 668     Klass* k = _global_klass_objects-&gt;at(i);
 669     if (!k-&gt;is_objArray_klass()) {
 670       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 671       // on their array classes.
 672       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 673       k-&gt;remove_unshareable_info();
 674     }
 675   }
 676 }
 677 
 678 static void remove_java_mirror_in_classes() {
 679   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 680     Klass* k = _global_klass_objects-&gt;at(i);
 681     if (!k-&gt;is_objArray_klass()) {
 682       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 683       // on their array classes.
 684       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 685       k-&gt;remove_java_mirror();
</pre>
<hr />
<pre>
1221   void dump_java_heap_objects() NOT_CDS_JAVA_HEAP_RETURN;
1222   void dump_archive_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;
1223   void dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1224                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps);
1225   void dump_symbols();
1226   char* dump_read_only_tables();
1227   void print_class_stats();
1228   void print_region_stats(FileMapInfo* map_info);
1229   void print_bitmap_region_stats(size_t size, size_t total_size);
1230   void print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1231                                const char *name, size_t total_size);
1232   void relocate_to_requested_base_address(CHeapBitMap* ptrmap);
1233 
1234 public:
1235 
1236   VMOp_Type type() const { return VMOp_PopulateDumpSharedSpace; }
1237   void doit();   // outline because gdb sucks
1238   bool allow_nested_vm_operations() const { return true; }
1239 }; // class VM_PopulateDumpSharedSpace
1240 
<span class="line-removed">1241 class SortedSymbolClosure: public SymbolClosure {</span>
<span class="line-removed">1242   GrowableArray&lt;Symbol*&gt; _symbols;</span>
<span class="line-removed">1243   virtual void do_symbol(Symbol** sym) {</span>
<span class="line-removed">1244     assert((*sym)-&gt;is_permanent(), &quot;archived symbols must be permanent&quot;);</span>
<span class="line-removed">1245     _symbols.append(*sym);</span>
<span class="line-removed">1246   }</span>
<span class="line-removed">1247   static int compare_symbols_by_address(Symbol** a, Symbol** b) {</span>
<span class="line-removed">1248     if (a[0] &lt; b[0]) {</span>
<span class="line-removed">1249       return -1;</span>
<span class="line-removed">1250     } else if (a[0] == b[0]) {</span>
<span class="line-removed">1251       ResourceMark rm;</span>
<span class="line-removed">1252       log_warning(cds)(&quot;Duplicated symbol %s unexpected&quot;, (*a)-&gt;as_C_string());</span>
<span class="line-removed">1253       return 0;</span>
<span class="line-removed">1254     } else {</span>
<span class="line-removed">1255       return 1;</span>
<span class="line-removed">1256     }</span>
<span class="line-removed">1257   }</span>
<span class="line-removed">1258 </span>
<span class="line-removed">1259 public:</span>
<span class="line-removed">1260   SortedSymbolClosure() {</span>
<span class="line-removed">1261     SymbolTable::symbols_do(this);</span>
<span class="line-removed">1262     _symbols.sort(compare_symbols_by_address);</span>
<span class="line-removed">1263   }</span>
<span class="line-removed">1264   GrowableArray&lt;Symbol*&gt;* get_sorted_symbols() {</span>
<span class="line-removed">1265     return &amp;_symbols;</span>
<span class="line-removed">1266   }</span>
<span class="line-removed">1267 };</span>
<span class="line-removed">1268 </span>
1269 // ArchiveCompactor --
1270 //
1271 // This class is the central piece of shared archive compaction -- all metaspace data are
1272 // initially allocated outside of the shared regions. ArchiveCompactor copies the
1273 // metaspace data into their final location in the shared regions.
1274 
1275 class ArchiveCompactor : AllStatic {
1276   static const int INITIAL_TABLE_SIZE = 8087;
1277   static const int MAX_TABLE_SIZE     = 1000000;
1278 
1279   static DumpAllocStats* _alloc_stats;
<span class="line-removed">1280   static SortedSymbolClosure* _ssc;</span>
1281 
1282   typedef KVHashtable&lt;address, address, mtInternal&gt; RelocationTable;
1283   static RelocationTable* _new_loc_table;
1284 
1285 public:
1286   static void initialize() {
1287     _alloc_stats = new(ResourceObj::C_HEAP, mtInternal)DumpAllocStats;
1288     _new_loc_table = new RelocationTable(INITIAL_TABLE_SIZE);
1289   }
1290   static DumpAllocStats* alloc_stats() {
1291     return _alloc_stats;
1292   }
1293 
1294   // Use this when you allocate space with MetaspaceShare::read_only_space_alloc()
1295   // outside of ArchiveCompactor::allocate(). These are usually for misc tables
1296   // that are allocated in the RO space.
1297   class OtherROAllocMark {
1298     char* _oldtop;
1299   public:
1300     OtherROAllocMark() {
</pre>
<hr />
<pre>
1404     }
1405   };
1406 
1407 #ifdef ASSERT
1408   class IsRefInArchiveChecker: public MetaspaceClosure {
1409   public:
1410     virtual bool do_ref(Ref* ref, bool read_only) {
1411       if (ref-&gt;not_null()) {
1412         char* obj = (char*)ref-&gt;obj();
1413         assert(_ro_region.contains(obj) || _rw_region.contains(obj),
1414                &quot;must be relocated to point to CDS archive&quot;);
1415       }
1416       return false; // Do not recurse.
1417     }
1418   };
1419 #endif
1420 
1421 public:
1422   static void copy_and_compact() {
1423     ResourceMark rm;
<span class="line-removed">1424     SortedSymbolClosure the_ssc; // StackObj</span>
<span class="line-removed">1425     _ssc = &amp;the_ssc;</span>
1426 
1427     log_info(cds)(&quot;Scanning all metaspace objects ... &quot;);
1428     {
1429       // allocate and shallow-copy RW objects, immediately following the MC region
1430       log_info(cds)(&quot;Allocating RW objects ... &quot;);
1431       _mc_region.pack(&amp;_rw_region);
1432 
1433       ResourceMark rm;
1434       ShallowCopier rw_copier(false);
1435       iterate_roots(&amp;rw_copier);
1436     }
1437     {
1438       // allocate and shallow-copy of RO object, immediately following the RW region
1439       log_info(cds)(&quot;Allocating RO objects ... &quot;);
1440       _rw_region.pack(&amp;_ro_region);
1441 
1442       ResourceMark rm;
1443       ShallowCopier ro_copier(true);
1444       iterate_roots(&amp;ro_copier);
1445     }
1446     {
1447       log_info(cds)(&quot;Relocating embedded pointers ... &quot;);
1448       ResourceMark rm;
1449       ShallowCopyEmbeddedRefRelocator emb_reloc;
1450       iterate_roots(&amp;emb_reloc);
1451     }
1452     {
1453       log_info(cds)(&quot;Relocating external roots ... &quot;);
1454       ResourceMark rm;
1455       RefRelocator ext_reloc;
1456       iterate_roots(&amp;ext_reloc);
1457     }
1458     {
1459       log_info(cds)(&quot;Fixing symbol identity hash ... &quot;);
1460       os::init_random(0x12345678);
<span class="line-modified">1461       GrowableArray&lt;Symbol*&gt;* symbols = _ssc-&gt;get_sorted_symbols();</span>
<span class="line-modified">1462       for (int i=0; i&lt;symbols-&gt;length(); i++) {</span>
<span class="line-modified">1463         symbols-&gt;at(i)-&gt;update_identity_hash();</span>


1464       }
1465     }
1466 #ifdef ASSERT
1467     {
1468       log_info(cds)(&quot;Verifying external roots ... &quot;);
1469       ResourceMark rm;
1470       IsRefInArchiveChecker checker;
1471       iterate_roots(&amp;checker);
1472     }
1473 #endif
<span class="line-removed">1474 </span>
<span class="line-removed">1475 </span>
<span class="line-removed">1476     // cleanup</span>
<span class="line-removed">1477     _ssc = NULL;</span>
1478   }
1479 
1480   // We must relocate the System::_well_known_klasses only after we have copied the
1481   // java objects in during dump_java_heap_objects(): during the object copy, we operate on
1482   // old objects which assert that their klass is the original klass.
1483   static void relocate_well_known_klasses() {
1484     {
1485       log_info(cds)(&quot;Relocating SystemDictionary::_well_known_klasses[] ... &quot;);
1486       ResourceMark rm;
1487       RefRelocator ext_reloc;
1488       SystemDictionary::well_known_klasses_do(&amp;ext_reloc);
1489     }
1490     // NOTE: after this point, we shouldn&#39;t have any globals that can reach the old
1491     // objects.
1492 
1493     // We cannot use any of the objects in the heap anymore (except for the
1494     // shared strings) because their headers no longer point to valid Klasses.
1495   }
1496 
1497   static void iterate_roots(MetaspaceClosure* it) {
1498     // To ensure deterministic contents in the archive, we just need to ensure that
1499     // we iterate the MetsapceObjs in a deterministic order. It doesn&#39;t matter where
1500     // the MetsapceObjs are located originally, as they are copied sequentially into
1501     // the archive during the iteration.
1502     //
1503     // The only issue here is that the symbol table and the system directories may be
1504     // randomly ordered, so we copy the symbols and klasses into two arrays and sort
1505     // them deterministically.
1506     //
1507     // During -Xshare:dump, the order of Symbol creation is strictly determined by
1508     // the SharedClassListFile (class loading is done in a single thread and the JIT
1509     // is disabled). Also, Symbols are allocated in monotonically increasing addresses
1510     // (see Symbol::operator new(size_t, int)). So if we iterate the Symbols by
1511     // ascending address order, we ensure that all Symbols are copied into deterministic
1512     // locations in the archive.
<span class="line-modified">1513     GrowableArray&lt;Symbol*&gt;* symbols = _ssc-&gt;get_sorted_symbols();</span>
<span class="line-modified">1514     for (int i=0; i&lt;symbols-&gt;length(); i++) {</span>
1515       it-&gt;push(symbols-&gt;adr_at(i));
1516     }
1517     if (_global_klass_objects != NULL) {
1518       // Need to fix up the pointers
1519       for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1520         // NOTE -- this requires that the vtable is NOT yet patched, or else we are hosed.
1521         it-&gt;push(_global_klass_objects-&gt;adr_at(i));
1522       }
1523     }
1524     FileMapInfo::metaspace_pointers_do(it, false);
1525     SystemDictionaryShared::dumptime_classes_do(it);
1526     Universe::metaspace_pointers_do(it);
1527     SymbolTable::metaspace_pointers_do(it);
1528     vmSymbols::metaspace_pointers_do(it);
1529 
1530     it-&gt;finish();
1531   }
1532 
1533   static Klass* get_relocated_klass(Klass* orig_klass) {
1534     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1535     address* pp = _new_loc_table-&gt;lookup((address)orig_klass);
1536     assert(pp != NULL, &quot;must be&quot;);
1537     Klass* klass = (Klass*)(*pp);
1538     assert(klass-&gt;is_klass(), &quot;must be&quot;);
1539     return klass;
1540   }
1541 };
1542 
1543 DumpAllocStats* ArchiveCompactor::_alloc_stats;
<span class="line-removed">1544 SortedSymbolClosure* ArchiveCompactor::_ssc;</span>
1545 ArchiveCompactor::RelocationTable* ArchiveCompactor::_new_loc_table;
1546 
1547 void VM_PopulateDumpSharedSpace::dump_symbols() {
1548   log_info(cds)(&quot;Dumping symbol table ...&quot;);
1549 
1550   NOT_PRODUCT(SymbolTable::verify());
1551   SymbolTable::write_to_archive();
1552 }
1553 
1554 char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {
1555   ArchiveCompactor::OtherROAllocMark mark;
1556 
1557   log_info(cds)(&quot;Removing java_mirror ... &quot;);
1558   if (!HeapShared::is_heap_object_archiving_allowed()) {
1559     clear_basic_type_mirrors();
1560   }
1561   remove_java_mirror_in_classes();
1562   log_info(cds)(&quot;done. &quot;);
1563 
1564   SystemDictionaryShared::write_to_archive();
</pre>
</td>
<td>
<hr />
<pre>
 439 // Called by universe_post_init()
 440 void MetaspaceShared::post_initialize(TRAPS) {
 441   if (UseSharedSpaces) {
 442     int size = FileMapInfo::get_number_of_shared_paths();
 443     if (size &gt; 0) {
 444       SystemDictionaryShared::allocate_shared_data_arrays(size, THREAD);
 445       if (!DynamicDumpSharedSpaces) {
 446         FileMapInfo* info;
 447         if (FileMapInfo::dynamic_info() == NULL) {
 448           info = FileMapInfo::current_info();
 449         } else {
 450           info = FileMapInfo::dynamic_info();
 451         }
 452         ClassLoaderExt::init_paths_start_index(info-&gt;app_class_paths_start_index());
 453         ClassLoaderExt::init_app_module_paths_start_index(info-&gt;app_module_paths_start_index());
 454       }
 455     }
 456   }
 457 }
 458 
<span class="line-modified"> 459 static GrowableArrayCHeap&lt;Handle, mtClassShared&gt;* _extra_interned_strings = NULL;</span>
 460 
 461 void MetaspaceShared::read_extra_data(const char* filename, TRAPS) {
<span class="line-modified"> 462   _extra_interned_strings = new GrowableArrayCHeap&lt;Handle, mtClassShared&gt;(10000);</span>
 463 
 464   HashtableTextDump reader(filename);
 465   reader.check_version(&quot;VERSION: 1.0&quot;);
 466 
 467   while (reader.remain() &gt; 0) {
 468     int utf8_length;
 469     int prefix_type = reader.scan_prefix(&amp;utf8_length);
 470     ResourceMark rm(THREAD);
 471     if (utf8_length == 0x7fffffff) {
 472       // buf_len will overflown 32-bit value.
 473       vm_exit_during_initialization(err_msg(&quot;string length too large: %d&quot;, utf8_length));
 474     }
 475     int buf_len = utf8_length+1;
 476     char* utf8_buffer = NEW_RESOURCE_ARRAY(char, buf_len);
 477     reader.get_utf8(utf8_buffer, utf8_length);
 478     utf8_buffer[utf8_length] = &#39;\0&#39;;
 479 
 480     if (prefix_type == HashtableTextDump::SymbolPrefix) {
 481       SymbolTable::new_permanent_symbol(utf8_buffer);
 482     } else{
</pre>
<hr />
<pre>
 646 
 647 class CollectClassesClosure : public KlassClosure {
 648   void do_klass(Klass* k) {
 649     if (k-&gt;is_instance_klass() &amp;&amp;
 650         SystemDictionaryShared::is_excluded_class(InstanceKlass::cast(k))) {
 651       // Don&#39;t add to the _global_klass_objects
 652     } else {
 653       _global_klass_objects-&gt;append_if_missing(k);
 654     }
 655     if (k-&gt;is_array_klass()) {
 656       // Add in the array classes too
 657       ArrayKlass* ak = ArrayKlass::cast(k);
 658       Klass* h = ak-&gt;higher_dimension();
 659       if (h != NULL) {
 660         h-&gt;array_klasses_do(collect_array_classes);
 661       }
 662     }
 663   }
 664 };
 665 
<span class="line-added"> 666 // Global object for holding symbols that created during class loading. See SymbolTable::new_symbol</span>
<span class="line-added"> 667 static GrowableArray&lt;Symbol*&gt;* _global_symbol_objects = NULL;</span>
<span class="line-added"> 668 </span>
<span class="line-added"> 669 static int compare_symbols_by_address(Symbol** a, Symbol** b) {</span>
<span class="line-added"> 670   if (a[0] &lt; b[0]) {</span>
<span class="line-added"> 671     return -1;</span>
<span class="line-added"> 672   } else if (a[0] == b[0]) {</span>
<span class="line-added"> 673     ResourceMark rm;</span>
<span class="line-added"> 674     log_warning(cds)(&quot;Duplicated symbol %s unexpected&quot;, (*a)-&gt;as_C_string());</span>
<span class="line-added"> 675     return 0;</span>
<span class="line-added"> 676   } else {</span>
<span class="line-added"> 677     return 1;</span>
<span class="line-added"> 678   }</span>
<span class="line-added"> 679 }</span>
<span class="line-added"> 680 </span>
<span class="line-added"> 681 void MetaspaceShared::add_symbol(Symbol* sym) {</span>
<span class="line-added"> 682   MutexLocker ml(CDSAddSymbol_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added"> 683   if (_global_symbol_objects == NULL) {</span>
<span class="line-added"> 684     _global_symbol_objects = new (ResourceObj::C_HEAP, mtSymbol) GrowableArray&lt;Symbol*&gt;(2048, mtSymbol);</span>
<span class="line-added"> 685   }</span>
<span class="line-added"> 686   _global_symbol_objects-&gt;append(sym);</span>
<span class="line-added"> 687 }</span>
<span class="line-added"> 688 </span>
<span class="line-added"> 689 GrowableArray&lt;Symbol*&gt;* MetaspaceShared::collected_symbols() {</span>
<span class="line-added"> 690   return _global_symbol_objects;</span>
<span class="line-added"> 691 }</span>
<span class="line-added"> 692 </span>
 693 static void remove_unshareable_in_classes() {
 694   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 695     Klass* k = _global_klass_objects-&gt;at(i);
 696     if (!k-&gt;is_objArray_klass()) {
 697       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 698       // on their array classes.
 699       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 700       k-&gt;remove_unshareable_info();
 701     }
 702   }
 703 }
 704 
 705 static void remove_java_mirror_in_classes() {
 706   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 707     Klass* k = _global_klass_objects-&gt;at(i);
 708     if (!k-&gt;is_objArray_klass()) {
 709       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 710       // on their array classes.
 711       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 712       k-&gt;remove_java_mirror();
</pre>
<hr />
<pre>
1248   void dump_java_heap_objects() NOT_CDS_JAVA_HEAP_RETURN;
1249   void dump_archive_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;
1250   void dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1251                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps);
1252   void dump_symbols();
1253   char* dump_read_only_tables();
1254   void print_class_stats();
1255   void print_region_stats(FileMapInfo* map_info);
1256   void print_bitmap_region_stats(size_t size, size_t total_size);
1257   void print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1258                                const char *name, size_t total_size);
1259   void relocate_to_requested_base_address(CHeapBitMap* ptrmap);
1260 
1261 public:
1262 
1263   VMOp_Type type() const { return VMOp_PopulateDumpSharedSpace; }
1264   void doit();   // outline because gdb sucks
1265   bool allow_nested_vm_operations() const { return true; }
1266 }; // class VM_PopulateDumpSharedSpace
1267 




























1268 // ArchiveCompactor --
1269 //
1270 // This class is the central piece of shared archive compaction -- all metaspace data are
1271 // initially allocated outside of the shared regions. ArchiveCompactor copies the
1272 // metaspace data into their final location in the shared regions.
1273 
1274 class ArchiveCompactor : AllStatic {
1275   static const int INITIAL_TABLE_SIZE = 8087;
1276   static const int MAX_TABLE_SIZE     = 1000000;
1277 
1278   static DumpAllocStats* _alloc_stats;

1279 
1280   typedef KVHashtable&lt;address, address, mtInternal&gt; RelocationTable;
1281   static RelocationTable* _new_loc_table;
1282 
1283 public:
1284   static void initialize() {
1285     _alloc_stats = new(ResourceObj::C_HEAP, mtInternal)DumpAllocStats;
1286     _new_loc_table = new RelocationTable(INITIAL_TABLE_SIZE);
1287   }
1288   static DumpAllocStats* alloc_stats() {
1289     return _alloc_stats;
1290   }
1291 
1292   // Use this when you allocate space with MetaspaceShare::read_only_space_alloc()
1293   // outside of ArchiveCompactor::allocate(). These are usually for misc tables
1294   // that are allocated in the RO space.
1295   class OtherROAllocMark {
1296     char* _oldtop;
1297   public:
1298     OtherROAllocMark() {
</pre>
<hr />
<pre>
1402     }
1403   };
1404 
1405 #ifdef ASSERT
1406   class IsRefInArchiveChecker: public MetaspaceClosure {
1407   public:
1408     virtual bool do_ref(Ref* ref, bool read_only) {
1409       if (ref-&gt;not_null()) {
1410         char* obj = (char*)ref-&gt;obj();
1411         assert(_ro_region.contains(obj) || _rw_region.contains(obj),
1412                &quot;must be relocated to point to CDS archive&quot;);
1413       }
1414       return false; // Do not recurse.
1415     }
1416   };
1417 #endif
1418 
1419 public:
1420   static void copy_and_compact() {
1421     ResourceMark rm;


1422 
1423     log_info(cds)(&quot;Scanning all metaspace objects ... &quot;);
1424     {
1425       // allocate and shallow-copy RW objects, immediately following the MC region
1426       log_info(cds)(&quot;Allocating RW objects ... &quot;);
1427       _mc_region.pack(&amp;_rw_region);
1428 
1429       ResourceMark rm;
1430       ShallowCopier rw_copier(false);
1431       iterate_roots(&amp;rw_copier);
1432     }
1433     {
1434       // allocate and shallow-copy of RO object, immediately following the RW region
1435       log_info(cds)(&quot;Allocating RO objects ... &quot;);
1436       _rw_region.pack(&amp;_ro_region);
1437 
1438       ResourceMark rm;
1439       ShallowCopier ro_copier(true);
1440       iterate_roots(&amp;ro_copier);
1441     }
1442     {
1443       log_info(cds)(&quot;Relocating embedded pointers ... &quot;);
1444       ResourceMark rm;
1445       ShallowCopyEmbeddedRefRelocator emb_reloc;
1446       iterate_roots(&amp;emb_reloc);
1447     }
1448     {
1449       log_info(cds)(&quot;Relocating external roots ... &quot;);
1450       ResourceMark rm;
1451       RefRelocator ext_reloc;
1452       iterate_roots(&amp;ext_reloc);
1453     }
1454     {
1455       log_info(cds)(&quot;Fixing symbol identity hash ... &quot;);
1456       os::init_random(0x12345678);
<span class="line-modified">1457       GrowableArray&lt;Symbol*&gt;* all_symbols = MetaspaceShared::collected_symbols();</span>
<span class="line-modified">1458       all_symbols-&gt;sort(compare_symbols_by_address);</span>
<span class="line-modified">1459       for (int i = 0; i &lt; all_symbols-&gt;length(); i++) {</span>
<span class="line-added">1460         assert(all_symbols-&gt;at(i)-&gt;is_permanent(), &quot;archived symbols must be permanent&quot;);</span>
<span class="line-added">1461         all_symbols-&gt;at(i)-&gt;update_identity_hash();</span>
1462       }
1463     }
1464 #ifdef ASSERT
1465     {
1466       log_info(cds)(&quot;Verifying external roots ... &quot;);
1467       ResourceMark rm;
1468       IsRefInArchiveChecker checker;
1469       iterate_roots(&amp;checker);
1470     }
1471 #endif




1472   }
1473 
1474   // We must relocate the System::_well_known_klasses only after we have copied the
1475   // java objects in during dump_java_heap_objects(): during the object copy, we operate on
1476   // old objects which assert that their klass is the original klass.
1477   static void relocate_well_known_klasses() {
1478     {
1479       log_info(cds)(&quot;Relocating SystemDictionary::_well_known_klasses[] ... &quot;);
1480       ResourceMark rm;
1481       RefRelocator ext_reloc;
1482       SystemDictionary::well_known_klasses_do(&amp;ext_reloc);
1483     }
1484     // NOTE: after this point, we shouldn&#39;t have any globals that can reach the old
1485     // objects.
1486 
1487     // We cannot use any of the objects in the heap anymore (except for the
1488     // shared strings) because their headers no longer point to valid Klasses.
1489   }
1490 
1491   static void iterate_roots(MetaspaceClosure* it) {
1492     // To ensure deterministic contents in the archive, we just need to ensure that
1493     // we iterate the MetsapceObjs in a deterministic order. It doesn&#39;t matter where
1494     // the MetsapceObjs are located originally, as they are copied sequentially into
1495     // the archive during the iteration.
1496     //
1497     // The only issue here is that the symbol table and the system directories may be
1498     // randomly ordered, so we copy the symbols and klasses into two arrays and sort
1499     // them deterministically.
1500     //
1501     // During -Xshare:dump, the order of Symbol creation is strictly determined by
1502     // the SharedClassListFile (class loading is done in a single thread and the JIT
1503     // is disabled). Also, Symbols are allocated in monotonically increasing addresses
1504     // (see Symbol::operator new(size_t, int)). So if we iterate the Symbols by
1505     // ascending address order, we ensure that all Symbols are copied into deterministic
1506     // locations in the archive.
<span class="line-modified">1507     GrowableArray&lt;Symbol*&gt;* symbols = _global_symbol_objects;</span>
<span class="line-modified">1508     for (int i = 0; i &lt; symbols-&gt;length(); i++) {</span>
1509       it-&gt;push(symbols-&gt;adr_at(i));
1510     }
1511     if (_global_klass_objects != NULL) {
1512       // Need to fix up the pointers
1513       for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1514         // NOTE -- this requires that the vtable is NOT yet patched, or else we are hosed.
1515         it-&gt;push(_global_klass_objects-&gt;adr_at(i));
1516       }
1517     }
1518     FileMapInfo::metaspace_pointers_do(it, false);
1519     SystemDictionaryShared::dumptime_classes_do(it);
1520     Universe::metaspace_pointers_do(it);
1521     SymbolTable::metaspace_pointers_do(it);
1522     vmSymbols::metaspace_pointers_do(it);
1523 
1524     it-&gt;finish();
1525   }
1526 
1527   static Klass* get_relocated_klass(Klass* orig_klass) {
1528     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1529     address* pp = _new_loc_table-&gt;lookup((address)orig_klass);
1530     assert(pp != NULL, &quot;must be&quot;);
1531     Klass* klass = (Klass*)(*pp);
1532     assert(klass-&gt;is_klass(), &quot;must be&quot;);
1533     return klass;
1534   }
1535 };
1536 
1537 DumpAllocStats* ArchiveCompactor::_alloc_stats;

1538 ArchiveCompactor::RelocationTable* ArchiveCompactor::_new_loc_table;
1539 
1540 void VM_PopulateDumpSharedSpace::dump_symbols() {
1541   log_info(cds)(&quot;Dumping symbol table ...&quot;);
1542 
1543   NOT_PRODUCT(SymbolTable::verify());
1544   SymbolTable::write_to_archive();
1545 }
1546 
1547 char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {
1548   ArchiveCompactor::OtherROAllocMark mark;
1549 
1550   log_info(cds)(&quot;Removing java_mirror ... &quot;);
1551   if (!HeapShared::is_heap_object_archiving_allowed()) {
1552     clear_basic_type_mirrors();
1553   }
1554   remove_java_mirror_in_classes();
1555   log_info(cds)(&quot;done. &quot;);
1556 
1557   SystemDictionaryShared::write_to_archive();
</pre>
</td>
</tr>
</table>
<center><a href="iterator.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/utilities/stack.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stack.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/io/ObjectInputStream.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/stack.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -59,27 +59,31 @@</span>
  
  template &lt;class E, MEMFLAGS F&gt;
  void Stack&lt;E, F&gt;::push(E item)
  {
    assert(!is_full(), &quot;pushing onto a full stack&quot;);
<span class="udiff-line-modified-removed">-   if (this-&gt;_cur_seg_size == this-&gt;_seg_size) {</span>
<span class="udiff-line-modified-added">+   size_t index = this-&gt;_cur_seg_size;</span>
<span class="udiff-line-added">+   if (index == this-&gt;_seg_size) {</span>
      push_segment();
<span class="udiff-line-added">+     index = 0;                  // Instead of fetching known zero _cur_seg_size.</span>
    }
<span class="udiff-line-modified-removed">-   this-&gt;_cur_seg[this-&gt;_cur_seg_size] = item;</span>
<span class="udiff-line-modified-removed">-   ++this-&gt;_cur_seg_size;</span>
<span class="udiff-line-modified-added">+   this-&gt;_cur_seg[index] = item;</span>
<span class="udiff-line-modified-added">+   this-&gt;_cur_seg_size = index + 1;</span>
  }
  
  template &lt;class E, MEMFLAGS F&gt;
  E Stack&lt;E, F&gt;::pop()
  {
    assert(!is_empty(), &quot;popping from an empty stack&quot;);
<span class="udiff-line-modified-removed">-   if (this-&gt;_cur_seg_size == 1) {</span>
<span class="udiff-line-modified-removed">-     E tmp = _cur_seg[--this-&gt;_cur_seg_size];</span>
<span class="udiff-line-modified-removed">-     pop_segment();</span>
<span class="udiff-line-modified-removed">-     return tmp;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   return this-&gt;_cur_seg[--this-&gt;_cur_seg_size];</span>
<span class="udiff-line-modified-added">+   // _cur_seg_size is never 0 if not empty.  pop that empties a</span>
<span class="udiff-line-modified-added">+   // segment also pops the segment.  push that adds a segment always</span>
<span class="udiff-line-modified-added">+   // adds an entry to the new segment.</span>
<span class="udiff-line-modified-added">+   assert(this-&gt;_cur_seg_size != 0, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   size_t index = --this-&gt;_cur_seg_size;</span>
<span class="udiff-line-modified-added">+   E result = _cur_seg[index];</span>
<span class="udiff-line-added">+   if (index == 0) pop_segment();</span>
<span class="udiff-line-added">+   return result;</span>
  }
  
  template &lt;class E, MEMFLAGS F&gt;
  void Stack&lt;E, F&gt;::clear(bool clear_cache)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -143,13 +147,12 @@</span>
    FREE_C_HEAP_ARRAY(char, (char*) addr);
  }
  
  // Stack is used by the GC code and in some hot paths a lot of the Stack
  // code gets inlined. This is generally good, but when too much code has
<span class="udiff-line-modified-removed">- // been inlined, no further inlining is allowed by GCC. Therefore we need</span>
<span class="udiff-line-modified-removed">- // to prevent parts of the slow path in Stack to be inlined to allow other</span>
<span class="udiff-line-removed">- // code to be.</span>
<span class="udiff-line-modified-added">+ // been inlined, further inlining in the caller might be inhibited. So</span>
<span class="udiff-line-modified-added">+ // prevent infrequent slow path segment manipulation from being inlined.</span>
  template &lt;class E, MEMFLAGS F&gt;
  NOINLINE void Stack&lt;E, F&gt;::push_segment()
  {
    assert(this-&gt;_cur_seg_size == this-&gt;_seg_size, &quot;current segment is not full&quot;);
    E* next;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -168,11 +171,11 @@</span>
    this-&gt;_full_seg_size += at_empty_transition ? 0 : this-&gt;_seg_size;
    DEBUG_ONLY(verify(at_empty_transition);)
  }
  
  template &lt;class E, MEMFLAGS F&gt;
<span class="udiff-line-modified-removed">- void Stack&lt;E, F&gt;::pop_segment()</span>
<span class="udiff-line-modified-added">+ NOINLINE void Stack&lt;E, F&gt;::pop_segment()</span>
  {
    assert(this-&gt;_cur_seg_size == 0, &quot;current segment is not empty&quot;);
    E* const prev = get_link(_cur_seg);
    if (this-&gt;_cache_size &lt; this-&gt;_max_cache_size) {
      // Add the current segment to the cache.
</pre>
<center><a href="stack.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/io/ObjectInputStream.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
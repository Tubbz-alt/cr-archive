<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/stack.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_STACK_INLINE_HPP
 26 #define SHARE_UTILITIES_STACK_INLINE_HPP
 27 
 28 #include &quot;memory/allocation.inline.hpp&quot;
 29 #include &quot;utilities/align.hpp&quot;
 30 #include &quot;utilities/stack.hpp&quot;
 31 #include &quot;utilities/copy.hpp&quot;
 32 
 33 template &lt;MEMFLAGS F&gt; StackBase&lt;F&gt;::StackBase(size_t segment_size, size_t max_cache_size,
 34                      size_t max_size):
 35   _seg_size(segment_size),
 36   _max_size(adjust_max_size(max_size, segment_size)),
 37   _max_cache_size(max_cache_size)
 38 {
 39   assert(_max_size % _seg_size == 0, &quot;not a multiple&quot;);
 40 }
 41 
 42 template &lt;MEMFLAGS F&gt; size_t StackBase&lt;F&gt;::adjust_max_size(size_t max_size, size_t seg_size)
 43 {
 44   assert(seg_size &gt; 0, &quot;cannot be 0&quot;);
 45   assert(max_size &gt;= seg_size || max_size == 0, &quot;max_size too small&quot;);
 46   const size_t limit = max_uintx - (seg_size - 1);
 47   if (max_size == 0 || max_size &gt; limit) {
 48     max_size = limit;
 49   }
 50   return (max_size + seg_size - 1) / seg_size * seg_size;
 51 }
 52 
 53 template &lt;class E, MEMFLAGS F&gt;
 54 Stack&lt;E, F&gt;::Stack(size_t segment_size, size_t max_cache_size, size_t max_size):
 55   StackBase&lt;F&gt;(adjust_segment_size(segment_size), max_cache_size, max_size)
 56 {
 57   reset(true);
 58 }
 59 
 60 template &lt;class E, MEMFLAGS F&gt;
 61 void Stack&lt;E, F&gt;::push(E item)
 62 {
 63   assert(!is_full(), &quot;pushing onto a full stack&quot;);
<a name="2" id="anc2"></a><span class="line-modified"> 64   if (this-&gt;_cur_seg_size == this-&gt;_seg_size) {</span>

 65     push_segment();
<a name="3" id="anc3"></a>
 66   }
<a name="4" id="anc4"></a><span class="line-modified"> 67   this-&gt;_cur_seg[this-&gt;_cur_seg_size] = item;</span>
<span class="line-modified"> 68   ++this-&gt;_cur_seg_size;</span>
 69 }
 70 
 71 template &lt;class E, MEMFLAGS F&gt;
 72 E Stack&lt;E, F&gt;::pop()
 73 {
 74   assert(!is_empty(), &quot;popping from an empty stack&quot;);
<a name="5" id="anc5"></a><span class="line-modified"> 75   if (this-&gt;_cur_seg_size == 1) {</span>
<span class="line-modified"> 76     E tmp = _cur_seg[--this-&gt;_cur_seg_size];</span>
<span class="line-modified"> 77     pop_segment();</span>
<span class="line-modified"> 78     return tmp;</span>
<span class="line-modified"> 79   }</span>
<span class="line-modified"> 80   return this-&gt;_cur_seg[--this-&gt;_cur_seg_size];</span>


 81 }
 82 
 83 template &lt;class E, MEMFLAGS F&gt;
 84 void Stack&lt;E, F&gt;::clear(bool clear_cache)
 85 {
 86   free_segments(_cur_seg);
 87   if (clear_cache) free_segments(_cache);
 88   reset(clear_cache);
 89 }
 90 
 91 template &lt;class E, MEMFLAGS F&gt;
 92 size_t Stack&lt;E, F&gt;::adjust_segment_size(size_t seg_size)
 93 {
 94   const size_t elem_sz = sizeof(E);
 95   const size_t ptr_sz = sizeof(E*);
 96   assert(elem_sz % ptr_sz == 0 || ptr_sz % elem_sz == 0, &quot;bad element size&quot;);
 97   if (elem_sz &lt; ptr_sz) {
 98     return align_up(seg_size * elem_sz, ptr_sz) / elem_sz;
 99   }
100   return seg_size;
101 }
102 
103 template &lt;class E, MEMFLAGS F&gt;
104 size_t Stack&lt;E, F&gt;::link_offset() const
105 {
106   return align_up(this-&gt;_seg_size * sizeof(E), sizeof(E*));
107 }
108 
109 template &lt;class E, MEMFLAGS F&gt;
110 size_t Stack&lt;E, F&gt;::segment_bytes() const
111 {
112   return link_offset() + sizeof(E*);
113 }
114 
115 template &lt;class E, MEMFLAGS F&gt;
116 E** Stack&lt;E, F&gt;::link_addr(E* seg) const
117 {
118   return (E**) ((char*)seg + link_offset());
119 }
120 
121 template &lt;class E, MEMFLAGS F&gt;
122 E* Stack&lt;E, F&gt;::get_link(E* seg) const
123 {
124   return *link_addr(seg);
125 }
126 
127 template &lt;class E, MEMFLAGS F&gt;
128 E* Stack&lt;E, F&gt;::set_link(E* new_seg, E* old_seg)
129 {
130   *link_addr(new_seg) = old_seg;
131   return new_seg;
132 }
133 
134 template &lt;class E, MEMFLAGS F&gt;
135 E* Stack&lt;E, F&gt;::alloc(size_t bytes)
136 {
137   return (E*) NEW_C_HEAP_ARRAY(char, bytes, F);
138 }
139 
140 template &lt;class E, MEMFLAGS F&gt;
141 void Stack&lt;E, F&gt;::free(E* addr, size_t bytes)
142 {
143   FREE_C_HEAP_ARRAY(char, (char*) addr);
144 }
145 
146 // Stack is used by the GC code and in some hot paths a lot of the Stack
147 // code gets inlined. This is generally good, but when too much code has
<a name="6" id="anc6"></a><span class="line-modified">148 // been inlined, no further inlining is allowed by GCC. Therefore we need</span>
<span class="line-modified">149 // to prevent parts of the slow path in Stack to be inlined to allow other</span>
<span class="line-removed">150 // code to be.</span>
151 template &lt;class E, MEMFLAGS F&gt;
152 NOINLINE void Stack&lt;E, F&gt;::push_segment()
153 {
154   assert(this-&gt;_cur_seg_size == this-&gt;_seg_size, &quot;current segment is not full&quot;);
155   E* next;
156   if (this-&gt;_cache_size &gt; 0) {
157     // Use a cached segment.
158     next = _cache;
159     _cache = get_link(_cache);
160     --this-&gt;_cache_size;
161   } else {
162     next = alloc(segment_bytes());
163     DEBUG_ONLY(zap_segment(next, true);)
164   }
165   const bool at_empty_transition = is_empty();
166   this-&gt;_cur_seg = set_link(next, _cur_seg);
167   this-&gt;_cur_seg_size = 0;
168   this-&gt;_full_seg_size += at_empty_transition ? 0 : this-&gt;_seg_size;
169   DEBUG_ONLY(verify(at_empty_transition);)
170 }
171 
172 template &lt;class E, MEMFLAGS F&gt;
<a name="7" id="anc7"></a><span class="line-modified">173 void Stack&lt;E, F&gt;::pop_segment()</span>
174 {
175   assert(this-&gt;_cur_seg_size == 0, &quot;current segment is not empty&quot;);
176   E* const prev = get_link(_cur_seg);
177   if (this-&gt;_cache_size &lt; this-&gt;_max_cache_size) {
178     // Add the current segment to the cache.
179     DEBUG_ONLY(zap_segment(_cur_seg, false);)
180     _cache = set_link(_cur_seg, _cache);
181     ++this-&gt;_cache_size;
182   } else {
183     DEBUG_ONLY(zap_segment(_cur_seg, true);)
184     free(_cur_seg, segment_bytes());
185   }
186   const bool at_empty_transition = prev == NULL;
187   this-&gt;_cur_seg = prev;
188   this-&gt;_cur_seg_size = this-&gt;_seg_size;
189   this-&gt;_full_seg_size -= at_empty_transition ? 0 : this-&gt;_seg_size;
190   DEBUG_ONLY(verify(at_empty_transition);)
191 }
192 
193 template &lt;class E, MEMFLAGS F&gt;
194 void Stack&lt;E, F&gt;::free_segments(E* seg)
195 {
196   const size_t bytes = segment_bytes();
197   while (seg != NULL) {
198     E* const prev = get_link(seg);
199     free(seg, bytes);
200     seg = prev;
201   }
202 }
203 
204 template &lt;class E, MEMFLAGS F&gt;
205 void Stack&lt;E, F&gt;::reset(bool reset_cache)
206 {
207   this-&gt;_cur_seg_size = this-&gt;_seg_size; // So push() will alloc a new segment.
208   this-&gt;_full_seg_size = 0;
209   _cur_seg = NULL;
210   if (reset_cache) {
211     this-&gt;_cache_size = 0;
212     _cache = NULL;
213   }
214 }
215 
216 #ifdef ASSERT
217 template &lt;class E, MEMFLAGS F&gt;
218 void Stack&lt;E, F&gt;::verify(bool at_empty_transition) const
219 {
220   assert(size() &lt;= this-&gt;max_size(), &quot;stack exceeded bounds&quot;);
221   assert(this-&gt;cache_size() &lt;= this-&gt;max_cache_size(), &quot;cache exceeded bounds&quot;);
222   assert(this-&gt;_cur_seg_size &lt;= this-&gt;segment_size(), &quot;segment index exceeded bounds&quot;);
223 
224   assert(this-&gt;_full_seg_size % this-&gt;_seg_size == 0, &quot;not a multiple&quot;);
225   assert(at_empty_transition || is_empty() == (size() == 0), &quot;mismatch&quot;);
226   assert((_cache == NULL) == (this-&gt;cache_size() == 0), &quot;mismatch&quot;);
227 
228   if (is_empty()) {
229     assert(this-&gt;_cur_seg_size == this-&gt;segment_size(), &quot;sanity&quot;);
230   }
231 }
232 
233 template &lt;class E, MEMFLAGS F&gt;
234 void Stack&lt;E, F&gt;::zap_segment(E* seg, bool zap_link_field) const
235 {
236   if (!ZapStackSegments) return;
237   const size_t zap_bytes = segment_bytes() - (zap_link_field ? 0 : sizeof(E*));
238   Copy::fill_to_bytes(seg, zap_bytes, badStackSegVal);
239 }
240 #endif
241 
242 template &lt;class E, MEMFLAGS F&gt;
243 E* ResourceStack&lt;E, F&gt;::alloc(size_t bytes)
244 {
245   return (E*) resource_allocate_bytes(bytes);
246 }
247 
248 template &lt;class E, MEMFLAGS F&gt;
249 void ResourceStack&lt;E, F&gt;::free(E* addr, size_t bytes)
250 {
251   resource_free_bytes((char*) addr, bytes);
252 }
253 
254 template &lt;class E, MEMFLAGS F&gt;
255 void StackIterator&lt;E, F&gt;::sync()
256 {
257   _full_seg_size = _stack._full_seg_size;
258   _cur_seg_size = _stack._cur_seg_size;
259   _cur_seg = _stack._cur_seg;
260 }
261 
262 template &lt;class E, MEMFLAGS F&gt;
263 E* StackIterator&lt;E, F&gt;::next_addr()
264 {
265   assert(!is_empty(), &quot;no items left&quot;);
266   if (_cur_seg_size == 1) {
267     E* addr = _cur_seg;
268     _cur_seg = _stack.get_link(_cur_seg);
269     _cur_seg_size = _stack.segment_size();
270     _full_seg_size -= _stack.segment_size();
271     return addr;
272   }
273   return _cur_seg + --_cur_seg_size;
274 }
275 
276 #endif // SHARE_UTILITIES_STACK_INLINE_HPP
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
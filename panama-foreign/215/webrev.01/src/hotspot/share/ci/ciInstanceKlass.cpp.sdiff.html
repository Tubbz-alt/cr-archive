<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciInstanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciField.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciInstanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciInstanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 47 // ciInstanceKlass::ciInstanceKlass
 48 //
 49 // Loaded instance klass.
 50 ciInstanceKlass::ciInstanceKlass(Klass* k) :
 51   ciKlass(k)
 52 {
 53   assert(get_Klass()-&gt;is_instance_klass(), &quot;wrong type&quot;);
 54   assert(get_instanceKlass()-&gt;is_loaded(), &quot;must be at least loaded&quot;);
 55   InstanceKlass* ik = get_instanceKlass();
 56 
 57   AccessFlags access_flags = ik-&gt;access_flags();
 58   _flags = ciFlags(access_flags);
 59   _has_finalizer = access_flags.has_finalizer();
 60   _has_subklass = flags().is_final() ? subklass_false : subklass_unknown;
 61   _init_state = ik-&gt;init_state();
 62   _nonstatic_field_size = ik-&gt;nonstatic_field_size();
 63   _has_nonstatic_fields = ik-&gt;has_nonstatic_fields();
 64   _has_nonstatic_concrete_methods = ik-&gt;has_nonstatic_concrete_methods();
 65   _is_unsafe_anonymous = ik-&gt;is_unsafe_anonymous();
 66   _is_hidden = ik-&gt;is_hidden();

 67   _nonstatic_fields = NULL; // initialized lazily by compute_nonstatic_fields:
 68   _has_injected_fields = -1;
 69   _implementor = NULL; // we will fill these lazily
 70 
 71   // Ensure that the metadata wrapped by the ciMetadata is kept alive by GC.
 72   // This is primarily useful for metadata which is considered as weak roots
 73   // by the GC but need to be strong roots if reachable from a current compilation.
 74   // InstanceKlass are created for both weak and strong metadata.  Ensuring this metadata
 75   // alive covers the cases where there are weak roots without performance cost.
 76   oop holder = ik-&gt;klass_holder();
 77   if (ik-&gt;class_loader_data()-&gt;has_class_mirror_holder()) {
 78     // Though ciInstanceKlass records class loader oop, it&#39;s not enough to keep
 79     // non-strong hidden classes and VM unsafe anonymous classes alive (loader == NULL). Klass holder should
 80     // be used instead. It is enough to record a ciObject, since cached elements are never removed
 81     // during ciObjectFactory lifetime. ciObjectFactory itself is created for
 82     // every compilation and lives for the whole duration of the compilation.
 83     assert(holder != NULL, &quot;holder of hidden or unsafe anonymous class is the mirror which is never null&quot;);
 84     (void)CURRENT_ENV-&gt;get_object(holder);
 85   }
 86 
</pre>
<hr />
<pre>
108     }
109     //compute_nonstatic_fields();  // done outside of constructor
110   }
111 
112   _field_cache = NULL;
113 }
114 
115 // Version for unloaded classes:
116 ciInstanceKlass::ciInstanceKlass(ciSymbol* name,
117                                  jobject loader, jobject protection_domain)
118   : ciKlass(name, T_OBJECT)
119 {
120   assert(name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY, &quot;not an instance klass&quot;);
121   _init_state = (InstanceKlass::ClassState)0;
122   _nonstatic_field_size = -1;
123   _has_nonstatic_fields = false;
124   _nonstatic_fields = NULL;
125   _has_injected_fields = -1;
126   _is_unsafe_anonymous = false;
127   _is_hidden = false;

128   _loader = loader;
129   _protection_domain = protection_domain;
130   _is_shared = false;
131   _super = NULL;
132   _java_mirror = NULL;
133   _field_cache = NULL;
134 }
135 
136 
137 
138 // ------------------------------------------------------------------
139 // ciInstanceKlass::compute_shared_is_initialized
140 void ciInstanceKlass::compute_shared_init_state() {
141   GUARDED_VM_ENTRY(
142     InstanceKlass* ik = get_instanceKlass();
143     _init_state = ik-&gt;init_state();
144   )
145 }
146 
147 // ------------------------------------------------------------------
</pre>
</td>
<td>
<hr />
<pre>
 47 // ciInstanceKlass::ciInstanceKlass
 48 //
 49 // Loaded instance klass.
 50 ciInstanceKlass::ciInstanceKlass(Klass* k) :
 51   ciKlass(k)
 52 {
 53   assert(get_Klass()-&gt;is_instance_klass(), &quot;wrong type&quot;);
 54   assert(get_instanceKlass()-&gt;is_loaded(), &quot;must be at least loaded&quot;);
 55   InstanceKlass* ik = get_instanceKlass();
 56 
 57   AccessFlags access_flags = ik-&gt;access_flags();
 58   _flags = ciFlags(access_flags);
 59   _has_finalizer = access_flags.has_finalizer();
 60   _has_subklass = flags().is_final() ? subklass_false : subklass_unknown;
 61   _init_state = ik-&gt;init_state();
 62   _nonstatic_field_size = ik-&gt;nonstatic_field_size();
 63   _has_nonstatic_fields = ik-&gt;has_nonstatic_fields();
 64   _has_nonstatic_concrete_methods = ik-&gt;has_nonstatic_concrete_methods();
 65   _is_unsafe_anonymous = ik-&gt;is_unsafe_anonymous();
 66   _is_hidden = ik-&gt;is_hidden();
<span class="line-added"> 67   _is_record = ik-&gt;is_record();</span>
 68   _nonstatic_fields = NULL; // initialized lazily by compute_nonstatic_fields:
 69   _has_injected_fields = -1;
 70   _implementor = NULL; // we will fill these lazily
 71 
 72   // Ensure that the metadata wrapped by the ciMetadata is kept alive by GC.
 73   // This is primarily useful for metadata which is considered as weak roots
 74   // by the GC but need to be strong roots if reachable from a current compilation.
 75   // InstanceKlass are created for both weak and strong metadata.  Ensuring this metadata
 76   // alive covers the cases where there are weak roots without performance cost.
 77   oop holder = ik-&gt;klass_holder();
 78   if (ik-&gt;class_loader_data()-&gt;has_class_mirror_holder()) {
 79     // Though ciInstanceKlass records class loader oop, it&#39;s not enough to keep
 80     // non-strong hidden classes and VM unsafe anonymous classes alive (loader == NULL). Klass holder should
 81     // be used instead. It is enough to record a ciObject, since cached elements are never removed
 82     // during ciObjectFactory lifetime. ciObjectFactory itself is created for
 83     // every compilation and lives for the whole duration of the compilation.
 84     assert(holder != NULL, &quot;holder of hidden or unsafe anonymous class is the mirror which is never null&quot;);
 85     (void)CURRENT_ENV-&gt;get_object(holder);
 86   }
 87 
</pre>
<hr />
<pre>
109     }
110     //compute_nonstatic_fields();  // done outside of constructor
111   }
112 
113   _field_cache = NULL;
114 }
115 
116 // Version for unloaded classes:
117 ciInstanceKlass::ciInstanceKlass(ciSymbol* name,
118                                  jobject loader, jobject protection_domain)
119   : ciKlass(name, T_OBJECT)
120 {
121   assert(name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY, &quot;not an instance klass&quot;);
122   _init_state = (InstanceKlass::ClassState)0;
123   _nonstatic_field_size = -1;
124   _has_nonstatic_fields = false;
125   _nonstatic_fields = NULL;
126   _has_injected_fields = -1;
127   _is_unsafe_anonymous = false;
128   _is_hidden = false;
<span class="line-added">129   _is_record = false;</span>
130   _loader = loader;
131   _protection_domain = protection_domain;
132   _is_shared = false;
133   _super = NULL;
134   _java_mirror = NULL;
135   _field_cache = NULL;
136 }
137 
138 
139 
140 // ------------------------------------------------------------------
141 // ciInstanceKlass::compute_shared_is_initialized
142 void ciInstanceKlass::compute_shared_init_state() {
143   GUARDED_VM_ENTRY(
144     InstanceKlass* ik = get_instanceKlass();
145     _init_state = ik-&gt;init_state();
146   )
147 }
148 
149 // ------------------------------------------------------------------
</pre>
</td>
</tr>
</table>
<center><a href="ciField.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciInstanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
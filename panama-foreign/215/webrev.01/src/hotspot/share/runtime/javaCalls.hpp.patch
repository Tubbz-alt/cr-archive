diff a/src/hotspot/share/runtime/javaCalls.hpp b/src/hotspot/share/runtime/javaCalls.hpp
--- a/src/hotspot/share/runtime/javaCalls.hpp
+++ b/src/hotspot/share/runtime/javaCalls.hpp
@@ -86,21 +86,23 @@
   intptr_t*   _value;
   u_char*     _value_state;
   int         _size;
   int         _max_size;
   bool        _start_at_zero;      // Support late setting of receiver
-  JVMCI_ONLY(nmethod*    _alternative_target;) // Nmethod that should be called instead of normal target
+#if INCLUDE_JVMCI
+  Handle      _alternative_target; // HotSpotNmethod wrapping an nmethod whose verified entry point
+                                   // should be called instead of the normal target
+#endif
 
   void initialize() {
     // Starts at first element to support set_receiver.
     _value       = &_value_buffer[1];
     _value_state = &_value_state_buffer[1];
 
     _max_size = _default_size;
     _size = 0;
     _start_at_zero = false;
-    JVMCI_ONLY(_alternative_target = NULL;)
   }
 
   // Helper for push_oop and the like.  The value argument is a
   // "handle" that refers to an oop.  We record the address of the
   // handle rather than the designated oop.  The handle is later
@@ -136,22 +138,21 @@
       _value_state++;
 
       _max_size = max_size;
       _size = 0;
       _start_at_zero = false;
-      JVMCI_ONLY(_alternative_target = NULL;)
     } else {
       initialize();
     }
   }
 
 #if INCLUDE_JVMCI
-  void set_alternative_target(nmethod* target) {
+  void set_alternative_target(Handle target) {
     _alternative_target = target;
   }
 
-  nmethod* alternative_target() {
+  Handle alternative_target() {
     return _alternative_target;
   }
 #endif
 
   // The possible values for _value_state elements.

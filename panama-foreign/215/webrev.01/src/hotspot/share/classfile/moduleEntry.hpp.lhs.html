<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/moduleEntry.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_MODULEENTRY_HPP
 26 #define SHARE_CLASSFILE_MODULEENTRY_HPP
 27 
 28 #include &quot;jni.h&quot;
 29 #include &quot;classfile/classLoaderData.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;oops/oopHandle.hpp&quot;
 32 #include &quot;oops/symbol.hpp&quot;
 33 #include &quot;runtime/jniHandles.hpp&quot;
 34 #include &quot;runtime/mutexLocker.hpp&quot;
 35 #include &quot;utilities/growableArray.hpp&quot;
 36 #include &quot;utilities/hashtable.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
 38 #include &quot;utilities/ostream.hpp&quot;
 39 #if INCLUDE_JFR
 40 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
 41 #endif
 42 
 43 #define UNNAMED_MODULE &quot;unnamed module&quot;
 44 #define UNNAMED_MODULE_LEN 14
 45 #define JAVAPKG &quot;java&quot;
 46 #define JAVAPKG_LEN 4
 47 #define JAVA_BASE_NAME &quot;java.base&quot;
 48 #define JAVA_BASE_NAME_LEN 9
 49 
 50 class ModuleClosure;
 51 
 52 // A ModuleEntry describes a module that has been defined by a call to JVM_DefineModule.
 53 // It contains:
 54 //   - Symbol* containing the module&#39;s name.
 55 //   - pointer to the java.lang.Module for this module.
 56 //   - pointer to the java.security.ProtectionDomain shared by classes defined to this module.
 57 //   - ClassLoaderData*, class loader of this module.
 58 //   - a growable array containg other module entries that this module can read.
 59 //   - a flag indicating if this module can read all unnamed modules.
 60 //
 61 // The Mutex Module_lock is shared between ModuleEntry and PackageEntry, to lock either
 62 // data structure.
 63 class ModuleEntry : public HashtableEntry&lt;Symbol*, mtModule&gt; {
 64 private:
 65   OopHandle _module;                   // java.lang.Module
 66   OopHandle _pd;                       // java.security.ProtectionDomain, cached
 67                                        // for shared classes from this module
 68   ClassLoaderData* _loader_data;
 69   GrowableArray&lt;ModuleEntry*&gt;* _reads; // list of modules that are readable by this module
 70   Symbol* _version;                    // module version number
 71   Symbol* _location;                   // module location
<a name="1" id="anc1"></a>
 72   bool _can_read_all_unnamed;
 73   bool _has_default_read_edges;        // JVMTI redefine/retransform support
 74   bool _must_walk_reads;               // walk module&#39;s reads list at GC safepoints to purge out dead modules
 75   bool _is_open;                       // whether the packages in the module are all unqualifiedly exported
 76   bool _is_patched;                    // whether the module is patched via --patch-module
 77   JFR_ONLY(DEFINE_TRACE_ID_FIELD;)
 78   enum {MODULE_READS_SIZE = 101};      // Initial size of list of modules that the module can read.
 79 
 80 public:
 81   void init() {
 82     _module = OopHandle();
 83     _pd = OopHandle();
 84     _loader_data = NULL;
 85     _reads = NULL;
 86     _version = NULL;
 87     _location = NULL;
 88     _can_read_all_unnamed = false;
 89     _has_default_read_edges = false;
 90     _must_walk_reads = false;
 91     _is_patched = false;
 92     _is_open = false;
<a name="2" id="anc2"></a>
 93   }
 94 
 95   Symbol*          name() const                        { return literal(); }
 96   void             set_name(Symbol* n)                 { set_literal(n); }
 97 
 98   oop              module() const;
 99   OopHandle        module_handle() const               { return _module; }
100   void             set_module(OopHandle j)             { _module = j; }
101 
102   // The shared ProtectionDomain reference is set once the VM loads a shared class
103   // originated from the current Module. The referenced ProtectionDomain object is
104   // created by the ClassLoader when loading a class (shared or non-shared) from the
105   // Module for the first time. This ProtectionDomain object is used for all
106   // classes from the Module loaded by the same ClassLoader.
107   oop              shared_protection_domain();
108   void             set_shared_protection_domain(ClassLoaderData *loader_data, Handle pd);
109 
110   ClassLoaderData* loader_data() const                 { return _loader_data; }
111 
112   void set_loader_data(ClassLoaderData* cld) {
113     assert(!cld-&gt;has_class_mirror_holder(), &quot;Unexpected has_class_mirror_holder cld&quot;);
114     _loader_data = cld;
115   }
116 
117   Symbol*          version() const                     { return _version; }
118   void             set_version(Symbol* version);
119 
120   Symbol*          location() const                    { return _location; }
121   void             set_location(Symbol* location);
122   bool             should_show_version();
123 
124   bool             can_read(ModuleEntry* m) const;
125   bool             has_reads_list() const;
126   void             add_read(ModuleEntry* m);
127   void             set_read_walk_required(ClassLoaderData* m_loader_data);
128 
129   bool             is_open() const                     { return _is_open; }
130   void             set_is_open(bool is_open);
131 
132   bool             is_named() const                    { return (name() != NULL); }
133 
134   bool can_read_all_unnamed() const {
135     assert(is_named() || _can_read_all_unnamed == true,
136            &quot;unnamed modules can always read all unnamed modules&quot;);
137     return _can_read_all_unnamed;
138   }
139 
140   // Modules can only go from strict to loose.
141   void set_can_read_all_unnamed() { _can_read_all_unnamed = true; }
142 
143   bool has_default_read_edges() const {
144     return _has_default_read_edges;
145   }
146 
147   // Sets true and returns the previous value.
148   bool set_has_default_read_edges() {
149     MutexLocker ml(Module_lock);
150     bool prev = _has_default_read_edges;
151     _has_default_read_edges = true;
152     return prev;
153   }
154 
155   void set_is_patched() {
156       _is_patched = true;
<a name="3" id="anc3"></a>
157   }
158   bool is_patched() {
159       return _is_patched;
160   }
161 
162   ModuleEntry* next() const {
163     return (ModuleEntry*)HashtableEntry&lt;Symbol*, mtModule&gt;::next();
164   }
165   ModuleEntry** next_addr() {
166     return (ModuleEntry**)HashtableEntry&lt;Symbol*, mtModule&gt;::next_addr();
167   }
168 
169   // iteration support for readability
170   void module_reads_do(ModuleClosure* const f);
171 
172   // Purge dead weak references out of reads list when any given class loader is unloaded.
173   void purge_reads();
174   void delete_reads();
175 
176   // Special handling for unnamed module, one per class loader
177   static ModuleEntry* create_unnamed_module(ClassLoaderData* cld);
178   static ModuleEntry* create_boot_unnamed_module(ClassLoaderData* cld);
179   static ModuleEntry* new_unnamed_module_entry(Handle module_handle, ClassLoaderData* cld);
180   void delete_unnamed_module();
181 
182   void print(outputStream* st = tty);
183   void verify();
184 
<a name="4" id="anc4"></a>

185   JFR_ONLY(DEFINE_TRACE_ID_METHODS;)
186 };
187 
188 // Iterator interface
189 class ModuleClosure: public StackObj {
190  public:
191   virtual void do_module(ModuleEntry* module) = 0;
192 };
193 
194 
195 // The ModuleEntryTable is a Hashtable containing a list of all modules defined
196 // by a particular class loader.  Each module is represented as a ModuleEntry node.
197 //
198 // Each ModuleEntryTable contains a _javabase_module field which allows for the
199 // creation of java.base&#39;s ModuleEntry very early in bootstrapping before the
200 // corresponding JVM_DefineModule call for java.base occurs during module system
201 // initialization.  Setting up java.base&#39;s ModuleEntry early enables classes,
202 // loaded prior to the module system being initialized to be created with their
203 // PackageEntry node&#39;s correctly pointing at java.base&#39;s ModuleEntry.  No class
204 // outside of java.base is allowed to be loaded pre-module system initialization.
205 //
206 // The ModuleEntryTable&#39;s lookup is lock free.
207 //
208 class ModuleEntryTable : public Hashtable&lt;Symbol*, mtModule&gt; {
209   friend class VMStructs;
210 public:
211   enum Constants {
212     _moduletable_entry_size  = 109 // number of entries in module entry table
213   };
214 
215 private:
216   static ModuleEntry* _javabase_module;
217 
218   ModuleEntry* new_entry(unsigned int hash, Handle module_handle, bool is_open,
219                          Symbol* name, Symbol* version, Symbol* location, ClassLoaderData* loader_data);
220   void add_entry(int index, ModuleEntry* new_entry);
221 
222   int entry_size() const { return BasicHashtable&lt;mtModule&gt;::entry_size(); }
223 
224   ModuleEntry** bucket_addr(int i) {
225     return (ModuleEntry**)Hashtable&lt;Symbol*, mtModule&gt;::bucket_addr(i);
226   }
227 
228   static unsigned int compute_hash(Symbol* name) { return ((name == NULL) ? 0 : (unsigned int)(name-&gt;identity_hash())); }
229   int index_for(Symbol* name) const              { return hash_to_index(compute_hash(name)); }
230 
231 public:
232   ModuleEntryTable(int table_size);
233   ~ModuleEntryTable();
234 
235   ModuleEntry* bucket(int i) {
236     return (ModuleEntry*)Hashtable&lt;Symbol*, mtModule&gt;::bucket(i);
237   }
238 
239   // Create module in loader&#39;s module entry table.  Assume Module_lock
240   // has been locked by caller.
241   ModuleEntry* locked_create_entry(Handle module_handle,
242                                    bool is_open,
243                                    Symbol* module_name,
244                                    Symbol* module_version,
245                                    Symbol* module_location,
246                                    ClassLoaderData* loader_data);
247 
248   // Only lookup module within loader&#39;s module entry table.  The table read is lock-free.
249   ModuleEntry* lookup_only(Symbol* name);
250 
251   // purge dead weak references out of reads list
252   void purge_all_module_reads();
253 
254   // Special handling for java.base
255   static ModuleEntry* javabase_moduleEntry()                   { return _javabase_module; }
256   static void set_javabase_moduleEntry(ModuleEntry* java_base) {
257     assert(_javabase_module == NULL, &quot;_javabase_module is already defined&quot;);
258     _javabase_module = java_base;
259   }
260 
261   static bool javabase_defined() { return ((_javabase_module != NULL) &amp;&amp;
262                                            (_javabase_module-&gt;module() != NULL)); }
263   static void finalize_javabase(Handle module_handle, Symbol* version, Symbol* location);
264   static void patch_javabase_entries(Handle module_handle);
265 
266   void print(outputStream* st = tty);
267   void verify();
268 };
269 
270 #endif // SHARE_CLASSFILE_MODULEENTRY_HPP
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
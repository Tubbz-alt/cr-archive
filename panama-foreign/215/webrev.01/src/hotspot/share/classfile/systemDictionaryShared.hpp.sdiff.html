<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionaryShared.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionaryShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionaryShared.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
225   static bool is_hidden_lambda_proxy(InstanceKlass* ik);
226   static Handle init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS);
227   static InstanceKlass* find_builtin_class(Symbol* class_name);
228 
229   static const RunTimeSharedClassInfo* find_record(RunTimeSharedDictionary* static_dict,
230                                                    RunTimeSharedDictionary* dynamic_dict,
231                                                    Symbol* name);
232 
233   static bool has_platform_or_app_classes();
234 
235   // Called by PLATFORM/APP loader only
236   static InstanceKlass* find_or_load_shared_class(Symbol* class_name,
237                                                Handle class_loader,
238                                                TRAPS);
239 
240 
241   static void allocate_shared_data_arrays(int size, TRAPS);
242 
243   // Check if sharing is supported for the class loader.
244   static bool is_sharing_possible(ClassLoaderData* loader_data);
<span class="line-removed">245   static bool is_shared_class_visible_for_classloader(InstanceKlass* ik,</span>
<span class="line-removed">246                                                       Handle class_loader,</span>
<span class="line-removed">247                                                       Symbol* pkg_name,</span>
<span class="line-removed">248                                                       PackageEntry* pkg_entry,</span>
<span class="line-removed">249                                                       ModuleEntry* mod_entry,</span>
<span class="line-removed">250                                                       TRAPS);</span>
251 
252   static bool add_unregistered_class(InstanceKlass* k, TRAPS);
253   static InstanceKlass* dump_time_resolve_super_or_fail(Symbol* child_name,
254                                                 Symbol* class_name,
255                                                 Handle class_loader,
256                                                 Handle protection_domain,
257                                                 bool is_superclass,
258                                                 TRAPS);
259 
260   static void init_dumptime_info(InstanceKlass* k) NOT_CDS_RETURN;
261   static void remove_dumptime_info(InstanceKlass* k) NOT_CDS_RETURN;
262 
263   static Dictionary* boot_loader_dictionary() {
264     return ClassLoaderData::the_null_class_loader_data()-&gt;dictionary();
265   }
266 
267   static void update_shared_entry(InstanceKlass* klass, int id);
268   static void set_shared_class_misc_info(InstanceKlass* k, ClassFileStream* cfs);
269 
270   static InstanceKlass* lookup_from_stream(Symbol* class_name,
</pre>
</td>
<td>
<hr />
<pre>
225   static bool is_hidden_lambda_proxy(InstanceKlass* ik);
226   static Handle init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS);
227   static InstanceKlass* find_builtin_class(Symbol* class_name);
228 
229   static const RunTimeSharedClassInfo* find_record(RunTimeSharedDictionary* static_dict,
230                                                    RunTimeSharedDictionary* dynamic_dict,
231                                                    Symbol* name);
232 
233   static bool has_platform_or_app_classes();
234 
235   // Called by PLATFORM/APP loader only
236   static InstanceKlass* find_or_load_shared_class(Symbol* class_name,
237                                                Handle class_loader,
238                                                TRAPS);
239 
240 
241   static void allocate_shared_data_arrays(int size, TRAPS);
242 
243   // Check if sharing is supported for the class loader.
244   static bool is_sharing_possible(ClassLoaderData* loader_data);






245 
246   static bool add_unregistered_class(InstanceKlass* k, TRAPS);
247   static InstanceKlass* dump_time_resolve_super_or_fail(Symbol* child_name,
248                                                 Symbol* class_name,
249                                                 Handle class_loader,
250                                                 Handle protection_domain,
251                                                 bool is_superclass,
252                                                 TRAPS);
253 
254   static void init_dumptime_info(InstanceKlass* k) NOT_CDS_RETURN;
255   static void remove_dumptime_info(InstanceKlass* k) NOT_CDS_RETURN;
256 
257   static Dictionary* boot_loader_dictionary() {
258     return ClassLoaderData::the_null_class_loader_data()-&gt;dictionary();
259   }
260 
261   static void update_shared_entry(InstanceKlass* klass, int id);
262   static void set_shared_class_misc_info(InstanceKlass* k, ClassFileStream* cfs);
263 
264   static InstanceKlass* lookup_from_stream(Symbol* class_name,
</pre>
</td>
</tr>
</table>
<center><a href="systemDictionaryShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
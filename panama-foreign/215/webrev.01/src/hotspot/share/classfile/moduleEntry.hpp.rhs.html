<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/moduleEntry.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_MODULEENTRY_HPP
 26 #define SHARE_CLASSFILE_MODULEENTRY_HPP
 27 
 28 #include &quot;jni.h&quot;
 29 #include &quot;classfile/classLoaderData.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;oops/oopHandle.hpp&quot;
 32 #include &quot;oops/symbol.hpp&quot;
 33 #include &quot;runtime/jniHandles.hpp&quot;
 34 #include &quot;runtime/mutexLocker.hpp&quot;
 35 #include &quot;utilities/growableArray.hpp&quot;
 36 #include &quot;utilities/hashtable.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
 38 #include &quot;utilities/ostream.hpp&quot;
 39 #if INCLUDE_JFR
 40 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
 41 #endif
 42 
 43 #define UNNAMED_MODULE &quot;unnamed module&quot;
 44 #define UNNAMED_MODULE_LEN 14
 45 #define JAVAPKG &quot;java&quot;
 46 #define JAVAPKG_LEN 4
 47 #define JAVA_BASE_NAME &quot;java.base&quot;
 48 #define JAVA_BASE_NAME_LEN 9
 49 
 50 class ModuleClosure;
 51 
 52 // A ModuleEntry describes a module that has been defined by a call to JVM_DefineModule.
 53 // It contains:
 54 //   - Symbol* containing the module&#39;s name.
 55 //   - pointer to the java.lang.Module for this module.
 56 //   - pointer to the java.security.ProtectionDomain shared by classes defined to this module.
 57 //   - ClassLoaderData*, class loader of this module.
 58 //   - a growable array containg other module entries that this module can read.
 59 //   - a flag indicating if this module can read all unnamed modules.
 60 //
 61 // The Mutex Module_lock is shared between ModuleEntry and PackageEntry, to lock either
 62 // data structure.
 63 class ModuleEntry : public HashtableEntry&lt;Symbol*, mtModule&gt; {
 64 private:
 65   OopHandle _module;                   // java.lang.Module
 66   OopHandle _pd;                       // java.security.ProtectionDomain, cached
 67                                        // for shared classes from this module
 68   ClassLoaderData* _loader_data;
 69   GrowableArray&lt;ModuleEntry*&gt;* _reads; // list of modules that are readable by this module
 70   Symbol* _version;                    // module version number
 71   Symbol* _location;                   // module location
<a name="1" id="anc1"></a><span class="line-added"> 72   CDS_ONLY(int _shared_path_index;)    // &gt;=0 if classes in this module are in CDS archive</span>
 73   bool _can_read_all_unnamed;
 74   bool _has_default_read_edges;        // JVMTI redefine/retransform support
 75   bool _must_walk_reads;               // walk module&#39;s reads list at GC safepoints to purge out dead modules
 76   bool _is_open;                       // whether the packages in the module are all unqualifiedly exported
 77   bool _is_patched;                    // whether the module is patched via --patch-module
 78   JFR_ONLY(DEFINE_TRACE_ID_FIELD;)
 79   enum {MODULE_READS_SIZE = 101};      // Initial size of list of modules that the module can read.
 80 
 81 public:
 82   void init() {
 83     _module = OopHandle();
 84     _pd = OopHandle();
 85     _loader_data = NULL;
 86     _reads = NULL;
 87     _version = NULL;
 88     _location = NULL;
 89     _can_read_all_unnamed = false;
 90     _has_default_read_edges = false;
 91     _must_walk_reads = false;
 92     _is_patched = false;
 93     _is_open = false;
<a name="2" id="anc2"></a><span class="line-added"> 94     CDS_ONLY(_shared_path_index = -1);</span>
 95   }
 96 
 97   Symbol*          name() const                        { return literal(); }
 98   void             set_name(Symbol* n)                 { set_literal(n); }
 99 
100   oop              module() const;
101   OopHandle        module_handle() const               { return _module; }
102   void             set_module(OopHandle j)             { _module = j; }
103 
104   // The shared ProtectionDomain reference is set once the VM loads a shared class
105   // originated from the current Module. The referenced ProtectionDomain object is
106   // created by the ClassLoader when loading a class (shared or non-shared) from the
107   // Module for the first time. This ProtectionDomain object is used for all
108   // classes from the Module loaded by the same ClassLoader.
109   oop              shared_protection_domain();
110   void             set_shared_protection_domain(ClassLoaderData *loader_data, Handle pd);
111 
112   ClassLoaderData* loader_data() const                 { return _loader_data; }
113 
114   void set_loader_data(ClassLoaderData* cld) {
115     assert(!cld-&gt;has_class_mirror_holder(), &quot;Unexpected has_class_mirror_holder cld&quot;);
116     _loader_data = cld;
117   }
118 
119   Symbol*          version() const                     { return _version; }
120   void             set_version(Symbol* version);
121 
122   Symbol*          location() const                    { return _location; }
123   void             set_location(Symbol* location);
124   bool             should_show_version();
125 
126   bool             can_read(ModuleEntry* m) const;
127   bool             has_reads_list() const;
128   void             add_read(ModuleEntry* m);
129   void             set_read_walk_required(ClassLoaderData* m_loader_data);
130 
131   bool             is_open() const                     { return _is_open; }
132   void             set_is_open(bool is_open);
133 
134   bool             is_named() const                    { return (name() != NULL); }
135 
136   bool can_read_all_unnamed() const {
137     assert(is_named() || _can_read_all_unnamed == true,
138            &quot;unnamed modules can always read all unnamed modules&quot;);
139     return _can_read_all_unnamed;
140   }
141 
142   // Modules can only go from strict to loose.
143   void set_can_read_all_unnamed() { _can_read_all_unnamed = true; }
144 
145   bool has_default_read_edges() const {
146     return _has_default_read_edges;
147   }
148 
149   // Sets true and returns the previous value.
150   bool set_has_default_read_edges() {
151     MutexLocker ml(Module_lock);
152     bool prev = _has_default_read_edges;
153     _has_default_read_edges = true;
154     return prev;
155   }
156 
157   void set_is_patched() {
158       _is_patched = true;
<a name="3" id="anc3"></a><span class="line-added">159       CDS_ONLY(_shared_path_index = -1); // Mark all shared classes in this module invisible.</span>
160   }
161   bool is_patched() {
162       return _is_patched;
163   }
164 
165   ModuleEntry* next() const {
166     return (ModuleEntry*)HashtableEntry&lt;Symbol*, mtModule&gt;::next();
167   }
168   ModuleEntry** next_addr() {
169     return (ModuleEntry**)HashtableEntry&lt;Symbol*, mtModule&gt;::next_addr();
170   }
171 
172   // iteration support for readability
173   void module_reads_do(ModuleClosure* const f);
174 
175   // Purge dead weak references out of reads list when any given class loader is unloaded.
176   void purge_reads();
177   void delete_reads();
178 
179   // Special handling for unnamed module, one per class loader
180   static ModuleEntry* create_unnamed_module(ClassLoaderData* cld);
181   static ModuleEntry* create_boot_unnamed_module(ClassLoaderData* cld);
182   static ModuleEntry* new_unnamed_module_entry(Handle module_handle, ClassLoaderData* cld);
183   void delete_unnamed_module();
184 
185   void print(outputStream* st = tty);
186   void verify();
187 
<a name="4" id="anc4"></a><span class="line-added">188   CDS_ONLY(int shared_path_index() { return _shared_path_index;})</span>
<span class="line-added">189 </span>
190   JFR_ONLY(DEFINE_TRACE_ID_METHODS;)
191 };
192 
193 // Iterator interface
194 class ModuleClosure: public StackObj {
195  public:
196   virtual void do_module(ModuleEntry* module) = 0;
197 };
198 
199 
200 // The ModuleEntryTable is a Hashtable containing a list of all modules defined
201 // by a particular class loader.  Each module is represented as a ModuleEntry node.
202 //
203 // Each ModuleEntryTable contains a _javabase_module field which allows for the
204 // creation of java.base&#39;s ModuleEntry very early in bootstrapping before the
205 // corresponding JVM_DefineModule call for java.base occurs during module system
206 // initialization.  Setting up java.base&#39;s ModuleEntry early enables classes,
207 // loaded prior to the module system being initialized to be created with their
208 // PackageEntry node&#39;s correctly pointing at java.base&#39;s ModuleEntry.  No class
209 // outside of java.base is allowed to be loaded pre-module system initialization.
210 //
211 // The ModuleEntryTable&#39;s lookup is lock free.
212 //
213 class ModuleEntryTable : public Hashtable&lt;Symbol*, mtModule&gt; {
214   friend class VMStructs;
215 public:
216   enum Constants {
217     _moduletable_entry_size  = 109 // number of entries in module entry table
218   };
219 
220 private:
221   static ModuleEntry* _javabase_module;
222 
223   ModuleEntry* new_entry(unsigned int hash, Handle module_handle, bool is_open,
224                          Symbol* name, Symbol* version, Symbol* location, ClassLoaderData* loader_data);
225   void add_entry(int index, ModuleEntry* new_entry);
226 
227   int entry_size() const { return BasicHashtable&lt;mtModule&gt;::entry_size(); }
228 
229   ModuleEntry** bucket_addr(int i) {
230     return (ModuleEntry**)Hashtable&lt;Symbol*, mtModule&gt;::bucket_addr(i);
231   }
232 
233   static unsigned int compute_hash(Symbol* name) { return ((name == NULL) ? 0 : (unsigned int)(name-&gt;identity_hash())); }
234   int index_for(Symbol* name) const              { return hash_to_index(compute_hash(name)); }
235 
236 public:
237   ModuleEntryTable(int table_size);
238   ~ModuleEntryTable();
239 
240   ModuleEntry* bucket(int i) {
241     return (ModuleEntry*)Hashtable&lt;Symbol*, mtModule&gt;::bucket(i);
242   }
243 
244   // Create module in loader&#39;s module entry table.  Assume Module_lock
245   // has been locked by caller.
246   ModuleEntry* locked_create_entry(Handle module_handle,
247                                    bool is_open,
248                                    Symbol* module_name,
249                                    Symbol* module_version,
250                                    Symbol* module_location,
251                                    ClassLoaderData* loader_data);
252 
253   // Only lookup module within loader&#39;s module entry table.  The table read is lock-free.
254   ModuleEntry* lookup_only(Symbol* name);
255 
256   // purge dead weak references out of reads list
257   void purge_all_module_reads();
258 
259   // Special handling for java.base
260   static ModuleEntry* javabase_moduleEntry()                   { return _javabase_module; }
261   static void set_javabase_moduleEntry(ModuleEntry* java_base) {
262     assert(_javabase_module == NULL, &quot;_javabase_module is already defined&quot;);
263     _javabase_module = java_base;
264   }
265 
266   static bool javabase_defined() { return ((_javabase_module != NULL) &amp;&amp;
267                                            (_javabase_module-&gt;module() != NULL)); }
268   static void finalize_javabase(Handle module_handle, Symbol* version, Symbol* location);
269   static void patch_javabase_entries(Handle module_handle);
270 
271   void print(outputStream* st = tty);
272   void verify();
273 };
274 
275 #endif // SHARE_CLASSFILE_MODULEENTRY_HPP
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
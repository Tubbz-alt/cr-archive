<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionaryShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionaryShared.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionaryShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classFileStream.hpp&quot;
  27 #include &quot;classfile/classListParser.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  30 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  31 #include &quot;classfile/classLoaderExt.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;classfile/systemDictionary.hpp&quot;
  36 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  37 #include &quot;classfile/verificationType.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;

  39 #include &quot;jfr/jfrEvents.hpp&quot;
  40 #include &quot;logging/log.hpp&quot;
  41 #include &quot;memory/allocation.hpp&quot;
  42 #include &quot;memory/archiveUtils.hpp&quot;
  43 #include &quot;memory/dynamicArchive.hpp&quot;
  44 #include &quot;memory/filemap.hpp&quot;
  45 #include &quot;memory/heapShared.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/metaspaceClosure.hpp&quot;
  48 #include &quot;memory/oopFactory.hpp&quot;
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;memory/universe.hpp&quot;
  51 #include &quot;oops/instanceKlass.hpp&quot;
  52 #include &quot;oops/klass.inline.hpp&quot;
  53 #include &quot;oops/objArrayOop.inline.hpp&quot;
  54 #include &quot;oops/oop.inline.hpp&quot;
  55 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  56 #include &quot;runtime/handles.inline.hpp&quot;
  57 #include &quot;runtime/java.hpp&quot;
  58 #include &quot;runtime/javaCalls.hpp&quot;
</pre>
<hr />
<pre>
 868       //     define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));
 869       //
 870       //   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by
 871       //   the corresponding SystemDictionaryShared::get_shared_xxx() function.
 872       Handle manifest = get_shared_jar_manifest(index, CHECK_(pd));
 873       Handle url = get_shared_jar_url(index, CHECK_(pd));
 874       define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));
 875       pd = get_shared_protection_domain(class_loader, index, url, CHECK_(pd));
 876     }
 877   }
 878   return pd;
 879 }
 880 
 881 bool SystemDictionaryShared::is_sharing_possible(ClassLoaderData* loader_data) {
 882   oop class_loader = loader_data-&gt;class_loader();
 883   return (class_loader == NULL ||
 884           SystemDictionary::is_system_class_loader(class_loader) ||
 885           SystemDictionary::is_platform_class_loader(class_loader));
 886 }
 887 
<span class="line-removed"> 888 // Currently AppCDS only archives classes from the run-time image, the</span>
<span class="line-removed"> 889 // -Xbootclasspath/a path, the class path, and the module path.</span>
<span class="line-removed"> 890 //</span>
<span class="line-removed"> 891 // Check if a shared class can be loaded by the specific classloader. Following</span>
<span class="line-removed"> 892 // are the &quot;visible&quot; archived classes for different classloaders.</span>
<span class="line-removed"> 893 //</span>
<span class="line-removed"> 894 // NULL classloader:</span>
<span class="line-removed"> 895 //   - see SystemDictionary::is_shared_class_visible()</span>
<span class="line-removed"> 896 // Platform classloader:</span>
<span class="line-removed"> 897 //   - Module class from runtime image. ModuleEntry must be defined in the</span>
<span class="line-removed"> 898 //     classloader.</span>
<span class="line-removed"> 899 // App classloader:</span>
<span class="line-removed"> 900 //   - Module Class from runtime image and module path. ModuleEntry must be defined in the</span>
<span class="line-removed"> 901 //     classloader.</span>
<span class="line-removed"> 902 //   - Class from -cp. The class must have no PackageEntry defined in any of the</span>
<span class="line-removed"> 903 //     boot/platform/app classloader, or must be in the unnamed module defined in the</span>
<span class="line-removed"> 904 //     AppClassLoader.</span>
<span class="line-removed"> 905 bool SystemDictionaryShared::is_shared_class_visible_for_classloader(</span>
<span class="line-removed"> 906                                                      InstanceKlass* ik,</span>
<span class="line-removed"> 907                                                      Handle class_loader,</span>
<span class="line-removed"> 908                                                      Symbol* pkg_name,</span>
<span class="line-removed"> 909                                                      PackageEntry* pkg_entry,</span>
<span class="line-removed"> 910                                                      ModuleEntry* mod_entry,</span>
<span class="line-removed"> 911                                                      TRAPS) {</span>
<span class="line-removed"> 912   assert(class_loader.not_null(), &quot;Class loader should not be NULL&quot;);</span>
<span class="line-removed"> 913   assert(Universe::is_module_initialized(), &quot;Module system is not initialized&quot;);</span>
<span class="line-removed"> 914   ResourceMark rm(THREAD);</span>
<span class="line-removed"> 915 </span>
<span class="line-removed"> 916   int path_index = ik-&gt;shared_classpath_index();</span>
<span class="line-removed"> 917   SharedClassPathEntry* ent =</span>
<span class="line-removed"> 918             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);</span>
<span class="line-removed"> 919 </span>
<span class="line-removed"> 920   if (SystemDictionary::is_platform_class_loader(class_loader())) {</span>
<span class="line-removed"> 921     assert(ent != NULL, &quot;shared class for PlatformClassLoader should have valid SharedClassPathEntry&quot;);</span>
<span class="line-removed"> 922     // The PlatformClassLoader can only load archived class originated from the</span>
<span class="line-removed"> 923     // run-time image. The class&#39; PackageEntry/ModuleEntry must be</span>
<span class="line-removed"> 924     // defined by the PlatformClassLoader.</span>
<span class="line-removed"> 925     if (mod_entry != NULL) {</span>
<span class="line-removed"> 926       // PackageEntry/ModuleEntry is found in the classloader. Check if the</span>
<span class="line-removed"> 927       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.</span>
<span class="line-removed"> 928       if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {</span>
<span class="line-removed"> 929         return true; // Module class from the runtime image</span>
<span class="line-removed"> 930       }</span>
<span class="line-removed"> 931     }</span>
<span class="line-removed"> 932   } else if (SystemDictionary::is_system_class_loader(class_loader())) {</span>
<span class="line-removed"> 933     assert(ent != NULL, &quot;shared class for system loader should have valid SharedClassPathEntry&quot;);</span>
<span class="line-removed"> 934     if (pkg_name == NULL) {</span>
<span class="line-removed"> 935       // The archived class is in the unnamed package. Currently, the boot image</span>
<span class="line-removed"> 936       // does not contain any class in the unnamed package.</span>
<span class="line-removed"> 937       assert(!ent-&gt;is_modules_image(), &quot;Class in the unnamed package must be from the classpath&quot;);</span>
<span class="line-removed"> 938       if (path_index &gt;= ClassLoaderExt::app_class_paths_start_index()) {</span>
<span class="line-removed"> 939         assert(path_index &lt; ClassLoaderExt::app_module_paths_start_index(), &quot;invalid path_index&quot;);</span>
<span class="line-removed"> 940         return true;</span>
<span class="line-removed"> 941       }</span>
<span class="line-removed"> 942     } else {</span>
<span class="line-removed"> 943       // Check if this is from a PackageEntry/ModuleEntry defined in the AppClassloader.</span>
<span class="line-removed"> 944       if (pkg_entry == NULL) {</span>
<span class="line-removed"> 945         // It&#39;s not guaranteed that the class is from the classpath if the</span>
<span class="line-removed"> 946         // PackageEntry cannot be found from the AppClassloader. Need to check</span>
<span class="line-removed"> 947         // the boot and platform classloader as well.</span>
<span class="line-removed"> 948         ClassLoaderData* platform_loader_data =</span>
<span class="line-removed"> 949           ClassLoaderData::class_loader_data_or_null(SystemDictionary::java_platform_loader()); // can be NULL during bootstrap</span>
<span class="line-removed"> 950         if ((platform_loader_data == NULL ||</span>
<span class="line-removed"> 951              ClassLoader::get_package_entry(pkg_name, platform_loader_data) == NULL) &amp;&amp;</span>
<span class="line-removed"> 952              ClassLoader::get_package_entry(pkg_name, ClassLoaderData::the_null_class_loader_data()) == NULL) {</span>
<span class="line-removed"> 953           // The PackageEntry is not defined in any of the boot/platform/app classloaders.</span>
<span class="line-removed"> 954           // The archived class must from -cp path and not from the runtime image.</span>
<span class="line-removed"> 955           if (!ent-&gt;is_modules_image() &amp;&amp; path_index &gt;= ClassLoaderExt::app_class_paths_start_index() &amp;&amp;</span>
<span class="line-removed"> 956                                           path_index &lt; ClassLoaderExt::app_module_paths_start_index()) {</span>
<span class="line-removed"> 957             return true;</span>
<span class="line-removed"> 958           }</span>
<span class="line-removed"> 959         }</span>
<span class="line-removed"> 960       } else if (mod_entry != NULL) {</span>
<span class="line-removed"> 961         // The package/module is defined in the AppClassLoader. We support</span>
<span class="line-removed"> 962         // archiving application module class from the runtime image or from</span>
<span class="line-removed"> 963         // a named module from a module path.</span>
<span class="line-removed"> 964         // Packages from the -cp path are in the unnamed_module.</span>
<span class="line-removed"> 965         if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {</span>
<span class="line-removed"> 966           // shared module class from runtime image</span>
<span class="line-removed"> 967           return true;</span>
<span class="line-removed"> 968         } else if (pkg_entry-&gt;in_unnamed_module() &amp;&amp; path_index &gt;= ClassLoaderExt::app_class_paths_start_index() &amp;&amp;</span>
<span class="line-removed"> 969             path_index &lt; ClassLoaderExt::app_module_paths_start_index()) {</span>
<span class="line-removed"> 970           // shared class from -cp</span>
<span class="line-removed"> 971           DEBUG_ONLY( \</span>
<span class="line-removed"> 972             ClassLoaderData* loader_data = class_loader_data(class_loader); \</span>
<span class="line-removed"> 973             assert(mod_entry == loader_data-&gt;unnamed_module(), &quot;the unnamed module is not defined in the classloader&quot;);)</span>
<span class="line-removed"> 974           return true;</span>
<span class="line-removed"> 975         } else {</span>
<span class="line-removed"> 976           if(!pkg_entry-&gt;in_unnamed_module() &amp;&amp;</span>
<span class="line-removed"> 977               (path_index &gt;= ClassLoaderExt::app_module_paths_start_index())&amp;&amp;</span>
<span class="line-removed"> 978               (path_index &lt; FileMapInfo::get_number_of_shared_paths()) &amp;&amp;</span>
<span class="line-removed"> 979               (strcmp(ent-&gt;name(), ClassLoader::skip_uri_protocol(mod_entry-&gt;location()-&gt;as_C_string())) == 0)) {</span>
<span class="line-removed"> 980             // shared module class from module path</span>
<span class="line-removed"> 981             return true;</span>
<span class="line-removed"> 982           } else {</span>
<span class="line-removed"> 983             assert(path_index &lt; FileMapInfo::get_number_of_shared_paths(), &quot;invalid path_index&quot;);</span>
<span class="line-removed"> 984           }</span>
<span class="line-removed"> 985         }</span>
<span class="line-removed"> 986       }</span>
<span class="line-removed"> 987     }</span>
<span class="line-removed"> 988   } else {</span>
<span class="line-removed"> 989     // TEMP: if a shared class can be found by a custom loader, consider it visible now.</span>
<span class="line-removed"> 990     // FIXME: is this actually correct?</span>
<span class="line-removed"> 991     return true;</span>
<span class="line-removed"> 992   }</span>
<span class="line-removed"> 993   return false;</span>
<span class="line-removed"> 994 }</span>
<span class="line-removed"> 995 </span>
 996 bool SystemDictionaryShared::has_platform_or_app_classes() {
 997   if (FileMapInfo::current_info()-&gt;has_platform_or_app_classes()) {
 998     return true;
 999   }
1000   if (DynamicArchive::is_mapped() &amp;&amp;
1001       FileMapInfo::dynamic_info()-&gt;has_platform_or_app_classes()) {
1002     return true;
1003   }
1004   return false;
1005 }
1006 
1007 // The following stack shows how this code is reached:
1008 //
1009 //   [0] SystemDictionaryShared::find_or_load_shared_class()
1010 //   [1] JVM_FindLoadedClass
1011 //   [2] java.lang.ClassLoader.findLoadedClass0()
1012 //   [3] java.lang.ClassLoader.findLoadedClass()
1013 //   [4] jdk.internal.loader.BuiltinClassLoader.loadClassOrNull()
1014 //   [5] jdk.internal.loader.BuiltinClassLoader.loadClass()
1015 //   [6] jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(), or
1016 //       jdk.internal.loader.ClassLoaders$PlatformClassLoader.loadClass()
1017 //
1018 // AppCDS supports fast class loading for these 2 built-in class loaders:
1019 //    jdk.internal.loader.ClassLoaders$PlatformClassLoader
1020 //    jdk.internal.loader.ClassLoaders$AppClassLoader
1021 // with the following assumptions (based on the JDK core library source code):
1022 //
1023 // [a] these two loaders use the BuiltinClassLoader.loadClassOrNull() to
1024 //     load the named class.
1025 // [b] BuiltinClassLoader.loadClassOrNull() first calls findLoadedClass(name).
1026 // [c] At this point, if we can find the named class inside the
1027 //     shared_dictionary, we can perform further checks (see
<span class="line-modified">1028 //     is_shared_class_visible_for_classloader() to ensure that this class</span>
1029 //     was loaded by the same class loader during dump time.
1030 //
1031 // Given these assumptions, we intercept the findLoadedClass() call to invoke
1032 // SystemDictionaryShared::find_or_load_shared_class() to load the shared class from
1033 // the archive for the 2 built-in class loaders. This way,
1034 // we can improve start-up because we avoid decoding the classfile,
1035 // and avoid delegating to the parent loader.
1036 //
1037 // NOTE: there&#39;s a lot of assumption about the Java code. If any of that change, this
1038 // needs to be redesigned.
1039 
1040 InstanceKlass* SystemDictionaryShared::find_or_load_shared_class(
1041                  Symbol* name, Handle class_loader, TRAPS) {
1042   InstanceKlass* k = NULL;
1043   if (UseSharedSpaces) {
1044     if (!has_platform_or_app_classes()) {
1045       return NULL;
1046     }
1047 
1048     if (SystemDictionary::is_system_class_loader(class_loader()) ||
</pre>
<hr />
<pre>
1101   InstanceKlass* ik = find_builtin_class(class_name);
1102 
1103   if (ik != NULL) {
1104     if ((ik-&gt;is_shared_app_class() &amp;&amp;
1105          SystemDictionary::is_system_class_loader(class_loader()))  ||
1106         (ik-&gt;is_shared_platform_class() &amp;&amp;
1107          SystemDictionary::is_platform_class_loader(class_loader()))) {
1108       PackageEntry* pkg_entry = get_package_entry_from_class_name(class_loader, class_name);
1109       Handle protection_domain =
1110         SystemDictionaryShared::init_security_info(class_loader, ik, pkg_entry, CHECK_NULL);
1111       return load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, THREAD);
1112     }
1113   }
1114   return NULL;
1115 }
1116 
1117 void SystemDictionaryShared::allocate_shared_protection_domain_array(int size, TRAPS) {
1118   if (_shared_protection_domains.resolve() == NULL) {
1119     oop spd = oopFactory::new_objArray(
1120         SystemDictionary::ProtectionDomain_klass(), size, CHECK);
<span class="line-modified">1121     _shared_protection_domains = OopHandle::create(spd);</span>
1122   }
1123 }
1124 
1125 void SystemDictionaryShared::allocate_shared_jar_url_array(int size, TRAPS) {
1126   if (_shared_jar_urls.resolve() == NULL) {
1127     oop sju = oopFactory::new_objArray(
1128         SystemDictionary::URL_klass(), size, CHECK);
<span class="line-modified">1129     _shared_jar_urls = OopHandle::create(sju);</span>
1130   }
1131 }
1132 
1133 void SystemDictionaryShared::allocate_shared_jar_manifest_array(int size, TRAPS) {
1134   if (_shared_jar_manifests.resolve() == NULL) {
1135     oop sjm = oopFactory::new_objArray(
1136         SystemDictionary::Jar_Manifest_klass(), size, CHECK);
<span class="line-modified">1137     _shared_jar_manifests = OopHandle::create(sjm);</span>
1138   }
1139 }
1140 
1141 void SystemDictionaryShared::allocate_shared_data_arrays(int size, TRAPS) {
1142   allocate_shared_protection_domain_array(size, CHECK);
1143   allocate_shared_jar_url_array(size, CHECK);
1144   allocate_shared_jar_manifest_array(size, CHECK);
1145 }
1146 
1147 // This function is called for loading only UNREGISTERED classes
1148 InstanceKlass* SystemDictionaryShared::lookup_from_stream(Symbol* class_name,
1149                                                           Handle class_loader,
1150                                                           Handle protection_domain,
1151                                                           const ClassFileStream* cfs,
1152                                                           TRAPS) {
1153   if (!UseSharedSpaces) {
1154     return NULL;
1155   }
1156   if (class_name == NULL) {  // don&#39;t do this for hidden and unsafe anonymous classes
1157     return NULL;
</pre>
</td>
<td>
<hr />
<pre>
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classFileStream.hpp&quot;
  27 #include &quot;classfile/classListParser.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  30 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  31 #include &quot;classfile/classLoaderExt.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;classfile/systemDictionary.hpp&quot;
  36 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  37 #include &quot;classfile/verificationType.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
<span class="line-added">  39 #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
  40 #include &quot;jfr/jfrEvents.hpp&quot;
  41 #include &quot;logging/log.hpp&quot;
  42 #include &quot;memory/allocation.hpp&quot;
  43 #include &quot;memory/archiveUtils.hpp&quot;
  44 #include &quot;memory/dynamicArchive.hpp&quot;
  45 #include &quot;memory/filemap.hpp&quot;
  46 #include &quot;memory/heapShared.hpp&quot;
  47 #include &quot;memory/metadataFactory.hpp&quot;
  48 #include &quot;memory/metaspaceClosure.hpp&quot;
  49 #include &quot;memory/oopFactory.hpp&quot;
  50 #include &quot;memory/resourceArea.hpp&quot;
  51 #include &quot;memory/universe.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/klass.inline.hpp&quot;
  54 #include &quot;oops/objArrayOop.inline.hpp&quot;
  55 #include &quot;oops/oop.inline.hpp&quot;
  56 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  57 #include &quot;runtime/handles.inline.hpp&quot;
  58 #include &quot;runtime/java.hpp&quot;
  59 #include &quot;runtime/javaCalls.hpp&quot;
</pre>
<hr />
<pre>
 869       //     define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));
 870       //
 871       //   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by
 872       //   the corresponding SystemDictionaryShared::get_shared_xxx() function.
 873       Handle manifest = get_shared_jar_manifest(index, CHECK_(pd));
 874       Handle url = get_shared_jar_url(index, CHECK_(pd));
 875       define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));
 876       pd = get_shared_protection_domain(class_loader, index, url, CHECK_(pd));
 877     }
 878   }
 879   return pd;
 880 }
 881 
 882 bool SystemDictionaryShared::is_sharing_possible(ClassLoaderData* loader_data) {
 883   oop class_loader = loader_data-&gt;class_loader();
 884   return (class_loader == NULL ||
 885           SystemDictionary::is_system_class_loader(class_loader) ||
 886           SystemDictionary::is_platform_class_loader(class_loader));
 887 }
 888 












































































































 889 bool SystemDictionaryShared::has_platform_or_app_classes() {
 890   if (FileMapInfo::current_info()-&gt;has_platform_or_app_classes()) {
 891     return true;
 892   }
 893   if (DynamicArchive::is_mapped() &amp;&amp;
 894       FileMapInfo::dynamic_info()-&gt;has_platform_or_app_classes()) {
 895     return true;
 896   }
 897   return false;
 898 }
 899 
 900 // The following stack shows how this code is reached:
 901 //
 902 //   [0] SystemDictionaryShared::find_or_load_shared_class()
 903 //   [1] JVM_FindLoadedClass
 904 //   [2] java.lang.ClassLoader.findLoadedClass0()
 905 //   [3] java.lang.ClassLoader.findLoadedClass()
 906 //   [4] jdk.internal.loader.BuiltinClassLoader.loadClassOrNull()
 907 //   [5] jdk.internal.loader.BuiltinClassLoader.loadClass()
 908 //   [6] jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(), or
 909 //       jdk.internal.loader.ClassLoaders$PlatformClassLoader.loadClass()
 910 //
 911 // AppCDS supports fast class loading for these 2 built-in class loaders:
 912 //    jdk.internal.loader.ClassLoaders$PlatformClassLoader
 913 //    jdk.internal.loader.ClassLoaders$AppClassLoader
 914 // with the following assumptions (based on the JDK core library source code):
 915 //
 916 // [a] these two loaders use the BuiltinClassLoader.loadClassOrNull() to
 917 //     load the named class.
 918 // [b] BuiltinClassLoader.loadClassOrNull() first calls findLoadedClass(name).
 919 // [c] At this point, if we can find the named class inside the
 920 //     shared_dictionary, we can perform further checks (see
<span class="line-modified"> 921 //     SystemDictionary::is_shared_class_visible) to ensure that this class</span>
 922 //     was loaded by the same class loader during dump time.
 923 //
 924 // Given these assumptions, we intercept the findLoadedClass() call to invoke
 925 // SystemDictionaryShared::find_or_load_shared_class() to load the shared class from
 926 // the archive for the 2 built-in class loaders. This way,
 927 // we can improve start-up because we avoid decoding the classfile,
 928 // and avoid delegating to the parent loader.
 929 //
 930 // NOTE: there&#39;s a lot of assumption about the Java code. If any of that change, this
 931 // needs to be redesigned.
 932 
 933 InstanceKlass* SystemDictionaryShared::find_or_load_shared_class(
 934                  Symbol* name, Handle class_loader, TRAPS) {
 935   InstanceKlass* k = NULL;
 936   if (UseSharedSpaces) {
 937     if (!has_platform_or_app_classes()) {
 938       return NULL;
 939     }
 940 
 941     if (SystemDictionary::is_system_class_loader(class_loader()) ||
</pre>
<hr />
<pre>
 994   InstanceKlass* ik = find_builtin_class(class_name);
 995 
 996   if (ik != NULL) {
 997     if ((ik-&gt;is_shared_app_class() &amp;&amp;
 998          SystemDictionary::is_system_class_loader(class_loader()))  ||
 999         (ik-&gt;is_shared_platform_class() &amp;&amp;
1000          SystemDictionary::is_platform_class_loader(class_loader()))) {
1001       PackageEntry* pkg_entry = get_package_entry_from_class_name(class_loader, class_name);
1002       Handle protection_domain =
1003         SystemDictionaryShared::init_security_info(class_loader, ik, pkg_entry, CHECK_NULL);
1004       return load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, THREAD);
1005     }
1006   }
1007   return NULL;
1008 }
1009 
1010 void SystemDictionaryShared::allocate_shared_protection_domain_array(int size, TRAPS) {
1011   if (_shared_protection_domains.resolve() == NULL) {
1012     oop spd = oopFactory::new_objArray(
1013         SystemDictionary::ProtectionDomain_klass(), size, CHECK);
<span class="line-modified">1014     _shared_protection_domains = OopHandle(OopStorageSet::vm_global(), spd);</span>
1015   }
1016 }
1017 
1018 void SystemDictionaryShared::allocate_shared_jar_url_array(int size, TRAPS) {
1019   if (_shared_jar_urls.resolve() == NULL) {
1020     oop sju = oopFactory::new_objArray(
1021         SystemDictionary::URL_klass(), size, CHECK);
<span class="line-modified">1022     _shared_jar_urls = OopHandle(OopStorageSet::vm_global(), sju);</span>
1023   }
1024 }
1025 
1026 void SystemDictionaryShared::allocate_shared_jar_manifest_array(int size, TRAPS) {
1027   if (_shared_jar_manifests.resolve() == NULL) {
1028     oop sjm = oopFactory::new_objArray(
1029         SystemDictionary::Jar_Manifest_klass(), size, CHECK);
<span class="line-modified">1030     _shared_jar_manifests = OopHandle(OopStorageSet::vm_global(), sjm);</span>
1031   }
1032 }
1033 
1034 void SystemDictionaryShared::allocate_shared_data_arrays(int size, TRAPS) {
1035   allocate_shared_protection_domain_array(size, CHECK);
1036   allocate_shared_jar_url_array(size, CHECK);
1037   allocate_shared_jar_manifest_array(size, CHECK);
1038 }
1039 
1040 // This function is called for loading only UNREGISTERED classes
1041 InstanceKlass* SystemDictionaryShared::lookup_from_stream(Symbol* class_name,
1042                                                           Handle class_loader,
1043                                                           Handle protection_domain,
1044                                                           const ClassFileStream* cfs,
1045                                                           TRAPS) {
1046   if (!UseSharedSpaces) {
1047     return NULL;
1048   }
1049   if (class_name == NULL) {  // don&#39;t do this for hidden and unsafe anonymous classes
1050     return NULL;
</pre>
</td>
</tr>
</table>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionaryShared.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
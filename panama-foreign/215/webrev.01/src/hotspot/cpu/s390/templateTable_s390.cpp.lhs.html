<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/templateTable_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
<a name="1" id="anc1"></a><span class="line-modified">   3  * Copyright (c) 2016, 2018 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/interpreter.hpp&quot;
  30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  31 #include &quot;interpreter/interp_masm.hpp&quot;
  32 #include &quot;interpreter/templateTable.hpp&quot;
  33 #include &quot;memory/universe.hpp&quot;
<a name="2" id="anc2"></a>
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;prims/methodHandles.hpp&quot;
  37 #include &quot;runtime/frame.inline.hpp&quot;
  38 #include &quot;runtime/safepointMechanism.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/stubRoutines.hpp&quot;
  41 #include &quot;runtime/synchronizer.hpp&quot;
  42 #include &quot;utilities/powerOfTwo.hpp&quot;
  43 
  44 #ifdef PRODUCT
  45 #define __ _masm-&gt;
  46 #define BLOCK_COMMENT(str)
  47 #define BIND(label)        __ bind(label);
  48 #else
  49 #define __ (PRODUCT_ONLY(false&amp;&amp;)Verbose ? (_masm-&gt;block_comment(FILE_AND_LINE),_masm):_masm)-&gt;
  50 #define BLOCK_COMMENT(str) __ block_comment(str)
  51 #define BIND(label)        __ bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  52 #endif
  53 
  54 // The assumed minimum size of a BranchTableBlock.
  55 // The actual size of each block heavily depends on the CPU capabilities and,
  56 // of course, on the logic implemented in each block.
  57 #ifdef ASSERT
  58   #define BTB_MINSIZE 256
  59 #else
  60   #define BTB_MINSIZE  64
  61 #endif
  62 
  63 #ifdef ASSERT
  64 // Macro to open a BranchTableBlock (a piece of code that is branched to by a calculated branch).
  65 #define BTB_BEGIN(lbl, alignment, name)                                        \
  66   __ align_address(alignment);                                                 \
  67   __ bind(lbl);                                                                \
  68   { unsigned int b_off = __ offset();                                          \
  69     uintptr_t   b_addr = (uintptr_t)__ pc();                                   \
  70     __ z_larl(Z_R0, (int64_t)0);     /* Check current address alignment. */    \
  71     __ z_slgr(Z_R0, br_tab);         /* Current Address must be equal    */    \
  72     __ z_slgr(Z_R0, flags);          /* to calculated branch target.     */    \
  73     __ z_brc(Assembler::bcondLogZero, 3); /* skip trap if ok. */               \
  74     __ z_illtrap(0x55);                                                        \
  75     guarantee(b_addr%alignment == 0, &quot;bad alignment at begin of block&quot; name);
  76 
  77 // Macro to close a BranchTableBlock (a piece of code that is branched to by a calculated branch).
  78 #define BTB_END(lbl, alignment, name)                                          \
  79     uintptr_t   e_addr = (uintptr_t)__ pc();                                   \
  80     unsigned int e_off = __ offset();                                          \
  81     unsigned int len   = e_off-b_off;                                          \
  82     if (len &gt; alignment) {                                                     \
  83       tty-&gt;print_cr(&quot;%4d of %4d @ &quot; INTPTR_FORMAT &quot;: Block len for %s&quot;,        \
  84                     len, alignment, e_addr-len, name);                         \
  85       guarantee(len &lt;= alignment, &quot;block too large&quot;);                          \
  86     }                                                                          \
  87     guarantee(len == e_addr-b_addr, &quot;block len mismatch&quot;);                     \
  88   }
  89 #else
  90 // Macro to open a BranchTableBlock (a piece of code that is branched to by a calculated branch).
  91 #define BTB_BEGIN(lbl, alignment, name)                                        \
  92   __ align_address(alignment);                                                 \
  93   __ bind(lbl);                                                                \
  94   { unsigned int b_off = __ offset();                                          \
  95     uintptr_t   b_addr = (uintptr_t)__ pc();                                   \
  96     guarantee(b_addr%alignment == 0, &quot;bad alignment at begin of block&quot; name);
  97 
  98 // Macro to close a BranchTableBlock (a piece of code that is branched to by a calculated branch).
  99 #define BTB_END(lbl, alignment, name)                                          \
 100     uintptr_t   e_addr = (uintptr_t)__ pc();                                   \
 101     unsigned int e_off = __ offset();                                          \
 102     unsigned int len   = e_off-b_off;                                          \
 103     if (len &gt; alignment) {                                                     \
 104       tty-&gt;print_cr(&quot;%4d of %4d @ &quot; INTPTR_FORMAT &quot;: Block len for %s&quot;,        \
 105                     len, alignment, e_addr-len, name);                         \
 106       guarantee(len &lt;= alignment, &quot;block too large&quot;);                          \
 107     }                                                                          \
 108     guarantee(len == e_addr-b_addr, &quot;block len mismatch&quot;);                     \
 109   }
 110 #endif // ASSERT
 111 
 112 // Platform-dependent initialization.
 113 
 114 void TemplateTable::pd_initialize() {
 115   // No specific initialization.
 116 }
 117 
 118 // Address computation: local variables
 119 
 120 static inline Address iaddress(int n) {
 121   return Address(Z_locals, Interpreter::local_offset_in_bytes(n));
 122 }
 123 
 124 static inline Address laddress(int n) {
 125   return iaddress(n + 1);
 126 }
 127 
 128 static inline Address faddress(int n) {
 129   return iaddress(n);
 130 }
 131 
 132 static inline Address daddress(int n) {
 133   return laddress(n);
 134 }
 135 
 136 static inline Address aaddress(int n) {
 137   return iaddress(n);
 138 }
 139 
 140 // Pass NULL, if no shift instruction should be emitted.
 141 static inline Address iaddress(InterpreterMacroAssembler *masm, Register r) {
 142   if (masm) {
 143     masm-&gt;z_sllg(r, r, LogBytesPerWord);  // index2bytes
 144   }
 145   return Address(Z_locals, r, Interpreter::local_offset_in_bytes(0));
 146 }
 147 
 148 // Pass NULL, if no shift instruction should be emitted.
 149 static inline Address laddress(InterpreterMacroAssembler *masm, Register r) {
 150   if (masm) {
 151     masm-&gt;z_sllg(r, r, LogBytesPerWord);  // index2bytes
 152   }
 153   return Address(Z_locals, r, Interpreter::local_offset_in_bytes(1) );
 154 }
 155 
 156 static inline Address faddress(InterpreterMacroAssembler *masm, Register r) {
 157   return iaddress(masm, r);
 158 }
 159 
 160 static inline Address daddress(InterpreterMacroAssembler *masm, Register r) {
 161   return laddress(masm, r);
 162 }
 163 
 164 static inline Address aaddress(InterpreterMacroAssembler *masm, Register r) {
 165   return iaddress(masm, r);
 166 }
 167 
 168 // At top of Java expression stack which may be different than esp(). It
 169 // isn&#39;t for category 1 objects.
 170 static inline Address at_tos(int slot = 0) {
 171   return Address(Z_esp, Interpreter::expr_offset_in_bytes(slot));
 172 }
 173 
 174 // Condition conversion
 175 static Assembler::branch_condition j_not(TemplateTable::Condition cc) {
 176   switch (cc) {
 177     case TemplateTable::equal :
 178       return Assembler::bcondNotEqual;
 179     case TemplateTable::not_equal :
 180       return Assembler::bcondEqual;
 181     case TemplateTable::less :
 182       return Assembler::bcondNotLow;
 183     case TemplateTable::less_equal :
 184       return Assembler::bcondHigh;
 185     case TemplateTable::greater :
 186       return Assembler::bcondNotHigh;
 187     case TemplateTable::greater_equal:
 188       return Assembler::bcondLow;
 189   }
 190   ShouldNotReachHere();
 191   return Assembler::bcondZero;
 192 }
 193 
 194 // Do an oop store like *(base + offset) = val
 195 // offset can be a register or a constant.
 196 static void do_oop_store(InterpreterMacroAssembler* _masm,
 197                          const Address&amp;     addr,
 198                          Register           val,         // Noreg means always null.
 199                          Register           tmp1,
 200                          Register           tmp2,
 201                          Register           tmp3,
 202                          DecoratorSet       decorators) {
 203   assert_different_registers(tmp1, tmp2, tmp3, val, addr.base());
 204   __ store_heap_oop(val, addr, tmp1, tmp2, tmp3, decorators);
 205 }
 206 
 207 static void do_oop_load(InterpreterMacroAssembler* _masm,
 208                         const Address&amp; addr,
 209                         Register dst,
 210                         Register tmp1,
 211                         Register tmp2,
 212                         DecoratorSet decorators) {
 213   assert_different_registers(addr.base(), tmp1, tmp2);
 214   assert_different_registers(dst, tmp1, tmp2);
 215   __ load_heap_oop(dst, addr, tmp1, tmp2, decorators);
 216 }
 217 
 218 Address TemplateTable::at_bcp(int offset) {
 219   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 220   return Address(Z_bcp, offset);
 221 }
 222 
 223 void TemplateTable::patch_bytecode(Bytecodes::Code bc,
 224                                    Register        bc_reg,
 225                                    Register        temp_reg,
 226                                    bool            load_bc_into_bc_reg, // = true
 227                                    int             byte_no) {
 228   if (!RewriteBytecodes) { return; }
 229 
 230   NearLabel L_patch_done;
 231   BLOCK_COMMENT(&quot;patch_bytecode {&quot;);
 232 
 233   switch (bc) {
 234     case Bytecodes::_fast_aputfield:
 235     case Bytecodes::_fast_bputfield:
 236     case Bytecodes::_fast_zputfield:
 237     case Bytecodes::_fast_cputfield:
 238     case Bytecodes::_fast_dputfield:
 239     case Bytecodes::_fast_fputfield:
 240     case Bytecodes::_fast_iputfield:
 241     case Bytecodes::_fast_lputfield:
 242     case Bytecodes::_fast_sputfield:
 243       {
 244         // We skip bytecode quickening for putfield instructions when
 245         // the put_code written to the constant pool cache is zero.
 246         // This is required so that every execution of this instruction
 247         // calls out to InterpreterRuntime::resolve_get_put to do
 248         // additional, required work.
 249         assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 250         assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 251         __ get_cache_and_index_and_bytecode_at_bcp(Z_R1_scratch, bc_reg,
 252                                                    temp_reg, byte_no, 1);
 253         __ load_const_optimized(bc_reg, bc);
 254         __ compareU32_and_branch(temp_reg, (intptr_t)0,
 255                                  Assembler::bcondZero, L_patch_done);
 256       }
 257       break;
 258     default:
 259       assert(byte_no == -1, &quot;sanity&quot;);
 260       // The pair bytecodes have already done the load.
 261       if (load_bc_into_bc_reg) {
 262         __ load_const_optimized(bc_reg, bc);
 263       }
 264       break;
 265   }
 266 
 267   if (JvmtiExport::can_post_breakpoint()) {
 268 
 269     Label   L_fast_patch;
 270 
 271     // If a breakpoint is present we can&#39;t rewrite the stream directly.
 272     __ z_cli(at_bcp(0), Bytecodes::_breakpoint);
 273     __ z_brne(L_fast_patch);
 274     __ get_method(temp_reg);
 275     // Let breakpoint table handling rewrite to quicker bytecode.
 276     __ call_VM_static(noreg,
 277                       CAST_FROM_FN_PTR(address, InterpreterRuntime::set_original_bytecode_at),
 278                       temp_reg, Z_R13, bc_reg);
 279     __ z_bru(L_patch_done);
 280 
 281     __ bind(L_fast_patch);
 282   }
 283 
 284 #ifdef ASSERT
 285   NearLabel   L_okay;
 286 
 287   // We load into 64 bits, since this works on any CPU.
 288   __ z_llgc(temp_reg, at_bcp(0));
 289   __ compareU32_and_branch(temp_reg, Bytecodes::java_code(bc),
 290                             Assembler::bcondEqual, L_okay        );
 291   __ compareU32_and_branch(temp_reg, bc_reg, Assembler::bcondEqual, L_okay);
 292   __ stop_static(&quot;patching the wrong bytecode&quot;);
 293   __ bind(L_okay);
 294 #endif
 295 
 296   // Patch bytecode.
 297   __ z_stc(bc_reg, at_bcp(0));
 298 
 299   __ bind(L_patch_done);
 300   BLOCK_COMMENT(&quot;} patch_bytecode&quot;);
 301 }
 302 
 303 // Individual instructions
 304 
 305 void TemplateTable::nop() {
 306   transition(vtos, vtos);
 307 }
 308 
 309 void TemplateTable::shouldnotreachhere() {
 310   transition(vtos, vtos);
 311   __ stop(&quot;shouldnotreachhere bytecode&quot;);
 312 }
 313 
 314 void TemplateTable::aconst_null() {
 315   transition(vtos, atos);
 316   __ clear_reg(Z_tos, true, false);
 317 }
 318 
 319 void TemplateTable::iconst(int value) {
 320   transition(vtos, itos);
 321   // Zero extension of the iconst makes zero extension at runtime obsolete.
 322   __ load_const_optimized(Z_tos, ((unsigned long)(unsigned int)value));
 323 }
 324 
 325 void TemplateTable::lconst(int value) {
 326   transition(vtos, ltos);
 327   __ load_const_optimized(Z_tos, value);
 328 }
 329 
 330 // No pc-relative load/store for floats.
 331 void TemplateTable::fconst(int value) {
 332   transition(vtos, ftos);
 333   static float   one = 1.0f, two = 2.0f;
 334 
 335   switch (value) {
 336     case 0:
 337       __ z_lzer(Z_ftos);
 338       return;
 339     case 1:
 340       __ load_absolute_address(Z_R1_scratch, (address) &amp;one);
 341       __ mem2freg_opt(Z_ftos, Address(Z_R1_scratch), false);
 342       return;
 343     case 2:
 344       __ load_absolute_address(Z_R1_scratch, (address) &amp;two);
 345       __ mem2freg_opt(Z_ftos, Address(Z_R1_scratch), false);
 346       return;
 347     default:
 348       ShouldNotReachHere();
 349       return;
 350   }
 351 }
 352 
 353 void TemplateTable::dconst(int value) {
 354   transition(vtos, dtos);
 355   static double one = 1.0;
 356 
 357   switch (value) {
 358     case 0:
 359       __ z_lzdr(Z_ftos);
 360       return;
 361     case 1:
 362       __ load_absolute_address(Z_R1_scratch, (address) &amp;one);
 363       __ mem2freg_opt(Z_ftos, Address(Z_R1_scratch));
 364       return;
 365     default:
 366       ShouldNotReachHere();
 367       return;
 368   }
 369 }
 370 
 371 void TemplateTable::bipush() {
 372   transition(vtos, itos);
 373   __ z_lb(Z_tos, at_bcp(1));
 374 }
 375 
 376 void TemplateTable::sipush() {
 377   transition(vtos, itos);
 378   __ get_2_byte_integer_at_bcp(Z_tos, 1, InterpreterMacroAssembler::Signed);
 379 }
 380 
 381 
 382 void TemplateTable::ldc(bool wide) {
 383   transition(vtos, vtos);
 384   Label call_ldc, notFloat, notClass, notInt, Done;
 385   const Register RcpIndex = Z_tmp_1;
 386   const Register Rtags = Z_ARG2;
 387 
 388   if (wide) {
 389     __ get_2_byte_integer_at_bcp(RcpIndex, 1, InterpreterMacroAssembler::Unsigned);
 390   } else {
 391     __ z_llgc(RcpIndex, at_bcp(1));
 392   }
 393 
 394   __ get_cpool_and_tags(Z_tmp_2, Rtags);
 395 
 396   const int      base_offset = ConstantPool::header_size() * wordSize;
 397   const int      tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 398   const Register Raddr_type = Rtags;
 399 
 400   // Get address of type.
 401   __ add2reg_with_index(Raddr_type, tags_offset, RcpIndex, Rtags);
 402 
 403   __ z_cli(0, Raddr_type, JVM_CONSTANT_UnresolvedClass);
 404   __ z_bre(call_ldc);    // Unresolved class - get the resolved class.
 405 
 406   __ z_cli(0, Raddr_type, JVM_CONSTANT_UnresolvedClassInError);
 407   __ z_bre(call_ldc);    // Unresolved class in error state - call into runtime
 408                          // to throw the error from the first resolution attempt.
 409 
 410   __ z_cli(0, Raddr_type, JVM_CONSTANT_Class);
 411   __ z_brne(notClass);   // Resolved class - need to call vm to get java
 412                          // mirror of the class.
 413 
 414   // We deal with a class. Call vm to do the appropriate.
 415   __ bind(call_ldc);
 416   __ load_const_optimized(Z_ARG2, wide);
 417   call_VM(Z_RET, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), Z_ARG2);
 418   __ push_ptr(Z_RET);
 419   __ z_bru(Done);
 420 
 421   // Not a class.
 422   __ bind(notClass);
 423   Register RcpOffset = RcpIndex;
 424   __ z_sllg(RcpOffset, RcpIndex, LogBytesPerWord); // Convert index to offset.
 425   __ z_cli(0, Raddr_type, JVM_CONSTANT_Float);
 426   __ z_brne(notFloat);
 427 
 428   // ftos
 429   __ mem2freg_opt(Z_ftos, Address(Z_tmp_2, RcpOffset, base_offset), false);
 430   __ push_f();
 431   __ z_bru(Done);
 432 
 433   __ bind(notFloat);
 434   __ z_cli(0, Raddr_type, JVM_CONSTANT_Integer);
 435   __ z_brne(notInt);
 436 
 437   // itos
 438   __ mem2reg_opt(Z_tos, Address(Z_tmp_2, RcpOffset, base_offset), false);
 439   __ push_i(Z_tos);
 440   __ z_bru(Done);
 441 
 442   // assume the tag is for condy; if not, the VM runtime will tell us
 443   __ bind(notInt);
 444   condy_helper(Done);
 445 
 446   __ bind(Done);
 447 }
 448 
 449 // Fast path for caching oop constants.
 450 // %%% We should use this to handle Class and String constants also.
 451 // %%% It will simplify the ldc/primitive path considerably.
 452 void TemplateTable::fast_aldc(bool wide) {
 453   transition(vtos, atos);
 454 
 455   const Register index = Z_tmp_2;
 456   int            index_size = wide ? sizeof(u2) : sizeof(u1);
 457   Label          L_do_resolve, L_resolved;
 458 
 459   // We are resolved if the resolved reference cache entry contains a
 460   // non-null object (CallSite, etc.).
 461   __ get_cache_index_at_bcp(index, 1, index_size);  // Load index.
 462   __ load_resolved_reference_at_index(Z_tos, index);
 463   __ z_ltgr(Z_tos, Z_tos);
 464   __ z_bre(L_do_resolve);
 465 
 466   // Convert null sentinel to NULL.
 467   __ load_const_optimized(Z_R1_scratch, (intptr_t)Universe::the_null_sentinel_addr());
 468   __ z_cg(Z_tos, Address(Z_R1_scratch));
 469   __ z_brne(L_resolved);
 470   __ clear_reg(Z_tos);
 471   __ z_bru(L_resolved);
 472 
 473   __ bind(L_do_resolve);
 474   // First time invocation - must resolve first.
 475   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 476   __ load_const_optimized(Z_ARG1, (int)bytecode());
 477   __ call_VM(Z_tos, entry, Z_ARG1);
 478 
 479   __ bind(L_resolved);
 480   __ verify_oop(Z_tos);
 481 }
 482 
 483 void TemplateTable::ldc2_w() {
 484   transition(vtos, vtos);
 485   Label notDouble, notLong, Done;
 486 
 487   // Z_tmp_1 = index of cp entry
 488   __ get_2_byte_integer_at_bcp(Z_tmp_1, 1, InterpreterMacroAssembler::Unsigned);
 489 
 490   __ get_cpool_and_tags(Z_tmp_2, Z_tos);
 491 
 492   const int base_offset = ConstantPool::header_size() * wordSize;
 493   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 494 
 495   // Get address of type.
 496   __ add2reg_with_index(Z_tos, tags_offset, Z_tos, Z_tmp_1);
 497 
 498   // Index needed in both branches, so calculate here.
 499   __ z_sllg(Z_tmp_1, Z_tmp_1, LogBytesPerWord);  // index2bytes
 500 
 501   // Check type.
 502   __ z_cli(0, Z_tos, JVM_CONSTANT_Double);
 503   __ z_brne(notDouble);
 504   // dtos
 505   __ mem2freg_opt(Z_ftos, Address(Z_tmp_2, Z_tmp_1, base_offset));
 506   __ push_d();
 507   __ z_bru(Done);
 508 
 509   __ bind(notDouble);
 510   __ z_cli(0, Z_tos, JVM_CONSTANT_Long);
 511   __ z_brne(notLong);
 512   // ltos
 513   __ mem2reg_opt(Z_tos, Address(Z_tmp_2, Z_tmp_1, base_offset));
 514   __ push_l();
 515   __ z_bru(Done);
 516 
 517   __ bind(notLong);
 518   condy_helper(Done);
 519 
 520   __ bind(Done);
 521 }
 522 
 523 void TemplateTable::condy_helper(Label&amp; Done) {
 524   const Register obj   = Z_tmp_1;
 525   const Register off   = Z_tmp_2;
 526   const Register flags = Z_ARG1;
 527   const Register rarg  = Z_ARG2;
 528   __ load_const_optimized(rarg, (int)bytecode());
 529   call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc), rarg);
 530   __ get_vm_result_2(flags);
 531 
 532   // VMr = obj = base address to find primitive value to push
 533   // VMr2 = flags = (tos, off) using format of CPCE::_flags
 534   assert(ConstantPoolCacheEntry::field_index_mask == 0xffff, &quot;or use other instructions&quot;);
 535   __ z_llghr(off, flags);
 536   const Address field(obj, off);
 537 
 538   // What sort of thing are we loading?
 539   __ z_srl(flags, ConstantPoolCacheEntry::tos_state_shift);
 540   // Make sure we don&#39;t need to mask flags for tos_state after the above shift.
 541   ConstantPoolCacheEntry::verify_tos_state_shift();
 542 
 543   switch (bytecode()) {
 544   case Bytecodes::_ldc:
 545   case Bytecodes::_ldc_w:
 546     {
 547       // tos in (itos, ftos, stos, btos, ctos, ztos)
 548       Label notInt, notFloat, notShort, notByte, notChar, notBool;
 549       __ z_cghi(flags, itos);
 550       __ z_brne(notInt);
 551       // itos
 552       __ z_l(Z_tos, field);
 553       __ push(itos);
 554       __ z_bru(Done);
 555 
 556       __ bind(notInt);
 557       __ z_cghi(flags, ftos);
 558       __ z_brne(notFloat);
 559       // ftos
 560       __ z_le(Z_ftos, field);
 561       __ push(ftos);
 562       __ z_bru(Done);
 563 
 564       __ bind(notFloat);
 565       __ z_cghi(flags, stos);
 566       __ z_brne(notShort);
 567       // stos
 568       __ z_lh(Z_tos, field);
 569       __ push(stos);
 570       __ z_bru(Done);
 571 
 572       __ bind(notShort);
 573       __ z_cghi(flags, btos);
 574       __ z_brne(notByte);
 575       // btos
 576       __ z_lb(Z_tos, field);
 577       __ push(btos);
 578       __ z_bru(Done);
 579 
 580       __ bind(notByte);
 581       __ z_cghi(flags, ctos);
 582       __ z_brne(notChar);
 583       // ctos
 584       __ z_llh(Z_tos, field);
 585       __ push(ctos);
 586       __ z_bru(Done);
 587 
 588       __ bind(notChar);
 589       __ z_cghi(flags, ztos);
 590       __ z_brne(notBool);
 591       // ztos
 592       __ z_lb(Z_tos, field);
 593       __ push(ztos);
 594       __ z_bru(Done);
 595 
 596       __ bind(notBool);
 597       break;
 598     }
 599 
 600   case Bytecodes::_ldc2_w:
 601     {
 602       Label notLong, notDouble;
 603       __ z_cghi(flags, ltos);
 604       __ z_brne(notLong);
 605       // ltos
 606       __ z_lg(Z_tos, field);
 607       __ push(ltos);
 608       __ z_bru(Done);
 609 
 610       __ bind(notLong);
 611       __ z_cghi(flags, dtos);
 612       __ z_brne(notDouble);
 613       // dtos
 614       __ z_ld(Z_ftos, field);
 615       __ push(dtos);
 616       __ z_bru(Done);
 617 
 618       __ bind(notDouble);
 619       break;
 620     }
 621 
 622   default:
 623     ShouldNotReachHere();
 624   }
 625 
 626   __ stop(&quot;bad ldc/condy&quot;);
 627 }
 628 
 629 void TemplateTable::locals_index(Register reg, int offset) {
 630   __ z_llgc(reg, at_bcp(offset));
 631   __ z_lcgr(reg);
 632 }
 633 
 634 void TemplateTable::iload() {
 635   iload_internal();
 636 }
 637 
 638 void TemplateTable::nofast_iload() {
 639   iload_internal(may_not_rewrite);
 640 }
 641 
 642 void TemplateTable::iload_internal(RewriteControl rc) {
 643   transition(vtos, itos);
 644 
 645   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 646     NearLabel rewrite, done;
 647     const Register bc = Z_ARG4;
 648 
 649     assert(Z_R1_scratch != bc, &quot;register damaged&quot;);
 650 
 651     // Get next byte.
 652     __ z_llgc(Z_R1_scratch, at_bcp(Bytecodes::length_for (Bytecodes::_iload)));
 653 
 654     // If _iload, wait to rewrite to iload2. We only want to rewrite the
 655     // last two iloads in a pair. Comparing against fast_iload means that
 656     // the next bytecode is neither an iload or a caload, and therefore
 657     // an iload pair.
 658     __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_iload,
 659                              Assembler::bcondEqual, done);
 660 
 661     __ load_const_optimized(bc, Bytecodes::_fast_iload2);
 662     __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_fast_iload,
 663                              Assembler::bcondEqual, rewrite);
 664 
 665     // If _caload, rewrite to fast_icaload.
 666     __ load_const_optimized(bc, Bytecodes::_fast_icaload);
 667     __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_caload,
 668                              Assembler::bcondEqual, rewrite);
 669 
 670     // Rewrite so iload doesn&#39;t check again.
 671     __ load_const_optimized(bc, Bytecodes::_fast_iload);
 672 
 673     // rewrite
 674     // bc: fast bytecode
 675     __ bind(rewrite);
 676     patch_bytecode(Bytecodes::_iload, bc, Z_R1_scratch, false);
 677 
 678     __ bind(done);
 679 
 680   }
 681 
 682   // Get the local value into tos.
 683   locals_index(Z_R1_scratch);
 684   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
 685 }
 686 
 687 void TemplateTable::fast_iload2() {
 688   transition(vtos, itos);
 689 
 690   locals_index(Z_R1_scratch);
 691   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
 692   __ push_i(Z_tos);
 693   locals_index(Z_R1_scratch, 3);
 694   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
 695 }
 696 
 697 void TemplateTable::fast_iload() {
 698   transition(vtos, itos);
 699 
 700   locals_index(Z_R1_scratch);
 701   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
 702 }
 703 
 704 void TemplateTable::lload() {
 705   transition(vtos, ltos);
 706 
 707   locals_index(Z_R1_scratch);
 708   __ mem2reg_opt(Z_tos, laddress(_masm, Z_R1_scratch));
 709 }
 710 
 711 void TemplateTable::fload() {
 712   transition(vtos, ftos);
 713 
 714   locals_index(Z_R1_scratch);
 715   __ mem2freg_opt(Z_ftos, faddress(_masm, Z_R1_scratch), false);
 716 }
 717 
 718 void TemplateTable::dload() {
 719   transition(vtos, dtos);
 720 
 721   locals_index(Z_R1_scratch);
 722   __ mem2freg_opt(Z_ftos, daddress(_masm, Z_R1_scratch));
 723 }
 724 
 725 void TemplateTable::aload() {
 726   transition(vtos, atos);
 727 
 728   locals_index(Z_R1_scratch);
 729   __ mem2reg_opt(Z_tos, aaddress(_masm, Z_R1_scratch));
 730 }
 731 
 732 void TemplateTable::locals_index_wide(Register reg) {
 733   __ get_2_byte_integer_at_bcp(reg, 2, InterpreterMacroAssembler::Unsigned);
 734   __ z_lcgr(reg);
 735 }
 736 
 737 void TemplateTable::wide_iload() {
 738   transition(vtos, itos);
 739 
 740   locals_index_wide(Z_tmp_1);
 741   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_tmp_1), false);
 742 }
 743 
 744 void TemplateTable::wide_lload() {
 745   transition(vtos, ltos);
 746 
 747   locals_index_wide(Z_tmp_1);
 748   __ mem2reg_opt(Z_tos, laddress(_masm, Z_tmp_1));
 749 }
 750 
 751 void TemplateTable::wide_fload() {
 752   transition(vtos, ftos);
 753 
 754   locals_index_wide(Z_tmp_1);
 755   __ mem2freg_opt(Z_ftos, faddress(_masm, Z_tmp_1), false);
 756 }
 757 
 758 void TemplateTable::wide_dload() {
 759   transition(vtos, dtos);
 760 
 761   locals_index_wide(Z_tmp_1);
 762   __ mem2freg_opt(Z_ftos, daddress(_masm, Z_tmp_1));
 763 }
 764 
 765 void TemplateTable::wide_aload() {
 766   transition(vtos, atos);
 767 
 768   locals_index_wide(Z_tmp_1);
 769   __ mem2reg_opt(Z_tos, aaddress(_masm, Z_tmp_1));
 770 }
 771 
 772 void TemplateTable::index_check(Register array, Register index, unsigned int shift) {
 773   assert_different_registers(Z_R1_scratch, array, index);
 774 
 775   // Check array.
 776   __ null_check(array, Z_R0_scratch, arrayOopDesc::length_offset_in_bytes());
 777 
 778   // Sign extend index for use by indexed load.
 779   __ z_lgfr(index, index);
 780 
 781   // Check index.
 782   Label index_ok;
 783   __ z_cl(index, Address(array, arrayOopDesc::length_offset_in_bytes()));
 784   __ z_brl(index_ok);
 785   __ lgr_if_needed(Z_ARG3, index); // See generate_ArrayIndexOutOfBounds_handler().
 786   // Pass the array to create more detailed exceptions.
 787   __ lgr_if_needed(Z_ARG2, array); // See generate_ArrayIndexOutOfBounds_handler().
 788   __ load_absolute_address(Z_R1_scratch,
 789                            Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);
 790   __ z_bcr(Assembler::bcondAlways, Z_R1_scratch);
 791   __ bind(index_ok);
 792 
 793   if (shift &gt; 0)
 794     __ z_sllg(index, index, shift);
 795 }
 796 
 797 void TemplateTable::iaload() {
 798   transition(itos, itos);
 799 
 800   __ pop_ptr(Z_tmp_1);  // array
 801   // Index is in Z_tos.
 802   Register index = Z_tos;
 803   index_check(Z_tmp_1, index, LogBytesPerInt); // Kills Z_ARG3.
 804   // Load the value.
 805   __ mem2reg_opt(Z_tos,
 806                  Address(Z_tmp_1, index, arrayOopDesc::base_offset_in_bytes(T_INT)),
 807                  false);
 808 }
 809 
 810 void TemplateTable::laload() {
 811   transition(itos, ltos);
 812 
 813   __ pop_ptr(Z_tmp_2);
 814   // Z_tos   : index
 815   // Z_tmp_2 : array
 816   Register index = Z_tos;
 817   index_check(Z_tmp_2, index, LogBytesPerLong);
 818   __ mem2reg_opt(Z_tos,
 819                  Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_LONG)));
 820 }
 821 
 822 void TemplateTable::faload() {
 823   transition(itos, ftos);
 824 
 825   __ pop_ptr(Z_tmp_2);
 826   // Z_tos   : index
 827   // Z_tmp_2 : array
 828   Register index = Z_tos;
 829   index_check(Z_tmp_2, index, LogBytesPerInt);
 830   __ mem2freg_opt(Z_ftos,
 831                   Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
 832                   false);
 833 }
 834 
 835 void TemplateTable::daload() {
 836   transition(itos, dtos);
 837 
 838   __ pop_ptr(Z_tmp_2);
 839   // Z_tos   : index
 840   // Z_tmp_2 : array
 841   Register index = Z_tos;
 842   index_check(Z_tmp_2, index, LogBytesPerLong);
 843   __ mem2freg_opt(Z_ftos,
 844                   Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_DOUBLE)));
 845 }
 846 
 847 void TemplateTable::aaload() {
 848   transition(itos, atos);
 849 
 850   unsigned const int shift = LogBytesPerHeapOop;
 851   __ pop_ptr(Z_tmp_1);  // array
 852   // Index is in Z_tos.
 853   Register index = Z_tos;
 854   index_check(Z_tmp_1, index, shift);
 855   // Now load array element.
 856   do_oop_load(_masm, Address(Z_tmp_1, index, arrayOopDesc::base_offset_in_bytes(T_OBJECT)), Z_tos,
 857               Z_tmp_2, Z_tmp_3, IS_ARRAY);
 858   __ verify_oop(Z_tos);
 859 }
 860 
 861 void TemplateTable::baload() {
 862   transition(itos, itos);
 863 
 864   __ pop_ptr(Z_tmp_1);
 865   // Z_tos   : index
 866   // Z_tmp_1 : array
 867   Register index = Z_tos;
 868   index_check(Z_tmp_1, index, 0);
 869   __ z_lb(Z_tos,
 870           Address(Z_tmp_1, index, arrayOopDesc::base_offset_in_bytes(T_BYTE)));
 871 }
 872 
 873 void TemplateTable::caload() {
 874   transition(itos, itos);
 875 
 876   __ pop_ptr(Z_tmp_2);
 877   // Z_tos   : index
 878   // Z_tmp_2 : array
 879   Register index = Z_tos;
 880   index_check(Z_tmp_2, index, LogBytesPerShort);
 881   // Load into 64 bits, works on all CPUs.
 882   __ z_llgh(Z_tos,
 883             Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_CHAR)));
 884 }
 885 
 886 // Iload followed by caload frequent pair.
 887 void TemplateTable::fast_icaload() {
 888   transition(vtos, itos);
 889 
 890   // Load index out of locals.
 891   locals_index(Z_R1_scratch);
 892   __ mem2reg_opt(Z_ARG3, iaddress(_masm, Z_R1_scratch), false);
 893   // Z_ARG3  : index
 894   // Z_tmp_2 : array
 895   __ pop_ptr(Z_tmp_2);
 896   index_check(Z_tmp_2, Z_ARG3, LogBytesPerShort);
 897   // Load into 64 bits, works on all CPUs.
 898   __ z_llgh(Z_tos,
 899             Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_CHAR)));
 900 }
 901 
 902 void TemplateTable::saload() {
 903   transition(itos, itos);
 904 
 905   __ pop_ptr(Z_tmp_2);
 906   // Z_tos   : index
 907   // Z_tmp_2 : array
 908   Register index = Z_tos;
 909   index_check(Z_tmp_2, index, LogBytesPerShort);
 910   __ z_lh(Z_tos,
 911           Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_SHORT)));
 912 }
 913 
 914 void TemplateTable::iload(int n) {
 915   transition(vtos, itos);
 916   __ z_ly(Z_tos, iaddress(n));
 917 }
 918 
 919 void TemplateTable::lload(int n) {
 920   transition(vtos, ltos);
 921   __ z_lg(Z_tos, laddress(n));
 922 }
 923 
 924 void TemplateTable::fload(int n) {
 925   transition(vtos, ftos);
 926   __ mem2freg_opt(Z_ftos, faddress(n), false);
 927 }
 928 
 929 void TemplateTable::dload(int n) {
 930   transition(vtos, dtos);
 931   __ mem2freg_opt(Z_ftos, daddress(n));
 932 }
 933 
 934 void TemplateTable::aload(int n) {
 935   transition(vtos, atos);
 936   __ mem2reg_opt(Z_tos, aaddress(n));
 937 }
 938 
 939 void TemplateTable::aload_0() {
 940   aload_0_internal();
 941 }
 942 
 943 void TemplateTable::nofast_aload_0() {
 944   aload_0_internal(may_not_rewrite);
 945 }
 946 
 947 void TemplateTable::aload_0_internal(RewriteControl rc) {
 948   transition(vtos, atos);
 949 
 950   // According to bytecode histograms, the pairs:
 951   //
 952   // _aload_0, _fast_igetfield
 953   // _aload_0, _fast_agetfield
 954   // _aload_0, _fast_fgetfield
 955   //
 956   // occur frequently. If RewriteFrequentPairs is set, the (slow)
 957   // _aload_0 bytecode checks if the next bytecode is either
 958   // _fast_igetfield, _fast_agetfield or _fast_fgetfield and then
 959   // rewrites the current bytecode into a pair bytecode; otherwise it
 960   // rewrites the current bytecode into _fast_aload_0 that doesn&#39;t do
 961   // the pair check anymore.
 962   //
 963   // Note: If the next bytecode is _getfield, the rewrite must be
 964   //       delayed, otherwise we may miss an opportunity for a pair.
 965   //
 966   // Also rewrite frequent pairs
 967   //   aload_0, aload_1
 968   //   aload_0, iload_1
 969   // These bytecodes with a small amount of code are most profitable
 970   // to rewrite.
 971   if (!(RewriteFrequentPairs &amp;&amp; (rc == may_rewrite))) {
 972     aload(0);
 973     return;
 974   }
 975 
 976   NearLabel rewrite, done;
 977   const Register bc = Z_ARG4;
 978 
 979   assert(Z_R1_scratch != bc, &quot;register damaged&quot;);
 980   // Get next byte.
 981   __ z_llgc(Z_R1_scratch, at_bcp(Bytecodes::length_for (Bytecodes::_aload_0)));
 982 
 983   // Do actual aload_0.
 984   aload(0);
 985 
 986   // If _getfield then wait with rewrite.
 987   __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_getfield,
 988                            Assembler::bcondEqual, done);
 989 
 990   // If _igetfield then rewrite to _fast_iaccess_0.
 991   assert(Bytecodes::java_code(Bytecodes::_fast_iaccess_0)
 992             == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 993 
 994   __ load_const_optimized(bc, Bytecodes::_fast_iaccess_0);
 995   __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_fast_igetfield,
 996                            Assembler::bcondEqual, rewrite);
 997 
 998   // If _agetfield then rewrite to _fast_aaccess_0.
 999   assert(Bytecodes::java_code(Bytecodes::_fast_aaccess_0)
1000             == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1001 
1002   __ load_const_optimized(bc, Bytecodes::_fast_aaccess_0);
1003   __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_fast_agetfield,
1004                            Assembler::bcondEqual, rewrite);
1005 
1006   // If _fgetfield then rewrite to _fast_faccess_0.
1007   assert(Bytecodes::java_code(Bytecodes::_fast_faccess_0)
1008             == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1009 
1010   __ load_const_optimized(bc, Bytecodes::_fast_faccess_0);
1011   __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_fast_fgetfield,
1012                            Assembler::bcondEqual, rewrite);
1013 
1014   // Else rewrite to _fast_aload0.
1015   assert(Bytecodes::java_code(Bytecodes::_fast_aload_0)
1016             == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1017   __ load_const_optimized(bc, Bytecodes::_fast_aload_0);
1018 
1019   // rewrite
1020   // bc: fast bytecode
1021   __ bind(rewrite);
1022 
1023   patch_bytecode(Bytecodes::_aload_0, bc, Z_R1_scratch, false);
1024   // Reload local 0 because of VM call inside patch_bytecode().
1025   // this may trigger GC and thus change the oop.
1026   aload(0);
1027 
1028   __ bind(done);
1029 }
1030 
1031 void TemplateTable::istore() {
1032   transition(itos, vtos);
1033   locals_index(Z_R1_scratch);
1034   __ reg2mem_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
1035 }
1036 
1037 void TemplateTable::lstore() {
1038   transition(ltos, vtos);
1039   locals_index(Z_R1_scratch);
1040   __ reg2mem_opt(Z_tos, laddress(_masm, Z_R1_scratch));
1041 }
1042 
1043 void TemplateTable::fstore() {
1044   transition(ftos, vtos);
1045   locals_index(Z_R1_scratch);
1046   __ freg2mem_opt(Z_ftos, faddress(_masm, Z_R1_scratch));
1047 }
1048 
1049 void TemplateTable::dstore() {
1050   transition(dtos, vtos);
1051   locals_index(Z_R1_scratch);
1052   __ freg2mem_opt(Z_ftos, daddress(_masm, Z_R1_scratch));
1053 }
1054 
1055 void TemplateTable::astore() {
1056   transition(vtos, vtos);
1057   __ pop_ptr(Z_tos);
1058   locals_index(Z_R1_scratch);
1059   __ reg2mem_opt(Z_tos, aaddress(_masm, Z_R1_scratch));
1060 }
1061 
1062 void TemplateTable::wide_istore() {
1063   transition(vtos, vtos);
1064   __ pop_i(Z_tos);
1065   locals_index_wide(Z_tmp_1);
1066   __ reg2mem_opt(Z_tos, iaddress(_masm, Z_tmp_1), false);
1067 }
1068 
1069 void TemplateTable::wide_lstore() {
1070   transition(vtos, vtos);
1071   __ pop_l(Z_tos);
1072   locals_index_wide(Z_tmp_1);
1073   __ reg2mem_opt(Z_tos, laddress(_masm, Z_tmp_1));
1074 }
1075 
1076 void TemplateTable::wide_fstore() {
1077   transition(vtos, vtos);
1078   __ pop_f(Z_ftos);
1079   locals_index_wide(Z_tmp_1);
1080   __ freg2mem_opt(Z_ftos, faddress(_masm, Z_tmp_1), false);
1081 }
1082 
1083 void TemplateTable::wide_dstore() {
1084   transition(vtos, vtos);
1085   __ pop_d(Z_ftos);
1086   locals_index_wide(Z_tmp_1);
1087   __ freg2mem_opt(Z_ftos, daddress(_masm, Z_tmp_1));
1088 }
1089 
1090 void TemplateTable::wide_astore() {
1091   transition(vtos, vtos);
1092   __ pop_ptr(Z_tos);
1093   locals_index_wide(Z_tmp_1);
1094   __ reg2mem_opt(Z_tos, aaddress(_masm, Z_tmp_1));
1095 }
1096 
1097 void TemplateTable::iastore() {
1098   transition(itos, vtos);
1099 
1100   Register index = Z_ARG3; // Index_check expects index in Z_ARG3.
1101   // Value is in Z_tos ...
1102   __ pop_i(index);        // index
1103   __ pop_ptr(Z_tmp_1);    // array
1104   index_check(Z_tmp_1, index, LogBytesPerInt);
1105   // ... and then move the value.
1106   __ reg2mem_opt(Z_tos,
1107                  Address(Z_tmp_1, index, arrayOopDesc::base_offset_in_bytes(T_INT)),
1108                  false);
1109 }
1110 
1111 void TemplateTable::lastore() {
1112   transition(ltos, vtos);
1113 
1114   __ pop_i(Z_ARG3);
1115   __ pop_ptr(Z_tmp_2);
1116   // Z_tos   : value
1117   // Z_ARG3  : index
1118   // Z_tmp_2 : array
1119  index_check(Z_tmp_2, Z_ARG3, LogBytesPerLong); // Prefer index in Z_ARG3.
1120   __ reg2mem_opt(Z_tos,
1121                  Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_LONG)));
1122 }
1123 
1124 void TemplateTable::fastore() {
1125   transition(ftos, vtos);
1126 
1127   __ pop_i(Z_ARG3);
1128   __ pop_ptr(Z_tmp_2);
1129   // Z_ftos  : value
1130   // Z_ARG3  : index
1131   // Z_tmp_2 : array
1132   index_check(Z_tmp_2, Z_ARG3, LogBytesPerInt); // Prefer index in Z_ARG3.
1133   __ freg2mem_opt(Z_ftos,
1134                   Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
1135                   false);
1136 }
1137 
1138 void TemplateTable::dastore() {
1139   transition(dtos, vtos);
1140 
1141   __ pop_i(Z_ARG3);
1142   __ pop_ptr(Z_tmp_2);
1143   // Z_ftos  : value
1144   // Z_ARG3  : index
1145   // Z_tmp_2 : array
1146   index_check(Z_tmp_2, Z_ARG3, LogBytesPerLong); // Prefer index in Z_ARG3.
1147   __ freg2mem_opt(Z_ftos,
1148                   Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_DOUBLE)));
1149 }
1150 
1151 void TemplateTable::aastore() {
1152   NearLabel is_null, ok_is_subtype, done;
1153   transition(vtos, vtos);
1154 
1155   // stack: ..., array, index, value
1156 
1157   Register Rvalue = Z_tos;
1158   Register Rarray = Z_ARG2;
1159   Register Rindex = Z_ARG3; // Convention for index_check().
1160 
1161   __ load_ptr(0, Rvalue);
1162   __ z_l(Rindex, Address(Z_esp, Interpreter::expr_offset_in_bytes(1)));
1163   __ load_ptr(2, Rarray);
1164 
1165   unsigned const int shift = LogBytesPerHeapOop;
1166   index_check(Rarray, Rindex, shift); // side effect: Rindex = Rindex &lt;&lt; shift
1167   Register Rstore_addr  = Rindex;
1168   // Address where the store goes to, i.e. &amp;(Rarry[index])
1169   __ load_address(Rstore_addr, Address(Rarray, Rindex, arrayOopDesc::base_offset_in_bytes(T_OBJECT)));
1170 
1171   // do array store check - check for NULL value first.
1172   __ compareU64_and_branch(Rvalue, (intptr_t)0, Assembler::bcondEqual, is_null);
1173 
1174   Register Rsub_klass   = Z_ARG4;
1175   Register Rsuper_klass = Z_ARG5;
1176   __ load_klass(Rsub_klass, Rvalue);
1177   // Load superklass.
1178   __ load_klass(Rsuper_klass, Rarray);
1179   __ z_lg(Rsuper_klass, Address(Rsuper_klass, ObjArrayKlass::element_klass_offset()));
1180 
1181   // Generate a fast subtype check.  Branch to ok_is_subtype if no failure.
1182   // Throw if failure.
1183   Register tmp1 = Z_tmp_1;
1184   Register tmp2 = Z_tmp_2;
1185   __ gen_subtype_check(Rsub_klass, Rsuper_klass, tmp1, tmp2, ok_is_subtype);
1186 
1187   // Fall through on failure.
1188   // Object is in Rvalue == Z_tos.
1189   assert(Rvalue == Z_tos, &quot;that&#39;s the expected location&quot;);
1190   __ load_absolute_address(tmp1, Interpreter::_throw_ArrayStoreException_entry);
1191   __ z_br(tmp1);
1192 
1193   Register tmp3 = Rsub_klass;
1194 
1195   // Have a NULL in Rvalue.
1196   __ bind(is_null);
1197   __ profile_null_seen(tmp1);
1198 
1199   // Store a NULL.
1200   do_oop_store(_masm, Address(Rstore_addr, (intptr_t)0), noreg,
1201                tmp3, tmp2, tmp1, IS_ARRAY);
1202   __ z_bru(done);
1203 
1204   // Come here on success.
1205   __ bind(ok_is_subtype);
1206 
1207   // Now store using the appropriate barrier.
1208   do_oop_store(_masm, Address(Rstore_addr, (intptr_t)0), Rvalue,
1209                tmp3, tmp2, tmp1, IS_ARRAY | IS_NOT_NULL);
1210 
1211   // Pop stack arguments.
1212   __ bind(done);
1213   __ add2reg(Z_esp, 3 * Interpreter::stackElementSize);
1214 }
1215 
1216 
1217 void TemplateTable::bastore() {
1218   transition(itos, vtos);
1219 
1220   __ pop_i(Z_ARG3);
1221   __ pop_ptr(Z_tmp_2);
1222   // Z_tos   : value
1223   // Z_ARG3  : index
1224   // Z_tmp_2 : array
1225 
1226   // Need to check whether array is boolean or byte
1227   // since both types share the bastore bytecode.
1228   __ load_klass(Z_tmp_1, Z_tmp_2);
1229   __ z_llgf(Z_tmp_1, Address(Z_tmp_1, Klass::layout_helper_offset()));
1230   __ z_tmll(Z_tmp_1, Klass::layout_helper_boolean_diffbit());
1231   Label L_skip;
1232   __ z_bfalse(L_skip);
1233   // if it is a T_BOOLEAN array, mask the stored value to 0/1
1234   __ z_nilf(Z_tos, 0x1);
1235   __ bind(L_skip);
1236 
1237   // No index shift necessary - pass 0.
1238   index_check(Z_tmp_2, Z_ARG3, 0); // Prefer index in Z_ARG3.
1239   __ z_stc(Z_tos,
1240            Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_BYTE)));
1241 }
1242 
1243 void TemplateTable::castore() {
1244   transition(itos, vtos);
1245 
1246   __ pop_i(Z_ARG3);
1247   __ pop_ptr(Z_tmp_2);
1248   // Z_tos   : value
1249   // Z_ARG3  : index
1250   // Z_tmp_2 : array
1251   Register index = Z_ARG3; // prefer index in Z_ARG3
1252   index_check(Z_tmp_2, index, LogBytesPerShort);
1253   __ z_sth(Z_tos,
1254            Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_CHAR)));
1255 }
1256 
1257 void TemplateTable::sastore() {
1258   castore();
1259 }
1260 
1261 void TemplateTable::istore(int n) {
1262   transition(itos, vtos);
1263   __ reg2mem_opt(Z_tos, iaddress(n), false);
1264 }
1265 
1266 void TemplateTable::lstore(int n) {
1267   transition(ltos, vtos);
1268   __ reg2mem_opt(Z_tos, laddress(n));
1269 }
1270 
1271 void TemplateTable::fstore(int n) {
1272   transition(ftos, vtos);
1273   __ freg2mem_opt(Z_ftos, faddress(n), false);
1274 }
1275 
1276 void TemplateTable::dstore(int n) {
1277   transition(dtos, vtos);
1278   __ freg2mem_opt(Z_ftos, daddress(n));
1279 }
1280 
1281 void TemplateTable::astore(int n) {
1282   transition(vtos, vtos);
1283   __ pop_ptr(Z_tos);
1284   __ reg2mem_opt(Z_tos, aaddress(n));
1285 }
1286 
1287 void TemplateTable::pop() {
1288   transition(vtos, vtos);
1289   __ add2reg(Z_esp, Interpreter::stackElementSize);
1290 }
1291 
1292 void TemplateTable::pop2() {
1293   transition(vtos, vtos);
1294   __ add2reg(Z_esp, 2 * Interpreter::stackElementSize);
1295 }
1296 
1297 void TemplateTable::dup() {
1298   transition(vtos, vtos);
1299   __ load_ptr(0, Z_tos);
1300   __ push_ptr(Z_tos);
1301   // stack: ..., a, a
1302 }
1303 
1304 void TemplateTable::dup_x1() {
1305   transition(vtos, vtos);
1306 
1307   // stack: ..., a, b
1308   __ load_ptr(0, Z_tos);          // load b
1309   __ load_ptr(1, Z_R0_scratch);   // load a
1310   __ store_ptr(1, Z_tos);         // store b
1311   __ store_ptr(0, Z_R0_scratch);  // store a
1312   __ push_ptr(Z_tos);             // push b
1313   // stack: ..., b, a, b
1314 }
1315 
1316 void TemplateTable::dup_x2() {
1317   transition(vtos, vtos);
1318 
1319   // stack: ..., a, b, c
1320   __ load_ptr(0, Z_R0_scratch);   // load c
1321   __ load_ptr(2, Z_R1_scratch);   // load a
1322   __ store_ptr(2, Z_R0_scratch);  // store c in a
1323   __ push_ptr(Z_R0_scratch);      // push c
1324   // stack: ..., c, b, c, c
1325   __ load_ptr(2, Z_R0_scratch);   // load b
1326   __ store_ptr(2, Z_R1_scratch);  // store a in b
1327   // stack: ..., c, a, c, c
1328   __ store_ptr(1, Z_R0_scratch);  // store b in c
1329   // stack: ..., c, a, b, c
1330 }
1331 
1332 void TemplateTable::dup2() {
1333   transition(vtos, vtos);
1334 
1335   // stack: ..., a, b
1336   __ load_ptr(1, Z_R0_scratch);  // load a
1337   __ push_ptr(Z_R0_scratch);     // push a
1338   __ load_ptr(1, Z_R0_scratch);  // load b
1339   __ push_ptr(Z_R0_scratch);     // push b
1340   // stack: ..., a, b, a, b
1341 }
1342 
1343 void TemplateTable::dup2_x1() {
1344   transition(vtos, vtos);
1345 
1346   // stack: ..., a, b, c
1347   __ load_ptr(0, Z_R0_scratch);  // load c
1348   __ load_ptr(1, Z_R1_scratch);  // load b
1349   __ push_ptr(Z_R1_scratch);     // push b
1350   __ push_ptr(Z_R0_scratch);     // push c
1351   // stack: ..., a, b, c, b, c
1352   __ store_ptr(3, Z_R0_scratch); // store c in b
1353   // stack: ..., a, c, c, b, c
1354   __ load_ptr( 4, Z_R0_scratch); // load a
1355   __ store_ptr(2, Z_R0_scratch); // store a in 2nd c
1356   // stack: ..., a, c, a, b, c
1357   __ store_ptr(4, Z_R1_scratch); // store b in a
1358   // stack: ..., b, c, a, b, c
1359 }
1360 
1361 void TemplateTable::dup2_x2() {
1362   transition(vtos, vtos);
1363 
1364   // stack: ..., a, b, c, d
1365   __ load_ptr(0, Z_R0_scratch);   // load d
1366   __ load_ptr(1, Z_R1_scratch);   // load c
1367   __ push_ptr(Z_R1_scratch);      // push c
1368   __ push_ptr(Z_R0_scratch);      // push d
1369   // stack: ..., a, b, c, d, c, d
1370   __ load_ptr(4, Z_R1_scratch);   // load b
1371   __ store_ptr(2, Z_R1_scratch);  // store b in d
1372   __ store_ptr(4, Z_R0_scratch);  // store d in b
1373   // stack: ..., a, d, c, b, c, d
1374   __ load_ptr(5, Z_R0_scratch);   // load a
1375   __ load_ptr(3, Z_R1_scratch);   // load c
1376   __ store_ptr(3, Z_R0_scratch);  // store a in c
1377   __ store_ptr(5, Z_R1_scratch);  // store c in a
1378   // stack: ..., c, d, a, b, c, d
1379 }
1380 
1381 void TemplateTable::swap() {
1382   transition(vtos, vtos);
1383 
1384   // stack: ..., a, b
1385   __ load_ptr(1, Z_R0_scratch);  // load a
1386   __ load_ptr(0, Z_R1_scratch);  // load b
1387   __ store_ptr(0, Z_R0_scratch);  // store a in b
1388   __ store_ptr(1, Z_R1_scratch);  // store b in a
1389   // stack: ..., b, a
1390 }
1391 
1392 void TemplateTable::iop2(Operation op) {
1393   transition(itos, itos);
1394   switch (op) {
1395     case add  :                           __ z_ay(Z_tos,  __ stackTop()); __ pop_i(); break;
1396     case sub  :                           __ z_sy(Z_tos,  __ stackTop()); __ pop_i(); __ z_lcr(Z_tos, Z_tos); break;
1397     case mul  :                           __ z_msy(Z_tos, __ stackTop()); __ pop_i(); break;
1398     case _and :                           __ z_ny(Z_tos,  __ stackTop()); __ pop_i(); break;
1399     case _or  :                           __ z_oy(Z_tos,  __ stackTop()); __ pop_i(); break;
1400     case _xor :                           __ z_xy(Z_tos,  __ stackTop()); __ pop_i(); break;
1401     case shl  : __ z_lr(Z_tmp_1, Z_tos);
1402                 __ z_nill(Z_tmp_1, 31);  // Lowest 5 bits are shiftamount.
1403                                           __ pop_i(Z_tos);   __ z_sll(Z_tos, 0,  Z_tmp_1); break;
1404     case shr  : __ z_lr(Z_tmp_1, Z_tos);
1405                 __ z_nill(Z_tmp_1, 31);  // Lowest 5 bits are shiftamount.
1406                                           __ pop_i(Z_tos);   __ z_sra(Z_tos, 0,  Z_tmp_1); break;
1407     case ushr : __ z_lr(Z_tmp_1, Z_tos);
1408                 __ z_nill(Z_tmp_1, 31);  // Lowest 5 bits are shiftamount.
1409                                           __ pop_i(Z_tos);   __ z_srl(Z_tos, 0,  Z_tmp_1); break;
1410     default   : ShouldNotReachHere(); break;
1411   }
1412   return;
1413 }
1414 
1415 void TemplateTable::lop2(Operation op) {
1416   transition(ltos, ltos);
1417 
1418   switch (op) {
1419     case add  :  __ z_ag(Z_tos,  __ stackTop()); __ pop_l(); break;
1420     case sub  :  __ z_sg(Z_tos,  __ stackTop()); __ pop_l(); __ z_lcgr(Z_tos, Z_tos); break;
1421     case mul  :  __ z_msg(Z_tos, __ stackTop()); __ pop_l(); break;
1422     case _and :  __ z_ng(Z_tos,  __ stackTop()); __ pop_l(); break;
1423     case _or  :  __ z_og(Z_tos,  __ stackTop()); __ pop_l(); break;
1424     case _xor :  __ z_xg(Z_tos,  __ stackTop()); __ pop_l(); break;
1425     default   : ShouldNotReachHere(); break;
1426   }
1427   return;
1428 }
1429 
1430 // Common part of idiv/irem.
1431 static void idiv_helper(InterpreterMacroAssembler * _masm, address exception) {
1432   NearLabel not_null;
1433 
1434   // Use register pair Z_tmp_1, Z_tmp_2 for DIVIDE SINGLE.
1435   assert(Z_tmp_1-&gt;successor() == Z_tmp_2, &quot; need even/odd register pair for idiv/irem&quot;);
1436 
1437   // Get dividend.
1438   __ pop_i(Z_tmp_2);
1439 
1440   // If divisor == 0 throw exception.
1441   __ compare32_and_branch(Z_tos, (intptr_t) 0,
1442                           Assembler::bcondNotEqual, not_null   );
1443   __ load_absolute_address(Z_R1_scratch, exception);
1444   __ z_br(Z_R1_scratch);
1445 
1446   __ bind(not_null);
1447 
1448   __ z_lgfr(Z_tmp_2, Z_tmp_2);   // Sign extend dividend.
1449   __ z_dsgfr(Z_tmp_1, Z_tos);    // Do it.
1450 }
1451 
1452 void TemplateTable::idiv() {
1453   transition(itos, itos);
1454 
1455   idiv_helper(_masm, Interpreter::_throw_ArithmeticException_entry);
1456   __ z_llgfr(Z_tos, Z_tmp_2);     // Result is in Z_tmp_2.
1457 }
1458 
1459 void TemplateTable::irem() {
1460   transition(itos, itos);
1461 
1462   idiv_helper(_masm, Interpreter::_throw_ArithmeticException_entry);
1463   __ z_llgfr(Z_tos, Z_tmp_1);     // Result is in Z_tmp_1.
1464 }
1465 
1466 void TemplateTable::lmul() {
1467   transition(ltos, ltos);
1468 
1469   // Multiply with memory operand.
1470   __ z_msg(Z_tos, __ stackTop());
1471   __ pop_l();  // Pop operand.
1472 }
1473 
1474 // Common part of ldiv/lrem.
1475 //
1476 // Input:
1477 //     Z_tos := the divisor (dividend still on stack)
1478 //
1479 // Updated registers:
1480 //     Z_tmp_1 := pop_l() % Z_tos     ; if is_ldiv == false
1481 //     Z_tmp_2 := pop_l() / Z_tos     ; if is_ldiv == true
1482 //
1483 static void ldiv_helper(InterpreterMacroAssembler * _masm, address exception, bool is_ldiv) {
1484   NearLabel not_null, done;
1485 
1486   // Use register pair Z_tmp_1, Z_tmp_2 for DIVIDE SINGLE.
1487   assert(Z_tmp_1-&gt;successor() == Z_tmp_2,
1488          &quot; need even/odd register pair for idiv/irem&quot;);
1489 
1490   // Get dividend.
1491   __ pop_l(Z_tmp_2);
1492 
1493   // If divisor == 0 throw exception.
1494   __ compare64_and_branch(Z_tos, (intptr_t)0, Assembler::bcondNotEqual, not_null);
1495   __ load_absolute_address(Z_R1_scratch, exception);
1496   __ z_br(Z_R1_scratch);
1497 
1498   __ bind(not_null);
1499   // Special case for dividend == 0x8000 and divisor == -1.
1500   if (is_ldiv) {
1501     // result := Z_tmp_2 := - dividend
1502     __ z_lcgr(Z_tmp_2, Z_tmp_2);
1503   } else {
1504     // result remainder := Z_tmp_1 := 0
1505     __ clear_reg(Z_tmp_1, true, false);  // Don&#39;t set CC.
1506   }
1507 
1508   // if divisor == -1 goto done
1509   __ compare64_and_branch(Z_tos, -1, Assembler::bcondEqual, done);
1510   if (is_ldiv)
1511     // Restore sign, because divisor != -1.
1512     __ z_lcgr(Z_tmp_2, Z_tmp_2);
1513   __ z_dsgr(Z_tmp_1, Z_tos);    // Do it.
1514   __ bind(done);
1515 }
1516 
1517 void TemplateTable::ldiv() {
1518   transition(ltos, ltos);
1519 
1520   ldiv_helper(_masm, Interpreter::_throw_ArithmeticException_entry, true /*is_ldiv*/);
1521   __ z_lgr(Z_tos, Z_tmp_2);     // Result is in Z_tmp_2.
1522 }
1523 
1524 void TemplateTable::lrem() {
1525   transition(ltos, ltos);
1526 
1527   ldiv_helper(_masm, Interpreter::_throw_ArithmeticException_entry, false /*is_ldiv*/);
1528   __ z_lgr(Z_tos, Z_tmp_1);     // Result is in Z_tmp_1.
1529 }
1530 
1531 void TemplateTable::lshl() {
1532   transition(itos, ltos);
1533 
1534   // Z_tos: shift amount
1535   __ pop_l(Z_tmp_1);              // Get shift value.
1536   __ z_sllg(Z_tos, Z_tmp_1, 0, Z_tos);
1537 }
1538 
1539 void TemplateTable::lshr() {
1540   transition(itos, ltos);
1541 
1542   // Z_tos: shift amount
1543   __ pop_l(Z_tmp_1);              // Get shift value.
1544   __ z_srag(Z_tos, Z_tmp_1, 0, Z_tos);
1545 }
1546 
1547 void TemplateTable::lushr() {
1548   transition(itos, ltos);
1549 
1550   // Z_tos: shift amount
1551   __ pop_l(Z_tmp_1);              // Get shift value.
1552   __ z_srlg(Z_tos, Z_tmp_1, 0, Z_tos);
1553 }
1554 
1555 void TemplateTable::fop2(Operation op) {
1556   transition(ftos, ftos);
1557 
1558   switch (op) {
1559     case add:
1560       // Add memory operand.
1561       __ z_aeb(Z_ftos, __ stackTop()); __ pop_f(); return;
1562     case sub:
1563       // Sub memory operand.
1564       __ z_ler(Z_F1, Z_ftos);    // first operand
1565       __ pop_f(Z_ftos);          // second operand from stack
1566       __ z_sebr(Z_ftos, Z_F1);
1567       return;
1568     case mul:
1569       // Multiply with memory operand.
1570       __ z_meeb(Z_ftos, __ stackTop()); __ pop_f(); return;
1571     case div:
1572       __ z_ler(Z_F1, Z_ftos);    // first operand
1573       __ pop_f(Z_ftos);          // second operand from stack
1574       __ z_debr(Z_ftos, Z_F1);
1575       return;
1576     case rem:
1577       // Do runtime call.
1578       __ z_ler(Z_FARG2, Z_ftos);  // divisor
1579       __ pop_f(Z_FARG1);          // dividend
1580       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::frem));
1581       // Result should be in the right place (Z_ftos == Z_FRET).
1582       return;
1583     default:
1584       ShouldNotReachHere();
1585       return;
1586   }
1587 }
1588 
1589 void TemplateTable::dop2(Operation op) {
1590   transition(dtos, dtos);
1591 
1592   switch (op) {
1593     case add:
1594       // Add memory operand.
1595       __ z_adb(Z_ftos, __ stackTop()); __ pop_d(); return;
1596     case sub:
1597       // Sub memory operand.
1598       __ z_ldr(Z_F1, Z_ftos);    // first operand
1599       __ pop_d(Z_ftos);          // second operand from stack
1600       __ z_sdbr(Z_ftos, Z_F1);
1601       return;
1602     case mul:
1603       // Multiply with memory operand.
1604       __ z_mdb(Z_ftos, __ stackTop()); __ pop_d(); return;
1605     case div:
1606       __ z_ldr(Z_F1, Z_ftos);    // first operand
1607       __ pop_d(Z_ftos);          // second operand from stack
1608       __ z_ddbr(Z_ftos, Z_F1);
1609       return;
1610     case rem:
1611       // Do runtime call.
1612       __ z_ldr(Z_FARG2, Z_ftos);  // divisor
1613       __ pop_d(Z_FARG1);          // dividend
1614       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::drem));
1615       // Result should be in the right place (Z_ftos == Z_FRET).
1616       return;
1617     default:
1618       ShouldNotReachHere();
1619       return;
1620   }
1621 }
1622 
1623 void TemplateTable::ineg() {
1624   transition(itos, itos);
1625   __ z_lcr(Z_tos);
1626 }
1627 
1628 void TemplateTable::lneg() {
1629   transition(ltos, ltos);
1630   __ z_lcgr(Z_tos);
1631 }
1632 
1633 void TemplateTable::fneg() {
1634   transition(ftos, ftos);
1635   __ z_lcebr(Z_ftos, Z_ftos);
1636 }
1637 
1638 void TemplateTable::dneg() {
1639   transition(dtos, dtos);
1640   __ z_lcdbr(Z_ftos, Z_ftos);
1641 }
1642 
1643 void TemplateTable::iinc() {
1644   transition(vtos, vtos);
1645 
1646   Address local;
1647   __ z_lb(Z_R0_scratch, at_bcp(2)); // Get constant.
1648   locals_index(Z_R1_scratch);
1649   local = iaddress(_masm, Z_R1_scratch);
1650   __ z_a(Z_R0_scratch, local);
1651   __ reg2mem_opt(Z_R0_scratch, local, false);
1652 }
1653 
1654 void TemplateTable::wide_iinc() {
1655   transition(vtos, vtos);
1656 
1657   // Z_tmp_1 := increment
1658   __ get_2_byte_integer_at_bcp(Z_tmp_1, 4, InterpreterMacroAssembler::Signed);
1659   // Z_R1_scratch := index of local to increment
1660   locals_index_wide(Z_tmp_2);
1661   // Load, increment, and store.
1662   __ access_local_int(Z_tmp_2, Z_tos);
1663   __ z_agr(Z_tos,  Z_tmp_1);
1664   // Shifted index is still in Z_tmp_2.
1665   __ reg2mem_opt(Z_tos, Address(Z_locals, Z_tmp_2), false);
1666 }
1667 
1668 
1669 void TemplateTable::convert() {
1670   // Checking
1671 #ifdef ASSERT
1672   TosState   tos_in  = ilgl;
1673   TosState   tos_out = ilgl;
1674 
1675   switch (bytecode()) {
1676     case Bytecodes::_i2l:
1677     case Bytecodes::_i2f:
1678     case Bytecodes::_i2d:
1679     case Bytecodes::_i2b:
1680     case Bytecodes::_i2c:
1681     case Bytecodes::_i2s:
1682       tos_in = itos;
1683       break;
1684     case Bytecodes::_l2i:
1685     case Bytecodes::_l2f:
1686     case Bytecodes::_l2d:
1687       tos_in = ltos;
1688       break;
1689     case Bytecodes::_f2i:
1690     case Bytecodes::_f2l:
1691     case Bytecodes::_f2d:
1692       tos_in = ftos;
1693       break;
1694     case Bytecodes::_d2i:
1695     case Bytecodes::_d2l:
1696     case Bytecodes::_d2f:
1697       tos_in = dtos;
1698       break;
1699     default :
1700       ShouldNotReachHere();
1701   }
1702   switch (bytecode()) {
1703     case Bytecodes::_l2i:
1704     case Bytecodes::_f2i:
1705     case Bytecodes::_d2i:
1706     case Bytecodes::_i2b:
1707     case Bytecodes::_i2c:
1708     case Bytecodes::_i2s:
1709       tos_out = itos;
1710       break;
1711     case Bytecodes::_i2l:
1712     case Bytecodes::_f2l:
1713     case Bytecodes::_d2l:
1714       tos_out = ltos;
1715       break;
1716     case Bytecodes::_i2f:
1717     case Bytecodes::_l2f:
1718     case Bytecodes::_d2f:
1719       tos_out = ftos;
1720       break;
1721     case Bytecodes::_i2d:
1722     case Bytecodes::_l2d:
1723     case Bytecodes::_f2d:
1724       tos_out = dtos;
1725       break;
1726     default :
1727       ShouldNotReachHere();
1728   }
1729 
1730   transition(tos_in, tos_out);
1731 #endif // ASSERT
1732 
1733   // Conversion
1734   Label done;
1735   switch (bytecode()) {
1736     case Bytecodes::_i2l:
1737       __ z_lgfr(Z_tos, Z_tos);
1738       return;
1739     case Bytecodes::_i2f:
1740       __ z_cefbr(Z_ftos, Z_tos);
1741       return;
1742     case Bytecodes::_i2d:
1743       __ z_cdfbr(Z_ftos, Z_tos);
1744       return;
1745     case Bytecodes::_i2b:
1746       // Sign extend least significant byte.
1747       __ move_reg_if_needed(Z_tos, T_BYTE, Z_tos, T_INT);
1748       return;
1749     case Bytecodes::_i2c:
1750       // Zero extend 2 least significant bytes.
1751       __ move_reg_if_needed(Z_tos, T_CHAR, Z_tos, T_INT);
1752       return;
1753     case Bytecodes::_i2s:
1754       // Sign extend 2 least significant bytes.
1755       __ move_reg_if_needed(Z_tos, T_SHORT, Z_tos, T_INT);
1756       return;
1757     case Bytecodes::_l2i:
1758       // Sign-extend not needed here, upper 4 bytes of int value in register are ignored.
1759       return;
1760     case Bytecodes::_l2f:
1761       __ z_cegbr(Z_ftos, Z_tos);
1762       return;
1763     case Bytecodes::_l2d:
1764       __ z_cdgbr(Z_ftos, Z_tos);
1765       return;
1766     case Bytecodes::_f2i:
1767     case Bytecodes::_f2l:
1768       __ clear_reg(Z_tos, true, false);  // Don&#39;t set CC.
1769       __ z_cebr(Z_ftos, Z_ftos);
1770       __ z_brno(done); // NaN -&gt; 0
1771       if (bytecode() == Bytecodes::_f2i)
1772         __ z_cfebr(Z_tos, Z_ftos, Assembler::to_zero);
1773       else // bytecode() == Bytecodes::_f2l
1774         __ z_cgebr(Z_tos, Z_ftos, Assembler::to_zero);
1775       break;
1776     case Bytecodes::_f2d:
1777       __ move_freg_if_needed(Z_ftos, T_DOUBLE, Z_ftos, T_FLOAT);
1778       return;
1779     case Bytecodes::_d2i:
1780     case Bytecodes::_d2l:
1781       __ clear_reg(Z_tos, true, false);  // Ddon&#39;t set CC.
1782       __ z_cdbr(Z_ftos, Z_ftos);
1783       __ z_brno(done); // NaN -&gt; 0
1784       if (bytecode() == Bytecodes::_d2i)
1785         __ z_cfdbr(Z_tos, Z_ftos, Assembler::to_zero);
1786       else // Bytecodes::_d2l
1787         __ z_cgdbr(Z_tos, Z_ftos, Assembler::to_zero);
1788       break;
1789     case Bytecodes::_d2f:
1790       __ move_freg_if_needed(Z_ftos, T_FLOAT, Z_ftos, T_DOUBLE);
1791       return;
1792     default:
1793       ShouldNotReachHere();
1794   }
1795   __ bind(done);
1796 }
1797 
1798 void TemplateTable::lcmp() {
1799   transition(ltos, itos);
1800 
1801   Label   done;
1802   Register val1 = Z_R0_scratch;
1803   Register val2 = Z_R1_scratch;
1804 
1805   if (VM_Version::has_LoadStoreConditional()) {
1806     __ pop_l(val1);           // pop value 1.
1807     __ z_lghi(val2,  -1);     // lt value
1808     __ z_cgr(val1, Z_tos);    // Compare with Z_tos (value 2). Protect CC under all circumstances.
1809     __ z_lghi(val1,   1);     // gt value
1810     __ z_lghi(Z_tos,  0);     // eq value
1811 
1812     __ z_locgr(Z_tos, val1, Assembler::bcondHigh);
1813     __ z_locgr(Z_tos, val2, Assembler::bcondLow);
1814   } else {
1815     __ pop_l(val1);           // Pop value 1.
1816     __ z_cgr(val1, Z_tos);    // Compare with Z_tos (value 2). Protect CC under all circumstances.
1817 
1818     __ z_lghi(Z_tos,  0);     // eq value
1819     __ z_bre(done);
1820 
1821     __ z_lghi(Z_tos,  1);     // gt value
1822     __ z_brh(done);
1823 
1824     __ z_lghi(Z_tos, -1);     // lt value
1825   }
1826 
1827   __ bind(done);
1828 }
1829 
1830 
1831 void TemplateTable::float_cmp(bool is_float, int unordered_result) {
1832   Label done;
1833 
1834   if (is_float) {
1835     __ pop_f(Z_FARG2);
1836     __ z_cebr(Z_FARG2, Z_ftos);
1837   } else {
1838     __ pop_d(Z_FARG2);
1839     __ z_cdbr(Z_FARG2, Z_ftos);
1840   }
1841 
1842   if (VM_Version::has_LoadStoreConditional()) {
1843     Register one       = Z_R0_scratch;
1844     Register minus_one = Z_R1_scratch;
1845     __ z_lghi(minus_one,  -1);
1846     __ z_lghi(one,  1);
1847     __ z_lghi(Z_tos, 0);
1848     __ z_locgr(Z_tos, one,       unordered_result == 1 ? Assembler::bcondHighOrNotOrdered : Assembler::bcondHigh);
1849     __ z_locgr(Z_tos, minus_one, unordered_result == 1 ? Assembler::bcondLow              : Assembler::bcondLowOrNotOrdered);
1850   } else {
1851     // Z_FARG2 == Z_ftos
1852     __ clear_reg(Z_tos, false, false);
1853     __ z_bre(done);
1854 
1855     // F_ARG2 &gt; Z_Ftos, or unordered
1856     __ z_lhi(Z_tos, 1);
1857     __ z_brc(unordered_result == 1 ? Assembler::bcondHighOrNotOrdered : Assembler::bcondHigh, done);
1858 
1859     // F_ARG2 &lt; Z_FTOS, or unordered
1860     __ z_lhi(Z_tos, -1);
1861 
1862     __ bind(done);
1863   }
1864 }
1865 
1866 void TemplateTable::branch(bool is_jsr, bool is_wide) {
1867   const Register   bumped_count = Z_tmp_1;
1868   const Register   method       = Z_tmp_2;
1869   const Register   m_counters   = Z_R1_scratch;
1870   const Register   mdo          = Z_tos;
1871 
1872   BLOCK_COMMENT(&quot;TemplateTable::branch {&quot;);
1873   __ get_method(method);
1874   __ profile_taken_branch(mdo, bumped_count);
1875 
1876   const ByteSize ctr_offset = InvocationCounter::counter_offset();
1877   const ByteSize be_offset  = MethodCounters::backedge_counter_offset()   + ctr_offset;
1878   const ByteSize inv_offset = MethodCounters::invocation_counter_offset() + ctr_offset;
1879 
1880   // Get (wide) offset to disp.
1881   const Register disp = Z_ARG5;
1882   if (is_wide) {
1883     __ get_4_byte_integer_at_bcp(disp, 1);
1884   } else {
1885     __ get_2_byte_integer_at_bcp(disp, 1, InterpreterMacroAssembler::Signed);
1886   }
1887 
1888   // Handle all the JSR stuff here, then exit.
1889   // It&#39;s much shorter and cleaner than intermingling with the
1890   // non-JSR normal-branch stuff occurring below.
1891   if (is_jsr) {
1892     // Compute return address as bci in Z_tos.
1893     __ z_lgr(Z_R1_scratch, Z_bcp);
1894     __ z_sg(Z_R1_scratch, Address(method, Method::const_offset()));
1895     __ add2reg(Z_tos, (is_wide ? 5 : 3) - in_bytes(ConstMethod::codes_offset()), Z_R1_scratch);
1896 
1897     // Bump bcp to target of JSR.
1898     __ z_agr(Z_bcp, disp);
1899     // Push return address for &quot;ret&quot; on stack.
1900     __ push_ptr(Z_tos);
1901     // And away we go!
1902     __ dispatch_next(vtos, 0 , true);
1903     return;
1904   }
1905 
1906   // Normal (non-jsr) branch handling.
1907 
1908   // Bump bytecode pointer by displacement (take the branch).
1909   __ z_agr(Z_bcp, disp);
1910 
1911   assert(UseLoopCounter || !UseOnStackReplacement,
1912          &quot;on-stack-replacement requires loop counters&quot;);
1913 
1914   NearLabel backedge_counter_overflow;
1915   NearLabel profile_method;
1916   NearLabel dispatch;
1917   int       increment = InvocationCounter::count_increment;
1918 
1919   if (UseLoopCounter) {
1920     // Increment backedge counter for backward branches.
1921     // disp: target offset
1922     // Z_bcp: target bcp
1923     // Z_locals: locals pointer
1924     //
1925     // Count only if backward branch.
1926     __ compare32_and_branch(disp, (intptr_t)0, Assembler::bcondHigh, dispatch);
1927 
1928     if (TieredCompilation) {
1929       Label noCounters;
1930 
1931       if (ProfileInterpreter) {
1932         NearLabel   no_mdo;
1933 
1934         // Are we profiling?
1935         __ load_and_test_long(mdo, Address(method, Method::method_data_offset()));
1936         __ branch_optimized(Assembler::bcondZero, no_mdo);
1937 
1938         // Increment the MDO backedge counter.
1939         const Address mdo_backedge_counter(mdo, MethodData::backedge_counter_offset() + InvocationCounter::counter_offset());
1940 
1941         const Address mask(mdo, MethodData::backedge_mask_offset());
1942         __ increment_mask_and_jump(mdo_backedge_counter, increment, mask,
1943                                    Z_ARG2, false, Assembler::bcondZero,
1944                                    UseOnStackReplacement ? &amp;backedge_counter_overflow : NULL);
1945         __ z_bru(dispatch);
1946         __ bind(no_mdo);
1947       }
1948 
1949       // Increment backedge counter in MethodCounters*.
1950       __ get_method_counters(method, m_counters, noCounters);
1951       const Address mask(m_counters, MethodCounters::backedge_mask_offset());
1952       __ increment_mask_and_jump(Address(m_counters, be_offset),
1953                                  increment, mask,
1954                                  Z_ARG2, false, Assembler::bcondZero,
1955                                  UseOnStackReplacement ? &amp;backedge_counter_overflow : NULL);
1956       __ bind(noCounters);
1957     } else {
1958       Register counter = Z_tos;
1959       Label    noCounters;
1960       // Get address of MethodCounters object.
1961       __ get_method_counters(method, m_counters, noCounters);
1962       // Increment backedge counter.
1963       __ increment_backedge_counter(m_counters, counter);
1964 
1965       if (ProfileInterpreter) {
1966         // Test to see if we should create a method data obj.
1967         __ z_cl(counter, Address(m_counters, MethodCounters::interpreter_profile_limit_offset()));
1968         __ z_brl(dispatch);
1969 
1970         // If no method data exists, go to profile method.
1971         __ test_method_data_pointer(Z_ARG4/*result unused*/, profile_method);
1972 
1973         if (UseOnStackReplacement) {
1974           // Check for overflow against &#39;bumped_count&#39; which is the MDO taken count.
1975           __ z_cl(bumped_count, Address(m_counters, MethodCounters::interpreter_backward_branch_limit_offset()));
1976           __ z_brl(dispatch);
1977 
1978           // When ProfileInterpreter is on, the backedge_count comes
1979           // from the methodDataOop, which value does not get reset on
1980           // the call to frequency_counter_overflow(). To avoid
1981           // excessive calls to the overflow routine while the method is
1982           // being compiled, add a second test to make sure the overflow
1983           // function is called only once every overflow_frequency.
1984           const int overflow_frequency = 1024;
1985           __ and_imm(bumped_count, overflow_frequency - 1);
1986           __ z_brz(backedge_counter_overflow);
1987 
1988         }
1989       } else {
1990         if (UseOnStackReplacement) {
1991           // Check for overflow against &#39;counter&#39;, which is the sum of the
1992           // counters.
1993           __ z_cl(counter, Address(m_counters, MethodCounters::interpreter_backward_branch_limit_offset()));
1994           __ z_brh(backedge_counter_overflow);
1995         }
1996       }
1997       __ bind(noCounters);
1998     }
1999 
2000     __ bind(dispatch);
2001   }
2002 
2003   // Pre-load the next target bytecode into rbx.
2004   __ z_llgc(Z_bytecode, Address(Z_bcp, (intptr_t) 0));
2005 
2006   // Continue with the bytecode @ target.
2007   // Z_tos: Return bci for jsr&#39;s, unused otherwise.
2008   // Z_bytecode: target bytecode
2009   // Z_bcp: target bcp
2010   __ dispatch_only(vtos, true);
2011 
2012   // Out-of-line code runtime calls.
2013   if (UseLoopCounter) {
2014     if (ProfileInterpreter) {
2015       // Out-of-line code to allocate method data oop.
2016       __ bind(profile_method);
2017 
2018       __ call_VM(noreg,
2019                  CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
2020       __ z_llgc(Z_bytecode, Address(Z_bcp, (intptr_t) 0));  // Restore target bytecode.
2021       __ set_method_data_pointer_for_bcp();
2022       __ z_bru(dispatch);
2023     }
2024 
2025     if (UseOnStackReplacement) {
2026 
2027       // invocation counter overflow
2028       __ bind(backedge_counter_overflow);
2029 
2030       __ z_lcgr(Z_ARG2, disp); // Z_ARG2 := -disp
2031       __ z_agr(Z_ARG2, Z_bcp); // Z_ARG2 := branch target bcp - disp == branch bcp
2032       __ call_VM(noreg,
2033                  CAST_FROM_FN_PTR(address, InterpreterRuntime::frequency_counter_overflow),
2034                  Z_ARG2);
2035 
2036       // Z_RET: osr nmethod (osr ok) or NULL (osr not possible).
2037       __ compare64_and_branch(Z_RET, (intptr_t) 0, Assembler::bcondEqual, dispatch);
2038 
2039       // Nmethod may have been invalidated (VM may block upon call_VM return).
2040       __ z_cliy(nmethod::state_offset(), Z_RET, nmethod::in_use);
2041       __ z_brne(dispatch);
2042 
2043       // Migrate the interpreter frame off of the stack.
2044 
2045       __ z_lgr(Z_tmp_1, Z_RET); // Save the nmethod.
2046 
2047       call_VM(noreg,
2048               CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));
2049 
2050       // Z_RET is OSR buffer, move it to expected parameter location.
2051       __ lgr_if_needed(Z_ARG1, Z_RET);
2052 
2053       // Pop the interpreter frame ...
2054       __ pop_interpreter_frame(Z_R14, Z_ARG2/*tmp1*/, Z_ARG3/*tmp2*/);
2055 
2056       // ... and begin the OSR nmethod.
2057       __ z_lg(Z_R1_scratch, Address(Z_tmp_1, nmethod::osr_entry_point_offset()));
2058       __ z_br(Z_R1_scratch);
2059     }
2060   }
2061   BLOCK_COMMENT(&quot;} TemplateTable::branch&quot;);
2062 }
2063 
2064 void TemplateTable::if_0cmp(Condition cc) {
2065   transition(itos, vtos);
2066 
2067   // Assume branch is more often taken than not (loops use backward branches).
2068   NearLabel not_taken;
2069   __ compare32_and_branch(Z_tos, (intptr_t) 0, j_not(cc), not_taken);
2070   branch(false, false);
2071   __ bind(not_taken);
2072   __ profile_not_taken_branch(Z_tos);
2073 }
2074 
2075 void TemplateTable::if_icmp(Condition cc) {
2076   transition(itos, vtos);
2077 
2078   // Assume branch is more often taken than not (loops use backward branches).
2079   NearLabel not_taken;
2080   __ pop_i(Z_R0_scratch);
2081   __ compare32_and_branch(Z_R0_scratch, Z_tos, j_not(cc), not_taken);
2082   branch(false, false);
2083   __ bind(not_taken);
2084   __ profile_not_taken_branch(Z_tos);
2085 }
2086 
2087 void TemplateTable::if_nullcmp(Condition cc) {
2088   transition(atos, vtos);
2089 
2090   // Assume branch is more often taken than not (loops use backward branches) .
2091   NearLabel not_taken;
2092   __ compare64_and_branch(Z_tos, (intptr_t) 0, j_not(cc), not_taken);
2093   branch(false, false);
2094   __ bind(not_taken);
2095   __ profile_not_taken_branch(Z_tos);
2096 }
2097 
2098 void TemplateTable::if_acmp(Condition cc) {
2099   transition(atos, vtos);
2100   // Assume branch is more often taken than not (loops use backward branches).
2101   NearLabel not_taken;
2102   __ pop_ptr(Z_ARG2);
2103   __ verify_oop(Z_ARG2);
2104   __ verify_oop(Z_tos);
2105   __ compareU64_and_branch(Z_tos, Z_ARG2, j_not(cc), not_taken);
2106   branch(false, false);
2107   __ bind(not_taken);
2108   __ profile_not_taken_branch(Z_ARG3);
2109 }
2110 
2111 void TemplateTable::ret() {
2112   transition(vtos, vtos);
2113 
2114   locals_index(Z_tmp_1);
2115   // Get return bci, compute return bcp. Must load 64 bits.
2116   __ mem2reg_opt(Z_tmp_1, iaddress(_masm, Z_tmp_1));
2117   __ profile_ret(Z_tmp_1, Z_tmp_2);
2118   __ get_method(Z_tos);
2119   __ mem2reg_opt(Z_R1_scratch, Address(Z_tos, Method::const_offset()));
2120   __ load_address(Z_bcp, Address(Z_R1_scratch, Z_tmp_1, ConstMethod::codes_offset()));
2121   __ dispatch_next(vtos, 0 , true);
2122 }
2123 
2124 void TemplateTable::wide_ret() {
2125   transition(vtos, vtos);
2126 
2127   locals_index_wide(Z_tmp_1);
2128   // Get return bci, compute return bcp.
2129   __ mem2reg_opt(Z_tmp_1, aaddress(_masm, Z_tmp_1));
2130   __ profile_ret(Z_tmp_1, Z_tmp_2);
2131   __ get_method(Z_tos);
2132   __ mem2reg_opt(Z_R1_scratch, Address(Z_tos, Method::const_offset()));
2133   __ load_address(Z_bcp, Address(Z_R1_scratch, Z_tmp_1, ConstMethod::codes_offset()));
2134   __ dispatch_next(vtos, 0, true);
2135 }
2136 
2137 void TemplateTable::tableswitch () {
2138   transition(itos, vtos);
2139 
2140   NearLabel default_case, continue_execution;
2141   Register  bcp = Z_ARG5;
2142   // Align bcp.
2143   __ load_address(bcp, at_bcp(BytesPerInt));
2144   __ z_nill(bcp, (-BytesPerInt) &amp; 0xffff);
2145 
2146   // Load lo &amp; hi.
2147   Register low  = Z_tmp_1;
2148   Register high = Z_tmp_2;
2149 
2150   // Load low into 64 bits, since used for address calculation.
2151   __ mem2reg_signed_opt(low, Address(bcp, BytesPerInt));
2152   __ mem2reg_opt(high, Address(bcp, 2 * BytesPerInt), false);
2153   // Sign extend &quot;label&quot; value for address calculation.
2154   __ z_lgfr(Z_tos, Z_tos);
2155 
2156   // Check against lo &amp; hi.
2157   __ compare32_and_branch(Z_tos, low, Assembler::bcondLow, default_case);
2158   __ compare32_and_branch(Z_tos, high, Assembler::bcondHigh, default_case);
2159 
2160   // Lookup dispatch offset.
2161   __ z_sgr(Z_tos, low);
2162   Register jump_table_offset = Z_ARG3;
2163   // Index2offset; index in Z_tos is killed by profile_switch_case.
2164   __ z_sllg(jump_table_offset, Z_tos, LogBytesPerInt);
2165   __ profile_switch_case(Z_tos, Z_ARG4 /*tmp for mdp*/, low/*tmp*/, Z_bytecode/*tmp*/);
2166 
2167   Register index = Z_tmp_2;
2168 
2169   // Load index sign extended for addressing.
2170   __ mem2reg_signed_opt(index, Address(bcp, jump_table_offset, 3 * BytesPerInt));
2171 
2172   // Continue execution.
2173   __ bind(continue_execution);
2174 
2175   // Load next bytecode.
2176   __ z_llgc(Z_bytecode, Address(Z_bcp, index));
2177   __ z_agr(Z_bcp, index); // Advance bcp.
2178   __ dispatch_only(vtos, true);
2179 
2180   // Handle default.
2181   __ bind(default_case);
2182 
2183   __ profile_switch_default(Z_tos);
2184   __ mem2reg_signed_opt(index, Address(bcp));
2185   __ z_bru(continue_execution);
2186 }
2187 
2188 void TemplateTable::lookupswitch () {
2189   transition(itos, itos);
2190   __ stop(&quot;lookupswitch bytecode should have been rewritten&quot;);
2191 }
2192 
2193 void TemplateTable::fast_linearswitch () {
2194   transition(itos, vtos);
2195 
2196   Label    loop_entry, loop, found, continue_execution;
2197   Register bcp = Z_ARG5;
2198 
2199   // Align bcp.
2200   __ load_address(bcp, at_bcp(BytesPerInt));
2201   __ z_nill(bcp, (-BytesPerInt) &amp; 0xffff);
2202 
2203   // Start search with last case.
2204   Register current_case_offset = Z_tmp_1;
2205 
2206   __ mem2reg_signed_opt(current_case_offset, Address(bcp, BytesPerInt));
2207   __ z_sllg(current_case_offset, current_case_offset, LogBytesPerWord);   // index2bytes
2208   __ z_bru(loop_entry);
2209 
2210   // table search
2211   __ bind(loop);
2212 
2213   __ z_c(Z_tos, Address(bcp, current_case_offset, 2 * BytesPerInt));
2214   __ z_bre(found);
2215 
2216   __ bind(loop_entry);
2217   __ z_aghi(current_case_offset, -2 * BytesPerInt);  // Decrement.
2218   __ z_brnl(loop);
2219 
2220   // default case
2221   Register   offset = Z_tmp_2;
2222 
2223   __ profile_switch_default(Z_tos);
2224   // Load offset sign extended for addressing.
2225   __ mem2reg_signed_opt(offset, Address(bcp));
2226   __ z_bru(continue_execution);
2227 
2228   // Entry found -&gt; get offset.
2229   __ bind(found);
2230   __ mem2reg_signed_opt(offset, Address(bcp, current_case_offset, 3 * BytesPerInt));
2231   // Profile that this case was taken.
2232   Register current_case_idx = Z_ARG4;
2233   __ z_srlg(current_case_idx, current_case_offset, LogBytesPerWord); // bytes2index
2234   __ profile_switch_case(current_case_idx, Z_tos, bcp, Z_bytecode);
2235 
2236   // Continue execution.
2237   __ bind(continue_execution);
2238 
2239   // Load next bytecode.
2240   __ z_llgc(Z_bytecode, Address(Z_bcp, offset, 0));
2241   __ z_agr(Z_bcp, offset); // Advance bcp.
2242   __ dispatch_only(vtos, true);
2243 }
2244 
2245 
2246 void TemplateTable::fast_binaryswitch() {
2247 
2248   transition(itos, vtos);
2249 
2250   // Implementation using the following core algorithm:
2251   //
2252   // int binary_search(int key, LookupswitchPair* array, int n) {
2253   //   // Binary search according to &quot;Methodik des Programmierens&quot; by
2254   //   // Edsger W. Dijkstra and W.H.J. Feijen, Addison Wesley Germany 1985.
2255   //   int i = 0;
2256   //   int j = n;
2257   //   while (i+1 &lt; j) {
2258   //     // invariant P: 0 &lt;= i &lt; j &lt;= n and (a[i] &lt;= key &lt; a[j] or Q)
2259   //     // with      Q: for all i: 0 &lt;= i &lt; n: key &lt; a[i]
2260   //     // where a stands for the array and assuming that the (inexisting)
2261   //     // element a[n] is infinitely big.
2262   //     int h = (i + j) &gt;&gt; 1;
2263   //     // i &lt; h &lt; j
2264   //     if (key &lt; array[h].fast_match()) {
2265   //       j = h;
2266   //     } else {
2267   //       i = h;
2268   //     }
2269   //   }
2270   //   // R: a[i] &lt;= key &lt; a[i+1] or Q
2271   //   // (i.e., if key is within array, i is the correct index)
2272   //   return i;
2273   // }
2274 
2275   // Register allocation
2276   // Note: Since we use the indices in address operands, we do all the
2277   // computation in 64 bits.
2278   const Register key   = Z_tos; // Already set (tosca).
2279   const Register array = Z_tmp_1;
2280   const Register i     = Z_tmp_2;
2281   const Register j     = Z_ARG5;
2282   const Register h     = Z_ARG4;
2283   const Register temp  = Z_R1_scratch;
2284 
2285   // Find array start.
2286   __ load_address(array, at_bcp(3 * BytesPerInt));
2287   __ z_nill(array, (-BytesPerInt) &amp; 0xffff);   // align
2288 
2289   // Initialize i &amp; j.
2290   __ clear_reg(i, true, false);  // i = 0;  Don&#39;t set CC.
2291   __ mem2reg_signed_opt(j, Address(array, -BytesPerInt)); // j = length(array);
2292 
2293   // And start.
2294   Label entry;
2295   __ z_bru(entry);
2296 
2297   // binary search loop
2298   {
2299     NearLabel   loop;
2300 
2301     __ bind(loop);
2302 
2303     // int h = (i + j) &gt;&gt; 1;
2304     __ add2reg_with_index(h, 0, i, j); // h = i + j;
2305     __ z_srag(h, h, 1);                // h = (i + j) &gt;&gt; 1;
2306 
2307     // if (key &lt; array[h].fast_match()) {
2308     //   j = h;
2309     // } else {
2310     //   i = h;
2311     // }
2312 
2313     // Convert array[h].match to native byte-ordering before compare.
2314     __ z_sllg(temp, h, LogBytesPerWord);   // index2bytes
2315     __ mem2reg_opt(temp, Address(array, temp), false);
2316 
2317     NearLabel  else_;
2318 
2319     __ compare32_and_branch(key, temp, Assembler::bcondNotLow, else_);
2320     // j = h if (key &lt;  array[h].fast_match())
2321     __ z_lgr(j, h);
2322     __ z_bru(entry); // continue
2323 
2324     __ bind(else_);
2325 
2326     // i = h if (key &gt;= array[h].fast_match())
2327     __ z_lgr(i, h);  // and fallthrough
2328 
2329     // while (i+1 &lt; j)
2330     __ bind(entry);
2331 
2332     // if (i + 1 &lt; j) continue search
2333     __ add2reg(h, 1, i);
2334     __ compare64_and_branch(h, j, Assembler::bcondLow, loop);
2335   }
2336 
2337   // End of binary search, result index is i (must check again!).
2338   NearLabel default_case;
2339 
2340   // h is no longer needed, so use it to hold the byte offset.
2341   __ z_sllg(h, i, LogBytesPerWord);   // index2bytes
2342   __ mem2reg_opt(temp, Address(array, h), false);
2343   __ compare32_and_branch(key, temp, Assembler::bcondNotEqual, default_case);
2344 
2345   // entry found -&gt; j = offset
2346   __ mem2reg_signed_opt(j, Address(array, h, BytesPerInt));
2347   __ profile_switch_case(i, key, array, Z_bytecode);
2348   // Load next bytecode.
2349   __ z_llgc(Z_bytecode, Address(Z_bcp, j));
2350   __ z_agr(Z_bcp, j);       // Advance bcp.
2351   __ dispatch_only(vtos, true);
2352 
2353   // default case -&gt; j = default offset
2354   __ bind(default_case);
2355 
2356   __ profile_switch_default(i);
2357   __ mem2reg_signed_opt(j, Address(array, -2 * BytesPerInt));
2358   // Load next bytecode.
2359   __ z_llgc(Z_bytecode, Address(Z_bcp, j));
2360   __ z_agr(Z_bcp, j);       // Advance bcp.
2361   __ dispatch_only(vtos, true);
2362 }
2363 
2364 void TemplateTable::_return(TosState state) {
2365   transition(state, state);
2366   assert(_desc-&gt;calls_vm(),
2367          &quot;inconsistent calls_vm information&quot;); // call in remove_activation
2368 
2369   if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
2370     Register Rthis  = Z_ARG2;
2371     Register Rklass = Z_ARG5;
2372     Label skip_register_finalizer;
2373     assert(state == vtos, &quot;only valid state&quot;);
2374     __ z_lg(Rthis, aaddress(0));
2375     __ load_klass(Rklass, Rthis);
2376     __ testbit(Address(Rklass, Klass::access_flags_offset()), exact_log2(JVM_ACC_HAS_FINALIZER));
2377     __ z_bfalse(skip_register_finalizer);
2378     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::register_finalizer), Rthis);
2379     __ bind(skip_register_finalizer);
2380   }
2381 
2382   if (_desc-&gt;bytecode() != Bytecodes::_return_register_finalizer) {
2383     Label no_safepoint;
2384     const Address poll_byte_addr(Z_thread, in_bytes(Thread::polling_page_offset()) + 7 /* Big Endian */);
2385     __ z_tm(poll_byte_addr, SafepointMechanism::poll_bit());
2386     __ z_braz(no_safepoint);
2387     __ push(state);
2388     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint));
2389     __ pop(state);
2390     __ bind(no_safepoint);
2391   }
2392 
2393   if (state == itos) {
2394     // Narrow result if state is itos but result type is smaller.
2395     // Need to narrow in the return bytecode rather than in generate_return_entry
2396     // since compiled code callers expect the result to already be narrowed.
2397     __ narrow(Z_tos, Z_tmp_1); /* fall through */
2398   }
2399 
2400   __ remove_activation(state, Z_R14);
2401   __ z_br(Z_R14);
2402 }
2403 
2404 // ----------------------------------------------------------------------------
2405 // NOTE: Cpe_offset is already computed as byte offset, so we must not
2406 // shift it afterwards!
2407 void TemplateTable::resolve_cache_and_index(int byte_no,
2408                                             Register cache,
2409                                             Register cpe_offset,
2410                                             size_t index_size) {
2411   BLOCK_COMMENT(&quot;resolve_cache_and_index {&quot;);
2412   NearLabel      resolved, clinit_barrier_slow;
2413   const Register bytecode_in_cpcache = Z_R1_scratch;
2414   const int      total_f1_offset = in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset());
2415   assert_different_registers(cache, cpe_offset, bytecode_in_cpcache);
2416 
2417   Bytecodes::Code code = bytecode();
2418   switch (code) {
2419     case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
2420     case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
2421     default:
2422       break;
2423   }
2424 
2425   {
2426     assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
2427     __ get_cache_and_index_and_bytecode_at_bcp(cache, cpe_offset, bytecode_in_cpcache, byte_no, 1, index_size);
2428     // Have we resolved this bytecode?
2429     __ compare32_and_branch(bytecode_in_cpcache, (int)code, Assembler::bcondEqual, resolved);
2430   }
2431 
2432   // Resolve first time through.
2433   // Class initialization barrier slow path lands here as well.
2434   __ bind(clinit_barrier_slow);
2435   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
2436   __ load_const_optimized(Z_ARG2, (int) code);
2437   __ call_VM(noreg, entry, Z_ARG2);
2438 
2439   // Update registers with resolved info.
2440   __ get_cache_and_index_at_bcp(cache, cpe_offset, 1, index_size);
2441   __ bind(resolved);
2442 
2443   // Class initialization barrier for static methods
2444   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; bytecode() == Bytecodes::_invokestatic) {
2445     const Register method = Z_R1_scratch;
2446     const Register klass  = Z_R1_scratch;
2447 
2448     __ load_resolved_method_at_index(byte_no, cache, cpe_offset, method);
2449     __ load_method_holder(klass, method);
2450     __ clinit_barrier(klass, Z_thread, NULL /*L_fast_path*/, &amp;clinit_barrier_slow);
2451   }
2452 
2453   BLOCK_COMMENT(&quot;} resolve_cache_and_index&quot;);
2454 }
2455 
2456 // The Rcache and index registers must be set before call.
2457 // Index is already a byte offset, don&#39;t shift!
2458 void TemplateTable::load_field_cp_cache_entry(Register obj,
2459                                               Register cache,
2460                                               Register index,
2461                                               Register off,
2462                                               Register flags,
2463                                               bool is_static = false) {
2464   assert_different_registers(cache, index, flags, off);
2465   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2466 
2467   // Field offset
2468   __ mem2reg_opt(off, Address(cache, index, cp_base_offset + ConstantPoolCacheEntry::f2_offset()));
2469   // Flags. Must load 64 bits.
2470   __ mem2reg_opt(flags, Address(cache, index, cp_base_offset + ConstantPoolCacheEntry::flags_offset()));
2471 
2472   // klass overwrite register
2473   if (is_static) {
2474     __ mem2reg_opt(obj, Address(cache, index, cp_base_offset + ConstantPoolCacheEntry::f1_offset()));
2475     __ mem2reg_opt(obj, Address(obj, Klass::java_mirror_offset()));
2476     __ resolve_oop_handle(obj);
2477   }
2478 }
2479 
2480 void TemplateTable::load_invoke_cp_cache_entry(int byte_no,
2481                                                Register method,
2482                                                Register itable_index,
2483                                                Register flags,
2484                                                bool is_invokevirtual,
2485                                                bool is_invokevfinal, // unused
2486                                                bool is_invokedynamic) {
2487   BLOCK_COMMENT(&quot;load_invoke_cp_cache_entry {&quot;);
2488   // Setup registers.
2489   const Register cache     = Z_ARG1;
2490   const Register cpe_offset= flags;
2491   const ByteSize base_off  = ConstantPoolCache::base_offset();
2492   const ByteSize f1_off    = ConstantPoolCacheEntry::f1_offset();
2493   const ByteSize f2_off    = ConstantPoolCacheEntry::f2_offset();
2494   const ByteSize flags_off = ConstantPoolCacheEntry::flags_offset();
2495   const int method_offset  = in_bytes(base_off + ((byte_no == f2_byte) ? f2_off : f1_off));
2496   const int flags_offset   = in_bytes(base_off + flags_off);
2497   // Access constant pool cache fields.
2498   const int index_offset   = in_bytes(base_off + f2_off);
2499 
2500   assert_different_registers(method, itable_index, flags, cache);
2501   assert(is_invokevirtual == (byte_no == f2_byte), &quot;is_invokevirtual flag redundant&quot;);
2502 
2503   if (is_invokevfinal) {
2504     // Already resolved.
2505      assert(itable_index == noreg, &quot;register not used&quot;);
2506      __ get_cache_and_index_at_bcp(cache, cpe_offset, 1);
2507   } else {
2508     // Need to resolve.
2509     resolve_cache_and_index(byte_no, cache, cpe_offset, is_invokedynamic ? sizeof(u4) : sizeof(u2));
2510   }
2511   __ z_lg(method, Address(cache, cpe_offset, method_offset));
2512 
2513   if (itable_index != noreg) {
2514     __ z_lg(itable_index, Address(cache, cpe_offset, index_offset));
2515   }
2516 
2517   // Only load the lower 4 bytes and fill high bytes of flags with zeros.
2518   // Callers depend on this zero-extension!!!
2519   // Attention: overwrites cpe_offset == flags
2520   __ z_llgf(flags, Address(cache, cpe_offset, flags_offset + (BytesPerLong-BytesPerInt)));
2521 
2522   BLOCK_COMMENT(&quot;} load_invoke_cp_cache_entry&quot;);
2523 }
2524 
2525 // The registers cache and index expected to be set before call.
2526 // Correct values of the cache and index registers are preserved.
2527 void TemplateTable::jvmti_post_field_access(Register cache, Register index,
2528                                             bool is_static, bool has_tos) {
2529 
2530   // Do the JVMTI work here to avoid disturbing the register state below.
2531   // We use c_rarg registers here because we want to use the register used in
2532   // the call to the VM
2533   if (!JvmtiExport::can_post_field_access()) {
2534     return;
2535   }
2536 
2537   // Check to see if a field access watch has been set before we
2538   // take the time to call into the VM.
2539   Label exit;
2540   assert_different_registers(cache, index, Z_tos);
2541   __ load_absolute_address(Z_tos, (address)JvmtiExport::get_field_access_count_addr());
2542   __ load_and_test_int(Z_R0, Address(Z_tos));
2543   __ z_brz(exit);
2544 
2545   // Index is returned as byte offset, do not shift!
2546   __ get_cache_and_index_at_bcp(Z_ARG3, Z_R1_scratch, 1);
2547 
2548   // cache entry pointer
2549   __ add2reg_with_index(Z_ARG3,
2550                         in_bytes(ConstantPoolCache::base_offset()),
2551                         Z_ARG3, Z_R1_scratch);
2552 
2553   if (is_static) {
2554     __ clear_reg(Z_ARG2, true, false); // NULL object reference. Don&#39;t set CC.
2555   } else {
2556     __ mem2reg_opt(Z_ARG2, at_tos());  // Get object pointer without popping it.
2557     __ verify_oop(Z_ARG2);
2558   }
2559   // Z_ARG2: object pointer or NULL
2560   // Z_ARG3: cache entry pointer
2561   __ call_VM(noreg,
2562              CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access),
2563              Z_ARG2, Z_ARG3);
2564   __ get_cache_and_index_at_bcp(cache, index, 1);
2565 
2566   __ bind(exit);
2567 }
2568 
2569 void TemplateTable::pop_and_check_object(Register r) {
2570   __ pop_ptr(r);
2571   __ null_check(r);  // for field access must check obj.
2572   __ verify_oop(r);
2573 }
2574 
2575 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2576   transition(vtos, vtos);
2577 
2578   const Register cache = Z_tmp_1;
2579   const Register index = Z_tmp_2;
2580   const Register obj   = Z_tmp_1;
2581   const Register off   = Z_ARG2;
2582   const Register flags = Z_ARG1;
2583   const Register bc    = Z_tmp_1;  // Uses same reg as obj, so don&#39;t mix them.
2584 
2585   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2586   jvmti_post_field_access(cache, index, is_static, false);
2587   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
2588 
2589   if (!is_static) {
2590     // Obj is on the stack.
2591     pop_and_check_object(obj);
2592   }
2593 
2594   // Displacement is 0, so any store instruction will be fine on any CPU.
2595   const Address field(obj, off);
2596 
2597   Label    is_Byte, is_Bool, is_Int, is_Short, is_Char,
2598            is_Long, is_Float, is_Object, is_Double;
2599   Label    is_badState8, is_badState9, is_badStateA, is_badStateB,
2600            is_badStateC, is_badStateD, is_badStateE, is_badStateF,
2601            is_badState;
2602   Label    branchTable, atosHandler,  Done;
2603   Register br_tab       = Z_R1_scratch;
2604   bool     do_rewrite   = !is_static &amp;&amp; (rc == may_rewrite);
2605   bool     dont_rewrite = (is_static || (rc == may_not_rewrite));
2606 
2607   assert(do_rewrite == !dont_rewrite, &quot;Oops, code is not fit for that&quot;);
2608   assert(btos == 0, &quot;change code, btos != 0&quot;);
2609 
2610   // Calculate branch table size. Generated code size depends on ASSERT and on bytecode rewriting.
2611 #ifdef ASSERT
2612   const unsigned int bsize = dont_rewrite ? BTB_MINSIZE*1 : BTB_MINSIZE*4;
2613 #else
2614   const unsigned int bsize = dont_rewrite ? BTB_MINSIZE*1 : BTB_MINSIZE*4;
2615 #endif
2616 
2617   // Calculate address of branch table entry and branch there.
2618   {
2619     const int bit_shift = exact_log2(bsize); // Size of each branch table entry.
2620     const int r_bitpos  = 63 - bit_shift;
2621     const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::tos_state_bits + 1;
2622     const int n_rotate  = (bit_shift-ConstantPoolCacheEntry::tos_state_shift);
2623     __ z_larl(br_tab, branchTable);
2624     __ rotate_then_insert(flags, flags, l_bitpos, r_bitpos, n_rotate, true);
2625   }
2626   __ z_bc(Assembler::bcondAlways, 0, flags, br_tab);
2627 
2628   __ align_address(bsize);
2629   BIND(branchTable);
2630 
2631   // btos
2632   BTB_BEGIN(is_Byte, bsize, &quot;getfield_or_static:is_Byte&quot;);
2633   __ z_lb(Z_tos, field);
2634   __ push(btos);
2635   // Rewrite bytecode to be faster.
2636   if (do_rewrite) {
2637     patch_bytecode(Bytecodes::_fast_bgetfield, bc, Z_ARG5);
2638   }
2639   __ z_bru(Done);
2640   BTB_END(is_Byte, bsize, &quot;getfield_or_static:is_Byte&quot;);
2641 
2642   // ztos
2643   BTB_BEGIN(is_Bool, bsize, &quot;getfield_or_static:is_Bool&quot;);
2644   __ z_lb(Z_tos, field);
2645   __ push(ztos);
2646   // Rewrite bytecode to be faster.
2647   if (do_rewrite) {
2648     // Use btos rewriting, no truncating to t/f bit is needed for getfield.
2649     patch_bytecode(Bytecodes::_fast_bgetfield, bc, Z_ARG5);
2650   }
2651   __ z_bru(Done);
2652   BTB_END(is_Bool, bsize, &quot;getfield_or_static:is_Bool&quot;);
2653 
2654   // ctos
2655   BTB_BEGIN(is_Char, bsize, &quot;getfield_or_static:is_Char&quot;);
2656   // Load into 64 bits, works on all CPUs.
2657   __ z_llgh(Z_tos, field);
2658   __ push(ctos);
2659   // Rewrite bytecode to be faster.
2660   if (do_rewrite) {
2661     patch_bytecode(Bytecodes::_fast_cgetfield, bc, Z_ARG5);
2662   }
2663   __ z_bru(Done);
2664   BTB_END(is_Char, bsize, &quot;getfield_or_static:is_Char&quot;);
2665 
2666   // stos
2667   BTB_BEGIN(is_Short, bsize, &quot;getfield_or_static:is_Short&quot;);
2668   __ z_lh(Z_tos, field);
2669   __ push(stos);
2670   // Rewrite bytecode to be faster.
2671   if (do_rewrite) {
2672     patch_bytecode(Bytecodes::_fast_sgetfield, bc, Z_ARG5);
2673   }
2674   __ z_bru(Done);
2675   BTB_END(is_Short, bsize, &quot;getfield_or_static:is_Short&quot;);
2676 
2677   // itos
2678   BTB_BEGIN(is_Int, bsize, &quot;getfield_or_static:is_Int&quot;);
2679   __ mem2reg_opt(Z_tos, field, false);
2680   __ push(itos);
2681   // Rewrite bytecode to be faster.
2682   if (do_rewrite) {
2683     patch_bytecode(Bytecodes::_fast_igetfield, bc, Z_ARG5);
2684   }
2685   __ z_bru(Done);
2686   BTB_END(is_Int, bsize, &quot;getfield_or_static:is_Int&quot;);
2687 
2688   // ltos
2689   BTB_BEGIN(is_Long, bsize, &quot;getfield_or_static:is_Long&quot;);
2690   __ mem2reg_opt(Z_tos, field);
2691   __ push(ltos);
2692   // Rewrite bytecode to be faster.
2693   if (do_rewrite) {
2694     patch_bytecode(Bytecodes::_fast_lgetfield, bc, Z_ARG5);
2695   }
2696   __ z_bru(Done);
2697   BTB_END(is_Long, bsize, &quot;getfield_or_static:is_Long&quot;);
2698 
2699   // ftos
2700   BTB_BEGIN(is_Float, bsize, &quot;getfield_or_static:is_Float&quot;);
2701   __ mem2freg_opt(Z_ftos, field, false);
2702   __ push(ftos);
2703   // Rewrite bytecode to be faster.
2704   if (do_rewrite) {
2705     patch_bytecode(Bytecodes::_fast_fgetfield, bc, Z_ARG5);
2706   }
2707   __ z_bru(Done);
2708   BTB_END(is_Float, bsize, &quot;getfield_or_static:is_Float&quot;);
2709 
2710   // dtos
2711   BTB_BEGIN(is_Double, bsize, &quot;getfield_or_static:is_Double&quot;);
2712   __ mem2freg_opt(Z_ftos, field);
2713   __ push(dtos);
2714   // Rewrite bytecode to be faster.
2715   if (do_rewrite) {
2716     patch_bytecode(Bytecodes::_fast_dgetfield, bc, Z_ARG5);
2717   }
2718   __ z_bru(Done);
2719   BTB_END(is_Double, bsize, &quot;getfield_or_static:is_Double&quot;);
2720 
2721   // atos
2722   BTB_BEGIN(is_Object, bsize, &quot;getfield_or_static:is_Object&quot;);
2723   __ z_bru(atosHandler);
2724   BTB_END(is_Object, bsize, &quot;getfield_or_static:is_Object&quot;);
2725 
2726   // Bad state detection comes at no extra runtime cost.
2727   BTB_BEGIN(is_badState8, bsize, &quot;getfield_or_static:is_badState8&quot;);
2728   __ z_illtrap();
2729   __ z_bru(is_badState);
2730   BTB_END( is_badState8, bsize, &quot;getfield_or_static:is_badState8&quot;);
2731   BTB_BEGIN(is_badState9, bsize, &quot;getfield_or_static:is_badState9&quot;);
2732   __ z_illtrap();
2733   __ z_bru(is_badState);
2734   BTB_END( is_badState9, bsize, &quot;getfield_or_static:is_badState9&quot;);
2735   BTB_BEGIN(is_badStateA, bsize, &quot;getfield_or_static:is_badStateA&quot;);
2736   __ z_illtrap();
2737   __ z_bru(is_badState);
2738   BTB_END( is_badStateA, bsize, &quot;getfield_or_static:is_badStateA&quot;);
2739   BTB_BEGIN(is_badStateB, bsize, &quot;getfield_or_static:is_badStateB&quot;);
2740   __ z_illtrap();
2741   __ z_bru(is_badState);
2742   BTB_END( is_badStateB, bsize, &quot;getfield_or_static:is_badStateB&quot;);
2743   BTB_BEGIN(is_badStateC, bsize, &quot;getfield_or_static:is_badStateC&quot;);
2744   __ z_illtrap();
2745   __ z_bru(is_badState);
2746   BTB_END( is_badStateC, bsize, &quot;getfield_or_static:is_badStateC&quot;);
2747   BTB_BEGIN(is_badStateD, bsize, &quot;getfield_or_static:is_badStateD&quot;);
2748   __ z_illtrap();
2749   __ z_bru(is_badState);
2750   BTB_END( is_badStateD, bsize, &quot;getfield_or_static:is_badStateD&quot;);
2751   BTB_BEGIN(is_badStateE, bsize, &quot;getfield_or_static:is_badStateE&quot;);
2752   __ z_illtrap();
2753   __ z_bru(is_badState);
2754   BTB_END( is_badStateE, bsize, &quot;getfield_or_static:is_badStateE&quot;);
2755   BTB_BEGIN(is_badStateF, bsize, &quot;getfield_or_static:is_badStateF&quot;);
2756   __ z_illtrap();
2757   __ z_bru(is_badState);
2758   BTB_END( is_badStateF, bsize, &quot;getfield_or_static:is_badStateF&quot;);
2759 
2760   __ align_address(64);
2761   BIND(is_badState);  // Do this outside branch table. Needs a lot of space.
2762   {
2763     unsigned int b_off = __ offset();
2764     if (is_static) {
2765       __ stop_static(&quot;Bad state in getstatic&quot;);
2766     } else {
2767       __ stop_static(&quot;Bad state in getfield&quot;);
2768     }
2769     unsigned int e_off = __ offset();
2770   }
2771 
2772   __ align_address(64);
2773   BIND(atosHandler);  // Oops are really complicated to handle.
2774                       // There is a lot of code generated.
2775                       // Therefore: generate the handler outside of branch table.
2776                       // There is no performance penalty. The additional branch
2777                       // to here is compensated for by the fallthru to &quot;Done&quot;.
2778   {
2779     unsigned int b_off = __ offset();
2780     do_oop_load(_masm, field, Z_tos, Z_tmp_2, Z_tmp_3, IN_HEAP);
2781     __ verify_oop(Z_tos);
2782     __ push(atos);
2783     if (do_rewrite) {
2784       patch_bytecode(Bytecodes::_fast_agetfield, bc, Z_ARG5);
2785     }
2786     unsigned int e_off = __ offset();
2787   }
2788 
2789   BIND(Done);
2790 }
2791 
2792 void TemplateTable::getfield(int byte_no) {
2793   BLOCK_COMMENT(&quot;getfield  {&quot;);
2794   getfield_or_static(byte_no, false);
2795   BLOCK_COMMENT(&quot;} getfield&quot;);
2796 }
2797 
2798 void TemplateTable::nofast_getfield(int byte_no) {
2799   getfield_or_static(byte_no, false, may_not_rewrite);
2800 }
2801 
2802 void TemplateTable::getstatic(int byte_no) {
2803   BLOCK_COMMENT(&quot;getstatic {&quot;);
2804   getfield_or_static(byte_no, true);
2805   BLOCK_COMMENT(&quot;} getstatic&quot;);
2806 }
2807 
2808 // The registers cache and index expected to be set before call.  The
2809 // function may destroy various registers, just not the cache and
2810 // index registers.
2811 void TemplateTable::jvmti_post_field_mod(Register cache,
2812                                          Register index, bool is_static) {
2813   transition(vtos, vtos);
2814 
2815   if (!JvmtiExport::can_post_field_modification()) {
2816     return;
2817   }
2818 
2819   BLOCK_COMMENT(&quot;jvmti_post_field_mod {&quot;);
2820 
2821   // Check to see if a field modification watch has been set before
2822   // we take the time to call into the VM.
2823   Label    L1;
2824   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2825   assert_different_registers(cache, index, Z_tos);
2826 
2827   __ load_absolute_address(Z_tos, (address)JvmtiExport::get_field_modification_count_addr());
2828   __ load_and_test_int(Z_R0, Address(Z_tos));
2829   __ z_brz(L1);
2830 
2831   // Index is returned as byte offset, do not shift!
2832   __ get_cache_and_index_at_bcp(Z_ARG3, Z_R1_scratch, 1);
2833 
2834   if (is_static) {
2835     // Life is simple. Null out the object pointer.
2836     __ clear_reg(Z_ARG2, true, false);   // Don&#39;t set CC.
2837   } else {
2838     // Life is harder. The stack holds the value on top, followed by
2839     // the object. We don&#39;t know the size of the value, though. It
2840     // could be one or two words depending on its type. As a result,
2841     // we must find the type to determine where the object is.
2842     __ mem2reg_opt(Z_ARG4,
2843                    Address(Z_ARG3, Z_R1_scratch,
2844                            in_bytes(cp_base_offset + ConstantPoolCacheEntry::flags_offset()) +
2845                            (BytesPerLong - BytesPerInt)),
2846                    false);
2847     __ z_srl(Z_ARG4, ConstantPoolCacheEntry::tos_state_shift);
2848     // Make sure we don&#39;t need to mask Z_ARG4 for tos_state after the above shift.
2849     ConstantPoolCacheEntry::verify_tos_state_shift();
2850     __ mem2reg_opt(Z_ARG2, at_tos(1));  // Initially assume a one word jvalue.
2851 
2852     NearLabel   load_dtos, cont;
2853 
2854     __ compareU32_and_branch(Z_ARG4, (intptr_t) ltos,
2855                               Assembler::bcondNotEqual, load_dtos);
2856     __ mem2reg_opt(Z_ARG2, at_tos(2)); // ltos (two word jvalue)
2857     __ z_bru(cont);
2858 
2859     __ bind(load_dtos);
2860     __ compareU32_and_branch(Z_ARG4, (intptr_t)dtos, Assembler::bcondNotEqual, cont);
2861     __ mem2reg_opt(Z_ARG2, at_tos(2)); // dtos (two word jvalue)
2862 
2863     __ bind(cont);
2864   }
2865   // cache entry pointer
2866 
2867   __ add2reg_with_index(Z_ARG3, in_bytes(cp_base_offset), Z_ARG3, Z_R1_scratch);
2868 
2869   // object(tos)
2870   __ load_address(Z_ARG4, Address(Z_esp, Interpreter::stackElementSize));
2871   // Z_ARG2: object pointer set up above (NULL if static)
2872   // Z_ARG3: cache entry pointer
2873   // Z_ARG4: jvalue object on the stack
2874   __ call_VM(noreg,
2875              CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification),
2876              Z_ARG2, Z_ARG3, Z_ARG4);
2877   __ get_cache_and_index_at_bcp(cache, index, 1);
2878 
2879   __ bind(L1);
2880   BLOCK_COMMENT(&quot;} jvmti_post_field_mod&quot;);
2881 }
2882 
2883 
2884 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2885   transition(vtos, vtos);
2886 
2887   const Register cache         = Z_tmp_1;
2888   const Register index         = Z_ARG5;
2889   const Register obj           = Z_tmp_1;
2890   const Register off           = Z_tmp_2;
2891   const Register flags         = Z_R1_scratch;
2892   const Register br_tab        = Z_ARG5;
2893   const Register bc            = Z_tmp_1;
2894   const Register oopStore_tmp1 = Z_R1_scratch;
2895   const Register oopStore_tmp2 = Z_ARG5;
2896   const Register oopStore_tmp3 = Z_R0_scratch;
2897 
2898   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2899   jvmti_post_field_mod(cache, index, is_static);
2900   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
2901   // begin of life for:
2902   //   obj, off   long life range
2903   //   flags      short life range, up to branch into branch table
2904   // end of life for:
2905   //   cache, index
2906 
2907   const Address field(obj, off);
2908   Label is_Byte, is_Bool, is_Int, is_Short, is_Char,
2909         is_Long, is_Float, is_Object, is_Double;
2910   Label is_badState8, is_badState9, is_badStateA, is_badStateB,
2911         is_badStateC, is_badStateD, is_badStateE, is_badStateF,
2912         is_badState;
2913   Label branchTable, atosHandler, Done;
2914   bool  do_rewrite   = !is_static &amp;&amp; (rc == may_rewrite);
2915   bool  dont_rewrite = (is_static || (rc == may_not_rewrite));
2916 
2917   assert(do_rewrite == !dont_rewrite, &quot;Oops, code is not fit for that&quot;);
2918 
2919   assert(btos == 0, &quot;change code, btos != 0&quot;);
2920 
2921 #ifdef ASSERT
2922   const unsigned int bsize = is_static ? BTB_MINSIZE*1 : BTB_MINSIZE*4;
2923 #else
2924   const unsigned int bsize = is_static ? BTB_MINSIZE*1 : BTB_MINSIZE*8;
2925 #endif
2926 
2927   // Calculate address of branch table entry and branch there.
2928   {
2929     const int bit_shift = exact_log2(bsize); // Size of each branch table entry.
2930     const int r_bitpos  = 63 - bit_shift;
2931     const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::tos_state_bits + 1;
2932     const int n_rotate  = (bit_shift-ConstantPoolCacheEntry::tos_state_shift);
2933     __ z_larl(br_tab, branchTable);
2934     __ rotate_then_insert(flags, flags, l_bitpos, r_bitpos, n_rotate, true);
2935     __ z_bc(Assembler::bcondAlways, 0, flags, br_tab);
2936   }
2937   // end of life for:
2938   //   flags, br_tab
2939 
2940   __ align_address(bsize);
2941   BIND(branchTable);
2942 
2943   // btos
2944   BTB_BEGIN(is_Byte, bsize, &quot;putfield_or_static:is_Byte&quot;);
2945   __ pop(btos);
2946   if (!is_static) {
2947     pop_and_check_object(obj);
2948   }
2949   __ z_stc(Z_tos, field);
2950   if (do_rewrite) {
2951     patch_bytecode(Bytecodes::_fast_bputfield, bc, Z_ARG5, true, byte_no);
2952   }
2953   __ z_bru(Done);
2954   BTB_END( is_Byte, bsize, &quot;putfield_or_static:is_Byte&quot;);
2955 
2956   // ztos
2957   BTB_BEGIN(is_Bool, bsize, &quot;putfield_or_static:is_Bool&quot;);
2958   __ pop(ztos);
2959   if (!is_static) {
2960     pop_and_check_object(obj);
2961   }
2962   __ z_nilf(Z_tos, 0x1);
2963   __ z_stc(Z_tos, field);
2964   if (do_rewrite) {
2965     patch_bytecode(Bytecodes::_fast_zputfield, bc, Z_ARG5, true, byte_no);
2966   }
2967   __ z_bru(Done);
2968   BTB_END(is_Bool, bsize, &quot;putfield_or_static:is_Bool&quot;);
2969 
2970   // ctos
2971   BTB_BEGIN(is_Char, bsize, &quot;putfield_or_static:is_Char&quot;);
2972   __ pop(ctos);
2973   if (!is_static) {
2974     pop_and_check_object(obj);
2975   }
2976   __ z_sth(Z_tos, field);
2977   if (do_rewrite) {
2978     patch_bytecode(Bytecodes::_fast_cputfield, bc, Z_ARG5, true, byte_no);
2979   }
2980   __ z_bru(Done);
2981   BTB_END( is_Char, bsize, &quot;putfield_or_static:is_Char&quot;);
2982 
2983   // stos
2984   BTB_BEGIN(is_Short, bsize, &quot;putfield_or_static:is_Short&quot;);
2985   __ pop(stos);
2986   if (!is_static) {
2987     pop_and_check_object(obj);
2988   }
2989   __ z_sth(Z_tos, field);
2990   if (do_rewrite) {
2991     patch_bytecode(Bytecodes::_fast_sputfield, bc, Z_ARG5, true, byte_no);
2992   }
2993   __ z_bru(Done);
2994   BTB_END( is_Short, bsize, &quot;putfield_or_static:is_Short&quot;);
2995 
2996   // itos
2997   BTB_BEGIN(is_Int, bsize, &quot;putfield_or_static:is_Int&quot;);
2998   __ pop(itos);
2999   if (!is_static) {
3000     pop_and_check_object(obj);
3001   }
3002   __ reg2mem_opt(Z_tos, field, false);
3003   if (do_rewrite) {
3004     patch_bytecode(Bytecodes::_fast_iputfield, bc, Z_ARG5, true, byte_no);
3005   }
3006   __ z_bru(Done);
3007   BTB_END( is_Int, bsize, &quot;putfield_or_static:is_Int&quot;);
3008 
3009   // ltos
3010   BTB_BEGIN(is_Long, bsize, &quot;putfield_or_static:is_Long&quot;);
3011   __ pop(ltos);
3012   if (!is_static) {
3013     pop_and_check_object(obj);
3014   }
3015   __ reg2mem_opt(Z_tos, field);
3016   if (do_rewrite) {
3017     patch_bytecode(Bytecodes::_fast_lputfield, bc, Z_ARG5, true, byte_no);
3018   }
3019   __ z_bru(Done);
3020   BTB_END( is_Long, bsize, &quot;putfield_or_static:is_Long&quot;);
3021 
3022   // ftos
3023   BTB_BEGIN(is_Float, bsize, &quot;putfield_or_static:is_Float&quot;);
3024   __ pop(ftos);
3025   if (!is_static) {
3026     pop_and_check_object(obj);
3027   }
3028   __ freg2mem_opt(Z_ftos, field, false);
3029   if (do_rewrite) {
3030     patch_bytecode(Bytecodes::_fast_fputfield, bc, Z_ARG5, true, byte_no);
3031   }
3032   __ z_bru(Done);
3033   BTB_END( is_Float, bsize, &quot;putfield_or_static:is_Float&quot;);
3034 
3035   // dtos
3036   BTB_BEGIN(is_Double, bsize, &quot;putfield_or_static:is_Double&quot;);
3037   __ pop(dtos);
3038   if (!is_static) {
3039     pop_and_check_object(obj);
3040   }
3041   __ freg2mem_opt(Z_ftos, field);
3042   if (do_rewrite) {
3043     patch_bytecode(Bytecodes::_fast_dputfield, bc, Z_ARG5, true, byte_no);
3044   }
3045   __ z_bru(Done);
3046   BTB_END( is_Double, bsize, &quot;putfield_or_static:is_Double&quot;);
3047 
3048   // atos
3049   BTB_BEGIN(is_Object, bsize, &quot;putfield_or_static:is_Object&quot;);
3050   __ z_bru(atosHandler);
3051   BTB_END( is_Object, bsize, &quot;putfield_or_static:is_Object&quot;);
3052 
3053   // Bad state detection comes at no extra runtime cost.
3054   BTB_BEGIN(is_badState8, bsize, &quot;putfield_or_static:is_badState8&quot;);
3055   __ z_illtrap();
3056   __ z_bru(is_badState);
3057   BTB_END( is_badState8, bsize, &quot;putfield_or_static:is_badState8&quot;);
3058   BTB_BEGIN(is_badState9, bsize, &quot;putfield_or_static:is_badState9&quot;);
3059   __ z_illtrap();
3060   __ z_bru(is_badState);
3061   BTB_END( is_badState9, bsize, &quot;putfield_or_static:is_badState9&quot;);
3062   BTB_BEGIN(is_badStateA, bsize, &quot;putfield_or_static:is_badStateA&quot;);
3063   __ z_illtrap();
3064   __ z_bru(is_badState);
3065   BTB_END( is_badStateA, bsize, &quot;putfield_or_static:is_badStateA&quot;);
3066   BTB_BEGIN(is_badStateB, bsize, &quot;putfield_or_static:is_badStateB&quot;);
3067   __ z_illtrap();
3068   __ z_bru(is_badState);
3069   BTB_END( is_badStateB, bsize, &quot;putfield_or_static:is_badStateB&quot;);
3070   BTB_BEGIN(is_badStateC, bsize, &quot;putfield_or_static:is_badStateC&quot;);
3071   __ z_illtrap();
3072   __ z_bru(is_badState);
3073   BTB_END( is_badStateC, bsize, &quot;putfield_or_static:is_badStateC&quot;);
3074   BTB_BEGIN(is_badStateD, bsize, &quot;putfield_or_static:is_badStateD&quot;);
3075   __ z_illtrap();
3076   __ z_bru(is_badState);
3077   BTB_END( is_badStateD, bsize, &quot;putfield_or_static:is_badStateD&quot;);
3078   BTB_BEGIN(is_badStateE, bsize, &quot;putfield_or_static:is_badStateE&quot;);
3079   __ z_illtrap();
3080   __ z_bru(is_badState);
3081   BTB_END( is_badStateE, bsize, &quot;putfield_or_static:is_badStateE&quot;);
3082   BTB_BEGIN(is_badStateF, bsize, &quot;putfield_or_static:is_badStateF&quot;);
3083   __ z_illtrap();
3084   __ z_bru(is_badState);
3085   BTB_END( is_badStateF, bsize, &quot;putfield_or_static:is_badStateF&quot;);
3086 
3087   __ align_address(64);
3088   BIND(is_badState);  // Do this outside branch table. Needs a lot of space.
3089   {
3090     unsigned int b_off = __ offset();
3091     if (is_static) __ stop_static(&quot;Bad state in putstatic&quot;);
3092     else            __ stop_static(&quot;Bad state in putfield&quot;);
3093     unsigned int e_off = __ offset();
3094   }
3095 
3096   __ align_address(64);
3097   BIND(atosHandler);  // Oops are really complicated to handle.
3098                       // There is a lot of code generated.
3099                       // Therefore: generate the handler outside of branch table.
3100                       // There is no performance penalty. The additional branch
3101                       // to here is compensated for by the fallthru to &quot;Done&quot;.
3102   {
3103     unsigned int b_off = __ offset();
3104     __ pop(atos);
3105     if (!is_static) {
3106       pop_and_check_object(obj);
3107     }
3108     // Store into the field
3109     do_oop_store(_masm, Address(obj, off), Z_tos,
3110                  oopStore_tmp1, oopStore_tmp2, oopStore_tmp3, IN_HEAP);
3111     if (do_rewrite) {
3112       patch_bytecode(Bytecodes::_fast_aputfield, bc, Z_ARG5, true, byte_no);
3113     }
3114     // __ z_bru(Done); // fallthru
3115     unsigned int e_off = __ offset();
3116   }
3117 
3118   BIND(Done);
3119 
3120   // Check for volatile store.
3121   Label notVolatile;
3122 
3123   __ testbit(Z_ARG4, ConstantPoolCacheEntry::is_volatile_shift);
3124   __ z_brz(notVolatile);
3125   __ z_fence();
3126 
3127   BIND(notVolatile);
3128 }
3129 
3130 void TemplateTable::putfield(int byte_no) {
3131   BLOCK_COMMENT(&quot;putfield  {&quot;);
3132   putfield_or_static(byte_no, false);
3133   BLOCK_COMMENT(&quot;} putfield&quot;);
3134 }
3135 
3136 void TemplateTable::nofast_putfield(int byte_no) {
3137   putfield_or_static(byte_no, false, may_not_rewrite);
3138 }
3139 
3140 void TemplateTable::putstatic(int byte_no) {
3141   BLOCK_COMMENT(&quot;putstatic {&quot;);
3142   putfield_or_static(byte_no, true);
3143   BLOCK_COMMENT(&quot;} putstatic&quot;);
3144 }
3145 
3146 // Push the tos value back to the stack.
3147 // gc will find oops there and update.
3148 void TemplateTable::jvmti_post_fast_field_mod() {
3149 
3150   if (!JvmtiExport::can_post_field_modification()) {
3151     return;
3152   }
3153 
3154   // Check to see if a field modification watch has been set before
3155   // we take the time to call into the VM.
3156   Label   exit;
3157 
3158   BLOCK_COMMENT(&quot;jvmti_post_fast_field_mod {&quot;);
3159 
3160   __ load_absolute_address(Z_R1_scratch,
3161                            (address) JvmtiExport::get_field_modification_count_addr());
3162   __ load_and_test_int(Z_R0_scratch, Address(Z_R1_scratch));
3163   __ z_brz(exit);
3164 
3165   Register obj = Z_tmp_1;
3166 
3167   __ pop_ptr(obj);                  // Copy the object pointer from tos.
3168   __ verify_oop(obj);
3169   __ push_ptr(obj);                 // Put the object pointer back on tos.
3170 
3171   // Save tos values before call_VM() clobbers them. Since we have
3172   // to do it for every data type, we use the saved values as the
3173   // jvalue object.
3174   switch (bytecode()) {          // Load values into the jvalue object.
3175     case Bytecodes::_fast_aputfield:
3176       __ push_ptr(Z_tos);
3177       break;
3178     case Bytecodes::_fast_bputfield:
3179     case Bytecodes::_fast_zputfield:
3180     case Bytecodes::_fast_sputfield:
3181     case Bytecodes::_fast_cputfield:
3182     case Bytecodes::_fast_iputfield:
3183       __ push_i(Z_tos);
3184       break;
3185     case Bytecodes::_fast_dputfield:
3186       __ push_d();
3187       break;
3188     case Bytecodes::_fast_fputfield:
3189       __ push_f();
3190       break;
3191     case Bytecodes::_fast_lputfield:
3192       __ push_l(Z_tos);
3193       break;
3194 
3195     default:
3196       ShouldNotReachHere();
3197   }
3198 
3199   // jvalue on the stack
3200   __ load_address(Z_ARG4, Address(Z_esp, Interpreter::stackElementSize));
3201   // Access constant pool cache entry.
3202   __ get_cache_entry_pointer_at_bcp(Z_ARG3, Z_tos, 1);
3203   __ verify_oop(obj);
3204 
3205   // obj   : object pointer copied above
3206   // Z_ARG3: cache entry pointer
3207   // Z_ARG4: jvalue object on the stack
3208   __ call_VM(noreg,
3209              CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification),
3210              obj, Z_ARG3, Z_ARG4);
3211 
3212   switch (bytecode()) {             // Restore tos values.
3213     case Bytecodes::_fast_aputfield:
3214       __ pop_ptr(Z_tos);
3215       break;
3216     case Bytecodes::_fast_bputfield:
3217     case Bytecodes::_fast_zputfield:
3218     case Bytecodes::_fast_sputfield:
3219     case Bytecodes::_fast_cputfield:
3220     case Bytecodes::_fast_iputfield:
3221       __ pop_i(Z_tos);
3222       break;
3223     case Bytecodes::_fast_dputfield:
3224       __ pop_d(Z_ftos);
3225       break;
3226     case Bytecodes::_fast_fputfield:
3227       __ pop_f(Z_ftos);
3228       break;
3229     case Bytecodes::_fast_lputfield:
3230       __ pop_l(Z_tos);
3231       break;
3232     default:
3233       break;
3234   }
3235 
3236   __ bind(exit);
3237   BLOCK_COMMENT(&quot;} jvmti_post_fast_field_mod&quot;);
3238 }
3239 
3240 void TemplateTable::fast_storefield(TosState state) {
3241   transition(state, vtos);
3242 
3243   ByteSize base = ConstantPoolCache::base_offset();
3244   jvmti_post_fast_field_mod();
3245 
3246   // Access constant pool cache.
3247   Register cache = Z_tmp_1;
3248   Register index = Z_tmp_2;
3249   Register flags = Z_ARG5;
3250 
3251   // Index comes in bytes, don&#39;t shift afterwards!
3252   __ get_cache_and_index_at_bcp(cache, index, 1);
3253 
3254   // Test for volatile.
3255   assert(!flags-&gt;is_volatile(), &quot;do_oop_store could perform leaf RT call&quot;);
3256   __ z_lg(flags, Address(cache, index, base + ConstantPoolCacheEntry::flags_offset()));
3257 
3258   // Replace index with field offset from cache entry.
3259   Register field_offset = index;
3260   __ z_lg(field_offset, Address(cache, index, base + ConstantPoolCacheEntry::f2_offset()));
3261 
3262   // Get object from stack.
3263   Register   obj = cache;
3264 
3265   pop_and_check_object(obj);
3266 
3267   // field address
3268   const Address   field(obj, field_offset);
3269 
3270   // access field
3271   switch (bytecode()) {
3272     case Bytecodes::_fast_aputfield:
3273       do_oop_store(_masm, Address(obj, field_offset), Z_tos,
3274                    Z_ARG2, Z_ARG3, Z_ARG4, IN_HEAP);
3275       break;
3276     case Bytecodes::_fast_lputfield:
3277       __ reg2mem_opt(Z_tos, field);
3278       break;
3279     case Bytecodes::_fast_iputfield:
3280       __ reg2mem_opt(Z_tos, field, false);
3281       break;
3282     case Bytecodes::_fast_zputfield:
3283       __ z_nilf(Z_tos, 0x1);
3284       // fall through to bputfield
3285     case Bytecodes::_fast_bputfield:
3286       __ z_stc(Z_tos, field);
3287       break;
3288     case Bytecodes::_fast_sputfield:
3289       // fall through
3290     case Bytecodes::_fast_cputfield:
3291       __ z_sth(Z_tos, field);
3292       break;
3293     case Bytecodes::_fast_fputfield:
3294       __ freg2mem_opt(Z_ftos, field, false);
3295       break;
3296     case Bytecodes::_fast_dputfield:
3297       __ freg2mem_opt(Z_ftos, field);
3298       break;
3299     default:
3300       ShouldNotReachHere();
3301   }
3302 
3303   //  Check for volatile store.
3304   Label notVolatile;
3305 
3306   __ testbit(flags, ConstantPoolCacheEntry::is_volatile_shift);
3307   __ z_brz(notVolatile);
3308   __ z_fence();
3309 
3310   __ bind(notVolatile);
3311 }
3312 
3313 void TemplateTable::fast_accessfield(TosState state) {
3314   transition(atos, state);
3315 
3316   Register obj = Z_tos;
3317 
3318   // Do the JVMTI work here to avoid disturbing the register state below
3319   if (JvmtiExport::can_post_field_access()) {
3320     // Check to see if a field access watch has been set before we
3321     // take the time to call into the VM.
3322     Label cont;
3323 
3324     __ load_absolute_address(Z_R1_scratch,
3325                              (address)JvmtiExport::get_field_access_count_addr());
3326     __ load_and_test_int(Z_R0_scratch, Address(Z_R1_scratch));
3327     __ z_brz(cont);
3328 
3329     // Access constant pool cache entry.
3330 
3331     __ get_cache_entry_pointer_at_bcp(Z_ARG3, Z_tmp_1, 1);
3332     __ verify_oop(obj);
3333     __ push_ptr(obj);  // Save object pointer before call_VM() clobbers it.
3334     __ z_lgr(Z_ARG2, obj);
3335 
3336     // Z_ARG2: object pointer copied above
3337     // Z_ARG3: cache entry pointer
3338     __ call_VM(noreg,
3339                CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access),
3340                Z_ARG2, Z_ARG3);
3341     __ pop_ptr(obj); // Restore object pointer.
3342 
3343     __ bind(cont);
3344   }
3345 
3346   // Access constant pool cache.
3347   Register   cache = Z_tmp_1;
3348   Register   index = Z_tmp_2;
3349 
3350   // Index comes in bytes, don&#39;t shift afterwards!
3351   __ get_cache_and_index_at_bcp(cache, index, 1);
3352   // Replace index with field offset from cache entry.
3353   __ mem2reg_opt(index,
3354                  Address(cache, index,
3355                          ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f2_offset()));
3356 
3357   __ verify_oop(obj);
3358   __ null_check(obj);
3359 
3360   Address field(obj, index);
3361 
3362   // access field
3363   switch (bytecode()) {
3364     case Bytecodes::_fast_agetfield:
3365       do_oop_load(_masm, field, Z_tos, Z_tmp_1, Z_tmp_2, IN_HEAP);
3366       __ verify_oop(Z_tos);
3367       return;
3368     case Bytecodes::_fast_lgetfield:
3369       __ mem2reg_opt(Z_tos, field);
3370       return;
3371     case Bytecodes::_fast_igetfield:
3372       __ mem2reg_opt(Z_tos, field, false);
3373       return;
3374     case Bytecodes::_fast_bgetfield:
3375       __ z_lb(Z_tos, field);
3376       return;
3377     case Bytecodes::_fast_sgetfield:
3378       __ z_lh(Z_tos, field);
3379       return;
3380     case Bytecodes::_fast_cgetfield:
3381       __ z_llgh(Z_tos, field);   // Load into 64 bits, works on all CPUs.
3382       return;
3383     case Bytecodes::_fast_fgetfield:
3384       __ mem2freg_opt(Z_ftos, field, false);
3385       return;
3386     case Bytecodes::_fast_dgetfield:
3387       __ mem2freg_opt(Z_ftos, field);
3388       return;
3389     default:
3390       ShouldNotReachHere();
3391   }
3392 }
3393 
3394 void TemplateTable::fast_xaccess(TosState state) {
3395   transition(vtos, state);
3396 
3397   Register receiver = Z_tos;
3398   // Get receiver.
3399   __ mem2reg_opt(Z_tos, aaddress(0));
3400 
3401   // Access constant pool cache.
3402   Register cache = Z_tmp_1;
3403   Register index = Z_tmp_2;
3404 
3405   // Index comes in bytes, don&#39;t shift afterwards!
3406   __ get_cache_and_index_at_bcp(cache, index, 2);
3407   // Replace index with field offset from cache entry.
3408   __ mem2reg_opt(index,
3409                  Address(cache, index,
3410                          ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f2_offset()));
3411 
3412   // Make sure exception is reported in correct bcp range (getfield is
3413   // next instruction).
3414   __ add2reg(Z_bcp, 1);
3415   __ null_check(receiver);
3416   switch (state) {
3417     case itos:
3418       __ mem2reg_opt(Z_tos, Address(receiver, index), false);
3419       break;
3420     case atos:
3421       do_oop_load(_masm, Address(receiver, index), Z_tos, Z_tmp_1, Z_tmp_2, IN_HEAP);
3422       __ verify_oop(Z_tos);
3423       break;
3424     case ftos:
3425       __ mem2freg_opt(Z_ftos, Address(receiver, index));
3426       break;
3427     default:
3428       ShouldNotReachHere();
3429   }
3430 
3431   // Reset bcp to original position.
3432   __ add2reg(Z_bcp, -1);
3433 }
3434 
3435 //-----------------------------------------------------------------------------
3436 // Calls
3437 
3438 void TemplateTable::prepare_invoke(int byte_no,
3439                                    Register method,  // linked method (or i-klass)
3440                                    Register index,   // itable index, MethodType, etc.
3441                                    Register recv,    // If caller wants to see it.
3442                                    Register flags) { // If caller wants to test it.
3443   // Determine flags.
3444   const Bytecodes::Code code = bytecode();
3445   const bool is_invokeinterface  = code == Bytecodes::_invokeinterface;
3446   const bool is_invokedynamic    = code == Bytecodes::_invokedynamic;
3447   const bool is_invokehandle     = code == Bytecodes::_invokehandle;
3448   const bool is_invokevirtual    = code == Bytecodes::_invokevirtual;
3449   const bool is_invokespecial    = code == Bytecodes::_invokespecial;
3450   const bool load_receiver       = (recv != noreg);
3451   assert(load_receiver == (code != Bytecodes::_invokestatic &amp;&amp; code != Bytecodes::_invokedynamic), &quot;&quot;);
3452 
3453   // Setup registers &amp; access constant pool cache.
3454   if (recv  == noreg) { recv  = Z_ARG1; }
3455   if (flags == noreg) { flags = Z_ARG2; }
3456   assert_different_registers(method, Z_R14, index, recv, flags);
3457 
3458   BLOCK_COMMENT(&quot;prepare_invoke {&quot;);
3459 
3460   load_invoke_cp_cache_entry(byte_no, method, index, flags, is_invokevirtual, false, is_invokedynamic);
3461 
3462   // Maybe push appendix to arguments.
3463   if (is_invokedynamic || is_invokehandle) {
3464     Label L_no_push;
3465     Register resolved_reference = Z_R1_scratch;
3466     __ testbit(flags, ConstantPoolCacheEntry::has_appendix_shift);
3467     __ z_bfalse(L_no_push);
3468     // Push the appendix as a trailing parameter.
3469     // This must be done before we get the receiver,
3470     // since the parameter_size includes it.
3471     __ load_resolved_reference_at_index(resolved_reference, index);
3472     __ verify_oop(resolved_reference);
3473     __ push_ptr(resolved_reference);  // Push appendix (MethodType, CallSite, etc.).
3474     __ bind(L_no_push);
3475   }
3476 
3477   // Load receiver if needed (after appendix is pushed so parameter size is correct).
3478   if (load_receiver) {
3479     assert(!is_invokedynamic, &quot;&quot;);
3480     // recv := int2long(flags &amp; ConstantPoolCacheEntry::parameter_size_mask) &lt;&lt; 3
3481     // Flags is zero-extended int2long when loaded during load_invoke_cp_cache_entry().
3482     // Only the least significant byte (psize) of flags is used.
3483     {
3484       const unsigned int logSES = Interpreter::logStackElementSize;
3485       const int bit_shift = logSES;
3486       const int r_bitpos  = 63 - bit_shift;
3487       const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::parameter_size_bits + 1;
3488       const int n_rotate  = bit_shift;
3489       assert(ConstantPoolCacheEntry::parameter_size_mask == 255, &quot;adapt bitpositions&quot;);
3490       __ rotate_then_insert(recv, flags, l_bitpos, r_bitpos, n_rotate, true);
3491     }
3492     // Recv now contains #arguments * StackElementSize.
3493 
3494     Address recv_addr(Z_esp, recv);
3495     __ z_lg(recv, recv_addr);
3496     __ verify_oop(recv);
3497   }
3498 
3499   // Compute return type.
3500   // ret_type is used by callers (invokespecial, invokestatic) at least.
3501   Register ret_type = Z_R1_scratch;
3502   assert_different_registers(ret_type, method);
3503 
3504   const address table_addr = (address)Interpreter::invoke_return_entry_table_for(code);
3505   __ load_absolute_address(Z_R14, table_addr);
3506 
3507   {
3508     const int bit_shift = LogBytesPerWord;           // Size of each table entry.
3509     const int r_bitpos  = 63 - bit_shift;
3510     const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::tos_state_bits + 1;
3511     const int n_rotate  = bit_shift-ConstantPoolCacheEntry::tos_state_shift;
3512     __ rotate_then_insert(ret_type, flags, l_bitpos, r_bitpos, n_rotate, true);
3513     // Make sure we don&#39;t need to mask flags for tos_state after the above shift.
3514     ConstantPoolCacheEntry::verify_tos_state_shift();
3515   }
3516 
3517     __ z_lg(Z_R14, Address(Z_R14, ret_type)); // Load return address.
3518   BLOCK_COMMENT(&quot;} prepare_invoke&quot;);
3519 }
3520 
3521 
3522 void TemplateTable::invokevirtual_helper(Register index,
3523                                          Register recv,
3524                                          Register flags) {
3525   // Uses temporary registers Z_tmp_2, Z_ARG4.
3526   assert_different_registers(index, recv, Z_tmp_2, Z_ARG4);
3527 
3528   // Test for an invoke of a final method.
3529   Label notFinal;
3530 
3531   BLOCK_COMMENT(&quot;invokevirtual_helper {&quot;);
3532 
3533   __ testbit(flags, ConstantPoolCacheEntry::is_vfinal_shift);
3534   __ z_brz(notFinal);
3535 
3536   const Register method = index;  // Method must be Z_ARG3.
3537   assert(method == Z_ARG3, &quot;method must be second argument for interpreter calling convention&quot;);
3538 
3539   // Do the call - the index is actually the method to call.
3540   // That is, f2 is a vtable index if !is_vfinal, else f2 is a method.
3541 
3542   // It&#39;s final, need a null check here!
3543   __ null_check(recv);
3544 
3545   // Profile this call.
3546   __ profile_final_call(Z_tmp_2);
3547   __ profile_arguments_type(Z_tmp_2, method, Z_ARG5, true); // Argument type profiling.
3548   __ jump_from_interpreted(method, Z_tmp_2);
3549 
3550   __ bind(notFinal);
3551 
3552   // Get receiver klass.
3553   __ null_check(recv, Z_R0_scratch, oopDesc::klass_offset_in_bytes());
3554   __ load_klass(Z_tmp_2, recv);
3555 
3556   // Profile this call.
3557   __ profile_virtual_call(Z_tmp_2, Z_ARG4, Z_ARG5);
3558 
3559   // Get target method &amp; entry point.
3560   __ z_sllg(index, index, exact_log2(vtableEntry::size_in_bytes()));
3561   __ mem2reg_opt(method,
3562                  Address(Z_tmp_2, index,
3563                          Klass::vtable_start_offset() + in_ByteSize(vtableEntry::method_offset_in_bytes())));
3564   __ profile_arguments_type(Z_ARG4, method, Z_ARG5, true);
3565   __ jump_from_interpreted(method, Z_ARG4);
3566   BLOCK_COMMENT(&quot;} invokevirtual_helper&quot;);
3567 }
3568 
3569 void TemplateTable::invokevirtual(int byte_no) {
3570   transition(vtos, vtos);
3571 
3572   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3573   prepare_invoke(byte_no,
3574                  Z_ARG3,  // method or vtable index
3575                  noreg,   // unused itable index
3576                  Z_ARG1,  // recv
3577                  Z_ARG2); // flags
3578 
3579   // Z_ARG3 : index
3580   // Z_ARG1 : receiver
3581   // Z_ARG2 : flags
3582   invokevirtual_helper(Z_ARG3, Z_ARG1, Z_ARG2);
3583 }
3584 
3585 void TemplateTable::invokespecial(int byte_no) {
3586   transition(vtos, vtos);
3587 
3588   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3589   Register Rmethod = Z_tmp_2;
3590   prepare_invoke(byte_no, Rmethod, noreg, // Get f1 method.
3591                  Z_ARG3);   // Get receiver also for null check.
3592   __ verify_oop(Z_ARG3);
3593   __ null_check(Z_ARG3);
3594   // Do the call.
3595   __ profile_call(Z_ARG2);
3596   __ profile_arguments_type(Z_ARG2, Rmethod, Z_ARG5, false);
3597   __ jump_from_interpreted(Rmethod, Z_R1_scratch);
3598 }
3599 
3600 void TemplateTable::invokestatic(int byte_no) {
3601   transition(vtos, vtos);
3602 
3603   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3604   Register Rmethod = Z_tmp_2;
3605   prepare_invoke(byte_no, Rmethod);   // Get f1 method.
3606   // Do the call.
3607   __ profile_call(Z_ARG2);
3608   __ profile_arguments_type(Z_ARG2, Rmethod, Z_ARG5, false);
3609   __ jump_from_interpreted(Rmethod, Z_R1_scratch);
3610 }
3611 
3612 // Outdated feature, and we don&#39;t support it.
3613 void TemplateTable::fast_invokevfinal(int byte_no) {
3614   transition(vtos, vtos);
3615   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3616   __ stop(&quot;fast_invokevfinal not used on linuxs390x&quot;);
3617 }
3618 
3619 void TemplateTable::invokeinterface(int byte_no) {
3620   transition(vtos, vtos);
3621 
3622   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3623   Register klass     = Z_ARG2,
3624            method    = Z_ARG3,
3625            interface = Z_ARG4,
3626            flags     = Z_ARG5,
3627            receiver  = Z_tmp_1;
3628 
3629   BLOCK_COMMENT(&quot;invokeinterface {&quot;);
3630 
3631   prepare_invoke(byte_no, interface, method,  // Get f1 klassOop, f2 Method*.
3632                  receiver, flags);
3633 
3634   // Z_R14 (== Z_bytecode) : return entry
3635 
3636   // First check for Object case, then private interface method,
3637   // then regular interface method.
3638 
3639   // Special case of invokeinterface called for virtual method of
3640   // java.lang.Object. See cpCache.cpp for details.
3641   NearLabel notObjectMethod, no_such_method;
3642   __ testbit(flags, ConstantPoolCacheEntry::is_forced_virtual_shift);
3643   __ z_brz(notObjectMethod);
3644   invokevirtual_helper(method, receiver, flags);
3645   __ bind(notObjectMethod);
3646 
3647   // Check for private method invocation - indicated by vfinal
3648   NearLabel notVFinal;
3649   __ testbit(flags, ConstantPoolCacheEntry::is_vfinal_shift);
3650   __ z_brz(notVFinal);
3651 
3652   // Get receiver klass into klass - also a null check.
3653   __ load_klass(klass, receiver);
3654 
3655   NearLabel subtype, no_such_interface;
3656 
3657   __ check_klass_subtype(klass, interface, Z_tmp_2, flags/*scratch*/, subtype);
3658   // If we get here the typecheck failed
3659   __ z_bru(no_such_interface);
3660   __ bind(subtype);
3661 
3662   // do the call
3663   __ profile_final_call(Z_tmp_2);
3664   __ profile_arguments_type(Z_tmp_2, method, Z_ARG5, true);
3665   __ jump_from_interpreted(method, Z_tmp_2);
3666 
3667   __ bind(notVFinal);
3668 
3669   // Get receiver klass into klass - also a null check.
3670   __ load_klass(klass, receiver);
3671 
3672   __ lookup_interface_method(klass, interface, noreg, noreg, /*temp*/Z_ARG1,
3673                              no_such_interface, /*return_method=*/false);
3674 
3675   // Profile this call.
3676   __ profile_virtual_call(klass, Z_ARG1/*mdp*/, flags/*scratch*/);
3677 
3678   // Find entry point to call.
3679 
3680   // Get declaring interface class from method
3681   __ load_method_holder(interface, method);
3682 
3683   // Get itable index from method
3684   Register index   = receiver,
3685            method2 = flags;
3686   __ z_lgf(index, Address(method, Method::itable_index_offset()));
3687   __ z_aghi(index, -Method::itable_index_max);
3688   __ z_lcgr(index, index);
3689 
3690   __ lookup_interface_method(klass, interface, index, method2, Z_tmp_2,
3691                              no_such_interface);
3692 
3693   // Check for abstract method error.
3694   // Note: This should be done more efficiently via a throw_abstract_method_error
3695   // interpreter entry point and a conditional jump to it in case of a null
3696   // method.
3697   __ compareU64_and_branch(method2, (intptr_t) 0,
3698                            Assembler::bcondZero, no_such_method);
3699 
3700   __ profile_arguments_type(Z_tmp_1, method2, Z_tmp_2, true);
3701 
3702   // Do the call.
3703   __ jump_from_interpreted(method2, Z_tmp_2);
3704   __ should_not_reach_here();
3705 
3706   // exception handling code follows...
3707   // Note: Must restore interpreter registers to canonical
3708   // state for exception handling to work correctly!
3709 
3710   __ bind(no_such_method);
3711 
3712   // Throw exception.
3713   // Pass arguments for generating a verbose error message.
3714   __ z_lgr(Z_tmp_1, method); // Prevent register clash.
3715   __ call_VM(noreg,
3716              CAST_FROM_FN_PTR(address,
3717                               InterpreterRuntime::throw_AbstractMethodErrorVerbose),
3718                               klass, Z_tmp_1);
3719   // The call_VM checks for exception, so we should never return here.
3720   __ should_not_reach_here();
3721 
3722   __ bind(no_such_interface);
3723 
3724   // Throw exception.
3725   // Pass arguments for generating a verbose error message.
3726   __ call_VM(noreg,
3727              CAST_FROM_FN_PTR(address,
3728                               InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose),
3729                               klass, interface);
3730   // The call_VM checks for exception, so we should never return here.
3731   __ should_not_reach_here();
3732 
3733   BLOCK_COMMENT(&quot;} invokeinterface&quot;);
3734   return;
3735 }
3736 
3737 void TemplateTable::invokehandle(int byte_no) {
3738   transition(vtos, vtos);
3739 
3740   const Register method = Z_tmp_2;
3741   const Register recv   = Z_ARG5;
3742   const Register mtype  = Z_tmp_1;
3743   prepare_invoke(byte_no,
3744                  method, mtype,   // Get f2 method, f1 MethodType.
3745                  recv);
3746   __ verify_method_ptr(method);
3747   __ verify_oop(recv);
3748   __ null_check(recv);
3749 
3750   // Note: Mtype is already pushed (if necessary) by prepare_invoke.
3751 
3752   // FIXME: profile the LambdaForm also.
3753   __ profile_final_call(Z_ARG2);
3754   __ profile_arguments_type(Z_ARG3, method, Z_ARG5, true);
3755 
3756   __ jump_from_interpreted(method, Z_ARG3);
3757 }
3758 
3759 void TemplateTable::invokedynamic(int byte_no) {
3760   transition(vtos, vtos);
3761 
3762   const Register Rmethod   = Z_tmp_2;
3763   const Register Rcallsite = Z_tmp_1;
3764 
3765   prepare_invoke(byte_no, Rmethod, Rcallsite);
3766 
3767   // Rmethod: CallSite object (from f1)
3768   // Rcallsite: MH.linkToCallSite method (from f2)
3769 
3770   // Note: Callsite is already pushed by prepare_invoke.
3771 
3772   // TODO: should make a type profile for any invokedynamic that takes a ref argument.
3773   // Profile this call.
3774   __ profile_call(Z_ARG2);
3775   __ profile_arguments_type(Z_ARG2, Rmethod, Z_ARG5, false);
3776   __ jump_from_interpreted(Rmethod, Z_ARG2);
3777 }
3778 
3779 //-----------------------------------------------------------------------------
3780 // Allocation
3781 
3782 // Original comment on &quot;allow_shared_alloc&quot;:
3783 // Always go the slow path.
3784 //  + Eliminated optimization within the template-based interpreter:
3785 //    If an allocation is done within the interpreter without using
3786 //    tlabs, the interpreter tries to do the allocation directly
3787 //    on the heap.
3788 //  + That means the profiling hooks are not considered and allocations
3789 //    get lost for the profiling framework.
3790 //  + However, we do not think that this optimization is really needed,
3791 //    so we always go now the slow path through the VM in this case --
3792 //    spec jbb2005 shows no measurable performance degradation.
3793 void TemplateTable::_new() {
3794   transition(vtos, atos);
3795   address prev_instr_address = NULL;
3796   Register tags  = Z_tmp_1;
3797   Register RallocatedObject   = Z_tos;
3798   Register cpool = Z_ARG2;
3799   Register tmp = Z_ARG3; // RobjectFields==tmp and Rsize==offset must be a register pair.
3800   Register offset = Z_ARG4;
3801   Label slow_case;
3802   Label done;
3803   Label initialize_header;
3804 
3805   BLOCK_COMMENT(&quot;TemplateTable::_new {&quot;);
3806   __ get_2_byte_integer_at_bcp(offset/*dest*/, 1, InterpreterMacroAssembler::Unsigned);
3807   __ get_cpool_and_tags(cpool, tags);
3808   // Make sure the class we&#39;re about to instantiate has been resolved.
3809   // This is done before loading InstanceKlass to be consistent with the order
3810   // how Constant Pool is updated (see ConstantPool::klass_at_put).
3811   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
3812   __ load_address(tmp, Address(tags, offset, tags_offset));
3813   __ z_cli(0, tmp, JVM_CONSTANT_Class);
3814   __ z_brne(slow_case);
3815 
3816   __ z_sllg(offset, offset, LogBytesPerWord); // Convert to to offset.
3817   // Get InstanceKlass.
3818   Register iklass = cpool;
3819   __ load_resolved_klass_at_offset(cpool, offset, iklass);
3820 
3821   // Make sure klass is initialized &amp; doesn&#39;t have finalizer.
3822   // Make sure klass is fully initialized.
3823   const int state_offset = in_bytes(InstanceKlass::init_state_offset());
3824   if (Immediate::is_uimm12(state_offset)) {
3825     __ z_cli(state_offset, iklass, InstanceKlass::fully_initialized);
3826   } else {
3827     __ z_cliy(state_offset, iklass, InstanceKlass::fully_initialized);
3828   }
3829   __ z_brne(slow_case);
3830 
3831   // Get instance_size in InstanceKlass (scaled to a count of bytes).
3832   Register Rsize = offset;
3833   const int mask = 1 &lt;&lt; Klass::_lh_instance_slow_path_bit;
3834   __ z_llgf(Rsize, Address(iklass, Klass::layout_helper_offset()));
3835   __ z_tmll(Rsize, mask);
3836   __ z_btrue(slow_case);
3837 
3838   // Allocate the instance
3839   // 1) Try to allocate in the TLAB.
3840   // 2) If the above fails (or is not applicable), go to a slow case
3841   // (creates a new TLAB, etc.).
3842   // Note: compared to other architectures, s390&#39;s implementation always goes
3843   // to the slow path if TLAB is used and fails.
3844   if (UseTLAB) {
3845     Register RoldTopValue = RallocatedObject;
3846     Register RnewTopValue = tmp;
3847     __ z_lg(RoldTopValue, Address(Z_thread, JavaThread::tlab_top_offset()));
3848     __ load_address(RnewTopValue, Address(RoldTopValue, Rsize));
3849     __ z_cg(RnewTopValue, Address(Z_thread, JavaThread::tlab_end_offset()));
3850     __ z_brh(slow_case);
3851     __ z_stg(RnewTopValue, Address(Z_thread, JavaThread::tlab_top_offset()));
3852 
3853     Register RobjectFields = tmp;
3854     Register Rzero = Z_R1_scratch;
3855     __ clear_reg(Rzero, true /*whole reg*/, false); // Load 0L into Rzero. Don&#39;t set CC.
3856 
3857     if (!ZeroTLAB) {
3858       // The object is initialized before the header. If the object size is
3859       // zero, go directly to the header initialization.
3860       __ z_aghi(Rsize, (int)-sizeof(oopDesc)); // Subtract header size, set CC.
3861       __ z_bre(initialize_header);             // Jump if size of fields is zero.
3862 
3863       // Initialize object fields.
3864       // See documentation for MVCLE instruction!!!
3865       assert(RobjectFields-&gt;encoding() % 2 == 0, &quot;RobjectFields must be an even register&quot;);
3866       assert(Rsize-&gt;encoding() == (RobjectFields-&gt;encoding()+1),
3867              &quot;RobjectFields and Rsize must be a register pair&quot;);
3868       assert(Rzero-&gt;encoding() % 2 == 1, &quot;Rzero must be an odd register&quot;);
3869 
3870       // Set Rzero to 0 and use it as src length, then mvcle will copy nothing
3871       // and fill the object with the padding value 0.
3872       __ add2reg(RobjectFields, sizeof(oopDesc), RallocatedObject);
3873       __ move_long_ext(RobjectFields, as_Register(Rzero-&gt;encoding() - 1), 0);
3874     }
3875 
3876     // Initialize object header only.
3877     __ bind(initialize_header);
3878     if (UseBiasedLocking) {
3879       Register prototype = RobjectFields;
3880       __ z_lg(prototype, Address(iklass, Klass::prototype_header_offset()));
3881       __ z_stg(prototype, Address(RallocatedObject, oopDesc::mark_offset_in_bytes()));
3882     } else {
3883       __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),
3884                      (long)markWord::prototype().value());
3885     }
3886 
3887     __ store_klass_gap(Rzero, RallocatedObject);  // Zero klass gap for compressed oops.
3888     __ store_klass(iklass, RallocatedObject);     // Store klass last.
3889 
3890     {
3891       SkipIfEqual skip(_masm, &amp;DTraceAllocProbes, false, Z_ARG5 /*scratch*/);
3892       // Trigger dtrace event for fastpath.
3893       __ push(atos); // Save the return value.
3894       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), RallocatedObject);
3895       __ pop(atos); // Restore the return value.
3896     }
3897     __ z_bru(done);
3898   }
3899 
3900   // slow case
3901   __ bind(slow_case);
3902   __ get_constant_pool(Z_ARG2);
3903   __ get_2_byte_integer_at_bcp(Z_ARG3/*dest*/, 1, InterpreterMacroAssembler::Unsigned);
3904   call_VM(Z_tos, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), Z_ARG2, Z_ARG3);
3905   __ verify_oop(Z_tos);
3906 
3907   // continue
3908   __ bind(done);
3909 
3910   BLOCK_COMMENT(&quot;} TemplateTable::_new&quot;);
3911 }
3912 
3913 void TemplateTable::newarray() {
3914   transition(itos, atos);
3915 
3916   // Call runtime.
3917   __ z_llgc(Z_ARG2, at_bcp(1));   // type
3918   __ z_lgfr(Z_ARG3, Z_tos);       // size
3919   call_VM(Z_RET,
3920           CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
3921           Z_ARG2, Z_ARG3);
3922 }
3923 
3924 void TemplateTable::anewarray() {
3925   transition(itos, atos);
3926   __ get_2_byte_integer_at_bcp(Z_ARG3, 1, InterpreterMacroAssembler::Unsigned);
3927   __ get_constant_pool(Z_ARG2);
3928   __ z_lgfr(Z_ARG4, Z_tos);
3929   call_VM(Z_tos, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
3930           Z_ARG2, Z_ARG3, Z_ARG4);
3931 }
3932 
3933 void TemplateTable::arraylength() {
3934   transition(atos, itos);
3935 
3936   int offset = arrayOopDesc::length_offset_in_bytes();
3937 
3938   __ null_check(Z_tos, Z_R0_scratch, offset);
3939   __ mem2reg_opt(Z_tos, Address(Z_tos, offset), false);
3940 }
3941 
3942 void TemplateTable::checkcast() {
3943   transition(atos, atos);
3944 
3945   NearLabel done, is_null, ok_is_subtype, quicked, resolved;
3946 
3947   BLOCK_COMMENT(&quot;checkcast {&quot;);
3948   // If object is NULL, we are almost done.
3949   __ compareU64_and_branch(Z_tos, (intptr_t) 0, Assembler::bcondZero, is_null);
3950 
3951   // Get cpool &amp; tags index.
3952   Register cpool = Z_tmp_1;
3953   Register tags = Z_tmp_2;
3954   Register index = Z_ARG5;
3955 
3956   __ get_cpool_and_tags(cpool, tags);
3957   __ get_2_byte_integer_at_bcp(index, 1, InterpreterMacroAssembler::Unsigned);
3958   // See if bytecode has already been quicked.
3959   // Note: For CLI, we would have to add the index to the tags pointer first,
3960   // thus load and compare in a &quot;classic&quot; manner.
3961   __ z_llgc(Z_R0_scratch,
3962             Address(tags, index, Array&lt;u1&gt;::base_offset_in_bytes()));
3963   __ compareU64_and_branch(Z_R0_scratch, JVM_CONSTANT_Class,
3964                            Assembler::bcondEqual, quicked);
3965 
3966   __ push(atos); // Save receiver for result, and for GC.
3967   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
3968   __ get_vm_result_2(Z_tos);
3969 
3970   Register   receiver = Z_ARG4;
3971   Register   klass = Z_tos;
3972   Register   subklass = Z_ARG5;
3973 
3974   __ pop_ptr(receiver); // restore receiver
3975   __ z_bru(resolved);
3976 
3977   // Get superklass in klass and subklass in subklass.
3978   __ bind(quicked);
3979 
3980   __ z_lgr(Z_ARG4, Z_tos);  // Save receiver.
3981   __ z_sllg(index, index, LogBytesPerWord);  // index2bytes for addressing
3982   __ load_resolved_klass_at_offset(cpool, index, klass);
3983 
3984   __ bind(resolved);
3985 
3986   __ load_klass(subklass, receiver);
3987 
3988   // Generate subtype check. Object in receiver.
3989   // Superklass in klass. Subklass in subklass.
3990   __ gen_subtype_check(subklass, klass, Z_ARG3, Z_tmp_1, ok_is_subtype);
3991 
3992   // Come here on failure.
3993   __ push_ptr(receiver);
3994   // Object is at TOS, target klass oop expected in rax by convention.
3995   __ z_brul((address) Interpreter::_throw_ClassCastException_entry);
3996 
3997   // Come here on success.
3998   __ bind(ok_is_subtype);
3999 
4000   __ z_lgr(Z_tos, receiver); // Restore object.
4001 
4002   // Collect counts on whether this test sees NULLs a lot or not.
4003   if (ProfileInterpreter) {
4004     __ z_bru(done);
4005     __ bind(is_null);
4006     __ profile_null_seen(Z_tmp_1);
4007   } else {
4008     __ bind(is_null);   // Same as &#39;done&#39;.
4009   }
4010 
4011   __ bind(done);
4012   BLOCK_COMMENT(&quot;} checkcast&quot;);
4013 }
4014 
4015 void TemplateTable::instanceof() {
4016   transition(atos, itos);
4017 
4018   NearLabel done, is_null, ok_is_subtype, quicked, resolved;
4019 
4020   BLOCK_COMMENT(&quot;instanceof {&quot;);
4021   // If object is NULL, we are almost done.
4022   __ compareU64_and_branch(Z_tos, (intptr_t) 0, Assembler::bcondZero, is_null);
4023 
4024   // Get cpool &amp; tags index.
4025   Register cpool = Z_tmp_1;
4026   Register tags = Z_tmp_2;
4027   Register index = Z_ARG5;
4028 
4029   __ get_cpool_and_tags(cpool, tags);
4030   __ get_2_byte_integer_at_bcp(index, 1, InterpreterMacroAssembler::Unsigned);
4031   // See if bytecode has already been quicked.
4032   // Note: For CLI, we would have to add the index to the tags pointer first,
4033   // thus load and compare in a &quot;classic&quot; manner.
4034   __ z_llgc(Z_R0_scratch,
4035             Address(tags, index, Array&lt;u1&gt;::base_offset_in_bytes()));
4036   __ compareU64_and_branch(Z_R0_scratch, JVM_CONSTANT_Class, Assembler::bcondEqual, quicked);
4037 
4038   __ push(atos); // Save receiver for result, and for GC.
4039   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4040   __ get_vm_result_2(Z_tos);
4041 
4042   Register receiver = Z_tmp_2;
4043   Register klass = Z_tos;
4044   Register subklass = Z_tmp_2;
4045 
4046   __ pop_ptr(receiver); // Restore receiver.
4047   __ verify_oop(receiver);
4048   __ load_klass(subklass, subklass);
4049   __ z_bru(resolved);
4050 
4051   // Get superklass in klass and subklass in subklass.
4052   __ bind(quicked);
4053 
4054   __ load_klass(subklass, Z_tos);
4055   __ z_sllg(index, index, LogBytesPerWord);  // index2bytes for addressing
4056   __ load_resolved_klass_at_offset(cpool, index, klass);
4057 
4058   __ bind(resolved);
4059 
4060   // Generate subtype check.
4061   // Superklass in klass. Subklass in subklass.
4062   __ gen_subtype_check(subklass, klass, Z_ARG4, Z_ARG5, ok_is_subtype);
4063 
4064   // Come here on failure.
4065   __ clear_reg(Z_tos, true, false);
4066   __ z_bru(done);
4067 
4068   // Come here on success.
4069   __ bind(ok_is_subtype);
4070   __ load_const_optimized(Z_tos, 1);
4071 
4072   // Collect counts on whether this test sees NULLs a lot or not.
4073   if (ProfileInterpreter) {
4074     __ z_bru(done);
4075     __ bind(is_null);
4076     __ profile_null_seen(Z_tmp_1);
4077   } else {
4078     __ bind(is_null);   // same as &#39;done&#39;
4079   }
4080 
4081   __ bind(done);
4082   // tos = 0: obj == NULL or  obj is not an instanceof the specified klass
4083   // tos = 1: obj != NULL and obj is     an instanceof the specified klass
4084   BLOCK_COMMENT(&quot;} instanceof&quot;);
4085 }
4086 
4087 //-----------------------------------------------------------------------------
4088 // Breakpoints
4089 void TemplateTable::_breakpoint() {
4090 
4091   // Note: We get here even if we are single stepping.
4092   // Jbug insists on setting breakpoints at every bytecode
4093   // even if we are in single step mode.
4094 
4095   transition(vtos, vtos);
4096 
4097   // Get the unpatched byte code.
4098   __ get_method(Z_ARG2);
4099   __ call_VM(noreg,
4100              CAST_FROM_FN_PTR(address, InterpreterRuntime::get_original_bytecode_at),
4101              Z_ARG2, Z_bcp);
4102   // Save the result to a register that is preserved over C-function calls.
4103   __ z_lgr(Z_tmp_1, Z_RET);
4104 
4105   // Post the breakpoint event.
4106   __ get_method(Z_ARG2);
4107   __ call_VM(noreg,
4108              CAST_FROM_FN_PTR(address, InterpreterRuntime::_breakpoint),
4109              Z_ARG2, Z_bcp);
4110 
4111   // Must restore the bytecode, because call_VM destroys Z_bytecode.
4112   __ z_lgr(Z_bytecode, Z_tmp_1);
4113 
4114   // Complete the execution of original bytecode.
4115   __ dispatch_only_normal(vtos);
4116 }
4117 
4118 
4119 // Exceptions
4120 
4121 void TemplateTable::athrow() {
4122   transition(atos, vtos);
4123   __ null_check(Z_tos);
4124   __ load_absolute_address(Z_ARG2, Interpreter::throw_exception_entry());
4125   __ z_br(Z_ARG2);
4126 }
4127 
4128 // Synchronization
4129 //
4130 // Note: monitorenter &amp; exit are symmetric routines; which is reflected
4131 //       in the assembly code structure as well
4132 //
4133 // Stack layout:
4134 //
4135 //               callers_sp        &lt;- Z_SP (callers_sp == Z_fp (own fp))
4136 //               return_pc
4137 //               [rest of ABI_160]
4138 //              /slot o:   free
4139 //             / ...       free
4140 //       oper. | slot n+1: free    &lt;- Z_esp points to first free slot
4141 //       stack | slot n:   val                      caches IJAVA_STATE.esp
4142 //             | ...
4143 //              \slot 0:   val
4144 //              /slot m            &lt;- IJAVA_STATE.monitors = monitor block top
4145 //             | ...
4146 //     monitors| slot 2
4147 //             | slot 1
4148 //              \slot 0
4149 //              /slot l            &lt;- monitor block bot
4150 // ijava_state | ...
4151 //             | slot 2
4152 //              \slot 0
4153 //                                 &lt;- Z_fp
4154 void TemplateTable::monitorenter() {
4155   transition(atos, vtos);
4156 
4157   BLOCK_COMMENT(&quot;monitorenter {&quot;);
4158 
4159   // Check for NULL object.
4160   __ null_check(Z_tos);
4161   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4162   NearLabel allocated;
4163   // Initialize entry pointer.
4164   const Register Rfree_slot = Z_tmp_1;
4165   __ clear_reg(Rfree_slot, true, false); // Points to free slot or NULL. Don&#39;t set CC.
4166 
4167   // Find a free slot in the monitor block from top to bot (result in Rfree_slot).
4168   {
4169     const Register Rcurr_monitor = Z_ARG2;
4170     const Register Rbot = Z_ARG3; // Points to word under bottom of monitor block.
4171     const Register Rlocked_obj = Z_ARG4;
4172     NearLabel loop, exit, not_free;
4173     // Starting with top-most entry.
4174     __ get_monitors(Rcurr_monitor); // Rcur_monitor = IJAVA_STATE.monitors
4175     __ add2reg(Rbot, -frame::z_ijava_state_size, Z_fp);
4176 
4177 #ifdef ASSERT
4178     address reentry = NULL;
4179     { NearLabel ok;
4180       __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondNotHigh, ok);
4181       reentry = __ stop_chain_static(reentry, &quot;IJAVA_STATE.monitors points below monitor block bottom&quot;);
4182       __ bind(ok);
4183     }
4184     { NearLabel ok;
4185       __ compareU64_and_branch(Rcurr_monitor, Z_esp, Assembler::bcondHigh, ok);
4186       reentry = __ stop_chain_static(reentry, &quot;IJAVA_STATE.monitors above Z_esp&quot;);
4187       __ bind(ok);
4188     }
4189 #endif
4190 
4191     // Check if bottom reached, i.e. if there is at least one monitor.
4192     __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondEqual, exit);
4193 
4194     __ bind(loop);
4195     // Check if current entry is used.
4196     __ load_and_test_long(Rlocked_obj, Address(Rcurr_monitor, BasicObjectLock::obj_offset_in_bytes()));
4197     __ z_brne(not_free);
4198     // If not used then remember entry in Rfree_slot.
4199     __ z_lgr(Rfree_slot, Rcurr_monitor);
4200     __ bind(not_free);
4201     // Exit if current entry is for same object; this guarantees, that new monitor
4202     // used for recursive lock is above the older one.
4203     __ compareU64_and_branch(Rlocked_obj, Z_tos, Assembler::bcondEqual, exit);
4204     // otherwise advance to next entry
4205     __ add2reg(Rcurr_monitor, entry_size);
4206     // Check if bottom reached, if not at bottom then check this entry.
4207     __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondNotEqual, loop);
4208     __ bind(exit);
4209   }
4210 
4211   // Rfree_slot != NULL -&gt; found one
4212   __ compareU64_and_branch(Rfree_slot, (intptr_t)0L, Assembler::bcondNotEqual, allocated);
4213 
4214   // Allocate one if there&#39;s no free slot.
4215   __ add_monitor_to_stack(false, Z_ARG3, Z_ARG4, Z_ARG5);
4216   __ get_monitors(Rfree_slot);
4217 
4218   // Rfree_slot: points to monitor entry.
4219   __ bind(allocated);
4220 
4221   // Increment bcp to point to the next bytecode, so exception
4222   // handling for async. exceptions work correctly.
4223   // The object has already been poped from the stack, so the
4224   // expression stack looks correct.
4225   __ add2reg(Z_bcp, 1, Z_bcp);
4226 
4227   // Store object.
4228   __ z_stg(Z_tos, BasicObjectLock::obj_offset_in_bytes(), Rfree_slot);
4229   __ lock_object(Rfree_slot, Z_tos);
4230 
4231   // Check to make sure this monitor doesn&#39;t cause stack overflow after locking.
4232   __ save_bcp();  // in case of exception
4233   __ generate_stack_overflow_check(0);
4234 
4235   // The bcp has already been incremented. Just need to dispatch to
4236   // next instruction.
4237   __ dispatch_next(vtos);
4238 
4239   BLOCK_COMMENT(&quot;} monitorenter&quot;);
4240 }
4241 
4242 
4243 void TemplateTable::monitorexit() {
4244   transition(atos, vtos);
4245 
4246   BLOCK_COMMENT(&quot;monitorexit {&quot;);
4247 
4248   // Check for NULL object.
4249   __ null_check(Z_tos);
4250 
4251   NearLabel found, not_found;
4252   const Register Rcurr_monitor = Z_ARG2;
4253 
4254   // Find matching slot.
4255   {
4256     const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4257     NearLabel entry, loop;
4258 
4259     const Register Rbot = Z_ARG3; // Points to word under bottom of monitor block.
4260     const Register Rlocked_obj = Z_ARG4;
4261     // Starting with top-most entry.
4262     __ get_monitors(Rcurr_monitor); // Rcur_monitor = IJAVA_STATE.monitors
4263     __ add2reg(Rbot, -frame::z_ijava_state_size, Z_fp);
4264 
4265 #ifdef ASSERT
4266     address reentry = NULL;
4267     { NearLabel ok;
4268       __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondNotHigh, ok);
4269       reentry = __ stop_chain_static(reentry, &quot;IJAVA_STATE.monitors points below monitor block bottom&quot;);
4270       __ bind(ok);
4271     }
4272     { NearLabel ok;
4273       __ compareU64_and_branch(Rcurr_monitor, Z_esp, Assembler::bcondHigh, ok);
4274       reentry = __ stop_chain_static(reentry, &quot;IJAVA_STATE.monitors above Z_esp&quot;);
4275       __ bind(ok);
4276     }
4277 #endif
4278 
4279     // Check if bottom reached, i.e. if there is at least one monitor.
4280     __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondEqual, not_found);
4281 
4282     __ bind(loop);
4283     // Check if current entry is for same object.
4284     __ z_lg(Rlocked_obj, Address(Rcurr_monitor, BasicObjectLock::obj_offset_in_bytes()));
4285     // If same object then stop searching.
4286     __ compareU64_and_branch(Rlocked_obj, Z_tos, Assembler::bcondEqual, found);
4287     // Otherwise advance to next entry.
4288     __ add2reg(Rcurr_monitor, entry_size);
4289     // Check if bottom reached, if not at bottom then check this entry.
4290     __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondNotEqual, loop);
4291   }
4292 
4293   __ bind(not_found);
4294   // Error handling. Unlocking was not block-structured.
4295   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
4296                    InterpreterRuntime::throw_illegal_monitor_state_exception));
4297   __ should_not_reach_here();
4298 
4299   __ bind(found);
4300   __ push_ptr(Z_tos); // Make sure object is on stack (contract with oopMaps).
4301   __ unlock_object(Rcurr_monitor, Z_tos);
4302   __ pop_ptr(Z_tos); // Discard object.
4303   BLOCK_COMMENT(&quot;} monitorexit&quot;);
4304 }
4305 
4306 // Wide instructions
4307 void TemplateTable::wide() {
4308   transition(vtos, vtos);
4309 
4310   __ z_llgc(Z_R1_scratch, at_bcp(1));
4311   __ z_sllg(Z_R1_scratch, Z_R1_scratch, LogBytesPerWord);
4312   __ load_absolute_address(Z_tmp_1, (address) Interpreter::_wentry_point);
4313   __ mem2reg_opt(Z_tmp_1, Address(Z_tmp_1, Z_R1_scratch));
4314   __ z_br(Z_tmp_1);
4315   // Note: the bcp increment step is part of the individual wide
4316   // bytecode implementations.
4317 }
4318 
4319 // Multi arrays
4320 void TemplateTable::multianewarray() {
4321   transition(vtos, atos);
4322 
4323   __ z_llgc(Z_tmp_1, at_bcp(3)); // Get number of dimensions.
4324   // Slot count to byte offset.
4325   __ z_sllg(Z_tmp_1, Z_tmp_1, Interpreter::logStackElementSize);
4326   // Z_esp points past last_dim, so set to Z_ARG2 to first_dim address.
4327   __ load_address(Z_ARG2, Address(Z_esp, Z_tmp_1));
4328   call_VM(Z_RET,
4329           CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray),
4330           Z_ARG2);
4331   // Pop dimensions from expression stack.
4332   __ z_agr(Z_esp, Z_tmp_1);
4333 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>